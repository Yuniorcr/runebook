<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="5d1928864135bba9ca1e5db7c9ed5c9e48fe306d" translate="yes" xml:space="preserve">
          <source>Indicates if process information is to be collected. If &lt;code&gt;PI = true&lt;/code&gt; (which is default), each process identifier &lt;code&gt;Pid&lt;/code&gt; is replaced by a tuple &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt;, where &lt;code&gt;ProcessInfo&lt;/code&gt; is the registered process name, its globally registered name, or its initial function. To turn off this functionality, set &lt;code&gt;PI = false&lt;/code&gt;.</source>
          <target state="translated">프로세스 정보를 수집할지 여부를 나타냅니다. 경우 &lt;code&gt;PI = true&lt;/code&gt; (기본이되는), 식별자 각 공정 &lt;code&gt;Pid&lt;/code&gt; 튜플로 대체 &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt; , &lt;code&gt;ProcessInfo&lt;/code&gt; 는 등록 프로세스 명, 그 전역 등록 된 이름, 또는 초기 기능. 이 기능을 끄려면 &lt;code&gt;PI = false&lt;/code&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b164f888f879044385341ec2797d6c82e6c4e946" translate="yes" xml:space="preserve">
          <source>Indicates if the table is compressed.</source>
          <target state="translated">테이블이 압축되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04ae54ea063d09f2c3664e4b4c23adf6f54a8c52" translate="yes" xml:space="preserve">
          <source>Indicates if the table is fixed by any process.</source>
          <target state="translated">프로세스가 테이블을 수정했는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa89b00792f2ce063403297cd8b1e138fe770604" translate="yes" xml:space="preserve">
          <source>Indicates if the table is named.</source>
          <target state="translated">테이블의 이름이 지정되었는지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf35be555e3459fa6b5edfb9108dbeacc82f59eb" translate="yes" xml:space="preserve">
          <source>Indicates in which phase the child terminated from the supervisor's point of view. This can be &lt;code&gt;start_error&lt;/code&gt;, &lt;code&gt;child_terminated&lt;/code&gt;, or &lt;code&gt;shutdown_error&lt;/code&gt;.</source>
          <target state="translated">자녀가 감독자의 관점에서 종료 된 단계를 나타냅니다. &lt;code&gt;start_error&lt;/code&gt; , &lt;code&gt;child_terminated&lt;/code&gt; 또는 &lt;code&gt;shutdown_error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe81303e088259aab453750cd52960b57072562a" translate="yes" xml:space="preserve">
          <source>Indicates that all modules that &lt;strong&gt;must&lt;/strong&gt; be loaded &lt;strong&gt;before&lt;/strong&gt; any processes are started are loaded. In interactive mode, all &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; commands interpreted after this command are ignored, and these modules are loaded on demand. In embedded mode, &lt;code&gt;kernel_load_completed&lt;/code&gt; is ignored, and all modules are loaded during system start.</source>
          <target state="translated">프로세스를 시작 &lt;strong&gt;하기 전에&lt;/strong&gt; 로드 &lt;strong&gt;해야하는&lt;/strong&gt; 모든 모듈이 로드 되었음을 나타냅니다 . 대화식 모드 에서이 명령 이후에 해석 된 모든 &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; 명령은 무시되며 이러한 모듈은 요청시로드됩니다. 내장 모드에서는 &lt;code&gt;kernel_load_completed&lt;/code&gt; 가 무시되고 시스템 시작 중에 모든 모듈이로드됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f9048661a24ae25a077ce5abbcac108d3320208" translate="yes" xml:space="preserve">
          <source>Indicates that an ordinary send operation has occurred. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient (the C-node).</source>
          <target state="translated">일반 전송 작업이 발생했음을 나타냅니다. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 수신자 (C-node)의 pid 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cbcba1ae27045d37f3db86e74369cc4a7aceb7a1" translate="yes" xml:space="preserve">
          <source>Indicates that no more data is to be sent.</source>
          <target state="translated">더 이상 데이터가 전송되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8bf849b9fec9e1760cea1c2d5389817b3c0bc05b" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;ssh_client_channel&lt;/code&gt; started for the execution of the command has now been shut down.</source>
          <target state="translated">명령 실행을 위해 시작된 &lt;code&gt;ssh_client_channel&lt;/code&gt; 이 이제 종료되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a5828edbce1099ee1930a44aab4d8fd37ec11d89" translate="yes" xml:space="preserve">
          <source>Indicates that the client is to try to perform Next Protocol Negotiation.</source>
          <target state="translated">클라이언트가 Next Protocol Negotiation을 수행하려고 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b5dd8bc7ce080d99125903fe8b90315e92ea02c" translate="yes" xml:space="preserve">
          <source>Indicates that the function must return if the Telnet client is idle (that is, if no data is received) for more than &lt;code&gt;IdleTimeout&lt;/code&gt; milliseconds. Default time-out is 10 seconds.</source>
          <target state="translated">Telnet 클라이언트가 유휴 상태 (즉, 데이터가 수신되지 않은 경우)보다 &lt;code&gt;IdleTimeout&lt;/code&gt; 밀리 초 이상 동안 함수가 리턴해야 함을 나타냅니다 . 기본 시간 제한은 10 초입니다.</target>
        </trans-unit>
        <trans-unit id="9e67f2121ae2256f3ebfae7320f2bc6126d35396" translate="yes" xml:space="preserve">
          <source>Indicates that the logs are not to be merged according to time-stamp, but processed one file after another (this can be a bit faster).</source>
          <target state="translated">로그가 타임 스탬프에 따라 병합되지 않고 파일마다 하나씩 처리됨을 나타냅니다 (조금 더 빠를 수 있음).</target>
        </trans-unit>
        <trans-unit id="1ab33322e5998509567ec1f06a0e97917a03dfe6" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt; ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상대방이 더 이상 데이터를 보내지 않음을 나타냅니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt; ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt; 호출의 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9a42fd50ec01a86c14c261f603beda5c60f5a57" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상대방이 더 이상 데이터를 보내지 않음을 나타냅니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed8b1ea4428cfedc7e1254d4ff25775923613c69" translate="yes" xml:space="preserve">
          <source>Indicates that the trace is to be automatically stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds. &lt;code&gt;StopOpts&lt;/code&gt; are passed to command &lt;code&gt;ttb:stop/2&lt;/code&gt; if specified (default is &lt;code&gt;[]&lt;/code&gt;). Notice that the timing is approximate, as delays related to network communication are always present. The timer starts after &lt;code&gt;ttb:p/2&lt;/code&gt; is issued, so you can set up your trace patterns before.</source>
          <target state="translated">&lt;code&gt;MSec&lt;/code&gt; 밀리 초 후에 추적이 자동으로 중지됨을 나타냅니다 . &lt;code&gt;StopOpts&lt;/code&gt; 는 지정된 경우 명령 &lt;code&gt;ttb:stop/2&lt;/code&gt; 에 전달 됩니다 (기본값은 &lt;code&gt;[]&lt;/code&gt; ). 네트워크 통신과 관련된 지연이 항상 존재하므로 타이밍은 대략적인 것입니다. &lt;code&gt;ttb:p/2&lt;/code&gt; 가 실행 된 후 타이머가 시작 되므로 추적 패턴을 미리 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9cf951fb07996703ea5f15911991b7ead2c767" translate="yes" xml:space="preserve">
          <source>Indicates that there is sufficient input data to get a result. &lt;code&gt;Result&lt;/code&gt; is:</source>
          <target state="translated">결과를 얻기에 충분한 입력 데이터가 있음을 나타냅니다. &lt;code&gt;Result&lt;/code&gt; 는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="ce31dc16108b768360d358241497a298269b4a82" translate="yes" xml:space="preserve">
          <source>Indicates that this call removed the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; from the driver, but there are still open ports using it. When all ports are closed and no new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have arrived, the driver is reloaded and the name and memory reclaimed.</source>
          <target state="translated">이 호출이 드라이버에서 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 를 제거 했지만 여전히 사용중인 열린 포트가 있음을 나타냅니다 . 모든 포트가 닫히고 새로운 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 도착 하지 않으면 드라이버가 다시로드되고 이름과 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="9d25290abdf2e0ca7cc841bfb568813355a0802e" translate="yes" xml:space="preserve">
          <source>Indicates that trace logs are not to be collected after tracing is stopped.</source>
          <target state="translated">추적이 중지 된 후 추적 로그가 수집되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a7ce5c93e6670b3ab25a70739bf3a2b64bf5289d" translate="yes" xml:space="preserve">
          <source>Indicates that trace messages are to be printed on the console as they are received by the tracing process. This implies trace client &lt;code&gt;{local, File}&lt;/code&gt;. If &lt;code&gt;ShellSpec&lt;/code&gt; is &lt;code&gt;only&lt;/code&gt; (instead of &lt;code&gt;true&lt;/code&gt;), no trace logs are stored.</source>
          <target state="translated">추적 메시지가 추적 프로세스에 수신 될 때 콘솔에 추적 메시지가 인쇄됨을 나타냅니다. 이는 추적 클라이언트 &lt;code&gt;{local, File}&lt;/code&gt; 의미합니다 . &lt;code&gt;ShellSpec&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 가 아닌 &lt;code&gt;only&lt;/code&gt; 경우 에는 추적 로그가 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca4adbf68227389dc62c330e8e9bac1501e4b85b" translate="yes" xml:space="preserve">
          <source>Indicates the file owner. Ignored for non-Unix file systems.</source>
          <target state="translated">파일 소유자를 나타냅니다. 비 유닉스 파일 시스템에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c68113f254ba2ea7ffc965f78681100985873d3" translate="yes" xml:space="preserve">
          <source>Indicates the inets version.</source>
          <target state="translated">inets 버전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="224497035660eaa0bff9029bd6c2cd2438d9b394" translate="yes" xml:space="preserve">
          <source>Indicates the owner of the file. On non-Unix file systems, this field is zero.</source>
          <target state="translated">파일의 소유자를 나타냅니다. 비 유닉스 파일 시스템에서이 필드는 0입니다.</target>
        </trans-unit>
        <trans-unit id="b47cb315e9dabaf8faae72ffb461cea7bba28766" translate="yes" xml:space="preserve">
          <source>Indicates the return value to be &lt;code&gt;{stopped, Dir}&lt;/code&gt; and not just &lt;code&gt;stopped&lt;/code&gt;. This implies &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">리턴 값이 &lt;code&gt;{stopped, Dir}&lt;/code&gt; 이고 &lt;code&gt;stopped&lt;/code&gt; 되지 않은 것을 나타냅니다 . 이것은 &lt;code&gt;fetch&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d35b2e4ff0ddad33a5641c5c7f2c271f941aca60" translate="yes" xml:space="preserve">
          <source>Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">서버가 ALPN (Application-Layer Protocol Negotiation)을 수행하려고 시도 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f3f315fb532a3b7264bb002ee89acdb0f4afc9e0" translate="yes" xml:space="preserve">
          <source>Indicates the trace logs to be formatted after tracing is stopped. All logs in the fetch directory are merged.</source>
          <target state="translated">추적이 중지 된 후 형식화 될 추적 로그를 나타냅니다. 페치 디렉토리의 모든 로그가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="c9caeef1a9bf6a4c1f663bd7540e3e604062a5c1" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;decentralized_counters&lt;/code&gt;.</source>
          <target state="translated">테이블이 &lt;code&gt;decentralized_counters&lt;/code&gt; 를 사용하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3d7885720efb295da36f8958002ab554f813fd40" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;read_concurrency&lt;/code&gt; or not.</source>
          <target state="translated">테이블이 &lt;code&gt;read_concurrency&lt;/code&gt; 를 사용하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0f194418909ecb0776bfd3596100881c33eff9da" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;write_concurrency&lt;/code&gt;.</source>
          <target state="translated">테이블이 &lt;code&gt;write_concurrency&lt;/code&gt; 를 사용하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1e0e5bf9d20bf47d959fe201139325627c2f3941" translate="yes" xml:space="preserve">
          <source>Indicates which stream of event is of interest. If not present, events in the default NETCONF stream are sent.</source>
          <target state="translated">관심있는 이벤트 스트림을 나타냅니다. 존재하지 않는 경우 기본 NETCONF 스트림의 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d333b1897ab1d5bb5a70973c07335347937ec466" translate="yes" xml:space="preserve">
          <source>Indicates which subset of all possible events is of interest. The parameter format is the same as that of the filter parameter in the NETCONF protocol operations. If not present, all events not precluded by other parameters are sent.</source>
          <target state="translated">가능한 모든 이벤트 중 관심있는 부분 집합을 나타냅니다. 매개 변수 형식은 NETCONF 프로토콜 작업의 필터 매개 변수 형식과 동일합니다. 존재하지 않으면 다른 매개 변수에 의해 제외되지 않은 모든 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="69bd50ab548b8102cd9a1fe6230c53d33f12b9be" translate="yes" xml:space="preserve">
          <source>Indication of whether or not capabilities exchange has selected inband security using TLS. &lt;code&gt;Ref&lt;/code&gt; is a reference() that must be included in the &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; reply message to the transport's parent process (see below). &lt;code&gt;Type&lt;/code&gt; is either &lt;code&gt;connect&lt;/code&gt; or &lt;code&gt;accept&lt;/code&gt; depending on whether the process has been started for a connecting or listening transport respectively. &lt;code&gt;Bool&lt;/code&gt; is a boolean() indicating whether or not the transport connection should be upgraded to TLS.</source>
          <target state="translated">기능 교환이 TLS를 사용하여 대역 내 보안을 선택했는지 여부를 나타냅니다. &lt;code&gt;Ref&lt;/code&gt; 는 전송의 부모 프로세스 에 대한 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 응답 메시지에 포함되어야하는 reference ()입니다 (아래 참조). &lt;code&gt;Type&lt;/code&gt; 은 연결 또는 청취 전송에 대해 프로세스가 각각 시작되었는지에 따라 &lt;code&gt;connect&lt;/code&gt; 또는 &lt;code&gt;accept&lt;/code&gt; 입니다. &lt;code&gt;Bool&lt;/code&gt; 은 전송 연결을 TLS로 업그레이드해야하는지 여부를 나타내는 boolean ()입니다.</target>
        </trans-unit>
        <trans-unit id="05533a98ca1eac044b0fade678b3259891f47860" translate="yes" xml:space="preserve">
          <source>Individual patterns are represented as follows:</source>
          <target state="translated">개별 패턴은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="62fba71f7f99e1c8a7d2339ef9441f9378f3f692" translate="yes" xml:space="preserve">
          <source>Inferring Session Termination from Origin-State-Id</source>
          <target state="translated">Origin-State-Id에서 세션 종료 유추</target>
        </trans-unit>
        <trans-unit id="312cf7f9e08930449da2f3a70ec59de01578d97a" translate="yes" xml:space="preserve">
          <source>Infinite Lists</source>
          <target state="translated">무한 목록</target>
        </trans-unit>
        <trans-unit id="68f6c014d38a2a4ded13ed708fa02ce23813c010" translate="yes" xml:space="preserve">
          <source>Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:</source>
          <target state="translated">무한 루프는 예를 들어 상한이없는 수량 자와 문자를 일치시킬 수없는 하위 패턴을 따라 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e575fea98a15d988a12ed46eab26f00dd0e764af" translate="yes" xml:space="preserve">
          <source>InfoTupleList | InfoTuple</source>
          <target state="translated">InfoTupleList | InfoTuple</target>
        </trans-unit>
        <trans-unit id="d6e649f7899e661682dcf40da83dd77a934e9978" translate="yes" xml:space="preserve">
          <source>InfoTupleList | InfoTuple | {error, bad_daemon_ref}</source>
          <target state="translated">InfoTupleList | InfoTuple | {오류, bad_daemon_ref}</target>
        </trans-unit>
        <trans-unit id="3da4edd9211b1f0de62eb4b59bb0f4a07f35071f" translate="yes" xml:space="preserve">
          <source>Inform about delivery result.</source>
          <target state="translated">배송 결과를 알려주세요.</target>
        </trans-unit>
        <trans-unit id="bfcd17ecc49f5239dbbb19b14b0dc7ca6b6bf5ec" translate="yes" xml:space="preserve">
          <source>Inform about file descriptor used by the socket which is identified by &lt;code&gt;ctx&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 로 식별되는 소켓에서 사용하는 파일 설명자에 대해 알립니다 .</target>
        </trans-unit>
        <trans-unit id="46f033a38b61d37b7919f393716c730267413513" translate="yes" xml:space="preserve">
          <source>Inform about handshake packet header size to use during the Erlang distribution handshake.</source>
          <target state="translated">Erlang 배포 핸드 셰이크 중에 사용할 핸드 셰이크 패킷 헤더 크기에 대해 알립니다.</target>
        </trans-unit>
        <trans-unit id="2957467750434af57077099e35ef2ac6165d01aa" translate="yes" xml:space="preserve">
          <source>Inform about target addresses.</source>
          <target state="translated">대상 주소를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="90049cac09e82499ae5c45699662d377e2e83121" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=accept&lt;/code&gt; has established a connection with the peer. Not sent if the transport process has &lt;code&gt;Type=connect&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=accept&lt;/code&gt; 인 전송 프로세스가 피어와 연결을 설정 했음을 부모에게 알리십시오 . 전송 프로세스에 &lt;code&gt;Type=connect&lt;/code&gt; 가 있으면 전송되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0a5e762b03951002c7550ea2ef3353a81e74fc7" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=connect&lt;/code&gt; has established a connection with a peer. Not sent if the transport process has &lt;code&gt;Type=accept&lt;/code&gt;. &lt;code&gt;Remote&lt;/code&gt; is an arbitrary term that uniquely identifies the remote endpoint to which the transport has connected. A &lt;code&gt;LocalAddr&lt;/code&gt; list has the same semantics as one returned from &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=connect&lt;/code&gt; 인 전송 프로세스가 피어와 연결 을 설정 했음을 부모에게 알리십시오 . 전송 프로세스에 &lt;code&gt;Type=accept&lt;/code&gt; 가 있으면 전송되지 않습니다 . &lt;code&gt;Remote&lt;/code&gt; 는 전송이 연결된 리모트 엔드 포인트를 고유하게 식별하는 임의의 용어입니다. &lt;code&gt;LocalAddr&lt;/code&gt; 의 리스트로부터 리턴 된 것과 동일한 의미를 가지고 &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2447fae055d21e07237d4cd9806f0d1e44fef23" translate="yes" xml:space="preserve">
          <source>Informally, an I/O list is a deep list of characters and binaries that can be sent to an Erlang port. In BNF, an I/O list is formally defined as follows:</source>
          <target state="translated">비공식적으로 I / O 목록은 Erlang 포트로 보낼 수있는 문자 및 이진의 깊은 목록입니다. BNF에서 I / O 목록은 공식적으로 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="625b4ee43825e1d7dccb243cb5097290a139ac08" translate="yes" xml:space="preserve">
          <source>Information Object Classes, Information Objects, and Information Object Sets (in the following called classes, objects, and object sets, respectively) are defined in the standard definition X.681. Only a brief explanation is given here.</source>
          <target state="translated">정보 객체 클래스, 정보 객체 및 정보 객체 세트 (각각 다음의 클래스, 객체 및 객체 세트)는 표준 정의 X.681에 정의되어 있습니다. 여기서는 간단한 설명 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2d484a6c4fd2a8198b820555e505d0e990310c8a" translate="yes" xml:space="preserve">
          <source>Information about a message received via &lt;code&gt;&lt;a href=&quot;#ei_receive_msg&quot;&gt;ei_receive_msg()&lt;/a&gt;&lt;/code&gt; or friends.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ei_receive_msg&quot;&gt;ei_receive_msg()&lt;/a&gt;&lt;/code&gt; 또는 친구 를 통해받은 메시지에 대한 정보 .</target>
        </trans-unit>
        <trans-unit id="a82aa8be7390c90d1ca31ddb9f26374aa32e3de7" translate="yes" xml:space="preserve">
          <source>Information about all debugged processes, that is, all processes that have been or are executing code in interpreted modules</source>
          <target state="translated">모든 디버깅 된 프로세스, 즉 해석 된 모듈에서 코드를 실행했거나 실행중인 모든 프로세스에 대한 정보</target>
        </trans-unit>
        <trans-unit id="7b5fbcbe4f33b24be7f7dade0473f9e3fd15c849" translate="yes" xml:space="preserve">
          <source>Information about applications is fetched from the script when an upgrade or downgrade is performed.</source>
          <target state="translated">업그레이드 또는 다운 그레이드가 수행 될 때 스크립트에서 응용 프로그램에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="727a296b0edd7e6903cb4f17c45d2edcf89ed311" translate="yes" xml:space="preserve">
          <source>Information about implementation of Erlang can, for example, be found, in the following:</source>
          <target state="translated">Erlang 구현에 대한 정보는 예를 들어 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c573cb4e686c6d4351b362e3e317ae0cec7f7b7" translate="yes" xml:space="preserve">
          <source>Information about processes that are linked to the crashing process and do not trap exits. These processes are the neighbours that terminate because of this process crash. The information gathered is the same as the information for Crasher, described in the previous item.</source>
          <target state="translated">충돌 프로세스에 링크되고 종료를 트랩하지 않는 프로세스에 대한 정보. 이러한 프로세스는이 프로세스 충돌로 인해 종료되는 이웃입니다. 수집 된 정보는 이전 항목에서 설명한 Crasher의 정보와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3d412b1b20ea796db2817fa903c28c18a18ab90f" translate="yes" xml:space="preserve">
          <source>Information about the crashing process, such as initial function call, exit reason, and message queue.</source>
          <target state="translated">초기 함수 호출, 종료 이유 및 메시지 큐와 같은 충돌 프로세스에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="aed31395b72e3d4a3ffcf65b21d202b748042b7c" translate="yes" xml:space="preserve">
          <source>Information can be added to an existing PLT using option &lt;code&gt;--add_to_plt&lt;/code&gt;. If you also want to include the Erlang compiler in the PLT and place it in a new PLT, then use the following command:</source>
          <target state="translated">&lt;code&gt;--add_to_plt&lt;/code&gt; 옵션을 사용하여 기존 PLT에 정보를 추가 할 수 있습니다 . Erlang 컴파일러를 PLT에 포함시키고 새 PLT에 배치하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3521f2cf94de7eff4c9ac49833f3792cb383574d" translate="yes" xml:space="preserve">
          <source>Information flows between processes in a lot of different ways. Not all flows of information will be covered by sequential tracing. One example is information passed via ETS tables. Below is a list of information paths that are covered by sequential tracing:</source>
          <target state="translated">정보는 다양한 방식으로 프로세스간에 흐릅니다. 모든 정보 흐름이 순차 추적으로 처리되는 것은 아닙니다. 한 가지 예는 ETS 테이블을 통해 전달되는 정보입니다. 다음은 순차 추적이 적용되는 정보 경로 목록입니다.</target>
        </trans-unit>
        <trans-unit id="2d714fa02dd99c17cb145c5818ce9c2c7a15188e" translate="yes" xml:space="preserve">
          <source>Information for ssl applications use of &lt;code&gt; Logger(3)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt; Logger(3)&lt;/code&gt; 의 SSL 애플리케이션 사용에 대한 정보</target>
        </trans-unit>
        <trans-unit id="badb50beadce8a2fedabb18c2c3e47e220d098c1" translate="yes" xml:space="preserve">
          <source>Information function that returns a list of test case properties. (Optional)</source>
          <target state="translated">테스트 케이스 특성 목록을 리턴하는 정보 함수. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="a3358e99a156706a4b02a438de13cfba6a39cfde" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for a test case group. (Optional)</source>
          <target state="translated">테스트 케이스 그룹의 특성을 리턴하는 데 사용되는 정보 기능. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="b7b69d6b9f543c0eaac78b09bddfd720500262fd" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for the suite. (Optional)</source>
          <target state="translated">제품군의 속성을 반환하는 데 사용되는 정보 함수입니다. (선택 과목)</target>
        </trans-unit>
        <trans-unit id="275d164cb628d42311ae4ac3f05e29648d313888" translate="yes" xml:space="preserve">
          <source>Information functions can also be used for functions &lt;code&gt;init_per_suite&lt;/code&gt;, &lt;code&gt;end_per_suite&lt;/code&gt;, &lt;code&gt;init_per_group&lt;/code&gt;, and &lt;code&gt;end_per_group&lt;/code&gt;, and they work the same way as with the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;. This is useful, for example, for setting timetraps and requiring external configuration data relevant only for the configuration function in question (without affecting properties set for groups and test cases in the suite).</source>
          <target state="translated">정보 함수는 &lt;code&gt;init_per_suite&lt;/code&gt; , &lt;code&gt;end_per_suite&lt;/code&gt; , &lt;code&gt;init_per_group&lt;/code&gt; 및 &lt;code&gt;end_per_group&lt;/code&gt; 함수에도 사용할 수 있으며 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동합니다 . 예를 들어, 타임 트랩을 설정하고 해당 구성 기능과 관련된 외부 구성 데이터가 필요한 경우에 유용합니다 (스위트의 그룹 및 테스트 케이스에 설정된 특성에 영향을주지 않음).</target>
        </trans-unit>
        <trans-unit id="a4cf2090c576759071b1e7653127fe15f6adfbf5" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the callback function &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt;.</source>
          <target state="translated">콜백 함수 &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt; 에 대한 호출을 통해 정보가 수신자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0dca988e4a05ad3fbc98691395293e6bd4182b54" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the provided fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt;.</source>
          <target state="translated">제공된 fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt; 에 대한 호출을 통해 정보가 수신자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="cec5dea1f15eeea2c3e84d3e4ca8bca5a2733527" translate="yes" xml:space="preserve">
          <source>Information on the current primary peer address (see below for the format of &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt;)</source>
          <target state="translated">현재 기본 피어 주소에 대한 정보 ( &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt; 형식은 아래 참조 )</target>
        </trans-unit>
        <trans-unit id="943263da051924df889852b7d374aa63740830a1" translate="yes" xml:space="preserve">
          <source>Information passed as &lt;code&gt;Allowed&lt;/code&gt; to &lt;code&gt;accept_connection/5&lt;/code&gt;. This field is only mandatory when the remote node initiated the connection. That is, when the connection is set up via &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로 정보 전달 &lt;code&gt;Allowed&lt;/code&gt; 에 &lt;code&gt;accept_connection/5&lt;/code&gt; . 이 필드는 원격 노드가 연결을 시작한 경우에만 필수입니다. 즉, &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 를 통해 연결이 설정된 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="ade170506ce24c2adf11de9da3bbb7eb70a58a29" translate="yes" xml:space="preserve">
          <source>Information to the trace information file by can be added by calling &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;ValueList&lt;/code&gt; always is a list, and if you call &lt;code&gt;write_trace_info/2&lt;/code&gt; many times with the same &lt;code&gt;Key&lt;/code&gt;, the &lt;code&gt;ValueList&lt;/code&gt; is extended with a new value each time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 추적 정보 파일에 정보를 추가 할 수 있습니다 . 공지 사항 것을 &lt;code&gt;ValueList&lt;/code&gt; 는 항상 목록입니다, 당신이 호출하면 &lt;code&gt;write_trace_info/2&lt;/code&gt; 같은과 함께 여러 번 &lt;code&gt;Key&lt;/code&gt; 는 &lt;code&gt;ValueList&lt;/code&gt; 는 새 값마다로 확장된다.</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="fde8a0e7f8bd0a412204912650f8bc070489e1ef" translate="yes" xml:space="preserve">
          <source>Informative References</source>
          <target state="translated">유익한 참고 문헌</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="e10de46302bedac991ba7ad1e088a618722e8fd6" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case</source>
          <target state="translated">테스트 케이스를위한 초기화 / 종료 구성 기능</target>
        </trans-unit>
        <trans-unit id="d015c9ace3c20434d0041ce0cff6ccab9781d84e" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case group</source>
          <target state="translated">테스트 케이스 그룹의 초기화 / 종료 구성 기능</target>
        </trans-unit>
        <trans-unit id="58ae4fa4e4c45a4042a21249a079524cbdf1fa72" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for the test suite</source>
          <target state="translated">테스트 스위트를위한 초기화 / 종료 구성 기능</target>
        </trans-unit>
        <trans-unit id="569763f9af2cd4ec4e87af5548f03474b19269ff" translate="yes" xml:space="preserve">
          <source>Initial Database Content</source>
          <target state="translated">초기 데이터베이스 콘텐츠</target>
        </trans-unit>
        <trans-unit id="aa2b1ad6dd5b0e863107461f8ceb27d60b1c0cb1" translate="yes" xml:space="preserve">
          <source>Initial Heap Size</source>
          <target state="translated">초기 힙 크기</target>
        </trans-unit>
        <trans-unit id="04b4f9e33823c16aab76a0d934f32d38d4e5908c" translate="yes" xml:space="preserve">
          <source>Initial actions can be started and performed automatically on test target nodes using test specification term &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">테스트 스펙 용어 &lt;code&gt;init&lt;/code&gt; 를 사용하여 테스트 대상 노드에서 초기 조치를 자동으로 시작하고 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2e68d0686900d050b8e51048d38b591ec44cadd" translate="yes" xml:space="preserve">
          <source>Initial callback state. The prevailing state is passed to some &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks, which can then return a new state. Defaults to the value of the &lt;code&gt;alias&lt;/code&gt; option.</source>
          <target state="translated">초기 콜백 상태 우세한 상태는 어떤 &lt;code&gt;diameter_app(3)&lt;/code&gt; 콜백으로 전달되어 새로운 상태를 반환 할 수 있습니다. &lt;code&gt;alias&lt;/code&gt; 옵션 의 값이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="11127aa4503fb4c327cb52eefbc283b5b904478b" translate="yes" xml:space="preserve">
          <source>Initial configuration of a user</source>
          <target state="translated">사용자의 초기 구성</target>
        </trans-unit>
        <trans-unit id="f63e2a1458a3165eba761814a98cccd7a36796bc" translate="yes" xml:space="preserve">
          <source>Initial configuring of the benchmark is done. It is time to profile the actual benchmark and Mnesia</source>
          <target state="translated">벤치 마크의 초기 구성이 완료되었습니다. 실제 벤치 마크 및 Mnesia를 프로파일 링 할 때입니다</target>
        </trans-unit>
        <trans-unit id="fd67134d209d3929a18fd22b2bf93061d0a6fcc9" translate="yes" xml:space="preserve">
          <source>Initial punctuation</source>
          <target state="translated">구두점</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="720af05a9330814d44ade6dcc2331d10aefceb80" translate="yes" xml:space="preserve">
          <source>Initialization Vector</source>
          <target state="translated">초기화 벡터</target>
        </trans-unit>
        <trans-unit id="2a42b2def50c7a5490ba305f82951039087900a5" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt; enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt; enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt; 에서 읽은 초기화 구조 .</target>
        </trans-unit>
        <trans-unit id="7b1e85e5bbe04989425e3d15621533a5999e3cbf" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt; 가 읽은 초기화 구조 .</target>
        </trans-unit>
        <trans-unit id="b321f9a1e8a675ea2509ce2b0539809a756cd038" translate="yes" xml:space="preserve">
          <source>Initialize a Schema and Start Mnesia</source>
          <target state="translated">스키마 초기화 및 기억 상실 시작</target>
        </trans-unit>
        <trans-unit id="c27938fcde1cf5af3f8db5ecbf20a6ad88b05809" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;code&gt;ei&lt;/code&gt; library. This function should be called once (and only once) before calling any other functionality in the &lt;code&gt;ei&lt;/code&gt; library.</source>
          <target state="translated">&lt;code&gt;ei&lt;/code&gt; 라이브러리를 초기화합니다 . 이 함수는 &lt;code&gt;ei&lt;/code&gt; 라이브러리 에서 다른 기능을 호출하기 전에 한 번만 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a64f6886984c95422bac94f177607f7282849e50" translate="yes" xml:space="preserve">
          <source>Initialize the dynamically realizable buffer referred to by &lt;code&gt;x&lt;/code&gt;. The fields of the structure pointed to by parameter &lt;code&gt;x&lt;/code&gt; is filled in, and a default buffer is allocated. &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; also puts an initial version byte, which is used in the binary format (so that &lt;code&gt;ei_x_encode_version()&lt;/code&gt; will not be needed.)</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 참조하는 동적으로 실현 가능한 버퍼를 초기화합니다 . 매개 변수 &lt;code&gt;x&lt;/code&gt; 가 가리키는 구조의 필드 가 채워지고 기본 버퍼가 할당됩니다. &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; 은 또한 바이너리 형식으로 사용되는 초기 버전 바이트를 넣습니다 (따라서 &lt;code&gt;ei_x_encode_version()&lt;/code&gt; 이 필요하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="7f237c69a9e859db2237946c5d7c0d276ae06c1c" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;Config&lt;/code&gt; for property testing.</source>
          <target state="translated">속성 테스트를위한 &lt;code&gt;Config&lt;/code&gt; 을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="ab1eb197ba5ebd342dc2ee475284fc7e5bf38b6a" translate="yes" xml:space="preserve">
          <source>Initializes a decompression session on zlib stream.</source>
          <target state="translated">zlib 스트림에서 압축 해제 세션을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="41ffca7e6986ca11ec650f170b95e3cc75bf8fd1" translate="yes" xml:space="preserve">
          <source>Initializes a series of encryptions or decryptions where the IV is provided later. The actual encryption or decryption is done by &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">IV가 나중에 제공되는 일련의 암호화 또는 암호 해독을 초기화합니다. 실제 암호화 또는 복호화는 &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt; 에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="71cf011a78329c432562646be985f8bd2d74719c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for compression.</source>
          <target state="translated">압축을 위해 zlib 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3b0787c54b4aa93c99e4db7e0aa8440f3e95865c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for decompression.</source>
          <target state="translated">압축 해제를 위해 zlib 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="336b3d7ce13f5601ff72f5897cdf09da9f9fe9ae" translate="yes" xml:space="preserve">
          <source>Initializes and extends &lt;code&gt;Config&lt;/code&gt; for property based testing.</source>
          <target state="translated">속성 기반 테스트를 위해 &lt;code&gt;Config&lt;/code&gt; 를 초기화하고 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="f2ef76634443e1b1606ba6eb2d97778abbd5fbc8" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; variable at &lt;code&gt;*pid&lt;/code&gt; to represent the calling process.</source>
          <target state="translated">&lt;code&gt;*pid&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 변수를 초기화하여 호출 프로세스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3d111765b0e759f11aeb197d3230fefefbab898e" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;ec&lt;/code&gt; structure, to identify the node name and cookie of the server. One of them must be called before other functions that works on the &lt;code&gt;ei_cnode&lt;/code&gt; type or a file descriptor associated with a connection to another node is used.</source>
          <target state="translated">서버의 노드 이름과 쿠키를 식별하기 위해 &lt;code&gt;ec&lt;/code&gt; 구조를 초기화 합니다. &lt;code&gt;ei_cnode&lt;/code&gt; 유형 에서 작동하는 다른 함수 나 다른 노드에 대한 연결과 연관된 파일 디스크립터를 사용 하기 전에 이들 중 하나를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27ee5ce539b908b2f9afc72b6ece61043b8b3a2b" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;erl_connect&lt;/code&gt; module. In particular, these functions are used to identify the name of the C-node from which they are called. One of these functions must be called before any of the other functions in the &lt;code&gt;erl_connect&lt;/code&gt; module are used.</source>
          <target state="translated">&lt;code&gt;erl_connect&lt;/code&gt; 모듈을 초기화합니다 . 특히,이 함수는 호출 된 C 노드의 이름을 식별하는 데 사용됩니다. &lt;code&gt;erl_connect&lt;/code&gt; 모듈 의 다른 기능을 사용 하기 전에 이러한 기능 중 하나를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fff4647fcca281983f6aa36bc54f3d489503d92" translate="yes" xml:space="preserve">
          <source>Initializes the compression dictionary from the specified byte sequence without producing any compressed output.</source>
          <target state="translated">압축 된 출력을 생성하지 않고 지정된 바이트 시퀀스에서 압축 사전을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="cecdcace992350d4b41d9351d096bb6f4340a901" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming HMAC operations. &lt;code&gt;Type&lt;/code&gt; determines which hash function to use in the HMAC operation. &lt;code&gt;Key&lt;/code&gt; is the authentication key. The key can be any length.</source>
          <target state="translated">스트리밍 HMAC 작업에 대한 컨텍스트를 초기화합니다. &lt;code&gt;Type&lt;/code&gt; 은 HMAC 작업에 사용할 해시 함수를 결정합니다. &lt;code&gt;Key&lt;/code&gt; 는 인증 키입니다. 키는 임의의 길이가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc5e35ae1f6e4c8a9f317a985307e702ec5fe8b6" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming MAC operations.</source>
          <target state="translated">MAC 작업 스트리밍을위한 컨텍스트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="58ee8f0d598b1ace76a798b4bc4357923d380ca5" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming hash operations. &lt;code&gt;Type&lt;/code&gt; determines which digest to use. The returned context should be used as argument to &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스트리밍 해시 작업에 대한 컨텍스트를 초기화합니다. &lt;code&gt;Type&lt;/code&gt; 은 사용할 다이제스트를 결정합니다. 리턴 된 컨텍스트는 &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt; 의 인수로 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="25148288204f1c00d73668550121311425efb10f" translate="yes" xml:space="preserve">
          <source>Initializes the decompression dictionary from the specified uncompressed byte sequence. This function must be called as a response to an inflate operation (eg. &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt;) returning &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; or in the case of deprecated functions, throwing an &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; exception.</source>
          <target state="translated">지정된 비 압축 바이트 시퀀스에서 압축 해제 사전을 초기화합니다. 이 함수는 &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; 을 리턴 하거나 더 이상 사용되지 않는 함수의 경우 &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; 리턴 하는 팽창 조작 (예 : &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; )에 대한 응답으로 호출되어야합니다. }} 예외.</target>
        </trans-unit>
        <trans-unit id="ac2bef434e9feaa5de169d2c6afbadd5a7c8908f" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in RC4 stream encryption &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">RC4 스트림 암호화에 사용할 상태를 초기화합니다. &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5663fa60784f6a9095ca4a82fdf76aac4aedd36a" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in streaming AES encryption using Counter mode (CTR). &lt;code&gt;Key&lt;/code&gt; is the AES key and must be either 128, 192, or 256 bits long. &lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">카운터 모드 (CTR)를 사용하여 스트리밍 AES 암호화에서 사용할 상태를 초기화합니다. &lt;code&gt;Key&lt;/code&gt; 는 AES 키이며 길이는 128, 192 또는 256 비트 여야합니다. &lt;code&gt;IVec&lt;/code&gt; 은 128 비트 (16 바이트)의 임의의 초기화 벡터입니다. 이 상태는 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a25db95ace1f2c927c73f5809d432ed6899752c5" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with a continuous buffer with the same byte content as &lt;code&gt;iolist&lt;/code&gt;. As with &lt;code&gt;inspect_binary&lt;/code&gt;, the data pointed to by &lt;code&gt;bin&lt;/code&gt; is transient and does not need to be released.</source>
          <target state="translated">&lt;code&gt;iolist&lt;/code&gt; 와 동일한 바이트 내용을 갖는 연속 버퍼를 사용하여 &lt;code&gt;bin&lt;/code&gt; 이 가리키는 구조를 초기화합니다 . &lt;code&gt;inspect_binary&lt;/code&gt; 와 마찬가지로 &lt;code&gt;bin&lt;/code&gt; 이 가리키는 데이터 는 일시적이므로 해제 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="53971700cd909eeea0c14864c58051e869c0d933" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with information about binary term &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">이진 용어 &lt;code&gt;bin_term&lt;/code&gt; 에 대한 정보 를 사용하여 &lt;code&gt;bin&lt;/code&gt; 이 가리키는 구조를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="6f1914215cd23f1ae665e3e4aa9c43e473915c1e" translate="yes" xml:space="preserve">
          <source>Initializing &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 초기화</target>
        </trans-unit>
        <trans-unit id="095ce38697e0ac705466cb7422f064715a0a7be2" translate="yes" xml:space="preserve">
          <source>Initializing a database</source>
          <target state="translated">데이터베이스 초기화</target>
        </trans-unit>
        <trans-unit id="142639d39cd6ad6faf1f4a1c6ffbfff03a3e72a6" translate="yes" xml:space="preserve">
          <source>Initializing a new database schema with an attribute that specifies on which node, or nodes, that database is to operate.</source>
          <target state="translated">해당 데이터베이스를 운영 할 노드를 지정하는 속성을 사용하여 새 데이터베이스 스키마를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="8af85a22a580244a2da7187be7bcbcb5ef240447" translate="yes" xml:space="preserve">
          <source>Initially 768 words + the size of each element (6 words + the size of Erlang data). The table grows when necessary.</source>
          <target state="translated">처음에는 768 단어 + 각 요소의 크기 (6 단어 + Erlang 데이터의 크기). 필요한 경우 테이블이 커집니다.</target>
        </trans-unit>
        <trans-unit id="0c0e4c0739e6fa2df487aed1a38bae60d5b44dca" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all Erlang object code directories under library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt;, where &lt;code&gt;$OTPROOT&lt;/code&gt; is the installation directory of Erlang/OTP, &lt;code&gt;code:root_dir()&lt;/code&gt;. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt; and the code server, by default, chooses the directory with the highest version number among those having the same &lt;code&gt;Name&lt;/code&gt;. Suffix &lt;code&gt;-Vsn&lt;/code&gt; is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under &lt;code&gt;Name[-Vsn]&lt;/code&gt;, this directory is added to the code path.</source>
          <target state="translated">처음에 코드 경로는 현재 작업 디렉토리와 라이브러리 디렉토리 &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 아래의 모든 Erlang 오브젝트 코드 디렉토리로 구성됩니다 . 여기서 &lt;code&gt;$OTPROOT&lt;/code&gt; 는 Erlang / OTP의 설치 디렉토리, &lt;code&gt;code:root_dir()&lt;/code&gt; 입니다. 디렉토리 이름을 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 지정할 수 있으며 기본적으로 코드 서버는 동일한 &lt;code&gt;Name&lt;/code&gt; 을 가진 디렉토리 중에서 가장 높은 버전 번호를 가진 디렉토리를 선택합니다 . 접미사 &lt;code&gt;-Vsn&lt;/code&gt; 은 선택 사항입니다. &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 아래에 있으면 이 디렉토리가 코드 경로에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1ef73203a7358f8c0665ad7be5a157f1e4b9f4a0" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all object code directories under &lt;code&gt;ROOT/lib&lt;/code&gt;, where &lt;code&gt;ROOT&lt;/code&gt; is the installation directory of Erlang/OTP. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt;. The code server, by default, chooses the directory with the highest version number among those which have the same &lt;code&gt;Name&lt;/code&gt;. The &lt;code&gt;-Vsn&lt;/code&gt; suffix is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under the &lt;code&gt;Name[-Vsn]&lt;/code&gt; directory, this directory is added to the code path.</source>
          <target state="translated">처음에 코드 경로는 현재 작업 디렉토리와 &lt;code&gt;ROOT/lib&lt;/code&gt; 아래의 모든 객체 코드 디렉토리로 구성됩니다 . 여기서 &lt;code&gt;ROOT&lt;/code&gt; 는 Erlang / OTP의 설치 디렉토리입니다. 디렉토리 이름은 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 지정할 수 있습니다 . 코드 서버는 기본적으로 &lt;code&gt;Name&lt;/code&gt; 이 같은 디렉토리 중에서 버전 번호가 가장 높은 디렉토리를 선택합니다 . &lt;code&gt;-Vsn&lt;/code&gt; 접미사는 선택 사항입니다. &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 디렉토리 아래에 있으면 이 디렉토리가 코드 경로에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="73e156d278bb294a1d36b0f1e8eeb76af35c2cea" translate="yes" xml:space="preserve">
          <source>Initiate the discovery process with the manager identified by &lt;code&gt;TargetName&lt;/code&gt; using the notification &lt;code&gt;Notification&lt;/code&gt;.</source>
          <target state="translated">알림 &lt;code&gt;Notification&lt;/code&gt; 을 사용하여 &lt;code&gt;TargetName&lt;/code&gt; 으로 식별 된 관리자와 함께 발견 프로세스를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c7e89fc3067a91d9dc22af26a15ef53fe7faa29" translate="yes" xml:space="preserve">
          <source>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</source>
          <target state="translated">전송 서비스를 시작하고 megaco : user_info / 2에서받은 수신 핸들을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d124310299080eb087672c20f460f474dd7a228b" translate="yes" xml:space="preserve">
          <source>Initiates a new association for socket &lt;code&gt;Socket&lt;/code&gt;, with the peer (SCTP server socket) specified by &lt;code&gt;Addr&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Addr&lt;/code&gt; 및 &lt;code&gt;Port&lt;/code&gt; 로 지정된 피어 (SCTP 서버 소켓)를 사용하여 &lt;code&gt;Socket&lt;/code&gt; 에 대한 새 연관을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="cbce06bee52bd534bac0f1fd879f556b081eb91b" translate="yes" xml:space="preserve">
          <source>Initiates a new handshake. A notable return value is &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; indicating that the peer refused to go through with the renegotiation, but the connection is still active using the previously negotiated session.</source>
          <target state="translated">새로운 핸드 셰이크를 시작합니다. 주목할만한 리턴 값은 &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; 이며 피어가 재협상을 거치지 않았지만 이전에 협상 된 세션을 사용하여 연결이 여전히 활성 상태임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5c1ebc3443b604685c9bbd2239beafaabb442116" translate="yes" xml:space="preserve">
          <source>Initiates a zlib stream for compression.</source>
          <target state="translated">압축을 위해 zlib 스트림을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1829936800429f27b95a3900650dc47d80c4529b" translate="yes" xml:space="preserve">
          <source>Initiates heartbeat immediately</source>
          <target state="translated">하트 비트를 즉시 시작합니다</target>
        </trans-unit>
        <trans-unit id="a7b905a30abe8561cdf350ab8f4be5235485bbee" translate="yes" xml:space="preserve">
          <source>Initiates the event handler. Returns &lt;code&gt;Args&lt;/code&gt;, which is to be used in a call to &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러를 시작합니다. &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt; 호출에 사용될 &lt;code&gt;Args&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="cb3f35312b4615bd360925cee6cb1cda3648d9e7" translate="yes" xml:space="preserve">
          <source>Initiating discovery towards a manager is done by calling the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;EngineId&lt;/code&gt; field of the target (manager) entry in the &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; file has to have the value &lt;code&gt;discovery&lt;/code&gt;. Note that if the manager does not respond, the &lt;code&gt;Timeout&lt;/code&gt; and &lt;code&gt;RetryCount&lt;/code&gt; fields decide how long the function will hang before it returns.</source>
          <target state="translated">관리자에 대한 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 는 감지 기능 을 호출하여 수행됩니다 . &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; 파일 에서 대상 (관리자) 항목 의 &lt;code&gt;EngineId&lt;/code&gt; 필드는 &lt;code&gt;discovery&lt;/code&gt; 값을 가져야합니다 . 관리자가 응답하지 않으면 &lt;code&gt;Timeout&lt;/code&gt; 및 &lt;code&gt;RetryCount&lt;/code&gt; 필드는 함수가 반환되기 전에 얼마나 오래 중단 될지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="46e460ee323eec031b508ab0863b81f298c0e181" translate="yes" xml:space="preserve">
          <source>Initiation of the system tracer. This is automatically done when a trace port is started with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시스템 추적 프로그램 시작 추적 포트가 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 로 시작되면 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="a1e4de183a1e55e20092fbfffb06a3ca6dabef2e" translate="yes" xml:space="preserve">
          <source>Inlining does not necessarily improve running time. For example, inlining can increase Beam stack use, which probably is detrimental to performance for recursive functions.</source>
          <target state="translated">인라인이 반드시 실행 시간을 개선하지는 않습니다. 예를 들어, 인라인은 빔 스택 사용을 증가시킬 수 있으며, 이는 재귀 함수의 성능에 해로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b63d2fcb1c0298d4382222c2fee85ab11fe71d42" translate="yes" xml:space="preserve">
          <source>Inlining is never default. It must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">인라인은 기본값이 아닙니다. 소스 옵션에서 컴파일러 옵션 또는 &lt;code&gt;-compile()&lt;/code&gt; 속성을 사용하여 명시 적으로 사용 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1f86e94d7e79143e2b6de623fe87b30507e4ce9" translate="yes" xml:space="preserve">
          <source>Inlining of List Functions</source>
          <target state="translated">목록 함수 인라인</target>
        </trans-unit>
        <trans-unit id="d77e8eee07a3df5a34aa397c94c2739ac57d8e58" translate="yes" xml:space="preserve">
          <source>Input File Format</source>
          <target state="translated">입력 파일 형식</target>
        </trans-unit>
        <trans-unit id="9684f8c1b7785c7f3b7b0c7da13c9d237117432e" translate="yes" xml:space="preserve">
          <source>Input is the &lt;code&gt;modify_algs_list()&lt;/code&gt; and a set of algorithms &lt;code&gt;A&lt;/code&gt; obtained from the &lt;code&gt;preferred_algorithms&lt;/code&gt; option if existing, or else from the &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력 한 내용이다 &lt;code&gt;modify_algs_list()&lt;/code&gt; 및 알고리즘의 집합 &lt;code&gt;A&lt;/code&gt; 는 로부터 얻어진 &lt;code&gt;preferred_algorithms&lt;/code&gt; 의 , 또는 그 밖의 경우에서의 기존 옵션 &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="23d75e61604fece9c7dbc8a44250dba16a34606c" translate="yes" xml:space="preserve">
          <source>Insert CRLs into the ssl applications local cache.</source>
          <target state="translated">SSL 애플리케이션 로컬 캐시에 CRL을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="c64d6655689268dfa5695acb8ab21be53b2e0542" translate="yes" xml:space="preserve">
          <source>Insert CRLs, available to fetch on DER format from &lt;code&gt;URI&lt;/code&gt;, into the ssl applications local cache.</source>
          <target state="translated">&lt;code&gt;URI&lt;/code&gt; 에서 DER 형식으로 가져올 수있는 CRL을 SSL 애플리케이션 로컬 캐시에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="cd5094189bd5cfd6365f179313ffd178fdf639f3" translate="yes" xml:space="preserve">
          <source>Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers.</source>
          <target state="translated">사전 항목을 삽입하고 등록 된 모든 구독자에게 {et, {dict_insert, Key, Val}} 튜플을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e4cd78fd267862c838a3ab52eeab4765922d4166" translate="yes" xml:space="preserve">
          <source>Insert and lookup times in tables of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; are constant, regardless of the table size. For the &lt;code&gt;ordered_set&lt;/code&gt; datatype, time is proportional to the (binary) logarithm of the number of objects.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 및 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블에서 삽입 및 조회 시간 은 테이블 크기에 관계없이 일정합니다. 들어 &lt;code&gt;ordered_set&lt;/code&gt; 데이터 유형, 시간은 개체의 수의 (이진) 대수에 비례한다.</target>
        </trans-unit>
        <trans-unit id="ddc91d12a204c2897db05b9911e78202bfd7630f" translate="yes" xml:space="preserve">
          <source>Insert matching closing bracket</source>
          <target state="translated">일치하는 닫는 괄호 삽입</target>
        </trans-unit>
        <trans-unit id="8d23e9df496d5b5f549fd584b36ee77d8c95cf96" translate="yes" xml:space="preserve">
          <source>Insert previously killed text</source>
          <target state="translated">이전에 죽인 텍스트 삽입</target>
        </trans-unit>
        <trans-unit id="3bc9ebf4c62f530cbb1f2b55cfa61617e0d53ff4" translate="yes" xml:space="preserve">
          <source>Insert some data</source>
          <target state="translated">일부 데이터 삽입</target>
        </trans-unit>
        <trans-unit id="640a4aeeec0f1ba39ab23368bd04d29b5d8e1a0c" translate="yes" xml:space="preserve">
          <source>Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; to force processing an inserted event before others.</source>
          <target state="translated">이벤트를 삽입하면 다른 이벤트보다 먼저 삽입 된 이벤트를 처리하기 위해 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 과 같이 자주 사용하는 상태 처리 함수를 호출하는 트릭이 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd8d30baff70186f2f7aad20b4678282d4900c5d" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees</source>
          <target state="translated">추상 Erlang 구문 트리에 주석 삽입</target>
        </trans-unit>
        <trans-unit id="341885c8dc77554a3ac76126d852595374756f74" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees.</source>
          <target state="translated">추상 Erlang 구문 트리에 주석 삽입</target>
        </trans-unit>
        <trans-unit id="a3d2a2e2f845d7b7a7ee869ede57ddf6daa0a066" translate="yes" xml:space="preserve">
          <source>Insertions and deletions are inefficient for large tables.</source>
          <target state="translated">큰 테이블에서는 삽입 및 삭제가 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4bb765df879b9e1259d0b71afc9c95a90dee1bad" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; as the tail item of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 의 테일 항목으로 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 새로운 큐 &lt;code&gt;Q2&lt;/code&gt; 를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="0cb0ec71eee2375facccac9dd350eb3632385a27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the front of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 앞에 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 결과 큐 &lt;code&gt;Q2&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bff09ae949ed6c5d82000889e64ff74881a86a81" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the head of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 의 헤드에 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 새로운 큐 &lt;code&gt;Q2&lt;/code&gt; 를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="bb8be9c95d38e2c2c62d2277f37e3d777ea4428a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the rear of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q1&lt;/code&gt; 의 뒷면에 &lt;code&gt;Item&lt;/code&gt; 을 삽입합니다 . 결과 큐 &lt;code&gt;Q2&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4f86a04b36f84c1791d73ad2f91028f7ab17de69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.</source>
          <target state="translated">값이 &lt;code&gt;Value&lt;/code&gt; 인 &lt;code&gt;Key&lt;/code&gt; 를 &lt;code&gt;Tree1&lt;/code&gt; 에 삽입 하고 새 트리를 반환합니다. 키가 트리에 존재하지 않으면 충돌이 발생한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b0b72cb6b3b7b94bac6237d6384f911cba7c3b63" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; if the key is not present in the tree, otherwise updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt;. Returns the new tree.</source>
          <target state="translated">삽입 &lt;code&gt;Key&lt;/code&gt; 값 &lt;code&gt;Value&lt;/code&gt; 에 &lt;code&gt;Tree1&lt;/code&gt; 키가 트리에없는 경우, 그렇지 않으면 갱신 &lt;code&gt;Key&lt;/code&gt; 값에 &lt;code&gt;Value&lt;/code&gt; 에 &lt;code&gt;Tree1&lt;/code&gt; . 새로운 트리를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="8e70edfd3b0237725cfb5a40acf9c3b7b150a1b7" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Sep&lt;/code&gt; between each element in &lt;code&gt;List1&lt;/code&gt;. Has no effect on the empty list and on a singleton list. For example:</source>
          <target state="translated">&lt;code&gt;List1&lt;/code&gt; 의 각 요소 사이에 &lt;code&gt;Sep&lt;/code&gt; 를 삽입합니다 . 빈 목록과 싱글 톤 목록에는 영향을 미치지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a325e6f446aeb80024c65275457065a8938c1716" translate="yes" xml:space="preserve">
          <source>Inserts a new key value tuple into the index structure. If an item with the same key already exists, the new &lt;code&gt;Value&lt;/code&gt; overwrites the old value.</source>
          <target state="translated">색인 구조에 새 키 값 튜플을 삽입합니다. 동일한 키를 가진 항목이 이미 존재하면 새 &lt;code&gt;Value&lt;/code&gt; 이 이전 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="dd7d42875749ae25962aac0a68ced0a0cdaac6c5" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data, including the rows with StorageType &lt;code&gt;nonVolatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 모든 데이터를 데이터베이스에 삽입하고 StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 인 행을 포함하여 모든 이전 데이터를 삭제합니다 . 구성 파일에서 작성된 행은 StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2674f03b5ae49062060d17f947dd901cec545e2" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data.</source>
          <target state="translated">구성 파일의 모든 데이터를 데이터베이스에 삽입하고 모든 이전 데이터를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="81d473e42a2389c80ba7b8bd8eaae2b9ad9818bb" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old rows with StorageType &lt;code&gt;volatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 모든 데이터를 데이터베이스에 삽입하고 StorageType &lt;code&gt;volatile&lt;/code&gt; 을 사용 하여 이전 행을 모두 삭제합니다 . 구성 파일에서 작성된 행은 StorageType &lt;code&gt;nonVolatile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e4c6bfec305d402baf1f6154ff407e6c91aee57" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into table &lt;code&gt;Name&lt;/code&gt;. If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and &lt;code&gt;false&lt;/code&gt; is returned. Otherwise the objects are inserted and &lt;code&gt;true&lt;/code&gt; returned.</source>
          <target state="translated">테이블 &lt;code&gt;Name&lt;/code&gt; 에 하나 이상의 객체를 삽입합니다 . 지정된 개체의 키와 일치하는 키가있는 개체가 이미 있으면 테이블이 업데이트되지 않고 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 그렇지 않으면 객체가 삽입되고 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1739eb862c4f44f0c8b8666aa94b12c3c5873c60" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into the table &lt;code&gt;Name&lt;/code&gt;. If there already exists an object with a key matching the key of some of the given objects and the table type is &lt;code&gt;set&lt;/code&gt;, the old object will be replaced.</source>
          <target state="translated">테이블 &lt;code&gt;Name&lt;/code&gt; 에 하나 이상의 객체를 삽입합니다 . 주어진 객체 중 일부의 키와 일치하는 키를 가진 객체가 이미 존재하고 테이블 유형이 &lt;code&gt;set&lt;/code&gt; 경우 이전 객체가 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="876fd5ef2edcb097ef23ce7a73b8560c457972a7" translate="yes" xml:space="preserve">
          <source>Inserts the object or all of the objects in list &lt;code&gt;ObjectOrObjects&lt;/code&gt; into table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ObjectOrObjects&lt;/code&gt; 목록의 객체 또는 모든 객체 를 테이블 &lt;code&gt;Tab&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="ae27be6880fa3f4c4317e7fa32cf164938b23b5f" translate="yes" xml:space="preserve">
          <source>Inserts the objects of the Dets table &lt;code&gt;Name&lt;/code&gt; into the ETS table &lt;code&gt;EtsTab&lt;/code&gt;. The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten.</source>
          <target state="translated">Dets 테이블 &lt;code&gt;Name&lt;/code&gt; 의 오브젝트를 ETS 테이블 &lt;code&gt;EtsTab&lt;/code&gt; 에 삽입 합니다. 개체가 삽입되는 순서는 지정되지 않았습니다. 덮어 쓰지 않으면 ETS 테이블의 기존 개체가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b4bdee8f5d016433edb2959501b5ea73fcb10ffd" translate="yes" xml:space="preserve">
          <source>Inside a character class, \b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \B matches the letter B).</source>
          <target state="translated">문자 클래스 안에서 \ b는 다른 의미를 가지고 있습니다. 백 스페이스 문자와 일치합니다. 이러한 어설 션 중 하나라도 문자 클래스에 나타나는 경우 기본적으로 해당 리터럴 문자와 일치합니다 (예 : \ B는 문자 B와 일치).</target>
        </trans-unit>
        <trans-unit id="6629b1052ba09388c69c25e3887de5fe2387123b" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number following \ is &amp;gt; 7 and there have not been that many capturing subpatterns, PCRE handles \8 and \9 as the literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">문자 클래스 내에서 또는 \ 다음에 오는 10 진수가&amp;gt; 7이고 캡처하는 하위 패턴이 많지 않은 경우 PCRE는 \ 8과 \ 9를 리터럴 문자 &quot;8&quot;과 &quot;9&quot;로 처리하고 그렇지 않으면 다시 읽습니다. 백 슬래시 다음에 3 자리 8 진수를 사용하고이를 사용하여 데이터 문자를 생성합니다. 모든 후속 숫자는 자체를 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="238b16c4bad02ed3ad5ceb23a1d53060e3529beb" translate="yes" xml:space="preserve">
          <source>Inspecting the Inferred Types of the Analyzed Functions</source>
          <target state="translated">분석 된 함수의 추론 된 유형 검사</target>
        </trans-unit>
        <trans-unit id="772561da756f5538f076f086e95fd9bb72f9c7ca" translate="yes" xml:space="preserve">
          <source>Inspection of options and the collection of information about tables. As a result, qualifiers are modified during the optimization phase.</source>
          <target state="translated">옵션 검사 및 테이블 정보 수집. 결과적으로 한정자는 최적화 단계에서 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed15bc5bc33649cbd97c75a190935b6fc664a985" translate="yes" xml:space="preserve">
          <source>Inspects the message queue of the process. The queue is displayed in the Evaluator area.</source>
          <target state="translated">프로세스의 메시지 큐를 검사합니다. 큐가 평가자 영역에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c41908611056183491b965384931dc36fcce9650" translate="yes" xml:space="preserve">
          <source>Inspects the next function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">스택에서 다음 함수 호출을 검사하여 위치 및 변수 바인딩을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="99dd332d9a6b322e273f2bf083bbb69e0124148d" translate="yes" xml:space="preserve">
          <source>Inspects the previous function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">스택에서 이전 함수 호출을 검사하여 위치 및 변수 바인딩을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e0e3ac66ea23824a0888a07102b587536d02e2eb" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;Common Test Hooks&lt;/code&gt; (similar to &lt;code&gt;ct_run -ch_hooks&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test Hooks&lt;/code&gt; 설치하십시오 ( &lt;code&gt;ct_run -ch_hooks&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="f5eb1e91b4143e0bbdfbeefb2ba46df0c77182c0" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;event_handler&lt;/code&gt; plugins (similar to &lt;code&gt;ct_run -event_handler&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;event_handler&lt;/code&gt; 플러그인을 설치하십시오 ( &lt;code&gt;ct_run -event_handler&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="15c10e0edbffd8d75bb304a5e91c935e1d915d30" translate="yes" xml:space="preserve">
          <source>Install Microsofts Windows SDK 8.1</source>
          <target state="translated">Microsoft Windows SDK 8.1 설치</target>
        </trans-unit>
        <trans-unit id="33d5b3ab81816b854714f8f217754d3d00d7f871" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 12.0 (2013)</source>
          <target state="translated">Visual Studio 12.0 (2013) 설치</target>
        </trans-unit>
        <trans-unit id="7c3074dad8c89939fd6bc2238ba9706f6b6fa012" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 2019</source>
          <target state="translated">Visual Studio 2019 설치</target>
        </trans-unit>
        <trans-unit id="922606362e642350b80d6e7820e8b5540da61e4b" translate="yes" xml:space="preserve">
          <source>Install a created target system</source>
          <target state="translated">작성된 대상 시스템 설치</target>
        </trans-unit>
        <trans-unit id="15bd18613a0aabd193b9d2c514329890ddf37e12" translate="yes" xml:space="preserve">
          <source>Install an alternative evaluator.</source>
          <target state="translated">대체 평가자를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="670c52cab50cfe68e434bacfaa8fb6e66c45fef4" translate="yes" xml:space="preserve">
          <source>Install into &lt;code&gt;C:/OpenSSL-Win64&lt;/code&gt; (or &lt;code&gt;C:/OpenSSL-Win32&lt;/code&gt;)</source>
          <target state="translated">에 설치 &lt;code&gt;C:/OpenSSL-Win64&lt;/code&gt; (또는 &lt;code&gt;C:/OpenSSL-Win32&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="92439a10a8cbf48c10c3c7a94cc9989ba236ab4b" translate="yes" xml:space="preserve">
          <source>Install mingw-gcc, make and autoconf: &lt;code&gt;sudo apt install gcc-mingw-w64 make autoconf&lt;/code&gt;</source>
          <target state="translated">mingw-gcc, make 및 autoconf &lt;code&gt;sudo apt install gcc-mingw-w64 make autoconf&lt;/code&gt; : sudo apt install gcc-mingw-w64 make autoconf</target>
        </trans-unit>
        <trans-unit id="784778ecb391c0bb8180f39379167dc61078581c" translate="yes" xml:space="preserve">
          <source>Install or unpack it to the pgm folder: Cygwin: &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS: &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2: &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</source>
          <target state="translated">pgm 폴더에 설치하거나 압축을 풉니 다 : Cygwin : &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS : &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2 : &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5895bd8f7070b66bf6ef0fbd6cb29198cf6422c6" translate="yes" xml:space="preserve">
          <source>Install the lot, especially the modern user interface components, as it's definitely needed. Put &lt;code&gt;makensis&lt;/code&gt; in your path, in my case:</source>
          <target state="translated">꼭 필요한대로 로트, 특히 최신 사용자 인터페이스 구성 요소를 설치하십시오. 넣어 &lt;code&gt;makensis&lt;/code&gt; 를 내 경우, 경로에 :</target>
        </trans-unit>
        <trans-unit id="dcb4dffdf7e0a85f3c664c1c7c53716ab6be43e4" translate="yes" xml:space="preserve">
          <source>Install using the &lt;code&gt;release&lt;/code&gt; target. Instead of doing &lt;code&gt;make install&lt;/code&gt; you can create the installation in whatever directory you like using the &lt;code&gt;release&lt;/code&gt; target and run the &lt;code&gt;Install&lt;/code&gt; script yourself. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; is used for specifying the directory where the installation should be created. This is what by default ends up under &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; if you do the install using &lt;code&gt;make install&lt;/code&gt;. All installation paths provided in the &lt;code&gt;configure&lt;/code&gt; phase are ignored, as well as &lt;code&gt;DESTDIR&lt;/code&gt;, and &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. If you want links from a specific &lt;code&gt;bin&lt;/code&gt; directory to the installation you have to set those up yourself. An example where Erlang/OTP should be located at &lt;code&gt;/home/me/OTP&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;release&lt;/code&gt; 대상을 사용하여 설치하십시오 . &lt;code&gt;make install&lt;/code&gt; 을 수행하는 대신 &lt;code&gt;release&lt;/code&gt; 대상을 사용하여 원하는 디렉토리 에 &lt;code&gt;Install&lt;/code&gt; 작성 하고 Install 스크립트를 직접 실행할 수 있습니다. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; 는 설치를 작성해야하는 디렉토리를 지정하는 데 사용됩니다. &lt;code&gt;make install&lt;/code&gt; 을 사용하여 설치하는 경우 기본적으로 &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; 아래에 있습니다 . &lt;code&gt;configure&lt;/code&gt; 단계 에서 제공된 모든 설치 경로 와 &lt;code&gt;DESTDIR&lt;/code&gt; 및 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 가 무시됩니다 . 특정 &lt;code&gt;bin&lt;/code&gt; 에서 링크를 원하는 경우설치 디렉토리를 직접 설정해야합니다. Erlang / OTP가 &lt;code&gt;/home/me/OTP&lt;/code&gt; 에 위치해야하는 예 :</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="1061e24b97b7e7926c0e75ef8fe1d7b8635a2b45" translate="yes" xml:space="preserve">
          <source>Installation Problems</source>
          <target state="translated">설치 문제</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="ae2c551e6a734627f9bb26b99844fa20be2bf09e" translate="yes" xml:space="preserve">
          <source>Installing Manually</source>
          <target state="translated">수동 설치</target>
        </trans-unit>
        <trans-unit id="9a154fadab6abdb56f07ab11ddc3af5ae97be03c" translate="yes" xml:space="preserve">
          <source>Installing Module os_sup in Application os_mon</source>
          <target state="translated">응용 프로그램 os_mon에 모듈 os_sup 설치</target>
        </trans-unit>
        <trans-unit id="75e25ed448b223fc53dd0af23c71cf6acd70383c" translate="yes" xml:space="preserve">
          <source>Installing Using Paths Determined by configure</source>
          <target state="translated">configure에 의해 결정된 경로를 사용하여 설치</target>
        </trans-unit>
        <trans-unit id="37e8b615530d3eddfdf35ea03fe9f1d1df10701f" translate="yes" xml:space="preserve">
          <source>Installing a fallback is a distributed operation, which is &lt;strong&gt;only&lt;/strong&gt; performed on all &lt;code&gt;db_nodes&lt;/code&gt;. The fallback restores the database the next time the system is started. If a &lt;code&gt;Mnesia&lt;/code&gt; node with a fallback installed detects that &lt;code&gt;Mnesia&lt;/code&gt; on another node has died, it unconditionally terminates itself.</source>
          <target state="translated">폴백 설치는 분산 작업이며 모든 &lt;code&gt;db_nodes&lt;/code&gt; &lt;strong&gt;에서만&lt;/strong&gt; 수행됩니다 . 폴백은 다음에 시스템이 시작될 때 데이터베이스를 복원합니다. 경우 &lt;code&gt;Mnesia&lt;/code&gt; 의 대체와 노드가 감지를 설치 &lt;code&gt;Mnesia&lt;/code&gt; 다른 노드가 사망했다, 그것은 무조건 자신을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bf8d05868ee0f453c0775974d588edfe5e97fc4f" translate="yes" xml:space="preserve">
          <source>Installing a new release can be time consuming if there are many processes in the system. The reason is that each process must be checked for references to old code before a module can be purged. This check can lead to garbage collections and copying of data.</source>
          <target state="translated">시스템에 프로세스가 많은 경우 새 릴리스를 설치하는 데 시간이 오래 걸릴 수 있습니다. 그 이유는 모듈을 제거하기 전에 각 프로세스에서 이전 코드에 대한 참조를 확인해야하기 때문입니다. 이 검사는 가비지 수집 및 데이터 복사로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f49d0664d6c577222fc6b488f95606771d152054" translate="yes" xml:space="preserve">
          <source>Installing an Embedded System</source>
          <target state="translated">임베디드 시스템 설치</target>
        </trans-unit>
        <trans-unit id="65c9d6735d0aa5d00aafa4b2d57376ac26a57083" translate="yes" xml:space="preserve">
          <source>Installing an embedded system</source>
          <target state="translated">임베디드 시스템 설치</target>
        </trans-unit>
        <trans-unit id="f249b05e1f990b98f6f7c2fa7204014037a42f4b" translate="yes" xml:space="preserve">
          <source>Installing module os_sup in application os_mon</source>
          <target state="translated">애플리케이션 os_mon에 os_sup 모듈 설치</target>
        </trans-unit>
        <trans-unit id="0d6b51117865caef3500da1315942ae925f5b512" translate="yes" xml:space="preserve">
          <source>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</source>
          <target state="translated">백업을 폴백으로 설치합니다. 폴백은 다음에 시작할 때 데이터베이스를 복원하는 데 사용됩니다. 폴백을 설치하려면 관련된 모든 노드에서 Erlang이 작동해야하지만 Mnesia가 실행 중인지 여부는 중요하지 않습니다. 로컬 노드가 백업에서 디스크 상주 노드 중 하나가 아닌 경우 대체 설치가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="80bbef4d77254070ebc618b29a62e45e28b022f6" translate="yes" xml:space="preserve">
          <source>Installs a release-dependent file in the release structure. The release-dependent file must be in the release structure when a new release is installed: &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;relup&lt;/code&gt;, and &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">릴리스 구조에 릴리스 종속 파일을 설치합니다. 새 릴리스가 설치 될 때 릴리스 종속 파일은 릴리스 구조에 있어야합니다 ( &lt;code&gt;start.boot&lt;/code&gt; , &lt;code&gt;relup&lt;/code&gt; 및 &lt;code&gt;sys.config&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="9cc17758134c369293b8376cf241e90d4ab3c9cf" translate="yes" xml:space="preserve">
          <source>Installs configuration files and event handlers.</source>
          <target state="translated">구성 파일 및 이벤트 핸들러를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="cd266c6ba0dabab762b2f84c06c3f60e46cbc0a9" translate="yes" xml:space="preserve">
          <source>Installs the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release. Looks first for a &lt;code&gt;relup&lt;/code&gt; file for &lt;code&gt;Vsn&lt;/code&gt; and a script &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; in this file for upgrading from the current version. If not found, the function looks for a &lt;code&gt;relup&lt;/code&gt; file for the current version and a script &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; in this file for downgrading to &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">릴리스 의 지정된 버전 &lt;code&gt;Vsn&lt;/code&gt; 을 설치합니다 . 현재 버전에서 업그레이드 하기 위해 &lt;code&gt;Vsn&lt;/code&gt; 의 &lt;code&gt;relup&lt;/code&gt; 파일 과이 파일 의 스크립트 &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; 을 먼저 찾습니다 . 찾을 수없는 경우에 대한 기능 외모 &lt;code&gt;relup&lt;/code&gt; 의 현재 버전과 스크립트 파일 &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; 으로 다운 그레이드이 파일에서 &lt;code&gt;Vsn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894c05ee140b1e5c4a2d166f027270a4786a5715" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt;, it is recommended to use &lt;code&gt;information object class&lt;/code&gt;, &lt;code&gt;table constraints&lt;/code&gt;, and &lt;code&gt;parameterization&lt;/code&gt;. In particular the construct &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; accomplish the same as the deprecated &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ANY&lt;/code&gt; 및 &lt;code&gt;ANY DEFINED BY&lt;/code&gt; 대신 &lt;code&gt;information object class&lt;/code&gt; , &lt;code&gt;table constraints&lt;/code&gt; 및 &lt;code&gt;parameterization&lt;/code&gt; 를 사용하는 것이 좋습니다 . 특히 &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; 구문 은 더 이상 사용되지 않는 &lt;code&gt;ANY&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1a112f4ca91bf66f308e6108843c00878e4e2493" translate="yes" xml:space="preserve">
          <source>Instead of a syntax tree, the atom &lt;code&gt;any&lt;/code&gt; can be passed for &lt;code&gt;Expr&lt;/code&gt; (or, more generally, be used for any subtree of &lt;code&gt;Expr&lt;/code&gt;, in as much the abstract syntax tree implementation allows it); this means that it cannot be decided whether the pattern will match or not, and the corresponding variable bindings will all map to &lt;code&gt;any&lt;/code&gt;. The typical use is for producing bindings for &lt;code&gt;receive&lt;/code&gt; clauses.</source>
          <target state="translated">구문 트리 대신, 원자 &lt;code&gt;any&lt;/code&gt; 는 &lt;code&gt;Expr&lt;/code&gt; 에 대해 전달 될 수 있습니다 (또는 추상 구문 트리 구현이 허용하는 한 &lt;code&gt;Expr&lt;/code&gt; 의 모든 하위 트리에 대해 더 일반적으로 사용됨 ). 이 패턴 일치 여부 및 해당 변수 바인딩 모든 매핑됩니다 여부를 결정 할 수 없음이 의미 &lt;code&gt;any&lt;/code&gt; . 일반적인 용도는 &lt;code&gt;receive&lt;/code&gt; 절에 대한 바인딩을 생성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fcac9a2c6f438e0b892acc88067b58945c6aafe1" translate="yes" xml:space="preserve">
          <source>Instead of allocating and deallocating memory blocks for the different versions of the balancing information we keep old memory blocks and reuse them when it is safe to do so. In order to be able to determine when it is safe to reuse a block we use the thread progress functionality, ensuring that no threads have any references to the memory block when we reuse it.</source>
          <target state="translated">다른 버전의 밸런싱 정보에 대해 메모리 블록을 할당 및 할당 해제하는 대신 이전 메모리 블록을 유지하고 안전 할 때 다시 사용합니다. 블록을 재사용하는 것이 안전한시기를 결정할 수 있도록 스레드 진행 기능을 사용하여 재사용 할 때 스레드가 메모리 블록에 대한 참조를 갖지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="fc7e20b59d61598b6e28276f64b45fa785f43095" translate="yes" xml:space="preserve">
          <source>Instead of bothering with when to cancel a time-out, a late time-out event can be handled by ignoring it if it arrives in a state where it is known to be late.</source>
          <target state="translated">타임 아웃을 취소 할 때 방해하지 않고 늦은 타임 아웃 이벤트는 지연된 것으로 알려진 상태에 도달하면 무시하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5df25e84cfbffa2ce05cceb65eb4a19410b1a990" translate="yes" xml:space="preserve">
          <source>Instead of confirming at a global location each thread confirms that it accepts in increment of the global counter in its own cache line. These confirmation cache lines are located in sequence in an array, and each confirmation cache line will only be written by one and only one thread. One of the managed threads always have the leader responsibility. This responsibility may jump between threads, but as long as there are some activity in the system always one of them will have the leader responsibility. The thread with the leader responsibility will call &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt; which will check that all other threads have confirmed an increment of the global counter before doing the increment of the global counter. The leader thread is the only thread reading the confirmation cache lines.</source>
          <target state="translated">전역 위치에서 확인하는 대신 각 스레드는 자체 캐시 라인에서 전역 카운터의 증분을 수락하는지 확인합니다. 이러한 확인 캐시 라인은 배열에서 순서대로 위치하며 각 확인 캐시 라인은 단 하나의 스레드에 의해서만 기록됩니다. 관리되는 스레드 중 하나는 항상 리더 책임을 갖습니다. 이 책임은 스레드간에 이동할 수 있지만 시스템에 어떤 활동이있는 한 항상 그들 중 하나가 리더 책임을 갖습니다. 리더 책임을 가진 스레드는 &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt; 를 호출 하여 다른 모든 스레드가 글로벌 카운터의 증가를 수행하기 전에 글로벌 카운터의 증가를 확인했는지 확인합니다. 리더 스레드는 확인 캐시 라인을 읽는 유일한 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="213371ce84506976ac4492056a774bb42087e25f" translate="yes" xml:space="preserve">
          <source>Instead of decoding a term you can also skipped past it if you are not interested in the data by usage of &lt;code&gt;&lt;a href=&quot;#ei_skip_term&quot;&gt;ei_skip_term()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">용어를 디코딩하는 대신 &lt;code&gt;&lt;a href=&quot;#ei_skip_term&quot;&gt;ei_skip_term()&lt;/a&gt;&lt;/code&gt; 사용하여 데이터에 관심이없는 경우 해당 용어를 건너 뛸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ac5e371533e8b9b9bddff06d20eea879128e69a" translate="yes" xml:space="preserve">
          <source>Instead of extracting to a directory, this option gives the result as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of the file named &lt;code&gt;Filename&lt;/code&gt; in the tar file.</source>
          <target state="translated">이 옵션은 디렉토리로 추출하는 대신 결과를 튜플 &lt;code&gt;{Filename, Binary}&lt;/code&gt; 목록으로 제공합니다 . 여기서 &lt;code&gt;Binary&lt;/code&gt; 는 tar 파일에 &lt;code&gt;Filename&lt;/code&gt; 이라는 파일 의 추출 된 데이터를 포함하는 이진 입니다.</target>
        </trans-unit>
        <trans-unit id="4784466e0218483e747807ddebabf7681aeccce8" translate="yes" xml:space="preserve">
          <source>Instead of extracting to the current directory, the result is given as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of file &lt;code&gt;Filename&lt;/code&gt; in the zip archive.</source>
          <target state="translated">현재 디렉토리로 추출하는 대신 결과는 튜플 &lt;code&gt;{Filename, Binary}&lt;/code&gt; 의 목록으로 제공됩니다. 여기서 &lt;code&gt;Binary&lt;/code&gt; 는 zip 아카이브에 &lt;code&gt;Filename&lt;/code&gt; 파일의 추출 된 데이터를 포함하는 2 진 입니다.</target>
        </trans-unit>
        <trans-unit id="b7a7e21b3061206a522b83d82bc15d0c88d5c34c" translate="yes" xml:space="preserve">
          <source>Instead of inventing an encoding/decoding scheme, the &lt;code&gt;term_to_binary/1&lt;/code&gt; and &lt;code&gt;binary_to_term/1&lt;/code&gt; BIFs are to be used.</source>
          <target state="translated">인코딩 / 디코딩 방식을 발명하는 대신 &lt;code&gt;term_to_binary/1&lt;/code&gt; 및 &lt;code&gt;binary_to_term/1&lt;/code&gt; BIF가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="957a44da07f45a291c340d2351a1716bd46e06c0" translate="yes" xml:space="preserve">
          <source>Instead of keeping the events after writing them to file, it is possible to remove all stored events after they have successfully written to file (clear).</source>
          <target state="translated">파일에 기록한 후 이벤트를 유지하는 대신 파일에 성공적으로 기록한 후 저장된 모든 이벤트를 제거 할 수 있습니다 (지우기).</target>
        </trans-unit>
        <trans-unit id="d6b6ced692332e6827f1ab9c6981a8b233a0df36" translate="yes" xml:space="preserve">
          <source>Instead of making two &lt;strong&gt;complete decodes&lt;/strong&gt; (the normal case of decode), one in the server and one in the addressee, it is only necessary to make one &lt;strong&gt;specialized decode&lt;/strong&gt;(in the server) and another complete decode(in the addressee). This section describes the following two specialized decodes, which support to solve this and similar problems:</source>
          <target state="translated">하나는 서버에, 하나는 수신인에 두 개의 &lt;strong&gt;완전한 디코드&lt;/strong&gt; (일반적인 디코딩의 경우) 를 만드는 대신 , 하나의 &lt;strong&gt;특수한 디코드&lt;/strong&gt; (서버에서)와 다른 하나의 완전한 디코드 (주소에서) 를 만드는 것만 필요합니다 . 이 섹션에서는이 문제와 비슷한 문제를 해결하기 위해 지원되는 다음과 같은 두 가지 특수한 디코딩에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="91c6a0b15ffa9e153241283e847138f73993d2de" translate="yes" xml:space="preserve">
          <source>Instead of passing data between test cases, it is recommended that the test cases read the state from the SUT and perform assertions (that is, let the test case run if the state is as expected, otherwise reset or fail). It is also recommended to use the state to set variables necessary for the test case to execute properly. Common actions can often be implemented as library functions for test cases to call to set the SUT in a required state. (Such common actions can also be separately tested, if necessary, to ensure that they work as expected). It is sometimes also possible, but not always desirable, to group tests together in one test case, that is, let a test case perform a &quot;scenario&quot; test (a test consisting of subtests).</source>
          <target state="translated">테스트 사례간에 데이터를 전달하는 대신 테스트 사례는 SUT에서 상태를 읽고 어설 션을 수행하는 것이 좋습니다 (즉, 상태가 예상 한 경우 테스트 사례를 실행하고 그렇지 않으면 재설정 또는 실패). 상태를 사용하여 테스트 케이스가 올바르게 실행되는 데 필요한 변수를 설정하는 것이 좋습니다. 공통 조치는 종종 테스트 케이스가 SUT를 필수 상태로 설정하기 위해 호출하는 라이브러리 함수로 구현 될 수 있습니다. (필요한 경우 이러한 공통 작업을 별도로 테스트하여 예상대로 작동하는지 확인할 수도 있습니다). 테스트를 하나의 테스트 사례로 그룹화하는 것이 가능할 수도 있지만 항상 바람직한 것은 아닙니다. 즉, 테스트 사례가 &quot;시나리오&quot;테스트 (하위 테스트로 구성된 테스트)를 수행하게합니다.</target>
        </trans-unit>
        <trans-unit id="5e843f77e91e88619108e5e1053242424ec8027e" translate="yes" xml:space="preserve">
          <source>Instead of printing the logs to stdout we print them to a rotating file log.</source>
          <target state="translated">로그를 stdout에 인쇄하는 대신 회전 파일 로그에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="12e2746f238f1ef6d97ef5382070198c881467b2" translate="yes" xml:space="preserve">
          <source>Instead of sending and receiving messages, there are also a number of BIFs that can be used:</source>
          <target state="translated">메시지를 보내고받는 대신 사용할 수있는 여러 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7e7103489360f3cee70f09abebe4add0bd2f172" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; to retrieve the call stack back-trace, use the following syntax:</source>
          <target state="translated">&lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; 을 사용하여 호출 스택 역 추적을 검색하는 대신 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="de3457c1d8ba8869d9e05a5cf426f25a98eeb702" translate="yes" xml:space="preserve">
          <source>Instead of using a global lock protecting modifications of this information, we write a completely new version of it at each load balancing. The new version is written in another memory block than the previous one, and published by issuing a write memory barrier and then storing a pointer to the new memory block in a global variable using an atomic write operation.</source>
          <target state="translated">이 정보의 수정을 보호하는 전역 잠금을 사용하는 대신 각로드 밸런싱에서 완전히 새로운 버전을 작성합니다. 새 버전은 이전 버전이 아닌 다른 메모리 블록에 기록되고 쓰기 메모리 장벽을 발행 한 다음 원자 쓰기 작업을 사용하여 전역 변수에 새 메모리 블록에 대한 포인터를 저장하여 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="ee1209a66a0d33f9394aa6222d618b5c852bc2f2" translate="yes" xml:space="preserve">
          <source>Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y.</source>
          <target state="translated">F 또는 x F y에 (x, y)를 쓰지 않고 F가 함수일 때 F (x) = y를 쓰고 F가 x를 y에 매핑하거나 x의 F 값이 y라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="a36e0c64e3f3fa49d084296cc4e8951b3a27ede3" translate="yes" xml:space="preserve">
          <source>Instead use the &lt;code&gt;ordsets&lt;/code&gt; module in STDLIB:</source>
          <target state="translated">대신 &lt;code&gt;ordsets&lt;/code&gt; 에서 ordsets 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbec30d1239740312abe0f5b282771460878faea" translate="yes" xml:space="preserve">
          <source>Instead we store the meta information about all the free segments in a dedicated area apart from the &lt;code&gt;sa&lt;/code&gt; and &lt;code&gt;sua&lt;/code&gt; areas. Every free segment is represented by a descriptor struct (&lt;code&gt;ErtsFreeSegDesc&lt;/code&gt;).</source>
          <target state="translated">대신 &lt;code&gt;sa&lt;/code&gt; 및 &lt;code&gt;sua&lt;/code&gt; 영역을 제외한 전용 영역에 모든 무료 세그먼트에 대한 메타 정보를 저장합니다 . 모든 자유 세그먼트는 설명자 구조체 ( &lt;code&gt;ErtsFreeSegDesc&lt;/code&gt; )로 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="8284bfaef1136f8c3023ca2dd6044b337e83ed3a" translate="yes" xml:space="preserve">
          <source>Instead, a correct &lt;code&gt;relup&lt;/code&gt; file can be created manually, either from scratch or by editing the generated version. The instructions for starting/stopping &lt;code&gt;ch_app&lt;/code&gt; are replaced by instructions for loading/unloading the application:</source>
          <target state="translated">대신 처음부터 또는 생성 된 버전을 편집하여 올바른 &lt;code&gt;relup&lt;/code&gt; 파일을 수동으로 만들 수 있습니다. &lt;code&gt;ch_app&lt;/code&gt; 시작 / 중지 지시 사항은 응용 프로그램로드 / 언로드 지시 사항으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ba07e35226d0f31a98d4cafeb0c6278cbf810675" translate="yes" xml:space="preserve">
          <source>Instead, write as follows:</source>
          <target state="translated">대신 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="9fc643b23198428cdd06035331b0190f9cb1cf31" translate="yes" xml:space="preserve">
          <source>Instruct the network interface process to send the response (acknowledgment) to an inform-request.</source>
          <target state="translated">응답 (확인)을 정보 요청으로 보내도록 네트워크 인터페이스 프로세스에 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="d2bbe05f8fa95e1efc3d5bece8070fe298a07cc9" translate="yes" xml:space="preserve">
          <source>Instruction</source>
          <target state="translated">Instruction</target>
        </trans-unit>
        <trans-unit id="950c248b2e82115897c90fa4bea94141b0b4cd0f" translate="yes" xml:space="preserve">
          <source>Instructions for this are added to the &lt;code&gt;relup&lt;/code&gt; file in the above order. Instructions for upgrading or downgrading between application versions are fetched from the relevant application upgrade files &lt;code&gt;App.appup&lt;/code&gt;, sorted in the same order as when generating a boot script, see &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt;. High-level instructions are translated into low-level instructions and the result is printed to the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">이에 대한 지침 은 위 순서대로 &lt;code&gt;relup&lt;/code&gt; 파일에 추가됩니다 . 응용 프로그램 버전 간 업그레이드 또는 다운 그레이드 지침은 관련 응용 프로그램 업그레이드 파일 &lt;code&gt;App.appup&lt;/code&gt; 에서 가져와 부팅 스크립트 생성시와 동일한 순서로 정렬됩니다 ( &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt; 참조) . 고수준 명령어는 저수준 명령어로 변환되고 결과는 &lt;code&gt;relup&lt;/code&gt; 파일로 인쇄 됩니다.</target>
        </trans-unit>
        <trans-unit id="15a574978b985fb36f19dcd27a57e275c9779736" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to search for include files in the &lt;code&gt;Directory&lt;/code&gt;. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">컴파일러가 &lt;code&gt;Directory&lt;/code&gt; 에서 포함 파일을 검색하도록 지시합니다 . &lt;code&gt;-include&lt;/code&gt; 또는 &lt;code&gt;-include_lib&lt;/code&gt; 지시문 이 발생하면 컴파일러는 다음 디렉토리에서 헤더 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="090b6773e54bc64eab02dc4333eb95623d3030be" translate="yes" xml:space="preserve">
          <source>Instructs the server whether to use persistent connections when the client claims to be HTTP/1.1 compliant. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 HTTP / 1.1 호환이라고 주장 할 때 영구 연결을 사용할지 서버에 지시합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e97bdfc8fc290d16010ddf7b419664bce4b9617" translate="yes" xml:space="preserve">
          <source>Instrumentation Flags</source>
          <target state="translated">계측 플래그</target>
        </trans-unit>
        <trans-unit id="d576ad12ae7ca73aaebcc2a1bd690b16fd09352f" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions</source>
          <target state="translated">계측 기능</target>
        </trans-unit>
        <trans-unit id="7e107f318ea5b4287f70d2ec329ab60cf318fcd6" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-COMMUNITY-MIB</source>
          <target state="translated">SNMP-COMMUNITY-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="b5ea15149e34607b8a589fb5bf1d1b743d875810" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-FRAMEWORK-MIB</source>
          <target state="translated">SNMP-FRAMEWORK-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="6b4f14b977fdbe201544748c402fba9645dfd2c0" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-NOTIFICATION-MIB</source>
          <target state="translated">SNMP-NOTIFICATION-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="6b69550b40cf6b05f4832bfe56c28495ecf7fe30" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-TARGET-MIB</source>
          <target state="translated">SNMP-TARGET-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="f65fddfd52fcea283103e339d1c60b0f5ba6c122" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="d49a7cc7da280cbfd346949bb2a603ee48e8fb05" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</source>
          <target state="translated">SNMP-VIEW-BASED-ACM-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="d7f6a4f444ab301e6d5e54f70415dd52f590fae1" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</source>
          <target state="translated">STANDARD-MIB 및 SNMPv2-MIB를위한 계측 기능</target>
        </trans-unit>
        <trans-unit id="e47c5f3c57120b008bbaac0ca750237faa5971be" translate="yes" xml:space="preserve">
          <source>Instrumentation can use Distributed Erlang to communicate with an application.</source>
          <target state="translated">인스 트루먼 테이션은 Distributed Erlang을 사용하여 애플리케이션과 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e54e2e240bbb19f14b4c55bc3b487003ec8395" translate="yes" xml:space="preserve">
          <source>Instrumentation functions must be written for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; for scalar variables and tables, and for &lt;code&gt;get-next&lt;/code&gt; for tables only. The &lt;code&gt;get-bulk&lt;/code&gt; operation is translated into a series of calls to &lt;code&gt;get-next&lt;/code&gt;.</source>
          <target state="translated">스칼라 변수 및 테이블의 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 및 테이블의 &lt;code&gt;get-next&lt;/code&gt; 에 대한 계측 기능을 작성해야합니다 . &lt;code&gt;get-bulk&lt;/code&gt; 작업은하는 일련의 호출로 번역 &lt;code&gt;get-next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f47cc59656d4c025462d150f89cebf98c56ae3f" translate="yes" xml:space="preserve">
          <source>Insufficient storage space in system [452].</source>
          <target state="translated">시스템의 저장 공간이 부족합니다 [452].</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="bab8970ab6c1e2445db3a30cda08c3f08c7ba8ce" translate="yes" xml:space="preserve">
          <source>Integer (24 bits unsigned). Used to limit the size of valid TLS handshake packets to avoid DoS attacks. Defaults to 256*1024.</source>
          <target state="translated">정수 (24 비트 부호 없음). DoS 공격을 피하기 위해 유효한 TLS 핸드 셰이크 패킷의 크기를 제한하는 데 사용됩니다. 기본적으로 256 * 1024입니다.</target>
        </trans-unit>
        <trans-unit id="4054de071d83c0118f2e7e0bb466ffc5a48431e8" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received information that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="translated">Integer &lt;code&gt;PreviousSerial&lt;/code&gt; 은 추적 토큰을 전달하는 마지막 수신 정보에서 전달 된 직렬 카운터를 나타냅니다. 프로세스가 새 순차 추적에서 첫 번째 인 경우, &lt;code&gt;PreviousSerial&lt;/code&gt; 은 프로세스 내부 &quot;추적 클록&quot;의 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cd1200dfbc2522df40f5135712d5fcc5350dab3d" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received message that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="translated">정수 &lt;code&gt;PreviousSerial&lt;/code&gt; 은 추적 토큰을 전달한 마지막으로받은 메시지에 전달 된 직렬 카운터를 나타냅니다. 프로세스가 새로운 순차 추적에서 첫 번째 인 경우 &lt;code&gt;PreviousSerial&lt;/code&gt; 은 프로세스 내부 &quot;추적 클럭&quot;의 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fd0e21bf741b765fbb25882622616e5016575de7" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;ThisSerial&lt;/code&gt; is the serial counter that a process sets on outgoing messages. It is based on the process internal &quot;trace clock&quot;, which is incremented by one before it is attached to the trace token in the message.</source>
          <target state="translated">정수 &lt;code&gt;ThisSerial&lt;/code&gt; 은 프로세스가 발신 메시지에 설정하는 직렬 카운터입니다. 메시지 내부의 추적 토큰에 연결되기 전에 1 씩 증가하는 프로세스 내부 &quot;추적 클록&quot;을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="70d648e65d494f28a7240688bec60fdcef36d372" translate="yes" xml:space="preserve">
          <source>Integer division</source>
          <target state="translated">정수 나누기</target>
        </trans-unit>
        <trans-unit id="ae4df4a5ccd3fc7872ad572de0cb764f4a758558" translate="yes" xml:space="preserve">
          <source>Integer remainder of X/Y</source>
          <target state="translated">X / Y의 정수 나머지</target>
        </trans-unit>
        <trans-unit id="d2bea1d11037eb2c7d3d25da5484514181294970" translate="yes" xml:space="preserve">
          <source>Integer representing valid unicode codepoint.</source>
          <target state="translated">유효한 유니 코드 코드 포인트를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="181a76a5f255c27b6eead001f5b06ef26f0b2d1e" translate="yes" xml:space="preserve">
          <source>Integer values are either integer or character literals or expressions consisting of possibily nested unary or binary operations that evaluate to an integer. Such expressions can also be used in bit strings and ranges.</source>
          <target state="translated">정수 값은 정수 또는 문자 리터럴이거나 정수로 평가되는 중첩 된 단항 또는 이진 연산으로 구성된 표현식입니다. 이러한 식은 비트 문자열 및 범위에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="845b1adfda3fcd43e837ece8fd1075b9fd016964" translate="yes" xml:space="preserve">
          <source>Integer values, for example in the &lt;code&gt;SIZE&lt;/code&gt; expression must be entered in decimal syntax, not in hex or bit syntax.</source>
          <target state="translated">예를 들어 &lt;code&gt;SIZE&lt;/code&gt; 표현식의 정수 값 은 16 진 또는 비트 구문이 아닌 10 진수 구문으로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="a84d8938ca4e58573de3fba8872fd63ef8c7c19d" translate="yes" xml:space="preserve">
          <source>Integer with the base &lt;strong&gt;&lt;code&gt;base&lt;/code&gt;&lt;/strong&gt;, that must be an integer in the range 2..36.</source>
          <target state="translated">base &lt;strong&gt; &lt;code&gt;base&lt;/code&gt; &lt;/strong&gt; 인 정수로, 2..36 범위의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="61e3decdf5d6115018a9e34ce42bf8006f9593cd" translate="yes" xml:space="preserve">
          <source>Integers must be in microseconds, meaning that the offset &lt;code&gt;7200000000&lt;/code&gt; is equivalent to &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt;.</source>
          <target state="translated">정수는 마이크로 초 여야합니다. 오프셋 &lt;code&gt;7200000000&lt;/code&gt; 은 &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7c69ae2cd9192c2c796400efe2ac35c22e2e2ca5" translate="yes" xml:space="preserve">
          <source>Integers out of range.</source>
          <target state="translated">정수가 범위를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="07e05e6c552c53b1a227c82d017e7aac90837347" translate="yes" xml:space="preserve">
          <source>Integers starting with 909, for example &lt;code&gt;9091&lt;/code&gt; or &lt;code&gt;909123&lt;/code&gt;</source>
          <target state="translated">909로 시작하는 정수 (예 : &lt;code&gt;9091&lt;/code&gt; 또는 &lt;code&gt;909123&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="60073de1e4b76eca2577f27a28edb01f36540075" translate="yes" xml:space="preserve">
          <source>Intended to facilitate testing.</source>
          <target state="translated">테스트를 용이하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9801faf88c32829ebf6c941dbb638428950801bd" translate="yes" xml:space="preserve">
          <source>Intended when ERTS, Kernel, STDLIB, or SASL is upgraded. It is automatically added when the &lt;code&gt;relup&lt;/code&gt; file is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. It is executed before all other upgrade instructions. For more information about this instruction, see restart_new_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS, 커널, STDLIB 또는 SASL이 업그레이드 될 때 사용됩니다. &lt;code&gt;relup&lt;/code&gt; 파일이 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 에 의해 생성 될 때 자동으로 추가됩니다 . 다른 모든 업그레이드 지침 전에 실행됩니다. 이 명령어에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; restart_new_emulator (낮은 수준)를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="047073e3b4116ee04b74c0c1cc448bd79da99506" translate="yes" xml:space="preserve">
          <source>Intentionally left undocumented.</source>
          <target state="translated">의도적으로 문서화하지 않은 채로 두었습니다.</target>
        </trans-unit>
        <trans-unit id="e997f694b62e9d0577171e2f7dc26f17597ee566" translate="yes" xml:space="preserve">
          <source>Inter Call Graph Edges (*).</source>
          <target state="translated">인터 콜 그래프 에지 (*).</target>
        </trans-unit>
        <trans-unit id="c0647e7fac7fdd2a3b341864d842dcd6753383c9" translate="yes" xml:space="preserve">
          <source>Interaction With Other SNMP Agent Toolkits</source>
          <target state="translated">다른 SNMP 에이전트 툴킷과의 상호 작용</target>
        </trans-unit>
        <trans-unit id="eddaa29b2e62f4b03003dfe22bc83c780028fc16" translate="yes" xml:space="preserve">
          <source>Interaction data enforces module dependencies and is to be avoided if possible. This means that the order of modules in the modules property is significant.</source>
          <target state="translated">상호 작용 데이터는 모듈 종속성을 강제하며 가능한 경우 피해야합니다. 이는 modules 속성에서 모듈의 순서가 중요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0a9935f358aacf056c71d573e766697caf72716e" translate="yes" xml:space="preserve">
          <source>Interface Functions for Secure Socket Layer</source>
          <target state="translated">SSL (Secure Socket Layer)을위한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="b75e70d6d70b916e116f37e9c717c016fbc0e51b" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit MIB compiler</source>
          <target state="translated">SNMP 툴킷 MIB 컴파일러에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="6f6bbd90e92a57397bbeedbddd3fab27ffbb44a4" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit agent</source>
          <target state="translated">SNMP 툴킷 에이전트에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="47f2cdd50d9092fae631a48bdc454c378a0342df" translate="yes" xml:space="preserve">
          <source>Interface address description list returned from &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0,1&lt;/a&gt;&lt;/code&gt; for a named interface, translated from the returned data of the POSIX API function &lt;code&gt;getaddrinfo()&lt;/code&gt;.</source>
          <target state="translated">POSIX API 함수 &lt;code&gt;getaddrinfo()&lt;/code&gt; 의 반환 된 데이터에서 변환 된 명명 된 인터페이스에 대해 &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0,1&lt;/a&gt;&lt;/code&gt; 에서 반환 된 인터페이스 주소 설명 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="8423a1ea8308683d2b47e96337afebc61ea2820a" translate="yes" xml:space="preserve">
          <source>Interface definitions between the client and the messenger</source>
          <target state="translated">클라이언트와 메신저 사이의 인터페이스 정의</target>
        </trans-unit>
        <trans-unit id="323c54cb50a9e3d1f4d686a59d1de38461683cb5" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit</source>
          <target state="translated">SNMP 툴킷에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="d20fd70153a1269fbf41940e196fc270f187a23c" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit manager</source>
          <target state="translated">SNMP 툴킷 관리자에 대한 인터페이스 기능</target>
        </trans-unit>
        <trans-unit id="ce6831520571e37fee954cd1b34f9e1abf7d82ff" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation.</source>
          <target state="translated">XML 스키마 유효성 검사를위한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="050237493439e212d4bc538dddbf1f1eda8b5092" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation. It handles the W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; of XML Schema second edition 28 october 2004. For an introduction to XML Schema study &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; An XML structure is validated by xmerl_xsd:validate/[2,3].</source>
          <target state="translated">XML 스키마 유효성 검사를위한 인터페이스 모듈. 이 문서는 2004 년 10 월 28 일자 XML Schema 제 2 판 의 W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; 을 다루고있다 . XML Schema 연구 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; 소개를 위해 xmerl_xsd : validate / [2,3]에 의해 XML 구조가 검증된다.</target>
        </trans-unit>
        <trans-unit id="6e2ae4a4e371583e84ad62568aeaef5ba4469dae" translate="yes" xml:space="preserve">
          <source>Interface module for the &lt;code&gt;tftp&lt;/code&gt; application.</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; 어플리케이션을 위한 인터페이스 모듈 .</target>
        </trans-unit>
        <trans-unit id="ca876b1a699869a57f784174cba40d788c67ea64" translate="yes" xml:space="preserve">
          <source>Interface module for the Event Trace (ET) application</source>
          <target state="translated">ET (Event Trace) 애플리케이션을위한 인터페이스 모듈</target>
        </trans-unit>
        <trans-unit id="45f7c5e26612823c7e6731913f85b1300e9ae4ce" translate="yes" xml:space="preserve">
          <source>Interface module for the Megaco application</source>
          <target state="translated">Megaco 애플리케이션을위한 인터페이스 모듈</target>
        </trans-unit>
        <trans-unit id="c936eb6df938f4d258995b26947dcddb7458ae2b" translate="yes" xml:space="preserve">
          <source>Interface module to TPKT transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco / H.248 용 TPKT 전송 프로토콜에 대한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="27468964adda1f4dd990691916ff4a4d446a2e7d" translate="yes" xml:space="preserve">
          <source>Interface module to UDP transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco / H.248 용 UDP 전송 프로토콜에 대한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="6d75c5c7c8f11fcc10b56585e807ce50cb617d4f" translate="yes" xml:space="preserve">
          <source>Interface module to the flex scanner linked in driver.</source>
          <target state="translated">드라이버에 연결된 플렉스 스캐너에 대한 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="aacb400767c682f7416831e0737ea9f733b0c6c0" translate="yes" xml:space="preserve">
          <source>Interface to OS System Messages</source>
          <target state="translated">OS 시스템 메시지에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="2a76ee81e739df0dc00918ece6fa79aa9518edfe" translate="yes" xml:space="preserve">
          <source>Interface to TCP/IP sockets.</source>
          <target state="translated">TCP / IP 소켓에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="cc16cc1cca26b8e2731cb9be496453c8f68c2df9" translate="yes" xml:space="preserve">
          <source>Interface to UDP sockets.</source>
          <target state="translated">UDP 소켓에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="96f6013ec56594333c06a3834e9c2473d15a18de" translate="yes" xml:space="preserve">
          <source>Interface to Windows Event Log</source>
          <target state="translated">Windows 이벤트 로그에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="d4457db8b0de1c4d4686f8d6b2a56e3e9ab8095b" translate="yes" xml:space="preserve">
          <source>Interface to dynamic tracing</source>
          <target state="translated">동적 추적에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="0716ba0b63e064bb3cb187f55a890a904447d9e9" translate="yes" xml:space="preserve">
          <source>Interface to standard Erlang I/O servers</source>
          <target state="translated">표준 Erlang I / O 서버에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="43768b10820f3bcc951b6981b78de3c2c85818c7" translate="yes" xml:space="preserve">
          <source>Interface to the Erlang built-in term storage BIFs</source>
          <target state="translated">Erlang 내장 용어 스토리지 BIF에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="e271a1417ebd38c2097dcca069254ee88820347c" translate="yes" xml:space="preserve">
          <source>Interfaces with &lt;strong&gt;only&lt;/strong&gt; the specified address family</source>
          <target state="translated">지정된 주소 계열 &lt;strong&gt;만&lt;/strong&gt; 있는 인터페이스</target>
        </trans-unit>
        <trans-unit id="1f70720ae9d9a9229ade1c047b73ae221942913d" translate="yes" xml:space="preserve">
          <source>Interfaces with address family &lt;code&gt;inet&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;inet6&lt;/code&gt;</source>
          <target state="translated">주소 계열 &lt;code&gt;inet&lt;/code&gt; &lt;strong&gt;및 &lt;/strong&gt; &lt;code&gt;inet6&lt;/code&gt; &lt;strong&gt;과의&lt;/strong&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="f672e9ac51285d0fd0e7e4843c6946df35242ba0" translate="yes" xml:space="preserve">
          <source>Internal Erlang definitions.</source>
          <target state="translated">내부 얼랭 정의.</target>
        </trans-unit>
        <trans-unit id="1d7b78aa00f45d0dd9ee4563372276be519f843b" translate="yes" xml:space="preserve">
          <source>Internal Events</source>
          <target state="translated">내부 이벤트</target>
        </trans-unit>
        <trans-unit id="e76a3a1f266ee2d2c19bd1cf93ee7be9edde487b" translate="yes" xml:space="preserve">
          <source>Internal data types</source>
          <target state="translated">내부 데이터 유형</target>
        </trans-unit>
        <trans-unit id="c321c0008c19ab39f772c58457023179c5cabf57" translate="yes" xml:space="preserve">
          <source>Internal generic instructions are known only to the runtime system and can be changed at any time without compatibility issues.</source>
          <target state="translated">내부 일반 명령어는 런타임 시스템에만 알려져 있으며 호환성 문제없이 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57478123672682d59f79168c35495125ed986756" translate="yes" xml:space="preserve">
          <source>Internal generic instructions. They are known only to the runtime system and can be changed at any time without compatibility issues. They are created by transformation rules (described next).</source>
          <target state="translated">내부 일반 지침. 런타임 시스템에만 알려져 있으며 호환성 문제없이 언제든지 변경할 수 있습니다. 변환 규칙에 의해 생성됩니다 (다음에 설명).</target>
        </trans-unit>
        <trans-unit id="c43136ea5f7b358debf82f26c7522eae622f4bc8" translate="yes" xml:space="preserve">
          <source>Internal id for set of locks, not always unique. This could be table name for ets tables (db_tab), port id for ports, integer identifiers for allocators, etc.</source>
          <target state="translated">잠금 세트의 내부 ID이며 항상 고유하지는 않습니다. ets 테이블의 테이블 이름 (db_tab), 포트의 포트 ID, 할당 자의 정수 식별자 등이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b4e732bf321d59bf0542504f5ae72694c688f58" translate="yes" xml:space="preserve">
          <source>Internal runtime lock counter controllers</source>
          <target state="translated">내부 런타임 잠금 카운터 컨트롤러</target>
        </trans-unit>
        <trans-unit id="341fa1e0f35c53a05146fef56f0f0dcefb3384e9" translate="yes" xml:space="preserve">
          <source>Internal server errors are recorded in the error log file. The format of this file is a more unplanned format than the logs using Common Logfile Format, but conforms to the following syntax:</source>
          <target state="translated">내부 서버 오류는 오류 로그 파일에 기록됩니다. 이 파일의 형식은 Common Logfile 형식을 사용하는 로그보다 계획되지 않은 형식이지만 다음 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3d37510d25e4b581b66d9a9103bd0c6f31ee62ee" translate="yes" xml:space="preserve">
          <source>Internal state of the channel.</source>
          <target state="translated">채널의 내부 상태</target>
        </trans-unit>
        <trans-unit id="badfae6bbc42b495ad12bdff0f4b098f913dcb9a" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;Mnesia&lt;/code&gt; uses several commit protocols. The selected protocol depends on which table that has been updated in the transaction. If all the involved tables are symmetrically replicated (that is, they all have the same &lt;code&gt;ram_nodes&lt;/code&gt;, &lt;code&gt;disc_nodes&lt;/code&gt;, and &lt;code&gt;disc_only_nodes&lt;/code&gt; currently accessible from the coordinator node), a lightweight transaction commit protocol is used.</source>
          <target state="translated">내부적으로 &lt;code&gt;Mnesia&lt;/code&gt; 는 여러 커밋 프로토콜을 사용합니다. 선택된 프로토콜은 트랜잭션에서 업데이트 된 테이블에 따라 다릅니다. 관련된 모든 테이블이 대칭 적으로 복제되는 경우 (즉 , 코디네이터 노드에서 현재 액세스 할 수 있는 동일한 &lt;code&gt;ram_nodes&lt;/code&gt; , &lt;code&gt;disc_nodes&lt;/code&gt; 및 &lt;code&gt;disc_only_nodes&lt;/code&gt; 가 있는 경우) 경량 트랜잭션 커밋 프로토콜이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4be7390306e27edeab5e110ad71f96da0daba7a4" translate="yes" xml:space="preserve">
          <source>Internally a framework called &lt;code&gt;alloc_util&lt;/code&gt; is used for implementing allocators. &lt;code&gt;sys_alloc&lt;/code&gt; and &lt;code&gt;mseg_alloc&lt;/code&gt; do not use this framework, so the following does &lt;strong&gt;not&lt;/strong&gt; apply to them.</source>
          <target state="translated">내부적으로 &lt;code&gt;alloc_util&lt;/code&gt; 이라는 프레임 워크 가 할당자를 구현하는 데 사용됩니다. &lt;code&gt;sys_alloc&lt;/code&gt; 및 &lt;code&gt;mseg_alloc&lt;/code&gt; 은이 프레임 워크를 사용하지 &lt;strong&gt;않으므로&lt;/strong&gt; 다음이 적용 되지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c426ea5b2618f0f6ae7be49919b9b54e05abea42" translate="yes" xml:space="preserve">
          <source>Internally in each priority level, processes are scheduled in a round robin fashion.</source>
          <target state="translated">각 우선 순위 수준에서 내부적으로 프로세스는 라운드 로빈 방식으로 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="c41284ece411489ae5985686dd33bb0cf82727eb" translate="yes" xml:space="preserve">
          <source>Internally in the Erlang runtime system locks are used to protect resources from being updated from multiple threads in a fatal way. Locks are necessary to ensure that the runtime system works properly but it also introduces a couple of limitations. Lock contention and locking overhead.</source>
          <target state="translated">내부적으로 Erlang 런타임 시스템 잠금은 치명적인 방식으로 여러 스레드에서 자원이 업데이트되지 않도록 보호하는 데 사용됩니다. 런타임 시스템이 올바르게 작동하도록하려면 잠금이 필요하지만 몇 가지 제한 사항이 있습니다. 경합 및 잠금 오버 헤드를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="7d74971bacf5510c7ab75585168e740293be593d" translate="yes" xml:space="preserve">
          <source>Internally in the runtime system, Erlang monotonic time is the &quot;time engine&quot; that is used for more or less everything that has anything to do with time. All timers, regardless of it is a &lt;code&gt;receive ... after&lt;/code&gt; timer, BIF timer, or a timer in the &lt;code&gt;timer(3)&lt;/code&gt; module, are triggered relative Erlang monotonic time. Even &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; is based on Erlang monotonic time. By adding current Erlang monotonic time with current time offset, you get current Erlang system time.</source>
          <target state="translated">런타임 시스템에서 내부적으로 Erlang 단조 시간은 시간과 관련이있는 거의 모든 것에 사용되는 &quot;시간 엔진&quot;입니다. 타이머, BIF 타이머 또는 &lt;code&gt;timer(3)&lt;/code&gt; 모듈의 타이머에 관계없이 모든 타이머는 &lt;code&gt;receive ... after&lt;/code&gt; 관계없이 Erlang 단조 시간에 대해 트리거됩니다. &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 조차도 Erlang 단조 시간을 기준으로합니다. 현재 시간 오프셋과 함께 현재 Erlang 단조 시간을 추가하면 현재 Erlang 시스템 시간을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="a059bcd00d503bcbdc0046cbcdb9ce42b54025ec" translate="yes" xml:space="preserve">
          <source>Internally, binaries and bitstrings are implemented in the same way. In this section, they are called &lt;strong&gt;binaries&lt;/strong&gt; because that is what they are called in the emulator source code.</source>
          <target state="translated">내부적으로 바이너리와 비트 스트링은 같은 방식으로 구현됩니다. 이 섹션에서는 에뮬레이터 소스 코드에서 호출되기 때문에 &lt;strong&gt;바이너리&lt;/strong&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="65b23551ca2d93024f6a6d3767a19538365fa833" translate="yes" xml:space="preserve">
          <source>Internally, for example in the generated code and in the output from the BEAM disassembler, the instruction &lt;code&gt;move x y&lt;/code&gt; will be called &lt;code&gt;move_xy&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 생성 된 코드와 BEAM 디스어셈블러의 출력에서 &lt;code&gt;move_xy&lt;/code&gt; &lt;code&gt;move x y&lt;/code&gt; 명령어 는 move_xy 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="f6f3359a916a2a0d142f95745652bdd812cac3df" translate="yes" xml:space="preserve">
          <source>Internally, records are represented using tagged tuples:</source>
          <target state="translated">내부적으로 레코드는 태그가 지정된 튜플을 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd2c83c9c4fac498df04ee4596255b013c52c14a" translate="yes" xml:space="preserve">
          <source>Internally, the supervisor also keeps track of the pid &lt;code&gt;Child&lt;/code&gt; of the child process, or &lt;code&gt;undefined&lt;/code&gt; if no pid exists.</source>
          <target state="translated">내부적으로 감독자는 자식 프로세스 의 pid &lt;code&gt;Child&lt;/code&gt; 을 추적 하거나 pid가없는 경우 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3623dcb4995df517dc1119f9c1eac79892d03149" translate="yes" xml:space="preserve">
          <source>Internationalized domain names are not supported.</source>
          <target state="translated">국제화 된 도메인 이름은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e68d66b86c5b372f203a16d7698b8bcac56dc8f3" translate="yes" xml:space="preserve">
          <source>Interpretable modules are modules for which a &lt;code&gt;.beam&lt;/code&gt; file, compiled with option &lt;code&gt;debug_info&lt;/code&gt; set, is located in the same directory as the source code, or in an &lt;code&gt;ebin&lt;/code&gt; directory next to it.</source>
          <target state="translated">해석 모듈은되는 모듈입니다 &lt;code&gt;.beam&lt;/code&gt; 의 옵션을 사용하여 컴파일 된 파일, &lt;code&gt;debug_info&lt;/code&gt; 세트, 소스 코드와 동일한 디렉토리에있는, 또는에서 &lt;code&gt;ebin&lt;/code&gt; 옆에 디렉토리.</target>
        </trans-unit>
        <trans-unit id="11c3c6c74af70de4fbc0724c5fe96be415a45a08" translate="yes" xml:space="preserve">
          <source>Interpreter Interface.</source>
          <target state="translated">통역 인터페이스.</target>
        </trans-unit>
        <trans-unit id="d0145d7b897252f435c3a2f9b80c340bcaeb2cbd" translate="yes" xml:space="preserve">
          <source>Interprets it as universal time.</source>
          <target state="translated">세계시로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="ccdccf92f6f4b9eea51ade2820a3421f89b938c1" translate="yes" xml:space="preserve">
          <source>Interprets the escript regardless of the value of the mode attribute.</source>
          <target state="translated">mode 속성 값에 관계없이 escript를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="d062a6aaa1321b4fbe61ff2e8174819990ef6080" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;i/1&lt;/code&gt; interprets the module only at the current node. &lt;code&gt;ni/1&lt;/code&gt; interprets the module at all known nodes.</source>
          <target state="translated">지정된 모듈을 해석합니다. &lt;code&gt;i/1&lt;/code&gt; 은 현재 노드에서만 모듈을 해석합니다. &lt;code&gt;ni/1&lt;/code&gt; 은 알려진 모든 노드에서 모듈을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="8f875d6a6ca694f0b14cea8f5848e9d0ba0a21ef" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;ii/1&lt;/code&gt; interprets the module(s) only at the current node, see &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ini/1&lt;/code&gt; interprets the module(s) at all known nodes, see &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈을 해석합니다. &lt;code&gt;ii/1&lt;/code&gt; 은 현재 노드에서만 모듈을 해석합니다 ( &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt; 참조) . &lt;code&gt;ini/1&lt;/code&gt; 은 알려진 모든 노드에서 모듈을 해석합니다 ( &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3729c738460ce5f6a85bafb8d5ebc52b2170ffc7" translate="yes" xml:space="preserve">
          <source>Interprets the time set as local.</source>
          <target state="translated">현지 시간으로 설정된 시간을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="a6a03664ff2ef589fe34431565963c09a8035a81" translate="yes" xml:space="preserve">
          <source>Intersecting an empty family exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">빈 패밀리를 교차하면 &lt;code&gt;badarg&lt;/code&gt; 메시지 와 함께 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b56d0e04c45c4c2d5526cfbb776e3ab6ea16e89" translate="yes" xml:space="preserve">
          <source>Intersecting an empty set of sets exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">빈 세트 세트를 교차 &lt;code&gt;badarg&lt;/code&gt; 메시지 와 함께 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3aecd4f7ca9b10ba6eefdc3b3982ee51acbee86" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</source>
          <target state="translated">ERTS 8.1.2 (Erlang / OTP 19.2)에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="e4185202e789e006e8d46cab5bb0f1344a5a2825" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</source>
          <target state="translated">ERTS 8.3에 도입 (Erlang / OTP 19.3)</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1e7228f13f302f91d97086fd99b6f4023b94b4ab" translate="yes" xml:space="preserve">
          <source>Invalid Subject Alternative Name extension.</source>
          <target state="translated">잘못된 주제 대체 이름 확장자입니다.</target>
        </trans-unit>
        <trans-unit id="6dd22909406f536945b3651891eae0a11394eec6" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called &quot;surrogate&quot; codepoints), and 0xffef.</source>
          <target state="translated">잘못된 유니 코드 코드 포인트는 0xd800에서 0xdfff (소위 &quot;대리&quot;코드 포인트) 범위 및 0xffef입니다.</target>
        </trans-unit>
        <trans-unit id="970e02af50aef8057777e1e719234daf9ac3bd81" translate="yes" xml:space="preserve">
          <source>Invalid argument: &lt;code&gt;to&lt;/code&gt; is not a valid Erlang pid.</source>
          <target state="translated">잘못된 인수 : &lt;code&gt;to&lt;/code&gt; 는 유효한 Erlang pid가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0cc909be0f2da4ba1a41bb22abd333ee5d822722" translate="yes" xml:space="preserve">
          <source>Invalid username or password.</source>
          <target state="translated">잘못된 사용자 이름 또는 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="e8f7b9edf2ca5bb757072a798bd0acfa87861234" translate="yes" xml:space="preserve">
          <source>Invalidate the mib server cache.</source>
          <target state="translated">mib 서버 캐시를 무효화하십시오.</target>
        </trans-unit>
        <trans-unit id="9759cc5e347da705fdd81203cf52cec5eb5adf6e" translate="yes" xml:space="preserve">
          <source>Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a &lt;code&gt;(?U)&lt;/code&gt; option setting within the pattern.</source>
          <target state="translated">수량 자의 &quot;greediness&quot;를 반전시켜 기본적으로 욕심이 없지만 &quot;?&quot;가 오면 욕심이됩니다. Perl과 호환되지 않습니다. 패턴 내에서 &lt;code&gt;(?U)&lt;/code&gt; 옵션 설정 으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce3b1ae867572c714bd282ce9e483e01b357834" translate="yes" xml:space="preserve">
          <source>Invoked for each transaction request</source>
          <target state="translated">각 트랜잭션 요청에 대해 호출</target>
        </trans-unit>
        <trans-unit id="3d01902a8b40974a69e9ea306fbe52a7b7185b83" translate="yes" xml:space="preserve">
          <source>Invoked when a connection is teared down</source>
          <target state="translated">연결이 끊어졌을 때 호출</target>
        </trans-unit>
        <trans-unit id="39559513e0fdc0d1c43b0c8be77af3afaf11b089" translate="yes" xml:space="preserve">
          <source>Invoked when a new connection is established</source>
          <target state="translated">새 연결이 설정되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="aad6f32ab5334acc03c0b23cd1d9febffce28f41" translate="yes" xml:space="preserve">
          <source>Invoked when a received message had syntax errors</source>
          <target state="translated">수신 된 메시지에 구문 오류가있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d768e80023291d60266531cb13740e0ce1f447c2" translate="yes" xml:space="preserve">
          <source>Invoked when a received message just contains an error instead of a list of transactions.</source>
          <target state="translated">수신 된 메시지에 트랜잭션 목록 대신 오류가 포함되어있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f77eaeba46fb85e4b28b68f94f4e359f9e2851ee" translate="yes" xml:space="preserve">
          <source>Invoked when a transaction request has been aborted</source>
          <target state="translated">트랜잭션 요청이 중단되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cc89cd28b56040ba5e6a38dfd9e4d4df5cc8c73b" translate="yes" xml:space="preserve">
          <source>Invoked when a unexpected message is received</source>
          <target state="translated">예기치 않은 메시지가 수신되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0af975defd697440d1ee7d6af73916790ab9bbc3" translate="yes" xml:space="preserve">
          <source>Invoked when the file transfer is aborted.</source>
          <target state="translated">파일 전송이 중단되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0427692fb99ce605340c28aa25be48c6566c62f3" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;et:trace_me/5&lt;/code&gt; with both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; set to &lt;code&gt;FromTo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;From&lt;/code&gt; 및 &lt;code&gt;To&lt;/code&gt; 를 &lt;code&gt;FromTo&lt;/code&gt; 로 설정하여 &lt;code&gt;et:trace_me/5&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d83df673697f3918f082f79e1172314cb5c6089b" translate="yes" xml:space="preserve">
          <source>Invokes a memory check and returns the resulting, system dependent, data as a list of tagged tuples, where &lt;code&gt;Tag&lt;/code&gt; can be one of the following:</source>
          <target state="translated">메모리 검사를 호출하고 결과로 시스템에 의존하는 데이터를 태그가 지정된 튜플 목록으로 반환합니다. 여기서 &lt;code&gt;Tag&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1100bbe70f71111dfc5fac73d1ff0bdf78d63a7b" translate="yes" xml:space="preserve">
          <source>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell can still be used.</source>
          <target state="translated">Erlang / OTP 3.3에서 이전 Erlang 쉘을 호출합니다. 오래된 쉘을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36a3a3daec3816a0a8d74afe681df212e4a06b79" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; might fail, silently produce suboptimal code, or silently produce erroneous code.</source>
          <target state="translated">&lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; 를 호출하면 실패하거나, 최적이 아닌 코드를 자동으로 생성하거나, 잘못된 코드를 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b08f920d3a33d8317baaf4578d92c7eb8654fd5" translate="yes" xml:space="preserve">
          <source>IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</source>
          <target state="translated">IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="216b4a0c9222fc30988b436b2d5c7b661431663a" translate="yes" xml:space="preserve">
          <source>Irrelevant</source>
          <target state="translated">Irrelevant</target>
        </trans-unit>
        <trans-unit id="9d4e3fd7167bf46822004ff30d54f3257b464f0a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;0&lt;/code&gt; for a regular NIF (and so its value can be omitted for statically initialized &lt;code&gt;ErlNifFunc&lt;/code&gt; instances).</source>
          <target state="translated">는 &lt;code&gt;0&lt;/code&gt; 일반 NIF 위해 (그 값은 정적으로 초기화를 위해 생략 될 수 &lt;code&gt;ErlNifFunc&lt;/code&gt; 의 경우).</target>
        </trans-unit>
        <trans-unit id="7bfc1a78cb2bcc7b84b4d8522e849e276e3b2586" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if encryption is performed. It is &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 암호화가 수행되는 경우. 그것은이다 &lt;code&gt;false&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b115b1ae7fa7943e2604056f2ecd826dceada9e" translate="yes" xml:space="preserve">
          <source>Is a list of column numbers in the case of a &lt;code&gt;get&lt;/code&gt; operation, and a list of column numbers and values in the case of a &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 조작 의 경우 열 번호 목록이고 &lt;code&gt;set&lt;/code&gt; 조작 의 경우 열 번호 및 값 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="58f4eb42bb30362fe7878dc6d1c4495841ad13d1" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the meas.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">도구에서 제공하는 meas.sh.skel 스켈레톤 스크립트를 수정하여 실행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c23fe05a88d02257549454dd15123c24fa32ea77" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the mstone1.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">도구에서 제공하는 mstone1.sh.skel 스켈레톤 스크립트를 수정하여 실행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="87198e2f1c7806f1ad60ae76ac1d595598bf98a2" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;height&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;height&lt;/code&gt; 가 정의되어 있으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="269a41e3fe559c0e05b304e7b6c27b5566c39389" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;width&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 가 정의되어 있으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffe57a12bbaf259c034632c80ca23397143420b7" translate="yes" xml:space="preserve">
          <source>Is it possible to reduce the number of times the function is called?</source>
          <target state="translated">함수 호출 횟수를 줄일 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="460929b5d588ad61c8de03280e78c7d56b2a232e" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_event&lt;/code&gt; when the message &lt;code&gt;Msg&lt;/code&gt; arrives.</source>
          <target state="translated">메시지 &lt;code&gt;Msg&lt;/code&gt; 가 도착하면 &lt;code&gt;gen_server&lt;/code&gt; 및 &lt;code&gt;gen_event&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cc97fc3f4fc4dc1bf68aae6f4b7ffaa2bb517cc" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; when a &lt;code&gt;{continue,Continuation}&lt;/code&gt; tuple is returned from the callback module.</source>
          <target state="translated">콜백 모듈에서 &lt;code&gt;{continue,Continuation}&lt;/code&gt; 튜플이 반환 될 때 &lt;code&gt;gen_server&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e898ead58a9e871bab718f1e84f37b0b14af8665" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; when a &lt;code&gt;{noreply,...}&lt;/code&gt; tuple is returned from the callback module.</source>
          <target state="translated">콜백 모듈에서 &lt;code&gt;{noreply,...}&lt;/code&gt; 튜플이 반환 될 때 &lt;code&gt;gen_server&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="228974dc1e2ee8c166ab5346a104e82ff7c3810f" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_server&lt;/code&gt; when the reply &lt;code&gt;Msg&lt;/code&gt; is sent back to &lt;code&gt;To&lt;/code&gt; by returning a &lt;code&gt;{reply,...}&lt;/code&gt; tuple from the callback module.</source>
          <target state="translated">콜백 모듈에서 &lt;code&gt;{reply,...}&lt;/code&gt; 튜플을 반환 하여 응답 &lt;code&gt;Msg&lt;/code&gt; 가 &lt;code&gt;To&lt;/code&gt; 로 다시 전송 될 때 &lt;code&gt;gen_server&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e74227d0a2fe296366515d24df1da708c9888f70" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when a timeout zero action inserts event &lt;code&gt;Event&lt;/code&gt; in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="translated">timeout zero action이 &lt;code&gt;State&lt;/code&gt; 에 이벤트 &lt;code&gt;Event&lt;/code&gt; 를 삽입 할 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ff83bfe286bb6329b89d051e527a883c039d588" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when it terminates with reason &lt;code&gt;Reason&lt;/code&gt; in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 상태가 &lt;code&gt;State&lt;/code&gt; 인이유 와 함께 종료 될 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="294a5b48153239c37765e39a931950c322e99aa9" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the action &lt;code&gt;Action&lt;/code&gt; starts a timer in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Action&lt;/code&gt; 이 &lt;code&gt;State&lt;/code&gt; 에서 타이머를 시작할 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="071d8e95d779e01785b0a3c05e94ce0fe7b67644" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the first state &lt;code&gt;State&lt;/code&gt; is entered.</source>
          <target state="translated">첫 번째 상태 &lt;code&gt;State&lt;/code&gt; 가 입력 될 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5f49c2b43436a344fa100ba7cd9b9f4394a258d" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Event&lt;/code&gt; arrives in state &lt;code&gt;State&lt;/code&gt; as the first event after a code change.</source>
          <target state="translated">메시지 &lt;code&gt;Event&lt;/code&gt; 가 코드 변경 후 첫 번째 이벤트로 &lt;code&gt;State&lt;/code&gt; 에 도착하면 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="be78ba4038f711f408995f0478a8c603d217458b" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Event&lt;/code&gt; is consumed in state &lt;code&gt;State&lt;/code&gt;. &lt;code&gt;NextState&lt;/code&gt; is the new state.</source>
          <target state="translated">메시지 &lt;code&gt;Event&lt;/code&gt; 가 &lt;code&gt;State&lt;/code&gt; 상태에서 &lt;code&gt;gen_statem&lt;/code&gt; 때 gen_statem에 의해 생성됩니다 . &lt;code&gt;NextState&lt;/code&gt; 는 새로운 상태입니다.</target>
        </trans-unit>
        <trans-unit id="9e7103dc771c5867d2888c1c26ca98a43ac20ce8" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Event&lt;/code&gt; is postponed in state &lt;code&gt;State&lt;/code&gt;. &lt;code&gt;NextState&lt;/code&gt; is the new state.</source>
          <target state="translated">메시지 &lt;code&gt;Event&lt;/code&gt; 가 &lt;code&gt;State&lt;/code&gt; 상태에서 연기 될 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 . &lt;code&gt;NextState&lt;/code&gt; 는 새로운 상태입니다.</target>
        </trans-unit>
        <trans-unit id="bfb861ed4a841ceaed35aa2f090480bc6b20d264" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the message &lt;code&gt;Msg&lt;/code&gt; arrives in state &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="translated">메시지 &lt;code&gt;Msg&lt;/code&gt; 가 &lt;code&gt;State&lt;/code&gt; 상태에 도착하면 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3e32c5ff6e17908a1ac3d4af8b673dfb7f78b40" translate="yes" xml:space="preserve">
          <source>Is produced by &lt;code&gt;gen_statem&lt;/code&gt; when the reply &lt;code&gt;Msg&lt;/code&gt; is sent back to &lt;code&gt;To&lt;/code&gt; by returning a &lt;code&gt;{reply,To,Msg}&lt;/code&gt; action from the callback module.</source>
          <target state="translated">콜백 모듈에서 &lt;code&gt;{reply,To,Msg}&lt;/code&gt; 작업을 반환 하여 응답 &lt;code&gt;Msg&lt;/code&gt; 가 &lt;code&gt;To&lt;/code&gt; 로 다시 전송 될 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e288cb6c9e74155297a40b276058aa6236c59a1c" translate="yes" xml:space="preserve">
          <source>Is the actual protocol version. In most cases the protocol version is retrieved from the processed message, but there are exceptions:</source>
          <target state="translated">실제 프로토콜 버전입니다. 대부분의 경우 프로토콜 버전은 처리 된 메시지에서 검색되지만 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0588901bedfe37cbeecafd41fb2d74795460658" translate="yes" xml:space="preserve">
          <source>Is the flex scanner reentrant or not.</source>
          <target state="translated">플렉스 스캐너가 재진입입니까?</target>
        </trans-unit>
        <trans-unit id="1e9df40deeb13aac31ab4026e6e08e1f63bbae21" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">과 동일 &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="119f8a66ca64a5694cc3478ae4de46bcaf1a9423" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">동일하다 &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3bd9e6b2f2c505e7347d749868eb9820f223c7" translate="yes" xml:space="preserve">
          <source>Is to be called by a client channel process to request that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end.</source>
          <target state="translated">클라이언트 채널 프로세스에 의해 호출되어 사용자 기본 쉘 (일반적으로 Unix 시스템의 / etc / passwd에 정의 됨)이 서버 측에서 실행되도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="7ceeac9a5465ffa310db9af05a50178436138dfb" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process for requesting to execute a predefined subsystem on the server.</source>
          <target state="translated">서버에서 사전 정의 된 서브 시스템 실행을 요청하기 위해 클라이언트 채널 프로세스에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c26f3b86fc0054ade9e50cca18683944d8b10a73" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process to request that the server starts executing the given command. The result is several messages according to the following pattern. The last message is a channel close message, as the &lt;code&gt;exec&lt;/code&gt; request is a one-time execution that closes the channel when it is done.</source>
          <target state="translated">서버가 주어진 명령의 실행을 시작하도록 요청하기 위해 클라이언트 채널 프로세스에 의해 호출됩니다. 결과는 다음 패턴에 따라 여러 메시지가 나타납니다. 마지막 메시지는 &lt;code&gt;exec&lt;/code&gt; 요청이 완료되면 채널을 닫는 일회성 실행이므로 채널 닫기 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="0f5f5d78eb634db530f821ffb8bb8f751e62bff8" translate="yes" xml:space="preserve">
          <source>Is to be called by a server-channel process to send the exit status of a command to the client.</source>
          <target state="translated">서버의 채널 프로세스에서 호출하여 명령의 종료 상태를 클라이언트에 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d48b86257b47b5c4e3321d39134c0623cc1ea274" translate="yes" xml:space="preserve">
          <source>Is to be called by client- and server-channel processes to send data to each other.</source>
          <target state="translated">클라이언트와 서버 채널 프로세스가 서로에게 데이터를 보내기 위해 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="58c7c3af31214a2559fd6c1a8a5a15f560200d51" translate="yes" xml:space="preserve">
          <source>Is to be used as argument to &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;     Will be the return value of &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; 인수로 사용됩니다. &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt; 의 반환 값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="797fbc2978e0717dd29a9c7b419f35b1add8ae5d" translate="yes" xml:space="preserve">
          <source>Is to be used together with &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt; 과 함께 사용</target>
        </trans-unit>
        <trans-unit id="82fbc73aac01b54be4b187e714699ce8bf8833b0" translate="yes" xml:space="preserve">
          <source>Is-set-ok Operation</source>
          <target state="translated">Is-set-ok 작동</target>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="cad8c95e87d4c8212862db03444550588eb9575a" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get next&lt;/code&gt; request.</source>
          <target state="translated">&lt;code&gt;get next&lt;/code&gt; SNMP 동기화 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="341f83a51a550d204d993e9fdbc3e49fbf2fc850" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get&lt;/code&gt; request.</source>
          <target state="translated">동기식 SNMP &lt;code&gt;get&lt;/code&gt; 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="8c7f616c91a41fcdcd984c210b1ad39f21a4abe5" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;set&lt;/code&gt; request.</source>
          <target state="translated">동기 SNMP &lt;code&gt;set&lt;/code&gt; 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="0768892d2762d9ec323c2e61d80bb2d335f194dd" translate="yes" xml:space="preserve">
          <source>Issuing this command starts the timer for this trace if option &lt;code&gt;timer&lt;/code&gt; is specified with &lt;code&gt;tracer/2&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;timer&lt;/code&gt; 가 &lt;code&gt;tracer/2&lt;/code&gt; 로 지정된 경우이 명령을 실행하면이 추적에 대한 타이머가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="527b024e0f1be9518973bad0f8b1a28cfc553cd1" translate="yes" xml:space="preserve">
          <source>It F is a family, it holds that F is a subset of &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt;. Equality holds if &lt;code&gt;union_of_family(F)&lt;/code&gt; is a subset of &lt;code&gt;domain(F)&lt;/code&gt;.</source>
          <target state="translated">F는 패밀리이며, F는 &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt; 의 하위 세트입니다 . &lt;code&gt;union_of_family(F)&lt;/code&gt; 가 &lt;code&gt;domain(F)&lt;/code&gt; 의 하위 집합 인 경우 동등성이 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="348ecbd21ed63b96be9eb151353dced54f040940" translate="yes" xml:space="preserve">
          <source>It allows other tables to be replicated to this node.</source>
          <target state="translated">다른 테이블을이 노드에 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db00fe5a5a8e9c911935cedb14376bb72459b7b7" translate="yes" xml:space="preserve">
          <source>It allows the handler to remove internal data fields from its configuration data before it is returned to the caller.</source>
          <target state="translated">핸들러가 호출자에게 리턴되기 전에 구성 데이터에서 내부 데이터 필드를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502cbb23b6da4d09ac652d118086581df05059bf" translate="yes" xml:space="preserve">
          <source>It also initializes some SNMP counters.</source>
          <target state="translated">또한 일부 SNMP 카운터를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0d3f428d2936ea84cb0649cae0490ba763c4555f" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;run_erl&lt;/code&gt;, which sets up things so the operator can attach to the system.</source>
          <target state="translated">운영자가 시스템에 연결할 수 있도록 설정하는 &lt;code&gt;run_erl&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6560322fa3ad293d5b242b322f5dac4de01df8c8" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;start_erl&lt;/code&gt;, which calls the correct version of &lt;code&gt;erlexec&lt;/code&gt; (which is located in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt;) with the correct &lt;code&gt;boot&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; files.</source>
          <target state="translated">그것은 호출 &lt;code&gt;start_erl&lt;/code&gt; 의 올바른 버전 호출 &lt;code&gt;erlexec&lt;/code&gt; (에 위치한 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt; 올바른로) &lt;code&gt;boot&lt;/code&gt; 및 &lt;code&gt;config&lt;/code&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="3c0fc93fb15a2633f7d6c853cf154a0edd87bf6a" translate="yes" xml:space="preserve">
          <source>It can also be used from inside an Erlang program. If this ASN.1 code is defined in ASN.1 module &lt;code&gt;Values&lt;/code&gt;, the ASN.1 value &lt;code&gt;tt&lt;/code&gt; can be reached from Erlang as a function call to &lt;code&gt;'Values':tt()&lt;/code&gt; as in the following example:</source>
          <target state="translated">Erlang 프로그램 내부에서도 사용할 수 있습니다. 이 ASN.1 코드가 ASN.1 모듈 &lt;code&gt;Values&lt;/code&gt; 에 정의 된 경우 다음 예제와 같이 Erlang에서 ASN.1 값 &lt;code&gt;tt&lt;/code&gt; 에 &lt;code&gt;'Values':tt()&lt;/code&gt; 대한 함수 호출로 도달 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cab601fee61bbc23a1da1dd5afb684daa2673400" translate="yes" xml:space="preserve">
          <source>It can be accessed as follows:</source>
          <target state="translated">다음과 같이 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77546f4819cb51bf45faf9651c89e8f35e71626" translate="yes" xml:space="preserve">
          <source>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</source>
          <target state="translated">로컬 노드에서 빠른 읽기 작업을 수행하기 위해 데이터를 자주 읽지 만 거의 쓰지 않는 분산 응용 프로그램에 대한 테이블 복제본을 만드는 것이 유리할 수 있습니다. 복제의 주요 단점은 데이터 쓰기 시간이 늘어난다는 것입니다. 테이블에 두 개의 복제본이 있으면 모든 쓰기 작업에서 두 ​​테이블 복제본에 모두 액세스해야합니다. 이러한 쓰기 작업 중 하나는 네트워크 작업이어야하므로 복제되지 않은 테이블보다 복제 된 테이블에 대한 쓰기 작업을 수행하는 것이 상당히 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="3ecec720b0256b562180425a889c57f1514a840b" translate="yes" xml:space="preserve">
          <source>It can be appropriate to calculate the message digest before calling &lt;code&gt;sign&lt;/code&gt; or &lt;code&gt;verify&lt;/code&gt;, and then use &lt;code&gt;none&lt;/code&gt; as second argument:</source>
          <target state="translated">&lt;code&gt;sign&lt;/code&gt; 또는 &lt;code&gt;verify&lt;/code&gt; 를 호출하기 전에 메시지 요약을 계산 한 다음 두 번째 인수로 &lt;code&gt;none&lt;/code&gt; 을 사용 하는 것이 적절할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="429a02b10011f23201ea705082a6734a13afe1dd" translate="yes" xml:space="preserve">
          <source>It can be required that your code must run on a variety of OTP installations of different OTP releases. If so, you cannot use the new API out of the box, as it will not be available on releases before OTP 18. The solution is &lt;strong&gt;not&lt;/strong&gt; to avoid using the new API, as your code would then not benefit from the scalability and accuracy improvements made. Instead, use the new API when available, and fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable.</source>
          <target state="translated">다른 OTP 릴리스의 다양한 OTP 설치에서 코드를 실행해야 할 수도 있습니다. 그렇다면이 OTP (18) 전에 릴리스에서 사용할 수 없습니다, 당신은이 솔루션은, 상자의 새 API를 사용할 수 &lt;strong&gt;없는&lt;/strong&gt; 코드는 다음 확장 성 및 정확도 개선에서 혜택을받지 것처럼, 새로운 API를 사용하지 만든. 대신 사용 가능한 경우 새 API를 사용 하고 새 API를 사용할 수없는 경우 &lt;code&gt;erlang:now/0&lt;/code&gt; 으로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfb69fb6c9632871f7941143462a0957b50d8dd0" translate="yes" xml:space="preserve">
          <source>It can be seen that the DBMS was initiated from a regular text file.</source>
          <target state="translated">DBMS가 일반 텍스트 파일에서 시작되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75e6728c619228a8a187725396b17bac62286a9" translate="yes" xml:space="preserve">
          <source>It can be useful to find the maximum and minimum temperature in lists like this. Before extending the program to do this, let us look at functions for finding the maximum value of the elements in a list:</source>
          <target state="translated">이와 같은 목록에서 최대 및 최소 온도를 찾는 것이 유용 할 수 있습니다. 이를 위해 프로그램을 확장하기 전에 목록에서 요소의 최대 값을 찾는 함수를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a8817b3a522907eb1d028eaf50da33a71ee687b3" translate="yes" xml:space="preserve">
          <source>It can be verified that sharing will be lost if the data is inserted into an Ets table:</source>
          <target state="translated">데이터가 Ets 테이블에 삽입되면 공유가 유실되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f936533cc1f942a4c17074d1665c908f8eec35" translate="yes" xml:space="preserve">
          <source>It can be:</source>
          <target state="translated">그것은 될 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="16e18e41dba30df6f2a27da6db7356bd2d51bd66" translate="yes" xml:space="preserve">
          <source>It can optionally also export some, or all, of the following:</source>
          <target state="translated">선택적으로 다음 중 일부 또는 전부를 내보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d39574d1fe984a33b1d8417902ff2e4fa04c224" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="translated">때때로 자신의 상태 머신에 이벤트를 생성 할 수있는 것이 유리할 수 있습니다. 이는 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="955cb8381bd4c10a03ed96cbdf6e946485df3b5c" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="translated">자신의 상태 머신에 이벤트를 생성 할 수 있으면 도움이 될 수 있습니다. 이는 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; &lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt; 로 수행 할 수 있습니다 . &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0df60d291abc2f1c1b6553af06070513493b119c" translate="yes" xml:space="preserve">
          <source>It can sometimes be helpful to enable trace for a specified period of time (for example, to monitor a system for 24 hours or half a second). This can be done with option &lt;code&gt;{timer, TimerSpec}&lt;/code&gt;. If &lt;code&gt;TimerSpec&lt;/code&gt; has the form of &lt;code&gt;MSec&lt;/code&gt;, the trace is stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds using &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt;. If more options are provided (&lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; is called instead with &lt;code&gt;Opts&lt;/code&gt; as argument.</source>
          <target state="translated">지정된 시간 동안 추적을 활성화하는 것이 도움이 될 수 있습니다 (예 : 24 시간 또는 0.5 초 동안 시스템을 모니터링하는 경우). &lt;code&gt;{timer, TimerSpec}&lt;/code&gt; 옵션으로이를 수행 할 수 있습니다 . 경우 &lt;code&gt;TimerSpec&lt;/code&gt; 이 의 형태가 &lt;code&gt;MSec&lt;/code&gt; , 추적은 후 정지 &lt;code&gt;MSec&lt;/code&gt; 사용하여 밀리 초 &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt; . 더 많은 옵션이 제공되면 ( &lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt; ), &lt;code&gt;Opts&lt;/code&gt; 를 인수로 사용하여 &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; 이 대신 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1166234dedafbc9026660c1e71ce391bf682d71c" translate="yes" xml:space="preserve">
          <source>It can vary from case to case which combination of selective/complete decode or exclusive/part decode is the fastest.</source>
          <target state="translated">선택적 / 완전한 디코딩 또는 배타적 / 부분 디코딩의 조합이 가장 빠른 경우에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21d9b21f8fd67733cf908cf5de319a682227acf" translate="yes" xml:space="preserve">
          <source>It cannot retrieve external entities on the Internet by a URL reference, only resources in the local file system.</source>
          <target state="translated">URL 참조로 인터넷에서 외부 엔티티를 검색 할 수없고 로컬 파일 시스템의 자원 만 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ad56b9e963d65cee1d6e784ab67ae9a7a2c796" translate="yes" xml:space="preserve">
          <source>It causes &lt;code&gt;Mnesia&lt;/code&gt; to try to contact the node at startup of disc-full nodes.</source>
          <target state="translated">그것은 원인 &lt;code&gt;Mnesia&lt;/code&gt; 을 디스크 전체 노드의 시작시 노드에 접속을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f72ebd5459698111bb78002fb36494deb48145f4" translate="yes" xml:space="preserve">
          <source>It could also be a late reply to a synchronous request.</source>
          <target state="translated">동기 요청에 대한 늦은 응답 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d82ac91e7712df5bdf96a55a2294646a1789f2" translate="yes" xml:space="preserve">
          <source>It defines the version of the instruction set (which will be included in the code header in the BEAM code). Theoretically, the version could be bumped, and all instructions changed. In practice, we would have two support two instruction sets in the runtime system for at least two releases, so it will probably never happen in practice.</source>
          <target state="translated">명령 세트의 버전을 정의합니다 (BEAM 코드의 코드 헤더에 포함됨). 이론적으로 버전이 충돌하고 모든 지침이 변경 될 수 있습니다. 실제로는 두 개 이상의 릴리스에 대해 런타임 시스템에서 두 개의 명령 세트를 지원하므로 실제로는 발생하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c3698cc734ccb5f61d3ae21369086bfe0bd5a1e8" translate="yes" xml:space="preserve">
          <source>It does not really implement any management capabilities by itself. That is up to the &lt;strong&gt;user&lt;/strong&gt;.</source>
          <target state="translated">실제로 자체적으로 관리 기능을 구현하지는 않습니다. 그것은 &lt;strong&gt;사용자&lt;/strong&gt; 에게 달려 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1c0facb3f9f742f5d022d43754416108d7a651fc" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition_option() &lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition_option() &lt;/a&gt;&lt;/code&gt; 설정하지 않고 대신 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 에서 응답을 기다리는 호출자에게 응답 합니다. &lt;code&gt;From&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 호출에서 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; 인수의 용어 여야합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f06f024f140f97af334f2f96d37458dba2e893a" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; 설정하지 않고 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 에서 응답을 기다리는 호출자에게 응답 합니다. &lt;code&gt;From&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 에 대한 호출 에서 인수 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; 의 용어 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="f569904cdf74c64d61502b40cdf52a64e986cfae" translate="yes" xml:space="preserve">
          <source>It evaluates to &lt;code&gt;true&lt;/code&gt; if submitted to the Erlang daemon started in &lt;code&gt;&lt;a href=&quot;#start-daemon-step3&quot;&gt;Step 3&lt;/a&gt;&lt;/code&gt; above:</source>
          <target state="translated">위의 &lt;code&gt;&lt;a href=&quot;#start-daemon-step3&quot;&gt;Step 3&lt;/a&gt;&lt;/code&gt; 에서 시작된 Erlang 데몬에 제출 하면 &lt;code&gt;true&lt;/code&gt; 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a9d83d94c6d539b05132d871e1c9c5c83c742ef" translate="yes" xml:space="preserve">
          <source>It follows all the pointers from the root-set to the heap and copies each term word by word to the &lt;strong&gt;to space&lt;/strong&gt;.</source>
          <target state="translated">루트 세트에서 힙까지의 모든 포인터를 따라 가며 각 용어를 단어 단위 &lt;strong&gt;로 공백으로&lt;/strong&gt; 복사 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7017aa44c3506907262780fe0caea30cac852593" translate="yes" xml:space="preserve">
          <source>It has been implemented on top of the User Datagram protocol (UDP) so it may be used to move files between machines on different networks implementing UDP. It is designed to be small and easy to implement. Therefore, it lacks most of the features of a regular FTP. The only thing it can do is read and write files (or mail) from/to a remote server. It cannot list directories, and currently has no provisions for user authentication.</source>
          <target state="translated">UDP (User Datagram Protocol) 위에 구현되었으므로 UDP를 구현하는 다른 네트워크의 시스템간에 파일을 이동하는 데 사용될 수 있습니다. 작고 구현하기 쉽도록 설계되었습니다. 따라서 일반 FTP의 기능 대부분이 부족합니다. 그것이 할 수있는 유일한 것은 원격 서버와 파일을 읽거나 쓰는 것입니다. 디렉토리를 나열 할 수 없으며 현재 사용자 인증에 대한 규정이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f8d75bfb90a8936251b79f719fa6e9b6f94c3d3" translate="yes" xml:space="preserve">
          <source>It has previously been shown that each table has a number of system attributes, such as &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">이전에는 각 테이블에 &lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 과 같은 여러 시스템 속성이있는 것으로 나타났습니다 .</target>
        </trans-unit>
        <trans-unit id="bbd5032f06df0ef2f2a99e589085d981c5bc3619" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;true&lt;/code&gt; if the predicate applied to all elements in the list is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">목록의 모든 요소에 적용된 술어 가 &lt;code&gt;true&lt;/code&gt; 인 경우에 &lt;code&gt;true&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0472f06f57f61fb910d5f2746c6db12d6bf0beef" translate="yes" xml:space="preserve">
          <source>It is a channel callback module that implements a shell and command execution. The shell's read-eval-print loop can be customized, using the option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt;. This means less work than implementing an own CLI channel. If &lt;code&gt;ssh_cli&lt;/code&gt; is set to &lt;code&gt;no_cli&lt;/code&gt;, the CLI channels like &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are disabled and only subsystem channels are allowed.</source>
          <target state="translated">쉘 및 명령 실행을 구현하는 채널 콜백 모듈입니다. 쉘의 읽기 평가 후면 인쇄 루프가 옵션을 사용하여 사용자 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; . 이는 자체 CLI 채널을 구현하는 것보다 적은 작업을 의미합니다. 경우 &lt;code&gt;ssh_cli&lt;/code&gt; 가 설정되어 &lt;code&gt;no_cli&lt;/code&gt; 의 CLI의 같은 채널 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 장애인 전용 서브 채널이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9cfea932baea2333d069d06996afd05ae69495a2" translate="yes" xml:space="preserve">
          <source>It is a dump from an old OTP release in which this item was not written.</source>
          <target state="translated">이 항목이 작성되지 않은 이전 OTP 릴리스의 덤프입니다.</target>
        </trans-unit>
        <trans-unit id="e5182044a6ea3fa91dca2975296e4a746a6452be" translate="yes" xml:space="preserve">
          <source>It is a major source of confusion exactly which characters will be percent-encoded. In order to make it easier to answer this question the library provides a utility function, &lt;code id=&quot;percent_encoding&quot;&gt;&lt;a href=&quot;uri_string#allowed_characters-0&quot;&gt;uri_string:allowed_characters/0 &lt;/a&gt;&lt;/code&gt;, that lists the allowed set of characters in each major URI component, and also in the most important standard character sets.</source>
          <target state="translated">정확히 어떤 문자가 퍼센트 인코딩 될 것인지 혼란의 주요 원인입니다. 이 질문에 더 쉽게 답할 수 있도록 라이브러리는 각 주요 URI 구성 요소와 가장 중요한 표준 문자 집합에 허용 된 문자 집합을 나열 하는 유틸리티 함수 &lt;code id=&quot;percent_encoding&quot;&gt;&lt;a href=&quot;uri_string#allowed_characters-0&quot;&gt;uri_string:allowed_characters/0 &lt;/a&gt;&lt;/code&gt; 을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="e3c2eb9542657da53e8c70e8a085ab3bd63983e1" translate="yes" xml:space="preserve">
          <source>It is advised for compilers to remove all non-deterministic information if the &lt;code&gt;deterministic&lt;/code&gt; option is supported and it was supplied by the user.</source>
          <target state="translated">&lt;code&gt;deterministic&lt;/code&gt; 옵션이 지원되고 사용자가 제공 한 경우 컴파일러는 모든 비 결정적 정보를 제거하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bdc959811bb36191808503a6fa15bf4c4b73e490" translate="yes" xml:space="preserve">
          <source>It is allowed to omit &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Stacktrace&lt;/code&gt;. An omitted &lt;code&gt;Class&lt;/code&gt; is shorthand for &lt;code&gt;throw&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Class&lt;/code&gt; 와 &lt;code&gt;Stacktrace&lt;/code&gt; 를 생략 할 수 있습니다. 생략 된 &lt;code&gt;Class&lt;/code&gt; 는 &lt;code&gt;throw&lt;/code&gt; 의 약자입니다 .</target>
        </trans-unit>
        <trans-unit id="48abed156caaf8fbad6e753b59c7f4527e776ac9" translate="yes" xml:space="preserve">
          <source>It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker.</source>
          <target state="translated">하위 프로세스가 작업자 인 경우 &lt;code&gt;infinity&lt;/code&gt; 로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abf6d7124954bad38d134fedee149371dc306be5" translate="yes" xml:space="preserve">
          <source>It is also assumed that in the home directory of &lt;code&gt;otpuser&lt;/code&gt;, there is a directory named &lt;code&gt;otp&lt;/code&gt;, the full path of which is:</source>
          <target state="translated">그것은 또한의 홈 디렉토리에 있다고 가정 &lt;code&gt;otpuser&lt;/code&gt; 라는 디렉토리가 &lt;code&gt;otp&lt;/code&gt; , 전체 경로는이다 :</target>
        </trans-unit>
        <trans-unit id="9c70f3b40e4a761a37740b02e2f452d7fdd283c0" translate="yes" xml:space="preserve">
          <source>It is also necessary to take care of the types &lt;code&gt;ERL_ERROR&lt;/code&gt; (an error occurred) and &lt;code&gt;ERL_TICK&lt;/code&gt; (alive check from other node, is to be ignored). Other possible types indicate process events such as link, unlink, and exit:</source>
          <target state="translated">또한 &lt;code&gt;ERL_ERROR&lt;/code&gt; (오류가 발생 함) 및 &lt;code&gt;ERL_TICK&lt;/code&gt; (다른 노드의 점검은 무시 됨) 유형을 처리해야합니다. 다른 가능한 유형은 링크, 링크 해제 및 종료와 같은 프로세스 이벤트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c5a50cd1bdb197fcc39af462f4c2f62a0631dfb0" translate="yes" xml:space="preserve">
          <source>It is also of interest to know the relation is between a complete decode, an exclusive decode followed by &lt;code&gt;decode_part&lt;/code&gt; of the excluded parts, and a selective decode followed by a complete decode. Some situations can be compared to this simulation, for example, inspect a subvalue and later inspect the entire value. The following table shows figures from this test. The number of loops and the time unit are the same as in the previous test.</source>
          <target state="translated">또한, 완전한 디코드, 배타적 디코드 다음에 배제 된 부분의 &lt;code&gt;decode_part&lt;/code&gt; , 및 선택적 디코드 및 완전한 디코드 사이의 관계를 알고있는 것도 흥미 롭다 . 일부 상황은이 시뮬레이션과 비교할 수 있습니다 (예 : 하위 값 검사 및 나중에 전체 값 검사). 다음 표는이 테스트의 수치를 보여줍니다. 루프 수와 시간 단위는 이전 테스트와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="47109d04235cc55b443f9196149aab3ccf242450" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &lt;code&gt;%else&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;%else&lt;/code&gt; 절 을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="430745d1b00721c91adf6b7795f4d85575fbbdfd" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; directly from the normal Erlang shell prompt:</source>
          <target state="translated">일반적인 Erlang 쉘 프롬프트에서 직접 &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; 를 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b17c759d73ecb8e47a8732d667bdc184b493889c" translate="yes" xml:space="preserve">
          <source>It is also possible to dig deeper and, for example, perform pattern matching on the various reasons for skipped or failed. Notice that &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; tuples are translated into &lt;code&gt;{error,Reason}&lt;/code&gt;. Notice also that if a &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; result is received, the test case was successful, but &lt;code&gt;end_per_testcase&lt;/code&gt; for the case failed.</source>
          <target state="translated">예를 들어 건너 뛰거나 실패한 여러 가지 이유에 대해 더 깊이 파고 패턴 일치를 수행 할 수도 있습니다. 것을 알 수 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; 튜플로 번역 &lt;code&gt;{error,Reason}&lt;/code&gt; . 경우주의 또한 &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; 결과를 수신, 테스트 케이스가 성공하지만, &lt;code&gt;end_per_testcase&lt;/code&gt; 경우에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="f8151f1eae3c7a350004aaaa46abaeee77adbcc2" translate="yes" xml:space="preserve">
          <source>It is also possible to do further processing of parsed XML with xmerl. If you want to change format of the XML document to for instance HTML, text or other XML format you can transform it. There is support for such transformations in xmerl.</source>
          <target state="translated">xmerl을 사용하여 구문 분석 된 XML을 추가로 처리 할 수도 있습니다. XML 문서의 형식을 예를 들어 HTML, 텍스트 또는 다른 XML 형식으로 변경하려는 경우이를 변환 할 수 있습니다. xmerl에서 이러한 변환을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1fb169d7a25eee8232f1cc295837278dd944901e" translate="yes" xml:space="preserve">
          <source>It is also possible to do the same changes in an already running system using the &lt;code&gt;logger&lt;/code&gt; module. Then you do like this:</source>
          <target state="translated">&lt;code&gt;logger&lt;/code&gt; 모듈을 사용하여 이미 실행중인 시스템에서 동일한 변경을 수행 할 수도 있습니다 . 그런 다음 이렇게합니다.</target>
        </trans-unit>
        <trans-unit id="166a98df287ec46c15162d974f22e50c42ef71ea" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch the configuration using &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config()&lt;/a&gt;&lt;/code&gt; 사용하여 구성을 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14975a2ed99f645727531a93c1fa136da016d57c" translate="yes" xml:space="preserve">
          <source>It is also possible to import MIBs from OTP applications in an &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; like fashion with the &lt;code&gt;il&lt;/code&gt; option. Example:</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; 와 같은 방식으로 OTP 응용 프로그램에서 MIB를 가져올 수도 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="9aa704896d79235d85aad0da0fabd9cf784e3fd6" translate="yes" xml:space="preserve">
          <source>It is also possible to make the parser ask for more input tokens when needed if the following call format is used:</source>
          <target state="translated">다음 호출 형식을 사용하는 경우 파서가 필요할 때 더 많은 입력 토큰을 요구하도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c383d15045b8504152e045fd9c571fda9d5f908" translate="yes" xml:space="preserve">
          <source>It is also possible to perform live tracing of a running system by making use of the built-in trace support in the Erlang emulator. These Erlang traces can be directed to files or to ports. See the reference manual for &lt;code&gt;erlang:trace/4&lt;/code&gt;, &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;, &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;ttb&lt;/code&gt; for more info.</source>
          <target state="translated">Erlang 에뮬레이터에서 내장 된 추적 지원을 사용하여 실행중인 시스템의 실시간 추적을 수행 할 수도 있습니다. 이러한 Erlang 추적은 파일 또는 포트로 전달 될 수 있습니다. 자세한 정보는 &lt;code&gt;erlang:trace/4&lt;/code&gt; , &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; , &lt;code&gt;dbg&lt;/code&gt; 및 &lt;code&gt;ttb&lt;/code&gt; 의 참조 매뉴얼을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41ebfd44811c7419cd9574f7d7d60c6961c05cc8" translate="yes" xml:space="preserve">
          <source>It is also possible to push back characters into the input characters with the following returns:</source>
          <target state="translated">다음 리턴을 사용하여 문자를 입력 문자로 푸시 백 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="05fa2dcff8f4128cd8ba172c0c2e9803bd23c257" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to a function defined in a different module, with the following syntax:</source>
          <target state="translated">다음 구문을 사용하여 다른 모듈에 정의 된 함수를 참조 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="20722acbae34522cf86f97ada05f47778507e40b" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section.</source>
          <target state="translated">(? +2)와 같은 참조를 작성하여 나중에 열린 괄호를 참조 할 수도 있습니다. 그러나 참조가 참조 된 괄호 안에 없기 때문에 이들은 재귀적일 수 없습니다. 다음 섹션에서 설명하는 것처럼 항상 비 재귀 서브 루틴 호출입니다.</target>
        </trans-unit>
        <trans-unit id="1bc8e55a741fd982875922535be0a290d5e493ac" translate="yes" xml:space="preserve">
          <source>It is also possible to specify names and values for extra variables that should be sent in the notification, but were not defined in the notification specification.</source>
          <target state="translated">통지에는 보내야하지만 통지 스펙에는 정의되지 않은 추가 변수의 이름과 값을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e96afe727ef3a6cdba9249f88e9858694c628d45" translate="yes" xml:space="preserve">
          <source>It is also possible to trace immediately into the profiling process that creates the raw profile data, that is to short circuit the tracing and profiling steps so that the filesystem is not used.</source>
          <target state="translated">원시 프로파일 데이터를 작성하는 프로파일 링 프로세스, 즉 추적 및 프로파일 링 단계를 단락시켜 파일 시스템이 사용되지 않도록 즉시 추적 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d9bdad443276567d85de0b3d4b695aa8af5458" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process and this section describes how to do that.</source>
          <target state="translated">프로세스가있는 경우 자신 만의 Net을 작성하는 것도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0443424fb9ad4a6013fc87f7edd777ad9e3ed640" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process. The default Net if process is implemented in the module &lt;code&gt;snmpa_net_if&lt;/code&gt; and it uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;.</source>
          <target state="translated">자신의 Net if 프로세스를 작성할 수도 있습니다. 기본 Net if 프로세스는 &lt;code&gt;snmpa_net_if&lt;/code&gt; 모듈에서 구현되며 전송 도메인, 즉 전송 도메인 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 및 / 또는 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 로 UDP를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="38b9346e442ee7340bad67270cc18e9b0d13905f" translate="yes" xml:space="preserve">
          <source>It is also possible, in &lt;code&gt;end_per_group/2&lt;/code&gt;, to check the status of a subgroup (maybe to determine what status the current group is to return). This is as simple as illustrated in the previous example, only the group name is stored in a tuple &lt;code&gt;{group_result,GroupName}&lt;/code&gt;, which can be searched for in the status lists.</source>
          <target state="translated">&lt;code&gt;end_per_group/2&lt;/code&gt; 에서 하위 그룹의 상태를 확인하는 것도 가능 합니다 (현재 그룹이 어떤 상태를 반환할지 결정할 수 있음). 이는 이전 예에서 설명한 것처럼 간단하지만 그룹 이름 만 튜플 &lt;code&gt;{group_result,GroupName}&lt;/code&gt; 에 저장되며 상태 목록에서 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef03b90d92e28fc57662f95ab1cf5a610f370745" translate="yes" xml:space="preserve">
          <source>It is also recommended that the &lt;code&gt;ct.hrl&lt;/code&gt; header file is included in all test suite modules.</source>
          <target state="translated">&lt;code&gt;ct.hrl&lt;/code&gt; 헤더 파일은 모든 테스트 스위트 모듈에 포함되는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="313a7e4451fc081efeaa2c6bb4fb1dfc6f14d0a1" translate="yes" xml:space="preserve">
          <source>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function &lt;code&gt;raise(Name, Amount)&lt;/code&gt;, which adds &lt;code&gt;Amount&lt;/code&gt; to the salary field of a person, is to be implemented as follows:</source>
          <target state="translated">여러 프로세스가 동일한 레코드를 동시에 업데이트하는 경우 트랜잭션 내에서 데이터베이스를 업데이트하는 것도 유용합니다. 예를 들어, 사람의 급여 필드에 &lt;code&gt;Amount&lt;/code&gt; 을 추가하는 &lt;code&gt;raise(Name, Amount)&lt;/code&gt; 함수 는 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="4b6eccdabde840ecd1e02e1dfcae25d7936cafd7" translate="yes" xml:space="preserve">
          <source>It is also worth to keep in mind that programs with timers can behave differently when debugged. This is especially true when stopping the execution of a process (for example, at a breakpoint). Time-outs can then occur in other processes that continue execution as normal.</source>
          <target state="translated">타이머가있는 프로그램은 디버깅 할 때 다르게 동작 할 수 있다는 점도 명심해야합니다. 프로세스 실행을 중지 할 때 (예 : 중단 점에서) 특히 그렇습니다. 그런 다음 정상적으로 실행되는 다른 프로세스에서 시간 초과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de21ba3a5d42796cea74d79d5a22659949031529" translate="yes" xml:space="preserve">
          <source>It is an error if not all of the characters in &lt;code&gt;String&lt;/code&gt; are consumed.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 의 모든 문자를 사용하지 않으면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="1169d92cb2cd8a5d121fb5cf87770320a1885975" translate="yes" xml:space="preserve">
          <source>It is assigned a value in Erlang as follows:</source>
          <target state="translated">다음과 같이 Erlang에 값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b026425ce0c7a9d0f11df724a1d98610d0783ee" translate="yes" xml:space="preserve">
          <source>It is assumed that drivers do not access other drivers. If drivers access each other, they must provide their own mechanism for thread-safe synchronization. Such &quot;inter-driver communication&quot; is strongly discouraged.</source>
          <target state="translated">드라이버는 다른 드라이버에 액세스하지 않는 것으로 가정합니다. 드라이버가 서로 액세스하는 경우 스레드 안전 동기화를위한 고유 한 메커니즘을 제공해야합니다. 이러한 &quot;드라이버 간 통신&quot;은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00523370ed1fef973a609af025d17f8d7fd78abb" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader has done some programming and is familiar with concepts such as data types and programming language syntax.</source>
          <target state="translated">독자가 일부 프로그래밍을 수행했으며 데이터 유형 및 프로그래밍 언어 구문과 같은 개념에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="539ca4643ea98ae299a95a5eae96dbefe42276e2" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language and has a basic understanding of the concepts of using public-keys and digital certificates.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어에 익숙하고 공개 키 및 디지털 인증서 사용의 개념을 기본적으로 이해하고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a6052ded16f1143a2540c6e38a39ca5ce2ceee2c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of &lt;strong&gt;OTP&lt;/strong&gt;, and has a basic understanding of &lt;strong&gt;public keys&lt;/strong&gt;.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, &lt;strong&gt;OTP&lt;/strong&gt; 개념에 익숙하고 &lt;strong&gt;공개 키에&lt;/strong&gt; 대한 기본 지식을 가지고 있다고 가정 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="243320d766e4df468a34184aedf16e004fb9c770" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic knowledge of SNMP.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 SNMP에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="367f5b39b966ad211fd31d9fe4e051b0012e6562" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic understanding of relational databases and SQL.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP의 개념에 익숙하고 관계형 데이터베이스 및 SQL에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c531f58d242ffa0ef29281ed62ced9b43c4c5836" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of and HTTP protocol.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 HTTP 프로토콜에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="226cdb7652f0e63605e771f89f0979cf6a181d4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the FTP protocol.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 FTP 프로토콜에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ffe91dc03e0f170b97f84ca7d684803118d71efd" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the TFTP protocol.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 TFTP 프로토콜에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6ad11381560d09325d3341cb53cee49377ce9e91" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and is familiar with the ASN.1 notation. The ASN.1 notation is documented in the standard definition X.680, which is the primary text. It can also be helpful, but not necessary, to read the standard definitions X.681, X.682, X.683, X.690, and X.691.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP 개념에 익숙하고 ASN.1 표기법에 익숙하다고 가정합니다. ASN.1 표기법은 기본 텍스트 인 표준 정의 X.680에 문서화되어 있습니다. 표준 정의 X.681, X.682, X.683, X.690 및 X.691을 읽는 것이 도움이되지만 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f994e3d36186bc56a3b0c41d4317147ad16d939f" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, system development principles, and database management systems.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, 시스템 개발 원칙 및 데이터베이스 관리 시스템에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c80c2b6f4e39beead5852bafd919144c58cd0f95" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of SSL/TLS/DTLS.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어, OTP의 개념에 익숙하고 SSL / TLS / DTLS에 대한 기본 지식을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="537e5cc7cbceb70acccab6e7e1e372b187bbe2dc" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of TLS/DTLS.</source>
          <target state="translated">독자는 OTP의 개념 인 Erlang 프로그래밍 언어에 익숙하고 TLS / DTLS에 대한 기본적인 이해가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="196722391e42a0afccee28b3efb0c6e7a2974b84" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language.</source>
          <target state="translated">독자는 Erlang 프로그래밍 언어에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b881451c83c7ede35a49713311b8b3c77d21da3f" translate="yes" xml:space="preserve">
          <source>It is assumed that tracing has already been enabled (see &lt;code&gt;enable_trace&lt;/code&gt; above).</source>
          <target state="translated">추적이 이미 사용 가능하다고 가정 &lt;code&gt;enable_trace&lt;/code&gt; 위의 enable_trace 참조).</target>
        </trans-unit>
        <trans-unit id="fbce7d0b5c1d3d362c2e0e3170d2a81ddcc3cae0" translate="yes" xml:space="preserve">
          <source>It is assumed that you are a skilled Erlang programmer, familiar with concepts such as Erlang data types, processes, messages, and error handling.</source>
          <target state="translated">Erlang 데이터 유형, 프로세스, 메시지 및 오류 처리와 같은 개념에 익숙한 숙련 된 Erlang 프로그래머라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="46d05879b990c1b42f80173e3ce33f9af16334ea" translate="yes" xml:space="preserve">
          <source>It is assumed that you are familiar with the Erlang programming language and the OTP concepts.</source>
          <target state="translated">Erlang 프로그래밍 언어 및 OTP 개념에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c59fc60f5301a42fa897f9e86ad129262fbe9775" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a good understanding of drivers.</source>
          <target state="translated">운전자에 대해 잘 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="57d587d7dcd33bf268c53e8c295b7bbd98dd5a25" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a working Erlang/OTP system structured according to the OTP design principles.</source>
          <target state="translated">OTP 설계 원칙에 따라 작동하는 Erlang / OTP 시스템이 작동한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="da7170d41c4bbfe66ba486c027eb9dc9f166d049" translate="yes" xml:space="preserve">
          <source>It is assumed to be called inside the property called by &lt;code&gt;&lt;a href=&quot;#quickcheck-2&quot;&gt;quickcheck/2&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#quickcheck-2&quot;&gt;quickcheck/2&lt;/a&gt;&lt;/code&gt; 에 의해 호출 된 속성 내에서 호출되는 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="65b8a74dc8b2985b7d8ff2f06c5800ab5b031e0b" translate="yes" xml:space="preserve">
          <source>It is called before scheme string gets converted into scheme atom and thus possible atom leak could be prevented</source>
          <target state="translated">체계 문자열이 체계 원자로 변환되기 전에 호출되므로 원자 누출을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9008c50a0a551cbb25d9ec24896b64ea9a564251" translate="yes" xml:space="preserve">
          <source>It is common that ASN.1 modules import defined types, values, and other entities from another ASN.1 module.</source>
          <target state="translated">ASN.1 모듈은 정의 된 유형, 값 및 기타 엔티티를 다른 ASN.1 모듈에서 가져 오는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="f3c0695294a6b1c0df2bd4d07de88a1e3a54c6dd" translate="yes" xml:space="preserve">
          <source>It is composed of lines as for &lt;code&gt;&lt;a href=&quot;https://man.openbsd.org/sshd#AUTHORIZED_KEYS_FILE_FORMAT&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://man.openbsd.org/sshd#AUTHORIZED_KEYS_FILE_FORMAT&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 의 경우 다음 과 같이 행으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="366ff05e8481f1b50ee5d8b0ae1d4dea2764c12b" translate="yes" xml:space="preserve">
          <source>It is composed of lines as for &lt;code&gt;&lt;a href=&quot;https://man.openbsd.org/sshd#SSH_KNOWN_HOSTS_FILE_FORMAT&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://man.openbsd.org/sshd#SSH_KNOWN_HOSTS_FILE_FORMAT&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 의 경우 다음 과 같이 행으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="30e9e1b630f3f988db69ac953192881fde572b35" translate="yes" xml:space="preserve">
          <source>It is crucial to clarify that a</source>
          <target state="translated">다음 사항을 명확히하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="84117e18953c312000f68fd2f9a76688512ad635" translate="yes" xml:space="preserve">
          <source>It is easy to design applications that use SNMP to manipulate and control the system. &lt;code&gt;Mnesia&lt;/code&gt; provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a &lt;code&gt;Mnesia&lt;/code&gt; table. The default value is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">SNMP를 사용하여 시스템을 조작하고 제어하는 ​​응용 프로그램을 쉽게 설계 할 수 있습니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 SNMP 제어 응용 프로그램을 구성하는 논리 테이블과 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 을 구성하는 실제 데이터를 직접 매핑 합니다. 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cce76fb9ee4c72d8c84f9435e857ad958e3bb420" translate="yes" xml:space="preserve">
          <source>It is easy to make mistakes when registering sub-agents and this activity should be done carefully. For example, a strange behaviour would result from the following configuration:</source>
          <target state="translated">하위 에이전트를 등록 할 때 실수를 저지르기 쉽고이 활동은 신중하게 수행해야합니다. 예를 들어 다음 구성에서 이상한 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4c9710b1e208fb15c3da52130d4225c07e26a51" translate="yes" xml:space="preserve">
          <source>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function &lt;code&gt;get_emps/2&lt;/code&gt; is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</source>
          <target state="translated">정규화 된 모델 대신 비정규 화 된 데이터 모델을 사용하면 더 빠르게 실행되는 코드의 예를 쉽게 보여줄 수 있습니다. 주된 이유는 더 적은 테이블이 필요하기 때문입니다. 따라서 조인 작업에서 다른 테이블의 데이터를보다 쉽게 ​​결합 할 수 있습니다. 이전 예에서 &lt;code&gt;get_emps/2&lt;/code&gt; 함수 는 결합 조작에서 하나의 단일 테이블에 대한 선택 및 프로젝션으로 구성된 단순 조회로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="da800d6ee148efa5e9b76c02de805a669c995873" translate="yes" xml:space="preserve">
          <source>It is encouraged to omit empty directories.</source>
          <target state="translated">빈 디렉토리는 생략하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f598ee38e63f95f13ae4c91139c94c9acddbba8b" translate="yes" xml:space="preserve">
          <source>It is enough to initialize &lt;code&gt;myKey&lt;/code&gt; once for each driver instance.</source>
          <target state="translated">각 드라이버 인스턴스에 대해 &lt;code&gt;myKey&lt;/code&gt; 를 한 번만 초기화 하면 충분 합니다.</target>
        </trans-unit>
        <trans-unit id="09d13ede3ec03425733048bb49466428e4cde9a4" translate="yes" xml:space="preserve">
          <source>It is expected that the type language described in this section supersedes and replaces the purely comment-based &lt;code&gt;@type&lt;/code&gt; and &lt;code&gt;@spec&lt;/code&gt; declarations used by EDoc.</source>
          <target state="translated">이 섹션에 설명 된 유형 언어는 &lt;code&gt;@spec&lt;/code&gt; 사용되는 순수 주석 기반 &lt;code&gt;@type&lt;/code&gt; 및 @spec 선언을 대체하고 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="bd88b807c9b8b49f6a04c0814a09c4643a76b579" translate="yes" xml:space="preserve">
          <source>It is fairly easy to write a generator which, each time it is called, either produces an empty list if it is done, or otherwise produces a list containing a single test case plus a new generator which will produce the rest of the tests. This demonstrates the basic pattern:</source>
          <target state="translated">생성 될 때마다 빈 목록을 생성하거나 단일 테스트 케이스와 나머지 테스트를 생성하는 새로운 생성기를 포함하는 목록을 생성하는 생성기를 작성하는 것은 매우 쉽습니다. 기본 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="216d3558427ea98e53bf41b5f47e9b9d46bf1da8" translate="yes" xml:space="preserve">
          <source>It is good programming practice, but not mandatory, to ensure that a macro definition is a valid Erlang syntactic form.</source>
          <target state="translated">매크로 정의가 유효한 Erlang 구문 형식인지 확인하는 것은 좋은 프로그래밍 관행이지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="20fc259cbb6b4c9e5e515f22c485c458685813f7" translate="yes" xml:space="preserve">
          <source>It is implemented like this:</source>
          <target state="translated">다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="658c926a7a3ff092c88e185ba8a44d03268b9b65" translate="yes" xml:space="preserve">
          <source>It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when &lt;code&gt;init_table/2&lt;/code&gt; returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the &lt;code&gt;open_file/2&lt;/code&gt; option &lt;code&gt;min_no_slots&lt;/code&gt; and returned by the &lt;code&gt;info/2&lt;/code&gt; item &lt;code&gt;no_slots&lt;/code&gt;. See also option &lt;code&gt;min_no_slots&lt;/code&gt; below.</source>
          <target state="translated">테이블에 객체를위한 충분한 수의 슬롯이 있어야합니다. 그렇지 않으면, &lt;code&gt;init_table/2&lt;/code&gt; 가 리턴 될 때 해시 목록이 커지기 시작하여 일정 기간 동안 테이블에 대한 액세스 속도가 현저히 느려집니다. 최소 슬롯 수는 &lt;code&gt;open_file/2&lt;/code&gt; 옵션 &lt;code&gt;min_no_slots&lt;/code&gt; 에 의해 설정되고 &lt;code&gt;info/2&lt;/code&gt; 항목 &lt;code&gt;no_slots&lt;/code&gt; 에 의해 리턴됩니다 . 아래의 옵션 &lt;code&gt;min_no_slots&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfd76fb18738a1a7309ffa02f852c57726d1bccb" translate="yes" xml:space="preserve">
          <source>It is important that you do not raise the primary log level before adjusting the default handler's level as otherwise your standard out may be flooded by debug log messages.</source>
          <target state="translated">기본 처리기의 수준을 조정하기 전에 기본 로그 수준을 올리지 않는 것이 중요합니다. 그렇지 않으면 표준 출력이 디버그 로그 메시지로 넘칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc58fdeef579f98fae78bf5fe0d5883ad2b7f7a5" translate="yes" xml:space="preserve">
          <source>It is important though that the returned data is of the correct type depending on the options set. We therefore convert the lists to binaries in the correct encoding &lt;strong&gt;if possible&lt;/strong&gt; before returning. The function supplied in the &lt;code&gt;get_until&lt;/code&gt; request tuple can, as its final result return anything, so only functions returning lists can get them converted to binaries. If the request contains encoding tag &lt;code&gt;unicode&lt;/code&gt;, the lists can contain all Unicode code points and the binaries are to be in UTF-8. If the encoding tag is &lt;code&gt;latin1&lt;/code&gt;, the client is only to get characters in the range &lt;code&gt;0..255&lt;/code&gt;. Function &lt;code&gt;check/2&lt;/code&gt; takes care of not returning arbitrary Unicode code points in lists if the encoding was specified as &lt;code&gt;latin1&lt;/code&gt;. If the function does not return a list, the check cannot be performed and the result is that of the supplied function untouched.</source>
          <target state="translated">옵션 세트에 따라 리턴 된 데이터가 올바른 유형이어야합니다. 따라서 &lt;strong&gt;가능하면&lt;/strong&gt; 리턴하기 전에 목록을 올바른 인코딩으로 바이너리로 변환하십시오 . &lt;code&gt;get_until&lt;/code&gt; 요청 튜플에 제공된 함수 는 최종 결과가 무엇이든 리턴하므로 목록을 리턴하는 함수 만 바이너리로 변환 할 수 있습니다. 요청에 인코딩 태그 &lt;code&gt;unicode&lt;/code&gt; 가 포함 된 경우 목록에 모든 유니 코드 코드 포인트가 포함될 수 있으며 이진은 UTF-8이어야합니다. 인코딩 태그가 &lt;code&gt;latin1&lt;/code&gt; 인 경우 클라이언트는 &lt;code&gt;0..255&lt;/code&gt; 범위의 문자 만 가져옵니다 . 기능 &lt;code&gt;check/2&lt;/code&gt; 인코딩이 &lt;code&gt;latin1&lt;/code&gt; 로 지정된 경우 목록에서 임의의 유니 코드 코드 포인트를 반환하지 않도록 처리합니다 . 기능이 목록을 반환하지 않으면 점검을 수행 할 수 없으며 결과는 제공된 기능을 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="9f482f1f05e993d08f85fc64a1e60725affe0355" translate="yes" xml:space="preserve">
          <source>It is important to classify the dirty job correct. An I/O bound job should be classified as such, and a CPU bound job should be classified as such. If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are expected to either block waiting for I/O, and/or spend a limited amount of time moving data.</source>
          <target state="translated">더티 작업을 올바르게 분류하는 것이 중요합니다. I / O 바운드 작업은 이와 같이 분류되어야하고 CPU 바운드 작업은 이와 같이 분류되어야합니다. CPU 바운드 작업을 I / O 바운드 작업으로 분류해야하는 경우 더티 I / O 스케줄러가 일반 스케줄러에 굶주릴 수 있습니다. I / O 바운드 작업은 I / O 대기를 차단하거나 데이터 이동에 제한된 시간을 소비해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a4196885ce002104d00e42ea02d9f5307edd242" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that it is not safe to apply &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; directly on an input URI:</source>
          <target state="translated">입력 URI에 &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; 을 직접 적용하는 것은 안전하지 않다는 점을 강조하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="d9976dd4908ba58e6dd50ae2770854ad93d01862" translate="yes" xml:space="preserve">
          <source>It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</source>
          <target state="translated">일치를 제한 할 때 &quot;재귀&quot;라고하는 것은 Erlang 시스템의 C 스택 또는 Erlang 프로세스 스택에서 재귀가 아님을 이해하는 것이 중요합니다. Erlang VM으로 컴파일 된 PCRE 버전은 머신 &quot;힙&quot;메모리를 사용하여 정규 표현식 일치에서 재귀를 통해 유지되어야하는 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5fc84b5054a683e27bd285de83b2269e24832caa" translate="yes" xml:space="preserve">
          <source>It is legal to use a &lt;code&gt;receive..after&lt;/code&gt; expression with no branches:</source>
          <target state="translated">분기없이 &lt;code&gt;receive..after&lt;/code&gt; 표현식 을 사용하는 것이 합법적입니다 .</target>
        </trans-unit>
        <trans-unit id="8591893750dc5759c22c24a40b729a09191cadb5" translate="yes" xml:space="preserve">
          <source>It is like the older type an exception of the &lt;code&gt;error&lt;/code&gt; class. In addition they contain a descriptive text in English. That text is targeted to a developer. Examples are &quot;Bad key size&quot; or &quot;Cipher id is not an atom&quot;.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 클래스 의 예외 인 이전 유형과 같습니다 . 또한 영어로 된 설명 텍스트가 포함되어 있습니다. 이 텍스트는 개발자를 대상으로합니다. 예는 &quot;잘못된 키 크기&quot;또는 &quot;암호 ID가 원자가 아닙니다&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="44e50f37a24e3efe1e7a14657ed0c069786f809c" translate="yes" xml:space="preserve">
          <source>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</source>
          <target state="translated">정규화 된 데이터베이스에서 일반화 된 검색을 수행하는 것이 더 효율적입니다. 정규화 된 데이터 모델에서 일부 작업을 수행하기도 쉽습니다. 예를 들어 다음 예제와 같이 하나의 프로젝트를 쉽게 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a62a914f23c7f077c19bf0735e258c81935d769" translate="yes" xml:space="preserve">
          <source>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</source>
          <target state="translated">네트워크 잠금을 설정하는 것보다 로컬 잠금을 설정하는 것이 더 효율적입니다. 따라서 고정 잠금은 복제 된 테이블을 사용하고 하나의 노드에서만 대부분의 작업을 수행하는 응용 프로그램에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="266a8a540d53489e054ee8e53285fcaa3022a860" translate="yes" xml:space="preserve">
          <source>It is much more efficient.</source>
          <target state="translated">훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f70ad1b7b9db40203db93fc2a60726affaeebaca" translate="yes" xml:space="preserve">
          <source>It is nice to be able to do formatted output in examples, so the next example shows a simple way to use the &lt;code&gt;io:format&lt;/code&gt; function. Like all other exported functions, you can test the &lt;code&gt;io:format&lt;/code&gt; function in the shell:</source>
          <target state="translated">예제에서 형식화 된 출력을 수행하는 것이 좋으므로 다음 예제는 &lt;code&gt;io:format&lt;/code&gt; 함수 를 사용하는 간단한 방법을 보여줍니다 . 내 보낸 다른 모든 함수와 마찬가지로 쉘에서 &lt;code&gt;io:format&lt;/code&gt; 함수를 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d490184e49da4da8de81362df926c0ada310f4" translate="yes" xml:space="preserve">
          <source>It is not a good idea to use a global variable as the port driver can be spawned by multiple Erlang processes. This driver-structure is to be instantiated multiple times:</source>
          <target state="translated">여러 Erlang 프로세스에서 포트 드라이버를 생성 할 수 있으므로 전역 변수를 사용하는 것은 좋지 않습니다. 이 드라이버 구조는 여러 번 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="6daf413f50e26bb393a9adb93de8ca6d96ea4c43" translate="yes" xml:space="preserve">
          <source>It is not allowed to call any functions in the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;stop_select&lt;/code&gt;. This strict limitation is because the volatile context that &lt;code&gt;stop_select&lt;/code&gt; can be called.</source>
          <target state="translated">어떤 함수를 호출 할 수 없습니다 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;stop_select&lt;/code&gt; . 이 엄격한 제한은 &lt;code&gt;stop_select&lt;/code&gt; 라는 휘발성 컨텍스트를 호출 할 수 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="019cb18d2dc1083bf927207eb128dc99a14ce1cb" translate="yes" xml:space="preserve">
          <source>It is not allowed to change trace details (with &lt;code&gt;ttb:p&lt;/code&gt; and &lt;code&gt;ttb:tp/tpl...&lt;/code&gt;) once overload protection is activated in one of the traced nodes. This is to avoid trace setup being inconsistent between nodes.</source>
          <target state="translated">추적 된 노드 중 하나에서 과부하 보호가 활성화되면 추적 세부 사항 ( &lt;code&gt;ttb:p&lt;/code&gt; 및 &lt;code&gt;ttb:tp/tpl...&lt;/code&gt; ) 을 변경할 수 없습니다 . 이는 노드간에 추적 설정이 일치하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e8776419aaae9b828a3d1b448f27e629b87f9db" translate="yes" xml:space="preserve">
          <source>It is not allowed to load multiple drivers with the same name but with different &lt;code&gt;Path&lt;/code&gt; parameters.</source>
          <target state="translated">이름은 같지만 &lt;code&gt;Path&lt;/code&gt; 매개 변수 가 다른 여러 드라이버를로드 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="267a6935a47a3d4aa60125e0028f69bd27f1ad69" translate="yes" xml:space="preserve">
          <source>It is not allowed to refer to types that are not declared as exported.</source>
          <target state="translated">반출 된 것으로 선언되지 않은 유형은 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52ca1d72ceed7a04c50a67b9f4c3b637fc684ff0" translate="yes" xml:space="preserve">
          <source>It is not allowed to use the atoms &lt;code&gt;asn1_VALUE&lt;/code&gt; and &lt;code&gt;asn1_DEFAULT&lt;/code&gt; with maps.</source>
          <target state="translated">원자 &lt;code&gt;asn1_VALUE&lt;/code&gt; 및 &lt;code&gt;asn1_DEFAULT&lt;/code&gt; 를 맵과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="be6106b5316f8ae8651f28932170f500e7f32a70" translate="yes" xml:space="preserve">
          <source>It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the following pattern, the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2:</source>
          <target state="translated">일반 괄호가 두 가지 기능을 수행하는 것이 항상 도움이되는 것은 아닙니다. 종종 캡처 요구 사항없이 그룹화 서브 패턴이 필요합니다. 여는 괄호 뒤에 물음표와 콜론이 있으면 하위 패턴은 캡처를 수행하지 않으며 후속 캡처 하위 패턴의 수를 계산할 때 계산되지 않습니다. 예를 들어, 문자열 &quot;white queen&quot;이 다음 패턴과 일치하는 경우 캡처 된 하위 문자열은 &quot;white queen&quot;및 &quot;queen&quot;이며 1과 2로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="172ef3e2b0d7516e4d00a976dfcc654e15ef5e2e" translate="yes" xml:space="preserve">
          <source>It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.</source>
          <target state="translated">아직 구성되지 않은 서비스에 전송을 추가하는 것은 오류가 아닙니다. 전송을 구성한 후 서비스를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714ec40d84015427dbe106f387df1a398ce13922" translate="yes" xml:space="preserve">
          <source>It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.</source>
          <target state="translated">아직 존재하지 않는 서비스의 이벤트를 구독하는 것은 오류가 아닙니다. 모든 운송 관련 이벤트의 수신을 보장하려면 전송을 추가하기 전에 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6506688cea3e9daf57ae35e48e1e48f518b6ed35" translate="yes" xml:space="preserve">
          <source>It is not checked that the forms conform to the abstract format indicated by &lt;code&gt;AbstVersion&lt;/code&gt;. &lt;code&gt;no_abstract_code&lt;/code&gt; means that chunk &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; is present, but empty.</source>
          <target state="translated">양식이 &lt;code&gt;AbstVersion&lt;/code&gt; 이 나타내는 추상 형식을 따르는 지 확인하지 않습니다 . &lt;code&gt;no_abstract_code&lt;/code&gt; 는 &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; 청크 가 있지만 비어 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="adff89968dc05df945ea7914de5055f731976098" translate="yes" xml:space="preserve">
          <source>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</source>
          <target state="translated">애플리케이션이 직접 호출하도록 설계되지 않았지만 다음과 같은 방법으로 애플리케이션에서 일반적으로 호출 할 수있는 i / o 시스템을 통해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48dac80b8a2417f47d829c8b695667c7b727c326" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that all log files of a distributed disk log contain the same log items. No attempt is made to synchronize the contents of the files. However, as long as at least one of the involved nodes is alive at each time, all items are logged. When logging items to a distributed log, or otherwise trying to change the log, the replies from individual logs are ignored. If all nodes are down, the disk log functions reply with a &lt;code&gt;nonode&lt;/code&gt; error.</source>
          <target state="translated">분산 디스크 로그의 모든 로그 파일에 동일한 로그 항목이 포함되어있는 것은 아닙니다. 파일 내용을 동기화하려고 시도하지 않습니다. 그러나 관련된 노드 중 하나 이상이 매번 살아있는 한 모든 항목이 기록됩니다. 항목을 분산 로그에 기록하거나 로그를 변경하려고하면 개별 로그의 회신이 무시됩니다. 모든 노드가 작동 중지되면 디스크 로그 기능이 &lt;code&gt;nonode&lt;/code&gt; 오류로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="6c08a59c0ce53162ab6636309433afb0420a7157" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that calls to &lt;code&gt;first/1&lt;/code&gt;, &lt;code&gt;next/2&lt;/code&gt;, or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table.</source>
          <target state="translated">테이블이 고정 된 경우에도 &lt;code&gt;first/1&lt;/code&gt; , &lt;code&gt;next/2&lt;/code&gt; 또는 select and match 함수에 대한 호출이 예상대로 작동 한다고 보장 할 수는 없습니다 . &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; 모듈 에서 제공하는 동시성에 대한 제한된 지원 은 아직 Dets에서 제공하지 않습니다. 테이블을 수정하면 현재 테이블의 해시 목록 크기 조정 만 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d1b5a702c4f1e3b1b3222bf3f6b4f026b94f149e" translate="yes" xml:space="preserve">
          <source>It is not hard to guess that this program doubles the value of numbers. The first two lines of the code are described later. Let us compile the program. This can be done in an Erlang shell as follows, where &lt;code&gt;c&lt;/code&gt; means compile:</source>
          <target state="translated">이 프로그램이 숫자 값을 두 배로 늘린다는 것을 추측하는 것은 어렵지 않습니다. 코드의 처음 두 줄은 나중에 설명합니다. 프로그램을 컴파일하자. 이것은 다음과 같이 Erlang 쉘에서 수행 할 수 있습니다. 여기서 &lt;code&gt;c&lt;/code&gt; 는 컴파일을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6599e0f052b83133353329a627f4fcc452a99c7e" translate="yes" xml:space="preserve">
          <source>It is not mandatory to implement a &lt;code&gt;Module:format_status/2&lt;/code&gt; function. If you do not, a default implementation is used that does the same as this example function without filtering the &lt;code&gt;Data&lt;/code&gt; term, that is, &lt;code&gt;StateData = {State,Data}&lt;/code&gt;, in this example containing sensitive information.</source>
          <target state="translated">&lt;code&gt;Module:format_status/2&lt;/code&gt; 함수 를 구현할 필요는 없습니다 . 그렇지 않으면 민감한 정보를 포함하는이 예제에서 &lt;code&gt;Data&lt;/code&gt; 용어 를 필터링하지 않고이 예제 기능과 동일한 기본 구현 ( &lt;code&gt;StateData = {State,Data}&lt;/code&gt; )이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0b1f733cc068108abc1dfb8d6bfeb68f2238a31" translate="yes" xml:space="preserve">
          <source>It is not necessary to export the function. It is called in a freshly spawned process (which terminates as soon as the function returns).</source>
          <target state="translated">기능을 내보낼 필요는 없습니다. 새로 생성 된 프로세스에서 호출됩니다 (함수가 반환되는 즉시 종료됩니다).</target>
        </trans-unit>
        <trans-unit id="93f0d950414352a5d4ade5d65e2ed5c99e6d63a5" translate="yes" xml:space="preserve">
          <source>It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes.</source>
          <target state="translated">직경 자체가 적절한 값을 설정하므로 발신 메시지에서 헤더 필드를 명시 적으로 설정할 필요는 없습니다. 부적절한 값을 설정하면 테스트 목적으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a88f320b00286fede41d92ef08aebc45a1de0c25" translate="yes" xml:space="preserve">
          <source>It is not needed to link the start script to a standard directory like &lt;code&gt;/usr/local/bin&lt;/code&gt;.</source>
          <target state="translated">시작 스크립트를 &lt;code&gt;/usr/local/bin&lt;/code&gt; 과 같은 표준 디렉토리에 링크 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="67e4d152ebcc05f491b81e0ec203229252d7a205" translate="yes" xml:space="preserve">
          <source>It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern whose number is 10 or more using this syntax, as a sequence such as \50 is interpreted as a character defined in octal. For more details of the handling of digits following a backslash, see section &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; earlier. There is no such problem when named parentheses are used. A back reference to any subpattern is possible using named parentheses (see below).</source>
          <target state="translated">\ 50과 같은 시퀀스가 ​​8 진수로 정의 된 문자로 해석되므로이 구문을 사용하여 숫자가 10 이상인 하위 패턴에 대한 숫자 &quot;순방향 역 참조&quot;를 가질 수 없습니다. 백 슬래시 뒤의 숫자 처리에 대한 자세한 내용은 앞에서 &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 . 명명 된 괄호를 사용하는 경우에는 이러한 문제가 없습니다. 명명 된 괄호를 사용하여 하위 패턴에 대한 역 참조가 가능합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c8c3861d369958e8f50d803ddee527f70da5bdd2" translate="yes" xml:space="preserve">
          <source>It is not possible to have hook functions for unknown forms at other places than expressions.</source>
          <target state="translated">식 이외의 다른 위치에서는 알 수없는 형태에 대한 후크 함수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf5dc4b3da52b6319903eca1d8e499b4252bc392" translate="yes" xml:space="preserve">
          <source>It is not possible to prove that a program is correct by testing. On the contrary, it has been formally proven that it is impossible to prove programs in general by testing. Theoretical program proofs or plain examination of code can be viable options for those wishing to certify that a program is correct. The test server, as it is based on testing, cannot be used for certification. Its intended use is instead to (cost effectively) &lt;strong&gt;find bugs&lt;/strong&gt;. A successful test suite is one that reveals a bug. If a test suite results in OK, then we know very little that we did not know before.</source>
          <target state="translated">테스트를 통해 프로그램이 올바른지 증명할 수는 없습니다. 반대로, 테스트를 통해 일반적으로 프로그램을 증명할 수 없다는 것이 공식적으로 입증되었습니다. 프로그램의 정확성을 증명하고자하는 사람들에게는 이론적 인 프로그램 증명 또는 코드의 평범한 검사가 실행 가능한 옵션이 될 수 있습니다. 테스트를 기반으로하는 테스트 서버는 인증에 사용할 수 없습니다. 의도 된 용도는 &lt;strong&gt;버그&lt;/strong&gt; 를 (비용 효율적으로) &lt;strong&gt;찾는 것&lt;/strong&gt; 입니다. 성공적인 테스트 스위트는 버그를 드러내는 것입니다. 테스트 스위트 결과가 정상이면, 우리는 이전에 몰랐던 것을 거의 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="f090c83c0abe9549e98a789664a0923d4db3b914" translate="yes" xml:space="preserve">
          <source>It is not uncommon that a state diagram does not specify how to handle events that are not illustrated in a particular state in the diagram. Hopefully this is described in an associated text or from the context.</source>
          <target state="translated">상태 다이어그램이 다이어그램에서 특정 상태로 설명되지 않은 이벤트를 처리하는 방법을 지정하지 않는 것은 드문 일이 아닙니다. 바라건대 이것은 관련 텍스트 또는 컨텍스트에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="1b4b52b46f007701d86e5cbc9fd97f24e3345085" translate="yes" xml:space="preserve">
          <source>It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification.</source>
          <target state="translated">현재 시간보다 늦은 시작 시간을 지정하는 것은 유효하지 않습니다. 경우 &lt;code&gt;StartTime&lt;/code&gt; 로그가 지원할 수있는보다 일찍 지정, 재생이 가능한 가장 빠른 통지로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5d718859968289028b6154d936e134179997eaef" translate="yes" xml:space="preserve">
          <source>It is now easy to check the release for calls to undefined functions:</source>
          <target state="translated">정의되지 않은 함수에 대한 호출에 대한 릴리스를 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faf994c17800a7abaab6ecd7abe5ad72813bee4c" translate="yes" xml:space="preserve">
          <source>It is of course pointless to set this value to &lt;strong&gt;true&lt;/strong&gt; unless the &lt;code&gt;long_request_timer&lt;/code&gt; (see above) is also set to an incremental timer (&lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;long_request_timer&lt;/code&gt; (위 참조)도 증분 타이머 ( &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; )로 설정 하지 않는 한이 값을 &lt;strong&gt;true&lt;/strong&gt; 로 설정하는 것은 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="79ffc30d77639dd371cff25e8830713b8384b424" translate="yes" xml:space="preserve">
          <source>It is of course possible to change more than one list:</source>
          <target state="translated">물론 둘 이상의 목록을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bfa4ac8d028ee74a965d7390ff456df5b066f34" translate="yes" xml:space="preserve">
          <source>It is of course questionable why anyone would like to use the both these options together, but it is possible if an unforeseen need should arise.</source>
          <target state="translated">물론이 두 가지 옵션을 모두 함께 사용하려는 이유는 의심의 여지가 있지만, 예상치 못한 필요가 발생할 경우 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bf27b2f7999b2a0f376e32c255c57172849d6995" translate="yes" xml:space="preserve">
          <source>It is of vital importance that this operation does not block the caller for a long time. This since it is called from the connection supervisor.</source>
          <target state="translated">이 작업으로 인해 발신자를 오랫동안 차단하지 않는 것이 매우 중요합니다. 연결 관리자로부터 호출 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e5e8d870189d92edc558c16a26f0bf8ab0c4cb2b" translate="yes" xml:space="preserve">
          <source>It is often clarifying to mark the variables of a query in such a circle. This is illustrated in the picture below for some of the predefined analyses. Note that local functions used by local functions only are not marked in the &lt;code&gt;locals_not_used&lt;/code&gt; circle.</source>
          <target state="translated">그러한 원 안에 쿼리 변수를 표시하는 것이 종종 명확합니다. 이것은 사전 정의 된 분석 중 일부에 대해 아래 그림에 설명되어 있습니다. 로컬 함수에서만 사용되는 로컬 함수는 &lt;code&gt;locals_not_used&lt;/code&gt; 서클에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f00cf0fbfe0fde80503545d404b005925d1059f" translate="yes" xml:space="preserve">
          <source>It is often necessary to take some specific action when a table is modified. This is accomplished with an instrumentation function. It executes some specific code when the table is set, and passes all other requests down to the pre-defined function.</source>
          <target state="translated">테이블을 수정할 때 특정 조치를 수행해야하는 경우가 종종 있습니다. 이는 계측 기능으로 수행됩니다. 테이블이 설정되면 특정 코드를 실행하고 다른 모든 요청을 미리 정의 된 함수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="669d240c984f988928dcb3d02f7640e88b19a775" translate="yes" xml:space="preserve">
          <source>It is often not desirable to use an Erlang/OTP system as is. A developer can create new Erlang/OTP-compliant applications for a particular purpose, and several original Erlang/OTP applications can be irrelevant for the purpose in question. Thus, there is a need to be able to create a new system based on a given Erlang/OTP system, where dispensable applications are removed and new applications are included. Documentation and source code is irrelevant and is therefore not included in the new system.</source>
          <target state="translated">Erlang / OTP 시스템을 그대로 사용하는 것은 바람직하지 않습니다. 개발자는 특정 목적을 위해 새로운 Erlang / OTP 호환 응용 프로그램을 만들 수 있으며, 원래의 Erlang / OTP 응용 프로그램은 해당 목적과 관련이 없을 수 있습니다. 따라서, 주어진 Erlang / OTP 시스템을 기반으로 새로운 응용 프로그램을 작성할 수 있어야합니다. 여기서 분배 가능한 응용 프로그램이 제거되고 새 응용 프로그램이 포함됩니다. 설명서 및 소스 코드는 관련이 없으므로 새 시스템에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d21d755bf6ee35af46a7e0f26952debc88310ea" translate="yes" xml:space="preserve">
          <source>It is often very convenient to have a header in the escript, especially on Unix platforms. However, the header is optional, so you directly can &quot;execute&quot; an Erlang module, Beam file, or archive file without adding any header to them. But then you have to invoke the script as follows:</source>
          <target state="translated">특히 유닉스 플랫폼에서 escript에 헤더를 갖는 것이 매우 편리합니다. 그러나 헤더는 선택 사항이므로 헤더를 추가하지 않고 Erlang 모듈, Beam 파일 또는 아카이브 파일을 직접 &quot;실행&quot;할 수 있습니다. 그러나 다음과 같이 스크립트를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b82a26416eee8b8a22c361320edebe40a30f41c" translate="yes" xml:space="preserve">
          <source>It is only possible to use &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; and &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; for authentication and privacy respectively in FIPS mode. The snmp application however won't restrict selecting disabled protocols in any way, and using them would result in run time crashes.</source>
          <target state="translated">FIPS 모드에서 각각 인증 및 개인 정보 보호 를 위해 &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; 및 &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; 프로토콜 만 사용할 수 있습니다 . 그러나 snmp 응용 프로그램은 어떤 방식 으로든 비활성화 된 프로토콜 선택을 제한하지 않으며이를 사용하면 런타임 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9fa7b580bee0cd82b79a574d9169e03e86d95bf2" translate="yes" xml:space="preserve">
          <source>It is ordered by the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="translated">그것은 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt; 또는 단지 정수 &lt;code&gt;Time&lt;/code&gt; 에 의해 &lt;code&gt;gen_fsm&lt;/code&gt; 됩니다. &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd21c404d1e97d6cd83c5aba66d139ae4da23bac" translate="yes" xml:space="preserve">
          <source>It is ordered by the state transition action &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="translated">상태 변환 조치 &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt; 또는 엔 클로징 조치 목록이없는 경우에도 정수 &lt;code&gt;Time&lt;/code&gt; 순서로 정렬됩니다 (후자는 &lt;code&gt;gen_fsm&lt;/code&gt; 에서 상속 된 양식 입니다).</target>
        </trans-unit>
        <trans-unit id="c2055694d674903a04f32f46b3d110e4fe1e7d79" translate="yes" xml:space="preserve">
          <source>It is outside the scope for this document to describe in detail how such guard functions are written, but for the curious here is the implementation of &lt;code&gt;literal_is_map()&lt;/code&gt;:</source>
          <target state="translated">이러한 가드 함수가 어떻게 작성되는지 자세히 설명하는 것은이 문서의 범위를 벗어나지 만 여기서 흥미로운 것은 &lt;code&gt;literal_is_map()&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="cb514030de07cc7f47659f8e694150bb1b3605c4" translate="yes" xml:space="preserve">
          <source>It is outside the scope of this document to describe in detail how generator functions are written, but for the curious, here is the implementation of &lt;code&gt;gen_element()&lt;/code&gt;:</source>
          <target state="translated">생성기 함수를 작성하는 방법을 자세히 설명하는 것은이 문서의 범위를 벗어납니다.하지만 궁금한 사람을 위해 &lt;code&gt;gen_element()&lt;/code&gt; 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4f5f5edc97bf67285e58ab928b4aa2d01b87a09" translate="yes" xml:space="preserve">
          <source>It is possible by this option to provide a state with process information from an earlier validation.</source>
          <target state="translated">이 옵션을 통해 이전 유효성 검사의 프로세스 정보를 상태에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc2da2a53482855bb7753488df5c4c401558486" translate="yes" xml:space="preserve">
          <source>It is possible for Emacs to use colors when displaying a buffer. By &quot;syntax highlighting&quot;, we mean that syntactic components, for example keywords and function names, will be colored.</source>
          <target state="translated">버퍼를 표시 할 때 Emacs가 색상을 사용할 수 있습니다. &quot;구문 강조 표시&quot;는 키워드 및 함수 이름과 같은 구문 구성 요소에 색상이 지정됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="983ca3396eb1c79021585a9487782ad0ed7b06d7" translate="yes" xml:space="preserve">
          <source>It is possible that a handler, even if it can successfully manage peaks of high load without crashing, can build up a large message queue, or use a large amount of memory. The overload protection mechanism includes an automatic termination and restart feature for the purpose of guaranteeing that a handler does not grow out of bounds. The feature is configured with the following parameters:</source>
          <target state="translated">처리기는 충돌없이 최고로드의 피크를 성공적으로 관리 할 수 ​​있더라도 큰 메시지 큐를 만들거나 많은 양의 메모리를 사용할 수 있습니다. 과부하 보호 메커니즘에는 핸들러가 범위를 벗어나지 않도록하기 위해 자동 종료 및 재시작 기능이 포함되어 있습니다. 기능은 다음 매개 변수로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="89c49ffbfde542066361889dbf3e0036988b041f" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;strong&gt;notification filters&lt;/strong&gt; to an agent. These filters will be called when a notification is to be sent. Their purpose is to allow modification, suppression or other type of actions.</source>
          <target state="translated">에이전트에 &lt;strong&gt;알림 필터&lt;/strong&gt; 를 추가 할 수 있습니다 . 이 필터는 알림이 전송 될 때 호출됩니다. 그들의 목적은 수정, 억제 또는 다른 유형의 행동을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="611a47c1b5a7ffc5aabe01662e2b7fd7dc2dfd2f" translate="yes" xml:space="preserve">
          <source>It is possible to attach to interpreted processes by giving the corresponding process identity only. By default, an attachment window is displayed. Processes at other Erlang nodes can be attached manually or automatically.</source>
          <target state="translated">해당 프로세스 ID 만 제공하여 해석 된 프로세스에 첨부 할 수 있습니다. 기본적으로 첨부 파일 창이 표시됩니다. 다른 Erlang 노드의 프로세스는 수동 또는 자동으로 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e8dd8df3b8da8be36f66edb5a2d3e1745bac94b" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the script's original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="translated">&lt;code&gt;escript&lt;/code&gt; (s)를 Erlang 런타임 시스템과 번들로 묶어 자급 자족하고 재배치 할 수 있습니다. 이러한 독립형 시스템에서 &lt;code&gt;escript&lt;/code&gt; 는 독립형 시스템 의 최상위 &lt;code&gt;bin&lt;/code&gt; 디렉토리에 &lt;code&gt;.escript&lt;/code&gt; 하며 파일 확장자로 .escript 를 지정해야합니다. 또한 (내장 된) &lt;code&gt;escript&lt;/code&gt; 프로그램은 동일한 디렉토리에 복사해야하며 스크립트의 원래 이름 ( &lt;code&gt;.escript&lt;/code&gt; 확장자 없이 )을 지정해야합니다. 이렇게하면 번들로 제공되는 Erlang 런타임 시스템을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a33746b01c4222471af2ab90b1fda17ae37276" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the scripts original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템과 함께 &lt;code&gt;escript&lt;/code&gt; 를 번들 로 제공하여 자급 자족하고 재배치 할 수 있습니다. 이러한 독립형 시스템에서 &lt;code&gt;escript&lt;/code&gt; 는 독립형 시스템 의 최상위 &lt;code&gt;bin&lt;/code&gt; 디렉토리에 있으며 파일 확장자로 &lt;code&gt;.escript&lt;/code&gt; 를 제공해야합니다. 또한 (내장) &lt;code&gt;escript&lt;/code&gt; 프로그램을 동일한 디렉토리에 복사하고 스크립트의 원래 이름 ( &lt;code&gt;.escript&lt;/code&gt; 확장자 없이 )을 지정해야합니다. 번들로 제공되는 Erlang 런타임 시스템을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a74ec992e2736a1ad60efb4b66cf6169016243f" translate="yes" xml:space="preserve">
          <source>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern:</source>
          <target state="translated">어설 션 결과에 따라 또는 특정 캡처 하위 패턴이 이미 일치했는지 여부에 따라 일치 프로세스가 조건에 따라 하위 패턴을 따르거나 두 개의 대체 하위 패턴 중에서 선택하도록 할 수 있습니다. 다음은 두 가지 가능한 조건부 하위 패턴 양식입니다.</target>
        </trans-unit>
        <trans-unit id="ab76d6d5170404d3b2cda7f8cfb409928e7f4eef" translate="yes" xml:space="preserve">
          <source>It is possible to configure a 3588 dictionary in order to get 3588 semantics, where the differ from 6733.</source>
          <target state="translated">688과 다른 3588 의미를 얻기 위해 3588 사전을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c37c6dc0aa07be6c37e5deaa81d5f4c9f52e7cd" translate="yes" xml:space="preserve">
          <source>It is possible to debug every (non-supervisor) process of the application (both agent and manager), possibly with the exception of the net_if module(s), which could be supplied by a user of the application). This is done by calling the &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; and &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; function(s) and/or using &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;. The verbosity itself has several &lt;strong&gt;levels&lt;/strong&gt;: &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt;. For the lowest verbosity &lt;code&gt;silence&lt;/code&gt;, nothing is printed. The higher the verbosity, the more is printed. Default value is always &lt;code&gt;silence&lt;/code&gt;.</source>
          <target state="translated">net_if 모듈을 제외하고 응용 프로그램의 모든 (감독자가 아닌) 프로세스 (에이전트 및 관리자)를 디버깅 할 수 있습니다 (어플리케이션 사용자가 제공 할 수있는 net_if 모듈 제외). 이는 &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; 및 &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; 함수를 호출하거나 &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 사용하여 수행 됩니다 . 세부 사항 자체에는 여러 &lt;strong&gt;레벨이 있습니다&lt;/strong&gt; . &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt; . 가장 낮은 &lt;code&gt;silence&lt;/code&gt; 경우 아무 것도 인쇄되지 않습니다. 상세도가 높을수록 더 많이 인쇄됩니다. 기본값은 항상 &lt;code&gt;silence&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d39bbc803211df1332cc5dc8dcf83a0f92e55b1" translate="yes" xml:space="preserve">
          <source>It is possible to generate an &lt;code&gt;.hrl&lt;/code&gt; file which contains definitions of Erlang constants from a compiled MIB file. This file can then be included in Erlang source code. The file will contain constants for:</source>
          <target state="translated">컴파일 된 MIB 파일에서 Erlang 상수의 정의가 포함 된 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 생성 할 수 있습니다. 이 파일은 Erlang 소스 코드에 포함될 수 있습니다. 파일에는 다음에 대한 상수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="51fafe686c4a07e4e02f5d76d9dd1d3e7268cfbe" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node and another type on another node. Default is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">한 노드에는 &lt;code&gt;disc_copies&lt;/code&gt; 유형의 복제 된 테이블이 있고 다른 노드에는 다른 유형의 테이블이있을 수 있습니다 . 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="176cd0b1dd2d9962820987b7f9b12d3696c77d8c" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node, and the same table stored as a different type on another node. Default is &lt;code&gt;[]&lt;/code&gt;. This arrangement is desirable if the following operational characteristics are required:</source>
          <target state="translated">한 노드에 &lt;code&gt;disc_copies&lt;/code&gt; 유형의 복제 된 테이블이 있고 다른 노드에 다른 테이블로 저장된 동일한 테이블이있을 수 있습니다. 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다. 다음과 같은 작동 특성이 필요한 경우이 배열이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="1fe6b795938737aa56b18e0286b7c12c53710c77" translate="yes" xml:space="preserve">
          <source>It is possible to have the following ASN.1 type definitions:</source>
          <target state="translated">다음 ASN.1 유형 정의를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548cba172b1fcb6f71c35f5e74ff7ab8d68b17fd" translate="yes" xml:space="preserve">
          <source>It is possible to limit which types of documentation is build by passing the &lt;code&gt;DOC_TARGETS&lt;/code&gt; environment variable to &lt;code&gt;make docs&lt;/code&gt;. The currently available types are: &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;pdf&lt;/code&gt;, &lt;code&gt;man&lt;/code&gt; and &lt;code&gt;chunks&lt;/code&gt;. Example:</source>
          <target state="translated">이 빌드가 통과하는 것입니다 문서의 어떤 유형을 제한 할 수 &lt;code&gt;DOC_TARGETS&lt;/code&gt; 의 위해 환경 변수를 &lt;code&gt;make docs&lt;/code&gt; . 현재 사용 가능한 유형은 &lt;code&gt;html&lt;/code&gt; , &lt;code&gt;pdf&lt;/code&gt; , &lt;code&gt;man&lt;/code&gt; 및 &lt;code&gt;chunks&lt;/code&gt; 입니다. 예:</target>
        </trans-unit>
        <trans-unit id="e65479625a383af2cdbc9583d3c3a03b0cb2fe00" translate="yes" xml:space="preserve">
          <source>It is possible to limit which types of documentation is released using the same &lt;code&gt;DOC_TARGETS&lt;/code&gt; environment variable as when building documentation.</source>
          <target state="translated">문서 작성시와 동일한 &lt;code&gt;DOC_TARGETS&lt;/code&gt; 환경 변수를 사용하여 릴리스되는 문서 유형을 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="caeed91f5fcecb317cae9ea39c892cb575858fba" translate="yes" xml:space="preserve">
          <source>It is possible to load mibs into the manager, but this is not necessary for normal operation, and not recommended.</source>
          <target state="translated">관리자에 밉을로드 할 수 있지만 이는 정상적인 작동에는 필요하지 않으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ed112d6a70cb9d06cfb65b8258e9018e32dab8e" translate="yes" xml:space="preserve">
          <source>It is possible to modify the default behaviour of a process so that it does not get killed when it receives abnormal exit signals. Instead, all signals are turned into normal messages on the format &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; and added to the end of the receiving process' message queue. This behaviour is set by:</source>
          <target state="translated">비정상 종료 신호를 수신 할 때 종료되지 않도록 프로세스의 기본 동작을 수정할 수 있습니다. 대신, 모든 신호는 &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; 형식의 일반 메시지로 바뀌고 수신 프로세스의 메시지 큐 끝에 추가됩니다. 이 동작은 다음에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2b2147478740459290ffe9c88424b73275de9908" translate="yes" xml:space="preserve">
          <source>It is possible to overload macros, except for predefined macros. An overloaded macro has more than one definition, each with a different number of arguments.</source>
          <target state="translated">사전 정의 된 매크로를 제외하고 매크로를 오버로드 할 수 있습니다. 오버로드 된 매크로에는 각각 다른 수의 인수를 가진 둘 이상의 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1689c7a1afca7921fba43503d5e442362a2a71" translate="yes" xml:space="preserve">
          <source>It is possible to override the default behavior and control what types of files that are to be compressed by using options &lt;code&gt;{compress, What}&lt;/code&gt; and &lt;code&gt;{uncompress, What}&lt;/code&gt;. It is also possible to use many &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;{compress, What}&lt;/code&gt; 및 &lt;code&gt;{uncompress, What}&lt;/code&gt; 옵션을 사용하여 기본 작동을 대체하고 압축 할 파일 유형을 제어 할 수 있습니다 . 많은 &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;uncompress&lt;/code&gt; 옵션 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a56a8c28e6ccfea7e044e017bea02d64d0c26d0" translate="yes" xml:space="preserve">
          <source>It is possible to perform some limited manipulations of the graph. Nodes can be moved, selected, locked or deleted. Move a single node or the entire graph by moving the mouse while the left mouse button is pressed. A node can be locked into a fix position by holding down the shift button when the left mouse button is released. Select several nodes by moving the mouse while the control key and the left mouse button are pressed. Selected nodes can be locked, unlocked or deleted by clicking on a suitable button.</source>
          <target state="translated">그래프의 일부 제한된 조작을 수행 할 수 있습니다. 노드를 이동, 선택, 잠 그거나 삭제할 수 있습니다. 마우스 왼쪽 버튼을 누른 상태에서 마우스를 움직여 단일 노드 또는 전체 그래프를 이동하십시오. 마우스 왼쪽 버튼을 놓을 때 Shift 버튼을 누르면 노드가 고정 위치에 고정 될 수 있습니다. 컨트롤 키와 마우스 왼쪽 버튼을 누른 상태에서 마우스를 움직여 여러 노드를 선택하십시오. 적절한 버튼을 클릭하여 선택한 노드를 잠 그거나 잠금 해제하거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14dd64fc26d9237b80497c4bfb62db94add92668" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt; Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 또는 &lt;code&gt;try&lt;/code&gt; 를 사용하여 런타임 오류 및 기타 예외로 인해 프로세스가 종료되는 것을 방지 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt; Expressions&lt;/a&gt;&lt;/code&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="2fed4e0762f6fb12f483f3a5c7bb640cb225b33e" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 또는 &lt;code&gt;try&lt;/code&gt; 를 사용하여 런타임 오류 및 기타 예외로 인해 프로세스가 종료되는 것을 방지 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3df4ebaf240f63cbe2516bd7eacc27e64f5b97f0" translate="yes" xml:space="preserve">
          <source>It is possible to print more specific types of statistics by first manipulating the &lt;code&gt;DataOrStats&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. For instance if you want to print the percentage of run-time for each thread you can do:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 &lt;code&gt;DataOrStats&lt;/code&gt; 를 먼저 조작하여보다 구체적인 통계 유형을 인쇄 할 수 있습니다 . 예를 들어 각 스레드에 대한 런타임 백분율을 인쇄하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b575de532305d96f140137cd1f86dd41dc4043ea" translate="yes" xml:space="preserve">
          <source>It is possible to replace the string with one randomly generated for each connection attempt. See the reference manual for &lt;code&gt;&lt;a href=&quot;ssh#type-id_string_common_option&quot;&gt;id_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">각 연결 시도에 대해 무작위로 생성 된 문자열로 문자열을 바꿀 수 있습니다. &lt;code&gt;&lt;a href=&quot;ssh#type-id_string_common_option&quot;&gt;id_string&lt;/a&gt;&lt;/code&gt; 에 대한 참조 매뉴얼을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="356a713c1c6a5a552cd4fb5692b12412de6a432d" translate="yes" xml:space="preserve">
          <source>It is possible to return logger info that will be used by the TLS connection to produce log events.</source>
          <target state="translated">로그 이벤트를 생성하기 위해 TLS 연결에서 사용할 로거 정보를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63341d5389e1053c03c8898576d1f494be0100d" translate="yes" xml:space="preserve">
          <source>It is possible to specify more than one type letter for each operand. Here is an example:</source>
          <target state="translated">각 피연산자에 대해 둘 이상의 유형 문자를 지정할 수 있습니다. 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="edfc81400b7354fb02a37d8d3cbdc6435db75f99" translate="yes" xml:space="preserve">
          <source>It is possible to specify that the module is the callback module for a &lt;strong&gt;behaviour&lt;/strong&gt;:</source>
          <target state="translated">모듈이 &lt;strong&gt;동작에&lt;/strong&gt; 대한 콜백 모듈임을 지정할 수 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="81cfbe4935d3cb8cd743dc8d0f5da3c1eaae533d" translate="yes" xml:space="preserve">
          <source>It is possible to use Pre-Shared Key (PSK) and Secure Remote Password (SRP) cipher suites, but they are not enabled by default.</source>
          <target state="translated">PSK (Pre-Shared Key) 및 SRP (Secure Remote Password) 암호화 제품군을 사용할 수 있지만 기본적으로 활성화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64a48f3eede047c4b7880e6db7738b3c1b6b35fc" translate="yes" xml:space="preserve">
          <source>It is possible to use SSL/TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="translated">IPv4 대신 IPv6을 통한 SSL / TLS 배포를 사용할 수 있습니다. 이렇게하려면 옵션을 통과 &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; 대신 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 를 명령 줄이나에 중, 얼랑를 시작할 때 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 의 환경 변수.</target>
        </trans-unit>
        <trans-unit id="ff4792545154511875db9acebbc89980b3695713" translate="yes" xml:space="preserve">
          <source>It is possible to use TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="translated">IPv4 대신 IPv6를 통한 TLS 배포를 사용할 수 있습니다. 이렇게하려면 옵션을 통과 &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; 대신 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 를 명령 줄이나에 중, 얼랑를 시작할 때 &lt;code&gt;ERL_FLAGS&lt;/code&gt; 의 환경 변수.</target>
        </trans-unit>
        <trans-unit id="c2f7a787a6e395f6a23bb42d34f2d7a43e1c7c1a" translate="yes" xml:space="preserve">
          <source>It is possible to write a driver in C according to certain principles and dynamically link it to the Erlang runtime system. The linked-in driver looks like a port from the Erlang programmer's point of view and is called a &lt;strong&gt;port driver&lt;/strong&gt;.</source>
          <target state="translated">특정 원칙에 따라 C로 드라이버를 작성하고이를 Erlang 런타임 시스템에 동적으로 링크 할 수 있습니다. 링크 된 드라이버는 Erlang 프로그래머의 관점에서 포트처럼 보이고 &lt;strong&gt;포트 드라이버&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="3235ff3a1f208b096772a81fe4cb496997e0cde6" translate="yes" xml:space="preserve">
          <source>It is possible, but definitely not recommended, to start Debugger in global mode on more than one node in a network, as the nodes interfere with each other, leading to inconsistent behavior.</source>
          <target state="translated">노드가 서로 간섭하여 일관되지 않은 동작이 발생하므로 네트워크의 둘 이상의 노드에서 전역 모드로 디버거를 시작하는 것이 가능하지만 반드시 권장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bd608e2122cf39b6241e7c0694b05508a158bb5" translate="yes" xml:space="preserve">
          <source>It is primarily intended to be used in &lt;code&gt;ets:match/2&lt;/code&gt; and &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, to set record fields to the atom &lt;code&gt;'_'&lt;/code&gt;. (This is a wildcard in &lt;code&gt;ets:match/2&lt;/code&gt;.)</source>
          <target state="translated">레코드 필드를 원자 &lt;code&gt;'_'&lt;/code&gt; 로 설정 하기 위해 주로 &lt;code&gt;ets:match/2&lt;/code&gt; 및 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 에서 사용됩니다 . ( &lt;code&gt;ets:match/2&lt;/code&gt; 의 와일드 카드입니다 .)</target>
        </trans-unit>
        <trans-unit id="46e7fe56fdedc189f7070c8d58b82badd56c82e5" translate="yes" xml:space="preserve">
          <source>It is probably a good idea to do both wall-clock measurements and CPU time measurements.</source>
          <target state="translated">벽시계 측정과 CPU 시간 측정을 모두 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5a14f6ab8271ce6a90e3ad46573c990914b8aa87" translate="yes" xml:space="preserve">
          <source>It is rather costly to hibernate a process; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;. It is not something you want to do after every event.</source>
          <target state="translated">프로세스를 최대 절전 모드로 전환하는 데 비용이 많이 듭니다. &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 를 참조하십시오 . 모든 행사 후에하고 싶은 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3e4b9ac2fc75211bbe9ad50f5e40bfade9c76213" translate="yes" xml:space="preserve">
          <source>It is recommended by the SSH Connection Protocol to send this message, but that is not always the case.</source>
          <target state="translated">SSH 연결 프로토콜에서이 메시지를 보내는 것이 좋지만 항상 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3538339fde2ffca2f48c0ebf690413d3c9455c7f" translate="yes" xml:space="preserve">
          <source>It is recommended not to specify &lt;code&gt;LogFileOpts&lt;/code&gt; unless absolutely necessary. The default options used by the handler to open a file for logging are &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;, and &lt;code&gt;delayed_write&lt;/code&gt;. Notice that the standard handler does not have support for circular logging. Use the disk_log handler, &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, for this.</source>
          <target state="translated">꼭 필요한 경우가 아니면 &lt;code&gt;LogFileOpts&lt;/code&gt; 를 지정 하지 않는 것이 좋습니다 . 핸들러가 로깅을 위해 파일을 여는 데 사용하는 기본 옵션은 &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;append&lt;/code&gt; 및 &lt;code&gt;delayed_write&lt;/code&gt; 입니다. 표준 핸들러는 순환 로깅을 지원하지 않습니다. disk_log 핸들러 사용 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 이를 들어,.</target>
        </trans-unit>
        <trans-unit id="84dcefe80a30322b20b7d6bec52f8ca9cf6c5179" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt; 과 동일한 구조를 따르는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b386ae81313b705ebb70b487e37aefb55d196b01" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt; 과 동일한 구조를 따르는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ec7525c85fc1b0fc6b283c95390bdef2f3056b13" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt; 과 동일한 구조를 따르는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="783c04e3a082ab2be9d7c29f034cc09bfb7018db" translate="yes" xml:space="preserve">
          <source>It is recommended that application directories are named as the application, possibly followed by a dash and the version number. For example &lt;code&gt;myapp&lt;/code&gt; or &lt;code&gt;myapp-1.1&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 디렉토리의 이름을 응용 프로그램으로 지정하고 대시와 버전 번호를 지정하는 것이 좋습니다. 예를 들어, &lt;code&gt;myapp&lt;/code&gt; 또는 &lt;code&gt;myapp-1.1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d33efddc769eac5ce590e1e5ad80c9fa01a0ec69" translate="yes" xml:space="preserve">
          <source>It is recommended that the data files are not tampered with while &lt;code&gt;Mnesia&lt;/code&gt; is running. While not prohibited, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is unpredictable.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 가 실행되는 동안 데이터 파일이 변경되지 않는 것이 좋습니다 . 금지되지는 &lt;code&gt;Mnesia&lt;/code&gt; 의 행동 은 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a92359abef578e025508dcaa89e3308762079839" translate="yes" xml:space="preserve">
          <source>It is recommended that the embedded environment is run by an ordinary user, that is, a user who does not have super user privileges.</source>
          <target state="translated">임베디드 환경은 일반 사용자, 즉 수퍼 유저 권한이없는 사용자가 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="762df308b5cada2cb63ce0582b14513833afec03" translate="yes" xml:space="preserve">
          <source>It is recommended to add these lines to avoid a clash. The clash can make it impossible to boot the system.</source>
          <target state="translated">충돌을 피하기 위해이 줄을 추가하는 것이 좋습니다. 충돌로 인해 시스템을 부팅 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fd8b3ea5927d76b7682f8c2f4ad291b5b58b77d" translate="yes" xml:space="preserve">
          <source>It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets.</source>
          <target state="translated">필요한 경우 외부 엔터티와의 통신에 외부 인코딩 만 사용하는 것이 좋습니다. Erlang / OTP 환경에서 작업 할 때는 유니 코드 문자를 나타낼 때 바이너리를 UTF-8로 유지하는 것이 좋습니다. ISO Latin-1 인코딩은 이전 버전과의 호환성 및 유니 코드 문자 집합을 지원하지 않는 외부 엔터티와의 통신을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a86763d26205898122a82befc3a8840b014abd3a" translate="yes" xml:space="preserve">
          <source>It is recommended to set this parameter to &lt;code&gt;false&lt;/code&gt; on systems with many concurrent processes, as each process memory check makes a traversal of the entire list of processes.</source>
          <target state="translated">각 프로세스 메모리 검사에서 전체 프로세스 목록을 순회하므로 동시 프로세스가 많은 시스템에서는 이 매개 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="24e3dbfb80fbfa8e8fdafd6d93a77c0b3d9621a5" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;code&gt;ei_xreceive_msg&lt;/code&gt; instead when possible, for the sake of readability. However, the function will be retained in the interface for compatibility and will &lt;strong&gt;not&lt;/strong&gt; be removed in future releases without prior notice.</source>
          <target state="translated">가독성을 위해 가능한 경우 대신 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 를 사용하는 것이 좋습니다 . 그러나이 기능은 호환성을 위해 인터페이스에 유지 되며 향후 릴리스에서 사전 통지없이 제거 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f07eb0965b87ff02eea12ef51a97da8280fa42de" translate="yes" xml:space="preserve">
          <source>It is recommended to use keys like &lt;code&gt;?MODULE&lt;/code&gt; or &lt;code&gt;{?MODULE,SubKey}&lt;/code&gt; to avoid name collisions.</source>
          <target state="translated">이름 충돌을 피하기 위해 &lt;code&gt;?MODULE&lt;/code&gt; 또는 &lt;code&gt;{?MODULE,SubKey}&lt;/code&gt; 와 같은 키를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="68b150299a170408a969148f799267c01b2b3057" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;.hrl&lt;/code&gt; files created by the Erlang/OTP MIB compiler to define the Object Identifiers (OIDs). For example, to get the Erlang node name from &lt;code&gt;erlNodeTable&lt;/code&gt; in the OTP-MIB:</source>
          <target state="translated">Erlang / OTP MIB 컴파일러가 생성 한 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 사용하여 OID (Object Identifier)를 정의하는 것이 좋습니다 . 예를 들어, OTP-MIB의 &lt;code&gt;erlNodeTable&lt;/code&gt; 에서 Erlang 노드 이름을 가져 오려면 다음 을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="beb6f25876d5f5f2b17dc06907c6e940b602048d" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;record_info/2&lt;/code&gt; notation, as it becomes easier to maintain the program and the program becomes more robust with regards to future record changes.</source>
          <target state="translated">프로그램을 유지 관리하기가 더 쉬워지고 향후 레코드 변경과 관련하여 프로그램이 더욱 강력 해 지므로 &lt;code&gt;record_info/2&lt;/code&gt; 표기법 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b98f8e2acaa67a7dbb0c785ee6e89218b85a8106" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt; Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 부팅 스크립트를 만드는 것이 유용하거나 필요한 경우가 있습니다. 특히 임베디드 모드에서 Erlang을 실행할 때 그렇습니다 . &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt; Code Loading Strategy&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b76629f18d77250860872328b4b08636aca42ee" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">때때로 사용자 정의 부팅 스크립트를 작성하는 것이 유용하거나 필요합니다. 임베디드 모드에서 Erlang을 실행할 때 특히 그렇습니다 ( &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4428a0f8ea035e8ff8c49bdbc215a36fc422f39f" translate="yes" xml:space="preserve">
          <source>It is strongly recommend to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="translated">이 기능을 사용하고 비표준 방식으로 줄을 들여 쓰지 않는 것이 좋습니다. 몇 가지 동기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b50f3227925167fcdec205161b96c5f8d34fa936" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="translated">이 기능을 사용하고 비표준 방식으로 줄을 들여 쓰지 않는 것이 좋습니다. 몇 가지 동기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dce8043b4ef69a730f0893b68fe47eb9a7d53719" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array afterwards. It has been allocated by the function with a single call to &lt;code&gt;malloc()&lt;/code&gt;, so a single &lt;code&gt;free()&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">나중에 배열을 해제하는 것은 호출자의 책임입니다. &lt;code&gt;malloc()&lt;/code&gt; 대한 단일 호출로 함수에 의해 할당 되었으므로 단일 &lt;code&gt;free()&lt;/code&gt; 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="8a182802d5aa3c75c9fd2f1613ab45ae44c8ce7f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;ei_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">어레이를 해제하는 것은 호출자의 책임입니다. &lt;code&gt;ei_global_names&lt;/code&gt; 는 &lt;code&gt;malloc()&lt;/code&gt; 대한 단일 호출을 사용하여 배열과 모든 문자열을 할당 하므로 &lt;code&gt;free(names)&lt;/code&gt; 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="995f9fe18801008a7413cb59742eae29d2846eb4" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;erl_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">배열을 해제하는 것은 호출자의 책임입니다. &lt;code&gt;erl_global_names&lt;/code&gt; 는 &lt;code&gt;malloc()&lt;/code&gt; 대한 단일 호출을 사용하여 배열과 모든 문자열을 할당 하므로 &lt;code&gt;free(names)&lt;/code&gt; 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="72318ea3ee2cb4c60a442793c66f568591fae3fc" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the returned &lt;code&gt;ETERM&lt;/code&gt; structure and the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;.</source>
          <target state="translated">반환 된 &lt;code&gt;ETERM&lt;/code&gt; 구조와 &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 및 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 가 가리키는 메모리 를 해제하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="e90281b55dfbea943300fc790e2a254ba4758b5f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;, &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;, and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; , &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 및 &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; 이 가리키는 메모리를 해제하는 것은 호출자의 책임 입니다 .</target>
        </trans-unit>
        <trans-unit id="ffcb8bff0a2bc31b48d23416b425fa41cd4102ea" translate="yes" xml:space="preserve">
          <source>It is then possible to assign values as follows:</source>
          <target state="translated">그런 다음 다음과 같이 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24b56a6b7a78f70503c6ff661055208a04c51535" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; 에 주어진 Fun 내부의 코드 가 순수 하다는 것이 중요합니다 . 예를 들어 Fun 트랜잭션에서 메시지를 보내는 경우 이상한 결과가 발생할 수 있습니다. 다음 예는 이러한 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="32dd295574a144656b5cc3828c87c43e206ba562" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; 에 지정된 Fun 내부의 코드 가 순수해야합니다. 예를 들어 트랜잭션 Fun이 메시지를 보낸 경우 이상한 결과가 발생할 수 있습니다. 다음 예제는이 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52f4a38196075ad4a5127fd5f3778f1a63bfca93" translate="yes" xml:space="preserve">
          <source>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</source>
          <target state="translated">따라서 코드를 가능한 한 작은 단계로 변경하고 항상 이전 버전과 호환되는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d9ec68e380c2aeaf1e726fe77035c867ce201c19" translate="yes" xml:space="preserve">
          <source>It is to be (or result in) a call to any of the following:</source>
          <target state="translated">다음 중 하나를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f56ccb8476fcf4652fb1a09b059f74067c2b7dc" translate="yes" xml:space="preserve">
          <source>It is usually more efficient to split a binary using matching instead of calling the &lt;code&gt;split_binary/2&lt;/code&gt; function. Furthermore, mixing bit syntax matching and &lt;code&gt;split_binary/2&lt;/code&gt; can prevent some optimizations of bit syntax matching.</source>
          <target state="translated">&lt;code&gt;split_binary/2&lt;/code&gt; 함수 를 호출하는 대신 매칭을 사용하여 바이너리를 분할하는 것이 일반적으로 더 효율적 입니다. 또한 비트 구문 일치와 &lt;code&gt;split_binary/2&lt;/code&gt; 를 혼합하면 비트 구문 일치의 일부 최적화를 막을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40f0e2b9bfde282c6fadde5330a44421ff3e0a0" translate="yes" xml:space="preserve">
          <source>It is very easy to build a working OpenSSL FIPS Object Module and library from the source. However it &lt;strong&gt;does not&lt;/strong&gt; qualify as FIPS 140-2 validated if the numerous restrictions in the Security Policy are not properly followed.</source>
          <target state="translated">소스에서 작동하는 OpenSSL FIPS 오브젝트 모듈 및 라이브러리를 작성하는 것은 매우 쉽습니다. 그러나 그것은 &lt;strong&gt;하지 않는&lt;/strong&gt; 보안 정책에 많은 제한을 제대로 준수하지 않을 경우 FIPS 140-2 검증 자격.</target>
        </trans-unit>
        <trans-unit id="62c48e1d02aa5042a563d9cdc46a5c1f705ab388" translate="yes" xml:space="preserve">
          <source>It is vital to understand the difference between encodings and Unicode characters. Unicode characters are code points according to the Unicode standard, while the encodings are ways to represent such code points. An encoding is only a standard for representation. UTF-8 can, for example, be used to represent a very limited part of the Unicode character set (for example ISO-Latin-1) or the full Unicode range. It is only an encoding format.</source>
          <target state="translated">인코딩과 유니 코드 문자의 차이점을 이해하는 것이 중요합니다. 유니 코드 문자는 유니 코드 표준에 따른 코드 포인트 인 반면, 인코딩은 이러한 코드 포인트를 나타내는 방법입니다. 인코딩은 표현의 표준 일뿐입니다. 예를 들어 UTF-8을 사용하면 유니 코드 문자 집합의 매우 제한된 부분 (예 : ISO-Latin-1) 또는 전체 유니 코드 범위를 나타낼 수 있습니다. 인코딩 형식 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="0b9d2d00c773da9822d8e2592e3080b84694726c" translate="yes" xml:space="preserve">
          <source>It localizes a set of alternatives. For example, the following pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;:</source>
          <target state="translated">대안 세트를 현지화합니다. 예를 들어 다음 패턴은 &quot;cataract&quot;, &quot;caterpillar&quot;또는 &quot;cat&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="36ff8f13092a39bd2ba61c1ed0f713f6c5f51ed0" translate="yes" xml:space="preserve">
          <source>It makes debugging difficult (as a fault can be the result of a problem in a different test case than the one failing).</source>
          <target state="translated">오류가 발생하는 것과 다른 테스트 사례에서 문제가 발생할 수 있으므로 디버깅이 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="71e868c4d221d1f6e3b2db5cf4b3d7a681d61288" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases in a different order.</source>
          <target state="translated">테스트 케이스를 다른 순서로 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="607d901de681a7b70bb610e89380efa89701b1d6" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases individually.</source>
          <target state="translated">테스트 케이스를 개별적으로 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4d9bde63bab462d455aa3cb421fb8522231409c" translate="yes" xml:space="preserve">
          <source>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization.</source>
          <target state="translated">제목 &quot;aab&quot;에서 &quot;ab&quot;와 일치합니다. 역 추적 제어 동사 (* PRUNE) 및 (* SKIP)를 사용하면이 최적화가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ae6efd6ccdd0c384b5a13c5546c09169a3449d84" translate="yes" xml:space="preserve">
          <source>It may also raise the exception &lt;code&gt;error:notsup&lt;/code&gt; in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">또한 기본 OpenSSL 구현에 엔진 지원이없는 경우 예외 &lt;code&gt;error:notsup&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19d42ec8f2740a3cd0c2abd5afb5c44bd8a74c60" translate="yes" xml:space="preserve">
          <source>It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">기본 OpenSSL 구현에서 엔진을 지원하지 않는 경우 예외가 발생하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c74c37a77d9015d8cc2cde873f1e045e8626043" translate="yes" xml:space="preserve">
          <source>It may be impossible to know what (buffer) size is appropriate &quot;in advance&quot;, and in those cases it may be convenient to use the (recv) 'peek' flag. When this flag is provided, the message is *not* &quot;consumed&quot; from the underlying buffers, so another recvfrom call is needed, possibly with a then adjusted buffer size.</source>
          <target state="translated">어떤 (버퍼) 크기가 적절한 지 &quot;미리&quot;아는 것은 불가능할 수 있으며, 그런 경우 (recv) 'peek'플래그를 사용하는 것이 편리 할 수 ​​있습니다. 이 플래그가 제공되면 메시지는 기본 버퍼에서 &quot;소비 된&quot;* 아님 *이므로 버퍼 크기가 조정 된 다른 recvfrom 호출이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="96e63fe0213f34cbbed25cc7230c36479fd2b05a" translate="yes" xml:space="preserve">
          <source>It may be impossible to know what (buffer) size is appropriate &quot;in advance&quot;, and in those cases it may be convenient to use the (recv) 'peek' flag. When this flag is provided, the message is *not* &quot;consumed&quot; from the underlying buffers, so another recvmsg call is needed, possibly with a then adjusted buffer size.</source>
          <target state="translated">어떤 (버퍼) 크기가 적절한 지 &quot;미리&quot;아는 것은 불가능할 수 있으며, 그런 경우 (recv) 'peek'플래그를 사용하는 것이 편리 할 수 ​​있습니다. 이 플래그가 제공되면 메시지는 기본 버퍼에서 &quot;소비&quot;되지 * 않습니다 *. 따라서 버퍼 크기가 조정 된 다른 recvmsg 호출이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="338543b46e123502d18dfc5bfc5fdece95d218e9" translate="yes" xml:space="preserve">
          <source>It may not be possible to specify the default protocol (except when &lt;code&gt;Domain = local&lt;/code&gt;). We need to be able to retreive the resulting protocol, which is &lt;strong&gt;not&lt;/strong&gt; possble on all platforms.</source>
          <target state="translated">기본 프로토콜을 지정하지 못할 수 있습니다 ( &lt;code&gt;Domain = local&lt;/code&gt; 경우 제외 ). 모든 플랫폼에서 가능 &lt;strong&gt;하지 않은&lt;/strong&gt; 결과 프로토콜을 검색 할 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9ae8d33567c40fce809d17bd5e11afa0ce732fac" translate="yes" xml:space="preserve">
          <source>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Notice that the list &lt;code&gt;[a, b, c]&lt;/code&gt; can be written as &lt;code&gt;[a | [b | [c]]]&lt;/code&gt;. Using this, a list can be written as conses.</source>
          <target state="translated">미리 요소 수를 모르면 목록을 만들 수있는 방법이없는 것 같습니다. 그러나 실제로 방법이 있습니다. 리스트 &lt;code&gt;[a, b, c]&lt;/code&gt; 는 &lt;code&gt;[a | [b | [c]]]&lt;/code&gt; . 이를 사용하여 목록을 결과로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c879b18f150b020c56c6dce149540d933f7ca26" translate="yes" xml:space="preserve">
          <source>It might be necessary to introduce incompatible changes in order to solve a security issue. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">보안 문제를 해결하기 위해 호환되지 않는 변경 사항을 도입해야 할 수도 있습니다. 이러한 종류의 비 호환성은 패치에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af545030bc117fe554dbe2f7c3a3a6a615e4f7eb" translate="yes" xml:space="preserve">
          <source>It might point to the &lt;code&gt;init&lt;/code&gt; process if the &lt;code&gt;Fun&lt;/code&gt; was statically allocated when module was loaded (this optimisation is performed for local functions that do not capture the environment).</source>
          <target state="translated">모듈이로드 될 때 &lt;code&gt;Fun&lt;/code&gt; 이 정적으로 할당 된 경우 &lt;code&gt;init&lt;/code&gt; 프로세스를 가리킬 수 있습니다 (이 최적화는 환경을 캡처하지 않는 로컬 함수에 대해 수행됨).</target>
        </trans-unit>
        <trans-unit id="f6df38f1f74cd5ca73948bc650a636f7e7345d28" translate="yes" xml:space="preserve">
          <source>It might seem strange to do a two-step upgrade instead of just restarting the emulator with the new version of all applications. The reason for this design decision is to allow &lt;code&gt;code_change&lt;/code&gt; functions to have side effects, for example, changing data on disk. It also guarantees that the upgrade mechanism for non-core applications does not differ depending on whether or not core applications are changed at the same time.</source>
          <target state="translated">모든 응용 프로그램의 새 버전으로 에뮬레이터를 다시 시작하는 대신 2 단계 업그레이드를 수행하는 것이 이상하게 보일 수 있습니다. 이 디자인 결정의 이유는 &lt;code&gt;code_change&lt;/code&gt; 함수가 디스크에서 데이터를 변경하는 등의 부작용을 갖기 때문입니다. 또한 핵심 응용 프로그램이 동시에 변경되는지 여부에 따라 비 핵심 응용 프로그램의 업그레이드 메커니즘이 다르지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="1c34c71fa77eb63943ded2490f8fbc60c0d144da" translate="yes" xml:space="preserve">
          <source>It no longer matters (from a performance point of view) whether you write:</source>
          <target state="translated">더 이상 (성능 관점에서) 작성 여부는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c324ea70f963f73142902d03499b65a1148202cb" translate="yes" xml:space="preserve">
          <source>It only makes sense to define external generic instructions in the file &lt;code&gt;genop.tab&lt;/code&gt; in &lt;code&gt;lib/compiler/src&lt;/code&gt;, because the compiler must know about them in order to use them.</source>
          <target state="translated">그것은 단지 파일의 외부 일반적인 지침을 정의하는 것이 합리적 &lt;code&gt;genop.tab&lt;/code&gt; 에 &lt;code&gt;lib/compiler/src&lt;/code&gt; , 컴파일러를 사용하기 위해서는 그들에 대해 알고 있어야하기 때문이다.</target>
        </trans-unit>
        <trans-unit id="7c0489d666e1d6a42d00584a53dc773e8c02317f" translate="yes" xml:space="preserve">
          <source>It performs the following:</source>
          <target state="translated">다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4fc1e9aa2fcfb01c3fccf6fff85e215c7e86dd75" translate="yes" xml:space="preserve">
          <source>It requires the following entry in the configuration file:</source>
          <target state="translated">구성 파일에 다음 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4aee747e0c3b08a2000058880942c33ddee8f0ee" translate="yes" xml:space="preserve">
          <source>It returns the list obtained by applying the function to every argument in the list.</source>
          <target state="translated">리스트의 모든 인수에 함수를 적용하여 얻은리스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f32ea958d1b1b586fa5414a3a7ed52f8eb465554" translate="yes" xml:space="preserve">
          <source>It returns the value of &lt;code&gt;Exprs&lt;/code&gt; (a sequence of expressions &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt;) unless an exception occurs during the evaluation. In that case the exception is caught and the patterns &lt;code&gt;ExceptionPattern&lt;/code&gt; with the right exception class &lt;code&gt;Class&lt;/code&gt; are sequentially matched against the caught exception. If a match succeeds and the optional guard sequence &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;ExceptionBody&lt;/code&gt; is evaluated to become the return value.</source>
          <target state="translated">그것은의 값 반환 &lt;code&gt;Exprs&lt;/code&gt; (표현의 순서 &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt; 예외가 평가하는 동안 발생하지 않는 한)입니다. 이 경우 예외가 포착되고 올바른 예외 클래스가 &lt;code&gt;Class&lt;/code&gt; 인 &lt;code&gt;ExceptionPattern&lt;/code&gt; 패턴이 포착 된 예외 와 순차적으로 일치합니다. 일치하고 선택적 가드 시퀀스 &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; 가 true 인 경우 해당 &lt;code&gt;ExceptionBody&lt;/code&gt; 가 리턴 값이되도록 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f85990d4de42826fd89466e5ce7eebe1a15edc61" translate="yes" xml:space="preserve">
          <source>It sends the &lt;code&gt;io_reply&lt;/code&gt; tuple back to the client, providing element &lt;code&gt;ReplyAs&lt;/code&gt; received in the request along with the result of the request, as described earlier.</source>
          <target state="translated">&lt;code&gt;io_reply&lt;/code&gt; 튜플을 클라이언트로 다시 전송하여 요청에 수신 된 &lt;code&gt;ReplyAs&lt;/code&gt; 요소를 요청 결과와 함께 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6b6a1da626faadda605a267c6b1500e6d3d0ae88" translate="yes" xml:space="preserve">
          <source>It sets up the subpattern as a capturing subpattern. That is, when the complete pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller through the return value of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하위 패턴을 캡처 하위 패턴으로 설정합니다. 즉, 완전한 패턴이 일치하면 하위 패턴과 일치하는 주제 문자열의 해당 부분이 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 리턴 값을 통해 호출자에게 다시 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="49a082c6d89e819754d3f9153b8a7dfa0e39813e" translate="yes" xml:space="preserve">
          <source>It starts a tracer server and then sets the proper match spec (according to &lt;code&gt;Level&lt;/code&gt;).</source>
          <target state="translated">추적 프로그램 서버를 시작한 후 &lt;code&gt;Level&lt;/code&gt; 에 따라 적절한 일치 스펙을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="31112f0381a91b222a2817dba84ed1d667b040d2" translate="yes" xml:space="preserve">
          <source>It still works, but lacks for example I/O possibility. It is because of that compatibility we need the &lt;code&gt;{direct,...}&lt;/code&gt; construction.</source>
          <target state="translated">여전히 작동하지만 예를 들어 I / O 가능성이 없습니다. 그 호환성 때문에 &lt;code&gt;{direct,...}&lt;/code&gt; 구조 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="53405be9e406cd843e6767fd23eee426b478f794" translate="yes" xml:space="preserve">
          <source>It takes 32-bit salt values and generates hashes within &lt;code&gt;0..2^32-1&lt;/code&gt;.</source>
          <target state="translated">32 비트 솔트 값을 취하고 &lt;code&gt;0..2^32-1&lt;/code&gt; 내에 해시를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c42cf0c4b44711bb956523450bfed3115cf1f7e2" translate="yes" xml:space="preserve">
          <source>It turned out that using the old api in the new way (more about that later), and still keep it backwards compatible, was not possible. Specially as more precision in the error messages is desired it could not be combined with the old standard.</source>
          <target state="translated">이전 API를 새로운 방식 (나중에 더 자세히 설명)으로 사용하면서 이전 버전과의 호환성을 유지하는 것은 불가능하다는 것이 밝혀졌습니다. 특히 오류 메시지의 정확성이 더 요구되므로 이전 표준과 결합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b133d4d9bba6fcd143fa7778c2fc2dec25c3c1b" translate="yes" xml:space="preserve">
          <source>It uses only numeric or bitwise operators.</source>
          <target state="translated">숫자 또는 비트 연산자 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b267b9915cac30453e44b602e4b325db52e2a448" translate="yes" xml:space="preserve">
          <source>It would also be nice to get rid of the rwlock all together. The use of a reader optimized rwlock makes sure we do not any contention on the lock, but unnecessary memory barriers will be issued due to the lock. The main issue here is to modify iterating BIFs so that they do not require exclusive access to the table while reading a sequence of slots. In principle this should be rather easy, the code can handle sequences of variable sizes, so shrinking the sequence size of slots to one would solv the problem. This will, however, need some tweeks and modifications of not trival code, but is something that should be looked at in the future.</source>
          <target state="translated">rwlock을 모두 함께 제거하는 것도 좋을 것입니다. 판독기에 최적화 된 rwlock을 사용하면 잠금에 대한 경합이 발생하지 않지만 잠금으로 인해 불필요한 메모리 장벽이 발생합니다. 여기서 주요 문제는 반복되는 BIF를 수정하여 슬롯 시퀀스를 읽는 동안 테이블에 대한 배타적 액세스가 필요하지 않도록하는 것입니다. 원칙적으로 이것은 다소 쉬울 것입니다. 코드는 다양한 크기의 시퀀스를 처리 할 수 ​​있으므로 슬롯의 시퀀스 크기를 하나로 줄이면 문제가 해결됩니다. 그러나 이것은 트 라이벌 코드가 아닌 몇 주일과 수정이 필요하지만, 앞으로 살펴 봐야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b2540fbabc3c9158380baa45f0c22de898b8d1e1" translate="yes" xml:space="preserve">
          <source>It would also be possible to define it like this:</source>
          <target state="translated">다음과 같이 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="823797789dab9b16b0bc93679f0645c51a5106e7" translate="yes" xml:space="preserve">
          <source>It writes &quot;Ping received pong&quot; when this reply arrives, after which &quot;ping&quot; calls the &lt;code&gt;ping&lt;/code&gt; function again.</source>
          <target state="translated">이 응답이 도착하면 &quot;Ping received pong&quot;을 쓴 다음 &quot;ping&quot;이 &lt;code&gt;ping&lt;/code&gt; 기능을 다시 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="67225ea18531ad9a06624765739ff0f49809146c" translate="yes" xml:space="preserve">
          <source>It's assumed that the reader is familiar with &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt;. To be able to patch an application, the following must exist:</source>
          <target state="translated">독자는 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt; 익숙하다고 가정합니다 . 응용 프로그램을 패치하려면 다음이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5929da3898f0513dfeb23acbd712fe856694c82" translate="yes" xml:space="preserve">
          <source>It, however, uses a native implementation that does not build garbage on the heap and with slightly better performance.</source>
          <target state="translated">그러나 힙에 가비지를 작성하지 않고 약간 더 나은 성능을 제공하는 기본 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a06554ccb7c2d93d192c3296f349c54998105ca2" translate="yes" xml:space="preserve">
          <source>Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears.</source>
          <target state="translated">항목 (? p {...})은 런타임에 Perl 코드를 보간하며이 경우 표시되는 패턴을 재귀 적으로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="f9de605e9ca977eaf604ed29c15fb02f2b60a6a8" translate="yes" xml:space="preserve">
          <source>Items can be logged &lt;strong&gt;synchronously&lt;/strong&gt; by using functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt;. For each of these functions, the caller is put on hold until the items are logged (but not necessarily written, use &lt;code&gt;sync/1&lt;/code&gt; to ensure that). By adding an &lt;code&gt;a&lt;/code&gt; to each of the mentioned function names, we get functions that log items &lt;strong&gt;asynchronously&lt;/strong&gt;. Asynchronous functions do not wait for the disk log process to write the items to the file, but return the control to the caller more or less immediately.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 항목을 &lt;strong&gt;동 기적&lt;/strong&gt; 으로 로그 할 수 있습니다 . 이러한 각 기능에 대해 항목이 기록 될 때까지 호출자가 보류됩니다 (필수는 아니지만 반드시 &lt;code&gt;sync/1&lt;/code&gt; 을 사용 하여 확인하십시오). 언급 된 각 함수 이름에 &lt;code&gt;a&lt;/code&gt; 를 추가하여 항목을 &lt;strong&gt;비동기 적으로&lt;/strong&gt; 로그하는 함수를 얻습니다 . 비동기 함수는 디스크 로그 프로세스가 파일에 항목을 쓸 때까지 기다리지 않고 즉시 제어를 호출자에게 리턴합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71d4607a768e8062fc1b15efd7c3e9e68a5b3118" translate="yes" xml:space="preserve">
          <source>Iterate over the currently stored events.</source>
          <target state="translated">현재 저장된 이벤트를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="fcc26dcea46a8c4cabfbf0c36c28de8e261927eb" translate="yes" xml:space="preserve">
          <source>Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</source>
          <target state="translated">백업을 반복하여 새 백업으로 변환하거나 읽습니다. 여기에 논증이 간략하게 설명되어 있습니다. 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f75cc851edeeaf3491a906e7e439b3b971925d8d" translate="yes" xml:space="preserve">
          <source>Iterates over the currently stored events and applies a function for each event. The iteration may be performed forwards or backwards and may be limited to a maximum number of events (abs(Limit)).</source>
          <target state="translated">현재 저장된 이벤트를 반복하고 각 이벤트에 대한 기능을 적용합니다. 반복은 정방향 또는 역방향으로 수행 될 수 있으며 최대 이벤트 수 (abs (Limit))로 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a06d957ebec629d0f972194da6df852ad0d09740" translate="yes" xml:space="preserve">
          <source>Iterates over the table &lt;code&gt;Table&lt;/code&gt; and calls &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; for each &lt;code&gt;Record&lt;/code&gt; in the table. The term returned from &lt;code&gt;Function&lt;/code&gt; is used as the second argument in the next call to &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;Table&lt;/code&gt; 을 반복하고 테이블의 각 &lt;code&gt;Record&lt;/code&gt; 에 대해 &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; 을 호출 합니다. &lt;code&gt;Function&lt;/code&gt; 에서 반환 된 용어 는 다음에 &lt;code&gt;Function&lt;/code&gt; 호출시 두 번째 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="5786bb0f4dccffae9058c126884fe6758b70bd8a" translate="yes" xml:space="preserve">
          <source>Its syntax is as follows:</source>
          <target state="translated">구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0165af04c080f487130b22dea529e0f95b8d85ca" translate="yes" xml:space="preserve">
          <source>Its value can be evaluated to a constant when complied.</source>
          <target state="translated">준수 할 때 해당 값을 상수로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b9c42b14f3b80c83ccc522cfa693b39fd93fed6" translate="yes" xml:space="preserve">
          <source>JCL Mode</source>
          <target state="translated">JCL 모드</target>
        </trans-unit>
        <trans-unit id="9c706c391ec82badc3ec2e08de4f3bc19799ea82" translate="yes" xml:space="preserve">
          <source>JER encoding instructions</source>
          <target state="translated">JER 인코딩 지침</target>
        </trans-unit>
        <trans-unit id="3a7e6a489b783443722628f1a5e368b35cd12558" translate="yes" xml:space="preserve">
          <source>JUMP(Fail)</source>
          <target state="translated">JUMP(Fail)</target>
        </trans-unit>
        <trans-unit id="56d1de825316e64de255f931e870a2d3e72a7f4f" translate="yes" xml:space="preserve">
          <source>James logs on at c2@kosken:</source>
          <target state="translated">James가 c2 @ kosken에 로그온합니다.</target>
        </trans-unit>
        <trans-unit id="c42ecc8a80467df93a2c87a03b9343afff3e3487" translate="yes" xml:space="preserve">
          <source>James now tries to send a message to Fred:</source>
          <target state="translated">제임스는 이제 프레드에게 메시지를 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="5e448215b22256e2517ad0fd1cc0140dc720a94f" translate="yes" xml:space="preserve">
          <source>Java JDK 8 or later (optional) If you don't care about Java, you can skip this step. The result will be that jinterface is not built.</source>
          <target state="translated">Java JDK 8 이상 (선택 사항) Java에 관심이 없다면이 단계를 건너 뛸 수 있습니다. 그 결과 jinterface가 빌드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="9cdd767569c10e504770fd67a278cd9f65dc364a" translate="yes" xml:space="preserve">
          <source>Jinterface</source>
          <target state="translated">Jinterface</target>
        </trans-unit>
        <trans-unit id="985f31fc009e0eb1ee596f08399982c19f072dde" translate="yes" xml:space="preserve">
          <source>Jive - Removed from Erlang/OTP R7B.</source>
          <target state="translated">Jive-Erlang / OTP R7B에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="f404bac0df97acac197f63ffb414c0a51f6641b9" translate="yes" xml:space="preserve">
          <source>Jive provided a simple interface between an Erlang program and a Java program.</source>
          <target state="translated">Jive는 Erlang 프로그램과 Java 프로그램 사이에 간단한 인터페이스를 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="d4aaf0c42e0ce9df5b69e24e3360c3fccba4e12c" translate="yes" xml:space="preserve">
          <source>Job Control Mode, &lt;code&gt;JCL&lt;/code&gt;, in which jobs can be started, killed, detached, and connected</source>
          <target state="translated">작업을 시작, 종료, 분리 및 연결할 수있는 작업 제어 모드 ( &lt;code&gt;JCL&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="60fcc4fbeee80db53471e4e665b7867b155491ca" translate="yes" xml:space="preserve">
          <source>Joined specifications share common configuration settings, such as the list of &lt;code&gt;config&lt;/code&gt; files or &lt;code&gt;include&lt;/code&gt; directories. For configurations that cannot be combined, such as settings for &lt;code&gt;logdir&lt;/code&gt; or &lt;code&gt;verbosity&lt;/code&gt;, it is up to the user to ensure there are no clashes when the test specifications are joined. Specifications included with option &lt;code&gt;separate&lt;/code&gt; do not share configuration settings with the source specification. This is useful, for example, if there are clashing configuration settings in included specifications, making it them impossible to join.</source>
          <target state="translated">결합 된 사양은 &lt;code&gt;config&lt;/code&gt; 파일 목록 또는 &lt;code&gt;include&lt;/code&gt; 디렉토리 와 같은 일반적인 구성 설정을 공유합니다 . &lt;code&gt;logdir&lt;/code&gt; 또는 &lt;code&gt;verbosity&lt;/code&gt; 설정과 같이 결합 할 수없는 구성의 경우 테스트 사양을 결합 할 때 충돌이 없는지 사용자가 결정해야합니다. &lt;code&gt;separate&lt;/code&gt; 옵션에 포함 된 사양은 구성 사양을 소스 사양과 공유하지 않습니다. 예를 들어 포함 된 사양에 충돌하는 구성 설정이있어 가입 할 수없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="09836e547b774a1e0d6ccac306d02bc552ce1707" translate="yes" xml:space="preserve">
          <source>Joining a number of specifications, or running them separately, can also be accomplished with (and can be combined with) test specification file inclusion.</source>
          <target state="translated">테스트 사양 파일 포함을 사용하여 여러 사양을 결합하거나 별도로 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8fa532a1f183308b75829983ef5286dd43f6ae" translate="yes" xml:space="preserve">
          <source>Joins a list of filename &lt;code&gt;Components&lt;/code&gt; with directory separators. If one of the elements of &lt;code&gt;Components&lt;/code&gt; includes an absolute path, such as &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt;, the preceding elements, if any, are removed from the result.</source>
          <target state="translated">디렉토리 구분 기호를 사용하여 파일 이름 &lt;code&gt;Components&lt;/code&gt; 목록을 결합합니다 . &lt;code&gt;Components&lt;/code&gt; 의 요소 중 하나에 &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt; 와 같은 절대 경로가 포함 된 경우 이전 요소가 있으면 결과에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="767d4fa36d9593f6ccc09a43de0901229900dc82" translate="yes" xml:space="preserve">
          <source>Joins a multicast group.</source>
          <target state="translated">멀티 캐스트 그룹에 가입합니다.</target>
        </trans-unit>
        <trans-unit id="f18e485822fa69f055b28a9bb0d0a99a002c6e43" translate="yes" xml:space="preserve">
          <source>Joins an absolute directory with a relative filename. Similar to &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in &lt;code&gt;Filename&lt;/code&gt; are matched against trailing directory components in &lt;code&gt;Dir&lt;/code&gt; so they can be removed from the result - minimizing its length.</source>
          <target state="translated">상대 파일 이름으로 절대 디렉토리를 결합합니다. &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 원시 파일 이름 길이에 대한 엄격한 제한이 있고 기호 링크를 지원하지 않는 플랫폼 (VxWorks)에서는 &lt;code&gt;Filename&lt;/code&gt; 의 선행 상위 디렉토리 구성 요소가 &lt;code&gt;Dir&lt;/code&gt; 의 후행 디렉토리 구성 요소와 일치 하므로 결과에서 제거 될 수 있습니다. -길이를 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="b01e92d8e16fef4b631125f5e97915c826988378" translate="yes" xml:space="preserve">
          <source>Joins individual comment lines into multi-line comments. The input is a list of entries representing individual comment lines, &lt;strong&gt;in order of decreasing line-numbers&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; for details. The result is a list of entries representing &lt;strong&gt;multi-line&lt;/strong&gt; comments, &lt;strong&gt;still listed in order of decreasing line-numbers&lt;/strong&gt;, but where for each entry, &lt;code&gt;Text&lt;/code&gt; is a list of consecutive comment lines in order of &lt;strong&gt;increasing&lt;/strong&gt; line-numbers (i.e., top-down).</source>
          <target state="translated">개별 주석 행을 여러 줄 주석으로 결합합니다. 입력은 &lt;strong&gt;줄 번호의 내림차순으로&lt;/strong&gt; 개별 주석 줄을 나타내는 항목 목록입니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오. 결과는 &lt;strong&gt;줄 번호를 내림차순으로 나열한 &lt;/strong&gt;&lt;strong&gt;여러 줄&lt;/strong&gt; 주석을 나타내는 항목 목록 이지만 각 항목에 대해 &lt;code&gt;Text&lt;/code&gt; 는 줄 번호 를 &lt;strong&gt;증가시키는&lt;/strong&gt; 순서로 연속 주석 줄의 목록입니다 (예 : 하향식). ).&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dc90045824109fca3c74e3c2dd79f512aa8ec0c" translate="yes" xml:space="preserve">
          <source>Joins single process or multiple processes to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="translated">단일 프로세스 또는 여러 프로세스를 &lt;code&gt;Name&lt;/code&gt; 그룹에 결합 합니다. 프로세스는 그룹에 여러 번 참여할 수 있으며 동일한 횟수만큼 그룹에서 탈퇴해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0528c50bacb4e35cb285f0ed3e8896f71709c3e" translate="yes" xml:space="preserve">
          <source>Joins the calling thread with another thread, that is, the calling thread is blocked until the thread identified by &lt;code&gt;tid&lt;/code&gt; has terminated.</source>
          <target state="translated">호출 스레드를 다른 스레드와 결합합니다. 즉, 호출 스레드는 &lt;code&gt;tid&lt;/code&gt; 로 식별 된 스레드 가 종료 될 때까지 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="ed124b10c968f3ba56bc00750777640854ffbb45" translate="yes" xml:space="preserve">
          <source>Joins the process &lt;code&gt;Pid&lt;/code&gt; to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="translated">프로세스 &lt;code&gt;Pid&lt;/code&gt; 를 그룹 &lt;code&gt;Name&lt;/code&gt; 에 결합시킵니다 . 프로세스는 그룹에 여러 번 참여할 수 있으며 같은 수의 그룹을 떠나야합니다.</target>
        </trans-unit>
        <trans-unit id="a725b3a9aec37eb16b991bfa7ac62728bda90c3f" translate="yes" xml:space="preserve">
          <source>Joins two filename components with directory separators. Equivalent to &lt;code&gt;join([Name1, Name2])&lt;/code&gt;.</source>
          <target state="translated">두 개의 파일 이름 구성 요소를 디렉토리 구분 기호와 결합합니다. 등가 &lt;code&gt;join([Name1, Name2])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c209b4f5dd5eec8921277cc06b858d506fcc16" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^512 calls</source>
          <target state="translated">점프 기능 : 2 ^ 512 호출과 동일</target>
        </trans-unit>
        <trans-unit id="e9519676df51c9a760d29ebd09d2737821522add" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^64 calls</source>
          <target state="translated">점프 기능 : 2 ^ 64 호출과 동일</target>
        </trans-unit>
        <trans-unit id="993f27123cfb967c548d6417f96dc64d01aeac7a" translate="yes" xml:space="preserve">
          <source>Just add the &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; option to your command when you run the &lt;code&gt;configure&lt;/code&gt; script. If you are using systemtap, the configure option is &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 스크립트 를 실행할 때 &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; 옵션을 명령에 추가하십시오 . systemtap을 사용하는 경우 configure 옵션은 &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b611320826148a6230c5ef2adb69785b7a7a9d7" translate="yes" xml:space="preserve">
          <source>Just as a demonstration, we can add a &lt;code&gt;-no_prefetch&lt;/code&gt; directive to the &lt;code&gt;move/2&lt;/code&gt; instruction:</source>
          <target state="translated">데모처럼 &lt;code&gt;move/2&lt;/code&gt; 명령어에 &lt;code&gt;-no_prefetch&lt;/code&gt; 지시문을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="954a229b3c7d24932c013089be8a60de0b28ba48" translate="yes" xml:space="preserve">
          <source>Just prints a marker showing the current file and line number. Note that this is an argument-less macro. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">현재 파일과 줄 번호를 표시하는 마커를 인쇄합니다. 이것은 인수가없는 매크로입니다. 결과는 항상 &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="25abdae1d9ca507dc9eba57c2eaf4112edb57019" translate="yes" xml:space="preserve">
          <source>Keep alive (sends NOP to the server every 8 sec if connection is idle) = &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">연결 유지 (연결이 유휴 상태 인 경우 8 초마다 NOP를 서버에 전송) = &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ddeccd73131648e86aeb841d4eb296569a6a514" translate="yes" xml:space="preserve">
          <source>Keep in mind that external commands are highly dependent on the operating system. You can use the standard library function &lt;code&gt;os:type()&lt;/code&gt; in test generator functions, to produce different sets of tests depending on the current operating system.</source>
          <target state="translated">외부 명령은 운영 체제에 따라 크게 달라집니다. 테스트 생성기 함수에서 표준 라이브러리 함수 &lt;code&gt;os:type()&lt;/code&gt; 을 사용하여 현재 운영 체제에 따라 다른 테스트 세트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45ee9466d0be93f29125686a1cbd9782282e5eb8" translate="yes" xml:space="preserve">
          <source>Keep in mind that if the underlying OS &lt;code&gt;connect()&lt;/code&gt; call returns a timeout, &lt;code&gt;gen_tcp:connect&lt;/code&gt; will also return a timeout (i.e. &lt;code&gt;{error, etimedout}&lt;/code&gt;), even if a larger &lt;code&gt;Timeout&lt;/code&gt; was specified.</source>
          <target state="translated">기본 OS &lt;code&gt;connect()&lt;/code&gt; 호출이 시간 초과 를 반환 하면 더 큰 &lt;code&gt;Timeout&lt;/code&gt; 가 지정 &lt;code&gt;gen_tcp:connect&lt;/code&gt; 도 시간 초과 (예 : &lt;code&gt;{error, etimedout}&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="af2e28b7a1b7099319eee33d2a3b8c97b2e40baf" translate="yes" xml:space="preserve">
          <source>Keep the monitoring process neat and do not set the system monitor limits too tight.</source>
          <target state="translated">모니터링 프로세스를 깔끔하게 유지하고 시스템 모니터 제한을 너무 세게 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="500721d2cc2f16b61805dc2d3a9d1060f70c2830" translate="yes" xml:space="preserve">
          <source>Keeping an index table introduces some overhead when inserting records in the table. The number of operations gained from the table must therefore be compared against the number of operations inserting objects in the table. However, notice that the gain is significant when the key can be used to lookup elements.</source>
          <target state="translated">인덱스 테이블을 유지하면 테이블에 레코드를 삽입 할 때 약간의 오버 헤드가 발생합니다. 따라서 테이블에서 얻은 조작 수를 테이블에 오브젝트를 삽입하는 조작 수와 비교해야합니다. 그러나 키를 사용하여 요소를 조회 할 수있는 경우 게인이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="77d353f60b778f61763e54fe995206afd07d38e7" translate="yes" xml:space="preserve">
          <source>Kernel - Functionality necessary to run Erlang</source>
          <target state="translated">커널-Erlang을 실행하는 데 필요한 기능</target>
        </trans-unit>
        <trans-unit id="9b311a97505939c000087e862d0f4deafba1fdc1" translate="yes" xml:space="preserve">
          <source>Key :: &lt;code&gt;&lt;a href=&quot;#type-key&quot;&gt;key()&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">키 :: &lt;code&gt;&lt;a href=&quot;#type-key&quot;&gt;key()&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ec7e1a7afd70468b58a6a45217a2e808010638f9" translate="yes" xml:space="preserve">
          <source>Key :: filter_default,</source>
          <target state="translated">키 :: filter_default,</target>
        </trans-unit>
        <trans-unit id="26dc0e44f1ced76088c1d761ea664fe885bc865e" translate="yes" xml:space="preserve">
          <source>Key :: term(),</source>
          <target state="translated">키 :: term (),</target>
        </trans-unit>
        <trans-unit id="d94461d9eb74a4bd391db53e61a81a60c815b678" translate="yes" xml:space="preserve">
          <source>Key &lt;code&gt;mod&lt;/code&gt; is necessary for an application implemented as a supervision tree, otherwise the application controller does not know how to start it. &lt;code&gt;mod&lt;/code&gt; can be omitted for applications without processes, typically code libraries, for example, STDLIB.</source>
          <target state="translated">감독 트리로 구현 된 응용 프로그램에는 키 &lt;code&gt;mod&lt;/code&gt; 가 필요합니다. 그렇지 않으면 응용 프로그램 컨트롤러가이를 시작하는 방법을 모릅니다. 프로세스가없는 응용 프로그램, 일반적으로 코드 라이브러리 (예 : STDLIB)의 경우 &lt;code&gt;mod&lt;/code&gt; 를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6397ca66ce3b58cd7edcfd81299d71d5e083ac73" translate="yes" xml:space="preserve">
          <source>Key Equality</source>
          <target state="translated">핵심 평등</target>
        </trans-unit>
        <trans-unit id="f84946a9c6eeb1481d5b22997b26c2e0ed2cc12a" translate="yes" xml:space="preserve">
          <source>Key Exchange: ECDHE</source>
          <target state="translated">키 교환 : ECDHE</target>
        </trans-unit>
        <trans-unit id="8e6d5b439deefaa65c2dd5b4f472a6f796fb2c48" translate="yes" xml:space="preserve">
          <source>Key Share</source>
          <target state="translated">키 공유</target>
        </trans-unit>
        <trans-unit id="a1f470ba2d89f460de62ae07afdf74476dc26b66" translate="yes" xml:space="preserve">
          <source>Key and Initialization Vector Update is supported</source>
          <target state="translated">키 및 초기화 벡터 업데이트가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ca5a9efe453be1a8fb90eb103db6529be3cedecc" translate="yes" xml:space="preserve">
          <source>Key exchange.</source>
          <target state="translated">키 교환.</target>
        </trans-unit>
        <trans-unit id="ef9462cf7acc58f9332c44f3d35c8156471e2d59" translate="yes" xml:space="preserve">
          <source>Key length is 128, 192 or 256 bits</source>
          <target state="translated">키 길이는 128, 192 또는 256 비트입니다.</target>
        </trans-unit>
        <trans-unit id="8e49238278cd15e4058ff109458f7ab64787d062" translate="yes" xml:space="preserve">
          <source>Key length is 64 bits (in CBC mode only 8 bits are used)</source>
          <target state="translated">키 길이는 64 비트입니다 (CBC 모드에서는 8 비트 만 사용됨)</target>
        </trans-unit>
        <trans-unit id="a8eda14ae757b93056cfd42c03aa35572e0dfbf4" translate="yes" xml:space="preserve">
          <source>Key that thread-specific data can be associated with.</source>
          <target state="translated">스레드 특정 데이터를 연관시킬 수있는 키입니다.</target>
        </trans-unit>
        <trans-unit id="54bec160f0ff07cdaa698765d9e3b701a9206120" translate="yes" xml:space="preserve">
          <source>Key-value dictionary as ordered list.</source>
          <target state="translated">순서 목록으로서의 키-값 사전.</target>
        </trans-unit>
        <trans-unit id="03548558e8e95e2c9e4473346b7862a221a3449a" translate="yes" xml:space="preserve">
          <source>Key-value dictionary.</source>
          <target state="translated">키-값 사전.</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="f317a3c39acb1917a8e35e2c694160ac8d4dee6b" translate="yes" xml:space="preserve">
          <source>Keys and files</source>
          <target state="translated">키 및 파일</target>
        </trans-unit>
        <trans-unit id="64a1a6e2ae2f7e426d8c76fa00ed13e339774927" translate="yes" xml:space="preserve">
          <source>Keys and values are separated by the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow and associations are separated by a comma &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">키와 값은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 화살표로 구분되고 연결은 쉼표 ( &lt;code&gt;,&lt;/code&gt; ) 로 구분 됩니다.</target>
        </trans-unit>
        <trans-unit id="50ef25fb2e036bb0a08a44baf61c0ca27e1477ef" translate="yes" xml:space="preserve">
          <source>Keys are strings, that is, &lt;code&gt;NULL&lt;/code&gt;-terminated arrays of characters, and values are arbitrary objects. Although integers and floating point numbers are treated specially by the registry, you can store strings or binary objects of any type as pointers.</source>
          <target state="translated">키는 문자열, 즉 &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 문자 배열이며 값은 임의의 개체입니다. 정수와 부동 소수점 숫자는 레지스트리에서 특별히 처리되지만 문자열이나 이진 객체를 포인터로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="ae06f314c491ae0e878d4c91501cd37217955650" translate="yes" xml:space="preserve">
          <source>Khojki</source>
          <target state="translated">Khojki</target>
        </trans-unit>
        <trans-unit id="0aff8b4bceea8e19c584f9aea3e91bc8fa365436" translate="yes" xml:space="preserve">
          <source>Khudawadi</source>
          <target state="translated">Khudawadi</target>
        </trans-unit>
        <trans-unit id="f0368fc58ffcbb13dbf52da89366d4bc1cb1f40e" translate="yes" xml:space="preserve">
          <source>Kill EPMD</source>
          <target state="translated">EPMD 죽이기</target>
        </trans-unit>
        <trans-unit id="1d5d5869cb0eedafcc8a41f33ab897f070f4fb42" translate="yes" xml:space="preserve">
          <source>Kill line</source>
          <target state="translated">킬 라인</target>
        </trans-unit>
        <trans-unit id="f454e1ed16b6541108a62b0e0fc74e1cd5b5843d" translate="yes" xml:space="preserve">
          <source>Kill or suspend the current shell</source>
          <target state="translated">현재 쉘을 죽이거나 일시 중단</target>
        </trans-unit>
        <trans-unit id="880f10ee37e48d0c630a2a5789a5d88a3169af1e" translate="yes" xml:space="preserve">
          <source>Kill the receiving process.</source>
          <target state="translated">수신 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="5bfcbaee6e0f4c10a8cefbf0071cff67b1bf2828" translate="yes" xml:space="preserve">
          <source>Killing the running &lt;code&gt;epmd&lt;/code&gt; is only allowed if &lt;code&gt;epmd -names&lt;/code&gt; shows an empty database or if &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified when the running instance of &lt;code&gt;epmd&lt;/code&gt; was started.</source>
          <target state="translated">실행중인 죽이는 &lt;code&gt;epmd&lt;/code&gt; 경우에만 허용된다 &lt;code&gt;epmd -names&lt;/code&gt; 쇼 빈 데이터베이스를 경우 또는 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 가 의 실행중인 인스턴스 때 지정된 &lt;code&gt;epmd&lt;/code&gt; 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b4606adf1d6fece03ee95344c970518fc47aef2" translate="yes" xml:space="preserve">
          <source>Kills job number &lt;code&gt;nn&lt;/code&gt; or the current job. All spawned processes in the job are killed, provided they have not evaluated the &lt;code&gt;group_leader/1&lt;/code&gt; BIF and are located on the local machine. Processes spawned on remote nodes are not killed.</source>
          <target state="translated">작업 번호 &lt;code&gt;nn&lt;/code&gt; 또는 현재 작업을 종료합니다. &lt;code&gt;group_leader/1&lt;/code&gt; BIF를 평가하지 않고 로컬 시스템에있는 경우 작업에서 생성 된 모든 프로세스가 종료 됩니다. 원격 노드에서 생성 된 프로세스는 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc10a5d2feb24085bc1cb119b2435586c453c952" translate="yes" xml:space="preserve">
          <source>Kills the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">현재 실행중인 &lt;code&gt;epmd&lt;/code&gt; 를 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="d077f8d3e486ad628e73d06261b975a13986914e" translate="yes" xml:space="preserve">
          <source>Knowing that an operand is not always used can improve how packing is done for some instructions.</source>
          <target state="translated">피연산자가 항상 사용되는 것은 아니라는 것을 알면 일부 명령어에 대해 패킹이 수행되는 방식을 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b4bd81f6a1807f205eb7b39db738fc67e5d76b" translate="yes" xml:space="preserve">
          <source>Known Hosts - OpenSSH Format</source>
          <target state="translated">알려진 호스트-OpenSSH 형식</target>
        </trans-unit>
        <trans-unit id="0240977ffaeac0a7cbbd595196b651a1f287d553" translate="yes" xml:space="preserve">
          <source>Known Limitation</source>
          <target state="translated">알려진 제한</target>
        </trans-unit>
        <trans-unit id="616ae0e516f073c066a59a8a38d5b52110f5407c" translate="yes" xml:space="preserve">
          <source>Known Limitations</source>
          <target state="translated">알려진 제한</target>
        </trans-unit>
        <trans-unit id="9d84b2a4d9545512a2d7f125ae79d81a8e5c0761" translate="yes" xml:space="preserve">
          <source>Known hosts - OpenSSH format looks as follows:</source>
          <target state="translated">알려진 호스트-OpenSSH 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a39eb519037dfb6d76d299ba4999c6ffc80181b" translate="yes" xml:space="preserve">
          <source>Known issue: When a node is restarted multiple times with the same node name, references created on a newer node can be mistaken for a reference created on an older node with the same node name.</source>
          <target state="translated">알려진 문제 : 동일한 노드 이름으로 노드를 여러 번 다시 시작하면 새로운 노드에서 작성된 참조가 동일한 노드 이름을 가진 이전 노드에서 작성된 참조로 오인 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf67592c20c9144029824037c9c62ac2e394e9f6" translate="yes" xml:space="preserve">
          <source>Known nodes</source>
          <target state="translated">알려진 노드</target>
        </trans-unit>
        <trans-unit id="ed13795fff22b6ce7eef6295ec8759f5887cc8c1" translate="yes" xml:space="preserve">
          <source>LALR-1 Parser Generator</source>
          <target state="translated">LALR-1 파서 생성기</target>
        </trans-unit>
        <trans-unit id="8c1317978bcd30e222ba66c242f8123e43c7856b" translate="yes" xml:space="preserve">
          <source>LDAP Client</source>
          <target state="translated">LDAP 클라이언트</target>
        </trans-unit>
        <trans-unit id="51eb7d6d9c204fdf12fe469c25a3f66ed762d7c2" translate="yes" xml:space="preserve">
          <source>LTTng-UST: user space tracing library.</source>
          <target state="translated">LTTng-UST : 사용자 공간 추적 라이브러리.</target>
        </trans-unit>
        <trans-unit id="1a3e364b61f5b7002da39483efb6f5c6e878f8ed" translate="yes" xml:space="preserve">
          <source>LTTng-tools: a command line interface to control tracing sessions.</source>
          <target state="translated">LTTng-tools : 추적 세션을 제어하기위한 명령 행 인터페이스.</target>
        </trans-unit>
        <trans-unit id="835d9d02d574ee591fe276efb1ca4a509eeac77d" translate="yes" xml:space="preserve">
          <source>Label (type) of the event.</source>
          <target state="translated">이벤트의 레이블 (유형).</target>
        </trans-unit>
        <trans-unit id="da8c0bd743f4d20bdd7803e99770281ada2c9a3c" translate="yes" xml:space="preserve">
          <source>Label intended to provide a brief event summary.</source>
          <target state="translated">간단한 이벤트 요약을 제공하기위한 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="569411a8a6e7229622b5dc0e1261f3311e3e9ca4" translate="yes" xml:space="preserve">
          <source>Label the test run (similar to &lt;code&gt;ct_run -label&lt;/code&gt;).</source>
          <target state="translated">테스트 실행에 레이블을 지정하십시오 ( &lt;code&gt;ct_run -label&lt;/code&gt; 과 유사 ).</target>
        </trans-unit>
        <trans-unit id="043cffbb1435e33554384174474c4348b7979705" translate="yes" xml:space="preserve">
          <source>Labels each expression in the tree. A term &lt;code&gt;{label, L}&lt;/code&gt; is prefixed to the annotation list of each expression node, where L is a unique number for every node, except for variables (and function name variables) which get the same label if they represent the same variable. Constant literal nodes are not labeled.</source>
          <target state="translated">트리의 각 표현식에 레이블을 지정합니다. 용어 &lt;code&gt;{label, L}&lt;/code&gt; 은 각 표현식 노드의 주석 목록에 접두어로 추가됩니다. 여기서 L은 동일한 변수를 나타내는 경우 동일한 레이블을 갖는 변수 (및 함수 이름 변수)를 제외하고 모든 노드에 대한 고유 번호입니다. 상수 리터럴 노드는 ​​레이블이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a2ceed634c06e53fd54795bf2ad3a353a944142" translate="yes" xml:space="preserve">
          <source>Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token will be silenty dropped if it crosses over to a node that does not support the label.</source>
          <target state="translated">레이블은 OTP 21 이전에 작은 부호있는 정수 (28 비트)로 제한되었습니다. 추적 토큰이 레이블을 지원하지 않는 노드로 넘어 가면 추적 토큰이 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca0beae5821435b0fbc549f128dd2d696efd3c9" translate="yes" xml:space="preserve">
          <source>Lack of support. Such as loading NIF library for a HiPE compiled module.</source>
          <target state="translated">지원 부족. HiPE 컴파일 된 모듈을위한 NIF 라이브러리 로딩과 같은.</target>
        </trans-unit>
        <trans-unit id="bf9167c4d0a9ea5934fd36027e2b85a918a6fffd" translate="yes" xml:space="preserve">
          <source>Language constructions such as &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;catch&lt;/code&gt; that are not present in match specifications are not allowed.</source>
          <target state="translated">일치 스펙에없는 &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 와 같은 언어 구성 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="074e87167a892ed75f793d4be4f6837d502c8b01" translate="yes" xml:space="preserve">
          <source>Language or locale specific handling of input is not considered in any function.</source>
          <target state="translated">언어 또는 로케일 별 입력 처리는 어떤 기능에서도 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04eb4ab3dd59acb8c8766875365c70ae815f2eeb" translate="yes" xml:space="preserve">
          <source>Languages with no concept of upper case (or lower case).</source>
          <target state="translated">대문자 (또는 소문자) 개념이없는 언어</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="738fd1d2452fc31a236c5ad511bfcc46b324365e" translate="yes" xml:space="preserve">
          <source>Large</source>
          <target state="translated">Large</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">대용량 파일 지원</target>
        </trans-unit>
        <trans-unit id="a438bdcc6fdd98852d15b24d8295882a73c68552" translate="yes" xml:space="preserve">
          <source>Large Map (&amp;gt; 32 keys)</source>
          <target state="translated">큰지도 (&amp;gt; 32 키)</target>
        </trans-unit>
        <trans-unit id="09edce0ea90a1c7861091688fe21ce083d692315" translate="yes" xml:space="preserve">
          <source>Large bursts of log events - many events received by the handler under a short period of time - can potentially cause problems, such as:</source>
          <target state="translated">처리기에서 짧은 시간 내에 많은 이벤트를 수신 한 대량의 로그 이벤트는 다음과 같은 문제를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54100e7e3068c1ca218d4f103c9eb3344bef2359" translate="yes" xml:space="preserve">
          <source>Large integer</source>
          <target state="translated">큰 정수</target>
        </trans-unit>
        <trans-unit id="d84176d4d4e07b609ddf89b910ffa92d9b205afb" translate="yes" xml:space="preserve">
          <source>Large-scale automated testing requires running multiple independent test sessions in parallel. This is accomplished by running some &lt;code&gt;Common Test&lt;/code&gt; nodes on one or more hosts, testing different target systems. Configuring, starting, and controlling the test nodes independently can be a cumbersome operation. To aid this kind of automated large-scale testing, &lt;code&gt;Common Test&lt;/code&gt; offers a master test node component, &lt;code&gt;Common Test&lt;/code&gt; Master, which handles central configuration and control in a system of distributed &lt;code&gt;Common Test&lt;/code&gt; nodes.</source>
          <target state="translated">대규모 자동 테스트에는 여러 개의 독립적 인 테스트 세션을 병렬로 실행해야합니다. 이는 하나 이상의 호스트에서 일부 &lt;code&gt;Common Test&lt;/code&gt; 노드를 실행 하여 다른 대상 시스템을 테스트하여 수행됩니다. 테스트 노드를 독립적으로 구성, 시작 및 제어하는 ​​것은 번거로운 작업 일 수 있습니다. 이러한 종류의 자동화 된 대규모 테스트를 지원하기 위해 &lt;code&gt;Common Test&lt;/code&gt; 는 분산 &lt;code&gt;Common Test&lt;/code&gt; 노드 시스템에서 중앙 구성 및 제어를 처리 하는 마스터 테스트 노드 구성 요소 인 &lt;code&gt;Common Test&lt;/code&gt; 마스터를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="44df0948d1567d9036374aa410e4c8a2be0c9c10" translate="yes" xml:space="preserve">
          <source>Larger programs are usually written as a collection of files with a well-defined interface between the various parts.</source>
          <target state="translated">더 큰 프로그램은 일반적으로 다양한 부분 사이에 잘 ​​정의 된 인터페이스를 가진 파일 모음으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="693744ef4c03b347c7a1a709150a100f34f5dd75" translate="yes" xml:space="preserve">
          <source>Larger test cases make it harder to tell what went wrong if it fails. Also, large portions of test code risk being skipped when errors occur.</source>
          <target state="translated">테스트 케이스가 클수록 실패 할 경우 무엇이 잘못되었는지 알기가 더 어렵습니다. 또한 오류가 발생할 때 테스트 코드 위험의 대부분이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="1b435236d148d33634d75be98a7f8ff0238652ce" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt; The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 64 MB.</source>
          <target state="translated">가장 큰 ( &lt;code&gt;mseg_alloc&lt;/code&gt; ) 멀티 블록 캐리어 크기 (KB). &lt;code&gt;mseg_alloc&lt;/code&gt; 다중 블록 캐리어의 크기 가 결정되는 방법에 대한 설명 &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt; The alloc_util Framework&lt;/a&gt;&lt;/code&gt; 섹션에서 참조하십시오 . 32 비트 Unix 스타일 OS에서는이 제한을 64MB 이상으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8908c45e62de1705042c387b70533568d70c9293" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 128 MB.</source>
          <target state="translated">가장 큰 ( &lt;code&gt;mseg_alloc&lt;/code&gt; ) 멀티 블록 캐리어 크기 (킬로바이트). &lt;code&gt;mseg_alloc&lt;/code&gt; 멀티 블록 캐리어의 크기가 &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt; 섹션에서 결정되는 방법에 대한 설명을 참조하십시오 . 32 비트 Unix 스타일 OS에서는이 제한을 128MB보다 크게 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c3af79a814ee249e319b2aca0ff91587147fc1f" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">에 마지막 인수 &lt;code&gt;start_link/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff3ac5eb04bb6845c35e02907378511f958744f" translate="yes" xml:space="preserve">
          <source>Last trans id.</source>
          <target state="translated">마지막 거래 ID</target>
        </trans-unit>
        <trans-unit id="92691b5a6cdf3c7e69cbf1e0e1a0775e6d6241e3" translate="yes" xml:space="preserve">
          <source>Last, the application master terminates. Notice that all processes with the application master as group leader, that is, processes spawned from a process belonging to the application, are also terminated.</source>
          <target state="translated">마지막으로 응용 프로그램 마스터가 종료됩니다. 응용 프로그램 마스터를 그룹 리더로 사용하는 모든 프로세스, 즉 응용 프로그램에 속하는 프로세스에서 생성 된 프로세스도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e67316d545772b35f3ccfda079c9a6451806f0ad" translate="yes" xml:space="preserve">
          <source>Later, when you have fixed a bug in your application my_app, you want to update the PLT so that it becomes fresh the next time you run Dialyzer. In this case, run the following command:</source>
          <target state="translated">나중에 응용 프로그램 my_app에서 버그를 수정하면 다음에 Dialyzer를 실행할 때 새로워 지도록 PLT를 업데이트하려고합니다. 이 경우 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="0870ce81860445392cddd5a3e67af112160f7b41" translate="yes" xml:space="preserve">
          <source>Leading slashes in tar member names will be removed before writing the file. That is, absolute paths will be turned into relative paths. There will be an info message written to the error logger when paths are changed in this way.</source>
          <target state="translated">tar 멤버 이름의 선행 슬래시는 파일을 쓰기 전에 제거됩니다. 즉, 절대 경로는 상대 경로로 바뀝니다. 이러한 방식으로 경로가 변경되면 오류 로거에 정보 메시지가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="47b8a505fbd2560ad30175ab17add0932e2fcd2a" translate="yes" xml:space="preserve">
          <source>Leading zeroes are ignored. Single underscore &lt;code&gt;_&lt;/code&gt; can be inserted between digits as a visual separator.</source>
          <target state="translated">선행 0은 무시됩니다. 단일 밑줄 &lt;code&gt;_&lt;/code&gt; 을 시각적 구분 기호로 숫자 사이에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e94aa1c6222c80f386ab41d6d2143723fd28ef" translate="yes" xml:space="preserve">
          <source>Leap Years</source>
          <target state="translated">윤년</target>
        </trans-unit>
        <trans-unit id="0eb1f77fb19c9a09977d5bd220a6012ba74f0842" translate="yes" xml:space="preserve">
          <source>Leaves a multicast group.</source>
          <target state="translated">멀티 캐스트 그룹을 떠납니다.</target>
        </trans-unit>
        <trans-unit id="46ca3dd951cfb863abc35ba1a75861a27f06846b" translate="yes" xml:space="preserve">
          <source>Leaves it up to the user to read and interpret the logged data. The &lt;code&gt;disk_log&lt;/code&gt; module cannot repair externally formatted logs.</source>
          <target state="translated">기록 된 데이터를 읽고 해석 할 수 있도록 사용자에게 맡깁니다. &lt;code&gt;disk_log&lt;/code&gt; 모듈은 외부 형식의 로그를 복구 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3210120e1c6a9da2f06b35919f757a581401639" translate="yes" xml:space="preserve">
          <source>Leex will add the extension &lt;code&gt;.hrl&lt;/code&gt; to the &lt;code&gt;Includefile&lt;/code&gt; name and the extension &lt;code&gt;.erl&lt;/code&gt; to the &lt;code&gt;Scannerfile&lt;/code&gt; name, unless the extension is already there.</source>
          <target state="translated">Leex은 연장 추가합니다 &lt;code&gt;.hrl&lt;/code&gt; 을 받는 &lt;code&gt;Includefile&lt;/code&gt; 의 이름과 확장 &lt;code&gt;.erl&lt;/code&gt; 받는 &lt;code&gt;Scannerfile&lt;/code&gt; 의 확장이 이미 존재하지 않는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1ac95874a8d20e24893ff29b459f57b2ffdf6541" translate="yes" xml:space="preserve">
          <source>Left associative</source>
          <target state="translated">왼쪽 연관</target>
        </trans-unit>
        <trans-unit id="8565991e36224ecb55a79ffde16fa430f01d691e" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;process_msg/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">별도의 &lt;code&gt;IpAddr&lt;/code&gt; 및 &lt;code&gt;PortNumber&lt;/code&gt; 인수가있는 레거시 API 함수 &lt;code&gt;process_msg/7&lt;/code&gt; 은 이전 버전과의 호환성 이유로 여전히 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0f4bbc3721d99d879f2d29eca510835d82ca11bd" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;send_pdu/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">별도의 &lt;code&gt;IpAddr&lt;/code&gt; 및 &lt;code&gt;PortNumber&lt;/code&gt; &lt;code&gt;send_pdu/7&lt;/code&gt; 레거시 API 함수 send_pdu / 7 은 이전 버전과의 호환성 이유로 여전히 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a868752c2e0e19bf0913ba9d30f9f18839603e09" translate="yes" xml:space="preserve">
          <source>Legacy API functions &lt;code&gt;add_addr/10&lt;/code&gt; that does not specify transport domain, and &lt;code&gt;add_addr/11&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still work as before for backwards compatibility reasons.</source>
          <target state="translated">전송 도메인을 지정하지 않는 레거시 API 함수 &lt;code&gt;add_addr/10&lt;/code&gt; 및 별도의 &lt;code&gt;IpAddr&lt;/code&gt; 및 &lt;code&gt;PortNumber&lt;/code&gt; 인수가있는 &lt;code&gt;add_addr/11&lt;/code&gt; 은 이전 버전과의 호환성 이유로 여전히 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2c597c4b003d18d8f6683d7d10d1da508314f6e0" translate="yes" xml:space="preserve">
          <source>Legacy Functions</source>
          <target state="translated">레거시 기능</target>
        </trans-unit>
        <trans-unit id="4486c03db98a7fec674973adef6214fc73ffdd8c" translate="yes" xml:space="preserve">
          <source>Legacy configurations using tuples without &lt;code&gt;Domain&lt;/code&gt; element, as well as with all &lt;code&gt;TDomain&lt;/code&gt;, &lt;code&gt;Ip&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; elements still work.</source>
          <target state="translated">모든 &lt;code&gt;TDomain&lt;/code&gt; , &lt;code&gt;Ip&lt;/code&gt; 및 &lt;code&gt;Port&lt;/code&gt; 요소 뿐만 아니라 &lt;code&gt;Domain&lt;/code&gt; 요소가 없는 튜플을 사용하는 레거시 구성은 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="71367be8ed058ebcc73246ba1f97385975bee2e8" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP agent is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">레거시 네트워크 인터페이스 필터 모듈 은 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; 대신 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 형식의 인수 를 사용했으며 전송 도메인을 사용하도록 구성을 변경하지 않고 SNMP 에이전트가 실행되는 경우 네트워크 인터페이스 필터 여전히 오래된 주장을 얻고 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0c7683d8adcfcd8643203d0f2de9c1dd2d464605" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP manager is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">레거시 네트워크 인터페이스 필터 모듈 은 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; 대신 &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; 형식의 인수 를 사용했으며 전송 도메인을 사용하도록 구성을 변경하지 않고 SNMP 관리자가 실행되는 경우 네트워크 인터페이스 필터 여전히 오래된 주장을 얻고 이전과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e898fde08048c9f9f4cb5920c5ef464a7652e35b" translate="yes" xml:space="preserve">
          <source>Legacy notification delivery information receiver modules used a target argument on the form &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; instead of &lt;code&gt;{Domain, Addr}&lt;/code&gt;, and if the SNMP Agent is run without changing the configuration to use transport domains the notification delivery information receiver will still get the old arguments and work as before.</source>
          <target state="translated">레거시 알림 배달 정보 수신기 모듈 은 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 대신 &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; 형식의 대상 인수 를 사용했으며 전송 도메인을 사용하도록 구성을 변경하지 않고 SNMP 에이전트를 실행하는 경우 알림 배달 정보 수신기는 여전히 이전 주장과 이전처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1e08ec2ca11598f98010b341769a06c738201d73" translate="yes" xml:space="preserve">
          <source>Legacy parts of erl_interface</source>
          <target state="translated">erl_interface의 레거시 부분</target>
        </trans-unit>
        <trans-unit id="018b204a37dd2a9505f340e2927d8d648c29228b" translate="yes" xml:space="preserve">
          <source>Legacy solutions may eventually need to be removed. In such cases, they will be phased out on a long enough time period to give users the time to adapt. Before removal of functionality it will be deprecated at least during one release with an explicit announcement about the upcoming removal. A new deprecation will at least be announced in a release note and the documentation.</source>
          <target state="translated">레거시 솔루션은 결국 제거해야 할 수도 있습니다. 그러한 경우, 사용자에게 적응할 시간을주기에 충분한 시간 동안 단계적으로 제거됩니다. 기능을 제거하기 전에 향후 릴리스에 대한 명시적인 발표와 함께 최소한 한 번의 릴리스 동안 더 이상 사용되지 않습니다. 새로운 지원 중단은 최소한 릴리스 노트와 문서에서 발표 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1773bd5f1b30eddc0d699c8591ba090a7523c655" translate="yes" xml:space="preserve">
          <source>Legacy string used in CGI, just ignore.</source>
          <target state="translated">CGI에서 사용되는 레거시 문자열은 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="625b83df9b71ae174e6f9e5f483d636b4e85f3a9" translate="yes" xml:space="preserve">
          <source>Len</source>
          <target state="translated">Len</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="169c8a5cbd42e1499cc493ecd3316ae82374f224" translate="yes" xml:space="preserve">
          <source>Length of a node name</source>
          <target state="translated">노드 이름의 길이</target>
        </trans-unit>
        <trans-unit id="d326c8e60791bd80c030a051ea704db236992dae" translate="yes" xml:space="preserve">
          <source>Length of command sequences</source>
          <target state="translated">명령 시퀀스의 길이</target>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">이하</target>
        </trans-unit>
        <trans-unit id="d39f560b8c87e0c4b3a30cf39bb72967048838d1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;SetOfSets&lt;/code&gt; be a set of sets and &lt;code&gt;BinRel&lt;/code&gt; a binary relation. The function that maps each element &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;SetOfSets&lt;/code&gt; onto the &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; under &lt;code&gt;BinRel&lt;/code&gt; is returned by the following function:</source>
          <target state="translated">하자 &lt;code&gt;SetOfSets&lt;/code&gt; 이 세트의 세트하고 &lt;code&gt;BinRel&lt;/code&gt; 이진 관계. 각 요소의 매핑 기능 &lt;code&gt;Set&lt;/code&gt; 의 &lt;code&gt;SetOfSets&lt;/code&gt; 을 상 &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;Set&lt;/code&gt; 아래 &lt;code&gt;BinRel&lt;/code&gt; 은 다음 함수에 의해 리턴된다 :</target>
        </trans-unit>
        <trans-unit id="9f91f5a1240b87dec80e3e2107742012305cec9c" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created outside of a trace sequence. The counters are updated at the following occasions:</source>
          <target state="translated">각 프로세스에 &lt;code&gt;prev_cnt&lt;/code&gt; 및 &lt;code&gt;curr_cnt&lt;/code&gt; 라는 두 개의 카운터가 있으며 , 둘 다 프로세스가 추적 시퀀스 외부에서 생성 될 때 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 카운터는 다음과 같은 경우에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="aeac5d618aebeec528fc023b1fd7a175e4c5012b" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created. The counters are updated at the following occasions:</source>
          <target state="translated">각 프로세스에 두 개의 카운터 &lt;code&gt;prev_cnt&lt;/code&gt; 및 &lt;code&gt;curr_cnt&lt;/code&gt; 가 있고 프로세스가 작성 될 때 둘 다 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 카운터는 다음과 같은 경우에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d42e517ccaad48e6627d644a84fd1a33bb06509e" translate="yes" xml:space="preserve">
          <source>Let the Megaco stack start the flex scanner (load the driver).</source>
          <target state="translated">Megaco 스택이 플렉스 스캐너를 시작하게하십시오 (드라이버로드).</target>
        </trans-unit>
        <trans-unit id="604be9425d1bfef18f4166b2d117691ea3dd6d24" translate="yes" xml:space="preserve">
          <source>Let the serial of the trace token be &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt;.</source>
          <target state="translated">추적 토큰의 일련 번호를 &lt;code&gt;tprev&lt;/code&gt; 및 &lt;code&gt;tcurr&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="666a11ac8c95c51bf7258a4bd007f2a9fa01440e" translate="yes" xml:space="preserve">
          <source>Let this process start the flex scanner by calling the &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; function.</source>
          <target state="translated">이 프로세스에서 &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; 함수 를 호출하여 flex 스캐너를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="def84ff207439fffb76419aef627ce0d25f81d91" translate="yes" xml:space="preserve">
          <source>Let us (again) print the temperatures in a list of cities:</source>
          <target state="translated">도시 목록에 온도를 다시 인쇄합시다.</target>
        </trans-unit>
        <trans-unit id="c56d0e103691130e00273549b1e131c9fced0666" translate="yes" xml:space="preserve">
          <source>Let us assume there are two computers called gollum and kosken. First a node is started on kosken, called ping, and then a node on gollum, called pong.</source>
          <target state="translated">골룸과 코스 켄이라는 두 대의 컴퓨터가 있다고 가정 해 봅시다. 먼저 ping이라는 kosken에서 노드를 시작한 다음 pong이라는 gollum에서 노드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c3a7214e52200df1fa690005e2d061b16388a1ae" translate="yes" xml:space="preserve">
          <source>Let us break that apart into its components. First we have the distribution header tags together with the sequence id and a fragment id of 2.</source>
          <target state="translated">이를 구성 요소로 분리 해 보겠습니다. 먼저 배포 헤더 태그와 함께 시퀀스 ID 및 조각 ID 2가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d58ae25061d9ff7638fc2f52191b818f3f601803" translate="yes" xml:space="preserve">
          <source>Let us continue down the printout to find:</source>
          <target state="translated">출력물을 계속 찾아서 다음을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="3dcdf9690d199e15a9324121e54d91e81837cbbc" translate="yes" xml:space="preserve">
          <source>Let us find the &lt;code&gt;suspend&lt;/code&gt; entry:</source>
          <target state="translated">&lt;code&gt;suspend&lt;/code&gt; 항목을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="433bff1804e5bc582b9ad4a588bc980044f6d5b1" translate="yes" xml:space="preserve">
          <source>Let us first see how it is not to be done:</source>
          <target state="translated">먼저 수행되지 않는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="03868b7cc3939225f08fe8a6f0bab813a22248bc" translate="yes" xml:space="preserve">
          <source>Let us have a look at the printout after running:</source>
          <target state="translated">실행 후 출력물을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b4247fbb47d2025ec5fd1d6f1ed8b2a618036da1" translate="yes" xml:space="preserve">
          <source>Let us jump straight into the deep end with an example using some interesting features.</source>
          <target state="translated">몇 가지 흥미로운 기능을 사용하는 예제를 통해 딥 엔드로 바로 넘어 갑시다.</target>
        </trans-unit>
        <trans-unit id="9d72140b7996b3301a9ebd333821b758ccc810f1" translate="yes" xml:space="preserve">
          <source>Let us now call:</source>
          <target state="translated">이제 전화 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="340ab2a12c84a5de30c58279a2989702bffad374" translate="yes" xml:space="preserve">
          <source>Let us now define a fun that can be used to go through a list of cities and temperatures and transform them all to Celsius.</source>
          <target state="translated">이제 도시와 온도 목록을 살펴보고 모두 섭씨로 변환하는 데 사용할 수있는 재미를 정의합시다.</target>
        </trans-unit>
        <trans-unit id="64e5a143553594b38ecae6c7e33437d3a26bcb5c" translate="yes" xml:space="preserve">
          <source>Let us now get back to the test code:</source>
          <target state="translated">이제 테스트 코드로 돌아가 봅시다 :</target>
        </trans-unit>
        <trans-unit id="20fe5b908a76e9dd39847042c3de63708340328e" translate="yes" xml:space="preserve">
          <source>Let us now rewrite the ping pong example using this and give the name &lt;code&gt;pong&lt;/code&gt; to the &quot;pong&quot; process:</source>
          <target state="translated">우리가 지금을 사용하여 탁구의 예를 다시 작성하고 이름 보겠습니다 &lt;code&gt;pong&lt;/code&gt; 은 &quot;퐁&quot;프로세스 :</target>
        </trans-unit>
        <trans-unit id="85102cda9dfe19553fd35b6be3f95a64812d0b22" translate="yes" xml:space="preserve">
          <source>Let us return to the messenger program and add changes to make it more robust:</source>
          <target state="translated">메신저 프로그램으로 돌아가서 변경 사항을 추가하여 더욱 강력하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="1c6ef58bef398273a5e57030e28034688fd26a8c" translate="yes" xml:space="preserve">
          <source>Let us revisit the example in the beginning of the previous section:</source>
          <target state="translated">이전 섹션의 시작 부분에서 예제를 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8f258f141fde08f96558f8c38c9f4c0b345debcf" translate="yes" xml:space="preserve">
          <source>Let us rewrite the ping pong program with &quot;ping&quot; and &quot;pong&quot; on different computers. First a few things are needed to set up to get this to work. The distributed Erlang implementation provides a very basic authentication mechanism to prevent unintentional access to an Erlang system on another computer. Erlang systems which talk to each other must have the same &lt;strong&gt;magic cookie&lt;/strong&gt;. The easiest way to achieve this is by having a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in your home directory on all machines on which you are going to run Erlang systems communicating with each other:</source>
          <target state="translated">다른 컴퓨터에서 &quot;ping&quot;과 &quot;pong&quot;을 사용하여 핑퐁 프로그램을 다시 작성해 보겠습니다. 우선이 기능을 사용하려면 몇 가지 사항을 설정해야합니다. 분산 Erlang 구현은 다른 컴퓨터의 Erlang 시스템에 의도하지 않은 액세스를 방지하는 매우 기본적인 인증 메커니즘을 제공합니다. 서로 대화하는 Erlang 시스템은 동일한 &lt;strong&gt;매직 쿠키를&lt;/strong&gt; 가져야합니다 . 이를 달성하는 가장 쉬운 방법은 Erlang 시스템을 서로 통신하는 모든 시스템의 홈 디렉토리에 &lt;code&gt;.erlang.cookie&lt;/code&gt; 라는 파일을 두는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb9d01b09a7ede47f5da9307c84cc0ef18e349a1" translate="yes" xml:space="preserve">
          <source>Let us see what happens if something other than &lt;code&gt;centimeter&lt;/code&gt; or &lt;code&gt;inch&lt;/code&gt; is entered in the &lt;code&gt;convert&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;centimeter&lt;/code&gt; 나 &lt;code&gt;inch&lt;/code&gt; 이외의 것이 &lt;code&gt;convert&lt;/code&gt; 함수에 입력 되면 어떻게되는지 보자 :</target>
        </trans-unit>
        <trans-unit id="825a5c292a02028fb1b75a606eb848534357aed7" translate="yes" xml:space="preserve">
          <source>Let us use the example database &lt;code&gt;Company&lt;/code&gt;, described in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; to illustrate how to run a database on two separate nodes, called &lt;code&gt;a@gin&lt;/code&gt; and &lt;code&gt;b@skeppet&lt;/code&gt;. Each of these nodes must have a &lt;code&gt;Mnesia&lt;/code&gt; directory and an initialized schema before &lt;code&gt;Mnesia&lt;/code&gt; can be started. There are two ways to specify the &lt;code&gt;Mnesia&lt;/code&gt; directory to be used:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 에 설명 된 예제 데이터베이스 &lt;code&gt;Company&lt;/code&gt; 를 사용하여 &lt;code&gt;a@gin&lt;/code&gt; 및 &lt;code&gt;b@skeppet&lt;/code&gt; 라는 두 개의 개별 노드에서 데이터베이스를 실행하는 방법을 설명합니다 . 이러한 노드 각각은 있어야합니다 &lt;code&gt;Mnesia&lt;/code&gt; 의 이전 디렉토리 및 초기화 된 스키마 &lt;code&gt;Mnesia&lt;/code&gt; 을 시작할 수 있습니다. 사용할 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리를 지정하는 두 가지 방법 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e8bd71594ad75aa0208dcced0f635100f9212f" translate="yes" xml:space="preserve">
          <source>Let warnings about unknown functions and types affect the exit status of the command-line version. The default is to ignore warnings about unknown functions and types when setting the exit status. When using Dialyzer from Erlang, warnings about unknown functions and types are returned; the default is not to return these warnings.</source>
          <target state="translated">알 수없는 기능 및 유형에 대한 경고는 명령 행 버전의 종료 상태에 영향을줍니다. 기본값은 종료 상태를 설정할 때 알 수없는 기능 및 유형에 대한 경고를 무시하는 것입니다. Erlang의 Dialyzer를 사용할 때 알 수없는 기능 및 유형에 대한 경고가 반환됩니다. 기본값은 이러한 경고를 반환하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd1ced138efad4a76a4f08aefdf9554dec9dccb1" translate="yes" xml:space="preserve">
          <source>Let's have a look at &lt;code&gt;ops.tab&lt;/code&gt; in &lt;code&gt;erts/emulator/beam&lt;/code&gt;, where the specific &lt;code&gt;move&lt;/code&gt; instructions are defined. Here are a few of them:</source>
          <target state="translated">특정 &lt;code&gt;move&lt;/code&gt; 지침이 정의 된 &lt;code&gt;ops.tab&lt;/code&gt; &lt;code&gt;erts/emulator/beam&lt;/code&gt; 에서 ops.tab 을 살펴 보겠습니다 . 다음은 몇 가지입니다.</target>
        </trans-unit>
        <trans-unit id="3fdf49f0f1855811dcea84430d7a6c47956fe46f" translate="yes" xml:space="preserve">
          <source>Let's look at an example that returns a tuple with the newly created data.</source>
          <target state="translated">새로 생성 된 데이터로 튜플을 반환하는 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="def4ebac3d33eb1fabe588b9b1bb2ae738aa87c5" translate="yes" xml:space="preserve">
          <source>Let's say that we would like to create the following URI and send it over the network: &lt;code&gt;http://cities/&amp;ouml;rebro?foo bar&lt;/code&gt;. This is not a valid URI as it contains characters that are not allowed in a URI such as &quot;&amp;ouml;&quot; and the space. We can verify this by parsing the URI:</source>
          <target state="translated">&lt;code&gt;http://cities/&amp;ouml;rebro?foo bar&lt;/code&gt; URI를 만들어 네트워크를 통해 전송한다고 가정 해 보겠습니다 . &quot;&amp;ouml;&quot;및 공백과 같은 URI에 허용되지 않는 문자가 포함되어 있으므로 유효한 URI가 아닙니다. URI를 구문 분석하여이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="240d62239f989fbc36c65942d5c7b38032446bb1" translate="yes" xml:space="preserve">
          <source>Let's start with what it is not. It is not the text that you type in the address bar in your Web browser. Web browsers do all possible heuristics to convert the input into a valid URI that could be sent over the network.</source>
          <target state="translated">그것이 아닌 것부터 시작합시다. 웹 브라우저의 주소 표시 줄에 입력하는 텍스트가 아닙니다. 웹 브라우저는 가능한 모든 휴리스틱 스를 수행하여 입력을 네트워크를 통해 전송할 수있는 유효한 URI로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="220abf90cd3cccafcb4011dbe84fa8ca749e8bcc" translate="yes" xml:space="preserve">
          <source>Lets all processes created by the traced process inherit the trace flags of the traced process.</source>
          <target state="translated">추적 된 프로세스로 작성된 모든 프로세스가 추적 된 프로세스의 추적 플래그를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="d1d1fb9c4122f3954940623a46a59b2d039be292" translate="yes" xml:space="preserve">
          <source>Lets another process, &lt;code&gt;P2&lt;/code&gt;, inherit the trace flags of the traced process whenever the traced process links to &lt;code&gt;P2&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스가 &lt;code&gt;P2&lt;/code&gt; 에 링크 될 때마다 다른 프로세스 인 &lt;code&gt;P2&lt;/code&gt; 가 추적 된 프로세스의 추적 플래그를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="3e218df5f51ddbb889cff43b1c4f13125f2c057d" translate="yes" xml:space="preserve">
          <source>Lets get into more detail:</source>
          <target state="translated">더 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="186c274226920125ed827b7634dba82da7689d77" translate="yes" xml:space="preserve">
          <source>Lets go then! We&amp;rsquo;ll start with a short version of the setup procedure, followed by some FAQ, and then we&amp;rsquo;ll go into more details of the setup.</source>
          <target state="translated">그럼 가자! 짧은 버전의 설정 절차부터 시작하여 FAQ가 나온 다음 설정에 대한 자세한 내용을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="342dcf4caa3515593e70e5d37c040a7631a835d2" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen only on the comma-separated list of IP addresses and on the loopback address (which is implicitly added to the list if it has not been specified). This can also be set using environment variable &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;epmd&lt;/code&gt; 인스턴스는 쉼표로 구분 된 IP 주소 목록과 루프백 주소 (지정되지 않은 경우 목록에 암시 적으로 추가됨)에서만 수신 할 수 있습니다. 환경 변수 &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt; 를 사용하여 설정할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe550a3140cf30c4543bf73300c3aa1bcbc8deb8" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen to another TCP port than default 4369. This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;epmd&lt;/code&gt; 인스턴스 가 기본값 4369 이외의 다른 TCP 포트를 청취 할 수 있습니다 . 환경 변수 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 를 사용하여 설정할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="da5c93dba30bae6a81789ea350754c7db18d45fd" translate="yes" xml:space="preserve">
          <source>Letter number</source>
          <target state="translated">문자 번호</target>
        </trans-unit>
        <trans-unit id="6a37a6819c4ca3f372deb6f18b6c9a7263df9d68" translate="yes" xml:space="preserve">
          <source>Letters</source>
          <target state="translated">Letters</target>
        </trans-unit>
        <trans-unit id="8478fe30056611129de10e1dcb67a3cb5751c687" translate="yes" xml:space="preserve">
          <source>Letters and digits</source>
          <target state="translated">문자와 숫자</target>
        </trans-unit>
        <trans-unit id="5baaea6842aeb9d7041a377fa41f4a3c4ca67e64" translate="yes" xml:space="preserve">
          <source>Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option &lt;code&gt;/i&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?i)&lt;/code&gt; option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</source>
          <target state="translated">패턴의 문자는 대문자와 소문자가 모두 일치합니다. Perl 옵션 &lt;code&gt;/i&lt;/code&gt; 와 동일 하며 &lt;code&gt;(?i)&lt;/code&gt; 옵션 설정 으로 패턴 내에서 변경할 수 있습니다 . 대문자와 소문자는 ISO 8859-1 문자 세트에서와 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3e2aaf0fe96e43e92a68ce3b067fcb5b706d11e5" translate="yes" xml:space="preserve">
          <source>Level 0: Hard-coded default values in the source code</source>
          <target state="translated">레벨 0 : 소스 코드에 하드 코딩 된 기본값</target>
        </trans-unit>
        <trans-unit id="8d72e5305a2d6c95e1ce5a0fdd176d060f6349de" translate="yes" xml:space="preserve">
          <source>Level 1: &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;</source>
          <target state="translated">레벨 1 : &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f098a06328a86780258bc88ff74fbf46806b289" translate="yes" xml:space="preserve">
          <source>Level 1: Function headers, reserved words, comments, strings, quoted atoms, and character constants will be colored.</source>
          <target state="translated">레벨 1 : 함수 헤더, 예약어, 주석, 문자열, 인용 원자 및 문자 상수가 색상으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="06b1ca10283f0cd789d2a4ec53089eb86fe07e67" translate="yes" xml:space="preserve">
          <source>Level 2: Options in the &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;&lt;code&gt;server_options&lt;/code&gt; or &lt;code&gt;client_options&lt;/code&gt;</source>
          <target state="translated">레벨 2 : &lt;code&gt;OTP Configuration Parameters&lt;/code&gt; &lt;code&gt;server_options&lt;/code&gt; 또는 &lt;code&gt;client_options&lt;/code&gt; 의 옵션</target>
        </trans-unit>
        <trans-unit id="f28c43e4d336432c51e7d6f7ae8f272e7480311b" translate="yes" xml:space="preserve">
          <source>Level 2: The above, attributes, Erlang bif:s, guards, and words in comments enclosed in single quotes will be colored.</source>
          <target state="translated">2 단계 : 위의 속성, Erlang bif : s, guards 및 작은 따옴표로 묶은 주석의 단어에는 색상이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="005a74e908fba8ac913dab104358fa319caa3bd4" translate="yes" xml:space="preserve">
          <source>Level 3: Options in argument list to a function</source>
          <target state="translated">레벨 3 : 함수에 대한 인수 목록의 옵션</target>
        </trans-unit>
        <trans-unit id="765716d33c6ea85319738caae1b33005b2662242" translate="yes" xml:space="preserve">
          <source>Level 3: The above, variables, records, and macros will be colored. (This level is also known as the Christmas tree level.)</source>
          <target state="translated">레벨 3 : 위의 변수, 레코드 및 매크로가 색상으로 표시됩니다. 이 수준은 크리스마스 트리 수준이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="2bf81bf1cb8b7d9b8d3236953ea28aa39a5a5e01" translate="yes" xml:space="preserve">
          <source>Lexical analyzer generator for Erlang</source>
          <target state="translated">Erlang 용 어휘 분석기 생성기</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="cf656455a0c076b572da9d3e79ba5760d2879b7c" translate="yes" xml:space="preserve">
          <source>Library Summary</source>
          <target state="translated">도서관 요약</target>
        </trans-unit>
        <trans-unit id="b82b017d183339186ab0d2b0c5a5bfec8823103f" translate="yes" xml:space="preserve">
          <source>Library directories can be added, edited or deleted. This is done by selecting the line where the path to a library directory is displayed and clicking the right mouse button. Choose add, edit or delete in the menu that pops up. New library directories can also be added by selecting the line &lt;code&gt;Library directories&lt;/code&gt; and clicking the right mouse button. Choose add in the menu that pops up.</source>
          <target state="translated">라이브러리 디렉토리를 추가, 편집 또는 삭제할 수 있습니다. 라이브러리 디렉토리 경로가 표시되는 행을 선택하고 마우스 오른쪽 버튼을 클릭하면됩니다. 팝업 메뉴에서 추가, 편집 또는 삭제를 선택하십시오. 라인 &lt;code&gt;Library directories&lt;/code&gt; 를 선택하고 마우스 오른쪽 버튼을 클릭하여 새 라이브러리 디렉토리를 추가 할 수도 있습니다 . 팝업 메뉴에서 추가를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="2978f0a9a49c8c42789bf952364d24d1a5dbe46b" translate="yes" xml:space="preserve">
          <source>Library for handling binary data</source>
          <target state="translated">이진 데이터 처리를위한 라이브러리</target>
        </trans-unit>
        <trans-unit id="52399314911c08c3e5bf65cd9f9343b51490ef6c" translate="yes" xml:space="preserve">
          <source>Library for handling binary data.</source>
          <target state="translated">이진 데이터를 처리하기위한 라이브러리</target>
        </trans-unit>
        <trans-unit id="89d3a3ca0e1508a43064d7c5bc51385a80966d5e" translate="yes" xml:space="preserve">
          <source>Library module - skeleton for a module that does not implement a process.</source>
          <target state="translated">라이브러리 모듈-프로세스를 구현하지 않는 모듈의 골격.</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="63a3f94f87240d18e2608ac8e3fea63c89e207c2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;#&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">마찬가지로 &lt;code&gt;#&lt;/code&gt; 하지만 인쇄는 소문자.</target>
        </trans-unit>
        <trans-unit id="cc569b0959c426468676c9f9e2878439fb241769" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;, but the list is traversed from right to left.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 처럼 ,리스트는 오른쪽에서 왼쪽으로 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="32d5f6e565cfc3565274db933e070bbf6e2d1067" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2 &lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 하지만, 더 많은 데이터가 압축 해제되지 통해 구성된 버퍼에 맞는보다 &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2 &lt;/a&gt;&lt;/code&gt; . Is는 압축 비율이 높은 스트림을 압축 해제 할 때 유용하므로 소량의 압축 된 입력이 최대 1000 배까지 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f15f4f7ca9cb7875094377777336299eb89bba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 하지만, 더 많은 데이터가 압축 해제되지 통해 구성된 버퍼에 맞는보다 &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt; . 소량의 압축 입력이 최대 1000 배까지 확장 될 수 있도록 높은 압축 비율로 스트림을 압축 해제 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="72ba4cf8d1bc4075b239ef3e59d00ec710769e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but returns once it has expanded beyond a small implementation-defined threshold. It's useful when decompressing untrusted input which could have been maliciously crafted to expand until the system runs out of memory.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 만 반환은 작은 구현 정의 임계 값을 초과 확대되면. 시스템에 메모리가 부족할 때까지 확장되도록 악의적으로 제작 된 신뢰할 수없는 입력을 압축 해제 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="daf13adcbfffff9ed7affc2828dc952bc760e47b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt;, but only inserts top-level comments. Comments within function definitions or declarations (&quot;forms&quot;) are simply ignored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 최상위 주석 만 삽입합니다. 함수 정의 나 선언 ( &quot;양식&quot;) 내의 주석은 단순히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ef3750efd41bd9e594039bac37ecfb9248994272" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;@custom_types&lt;/code&gt; but requires the specified module to export &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; rather than &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@custom_types&lt;/code&gt; 와 비슷 하지만 &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt; 대신 &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; 을 내보내려면 지정된 모듈이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bea99210fbf7c6bed65f860ca599cb796325b2c8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">마찬가지로 &lt;code&gt;B&lt;/code&gt; ,하지만 인쇄는 소문자.</target>
        </trans-unit>
        <trans-unit id="86bbc734cf44d78a7649fa34a75e3f3c896f4e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints the number with an Erlang style &lt;code&gt;#&lt;/code&gt;-separated base prefix. Example:</source>
          <target state="translated">마찬가지로 &lt;code&gt;B&lt;/code&gt; , 얼랑 스타일로하지만 인쇄 번호 &lt;code&gt;#&lt;/code&gt; 는 기본 접두사를 단락 지어진. 예:</target>
        </trans-unit>
        <trans-unit id="f477e728585a752129db4fe6acfe44591222b305" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any.</source>
          <target state="translated">마찬가지로 &lt;code&gt;B&lt;/code&gt; (있는 경우),하지만, 숫자 앞에 삽입하는 접두어 추가 인수를 걸리지 만 대시 후.</target>
        </trans-unit>
        <trans-unit id="acd1912727bbe585b5be18af1470d511bb1bbc67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;X&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">마찬가지로 &lt;code&gt;X&lt;/code&gt; ,하지만 인쇄는 소문자.</target>
        </trans-unit>
        <trans-unit id="966ec3b06ee878fd6f57e5784bed91178bcad7fe" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;any&lt;/code&gt;, but stops at the first filter for which there are matches, which can be much more efficient when there are many peers. For example, the following filter causes only peers best matching both the host and realm filters to be presented.</source>
          <target state="translated">마찬가지로 &lt;code&gt;any&lt;/code&gt; ,하지만 첫 번째 필터의 정지는 많은 동료가있을 때 훨씬 더 효율적이 될 수 일치,있다. 예를 들어, 다음 필터는 호스트 및 영역 필터 모두에 가장 일치하는 피어 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d6e3635c0afce60dac176c677944b2628acbcc53" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;debugVal(Expr)&lt;/code&gt;, but prints terms truncated to the given depth.</source>
          <target state="translated">&lt;code&gt;debugVal(Expr)&lt;/code&gt; 과 유사 하지만 주어진 깊이로 잘린 항을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="63ad390555fcf8137ccbbb94972b3652ab59df2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:foldl/3&lt;/code&gt;, but over a list of lists.</source>
          <target state="translated">마찬가지로 &lt;code&gt;lists:foldl/3&lt;/code&gt; ,하지만리스트의 목록 이상.</target>
        </trans-unit>
        <trans-unit id="00d879ac0be1e80dff2fcb522c1f308589442773" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:mapfoldl/3&lt;/code&gt;, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</source>
          <target state="translated">마찬가지로 &lt;code&gt;lists:mapfoldl/3&lt;/code&gt; ,하지만리스트의 목록 이상. 결과의 목록 목록은 주어진 목록 목록과 동일한 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="20cd10d2eeffd99802581dc74afe8402156d942f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;make_data/2&lt;/code&gt;, but analogous to &lt;code&gt;c_tuple_skel/1&lt;/code&gt; and &lt;code&gt;c_cons_skel/2&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;make_data/2&lt;/code&gt; 유사에 있지만, &lt;code&gt;c_tuple_skel/1&lt;/code&gt; 및 &lt;code&gt;c_cons_skel/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfa498794c1c7f5c1165baaba1370336976238c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;match/2&lt;/code&gt;, but matching a sequence of patterns against a sequence of expressions. Passing an empty list for &lt;code&gt;Exprs&lt;/code&gt; is equivalent to passing a list of &lt;code&gt;any&lt;/code&gt; atoms of the same length as &lt;code&gt;Patterns&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;match/2&lt;/code&gt; ,하지만 표현의 순서에 대해 패턴의 순서를 일치. 목록이 비어 전달 &lt;code&gt;Exprs&lt;/code&gt; 것은 목록 전달 동등 &lt;code&gt;any&lt;/code&gt; 같은 길이의 원자 &lt;code&gt;Patterns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab237642580896dc26c686d01f6e5d1e47eb40a7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/1&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">마찬가지로 &lt;code&gt;new_variable_name/1&lt;/code&gt; ,하지만 목록을 생성 &lt;code&gt;N&lt;/code&gt; 새 이름을.</target>
        </trans-unit>
        <trans-unit id="faf0ff6789ba28d95ff3dae1292daf1cffb72f1a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/2&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">&lt;code&gt;new_variable_name/2&lt;/code&gt; 와 유사 하지만 &lt;code&gt;N&lt;/code&gt; 개의 새 이름 목록을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2dd37c4c8489c1b03eaf8a9be802ae7519cf2c9e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;notempty&lt;/code&gt;, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \K.</source>
          <target state="translated">주제 시작 부분에없는 빈 문자열 일치가 허용된다는 점을 제외하고 &lt;code&gt;notempty&lt;/code&gt; 와 같습니다 . 패턴이 고정 된 경우 패턴에 \ K가 포함 된 경우에만 이러한 일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e86a0413da3932950dc47086d60ef92f88635d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;update_c_fname/3&lt;/code&gt;, but takes the arity from &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;update_c_fname/3&lt;/code&gt; ,하지만의 인수에 대응합니다 &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e166321bf0d2863d025505b2e22d21ed9895ce6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;variables/1&lt;/code&gt;, but only includes variables that are free in the tree.</source>
          <target state="translated">&lt;code&gt;variables/1&lt;/code&gt; 과 유사 하지만 트리에서 사용 가능한 변수 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ea19d16016f4ba065add2108a05c41562006761a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{inparallel, Tests}&lt;/code&gt;, but running no more than &lt;code&gt;N&lt;/code&gt; subtests simultaneously.</source>
          <target state="translated">마찬가지로 &lt;code&gt;{inparallel, Tests}&lt;/code&gt; 하지만,보다 더 이상 실행 &lt;code&gt;N&lt;/code&gt; 의 동시에 하위 검사.</target>
        </trans-unit>
        <trans-unit id="86d23c0727a7f28841a9680a28cb323bba5bd6b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{spawn, Tests}&lt;/code&gt;, but runs the specified tests on the given Erlang node.</source>
          <target state="translated">마찬가지로 &lt;code&gt;{spawn, Tests}&lt;/code&gt; 하지만, 주어진 얼랑 노드에서 지정된 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="28c07f5f1815e2f3156834cae0b135871e7deefe" translate="yes" xml:space="preserve">
          <source>Like a port program, the port communicates with an Erlang process. All communication goes through one Erlang process that is the &lt;strong&gt;connected process&lt;/strong&gt; of the port driver. Terminating this process closes the port driver.</source>
          <target state="translated">포트 프로그램과 마찬가지로 포트는 Erlang 프로세스와 통신합니다. 모든 통신은 포트 드라이버 의 &lt;strong&gt;연결된 프로세스&lt;/strong&gt; 인 하나의 Erlang 프로세스를 거 &lt;strong&gt;칩니다&lt;/strong&gt; . 이 프로세스를 종료하면 포트 드라이버가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="0f0b5ac5e9d7250099d7a631f9477dabbc5350f7" translate="yes" xml:space="preserve">
          <source>Like before, in the &lt;code&gt;Options&lt;/code&gt; parameter in the Erlang code in a call to for example &lt;code&gt;&lt;a href=&quot;ssh#daemon-3&quot;&gt;ssh:daemon/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; or any of their variants. Example:</source>
          <target state="translated">이전과 마찬가지로 Erlang 코드 의 &lt;code&gt;Options&lt;/code&gt; 매개 변수에서 &lt;code&gt;&lt;a href=&quot;ssh#daemon-3&quot;&gt;ssh:daemon/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; 또는 그 변형을 호출합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="fb6947e8ac5f224ed9054599317fddd5d554df94" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviors, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behavior is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="translated">가장 좋아하는 &lt;code&gt;gen_&lt;/code&gt; 행동, &lt;code&gt;gen_statem&lt;/code&gt; 는 서버 유지 &lt;code&gt;Data&lt;/code&gt; 상태 외에. 이로 인해 상태 수 (가상 머신 메모리가 충분하다고 가정) 또는 별개의 입력 이벤트 수에 대한 제한이 없으므로이 동작으로 구현 된 상태 머신은 실제로 Turing 완료입니다. 그러나 그것은 주로 이벤트 중심의 Mealy 머신처럼 느껴집니다.</target>
        </trans-unit>
        <trans-unit id="667e40cbed5b7781de3cc699e0b1ac1e4df6269e" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviours, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behaviour is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="translated">가장 좋아하는 &lt;code&gt;gen_&lt;/code&gt; 행동, &lt;code&gt;gen_statem&lt;/code&gt; 는 서버 유지 &lt;code&gt;Data&lt;/code&gt; 상태 외에. 이로 인해 상태 수 (가상 머신 메모리가 충분하다고 가정) 또는 고유 한 입력 이벤트 수에 제한이 없으므로이 동작으로 구현 된 상태 머신은 실제로 튜링 완료입니다. 그러나 그것은 대부분 이벤트 기반 Mealy 기계처럼 느껴집니다.</target>
        </trans-unit>
        <trans-unit id="2d2a1cf01f82cc870ddfbc6074784aafada5af53" translate="yes" xml:space="preserve">
          <source>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</source>
          <target state="translated">subst / 2와 비슷하지만 결과를 템플릿에서 다시 트리로 변환하지 않습니다. 여러 개의 개별 대체를 수행하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9fb2ece1519e605cddcd4c31f14bfc8330a5db16" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; macro, but generates an exception unless the returned status value is &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">등 &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; , 반환 상태 값이 아닌 경우 매크로하지만, 예외를 생성 &lt;code&gt;N&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="b09308bcf178ae8be921fdbc2b93c7b533bf2b3a" translate="yes" xml:space="preserve">
          <source>Like the above, if you must remain USTAR compatible, you must also ensure than paths for symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.</source>
          <target state="translated">위와 같이 USTAR 호환 상태를 유지해야하는 경우 기호 / 하드 링크의 경로가 100 바이트를 넘지 않아야합니다. 그렇지 않으면 PAX 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b7ca39f6a507f719e0c2ad1d78b58767ce4db68c" translate="yes" xml:space="preserve">
          <source>Likewise, a registry can be restored from a &lt;code&gt;Mnesia&lt;/code&gt; table:</source>
          <target state="translated">마찬가지로 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에서 레지스트리를 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="78dc3a4fccf65f244492a69b7620630ce0e9464d" translate="yes" xml:space="preserve">
          <source>Limitations: Command string &lt;code&gt;Cmd&lt;/code&gt; is sent to the &lt;code&gt;heart&lt;/code&gt; program as an ISO Latin-1 or UTF-8 encoded binary, depending on the filename encoding mode of the emulator (see &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;). The size of the encoded binary must be less than 2047 bytes.</source>
          <target state="translated">제한 사항 : 명령 문자열 &lt;code&gt;Cmd&lt;/code&gt; 는 에뮬레이터의 파일 이름 인코딩 모드에 따라 ISO Latin-1 또는 UTF-8로 인코딩 된 바이너리로 &lt;code&gt;heart&lt;/code&gt; 프로그램으로 전송됩니다 ( &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 참조 ). 인코딩 된 이진의 크기는 2047 바이트보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="a5b6119a0e42de01e03b6e7576246105dd031f3e" translate="yes" xml:space="preserve">
          <source>Limits &lt;code&gt;run/3&lt;/code&gt; to matching at the first matching position. If a pattern was compiled with &lt;code&gt;anchored&lt;/code&gt;, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no &lt;code&gt;unanchored&lt;/code&gt; option.</source>
          <target state="translated">첫 번째 일치 위치에서 &lt;code&gt;run/3&lt;/code&gt; 을 일치로 제한 합니다 . 패턴이 컴파일 된 경우 &lt;code&gt;anchored&lt;/code&gt; , 또는 그 내용의 미덕에 의해 고정 밝혀졌다, 따라서 더 없다, 시간을 일치에서 비 고정 할 수 없습니다 &lt;code&gt;unanchored&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="53fd0a56aa60d6229d9774fb5d18054514021f8a" translate="yes" xml:space="preserve">
          <source>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in &lt;code&gt;Tree&lt;/code&gt; at the given &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Depth&lt;/code&gt; is negative, the result is always &lt;code&gt;Node&lt;/code&gt;, even if &lt;code&gt;Tree&lt;/code&gt; has no subtrees.</source>
          <target state="translated">구문 트리를 지정된 깊이로 제한합니다. 지정된 &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;Tree&lt;/code&gt; 의 모든 비 리프 하위 트리를 바꿉니다 . 경우 &lt;code&gt;Depth&lt;/code&gt; 부의 경우, 결과는 항상 &lt;code&gt;Node&lt;/code&gt; 경우에도, &lt;code&gt;Tree&lt;/code&gt; 더 하위 트리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f3cee9699c8974707e0009cafd9488a7e87e54c" translate="yes" xml:space="preserve">
          <source>Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to &lt;code&gt;match_limit&lt;/code&gt;. It is described as follows by the PCRE documentation:</source>
          <target state="translated">&lt;code&gt;match_limit&lt;/code&gt; 와 매우 유사한 구현 별 방식으로 일치의 실행 시간 및 메모리 소비를 제한합니다 . PCRE 설명서에 다음과 같이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e9ccbfc052c9f575272edd40f6b4a2a0bc74b7" translate="yes" xml:space="preserve">
          <source>Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</source>
          <target state="translated">구현 별 방식으로 일치하는 실행 시간을 제한합니다. PCRE 설명서에 다음과 같이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4883e35292d9be4c86365cc67be55d00ec1e1e6" translate="yes" xml:space="preserve">
          <source>Limits the number of decentralized counter groups used by decentralized counters optimized for update operations in the Erlang runtime system. By default, the limit is 256.</source>
          <target state="translated">Erlang 런타임 시스템에서 업데이트 작업에 최적화 된 분산 카운터에서 사용하는 분산 카운터 그룹의 수를 제한합니다. 기본적으로 제한은 256입니다.</target>
        </trans-unit>
        <trans-unit id="ebcb72346cc3142860ab9dce9c83e330a9b27032" translate="yes" xml:space="preserve">
          <source>Limits the number of reader groups used by read/write locks optimized for read operations in the Erlang runtime system. By default the reader groups limit is 64.</source>
          <target state="translated">Erlang 런타임 시스템에서 읽기 작업에 최적화 된 읽기 / 쓰기 잠금에 사용되는 리더 그룹 수를 제한합니다. 기본적으로 독자 그룹 제한은 64입니다.</target>
        </trans-unit>
        <trans-unit id="1aaddcb6d1d303241ab23ee03c9e955d5813903a" translate="yes" xml:space="preserve">
          <source>Limits the number of simultaneous requests that can be supported. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">지원할 수있는 동시 요청 수를 제한합니다. 기본값은 &lt;code&gt;150&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac5a291f0f9cb7077ef57a417ad04c2cde809e26" translate="yes" xml:space="preserve">
          <source>Limits the size of the HTTP request URI. Default is no limit.</source>
          <target state="translated">HTTP 요청 URI의 크기를 제한합니다. 기본값은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="01a54436655ccd4292a34867e24b94c649a6a7ef" translate="yes" xml:space="preserve">
          <source>Limits the size of the message body of an HTTP request. Default is no limit.</source>
          <target state="translated">HTTP 요청의 메시지 본문 크기를 제한합니다. 기본값은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f796a3375835935727b47e015cbce66aad2dfb2d" translate="yes" xml:space="preserve">
          <source>Limits the size of the message header of an HTTP request. Default is &lt;code&gt;10240&lt;/code&gt;.</source>
          <target state="translated">HTTP 요청의 메시지 헤더 크기를 제한합니다. 기본값은 &lt;code&gt;10240&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e89b80d9719e747b2760364410364b02949de43" translate="yes" xml:space="preserve">
          <source>Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; where &lt;code&gt;MaxClient&lt;/code&gt; and &lt;code&gt;MinClient&lt;/code&gt; are the values proposed by a connecting client.</source>
          <target state="translated">diffie-hellman-group-exchange에서 고객이 요청할 수있는 것을 제한합니다. 제한은 &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; 여기서 &lt;code&gt;MaxClient&lt;/code&gt; 및 &lt;code&gt;MinClient&lt;/code&gt; 는 연결 클라이언트가 제안한 값입니다.</target>
        </trans-unit>
        <trans-unit id="d606cdf694a134035f6374a74898f3c5d7314e3c" translate="yes" xml:space="preserve">
          <source>Line 1 (marked with the &lt;code&gt;%% 1&lt;/code&gt; comment), assigns a &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;Bin0&lt;/code&gt; variable.</source>
          <target state="translated">줄 1 ( &lt;code&gt;%% 1&lt;/code&gt; 주석으로 표시됨) 은 &lt;code&gt;Bin0&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; 에 힙 바이너리 를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="3a12079f3d22a373811b1791c48232229546d37f" translate="yes" xml:space="preserve">
          <source>Line 2 is an append operation. As &lt;code&gt;Bin0&lt;/code&gt; has not been involved in an append operation, a new &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; is created and the contents of &lt;code&gt;Bin0&lt;/code&gt; is copied into it. The &lt;strong&gt;ProcBin&lt;/strong&gt; part of the refc binary has its size set to the size of the data stored in the binary, while the binary object has extra space allocated. The size of the binary object is either twice the size of &lt;code&gt;Bin1&lt;/code&gt; or 256, whichever is larger. In this case it is 256.</source>
          <target state="translated">2 행은 추가 작업입니다. 으로 &lt;code&gt;Bin0&lt;/code&gt; 이 _가 작업에 참여하지 않은, 새로운 &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; 만들어지고의 내용 &lt;code&gt;Bin0&lt;/code&gt; 는 그것으로 복사됩니다. refc 이진 의 &lt;strong&gt;ProcBin&lt;/strong&gt; 부분은 이진에 저장된 데이터의 크기로 크기가 설정되어 있으며 이진 객체에는 추가 공간이 할당되어 있습니다. 이진 개체의 크기는 &lt;code&gt;Bin1&lt;/code&gt; 크기의 두 배 또는 256 중 큰 쪽입니다. 이 경우 256입니다.</target>
        </trans-unit>
        <trans-unit id="78a9183f7481a61745aa9568c7ccc4c6a4279b91" translate="yes" xml:space="preserve">
          <source>Line 3 is more interesting. &lt;code&gt;Bin1&lt;/code&gt;&lt;strong&gt;has&lt;/strong&gt; been used in an append operation, and it has 252 bytes of unused storage at the end, so the 3 new bytes are stored there.</source>
          <target state="translated">3 호선이 더 흥미 롭습니다. &lt;code&gt;Bin1&lt;/code&gt; &lt;strong&gt;은&lt;/strong&gt; 추가 작업에 사용되었으며 끝에 252 바이트의 사용되지 않은 스토리지가 있으므로 3 바이트의 새 바이트가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="606f836f0aef9364290324174a1660f8412d88a6" translate="yes" xml:space="preserve">
          <source>Line 4. The same applies here. There are 249 bytes left, so there is no problem storing another 3 bytes.</source>
          <target state="translated">네 번째 줄도 마찬가지입니다. 249 바이트가 남아 있으므로 다른 3 바이트를 저장하는 데 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a181978e790a24533adac43665a7c3bfc9494742" translate="yes" xml:space="preserve">
          <source>Line 5. Here, something &lt;strong&gt;interesting&lt;/strong&gt; happens. Notice that the result is not appended to the previous result in &lt;code&gt;Bin3&lt;/code&gt;, but to &lt;code&gt;Bin1&lt;/code&gt;. It is expected that &lt;code&gt;Bin4&lt;/code&gt; will be assigned the value &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt;. It is also expected that &lt;code&gt;Bin3&lt;/code&gt; will retain its value (&lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;). Clearly, the runtime system cannot write byte &lt;code&gt;17&lt;/code&gt; into the binary, because that would change the value of &lt;code&gt;Bin3&lt;/code&gt; to &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">5 행. 여기서 &lt;strong&gt;흥미로운&lt;/strong&gt; 일이 발생합니다. 결과에 이전 결과에 추가되지 않도록주의 &lt;code&gt;Bin3&lt;/code&gt; 만에 &lt;code&gt;Bin1&lt;/code&gt; 을 . &lt;code&gt;Bin4&lt;/code&gt; 에 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt; 값이 할당 될 것으로 예상 됩니다 . &lt;code&gt;Bin3&lt;/code&gt; 은 그 값 ( &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; )을 유지할 것으로 예상 됩니다 . 분명히 런타임 시스템은 바이트 &lt;code&gt;17&lt;/code&gt; 을 바이너리에 쓸 수 없습니다 . &lt;code&gt;Bin3&lt;/code&gt; 의 값이 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; 로 변경되기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="03d96d415e109919c75164ce4c11337300d5c505" translate="yes" xml:space="preserve">
          <source>Line Breakpoints</source>
          <target state="translated">라인 중단 점</target>
        </trans-unit>
        <trans-unit id="4f23e2d073d67acea8f123b42f84af035e27248d" translate="yes" xml:space="preserve">
          <source>Line feed</source>
          <target state="translated">줄 바꿈</target>
        </trans-unit>
        <trans-unit id="d6baf0500add79d50ac3b7f3a8db7d105c624d52" translate="yes" xml:space="preserve">
          <source>Line feed (LF)</source>
          <target state="translated">줄 바꿈 (LF)</target>
        </trans-unit>
        <trans-unit id="6e6281f3f812eba8375c5e757b0a8cfcb28090b9" translate="yes" xml:space="preserve">
          <source>Line feed (hex 0A)</source>
          <target state="translated">줄 바꿈 (16 진수 0A)</target>
        </trans-unit>
        <trans-unit id="815507f47a2606910a0fd0cc8b7e5b87462f8246" translate="yes" xml:space="preserve">
          <source>Line separator</source>
          <target state="translated">선 구분자</target>
        </trans-unit>
        <trans-unit id="2af7c8c92e94fc7eb6a6c63fb1ff0bce5d9c019f" translate="yes" xml:space="preserve">
          <source>LineOp ::= &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</source>
          <target state="translated">LineOp :: = &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96dcf318665fa36d70418026a3b6579ba1d37485" translate="yes" xml:space="preserve">
          <source>Linear_A</source>
          <target state="translated">Linear_A</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="d6c98026fbce4e93112774eec40362b0a7aed1ad" translate="yes" xml:space="preserve">
          <source>Lines containing comment are indented differently depending on the number of %-characters used:</source>
          <target state="translated">주석이 포함 된 행은 사용 된 % 문자 수에 따라 다르게 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="6020dbe4b85aaddb67863706a7bfa44b4279c255" translate="yes" xml:space="preserve">
          <source>Lines with one %-character is indented to the right of the code. The column is specified by the variable &lt;code&gt;comment-column&lt;/code&gt;, by default column 48 is used.</source>
          <target state="translated">코드 오른쪽에 하나의 % 문자가있는 줄이 들여 쓰기됩니다. 열은 변수 &lt;code&gt;comment-column&lt;/code&gt; 에 의해 지정 되며 기본적으로 열 48이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09bc4e361a8d125ebf0a75e49099df74d6c93932" translate="yes" xml:space="preserve">
          <source>Lines with three of more %-characters are indented to the left margin.</source>
          <target state="translated">% 문자가 3 개 이상있는 줄은 왼쪽 여백에 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="23c934b9a137cdcf80996b7f149382ca3a18710d" translate="yes" xml:space="preserve">
          <source>Lines with two %-characters will be indented to the same depth as code would have been in the same situation.</source>
          <target state="translated">% 문자가 두 개인 줄은 코드가 같은 상황에 있었던 것과 같은 깊이로 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="9e5bc846e2abf74c493c5775ca18f25f00253f12" translate="yes" xml:space="preserve">
          <source>Linked-in drivers involves writing certain call-back functions in C. This requires very good skills as the code is linked to the Erlang runtime system.</source>
          <target state="translated">링크 된 드라이버에는 C로 특정 콜백 함수를 작성하는 것이 포함됩니다. 코드가 Erlang 런타임 시스템에 링크되어 있으므로 매우 우수한 기술이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4767dee426c55691e7ec704688dd7011fdf6e6c1" translate="yes" xml:space="preserve">
          <source>Linking the code:</source>
          <target state="translated">코드 연결</target>
        </trans-unit>
        <trans-unit id="c84c983e1eb5366ff7155483ba08d2cf18181d6f" translate="yes" xml:space="preserve">
          <source>Links are bidirectional and there can only be one link between two processes. Repeated calls to &lt;code&gt;link(Pid)&lt;/code&gt; have no effect.</source>
          <target state="translated">링크는 양방향이며 두 프로세스간에 하나의 링크 만있을 수 있습니다. &lt;code&gt;link(Pid)&lt;/code&gt; 에 대한 반복 호출 은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="536671c5d8157a4198a59e5ae3d1dd5548fd13ad" translate="yes" xml:space="preserve">
          <source>Links are used to monitor the behaviour of other processes, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">링크는 다른 프로세스의 동작을 모니터링하는 데 사용됩니다 ( &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7503c78763ebecf671434c7b303123b1f56805aa" translate="yes" xml:space="preserve">
          <source>Linux (Aurora) is supported.</source>
          <target state="translated">Linux (Aurora)가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f49aab8507d2b62fb91db21f8494a181f98c1d79" translate="yes" xml:space="preserve">
          <source>Linux (Yellow Dog) and OS X 10.4 are supported.</source>
          <target state="translated">Linux (Yellow Dog) 및 OS X 10.4가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="38b6fdccab18afaaac184982069e00fd7f3ffef8" translate="yes" xml:space="preserve">
          <source>Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed)</source>
          <target state="translated">Linux Fedora Core 5.0 (커널 2.6.15-2054 이상 필요)</target>
        </trans-unit>
        <trans-unit id="7271c5381dda56086abe9358b1d2d1ac80324586" translate="yes" xml:space="preserve">
          <source>Linux Kernel with UTRACE support</source>
          <target state="translated">UTRACE를 지원하는 Linux 커널</target>
        </trans-unit>
        <trans-unit id="36cc9cbbe6cb1dce3453740ebc4bf86e8ca4eccd" translate="yes" xml:space="preserve">
          <source>Linux is supported.</source>
          <target state="translated">리눅스가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0b07d1c551ea1b1430dbe7348f1abb043df15a81" translate="yes" xml:space="preserve">
          <source>Linux via SystemTap compatibility. Please see &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">SystemTap 호환성을 통한 Linux. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc9111a94c72d771e7a92b8e98a4dad72cd10a62" translate="yes" xml:space="preserve">
          <source>Linux: Fedora Core is supported. Both 32-bit and 64-bit modes are supported.</source>
          <target state="translated">Linux : Fedora Core가 지원됩니다. 32 비트 및 64 비트 모드가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="cd35517590c8ba62aaafca822f31e45849fd7931" translate="yes" xml:space="preserve">
          <source>List Reports in Server</source>
          <target state="translated">서버에 보고서 나열</target>
        </trans-unit>
        <trans-unit id="84478621597e3250b6410dcf31b2c7f5cfa01376" translate="yes" xml:space="preserve">
          <source>List all engines currently loaded</source>
          <target state="translated">현재로드 된 모든 엔진 나열</target>
        </trans-unit>
        <trans-unit id="3e20fcd0dc8894a575034d1d37150331fce67f9a" translate="yes" xml:space="preserve">
          <source>List all notification filters in an agent.</source>
          <target state="translated">에이전트의 모든 알림 필터를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="433e9558c472f250dda9655b9de01d8c5b1cbc95" translate="yes" xml:space="preserve">
          <source>List comprehensions are analogous to set comprehensions in Zermelo-Frankel set theory and are called ZF expressions in Miranda. They are analogous to the &lt;code&gt;setof&lt;/code&gt; and &lt;code&gt;findall&lt;/code&gt; predicates in Prolog.</source>
          <target state="translated">리스트 이해는 Zermelo-Frankel 세트 이론에서 이해를 설정하는 것과 유사하며 미란다에서 ZF 표현이라고 불립니다. 이들은 Prolog 의 &lt;code&gt;setof&lt;/code&gt; 및 &lt;code&gt;findall&lt;/code&gt; 술어 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="493415e452a1ca58d7ab0e55c11450201b1caf07" translate="yes" xml:space="preserve">
          <source>List comprehensions are written with the following syntax:</source>
          <target state="translated">목록 이해는 다음 구문으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f643c07aa2da6eaa1122e1bfdb07a56a6d60470e" translate="yes" xml:space="preserve">
          <source>List comprehensions is a feature of many modern functional programming languages. Subject to certain rules, they provide a succinct notation for generating elements in a list.</source>
          <target state="translated">리스트 이해는 많은 현대 기능 프로그래밍 언어의 기능입니다. 특정 규칙에 따라 목록에서 요소를 생성하기위한 간결한 표기법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c0adcf806e6c6cb4dd52f21d37c6386d7fc26ec4" translate="yes" xml:space="preserve">
          <source>List comprehensions used to be implemented using funs, and in the old days funs were indeed slow.</source>
          <target state="translated">재미를 사용하여 구현되던 목록 이해력은 옛날에는 재미가 실제로 느 렸습니다.</target>
        </trans-unit>
        <trans-unit id="6a97adf09881d30899eb88074972670e34c92836" translate="yes" xml:space="preserve">
          <source>List comprehensions with low-level &lt;code&gt;Mnesia&lt;/code&gt; functions can be combined in the same transaction. To raise the salary of all female employees, execute the following:</source>
          <target state="translated">낮은 수준의 &lt;code&gt;Mnesia&lt;/code&gt; 기능을 갖춘 목록 이해 는 동일한 트랜잭션에서 결합 될 수 있습니다. 모든 여성 직원의 급여를 인상하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="49eee1559f1ee0d2b82c81d4f588a2ed770857f0" translate="yes" xml:space="preserve">
          <source>List comprehensions.</source>
          <target state="translated">이해력을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="05e97a2b6e38fea3735726e5819ee8ba95e83bc5" translate="yes" xml:space="preserve">
          <source>List elements are the UTF-8 encodings of the individual characters in the string. Invalid codepoints will result in encode/decode failure. On encode, a UTF8String() can be specified as a binary, or as a nested list of binaries and codepoints.</source>
          <target state="translated">목록 요소는 문자열에서 개별 문자의 UTF-8 인코딩입니다. 유효하지 않은 코드 포인트는 인코딩 / 디코딩 실패를 초래합니다. 인코딩시 UTF8String ()을 이진 또는 중첩 된 이진 및 코드 포인트 목록으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278d3b4f4ee0740a1de4cdf1bd2bf93be61d3954" translate="yes" xml:space="preserve">
          <source>List of algorithms to use in the algorithm negotiation. The default &lt;code&gt;algs_list()&lt;/code&gt; can be obtained from &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">알고리즘 협상에 사용할 알고리즘 목록입니다. 기본 &lt;code&gt;algs_list()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;default_algorithms/0&lt;/a&gt;&lt;/code&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9db4243408e7145f00857f4260325dcb24458c15" translate="yes" xml:space="preserve">
          <source>List of extra arguments to the user callback functions. See the the reference manual for megaco_user for more info.</source>
          <target state="translated">사용자 콜백 함수에 대한 추가 인수 목록 자세한 내용은 megaco_user의 참조 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46ea5ca4efb80ab899337d420e90c90285a406b1" translate="yes" xml:space="preserve">
          <source>List of protocols to send to the client if the client indicates that it supports the Next Protocol extension. The client can select a protocol that is not on this list. The list of protocols must not contain an empty binary. If the server negotiates a Next Protocol, it can be accessed using the &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; method.</source>
          <target state="translated">클라이언트가 다음 프로토콜 확장을 지원함을 나타내는 경우 클라이언트에 보낼 프로토콜 목록. 클라이언트는이 목록에없는 프로토콜을 선택할 수 있습니다. 프로토콜 목록에는 빈 바이너리가 포함되어서는 안됩니다. 서버가 다음 프로토콜을 협상하는 경우 &lt;code&gt;negotiated_next_protocol/1&lt;/code&gt; 메소드를 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e5b6b3bdd287b5c011c0b0403e09b9164fe07d" translate="yes" xml:space="preserve">
          <source>List of unicode codepoints, a UTF-8 encoded binary, or a mix of the two, representing an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant URI (&lt;strong&gt;percent-encoded form&lt;/strong&gt;). A URI is a sequence of characters from a very limited set: the letters of the basic Latin alphabet, digits, and a few special characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 호환 URI ( &lt;strong&gt;백분율로 인코딩 된 형식&lt;/strong&gt; )를 나타내는 유니 코드 코드 포인트, UTF-8 인코딩 바이너리 또는이 둘의 혼합 목록입니다 . URI는 기본 라틴 알파벳 문자, 숫자 및 몇 가지 특수 문자와 같이 매우 제한된 세트의 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="d93d5d53babf56ebe1e390ba9a950fbf91d0cb2b" translate="yes" xml:space="preserve">
          <source>List of user (client) public key algorithms to try to use.</source>
          <target state="translated">사용하려는 사용자 (클라이언트) 공개 키 알고리즘 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cc9f7cb6591bec743e823fe706dead283d4905b5" translate="yes" xml:space="preserve">
          <source>List of variable bindings in the shell environment.</source>
          <target state="translated">쉘 환경의 변수 바인딩 목록.</target>
        </trans-unit>
        <trans-unit id="f80b12db0f84fe26ec9bd3ed10dcbee12e085184" translate="yes" xml:space="preserve">
          <source>List processing</source>
          <target state="translated">리스트 처리</target>
        </trans-unit>
        <trans-unit id="8b3923bc8621a43a87bb226f3d90850a4f20ee30" translate="yes" xml:space="preserve">
          <source>List processing functions.</source>
          <target state="translated">목록 처리 기능.</target>
        </trans-unit>
        <trans-unit id="6345849796c275ff0cae0a5e12aa669943d6685e" translate="yes" xml:space="preserve">
          <source>List subtraction used to have a run-time complexity proportional to the product of the length of its operands, so it was extremely slow when both lists were long.</source>
          <target state="translated">목록 빼기는 피연산자 길이의 곱에 비례하는 런타임 복잡도를 갖기 위해 사용되었으므로 두 목록이 길면 매우 느 렸습니다.</target>
        </trans-unit>
        <trans-unit id="53479af7c4b258e47635cf3f831bd457573f3848" translate="yes" xml:space="preserve">
          <source>List the id's of all engines in OpenSSL's internal list.</source>
          <target state="translated">OpenSSL의 내부 목록에 모든 엔진의 ID를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="360c1be474e03a75dfed0b0aac585b7b6b77ea1d" translate="yes" xml:space="preserve">
          <source>Listen for connections on a socket.</source>
          <target state="translated">소켓에서 연결을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a2cf5c534cf79a3ef7abbfc9f78dcce0140e6482" translate="yes" xml:space="preserve">
          <source>Listing without class combiner.</source>
          <target state="translated">클래스 컴 바이 너가없는 리스팅.</target>
        </trans-unit>
        <trans-unit id="9d1f72a30a3a6c56319d5de301e7dcd8d4ea9184" translate="yes" xml:space="preserve">
          <source>Lists all TCP, UDP and SCTP sockets, including those that the Erlang runtime system uses as well as those created by the application.</source>
          <target state="translated">Erlang 런타임 시스템에서 사용하는 소켓과 응용 프로그램에서 작성된 소켓을 포함하여 모든 TCP, UDP 및 SCTP 소켓을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4337868b9d860ba3caf101beb26d92ab8c3abdd4" translate="yes" xml:space="preserve">
          <source>Lists all active connections for this user. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">이 사용자에 대한 모든 활성 연결을 나열합니다. megaco_conn_handle 레코드 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2714b113edcc2a65636a1ec94ae0d858a92ee520" translate="yes" xml:space="preserve">
          <source>Lists all active connections. Returns a list of megaco_conn_handle records.</source>
          <target state="translated">모든 활성 연결을 나열합니다. megaco_conn_handle 레코드 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c14044ad12ace6bccaea0455b877c42c13dc64aa" translate="yes" xml:space="preserve">
          <source>Lists all active users. Returns a list of megaco_mid()'s.</source>
          <target state="translated">모든 활성 사용자를 나열합니다. megaco_mid ()의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09883357a748a23703460bb6b31f36dc6eb24786" translate="yes" xml:space="preserve">
          <source>Lists all available start flags.</source>
          <target state="translated">사용 가능한 모든 시작 플래그를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="4edfc25b8c7646b4111ec287d11e328fd05b2ca3" translate="yes" xml:space="preserve">
          <source>Lists all entries in the specified configuration file.</source>
          <target state="translated">지정된 구성 파일의 모든 항목을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="2c53d0f7e8e7f87d95870b0e5dd392fdbd1aed3a" translate="yes" xml:space="preserve">
          <source>Lists all files in a directory, &lt;strong&gt;except&lt;/strong&gt; files with raw filenames. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">원시 파일 이름을 가진 파일을 &lt;strong&gt;제외한&lt;/strong&gt; 디렉토리의 모든 파일을 나열합니다 . 반환 &lt;code&gt;{ok, Filenames}&lt;/code&gt; 그렇지 않으면 성공하면, &lt;code&gt;{error, Reason}&lt;/code&gt; . &lt;code&gt;Filenames&lt;/code&gt; 은 디렉토리에있는 모든 파일의 이름 목록입니다. 이름이 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e14a213355b4d17f65990a6133f694eb009717fd" translate="yes" xml:space="preserve">
          <source>Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'.</source>
          <target state="translated">모든 작업을 나열합니다. 알려진 모든 작업 목록이 인쇄됩니다. 현재 작업 이름 앞에 '*'가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="d449a2e13ab08f8d884a484f2a845df785c5c0f1" translate="yes" xml:space="preserve">
          <source>Lists all modified modules. Shorthand for &lt;code&gt;code:modified_modules/0&lt;/code&gt;.</source>
          <target state="translated">수정 된 모든 모듈을 나열합니다. &lt;code&gt;code:modified_modules/0&lt;/code&gt; 의 약자 .</target>
        </trans-unit>
        <trans-unit id="8a4773cfa062c5fb572736024d216eb9e4b59ec0" translate="yes" xml:space="preserve">
          <source>Lists all possible cipher suites corresponding to &lt;code&gt;Description&lt;/code&gt; that are available. The &lt;code&gt;exclusive&lt;/code&gt; option will exclusively list cipher suites introduced in &lt;code&gt;Version&lt;/code&gt; whereas the the other options are inclusive from the lowest possible version to &lt;code&gt;Version&lt;/code&gt;. The &lt;code&gt;all&lt;/code&gt; options includes all suites except the anonymous.</source>
          <target state="translated">사용 가능한 &lt;code&gt;Description&lt;/code&gt; 해당하는 모든 가능한 암호 그룹을 나열합니다 . &lt;code&gt;exclusive&lt;/code&gt; 옵션이 독점적으로 목록에 암호 스위트에 도입됩니다 &lt;code&gt;Version&lt;/code&gt; 하여 다른 옵션에 가장 낮은 버전이 포함됩니다 반면 &lt;code&gt;Version&lt;/code&gt; . &lt;code&gt;all&lt;/code&gt; 옵션은 익명을 제외한 모든 스위트 룸을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9e08270ad4d1c057bd6013ee9f18877c27d91e14" translate="yes" xml:space="preserve">
          <source>Lists all reports loaded in &lt;code&gt;rb_server&lt;/code&gt;. Each report is given a unique number that can be used as a reference to the report in function &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rb_server&lt;/code&gt; 에 로드 된 모든 보고서를 나열합니다 . 각 보고서에는 &lt;code&gt;&lt;a href=&quot;#show-1&quot;&gt;show/1&lt;/a&gt;&lt;/code&gt; 함수의 보고서에 대한 참조로 사용할 수있는 고유 번호가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d585b5f080c2320d84337d311297ce3312051fb" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory, including files with raw filenames. Returns &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">원시 파일 이름을 가진 파일을 포함하여 디렉토리의 모든 파일을 나열합니다. 반환 &lt;code id=&quot;list_dir_all&quot;&gt;{ok, Filenames}&lt;/code&gt; 그렇지 않으면 성공하면, &lt;code&gt;{error, Reason}&lt;/code&gt; . &lt;code&gt;Filenames&lt;/code&gt; 은 디렉토리에있는 모든 파일의 이름 목록입니다. 이름이 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="02f72b758a50a88ea9e456ce7bb76a0ffe8cb08d" translate="yes" xml:space="preserve">
          <source>Lists all the files in a directory. Returns &lt;code&gt;{ok, Filenames}&lt;/code&gt; if successful, otherwise &lt;code&gt;error&lt;/code&gt;. &lt;code&gt;Filenames&lt;/code&gt; is a list of the names of all the files in the directory. The names are not sorted.</source>
          <target state="translated">디렉토리의 모든 파일을 나열합니다. 반환 &lt;code&gt;{ok, Filenames}&lt;/code&gt; 성공하면, 그렇지 않으면 &lt;code&gt;error&lt;/code&gt; . &lt;code&gt;Filenames&lt;/code&gt; 은 디렉토리에있는 모든 파일의 이름 목록입니다. 이름이 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4410d2b8ea4abd8b562807aff638f01d51fdbe5b" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element. Tuples are ordered by size, two tuples with the same size are compared element by element.</source>
          <target state="translated">목록은 요소별로 비교됩니다. 튜플은 크기별로 정렬되며 동일한 크기의 두 튜플은 요소별로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="aaaad5080a7d5e7990259ba71c1c2a741010f595" translate="yes" xml:space="preserve">
          <source>Lists can only be built starting from the end and attaching list elements at the beginning. If you use the &quot;&lt;code&gt;++&lt;/code&gt;&quot; operator as follows, a new list is created that is a copy of the elements in &lt;code&gt;List1&lt;/code&gt;, followed by &lt;code&gt;List2&lt;/code&gt;:</source>
          <target state="translated">목록은 끝에서 시작하여 처음에 목록 요소를 첨부하는 경우에만 빌드 할 수 있습니다. 다음과 같이 &quot; &lt;code&gt;++&lt;/code&gt; &quot;연산자 를 사용하는 경우 &lt;code&gt;List1&lt;/code&gt; 의 요소 사본 인 &lt;code&gt;List2&lt;/code&gt; 와 함께 새 목록이 작성 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4926eced8ea62bd521cb340059a74702d8b7f96d" translate="yes" xml:space="preserve">
          <source>Lists comprehensions still have a reputation for being slow. They used to be implemented using funs, which used to be slow.</source>
          <target state="translated">목록 이해력은 여전히 ​​느리다는 명성을 가지고 있습니다. 예전에는 재미를 사용하여 구현했지만 느려졌습니다.</target>
        </trans-unit>
        <trans-unit id="813529648a19db76d9b2436854b7d6cbfd832327" translate="yes" xml:space="preserve">
          <source>Lists directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 디렉토리를 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ad6d844316d235b7276ea8fedc7b6ce5feb6d2" translate="yes" xml:space="preserve">
          <source>Lists files in directory &lt;code&gt;Dir&lt;/code&gt; or, if &lt;code&gt;Dir&lt;/code&gt; is a file, only lists it.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 디렉토리에 파일을 나열 하거나 &lt;code&gt;Dir&lt;/code&gt; 이 파일 인 경우에만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="89af84891678e7a6adbb862fe15a05f7928921ee" translate="yes" xml:space="preserve">
          <source>Lists files in the current directory.</source>
          <target state="translated">현재 디렉토리의 파일을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="a526e66bff6fcc167e33e50709753226df32d0ad" translate="yes" xml:space="preserve">
          <source>Lists information, mainly concerning TLS/DTLS versions, in runtime for debugging and testing purposes.</source>
          <target state="translated">디버깅 및 테스트 목적으로 런타임에서 주로 TLS / DTLS 버전과 관련된 정보를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="c58c2a350f07347551b9f3634b864bd30234359c" translate="yes" xml:space="preserve">
          <source>Lists names registered with the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">현재 실행중인 &lt;code&gt;epmd&lt;/code&gt; 에 등록 된 이름을 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="db086781259aaadaaf44b182603d38e68f16fda8" translate="yes" xml:space="preserve">
          <source>Lists of UTF-8 Bytes</source>
          <target state="translated">UTF-8 바이트 목록</target>
        </trans-unit>
        <trans-unit id="6d04787e574b0b36059101cd1aba185b5fe294f5" translate="yes" xml:space="preserve">
          <source>Lists the given directory on the server, returning the filenames as a list of strings.</source>
          <target state="translated">서버에서 지정된 디렉토리를 나열하고 파일 이름을 문자열 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5b64a6325e7fd542159a3c84889b713d8f57a43" translate="yes" xml:space="preserve">
          <source>Lisu</source>
          <target state="translated">Lisu</target>
        </trans-unit>
        <trans-unit id="4dca4b373f502fbb16dccc9e0b7237d86410b372" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;Mibs&lt;/code&gt; into an agent. If the agent cannot load all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where loading was aborted. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">에이전트에 &lt;code&gt;Mibs&lt;/code&gt; 를 로드 하십시오 . 에이전트가 모든 MIB를로드 할 수없는 경우 ( &lt;code&gt;Force&lt;/code&gt; 인수 의 기본값 은 &lt;code&gt;false&lt;/code&gt; )로드가 중단 된 위치를 나타냅니다. &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9eb24b588b22c0b9641d19a0eb23be1ce0fbc392" translate="yes" xml:space="preserve">
          <source>Load Balancing</source>
          <target state="translated">부하 분산</target>
        </trans-unit>
        <trans-unit id="c4d7f412fb063f70b02868e384179ef9d1b1a087" translate="yes" xml:space="preserve">
          <source>Load a &lt;code&gt;Mib&lt;/code&gt; into the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">관리자 에게 &lt;code&gt;Mib&lt;/code&gt; 를 로드하십시오 . &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b3e3360ea19707f02f4a020e3f19c3e4bc8449f2" translate="yes" xml:space="preserve">
          <source>Load a crypto engine, should be done once per engine used. For example dynamically load the engine called &lt;code&gt;MyEngine&lt;/code&gt;:</source>
          <target state="translated">암호화 엔진을로드하십시오. 사용되는 엔진마다 한 번씩 수행해야합니다. 예를 들어 &lt;code&gt;MyEngine&lt;/code&gt; 이라는 엔진을 동적으로로드합니다 .</target>
        </trans-unit>
        <trans-unit id="8a579cb5ea4d299e98f6e3305e729a2e2691eb3c" translate="yes" xml:space="preserve">
          <source>Load a single &lt;code&gt;Mib&lt;/code&gt; into an agent. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example:</source>
          <target state="translated">단일 &lt;code&gt;Mib&lt;/code&gt; 를 에이전트에 로드하십시오 . &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="977a17eb3484eaefc96c3c23206f0b5245055b6b" translate="yes" xml:space="preserve">
          <source>Load an engine and replace some methods</source>
          <target state="translated">엔진로드 및 일부 방법 교체</target>
        </trans-unit>
        <trans-unit id="715502f398ccdfa0aa43a432af1ca13d1b7adbea" translate="yes" xml:space="preserve">
          <source>Load an engine with the dynamic engine</source>
          <target state="translated">동적 엔진으로 엔진로드</target>
        </trans-unit>
        <trans-unit id="c51c159c86fd747d2e5230014dcc8e2ec41e6224" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine and just replace some engine methods.</source>
          <target state="translated">동적 엔진을 사용하여 엔진을로드하고 일부 엔진 방법 만 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="4c42d226cb6d70b946e6d5b82bc4c3543f9c44ef" translate="yes" xml:space="preserve">
          <source>Load an engine with the help of the dynamic engine by giving the path to the library.</source>
          <target state="translated">라이브러리에 대한 경로를 제공하여 동적 엔진의 도움으로 엔진을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="32bc843d0b756c56e85673fa55374b9397575f9a" translate="yes" xml:space="preserve">
          <source>Load distribution facility.</source>
          <target state="translated">하중 분배 시설.</target>
        </trans-unit>
        <trans-unit id="76bad6da55b53cc690e8073bcd70b2d51d7df367" translate="yes" xml:space="preserve">
          <source>Load mode. Loads all recompiled modules.</source>
          <target state="translated">로드 모드. 재 컴파일 된 모든 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="2cccf6ad0728e7b357295554e6d28b49c3a4a67a" translate="yes" xml:space="preserve">
          <source>Load raw Erlang trace from a file, port or process.</source>
          <target state="translated">파일, 포트 또는 프로세스에서 원시 Erlang 추적을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="9270554fc2af7c0fd3400f7998148c1961fce683" translate="yes" xml:space="preserve">
          <source>Load the &lt;code&gt;dyntrace&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;dyntrace&lt;/code&gt; 모듈을 로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="c237f6e4c5365a30ac145a8b509d8e8b9dd96a4d" translate="yes" xml:space="preserve">
          <source>Load the compiled MIB into the agent.</source>
          <target state="translated">컴파일 된 MIB를 에이전트에로드하십시오.</target>
        </trans-unit>
        <trans-unit id="20c1d6dc95e25c92e1610b1211f7233c890d0b64" translate="yes" xml:space="preserve">
          <source>Load the event table from a file.</source>
          <target state="translated">파일에서 이벤트 테이블을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="a92787cc36930707fbb75a6d9a3de46ba71425a8" translate="yes" xml:space="preserve">
          <source>Load the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument into the mib-server. The &lt;code&gt;MeOverride&lt;/code&gt; and &lt;code&gt;TeOverride&lt;/code&gt; arguments specifies how the mib-server shall handle duplicate mib- and trap- entries.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 인수로 지정된 mib를 mib 서버로 로드하십시오 . &lt;code&gt;MeOverride&lt;/code&gt; 및 &lt;code&gt;TeOverride&lt;/code&gt; 은 MIB-서버가 중복 mib- 및 trap- 항목을 처리해야하는 방법을 인수 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b2d3b1b2db0276aeeaa93c9149c9814e0ffe32aa" translate="yes" xml:space="preserve">
          <source>Load with the ensure loaded function</source>
          <target state="translated">로드 보장 기능으로로드</target>
        </trans-unit>
        <trans-unit id="ffabdc1b0aada0df09c6b33e94264210e3036668" translate="yes" xml:space="preserve">
          <source>Loading and Unloading of OTP-OS-MON-MIB</source>
          <target state="translated">OTP-OS-MON-MIB의 로딩 및 언 로딩</target>
        </trans-unit>
        <trans-unit id="59f753c4a89d6cb4b2fbf224764ebcc567bab7f3" translate="yes" xml:space="preserve">
          <source>Loading and unloading of MIBs are quite cheap operations. However, if the application does this very often, perhaps several times per minute, it should load the MIBs once and for all in a sub-agent. This sub-agent only registers and unregisters itself under another agent instead of loading the MIBs each time. This is cheaper than loading an MIB.</source>
          <target state="translated">MIB로드 및 언로드는 매우 저렴한 작업입니다. 그러나 응용 프로그램에서이 작업을 매우 자주 (분당 몇 번) 수행하는 경우 MIB를 한 번에 하위 에이전트에로드해야합니다. 이 서브 에이전트는 매번 MIB를로드하는 대신 다른 에이전트에서 자신을 등록 및 등록 취소합니다. MIB를로드하는 것보다 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="4bbdf176626164bdc51fe89c8ab7ac24003faec2" translate="yes" xml:space="preserve">
          <source>Loading can fail for one the following reasons:</source>
          <target state="translated">다음과 같은 이유로 로딩이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4410a62a4b26f67ed425ab03e6b26d834ab6061b" translate="yes" xml:space="preserve">
          <source>Loading of Code From Archive Files</source>
          <target state="translated">아카이브 파일에서 코드로드</target>
        </trans-unit>
        <trans-unit id="c7b4c7383cbd28718a91c4b0a187d7de34640193" translate="yes" xml:space="preserve">
          <source>Loading on previous releases is &lt;strong&gt;not&lt;/strong&gt; supported.</source>
          <target state="translated">이전 릴리스에서는로드가 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b3ddb8527fe2c15b0846a1df5469d7936b6ac994" translate="yes" xml:space="preserve">
          <source>Loading tables at startup</source>
          <target state="translated">시작시 테이블로드</target>
        </trans-unit>
        <trans-unit id="262bab97e2113ec92485a2a01d5cabfcd110e445" translate="yes" xml:space="preserve">
          <source>Loading the NIF library overrides the stub implementations and cause calls to &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; to be dispatched to the NIF implementations instead.</source>
          <target state="translated">NIF 라이브러리를로드하면 스텁 구현이 대체되고 대신 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 에 대한 호출 이 NIF 구현으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="766009fe24c4fa886de18bd755755efdbd37a7b5" translate="yes" xml:space="preserve">
          <source>Loading/unloading an application does not load/unload the code used by the application. Code loading is done the usual way.</source>
          <target state="translated">응용 프로그램을로드 / 언로드해도 응용 프로그램이 사용하는 코드는로드 / 언로드되지 않습니다. 코드 로딩은 일반적인 방법으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="595a176aa31ecdb076d6a4fbcfdce5bb9c525cbc" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;Module&lt;/code&gt; on all nodes.</source>
          <target state="translated">모든 노드에 &lt;code&gt;Module&lt;/code&gt; 을 로드 합니다.</target>
        </trans-unit>
        <trans-unit id="4ffc53d4569575bdb25ef1541658266ca11f4420" translate="yes" xml:space="preserve">
          <source>Loads a new module &lt;code&gt;Mod&lt;/code&gt;.</source>
          <target state="translated">새 모듈 &lt;code&gt;Mod&lt;/code&gt; 를 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="663b889f55fd7cc7ec3d743d418d4fed670a69b0" translate="yes" xml:space="preserve">
          <source>Loads a series of definitions and data found in the text file (generated with &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt;) into Mnesia. This function also starts Mnesia and possibly creates a new schema. This function is intended for educational purposes only. It is recommended to use other functions to deal with real backups.</source>
          <target state="translated">텍스트 파일 ( &lt;code&gt;mnesia:dump_to_textfile/1&lt;/code&gt; 로 생성)에서 찾은 일련의 정의 및 데이터 를 Mnesia로로드합니다. 이 함수는 또한 Mnesia를 시작하고 새로운 스키마를 생성 할 수 있습니다. 이 기능은 교육 목적으로 만 사용됩니다. 실제 백업을 처리하기 위해 다른 기능을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b69f0a046ca1124c0aebf63391cf8345c5a3dd5" translate="yes" xml:space="preserve">
          <source>Loads and links a dynamic library containing native implemented functions (NIFs) for a module. &lt;code&gt;Path&lt;/code&gt; is a file path to the shareable object/dynamic library file minus the OS-dependent file extension (&lt;code&gt;.so&lt;/code&gt; for Unix and &lt;code&gt;.dll&lt;/code&gt; for Windows). Notice that on most OSs the library has to have a different name on disc when an upgrade of the nif is done. If the name is the same, but the contents differ, the old library may be loaded instead. For information on how to implement a NIF library, see &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈의 기본 구현 함수 (NIF)를 포함하는 동적 라이브러리를로드하고 링크합니다. &lt;code&gt;Path&lt;/code&gt; 는 공유 가능한 객체 / 동적 라이브러리 파일에서 OS 종속 파일 확장자 ( UNIX의 경우 &lt;code&gt;.so&lt;/code&gt; , Windows의 경우 &lt;code&gt;.dll&lt;/code&gt; ) 를 뺀 파일 경로 입니다. 대부분의 OS에서 nif 업그레이드가 완료되면 라이브러리의 디스크 이름이 달라야합니다. 이름은 동일하지만 내용이 다른 경우 이전 라이브러리가 대신로드 될 수 있습니다. NIF 라이브러리를 구현하는 방법에 대한 정보는 &lt;code&gt;&lt;a href=&quot;erl_nif&quot;&gt;erl_nif(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82f1623ae8a87546c7dd248aabd05fecaf6a3b4a" translate="yes" xml:space="preserve">
          <source>Loads and links the dynamic driver &lt;code&gt;Name&lt;/code&gt;. &lt;code&gt;Path&lt;/code&gt; is a file path to the directory containing the driver. &lt;code&gt;Name&lt;/code&gt; must be a sharable object/dynamic library. Two drivers with different &lt;code&gt;Path&lt;/code&gt; parameters cannot be loaded under the same name. &lt;code&gt;Name&lt;/code&gt; is a string or atom containing at least one character.</source>
          <target state="translated">동적 드라이버 &lt;code&gt;Name&lt;/code&gt; 을 로드하고 연결합니다 . &lt;code&gt;Path&lt;/code&gt; 는 드라이버가 포함 된 디렉토리의 파일 경로입니다. &lt;code&gt;Name&lt;/code&gt; 은 공유 가능한 객체 / 동적 라이브러리 여야합니다. 다른 &lt;code&gt;Path&lt;/code&gt; 매개 변수를 가진 두 개의 드라이버 는 동일한 이름으로로드 할 수 없습니다. &lt;code&gt;Name&lt;/code&gt; 은 하나 이상의 문자를 포함하는 문자열 또는 원자입니다.</target>
        </trans-unit>
        <trans-unit id="a9103067a9d66d079fdfa3978fe03390b072c888" translate="yes" xml:space="preserve">
          <source>Loads configuration variables using the specified callback module and configuration string. The callback module is to be either loaded or present in the code part. Loaded configuration variables can later be removed using function &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 콜백 모듈 및 구성 문자열을 사용하여 구성 변수를로드합니다. 콜백 모듈은 코드 부분에로드되거나 존재해야합니다. 로드 된 구성 변수는 나중에 &lt;code&gt;&lt;a href=&quot;#remove_config-2&quot;&gt;ct:remove_config/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92030378678e8bb7a8c82cb9b51ba59dd5bd9509" translate="yes" xml:space="preserve">
          <source>Loads the MIBs into agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">MIB를 에이전트 &lt;code&gt;snmp_master_agent&lt;/code&gt; 로로드합니다 .</target>
        </trans-unit>
        <trans-unit id="4dbafa4e360e2579c05082b7f407c76430fb3b56" translate="yes" xml:space="preserve">
          <source>Loads the OTP-MIB.</source>
          <target state="translated">OTP-MIB를로드합니다.</target>
        </trans-unit>
        <trans-unit id="309db15774fbe5a771972504b9f3ef690359b4c3" translate="yes" xml:space="preserve">
          <source>Loads the OTP-OS-MON-MIB.</source>
          <target state="translated">OTP-OS-MON-MIB를로드합니다.</target>
        </trans-unit>
        <trans-unit id="f34f8f079029d395543bcd8071ed78fa06f88866" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; and the path to the dynamic library implementing the engine. This function differs from the normal engine_load in that sense it also add the engine id to the internal list in OpenSSL. Then in the following calls to the function it just fetch the reference to the engine instead of loading it again. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">&lt;code&gt;EngineId&lt;/code&gt; 가 제공하는 OpenSSL 엔진 과 엔진을 구현하는 동적 라이브러리의 경로를 로드합니다 . 이 함수는 OpenSSL의 내부 목록에 엔진 ID를 추가한다는 점에서 일반 engine_load와 다릅니다. 그런 다음 함수에 대한 다음 호출에서 다시로드하는 대신 엔진에 대한 참조를 가져옵니다. 엔진을로드 할 수없는 경우 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="790d91314c3d136e8ec61f0c269f44b4dbdfc75f" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; and the path to the dynamic library implementing the engine. This function is the same as calling &lt;code&gt;ensure_engine_loaded/3&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">&lt;code&gt;EngineId&lt;/code&gt; 가 제공하는 OpenSSL 엔진 과 엔진을 구현하는 동적 라이브러리의 경로를 로드합니다 . 이 함수는 가능한 모든 메소드 목록에 &lt;code&gt;EngineMethods&lt;/code&gt; 를 설정하여 &lt;code&gt;ensure_engine_loaded/3&lt;/code&gt; 를 호출하는 것과 동일 합니다. 엔진을로드 할 수없는 경우 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="294bfed427ce1e4aaf41a120556a07d884c20438" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;EngineId&lt;/code&gt; 에서 제공 한 OpenSSL 엔진을로드 한 다음 ok 및 엔진 핸들을 리턴합니다. 엔진을로드 할 수 없으면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19c49f3d4456a895329c5795a2a2e050a1652c20" translate="yes" xml:space="preserve">
          <source>Loads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt; if it is available and then returns ok and an engine handle. This function is the same as calling &lt;code&gt;engine_load/4&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be loaded.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;EngineId&lt;/code&gt; 에서 제공 한 OpenSSL 엔진을로드 한 다음 ok 및 엔진 핸들을 리턴합니다. 이 함수는 &lt;code&gt;EngineMethods&lt;/code&gt; 가 가능한 모든 메소드 목록으로 설정된 &lt;code&gt;engine_load/4&lt;/code&gt; 를 호출하는 것과 같습니다 . 엔진을로드 할 수 없으면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="40397b451950fbe4fa114fa0103e62e80e7fa347" translate="yes" xml:space="preserve">
          <source>Loads the application specification for an application into the application controller. It also loads the application specifications for any included applications. Notice that the function does not load the Erlang object code.</source>
          <target state="translated">응용 프로그램의 응용 프로그램 사양을 응용 프로그램 컨트롤러에로드합니다. 또한 포함 된 모든 응용 프로그램의 응용 프로그램 사양을로드합니다. 이 함수는 Erlang 객체 코드를로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec340a7ef82adaf495980f8394af2d18c4828368" translate="yes" xml:space="preserve">
          <source>Loads the modules &lt;code&gt;[Mod]&lt;/code&gt; from the directories specified in &lt;code&gt;Path&lt;/code&gt;. The script interpreter fetches the appropriate module by calling &lt;code&gt; erl_prim_loader:get_file(Mod)&lt;/code&gt;. A fatal error that terminates the system occurs if the module cannot be located.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 에 지정된 디렉토리에서 &lt;code&gt;[Mod]&lt;/code&gt; 모듈을로드합니다 . 스크립트 인터프리터는 &lt;code&gt; erl_prim_loader:get_file(Mod)&lt;/code&gt; 호출하여 적절한 모듈을 가져옵니다 . 모듈을 찾을 수없는 경우 시스템을 종료하는 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ca0882de707c0d281667a21347a4ebcd6453edd4" translate="yes" xml:space="preserve">
          <source>Loads the modules &lt;code&gt;[Mod]&lt;/code&gt; from the directories specified in &lt;code&gt;Path&lt;/code&gt;. The script interpreter fetches the appropriate module by calling &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt;. A fatal error that terminates the system occurs if the module cannot be located.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 에 지정된 디렉토리에서 모듈 &lt;code&gt;[Mod]&lt;/code&gt; 를 로드합니다 . 스크립트 인터프리터는 &lt;code&gt;erl_prim_loader:get_file(Mod)&lt;/code&gt; 호출하여 적절한 모듈을 가져옵니다 . 모듈을 찾을 수없는 경우 시스템을 종료시키는 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b222c6a3c319314c492cf0438513476921b1937e" translate="yes" xml:space="preserve">
          <source>Local Calls (*).</source>
          <target state="translated">시내 전화 (*).</target>
        </trans-unit>
        <trans-unit id="22b269c280a4483582888bf05922c7b7ce1c87e3" translate="yes" xml:space="preserve">
          <source>Local Function Names Clashing With Auto-Imported BIFs</source>
          <target state="translated">자동으로 가져온 BIF와 충돌하는 로컬 함수 이름</target>
        </trans-unit>
        <trans-unit id="036d28f25e340f821fe07d1de47fc1a75ea76b56" translate="yes" xml:space="preserve">
          <source>Local Functions (*). All local functions of analyzed modules.</source>
          <target state="translated">로컬 기능 (*). 분석 된 모듈의 모든 로컬 기능.</target>
        </trans-unit>
        <trans-unit id="fc554992a28c61639d93b552c374a6c7640f6fd7" translate="yes" xml:space="preserve">
          <source>Local and universal time, day of the week, date and time conversions.</source>
          <target state="translated">현지 및 표준시, 요일, 날짜 및 시간 변환</target>
        </trans-unit>
        <trans-unit id="3a24185719639d033f0e83cfef0d2ecbbd64ed33" translate="yes" xml:space="preserve">
          <source>Local content tables</source>
          <target state="translated">로컬 컨텐츠 테이블</target>
        </trans-unit>
        <trans-unit id="eec0b138b64b9281f5ecd12aa0d772831301eadf" translate="yes" xml:space="preserve">
          <source>Local error handling (catch/throw).</source>
          <target state="translated">로컬 오류 처리 (캐치 / 투척)</target>
        </trans-unit>
        <trans-unit id="fec84131be53b732f54c4a71b1a7666df7c2da3e" translate="yes" xml:space="preserve">
          <source>Local membership is not preserved if scope process exits and restarts. This behaviour is different from &lt;code&gt;&lt;a href=&quot;pg2&quot;&gt;pg2&lt;/a&gt;&lt;/code&gt;, that recovers local membership from remote nodes.</source>
          <target state="translated">범위 프로세스가 종료되고 다시 시작되면 로컬 멤버십이 유지되지 않습니다. 이 동작은 원격 노드에서 로컬 멤버십을 복구하는 &lt;code&gt;&lt;a href=&quot;pg2&quot;&gt;pg2&lt;/a&gt;&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="90de80d54249d1e2b8e04f06115d77bf6522dcbe" translate="yes" xml:space="preserve">
          <source>Local or remote process is monitored by name.</source>
          <target state="translated">로컬 또는 원격 프로세스는 이름으로 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7734a4ec06d4dd200eb7b25986d4166f45276c" translate="yes" xml:space="preserve">
          <source>Local port is monitored by name. Please note, that remote port monitors are not supported, so &lt;code&gt;Node&lt;/code&gt; will always be the local node name.</source>
          <target state="translated">로컬 포트는 이름으로 모니터링됩니다. 원격 포트 모니터는 지원되지 않으므로 &lt;code&gt;Node&lt;/code&gt; 는 항상 로컬 노드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e7d3e02be42f1c184b6a3c3c525e75c5179c0a77" translate="yes" xml:space="preserve">
          <source>Local port is monitored by port id.</source>
          <target state="translated">로컬 포트는 포트 ID로 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6dd59b11d0e4520b4498e658eed0dbf5af795c" translate="yes" xml:space="preserve">
          <source>Local time is obtained from the Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt;. Universal time is computed from the BIF &lt;code&gt;universaltime/0&lt;/code&gt;.</source>
          <target state="translated">현지 시간은 Erlang BIF &lt;code&gt;localtime/0&lt;/code&gt; 에서 얻습니다 . 표준시는 BIF &lt;code&gt;universaltime/0&lt;/code&gt; 에서 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="4bbadc0e66c71769347f5cbcfb7c145c283ad8fd" translate="yes" xml:space="preserve">
          <source>LocalFunctionHandler,</source>
          <target state="translated">LocalFunctionHandler,</target>
        </trans-unit>
        <trans-unit id="fa3ca264b4b0fef6182372f6a2a3773355ef8380" translate="yes" xml:space="preserve">
          <source>Locally Used Functions (*). Functions of all modules that have been used in some local call.</source>
          <target state="translated">로컬로 사용되는 기능 (*). 일부 로컬 호출에 사용 된 모든 모듈의 기능.</target>
        </trans-unit>
        <trans-unit id="5b09785286488bac8a487ce328cb324b03ce2288" translate="yes" xml:space="preserve">
          <source>Location data produced by the log macros, and/or metadata given as argument to the log call (API function or macro), are merged with the process metadata. If the same keys occur, values from the metadata argument to the log call overwrite values from the process metadata, which in turn overwrite values from the location data.</source>
          <target state="translated">로그 매크로에 의해 생성 된 위치 데이터 및 / 또는 로그 호출에 대한 인수로 제공된 메타 데이터 (API 함수 또는 매크로)는 프로세스 메타 데이터와 병합됩니다. 동일한 키가 발생하면 메타 데이터 인수에서 로그 호출까지의 값이 프로세스 메타 데이터의 값을 덮어 쓰고 위치 데이터의 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="98d3b1967c02fdc780f97715c22bad74f36e5d2c" translate="yes" xml:space="preserve">
          <source>Location transparency. Programs can be written without knowledge of the actual data location.</source>
          <target state="translated">위치 투명성. 실제 데이터 위치에 대한 지식 없이도 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7786377791ba3a21918764c28fc12553cbbcfa4e" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS에서 BIF &lt;code&gt;erlang:process_info/1&lt;/code&gt; 의 위치 투명 버전 .</target>
        </trans-unit>
        <trans-unit id="ee8a078095b685bbe1aa5a8273ed6ba602b4e833" translate="yes" xml:space="preserve">
          <source>Location transparent version of the BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; in ERTS.</source>
          <target state="translated">ERTS에서 BIF &lt;code&gt;erlang:process_info/2&lt;/code&gt; 의 위치 투명 버전 .</target>
        </trans-unit>
        <trans-unit id="7890346208b55e9f0de8ac7ad2436d80c5f1ce98" translate="yes" xml:space="preserve">
          <source>Lock &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; for ports and processes are interchangeable with the use of &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; and is the reason why &lt;code&gt;pid()&lt;/code&gt; and &lt;code&gt;port()&lt;/code&gt; options can be used in both &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Id&lt;/code&gt; space. Both pids and ports are special identifiers with stripped creation and can be recreated with &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트 및 프로세스의 잠금 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Id&lt;/code&gt; 는 &lt;code&gt;lcnt:swap_pid_keys/0&lt;/code&gt; 을 사용하여 서로 바꿔 사용할 수 있으며 &lt;code&gt;pid()&lt;/code&gt; 및 &lt;code&gt;port()&lt;/code&gt; 옵션을 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Id&lt;/code&gt; 공간 모두에서 사용할 수있는 이유 입니다. pid와 포트는 모두 생성이 제거 된 특수 식별자이며 &lt;code&gt;&lt;a href=&quot;#pid-3&quot;&gt;lcnt:pid/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#port-2&quot;&gt;lcnt:port/1,2&lt;/a&gt;&lt;/code&gt; 로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a1f5f8eab7c8604bc5fd5406eb1dc291955e813" translate="yes" xml:space="preserve">
          <source>Lock physical memory. Defaults to &lt;code&gt;no&lt;/code&gt;, that is, no physical memory is locked. If set to &lt;code&gt;all&lt;/code&gt;, all memory mappings made by the runtime system are locked into physical memory. If set to &lt;code&gt;all&lt;/code&gt;, the runtime system fails to start if this feature is not supported, the user has not got enough privileges, or the user is not allowed to lock enough physical memory. The runtime system also fails with an out of memory condition if the user limit on the amount of locked memory is reached.</source>
          <target state="translated">실제 메모리를 잠급니다. 기본값은 &lt;code&gt;no&lt;/code&gt; 로 , 즉 물리적 메모리가 잠기지 않은 것입니다. &lt;code&gt;all&lt;/code&gt; 로 설정 하면 런타임 시스템에서 작성된 모든 메모리 맵핑이 실제 메모리에 잠 깁니다. &lt;code&gt;all&lt;/code&gt; 로 설정 하면이 기능이 지원되지 않거나 사용자에게 충분한 권한이 없거나 사용자가 충분한 실제 메모리를 잠글 수없는 경우 런타임 시스템이 시작되지 않습니다. 잠긴 메모리의 양에 대한 사용자 한계에 도달하면 런타임 시스템은 메모리 부족 상태로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9644e8510fee7197b968870e4b28fa5886afdcd9" translate="yes" xml:space="preserve">
          <source>LockKind :: &lt;code&gt;&lt;a href=&quot;#type-write_locks&quot;&gt;write_locks()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">LockKind :: &lt;code&gt;&lt;a href=&quot;#type-write_locks&quot;&gt;write_locks()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="45057a24787103ff08cc02cd027e2fddb757a403" translate="yes" xml:space="preserve">
          <source>Locks a mutex. The calling thread is blocked until the mutex has been locked. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; lock the same mutex again.</source>
          <target state="translated">뮤텍스를 잠급니다. 뮤텍스가 잠길 때까지 호출 스레드가 차단됩니다. 현재 뮤텍스를 잠근 스레드 는 동일한 뮤텍스를 다시 잠글 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="07893be798653c5847566c8be8dbfc1f8e339a9a" translate="yes" xml:space="preserve">
          <source>Locks are released when the outermost transaction ends.</source>
          <target state="translated">가장 바깥 쪽 트랜잭션이 끝나면 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="94c151cf6fbb179cda9bff3f3d73d852d7a92582" translate="yes" xml:space="preserve">
          <source>Locks have an inherent cost in execution time and memory space. It takes time initialize, destroy, aquiring or releasing locks. To decrease lock contention it some times necessary to use finer grained locking strategies. This will usually also increase the locking overhead and hence there is a tradeoff between lock contention and overhead. In general, lock contention increases with the number of threads running concurrently. The &lt;code&gt;lcnt&lt;/code&gt; tool does not measure locking overhead.</source>
          <target state="translated">잠금은 실행 시간과 메모리 공간에 고유 한 비용이 있습니다. 잠금을 초기화, 파기, 획득 또는 해제하는 데 시간이 걸립니다. 잠금 경합을 줄이려면 더 세밀한 잠금 전략을 사용해야합니다. 이는 일반적으로 잠금 오버 헤드를 증가 시키므로 잠금 경합과 오버 헤드 사이에 상충 관계가 있습니다. 일반적으로 잠금 경합은 동시에 실행되는 스레드 수에 따라 증가합니다. &lt;code&gt;lcnt&lt;/code&gt; 의 도구는 오버 헤드 잠금 측정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97e3b2745352de6be776b6b063835147719fb8df" translate="yes" xml:space="preserve">
          <source>Locks in the emulator are named after what type of resource they protect and where in the emulator they are initialized, those are lock 'classes'. Most of those locks are also instantiated several times, and given unique identifiers, to increase locking granularity. Typically an instantiated lock protects a disjunct set of the resource, for example ets tables, processes or ports. In other cases it protects a specific range of a resource, for example &lt;code&gt;pix_lock&lt;/code&gt; which protects index to process mappings, and is given a unique number within the class. A unique lock in &lt;code&gt;lcnt&lt;/code&gt; is referenced by a name (class) and an identifier: &lt;code&gt;{Name, Id}&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터의 잠금은 보호하는 리소스 유형과 에뮬레이터의 초기화 위치, 잠금 '클래스'에 따라 이름이 지정됩니다. 이러한 잠금의 대부분은 잠금 세분성을 높이기 위해 여러 번 인스턴스화되고 고유 식별자가 제공됩니다. 일반적으로 인스턴스화 된 잠금은 ets 테이블, 프로세스 또는 포트와 같은 분리 된 리소스 세트를 보호합니다. 다른 경우에는 특정 범위의 리소스 (예 : &lt;code&gt;pix_lock&lt;/code&gt; ) 를 보호하여 인덱스와 프로세스 매핑을 보호하고 클래스 내에서 고유 한 번호를 부여합니다. &lt;code&gt;lcnt&lt;/code&gt; 의 고유 잠금은 이름 (클래스) 및 식별자 &lt;code&gt;{Name, Id}&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e8dbe53a83645d1cc991331113f81f0a7faf9914" translate="yes" xml:space="preserve">
          <source>Locks the configuration target.</source>
          <target state="translated">구성 대상을 잠급니다.</target>
        </trans-unit>
        <trans-unit id="278c995aa0e75b2b9c086639c4daf158ccfe0917" translate="yes" xml:space="preserve">
          <source>Locks the driver used by the port &lt;code&gt;port&lt;/code&gt; in memory for the rest of the emulator process' lifetime. After this call, the driver behaves as one of Erlang's statically linked-in drivers.</source>
          <target state="translated">나머지 에뮬레이터 프로세스 수명 동안 포트 &lt;code&gt;port&lt;/code&gt; 가 사용하는 드라이버 를 메모리에 잠급니다 . 이 호출 후 드라이버는 Erlang의 정적으로 링크 된 드라이버 중 하나로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="877522e39f7783d66d9b87789ee2ec4ff4bf44e6" translate="yes" xml:space="preserve">
          <source>Locks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">인수 ( &lt;code&gt;pdl&lt;/code&gt; ) 로 전달 된 포트 데이터 잠금을 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="c61a839f83e5687db76049539133035688e5e448" translate="yes" xml:space="preserve">
          <source>Log File</source>
          <target state="translated">로그 파일</target>
        </trans-unit>
        <trans-unit id="38f84854507a1065ca8c9cdcabd8f6b4e1e78700" translate="yes" xml:space="preserve">
          <source>Log a standard error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">표준 오류 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d0480874641874b7e8e0be1a60fc5834def2580a" translate="yes" xml:space="preserve">
          <source>Log a standard error event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">표준 오류 이벤트를 기록하십시오. &lt;code&gt;Format&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인수의 인수와 동일한 &lt;code&gt;io:format/2&lt;/code&gt; STDLIB있다.</target>
        </trans-unit>
        <trans-unit id="ad4ad09e24cbfd4d5d21372873fb510f9def4cc0" translate="yes" xml:space="preserve">
          <source>Log a standard information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">표준 정보 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b41037da94e8aee3e126b299e92f7fe2e27f3503" translate="yes" xml:space="preserve">
          <source>Log a standard information event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">표준 정보 이벤트를 기록하십시오. &lt;code&gt;Format&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인수의 인수와 동일한 &lt;code&gt;io:format/2&lt;/code&gt; STDLIB있다.</target>
        </trans-unit>
        <trans-unit id="3fa6e0baa5d187967c02dcd11af5efcea6dd94e2" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">표준 경고 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0d4fed3a8c3034253fd45573f68ab458ca57cd12" translate="yes" xml:space="preserve">
          <source>Log a standard warning event. The &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; arguments are the same as the arguments of &lt;code&gt;io:format/2&lt;/code&gt; in STDLIB.</source>
          <target state="translated">표준 경고 이벤트를 기록하십시오. &lt;code&gt;Format&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인수의 인수와 동일한 &lt;code&gt;io:format/2&lt;/code&gt; STDLIB있다.</target>
        </trans-unit>
        <trans-unit id="1844b1c7ae49d978743ba14c4e6a6dc7c218a27d" translate="yes" xml:space="preserve">
          <source>Log a user-defined error event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">사용자 정의 오류 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="887d25b1b376c5062e3b1b29ffe4bc683a9b4867" translate="yes" xml:space="preserve">
          <source>Log a user-defined information event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">사용자 정의 정보 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="6d52584bb8ee44c32d0e928afa86be59daa75386" translate="yes" xml:space="preserve">
          <source>Log a user-defined warning event. Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">사용자 정의 경고 이벤트를 기록하십시오. 오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="068d9dbd5d7dcab97d0cf593a32eb92cca768c9e" translate="yes" xml:space="preserve">
          <source>Log events that do not contain any domain field, match only when &lt;code&gt;Compare&lt;/code&gt; is equal to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;not_equal&lt;/code&gt;.</source>
          <target state="translated">도메인 필드를 포함하지 않는 로그 이벤트는 &lt;code&gt;Compare&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;not_equal&lt;/code&gt; 인 경우에만 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="dab7fd93efd795148bbe27e97e70b16665121c7b" translate="yes" xml:space="preserve">
          <source>Log files are always UTF-8 encoded. The encoding cannot be changed by setting the mode &lt;code&gt;{encoding,Encoding}&lt;/code&gt;.</source>
          <target state="translated">로그 파일은 항상 UTF-8로 인코딩됩니다. &lt;code&gt;{encoding,Encoding}&lt;/code&gt; 모드를 설정하여 인코딩을 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="420705b9279101c5f7f8c29e1095fd25e0bd28a6" translate="yes" xml:space="preserve">
          <source>Log files are written in &lt;code&gt;log_dir&lt;/code&gt;. Each log file has a name of the form &lt;code&gt;erlang.log.N&lt;/code&gt;, where N is a generation number, ranging from 1 to 5. Each log file holds up to 100 kB text. As time goes by, the following log files are found in the log file directory:</source>
          <target state="translated">로그 파일은 &lt;code&gt;log_dir&lt;/code&gt; 에 작성됩니다 . 각 로그 파일의 이름은 &lt;code&gt;erlang.log.N&lt;/code&gt; 형식 이며 여기서 N은 1에서 5까지의 생성 번호입니다. 각 로그 파일은 최대 100kB 텍스트를 보유합니다. 시간이 지남에 따라 다음 로그 파일이 로그 파일 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a923af4f09938b28def56fc57c9c20863233189b" translate="yes" xml:space="preserve">
          <source>Log files from every repeated test run is saved in normal &lt;code&gt;Common Test&lt;/code&gt; fashion (described earlier).</source>
          <target state="translated">반복되는 모든 테스트 실행의 로그 파일은 일반적인 &lt;code&gt;Common Test&lt;/code&gt; 방식으로 저장됩니다 (앞서 설명).</target>
        </trans-unit>
        <trans-unit id="2578374749dfd011e3a5cbfbf27037022ad25cd6" translate="yes" xml:space="preserve">
          <source>Log files grow very large, very quickly.</source>
          <target state="translated">로그 파일은 매우 빠르게 커집니다.</target>
        </trans-unit>
        <trans-unit id="e92387004c6d91ee27198a23307e44f60b2be4d5" translate="yes" xml:space="preserve">
          <source>Log levels are expressed as atoms. Internally in Logger, the atoms are mapped to integer values, and a log event passes the log level check if the integer value of its log level is less than or equal to the currently configured log level. That is, the check passes if the event is equally or more severe than the configured level. See section &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; for a listing and description of all log levels.</source>
          <target state="translated">로그 수준은 원자로 표현됩니다. 내부적으로 로거에서 원자는 정수 값에 매핑되며 로그 이벤트의 로그 값이 현재 구성된 로그 수준보다 작거나 같은 경우 로그 이벤트가 로그 수준 검사를 통과합니다. 즉, 이벤트가 구성된 수준과 같거나 더 심각한 경우 확인이 통과됩니다. 섹션을 참조 &lt;code&gt;&lt;a href=&quot;#log_level&quot;&gt;Log Level&lt;/a&gt;&lt;/code&gt; 모든 로그 수준의 목록 및 설명.</target>
        </trans-unit>
        <trans-unit id="e3d6b530f7c8342006e1b77a12ea94bab500b544" translate="yes" xml:space="preserve">
          <source>Log size.</source>
          <target state="translated">로그 크기.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
