<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="383d8ab46c4dd3dcb7dacf32d96619c30112c096" translate="yes" xml:space="preserve">
          <source>Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of &lt;code&gt;N&lt;/code&gt;: at a rate of &lt;code&gt;R&lt;/code&gt; requests per second, an &lt;code&gt;N&lt;/code&gt;-bit counter traverses all of its values in &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; minutes, so the bound is &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt;.</source>
          <target state="translated">RFC 6733을 사용하려면 종단 간 식별자가 최소 4 분 동안 고유하게 유지되어야하며이 값과 호출 속도는 &lt;code&gt;N&lt;/code&gt; 의 적절한 값에 대해 하한을 설정해야 합니다. 초당 &lt;code&gt;R&lt;/code&gt; 요청 비율 , &lt;code&gt;N&lt;/code&gt; -bit 카운터는 모든 값을 &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; 분으로 통과 하므로 바운드는 &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab161900c8191797fce6b824ca72c3fe1be8d39b" translate="yes" xml:space="preserve">
          <source>Note that TLS-1.3 and TLS-1.2 cipher suites are not overlapping sets of cipher suites so to support both these versions cipher suites from both versions need to be included. If supporting TLS-1.3 versions prior to TLS-1.2 can not be supported.</source>
          <target state="translated">TLS-1.3 및 TLS-1.2 암호 제품군은 겹치는 암호 제품군 집합이 아니므로 두 버전을 모두 지원하려면 두 버전의 암호 제품군을 포함해야합니다. TLS-1.2 이전의 TLS-1.3 버전을 지원하는 경우 지원할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d954d0938e64e5c37a1b11f9fbf14279ee90b30d" translate="yes" xml:space="preserve">
          <source>Note that \0dd is always an octal code, and that \8 and \9 are the literal characters &quot;8&quot; and &quot;9&quot;.</source>
          <target state="translated">\ 0dd는 항상 8 진 코드이며 \ 8과 \ 9는 리터럴 문자 &quot;8&quot;과 &quot;9&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="fa00a5e7155faa8238baf7626fd63ae2adafb209" translate="yes" xml:space="preserve">
          <source>Note that a &lt;strong&gt;state enter call&lt;/strong&gt;&lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this actually is not a &lt;strong&gt;state change&lt;/strong&gt;. In this case &lt;code&gt;OldState =:= State&lt;/code&gt;, which cannot happen for a subsequent state change, but will happen when repeating the &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="translated">참고 &amp;bull; 그래도 &lt;strong&gt;상태가 입력 한 전화는 &lt;/strong&gt;&lt;strong&gt;것&lt;/strong&gt; 이 실제로없는 경우에도 초기 상태에 들어가기 전에 완료 권리가 될 &lt;strong&gt;상태 변경을&lt;/strong&gt; . 이 경우 &lt;code&gt;OldState =:= State&lt;/code&gt; , 후속 상태 변경에는 발생할 수 없지만 &lt;strong&gt;state enter call을&lt;/strong&gt; 반복 할 때 발생 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dd8f4a584e7baae9c7b73d493c112b4faac49187" translate="yes" xml:space="preserve">
          <source>Note that a dictionary module should have a unique name so as not collide with existing modules in the system.</source>
          <target state="translated">사전 모듈은 시스템의 기존 모듈과 충돌하지 않도록 고유 한 이름을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7d48dfa81ed35ed91309a0c63bf84e4d12b8db94" translate="yes" xml:space="preserve">
          <source>Note that a dictionary's &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, together with the &lt;code&gt;outdir&lt;/code&gt; option, determine the output paths when the &lt;code&gt;return&lt;/code&gt; option is not specified. The &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of a literal input dictionary defaults to &lt;code&gt;dictionary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;outdir&lt;/code&gt; 옵션 과 함께 사전의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 은 &lt;code&gt;return&lt;/code&gt; 옵션이 지정되지 않은 경우 출력 경로를 결정 합니다. 리터럴 입력 사전 의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 은 기본적으로 &lt;code&gt;dictionary&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="592ecd079ddc2c5dbec2876bde4efe18192a7501" translate="yes" xml:space="preserve">
          <source>Note that a distributed node will fail to start if epmd is not running.</source>
          <target state="translated">epmd가 실행되고 있지 않으면 분산 노드가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="210dee4c712f6038124cea11c85e7ab317eb49aa" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; event for a given peer corresponds to multiple &lt;code&gt;peer_up/3&lt;/code&gt; or &lt;code&gt;peer_down/3&lt;/code&gt; callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications.</source>
          <target state="translated">지정된 피어에 대한 단일 &lt;code&gt;up&lt;/code&gt; 또는 &lt;code&gt;down&lt;/code&gt; 이벤트는 기능 교환 중에 협상 된 각 Diameter 애플리케이션에 대해 하나씩 여러 개의 &lt;code&gt;peer_up/3&lt;/code&gt; 또는 &lt;code&gt;peer_down/3&lt;/code&gt; 콜백에 해당합니다. 즉,이 이벤트는 전체적으로 피어와의 연결을 통신하는 반면 콜백은 개별 Diameter 응용 프로그램과 관련하여 연결을 통신합니다.</target>
        </trans-unit>
        <trans-unit id="87238ebabfbb3a6373dc0cd859835703ac206a8a" translate="yes" xml:space="preserve">
          <source>Note that a state enter call &lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this formally is not a state change. In this case &lt;code&gt;OldState&lt;/code&gt; will be the same as &lt;code&gt;State&lt;/code&gt;, which can not happen for a subsequent state change, but will happen when repeating the state enter call.</source>
          <target state="translated">공식적으로 상태 변경이 아니더라도 초기 상태로 들어가기 직전에 상태 입력 호출 &lt;strong&gt;이&lt;/strong&gt; 수행됩니다. 이 경우 &lt;code&gt;OldState&lt;/code&gt; 는 &lt;code&gt;State&lt;/code&gt; 와 동일하며 , 이는 후속 상태 변경에는 발생하지 않지만 상태 입력 호출을 반복 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a1ae5ee8fe086b1e864731f91a5db626649b898" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case).</source>
          <target state="translated">다른 모든 사용자는 '현재 사용자'가 함수 (이 경우 recv)를 호출 &lt;strong&gt;할&lt;/strong&gt; 때까지 &lt;strong&gt;잠 깁니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fb520f2054c75e0b1b39831bcf49afdb1c0b3e3f" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case). So either immediately call the function or &lt;code&gt;&lt;a href=&quot;socket#cancel-2&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 모든 사용자는 '현재 사용자'가 함수 (이 경우 recv)를 호출 &lt;strong&gt;할&lt;/strong&gt; 때까지 &lt;strong&gt;잠 깁니다&lt;/strong&gt; . 따라서 즉시 함수를 호출하거나 &lt;code&gt;&lt;a href=&quot;socket#cancel-2&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cea408404d235688202589e612b275a8ce277c9d" translate="yes" xml:space="preserve">
          <source>Note that all processing is done in the context of the calling process. A transport module could call this function via one of the &lt;code&gt;spawn&lt;/code&gt; functions (e.g. &lt;code&gt;spawn_opt&lt;/code&gt;). See also &lt;code&gt;receive_message/4,5&lt;/code&gt;.</source>
          <target state="translated">모든 처리는 호출 프로세스의 컨텍스트에서 수행됩니다. 전송 모듈은 &lt;code&gt;spawn&lt;/code&gt; 함수 (예 : &lt;code&gt;spawn_opt&lt;/code&gt; ) 중 하나를 통해이 함수를 호출 할 수 있습니다. &lt;code&gt;receive_message/4,5&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3db41f10bff721f3ee02192c83ee3f08a54b12b" translate="yes" xml:space="preserve">
          <source>Note that although guard expressions should only yield boolean values, this function does not guarantee that &lt;code&gt;Term&lt;/code&gt; is either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed.</source>
          <target state="translated">가드 표현식은 부울 값만 생성해야하지만이 함수는 &lt;code&gt;Term&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 임을 보장하지 않습니다 . 또한 let-expression과 같은 단순한 구조 만 재귀 적으로 검사됩니다. 일반 상수 접기는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f01d1482d475dcf2740463e55c6c430cd948d4e9" translate="yes" xml:space="preserve">
          <source>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.</source>
          <target state="translated">SMIv2 MIB는 SMIv1 MIB를 가져올 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9b685cbc242545fbad15153c417da3182cac4fef" translate="yes" xml:space="preserve">
          <source>Note that an abstract atom may have several literal representations, and that the representation yielded by this function is not fixed; e.g., &lt;code&gt;atom_lit(c_atom(&quot;a\012b&quot;))&lt;/code&gt; could yield the string &lt;code&gt;&quot;\'a\\nb\'&quot;&lt;/code&gt;.</source>
          <target state="translated">추상 원자는 몇 가지 리터럴 표현을 가질 수 있으며이 함수에 의해 생성 된 표현은 고정되어 있지 않습니다. 예를 들어, &lt;code&gt;atom_lit(c_atom(&quot;a\012b&quot;))&lt;/code&gt; 는 &lt;code&gt;&quot;\'a\\nb\'&quot;&lt;/code&gt; 문자열을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f6954c77f955dafa6a2e123d05e96d272275df" translate="yes" xml:space="preserve">
          <source>Note that an alias-name is only unique within the mib, so when loading several mib's into a manager, there might be several instances of the same aliasname.</source>
          <target state="translated">alias-name은 mib 내에서만 고유하므로 여러 mib를 관리자에로드 할 때 동일한 aliasname의 여러 인스턴스가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe0be9b4d38daeed36a33562bc4da5606bc0b2f" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well when you have for example a status call as in section &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; 섹션에서와 같이 상태 호출이 있거나 알 수없는 이벤트를 처리 하는 경우 이벤트 시간 제한이 제대로 작동하지 않습니다. 모든 종류의 이벤트가 이벤트 시간 제한을 취소하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="44d8f63bf6bc16034f55c5cb547506223b7f3f16" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well with when you have for example a status call as in &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; 에서와 같이 상태 호출이 있거나 알 수없는 이벤트를 처리 하는 경우 이벤트 시간 초과가 제대로 작동하지 않습니다. 모든 종류의 이벤트는 이벤트 시간 초과를 취소합니다.</target>
        </trans-unit>
        <trans-unit id="def0f5ad0a0ace41622689a594950eb3fe32da96" translate="yes" xml:space="preserve">
          <source>Note that an inherited AVP that sets the V flag takes its Vendor-Id from either &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inheriting dictionary or &lt;code&gt;@vendor&lt;/code&gt; in the inherited dictionary. In particular, &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inherited dictionary is ignored. Inheriting from a dictionary that specifies the required &lt;code&gt;@vendor&lt;/code&gt; is equivalent to using &lt;code&gt;@avp_vendor_id&lt;/code&gt; with a copy of the dictionary's definitions but the former makes for easier reuse.</source>
          <target state="translated">V 플래그를 설정하는 상속 된 AVP 는 상속 사전의 &lt;code&gt;@vendor&lt;/code&gt; 또는 상속 된 사전의 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 에서 Vendor-Id를 가져 옵니다 . 특히 상속 된 사전의 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 는 무시됩니다. 필수 &lt;code&gt;@vendor&lt;/code&gt; 를 지정하는 사전에서 상속하는 것은 사전 정의 사본과 함께 &lt;code&gt;@avp_vendor_id&lt;/code&gt; 를 사용하는 것과 동일 하지만 전자는 더 쉽게 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d33800347145579293148a2f5b8e31e3a2764de" translate="yes" xml:space="preserve">
          <source>Note that arguments for macros cannot be complex expressions, because the arguments are split on &lt;code&gt;,&lt;/code&gt;. For example, the following would not work because &lt;strong&gt;beam_makeops&lt;/strong&gt; would split the expression into two arguments:</source>
          <target state="translated">인수는에 분할되어 있기 때문에 매크로 인수, 복잡한 표현식이 될 수 없습니다 &lt;code&gt;,&lt;/code&gt; . 예를 들어 다음은 &lt;strong&gt;beam_makeops&lt;/strong&gt; 가 표현식을 두 개의 인수로 분할 하므로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f5995dd05307d17cf1cf0275ae54c1c965044890" translate="yes" xml:space="preserve">
          <source>Note that both lists in &lt;code&gt;cipher&lt;/code&gt; has been changed to the provided value (&lt;code&gt;'aes128-ctr'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cipher&lt;/code&gt; 두 목록 이 제공된 값 ( &lt;code&gt;'aes128-ctr'&lt;/code&gt; ) 으로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a24670d7b6d01336c8695b5d4d57a391c44adcb2" translate="yes" xml:space="preserve">
          <source>Note that capabilities for an outgoing hello can be passed directly to &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">나가는 hello에 대한 기능은 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 로 직접 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e251f553696cbbe8af62f9b6e14b96ffcbc62108" translate="yes" xml:space="preserve">
          <source>Note that clauses following a default action will be ignored.</source>
          <target state="translated">기본 동작 다음에 나오는 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0160a9b8ce02f625812816b1ccc97166a7bb4956" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random and master_secret are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">client_random, server_random 및 master_secret은 연결 보안에 영향을주는 값입니다. 위에 지정되지 않은 의미있는 원자는 ssl 옵션 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f5dd2f74718152ce40902beac42e0c7a6f30ccfb" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random, master_secret and keylog are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">client_random, server_random, master_secret 및 keylog는 연결 보안에 영향을주는 값입니다. 위에 지정되지 않은 의미있는 원자는 ssl 옵션 이름입니다.</target>
        </trans-unit>
        <trans-unit id="67bf6b7b0630a07fa672109442d6b02fb72a8793" translate="yes" xml:space="preserve">
          <source>Note that doing the primary log level filtering through a filter and not through the level is quite a lot more expensive, so make sure to test that your system can handle the extra load before you enable it on a production node.</source>
          <target state="translated">레벨을 통하지 않고 필터를 통해 기본 로그 레벨 필터링을 수행하는 것은 훨씬 더 비싸므로 프로덕션 노드에서 활성화하기 전에 시스템이 추가로드를 처리 할 수 ​​있는지 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1fbc0b27f1c4b9334d7d0f187cdb9b5cc6eedece" translate="yes" xml:space="preserve">
          <source>Note that e.g. the result of &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; represents any and all of `x\ny'', `x\12y'', `x\012y'' and `x\^Jy\''; see &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; 의 결과는 `x \ ny ',`x \ 12y',`x \ 012y '및`x \ ^ Jy \'를 모두 나타냅니다. &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba188de7ea4673245bb93e421ced2f5246f6549c" translate="yes" xml:space="preserve">
          <source>Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.</source>
          <target state="translated">각 튜플은 하나 이상의 AVP 값을 전달합니다. 중복 튜플을 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="edc604b194978efcbdba0cbc4b89b369a9c99a82" translate="yes" xml:space="preserve">
          <source>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported with ecdsa and ecdh.</source>
          <target state="translated">ec_gf2m은 공개 키 알고리즘은 아니지만 ecdsa 및 ecdh에서 지원되는 곡선에 대한 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="29cd43d95778b2d115dbf308b03c62ae1c0160c0" translate="yes" xml:space="preserve">
          <source>Note that even if this function returns some &lt;code&gt;Tail&lt;/code&gt; that is not &lt;code&gt;none&lt;/code&gt;, the type of &lt;code&gt;Tail&lt;/code&gt; can be &lt;code&gt;nil&lt;/code&gt;, if the tail has been given explicitly, and the list skeleton has not been compacted (see &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 함수가 &lt;code&gt;none&lt;/code&gt; 이 아닌 일부 &lt;code&gt;Tail&lt;/code&gt; 을 반환하더라도 꼬리가 명시 적으로 제공되고 목록 골격이 압축되지 않은 경우 &lt;code&gt;Tail&lt;/code&gt; 유형은 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="192c5999ce9ab89a2a2dbe3ec7c900d7ee1db0a4" translate="yes" xml:space="preserve">
          <source>Note that file and line have to be added in the metadata by the caller of &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log/3&lt;/a&gt;&lt;/code&gt; as otherwise Logger will not know from where it was called. The file and line number are automatically added if you use the &lt;code&gt;?LOG_ERROR&lt;/code&gt; macros in &lt;code&gt;kernel/include/logger.hrl&lt;/code&gt;.</source>
          <target state="translated">파일과 행은 &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log/3&lt;/a&gt;&lt;/code&gt; 호출자에 의해 메타 데이터에 추가되어야합니다 . 그렇지 않으면 Logger가 호출 된 위치를 알 수 없습니다. &lt;code&gt;kernel/include/logger.hrl&lt;/code&gt; 에서 &lt;code&gt;?LOG_ERROR&lt;/code&gt; 매크로 를 사용하면 파일과 줄 번호가 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c389355e70f459658e087541ff06cacc40c70758" translate="yes" xml:space="preserve">
          <source>Note that for e.g. &lt;code&gt;protocol&lt;/code&gt; = &lt;code&gt;tcp&lt;/code&gt;, most implementations doing a close does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side.</source>
          <target state="translated">예를 들어 &lt;code&gt;protocol&lt;/code&gt; = &lt;code&gt;tcp&lt;/code&gt; 의 경우 , 닫기를 수행하는 대부분의 구현은 전송 된 데이터가 원격 측에서 닫기가 감지되기 ​​전에 수신자에게 전달된다는 것을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b99d2d0f80623c57fbaf51f6886234e7e4b951d" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;EngineId&lt;/code&gt; has the value &lt;code&gt;discovery&lt;/code&gt;, the agent cannot send &lt;code&gt;inform&lt;/code&gt; messages to that manager until it has performed the &lt;strong&gt;discovery&lt;/strong&gt; process with that manager.</source>
          <target state="translated">&lt;code&gt;EngineId&lt;/code&gt; 에 &lt;code&gt;discovery&lt;/code&gt; 값 이 있으면 에이전트는 해당 관리자 와 의 &lt;strong&gt;감지&lt;/strong&gt; 프로세스를 수행 할 때까지 해당 관리자 &lt;code&gt;inform&lt;/code&gt; 메시지를 보낼 수 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55bac8de272758448fe7d117efd8941f423d23e9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;udp&lt;/code&gt; is used, the same transport process could be used for several connections. This could make upgrading impossible.</source>
          <target state="translated">경우 참고 &lt;code&gt;udp&lt;/code&gt; 사용하는 경우, 동일한 전송 프로세스가 여러 연결에 사용될 수 있습니다. 업그레이드가 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18ab9ea99f0d2ed9aaa93df42d7129d992c9c108" translate="yes" xml:space="preserve">
          <source>Note that if a length (&lt;code&gt;&amp;gt; 0&lt;/code&gt;) is specified, and only part of that amount of data is available, the function will return with that data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait for the remaining data, it must immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="translated">길이 (경우에 있습니다 &lt;code&gt;&amp;gt; 0&lt;/code&gt; )을 지정하고, 데이터의 양의 일부만 사용할 수있는 함수는 데이터를 반환 &lt;strong&gt;하고 &lt;/strong&gt; &lt;code&gt;SelectInfo&lt;/code&gt; (호출자가 남아있는 데이터를 기다리지 않으려면, 그것은해야 즉시 &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; 함수를 호출하십시오 .)</target>
        </trans-unit>
        <trans-unit id="ed4a9e62154b96609da080c17aec27f4dd9246b0" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;port&lt;/code&gt; is given and if &lt;code&gt;taddress&lt;/code&gt; does not contain a port number, the default value is used.</source>
          <target state="translated">어떤 경우주의 &lt;code&gt;port&lt;/code&gt; 있는 경우 주어지지하고 &lt;code&gt;taddress&lt;/code&gt; 는 포트 번호를 포함하지 않는, 디폴트 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6b057ff98ba4785947d02f48c8fb42e16a4c39b" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;tdomain&lt;/code&gt; is given, the default value, &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, is used.</source>
          <target state="translated">&lt;code&gt;tdomain&lt;/code&gt; 을 지정 하지 않으면 기본값 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de8909d667626be185465024dfa8ebbd745359a8" translate="yes" xml:space="preserve">
          <source>Note that if not all the data was sent, the function will return with the remaining data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait to be able to send the rest, it should immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="translated">참고 모든 데이터가 전송 된 경우, 함수는 남아있는 데이터를 반환 할 것입니다 &lt;strong&gt;및 &lt;/strong&gt; &lt;code&gt;SelectInfo&lt;/code&gt; (호출자가 나머지를 보낼 수 있도록 기다리지 않으려면, 그것은 즉시 호출해야 &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; 기능을.)</target>
        </trans-unit>
        <trans-unit id="c484d69e82a05974946be309952b5bc3d7f4c76d" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;gen_statem&lt;/code&gt; is started through &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt;, this callback will never be called. Since this callback is not optional it can in that case be implemented as:</source>
          <target state="translated">경우 생성합니다 &lt;code&gt;gen_statem&lt;/code&gt; 를 통해 시작 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt; ,이 콜백이 호출되지 않습니다. 이 콜백은 선택 사항이 아니기 때문에 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c87f385bbe639188084f38ba17c84501fe670ca" translate="yes" xml:space="preserve">
          <source>Note that if the Version argument is &lt;code&gt;dynamic&lt;/code&gt;, the decoder should try to figure out the actual version from the message itself and then use the proper decoder, e.g. version 1.</source>
          <target state="translated">Version 인수가 &lt;code&gt;dynamic&lt;/code&gt; 인 경우 디코더는 메시지 자체에서 실제 버전을 파악한 다음 올바른 디코더 (예 : 버전 1)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="12f48a08b82dbcdbabc6e426452d1ee74de3e1a7" translate="yes" xml:space="preserve">
          <source>Note that if the body is small all data may be delivered in only one chunk and then the callback will be called with {last, Data::binary(), undefined} without getting called with &lt;code&gt;{first, Data::binary()}&lt;/code&gt;.</source>
          <target state="translated">본문이 작 으면 모든 데이터가 하나의 청크로만 전달 될 수 있으며 &lt;code&gt;{first, Data::binary()}&lt;/code&gt; 호출되지 않고 {last, Data :: binary (), undefined}로 콜백이 호출됩니다. .</target>
        </trans-unit>
        <trans-unit id="edf8bcd8d88dd948c2709c3f285acd4c03e67af3" translate="yes" xml:space="preserve">
          <source>Note that if the fun returns &lt;code&gt;unknown&lt;/code&gt; for an extension marked as critical, validation will fail.</source>
          <target state="translated">중요로 표시된 확장에 대해 fun이 &lt;code&gt;unknown&lt;/code&gt; 것을 반환 하면 유효성 검사가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9d0a053447ab79088b7ef6197ebb840d173587a7" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;warnings&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the option &lt;code&gt;verbosity&lt;/code&gt; is &lt;code&gt;silence&lt;/code&gt;, warning messages will still be shown.</source>
          <target state="translated">옵션 &lt;code&gt;warnings&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 옵션 세부 &lt;code&gt;verbosity&lt;/code&gt; 가 &lt;code&gt;silence&lt;/code&gt; 이면 경고 메시지가 계속 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5dec77651df10446f2452013b0e653832ee5a101" translate="yes" xml:space="preserve">
          <source>Note that if the reply is segmented (split into several smaller messages; segments), then some extra info, segment number and an indication if all segments of a reply has been received or not, is also included in the &lt;code&gt;UserReply&lt;/code&gt;.</source>
          <target state="translated">응답이 분할 된 경우 (여러 개의 작은 메시지, 세그먼트로 분할) 응답의 모든 세그먼트가 수신되었는지 여부에 대한 추가 정보, 세그먼트 번호 및 표시도 &lt;code&gt;UserReply&lt;/code&gt; 에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e84fec2f22c7d49771617b7f4326149f8363362" translate="yes" xml:space="preserve">
          <source>Note that in Erlang, a receive-expression must have at least one clause if no timeout part is specified.</source>
          <target state="translated">Erlang에서 시간 종료 부분이 지정되지 않은 경우 receive-expression에 하나 이상의 절이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="08a96fc716918fe5871d98094662c927e7804b46" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_in_daemon_option&quot;&gt;tcpip_tunnel_in&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="translated">Erlang / OTP SSH 서버 (데몬)를 피어 로 사용하는 경우 연결을 허용하려면 해당 서버가 &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_in_daemon_option&quot;&gt;tcpip_tunnel_in&lt;/a&gt;&lt;/code&gt; 옵션으로 시작되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="629d6084a6f0543f14df18dbc3535aef38711dc0" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_out_daemon_option&quot;&gt;tcpip_tunnel_out&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="translated">Erlang / OTP SSH 서버 (데몬)가 피어 인 경우 연결을 허용하려면 해당 서버가 &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_out_daemon_option&quot;&gt;tcpip_tunnel_out&lt;/a&gt;&lt;/code&gt; 옵션으로 시작되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8cef48befcd401dd112e3b47e9b84cfba29baac7" translate="yes" xml:space="preserve">
          <source>Note that in most implementations of TCP, doing a &lt;code&gt;close&lt;/code&gt; does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side. If you want to guarantee delivery of the data to the recipient there are two common ways to achieve this.</source>
          <target state="translated">대부분의 TCP 구현에서 &lt;code&gt;close&lt;/code&gt; 수행한다고해서 닫기가 원격 측에서 감지되기 ​​전에 전송 된 모든 데이터가 수신자에게 전달되는 것은 아닙니다. 수신자에게 데이터가 전달되도록하려면 두 가지 일반적인 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9a4adbac3d627161edb16842c38f7517677ffd5" translate="yes" xml:space="preserve">
          <source>Note that in order for reltool to sort application versions and thereby be able to select the latest, it is required that the version id for the application consits of integers and dots only, for example &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2.0&lt;/code&gt; or &lt;code&gt;3.17.1&lt;/code&gt;.</source>
          <target state="translated">reltool이 애플리케이션 버전을 정렬하여 최신 버전을 선택할 수 있으려면 애플리케이션의 버전 ID가 정수 및 점 (예 : &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2.0&lt;/code&gt; 또는 &lt;code&gt;3.17.1&lt;/code&gt; )으로 만 구성되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="e044f396b1f21f65746f1535663887993d7e14da" translate="yes" xml:space="preserve">
          <source>Note that integers in the list always represent code points regardless of &lt;code&gt;InEncoding&lt;/code&gt; passed. If &lt;code&gt;InEncoding latin1&lt;/code&gt; is passed, only code points &amp;lt; 256 are allowed; otherwise, all valid unicode code points are allowed.</source>
          <target state="translated">목록의 정수는 전달 된 &lt;code&gt;InEncoding&lt;/code&gt; 에 관계없이 항상 코드 포인트를 나타냅니다 . 경우 &lt;code&gt;InEncoding latin1&lt;/code&gt; 전달 만 코드 포인트 &amp;lt;256 사용할 수 있습니다; 그렇지 않으면 유효한 모든 유니 코드 코드 포인트가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b71fac57eccdc841417bdc84d942c5ed4df483a" translate="yes" xml:space="preserve">
          <source>Note that it also blocks other operations than just &lt;code&gt;rpc:block_call()&lt;/code&gt; operations, so use it with care.</source>
          <target state="translated">&lt;code&gt;rpc:block_call()&lt;/code&gt; 작업 이외의 다른 작업도 차단 하므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="da41371a24cf2bfa4ed67187ea540808d0a4589a" translate="yes" xml:space="preserve">
          <source>Note that it is easiest to write this kind of recursive generator using a help function, like the &lt;code&gt;lazy_gen/1&lt;/code&gt; function above. It can also be written using a recursive fun, if you prefer to not clutter your function namespace and are comfortable with writing that kind of code.</source>
          <target state="translated">위 의 &lt;code&gt;lazy_gen/1&lt;/code&gt; 함수 와 같은 help 함수를 사용하여 이런 종류의 재귀 생성기를 작성하는 것이 가장 쉽습니다 . 함수 네임 스페이스를 어지럽히 지 않고 그러한 종류의 코드를 작성하는 데 익숙하다면 재귀 적 인 재미를 사용하여 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32d52e1a01dca7a3f60f88baf54204f13cb5c4b" translate="yes" xml:space="preserve">
          <source>Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event.</source>
          <target state="translated">이 타임 아웃은 다른 이벤트에 의해 자동으로 취소되므로이 타임 아웃을 취소 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d2bc208d4ef85523a8bb2be7f7fe6957054fa30" translate="yes" xml:space="preserve">
          <source>Note that it is possible for this function to filter out targets (but &lt;strong&gt;not&lt;/strong&gt; to add its own) by returning an updated &lt;code&gt;Targets&lt;/code&gt; list (&lt;code&gt;NewTargets&lt;/code&gt;).</source>
          <target state="translated">이 함수 는 업데이트 된 &lt;code&gt;Targets&lt;/code&gt; 목록 ( &lt;code&gt;NewTargets&lt;/code&gt; ) 을 반환하여 대상을 필터링 할 수 있지만 ( 자체를 추가 하지는 &lt;strong&gt;않음&lt;/strong&gt; ) 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e68901639556f6e842921bc4c6aab5754c944701" translate="yes" xml:space="preserve">
          <source>Note that it is up to the user to ensure that correct code to execute via &lt;code&gt;erpc&lt;/code&gt; is available on the involved nodes.</source>
          <target state="translated">관련 노드에서 &lt;code&gt;erpc&lt;/code&gt; 를 통해 실행할 올바른 코드를 사용할 수 있는지 확인하는 것은 사용자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e083fd2ab9cd6e5f1715c135b9ad0cd6133523" translate="yes" xml:space="preserve">
          <source>Note that it seldom needs to be started explicitly since it is automatically started by the functions that need a running server.</source>
          <target state="translated">실행중인 서버가 필요한 기능에 의해 자동으로 시작되므로 명시 적으로 시작하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="bf76532ed69f19d320e28943c7ea7794c8213294" translate="yes" xml:space="preserve">
          <source>Note that its implementation dependant (and also dependent on mib-storage is used) if a backup is possible.</source>
          <target state="translated">백업이 가능한 경우 구현에 따라 (및 mib-storage에 따라 달라짐) 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="1fddaac0c2eba362c90fcf63bcdd71ddcd1d0713" translate="yes" xml:space="preserve">
          <source>Note that just because we have a documented and described option, it does &lt;strong&gt;not&lt;/strong&gt; mean that the OS supports it. So its recommended that the user reads the platform specific documentation for the option used.</source>
          <target state="translated">문서화되고 설명 된 옵션이 있다고해서 OS가이를 지원한다는 의미 는 &lt;strong&gt;아닙니다&lt;/strong&gt; . 따라서 사용자는 사용 된 옵션에 대한 플랫폼 별 문서를 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fec78a15c5217c92c95a49b94462adac13df7646" translate="yes" xml:space="preserve">
          <source>Note that new types may be added in the future, so the caller must be prepared to handle unknown types.</source>
          <target state="translated">나중에 새로운 유형이 추가 될 수 있으므로 호출자는 알 수없는 유형을 처리 할 준비가되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1ef50791d64ed0c0b90d9621e25834b3006be609" translate="yes" xml:space="preserve">
          <source>Note that no checking is done whether &lt;code&gt;Name&lt;/code&gt; is a reserved attribute name such as &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;: it is assumed that the attribute is &quot;wild&quot;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이 &lt;code&gt;module&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 와 같은 예약 된 속성 이름 인지 여부는 확인되지 않습니다 . 속성이 &quot;wild&quot;인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="da792409efb1d957a763465a0f90eb01b22a65de" translate="yes" xml:space="preserve">
          <source>Note that no global trace patterns are affected by this function.</source>
          <target state="translated">이 기능의 영향을받는 전역 추적 패턴은 없습니다.</target>
        </trans-unit>
        <trans-unit id="c9dbd761e7b3ccf030e5d2634d121608a5fc566a" translate="yes" xml:space="preserve">
          <source>Note that not all individual &lt;code&gt;Option&lt;/code&gt;s are checked when the spawn request is sent. Some &lt;code&gt;Option&lt;/code&gt;s can only be checked on reception of the request. Therefore an invalid option does &lt;strong&gt;not&lt;/strong&gt; cause a &lt;code&gt;badarg&lt;/code&gt; exception, but will cause the spawn operation to fail with an error reason of &lt;code&gt;badopt&lt;/code&gt;.</source>
          <target state="translated">스폰 요청이 전송 될 때 모든 개별 &lt;code&gt;Option&lt;/code&gt; 이 확인되는 것은 아닙니다 . 일부 &lt;code&gt;Option&lt;/code&gt; 은 요청 수신시에만 확인할 수 있습니다. 따라서 잘못된 옵션은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 원인 &lt;code&gt;badarg&lt;/code&gt; 의 예외를하지만 스폰 작업이의 오류 이유와 함께 실패합니다 &lt;code&gt;badopt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc1046cde1e5db61beca0efc3f9616a4641ffd20" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:connect_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="translated">모든 &lt;code&gt;gen_tcp:connect_option()&lt;/code&gt; 이 허용 되는 것은 아닙니다 . 금지 된 옵션 목록은 &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da7f42298d81e647ec75e32ec8f0a6e4e85efbf7" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:listen_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="translated">모든 &lt;code&gt;gen_tcp:listen_option()&lt;/code&gt; 이 허용 되는 것은 아닙니다 . 금지 된 옵션 목록은 &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="beb7d234e889fecf34a0a8cc44508f7dd715d1f4" translate="yes" xml:space="preserve">
          <source>Note that only one transport per kind for each transport domain can be configured.</source>
          <target state="translated">각 전송 도메인에 대해 종류 당 하나의 전송 만 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef85014f2633aed4a8852aa3b53ebbaf3622c48" translate="yes" xml:space="preserve">
          <source>Note that only the exec channel is closed after the one-time execution. The connection is still up and can handle previously opened channels. It is also possible to open a new channel:</source>
          <target state="translated">일회성 실행 후에는 exec 채널 만 닫힙니다. 연결은 여전히 ​​작동하며 이전에 열린 채널을 처리 할 수 ​​있습니다. 새 채널을 열 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1047c06dfd85c28e322de4ae968c83146c41303a" translate="yes" xml:space="preserve">
          <source>Note that processes that execute configuration functions or test cases are never included in &lt;code&gt;TestProcs&lt;/code&gt;. It is therefore safe to use post configuration hook functions (such as post_end_per_suite, post_end_per_group, post_end_per_testcase) to terminate all processes in &lt;code&gt;TestProcs&lt;/code&gt; that have the current group leader process as its group leader.</source>
          <target state="translated">구성 기능 또는 테스트 케이스를 실행하는 프로세스는 &lt;code&gt;TestProcs&lt;/code&gt; 에 포함되지 않습니다 . 따라서 사후 구성 후크 기능 (예 : post_end_per_suite, post_end_per_group, post_end_per_testcase)을 사용 하여 현재 그룹 리더 프로세스가 그룹 리더 인 &lt;code&gt;TestProcs&lt;/code&gt; 의 모든 프로세스를 종료 하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="83100a56e14e247fd18ef628ef7f4b9f51213734" translate="yes" xml:space="preserve">
          <source>Note that raw filenames &lt;strong&gt;not&lt;/strong&gt; necessarily are encoded the same way as on the OS level.</source>
          <target state="translated">원시 파일 이름 은 반드시 OS 수준에서와 같은 방식으로 인코딩 될 필요는 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="82914e4f408f26df4d5bb211a9e507c3fd9f2819" translate="yes" xml:space="preserve">
          <source>Note that some curves are disabled if FIPS is enabled.</source>
          <target state="translated">FIPS가 활성화 된 경우 일부 곡선이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="dbb3e885aec0adb2e32b31326d16ceb9409b7c9f" translate="yes" xml:space="preserve">
          <source>Note that spaces are preserved and that no point (.) is needed at the end - that was required by the default evaluator.</source>
          <target state="translated">공백이 유지되고 끝에 점 (.)이 필요하지 않습니다. 이는 기본 평가자가 필요로하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="15df3770c93a08f3b7628f1b3671253fafbc1cf9" translate="yes" xml:space="preserve">
          <source>Note that special characters in the text (&amp;lt;, &amp;gt; and &amp;amp;) will be escaped by Common Test before the text is printed to the log file.</source>
          <target state="translated">텍스트의 특수 문자 (&amp;lt;,&amp;gt; 및 &amp;amp;)는 텍스트가 로그 파일에 인쇄되기 전에 공통 테스트에 의해 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="863f3323e07ccde5b57c1b225a8cb6abcf3f22bb" translate="yes" xml:space="preserve">
          <source>Note that the &quot;super&quot; in super alignment and the &quot;super&quot; in super carrier has nothing to do with each other. We could have choosen another naming to avoid confusion, such as &quot;meta&quot; carrier or &quot;giant&quot; aligment.</source>
          <target state="translated">수퍼 얼라인먼트의 &quot;슈퍼&quot;와 수퍼 캐리어의 &quot;슈퍼&quot;는 서로 관련이 없습니다. 혼동을 피하기 위해 &quot;메타&quot;캐리어 또는 &quot;거대한&quot;aligment와 같은 다른 이름을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27bd01e0ed18a111b98018e635bbdb5be686872" translate="yes" xml:space="preserve">
          <source>Note that the (new) extended transport entries (including &lt;code&gt;Kind&lt;/code&gt; and &lt;code&gt;Opts&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; specify port-info as they ignore any value specified by &lt;code&gt;intAgentUDPPort&lt;/code&gt;.</source>
          <target state="translated">(새) 확장 전송 항목 ( &lt;code&gt;Kind&lt;/code&gt; 및 &lt;code&gt;Opts&lt;/code&gt; 포함 ) &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;intAgentUDPPort&lt;/code&gt; 로 지정된 값을 무시하므로 port-info를 지정 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7563ce9bbb8cb2de2be12e2c300f540e095441b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;RecordName&lt;/code&gt; and &lt;code&gt;Fields&lt;/code&gt; arguments my not be used in all implementations (they are actually only needed for mnesia-based implementations).</source>
          <target state="translated">있습니다 &lt;code&gt;RecordName&lt;/code&gt; 및 &lt;code&gt;Fields&lt;/code&gt; 인수 (그들은 실제로 단지 mnesia 기반 구현에 필요한) 모든 구현에 사용되는 나의.</target>
        </trans-unit>
        <trans-unit id="79647059410cdcc68796c813c0ea00f1df08febf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;erl_parse&lt;/code&gt; representation is identical for &quot;&lt;code&gt;FunctionType&lt;/code&gt;&quot; and &quot;&lt;code&gt;fun(FunctionType)&lt;/code&gt;&quot;.</source>
          <target state="translated">참고 것을 &lt;code&gt;erl_parse&lt;/code&gt; 표현 &quot;에 대한 동일 &lt;code&gt;FunctionType&lt;/code&gt; '과' &lt;code&gt;fun(FunctionType)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="77e8b76dc02c9cee773231d4002d964ee921a983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;sect&lt;/strong&gt; curves are GF2m (characteristic two) curves and are only supported if the underlying OpenSSL has support for them. See also &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">참고 것을 &lt;strong&gt;종파&lt;/strong&gt; 곡선 GF2m (특징 2 개)의 곡선이고 단지 기본 OpenSSL에 그들에 대한 지원이 경우 지원된다. &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="e846e6d7b0cd63a03e739f368b1e0f75bf3068da" translate="yes" xml:space="preserve">
          <source>Note that the AVP in question can be defined in an inherited dictionary in order to introduce additional values to an enumeration otherwise defined in another dictionary.</source>
          <target state="translated">문제의 AVP는 다른 사전에 다르게 정의 된 열거에 추가 값을 도입하기 위해 상속 된 사전에 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="545f0e872a991ae7619c44fcd6c8013504712aeb" translate="yes" xml:space="preserve">
          <source>Note that the CCF of this AVP is not the same as in RFC 3588.</source>
          <target state="translated">이 AVP의 CCF는 RFC 3588과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3839e34d035de6fcffb30bf27e41d5c5ddbeeb10" translate="yes" xml:space="preserve">
          <source>Note that the actual definition of (some of) these records depend on the megaco protocol version used. For instance, the &lt;code&gt;'TransactionReply'&lt;/code&gt; record has two more fields in version 3, so a simple erlang type definition cannot be made here.</source>
          <target state="translated">이러한 레코드 (일부)의 실제 정의는 사용 된 megaco 프로토콜 버전에 따라 다릅니다. 예를 들어 &lt;code&gt;'TransactionReply'&lt;/code&gt; 레코드에는 버전 3의 필드가 두 개 더 있으므로 여기서 간단한 erlang 유형 정의를 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc8a5b787d8524598e83ff6424d17b88b62138a1" translate="yes" xml:space="preserve">
          <source>Note that the actual supported dss_digest_type depends on the underlying crypto library. In OpenSSL version &amp;gt;= 1.0.1 the listed digest are supported, while in 1.0.0 only sha, sha224 and sha256 are supported. In version 0.9.8 only sha is supported.</source>
          <target state="translated">실제로 지원되는 dss_digest_type은 기본 암호화 라이브러리에 따라 다릅니다. OpenSSL 버전&amp;gt; = 1.0.1에서는 나열된 다이제스트가 지원되는 반면 1.0.0에서는 sha, sha224 및 sha256 만 지원됩니다. 버전 0.9.8에서는 sha 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3b70bc0ac9ae266a36a7ccaa90cb46529ab3a596" translate="yes" xml:space="preserve">
          <source>Note that the algorithms in the file &lt;code&gt;ex2.config&lt;/code&gt; is not yet applied. They will be when we start ssh:</source>
          <target state="translated">&lt;code&gt;ex2.config&lt;/code&gt; 파일의 알고리즘 은 아직 적용되지 않았습니다. ssh를 시작할 때 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="3f7c24f4a4a2d3cbb7e5f46db8ca5bbd93271e2c" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="translated">대안 인 이전 &lt;code&gt;Module:add_host_key/3&lt;/code&gt; 는 더 이상 &lt;code&gt;ssh_file&lt;/code&gt; 에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9cdefbbcdb7a6e85db537e1b6266c9775e69d082" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="translated">대안으로 이전 &lt;code&gt;Module:is_host_key/4&lt;/code&gt; 는 더 이상 &lt;code&gt;ssh_file&lt;/code&gt; 에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ca45c6542e0b81fb0f24e8247dda5f01d933e7b" translate="yes" xml:space="preserve">
          <source>Note that the appended algorithm is removed from its original place and then appended to the same list.</source>
          <target state="translated">추가 된 알고리즘은 원래 위치에서 제거 된 다음 동일한 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3ccb116cfa36059b115c940833292db4f44f844b" translate="yes" xml:space="preserve">
          <source>Note that the buffer pointed to by the &lt;code&gt;outbuf&lt;/code&gt; argument must be large enough if a non &lt;code&gt;NULL&lt;/code&gt; value is passed as &lt;code&gt;outbuf&lt;/code&gt;. You typically want to call &lt;code&gt;ei_decode_iodata()&lt;/code&gt; twice. First with a non &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; argument and a &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;outbuf&lt;/code&gt; argument in order to determine the size of the buffer needed, and then once again in order to do the actual decoding. Note that the integer pointed to by &lt;code&gt;index&lt;/code&gt; will be updated by the call determining the size as well, so you need to reset it before the second call doing the actual decoding.</source>
          <target state="translated">&lt;code&gt;outbuf&lt;/code&gt; 인수가 가리키는 버퍼는 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 값이 &lt;code&gt;outbuf&lt;/code&gt; 로 전달되는 경우 충분히 커야 합니다 . 일반적으로 &lt;code&gt;ei_decode_iodata()&lt;/code&gt; 두 번 호출하려고합니다 . 먼저 비와 &lt;code&gt;NULL&lt;/code&gt; 의 &lt;code&gt;size&lt;/code&gt; 인수 및 &lt;code&gt;NULL&lt;/code&gt; &lt;code&gt;outbuf&lt;/code&gt; 실제 디코딩을 수행하기 위해 다시 한번 필요한 버퍼의 크기를 결정하고,하기 위해 인수. &lt;code&gt;index&lt;/code&gt; 가 가리키는 정수는 크기를 결정하는 호출에 의해 업데이트되므로 실제 디코딩을 수행하는 두 번째 호출 전에 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f612c010562004f09536ba4c9211c91bf97b929" translate="yes" xml:space="preserve">
          <source>Note that the category argument is not required in order to only specify the importance of a printout. Example:</source>
          <target state="translated">인쇄물의 중요도 만 지정하기 위해 category 인수는 필요하지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="4b7df81861af684495c97c5fff7559eaf0915d2f" translate="yes" xml:space="preserve">
          <source>Note that the client is free to use any order and to exclude methods.</source>
          <target state="translated">클라이언트는 순서를 자유롭게 사용하고 메소드를 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="468edd7f0dc67514b910bd2116ac92cf52f20c09" translate="yes" xml:space="preserve">
          <source>Note that the command specified with the &lt;code&gt;-rsh&lt;/code&gt; flag is treated as a file name which may contain spaces. It is thus not possible to include any command line options. The remote node will be launched as &lt;code&gt;&quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ...&lt;/code&gt;, so the &lt;code&gt;erl&lt;/code&gt; command must be found in the path on the remote host.</source>
          <target state="translated">&lt;code&gt;-rsh&lt;/code&gt; 플래그로 지정된 명령 은 공백을 포함 할 수있는 파일 이름으로 처리됩니다. 따라서 명령 줄 옵션을 포함 할 수 없습니다. 원격 노드는 &lt;code&gt;&quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ...&lt;/code&gt; 으로 시작되므로 원격 호스트의 경로에서 &lt;code&gt;erl&lt;/code&gt; 명령을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="035d18f56820efe86cdac35e4891682c6e3af7b9" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; will fail.</source>
          <target state="translated">컴파일러는 원자를 멀리 최적화 할 수 있습니다. 예를 들어, 컴파일러는 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 을 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 으로 다시 작성 합니다. 해당 표현식이 포함 모듈에서 원자 &lt;code&gt;some_atom&lt;/code&gt; 에 대한 유일한 언급 인 경우, 모듈이로드 될 때 원자가 작성되지 않으며 &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; 대한 후속 호출 이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f826da285ddceeccbdbefeb9bfa7b16ed554783f" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; will fail.</source>
          <target state="translated">컴파일러는 원자를 멀리 최적화 할 수 있습니다. 예를 들어, 컴파일러는 &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; 을 &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; 으로 다시 작성 합니다. 해당 표현식이 포함 모듈에서 원자 &lt;code&gt;some_atom&lt;/code&gt; 에 대한 유일한 언급 인 경우, 모듈이로드 될 때 원자가 작성되지 않으며, &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; 에 대한 후속 호출 이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b82f239fea0a2dc9f48ac7fd1ebc1ab0b5051a56" translate="yes" xml:space="preserve">
          <source>Note that the data extracted from the imported (loaded) mibs are stored partly by the mib-server and partly by the symbolic-store server. See the default mib-server data module, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; for details.</source>
          <target state="translated">가져온 (로드 된) mib에서 추출 된 데이터는 mib-server에 의해 부분적으로 그리고 symbolic-store 서버에 의해 부분적으로 저장됩니다. 자세한 내용은 기본 mib-server 데이터 모듈 &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5bf74d56bb97406e9b99c3e9e52d5dbf134b453d" translate="yes" xml:space="preserve">
          <source>Note that the events &lt;code&gt;$s | $S&lt;/code&gt;, &lt;code&gt;l | $L&lt;/code&gt; and &lt;code&gt;$z | $Z&lt;/code&gt; has nothing to do with the timers using the same characters.</source>
          <target state="translated">이벤트 &lt;code&gt;$s | $S&lt;/code&gt; , &lt;code&gt;l | $L&lt;/code&gt; 및 &lt;code&gt;$z | $Z&lt;/code&gt; 는 같은 문자를 사용하는 타이머와 아무 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42629d78e6fdce7f2ed90c950f63dbfb4e3b847a" translate="yes" xml:space="preserve">
          <source>Note that the existing &lt;code&gt;.beam&lt;/code&gt; file must contain &lt;strong&gt;abstract code&lt;/strong&gt;, i.e. it must have been compiled with the &lt;code&gt;debug_info&lt;/code&gt; option. If not, the error reason &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; is returned. If the abstract code is encrypted, and no key is available for decrypting it, the error reason &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; is returned.</source>
          <target state="translated">기존 &lt;code&gt;.beam&lt;/code&gt; 파일에는 &lt;strong&gt;추상 코드&lt;/strong&gt; 가 포함되어야합니다 . 즉, &lt;code&gt;debug_info&lt;/code&gt; 옵션 으로 컴파일해야합니다 . 그렇지 않으면 오류 이유 &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; 이 리턴됩니다. 추상 코드가 암호화되어 있고 해독에 사용할 수있는 키가 없으면 오류 이유 &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="efa3ec631430748847eae6fa5201d4a2accae7a7" translate="yes" xml:space="preserve">
          <source>Note that the first two instruction have three fragments, while the other two only have two fragments. Here are the fragments:</source>
          <target state="translated">처음 두 명령에는 세 개의 조각이있는 반면 다른 두 명령에는 두 개의 조각 만 있습니다. 다음은 조각입니다.</target>
        </trans-unit>
        <trans-unit id="9a18b13a51422254edcdb84073c354c33a88853b" translate="yes" xml:space="preserve">
          <source>Note that the following will always be loaded:</source>
          <target state="translated">다음이 항상로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a2e58d441f9e2f474d803ab6a32dc6712ae978" translate="yes" xml:space="preserve">
          <source>Note that the function does not check if this entry already exists.</source>
          <target state="translated">함수는이 항목이 이미 존재하는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="279bdf4d0a207f6c87ecb0b4e0489436649191bf" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they can not be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">생성 된 인증서 및 키는 공식적으로 올바른 PKIX-trust-chain을 제공하지 않으며 실제 보안을 달성하는 데 사용할 수 없습니다. 이 기능은 테스트 목적으로 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="078ffae6e673ee69ef0d8a166daaaedfa933f1dd" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they cannot be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">생성 된 인증서와 키는 공식적으로 올바른 PKIX-trust-chain을 제공하지 않으며 실제 보안을 달성하는 데 사용할 수 없습니다. 이 기능은 테스트 목적으로 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6d6ba71f76cfedfe0e85aa82b7676692388cd2df" translate="yes" xml:space="preserve">
          <source>Note that the internal data that the &lt;code&gt;StateEnc&lt;/code&gt; and &lt;code&gt;StateDec&lt;/code&gt; references are destructivly updated by the calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt;. This is to gain time in the calls of the nifs interfacing the cryptolib. In a loop where the state is saved in the loop's state, it also saves one update of the loop state per crypto operation.</source>
          <target state="translated">&lt;code&gt;StateEnc&lt;/code&gt; 및 &lt;code&gt;StateDec&lt;/code&gt; 이 참조 하는 내부 데이터는 &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; 호출에 의해 파괴적으로 업데이트됩니다 . 이것은 cryptolib를 인터페이스하는 nifs의 호출 시간을 확보하기위한 것입니다. 상태가 루프의 상태에 저장되는 루프에서는 암호화 작업 당 루프 상태의 업데이트 하나도 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="02818bfeb97510589873cb15d812dd13537919d3" translate="yes" xml:space="preserve">
          <source>Note that the internal database is (re-)initiated during the compilation, meaning any previously collected coverage data for the module will be lost.</source>
          <target state="translated">내부 데이터베이스는 컴파일 중에 (재) 시작됩니다. 즉, 모듈에 대해 이전에 수집 된 적용 범위 데이터가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="cd70be69f8094d7d21e00a3313e50198d0e46168" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpa_net_if&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">네트워크 인터페이스 필터는 애플리케이션 ( &lt;code&gt;snmpa_net_if&lt;/code&gt; )이 제공하는 네트워크 인터페이스 구현에서 사용되는 필터입니다 . 기본 필터는 모든 메시지를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ec89ab3b5094ea790ba1c908f83fb43e535fef72" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpm_net_if&lt;/code&gt; and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">네트워크 인터페이스 필터는 애플리케이션에서 제공하는 네트워크 인터페이스 구현 ( &lt;code&gt;snmpm_net_if&lt;/code&gt; 및 &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; )에서 사용되는 필터입니다 . 기본 필터는 모든 메시지를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="34cd017ef347f58960dd48f7604233f91388b9db" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the agent in this way is to add the agent related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt;.</source>
          <target state="translated">실제로 이런 방식으로 에이전트를 시작하는 유일한 방법은 응용 프로그램을 시작한 후 에이전트 관련 구성을 추가하는 것입니다 (예 : 일반 응용 프로그램 구성의 일부일 수 없음 : sys.config). &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="81acf13e164a6ca93c0ecb3350e2a756f1a26bc4" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the manager in this way is to add the manager related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt;.</source>
          <target state="translated">실제로 이런 방식으로 관리자를 시작하는 유일한 방법은 응용 프로그램을 시작한 후 관리자 관련 구성을 추가하는 것입니다 (예 : 일반 응용 프로그램 구성의 일부가 될 수 없음 : sys.config). &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe1baccf1828d7692350ac5f909a060eecbece59" translate="yes" xml:space="preserve">
          <source>Note that the order of the tuples in the resulting list is undefined and may change at any time.</source>
          <target state="translated">결과 목록에서 튜플의 순서는 정의되지 않았으며 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07cb3c0cb2baba7b63c67e88c6cd13cca1a7e679" translate="yes" xml:space="preserve">
          <source>Note that the order that things are printed have changed, and also I added a reverse-dns lookup of the IP address. This will not print as nicely when using a single line formatter, however you can also use a report_cb fun with 2 arguments where the second argument is the formatting options.</source>
          <target state="translated">사물이 인쇄되는 순서가 변경되었으며 IP 주소의 역 DNS 조회도 추가했습니다. 이것은 한 줄 포맷터를 사용할 때 제대로 인쇄되지 않지만 두 번째 인수가 형식화 옵션 인 두 개의 인수와 함께 report_cb fun을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a75f4183db30bfbd690aebb40a7591e31cfea3" translate="yes" xml:space="preserve">
          <source>Note that the ordering of the tuples in the lists didn't matter.</source>
          <target state="translated">리스트에서 튜플의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f94de51b2bccdc5fd6127e2ecc608b422d804fb9" translate="yes" xml:space="preserve">
          <source>Note that the process that calls this function &lt;strong&gt;must&lt;/strong&gt; be permanent. If it dies, the port(s) will exit and the driver unload.</source>
          <target state="translated">이 함수를 호출하는 프로세스는 영구적 &lt;strong&gt;이어야&lt;/strong&gt; 합니다. 죽으면 포트가 종료되고 드라이버가 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="112c3dfc73e40a04304d2c8d43acbdb9eb33ab97" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt;) are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">이 기능을 사용 하는 경우 요청 특정 매개 변수 (예 : &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt; )는 인스 트루먼 테이션 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="290365691c0a5e60df1a89c122ce6576ebc4f890" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">이 기능을 사용 하면 요청 특정 매개 변수 (예 : &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; ) 에 계측 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="becd11dbe64d3cd785c4bb1c3c28a2d4f227a406" translate="yes" xml:space="preserve">
          <source>Note that the segments are delivered to the user differently depending on which function is used to issue the original request. When issuing the request using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; function, the segments are delivered to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function one at a time, as they arrive. But this obviously doe not work for the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; function. In this case, the segments are accumulated and then delivered all at once as the function returns.</source>
          <target state="translated">원래 요청을 발행하는 데 사용되는 기능에 따라 세그먼트가 사용자에게 다르게 전달됩니다. &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 요청을 발행 할 때 세그먼트는 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 콜백 함수 를 통해 사용자 에게 도착할 때 한 번에 하나씩 전달됩니다 . 그러나 이것은 &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 기능 에는 효과가 없습니다 . 이 경우 세그먼트가 누적 된 다음 함수가 반환 될 때 한 번에 모두 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e78277755ce3bad3e06f00c82c4d07b3b9286ed6" translate="yes" xml:space="preserve">
          <source>Note that the ssl application is required for TLS and must be started before configuring TLS capability on diameter transports.</source>
          <target state="translated">SSL 응용 프로그램은 TLS에 필요하며 직경 전송에 TLS 기능을 구성하기 전에 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="2dee8e68f59d0a0eec57cc8147e1a5be661efd08" translate="yes" xml:space="preserve">
          <source>Note that the unmentioned lists (&lt;code&gt;public_key&lt;/code&gt;, &lt;code&gt;cipher&lt;/code&gt;, &lt;code&gt;mac&lt;/code&gt; and &lt;code&gt;compression&lt;/code&gt;) are un-changed.</source>
          <target state="translated">언급되지 않은 목록 ( &lt;code&gt;public_key&lt;/code&gt; , &lt;code&gt;cipher&lt;/code&gt; , &lt;code&gt;mac&lt;/code&gt; 및 &lt;code&gt;compression&lt;/code&gt; )은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8989301ef700984d41bf0a2801b22ca08a2ce1f" translate="yes" xml:space="preserve">
          <source>Note that the use of the LocalEngineID argument is only intended for special cases, if the agent is to &quot;emulate&quot; multiple EngineIDs! By default, the agent uses the value of &lt;code&gt;SnmpEngineID&lt;/code&gt; (see SNMP-FRAMEWORK-MIB).</source>
          <target state="translated">에이전트가 여러 EngineID를 &quot;에뮬레이션&quot;하는 경우 LocalEngineID 인수 사용은 특수한 경우에만 사용됩니다. 기본적으로 에이전트는 &lt;code&gt;SnmpEngineID&lt;/code&gt; 값을 사용합니다 (SNMP-FRAMEWORK-MIB 참조).</target>
        </trans-unit>
        <trans-unit id="f2ec007dbfec9a50f3790ddfb78b2d7470067938" translate="yes" xml:space="preserve">
          <source>Note that the very first thing done is to fetch the address to the next instruction. The reason is that it usually improves performance.</source>
          <target state="translated">가장 먼저 수행되는 작업은 주소를 다음 명령어로 가져 오는 것입니다. 그 이유는 일반적으로 성능이 향상되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d56e76ea1af9a17fd56fb02b811e895206d51eb5" translate="yes" xml:space="preserve">
          <source>Note that there is a special case when the value of &lt;code&gt;ReqId&lt;/code&gt; has the value of the atom &lt;code&gt;netif&lt;/code&gt;. This means that the NetIF process has suffered a &quot;fatal&quot; error and been restarted. With possible loss of traffic!</source>
          <target state="translated">&lt;code&gt;ReqId&lt;/code&gt; 값이 원자 &lt;code&gt;netif&lt;/code&gt; 값을 가질 때 특별한 경우가 있습니다. 이는 NetIF 프로세스에 &quot;치명적인&quot;오류가 발생하여 다시 시작되었음을 의미합니다. 교통 손실 가능성이 있습니다!</target>
        </trans-unit>
        <trans-unit id="b41a1b6fd82bf7a6c9a348c40309d8522ab51f73" translate="yes" xml:space="preserve">
          <source>Note that there may be multiple entries with the same &lt;code&gt;ref&lt;/code&gt;, in contrast to &lt;code&gt;transport&lt;/code&gt; info.</source>
          <target state="translated">&lt;code&gt;transport&lt;/code&gt; 정보 와 달리 &lt;code&gt;ref&lt;/code&gt; 가 동일한 항목이 여러 개있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f8021919fad99cd5846d281ed37e3c831b466fa" translate="yes" xml:space="preserve">
          <source>Note that there need to be exactly one distribution controller per connection. A process or port can only be distribution controller for one connection. The registration as distribution controller cannot be undone. It will stick until the distribution controller terminates. The distribution controller should not ignore exit signals. It is allowed to trap exits, but it should then voluntarily terminate when an exit signal is received.</source>
          <target state="translated">연결 당 정확히 하나의 분배 제어기가 있어야합니다. 프로세스 또는 포트는 하나의 연결에 대해서만 분배 제어기 일 수 있습니다. 배포 컨트롤러로 등록을 취소 할 수 없습니다. 분배 컨트롤러가 종료 될 때까지 고정됩니다. 분배 제어기는 종료 신호를 무시해서는 안됩니다. 엑시트를 트랩 할 수 있지만 엑시트 신호가 수신되면 자발적으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="35ca0442324d4811fd6417d30d9643d51d667192" translate="yes" xml:space="preserve">
          <source>Note that these functions is intended to be called by the instrumentation functions and &lt;strong&gt;only&lt;/strong&gt; if they are executed in the context of the agent process (e.g. it does not work if called from a spawned process).</source>
          <target state="translated">이 함수는 인스 트루먼 테이션 함수 가 에이전트 프로세스의 컨텍스트에서 실행 된 경우 &lt;strong&gt;에만&lt;/strong&gt; 호출하도록되어 있습니다 (예 : 스폰 된 프로세스에서 호출 된 경우 작동하지 않음).</target>
        </trans-unit>
        <trans-unit id="05534c73155b84674fad449b2de6066e6ecf290c" translate="yes" xml:space="preserve">
          <source>Note that this can cause the message queue to overflow causing for example the virtual machine to run out of memory and crash.</source>
          <target state="translated">이로 인해 메시지 큐가 오버플로되어 예를 들어 가상 머신의 메모리 부족 및 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c6d3e9f0a111d997b09cc65e98dfb115cd9cb64" translate="yes" xml:space="preserve">
          <source>Note that this check use application versions that are loaded, or will be loaded when used. You might have application versions that satisfies all dependencies installed in the system, but if those are not loaded this check will fail. The system will of course also fail when used like this. This may happen when you have multiple &lt;code&gt;branched versions&lt;/code&gt; of the same application installed in the system, but you do not use a &lt;code&gt;boot script&lt;/code&gt; identifing the correct application version.</source>
          <target state="translated">이 검사는로드되거나 사용시로드되는 응용 프로그램 버전을 사용합니다. 시스템에 설치된 모든 종속성을 만족시키는 응용 프로그램 버전이있을 수 있지만로드되지 않은 경우이 확인이 실패합니다. 물론 이와 같이 사용하면 시스템이 실패합니다. 시스템에 동일한 응용 프로그램의 여러 &lt;code&gt;branched versions&lt;/code&gt; 이 설치되어 있지만 올바른 응용 프로그램 버전을 식별 하는 &lt;code&gt;boot script&lt;/code&gt; 사용하지 않는 경우에 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99d2fbc3cc50eaf8d82652d3e7dfaf6a59e6d53e" translate="yes" xml:space="preserve">
          <source>Note that this does not effect the messages that are sent autonomously by the stack. They use the protocol_version of the connection info.</source>
          <target state="translated">이것은 스택에 의해 자발적으로 전송 된 메시지에는 영향을 미치지 않습니다. 연결 정보의 protocol_version을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="caecb85cc20edb5c5424262ff84251833ebf6fc6" translate="yes" xml:space="preserve">
          <source>Note that this function is executed in the context of the master-agent process.</source>
          <target state="translated">이 기능은 master-agent 프로세스의 컨텍스트에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8fa22c35292c8c077560ab97a691881383aaa404" translate="yes" xml:space="preserve">
          <source>Note that this function will only be called if the user has set the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option to &lt;code&gt;true&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt; it is in fact a message resend. If not &lt;strong&gt;both&lt;/strong&gt; of these condition's are meet, &lt;code&gt;send_message&lt;/code&gt; will be called.</source>
          <target state="translated">사용자가 설정 한 경우이 함수가 불려가는 것은 &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; 의 에 설정 옵션 &lt;code&gt;true&lt;/code&gt; &lt;strong&gt;하고&lt;/strong&gt; 그것을 실제로 메시지 재전송입니다. 이 &lt;strong&gt;두&lt;/strong&gt; 조건이 모두 충족 되지 않으면 &lt;code&gt;send_message&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="732f01521ba5984e435cb22a9ac9e6a45f29f1a3" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the actual sending of pending transactions. This is either implicit (e.g. when receiving a re-sent transaction request for a request which is being processed) or controlled by the pending_timer, see above.</source>
          <target state="translated">이는 보류중인 트랜잭션의 실제 전송에는 영향을 미치지 않습니다. 이는 암시 적이거나 (예 : 처리중인 요청에 대한 재전송 트랜잭션 요청을 수신 할 때) pending_timer에 의해 제어됩니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="5991c7ab4d7c54b2c691ce4af01a35ebe0bdc5ec" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</source>
          <target state="translated">이는 구성 파일에 의해 정의 된 응용 프로그램 구성에 영향을 미치지 않으므로 노드를 다시 시작하면 구성이 해당 파일에있는 구성으로 되돌려집니다.</target>
        </trans-unit>
        <trans-unit id="50e67d142a316144e7ab07bc77f835927707bee6" translate="yes" xml:space="preserve">
          <source>Note that this identifier occasionally has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but in order to keep backwards compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">이 식별자는 때때로 &quot;이름&quot;이라고 불립니다. 가능한 한 &quot;식별자&quot;또는 &quot;id&quot;라는 용어가 사용되었지만 이전 버전과의 호환성을 유지하기 위해 오류 메시지에서 &quot;name&quot;이라는 일부 항목이 여전히 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ccf4b0fd3e0f0b163b5d9f781f3e69fb98fcf9b" translate="yes" xml:space="preserve">
          <source>Note that this is also the maximum amount of data that can be received from a single recv call. If you are using higher than normal MTU consider setting buffer higher.</source>
          <target state="translated">이는 단일 recv 호출에서 수신 할 수있는 최대 데이터 양이기도합니다. 일반 MTU보다 높은 값을 사용하는 경우 버퍼를 높게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8d6bbf6c0b04bfae62fc7c2e9271769120f7387b" translate="yes" xml:space="preserve">
          <source>Note that this is just a utility function, which does all the work of splitting the given string into words separated by whitespace and setting up a &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; with the proper indentation, containing a list of &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; elements.</source>
          <target state="translated">이것은 유틸리티 함수일뿐입니다. 주어진 문자열을 공백으로 구분 된 단어로 나누고 &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 요소 목록을 포함하는 적절한 들여 쓰기 로 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 를 설정하는 모든 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="3e4569ecffb57e143102668b7a6dd11b0264d4d3" translate="yes" xml:space="preserve">
          <source>Note that this list might be reduced if the underlying libcrypto does not support all of them.</source>
          <target state="translated">기본 libcrypto가 모든 항목을 지원하지 않는 경우이 목록이 줄어들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="392cc3c5602edaac365f69343bd3fabeabbfabb8" translate="yes" xml:space="preserve">
          <source>Note that this might be an incomplete list of files that need to be updated.</source>
          <target state="translated">업데이트해야 할 불완전한 파일 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ccf435027f13cc4c4ea5f6a451c968311242f89" translate="yes" xml:space="preserve">
          <source>Note that this only works as specified if the &lt;code&gt;sent_pending_limit&lt;/code&gt; config option has been set to an integer value.</source>
          <target state="translated">&lt;code&gt;sent_pending_limit&lt;/code&gt; 구성 옵션이 정수 값으로 설정된 경우에만 지정된대로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="14cde1c7fe3b7ab665fc387b99054848ce3fead5" translate="yes" xml:space="preserve">
          <source>Note that this whole module is experimental, and the representations used as well as the functionality is likely to change in the future.</source>
          <target state="translated">이 전체 모듈은 실험적이며 기능뿐만 아니라 사용 된 표현도 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d0f64dc22706965239d477a1963f767ce3f8f64" translate="yes" xml:space="preserve">
          <source>Note that this will always be the default user that is called.</source>
          <target state="translated">항상 기본 사용자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2e15a72745c4b2259c54938521a47a61a3e00dfd" translate="yes" xml:space="preserve">
          <source>Note that to enable FIPS mode succesfully, OTP must be built with the configure option &lt;code&gt;--enable-fips&lt;/code&gt;, and the underlying libcrypto must also support FIPS.</source>
          <target state="translated">FIPS 모드를 성공적으로 활성화하려면 구성 옵션 &lt;code&gt;--enable-fips&lt;/code&gt; 를 사용하여 OTP를 빌드해야하며 기본 libcrypto도 FIPS를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ec3dbe2e4a9ded21164737c3e53b41c247a0435" translate="yes" xml:space="preserve">
          <source>Note that transaction id's are (currently) maintained on a per user basis so there is no way to be sure that the value returned will actually be used for a transaction sent on this connection (in case a user has several connections, which is not at all unlikely).</source>
          <target state="translated">트랜잭션 ID는 (현재) 사용자 단위로 유지되므로 반환 된 값이이 연결을 통해 전송 된 트랜잭션에 실제로 사용되는지 확인할 방법이 없습니다 (사용자가 여러 연결을 가지고있는 경우). 모두 가능하지 않음).</target>
        </trans-unit>
        <trans-unit id="bfaf8929b2a813d73b67b54b1a840c42370aef06" translate="yes" xml:space="preserve">
          <source>Note that up until here it is not allowed to fragments the message. The entire atom cache and control message has to be part of the starting fragment. After the control message the payload of the message is sent using 128 bytes:</source>
          <target state="translated">여기까지는 메시지 조각화가 허용되지 않습니다. 전체 아톰 캐시 및 제어 메시지는 시작 조각의 일부 여야합니다. 제어 메시지 다음에 메시지의 페이로드가 128 바이트를 사용하여 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="74c2bdc163cd56fda0bc897570388a7d7819f96a" translate="yes" xml:space="preserve">
          <source>Note that user defined custom &lt;code&gt;verify_fun&lt;/code&gt; may alter original path validation error (e.g &lt;code&gt;selfsigned_peer&lt;/code&gt;). Use with caution.</source>
          <target state="translated">사용자 정의 사용자 정의 &lt;code&gt;verify_fun&lt;/code&gt; 은 원래 경로 유효성 검사 오류 (예 : &lt;code&gt;selfsigned_peer&lt;/code&gt; )를 변경할 수 있습니다 . 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6cfc282f9f5a7f60dc04c61e35f9a1919be96f74" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에서이 작업을 사용하는 것은 이 서버에서 이전에 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 을 호출하지 않았기 때문에 요술의 경계에서 이상 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8d60aba8258543e37473d13c94a9f81daa1cab90" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에서이 작업을 사용하면 이 서버 의 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출이 없었기 때문에 마법의 경계에서 이상하게 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="9f61aaf53fdf26271e4990884786f10164139b23" translate="yes" xml:space="preserve">
          <source>Note that when compiling a module &lt;strong&gt;all existing coverage data is removed&lt;/strong&gt;, including imported data. If a module is already compiled when data is imported, the imported data is &lt;strong&gt;added&lt;/strong&gt; to the existing coverage data.</source>
          <target state="translated">모듈을 컴파일 할 때 가져온 데이터를 포함하여 &lt;strong&gt;기존의 모든 커버리지 데이터가 제거됩니다&lt;/strong&gt; . 데이터를 가져올 때 모듈이 이미 컴파일 된 경우 가져온 데이터는 기존 적용 범위 데이터에 &lt;strong&gt;추가&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="df20ba18430e7a9839bde3720f0b99fc09d3133d" translate="yes" xml:space="preserve">
          <source>Note that when the value of the data to input is a string, it has to be quoted with &lt;code&gt;'&lt;/code&gt;. Example:</source>
          <target state="translated">입력 할 데이터 값이 문자열 인 경우 &lt;code&gt;'&lt;/code&gt; 로 인용해야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="686eb963081bb17804ec4126760703b99e0e06a4" translate="yes" xml:space="preserve">
          <source>Note that whenever a document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, it will be placed on a separate line. Thus, neither a layout such as</source>
          <target state="translated">에서 문서마다 참고 &lt;code&gt;Docs&lt;/code&gt; 줄 바꿈을 포함, 그것은 별도의 줄에 배치됩니다. 따라서 다음과 같은 레이아웃은</target>
        </trans-unit>
        <trans-unit id="f445dc35aa8bfa91f3e834a45f7fca092ded7275" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;TCP_NOPUSH&lt;/code&gt; socket option is available on OSX, its semantics is very different (e.g., unsetting it does not cause immediate send of accumulated data). Hence, &lt;code&gt;nopush&lt;/code&gt; option is intentionally ignored on OSX.</source>
          <target state="translated">반면 있습니다 &lt;code&gt;TCP_NOPUSH&lt;/code&gt; 소켓 옵션은 OSX 볼 수 있습니다, 그 의미는 (예를 들어, 설정 해제는 축적 된 데이터를 즉시 전송 발생하지 않습니다) 매우 다르다. 따라서 &lt;code&gt;nopush&lt;/code&gt; 옵션은 OSX에서 의도적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="51ce8067681e0ca58dded25b6ecd3a75afe5a9e0" translate="yes" xml:space="preserve">
          <source>Note that work executing on dirty I/O schedulers are expected to mainly wait for I/O. That is, when you get high scheduler utilization on dirty I/O schedulers, CPU utilization is &lt;strong&gt;not&lt;/strong&gt; expected to be high due to this work.</source>
          <target state="translated">더티 I / O 스케줄러에서 실행되는 작업은 주로 I / O를 기다릴 것으로 예상됩니다. 즉, 더티 I / O 스케줄러에서 스케줄러 활용도가 높으면이 작업으로 인해 CPU 사용량이 &lt;strong&gt;높지 않을&lt;/strong&gt; 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="523d72a03618b74e2aff0e449d66e6cc2c0c698a" translate="yes" xml:space="preserve">
          <source>Note that you cannot define arbitrary variables in a cross compilation configuration file. Only the ones listed below will be guaranteed to be visible throughout the whole execution of all &lt;code&gt;configure&lt;/code&gt; scripts. Other variables needs to be defined as arguments to &lt;code&gt;configure&lt;/code&gt; or exported in the environment.</source>
          <target state="translated">크로스 컴파일 구성 파일에는 임의의 변수를 정의 할 수 없습니다. 모든 &lt;code&gt;configure&lt;/code&gt; 스크립트를 전체적으로 실행할 때 아래에 나열된 것만 표시됩니다 . 환경에서 &lt;code&gt;configure&lt;/code&gt; 하거나 내보내 려면 다른 변수를 인수로 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7bfec520257edb9cec974688079c41974b401d13" translate="yes" xml:space="preserve">
          <source>Note that you need to have run &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; in the particular shell before building anything on Windows. After doing a make opt you can test your result by running &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt;. If you want to copy the result to a release directory (say &lt;code&gt;/tmp/erl_release&lt;/code&gt;), you do this (still in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt;)</source>
          <target state="translated">Windows에서 무언가를 빌드하기 전에 특정 쉘에서 &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; 를 실행해야합니다 . make opt를 수행 한 후 &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt; 을 실행하여 결과를 테스트 할 수 있습니다 . 결과를 릴리스 디렉토리 (예 : &lt;code&gt;/tmp/erl_release&lt;/code&gt; ) 에 복사하려면 이 작업을 수행하십시오 (여전히 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a5f7a43dea5055412cd813699aecbdd4537ff72" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 21 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">이 작업을 수행 할 때는 경로에 새로운 Erlang이 있어야하며, 이전 단계에서 작성한 일반 21이 바람직합니다. 특정 라이브러리를 다시 빌드하기 전에 &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; 을 &lt;code&gt;PATH&lt;/code&gt; 에 추가 할 수도 있습니다 . 그러면 OTP Erlang 코드를 컴파일하기에 충분한 Erlang 시스템이 제공됩니다. 경로를 올바르게 설정하는 것은 약간 까다 롭습니다. 당신은 여전히이 필요 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; &lt;strong&gt;전에&lt;/strong&gt; 경로의 실제 에뮬레이터. 부트 스트랩 컴파일러를 사용하기위한 일반적인 경로 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0eb0b5bede55df32486ffb5e68143aaf83b271f3" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 23 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">이 작업을 수행 할 때 경로에 새로운 Erlang이 있어야합니다. 이전 단계에서 빌드 한 일반 23을 사용하는 것이 좋습니다. 특정 라이브러리를 다시 빌드하기 전에 &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; 을 &lt;code&gt;PATH&lt;/code&gt; 에 추가 할 수도 있습니다 . 이는 OTP erlang 코드를 컴파일하기에 충분한 Erlang 시스템을 제공합니다. 경로를 올바르게 설정하는 것은 약간 까다 롭습니다. 당신은 여전히이 필요 &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt; &lt;strong&gt;전에&lt;/strong&gt; 경로의 실제 에뮬레이터. 부트 스트랩 컴파일러를 사용하기위한 일반적인 경로 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f59844103d6ba8ed4dae0a9ab2a29d364c2a6a4" translate="yes" xml:space="preserve">
          <source>Note that, as a way to indicate the newest file, &lt;code&gt;run_erl&lt;/code&gt; will delete the oldest log file to maintain a &quot;hole&quot; in the file sequences. For example, if log files #1, #2, #4 and #5 exists, that means #2 is the latest and #4 is the oldest. You will therefore at most get one less log file than the value set by &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt;.</source>
          <target state="translated">최신 파일을 나타내는 방법으로 &lt;code&gt;run_erl&lt;/code&gt; 은 가장 오래된 로그 파일을 삭제하여 파일 시퀀스에서 &quot;구멍&quot;을 유지합니다. 예를 들어, 로그 파일 # 1, # 2, # 4 및 # 5가 존재하면 # 2가 최신이고 # 4가 가장 오래된 것을 의미합니다. 따라서 최대 &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt; 에 의해 설정된 값보다 하나 적은 로그 파일을 얻게 됩니다.</target>
        </trans-unit>
        <trans-unit id="cc609e818cd60886eb0217d87244da60ff760651" translate="yes" xml:space="preserve">
          <source>Note the difference between &lt;code&gt;move c xy&lt;/code&gt; and &lt;code&gt;move c d&lt;/code&gt;. Note that &lt;code&gt;move c xy&lt;/code&gt; is equivalent to the following two definitions:</source>
          <target state="translated">&lt;code&gt;move c xy&lt;/code&gt; 와 &lt;code&gt;move c d&lt;/code&gt; 의 차이점에 유의하십시오 . 그 주 &lt;code&gt;move c xy&lt;/code&gt; 다음과 같은 두 가지 정의에 해당합니다 :</target>
        </trans-unit>
        <trans-unit id="d6c73dcf363499057947cccf47d8448b7dbaf012" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that can not return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 를 사용 하여 결과를 반환 할 수 있다는 점에 유의하십시오 . 예를 들어 &lt;code&gt;State&lt;/code&gt; 또는 &lt;code&gt;Data&lt;/code&gt; 가 더 이상 범위에 없기 때문에 &lt;code&gt;{next_state,State,Data}&lt;/code&gt; 를 반환 할 수없는 복잡한 코드 내에서 &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; 를 사용하여 구제하려면</target>
        </trans-unit>
        <trans-unit id="7f3c2db9a65e908102a67487ed12c89a758f057f" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that cannot return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 를 사용 하여 결과를 반환 할 수 있다는 사실에 유의하십시오 . 이는 유용 할 수 있습니다. 예를 들어 &lt;code&gt;State&lt;/code&gt; 또는 &lt;code&gt;Data&lt;/code&gt; 가 더 이상 범위에 없기 때문에 &lt;code&gt;{next_state,State,Data}&lt;/code&gt; 를 반환 할 수없는 복잡한 코드 내에서 &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; 를 사용하여 구제 조치를 취 합니다.</target>
        </trans-unit>
        <trans-unit id="4317e03fcba152213e0ea0f2f44b86239f1e5599" translate="yes" xml:space="preserve">
          <source>Note this option is not needed in normal TLS usage and should not be used to implement new clients. But legacy clients that retries connections in the following manner</source>
          <target state="translated">이 옵션은 일반적인 TLS 사용에는 필요하지 않으며 새 클라이언트를 구현하는 데 사용해서는 안됩니다. 그러나 다음과 같은 방식으로 연결을 재 시도하는 레거시 클라이언트</target>
        </trans-unit>
        <trans-unit id="3157e5999d26e98c016dbd63bda9ac9a0dfb9593" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Clause&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Clause&lt;/code&gt; 에는 &lt;code&gt;clause&lt;/code&gt; 유형이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="308285ef58a3193174b243e20988fef230082fab" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;arity_qualifier&lt;/code&gt; nodes are recognized. This is to follow The Erlang Parser when it comes to wild attributes: both {F, A} and F/A are recognized, which makes it possible to turn wild attributes into recognized attributes without at the same time making it impossible to compile files using the new syntax with the old version of the Erlang Compiler.</source>
          <target state="translated">참고 : &lt;code&gt;arity_qualifier&lt;/code&gt; 노드가 인식됩니다. 와일드 속성에 관해서는 Erlang Parser를 따르는 것입니다 : {F, A} 및 F / A가 모두 인식되므로 와일드 속성을 인식 된 속성으로 바꾸는 동시에 동시에 파일을 컴파일 할 수 없습니다. 이전 버전의 Erlang Compiler의 새로운 구문.</target>
        </trans-unit>
        <trans-unit id="d81e2383b82cc4e91e2f04de6cf454f9653c7f46" translate="yes" xml:space="preserve">
          <source>Note: All instances of free variables will be given distinct labels.</source>
          <target state="translated">참고 : 자유 변수의 모든 인스턴스에는 고유 한 레이블이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="8b61204a294edc11d57ba05c5e469df9123163d6" translate="yes" xml:space="preserve">
          <source>Note: Because &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Node&lt;/code&gt; 는 구문 트리 이기 때문에 하위 트리에 해당하는 실제 런타임 값은 종종 부분적으로 또는 완전히 알려지지 않을 수 있습니다. 따라서 &lt;code&gt;Node&lt;/code&gt; 가 예를 들어 &quot; &lt;code&gt;[... | Ns]&lt;/code&gt; &quot;(여기서 &lt;code&gt;Ns&lt;/code&gt; 는 변수 임)를 나타내는 경우 함수는 &lt;code&gt;Ns&lt;/code&gt; 가 런타임에 목록에 바인딩 되는지 여부를 알 수 없기 때문에 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . 경우 &lt;code&gt;Node&lt;/code&gt; 대신 &quot;예를 나타낸다 &lt;code&gt;[1, 2, 3]&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;[A | []]&lt;/code&gt; &quot;다음 함수는 반환됩니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adf9d511dcfa9aaf58ab7283975eec8497bcb0e4" translate="yes" xml:space="preserve">
          <source>Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function.</source>
          <target state="translated">참고 : 이진 구문 패턴은이 함수에 의해 이진 구문 표현식과 구조적으로 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0562ade2cea8acce9b76b0b4ab90737668e5d26" translate="yes" xml:space="preserve">
          <source>Note: Currently, the set of syntax trees which have a concrete representation is larger than the set of trees which can be built using the function &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt;. An abstract character will be concretised as an integer, while &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; does not at present yield an abstract character for any input. (Use the &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; function to explicitly create an abstract character.)</source>
          <target state="translated">참고 : 현재 구체적으로 표현 된 구문 트리 세트는 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 빌드 할 수있는 트리 세트보다 큽니다 . 추상 문자는 정수로 이해되는 반면 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 은 현재 입력에 대한 추상 문자를 생성하지 않습니다. (사용 &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; 명시 적 추상 문자를 작성하는 기능입니다.)</target>
        </trans-unit>
        <trans-unit id="165ae8a32f7b6f64943274e92b98458ca7d19edd" translate="yes" xml:space="preserve">
          <source>Note: If some document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, the vertical layout will always be selected.</source>
          <target state="translated">참고 : 일부 문서의 경우 &lt;code&gt;Docs&lt;/code&gt; 줄 바꿈을 포함, 수직 레이아웃이 항상 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="3840eb20d7586de2203199630f1c366ff144d8c6" translate="yes" xml:space="preserve">
          <source>Note: If you get a &quot;syntax error&quot; message when trying to merge files (and you know those files to be correct), then try the &lt;code&gt;preprocess&lt;/code&gt; option. It typically means that your code contains too strange macros to be handled without actually performing the preprocessor expansions.</source>
          <target state="translated">참고 : 파일을 병합 할 때 &quot;구문 오류&quot;메시지가 표시되고 해당 파일이 올바른지 알고있는 경우 &lt;code&gt;preprocess&lt;/code&gt; 옵션 을 사용해보십시오 . 일반적으로 코드에 프리 프로세서 확장을 실제로 수행하지 않고 처리하기에는 너무 이상한 매크로가 포함되어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="884eb65502e4a057112e64304a3aee60ecdc8306" translate="yes" xml:space="preserve">
          <source>Note: Since &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Node&lt;/code&gt; 는 구문 트리이므로 하위 트리에 해당하는 실제 런타임 값을 부분적으로 또는 완전히 알 수없는 경우가 있습니다. 따라서, 경우에 &lt;code&gt;Node&lt;/code&gt; 나타내는 예 : &quot; &lt;code&gt;[... | Ns]&lt;/code&gt; &quot;(여기서 &lt;code&gt;Ns&lt;/code&gt; 를가 변수입니다), 다음 함수가 반환 &lt;code&gt;false&lt;/code&gt; 여부가 알려져 있지 않기 때문에, &lt;code&gt;Ns&lt;/code&gt; 를이 실행시 목록에 바인딩됩니다. 경우 &lt;code&gt;Node&lt;/code&gt; 대신 &quot;예를 나타낸다 &lt;code&gt;[1, 2, 3]&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;[A | []]&lt;/code&gt; &quot;다음 함수는 반환됩니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef01dc14c91674b058f1673b8d98cbd24605f910" translate="yes" xml:space="preserve">
          <source>Note: The Erlang language has distinct 1-tuples, i.e., &lt;code&gt;{X}&lt;/code&gt; is always distinct from &lt;code&gt;X&lt;/code&gt; itself.</source>
          <target state="translated">참고 : Erlang 언어에는 고유 한 1- 튜플이 있습니다. 즉 &lt;code&gt;{X}&lt;/code&gt; 는 항상 &lt;code&gt;X&lt;/code&gt; 자체와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="cbd9bd8a8c68fbfcb71e2f8c20f0bf3e55f2ea3f" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we can not be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">참고 : 동적 코드 교체 시맨틱을 깨뜨리지 않으려면 &quot;정적&quot;모듈과 &quot;안전한&quot;모듈을 구분해야합니다. &quot;정적&quot;소스 모듈은 대상 모듈이 아닌 한 교체되지 않습니다. 이제 각 상태에 대한 코드를 별도의 모듈에 배치하여 구현 된 상태 머신을 상상하고 모든 소스 모듈을 정적으로 표시하여 단일 대상 모듈로 병합한다고 가정합니다. 모듈 중 하나에서 다른 모듈로 (즉, 상태 전이) 호출이 이루어지는 원래 코드의 각 지점에서 코드 교체가 감지 될 것으로 예상됩니다. 그런 다음 병합 된 코드에서 &lt;strong&gt;대상&lt;/strong&gt; 이 이러한 지점에서 확인하지 않으면&lt;strong&gt;&lt;/strong&gt;모듈 (병합 결과)이 교체되었으므로 일반적으로 병합 된 상태 머신의 코드 교체를 수행 할 수 있는지 확신 할 수 없습니다. 코드 변경을 감지하지 않고 영원히 실행될 수 있습니다. 따라서 이러한 모든 호출은 원격 호출 (코드 변경 감지)으로 유지되어야하지만 대상 모듈을 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8daa2d5e45d509f284f5f3a9bb9a8c05ad568947" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we cannot be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">참고 : 동적 코드 대체의 의미를 깨뜨리지 않으려면 &quot;정적&quot;모듈과 &quot;안전&quot;모듈을 구분해야합니다. &quot;정적&quot;소스 모듈은 대상 모듈도 그렇지 않으면 교체되지 않습니다. 이제 각 상태에 대한 코드를 별도의 모듈에 배치하여 구현 된 상태 머신을 상상하고이를 단일 대상 모듈로 병합하여 모든 소스 모듈을 정적으로 표시한다고 가정합니다. 모듈 중 하나에서 다른 모듈로 호출 (즉, 상태 전환)이 이루어지는 원래 코드의 각 지점에서 코드 교체가 감지 될 것으로 예상됩니다. 그런 다음 병합 된 코드에서 &lt;strong&gt;대상이&lt;/strong&gt;모듈 (병합의 결과)이 교체되었으므로 일반적으로 병합 된 상태 머신의 코드 교체를 수행 할 수 있을지 확신 할 수 없습니다. 코드 변경을 감지하지 않고 영원히 실행할 수 있습니다. 따라서 이러한 모든 호출은 원격 호출 (코드 변경 감지)로 유지되어야하지만 대상 모듈을 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9850cccf6fb6ccf68d12503d679738d939b63a6a" translate="yes" xml:space="preserve">
          <source>Note: The name of the primary constructor function for a node type is always the name of the type itself, prefixed by &quot;&lt;code&gt;c_&lt;/code&gt;&quot;; recognizer predicates are correspondingly prefixed by &quot;&lt;code&gt;is_c_&lt;/code&gt;&quot;. Furthermore, to simplify preservation of annotations (cf. &lt;code&gt;get_ann/1&lt;/code&gt;), there are analogous constructor functions prefixed by &quot;&lt;code&gt;ann_c_&lt;/code&gt;&quot; and &quot;&lt;code&gt;update_c_&lt;/code&gt;&quot;, for setting the annotation list of the new node to either a specific value or to the annotations of an existing node, respectively.</source>
          <target state="translated">참고 : 노드 유형에 대한 기본 생성자 함수의 이름은 항상 &quot; &lt;code&gt;c_&lt;/code&gt; &quot; 접두사가 붙은 유형 자체의 이름입니다 . 인식기 술어는 &quot; &lt;code&gt;is_c_&lt;/code&gt; &quot;로 시작됩니다 . 또한 주석 보존을 단순화하기 위해 ( &lt;code&gt;get_ann/1&lt;/code&gt; 참조 ), 새 노드의 주석 목록을 특정 값 또는 주석에 설정하기위한 &quot; &lt;code&gt;ann_c_&lt;/code&gt; &quot;및 &quot; &lt;code&gt;update_c_&lt;/code&gt; &quot; 접두사가 붙은 유사한 생성자 함수 가 있습니다. 각각 기존 노드.</target>
        </trans-unit>
        <trans-unit id="2872d7972612ca53705b122b06de88412b65023e" translate="yes" xml:space="preserve">
          <source>Note: The preprocessor macro definition directive &quot;&lt;code&gt;-define(Name, Body).&lt;/code&gt;&quot; has relatively few requirements on the syntactical form of &lt;code&gt;Body&lt;/code&gt; (viewed as a sequence of tokens). The &lt;code&gt;text&lt;/code&gt; node type can be used for a &lt;code&gt;Body&lt;/code&gt; that is not a normal Erlang construct.</source>
          <target state="translated">참고 : 전 처리기 매크로 정의 지시문 &quot; &lt;code&gt;-define(Name, Body).&lt;/code&gt; &quot;는 &lt;code&gt;Body&lt;/code&gt; 의 구문 형식에 대한 요구 사항이 비교적 적습니다 (토큰 순서로 표시됨). &lt;code&gt;text&lt;/code&gt; 노드 유형은 사용할 수 있습니다 &lt;code&gt;Body&lt;/code&gt; 정상 얼랑 구조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6a3d6a31994b23aff112f18cb8ed90847216cb94" translate="yes" xml:space="preserve">
          <source>Note: The primary constructor functions for a node type should always have the same name as the node type itself.</source>
          <target state="translated">참고 : 노드 유형의 기본 생성자 함수는 항상 노드 유형 자체와 이름이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="8ca2fedd6ed2548e302789ae2e0c23407f15fd76" translate="yes" xml:space="preserve">
          <source>Note: This is a constant time operation.</source>
          <target state="translated">참고 : 이것은 일정한 시간 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a75af5c6559b7697b82cd55b9c2024ae62ccc77d" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이는 &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="bb58e56411d72b2c5de64c07dff668396f493062" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="961e68d5ec80ea10407155400f5248fb08c77ba7" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;length(values_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(values_es(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f8cc9a8168087cf73aa91a1ca9a6fb283bef773c" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d09be805d2731441552cb1761a72f29b924b8a7a" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="698437d5693811f218a0125173a54360a31fae26" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="94f64f74f43a14a0fd5a71cca82d5190660bfa22" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1c349a183f568e3a4f03fe936ebb15f7b0b8d9c0" translate="yes" xml:space="preserve">
          <source>Note: all literals (cf. &lt;code&gt;is_literal/1&lt;/code&gt;) are leaf nodes, even if they represent structured (constant) values such as &lt;code&gt;{foo, [bar, baz]}&lt;/code&gt;. Also note that variables are leaf nodes but not literals.</source>
          <target state="translated">참고 : 모든 리터럴 (cf. &lt;code&gt;is_literal/1&lt;/code&gt; )은 &lt;code&gt;{foo, [bar, baz]}&lt;/code&gt; 와 같은 구조화 된 (상수) 값을 나타내더라도 리프 노드 입니다. 또한 변수는 리프 노드이지만 리터럴은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f9ca5b0925ea2a2251f51d1eef2e90cac1124164" translate="yes" xml:space="preserve">
          <source>Note: catch-expressions can be rewritten as try-expressions, and will eventually be removed from Core Erlang.</source>
          <target state="translated">참고 : catch-expression은 try-expression으로 다시 작성할 수 있으며 결국 Core Erlang에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c2cbae916b385a433641891fb2f65cb175003a34" translate="yes" xml:space="preserve">
          <source>Note: changing this value (and passing the resulting context to a continuation function) does not affect the normal formatting, but may affect user-defined behaviour in hook functions.</source>
          <target state="translated">참고 :이 값을 변경하고 결과 컨텍스트를 연속 함수에 전달하면 일반적인 형식에는 영향을 미치지 않지만 후크 함수의 사용자 정의 동작에는 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e66a58313670e508e4d5829246111554fd79c2d" translate="yes" xml:space="preserve">
          <source>Note: each node in &lt;code&gt;Clauses&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Clauses&lt;/code&gt; 의 각 노드에는 &lt;code&gt;clause&lt;/code&gt; 유형이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0e024adb668e3f8ad63658f3c7b61203ba9e048" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;M:F(...)&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;M:F&lt;/code&gt;&quot;.</source>
          <target state="translated">참고 : &lt;code&gt;Node&lt;/code&gt; 가 &quot; &lt;code&gt;M:F(...)&lt;/code&gt; &quot;를 나타내는 경우 결과는 &quot; &lt;code&gt;M:F&lt;/code&gt; &quot;를 나타내는 하위 트리 입니다.</target>
        </trans-unit>
        <trans-unit id="e950ce0b15b865ad70b6df0b8b6e16fd534c8751" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;fun N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;fun M:N/A&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;M:N/A&lt;/code&gt;&quot;, respectively.</source>
          <target state="translated">참고 : &lt;code&gt;Node&lt;/code&gt; 가 &quot; &lt;code&gt;fun N/A&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;fun M:N/A&lt;/code&gt; &quot;를 나타내는 경우 결과는 각각 &quot; &lt;code&gt;N/A&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;M:N/A&lt;/code&gt; &quot;를 나타내는 하위 트리 입니다.</target>
        </trans-unit>
        <trans-unit id="a650514ba11566a0849a47048d45d0a0ca77843f" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;cons&lt;/code&gt;, the number of subtrees is exactly two. If &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;{atomic, Value}&lt;/code&gt;, the number of subtrees is zero.</source>
          <target state="translated">참고 : &lt;code&gt;data_type(Node)&lt;/code&gt; 가 &lt;code&gt;cons&lt;/code&gt; 이면 하위 트리의 수는 정확히 2 개입니다. 경우 &lt;code&gt;data_type(Node)&lt;/code&gt; 인 &lt;code&gt;{atomic, Value}&lt;/code&gt; , 서브 트리들의 수는 0이다.</target>
        </trans-unit>
        <trans-unit id="024d798779fd03b9f02b44baf68e6e4bf1a905f4" translate="yes" xml:space="preserve">
          <source>Note: in &lt;code&gt;list(Elements, none)&lt;/code&gt;, the &quot;nil&quot; list terminator is implicit and has no associated information (see &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;), while in the seemingly equivalent &lt;code&gt;list(Elements, Tail)&lt;/code&gt; when &lt;code&gt;Tail&lt;/code&gt; has type &lt;code&gt;nil&lt;/code&gt;, the list terminator subtree &lt;code&gt;Tail&lt;/code&gt; may have attached attributes such as position, comments, and annotations, which will be preserved in the result.</source>
          <target state="translated">참고 :에서 &lt;code&gt;list(Elements, none)&lt;/code&gt; 은 &quot;전무&quot;목록 종결 암시하고 아무 관련 정보가 없습니다 (참조 &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; ), 동안 겉으로는 동등한 &lt;code&gt;list(Elements, Tail)&lt;/code&gt; 때 &lt;code&gt;Tail&lt;/code&gt; 형이 &lt;code&gt;nil&lt;/code&gt; 목록 종결을, 하위 트리 &lt;code&gt;Tail&lt;/code&gt; 에는 위치, 주석 및 주석과 같은 속성이 첨부되어있을 수 있으며 결과에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c912d0741e6afe02446fe862b8225b8a23da14f4" translate="yes" xml:space="preserve">
          <source>Note: no checking is done whether the character sequence represents a proper variable name, i.e., whether or not its first character is an uppercase Erlang character, or whether it does not contain control characters, whitespace, etc.</source>
          <target state="translated">참고 : 문자 시퀀스가 ​​올바른 변수 이름을 나타내는 지 여부, 즉 첫 문자가 대문자 Erlang 문자인지 여부 또는 제어 문자, 공백 등을 포함하지 않는지 여부는 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e16037ad2fddc6752207e81b2d23a2a536d6ff8" translate="yes" xml:space="preserve">
          <source>Note: not all literals are leaf nodes, and vice versa. E.g., tuples with nonzero arity and nonempty lists may be literals, but are not leaf nodes. Variables, on the other hand, are leaf nodes but not literals.</source>
          <target state="translated">참고 : 모든 리터럴이 리프 노드는 아니며 그 반대도 마찬가지입니다. 예를 들어, 0이 아닌 arity 및 비어 있지 않은 목록을 가진 튜플은 리터럴 일 수 있지만 리프 노드는 아닙니다. 반면에 변수는 리프 노드이지만 리터럴은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3393ba242996126bd79b8530e4ba8690724e5617" translate="yes" xml:space="preserve">
          <source>Note: passing a string as argument to this function causes a corresponding atom to be created for the internal representation.</source>
          <target state="translated">참고 : 문자열을이 함수에 인수로 전달하면 내부 표현에 해당하는 원자가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e19a5f5e7535dfc22dce9d8f5ad97ff942d5f69e" translate="yes" xml:space="preserve">
          <source>Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the character &quot;&lt;code&gt;a&lt;/code&gt;&quot; can be written both as &quot;&lt;code&gt;$a&lt;/code&gt;&quot; and &quot;&lt;code&gt;$\141&lt;/code&gt;&quot;, and a Tab character can be written as &quot;&lt;code&gt;$\11&lt;/code&gt;&quot;, &quot;&lt;code&gt;$\011&lt;/code&gt;&quot; or &quot;&lt;code&gt;$\t&lt;/code&gt;&quot;.</source>
          <target state="translated">참고 : 특정 문자 값에 해당하는 리터럴은 고유하게 정의되지 않습니다. 예를 들어, 문자 &quot; &lt;code&gt;a&lt;/code&gt; &quot;는 &quot; &lt;code&gt;$a&lt;/code&gt; &quot;및 &quot; &lt;code&gt;$\141&lt;/code&gt; &quot;로 작성 될 수 있고 탭 문자는 &quot; &lt;code&gt;$\11&lt;/code&gt; &quot;, &quot; &lt;code&gt;$\011&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;$\t&lt;/code&gt; &quot; 로 작성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6afc7eae3d94cce8a805b8208b70b9cbd6d1fee0" translate="yes" xml:space="preserve">
          <source>Note: the resulting list can contain more than one tuple &lt;code&gt;{ShortName, Name}&lt;/code&gt; for the same &lt;code&gt;ShortName&lt;/code&gt;, possibly with different values for &lt;code&gt;Name&lt;/code&gt;, depending on the given list.</source>
          <target state="translated">참고 : 결과 목록에는 동일한 &lt;code&gt;ShortName&lt;/code&gt; 에 대해 둘 이상의 튜플 &lt;code&gt;{ShortName, Name}&lt;/code&gt; 포함될 수 있으며 주어진 목록에 따라 &lt;code&gt;Name&lt;/code&gt; 에 대해 다른 값이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e12fe9dbfa6c36c26ca8159eaa9cc67ee440fdd9" translate="yes" xml:space="preserve">
          <source>Note: the return value is &lt;code&gt;ok&lt;/code&gt; instead of &lt;code&gt;success&lt;/code&gt; unlike in other functions in this module. This is a fault that was introduced so long ago that any change would break a large number of existing software.</source>
          <target state="translated">참고 : 이 모듈의 다른 기능과 달리 반환 값은 &lt;code&gt;success&lt;/code&gt; 대신 &lt;code&gt;ok&lt;/code&gt; 습니다 . 이것은 오래 전에 도입 된 결함으로, 모든 변경으로 인해 기존 소프트웨어가 많이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b17be20c7e8e9810e58ea4c73486c73bfc67e7" translate="yes" xml:space="preserve">
          <source>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</source>
          <target state="translated">참고 : 서식 지정 기능에 의해 반환되는 텍스트는 각 줄 바꿈에서 자동으로 별도의 주석 줄로 분할됩니다. 추가 작업이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41856edf3415d1e90c206e87cfe950bc7df0afeb" translate="yes" xml:space="preserve">
          <source>Note: these macros introduce a run-time dependency on the EUnit library code, if compiled with testing enabled.</source>
          <target state="translated">참고 :이 매크로는 테스트를 사용하여 컴파일 된 경우 EUnit 라이브러리 코드에 런타임 종속성을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="bd0d2709ddf8a0638d0aff92ed2e6f15b3be5f7b" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(apply_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(apply_args(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ed1209b617e8d5cc3c5cfc6c1377fd43e5ce41cd" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(call_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(call_args(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a6e53230502f03bb4733db74bc560eb0d865cde8" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(clause_pats(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(clause_pats(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6dd282e7fb8db35030f176c6215fe03b5567042d" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(fun_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(fun_vars(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="bca941f0b40db2f3695ecc15ccff4c8a24695250" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(let_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(let_vars(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="58d78502c9d35d74b9f564b739de13ccb2a77f56" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(list_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(list_elements(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ebcca9b6d7e57fd06c7e8bed4e5fd7e93be99484" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(primop_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(primop_args(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="97dc47a811817d58377be776d262e5b3c05f6cf1" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ec59e73e9bc821017665db80dbf6cf98689682f7" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;length(tuple_es(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cea075dee9256e89d461acd90fcf6f51117060f2" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, Annotations ++ get_ann(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_ann(Node, Annotations ++ get_ann(Node))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4666d61b1ebe44a455ff212df8dfe43d5e4150ff" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cdbc84877e38d50c218ad5207d2faecbe10b2060" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a5386e79b58eda950a5274a7a0af8b6cfc746999" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="27b141a49bc96901cfd1d105a64d4c5f5a09eca3" translate="yes" xml:space="preserve">
          <source>Note: this is retained only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">참고 : 기존 파서 및 도구와의 하위 호환성을 위해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9a585e3e15766522c8abd82fcb5ff8e1c6cca19e" translate="yes" xml:space="preserve">
          <source>Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order to form an Erlang module definition.</source>
          <target state="translated">참고 : 이것은 일반적으로 Erlang 모듈 정의를 형성하기 위해 소스 코드 양식을 단일 구문 트리로 그룹화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7a43199c7c25f11800016e7472f3564571a0c7b8" translate="yes" xml:space="preserve">
          <source>Note: this is supported only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">참고 : 기존 파서 및 도구와의 호환성을 위해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c32e67b1c4c65b813f5c5d3ba41235581ee4036f" translate="yes" xml:space="preserve">
          <source>Notes About MacOS X</source>
          <target state="translated">MacOS X에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4d325fef3978cce9c3fe25199318432f2a2956f8" translate="yes" xml:space="preserve">
          <source>Notes and Implementation Details</source>
          <target state="translated">참고 및 구현 세부 정보</target>
        </trans-unit>
        <trans-unit id="9b98b21a7184296ef346762bd6728f411d329337" translate="yes" xml:space="preserve">
          <source>Notes concerning the Log Files</source>
          <target state="translated">로그 파일에 관한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="36d78a208c85e4ee9fbb30023fe1b73f1f6b5ac7" translate="yes" xml:space="preserve">
          <source>Notes: Floating documents appear to work well, but are currently less general than you might wish, losing effect when embedded in certain contexts. It is possible to nest floating-operators (even with different priorities), but the effects may be difficult to predict. In any case, note that the way the algorithm reorders floating documents amounts to a &quot;bubblesort&quot;, so don't expect it to be able to sort large sequences of floating documents quickly.</source>
          <target state="translated">참고 : 플로팅 문서는 잘 작동하는 것처럼 보이지만 현재는 원하는 것보다 덜 일반적이므로 특정 컨텍스트에 포함되면 효과가 손실됩니다. 부동 연산자 (우선 순위가 다른 경우에도)를 중첩 할 수 있지만 효과를 예측하기 어려울 수 있습니다. 어쨌든 알고리즘이 플로팅 문서의 순서를 재정렬하는 방식은 &quot;버블 레트 (bubblesort)&quot;이므로 대량의 플로팅 문서 시퀀스를 빠르게 정렬 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="661b94995b5e8bdcfda9b5f651e69fddc51ef9bc" translate="yes" xml:space="preserve">
          <source>Notes: If a file contains too exotic definitions or uses of macros, it will not be possible to read it without preprocessing. Furthermore, Igor does not currently try to sort out multiple inclusions of the same file, or redefinitions of the same macro name. Therefore, when preprocessing is turned off, it may become necessary to edit the resulting source code, removing such re-inclusions and redefinitions.</source>
          <target state="translated">참고 : 파일에 너무 이색적인 정의 나 매크로 사용이 포함 된 경우 사전 처리없이 파일을 읽을 수 없습니다. 또한 Igor는 현재 동일한 파일을 여러 개 포함하거나 동일한 매크로 이름을 재정의하려고 시도하지 않습니다. 따라서 전처리를 끄면 결과 소스 코드를 편집하여 이러한 재 포함 및 재정의를 제거해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f88e626a7699794907797465138c59374fcbea" translate="yes" xml:space="preserve">
          <source>Notes: if &lt;code&gt;Arguments&lt;/code&gt; is the empty list, the result will thus represent &quot;&lt;code&gt;?Name()&lt;/code&gt;&quot;, including a pair of matching parentheses.</source>
          <target state="translated">참고 : &lt;code&gt;Arguments&lt;/code&gt; 가 빈 목록 인 경우 결과는 일치하는 괄호 쌍을 포함하여 &quot; &lt;code&gt;?Name()&lt;/code&gt; &quot; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="99a1f1cf872f6e0e707f9c22cb3a2c5254119532" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 큐에서 아무것도 제거되지 &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt; 로 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f4188a869e9e87b711a06e4a4b3f28fd00e2f8ef" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 큐에서 아무것도 제거되지 &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt; 로 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="65c645e6dc76f281bf44b4e98033d1a25ed3e13d" translate="yes" xml:space="preserve">
          <source>Notice also that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; is interpreted as &quot;&lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; which is a syntax error. The correct way is to write a space after '=': &quot;&lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;을 알 &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; ''로 해석 &lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 문법 에러이다.&quot; 올바른 방법은 '='뒤에 공백을 쓰는 것입니다 : &quot; &lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e7821e854de5de8a4aacee0ff97239e9645aa44" translate="yes" xml:space="preserve">
          <source>Notice also that byte-oriented data is simplest sent using the ISO Latin-1 encoding.</source>
          <target state="translated">바이트 지향 데이터는 ISO Latin-1 인코딩을 사용하여 가장 간단하게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8a4c53d6a09620002b97e1f8172f87b851fbd7a6" translate="yes" xml:space="preserve">
          <source>Notice also that the transient type is of little practical use, because when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">또한 감시 트리가 종료되면 이유가 &lt;code&gt;normal&lt;/code&gt; 아니라 &lt;code&gt;shutdown&lt;/code&gt; 로 설정되므로 과도 유형은 거의 실용적이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ed33ac880989d641a4eeb80431d2338e759148c9" translate="yes" xml:space="preserve">
          <source>Notice also that when testing the program from the shell, the input is spread over two lines as the line was too long.</source>
          <target state="translated">또한 쉘에서 프로그램을 테스트 할 때 라인이 너무 길어서 입력이 두 라인으로 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="831cedf2104bac2a5f0cad0d085a43c104fcbad7" translate="yes" xml:space="preserve">
          <source>Notice also that ~p is used instead of ~w in &lt;code&gt;io:format&lt;/code&gt;. To quote the manual: &quot;~p Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. It also tries to detect lists of printable characters and to output these as strings&quot;.</source>
          <target state="translated">또한 &lt;code&gt;io:format&lt;/code&gt; 에서 ~ w 대신 ~ p가 사용됩니다 . 매뉴얼을 인용하려면 : &quot;~ p ~ w와 같은 방식으로 표준 구문으로 데이터를 쓰지만 인쇄 된 표현이 한 줄보다 긴 용어를 여러 줄로 나누고 각 줄을 현명하게 들여 쓰기합니다. 또한 인쇄 가능한 목록을 감지하려고합니다. 문자와 문자열로 출력합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="c8bc316625e4c64bc96adbb50df0038f6cc5d2e3" translate="yes" xml:space="preserve">
          <source>Notice how the operator &quot;!&quot; is used to send messages. The syntax of &quot;!&quot; is:</source>
          <target state="translated">연산자 &quot;!&quot;에 주목하십시오. 메시지를 보내는 데 사용됩니다. &quot;!&quot;의 문법 입니다 :</target>
        </trans-unit>
        <trans-unit id="2981906ecbb99640904a52c6a3186e8def191ed9" translate="yes" xml:space="preserve">
          <source>Notice how to write the &lt;code&gt;server&lt;/code&gt; function so that it calls itself, through &lt;code&gt;server(User_List)&lt;/code&gt;, and thus creates a loop. The Erlang compiler is &quot;clever&quot; and optimizes the code so that this really is a sort of loop and not a proper function call. But this only works if there is no code after the call. Otherwise, the compiler expects the call to return and make a proper function call. This would result in the process getting bigger and bigger for every loop.</source>
          <target state="translated">&lt;code&gt;server(User_List)&lt;/code&gt; 통해 &lt;code&gt;server&lt;/code&gt; 함수를 호출 하여 루프 를 작성하도록 서버 함수 를 작성하는 방법에 주목하십시오 . Erlang 컴파일러는 &quot;영리한&quot;코드이며 코드를 최적화하여 이것이 실제로 함수 호출이 아닌 일종의 루프가되도록합니다. 그러나 이것은 호출 후 코드가없는 경우에만 작동합니다. 그렇지 않으면, 컴파일러는 호출이 리턴되어 적절한 함수 호출을 기대합니다. 결과적으로 모든 루프마다 프로세스가 점점 커집니다.</target>
        </trans-unit>
        <trans-unit id="5b3e78ade17b6e0804c28534fc7f4b91db6f6042" translate="yes" xml:space="preserve">
          <source>Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if &lt;code&gt;{capture, all_names}&lt;/code&gt; is specified as an option to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;. You can therefore create a name-to-value mapping from the result of &lt;code&gt;run/3&lt;/code&gt; like this:</source>
          <target state="translated">두 번째 예에서 중복 된 이름은 반환 된 목록에서 한 번만 발생하며 정규식에서 이름의 위치에 관계없이 목록이 알파벳 순서로 표시됩니다. &lt;code&gt;{capture, all_names}&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 옵션으로 지정된 경우 이름의 순서는 캡처 된 하위 표현식의 순서와 동일 합니다 . 따라서 &lt;code&gt;run/3&lt;/code&gt; 의 결과에서 다음 과 같이 이름-값 맵핑을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="686ddcda1c61a1ea244a057dd0d0172fe3f99230" translate="yes" xml:space="preserve">
          <source>Notice on line 16 that 5 inches is converted to centimeters and back again and reassuringly get back to the original value. That is, the argument to a function can be the result of another function. Consider how line 16 (above) works. The argument given to the function &lt;code&gt;{inch,5}&lt;/code&gt; is first matched against the first head clause of &lt;code&gt;convert_length&lt;/code&gt;, that is, &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt;. It can be seen that &lt;code&gt;{centimeter,X}&lt;/code&gt; does not match &lt;code&gt;{inch,5}&lt;/code&gt; (the head is the bit before the &quot;-&amp;gt;&quot;). This having failed, let us try the head of the next clause that is, &lt;code&gt;convert_length({inch,Y})&lt;/code&gt;. This matches, and &lt;code&gt;Y&lt;/code&gt; gets the value 5.</source>
          <target state="translated">16 행에서 5 인치가 센티미터로 변환되었다가 다시 되돌아오고 안심하고 원래 값으로 돌아갑니다. 즉, 함수에 대한 인수는 다른 함수의 결과 일 수 있습니다. 16 행 (위)의 작동 방식을 고려하십시오. &lt;code&gt;{inch,5}&lt;/code&gt; 함수에 제공된 인수 는 먼저 &lt;code&gt;convert_length&lt;/code&gt; 의 첫 번째 head 절 , 즉 &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt; 와 일치합니다 . &lt;code&gt;{centimeter,X}&lt;/code&gt; 가 &lt;code&gt;{inch,5}&lt;/code&gt; 와 일치하지 않는 것을 볼 수 있습니다 (머리는 &quot;-&amp;gt;&quot;앞의 비트입니다). 이것에 실패했습니다. 다음 절인 &lt;code&gt;convert_length({inch,Y})&lt;/code&gt; 의 헤드를 사용해 봅시다 . 이것은 일치하고 &lt;code&gt;Y&lt;/code&gt; 는 값 5를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="faf1518cd916f83fdab368cf16163b784374daaa" translate="yes" xml:space="preserve">
          <source>Notice that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; will be interpreted as &quot;&lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot;, which is a syntax error. The correct way to write the expression is: &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;알 &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; ''로 해석한다 &lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &quot;구문 오류이다. 표현식을 작성하는 올바른 방법은 &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e48d2b215215558347b575f3ecbab79091a73b6" translate="yes" xml:space="preserve">
          <source>Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example:</source>
          <target state="translated">다음 예와 같이 PCRE 일치 시작 최적화가 해제되어 있지 않으면 패턴 시작시 (* COMMIT)은 앵커와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7645c19f8cada682b7b2ac8e343c6026994bf018" translate="yes" xml:space="preserve">
          <source>Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).</source>
          <target state="translated">(* SKIP : NAME)은 (* MARK : NAME)에서 설정 한 이름 만 검색합니다. (* PRUNE : NAME) 또는 (* THEN : NAME)으로 설정된 이름은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ac772e9232c60fd05e436000b3d65e5ba73ff0bb" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt; file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">것을 알 수 &lt;code&gt; file:read_link/1&lt;/code&gt; 항상 링크가 가리키는 경우 잘못된 파일 이름에 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3adcc07be0a21a37482a3bd3976227349972956b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;-relaxed_command_check&lt;/code&gt; is specified when starting the daemon that is to accept killing when it has live nodes registered. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect. A daemon that is started without relaxed command checking must be killed using, for example, signals or some other OS-specific method if it has active clients registered.</source>
          <target state="translated">것을 알 수 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 이 이 등록 라이브 노드가있을 때 죽이는 동의하는 것입니다 데몬을 시작할 때 지정됩니다. &lt;code&gt;epmd&lt;/code&gt; 를 대화식으로 실행할 때는 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 가 적용되지 않습니다. 완화 된 명령 검사없이 시작된 데몬은 활성 클라이언트가 등록 된 경우 신호 또는 기타 OS 특정 방법 등을 사용하여 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="70bfe90d5c883bf60d9637a901f3b97c4d3f704b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">통지 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header &lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147f5f00692828642c9cf73812c37af283058699" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">통지 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8218b491a4b3c0c5eb8370427f8e63bc8b619227" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ActiveSuspendCount&lt;/code&gt; and &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; are not the total suspend count on &lt;code&gt;Suspendee&lt;/code&gt;, only the parts contributed by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">것을 알 수 &lt;code&gt;ActiveSuspendCount&lt;/code&gt; 및 &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; 가 총 아니다 의지 중단 &lt;code&gt;Suspendee&lt;/code&gt; 는 , 부분 만은 기부 &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd2f7d7216ad16040d03dfe0cd8ffeaa41f5fc9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ErlNifBinary&lt;/code&gt; is a semi-opaque type and you are only allowed to read fields &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">공지 사항이 &lt;code&gt;ErlNifBinary&lt;/code&gt; 는 반 불투명 한 유형이고 당신은 단지 필드 읽을 수 있습니다 &lt;code&gt;size&lt;/code&gt; 와 &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6fa80e962aa12707d897541b088fcd511a7fff9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Filename&lt;/code&gt; can be either a list or a binary.</source>
          <target state="translated">통지 &lt;code&gt;Filename&lt;/code&gt; 목록 또는 이진 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14731d9c3c6fd3730587d810464f8a2d56ecc47" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Tracee&lt;/code&gt; must refer to a process currently or previously existing on the same node as the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; resides on. The special &lt;code&gt;Tracee&lt;/code&gt; atom &lt;code&gt;all&lt;/code&gt; denotes all processes that currently are traced in the node.</source>
          <target state="translated">것을 알 수 &lt;code&gt;Tracee&lt;/code&gt; 은 현재 또는 이전의 호출자와 동일한 노드에 존재하는 프로세스를 참조해야합니다 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 상주에. 특수 &lt;code&gt;Tracee&lt;/code&gt; 의 원자는 &lt;code&gt;all&lt;/code&gt; 현재 노드에서 추적 된 모든 프로세스를 의미한다.</target>
        </trans-unit>
        <trans-unit id="e39772795b303f493c5e1f6ecf427eea0b844a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster according to the Unicode Standard.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;[$\r,$\n]&lt;/code&gt; 유니 코드 표준에 따라 하나 개의 그래 핀 클러스터입니다.</target>
        </trans-unit>
        <trans-unit id="6aa2d6619dffc8bd3c3adb06ec4c9073939311ad" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;[$\r,$\n]&lt;/code&gt; 하나 개의 자소 클러스터입니다.</target>
        </trans-unit>
        <trans-unit id="08897008ae2f97db9924c5cfdccc065044d13435" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;bind_address&lt;/code&gt; must be the IP address reported by function &lt;code&gt;info&lt;/code&gt; and cannot be the hostname that is allowed when putting in &lt;code&gt;bind_address&lt;/code&gt;.</source>
          <target state="translated">통지 &lt;code&gt;bind_address&lt;/code&gt; 가 IP 주소이어야 기능에 의해보고 된 &lt;code&gt;info&lt;/code&gt; 와 퍼팅 할 때 허용되는 호스트 이름이 될 수 없습니다 &lt;code&gt;bind_address&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c830556293b9a7bbf702aa85452de5ebbaf366" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;catch&lt;/code&gt; has low precedence and catch subexpressions often needs to be enclosed in a block expression or in parentheses:</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;catch&lt;/code&gt; 낮은 우선 순위와 종종 블록 식 또는 괄호로 묶어야 할 필요가 캐치 표현식을 가지고 :</target>
        </trans-unit>
        <trans-unit id="bb283657c8b33fada586a3cb80cefd9a6fce3dd1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;enif_open_resource_type&lt;/code&gt; is only allowed to be called in the two callbacks &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">것을 알 수 &lt;code&gt;enif_open_resource_type&lt;/code&gt; 은 단지 두 개의 콜백 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1773f52a457c6794f4a7d066fbfe3f05c2a765e3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;erlsrv&lt;/code&gt; is not a general service utility for Windows, but designed for embedded Erlang systems.</source>
          <target state="translated">것을 알 수 &lt;code&gt;erlsrv&lt;/code&gt; 는 Windows 용 일반 서비스 유틸리티가 아니라 임베디드 얼랑 시스템 용으로 설계.</target>
        </trans-unit>
        <trans-unit id="6e432f3e9c9e76ab03e11cf1eee130a983560aaa" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">것을 알 수 &lt;code&gt;file:read_link/1&lt;/code&gt; 항상 링크가 가리키는 경우 잘못된 파일 이름에 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b5eb19b7b6106c9b1640932097ed40e803eee2b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt; are obeyed by Logger itself before forwarding the log events to each handler, while &lt;code&gt;formatter&lt;/code&gt; and all handler specific options are left to the handler implementation.</source>
          <target state="translated">공지 사항 그 &lt;code&gt;level&lt;/code&gt; 과 &lt;code&gt;filters&lt;/code&gt; 동안, 각 처리기에 로그 이벤트를 전달하기 전에 로거 자체 순종하는 &lt;code&gt;formatter&lt;/code&gt; 모든 핸들러 특정 옵션이 핸들러 구현에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd581a406752603573ad8774cbe10adf7b5ab0d3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;n3&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">알 &lt;code&gt;n3&lt;/code&gt; 및 &lt;code&gt;creation&lt;/code&gt; 정밀도로 한정되므로, 단지 낮은 수치 18이 2 비트가 사용된다.</target>
        </trans-unit>
        <trans-unit id="5034ccb8d85a6d7fd7e77e33c704f31bb33968e9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">알 &lt;code&gt;number&lt;/code&gt; 및 &lt;code&gt;creation&lt;/code&gt; 정밀 이러한 번호 18, 2 비트가 사용되는 정도로 단지 낮은 제한된다.</target>
        </trans-unit>
        <trans-unit id="8f334a2a965ad63c5f73db11176f314492958179" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; is different from &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt;; the list of one element is not identified with the element itself.</source>
          <target state="translated">공지 것을 &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; 상이한 &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt; ; 하나의 요소 목록은 요소 자체로 식별되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6bd7c1e7434d1dad6aeb762e0751cad3313447c" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary for table type &lt;code&gt;ordered_set&lt;/code&gt; and for traversals done by a single ETS function call, like &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;safe_fixtable/2&lt;/code&gt; 테이블 유형에 대한 필요가 없습니다 &lt;code&gt;ordered_set&lt;/code&gt; 단일 ETS 함수 호출에 의해 수행 순회를 들어, 같은 &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3688c0644193c1e6416001dafdd6919064e11078" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are for buffered input/output and must &lt;strong&gt;not&lt;/strong&gt; be used for the communication with Erlang.</source>
          <target state="translated">공지 것으로 &lt;code&gt;stdin&lt;/code&gt; 와 &lt;code&gt;stdout&lt;/code&gt; 버퍼, 입력 / 출력하고 있어야 &lt;strong&gt;하지&lt;/strong&gt; 얼랑과 통신에 이용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="bc49c747fe59c837c18160b1da219cb9bb69f688" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; does not cause any condition to succeed. This leads to the run time error &lt;code&gt;if_clause&lt;/code&gt;, here nicely formatted by the shell. See &lt;code&gt;Guard Sequences&lt;/code&gt; for details of the many guard tests available.</source>
          <target state="translated">것을 알 수 &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; 어떤 조건이 성공을 발생하지 않습니다. 이로 인해 런타임 오류 &lt;code&gt;if_clause&lt;/code&gt; 가 발생 하는데 , 여기서는 쉘에 의해 형식화됩니다. 사용 가능한 많은 가드 테스트에 대한 자세한 내용은 &lt;code&gt;Guard Sequences&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4a0e079c5d305d9ddb09850abdc7996b675aca1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;{active, true}&lt;/code&gt; mode provides no flow control; a fast sender can easily overflow the receiver with incoming messages. The same is true for &lt;code&gt;{active, N}&lt;/code&gt; mode, while the message count is greater than zero.</source>
          <target state="translated">공지 사항 그게 &lt;code&gt;{active, true}&lt;/code&gt; 모드는 어떤 흐름 제어를 제공하지 않는다; 빠른 발신자는 수신 메시지로 수신자를 쉽게 넘칠 수 있습니다. &lt;code&gt;{active, N}&lt;/code&gt; 모드 의 경우에도 마찬가지이며 메시지 수가 0보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="3d5d39b6d9eb6afa53058c47c7cffc48273fdd29" translate="yes" xml:space="preserve">
          <source>Notice that Logger automatically inserts a timestamp in the meta data unless it already exists. This function is exported for the rare case when the timestamp must be taken at a different point in time than when the log event is issued.</source>
          <target state="translated">Logger는 메타 데이터가 이미 존재하지 않는 한 자동으로 타임 스탬프를 삽입합니다. 이 함수는 로그 이벤트가 발행 될 때와 다른 시점에서 타임 스탬프를 가져와야하는 드문 경우를 위해 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="1da54ccbef9166436330bfc6fd162fc86bc65127" translate="yes" xml:space="preserve">
          <source>Notice that Mnesia can be connected to other nodes than those returned in &lt;code&gt;ReturnValue&lt;/code&gt;.</source>
          <target state="translated">Mnesia는 &lt;code&gt;ReturnValue&lt;/code&gt; 에 반환 된 노드 이외의 다른 노드에 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca1604ae3c36200717b82378dacc675667bae387" translate="yes" xml:space="preserve">
          <source>Notice that USM users are needed for SNMPv3 configuration and are not to be confused with users.</source>
          <target state="translated">USM 사용자는 SNMPv3 구성에 필요하며 사용자와 혼동해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2103331cf1bc333f91a2382aff0f9f89c72945ce" translate="yes" xml:space="preserve">
          <source>Notice that UTF-8 is &lt;strong&gt;not&lt;/strong&gt; compatible with bytewise representation for code points from 128 through 255, so an ISO Latin-1 bytewise representation is generally incompatible with UTF-8.</source>
          <target state="translated">UTF-8은 128에서 255까지의 코드 포인트에 대한 바이트 단위 표현과 호환 &lt;strong&gt;되지 않으므로&lt;/strong&gt; ISO Latin-1 바이트 단위 표현은 일반적으로 UTF-8과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a6c1827f210e0e7a2b7f47b6b3a1bd1a9af4a39" translate="yes" xml:space="preserve">
          <source>Notice that \g{...} (Perl syntax) and \g&amp;lt;...&amp;gt; (Oniguruma syntax) are &lt;strong&gt;not&lt;/strong&gt; synonymous. The former is a back reference; the latter is a subroutine call.</source>
          <target state="translated">\ g {...} (Perl 구문) 및 \ g &amp;lt;...&amp;gt; (Oniguruma 구문)은 동의어 가 &lt;strong&gt;아닙니다&lt;/strong&gt; . 전자는 역 참조이다. 후자는 서브 루틴 호출입니다.</target>
        </trans-unit>
        <trans-unit id="8de6476a9a9e34e743ca7bda411e9e36e779275d" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_server&lt;/code&gt; process does not trap exit signals automatically, this must be explicitly initiated in the callback module.</source>
          <target state="translated">공지 사항이 있음을 &lt;code&gt;gen_server&lt;/code&gt; 의 과정이 아닌 트랩 출구 신호를 자동으로 수행이 명시 적으로 콜백 모듈에서 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8c968975fc7502f69e3fa5a0ebf2c3346e29c96" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_statem&lt;/code&gt; does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;.</source>
          <target state="translated">공지는 것을 &lt;code&gt;gen_statem&lt;/code&gt; 가 되지 트랩 출구 신호를 자동으로 수행이 명시 적으로 호출하여 (콜백 모듈에서 시작되어야합니다 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="755428447f434586578dae042ae0cabd4f3e660d" translate="yes" xml:space="preserve">
          <source>Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider:</source>
          <target state="translated">조건부 하위 패턴은 하나만 사용되므로 두 가지 대안이있는 것으로 간주되지 않습니다. 즉, | 조건부 하위 패턴의 문자는 다른 의미를 갖습니다. 공백을 무시하고 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="88df944878b2dfd57638c11c5f3a67b0b37ab5eb" translate="yes" xml:space="preserve">
          <source>Notice that a driver binary has an internal reference counter. This means that calling &lt;code&gt;driver_free_binary&lt;/code&gt;, it may not actually dispose of it. If it is sent to the emulator, it can be referenced there.</source>
          <target state="translated">드라이버 바이너리에는 내부 참조 카운터가 있습니다. 이것은 &lt;code&gt;driver_free_binary&lt;/code&gt; 호출 하면 실제로 처리하지 않을 수 있습니다. 에뮬레이터로 보내지면 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e57d3be6f96e69f222e396adc45b370579e57d1d" translate="yes" xml:space="preserve">
          <source>Notice that a faked CPU topology that does not reflect how the real CPU topology looks like is likely to decrease the performance of the runtime system.</source>
          <target state="translated">실제 CPU 토폴로지의 모양을 반영하지 않는 가짜 CPU 토폴로지는 런타임 시스템의 성능을 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="760aec758f8e9eb253ec969db2ad5ac99a17c5c4" translate="yes" xml:space="preserve">
          <source>Notice that a possessive quantifier can be used with an entire group, for example:</source>
          <target state="translated">소유 그룹화는 전체 그룹과 함께 사용할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="1bc519a5e1193bcfddf9bfba3de07bc1233b4abf" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using decentralized counter groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the groups are distributed better between schedulers with this option.</source>
          <target state="translated">분산 카운터 그룹을 사용하는 런타임 시스템 은이 옵션을 사용하면 스케줄러간에 그룹이 더 잘 분산되므로 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; 이점 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbbbc01405d36730105f83c66e9de97063c42e08" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using shared reader groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the reader groups are distributed better between schedulers.</source>
          <target state="translated">리더 그룹이 스케줄러간에 더 잘 분배되므로 공유 리더 그룹을 사용하는 런타임 시스템은 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b74f7fd747ff5bbe77c7879d54040bcdfa2b336e" translate="yes" xml:space="preserve">
          <source>Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.</source>
          <target state="translated">OS가 스케줄러 스레드를 스케줄 한 경우에도 스케줄러가 사용 중일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb44615a33547638a4835f2bb25ba9f7f738524" translate="yes" xml:space="preserve">
          <source>Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</source>
          <target state="translated">표준 OTP 동작 모듈을 사용하여 구현 된 모든 하위 프로세스는 자동으로 종료 프로토콜을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="022007469674875a658f3171e3ee5f06bc52c5ff" translate="yes" xml:space="preserve">
          <source>Notice that all eight levels can occur in the heading, not only &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;INFO&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; produces. And microseconds are added at the end of the timestamp.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 가 생성하는 것처럼 &lt;code&gt;ERROR&lt;/code&gt; , &lt;code&gt;WARNING&lt;/code&gt; 또는 &lt;code&gt;INFO&lt;/code&gt; 뿐만 아니라 8 가지 레벨 모두 제목에서 발생할 수 있습니다 . 타임 스탬프 끝에 마이크로 초가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a99f104a56eef6a6e79ebf5f27128ede71470917" translate="yes" xml:space="preserve">
          <source>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</source>
          <target state="translated">전체 조각이 삭제되므로 마지막 조각의 모든 레코드를 다른 조각으로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="43d4ab77c71efe5ed63400db11c28f943feb8544" translate="yes" xml:space="preserve">
          <source>Notice that all the output is received on gollum. This is because the I/O system finds out where the process is spawned from and sends all output there.</source>
          <target state="translated">모든 출력물은 골룸에서 수신됩니다. 이는 I / O 시스템이 프로세스가 생성 된 위치를 찾아서 모든 출력을 전송하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b1caf8d4d97365e6e7817ea835b055cfc59c2108" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자가 스케줄러를 바인딩하도록 요청했지만 자동으로 바인딩에 실패 할 수 있습니다. 스케줄러 바인딩을 검사하려면 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="afcf6c07d5d0261b9d60900ac2418148455d55af" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자가 스케줄러를 바인드하도록 요청했지만 자동으로 바인드하지 못했습니다. 스케줄러 바인딩을 검사하려면 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5737b0ee42e7396b1279449506400af6d4d0399" translate="yes" xml:space="preserve">
          <source>Notice that although the keyword &lt;code&gt;catch&lt;/code&gt; is used in the &lt;code&gt;try&lt;/code&gt; expression, there is not a &lt;code&gt;catch&lt;/code&gt; expression within the &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">키워드 있지만 것을 알 &lt;code&gt;catch&lt;/code&gt; 에 사용되는 &lt;code&gt;try&lt;/code&gt; 표현하는이없는 &lt;code&gt;catch&lt;/code&gt; 내에서 표현 &lt;code&gt;try&lt;/code&gt; 표현.</target>
        </trans-unit>
        <trans-unit id="994f867c355c6f90c5d005f5efe72e6205d3566f" translate="yes" xml:space="preserve">
          <source>Notice that an application can always be stopped explicitly by calling &lt;code&gt;stop/1&lt;/code&gt;. Regardless of the type of the application, no other applications are affected.</source>
          <target state="translated">&lt;code&gt;stop/1&lt;/code&gt; 을 호출하여 응용 프로그램을 항상 명시 적으로 중지 할 수 있습니다 . 응용 프로그램 유형에 관계없이 다른 응용 프로그램은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da2ab21694a90b36239b6620bd78657b3c952a69" translate="yes" xml:space="preserve">
          <source>Notice that an event manager &lt;strong&gt;does&lt;/strong&gt; trap exit signals automatically.</source>
          <target state="translated">이벤트 관리자 &lt;strong&gt;는&lt;/strong&gt; 종료 신호를 자동으로 트랩합니다.</target>
        </trans-unit>
        <trans-unit id="49dfb54eadef728066f7af6aab3f97cecf7b3fb1" translate="yes" xml:space="preserve">
          <source>Notice that an exiting port exists, but is not open.</source>
          <target state="translated">종료 포트가 있지만 열려 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e9791862f66b81843f5294813c5a3786cc4d5cd0" translate="yes" xml:space="preserve">
          <source>Notice that an exiting process exists, but is not alive. That is, &lt;code&gt;is_process_alive/1&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; for an exiting process, but its process identifier is part of the result returned from &lt;code&gt;processes/0&lt;/code&gt;.</source>
          <target state="translated">종료 프로세스가 존재하지만 활성 상태가 아닙니다. 즉, &lt;code&gt;is_process_alive/1&lt;/code&gt; 은 종료 프로세스에 대해 &lt;code&gt;false&lt;/code&gt; 를 리턴 하지만 프로세스 ID는 &lt;code&gt;processes/0&lt;/code&gt; 에서 리턴 된 결과의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e30baa54b514ae9385a376058a73878724a1d09c" translate="yes" xml:space="preserve">
          <source>Notice that any modifying operations, that is, &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt;, that are done between the &lt;code&gt;mnesia:select/4&lt;/code&gt; and &lt;code&gt;mnesia:select/1&lt;/code&gt; calls are not visible in the result.</source>
          <target state="translated">&lt;code&gt;mnesia:select/4&lt;/code&gt; 및 &lt;code&gt;mnesia:select/1&lt;/code&gt; 호출 사이에서 수행되는 수정 조작 (즉, &lt;code&gt;mnesia:write&lt;/code&gt; 또는 &lt;code&gt;mnesia:delete&lt;/code&gt; ) 은 결과에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c91a61c3b4aa6acc5afde73b1f0c373cd23ed1" translate="yes" xml:space="preserve">
          <source>Notice that any process can close a port using &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">모든 프로세스는 &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; 사용하여 포트를 닫을 수 있습니다 . {PortOwner, close} 자체는 포트 소유자 인 것처럼 보이지만 응답은 항상 포트 소유자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cc8e9c5e1271318aa4ada63b47a96351832036" translate="yes" xml:space="preserve">
          <source>Notice that any process can send to a port using &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; as if it itself was the port owner.</source>
          <target state="translated">모든 프로세스는 &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; 사용하여 포트로 보낼 수 있습니다 . 마치 포트 소유자 인 것처럼 {PortOwner, {command, Data}} .</target>
        </trans-unit>
        <trans-unit id="1824595a1c80b7075f5376bc1cd1c936c8d424db" translate="yes" xml:space="preserve">
          <source>Notice that any process can set the port owner using &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">모든 프로세스는 &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; 사용하여 포트 소유자를 설정할 수 있습니다 . {PortOwner, {connect, Pid}} 는 마치 포트 소유자 인 것처럼 응답하지만 항상 포트 소유자에게 응답이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a98b3f3c42ef6f33bfe8a7e8fccfe1473542b5f7" translate="yes" xml:space="preserve">
          <source>Notice that any tuple stored in the table must have at least &lt;code&gt;Pos&lt;/code&gt; number of elements.</source>
          <target state="translated">테이블에 저장된 튜플에는 최소한 &lt;code&gt;Pos&lt;/code&gt; 수의 요소 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd5de2485d7d394ae933d91e2e848ae72df0affa" translate="yes" xml:space="preserve">
          <source>Notice that as a driver binary is shared by the driver and the emulator. A binary received from the emulator or sent to the emulator must not be changed by the driver.</source>
          <target state="translated">드라이버 바이너리는 드라이버와 에뮬레이터에서 공유합니다. 에뮬레이터에서 받거나 에뮬레이터로 보낸 이진은 드라이버가 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f889fc9740aed7e3095d419001ad1fb0ce64b212" translate="yes" xml:space="preserve">
          <source>Notice that as this is &lt;code&gt;server_transfer/5&lt;/code&gt;, it is not the same as the previous function &lt;code&gt;server_transfer/4&lt;/code&gt;. Another &lt;code&gt;keysearch&lt;/code&gt; is done on &lt;code&gt;User_List&lt;/code&gt; to find the pid of the client corresponding to fred:</source>
          <target state="translated">이것이 &lt;code&gt;server_transfer/5&lt;/code&gt; 이므로 이전 함수 &lt;code&gt;server_transfer/4&lt;/code&gt; 와 같지 않습니다 . fred에 해당하는 클라이언트의 pid를 찾기 위해 &lt;code&gt;User_List&lt;/code&gt; 에서 다른 키 &lt;code&gt;keysearch&lt;/code&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="8fe86ce5fa59a3562a829573aaf5b3dfd2379e17" translate="yes" xml:space="preserve">
          <source>Notice that bit string patterns cannot be nested.</source>
          <target state="translated">비트 문자열 패턴은 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa80432fca6a469445d85d7dfaebe88b1a98b7f2" translate="yes" xml:space="preserve">
          <source>Notice that by passing the &lt;code&gt;positive&lt;/code&gt; modifier you will get heap allocated integers (bignums) quicker.</source>
          <target state="translated">&lt;code&gt;positive&lt;/code&gt; 수정자를 전달하면 힙 할당 정수 (큰 숫자)가 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="6a919935e37a99f7e411ad64d7426c9cc07d3818" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">트랜잭션 컨텍스트 내에서 &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; 를 호출 (중첩) 하면 트랜잭션 시맨틱이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="28de43964f8d0b0f5ebe0eeea1c37e096ff9f1e4" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) a &lt;code&gt;mnesia:ets&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">트랜잭션 컨텍스트 내에서 &lt;code&gt;mnesia:ets&lt;/code&gt; 를 호출 (중첩) 하면 트랜잭션 시맨틱이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="ccdf30109e045224354b9a92051a3710e7da0269" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;complex2:foo/1&lt;/code&gt; and &lt;code&gt;complex2:bar/1&lt;/code&gt; results in the tuple &lt;code&gt;{foo,X}&lt;/code&gt; or &lt;code&gt;{bar,Y}&lt;/code&gt; being sent to the &lt;code&gt;complex&lt;/code&gt; process, which codes them as binaries and sends them to the port. This means that the C program must be able to handle these two tuples.</source>
          <target state="translated">&lt;code&gt;complex2:foo/1&lt;/code&gt; 및 &lt;code&gt;complex2:bar/1&lt;/code&gt; 을 호출 하면 튜플 &lt;code&gt;{foo,X}&lt;/code&gt; 또는 &lt;code&gt;{bar,Y}&lt;/code&gt; 가 &lt;code&gt;complex&lt;/code&gt; 프로세스 로 전송 되어 이진으로 코딩되어 포트로 전송됩니다. 이것은 C 프로그램이이 두 튜플을 처리 할 수 ​​있어야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="76111f96a154ca2aa3dcd82c9fbe77397be7146e" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many children under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">메모리 부족 상태에서 많은 자식을 감독 할 때이 함수를 호출하면 메모리 부족 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f66f156315ef693448711da956208a1b9d370baa" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">메모리 부족 상태에서 많은 어린이를 감독 할 때이 기능을 호출하면 메모리 부족 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d8020652ba123cb254176a43a2c994dabfe6c7" translate="yes" xml:space="preserve">
          <source>Notice that chunked encoding can add headers so that there are more headers in the &lt;code&gt;stream_end&lt;/code&gt; message than in &lt;code&gt;stream_start&lt;/code&gt;. When streaming to a file and the request is asynchronous, the message &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; is sent.</source>
          <target state="translated">청크 인코딩은 &lt;code&gt;stream_start&lt;/code&gt; 메시지보다 &lt;code&gt;stream_end&lt;/code&gt; 메시지 에 더 많은 헤더가 있도록 헤더를 추가 할 수 있습니다 . 파일로 스트리밍하고 요청이 비동기 인 경우 &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8eacfb231646f67a84dd48c38b3252b46ba678d6" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt; tables.</source>
          <target state="translated">현재 &lt;code&gt;ordered_set&lt;/code&gt; 은 &lt;code&gt;disc_only_copies&lt;/code&gt; 테이블에 대해 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b6f86d7c1e62cac7ff19af2ed505338d552e40c3" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;ordered_set&lt;/code&gt; 은 &lt;code&gt;disc_only_copies&lt;/code&gt; 에 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c1ba106fc749c03f0e8e929a856488e3fe0469ca" translate="yes" xml:space="preserve">
          <source>Notice that default option &lt;code&gt;{active, true}&lt;/code&gt; cannot be changed, for internal reasons.</source>
          <target state="translated">내부 옵션으로 기본 옵션 &lt;code&gt;{active, true}&lt;/code&gt; 를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61f3baddeb0657db3f04655dfe751683be5006f5" translate="yes" xml:space="preserve">
          <source>Notice that deleted objects are not freed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">삭제 된 객체는 해제 될 때까지 고정 테이블에서 해제되지 않습니다. 프로세스가 테이블을 수정하지만 해제하지 않는 경우 삭제 된 개체가 사용하는 메모리는 해제되지 않습니다. 테이블에 대한 작업 성능도 크게 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="f9c5bb258ea4f52af5df09054ae473cf25538fc1" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead they use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">분배 소켓은 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 및 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 사용을 비활성화합니다 . 대신 그들은 유사한 기능인 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; 사용 제한 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8e359baa81f7be3463d30d7e81f74f0d6daa7f44" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">분배 소켓은 &lt;code&gt;high_msgq_watermark&lt;/code&gt; 및 &lt;code&gt;low_msgq_watermark&lt;/code&gt; 사용을 비활성화합니다 . 대신 유사한 기능인 &lt;code&gt;distribution buffer busy limit&lt;/code&gt; 사용 제한을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d5e701c93b303b29d937ac4bace336c512ed95b" translate="yes" xml:space="preserve">
          <source>Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does &lt;strong&gt;not&lt;/strong&gt; match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it does not match &quot;123abcfoo&quot;. A pattern to do that is the following:</source>
          <target state="translated">각 어설 션은 제목 문자열의 동일한 지점에서 독립적으로 적용됩니다. 먼저 앞의 세 문자가 모두 숫자인지 확인한 다음 동일한 세 문자가 &quot;999&quot;가 아닌지 확인합니다. 이 패턴은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; &quot;999&quot;하지 여섯 개 자리 중 첫 번째의 문자, 그리고 마지막 세 앞에 &quot;foo는&quot;일치합니다. 예를 들어 &quot;123abcfoo&quot;와 일치하지 않습니다. 이를 수행하는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5779934da069d89a75c4be1d8cdff80ec5c00bf4" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt; proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">호출 스택을 비우면 주변 &lt;code&gt;catch&lt;/code&gt; 가 제거되고 최대 절전 모드 후에 다시 삽입해야합니다. 이로 인한 한 가지 효과는 &lt;code&gt;proc_lib&lt;/code&gt; 를 사용하여 시작된 프로세스 ( &lt;code&gt;gen_server&lt;/code&gt; 프로세스 와 같은 간접적 )가 대신 &lt;code&gt; proc_lib:hibernate/3&lt;/code&gt; 를 사용하여 프로세스가 깨어날 때 예외 처리기가 계속 작동하도록한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5c69517c533a13ffb06612150fd12d6557f1bab" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">콜 스택을 비우면 주변 &lt;code&gt;catch&lt;/code&gt; 를 제거하고 최대 절전 모드 후에 다시 삽입해야합니다. 이것의 한 가지 효과는 &lt;code&gt;proc_lib&lt;/code&gt; 를 사용하여 시작된 프로세스 ( &lt;code&gt;gen_server&lt;/code&gt; 프로세스 와 같은 간접 프로세스)가 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; 를 대신 사용하여 프로세스가 깨어 났을 때 예외 처리기가 계속 작동하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5a1bb27af980314db81c1b30e32509a27fc50e5" translate="yes" xml:space="preserve">
          <source>Notice that error handling is omitted from the code:</source>
          <target state="translated">코드에서 오류 처리가 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac90f95ed355ecf5e134f5c94815fdaaf2216766" translate="yes" xml:space="preserve">
          <source>Notice that every guard test has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">모든 가드 테스트는 일부 표현식과 동일한 소스 형식을 가지며 해당 표현식과 동일한 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="12ac9f06be5d0c942954f11af7bd16a9c92f71af" translate="yes" xml:space="preserve">
          <source>Notice that every pattern has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">모든 패턴은 일부 표현식과 동일한 소스 형식을 가지며 해당 표현식과 동일한 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1dafff17410c30a74873fbb0f049fd6b36e0dd69" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_all/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="translated">의 수단에 의해 설치되어 CTHs 대한 통지 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 기능 &lt;code&gt;post_all/2&lt;/code&gt; 전과라고 &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 후크 함수. 그러나 CT 시작 플래그를 통해 설치된 CTH의 경우 &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 함수가 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5d439f14c665f39e855a7716b502d1b790e81b7b" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_groups/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="translated">의 수단에 의해 설치되어 CTHs 대한 통지 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 기능 &lt;code&gt;post_groups/2&lt;/code&gt; 전과라고 &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 후크 함수. 그러나 CT 시작 플래그를 통해 설치된 CTH의 경우 &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 함수가 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="22d44122084b22fa6c5e4d72f866f1a0cdc53879" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets this function returns only one of the socket addresses. Function &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">SCTP 소켓의 경우이 함수는 소켓 주소 중 하나만 반환합니다. 기능 &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; 반환을 모두.</target>
        </trans-unit>
        <trans-unit id="3eea76ec53bc50101ada93a2881a73a66d999f61" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets, this function returns only one of the peer addresses of the socket. Function &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">SCTP 소켓의 경우이 함수는 소켓의 피어 주소 중 하나만 반환합니다. 함수 &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; 는 모두를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b549a78c27b0039d4ff0cb9fa34e52e88f8ae6e" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">이외의 다른 이유로 통지 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; , 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스가 오류로 인해 종료 가정 및 오류 보고서를 사용하여 발행 &lt;code&gt;logger(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f2fde3695426d831d6f9a88359f21930dd08692" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">이외의 다른 이유로 통지 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; , 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 의 &lt;code&gt;gen_statem&lt;/code&gt; 이 오류로 인해 종료 가정 및 오류 보고서를 사용하여 발행 &lt;code&gt;logger(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c994ab42bf95f015c8131e40fece01289a1526" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt; before a &lt;code&gt;mnesia:select&lt;/code&gt;. For efficiency, &lt;code&gt;NObjects&lt;/code&gt; is a recommendation only and the result can contain anything from an empty list to all available results.</source>
          <target state="translated">최상의 성능을 얻으려면 동일한 트랜잭션의 해당 테이블에서 수정 작업을 수행하기 전에 &lt;code&gt;select&lt;/code&gt; 가 사용됩니다. 즉, &lt;code&gt;mnesia:select&lt;/code&gt; 전에 &lt;code&gt;mnesia:write&lt;/code&gt; 또는 &lt;code&gt;mnesia:delete&lt;/code&gt; 를 사용하지 마십시오 . 효율성을 위해 &lt;code&gt;NObjects&lt;/code&gt; 는 권장 사항 일 뿐이며 결과는 빈 목록에서 사용 가능한 모든 결과에 이르기까지 모든 것을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="575b65587388a5c28bf652744375022398c20ce2" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; before a &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">최상의 성능을 얻으려면 동일한 트랜잭션의 해당 테이블에서 수정 작업을 수행하기 전에 &lt;code&gt;select&lt;/code&gt; 가 사용됩니다. 즉, &lt;code&gt;select&lt;/code&gt; 전에 &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="a8e4ee50b8c86a9d97d28e810a76ef00e7ee22cf" translate="yes" xml:space="preserve">
          <source>Notice that for table type &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary, as calls to &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; always succeed.</source>
          <target state="translated">공지 사항 테이블 유형에 대한 것을 &lt;code&gt;ordered_set&lt;/code&gt; , &lt;code&gt;safe_fixtable/2&lt;/code&gt; 호출로 필요하지 않습니다 &lt;code&gt;first/1&lt;/code&gt; 와 &lt;code&gt;next/2&lt;/code&gt; 항상 성공.</target>
        </trans-unit>
        <trans-unit id="fadf7fb473798e1c8fbe8d738e7d7fba94595b7d" translate="yes" xml:space="preserve">
          <source>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</source>
          <target state="translated">임시 하위의 경우 하위가 종료되면 하위 스펙이 자동으로 삭제됩니다. 따라서 해당 하위를 다시 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8f8d69fc55404a3f5202b0589ebb12fa1fbadb2" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; should be used when converting a string to be tested for equality.</source>
          <target state="translated">테스트 할 문자열을 동일하게 변환 할 때는 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="405372cbb8689b7bb9d46fd60b33792430970cfc" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; can be used as help as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; 함수 는 다음과 같이 도움말로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0bcaa7532bb6bae36e73c3763ba087654d90d2" translate="yes" xml:space="preserve">
          <source>Notice that functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, and &lt;code&gt;chunk_step/3&lt;/code&gt; do not affect any value returned by &lt;code&gt;info/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; 및 &lt;code&gt;chunk_step/3&lt;/code&gt; 함수 는 &lt;code&gt;info/1&lt;/code&gt; 에 의해 리턴 된 값에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="da3a6b0a2ad8ae3b2ff383a08f0cdcfac8ef3282" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; do not exist in the suite, &lt;code&gt;Common Test&lt;/code&gt; calls dummy functions (with the same names) instead, so that output generated by hook functions can be saved to the log files for these dummies. For details, see &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주의 경우 것으로 &lt;code&gt;init_per_suite&lt;/code&gt; 하고 &lt;code&gt;end_per_suite&lt;/code&gt; 제품군에 존재하지 않는, &lt;code&gt;Common Test&lt;/code&gt; 후크 기능에 의해 생성 된 출력하는이 인형의 로그 파일에 저장 될 수 있도록, 대신에 (같은 이름) 더미 함수를 호출합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aee52a26c1c7778ed0141e880006af8c079abe71" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;parallel_login&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, only one client at a time can be in the authentication phase.</source>
          <target state="translated">경우 통지 &lt;code&gt;parallel_login&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , 한 번에 하나의 클라이언트가 인증 단계에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2ae74861195afaaaecbb5004aa3195b54b0af5d" translate="yes" xml:space="preserve">
          <source>Notice that if a &quot;technically built in function&quot; (that is, a function not written in Erlang) is traced, the &lt;code&gt;caller&lt;/code&gt; function sometimes returns the atom &lt;code&gt;undefined&lt;/code&gt;. The calling Erlang function is not available during such calls.</source>
          <target state="translated">&quot;기술적으로 내장 된 함수&quot;(즉, Erlang으로 작성되지 않은 함수)가 추적되면 &lt;code&gt;caller&lt;/code&gt; 함수는 때때로 원자 &lt;code&gt;undefined&lt;/code&gt; 를 리턴합니다 . 이러한 호출 중에는 호출 Erlang 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f92e3c3fb0383592cf170b7659be5a996f925ab5" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt; parameter must not be modified.</source>
          <target state="translated">런타임에서 핸들러 구성을 변경하는 경우 &lt;code&gt;type&lt;/code&gt; 매개 변수를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ce90066e3aad3459d75c1fb55cecaec28fe2794d" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, or &lt;code&gt;modes&lt;/code&gt; parameters must not be modified.</source>
          <target state="translated">런타임에서 핸들러의 구성을 변경하는 경우 &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; 또는 &lt;code&gt;modes&lt;/code&gt; 매개 변수를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="08ce68141a0a8640f5e5838bc1d59c39e01b55c0" translate="yes" xml:space="preserve">
          <source>Notice that if option &lt;code&gt;delayed_write&lt;/code&gt; was used when opening the file, &lt;code&gt;close/1&lt;/code&gt; can return an old write error and not even try to close the file. See &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 열 때 &lt;code&gt;delayed_write&lt;/code&gt; 옵션 이 사용 된 경우 &lt;code&gt;close/1&lt;/code&gt; 은 오래된 쓰기 오류를 반환하고 파일을 닫으려고 시도 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f698c6b4cd9ababf8d72ba0d6e493d5ad2e7229c" translate="yes" xml:space="preserve">
          <source>Notice that if the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; are not in directory &lt;code&gt;/etc&lt;/code&gt;, the file path in the second and third command must be modified.</source>
          <target state="translated">&lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 및 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 파일 이 &lt;code&gt;/etc&lt;/code&gt; 디렉토리에 없으면 두 번째 및 세 번째 명령의 파일 경로를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="245b52374d4b97b1ff0d2029d95aaa06dad4396b" translate="yes" xml:space="preserve">
          <source>Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If &lt;code&gt;Expansions&lt;/code&gt; contains more than one property with the same key, only the first occurrence is used.</source>
          <target state="translated">확장시 원래 속성 용어가 결과에 유지되는 경우 확장 목록에 포함되어야합니다. 삽입 된 항은 재귀 적으로 확장되지 않습니다. &lt;code&gt;Expansions&lt;/code&gt; 에 동일한 키를 가진 둘 이상의 특성이 포함 된 경우 첫 번째 항목 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc08705bf71174fc6daf6d3117f962a241235e84" translate="yes" xml:space="preserve">
          <source>Notice that if you restore to a non-empty registry, objects in the table overwrite objects in the registry with the same keys. Also, the &lt;strong&gt;entire&lt;/strong&gt; contents of the registry is marked as unmodified after the restore, including any modified objects that were not overwritten by the restore operation. This may not be your intention.</source>
          <target state="translated">비어 있지 않은 레지스트리로 복원하면 테이블의 오브젝트가 동일한 키로 레지스트리의 오브젝트를 겹쳐 씁니다. 또한 복원 작업으로 덮어 쓰지 않은 수정 된 개체를 포함하여 복원 후 레지스트리 의 &lt;strong&gt;전체&lt;/strong&gt; 내용이 수정되지 않은 것으로 표시됩니다. 이것은 당신의 의도가 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef1c34d22b7f466e6132c1e85ef582f650007b8" translate="yes" xml:space="preserve">
          <source>Notice that if you store binary objects that are context-dependent (for example, containing pointers or open file descriptors), they lose their meaning if they are backed up to a &lt;code&gt;Mnesia&lt;/code&gt; table and later restored in a different context.</source>
          <target state="translated">컨텍스트에 의존하는 (예 : 포인터 또는 열린 파일 디스크립터 포함) 이진 오브젝트를 저장하는 경우 &lt;code&gt;Mnesia&lt;/code&gt; 테이블에 백업 된 후 나중에 다른 컨텍스트에서 복원 되면 의미가 없어집니다 .</target>
        </trans-unit>
        <trans-unit id="c04eebf0253a2b09b02af48ec92f831c4ed73813" translate="yes" xml:space="preserve">
          <source>Notice that ignoring the return value from this function would result in an &lt;strong&gt;unreliable&lt;/strong&gt; message passing, which is contradictory to the Erlang programming model. The message is &lt;strong&gt;not&lt;/strong&gt; sent if this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수의 반환 값을 무시하면 &lt;strong&gt;신뢰할 수없는&lt;/strong&gt; 메시지가 전달되어 Erlang 프로그래밍 모델과 모순됩니다. 이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환하면 메시지가 전송 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8e0a7d0fec338c74c62f26d54f900722acf0e30d" translate="yes" xml:space="preserve">
          <source>Notice that in &lt;code&gt;ordered_set&lt;/code&gt; tables, the records are ordered per fragment, and the order is undefined in results returned by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;, as well as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">에 통지 &lt;code&gt;ordered_set&lt;/code&gt; 테이블, 레코드가 조각 당 정렬 및 순서에 의해 반환 된 결과에 정의되어 있지 않습니다 &lt;code&gt;select&lt;/code&gt; 하고 &lt;code&gt;match_object&lt;/code&gt; 뿐만 아니라, &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;prev&lt;/code&gt; 및 &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e87353c4be156a71ce7f89688b213b459834c505" translate="yes" xml:space="preserve">
          <source>Notice that in some cases, standard output of a command when called from another program (for example, &lt;code&gt;os:cmd/1&lt;/code&gt;) can differ, compared with the standard output of the command when called directly from an OS command shell.</source>
          <target state="translated">경우에 따라 다른 프로그램에서 호출 될 때 명령의 표준 출력 (예 &lt;code&gt;os:cmd/1&lt;/code&gt; )이 OS 명령 쉘에서 직접 호출 될 때 명령의 표준 출력과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3295423e0e8171c99eb1e9345ef25427a5a63801" translate="yes" xml:space="preserve">
          <source>Notice that in this unanchored example, the mark is retained from the match attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it.</source>
          <target state="translated">이 고정되지 않은 예에서, 마크는 주제에서 문자 &quot;X&quot;에서 시작된 일치 시도에서 유지됩니다. &quot;P&quot;로 시작한 다음 빈 문자열을 가진 후속 일치 시도는 (* MARK) 항목까지 도달하지 않지만 재설정하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cc48f18a5b25966f4b54af3d4aabec2ba6f3d99" translate="yes" xml:space="preserve">
          <source>Notice that it did not write &quot;hello&quot; three times and then &quot;goodbye&quot; three times. Instead, the first process wrote a &quot;hello&quot;, the second a &quot;goodbye&quot;, the first another &quot;hello&quot; and so forth. But where did the &amp;lt;0.63.0&amp;gt; come from? The return value of a function is the return value of the last &quot;thing&quot; in the function. The last thing in the function &lt;code&gt;start&lt;/code&gt; is</source>
          <target state="translated">&quot;hello&quot;를 세 번 쓴 다음 &quot;byebye&quot;를 세 번 쓰지 않았습니다. 대신, 첫 번째 프로세스는 &quot;hello&quot;, 두 번째 프로세스는 &quot;goodbye&quot;, 첫 번째 프로세스는 &quot;hello&quot;등을 작성했습니다. 그러나 &amp;lt;0.63.0&amp;gt;은 어디에서 왔습니까? 함수의 반환 값은 함수에서 마지막 &quot;thing&quot;의 반환 값입니다. 함수 &lt;code&gt;start&lt;/code&gt; 에서 마지막 은</target>
        </trans-unit>
        <trans-unit id="cf4175703ac6e9fdbe15e5acca7f10693ec63c07" translate="yes" xml:space="preserve">
          <source>Notice that it is also required to expand the &lt;code&gt;-export&lt;/code&gt; line with the information that there is another function &lt;code&gt;mult&lt;/code&gt; with two arguments.</source>
          <target state="translated">또한 두 개의 인수가있는 다른 함수 &lt;code&gt;mult&lt;/code&gt; 가 있다는 정보로 &lt;code&gt;-export&lt;/code&gt; 행 을 확장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a1a5ba2084c75a9789fb8664c66476603427348b" translate="yes" xml:space="preserve">
          <source>Notice that it is always the &lt;code&gt;merge_tests&lt;/code&gt; setting in the source specification that is used when joined with other specifications. Say, for example, that a source specification A, with tests TA1 and TA2, has &lt;code&gt;{merge_tests,false}&lt;/code&gt; set, and that it includes another specification, B, with tests TB1 and TB2, that has &lt;code&gt;{merge_tests,true}&lt;/code&gt; set. The result is that the test series &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; is executed. The opposite &lt;code&gt;merge_tests&lt;/code&gt; settings would result in the test series &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt;.</source>
          <target state="translated">다른 스펙과 결합 될 때 사용되는 소스 스펙의 항상 &lt;code&gt;merge_tests&lt;/code&gt; 설정입니다. 예를 들어, 테스트 TA1 및 TA2를 사용하는 소스 스펙 A에는 &lt;code&gt;{merge_tests,false}&lt;/code&gt; 가 설정되어 있고 다른 스펙 B에는 테스트 TB1 및 TB2가 있고 &lt;code&gt;{merge_tests,true}&lt;/code&gt; 가 설정되어 있다고 가정하십시오 . 결과 테스트 &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; 가 실행됩니다. 반대의 &lt;code&gt;merge_tests&lt;/code&gt; 설정은 테스트 시리즈 &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="24bcac8813bad82252a8da44008063c6a9939ca8" translate="yes" xml:space="preserve">
          <source>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</source>
          <target state="translated">트랜잭션 내에서보다 더티 레코드를 읽는 것이 10 배 이상 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="5fc580601d400a238482271cf80a8768aa43f791" translate="yes" xml:space="preserve">
          <source>Notice that it is normally the set of auto-imported BIFs that are referred to when talking about 'BIFs'.</source>
          <target state="translated">일반적으로 'BIF'에 대해 이야기 할 때 참조되는 자동 가져 오기 BIF 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f48367941ecb417ce39721c36cb2f46ca431113b" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call &lt;code&gt;enif_consume_timeslice&lt;/code&gt; to determine if it is allowed to continue execution.</source>
          <target state="translated">이 정보의 사용 여부와 방법을 결정하는 것은 런타임 시스템에 달려 있습니다. 일부 플랫폼에서의 구현은 다른 수단을 사용하여 소비 된 CPU 시간을 결정할 수 있습니다. 긴 NIF는이 문제와 상관없이 &lt;code&gt;enif_consume_timeslice&lt;/code&gt; 를 자주 호출 하여 실행을 계속할 수 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab3955ab8e83d7f2bb7bc498f1bd619814955ca0" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine the consumed fraction of the time-slice. Lengthy driver callbacks should, regardless of this, frequently call this function to determine if it is allowed to continue execution or not.</source>
          <target state="translated">이 정보의 사용 여부와 방법을 결정하는 것은 런타임 시스템에 달려 있습니다. 일부 플랫폼에서의 구현은 다른 방법을 사용하여 시간 분할의 소비 된 부분을 결정할 수 있습니다. 이에 관계없이 긴 드라이버 콜백은이 함수를 자주 호출하여 실행을 계속할 수 있는지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e2ef46263bde688553324aea18d9c6d620ba48f" translate="yes" xml:space="preserve">
          <source>Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255. This function do not decode such strings, use &lt;code&gt;ei_decode_string()&lt;/code&gt; instead.</source>
          <target state="translated">목록이 0..255 범위의 정수로만 구성된 경우 목록은 문자열로 인코딩됩니다. 이 함수는 그러한 문자열을 해독하지 않습니다 . 대신 &lt;code&gt;ei_decode_string()&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c29a9c8eeda96edcc7c5ce99dcb3efa7b2a52727" translate="yes" xml:space="preserve">
          <source>Notice that message &lt;code&gt;trace_delivered&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; imply that trace messages have been delivered. Instead it implies that all trace messages that &lt;strong&gt;are to be delivered&lt;/strong&gt; have been delivered. It is not an error if &lt;code&gt;Tracee&lt;/code&gt; is not, and has not been traced by someone, but if this is the case, &lt;strong&gt;no&lt;/strong&gt; trace messages have been delivered when the &lt;code&gt;trace_delivered&lt;/code&gt; message arrives.</source>
          <target state="translated">메시지 통지 &lt;code&gt;trace_delivered&lt;/code&gt; 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 트레이스 메시지를 의미가 전달되었다. 대신 &lt;strong&gt;배달 될&lt;/strong&gt; 모든 추적 메시지 가 배달되었음을 나타냅니다. &lt;code&gt;Tracee&lt;/code&gt; 가 아니고 누군가가 추적하지 않은 경우 오류 가 아니지만,이 경우 &lt;code&gt;trace_delivered&lt;/code&gt; 메시지가 도착할 때 추적 메시지가 전달 &lt;strong&gt;되지&lt;/strong&gt; 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="013198e22f586360fbbdabe6dcc8ff964ca7ded8" translate="yes" xml:space="preserve">
          <source>Notice that most type test BIFs have older equivalents, without the &lt;code&gt;is_&lt;/code&gt; prefix. These old BIFs are retained for backwards compatibility only and are not to be used in new code. They are also only allowed at top level. For example, they are not allowed in Boolean expressions in guards.</source>
          <target state="translated">대부분의 유형 테스트 BIF에는 &lt;code&gt;is_&lt;/code&gt; 접두사가 없는 이전 버전이 있습니다. 이러한 이전 BIF는 이전 버전과의 호환성을 위해서만 유지되며 새 코드에는 사용되지 않습니다. 또한 최상위 수준에서만 허용됩니다. 예를 들어, 가드의 부울 표현식에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8a03c035117d8088ab8da75706b1955d4613585" translate="yes" xml:space="preserve">
          <source>Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards).</source>
          <target state="translated">유닉스 와일드 카드에서와 같이 여러 개의 &quot;*&quot;문자가 허용되지만 Windows / DOS 와일드 카드와는 반대입니다.</target>
        </trans-unit>
        <trans-unit id="54221071699f0442ffc1867adb1c29b6517f290f" translate="yes" xml:space="preserve">
          <source>Notice that negative integer and float literals do not occur as such; they are parsed as an application of the unary negation operator.</source>
          <target state="translated">음의 정수 및 부동 리터럴은 그대로 발생하지 않습니다. 단항 부정 연산자의 응용 프로그램으로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="f22111bba803b0601fab83f0c4714a0a75aa87f8" translate="yes" xml:space="preserve">
          <source>Notice that no bounds checking is done on the buffer. It is the caller's responsibility to ensure that the buffer is large enough to hold the encoded terms. You can either use a static buffer that is large enough to hold the terms you expect to need in your program, or use &lt;code&gt;erl_term_len()&lt;/code&gt; to determine the exact requirements for a given term.</source>
          <target state="translated">버퍼에 대한 경계 검사가 수행되지 않습니다. 버퍼가 인코딩 된 용어를 보유 할만큼 충분히 큰지 확인하는 것은 호출자의 책임입니다. 프로그램에서 필요로하는 용어를 보유하기에 충분히 큰 정적 버퍼를 사용하거나 &lt;code&gt;erl_term_len()&lt;/code&gt; 을 사용하여 주어진 용어에 대한 정확한 요구 사항을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68f6c800f695bdd5313479dc773780ed9ac1eaba" translate="yes" xml:space="preserve">
          <source>Notice that no deleted objects are removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">삭제 된 개체는 고정 테이블에서 해제 될 때까지 제거되지 않습니다. 프로세스가 테이블을 수정하지만 테이블을 해제하지 않으면 삭제 된 개체가 사용한 메모리가 해제되지 않습니다. 테이블에서 작업 성능도 크게 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="27077c84801a08f27f5df1e48d210573f24a2d7b" translate="yes" xml:space="preserve">
          <source>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</source>
          <target state="translated">프로그램이 이러한 복제본에 대한 쓰기 작업을 실행할 때는 디스크 작업이 수행되지 않습니다. 그러나 영구 RAM 복제본이 필요한 경우 다음 대안을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a597a819e1aa34d827c71c03375ea201eae9bbe" translate="yes" xml:space="preserve">
          <source>Notice that not all implementations support all these &lt;code&gt;Item&lt;/code&gt;s.</source>
          <target state="translated">모든 구현이 이러한 모든 &lt;code&gt;Item&lt;/code&gt; 을 지원하는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="4b0bf74963177cf020fa41c6b9891ab9f9dfa55b" translate="yes" xml:space="preserve">
          <source>Notice that octal values &amp;gt;= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read.</source>
          <target state="translated">이 구문을 사용하여 지정된 8 진수 값&amp;gt; = 100은 3 자리 이하의 8 진수를 읽지 않기 때문에 선행 0으로 시작해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="52b3caa006e96a4c992643ceef9a790dd9eaf91b" translate="yes" xml:space="preserve">
          <source>Notice that offsets are counted in bytes, not in characters. If the file is opened using some other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries. That is, to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position &lt;strong&gt;known&lt;/strong&gt; to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</source>
          <target state="translated">오프셋은 문자가 아닌 바이트 단위로 계산됩니다. &lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 사용하여 파일을 열면 한 바이트가 한 문자에 해당하지 않습니다. 이러한 파일에서의 위치 지정은 알려진 문자 경계로만 수행 할 수 있습니다. 즉, 현재 위치를 가져 와서 파일의 시작 / 끝 또는 다른 방법으로 올바른 문자 경계에있는 &lt;strong&gt;것으로 알려진&lt;/strong&gt; 다른 위치 (일반적으로 파일의 바이트 순서 표시를 넘어서서 검색된 위치 , 알려진 바이트 크기를 가짐).&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf27ace1c7a3c2d0e720b1879eb1095858231ab1" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, this flag is only applicable for &lt;code&gt;werl&lt;/code&gt;, not &lt;code&gt;erl&lt;/code&gt; (&lt;code&gt;oldshell&lt;/code&gt;). Notice also that &lt;code&gt;Ctrl-Break&lt;/code&gt; is used instead of &lt;code&gt;Ctrl-C&lt;/code&gt; on Windows.</source>
          <target state="translated">Windows에서이 플래그는 &lt;code&gt;erl&lt;/code&gt; ( &lt;code&gt;oldshell&lt;/code&gt; )이 아닌 &lt;code&gt;werl&lt;/code&gt; 에만 적용됩니다 . 것 또한주의 &lt;code&gt;Ctrl-Break&lt;/code&gt; 대신 사용 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 Windows에서.</target>
        </trans-unit>
        <trans-unit id="b312389a960b6c4523a134c6d69a5e6dbd847cda" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must close the port explicitly</source>
          <target state="translated">일부 시스템 (예 : VxWorks)에서는 운영 체제가 노드가 실패했을 때 열려 있던 디스크립터를 자동으로 닫지 않기 때문에 실패한 노드는이 메커니즘에 의해 감지되지 않습니다. 이러한 방식으로 노드가 실패한 경우 &lt;code&gt;epmd&lt;/code&gt; 는 이전 이름이 아직 사용 중이라고 생각하므로 이전 이름으로 새 노드를 등록하지 못하게합니다. 이 경우 포트를 명시 적으로 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="32a6701d594a7f27b24d59d66fe69bc778606ca3" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must unregister the name explicitly:</source>
          <target state="translated">일부 시스템 (예 : VxWorks)에서는 운영 체제가 노드 장애시 열린 상태로 남아있는 설명자를 자동으로 닫지 않으므로이 메커니즘에서 장애가 발생한 노드를 감지하지 못합니다. 이런 방식으로 노드가 실패한 경우, &lt;code&gt;epmd&lt;/code&gt; 는 이전 이름이 여전히 사용중인 것으로 생각하여 이전 이름으로 새 노드를 등록하지 못하게합니다. 이 경우 이름을 명시 적으로 등록 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="43e1e5b7dc6da1a31388b14df1d6f6d64c3c0721" translate="yes" xml:space="preserve">
          <source>Notice that once &lt;code&gt;enif_make_resource&lt;/code&gt; creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely only on the garbage collector to deallocate the resource object eventually when it collects the term.</source>
          <target state="translated">공지 사항 일단 것을 &lt;code&gt;enif_make_resource&lt;/code&gt; 가 얼랑로 돌아갑니다 용어를 생성, 코드 중 하나를 할당 된 구조체에 자신의 네이티브 포인터를 유지하고 나중에 해제, 또는 즉시 해제하도록 선택할 때 결국 자원 객체를 할당 해제 만 가비지 컬렉터에 의존 할 수 용어를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="c711aa1c3890b7bd6065da8da6bc10f65058ad93" translate="yes" xml:space="preserve">
          <source>Notice that only nodes with disc are to be included in &lt;code&gt;DiscNodes&lt;/code&gt;. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</source>
          <target state="translated">디스크가있는 노드 만 &lt;code&gt;DiscNodes&lt;/code&gt; 에 포함됩니다 . 디스크가없는 노드, 즉 스키마를 포함한 모든 테이블이 RAM에만 상주하는 노드는 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="67651cee75d5ac445a33e918dbfa7e4e883f716f" translate="yes" xml:space="preserve">
          <source>Notice that only one timer exists on each driver instance; setting a new timer replaces an older one.</source>
          <target state="translated">각 드라이버 인스턴스에는 하나의 타이머 만 있습니다. 새 타이머를 설정하면 이전 타이머가 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="29d795d009d1ea7a8a290d1e73a04d2744f2a646" translate="yes" xml:space="preserve">
          <source>Notice that only schedulers online can be bound to logical processors.</source>
          <target state="translated">온라인 스케줄러 만 논리 프로세서에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f799abe642c8ae36124dcf7f5ee9ae1710bfa1f7" translate="yes" xml:space="preserve">
          <source>Notice that only tables of a certain format can be restored, that is, those that have been created and backed up to with &lt;code&gt;ei_reg_dump()&lt;/code&gt;. If the registry was not empty before the operation, the contents of the table are added to the contents of the registry. If the table contains objects with the same keys as those already in the registry, the registry objects are overwritten with the new values. If the registry contains objects that were not in the table, they are unchanged by this operation.</source>
          <target state="translated">특정 형식의 테이블, 즉 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 로 작성 및 백업 된 테이블 만 복원 할 수 있습니다 . 조작 전에 레지스트리가 비어 있지 않은 경우, 테이블의 내용이 레지스트리의 내용에 추가됩니다. 테이블에 이미 레지스트리에있는 것과 동일한 키를 가진 개체가 포함되어 있으면 레지스트리 개체를 새 값으로 덮어 씁니다. 레지스트리에 테이블에없는 오브젝트가 있으면이 조작으로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23b04cc5100e31a53261bbb900a051cd16d9ea99" translate="yes" xml:space="preserve">
          <source>Notice that only the channel is closed. The connection is still up and can handle other channels:</source>
          <target state="translated">채널 만 닫혀 있습니다. 연결은 여전히 ​​작동 중이며 다른 채널을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b15082a81f1a1a6e64b2d55298a12d9faa42eee1" translate="yes" xml:space="preserve">
          <source>Notice that only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</source>
          <target state="translated">사전 SNMP 순서 만 Mnesia에서 구현되며 실제 SNMP 모니터링은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a5838dc3537f85f38eb4149ebbfa4d4cafe73f75" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. For one-to-many style sockets, the special value &lt;code&gt;0&lt;/code&gt; is defined to mean that the returned addresses must be without any particular association. How different SCTP implementations interpret this varies somewhat.</source>
          <target state="translated">&lt;code&gt;Assoc&lt;/code&gt; 매개 변수 는 일대일 스타일 소켓에 대해 무시되도록 정의 된 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 에 의한 것입니다. 일대 다 스타일 소켓의 경우 특수 값 &lt;code&gt;0&lt;/code&gt; 은 반환 된 주소에 특별한 연관이 없어야 함을 의미합니다. 다른 SCTP 구현이이를 해석하는 방법은 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d0d1f865bec9fd2105dd8d15020f4e5d9157f2b3" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. What the special value &lt;code&gt;0&lt;/code&gt; means, hence its behavior for one-to-many style sockets, is unfortunately undefined.</source>
          <target state="translated">&lt;code&gt;Assoc&lt;/code&gt; 매개 변수 는 일대일 스타일 소켓에 대해 무시되도록 정의 된 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 에 의한 것입니다. 특수 값 &lt;code&gt;0&lt;/code&gt; 이 의미하는 바, 일대 다 스타일 소켓에 대한 동작은 불행히도 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ced3b5e4f7be44b8431fee61dd5559644b2a227" translate="yes" xml:space="preserve">
          <source>Notice that postponing buttons from the &lt;code&gt;open&lt;/code&gt; state to the &lt;code&gt;locked&lt;/code&gt; state feels like a strange thing to do for a code lock, but it at least illustrates event postponing.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 상태에서 &lt;code&gt;locked&lt;/code&gt; 상태로 연기하는 버튼은 코드 잠금에 대해 이상한 일처럼 느껴지지만 적어도 이벤트 연기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1c4f96f83f897de68ba3692f859901f16bc8520d" translate="yes" xml:space="preserve">
          <source>Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see &lt;code&gt;code/3&lt;/code&gt;.</source>
          <target state="translated">코드를 제거한다는 것은 모듈의 기존 코드에 남아있는 모든 프로세스가 경고없이 종료됨을 의미합니다. 자세한 정보는 &lt;code&gt;code/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c423ca269e9c8da0681587c3e65b43e4f6fcac32" translate="yes" xml:space="preserve">
          <source>Notice that relaxed command checking must enabled for the &lt;code&gt;epmd&lt;/code&gt; daemon contacted. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect.</source>
          <target state="translated">연락 된 &lt;code&gt;epmd&lt;/code&gt; 데몬에 대해 완화 된 명령 검사를 활성화해야합니다 . &lt;code&gt;epmd&lt;/code&gt; 를 대화식으로 실행할 때는 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9c86576f8186edb080a192562941feff98f7212" translate="yes" xml:space="preserve">
          <source>Notice that request for multiple parts of a document report a size of zero to the log file.</source>
          <target state="translated">문서의 여러 부분에 대한 요청은 크기가 0 인 로그 파일에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="e599e5f12a452819b319876058461d934b52f083" translate="yes" xml:space="preserve">
          <source>Notice that setting this value to &lt;code&gt;0&lt;/code&gt; does not turn of rotation. It only specifies that no archives are kept.</source>
          <target state="translated">이 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하면 회전하지 않습니다. 아카이브가 보관되지 않도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4443c6286a90c15343a889185dfe1fff15bfc5fd" translate="yes" xml:space="preserve">
          <source>Notice that settings saved by Erlang/OTP R16B01 or later cannot be read by Erlang/OTP R16B or earlier.</source>
          <target state="translated">Erlang / OTP R16B01 이상에서 저장 한 설정은 Erlang / OTP R16B 이전 버전에서는 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="649ed4989f050a560c2834e24c160ce1f14f0aab" translate="yes" xml:space="preserve">
          <source>Notice that since variables starting with an underscore are not anonymous, this matches:</source>
          <target state="translated">밑줄로 시작하는 변수는 익명이 아니므로 다음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d7a8cf550209c24a879718ffa59fcc7fbdaebab0" translate="yes" xml:space="preserve">
          <source>Notice that some system-internal events can also be received. Therefore a catch-all clause last in the definition of the event handler callback function &lt;code&gt;Module:handle_event/2&lt;/code&gt; is necessary. This also applies for &lt;code&gt;Module:handle_info/2&lt;/code&gt;, as the event handler must also take care of some system-internal messages.</source>
          <target state="translated">일부 시스템 내부 이벤트도 수신 할 수 있습니다. 따라서 이벤트 핸들러 콜백 함수 &lt;code&gt;Module:handle_event/2&lt;/code&gt; 의 정의에서 마지막에 catch-all 절이 필요합니다. 이벤트 핸들러도 일부 시스템 내부 메시지를 처리해야하므로 이는 &lt;code&gt;Module:handle_info/2&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4523f125f7da0a280c62ef57a22e6c4002553475" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;bin_opt_info&lt;/code&gt; is not meant to be a permanent option added to your &lt;code&gt;Makefile&lt;/code&gt;s, because all messages that it generates cannot be eliminated. Therefore, passing the option through the environment is in most cases the most practical approach.</source>
          <target state="translated">것을 알 수 &lt;code&gt;bin_opt_info&lt;/code&gt; 을 의미하지 않는다 당신에 추가 영구적 인 옵션이 될 수 있습니다 &lt;code&gt;Makefile&lt;/code&gt; 모든 메시지 있기 때문에 제거 할 수없는 생성하는,의. 따라서 환경을 통해 옵션을 전달하는 것이 대부분의 경우 가장 실용적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9f25de8ce6849112886fde44cc358ca27b801415" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;get_until&lt;/code&gt; request allows for a function with the data specified as always being a list. Also, the return value data from such a function can be of any type (as is indeed the case when an &lt;code&gt;io:fread/2,3&lt;/code&gt; request is sent to an I/O server). The client must be prepared for data received as answers to those requests to be in various forms. However, the I/O server is to convert the results to binaries whenever possible (that is, when the function supplied to &lt;code&gt;get_until&lt;/code&gt; returns a list). This is done in the example in section &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">을 주목하는 것이 &lt;code&gt;get_until&lt;/code&gt; 요청은 항상리스트로서 지정된 데이터와 기능을 허용합니다. 또한 이러한 함수의 반환 값 데이터는 모든 유형이 될 수 있습니다 (실제로 &lt;code&gt;io:fread/2,3&lt;/code&gt; 요청이 I / O 서버로 전송되는 경우). 클라이언트는 다양한 형태의 요청에 대한 응답으로 수신 된 데이터를 준비해야합니다. 그러나 I / O 서버는 가능한 경우 (즉, &lt;code&gt;get_until&lt;/code&gt; 에 제공된 함수 가 목록을 리턴 할 때) 결과를 2 진으로 변환해야합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt; 섹션 의 예제에서 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="869fe53220efffa9f2648be8687be1af3cac2f73" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;pid()&lt;/code&gt; of the I/O server is not explicitly present in tuple &lt;code&gt;io_reply&lt;/code&gt;. The reply can be sent from any process, not necessarily the actual I/O server.</source>
          <target state="translated">I / O 서버 의 &lt;code&gt;pid()&lt;/code&gt; 는 &lt;code&gt;io_reply&lt;/code&gt; 명시 적으로 존재하지 않습니다 . 응답은 실제 I / O 서버 일 필요는없는 모든 프로세스에서 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9bf7bd1d2a63adf57d1dd61e3e2c636ef718d87" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;start_link&lt;/code&gt; functions of the different behavior modules fulfill the above requirements.</source>
          <target state="translated">다른 비헤이비어 모듈 의 &lt;code&gt;start_link&lt;/code&gt; 함수는 위의 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="438a7860299a64ed5669574b6efede437e192860" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message can be the result of the link, but can also be the result of &lt;code&gt;Id&lt;/code&gt; calling &lt;code&gt;exit/2&lt;/code&gt;. Therefore, it &lt;strong&gt;can&lt;/strong&gt; be appropriate to clean up the message queue when trapping exits after the call to &lt;code&gt;unlink(Id)&lt;/code&gt;, as follows:</source>
          <target state="translated">공지는 것을 &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 메시지가 링크의 결과 일 수있다,뿐만 아니라의 결과 일 수있다 &lt;code&gt;Id&lt;/code&gt; 호출 &lt;code&gt;exit/2&lt;/code&gt; . 따라서 다음과 같이 &lt;code&gt;unlink(Id)&lt;/code&gt; 호출 후 트래핑이 종료 될 때 메시지 큐를 정리하는 것이 적절할 &lt;strong&gt;수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7d3b1ac2fe8c40d5c296cb9508ac5b63294a0ef" translate="yes" xml:space="preserve">
          <source>Notice that the BOM for UTF-8 is seldom used, and it is really not a &lt;strong&gt;byte order&lt;/strong&gt; mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.</source>
          <target state="translated">UTF-8 용 BOM은 거의 사용되지 않으며 실제로 &lt;strong&gt;바이트 순서&lt;/strong&gt; 표시가 아닙니다 . UTF-8에는 바이트 순서 문제가 없으므로 BOM은 UTF-8 인코딩을 다른 UTF 형식과 구별하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="60ba36aa64236926d8fc38d4a0caadafb0e955a8" translate="yes" xml:space="preserve">
          <source>Notice that the C program is in a &lt;code&gt;while&lt;/code&gt;-loop, checking for the return value of &lt;code&gt;read_cmd/1&lt;/code&gt;. This is because the C program must detect when the port closes and terminates.</source>
          <target state="translated">C 프로그램은 &lt;code&gt;while&lt;/code&gt; - loop에 있으며 &lt;code&gt;read_cmd/1&lt;/code&gt; 의 반환 값을 확인합니다 . C 프로그램은 포트가 닫히고 종료되는 시점을 감지해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a63c691118a268393e4b6c047b61976f9f09e5f5" translate="yes" xml:space="preserve">
          <source>Notice that the Kernel variable &lt;code&gt;inetrc&lt;/code&gt; overrides this environment variable.</source>
          <target state="translated">커널 변수 &lt;code&gt;inetrc&lt;/code&gt; 가이 환경 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="998c3bd807afb787e85df818d68896568ab1dac7" translate="yes" xml:space="preserve">
          <source>Notice that the above handler does not have any overload protection, and all log events are printed directly from the client process.</source>
          <target state="translated">위 핸들러에는 과부하 보호 기능이 없으며 모든 로그 이벤트는 클라이언트 프로세스에서 직접 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5b06b14e5057923df74530d889d86c130c4599fb" translate="yes" xml:space="preserve">
          <source>Notice that the above specification does not restrict the input and output type in any way. These types can be constrained by guard-like subtype constraints and provide bounded quantification:</source>
          <target state="translated">위의 사양은 입력 및 출력 유형을 제한하지 않습니다. 이러한 유형은 보호 유형의 하위 유형 제약 조건으로 제한 될 수 있으며 제한된 수량을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ffeb1c6cbb53bd413a17d7e4afa253b27c7a4334" translate="yes" xml:space="preserve">
          <source>Notice that the apparently similar pattern</source>
          <target state="translated">명백하게 유사한 패턴</target>
        </trans-unit>
        <trans-unit id="1865e3416dbeb17876187856aa08e4b5f4f9fd78" translate="yes" xml:space="preserve">
          <source>Notice that the application version specifies a source code version. One more, indirect, requirement is that the installed binary application of the specified version is built so that it is compatible with the rest of the system.</source>
          <target state="translated">응용 프로그램 버전은 소스 코드 버전을 지정합니다. 간접적 인 요구 사항 중 하나는 지정된 버전의 설치된 이진 응용 프로그램이 나머지 시스템과 호환되도록 빌드해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12430644918a731bc0331cb307bf4502fd57f823" translate="yes" xml:space="preserve">
          <source>Notice that the argument is a list with exactly one, two, or three arguments. &lt;code&gt;NameType&lt;/code&gt; defaults to &lt;code&gt;longnames&lt;/code&gt; and &lt;code&gt;Ticktime&lt;/code&gt; to &lt;code&gt;15000&lt;/code&gt;.</source>
          <target state="translated">인수는 정확히 하나, 둘 또는 세 개의 인수가있는 목록입니다. &lt;code&gt;NameType&lt;/code&gt; 의 기본값은 &lt;code&gt;longnames&lt;/code&gt; 이고 &lt;code&gt;Ticktime&lt;/code&gt; 은 &lt;code&gt;15000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e51fbbc05a639063fcd094a483d069e3e71d424" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this function for an SCTP one-to-many style socket is not defined by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SCTP 일대 다 스타일 소켓에 대한이 기능의 동작은 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 의해 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2695495d90a21bfbc215e48f946c97c1557c57eb" translate="yes" xml:space="preserve">
          <source>Notice that the compiler does not generate encode/decode functions for parameterized types, only for the instances of the parameterized types. Therefore, if a file contains the types &lt;code&gt;General{}&lt;/code&gt;, &lt;code&gt;T1&lt;/code&gt;, and &lt;code&gt;T2&lt;/code&gt; as in the previous example, encode/decode functions are only generated for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 매개 변수화 된 형식의 인스턴스에 대해서만 매개 변수화 된 형식에 대한 인코딩 / 디코딩 함수를 생성하지 않습니다. 따라서 파일 에 이전 예제에서 와 같이 &lt;code&gt;General{}&lt;/code&gt; , &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 유형이 포함 된 경우 인코딩 / 디코딩 기능은 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 에 대해서만 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4bdb273ffa02e13186dc2814d4167dbf9f7eac3" translate="yes" xml:space="preserve">
          <source>Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed).</source>
          <target state="translated">현재 키는 드라이버에 저장되며 유효하지 않을 수 있습니다 (예 : 키가 제거 된 경우).</target>
        </trans-unit>
        <trans-unit id="3425e12704f1ae2e3dac5bdc4405aa18192ba618" translate="yes" xml:space="preserve">
          <source>Notice that the default options for TCP/IP sockets can be changed with the Kernel configuration parameters mentioned in the beginning of this manual page.</source>
          <target state="translated">TCP / IP 소켓의 기본 옵션은이 매뉴얼 페이지의 시작 부분에 언급 된 커널 구성 매개 변수를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8735534cfeef989ea973a36967fd6073321a2a23" translate="yes" xml:space="preserve">
          <source>Notice that the definition of type &lt;code&gt;SET OF&lt;/code&gt; implies that the order of the components is undefined, but in practice there is no difference between &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt;. The ASN.1 compiler for Erlang does not randomize the order of the &lt;code&gt;SET OF&lt;/code&gt; components before encoding.</source>
          <target state="translated">&lt;code&gt;SET OF&lt;/code&gt; 유형의 정의 는 구성 요소의 순서가 정의되지 않았 음을 의미하지만 실제로 &lt;code&gt;SET OF&lt;/code&gt; 와 &lt;code&gt;SEQUENCE OF&lt;/code&gt; 사이에는 차이가 없습니다 . Erlang의 ASN.1 컴파일러는 인코딩 전에 &lt;code&gt;SET OF&lt;/code&gt; 구성 요소 의 순서를 무작위 화하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="85ee2b1beef42dfc51c38d1bdc5c48413f6418d8" translate="yes" xml:space="preserve">
          <source>Notice that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count. For example, consider the following pattern when &lt;code&gt;extended&lt;/code&gt; is set, and the default newline convention is in force:</source>
          <target state="translated">이 유형의 주석의 끝은 패턴에서 리터럴 개행 순서입니다. 줄 바꿈을 나타내는 이스케이프 시퀀스는 계산되지 않습니다. 예를 들어, &lt;code&gt;extended&lt;/code&gt; 이 설정되고 기본 줄 바꾸기 규칙이 적용되는 경우 다음 패턴을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="59c9761a4423dc8ba33d258174c0d7deb92180da" translate="yes" xml:space="preserve">
          <source>Notice that the file encoding options specified when opening a file has nothing to do with the filename encoding convention. You can very well open files containing data encoded in UTF-8, but having filenames in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding or conversely.</source>
          <target state="translated">파일을 열 때 지정된 파일 인코딩 옵션은 파일 이름 인코딩 규칙과 관련이 없습니다. UTF-8로 인코딩 된 데이터를 포함하지만 파일 이름을 바이트 단위 ( &lt;code&gt;latin1&lt;/code&gt; ) 인코딩으로 또는 반대로 반대로 파일을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54b730627c759c2237c6a38f6ac21fcf1d73b83e" translate="yes" xml:space="preserve">
          <source>Notice that the filesystem containing the virtual machine executable (&lt;code&gt;beam.smp&lt;/code&gt; in the example) must be local, mounted without flag &lt;code&gt;nosetuid&lt;/code&gt;, support extended attributes, and the kernel must support file capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except that SCTP sockets appear to not support network namespaces.</source>
          <target state="translated">가상 머신 실행 파일 ( 예 : &lt;code&gt;beam.smp&lt;/code&gt; ) 을 포함하는 파일 시스템 은 로컬이어야하고 플래그 &lt;code&gt;nosetuid&lt;/code&gt; 없이 마운트되고 확장 된 속성을 지원하며 커널은 파일 기능을 지원해야합니다. SCTP 소켓이 네트워크 네임 스페이스를 지원하지 않는 것 외에는이 모든 것이 최소한 우분투 12.04 LTS에서 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="856dd98224a317941549fceec575ed693a862a3b" translate="yes" xml:space="preserve">
          <source>Notice that the function &lt;code&gt;add_frag/2&lt;/code&gt; is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</source>
          <target state="translated">&lt;code&gt;add_frag/2&lt;/code&gt; 함수 는 테이블 작성 프로 시저의 일부로 다른 각 프래그먼트 (번호 1 제외)에 대해 한 번 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="71fbea88394343530b7ae5da050f337473550603" translate="yes" xml:space="preserve">
          <source>Notice that the function can return &lt;code&gt;true&lt;/code&gt; for a module that in fact is not interpretable in the case where the module is marked as sticky or resides in a directory marked as sticky. The reason is that this is not discovered until the interpreter tries to load the module.</source>
          <target state="translated">모듈이 sticky로 표시되거나 sticky로 표시된 디렉토리에있는 경우 실제로 해석 할 수 없는 모듈에 대해 함수가 &lt;code&gt;true&lt;/code&gt; 를 리턴 할 수 있습니다 . 그 이유는 인터프리터가 모듈을로드하려고 시도 할 때까지 감지되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fc5ff5fc0775ca18d960b27958c2c310603beba9" translate="yes" xml:space="preserve">
          <source>Notice that the functions below perform an RPC using an open file descriptor provided by the caller. This file descriptor must not be used for other traffic during the global operation, as the function can then receive unexpected data and fail.</source>
          <target state="translated">아래 함수는 호출자가 제공 한 열린 파일 설명자를 사용하여 RPC를 수행합니다. 함수가 예상치 못한 데이터를 수신하고 실패 할 수 있으므로 글로벌 조작 중에 다른 트래픽에이 파일 디스크립터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6344e9ae1d5d7f5e3378303250cff912dbc2282d" translate="yes" xml:space="preserve">
          <source>Notice that the history of the last trace is always available in file &lt;code&gt;ttb_last_config&lt;/code&gt;.</source>
          <target state="translated">마지막 추적의 히스토리는 항상 &lt;code&gt;ttb_last_config&lt;/code&gt; 파일에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="9b4c212a61f0bb3f68fad2d68b59100bb913758e" translate="yes" xml:space="preserve">
          <source>Notice that the information returned is highly implementation-dependent and can be changed or removed at any time without prior notice. It was initially intended as a tool when developing new allocators, but as it can be of interest for others it has been briefly documented.</source>
          <target state="translated">반환 된 정보는 구현에 따라 크게 달라지며 사전 통지없이 언제든지 변경하거나 제거 할 수 있습니다. 처음에는 새로운 할당자를 개발할 때 도구로 사용되었지만 다른 사람들이 관심을 가질 수 있도록 간략하게 문서화되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed442d55f4c83cba3d99e636fc5b3b8fb144e267" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정수 값은 Logger에서 내부적으로 만 사용됩니다. API에서는 항상 원자를 사용해야합니다. 두 로그 수준의 심각도를 비교하려면 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eec770c656034420f67e24636825b21ba0fb080" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정수 값은 로거에서 내부적으로 만 사용됩니다. API에서는 항상 원자를 사용해야합니다. 두 로그 레벨의 심각도를 비교하려면 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="913c6778d3ce72fc842456abadbdcd4a41900bd7" translate="yes" xml:space="preserve">
          <source>Notice that the last created atom is shown first.</source>
          <target state="translated">마지막으로 생성 된 원자가 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ee884138fcccc998b14a68323c7c49e44297a2" translate="yes" xml:space="preserve">
          <source>Notice that the last element in the &lt;code&gt;Request&lt;/code&gt; tuple (&lt;code&gt;[$\n]&lt;/code&gt;) is appended to the argument list when the function is called. The function is to be called like &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; by the I/O server.</source>
          <target state="translated">&lt;code&gt;Request&lt;/code&gt; 튜플 의 마지막 요소 ( &lt;code&gt;[$\n]&lt;/code&gt; )는 함수가 호출 될 때 인수 목록에 추가됩니다. 이 함수는 I / O 서버에 의해 &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; 와 같이 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="65e13b0553b24c92ba77e668391c89bbfe7c5f62" translate="yes" xml:space="preserve">
          <source>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">분할이 두 부분으로 지정되었으므로 마지막 부분은 &quot;an&quot;이 아니라 &quot;ang&quot;이며, 충분한 부분이 주어지면 분할이 중지되므로 결과가 &lt;code&gt;trim&lt;/code&gt; 의 결과와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0b0de072daf08ddb3bed5b003d16bec94ec3f838" translate="yes" xml:space="preserve">
          <source>Notice that the match context in &lt;code&gt;my_binary_to_list/1&lt;/code&gt; was discarded when the entire binary had been traversed. What happens if the iteration stops before it has reached the end of the binary? Will the optimization still work?</source>
          <target state="translated">전체 바이너리가 순회되면 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 의 일치 컨텍스트 가 삭제되었습니다. 이진의 끝에 도달하기 전에 반복이 중지되면 어떻게됩니까? 최적화가 여전히 작동합니까?</target>
        </trans-unit>
        <trans-unit id="2d19f8166370c4661429c3cee25b80ade4ba9fb7" translate="yes" xml:space="preserve">
          <source>Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</source>
          <target state="translated">반환 된 객체의 순서는 지정되어 있지 않습니다. 특히 개체가 삽입 된 순서는 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90ee8d6704f5ea8a8da9ff5e648eb8db8d5bce43" translate="yes" xml:space="preserve">
          <source>Notice that the program resides in the emulator's &lt;code&gt;bin&lt;/code&gt; directory, not in the &lt;code&gt;bin&lt;/code&gt; directory directly under the Erlang root. The reasons for this are the subtle problem of upgrading the emulator on a running system, where a new version of the runtime system should not need to overwrite existing (and probably used) executables.</source>
          <target state="translated">공지 사항이 에뮬레이터에서 프로그램이 상주 &lt;code&gt;bin&lt;/code&gt; 디렉토리가 아닌에서 &lt;code&gt;bin&lt;/code&gt; 직접 얼랑 루트 아래의 디렉토리. 그 이유는 실행중인 시스템에서 에뮬레이터를 업그레이드하는 데 미묘한 문제가 있기 때문입니다. 여기서 새 버전의 런타임 시스템은 기존 (및 아마도 사용 된) 실행 파일을 덮어 쓸 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="78b612195b425463060bd89b2b5fb48b2b6bc32f" translate="yes" xml:space="preserve">
          <source>Notice that the program runs slower if the data is located on a remote node.</source>
          <target state="translated">데이터가 원격 노드에있는 경우 프로그램이 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7527eddb37622ef5514d8dac4dc37568ecec15bd" translate="yes" xml:space="preserve">
          <source>Notice that the range &lt;code&gt;0..Range-1&lt;/code&gt; is different from the range of &lt;code&gt;phash/2&lt;/code&gt;, which is &lt;code&gt;1..Range&lt;/code&gt;.</source>
          <target state="translated">범위 알 &lt;code&gt;0..Range-1&lt;/code&gt; 의 범위에서 다른 &lt;code&gt;phash/2&lt;/code&gt; 이고, &lt;code&gt;1..Range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f5b1145658a0a3e84e5b5e128d226a353a792a5" translate="yes" xml:space="preserve">
          <source>Notice that the record name is the table name even when &lt;code&gt;record_name&lt;/code&gt; has another setting.</source>
          <target state="translated">&lt;code&gt;record_name&lt;/code&gt; 에 다른 설정이있는 경우에도 레코드 이름은 테이블 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="f556bad20e55c532b765ee625a5af6afc2bd2580" translate="yes" xml:space="preserve">
          <source>Notice that the regular expression must match the complete version string, so this example works for, for example, &lt;code&gt;2.1.1&lt;/code&gt;, but not for &lt;code&gt;2.1.1.1&lt;/code&gt;.</source>
          <target state="translated">정규식은 전체 버전 문자열과 일치해야 &lt;code&gt;2.1.1.1&lt;/code&gt; 예제는 예를 들어 &lt;code&gt;2.1.1&lt;/code&gt; 에서는 작동하지만 2.1.1.1 에서는 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="88bf6f27cbb64880bfd54716d99abab3e050207e" translate="yes" xml:space="preserve">
          <source>Notice that the risk of loosing log events grows when the &lt;code&gt;file_check&lt;/code&gt; value grows.</source>
          <target state="translated">&lt;code&gt;file_check&lt;/code&gt; 값이 커지면 로그 이벤트가 손실 될 위험이 커 집니다.</target>
        </trans-unit>
        <trans-unit id="3b783e1e390dc485584c1f74b3ed69a29fd778c4" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt; 과 동일한주의 사항이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eea6a747947fcb8f655a220c818e740e96ba5d5" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; 과 동일한 경고가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe10cacd28855d9196c579eb8146305f91e16641" translate="yes" xml:space="preserve">
          <source>Notice that the sequences \A, \Z, and \z can be used to match the start and end of the subject in both modes. If all branches of a pattern start with \A, it is always anchored, regardless if &lt;code&gt;multiline&lt;/code&gt; is set.</source>
          <target state="translated">\ A, \ Z 및 \ z 시퀀스를 사용하여 두 모드에서 피사체의 시작과 끝을 일치시킬 수 있습니다. \ A를 패턴 시작의 모든 지점 경우에는 관계없이 항상 경우, 고정되어 &lt;code&gt;multiline&lt;/code&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6724f506b54877b36a23e88d5de227a00d37732a" translate="yes" xml:space="preserve">
          <source>Notice that the shorthand for &lt;code&gt;list()&lt;/code&gt;, that is, the list of elements of unknown type, is &lt;code&gt;[_]&lt;/code&gt; (or &lt;code&gt;[any()]&lt;/code&gt;), not &lt;code&gt;[]&lt;/code&gt;. The notation &lt;code&gt;[]&lt;/code&gt; specifies the singleton type for the empty list.</source>
          <target state="translated">&lt;code&gt;list()&lt;/code&gt; 의 약자 , 즉 알 수없는 유형의 요소 목록은 &lt;code&gt;[]&lt;/code&gt; 가 아닌 [ &lt;code&gt;[_]&lt;/code&gt; (또는 &lt;code&gt;[any()]&lt;/code&gt; ) 입니다. &lt;code&gt;[]&lt;/code&gt; 표기법 은 빈 목록의 싱글 톤 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="73dac804c8d0ac669ce6f4344962d4b5c34961af" translate="yes" xml:space="preserve">
          <source>Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented.</source>
          <target state="translated">버디 시스템 인 RAM에 보관 된 공간 관리 데이터 구조도 디스크에 기록됩니다. 테이블이 조각난 경우 시간이 다소 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2158fd0c30567923e783ca815a320fc6fd564c3e" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt; erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 값의 합계 는 에뮬레이터에서 할당 한 총 메모리 양 이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 일부 값은 다른 값의 일부이고 일부 메모리 영역은 결과의 일부가 아닙니다. 에뮬레이터에서 할당 한 총 메모리 양에 대한 정보는 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt; erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30f0e9479e312465b9ff5d6f711d535a3e0101b4" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 값의 합계 는 에뮬레이터에서 할당 한 총 메모리 양 이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 일부 값은 다른 값의 일부이고 일부 메모리 영역은 결과의 일부가 아닙니다. 에뮬레이터에서 할당 한 총 메모리 양에 대한 정보는 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5abbe6d966c5fc1edc96d1f28f1436c4958c4e8" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (or &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt;), not &lt;code&gt;#{}&lt;/code&gt;. The notation &lt;code&gt;#{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">공지의 것을 표현 구문 &lt;code&gt;map()&lt;/code&gt; 이다 &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (또는 &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt; )하지 &lt;code&gt;#{}&lt;/code&gt; . &lt;code&gt;#{}&lt;/code&gt; 표기법 은 빈 맵의 싱글 톤 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d2c453c4a61a93e0e17811bf7efe3b048abd12f0" translate="yes" xml:space="preserve">
          <source>Notice that the template is here the same as for &lt;code&gt;single_line=false&lt;/code&gt;, but the resulting log entry differs in that there is only one line after the heading:</source>
          <target state="translated">여기서 템플릿은 &lt;code&gt;single_line=false&lt;/code&gt; 와 동일 하지만 결과 로그 항목은 제목 다음에 한 줄만 있다는 점에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1a0dfecdaad1fda603fa4229f911e862d71765b6" translate="yes" xml:space="preserve">
          <source>Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on.</source>
          <target state="translated">개체 삽입의 시간 순서가 유지됩니다. 지정된 키로 삽입 된 첫 번째 개체는 결과 목록에서 첫 번째 개체입니다.</target>
        </trans-unit>
        <trans-unit id="6f7067f925d0363a33444938455ac91fcd09edfb" translate="yes" xml:space="preserve">
          <source>Notice that the use of an &lt;code&gt;.inetrc&lt;/code&gt; file, which was supported in earlier Erlang/OTP versions, is now obsolete.</source>
          <target state="translated">이전 Erlang / OTP 버전에서 지원되었던 &lt;code&gt;.inetrc&lt;/code&gt; 파일 사용 은 이제 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b338a89eefab229871069c1f47956c10a1d50274" translate="yes" xml:space="preserve">
          <source>Notice that the value fed into the selective decode functions must be a binary.</source>
          <target state="translated">선택적 디코드 기능에 공급되는 값은 2 진이어야합니다.</target>
        </trans-unit>
        <trans-unit id="787fd319d83681555c07f1a96ca590fc08523120" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;;&quot; before &lt;code&gt;end&lt;/code&gt;. Conditions do the same as guards, that is, tests that succeed or fail. Erlang starts at the top and tests until it finds a condition that succeeds. Then it evaluates (performs) the action following the condition and ignores all other conditions and actions before the &lt;code&gt;end&lt;/code&gt;. If no condition matches, a run-time failure occurs. A condition that always succeeds is the atom &lt;code&gt;true&lt;/code&gt;. This is often used last in an &lt;code&gt;if&lt;/code&gt;, meaning, do the action following the &lt;code&gt;true&lt;/code&gt; if all other conditions have failed.</source>
          <target state="translated">&quot;;&quot;가 없습니다. &lt;code&gt;end&lt;/code&gt; 전에 . 조건은 가드, 즉 성공 또는 실패 테스트와 동일합니다. Erlang은 맨 위에서 시작하여 성공한 조건을 찾을 때까지 테스트합니다. 그런 다음 조건에 따라 동작을 평가 (수행)하고 &lt;code&gt;end&lt;/code&gt; 다른 모든 조건과 동작은 무시합니다 . 조건이 일치하지 않으면 런타임 오류가 발생합니다. 항상 성공하는 조건은 원자 &lt;code&gt;true&lt;/code&gt; 입니다. 다른 조건이 모두 실패한 경우 &lt;code&gt;true&lt;/code&gt; 뒤에있는 조치를 수행 하는 &lt;code&gt;if&lt;/code&gt; 가 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7902b9db4b62c4e9204bea0b7582aa107cd80a6" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;condition variable wait with time-out&quot; in the Erlang driver thread API. This because of issues with &lt;code&gt;pthread_cond_timedwait&lt;/code&gt;. When the system clock suddenly is changed, it is not always guaranteed that you will wake up from the call as expected. An Erlang runtime system must be able to cope with sudden changes of the system clock. Therefore, we have omitted it from the Erlang driver thread API. In the Erlang driver case, time-outs can and are to be handled with the timer functionality of the Erlang driver API.</source>
          <target state="translated">Erlang 드라이버 스레드 API에는 &quot;시간 초과시 조건 변수 대기&quot;가 없습니다. 이것은 &lt;code&gt;pthread_cond_timedwait&lt;/code&gt; 와 관련된 문제 때문입니다 . 시스템 시계가 갑자기 변경 될 때 항상 예상대로 전화가 깨어나는 것은 아닙니다. Erlang 런타임 시스템은 시스템 클럭의 갑작스러운 변화에 대처할 수 있어야합니다. 따라서 Erlang 드라이버 스레드 API에서 생략했습니다. Erlang 드라이버의 경우 시간 초과는 Erlang 드라이버 API의 타이머 기능으로 처리 할 수 ​​있으며 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="bceb9f4f6a6abdf1446e121be361b43261feb62c" translate="yes" xml:space="preserve">
          <source>Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt;. The default owner is the process that created the table. To transfer table ownership at process termination, use option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; or call &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블에 대한 자동 가비지 콜렉션이 없습니다. 프로세스에서 테이블에 대한 참조가 없더라도 소유자 프로세스가 종료되지 않으면 자동으로 소멸되지 않습니다. 테이블을 명시 적으로 제거하려면 &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 기본 소유자는 테이블을 생성 한 프로세스입니다. 프로세스 종료시 테이블 소유권을 이전하려면 옵션 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 사용 하거나 &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8bab5c018b3dd7779861d18a2de3b850779eed22" translate="yes" xml:space="preserve">
          <source>Notice that these results are highly implementation-specific and can change in a future release.</source>
          <target state="translated">이러한 결과는 구현에 따라 다르며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="869e22e1f3c3acbe1295f4e3f5e543c0967d43d9" translate="yes" xml:space="preserve">
          <source>Notice that these values are not guaranteed to be the exact time spent in each state. This is because of various optimisation done to keep the overhead as small as possible.</source>
          <target state="translated">이 값이 각 주에서 소비 된 정확한 시간임을 보장하지는 않습니다. 오버 헤드를 가능한 작게 유지하기 위해 다양한 최적화가 수행 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1b2a4c91cbe5e730d179e66ad334733cf9b2f315" translate="yes" xml:space="preserve">
          <source>Notice that this can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control).</source>
          <target state="translated">이 경우 발신자를 조절할 수있는 방법이 없으므로 (흐름 제어 없음) 메시지 대기열이 오버플로 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c845a0c39116c9a8667488291653cb120ecdb8" translate="yes" xml:space="preserve">
          <source>Notice that this code never uses &lt;code&gt;ets:match/2&lt;/code&gt; but instead uses the &lt;code&gt;ets:lookup/2&lt;/code&gt; call. The &lt;code&gt;lists:map/2&lt;/code&gt; call is only used to traverse the &lt;code&gt;idno&lt;/code&gt;s matching the name &quot;Bryan&quot; in the table; thus the number of lookups in the master table is minimized.</source>
          <target state="translated">이 코드는 &lt;code&gt;ets:match/2&lt;/code&gt; 를 사용하지 않고 대신 &lt;code&gt;ets:lookup/2&lt;/code&gt; 호출을 사용합니다. &lt;code&gt;lists:map/2&lt;/code&gt; 호출만을 통과하는 데 사용됩니다 &lt;code&gt;idno&lt;/code&gt; 의 표에 이름이 &quot;브라이언&quot;를 일치; 따라서 마스터 테이블의 조회 수가 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="642ed222441e7d274dce20239475afe796aa6f92" translate="yes" xml:space="preserve">
          <source>Notice that this does not in any way tell how characters are to be put on the I/O device or handled by the I/O server. Different I/O servers can handle the characters however they want, this only tells the I/O server which format the data is expected to have. In the &lt;code&gt;Module&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt;/&lt;code&gt;Args&lt;/code&gt; case, &lt;code&gt;Encoding&lt;/code&gt; tells which format the designated function produces.</source>
          <target state="translated">이것은 어떤 식 으로든 I / O 장치에 문자를 넣거나 I / O 서버에서 처리하는 방법을 나타내지 않습니다. 다른 I / O 서버는 원하는 문자를 처리 할 수 ​​있지만 이는 데이터가 어떤 형식으로 예상되는지 I / O 서버에만 알려줍니다. 에서 &lt;code&gt;Module&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; / &lt;code&gt;Args&lt;/code&gt; 경우, &lt;code&gt;Encoding&lt;/code&gt; 지정된 함수를 생성하는 포맷 말한다.</target>
        </trans-unit>
        <trans-unit id="349cea6fe5b002efa6f13c8a0b6d61002518bac7" translate="yes" xml:space="preserve">
          <source>Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section &lt;code&gt;Changing a Supervisor&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 기능은 코드 업그레이드 절차의 일부로 호출 될 수도 있습니다. 따라서이 기능은 부작용이 없어야합니다. 수퍼바이저의 코드 업그레이드에 대한 자세한 내용은 OTP 디자인 원칙에서 &lt;code&gt;Changing a Supervisor&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5a602977aaafafa43a23557b7310cdf92b1e9ad" translate="yes" xml:space="preserve">
          <source>Notice that this function does not affect option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; of the table. A table owner can, for example, set &lt;code&gt;heir&lt;/code&gt; to itself, give the table away, and then get it back if the receiver terminates.</source>
          <target state="translated">이 함수는 테이블의 옵션 &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; 에는 영향을 미치지 않습니다 . 예를 들어, 테이블 소유자는 &lt;code&gt;heir&lt;/code&gt; 를 자체로 설정 하고 테이블을 제공 한 다음 수신자가 종료되면 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb54426795679095e8a29fd043a79047773a14e" translate="yes" xml:space="preserve">
          <source>Notice that this function does not manipulate the Logger configuration directly, meaning that if the default Logger handler is already logging to a file, this function can potentially cause logging to a second file.</source>
          <target state="translated">이 함수는 로거 구성을 직접 조작하지 않습니다. 즉, 기본 로거 핸들러가 이미 파일에 로깅중인 경우이 기능으로 인해 두 번째 파일에 로깅이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7b1e720e05da028ebe3dc53213402e40544038" translate="yes" xml:space="preserve">
          <source>Notice that this function is &lt;strong&gt;not&lt;/strong&gt; thread-safe, not even when the emulator with SMP support is used.</source>
          <target state="translated">이 함수는 것을주의 &lt;strong&gt;하지&lt;/strong&gt; 스레드 안전은 SMP를 지원하는 에뮬레이터를 사용하지 경우에도.</target>
        </trans-unit>
        <trans-unit id="8447f5b25cdb8a2cfab1f25034c52ae944a2138b" translate="yes" xml:space="preserve">
          <source>Notice that this function is located in the &lt;code&gt;Erl_Interface&lt;/code&gt; library.</source>
          <target state="translated">이 함수는 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ba6495ef0d28a812199229a1ffda8befe21e10" translate="yes" xml:space="preserve">
          <source>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</source>
          <target state="translated">이 함수는 빈 스키마를 사용하여 새로 시작된 RAM 노드 (NDRSN)에 연결하는 데만 사용해야합니다. 예를 들어, 네트워크가 분할 된 후이 기능을 사용하면 테이블이 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0080e2dd941529f19011486ca16886c12b3f0d" translate="yes" xml:space="preserve">
          <source>Notice that this identifier on occations has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but to keep backward compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">occations에서이 식별자는 &quot;name&quot;이라고합니다. 가능한 한 &quot;식별자&quot;또는 &quot;id&quot;라는 용어가 사용되었지만 이전 버전과의 호환성을 유지하기 위해 오류 메시지에서 &quot;name&quot;이라는 일부 항목이 여전히 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d730d26eb5bc6c258ec3f4a85decab69ff65e557" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; equivalent to reversing the result list of a &lt;code&gt;select/3&lt;/code&gt; call, as the result list is not only reversed, but also contains the last &lt;code&gt;Limit&lt;/code&gt; matching objects in the table, not the first.</source>
          <target state="translated">이 것을주의 &lt;strong&gt;하지&lt;/strong&gt; a의 결과 목록 반전에 해당 &lt;code&gt;select/3&lt;/code&gt; 도 결과 목록은 반전되지 않기 때문에, 전화를하지만, 마지막 포함 &lt;code&gt;Limit&lt;/code&gt; , 첫 번째가 아닌 테이블에 일치하는 객체.</target>
        </trans-unit>
        <trans-unit id="70914725ae02a1a2e612f1b985dfda4ff43284f0" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.11.4.</source>
          <target state="translated">2.11.4 이전의 커널 버전에서는 이것이 보장 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7dcda89d0c9ebc603749979d693cfd0901ccfd8f" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.13.</source>
          <target state="translated">2.13 이전의 커널 버전에서는 이것이 보장 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ebcfa6b14e436143f912db1c4d94b897ad5c396b" translate="yes" xml:space="preserve">
          <source>Notice that this is a snapshot of what the entries are exactly when the crash dump is starting to be generated. Therefore they are most likely different (and more telling) than the entries for the same processes found in the &lt;strong&gt;=proc&lt;/strong&gt; section. If there is no currently running process, only the &lt;strong&gt;Current Process&lt;/strong&gt; entry is shown.</source>
          <target state="translated">이는 크래시 덤프가 생성되기 시작할 때 항목이 정확히 무엇인지에 대한 스냅 샷입니다. 따라서 그것들은 &lt;strong&gt;= proc&lt;/strong&gt; 섹션 에있는 동일한 프로세스에 대한 항목과 다를 수 있습니다. 현재 실행중인 프로세스가없는 경우 &lt;strong&gt;현재 프로세스&lt;/strong&gt; 항목 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6b5fe898d5908bd62ba390154dbda59785193315" translate="yes" xml:space="preserve">
          <source>Notice that this list was so long that it did not fit on one line. This does not matter, Erlang allows line breaks at all &quot;sensible places&quot; but not, for example, in the middle of atoms, integers, and others.</source>
          <target state="translated">이 목록은 너무 길어서 한 줄에 맞지 않습니다. 이것은 중요하지 않습니다. Erlang은 모든 &quot;감지 가능한 장소&quot;에서 줄 바꿈을 허용하지만 예를 들어 원자, 정수 등의 중간에서는 줄 바꿈을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bed5f26c2d951298be832ad680fbfcde5f6d0366" translate="yes" xml:space="preserve">
          <source>Notice that this only affects &lt;strong&gt;heuristic&lt;/strong&gt; interpretation of lists and binaries on output. For example, the &lt;code&gt;~ts&lt;/code&gt; format sequence always outputs a valid list of characters, regardless of the &lt;code&gt;+pc&lt;/code&gt; setting, as the programmer has explicitly requested string output.</source>
          <target state="translated">이는 출력에서 목록 및 이진의 &lt;strong&gt;휴리스틱&lt;/strong&gt; 해석 에만 영향을줍니다 . 예를 들어, &lt;code&gt;~ts&lt;/code&gt; 형식 순서 는 프로그래머가 명시 적으로 문자열 출력을 요청 &lt;code&gt;+pc&lt;/code&gt; 설정에 관계없이 항상 유효한 문자 목록을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="06bbb7eb9157769ac232caf919df5223a21c5714" translate="yes" xml:space="preserve">
          <source>Notice that this option does not change any guarantees about &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt;. Functions that makes such promises over many objects (like &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt;) gain less (or nothing) from this option.</source>
          <target state="translated">이 옵션은 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt; 에 대한 보증을 변경하지 않습니다 . &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; 와 같은 많은 객체에 대한 그러한 약속을 만드는 함수 는이 옵션에서 덜 얻거나 아무것도 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="621939df6e7634c47047d2e081590d78eaf11831" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a &quot;.&quot; saying that there are no more parts of this function.</source>
          <target state="translated">이 부분은 &quot;.&quot;로 끝납니다. 이 기능에는 더 이상 부분이 없다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="e6c419f8334737f0ba7bd3fd865a876302c62640" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a semicolon &quot;;&quot; that indicates that there is more of the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; to come.</source>
          <target state="translated">이 부분은 세미콜론 &quot;;&quot;으로 끝납니다. 이는 앞으로 더 많은 기능 &lt;code&gt;fac&amp;gt;&lt;/code&gt; 이 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="846082f1f38f9d35784642322c9bebfb5b6dff1c" translate="yes" xml:space="preserve">
          <source>Notice that this state diagram does not specify how to handle a button event in the state &lt;code&gt;open&lt;/code&gt;. So, you need to read in some side notes, that is, here: that unspecified events shall be postponed (handled in some later state). Also, the state diagram does not show that the &lt;code&gt;code_length/0&lt;/code&gt; call must be handled in every state.</source>
          <target state="translated">이 상태 다이어그램은 &lt;code&gt;open&lt;/code&gt; 상태에서 버튼 이벤트를 처리하는 방법을 지정하지 않습니다 . 따라서 몇 가지 참고 사항, 즉 여기에서 읽어야합니다. 지정되지 않은 이벤트는 연기됩니다 (나중에 처리). 또한 상태 다이어그램은 &lt;code&gt;code_length/0&lt;/code&gt; 호출이 모든 상태에서 처리되어야 한다는 것을 보여주지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6d7cfe9a38358e1080d2e905013781b2b4b7296d" translate="yes" xml:space="preserve">
          <source>Notice that type &lt;code&gt;ordered_set&lt;/code&gt; in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage.</source>
          <target state="translated">Ets에서 &lt;code&gt;ordered_set&lt;/code&gt; 유형 은 아직 Dets에서 제공하지 않으며, 고정 된 ETS 테이블에서 사용하기 위해 &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 호출 시퀀스를 안전하게 만드는 동시 업데이트에 대한 제한적인 지원도 아닙니다 . Erlang / OTP의 차기 릴리스에서 Dets가이 두 기능을 모두 제공 할 수 있습니다. 그때까지 안전한 동시성을 구현하려면 Mnesia 응용 프로그램 (또는 일부 사용자 구현 잠금 방법)을 사용해야합니다. 현재 Erlang / OTP 라이브러리는 주문 된 디스크 기반 용어 저장소를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49a7a915aea8e9d41179a8ea113e08f2ef1a2887" translate="yes" xml:space="preserve">
          <source>Notice that we only return data (with &lt;code&gt;driver_output&lt;/code&gt;) if there is an error here, otherwise we wait for the connection to be completed, in which case our &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">여기에 오류가있는 경우 데이터 ( &lt;code&gt;driver_output&lt;/code&gt; 포함 ) 만 반환합니다 . 그렇지 않으면 연결이 완료 될 때까지 기다립니다.이 경우 &lt;code&gt;ready_io&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ecb8672fadbd7174fe3603f747f5dd084a5c8a1f" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt; Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬 함수를 호출 할 때 암시 적 또는 정규화 된 함수 이름을 사용하는 데 차이가 있습니다. 후자는 항상 최신 버전의 모듈을 나타냅니다. &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading &lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt; Function Evaluation&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f51f3b121bba411146620bcda978e5f491550a29" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬 함수를 호출 할 때 내재적 또는 완전한 함수 이름을 사용하는 것에는 차이가 있습니다. 후자는 항상 최신 버전의 모듈을 나타냅니다. &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f8b34f22954b45969704565ba857ede0360296a" translate="yes" xml:space="preserve">
          <source>Notice that when changing the configuration of the handler in runtime, the disk_log options (&lt;code&gt;file&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;max_no_files&lt;/code&gt;, &lt;code&gt;max_no_bytes&lt;/code&gt;) must not be modified.</source>
          <target state="translated">런타임에서 핸들러 구성을 변경할 때 disk_log 옵션 ( &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;max_no_files&lt;/code&gt; , &lt;code&gt;max_no_bytes&lt;/code&gt; )을 수정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="290de7804d4ece9b07b182bd6263d67e874d7ab3" translate="yes" xml:space="preserve">
          <source>Notice that when manipulating the PLT, no warnings are emitted. To turn on warnings during (re)analysis of the PLT, use option &lt;code&gt;--get_warnings&lt;/code&gt;.</source>
          <target state="translated">PLT를 조작 할 때 경고가 발생하지 않습니다. PLT를 재분석하는 동안 경고를 설정하려면 &lt;code&gt;--get_warnings&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="45a6c9cf395e353cb2306cbfdb89cfe2d26435a1" translate="yes" xml:space="preserve">
          <source>Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a &lt;code&gt;hibernate&lt;/code&gt; request for the whole event manager to go into hibernation.</source>
          <target state="translated">여러 이벤트 핸들러가 호출되면 하나의 단일 이벤트 핸들러가 전체 이벤트 관리자가 최대 절전 모드로 전환하기위한 &lt;code&gt;hibernate&lt;/code&gt; 요청을 리턴하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="f33a5a292b9691e53af0ea35251a90bd5b70c0ab" translate="yes" xml:space="preserve">
          <source>Notice that when the restart strategy is &lt;code&gt;simple_one_for_one&lt;/code&gt;, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">재시작 전략이 &lt;code&gt;simple_one_for_one&lt;/code&gt; 인 경우 하위 스펙 목록은 하나의 하위 스펙 만있는 목록이어야합니다. (자식 지정 식별자는 무시됩니다.) 초기화 단계에서 자식 프로세스가 시작되지 않지만 &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 모든 자식이 동적으로 시작된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="9634bd19d38caf45acf63a0abbac721e5ae1181a" translate="yes" xml:space="preserve">
          <source>Notice that you do not have to worry about the order you assign values to the various parts of the records when you create it. The advantage of using records is that by placing their definitions in header files you can conveniently define interfaces that are easy to change. For example, if you want to add a new field to the record, you only have to change the code where the new field is used and not at every place the record is referred to. If you leave out a field when creating a record, it gets the value of the atom &lt;code&gt;undefined&lt;/code&gt;. (*manual*)</source>
          <target state="translated">레코드를 작성할 때 값을 레코드의 여러 부분에 지정하는 순서에 대해 걱정할 필요가 없습니다. 레코드를 사용하면 헤더 파일에 정의를 배치하여 변경하기 쉬운 인터페이스를 편리하게 정의 할 수 있다는 장점이 있습니다. 예를 들어, 레코드에 새 필드를 추가하려면 레코드가 참조되는 모든 위치가 아니라 새 필드가 사용되는 코드 만 변경하면됩니다. 레코드를 만들 때 필드를 제외하면 atom 값이 &lt;code&gt;undefined&lt;/code&gt; 로 설정 됩니다. (*설명서*)</target>
        </trans-unit>
        <trans-unit id="11459bdda73f31f4f445b7c1dd521d4fd85a0493" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator characters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of tokens.</source>
          <target state="translated">이 예에 표시된 것처럼 &lt;code&gt;String&lt;/code&gt; 에서 두 개 이상의 인접한 구분 기호 문자는 하나로 취급됩니다. 즉, 결과 토큰 목록에 빈 문자열이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5f78a295d4a14f6cc590b49dc6f1d0455cd3aab" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator graphemes clusters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; which returns empty strings.</source>
          <target state="translated">이 예제에서 볼 수 있듯이 &lt;code&gt;String&lt;/code&gt; 에서 두 개 이상의 인접한 구분자 그래 핀 클러스터는 하나로 취급됩니다. 즉, 결과 룩셈부르크 목록에 빈 문자열이 없습니다. 빈 문자열을 반환하는 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="400b0bdc7183dd864f7a333eda26b469890b40f9" translate="yes" xml:space="preserve">
          <source>Notice that, for example, using a string literal as in &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; 에서와 같이 문자열 리터럴을 사용하면 &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt; 구문 설탕입니다 .</target>
        </trans-unit>
        <trans-unit id="87029cbee6aaa0d9b300e7ad0b9486370e279d2c" translate="yes" xml:space="preserve">
          <source>Notice that, using the binary syntax in Erlang, the driver application can match the header directly from the binary, so the header can be put in the binary, and &lt;code&gt;hlen&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Erlang의 이진 구문을 사용하면 드라이버 응용 프로그램이 이진의 헤더를 직접 일치시킬 수 있으므로 이진에 헤더를 넣고 &lt;code&gt;hlen&lt;/code&gt; 을 &lt;code&gt;0&lt;/code&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7da0c41f09ad9eda092e8aa0b243d52520a156af" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;--&lt;/code&gt; delimiter in the second case.</source>
          <target state="translated">통지 &lt;code&gt;--&lt;/code&gt; 두 번째 경우에서 구분 기호를.</target>
        </trans-unit>
        <trans-unit id="0a1c8d08a9994e288f56b821c9bf285da6f45d73" translate="yes" xml:space="preserve">
          <source>Notice the following:</source>
          <target state="translated">다음을 주목하십시오 :</target>
        </trans-unit>
        <trans-unit id="d17e22e8a0b70553ac1713fc5aa1e39228341be7" translate="yes" xml:space="preserve">
          <source>Notice the introduction of decimals (floating point numbers) without any explanation. Hopefully you can cope with that.</source>
          <target state="translated">아무런 설명없이 소수 (부동 소수점 숫자)가 표시됩니다. 잘하면 당신은 그것에 대처할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b434bf92c1158275f129698bacaf4280054d4c1a" translate="yes" xml:space="preserve">
          <source>Notice the order, the &lt;code&gt;&lt;a href=&quot;uri_string#normalize-2&quot;&gt;uri_string:normalize(URIMap, [return_map])&lt;/a&gt;&lt;/code&gt; that we used many times in this user guide is a shortcut in the normalization process returning the intermediate datastructure, and allowing us to inspect and apply further decoding on the remaining percent-encoded triplets.</source>
          <target state="translated">순서, 통지 &lt;code&gt;&lt;a href=&quot;uri_string#normalize-2&quot;&gt;uri_string:normalize(URIMap, [return_map])&lt;/a&gt;&lt;/code&gt; 우리가 사용 설명서에 많은 시간을 사용하는 것이 상기 중간 자료 구조를 반환하고, 우리를 검사하고 percent- 나머지에 상기 디코딩을 적용 할 수 있도록 정규화 프로세스의 단축은 인코딩 된 세 쌍둥이.</target>
        </trans-unit>
        <trans-unit id="b22b470f990ba70d08ad30ea4441dbab4491e4f1" translate="yes" xml:space="preserve">
          <source>Notice the subtle difference between &lt;strong&gt;matching&lt;/strong&gt; and &lt;strong&gt;comparing equal&lt;/strong&gt;, which is demonstrated by table types &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;ordered_set&lt;/code&gt;:</source>
          <target state="translated">간의 미묘한 차이에 주목 &lt;strong&gt;매칭&lt;/strong&gt; 과 &lt;strong&gt;동일한 비교를&lt;/strong&gt; 테이블 형식에 의해 증명되고, &lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;ordered_set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e087413bca56723a464e980cdc7148c95c96c9f5" translate="yes" xml:space="preserve">
          <source>Notice the tags &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, which are used in the cover specification file and in the call to &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt;. The purpose of these is only to map the modules specified in the cover specification to the log directory specified in the call to the analyze function. The tag name has no meaning beyond this.</source>
          <target state="translated">표지 스펙 파일 및 &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt; 호출에서 사용되는 태그 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 를 확인하십시오 . 이것의 목적은 표지 스펙에 지정된 모듈을 분석 함수 호출에 지정된 로그 디렉토리에 맵핑하는 것입니다. 태그 이름은이 이상의 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7bb5bf565c03d21576042d149b51f71aca7f2ad7" translate="yes" xml:space="preserve">
          <source>Notice the use of brackets, the multiplication operator &quot;*&quot;, and the division operator &quot;/&quot;, as in normal arithmetic (see &lt;code&gt;Expressions&lt;/code&gt;).</source>
          <target state="translated">일반 산술에서와 같이 대괄호, 곱셈 연산자 &quot;*&quot;및 나누기 연산자 &quot;/&quot;가 사용됩니다 ( &lt;code&gt;Expressions&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1979d8b27f27698155a9b9f97c8dffec78cf1316" translate="yes" xml:space="preserve">
          <source>Notice there is no &quot;;&quot; before the &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">&quot;;&quot;가 없습니다. &lt;code&gt;end&lt;/code&gt; 전에 .</target>
        </trans-unit>
        <trans-unit id="b65c33941f0cec9bcc2027c063047fa6bab510b7" translate="yes" xml:space="preserve">
          <source>Notice, however, that the PCRE interpretation of \G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior.</source>
          <target state="translated">그러나 현재 일치의 시작 인 \ G의 PCRE 해석은 이전 일치의 끝으로 정의하는 Perl과 미묘하게 다릅니다. Perl에서는 이전에 일치 한 문자열이 비어있을 때 이것들이 다를 수 있습니다. PCRE는 한 번에 하나의 일치 만 수행하므로이 동작을 재현 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="741d95219191f3fd87708b3b502f3129d86f5b91" translate="yes" xml:space="preserve">
          <source>Notification Filters</source>
          <target state="translated">알림 필터</target>
        </trans-unit>
        <trans-unit id="0bc912e028896fb2120e68a26a7e2cec85b39064" translate="yes" xml:space="preserve">
          <source>Notification Sending</source>
          <target state="translated">알림 전송</target>
        </trans-unit>
        <trans-unit id="37be39660f9e3a6ee200e243af96a9c97d0d2344" translate="yes" xml:space="preserve">
          <source>Notifications are defined in SMIv1 with the TRAP-TYPE macro in the definition of an MIB (see RFC1215). The corresponding macro in SMIv2 is NOTIFICATION-TYPE. When an application decides to send a notification, it calls one of the following functions:</source>
          <target state="translated">알림은 MIB 정의에서 TRAP-TYPE 매크로를 사용하여 SMIv1에 정의됩니다 (RFC1215 참조). SMIv2의 해당 매크로는 NOTIFICATION-TYPE입니다. 응용 프로그램에서 알림을 보내려고하면 다음 기능 중 하나를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ac878d4197ecf46f67e006f7c94c70eec1e149de" translate="yes" xml:space="preserve">
          <source>Notifications/traps from an agent is delivered to the user that did the registration.</source>
          <target state="translated">에이전트의 알림 / 트랩이 등록을 수행 한 사용자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="317ade20c16481c20d662a3475f005419790a5e3" translate="yes" xml:space="preserve">
          <source>Notifies when the driver is reloaded (or loaded if loading is underway). It only makes sense to monitor drivers that are in the process of being loaded or reloaded. A future driver name for loading cannot be monitored. That only results in a &lt;code&gt;DOWN&lt;/code&gt; message sent immediately. Monitoring for loading is therefore most useful when triggered by function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;, where the monitor is created &lt;strong&gt;because&lt;/strong&gt; the driver is in such a pending state.</source>
          <target state="translated">드라이버가 다시로드되거나로드가 진행중인 경우로드됩니다. 로드 또는 재로드중인 드라이버를 모니터링하는 것이 좋습니다. 로드 할 향후 드라이버 이름은 모니터링 할 수 없습니다. 그러면 &lt;code&gt;DOWN&lt;/code&gt; 메시지 만 즉시 전송됩니다. 따라서로드 모니터링은 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 함수에 의해 트리거 될 때 가장 유용합니다 . 여기서 드라이버는 보류 상태에 &lt;strong&gt;있기 때문에&lt;/strong&gt; 모니터가 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="bb6282907337e9abaf6ab3833a675724d09d4658" translate="yes" xml:space="preserve">
          <source>Now &quot;Stack needed&quot; and &quot;Heap needed&quot; are in the same word.</source>
          <target state="translated">이제 &quot;스택 필요&quot;와 &quot;힙 필요&quot;가 같은 단어입니다.</target>
        </trans-unit>
        <trans-unit id="819549857bd0aea6faaa47a0d86a011bee67d2a5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;A&lt;/code&gt; has generated a digest and its own challenge. Those are sent together in a package to &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;A&lt;/code&gt; 는 다이제스트와 자체 도전을 생성했습니다. 그것들은 패키지로 &lt;code&gt;B&lt;/code&gt; 로 함께 보내집니다 :</target>
        </trans-unit>
        <trans-unit id="70500b06f7a8c7563bdbdac912b202c3e8bf3468" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex1:foo/1&lt;/code&gt; and &lt;code&gt;complex1:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following replies:</source>
          <target state="translated">이제 &lt;code&gt;complex1:foo/1&lt;/code&gt; 및 &lt;code&gt;complex1:bar/1&lt;/code&gt; 을 구현할 수 있습니다. 둘 다 &lt;code&gt;complex&lt;/code&gt; 프로세스에 메시지를 보내고 다음과 같은 응답을받습니다.</target>
        </trans-unit>
        <trans-unit id="afe7e60fc725dac4a8db204c6383ede32658e8ba" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex5:foo/1&lt;/code&gt; and &lt;code&gt;complex5:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following reply:</source>
          <target state="translated">이제 &lt;code&gt;complex5:foo/1&lt;/code&gt; 및 &lt;code&gt;complex5:bar/1&lt;/code&gt; 을 구현할 수 있습니다. 둘 다 &lt;code&gt;complex&lt;/code&gt; 프로세스에 메시지를 보내고 다음과 같은 응답을받습니다.</target>
        </trans-unit>
        <trans-unit id="1d972f3ac97809e6ef3b16135443e10b7f75eb60" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;format_temps(Rest)&lt;/code&gt; is called with the rest of the list as an argument. This way of doing things is similar to the loop constructs in other languages. (Yes, this is recursion, but do not let that worry you.) So the same &lt;code&gt;format_temps&lt;/code&gt; function is called again, this time &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; and the same procedure is repeated as before. This is done until the list becomes empty, that is [], which causes the first clause &lt;code&gt;format_temps([])&lt;/code&gt; to match. This simply returns (results in) the atom &lt;code&gt;ok&lt;/code&gt;, so the program ends.</source>
          <target state="translated">이제 &lt;code&gt;format_temps(Rest)&lt;/code&gt; 가 나머지 목록과 함께 인수로 호출됩니다. 이 작업 방식은 다른 언어의 루프 구문과 유사합니다. (예, 이것은 재귀이지만 걱정하지 마십시오.) 동일한 &lt;code&gt;format_temps&lt;/code&gt; 함수가 다시 호출됩니다. 이번에는 &lt;code&gt;City&lt;/code&gt; 가 &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; 값을 가져오고 이전과 동일한 절차가 반복됩니다. 이것은 목록이 비워 질 때까지, 즉 []이며, 이는 첫 번째 절 &lt;code&gt;format_temps([])&lt;/code&gt; 가 일치하게합니다. 이것은 단순히 atom &lt;code&gt;ok&lt;/code&gt; 를 리턴 (결과) 하므로 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f056c1e349914f861b0ec8d256143b66ef033fa2" translate="yes" xml:space="preserve">
          <source>Now Peter logs on at c1@bilbo:</source>
          <target state="translated">이제 Peter는 c1 @ bilbo에 로그온합니다.</target>
        </trans-unit>
        <trans-unit id="3ad12f32c3c04aabc045c91300983e1a4fd664c4" translate="yes" xml:space="preserve">
          <source>Now Peter sends Fred a message:</source>
          <target state="translated">이제 Peter는 Fred에게 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="229ad98b8db4a57370d88832d5c57bc6f3753fe1" translate="yes" xml:space="preserve">
          <source>Now a function has to be added to find the cities with the maximum and minimum temperatures. The following program is not the most efficient way of doing this as you walk through the list of cities four times. But it is better to first strive for clarity and correctness and to make programs efficient only if needed.</source>
          <target state="translated">이제 최대 및 최소 온도의 도시를 찾기위한 기능을 추가해야합니다. 다음 프로그램은 도시 목록을 네 번 걸을 때 가장 효율적인 방법은 아닙니다. 그러나 명확성과 정확성을 위해 먼저 노력하고 필요한 경우에만 프로그램을 효율적으로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b4bcc5baaf2e6bf86762a62f818283a767c38c4d" translate="yes" xml:space="preserve">
          <source>Now an &lt;code&gt;ETERM&lt;/code&gt; struct that represents the integer result can be constructed using the function &lt;code&gt;erl_mk_int()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;. The function &lt;code&gt;erl_format()&lt;/code&gt; from the module &lt;code&gt;erl_format&lt;/code&gt; can also be used:</source>
          <target state="translated">이제 &lt;code&gt;ETERM&lt;/code&gt; 의 정수 결과를 나타내는 구조체는 기능하여 구성 될 수 &lt;code&gt;erl_mk_int()&lt;/code&gt; 에서 &lt;code&gt;erl_eterm&lt;/code&gt; 를 . 함수 &lt;code&gt;erl_format()&lt;/code&gt; 모듈에서 &lt;code&gt;erl_format&lt;/code&gt; 가 또한 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="0d18575f2f97b95d7041b4a039a472881d09e334" translate="yes" xml:space="preserve">
          <source>Now an example of the ping pong example using links to terminate &quot;pong&quot;:</source>
          <target state="translated">이제 &quot;pong&quot;을 종료하기 위해 링크를 사용하는 핑퐁 예제의 예 :</target>
        </trans-unit>
        <trans-unit id="b5cee5cfc515b6296349cc8ee7e0cb8ec6901dca" translate="yes" xml:space="preserve">
          <source>Now an example of this when working with lists - reversing the order of a list:</source>
          <target state="translated">이제리스트로 작업 할 때리스트의 순서를 반대로 바꾸는 예가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="df7fd43be1dfcb89d9363916c80f74e8a91feb79" translate="yes" xml:space="preserve">
          <source>Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of calls. If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of calls (M1, M2) such that the interpretation of the expression contains a call from some function of M1 to some function of M2. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all function calls (F1, F2) such that the interpretation of the expression contains a call (M1, M2) and F1 is a function of M1 and F2 is a function of M2 (in &lt;code&gt;modules&lt;/code&gt; mode, there are no functions calls, so a cast to &lt;code&gt;Fun&lt;/code&gt; always yields an empty set). Again, the conversions to and from applications and releases work analogously.</source>
          <target state="translated">이제 &lt;code&gt;Expression&lt;/code&gt; 의 해석이 일련의 호출 이라고 가정 합니다. 명명 된 유형이 표현식 유형보다 일반인 경우 (예 : &lt;code&gt;Mod&lt;/code&gt; 및 &lt;code&gt;Fun&lt;/code&gt; ) , 캐스트 표현식의 해석은 호출 해석 (M1, M2)으로, 표현식 해석에 M1의 일부 함수의 호출이 포함됩니다. M2의 일부 기능에. 명명 된 유형이 표현식 유형보다 더 특수한 경우 ( &lt;code&gt;Fun&lt;/code&gt; 및 &lt;code&gt;Mod&lt;/code&gt; ) , 해석은 모든 함수 호출 (F1, F2)의 집합이므로 표현식 해석에는 호출 (M1, M2)이 포함되고 F1은 M1 및 F2의 함수는 M2의 함수입니다 ( &lt;code&gt;modules&lt;/code&gt; 모드에서는 함수 호출이 없으므로 캐스트 &lt;code&gt;Fun&lt;/code&gt; 항상 빈 세트를 산출합니다). 다시 말하지만, 응용 프로그램과 릴리스 간의 변환은 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d27e97cc64e73bbb29e8593d9319f121ee940fec" translate="yes" xml:space="preserve">
          <source>Now back to the ping pong example.</source>
          <target state="translated">이제 탁구 예제로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e1c4d378028d5d21080c935ee35d85591b2310e0" translate="yes" xml:space="preserve">
          <source>Now change directory into the base directory and set the &lt;code&gt;$ERL_TOP&lt;/code&gt; variable.</source>
          <target state="translated">이제 디렉토리를 기본 디렉토리로 변경하고 &lt;code&gt;$ERL_TOP&lt;/code&gt; 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8740487b8c6e4f56dfebcaaf8cf6bd3325bab300" translate="yes" xml:space="preserve">
          <source>Now for a larger example to consolidate what you have learnt so far. Assume that you have a list of temperature readings from a number of cities in the world. Some of them are in Celsius and some in Fahrenheit (as in the previous list). First let us convert them all to Celsius, then let us print the data neatly.</source>
          <target state="translated">지금까지 배운 내용을 통합하는 더 큰 예를 들어 보겠습니다. 세계 여러 도시의 온도 측정 값 목록이 있다고 가정합니다. 그들 중 일부는 섭씨에 있고 일부는 화씨에 있습니다 (이전 목록에서와 같이). 먼저 모두 섭씨로 변환 한 다음 데이터를 깔끔하게 인쇄하겠습니다.</target>
        </trans-unit>
        <trans-unit id="960dcce598e07679e1563922d8c8ce1be7e2353e" translate="yes" xml:space="preserve">
          <source>Now for a larger example with a simple &quot;messenger&quot;. The messenger is a program that allows users to log in on different nodes and send simple messages to each other.</source>
          <target state="translated">이제 간단한 &quot;메신저&quot;가있는 더 큰 예를 들어 보겠습니다. 메신저는 사용자가 다른 노드에 로그인하여 서로에게 간단한 메시지를 보낼 수있는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="8f9a8082924a3a55b208b60dc3c2a35c271485ed" translate="yes" xml:space="preserve">
          <source>Now for a more complicated example, the factorial of a number. For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</source>
          <target state="translated">더 복잡한 예를 들어, 숫자의 계승. 예를 들어, 계승 4는 4 * 3 * 2 * 1이며 24와 같습니다.</target>
        </trans-unit>
        <trans-unit id="85b87f3295c00771011c50c29b24763361547f32" translate="yes" xml:space="preserve">
          <source>Now let us get back to the cities and temperatures, but take a more structured approach this time. First let us convert the whole list to Celsius as follows:</source>
          <target state="translated">이제 도시와 온도로 돌아가 보도록하겠습니다. 이번에는보다 체계적인 접근 방식을 취하십시오. 먼저 다음과 같이 전체 목록을 섭씨로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f815262fb97682c5acd6fb931562748d09976dd2" translate="yes" xml:space="preserve">
          <source>Now let us get back to the first two lines of the code. Erlang programs are written in files. Each file contains an Erlang &lt;strong&gt;module&lt;/strong&gt;. The first line of code in the module is the module name (see &lt;code&gt;Modules&lt;/code&gt;):</source>
          <target state="translated">이제 코드의 처음 두 줄로 돌아가 봅시다. Erlang 프로그램은 파일로 작성됩니다. 각 파일에는 Erlang &lt;strong&gt;모듈이&lt;/strong&gt; 포함되어 있습니다 . 모듈의 첫 번째 코드 행은 모듈 이름입니다 ( &lt;code&gt;Modules&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0937bc21f5c355b7556a59cf5f4dbd1a5ec043f5" translate="yes" xml:space="preserve">
          <source>Now let us look at the process &quot;ping&quot;. Recall that it was started by executing:</source>
          <target state="translated">이제 &quot;ping&quot;프로세스를 보자. 다음을 실행하여 시작되었음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="6eddc3d3ff799bf232cc855fb7b548b211ee7ca5" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of &lt;code&gt;move_xx&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;move_xx&lt;/code&gt; 의 구현을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="73a7fa9dfcc333d467dd81b0a30c1df103da8ee8" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of the &lt;code&gt;move&lt;/code&gt; instruction. There are multiple files containing implementations of instructions in the &lt;code&gt;erts/emulator/beam&lt;/code&gt; directory. The &lt;code&gt;move&lt;/code&gt; instruction is defined in &lt;code&gt;instrs.tab&lt;/code&gt;. It looks like this:</source>
          <target state="translated">이제 &lt;code&gt;move&lt;/code&gt; 명령 의 구현을 살펴 보겠습니다 . &lt;code&gt;erts/emulator/beam&lt;/code&gt; 디렉토리 에는 명령어 구현이 포함 된 여러 파일이 있습니다 . &lt;code&gt;move&lt;/code&gt; 명령에 정의 &lt;code&gt;instrs.tab&lt;/code&gt; . 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="0930d4eadca76ecb3a8d6bfa6d074f842ec248fa" translate="yes" xml:space="preserve">
          <source>Now run the program:</source>
          <target state="translated">이제 프로그램을 실행하십시오 :</target>
        </trans-unit>
        <trans-unit id="7e848956566e548f1d9ae0d0b8013c74e6d83d3a" translate="yes" xml:space="preserve">
          <source>Now that we have defined the fragments, we need to inform &lt;strong&gt;beam_makeops&lt;/strong&gt; how they should be connected:</source>
          <target state="translated">이제 조각을 정의 &lt;strong&gt;했으므로 beam_makeops에&lt;/strong&gt; 연결 방법 을 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="55eb0e0626fb4ef4258288a934f71110a41abd31" translate="yes" xml:space="preserve">
          <source>Now the &quot;pong&quot; process on gollum is started:</source>
          <target state="translated">이제 골룸의 &quot;퐁&quot;프로세스가 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f18e66183fccf43dd04a3319e9abe480c44266d" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;relup&lt;/code&gt; file can be generated:</source>
          <target state="translated">이제 &lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="419ad4c19e6962a17e264cf0565e8680fba59965" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;tut2&lt;/code&gt; program is hardly good programming style. Consider:</source>
          <target state="translated">이제 &lt;code&gt;tut2&lt;/code&gt; 프로그램은 좋은 프로그래밍 스타일이 아닙니다. 치다:</target>
        </trans-unit>
        <trans-unit id="034e7984504e96eaaa52341007b573729c1bfa18" translate="yes" xml:space="preserve">
          <source>Now the C node can be initiated. If short node names are used, this is done by calling &lt;code&gt;erl_connect_init()&lt;/code&gt;:</source>
          <target state="translated">이제 C 노드를 시작할 수 있습니다. 짧은 노드 이름을 사용하는 경우 &lt;code&gt;erl_connect_init()&lt;/code&gt; 를 호출하여 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf6ba8b610923726e867dc5eac6994fcbdfa5a4" translate="yes" xml:space="preserve">
          <source>Now the C node server can accept connections from Erlang nodes:</source>
          <target state="translated">이제 C 노드 서버는 Erlang 노드의 연결을 수락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57b2ed1c1f99cc47795c85e2110f62964631a09" translate="yes" xml:space="preserve">
          <source>Now we can publish the structure in the table by writing the the pointer to the process structure in the slot previously reserved in 3.</source>
          <target state="translated">이제 이전에 3에서 예약 한 슬롯의 프로세스 구조에 대한 포인터를 작성하여 테이블에 구조를 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3630e70ae8e40d246b34002925292898bb67186e" translate="yes" xml:space="preserve">
          <source>Now we come to something more interesting:</source>
          <target state="translated">이제 우리는 더 흥미로운 것을 보게되었습니다 :</target>
        </trans-unit>
        <trans-unit id="790582ffcd379351fda4ad80a8805b29abc3d15b" translate="yes" xml:space="preserve">
          <source>Now we have a target system that can be started in various ways. We start it as a &lt;strong&gt;basic target system&lt;/strong&gt; by invoking:</source>
          <target state="translated">이제 다양한 방법으로 시작할 수있는 대상 시스템이 있습니다. 다음 을 호출 하여 &lt;strong&gt;기본 대상 시스템&lt;/strong&gt; 으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="07e2005a0a6deb7487edffb7259d4bbae161649b" translate="yes" xml:space="preserve">
          <source>Now we look at another interesting pseudo function, &lt;code&gt;garbage_collect&lt;/code&gt;:</source>
          <target state="translated">이제 또 다른 흥미로운 의사 함수 인 &lt;code&gt;garbage_collect&lt;/code&gt; 를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7baae9db7349907407d97b8497ef107b8eef0dbb" translate="yes" xml:space="preserve">
          <source>Now we want to read data from the table. Function &lt;code&gt;get_until/5&lt;/code&gt; reads data and applies the function until it says that it is done. The result is sent back to the client:</source>
          <target state="translated">이제 테이블에서 데이터를 읽고 싶습니다. 기능 &lt;code&gt;get_until/5&lt;/code&gt; 는 데이터를 읽고 그것이 완료 있다고 때까지 기능을 적용합니다. 결과는 클라이언트로 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="841ad6881ed808c0b00a3ce8e4425eac2fdd57ad" translate="yes" xml:space="preserve">
          <source>Now when the list is converted, a function to print it is added:</source>
          <target state="translated">이제 목록이 변환되면이를 인쇄하는 기능이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f946da2eb954f3f3431f7eaa1a17198b4a4bcad5" translate="yes" xml:space="preserve">
          <source>Now you are set up for some Unicode input and output. The simplest thing to do is to enter a string in the shell:</source>
          <target state="translated">이제 일부 유니 코드 입력 및 출력을 설정했습니다. 가장 간단한 방법은 쉘에 문자열을 입력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4101ddb4b1ba4c623fe01975aae255730951fb95" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; or &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt;.</source>
          <target state="translated">이제 쉘에 &lt;code&gt;type erlc&lt;/code&gt; 을 작성하여 사용중인 erlc를 확인할 수 있습니다 . 그것은에 있어야 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; 또는 &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd9b4b08ad2850cc0852933844bf5bbc09109e4" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;.</source>
          <target state="translated">이제 쉘에 &lt;code&gt;type erlc&lt;/code&gt; 을 작성하여 보유한 erlc를 확인할 수 있습니다 . 그것은에 있어야 &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6fd06da4ec350e2c1cd2afa53dc7213e2209fc9" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_21.exe&lt;/code&gt; or &lt;code&gt;otp_win64_21.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; 에 &lt;code&gt;otp_win32_21.exe&lt;/code&gt; 또는 &lt;code&gt;otp_win64_21.exe&lt;/code&gt; 파일이 있습니다 ( 예 : &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf27925b0551dd76b6d0908cbb333e95a400dac2" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_23.exe&lt;/code&gt; or &lt;code&gt;otp_win64_23.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; 에 &lt;code&gt;otp_win32_23.exe&lt;/code&gt; 또는 &lt;code&gt;otp_win64_23.exe&lt;/code&gt; 라는 파일이 있습니다. 즉 &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="716d0540851d08f95b750091b9b63ae2e0b978fa" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;fact(0)&lt;/code&gt; is called, and the function clauses are scanned sequentially again. First, the pattern &lt;code&gt;N&lt;/code&gt; is matched against 0. The matching succeeds, but the guard (&lt;code&gt;N&amp;gt;0&lt;/code&gt;) is false. Second, the pattern 0 is matched against 0. The matching succeeds and the body is evaluated:</source>
          <target state="translated">이제 &lt;code&gt;fact(0)&lt;/code&gt; 이 호출되고 함수 절이 순차적으로 다시 스캔됩니다. 먼저, 패턴 &lt;code&gt;N&lt;/code&gt; 이 0과 일치합니다. 일치는 성공하지만 가드 ( &lt;code&gt;N&amp;gt;0&lt;/code&gt; )는 false입니다. 둘째, 패턴 0이 0과 일치합니다. 일치가 성공하고 본문이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="98445b1d7f9952b03aea3c602d6261fd2d8aa394" translate="yes" xml:space="preserve">
          <source>Now, back to the example where we wanted to make the output more arranged. With the template:</source>
          <target state="translated">이제 출력을 더 정렬하려는 예제로 돌아갑니다. 템플릿으로 :</target>
        </trans-unit>
        <trans-unit id="0ccacd93bad121d635d3ee2cf04a4a93d66d91bb" translate="yes" xml:space="preserve">
          <source>Now, imagine that as &lt;code&gt;m1&lt;/code&gt; is a library module, it is also often used by system &lt;code&gt;s2&lt;/code&gt;. Test run &lt;code&gt;s2&lt;/code&gt; does not specifically test &lt;code&gt;m1&lt;/code&gt;, but it can still be interesting to see which parts of &lt;code&gt;m1&lt;/code&gt; that are covered by the &lt;code&gt;s2&lt;/code&gt; tests. To do this, &lt;code&gt;m1&lt;/code&gt; can be included also in the cover specification of &lt;code&gt;s2&lt;/code&gt; as follows:</source>
          <target state="translated">이제 &lt;code&gt;m1&lt;/code&gt; 이 라이브러리 모듈이므로 시스템 &lt;code&gt;s2&lt;/code&gt; 에서도 종종 사용 된다고 상상해보십시오 . 테스트 실행 &lt;code&gt;s2&lt;/code&gt; 는 &lt;code&gt;m1&lt;/code&gt; 을 구체적으로 테스트하지는 않지만 &lt;code&gt;s2&lt;/code&gt; 테스트에 포함되는 &lt;code&gt;m1&lt;/code&gt; 의 어떤 부분을 보는 것이 여전히 흥미로울 수 있습니다 . 이를 위해 &lt;code&gt;m1&lt;/code&gt; 은 다음과 같이 &lt;code&gt;s2&lt;/code&gt; 의 커버 사양에도 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33cc55d98c68e73ea0d743377235f62740c45f57" translate="yes" xml:space="preserve">
          <source>Now, such a call to &lt;code&gt;monitor&lt;/code&gt; will instead succeed and a monitor is created. But the monitor will only supervise the connection. That is, a &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; is the only message that may be received, as the primitive node have no way of reporting the status of the monitored process.</source>
          <target state="translated">이제 이러한 &lt;code&gt;monitor&lt;/code&gt; 호출이 성공하고 모니터가 작성됩니다. 그러나 모니터는 연결 만 감독합니다. 즉, 기본 노드가 모니터 된 프로세스의 상태를보고 할 방법이 없으므로 &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; 만이 수신 될 수있는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="815213b4b20368b41071811d96af96cae0ecf6af" translate="yes" xml:space="preserve">
          <source>Now, the fold and the map can be done at the same time:</source>
          <target state="translated">이제 접기와지도를 동시에 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd172c2b14d17bdd3e0bc285216399b7bf359fd" translate="yes" xml:space="preserve">
          <source>Nowadays, the compiler rewrites list comprehensions into an ordinary recursive function. Using a tail-recursive function with a reverse at the end would be still faster. Or would it? That leads us to the myth that tail-recursive functions are faster than body-recursive functions.</source>
          <target state="translated">오늘날 컴파일러는 목록 이해를 일반적인 재귀 함수로 다시 작성합니다. 끝에서 반대 방향으로 꼬리 재귀 함수를 사용하면 여전히 빠릅니다. 아니면? 그것은 꼬리 재귀 함수가 신체 재귀 함수보다 빠르다는 신화로 우리를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="b2b91a3dd3c62a3480c6550b4ca1758c4ca00cfd" translate="yes" xml:space="preserve">
          <source>Nullary callback function &lt;code&gt;PostFun&lt;/code&gt; is called once after the table was last read. The return value, which is caught, is ignored. If &lt;code&gt;PreFun&lt;/code&gt; has been called for a table, &lt;code&gt;PostFun&lt;/code&gt; is guaranteed to be called for that table, even if the evaluation of the query fails for some reason.</source>
          <target state="translated">테이블을 마지막으로 읽은 후 Nullary 콜백 함수 &lt;code&gt;PostFun&lt;/code&gt; 이 한 번 호출됩니다. 잡힌 리턴 값은 무시됩니다. 경우 &lt;code&gt;PreFun&lt;/code&gt; 이 테이블에 대해 호출 된, &lt;code&gt;PostFun&lt;/code&gt; 는 쿼리의 평가는 어떤 이유로 실패하는 경우에도, 해당 테이블에 대한 호출 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="e386a6937b577f217d46833120530e874cdb7e8a" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system (optional) You need this to build the self installing package.</source>
          <target state="translated">Nullsoft NSIS 설치 시스템 (선택 사항) 자체 설치 패키지를 빌드하려면이 시스템이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f11c0821f05eac62af0f028d86dc3849bfa606ca" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system. You need this to build the self installing package. It's a free open source installer that's much nicer to use than the commercial Wise and Install shield installers. This is the installer we use for commercial releases as well.</source>
          <target state="translated">Nullsoft NSIS 설치 시스템. 자체 설치 패키지를 빌드하려면 이것이 필요합니다. 상용 Wise and Install shield 설치 프로그램보다 사용하기 훨씬 좋은 무료 오픈 소스 설치 프로그램입니다. 이것은 상용 릴리스에도 사용되는 설치 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="576c424c360acfd1497ea21294f140f3cec38c19" translate="yes" xml:space="preserve">
          <source>Number ::= - same as non-negative Erlang integers -</source>
          <target state="translated">숫자 :: =-음이 아닌 Erlang 정수와 동일-</target>
        </trans-unit>
        <trans-unit id="b120174b0ca1d364c35e309340c2699137e93cf3" translate="yes" xml:space="preserve">
          <source>Number of Atoms</source>
          <target state="translated">원자 수</target>
        </trans-unit>
        <trans-unit id="436ff201e33fbebe2f89621894a2abd1c168a9b3" translate="yes" xml:space="preserve">
          <source>Number of acquisitions of this lock.</source>
          <target state="translated">이 잠금 획득 수</target>
        </trans-unit>
        <trans-unit id="156e52de6b6c52ca3695d88a4c555445a9d76e09" translate="yes" xml:space="preserve">
          <source>Number of arguments to a function or fun</source>
          <target state="translated">함수 또는 재미에 대한 인수 수</target>
        </trans-unit>
        <trans-unit id="5f360155f999f4bc86536b7ac3f8776370a01909" translate="yes" xml:space="preserve">
          <source>Number of bits may be divisible by 8, which means a binary decodable by &lt;code&gt;ei_decode_binary&lt;/code&gt; is also decodable by &lt;code&gt;ei_decode_bitstring&lt;/code&gt;.</source>
          <target state="translated">비트의 수에 의해 이진 디코딩 수단 (8)으로 나눌 수있다 &lt;code&gt;ei_decode_binary&lt;/code&gt; 은 또한 의해 복호 가능 &lt;code&gt;ei_decode_bitstring&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed917e86d9f18f03dbcccf6e65ab949d58ed88b7" translate="yes" xml:space="preserve">
          <source>Number of bytes received by the socket.</source>
          <target state="translated">소켓이 수신 한 바이트 수</target>
        </trans-unit>
        <trans-unit id="42046ff77420f4d17e7571e95bf522b706d2b214" translate="yes" xml:space="preserve">
          <source>Number of bytes sent from the socket.</source>
          <target state="translated">소켓에서 보낸 바이트 수</target>
        </trans-unit>
        <trans-unit id="2f05c7528a7c09c8ca7b40c3010abfa2c48aee95" translate="yes" xml:space="preserve">
          <source>Number of bytes waiting to be sent by the socket.</source>
          <target state="translated">소켓에서 전송 대기중인 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="abaddc1ab230437389138952dc901cca420ce997" translate="yes" xml:space="preserve">
          <source>Number of calls from exported functions.</source>
          <target state="translated">내 보낸 함수의 호출 수</target>
        </trans-unit>
        <trans-unit id="b6dc3a193a64eb663d8300e32005cd15708c2213" translate="yes" xml:space="preserve">
          <source>Number of collisions when a thread tried to acquire this lock. This is when a trylock is EBUSY, a write try on read held rw_lock, a try read on write held rw_lock, a thread tries to lock an already locked lock. (Internal states supervises this).</source>
          <target state="translated">스레드가이 잠금을 획득하려고 시도했을 때의 충돌 수 이것은 trylock이 EBUSY, 읽기 보류 rw_lock에 대한 쓰기 시도, 쓰기 보류 rw_lock에 대한 시도 읽기, 스레드가 이미 잠긴 잠금을 잠그려고 시도하는 경우입니다. (내부 국가가이를 감독합니다).</target>
        </trans-unit>
        <trans-unit id="b5befc3bf1ef58e74135162c0668ade7be2434a8" translate="yes" xml:space="preserve">
          <source>Number of data chunks pending receipt</source>
          <target state="translated">수신 보류중인 데이터 청크 수</target>
        </trans-unit>
        <trans-unit id="1788092af3b8a586296aa9df2406a866bfcd033f" translate="yes" xml:space="preserve">
          <source>Number of inbound streams</source>
          <target state="translated">인바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="0d39785385699f304d2bb821ff68b08bc05cf178" translate="yes" xml:space="preserve">
          <source>Number of lines (processes) to display.</source>
          <target state="translated">표시 할 라인 (프로세스) 수입니다.</target>
        </trans-unit>
        <trans-unit id="c7246b6b50502576f0a38d8a27451c68c1a94bf1" translate="yes" xml:space="preserve">
          <source>Number of links to the file (this is always 1 for file systems that have no concept of links).</source>
          <target state="translated">파일에 대한 링크 수 (링크 개념이없는 파일 시스템의 경우 항상 1 임)</target>
        </trans-unit>
        <trans-unit id="86b7d74929b08d37a5d6bbdc6ce558fa981b1e22" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an incoming DPR if the peer does not close the connection.</source>
          <target state="translated">피어가 연결을 닫지 않은 경우 들어오는 DPR 후에 전송 연결이 종료 된 후 경과 된 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="ad84b78a0ee803a8e44abc5c45068c551a8be685" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an outgoing DPR if DPA is not received.</source>
          <target state="translated">DPA가 수신되지 않은 경우 발신 DPR에 이어 전송 연결이 종료 된 후 경과 된 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="d143428966dbf2e9b35f53fde260f63542ea0ceb" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry. For a listening transport, the peer determines the timing.</source>
          <target state="translated">예상 된 기능 교환 메시지 (CER 또는 CEA)가 피어로부터 수신되지 않으면 전송 연결이 설정된 전송 프로세스가 종료 된 후의 시간 (밀리 초)입니다. 연결 전송의 경우 연결 시도 타이밍은 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; 만료 에 의해 결정됩니다 . 수신 전송의 경우 피어는 타이밍을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2a4f3d8f10ea95abb768e6ff37dcd2d263075314" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the request should timeout. Defaults to 5000.</source>
          <target state="translated">요청이 시간 초과되어야하는 시간 (밀리 초)입니다. 기본값은 5000입니다.</target>
        </trans-unit>
        <trans-unit id="4d5f53d55e482f8b255f961e8335b47ecc984cf9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to the value of &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DPA를받지 못한 경우 전송 프로세스가 종료 된 후 경과 된 시간 (밀리 초)입니다. 기본값은 &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b185f82b1b5bfaa8854d705b869060e9935cb3a" translate="yes" xml:space="preserve">
          <source>Number of milliseconds left until the message would have been sent.</source>
          <target state="translated">메시지가 전송 될 때까지 남은 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="1d3a9ba15cb753485b84a2ad953f8633c6b1bd33" translate="yes" xml:space="preserve">
          <source>Number of outbound streams</source>
          <target state="translated">아웃 바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="7cc577409a125b78cfe2310bff5b33c90e99d779" translate="yes" xml:space="preserve">
          <source>Number of packets received by the socket.</source>
          <target state="translated">소켓이 수신 한 패킷 수</target>
        </trans-unit>
        <trans-unit id="6cc46ab9febecbfd1c32816e8e1c042fb0b2037b" translate="yes" xml:space="preserve">
          <source>Number of packets sent from the socket.</source>
          <target state="translated">소켓에서 보낸 패킷 수</target>
        </trans-unit>
        <trans-unit id="0b905814d3355622795966fbb7336f35dc784aab" translate="yes" xml:space="preserve">
          <source>Number of transport processes to start. For a listening transport, determines the size of the pool of accepting transport processes, a larger number being desirable for processing multiple concurrent peer connection attempts. For a connecting transport, determines the number of connections to the peer in question that will be attempted to be establshed: the &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;restrict_connections&lt;/code&gt; should also be configured on the service in question to allow multiple connections to the same peer.</source>
          <target state="translated">시작할 전송 프로세스 수 수신 전송의 경우 전송 프로세스 허용 풀의 크기를 결정합니다. 다수의 동시 피어 연결 시도를 처리하는 데 더 많은 수가 바람직합니다. 연결 전송의 경우, 재설정하려는 해당 피어에 대한 연결 수를 판별하십시오 . 동일한 피어에 대한 다중 연결을 허용하려면 해당 서비스에서 &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;restrict_connections&lt;/code&gt; 도 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="66bc96661d8742ae05329a683dcb3f84683507cc" translate="yes" xml:space="preserve">
          <source>Number of unacked data chunks</source>
          <target state="translated">언락 된 데이터 청크 수</target>
        </trans-unit>
        <trans-unit id="0b1af9772e5bb4a2a3309eeb320fd315552f0cb5" translate="yes" xml:space="preserve">
          <source>NumberOfAtomCacheRefs/2+1 | 0</source>
          <target state="translated">NumberOfAtomCacheRefs / 2 + 1 | 0</target>
        </trans-unit>
        <trans-unit id="8e1b0dd3b8942a6f418c72794efaf599fa638602" translate="yes" xml:space="preserve">
          <source>Numbers are generated in batches and cached for speed reasons. The cache size can be changed from its default value using the &lt;code&gt; crypto app's &lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">숫자는 배치로 생성되고 속도를 위해 캐시됩니다. 캐시 크기는 &lt;code&gt; crypto app's &lt;/code&gt; 구성 매개 변수 &lt;code&gt;rand_cache_size&lt;/code&gt; 를 사용하여 기본값에서 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="742119a1b0ee0bffbdb7123efbae98b4d4cf4508" translate="yes" xml:space="preserve">
          <source>ODBC Data Type</source>
          <target state="translated">ODBC 데이터 타입</target>
        </trans-unit>
        <trans-unit id="a10c3f25c81a857c7ec7c54210e6931745d9810e" translate="yes" xml:space="preserve">
          <source>OPTIONAL</source>
          <target state="translated">OPTIONAL</target>
        </trans-unit>
        <trans-unit id="7025579510c04aa01d4607a0e0aca5cbec9f5502" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의 된 경우 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; 도 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fe255781a97feef0174934e6b7b818e19746a2b3" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="6aa8960d1405b5237c6590a23f7510a292a61f98" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;Module:end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의 된 경우 &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;Module:end_per_suite/1&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7020f99e2ebb79e7dec7703e4dde7e6f7d3ab62" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="178a184607add52e5bb5d680a1449c26c616fc56" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt; Module:end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의 된 경우 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt; Module:end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 도 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cb2b3bf247d98944fbe75b41c4379902fac4c0ed" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="01588880c00f5e2abc030e7f6d3e755195174bd7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의 된 경우 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; 도 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="811daf24de9dd5fef2b06f207387f6fa44818576" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="7438774d77f88e98fd2822354fa0458e5289e97d" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의 된 경우 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="09f3a1ee83f65c6b4212698c759ac143edb39e85" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="0552e661b2ea6fc224f8f95384fb27a6c1bfc0f7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt; Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의 된 경우 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt; Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 도 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="da40ab1589249e13637d8f194c28172da2bf88bf" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">선택 과목; 이 함수가 정의되면 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ff70d59339a0ed84894894c61d1c1f2ef4d4e9" translate="yes" xml:space="preserve">
          <source>OS Monotonic Time</source>
          <target state="translated">OS 단조로운 시간</target>
        </trans-unit>
        <trans-unit id="b6942daa3866fbe3e050507e50fbe84fe8347bcc" translate="yes" xml:space="preserve">
          <source>OS System Time</source>
          <target state="translated">OS 시스템 시간</target>
        </trans-unit>
        <trans-unit id="34d5721686b9afbeb78f01e3fc667ce57e89931f" translate="yes" xml:space="preserve">
          <source>OS X (Darwin)</source>
          <target state="translated">OS X (다윈)</target>
        </trans-unit>
        <trans-unit id="70a99f3723b01cca80b99d24bb0c2a412b59bf1d" translate="yes" xml:space="preserve">
          <source>OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion and probably newer versions.</source>
          <target state="translated">OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion 및 아마도 최신 버전 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="337dc1124caacdd89c2450e56842d52c3f0e6fad" translate="yes" xml:space="preserve">
          <source>OS X/Darwin: Darwin 9.8.0 in 32-bit mode should work.</source>
          <target state="translated">OS X / Darwin : 32 비트 모드의 Darwin 9.8.0이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="164a0c0837ae1b007b5e17a0056a34ade5f8ce3b" translate="yes" xml:space="preserve">
          <source>OS messages are formatted as a tuple &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt;:</source>
          <target state="translated">OS 메시지는 튜플 &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a67749980ef635fc8a670abb9e6fe74b4789978f" translate="yes" xml:space="preserve">
          <source>OS standard client and Erlang daemon (server)</source>
          <target state="translated">OS 표준 클라이언트 및 Erlang 데몬 (서버)</target>
        </trans-unit>
        <trans-unit id="1d1d16f43b9dc83cb0dfdf26c6b908a0323be7d3" translate="yes" xml:space="preserve">
          <source>OS system time can also be retreived by &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt; 로 OS 시스템 시간을 검색 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="253b34ed7414f8bd95bdcad3ec3b4eb61f4c6738" translate="yes" xml:space="preserve">
          <source>OS system time must be correct when the user finalizes the time offset.</source>
          <target state="translated">사용자가 시간 오프셋을 완료하면 OS 시스템 시간이 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a1aec662bcb7daef4aac0bdc11df31e66bf2d12" translate="yes" xml:space="preserve">
          <source>OTP 17.0</source>
          <target state="translated">OTP 17.0</target>
        </trans-unit>
        <trans-unit id="de82a1d6e138a112b2ca58f2dba4eb38c8d2b810" translate="yes" xml:space="preserve">
          <source>OTP 17.1</source>
          <target state="translated">OTP 17.1</target>
        </trans-unit>
        <trans-unit id="b37bb2cd4f43310f6b07a381a40baa26e515175a" translate="yes" xml:space="preserve">
          <source>OTP 17.1.2</source>
          <target state="translated">OTP 17.1.2</target>
        </trans-unit>
        <trans-unit id="7e91f185f69a2ee4d0fbc84adbe27a2af2afdba2" translate="yes" xml:space="preserve">
          <source>OTP 17.3</source>
          <target state="translated">OTP 17.3</target>
        </trans-unit>
        <trans-unit id="5349cafd1d20ce8426e0b816e9c62b481bf800e1" translate="yes" xml:space="preserve">
          <source>OTP 17.4</source>
          <target state="translated">OTP 17.4</target>
        </trans-unit>
        <trans-unit id="b7470cc6ea6636b34aed5c1b324e72d549188877" translate="yes" xml:space="preserve">
          <source>OTP 17.5</source>
          <target state="translated">OTP 17.5</target>
        </trans-unit>
        <trans-unit id="303ea13a1fd386fe9f485b047ad9fbdd6c02040e" translate="yes" xml:space="preserve">
          <source>OTP 17.5.3</source>
          <target state="translated">OTP 17.5.3</target>
        </trans-unit>
        <trans-unit id="43fb89bd5f06bbf79eb565ca69b6861d91f7db23" translate="yes" xml:space="preserve">
          <source>OTP 17.5.6</source>
          <target state="translated">OTP 17.5.6</target>
        </trans-unit>
        <trans-unit id="a80c6f60adc5b870c25fb7c1013052f9d969c1e6" translate="yes" xml:space="preserve">
          <source>OTP 18.0</source>
          <target state="translated">OTP 18.0</target>
        </trans-unit>
        <trans-unit id="5fb7af0c267d730fc45b68514cdc898b04ecd498" translate="yes" xml:space="preserve">
          <source>OTP 18.1</source>
          <target state="translated">OTP 18.1</target>
        </trans-unit>
        <trans-unit id="17bc05cb3765c17f769bcb5b7fb96b731b1c3725" translate="yes" xml:space="preserve">
          <source>OTP 18.1.1</source>
          <target state="translated">OTP 18.1.1</target>
        </trans-unit>
        <trans-unit id="3dd3b841b2d92c0b1abf38595d7acccf3845a2fa" translate="yes" xml:space="preserve">
          <source>OTP 18.2</source>
          <target state="translated">OTP 18.2</target>
        </trans-unit>
        <trans-unit id="bcc6e46df551f13559fc03eedfe953522eb1359b" translate="yes" xml:space="preserve">
          <source>OTP 18.3</source>
          <target state="translated">OTP 18.3</target>
        </trans-unit>
        <trans-unit id="f79c51896e23a1d1a678491db0ebaac921c06655" translate="yes" xml:space="preserve">
          <source>OTP 18.3.3</source>
          <target state="translated">OTP 18.3.3</target>
        </trans-unit>
        <trans-unit id="fda7846ff22cbff28cabbc39495e00ce1b7a18c2" translate="yes" xml:space="preserve">
          <source>OTP 19.0</source>
          <target state="translated">OTP 19.0</target>
        </trans-unit>
        <trans-unit id="932d95768670e0cd5fdbc1095ed0d1b993a8b2d9" translate="yes" xml:space="preserve">
          <source>OTP 19.1</source>
          <target state="translated">OTP 19.1</target>
        </trans-unit>
        <trans-unit id="05083dc18d014647306ef002a92e31b47deb28fc" translate="yes" xml:space="preserve">
          <source>OTP 19.2</source>
          <target state="translated">OTP 19.2</target>
        </trans-unit>
        <trans-unit id="ae471f5364f5af28f7619f0b3d347819f821f34c" translate="yes" xml:space="preserve">
          <source>OTP 19.3</source>
          <target state="translated">OTP 19.3</target>
        </trans-unit>
        <trans-unit id="2dfa396d52da21e038d97a4ee414f99969525781" translate="yes" xml:space="preserve">
          <source>OTP 20.0</source>
          <target state="translated">OTP 20.0</target>
        </trans-unit>
        <trans-unit id="3c37e3f1567db3d2ab061a53dad37370ec3d4a22" translate="yes" xml:space="preserve">
          <source>OTP 20.1</source>
          <target state="translated">OTP 20.1</target>
        </trans-unit>
        <trans-unit id="85f3a32e48ff7a1dda6db9c262b2f8cbf4924dab" translate="yes" xml:space="preserve">
          <source>OTP 20.1.3</source>
          <target state="translated">OTP 20.1.3</target>
        </trans-unit>
        <trans-unit id="3d1ec79e85f251b1426541568df1755b478c8f13" translate="yes" xml:space="preserve">
          <source>OTP 20.2</source>
          <target state="translated">OTP 20.2</target>
        </trans-unit>
        <trans-unit id="571eb6245a94eb851a6d7f90f3a8e74e0ae0d599" translate="yes" xml:space="preserve">
          <source>OTP 20.2.3</source>
          <target state="translated">OTP 20.2.3</target>
        </trans-unit>
        <trans-unit id="e7e47bfe8e3a87617385f6f0d76f42d53dc879d6" translate="yes" xml:space="preserve">
          <source>OTP 20.3</source>
          <target state="translated">OTP 20.3</target>
        </trans-unit>
        <trans-unit id="c00961db21191f2944a9b797a6cdbf961bf46d33" translate="yes" xml:space="preserve">
          <source>OTP 21.0</source>
          <target state="translated">OTP 21.0</target>
        </trans-unit>
        <trans-unit id="cb5be130ed3c502555d8f25e673de0b9efaa0941" translate="yes" xml:space="preserve">
          <source>OTP 21.0.6</source>
          <target state="translated">OTP 21.0.6</target>
        </trans-unit>
        <trans-unit id="6021644865848073f992bae8b9c943c4afc7f8d3" translate="yes" xml:space="preserve">
          <source>OTP 21.1</source>
          <target state="translated">OTP 21.1</target>
        </trans-unit>
        <trans-unit id="89bbe1165ae35f17f43e710bfcffbe55c6ef69a2" translate="yes" xml:space="preserve">
          <source>OTP 21.2</source>
          <target state="translated">OTP 21.2</target>
        </trans-unit>
        <trans-unit id="c2e689e6310bfe6136b48d902e26821ce9f123a9" translate="yes" xml:space="preserve">
          <source>OTP 21.3</source>
          <target state="translated">OTP 21.3</target>
        </trans-unit>
        <trans-unit id="1028e9221844cfd633f1eb008eaabcd781d51f96" translate="yes" xml:space="preserve">
          <source>OTP 21.3.8</source>
          <target state="translated">OTP 21.3.8</target>
        </trans-unit>
        <trans-unit id="c232413f3213891452a5c261023c072ccd809791" translate="yes" xml:space="preserve">
          <source>OTP 22.0</source>
          <target state="translated">OTP 22.0</target>
        </trans-unit>
        <trans-unit id="f48773e8bb6bc4865bc681e3589d114b4e76b24a" translate="yes" xml:space="preserve">
          <source>OTP 22.1</source>
          <target state="translated">OTP 22.1</target>
        </trans-unit>
        <trans-unit id="91df35b0c49a83fd12aa5367b8122925620295d9" translate="yes" xml:space="preserve">
          <source>OTP 22.3</source>
          <target state="translated">OTP 22.3</target>
        </trans-unit>
        <trans-unit id="d2e767c5320fed5f340e4813fb7b81851515b9db" translate="yes" xml:space="preserve">
          <source>OTP 23.0</source>
          <target state="translated">OTP 23.0</target>
        </trans-unit>
        <trans-unit id="645ad46075735cc44ee0b79de93dee14343f8e64" translate="yes" xml:space="preserve">
          <source>OTP 23.1</source>
          <target state="translated">OTP 23.1</target>
        </trans-unit>
        <trans-unit id="2c7aca3e13ec5787bed988186babbcbbb08e4d83" translate="yes" xml:space="preserve">
          <source>OTP 23.2</source>
          <target state="translated">OTP 23.2</target>
        </trans-unit>
        <trans-unit id="5c5cb3c43764b6e3642d0cc6e9870ab0a059e023" translate="yes" xml:space="preserve">
          <source>OTP R13B04</source>
          <target state="translated">OTP R13B04</target>
        </trans-unit>
        <trans-unit id="12c6138485cd68240ee15c2a9a5be15cfec50775" translate="yes" xml:space="preserve">
          <source>OTP R14B</source>
          <target state="translated">OTP R14B</target>
        </trans-unit>
        <trans-unit id="5b1b5b8bc61568f039950359e0853f2bf506f077" translate="yes" xml:space="preserve">
          <source>OTP R14B01</source>
          <target state="translated">OTP R14B01</target>
        </trans-unit>
        <trans-unit id="d2068218ce2ddac80161a50fcee5791fada3771a" translate="yes" xml:space="preserve">
          <source>OTP R14B02</source>
          <target state="translated">OTP R14B02</target>
        </trans-unit>
        <trans-unit id="3f9beac3fef36e94cdbe62f62d9631b02ce56c0c" translate="yes" xml:space="preserve">
          <source>OTP R14B03</source>
          <target state="translated">OTP R14B03</target>
        </trans-unit>
        <trans-unit id="da2cafa05f322e10fce6e2a71d88c24e3384148b" translate="yes" xml:space="preserve">
          <source>OTP R14B04</source>
          <target state="translated">OTP R14B04</target>
        </trans-unit>
        <trans-unit id="8c661581e56206ae5fffaf6b280a8cebf6df8545" translate="yes" xml:space="preserve">
          <source>OTP R15B</source>
          <target state="translated">OTP R15B</target>
        </trans-unit>
        <trans-unit id="9de524763778e0a0702eb821d76e1813ba58749a" translate="yes" xml:space="preserve">
          <source>OTP R15B01</source>
          <target state="translated">OTP R15B01</target>
        </trans-unit>
        <trans-unit id="af10a49ebba90d9d20eaf701836dad0d8942390f" translate="yes" xml:space="preserve">
          <source>OTP R15B02</source>
          <target state="translated">OTP R15B02</target>
        </trans-unit>
        <trans-unit id="927bd5757ada2536880868ac83237b0ba7d7267a" translate="yes" xml:space="preserve">
          <source>OTP R15B03</source>
          <target state="translated">OTP R15B03</target>
        </trans-unit>
        <trans-unit id="42d49d7f1b267727894067d4e17bd61989d7f900" translate="yes" xml:space="preserve">
          <source>OTP R16B</source>
          <target state="translated">OTP R16B</target>
        </trans-unit>
        <trans-unit id="5cf5721a7a707f5795c8ede7966ac925475590f0" translate="yes" xml:space="preserve">
          <source>OTP R16B01</source>
          <target state="translated">OTP R16B01</target>
        </trans-unit>
        <trans-unit id="99a6f83de13304461ed514ae1410a25c30bef92f" translate="yes" xml:space="preserve">
          <source>OTP R16B02</source>
          <target state="translated">OTP R16B02</target>
        </trans-unit>
        <trans-unit id="72498ce41f5658d95091b6ea2350ae21b5605581" translate="yes" xml:space="preserve">
          <source>OTP R16B03</source>
          <target state="translated">OTP R16B03</target>
        </trans-unit>
        <trans-unit id="8d85f4d55d00adcbdf0c015b765c1dbf0415d274" translate="yes" xml:space="preserve">
          <source>OTP Versions Table</source>
          <target state="translated">OTP 버전 표</target>
        </trans-unit>
        <trans-unit id="eb8e226d4cd37fd7c5b423ed6b5c26f687955027" translate="yes" xml:space="preserve">
          <source>OTP also supports changing the internal state of behaviour processes, see &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTP는 또한 내부 동작 프로세스 상태 변경을 지원합니다 (내부 상태 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4d6221b6a86032737a577d124bf2adb0a2907b66" translate="yes" xml:space="preserve">
          <source>OTP and (in consequence) the Mnesia database.</source>
          <target state="translated">OTP 및 결과적으로 Mnesia 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="a850f204ff4cd54ef41e013bea894026258c1347" translate="yes" xml:space="preserve">
          <source>OTP application Config</source>
          <target state="translated">OTP 애플리케이션 구성</target>
        </trans-unit>
        <trans-unit id="8f1f0506b65365d10c75cb9d39c0d18910b4731c" translate="yes" xml:space="preserve">
          <source>OTP of a specific version is a set of applications of specific versions. The application versions identified by an OTP version corresponds to application versions that have been tested together by the Erlang/OTP team at Ericsson AB. An OTP system can, however, be put together with applications from different OTP versions. Such a combination of application versions has not been tested by the Erlang/OTP team. It is therefore &lt;strong&gt;always preferred to use OTP applications from one single OTP version&lt;/strong&gt;.</source>
          <target state="translated">특정 버전의 OTP는 특정 버전의 응용 프로그램 집합입니다. OTP 버전으로 식별 된 응용 프로그램 버전은 Ericsson AB의 Erlang / OTP 팀이 함께 테스트 한 응용 프로그램 버전에 해당합니다. 그러나 OTP 시스템은 다른 OTP 버전의 응용 프로그램과 함께 사용할 수 있습니다. 이러한 응용 프로그램 버전 조합은 Erlang / OTP 팀에서 테스트하지 않았습니다. 따라서 &lt;strong&gt;항상 하나의 단일 OTP 버전에서 OTP 응용 프로그램을 사용하는 것이 좋습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2611693947bb5144c4c4a537a229fe14dfc567db" translate="yes" xml:space="preserve">
          <source>OTP start script example for Unix.</source>
          <target state="translated">유닉스 용 OTP 시작 스크립트 예제.</target>
        </trans-unit>
        <trans-unit id="44ed97d7d2bc021f13ae4421351ee910df8ab6f2" translate="yes" xml:space="preserve">
          <source>OTP supports a set of &lt;strong&gt;release handling instructions&lt;/strong&gt; that are used when creating &lt;code&gt;.appup&lt;/code&gt; files. The release handler understands a subset of these, the &lt;strong&gt;low-level&lt;/strong&gt; instructions. To make it easier for the user, there are also a number of &lt;strong&gt;high-level&lt;/strong&gt; instructions, which are translated to low-level instructions by &lt;code&gt;systools:make_relup&lt;/code&gt;.</source>
          <target state="translated">OTP는 &lt;code&gt;.appup&lt;/code&gt; 파일을 만들 때 사용되는 일련의 &lt;strong&gt;릴리스 처리 지침&lt;/strong&gt; 을 지원 합니다. 릴리스 핸들러는 하위 &lt;strong&gt;레벨&lt;/strong&gt; 명령어 인 이러한 하위 세트를 이해합니다 . 사용자가 쉽게 사용할 수 있도록 &lt;code&gt;systools:make_relup&lt;/code&gt; 에 의해 하위 수준의 명령어로 번역되는 여러 가지 &lt;strong&gt;고급 수준의&lt;/strong&gt; 명령어도 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ab311b5a61d5450520dde937fd634cbc9976caf" translate="yes" xml:space="preserve">
          <source>OTP thus provides no support for changing residence modules except in the case of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">따라서 OTP는 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt; 의 경우를 제외하고 거주 모듈 변경을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ad15f1b38f41249c946792c972d910fa729db9d3" translate="yes" xml:space="preserve">
          <source>OTP-22 introduces support for TLS 1.3. The current implementation supports a selective set of cryptographic algorithms:</source>
          <target state="translated">OTP-22는 TLS 1.3을 지원합니다. 현재 구현은 선택적 암호화 알고리즘 세트를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d96fc983a2c3eaec3d8d2f2620f536bca0494a75" translate="yes" xml:space="preserve">
          <source>OTP-22.0</source>
          <target state="translated">OTP-22.0</target>
        </trans-unit>
        <trans-unit id="e91f35ba89b72bce378114917c30a606df1775f6" translate="yes" xml:space="preserve">
          <source>OTP-23</source>
          <target state="translated">OTP-23</target>
        </trans-unit>
        <trans-unit id="7a931e0d87dd0cc978b0822251977a0aacd4fc45" translate="yes" xml:space="preserve">
          <source>OTP-SNMPEA-MIB</source>
          <target state="translated">OTP-SNMPEA-MIB</target>
        </trans-unit>
        <trans-unit id="15c4e1f1a4334a82cc1247671dd99e92e6bbd166" translate="yes" xml:space="preserve">
          <source>OTP/Crypto requires that the user provides two or three items of information about the key. The application used by the user is usually on a higher level, for example in &lt;code&gt;SSL&lt;/code&gt;. If using the crypto application directly, it is required that:</source>
          <target state="translated">OTP / Crypto에서는 사용자가 키에 대한 두세 가지 정보 항목을 제공해야합니다. 사용자가 사용하는 응용 프로그램은 일반적으로 &lt;code&gt;SSL&lt;/code&gt; 과 같이 더 높은 수준에 있습니다. 암호화 애플리케이션을 직접 사용하는 경우 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e00f6c999c0a17c02e9b5c79025ff5ac5261cb4a" translate="yes" xml:space="preserve">
          <source>Object identifier, a tuple of integers as generated by the &lt;code&gt;ASN.1&lt;/code&gt; compiler.</source>
          <target state="translated">&lt;code&gt;ASN.1&lt;/code&gt; 컴파일러에 의해 생성 된 정수의 터플 인 객체 식별자 .</target>
        </trans-unit>
        <trans-unit id="d389e1fd4f8140b1a2e4262dca91df97551e6b3f" translate="yes" xml:space="preserve">
          <source>Object-based programming with &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 를 사용한 객체 기반 프로그래밍</target>
        </trans-unit>
        <trans-unit id="e9756e31b402ef2beef3722149ad80b87a0cb1c1" translate="yes" xml:space="preserve">
          <source>Objects are stored and retrieved through set and get functions. The following example shows how to store integers, floats, strings, and arbitrary binary objects:</source>
          <target state="translated">객체는 set 및 get 함수를 통해 저장 및 검색됩니다. 다음 예제는 정수, 부동 소수점, 문자열 및 임의의 이진 객체를 저장하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="13dfd2b8ca88ce5b44fe927b518926c1e0325e95" translate="yes" xml:space="preserve">
          <source>Objects can be removed from the registry:</source>
          <target state="translated">레지스트리에서 객체를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5b9dd639a75a9d87bd4d53f043c544fbedd0e4c" translate="yes" xml:space="preserve">
          <source>Observe that E2 may differ from E if for instance there are default values defined in &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt; 에 기본값이 정의되어 있으면 E2가 E와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb56c5f19fbe9c5d32b08c312c11052dd5b634b7" translate="yes" xml:space="preserve">
          <source>Observe that the 'TerminationId' record is not used in the internal form. It has been replaced with a megaco_term_id record (defined in &quot;megaco/include/megaco.hrl&quot;).</source>
          <target state="translated">'TerminationId'레코드가 내부 형식으로 사용되지 않는지 확인하십시오. &quot;megaco / include / megaco.hrl&quot;에 정의 된 megaco_term_id 레코드로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="0bd7b307bc7f8afe70fed7a42de3d9fbb7b82fbb" translate="yes" xml:space="preserve">
          <source>Observe that white space: each space, tab or line feed, between mark-up results in an xmlText record.</source>
          <target state="translated">xmlText 레코드의 마크 업 결과 사이의 공백, 탭 또는 줄 바꿈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="92d3bdde80720a307b847a6b8a1080bcd444b6aa" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables and contains a front end for Erlang tracing.</source>
          <target state="translated">관찰자는 Erlang 시스템의 특성을 관찰하기위한 그래픽 도구입니다. Observer는 시스템 정보, 응용 프로그램 감독자 트리, 프로세스 정보, ETS 테이블, Mnesia 테이블을 표시하며 Erlang 추적을위한 프론트 엔드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="28cd1180f301b3154359b73583ee4c15ce0124d5" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. The tool Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables, and contains a front end for Erlang tracing with module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">관찰자는 Erlang 시스템의 특성을 관찰하기위한 그래픽 도구입니다. 도구 Observer는 시스템 정보, 응용 프로그램 감독자 트리, 프로세스 정보, ETS 테이블, Mnesia 테이블을 표시하고 &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; 모듈을 사용한 Erlang 추적을위한 프론트 엔드를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="8160323258aa98f01ffae3a9b4dd4732b06a4950" translate="yes" xml:space="preserve">
          <source>Obsolete API functions</source>
          <target state="translated">더 이상 사용되지 않는 API 함수</target>
        </trans-unit>
        <trans-unit id="828b44c38dbd9a16becde3e71362fe411c4b2d3c" translate="yes" xml:space="preserve">
          <source>Obsolete flag without any effect and common misspelling for &lt;code&gt;-setcookie&lt;/code&gt;. Use &lt;code&gt;-setcookie&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;-setcookie&lt;/code&gt; 에 대한 효과와 일반적인 철자가없는 오래된 플래그 입니다. 대신 &lt;code&gt;-setcookie&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8219545b990a3e898482be1f33bdc7f5472c0ab" translate="yes" xml:space="preserve">
          <source>Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10.</source>
          <target state="translated">분명히 PCRE는 Perl 코드의 보간을 지원할 수 없습니다. 대신, 전체 패턴의 재귀 및 개별 하위 패턴 재귀에 대한 특수 구문을 지원합니다. PCRE 및 Python에서 소개 된 후 이러한 종류의 재귀는 나중에 릴리스 5.10에서 Perl에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b15614a1ab393e5aeea9a1c392c3fa0e2e84f379" translate="yes" xml:space="preserve">
          <source>Obviously, that code does not work if the original order of the list is important. If the order of the list must be preserved, do as follows:</source>
          <target state="translated">목록의 원래 순서가 중요한 경우에는 해당 코드가 작동하지 않습니다. 목록의 순서를 유지해야하는 경우 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="8e8dc61a9436adab84db0adcc2c88c413a482fca" translate="yes" xml:space="preserve">
          <source>Of ECDSA keys, only the Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">ECDSA 키 중에서 일반적으로 RSA, DSA 또는 ECDSA 공개 키만 있지만 다른 공개 키 처리를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5975c0e8398e81740d7e6c9235666c7fc797c5" translate="yes" xml:space="preserve">
          <source>Off: Normal black and white display.</source>
          <target state="translated">꺼짐 : 일반 흑백 디스플레이.</target>
        </trans-unit>
        <trans-unit id="5e3b98e05dad157bd1a4bd5b9b0d226314cec835" translate="yes" xml:space="preserve">
          <source>Offline support - &lt;code&gt;systools&lt;/code&gt; for generating scripts and building release packages</source>
          <target state="translated">오프라인 지원- 스크립트 생성 및 릴리스 패키지 작성을위한 &lt;code&gt;systools&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f14b6c908a17fd970288025ad39d8151e0e31dda" translate="yes" xml:space="preserve">
          <source>Offset from the current position.</source>
          <target state="translated">현재 위치에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="48274bc06ce68fdb7834b5006c17db38cfd5bca3" translate="yes" xml:space="preserve">
          <source>Offset from the end of file.</source>
          <target state="translated">파일 끝에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="74f0c027755f3a641da0ac7fb4fdc91ca752be19" translate="yes" xml:space="preserve">
          <source>Offset to the next byte to write which also equals the amount of bytes currently written.</source>
          <target state="translated">현재 기록 된 바이트의 양과 동일한 기록 할 다음 바이트에 대한 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="c21c3314a2e6470603bd3c8f84047cb484b50ba5" translate="yes" xml:space="preserve">
          <source>Ogham</source>
          <target state="translated">Ogham</target>
        </trans-unit>
        <trans-unit id="b9c65c4bca9e4ad28b61b07b9af83fd8c0fb84c8" translate="yes" xml:space="preserve">
          <source>Ogham space mark</source>
          <target state="translated">오검 스페이스 마크</target>
        </trans-unit>
        <trans-unit id="80a20b8493b41152418b7eebcae86cbcce091a38" translate="yes" xml:space="preserve">
          <source>Okasaki API</source>
          <target state="translated">오카 사키 API</target>
        </trans-unit>
        <trans-unit id="5f8e3c9a997d8c6ac6d8e0cee37f365cfccbf2c1" translate="yes" xml:space="preserve">
          <source>Ol_Chiki</source>
          <target state="translated">Ol_Chiki</target>
        </trans-unit>
        <trans-unit id="5d9e0077e7780f989a1ceec9b3ec38c49f01d731" translate="yes" xml:space="preserve">
          <source>Old API</source>
          <target state="translated">이전 API</target>
        </trans-unit>
        <trans-unit id="3e62dbf3fb5370db410bc5b62d0381b5e3d16213" translate="yes" xml:space="preserve">
          <source>Old Crypto API</source>
          <target state="translated">오래된 암호화 API</target>
        </trans-unit>
        <trans-unit id="b6ffd367297aa558fd23448e1c93eab612c4b2b7" translate="yes" xml:space="preserve">
          <source>Old URI utility module, use uri_string instead</source>
          <target state="translated">이전 URI 유틸리티 모듈, 대신 uri_string 사용</target>
        </trans-unit>
        <trans-unit id="b178b6946982a11f1126a949ec15c4d708664fde" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">5.9 이전의 ERTS 버전에서 &lt;code&gt;erl_driver.h&lt;/code&gt; 로 컴파일 된 이전 드라이버 는 업데이트해야하며 확장 인터페이스 ( &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management &lt;/a&gt;&lt;/code&gt; ) 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ae910bfed0c2daf647c1a19f49b4a126bc16739" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">5.9 이전의 ERTS 버전에서 &lt;code&gt;erl_driver.h&lt;/code&gt; 로 컴파일 된 이전 드라이버 는 업데이트되어야하며 확장 인터페이스 ( &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; ) 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="13302e0d3a7dec730ee4bc597d731b5ec3f28913" translate="yes" xml:space="preserve">
          <source>Old-style exec specification that are kept for compatibility, but should not be used in new programs</source>
          <target state="translated">호환성을 위해 유지되지만 새 프로그램에서 사용해서는 안되는 구식 exec 사양</target>
        </trans-unit>
        <trans-unit id="157d75488b894d1cda756fa16127123d4d8b2331" translate="yes" xml:space="preserve">
          <source>OldBindType</source>
          <target state="translated">OldBindType</target>
        </trans-unit>
        <trans-unit id="7f70150bb048b630bda877379e329b1cba4ccf5d" translate="yes" xml:space="preserve">
          <source>OldBlockState</source>
          <target state="translated">OldBlockState</target>
        </trans-unit>
        <trans-unit id="dc265f2b8ca2bd1379067a84bcb36eee5f10c186" translate="yes" xml:space="preserve">
          <source>OldBoolean</source>
          <target state="translated">OldBoolean</target>
        </trans-unit>
        <trans-unit id="787f17ec93244a470977d9765b05c214ad524302" translate="yes" xml:space="preserve">
          <source>OldCpuTopology</source>
          <target state="translated">OldCpuTopology</target>
        </trans-unit>
        <trans-unit id="05284679f579d778eb76c6cb35f0adb51c1143c0" translate="yes" xml:space="preserve">
          <source>OldDirtyCPUSchedulersOnline</source>
          <target state="translated">OldDirtyCPUSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="d3e43fe6cc5ed7e93ad3fb3737bbd4c693602579" translate="yes" xml:space="preserve">
          <source>OldLevel :: &lt;code&gt;&lt;a href=&quot;#type-debug_level&quot;&gt;debug_level()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">OldLevel :: &lt;code&gt;&lt;a href=&quot;#type-debug_level&quot;&gt;debug_level()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1967122f5b0089c8c148736f325420c2e6e602a" translate="yes" xml:space="preserve">
          <source>OldMaxHeapSize</source>
          <target state="translated">OldMaxHeapSize</target>
        </trans-unit>
        <trans-unit id="44bb9d52af1c27b72d85ec222d49edbefed7f191" translate="yes" xml:space="preserve">
          <source>OldMinBinVHeapSize</source>
          <target state="translated">OldMinBinVHeapSize</target>
        </trans-unit>
        <trans-unit id="f03c39aabd48a51861a01442c2abd764c60f8791" translate="yes" xml:space="preserve">
          <source>OldMinHeapSize</source>
          <target state="translated">OldMinHeapSize</target>
        </trans-unit>
        <trans-unit id="a2eedd11d2145f39f33a241d59529adc2aae480c" translate="yes" xml:space="preserve">
          <source>OldSchedulersOnline</source>
          <target state="translated">OldSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="145ae46273aca133d92d9931894007faba8a6122" translate="yes" xml:space="preserve">
          <source>OldState</source>
          <target state="translated">OldState</target>
        </trans-unit>
        <trans-unit id="47ef70f9915b940884f76385b871fac7afb63176" translate="yes" xml:space="preserve">
          <source>OldValue</source>
          <target state="translated">OldValue</target>
        </trans-unit>
        <trans-unit id="d31721795f21dfce26688a7f8239a17ca4259705" translate="yes" xml:space="preserve">
          <source>Old_Italic</source>
          <target state="translated">Old_Italic</target>
        </trans-unit>
        <trans-unit id="2c0a6c802c2e969dfccf2fc785162a6f2b61c2bf" translate="yes" xml:space="preserve">
          <source>Old_North_Arabian</source>
          <target state="translated">Old_North_Arabian</target>
        </trans-unit>
        <trans-unit id="18fae1f67a0f3b95f77e39e31f33b8e9c0d5f5cb" translate="yes" xml:space="preserve">
          <source>Old_Permic</source>
          <target state="translated">Old_Permic</target>
        </trans-unit>
        <trans-unit id="40f6b23336b20230fad65810979b94941509719d" translate="yes" xml:space="preserve">
          <source>Old_Persian</source>
          <target state="translated">Old_Persian</target>
        </trans-unit>
        <trans-unit id="338432c6b8828a6dc79884aa878e0a2867c42479" translate="yes" xml:space="preserve">
          <source>Old_South_Arabian</source>
          <target state="translated">Old_South_Arabian</target>
        </trans-unit>
        <trans-unit id="3641abb7a588932eef54e644e9d1dff8f948abbf" translate="yes" xml:space="preserve">
          <source>Old_Turkic</source>
          <target state="translated">Old_Turkic</target>
        </trans-unit>
        <trans-unit id="ba2f4398b4a78c8c3781b266ce8f8b6790397950" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;, and reduce the paths in stack traces to the module name alone. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">&lt;code&gt;Module:module_info(compile)&lt;/code&gt; 에서 반환 한 목록에서 &lt;code&gt;options&lt;/code&gt; 과 &lt;code&gt;source&lt;/code&gt; 튜플을 생략하고 스택 추적의 경로를 모듈 이름만으로 줄이십시오. 이 옵션을 사용하면 재현 가능한 빌드를 더 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4dff48e0bc069d363085bc649284833fa87dbe" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">&lt;code&gt;Module:module_info(compile)&lt;/code&gt; 리턴 한 목록에서 &lt;code&gt;options&lt;/code&gt; 및 &lt;code&gt;source&lt;/code&gt; 튜플을 생략하십시오 . 이 옵션을 사용하면 재현 가능한 빌드를보다 쉽게 ​​수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1489713bac73f4571aa2114bb6a0e8bece846ba" translate="yes" xml:space="preserve">
          <source>Omits line number information to produce a slightly smaller output file.</source>
          <target state="translated">줄 번호 정보를 생략하여 약간 더 작은 출력 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ece5ff7a95f46bc465af7ccdd8565b862f2ad117" translate="yes" xml:space="preserve">
          <source>Omitted fields then get the value of evaluating &lt;code&gt;ExprL&lt;/code&gt; instead of their default values. This feature is primarily intended to be used to create patterns for ETS and Mnesia match functions.</source>
          <target state="translated">생략 된 필드 는 기본값 대신 &lt;code&gt;ExprL&lt;/code&gt; 을 평가하는 값을 얻습니다 . 이 기능은 주로 ETS 및 Mnesia 일치 기능에 대한 패턴을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b4336bcea263f419ca09551f44528b242f15a01" translate="yes" xml:space="preserve">
          <source>On 32 bit systems, there is not enough virtual memory space to allocate 1 GB for just literals, so instead small 256 KB sized literal regions are created on demand and a card mark bit-array of the entire 32 bit memory space is then used to determine if a term is a literal or not. Since the total memory space is only 32 bits, the card mark bit-array is only 256 words large. On a 64 bit system the same bit-array would have to be 1 tera words large, so this technique is only viable on 32 bit systems. Doing &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319&quot;&gt;lookups in the array&lt;/a&gt;&lt;/code&gt; is a little more expensive then just doing the pointer checks that can be done in 64 bit systems, but not extremely so.</source>
          <target state="translated">32 비트 시스템에서는 리터럴에만 1GB를 할당 할 가상 메모리 공간이 충분하지 않으므로 대신 작은 256KB 크기의 리터럴 영역이 필요에 따라 생성되고 전체 32 비트 메모리 공간의 카드 표시 비트 배열이 사용됩니다. 용어가 리터럴인지 아닌지 결정합니다. 총 메모리 공간이 32 비트에 불과하기 때문에 카드 마크 비트 어레이는 256 워드에 불과합니다. 64 비트 시스템에서 동일한 비트 어레이는 1 테라 워드 크기 여야하므로이 기술은 32 비트 시스템에서만 실행 가능합니다. 이렇게 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319&quot;&gt;lookups in the array&lt;/a&gt;&lt;/code&gt; 조금 더 비싼 그럼 그냥하지만 매우 그래서, 64 비트 시스템에서 수행 할 수있는 포인터 검사를하고있다.</target>
        </trans-unit>
        <trans-unit id="837ccb981f94461d47fadaa07a7f5c5a91558bf2" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: -134217729 &amp;lt; i &amp;lt; 134217728 (28 bits).</source>
          <target state="translated">32 비트 아키텍처 : -134217729 &amp;lt;i &amp;lt;134217728 (28 비트).</target>
        </trans-unit>
        <trans-unit id="07aa96ddf4a255f77698c1f72e8dbbc6f7d0ac40" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 4 words.</source>
          <target state="translated">32 비트 아키텍처 : 4 워드</target>
        </trans-unit>
        <trans-unit id="0aaea3805ba5a1657f963cc5531935c14dbff051" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 5 words for a reference from the current local node + 7 words for a reference from another node.</source>
          <target state="translated">32 비트 아키텍처 : 현재 로컬 노드에서 참조하는 5 워드 + 다른 노드에서 참조하는 7 워드</target>
        </trans-unit>
        <trans-unit id="d729d6c56ff45c63b971639d2a3f12703da39867" translate="yes" xml:space="preserve">
          <source>On 64 bit systems that allow mapping of unreserved virtual memory areas (most operating systems except Windows), an area of size 1 GB (by default) is mapped and then all literals are placed within that area. Then all that has to be done to determine if something is a literal or not is &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324&quot;&gt;two quick pointer checks&lt;/a&gt;&lt;/code&gt;. This system relies on the fact that a memory page that has not been touched yet does not take any actual space. So even if 1 GB of virtual memory is mapped, only the memory which is actually needed for literals is allocated in ram. The size of the literal area is configurable through the +MIscs erts_alloc option.</source>
          <target state="translated">예약되지 않은 가상 메모리 영역 (Windows를 제외한 대부분의 운영 체제) 매핑을 허용하는 64 비트 시스템에서는 크기가 1GB (기본적으로) 인 영역이 매핑 된 다음 모든 리터럴이 해당 영역에 배치됩니다. 그런 다음 어떤 것이 리터럴인지 아닌지를 결정하기 위해해야 ​​할 일은 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324&quot;&gt;two quick pointer checks&lt;/a&gt;&lt;/code&gt; 입니다. 이 시스템은 아직 건드리지 않은 메모리 페이지가 실제 공간을 차지하지 않는다는 사실에 의존합니다. 따라서 1GB의 가상 메모리가 매핑 되더라도 실제로 리터럴에 필요한 메모리 만 ram에 할당됩니다. 리터럴 영역의 크기는 + MIscs erts_alloc 옵션을 통해 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ee722acfea1218e0e9779b8fb79277f2b70e2b3" translate="yes" xml:space="preserve">
          <source>On 64 bit windows, on which erts_alloc cannot do unreserved virtual memory mappings, a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59&quot;&gt;special tag&lt;/a&gt;&lt;/code&gt; within the Erlang term object is used to determine if something &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252&quot;&gt;is a literal or not&lt;/a&gt;&lt;/code&gt;. This is very cheap, however, the tag is only available on 64 bit machines, and it is possible to do a great deal of other nice optimizations with this tag in the future (like for instance a more compact list implementation) so it is not used on operating systems where it is not needed.</source>
          <target state="translated">erts_alloc이 예약되지 않은 가상 메모리 매핑을 수행 할 수없는 64 비트 창 에서 Erlang 용어 개체 내의 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59&quot;&gt;special tag&lt;/a&gt;&lt;/code&gt; 사용하여 무언가 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252&quot;&gt;is a literal or not&lt;/a&gt;&lt;/code&gt; 인지 여부를 확인합니다 . 이것은 매우 저렴하지만 태그는 64 비트 머신에서만 사용할 수 있으며 앞으로이 태그를 사용하여 다른 멋진 최적화를 많이 수행 할 수 있습니다 (예 : 더 간결한 목록 구현). 필요하지 않은 운영 체제에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7773ad37cb673ee9b7860d0d4b67f31e39b62273" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: -576460752303423489 &amp;lt; i &amp;lt; 576460752303423488 (60 bits).</source>
          <target state="translated">64 비트 아키텍처 : -576460752303423489 &amp;lt;i &amp;lt;576460752303423488 (60 비트).</target>
        </trans-unit>
        <trans-unit id="ccffdbcaffb960350b1f03947273d32a77218dd0" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 3 words.</source>
          <target state="translated">64 비트 아키텍처 : 3 워드</target>
        </trans-unit>
        <trans-unit id="f4432adb4e3eddcf803da55fd62c8256f8c01dca" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 4 words for a reference from the current local node + 6 words for a reference from another node.</source>
          <target state="translated">64 비트 아키텍처 : 현재 로컬 노드에서 참조하는 4 워드 + 다른 노드에서 참조하는 6 워드</target>
        </trans-unit>
        <trans-unit id="883c639f7255c347e035338f052f0ec88dae56ed" translate="yes" xml:space="preserve">
          <source>On C-nodes, &lt;code&gt;erl_interface&lt;/code&gt; has support for registry tables. These tables reside in RAM on the C-node, but can also be dumped into Mnesia tables. By default, the dumping of registry tables through &lt;code&gt;erl_interface&lt;/code&gt; causes a corresponding Mnesia table to be created with &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt;, if necessary.</source>
          <target state="translated">C- 노드에서 &lt;code&gt;erl_interface&lt;/code&gt; 는 레지스트리 테이블을 지원합니다. 이 테이블은 C 노드의 RAM에 있지만 Mnesia 테이블로 덤프 할 수도 있습니다. 기본적으로 &lt;code&gt;erl_interface&lt;/code&gt; 를 통해 레지스트리 테이블을 덤프 하면 필요한 경우 &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt; 로 해당 Mnesia 테이블이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="53c351034515d0f74abb562de89183321dc3361d" translate="yes" xml:space="preserve">
          <source>On Darwin:</source>
          <target state="translated">다윈에서 :</target>
        </trans-unit>
        <trans-unit id="452d25bd3843cd164bb696cf08ee12ab9733accf" translate="yes" xml:space="preserve">
          <source>On Linux or UNIX you can safely ignore this and simply create a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in the directory you get to after executing the command &lt;code&gt;cd&lt;/code&gt; without any argument.</source>
          <target state="translated">Linux 또는 UNIX에서는이를 무시하고 인수없이 &lt;code&gt;cd&lt;/code&gt; 명령을 실행 한 후 얻는 디렉토리에 &lt;code&gt;.erlang.cookie&lt;/code&gt; 라는 파일을 작성하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="1abae7c719ffd5227ee01660d1ddd20cb3841aa3" translate="yes" xml:space="preserve">
          <source>On Linux systems the following changes will be made:</source>
          <target state="translated">Linux 시스템에서는 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="64ddff816a143447a28cf2b2f9c5227d387e78f6" translate="yes" xml:space="preserve">
          <source>On Linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">리눅스 에뮬레이터에 사용할 수있는 메모리입니다 &lt;code&gt;cached_memory&lt;/code&gt; 및 &lt;code&gt;buffered_memory&lt;/code&gt; 에 추가 &lt;code&gt;free_memory&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="07b320892e617ecd19e1d9117dbdaedf7a5983f2" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="6c57c64ae3b58fcb5970a5f623f9d3c0f6952789" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 를 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="99ba5d0f7bf487770a0030a3221eab9acf0e29cb" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="53587ca09ddf330890e10222f1f28d673e022a4f" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 를 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="d2fc503485c3bbe6875742c0c55de66f8b01c934" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_HOME&lt;/code&gt;.</source>
          <target state="translated">Linux : os 환경 변수 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="0127285f8943bba8fbcf06e2c56b836011b620f8" translate="yes" xml:space="preserve">
          <source>On UNIX, the release handler tells the &lt;code&gt;heart&lt;/code&gt; program which command to use to reboot the system. The environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt;, normally used by the &lt;code&gt;heart&lt;/code&gt; program, is ignored in this case. The command instead defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;. Another command can be set by using the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, see the &lt;code&gt;sasl(6)&lt;/code&gt; manual page.</source>
          <target state="translated">UNIX에서 릴리스 핸들러는 시스템을 재부팅하는 데 사용할 명령을 &lt;code&gt;heart&lt;/code&gt; 프로그램에 알려줍니다 . 이 경우 일반적으로 &lt;code&gt;heart&lt;/code&gt; 프로그램에서 사용하는 환경 변수 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 는 무시됩니다. 대신이 명령의 기본값은 &lt;code&gt;$ROOT/bin/start&lt;/code&gt; 입니다. SASL 구성 매개 변수 &lt;code&gt;start_prg&lt;/code&gt; 를 사용하여 다른 명령을 설정할 수 있습니다 . &lt;code&gt;sasl(6)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9712a16713ddd036d7484cde8377ae9fea3bea13" translate="yes" xml:space="preserve">
          <source>On Ubuntu this can be installed via &lt;code&gt;aptitude&lt;/code&gt;:</source>
          <target state="translated">우분투에서는 &lt;code&gt;aptitude&lt;/code&gt; 를 통해 설치할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="945f7eb32fc020ed4cd606f8c4ad2c5835f8ead0" translate="yes" xml:space="preserve">
          <source>On Unix platforms, other bits than those listed above may be set.</source>
          <target state="translated">Unix 플랫폼에서는 위에 나열된 것 이외의 다른 비트가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbea9d064da3b38737aba3e1e6b3c867dfe36620" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the environment is set using UTF-8 encoding if Unicode filename translation is in effect. On Windows, the environment is set using wide character interfaces.</source>
          <target state="translated">Unix 플랫폼에서 유니 코드 파일 이름 변환이 적용되는 경우 환경은 UTF-8 인코딩을 사용하여 설정됩니다. Windows에서 환경은 와이드 문자 인터페이스를 사용하여 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="864179103393e4079015a89879456910e0840ba4" translate="yes" xml:space="preserve">
          <source>On Unix systems, the Erlang runtime will interpret two types of signals.</source>
          <target state="translated">Unix 시스템에서 Erlang 런타임은 두 가지 유형의 신호를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="42f4a0b9ff2bf60e97136e578acd75fee6a21d57" translate="yes" xml:space="preserve">
          <source>On Unix the &lt;code&gt;event&lt;/code&gt; is a pipe or socket handle (or something that the &lt;code&gt;select&lt;/code&gt; system call understands).</source>
          <target state="translated">Unix에서 &lt;code&gt;event&lt;/code&gt; 는 파이프 또는 소켓 핸들 (또는 &lt;code&gt;select&lt;/code&gt; 시스템 호출이 이해하는 것)입니다.</target>
        </trans-unit>
        <trans-unit id="89488e0941b289b30ca17db0724ef6eb3f8cddfc" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;Osname&lt;/code&gt; has the same value as &lt;code&gt;uname -s&lt;/code&gt; returns, but in lower case. For example, on Solaris 1 and 2, it is &lt;code&gt;sunos&lt;/code&gt;.</source>
          <target state="translated">Unix에서 &lt;code&gt;Osname&lt;/code&gt; 은 &lt;code&gt;uname -s&lt;/code&gt; 반환 값과 같은 값을 갖지만 소문자 는 다릅니다 . 예를 들어, Solaris 1 및 2에서 &lt;code&gt;sunos&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f9abb41d788d59d3b3b9428af793da0ceb8018a" translate="yes" xml:space="preserve">
          <source>On Unix, any value specified for this field is ignored (the &quot;ctime&quot; for the file is set to the current time). On Windows, this field is the new creation time to set for the file.</source>
          <target state="translated">Unix에서이 필드에 지정된 값은 무시됩니다 (파일의 &quot;ctime&quot;은 현재 시간으로 설정 됨). Windows에서이 필드는 파일에 설정할 새로운 작성 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2f21108f8f59c58399736174f45da9282d8305fe" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, parameters are expected to be UTF-8 without translation if Unicode filenames are enabled.</source>
          <target state="translated">유닉스 계열 운영 체제에서 유니 코드 파일 이름이 활성화 된 경우 매개 변수는 변환없이 UTF-8이 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="624724bf76a78b8d09ce52016c5a6eefce217dcc" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the terminal is to be able to handle UTF-8 on input and output (this is done by, for example, modern versions of XTerm, KDE Konsole, and the Gnome terminal) and your locale settings must be proper. As an example, a &lt;code&gt;LANG&lt;/code&gt; environment variable can be set as follows:</source>
          <target state="translated">Unix와 유사한 운영 체제에서 터미널은 입력 및 출력에서 ​​UTF-8을 처리 할 수 ​​있어야하며 (예 : 최신 버전의 XTerm, KDE Konsole 및 Gnome 터미널에 의해 수행됨) 로케일 설정은 다음과 같아야합니다. 적절한. 예를 들어, &lt;code&gt;LANG&lt;/code&gt; 환경 변수는 다음과 같이 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3343aa00325e17effeba793420c23aae68f68a75" translate="yes" xml:space="preserve">
          <source>On Windows XP, select &lt;strong&gt;Control Panel&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Language Options&lt;/strong&gt;, select tab &lt;strong&gt;Language&lt;/strong&gt;, and click button &lt;strong&gt;Details...&lt;/strong&gt; in the square named &lt;strong&gt;Text Services and Input Languages&lt;/strong&gt;.</source>
          <target state="translated">윈도우 XP에서 선택 &lt;strong&gt;제어판&lt;/strong&gt; &amp;gt; &lt;strong&gt;국가 및 언어 옵션을&lt;/strong&gt; 탭 선택 &lt;strong&gt;언어&lt;/strong&gt; , 버튼 클릭 &lt;strong&gt;... 세부 정보&lt;/strong&gt; 광장라는 이름의 &lt;strong&gt;텍스트 서비스 및 입력 언어&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7bdd9c7b68e080175354bdf3fad784b9f495039c" translate="yes" xml:space="preserve">
          <source>On Windows platforms, Erlang searches the system registry rather than looks for configuration files when started in long name distributed mode.</source>
          <target state="translated">Windows 플랫폼에서 Erlang은 긴 이름 분산 모드로 시작할 때 구성 파일을 찾는 대신 시스템 레지스트리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e26d25aabbde72aeec251ac7d6d7e8b7d5ff65e1" translate="yes" xml:space="preserve">
          <source>On Windows systems the home directory is the directory pointed out by the environment variable $HOME - you may need to set this.</source>
          <target state="translated">Windows 시스템에서 홈 디렉토리는 환경 변수 $ HOME에 의해 지정된 디렉토리입니다.이를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c1eb5371b5194cdf64f66156f192b541e886e24" translate="yes" xml:space="preserve">
          <source>On Windows the &lt;code&gt;event&lt;/code&gt; is an &lt;code&gt;Event&lt;/code&gt; or &lt;code&gt;Semaphore&lt;/code&gt; (or something that the &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API function understands). (Some trickery in the emulator allows more than the built-in limit of 64 &lt;code&gt;Events&lt;/code&gt; to be used.)</source>
          <target state="translated">Windows에서 &lt;code&gt;event&lt;/code&gt; 는 &lt;code&gt;Event&lt;/code&gt; 또는 &lt;code&gt;Semaphore&lt;/code&gt; (또는 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API 함수가 이해하는 것)입니다. (에뮬레이터의 일부 트릭은 64 개 이상의 &lt;code&gt;Events&lt;/code&gt; 제한을 사용할 수있게합니다.)</target>
        </trans-unit>
        <trans-unit id="07f408912d4e25cbe3e69c344bbf252be7275718" translate="yes" xml:space="preserve">
          <source>On Windows the default value is set to &lt;code&gt;8196&lt;/code&gt; because the normal OS limitations are set higher than most machines can handle.</source>
          <target state="translated">Windows에서는 일반 OS 제한이 대부분의 시스템이 처리 할 수있는 것보다 높게 설정되어 있기 때문에 기본값은 &lt;code&gt;8196&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4b05412a62bc9a89fb50987de22114d258a3cec" translate="yes" xml:space="preserve">
          <source>On Windows the maximum number of nodes allowed in one epmd instance is 60. This is because of limitations in the current implementation. If you need more nodes, you should look into using and erlang based epmd implementation such as &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/epmd&quot;&gt;Erlang EPMD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 하나의 epmd 인스턴스에 허용되는 최대 노드 수는 60 개입니다. 이는 현재 구현의 제한 사항 때문입니다. 더 많은 노드가 필요하면 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/epmd&quot;&gt;Erlang EPMD&lt;/a&gt;&lt;/code&gt; 와 같은 erlang 기반 epmd 구현을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="818c5818d712a93bb76a90d8f6ce9237479e8047" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Osname&lt;/code&gt; is &lt;code&gt;nt&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;code&gt;Osname&lt;/code&gt; 은 &lt;code&gt;nt&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08a45149384450c4928eab3da298a998b5209ee6" translate="yes" xml:space="preserve">
          <source>On Windows, proper operation requires that a suitable font is installed and selected for the Erlang application to use. If no suitable font is available on your system, try installing the &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt;, which are freely available, and then select that font in the Erlang shell application.</source>
          <target state="translated">Windows에서 올바른 작동을 위해서는 Erlang 응용 프로그램에서 사용할 적절한 글꼴을 설치하고 선택해야합니다. 시스템에 적합한 글꼴이없는 경우 무료로 제공되는 &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt; 설치 한 다음 Erlang 쉘 응용 프로그램에서 해당 글꼴을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="73a6c028854ad01eefd9a69b170bcc32b5780e1c" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values can be calculated, just as some &lt;code&gt;Flag&lt;/code&gt; values. Report flagrant bugs.</source>
          <target state="translated">Windows에서는 다른 OS API 함수에서 데이터를 가져 오기 때문에 일부 &lt;code&gt;Flag&lt;/code&gt; 값 과 &lt;code&gt;Broadaddr&lt;/code&gt; &lt;code&gt;Netmask&lt;/code&gt; 및 Broadaddr 값을 계산할 수 있습니다 . 악의적 인 버그보고</target>
        </trans-unit>
        <trans-unit id="47575c57c43d9b6b182dce9d049d1942967994c2" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values may be calculated, just as some &lt;code&gt;Flags&lt;/code&gt; values.</source>
          <target state="translated">Windows에서는 다른 OS API 함수에서 데이터를 가져 &lt;code&gt;Broadaddr&lt;/code&gt; 로 일부 &lt;code&gt;Flags&lt;/code&gt; 값 과 마찬가지로 &lt;code&gt;Netmask&lt;/code&gt; 및 Broadaddr 값을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e5200c5fc7e9186939f4793a54da361f708e107" translate="yes" xml:space="preserve">
          <source>On Windows, the preferred way to start the Erlang system for interactive use is as follows:</source>
          <target state="translated">Windows에서 대화식 사용을 위해 Erlang 시스템을 시작하는 기본 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3c787c6250b0d27168a0579a029fe138a257fab" translate="yes" xml:space="preserve">
          <source>On Windows, use semi-colon as separator.</source>
          <target state="translated">Windows에서는 세미콜론을 구분 기호로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="91de63a646561418f6b7e070668224cb4764e75e" translate="yes" xml:space="preserve">
          <source>On a Unix system you can view the manual pages from the command line using</source>
          <target state="translated">유닉스 시스템에서는 다음을 사용하여 명령 행에서 매뉴얼 페이지를 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3c1e7fbc1efc10479b9f342b1427cfdbfeabd446" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, &lt;code&gt;ERL_LIBS&lt;/code&gt; can be set to the following</source>
          <target state="translated">유닉스 계열 시스템에서 &lt;code&gt;ERL_LIBS&lt;/code&gt; 는 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a74d3fb56059df82993a50e11000b4ec43a6e044" translate="yes" xml:space="preserve">
          <source>On a conceptual level starting a database connection using the Erlang ODBC API is a basic client server application. The client process uses the API to start and communicate with the server process that manages the connection. The strategy of the Erlang ODBC application is that programming faults in the application itself will cause the connection process to terminate abnormally.(When a process terminates abnormally its supervisor will log relevant error reports.) Calls to API functions during or after termination of the connection process, will return &lt;code&gt;{error, connection_closed}&lt;/code&gt;. Contextual errors on the other hand will not terminate the connection it will only return &lt;code&gt;{error, Reason}&lt;/code&gt; to the client, where &lt;code&gt;Reason&lt;/code&gt; may be any erlang term.</source>
          <target state="translated">개념적인 수준에서 Erlang ODBC API를 사용하여 데이터베이스 연결을 시작하는 것은 기본 클라이언트 서버 애플리케이션입니다. 클라이언트 프로세스는 API를 사용하여 연결을 관리하는 서버 프로세스를 시작하고 통신합니다. Erlang ODBC 응용 프로그램의 전략은 응용 프로그램 자체의 프로그래밍 오류로 인해 연결 프로세스가 비정상적으로 종료되는 것입니다 (프로세스가 비정상적으로 종료되면 관리자가 관련 오류 보고서를 기록합니다). 연결 종료 중 또는 종료 후 API 함수 호출 프로세스는 &lt;code&gt;{error, connection_closed}&lt;/code&gt; 반환 합니다. 반면 상황에 따른 오류는 연결을 종료하지 않으며 &lt;code&gt;{error, Reason}&lt;/code&gt; 만 클라이언트에게 반환 합니다. 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 잘못된 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d392ddbe029a1a10ad20de9a806356a9c906b21" translate="yes" xml:space="preserve">
          <source>On a file, a term is represented by a header and a binary. Two options define the format of terms on files:</source>
          <target state="translated">파일에서 용어는 헤더와 이진으로 표시됩니다. 두 가지 옵션은 파일에서 용어의 형식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0a1100e7bfb6397c36a4da859d5dfb1b68d51802" translate="yes" xml:space="preserve">
          <source>On a single core system or if it's a non-reentrant scanner, a single port is created. On a multi-core system with a reentrant scanner, several ports will be created (one for each scheduler).</source>
          <target state="translated">단일 코어 시스템 또는 재진입 할 ​​수없는 스캐너 인 경우 단일 포트가 작성됩니다. 재진입 스캐너가있는 멀티 코어 시스템에서는 여러 개의 포트가 작성됩니다 (각 스케줄러마다 하나씩).</target>
        </trans-unit>
        <trans-unit id="b61c13a696c2951dde75411aaee46764defe2d53" translate="yes" xml:space="preserve">
          <source>On a system where release handling is used, this is always to be set to &lt;code&gt;ignore&lt;/code&gt;. Use &lt;code&gt;heart&lt;/code&gt; to restart the service on failure instead.</source>
          <target state="translated">릴리스 처리가 사용되는 시스템에서는 항상 &lt;code&gt;ignore&lt;/code&gt; 로 설정해야 합니다. 대신 실패시 서비스를 다시 시작 하려면 &lt;code&gt;heart&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca5dabff07309a8980fe16e2ce2d9b17947978e9" translate="yes" xml:space="preserve">
          <source>On a system without OS monotonic time, Erlang monotonic time guarantees monotonicity, but cannot give other guarantees. The frequency adjustments made to Erlang monotonic time depend on the time warp mode used.</source>
          <target state="translated">OS 단조 시간이없는 시스템에서 Erlang 단조 시간은 단 조성을 보장하지만 다른 보장은 제공 할 수 없습니다. Erlang 단조 시간에 대한 주파수 조정은 사용 된 시간 왜곡 모드에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="78bd91cdbb8d95fdca3d6cb73e168bf34bd8e3ca" translate="yes" xml:space="preserve">
          <source>On all platforms that we provide atomic memory operations, this is just a &lt;code&gt;volatile&lt;/code&gt; read, preventing the compiler to use values in registers, forcing the a read from memory.</source>
          <target state="translated">원자 메모리 연산을 제공하는 모든 플랫폼에서 이것은 단지 &lt;code&gt;volatile&lt;/code&gt; 읽기 일 뿐이며 컴파일러가 레지스터의 값을 사용하지 못하도록하여 메모리에서 읽기를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="c10079e3d3b4af33197f73508809dcf8be943c1b" translate="yes" xml:space="preserve">
          <source>On an embedded system it is not uncommon that the system has no power supply, not even a battery, when it is shut off. The system clock on such a system is typically way off when the system boots. If &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, and the Erlang runtime system is started before OS system time has been corrected, Erlang system time can be wrong for a long time, centuries or even longer.</source>
          <target state="translated">내장형 시스템에서는 시스템을 종료 할 때 시스템에 배터리가 아닌 전원 공급 장치가없는 경우가 드물지 않습니다. 이러한 시스템의 시스템 클럭은 일반적으로 시스템 부팅시 꺼집니다. 경우 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 사용되지 않으며, OS의 시스템 시간이 수정되기 전에 얼랑 런타임 시스템이 시작될 때, 얼랑 시스템 시간은 긴 시간, 세기 또는 이상 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94848f950b79b2c5a62062642414a0d81b6809e5" translate="yes" xml:space="preserve">
          <source>On an embedded system, the &lt;code&gt;erlsrv&lt;/code&gt; module is to be used to install the Erlang process as a Windows system service. This service can start after Windows NT has booted.</source>
          <target state="translated">임베디드 시스템에서 &lt;code&gt;erlsrv&lt;/code&gt; 모듈은 Erlang 프로세스를 Windows 시스템 서비스로 설치하는 데 사용됩니다. 이 서비스는 Windows NT가 부팅 된 후에 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e74b9f0f9fc530f5a5a031fbc8a47d65641b3d" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;app&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">애플리케이션 ( &lt;code&gt;app&lt;/code&gt; ) 레벨에서 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8c2c100f87c410005b9664bcf1790490ce2930c4" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;escript&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">응용 프로그램 ( &lt;code&gt;escript&lt;/code&gt; ) 레벨에서 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2ca7be500feda1d827cc1f5458cea971c16dda" translate="yes" xml:space="preserve">
          <source>On builds without &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; there is a failed test case for undefined functions. Verify that the failed test case log only shows calls to skipped applications.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;ssl&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; 가 없는 빌드 에서는 정의되지 않은 함수에 대한 테스트 케이스가 실패했습니다. 실패한 테스트 사례 로그에 건너 뛴 응용 프로그램에 대한 호출 만 표시되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7b33a0aa47e36eff9a9acf946284dbd48855b743" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time a message with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">각 Erlang 노드에서 프로세스를 &lt;strong&gt;시스템 추적 프로그램&lt;/strong&gt; 으로 설정할 수 있습니다 . 이 프로세스는 추적 토큰이있는 메시지가 전송되거나 수신 될 때마다 (추적 토큰 플래그 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;'receive'&lt;/code&gt; 이 설정된 경우) 추적 메시지를 수신 합니다. 그런 다음 시스템 추적 프로그램은 각 추적 이벤트를 인쇄하거나 파일에 쓰거나 적절한 항목으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91f3ac52e30283e286d347e915ad6557b2459808" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time information with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">각 Erlang 노드에서 프로세스를 &lt;strong&gt;시스템 추적 프로그램&lt;/strong&gt; 으로 설정할 수 있습니다 . 이 프로세스는 추적 토큰이있는 정보를 보내거나받을 때마다 추적 메시지를받습니다 (추적 토큰 플래그 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;'receive'&lt;/code&gt; 가 설정된 경우). 그런 다음 시스템 추적 프로그램은 각 추적 이벤트를 인쇄하거나 파일에 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa1503e3bb1ca6d6b1d5db02a4ead78c2138817" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() IPv4 address is parsed in the usual x.x.x.x format while an IPv6 address is parsed in any of the formats specified by section 2.2 of RFC 2373, &quot;Text Representation of Addresses&quot;. An IPv4 tuple() has length 4 and contains values of type 0..255. An IPv6 tuple() has length 8 and contains values of type 0..65535. The tuple representation is used on decode.</source>
          <target state="translated">인코딩시 OctetString () IPv4 주소는 일반적인 xxxx 형식으로 구문 분석되는 반면 IPv6 주소는 RFC 2373, &quot;주소의 텍스트 표현&quot;섹션 2.2에 지정된 형식으로 구문 분석됩니다. IPv4 tuple ()은 길이가 4이며 0..255 유형의 값을 포함합니다. IPv6 tuple ()은 길이가 8이며 0..65535 유형의 값을 포함합니다. 튜플 표현은 디코딩에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d15ad498425526235871ebf68fcb9399fdea277" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() can be specified as an iolist(), excessively large floats (in absolute value) are equivalent to &lt;code&gt;infinity&lt;/code&gt; or &lt;code&gt;'-infinity'&lt;/code&gt; and excessively large integers result in encode failure. The records for grouped AVPs are as discussed in the previous section.</source>
          <target state="translated">인코딩시 OctetString ()을 iolist ()로 지정할 수 있으며, 너무 큰 부동 소수점 (절대 값)은 &lt;code&gt;infinity&lt;/code&gt; 또는 &lt;code&gt;'-infinity'&lt;/code&gt; 하며 지나치게 큰 정수는 인코딩 실패를 초래합니다. 그룹화 된 AVP에 대한 레코드는 이전 섹션에서 설명한대로입니다.</target>
        </trans-unit>
        <trans-unit id="c7844a2c02e87c5568f9be53b564891e2298588d" translate="yes" xml:space="preserve">
          <source>On encode, fields port, transport and protocol default to 3868, sctp and diameter respectively. The grammar of an OctetString-valued DiameterURI() is as specified in section 4.3 of RFC 6733. The record representation is used on decode.</source>
          <target state="translated">인코딩시 필드 포트, ​​전송 및 프로토콜의 기본값은 각각 3868, sctp 및 직경입니다. OctetString 값의 DiameterURI ()의 문법은 RFC 6733의 섹션 4.3에 지정되어 있습니다. 레코드 표현은 디코드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d66c2d9ea2e818fe35630d0324d41a67f4905d83" translate="yes" xml:space="preserve">
          <source>On encode, values can be specified using the macros defined in a dictionary's hrl file.</source>
          <target state="translated">인코딩시, 사전의 hrl 파일에 정의 된 매크로를 사용하여 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731614e2c441caf07c5c36a9a260f1d7987a91b7" translate="yes" xml:space="preserve">
          <source>On encountering character #, &lt;code&gt;pcre_compile()&lt;/code&gt; skips along, looking for a newline in the pattern. The sequence \n is still literal at this stage, so it does not terminate the comment. Only a character with code value 0x0a (the default newline) does so.</source>
          <target state="translated">문자 #가 발생하면 &lt;code&gt;pcre_compile()&lt;/code&gt; 건너 뛰면서 패턴에서 줄 바꿈을 찾습니다. 이 단계에서 \ n 시퀀스는 여전히 문자 그대로이므로 주석을 종료하지 않습니다. 코드 값이 0x0a (기본 줄 바꿈) 인 문자 만 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="6046ea4ed169ee86943dd8f909d8a57065f20fd4" translate="yes" xml:space="preserve">
          <source>On failure, that is, no such environment variable was found, a value &amp;lt; &lt;code&gt;0&lt;/code&gt; is returned. When the size of the &lt;code&gt;value&lt;/code&gt; buffer is too small, a value &amp;gt; &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;*value_size&lt;/code&gt; has been set to the buffer size needed.</source>
          <target state="translated">실패시, 즉 그러한 환경 변수를 찾지 못하면 값 &amp;lt; &lt;code&gt;0&lt;/code&gt; 이 리턴됩니다. &lt;code&gt;value&lt;/code&gt; 버퍼 의 크기 가 너무 작 으면 값&amp;gt; &lt;code&gt;0&lt;/code&gt; 이 리턴되고 &lt;code&gt;*value_size&lt;/code&gt; 가 필요한 버퍼 크기로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7d6dfc6c6549f9a2bde9d0b09efa932ae04ee7b" translate="yes" xml:space="preserve">
          <source>On gollum:</source>
          <target state="translated">골룸에서 :</target>
        </trans-unit>
        <trans-unit id="2fb361775fa49f574bf571176cefd50d9c38320a" translate="yes" xml:space="preserve">
          <source>On kosken (on a Linux/UNIX system):</source>
          <target state="translated">kosken (Linux / UNIX 시스템)에서 :</target>
        </trans-unit>
        <trans-unit id="254bbc8618baf4df2c0d1ded28631159588b541c" translate="yes" xml:space="preserve">
          <source>On line 1-10 the OS headers needed for the driver are included. As this driver is written for Solaris, we know that the header &lt;code&gt;uio.h&lt;/code&gt; exists. So the preprocessor variable &lt;code&gt;HAVE_UIO_H&lt;/code&gt; can be defined before &lt;code&gt;erl_driver.h&lt;/code&gt; is included on line 12. The definition of &lt;code&gt;HAVE_UIO_H&lt;/code&gt; will make the I/O vectors used in Erlang's driver queues to correspond to the operating systems ditto, which is very convenient.</source>
          <target state="translated">1-10 행에는 드라이버에 필요한 OS 헤더가 포함되어 있습니다. 이 드라이버는 Solaris 용으로 작성 &lt;code&gt;uio.h&lt;/code&gt; 헤더 가 존재 한다는 것을 알고 있습니다. 따라서 &lt;code&gt;erl_driver.h&lt;/code&gt; 가 12 행에 포함 되기 전에 전 처리기 변수 &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 를 정의 할 수 있습니다 . &lt;code&gt;HAVE_UIO_H&lt;/code&gt; 의 정의는 Erlang의 드라이버 대기열에 사용 된 I / O 벡터가 운영 체제 ditto에 해당하도록 만들므로 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="233d0459679e240e1a43d6003a0eed16b1b6db16" translate="yes" xml:space="preserve">
          <source>On line 16-23 the different callback functions are declared (&quot;forward declarations&quot;).</source>
          <target state="translated">16-23 행에서 다른 콜백 함수가 선언됩니다 ( &quot;전달 선언&quot;).</target>
        </trans-unit>
        <trans-unit id="1829525dba56c919f35e7fe241f7a7f27d37779d" translate="yes" xml:space="preserve">
          <source>On line 4-8 is handled the case where the port is in &lt;code&gt;data&lt;/code&gt; mode or &lt;code&gt;intermediate&lt;/code&gt; mode and the remaining routine handles the different commands. The routine uses the &lt;code&gt;driver_failure_posix()&lt;/code&gt; routine to report errors (see, for example, line 15). Notice that the failure routines make a call to the &lt;code&gt;uds_stop&lt;/code&gt; routine, which will remove the internal port data. The handle (and the casted handle &lt;code&gt;ud&lt;/code&gt;) is therefore &lt;strong&gt;invalid pointers&lt;/strong&gt; after a &lt;code&gt;driver_failure&lt;/code&gt; call and we should &lt;strong&gt;return immediately&lt;/strong&gt;. The runtime system will send exit signals to all linked processes.</source>
          <target state="translated">라인 4-8은 포트가 &lt;code&gt;data&lt;/code&gt; 모드 또는 &lt;code&gt;intermediate&lt;/code&gt; 모드에 있고 나머지 루틴이 다른 명령을 처리하는 경우에 처리됩니다. 이 루틴은 &lt;code&gt;driver_failure_posix()&lt;/code&gt; 루틴을 사용하여 오류를보고합니다 (예 : 15 행 참조). 실패 루틴은 &lt;code&gt;uds_stop&lt;/code&gt; 루틴을 호출 하여 내부 포트 데이터를 제거합니다. 따라서 handle (및 casted handle &lt;code&gt;ud&lt;/code&gt; )은 &lt;code&gt;driver_failure&lt;/code&gt; 호출 후 &lt;strong&gt;유효하지 않은 포인터&lt;/strong&gt; 이므로 &lt;strong&gt;즉시 리턴&lt;/strong&gt; 해야 &lt;strong&gt;합니다&lt;/strong&gt; . 런타임 시스템은 모든 연결된 프로세스에 종료 신호를 보냅니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0784da7963dd222dfcf8b747a5d57b72650b03dc" translate="yes" xml:space="preserve">
          <source>On linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">리눅스에 에뮬레이터에서 사용할 수있는 메모리입니다 &lt;code&gt;cached_memory&lt;/code&gt; 및 &lt;code&gt;buffered_memory&lt;/code&gt; 에 추가 &lt;code&gt;free_memory&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="9d908b49426b880b5a485931417759cde36bd6fa" translate="yes" xml:space="preserve">
          <source>On many platforms, the OS supports only status codes 0-255. A too large status code is truncated by clearing the high bits.</source>
          <target state="translated">많은 플랫폼에서 OS는 상태 코드 0-255 만 지원합니다. 높은 비트를 지우면 너무 큰 상태 코드가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="01e5aeaef327e8644ba3de200b1361c56477bc67" translate="yes" xml:space="preserve">
          <source>On module (&lt;code&gt;mod&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">모듈 ( &lt;code&gt;mod&lt;/code&gt; ) 레벨에서는 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="625fa204254a0a02e9def2bcc01ac2eefa5a78a4" translate="yes" xml:space="preserve">
          <source>On most platforms this option must be set on the socket before associating it to an address. It is therefore only reasonable to specify it when creating the socket and not to use it when calling function (&lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt;) containing this description.</source>
          <target state="translated">대부분의 플랫폼에서이 옵션은 소켓을 주소에 연결하기 전에 소켓에서 설정해야합니다. 따라서 소켓을 작성할 때 소켓을 지정 하고이 설명이 포함 된 함수 ( &lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt; )를 호출 할 때는 소켓을 지정하지 않는 것이 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="83547004e7613d3d63f0a97fcec4dde6aca4cb59" translate="yes" xml:space="preserve">
          <source>On one of the two nodes:</source>
          <target state="translated">두 노드 중 하나에서 :</target>
        </trans-unit>
        <trans-unit id="cc0bc87e9803dd29ab16d01f2771141460043748" translate="yes" xml:space="preserve">
          <source>On operating systems with mandatory Unicode filenames, this means that you more easily conform to the filenames of other (non-Erlang) applications. You can also process filenames that, at least on Windows, were inaccessible (because of having names that could not be represented in ISO Latin-1). Also, you avoid creating incomprehensible filenames on MacOS X, as the &lt;code&gt;vfs&lt;/code&gt; layer of the operating system accepts all your filenames as UTF-8 does not rewrite them.</source>
          <target state="translated">필수 유니 코드 파일 이름이있는 운영 체제에서 이는 다른 (비 Erlang) 응용 프로그램의 파일 이름을보다 쉽게 ​​준수 함을 의미합니다. ISO 라틴어 1로 표현할 수없는 이름이 있기 때문에 적어도 Windows에서는 액세스 할 수없는 파일 이름을 처리 할 수도 있습니다. 또한 운영 체제 의 &lt;code&gt;vfs&lt;/code&gt; 계층은 UTF-8이 파일 이름을 다시 쓰지 않으므로 모든 파일 이름을 허용 하므로 MacOS X에서 이해할 수없는 파일 이름을 작성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c01b078903bea1781dc2ed9488460d3b352c3b71" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming (for example, all Unix systems except MacOS X), default is &lt;code&gt;utf8&lt;/code&gt; if the terminal supports UTF-8, otherwise &lt;code&gt;latin1&lt;/code&gt;. The default can be overridden using &lt;code&gt;+fnl&lt;/code&gt; (to force &lt;code&gt;latin1&lt;/code&gt; mode) or &lt;code&gt;+fnu&lt;/code&gt; (to force &lt;code&gt;utf8&lt;/code&gt; mode) when starting &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">투명한 이름을 가진 운영 체제 (예 : MacOS X를 제외한 모든 Unix 시스템) 에서 터미널이 UTF-8을 지원하면 기본값은 &lt;code&gt;utf8&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;latin1&lt;/code&gt; 입니다. 기본값은 사용 오버라이드 (override) 할 수 있습니다 &lt;code&gt;+fnl&lt;/code&gt; (강제 &lt;code&gt;latin1&lt;/code&gt; 모드) 또는 &lt;code&gt;+fnu&lt;/code&gt; (힘에 &lt;code&gt;utf8&lt;/code&gt; 시작시 모드) &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd025a43addf4cf8a811c722598b09ff48bc9cb" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming, files can be inconsistently named, for example, some files are encoded in UTF-8 while others are encoded in ISO Latin-1. The concept of &lt;strong&gt;raw filenames&lt;/strong&gt; is introduced to handle file systems with inconsistent naming when running in &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">투명한 이름을 가진 운영 체제에서 파일 이름이 일치하지 않을 수 있습니다. 예를 들어 일부 파일은 UTF-8로 인코딩되고 다른 파일은 ISO Latin-1로 인코딩됩니다. &lt;strong&gt;원시 파일 이름&lt;/strong&gt; 의 개념은 &lt;code&gt;utf8&lt;/code&gt; 모드 에서 실행할 때 이름이 일치하지 않는 파일 시스템을 처리하기 위해 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e0eed5fde65bb7a382758dcc51496a31ac264639" translate="yes" xml:space="preserve">
          <source>On other supported systems, see &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; on how to enable HiPE.</source>
          <target state="translated">지원되는 다른 시스템에서는 HiPE를 활성화하는 방법에 대한 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="553a2be33582dd908d9294011101091577e2f096" translate="yes" xml:space="preserve">
          <source>On platforms supporting it, enables the POSIX &lt;code&gt;O_SYNC&lt;/code&gt; synchronous I/O flag or its platform-dependent equivalent (for example, &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; on Windows) so that writes to the file block until the data is physically written to disk. However, be aware that the exact semantics of this flag differ from platform to platform. For example, none of Linux or Windows guarantees that all file metadata are also written before the call returns. For precise semantics, check the details of your platform documentation. On platforms with no support for POSIX &lt;code&gt;O_SYNC&lt;/code&gt; or equivalent, use of the &lt;code&gt;sync&lt;/code&gt; flag causes &lt;code&gt;open&lt;/code&gt; to return &lt;code&gt;{error, enotsup}&lt;/code&gt;.</source>
          <target state="translated">이를 지원하는 플랫폼에서 POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 동기 I / O 플래그 또는 이와 동등한 플랫폼 종속 (예 : Windows의 &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; )을 활성화하여 데이터가 실제로 디스크에 기록 될 때까지 파일 블록에 기록합니다. 그러나이 플래그의 정확한 의미는 플랫폼마다 다릅니다. 예를 들어, Linux 또는 Windows는 호출이 리턴되기 전에 모든 파일 메타 데이터도 기록되도록 보장하지 않습니다. 정확한 의미를 위해서는 플랫폼 설명서의 세부 정보를 확인하십시오. POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 또는 이와 동등한 기능을 지원하지 않는 플랫폼 에서 &lt;code&gt;sync&lt;/code&gt; 플래그를 사용하면 &lt;code&gt;open&lt;/code&gt; 이 &lt;code&gt;{error, enotsup}&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d150b84d58ca2e7d5f356e3aff31a3d84da95bdf" translate="yes" xml:space="preserve">
          <source>On some operating systems &lt;strong&gt;syslog&lt;/strong&gt; will be used for error reporting when &lt;code&gt;epmd&lt;/code&gt; runs as a daemon. To enable the error logging, you must edit the /etc/syslog.conf file and add an entry:</source>
          <target state="translated">일부 운영 체제에서는 &lt;code&gt;epmd&lt;/code&gt; 가 데몬으로 실행될 때 &lt;strong&gt;syslog&lt;/strong&gt; 가 오류보고에 사용 됩니다. 오류 로깅을 활성화하려면 /etc/syslog.conf 파일을 편집하고 항목을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="47544928855d61173caf643cd7bfa90a251b1e29" translate="yes" xml:space="preserve">
          <source>On some platforms Perl may behave strangely if certain locales are set. If you get errors when building, try setting the LANG variable:</source>
          <target state="translated">일부 플랫폼에서 특정 로케일이 설정되면 Perl이 이상하게 작동 할 수 있습니다. 빌드 할 때 오류가 발생하면 LANG 변수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c557f429b8f8be575f4e9231e0c0e909cbf4d560" translate="yes" xml:space="preserve">
          <source>On some platforms its &lt;strong&gt;necessary&lt;/strong&gt; to provide the &lt;code&gt;protocol&lt;/code&gt; as its impossible to retrieve it.</source>
          <target state="translated">일부 플랫폼의 &lt;strong&gt;필요는&lt;/strong&gt; 제공하는 &lt;code&gt;protocol&lt;/code&gt; 을 검색 할 수는 없다 등을.</target>
        </trans-unit>
        <trans-unit id="4a78afab7d6e8dd2e7a981b5139d692992694b9a" translate="yes" xml:space="preserve">
          <source>On some platforms, the only allowed value for this option is &lt;code&gt;true&lt;/code&gt;, for example, OpenBSD and Windows. Trying to set this option to &lt;code&gt;false&lt;/code&gt;, when creating the socket, fails in this case.</source>
          <target state="translated">일부 플랫폼에서이 옵션에 허용되는 유일한 값은 &lt;code&gt;true&lt;/code&gt; 입니다 (예 : OpenBSD 및 Windows). 이 경우 소켓을 만들 때이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하려고 하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="36908e6d72c2b03311eb938d2432a12b5ab335ef" translate="yes" xml:space="preserve">
          <source>On some platforms, this function might have no effect.</source>
          <target state="translated">일부 플랫폼에서는이 기능이 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e64396927ca10116aa5e806980b90b12fcdc017" translate="yes" xml:space="preserve">
          <source>On some systems it can be necessary to link with some more libraries (for example, &lt;code&gt;libnsl.a&lt;/code&gt; and &lt;code&gt;libsocket.a&lt;/code&gt; on Solaris, or &lt;code&gt;wsock32.lib&lt;/code&gt; on Windows) to use the communication facilities of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">일부 시스템에서는 &lt;code&gt;libnsl.a&lt;/code&gt; 의 통신 기능을 사용하기 위해 더 많은 라이브러리 (예 : Solaris의 libnsl.a 및 &lt;code&gt;libsocket.a&lt;/code&gt; 또는 Windows의 &lt;code&gt;wsock32.lib&lt;/code&gt; )와 &lt;code&gt;Erl_Interface&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d0471b1a417f337e7d9ebce0c70ef9a7679a721c" translate="yes" xml:space="preserve">
          <source>On success a pointer to the process identifier is returned. On failure &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set.</source>
          <target state="translated">성공하면 프로세스 식별자에 대한 포인터가 반환됩니다. 실패시 &lt;code&gt;NULL&lt;/code&gt; 이 반환되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7cd76559ef60de76711ee9a78bc983a284264cd1" translate="yes" xml:space="preserve">
          <source>On success it should set &lt;code&gt;*ctx&lt;/code&gt; to point to a context for the created socket. This context will be passed to all other socket callbacks. This function will be passed the same &lt;code&gt;setup_context&lt;/code&gt; as passed to the preceeding &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">성공하면 &lt;code&gt;*ctx&lt;/code&gt; 가 생성 된 소켓에 대한 컨텍스트를 가리 키도록 설정해야 합니다. 이 컨텍스트는 다른 모든 소켓 콜백에 전달됩니다. 이 함수는 선행 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt; 호출에 전달 된 것과 동일한 &lt;code&gt;setup_context&lt;/code&gt; 를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="cd81851a39ee097fec934afda86c40e9cc8f6b19" translate="yes" xml:space="preserve">
          <source>On success zero is returned. On failure a posix error code is returned.</source>
          <target state="translated">성공하면 0이 반환됩니다. 실패시 posix 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="09e61d475574f0ccdd55488d9e0d991962394b15" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*sz&lt;/code&gt; should be set to the handshake packet header size to use. Valid values are &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;. Erlang TCP distribution use a handshake packet size of &lt;code&gt;2&lt;/code&gt; and Erlang TLS distribution use a handshake packet size of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;*sz&lt;/code&gt; 를 사용할 핸드 셰이크 패킷 헤더 크기로 설정해야합니다. 유효한 값은 &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;4&lt;/code&gt; 입니다. Erlang TCP 배포는 핸드 셰이크 패킷 크기 &lt;code&gt;2&lt;/code&gt; 를 사용 하고 Erlang TLS 배포는 핸드 셰이크 패킷 크기 &lt;code&gt;4&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="bb868b4886e090c126e2950aab6d84ed7dcb16dc" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;obuf&lt;/code&gt; is initialized to contain table statistics, otherwise &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;0&lt;/code&gt; 이 리턴되고 &lt;code&gt;obuf&lt;/code&gt; 는 테이블 통계를 포함하도록 초기화되고, 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b55c599082e06de776c0bd626fd828b706a34179" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned, the value of the environment variable has been written to the &lt;code&gt;value&lt;/code&gt; buffer, and &lt;code&gt;*value_size&lt;/code&gt; contains the string length (excluding the terminating &lt;code&gt;NULL&lt;/code&gt; character) of the value written to the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">성공시, &lt;code&gt;0&lt;/code&gt; 은 환경 변수의 값이 기록 된, 리턴 &lt;code&gt;value&lt;/code&gt; 버퍼 및 &lt;code&gt;*value_size&lt;/code&gt; 은 (종단을 제외한 문자열 길이를 포함 &lt;code&gt;NULL&lt;/code&gt; 을 받는 기록 된 값의 특성) &lt;code&gt;value&lt;/code&gt; 버퍼.</target>
        </trans-unit>
        <trans-unit id="eddebcdb76f9fab8ab2298752db267fa58432d28" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;conp&lt;/code&gt; is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;conp&lt;/code&gt; 가 연결 클라이언트의 주소와 노드 이름으로 채워지고 파일 설명자가 반환됩니다. 실패하면 &lt;code&gt;ERL_ERROR&lt;/code&gt; 가 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;EIO&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bc86d5b291cc284bbc0ca0e72d47d0adc2e32d6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;v&lt;/code&gt; (and &lt;code&gt;size&lt;/code&gt; if the object is binary) is initialized with the value associated with &lt;code&gt;key&lt;/code&gt;, and the function returns &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_STR&lt;/code&gt;, or &lt;code&gt;EI_BIN&lt;/code&gt;, indicating the type of object. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and the arguments are not updated.</source>
          <target state="translated">성공하면 &lt;code&gt;v&lt;/code&gt; (및 오브젝트가 이진 인 경우 &lt;code&gt;size&lt;/code&gt; )가 &lt;code&gt;key&lt;/code&gt; 와 연관된 값으로 초기화되고 함수는 오브젝트 유형을 나타내는 &lt;code&gt;EI_INT&lt;/code&gt; , &lt;code&gt;EI_FLT&lt;/code&gt; , &lt;code&gt;EI_STR&lt;/code&gt; 또는 &lt;code&gt;EI_BIN&lt;/code&gt; 을 리턴 합니다. 실패하면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 인수는 갱신되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="969e908d49a7fbc3a7e280f38ab4f55f6067faf3" translate="yes" xml:space="preserve">
          <source>On success, a descriptor connecting the calling process to EPMD is returned. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to:</source>
          <target state="translated">성공하면 호출 프로세스를 EPMD에 연결하는 설명자가 반환됩니다. 실패하면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 다음으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c0dc3f3e2f8d8457d666d03550d6d2ac2fec8095" translate="yes" xml:space="preserve">
          <source>On success, a file descriptor is returned which can be used in a call to &lt;code&gt;ei_accept()&lt;/code&gt;. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;ei_accept()&lt;/code&gt; 호출에 사용할 수있는 파일 설명자가 반환됩니다 . 실패하면 &lt;code&gt;ERL_ERROR&lt;/code&gt; 가 반환되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;EIO&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2aec08e035ff2227fedf237e8aaf81890b198c99" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*key&lt;/code&gt; and &lt;code&gt;*value&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if the iterator is positioned at head (before first entry) or tail (beyond last entry).</source>
          <target state="translated">성공하면 &lt;code&gt;*key&lt;/code&gt; 및 &lt;code&gt;*value&lt;/code&gt; 를 설정 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 반복자가 head (첫 번째 항목 이전) 또는 tail (마지막 항목 이외)에 위치한 경우 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="7ef0a43f7b72b72b522ca36cd55aa1e746822b9f" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*pid&lt;/code&gt; to the local process registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered process, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*pid&lt;/code&gt; is unchanged.</source>
          <target state="translated">성공하면 &lt;code&gt;*pid&lt;/code&gt; 를 &lt;code&gt;name&lt;/code&gt; 으로 등록 된 로컬 프로세스로 설정 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 경우 &lt;code&gt;name&lt;/code&gt; 등록 프로세스 없거나 원자 아니다 &lt;code&gt;false&lt;/code&gt; 리턴되고 &lt;code&gt;*pid&lt;/code&gt; 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="073e4acf139e5d3ba364bb27e432c64851509f50" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*port&lt;/code&gt; to the port registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered port, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*port&lt;/code&gt; is unchanged.</source>
          <target state="translated">성공하면 &lt;code&gt;*port&lt;/code&gt; 를 &lt;code&gt;name&lt;/code&gt; 으로 등록 된 포트 로 설정 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 경우 &lt;code&gt;name&lt;/code&gt; 등록 포트 없거나 원자 아니다 &lt;code&gt;false&lt;/code&gt; 리턴되고 &lt;code&gt;*port&lt;/code&gt; 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="939344767976749cae972a1349799f2c2eaf12ef" translate="yes" xml:space="preserve">
          <source>On success, stores the resulting term at &lt;code&gt;*term&lt;/code&gt; and returns the number of bytes read. Returns &lt;code&gt;0&lt;/code&gt; if decoding fails or if &lt;code&gt;opts&lt;/code&gt; is invalid.</source>
          <target state="translated">성공하면 결과 용어를 &lt;code&gt;*term&lt;/code&gt; 에 저장하고 읽은 바이트 수를 리턴합니다. 디코딩이 실패하거나 &lt;code&gt;opts&lt;/code&gt; 가 유효하지 않은 경우 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2e2b683cb27a455b0e37378b692f0fae65bff5e5" translate="yes" xml:space="preserve">
          <source>On success, the function returns 0, updates the &lt;code&gt;erlang_pid&lt;/code&gt; pointed to by the pid parameter, and the &lt;code&gt;node&lt;/code&gt; parameter is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, a negative number is returned.</source>
          <target state="translated">성공하면 함수는 0을 반환 하고 pid 매개 변수가 가리키는 &lt;code&gt;erlang_pid&lt;/code&gt; 를 업데이트 하며 &lt;code&gt;node&lt;/code&gt; 매개 변수는 &lt;code&gt;name&lt;/code&gt; 이 있는 노드 이름으로 초기화 됩니다. 실패하면 음수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c4c049046abd946d86db876a1e3d6ab44c243545" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;Emsg&lt;/code&gt; struct is initialized as described above, or &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;ERL_MSG&lt;/code&gt; 를 리턴 하고 &lt;code&gt;Emsg&lt;/code&gt; 구조체는 위에서 설명한대로 초기화되거나 &lt;code&gt;ERL_TICK&lt;/code&gt; 이며이 경우 메시지가 리턴되지 않습니다. 실패하면 함수는 &lt;code&gt;ERL_ERROR&lt;/code&gt; 를 리턴 하고 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="629b14be4c544ff9f65dc57b340e61cbbb39aafa" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the function returns an opaque error, except the &lt;code&gt;pending_process&lt;/code&gt; error described earlier. The opaque errors are to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 실패시 함수는 앞에서 설명한 &lt;code&gt;pending_process&lt;/code&gt; 오류를 제외하고 불투명 한 오류를 반환합니다 . 불투명 한 오류는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수에 의해 사람이 읽을 수있는 형태로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5f40438c31e5fae2d92b0ab21e0ba8037f1d866" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the return value is &lt;code&gt;{error,ErrorDesc}&lt;/code&gt;, where &lt;code&gt;ErrorDesc&lt;/code&gt; is an opaque term to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 실패한 경우 리턴 값은 &lt;code&gt;{error,ErrorDesc}&lt;/code&gt; 이며 여기서 &lt;code&gt;ErrorDesc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수에 의해 사람이 읽을 수있는 형식으로 변환되는 불투명 한 용어 입니다.</target>
        </trans-unit>
        <trans-unit id="9434e82ca19ea4e7015799cf03a1286d4e4d6516" translate="yes" xml:space="preserve">
          <source>On success, the function returns a descriptor connecting the calling process to EPMD. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 호출 프로세스를 EPMD에 연결하는 설명자를 반환합니다. 실패하면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;EIO&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4a5876f3c7f9a8dde05d398be614c4d3bae58d6" translate="yes" xml:space="preserve">
          <source>On success, the function returns a pointer to the resource type and &lt;code&gt;*tried&lt;/code&gt; is set to either &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; or &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; to indicate what was done. On failure, returns &lt;code&gt;NULL&lt;/code&gt; and sets &lt;code&gt;*tried&lt;/code&gt; to &lt;code&gt;flags&lt;/code&gt;. It is allowed to set &lt;code&gt;tried&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">성공하면 함수는 자원 유형에 대한 포인터를 리턴하고 &lt;code&gt;*tried&lt;/code&gt; 는 수행 된 작업을 표시하기 위해 &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; 또는 &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; 로 설정 됩니다. 실패하면 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 하고 &lt;code&gt;*tried&lt;/code&gt; 를 &lt;code&gt;flags&lt;/code&gt; 로 설정 합니다 . &lt;code&gt;tried&lt;/code&gt; 를 &lt;code&gt;NULL&lt;/code&gt; 로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fed20a53218971de1395aaff5c9c60036d53fb8" translate="yes" xml:space="preserve">
          <source>On success, the function returns an Erlang pid containing the address of the specified name, and the node is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;node&lt;/code&gt; is not modified.</source>
          <target state="translated">성공하면 함수는 지정된 이름의 주소를 포함하는 Erlang pid를 리턴하고 노드는 &lt;code&gt;name&lt;/code&gt; 이 있는 노드 이름으로 초기화 됩니다. 실패하면 &lt;code&gt;NULL&lt;/code&gt; 이 리턴되고 &lt;code&gt;node&lt;/code&gt; 가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="337efc03ad89d708d3afb77816250b7b6e5ac95d" translate="yes" xml:space="preserve">
          <source>On success, the function returns an array of strings, each containing a single registered name, and sets &lt;code&gt;count&lt;/code&gt; to the number of names found. The array is terminated by a single &lt;code&gt;NULL&lt;/code&gt; pointer. On failure, the function returns &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; is not modified.</source>
          <target state="translated">성공하면이 함수는 각각 등록 된 단일 이름을 포함하는 문자열 배열을 반환하고 &lt;code&gt;count&lt;/code&gt; 를 찾은 이름 수로 설정합니다 . 배열은 단일 &lt;code&gt;NULL&lt;/code&gt; 포인터로 종료됩니다 . 실패하면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 하고 &lt;code&gt;count&lt;/code&gt; 는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4272e6f5e6ca873a7a08ed89c16a8a80ef49afd" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt; and indicates its length in &lt;code&gt;size&lt;/code&gt;. If the object is not found or if it is not a binary object, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환 하고 길이를 &lt;code&gt;size&lt;/code&gt; 로 나타냅니다 . 오브젝트가 없거나 2 진 오브젝트가 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. 대역 내 오류보고와 관련된 문제를 방지하려면 (즉, &lt;code&gt;NULL&lt;/code&gt; 과 유효한 결과를 구분할 수없는 경우)보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="05d5be1ae587938fb787490f4e22f1def9a340ce" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a floating point object, &lt;code&gt;-1.0&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1.0&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환합니다 . 객체가 없거나 부동 소수점 객체가 아닌 경우 &lt;code&gt;-1.0&lt;/code&gt; 이 반환됩니다. 대역 내 오류보고와 관련된 문제를 피하려면 (즉, &lt;code&gt;-1.0&lt;/code&gt; 과 유효한 결과를 구별 할 수없는 경우)보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b3820a5ea0fe718970e9f3bbe04885da2999ec49" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a string, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환합니다 . 오브젝트가 없거나 문자열이 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. 대역 내 오류보고와 관련된 문제를 방지하려면 (즉, &lt;code&gt;NULL&lt;/code&gt; 과 유효한 결과를 구분할 수없는 경우)보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f63666e52d190298b2a061e3c8a1ed17bebbd73f" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not an integer object, &lt;code&gt;-1&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;key&lt;/code&gt; 와 관련된 값을 반환합니다 . 오브젝트가 없거나 정수 오브젝트가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 대역 내 오류보고 (즉, &lt;code&gt;-1&lt;/code&gt; 과 유효한 결과를 구별 할 수없는 경우)와 관련된 문제를 피하려면 보다 일반적인 함수 &lt;code&gt;ei_reg_getval()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1519b2c5db86ccdb596ec05a28c63cbcfef77f9b" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;#erlang_msg&quot;&gt;msg&lt;/a&gt;&lt;/code&gt; struct is initialized.</source>
          <target state="translated">성공하면 함수가 &lt;code&gt;ERL_MSG&lt;/code&gt; 를 반환 하고 &lt;code&gt;&lt;a href=&quot;#erlang_msg&quot;&gt;msg&lt;/a&gt;&lt;/code&gt; 구조체가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="826f3f3c68edb8d6a8417ffe459589634fbc1144" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;msg&lt;/code&gt; struct is initialized. &lt;code&gt;erlang_msg&lt;/code&gt; is defined as follows:</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;ERL_MSG&lt;/code&gt; 를 반환 하고 &lt;code&gt;msg&lt;/code&gt; 구조체가 초기화됩니다. &lt;code&gt;erlang_msg&lt;/code&gt; 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2e36d3c841193235e57c861682cf6d25481358db" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">성공하면 메시지가 지정된 버퍼에 배치되고 함수는 실제로 읽은 바이트 수를 리턴합니다. 실패하면 함수는 &lt;code&gt;ERL_ERROR&lt;/code&gt; 를 리턴 하고 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5b25bb3efb4ee6e26cac0f259c10a630574681e4" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns a negative value and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">성공하면 메시지가 지정된 버퍼에 배치되고 함수는 실제로 읽은 바이트 수를 리턴합니다. 실패하면 함수는 음수 값을 리턴하고 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="772f9d0d6c197237442ca0a6e490f7b7f2ebb396" translate="yes" xml:space="preserve">
          <source>On success, the registry is resized, all contents rehashed, and &lt;code&gt;0&lt;/code&gt; is returned. On failure, the registry is left unchanged and &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 레지스트리 크기가 조정되고 모든 내용 이 다시 해시되고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 실패하면 레지스트리가 변경되지 않고 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b55ff64c65276715f5cf5ac620e52f2b4c69380a" translate="yes" xml:space="preserve">
          <source>On systems that support OS signals, it is also possible to stop the runtime system and generate a crash dump by sending the &lt;code&gt;SIGUSR1&lt;/code&gt; signal.</source>
          <target state="translated">OS 신호를 지원하는 시스템에서는 &lt;code&gt;SIGUSR1&lt;/code&gt; 신호 를 전송하여 런타임 시스템을 중지하고 크래시 덤프를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8295dab59d105fcadee920c83d7a0087818d1ff8" translate="yes" xml:space="preserve">
          <source>On tab &lt;strong&gt;Internal Tables&lt;/strong&gt; you can from the left-hand menu select &lt;strong&gt;Hash Tables&lt;/strong&gt;, &lt;strong&gt;Index Tables&lt;/strong&gt;, or &lt;strong&gt;Internal ETS Tables&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;내부 테이블&lt;/strong&gt; 탭 에서 왼쪽 메뉴에서 &lt;strong&gt;해시 테이블&lt;/strong&gt; , &lt;strong&gt;인덱스 테이블&lt;/strong&gt; 또는 &lt;strong&gt;내부 ETS 테이블을&lt;/strong&gt; 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2fcf0646802d9dc8e8b2dc7ce9d29177a614ac1" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Code&lt;/code&gt; page the Erlang source code is displayed. It is possible to search forwards and backwards for text in the module. Enter a regular expression in the &lt;code&gt;Find&lt;/code&gt; field and press enter. It is also possible to go to a certain line in the module. The &lt;code&gt;Back&lt;/code&gt; button can be used to go back to the previous position.</source>
          <target state="translated">온 &lt;code&gt;Code&lt;/code&gt; 페이지 얼랑 소스 코드가 표시됩니다. 모듈에서 텍스트를 앞뒤로 검색 할 수 있습니다. &lt;code&gt;Find&lt;/code&gt; 필드에 정규식을 입력하고 Enter를 누르십시오. 모듈의 특정 줄로 이동할 수도 있습니다. &lt;code&gt;Back&lt;/code&gt; 버튼은 이전 위치로 돌아 가야하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f72d7009505c0a635de5a33f1a164f62ac37178" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the SSL/TLS distribution adds when creating a socket.</source>
          <target state="translated">온 &lt;code&gt;erl&lt;/code&gt; 소켓을 만들 때 SSL / TLS 분포를 추가하는 명령 줄 당신은 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a9c767404e4bacdf3f831aff6d5d541c2d1a85f" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the TLS distribution adds when creating a socket.</source>
          <target state="translated">온 &lt;code&gt;erl&lt;/code&gt; 명령 줄 당신은 소켓을 만들 때 TLS 분포는 추가 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58dd19bfb0b41f363c09999a6e4ad4b9c8bdfec9" translate="yes" xml:space="preserve">
          <source>On the C side, it is necessary to write functions for receiving and sending data with 2 byte length indicators from/to Erlang. By default, the C program is to read from standard input (file descriptor 0) and write to standard output (file descriptor 1). Examples of such functions, &lt;code&gt;read_cmd/1&lt;/code&gt; and &lt;code&gt;write_cmd/2&lt;/code&gt;, follows:</source>
          <target state="translated">C 측에서는 Erlang과 2 바이트 길이 표시기가있는 데이터를 송수신하기위한 기능을 작성해야합니다. 기본적으로 C 프로그램은 표준 입력 (파일 설명자 0)에서 읽고 표준 출력 (파일 설명자 1)에 씁니다. 이러한 함수의 예는 &lt;code&gt;read_cmd/1&lt;/code&gt; 및 &lt;code&gt;write_cmd/2&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b1adca5c0bfea4b4b3f2870a27e174b7d50075f9" translate="yes" xml:space="preserve">
          <source>On the client side the ssl application will save session data to try to automate session reuse on behalf of the client processes on the Erlang node. Note that only verified sessions will be saved for security reasons, that is session resumption relies on the certificate validation to have been run in the original handshake. To minimize memory consumption only unique sessions will be saved unless the special &lt;code&gt;save&lt;/code&gt; value is specified for the following option &lt;code&gt;{reuse_sessions, boolean() | save}&lt;/code&gt; in which case a full handhake will be performed and that specific session will have been saved before the handshake returns. The session id and even an opaque binary containing the session data can be retrieved using &lt;code&gt;ssl:connection_information/1&lt;/code&gt; function. A saved session (guaranteed by the save option) can be explicitly reused using &lt;code&gt;{reuse_session, SessionId}&lt;/code&gt;. Also it is possible for the client to reuse a session that is not saved by the ssl application using &lt;code&gt;{reuse_session, {SessionId, SessionData}}&lt;/code&gt;.</source>
          <target state="translated">클라이언트 측에서 SSL 애플리케이션은 세션 데이터를 저장하여 Erlang 노드의 클라이언트 프로세스를 대신하여 세션 재사용을 자동화합니다. 보안상의 이유로 확인 된 세션 만 저장됩니다. 즉, 세션 재개는 원래 핸드 셰이크에서 실행 된 인증서 유효성 검사에 의존합니다. 메모리 소비를 최소화하기 위해 다음 옵션 &lt;code&gt;{reuse_sessions, boolean() | save}&lt;/code&gt; 특수 &lt;code&gt;save&lt;/code&gt; 값이 지정 되지 않은 경우 고유 한 세션 만 저장됩니다. save} 이 경우 전체 핸드 셰이크가 수행되고 핸드 셰이크가 반환되기 전에 특정 세션이 저장됩니다. 세션 ID 및 세션 데이터를 포함하는 불투명 바이너리도 &lt;code&gt;ssl:connection_information/1&lt;/code&gt; 을 사용하여 검색 할 수 있습니다 .함수. 저장된 세션 (저장 옵션으로 보장됨)은 &lt;code&gt;{reuse_session, SessionId}&lt;/code&gt; 사용하여 명시 적으로 재사용 할 수 있습니다 . 또한 클라이언트는 &lt;code&gt;{reuse_session, {SessionId, SessionData}}&lt;/code&gt; 사용하여 SSL 애플리케이션에 의해 저장되지 않은 세션을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b62b54f6f16d351431e8df23105f4a3d3614069f" translate="yes" xml:space="preserve">
          <source>On the client side, function &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; spawn a temporary client process establishing contact with a TFTP daemon and perform the file transfer.</source>
          <target state="translated">클라이언트 측에서 &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; 함수 는 TFTP 데몬과의 연결을 설정하는 임시 클라이언트 프로세스를 생성하고 파일 전송을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="de8d284e24c9173448479649ca3673e3b9453805" translate="yes" xml:space="preserve">
          <source>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to &lt;code&gt;prepare/5&lt;/code&gt; with the same arguments as &lt;code&gt;open/5&lt;/code&gt; takes. &lt;code&gt;prepare/5&lt;/code&gt; is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function &lt;code&gt;open/5&lt;/code&gt; on the client side. On the client side, function &lt;code&gt;open/5&lt;/code&gt; must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt;, the returned state is forwarded to the user and returned from &lt;code&gt;read_file&lt;/code&gt;/3 or &lt;code&gt;write_file/3&lt;/code&gt;.</source>
          <target state="translated">클라이언트 쪽에서는 콜백 상호 작용이 동일하지만 약간 다르게 시작하고 끝납니다. &lt;code&gt;open/5&lt;/code&gt; 와 동일한 인수로 &lt;code&gt;prepare/5&lt;/code&gt; 를 준비 하는 호출로 시작 합니다. &lt;code&gt;prepare/5&lt;/code&gt; 는 사용자가 제안한 TFTP 옵션의 유효성을 검사하고 승인 된 해당 서브 세트를 반환합니다. 그런 다음 옵션이 서버로 전송되어 동일한 TFTP 옵션 협상 절차를 수행합니다. 서버가 승인 한 옵션 은 클라이언트 측에서 &lt;code&gt;open/5&lt;/code&gt; 기능을 수행하도록 전달됩니다 . 클라이언트 측에서 기능 &lt;code&gt;open/5&lt;/code&gt; 는 모든 옵션을 그대로 승인하거나 전송을 거부해야합니다. 그런 다음 콜백 상호 작용은 서버 측에서 설명한 것과 동일한 패턴을 따릅니다. 마지막 블록이 발견 될 때 &lt;code&gt;read/1&lt;/code&gt; 또는 &lt;code&gt;write/2&lt;/code&gt; 이면 리턴 된 상태가 사용자에게 전달되고 &lt;code&gt;read_file&lt;/code&gt; / 3 또는 &lt;code&gt;write_file/3&lt;/code&gt; 에서 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fb24826c266fe2b7d30c2585ff68e6ee2e2233f" translate="yes" xml:space="preserve">
          <source>On the client side, where the &lt;code&gt;open/5&lt;/code&gt; call has been preceded by a call to &lt;code&gt;prepare/5&lt;/code&gt;, all options must be accepted or rejected.</source>
          <target state="translated">&lt;code&gt;open/5&lt;/code&gt; 통화에 앞서 &lt;code&gt;prepare/5&lt;/code&gt; 를 준비 하는 통화가 있는 클라이언트 측에서는 모든 옵션을 승인하거나 거부해야합니다.</target>
        </trans-unit>
        <trans-unit id="30bc1d9225132fab91da41cb1dc8196b10d81a6f" translate="yes" xml:space="preserve">
          <source>On the destination side the transport service waits for messages. Each message is forwarded to the Megaco application via the megaco:receive_message/4 callback function. The transport service may or may not provide means for blocking and unblocking the reception of the incoming messages.</source>
          <target state="translated">대상 측에서 전송 서비스는 메시지를 기다립니다. 각 메시지는 megaco : receive_message / 4 콜백 함수를 통해 Megaco 애플리케이션으로 전달됩니다. 전송 서비스는 수신 메시지의 수신을 차단 및 차단 해제하기위한 수단을 제공하거나 제공하지 않을 수있다.</target>
        </trans-unit>
        <trans-unit id="8a6a0caacfe77936a01171aa4a2af7bcafb1d066" translate="yes" xml:space="preserve">
          <source>On the heap tuples require a word size for each of its elements as well as for the header. Cons cells always require two words. Adding these things together, we get seven words for the tuples and 26 words for the cons cells. The string &lt;code&gt;&quot;hello world!&quot;&lt;/code&gt; is a list of cons cells and thus requires 24 words. The atom &lt;code&gt;tag&lt;/code&gt; and the integer &lt;code&gt;42&lt;/code&gt; do not require any additional heap memory since it is an &lt;strong&gt;immediate&lt;/strong&gt;. Adding all the terms together, the heap space required in this example should be 33 words.</source>
          <target state="translated">힙 튜플에서 각 요소와 헤더에 대한 단어 크기가 필요합니다. 단점 셀에는 항상 두 단어가 필요합니다. 이 것들을 더하면, 우리는 튜플에 대해 7 개의 단어를 얻고 cons 셀에 대해 26 개의 단어를 얻습니다. 문자열 &lt;code&gt;&quot;hello world!&quot;&lt;/code&gt; 단점 셀 목록이므로 24 단어가 필요합니다. atom &lt;code&gt;tag&lt;/code&gt; 와 정수 &lt;code&gt;42&lt;/code&gt; 는 &lt;strong&gt;즉치&lt;/strong&gt; 이므로 추가 힙 메모리가 필요하지 않습니다 . 모든 용어를 더하면이 예제에서 필요한 힙 공간은 33 단어 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8d08ce8dca231cb0c413cc427e0f7b3615dc40e4" translate="yes" xml:space="preserve">
          <source>On the library page it is possible to control which sources the tool will use. The page is organized as a tree which can be expanded and collapsed by clicking on the little symbol in the beginning of the expandable/collapsible lines.</source>
          <target state="translated">라이브러리 페이지에서 도구가 사용할 소스를 제어 할 수 있습니다. 페이지는 트리로 구성되며 확장 / 축소 가능한 행의 시작 부분에있는 작은 기호를 클릭하여 확장 및 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359fa7aa2c051b4488b5e4f004a78d6117f975d2" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;a@gin&lt;/code&gt;:</source>
          <target state="translated">노드 &lt;code&gt;a@gin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4dcf5e92ec7cf6d33837ea0dba4f2cf9a86307f9" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;b@skeppet&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;b@skeppet&lt;/code&gt; 노드에서 :</target>
        </trans-unit>
        <trans-unit id="504dd890d20c855491af2a80a9207cca701308e3" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;stack&lt;/code&gt; there's an Erlang node &lt;code&gt;ant@stack&lt;/code&gt;, in the shell, type the following:</source>
          <target state="translated">노드 &lt;code&gt;stack&lt;/code&gt; 에는 Erlang 노드 &lt;code&gt;ant@stack&lt;/code&gt; 이 있고 쉘에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="72075800ddf3add147be6be68bd87c4adad1f4d0" translate="yes" xml:space="preserve">
          <source>On the node where the application is started, there is a transaction coordinator process. If the transaction is distributed, there is also a transaction participant process on all the other nodes where commit-work needs to be performed.</source>
          <target state="translated">응용 프로그램이 시작된 노드에는 트랜잭션 조정자 프로세스가 있습니다. 트랜잭션이 분배되면 확약 작업을 수행해야하는 다른 모든 노드에도 트랜잭션 참여자 프로세스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="30fba55f8fe9ca566a03374554f0601d38f82b56" translate="yes" xml:space="preserve">
          <source>On the other hand it worth mentioning that at least all cipher suites that would rely on non-validated algorithms are automatically disabled in FIPS mode.</source>
          <target state="translated">반면, 유효성이 검증되지 않은 알고리즘에 의존하는 적어도 모든 암호 스위트는 FIPS 모드에서 자동으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3d6f6cddc5dd538a25571ab6dae15764b54f7d33" translate="yes" xml:space="preserve">
          <source>On the other hand,</source>
          <target state="translated">반면에</target>
        </trans-unit>
        <trans-unit id="048ff061e68af3024276eb158992cafe58ebd7ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;move c d&lt;/code&gt; is a single instruction. At runtime, the &lt;code&gt;d&lt;/code&gt; operand will be tested to see whether it refers to an X register or a Y register, and a pointer to the register will be set up.</source>
          <target state="translated">반면에 &lt;code&gt;move c d&lt;/code&gt; 는 단일 명령입니다. 런타임에 &lt;code&gt;d&lt;/code&gt; 피연산자는 X 레지스터 또는 Y 레지스터를 참조하는지 확인하기 위해 테스트되며 레지스터에 대한 포인터가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="79d5245ba64d69949e15fc6366d11aa934acec96" translate="yes" xml:space="preserve">
          <source>On the receiving side the transport module receives the message and forwards it to the protocol engine, which decodes it and invokes user callback functions for each transaction. When a user has handled its action requests, it simply returns a list of action replies (or a message error) and the protocol engine uses the encoding module and transport module to compose and forward the message to the originating user.</source>
          <target state="translated">수신 측에서 전송 모듈은 메시지를 수신하여이를 프로토콜 엔진으로 전달합니다. 프로토콜 엔진은이를 해독하고 각 트랜잭션에 대한 사용자 콜백 기능을 호출합니다. 사용자가 작업 요청을 처리하면 작업 응답 목록 (또는 메시지 오류) 만 반환하고 프로토콜 엔진은 인코딩 모듈과 전송 모듈을 사용하여 메시지를 작성하여 사용자에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="823b2c02cd0160bf197b81f01b9301ddf6d5a739" translate="yes" xml:space="preserve">
          <source>On the server side the the &lt;code&gt;{reuse_sessions, boolean()}&lt;/code&gt; option determines if the server will save session data and allow session reuse or not. This can be further customized by the option &lt;code&gt;{reuse_session, fun()}&lt;/code&gt; that may introduce a local policy for session reuse.</source>
          <target state="translated">서버 측에서 &lt;code&gt;{reuse_sessions, boolean()}&lt;/code&gt; 옵션은 서버가 세션 데이터를 저장하고 세션 재사용을 허용할지 여부를 결정합니다. 이것은 세션 재사용을위한 로컬 정책을 도입 할 수있는 &lt;code&gt;{reuse_session, fun()}&lt;/code&gt; 옵션으로 추가로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb2efe7a16721a2ea4eaaca280d15198cd82819c" translate="yes" xml:space="preserve">
          <source>On the server side, the callback interaction starts with a call to &lt;code&gt;open/5&lt;/code&gt; with the registered initial callback state. &lt;code&gt;open/5&lt;/code&gt; is expected to open the (virtual) file. Then either function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is expected to close the (virtual) file and return its last state. Function &lt;code&gt;abort/3&lt;/code&gt; is only used in error situations. Function &lt;code&gt;prepare/5&lt;/code&gt; is not used on the server side.</source>
          <target state="translated">서버 측에서 콜백 상호 작용 은 등록 된 초기 콜백 상태 에서 &lt;code&gt;open/5&lt;/code&gt; 호출로 시작합니다 . &lt;code&gt;open/5&lt;/code&gt; 는 (가상) 파일을 열 것으로 예상됩니다. 그런 다음 전송 된 블록 당 한 번 함수 &lt;code&gt;read/1&lt;/code&gt; 또는 &lt;code&gt;write/2&lt;/code&gt; 가 반복적으로 호출됩니다. 각 함수 호출에서 이전 호출에서 리턴 된 상태가 확보됩니다. 마지막 블록이 발견되면 함수 &lt;code&gt;read/1&lt;/code&gt; 또는 &lt;code&gt;write/2&lt;/code&gt; 는 (가상) 파일을 닫고 마지막 상태를 리턴해야합니다. 기능 &lt;code&gt;abort/3&lt;/code&gt; 은 오류 상황에서만 사용됩니다. 서버 쪽에서는 기능 &lt;code&gt;prepare/5&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f688e5da429c0dc3dd18d9eb9bf400ae2b1e54a" translate="yes" xml:space="preserve">
          <source>On the server side, where there is no preceding &lt;code&gt;prepare/5&lt;/code&gt; call, no new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">사전 &lt;code&gt;prepare/5&lt;/code&gt; 호출 이없는 서버 측에서는 새 옵션을 추가 할 수 없지만 &lt;code&gt;SuggestedOptions&lt;/code&gt; 에 있는 옵션을 생략하거나 &lt;code&gt;AcceptedOptions&lt;/code&gt; 에서 새 값으로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d544406993542a47ac30874abf36e8f76938251" translate="yes" xml:space="preserve">
          <source>On the system settings page it is possible to control some global settings that are used as defaults for all applications. Set the &lt;code&gt;Application inclusion policy&lt;/code&gt; to &lt;code&gt;include&lt;/code&gt; to include all applications that are not explicitly excluded. See &lt;code&gt;incl_cond&lt;/code&gt; (application inclusion) and &lt;code&gt;mod_cond&lt;/code&gt; (module inclusion) in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt; for more info.</source>
          <target state="translated">시스템 설정 페이지에서 모든 응용 프로그램의 기본값으로 사용되는 일부 전역 설정을 제어 할 수 있습니다. 명시 적으로 제외되지 않은 모든 응용 프로그램 을 &lt;code&gt;include&lt;/code&gt; 하도록 &lt;code&gt;Application inclusion policy&lt;/code&gt; 을 설정하십시오 . 자세한 내용 은 모듈 &lt;code&gt;reltool&lt;/code&gt; 의 참조 설명서에서 &lt;code&gt;incl_cond&lt;/code&gt; (응용 프로그램 포함) 및 &lt;code&gt;mod_cond&lt;/code&gt; (모듈 포함)를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="200db783be88f8550d4a8913f57876ec9c489e2e" translate="yes" xml:space="preserve">
          <source>On the third line (or second line depending on the presence of the Emacs directive), arguments can be specified to the emulator, for example:</source>
          <target state="translated">세 번째 줄 (또는 Emacs 지시문의 존재 여부에 따라 두 번째 줄)에서 인수는 에뮬레이터에 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="919203571b510b75243e5425885ce5fd82bf64cd" translate="yes" xml:space="preserve">
          <source>On time-out, the test run is aborted when the current test job is finished. If &lt;code&gt;skip_rest&lt;/code&gt; is provided, the remaining test cases in the current test job are skipped (described later).</source>
          <target state="translated">제한 시간이 초과되면 현재 테스트 작업이 완료되면 테스트 실행이 중단됩니다. 경우 &lt;code&gt;skip_rest&lt;/code&gt; 가 제공되고, 현재의 검사 작업의 나머지 테스트 케이스 (후술) 스킵된다.</target>
        </trans-unit>
        <trans-unit id="94d0fdbeb40f8b7248647cabbfc52c99b7c568d4" translate="yes" xml:space="preserve">
          <source>On unix you can view the manual pages in emacs. In order to find the manual pages, the variable `erlang-root-dir' should be bound to the name of the directory containing the Erlang installation. The name should not include the final slash. Practically, you should add a line on the following form to your ~/.emacs,</source>
          <target state="translated">유닉스에서는 매뉴얼 페이지를 emacs에서 볼 수 있습니다. 매뉴얼 페이지를 찾으려면 변수 'erlang-root-dir'이 Erlang 설치를 포함하는 디렉토리의 이름에 바인딩되어야합니다. 이름에는 마지막 슬래시가 포함되지 않아야합니다. 실제로 다음 형식으로 ~ / .emacs에 줄을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f23caa93086babb9143d00576ee2b68575ed59f9" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt; demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">&lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 가 반환 되면 모니터로 인해 앞으로 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 메시지가 발신자 메시지 대기열에 배치되지 않습니다. 그러나 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 메시지는 호출 전에 호출자 메시지 대기열에 배치 될 수 있습니다. 따라서 일반적으로 모니터링이 중지 된 후 메시지 큐에서 이러한 &lt;code&gt;'DOWN'&lt;/code&gt; 메시지 를 제거하는 것이 좋습니다 . 이 정리가 필요한 경우 &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt; demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="730b25cb05ff67e83ca2df0e26ea964cf618b32a" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">&lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 가 반환 되면 모니터 때문에 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 메시지가 향후 발신자 메시지 큐에 배치되지 않습니다. 그러나 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; 메시지는 호출 전에 호출자 메시지 큐에 배치 될 수 있습니다. 따라서 일반적으로 모니터링이 중지 된 후 메시지 큐에서 이러한 &lt;code&gt;'DOWN'&lt;/code&gt; 메시지 를 제거하는 것이 좋습니다 . 이 정리를 원하면 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8eb33ed8277cd53945b8bd1336967ae012eaa432" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;unlink(Id)&lt;/code&gt; has returned, it is guaranteed that the link between the caller and the entity referred to by &lt;code&gt;Id&lt;/code&gt; has no effect on the caller in the future (unless the link is setup again). If the caller is trapping exits, an &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message from the link can have been placed in the caller's message queue before the call.</source>
          <target state="translated">일단 &lt;code&gt;unlink(Id)&lt;/code&gt; 돌아왔다, 발신자와 개체 사이의 링크가 참조하는 것을 보장 &lt;code&gt;Id&lt;/code&gt; (링크 설정을 다시하지 않는 한) 미래의 호출에 영향을주지 않습니다. 발신자가 트래핑을 종료하는 경우 링크 의 &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; 메시지가 호출 전에 호출자의 메시지 큐에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2da2fd243f88b2358a1e72df5b1691b330413f0" translate="yes" xml:space="preserve">
          <source>Once a port data lock has been created, it must be locked during all operations on the driver queue of the &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">포트 데이터 잠금이 생성되면, 그것은의 드라이버 큐에있는 모든 작업을 수행하는 동안 잠 가야합니다 &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="472161e0880a728a8d14ba236e81c941cac5bdc2" translate="yes" xml:space="preserve">
          <source>Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">일단로드되면 NIF 라이브러리는 영구적입니다. 해당 모듈 코드 버전이 제거 될 때까지 언로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ae5090c73eef20a1901a4262fb628566dc03086" translate="yes" xml:space="preserve">
          <source>Once read, this file produces the same configuration variables as the following text file:</source>
          <target state="translated">읽은 후에이 파일은 다음 텍스트 파일과 동일한 구성 변수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2874f79a41ab6a4167b9cad282ba54a8323fe29c" translate="yes" xml:space="preserve">
          <source>Once the CTH is installed into a certain test run it remains there until its scope is expired. The scope of a CTH depends on when it is installed, see the following table. Function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; is called at the beginning of the scope and function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; is called when the scope ends.</source>
          <target state="translated">CTH가 특정 테스트 실행에 설치되면 범위가 만료 될 때까지 그대로 유지됩니다. CTH의 범위는 설치시기에 따라 다릅니다. 다음 표를 참조하십시오. 범위의 시작 부분에서 함수 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 가 호출되고 범위가 종료되면 함수 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e0d89fa4414f90c8258d08a4cc02467fbf1279" translate="yes" xml:space="preserve">
          <source>Once the appropriate modules are interpreted, breakpoints can be set at relevant locations in the source code. Breakpoints are specified on a line basis. When a process reaches a breakpoint, it stops and waits for commands (&lt;strong&gt;Step&lt;/strong&gt;, &lt;strong&gt;Skip&lt;/strong&gt;, &lt;strong&gt;Continue&lt;/strong&gt; ...) from the user.</source>
          <target state="translated">적절한 모듈이 해석되면 소스 코드의 관련 위치에 중단 점을 설정할 수 있습니다. 중단 점은 라인 단위로 지정됩니다. 프로세스가 중단 점에 도달하면 프로세스가 중지되고 사용자의 명령 ( &lt;strong&gt;Step&lt;/strong&gt; , &lt;strong&gt;Skip&lt;/strong&gt; , &lt;strong&gt;Continue&lt;/strong&gt; ...)을 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="706354aec2cc6d6f0642591cdb86cf2c478e223c" translate="yes" xml:space="preserve">
          <source>Once the data is collected to the server it can be filtered, sorted and printed in many different ways.</source>
          <target state="translated">데이터가 서버에 수집되면 다양한 방법으로 필터링, 정렬 및 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55fa9be76565d3bf8388ee77c4576ca0c50c0cab" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt; driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt; driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">포트 데이터 잠금이 생성되면 포트 데이터 잠금이 잠겨있는 동안 포트 데이터 잠금과 관련된 데이터에 대한 모든 액세스를 수행해야합니다. 포트 데이터 잠금 잠금 및 잠금 해제가 &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt; driver_pdl_lock&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt; driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="ac354611c2ceba110708f663296284723c689ebb" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">포트 데이터 잠금이 작성되면 포트 데이터 잠금이 잠겨있는 동안 포트 데이터 잠금과 연관된 데이터에 대한 모든 액세스가 수행되어야합니다. 포트 데이터 잠금 잠금 및 잠금 해제가 &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="d4566776ad00ac441fb67a63e43838839e8da21d" translate="yes" xml:space="preserve">
          <source>Once the system is built, you might want to change it. Having a test release in some nice directory might be useful, but you can also run Erlang from within the source tree. The target &lt;code&gt;local_setup&lt;/code&gt;, makes the program &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; usable and it also uses all the OTP libraries in the source tree.</source>
          <target state="translated">시스템이 구축되면 시스템을 변경할 수 있습니다. 멋진 디렉토리에 테스트 릴리스가 있으면 유용 할 수 있지만 소스 트리 내에서 Erlang을 실행할 수도 있습니다. 대상 &lt;code&gt;local_setup&lt;/code&gt; 은 &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; 프로그램을 사용 가능하게하며 소스 트리의 모든 OTP 라이브러리도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad8f7b7317e234e5165d7fda5e02abbb7d93475a" translate="yes" xml:space="preserve">
          <source>Once you have a lock counting enabled VM the module &lt;code&gt;lcnt&lt;/code&gt; can be used. The module is intended to be used from the current running nodes shell. To access remote nodes use &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; and &lt;code&gt;lcnt:collect(Node)&lt;/code&gt;.</source>
          <target state="translated">잠금 계산이 활성화 된 VM이 있으면 &lt;code&gt;lcnt&lt;/code&gt; 모듈을 사용할 수 있습니다. 이 모듈은 현재 실행중인 노드 셸에서 사용하도록 설계되었습니다. 원격 노드에 액세스하려면 &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; 및 &lt;code&gt;lcnt:collect(Node)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe6fa81042f05838c7c931d240a87fc23ec1e33e" translate="yes" xml:space="preserve">
          <source>Once you have chosen the modules or directories you want to analyze, click the &lt;strong&gt;Run&lt;/strong&gt; button to start the analysis. If you for some reason want to stop the analysis while it is running, click the &lt;strong&gt;Stop&lt;/strong&gt; button.</source>
          <target state="translated">분석하려는 모듈 또는 디렉토리를 선택한 후 &lt;strong&gt;실행&lt;/strong&gt; 단추를 클릭 하여 분석을 시작하십시오. 어떤 이유로 분석이 실행되는 동안 분석을 &lt;strong&gt;중지&lt;/strong&gt; 하려면 &lt;strong&gt;중지&lt;/strong&gt; 단추를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1866013abe7a3a8a91c1626525b2105bdb78c26" translate="yes" xml:space="preserve">
          <source>One MIB can communicate with many applications.</source>
          <target state="translated">하나의 MIB가 많은 응용 프로그램과 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6ac6f5e1f4c553d516e35fd92ef8609ef86d4a" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit(1, second, native)&lt;/a&gt;&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit(1, second, native)&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;code&gt;native&lt;/code&gt; 시간 단위 의 근사치를 얻을 수 있습니다 . 결과는 초당 전체 &lt;code&gt;native&lt;/code&gt; 시간 단위 수와 같습니다 . 수있는 경우 &lt;code&gt;native&lt;/code&gt; 초당 시간 단위는 정수로 추가하지 않습니다, 결과는 둥근 아래입니다.</target>
        </trans-unit>
        <trans-unit id="7314739d088633c38ec313d94ecdc0d77f14a5ba" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">&lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt; 를 호출 하여 &lt;code&gt;native&lt;/code&gt; 시간 단위 의 근사값을 얻을 수 있습니다 . 결과는 초당 전체 &lt;code&gt;native&lt;/code&gt; 시간 단위 수와 같습니다 . 수있는 경우 &lt;code&gt;native&lt;/code&gt; 초당 시간 단위는 정수로 추가하지 않습니다, 결과는 둥근 아래입니다.</target>
        </trans-unit>
        <trans-unit id="ef10c93f15b1c52938ec7e181160a865ba85041c" translate="yes" xml:space="preserve">
          <source>One critical issue to note here is that any term on the young heap can reference terms on the old heap but &lt;strong&gt;no&lt;/strong&gt; term on the old heap may refer to a term on the young heap. This is due to the nature of the copy algorithm. Anything referenced by an old heap term is not included in the reference tree, root-set and its followers, and hence is not copied. If it was, the data would be lost, fire and brimstone would rise to cover the earth. Fortunately, this comes naturally for Erlang because the terms are immutable and thus there can be no pointers modified on the old heap to point to the young heap.</source>
          <target state="translated">여기서 주목해야 할 한 가지 중요한 문제는 젊은 힙의 모든 용어는 이전 힙의 용어를 참조 할 수 있지만 이전 힙의 용어는 젊은 힙의 용어를 참조 할 수 &lt;strong&gt;없다는&lt;/strong&gt; 것입니다. 이것은 복사 알고리즘의 특성 때문입니다. 이전 힙 용어로 참조 된 모든 항목은 참조 트리, 루트 세트 및 해당 팔로워에 포함되지 않으므로 복사되지 않습니다. 그렇다면 데이터가 손실되고 불과 유황이 지구를 덮을 것입니다. 운 좋게도 Erlang은 용어가 불변하고 따라서 이전 힙에서 젊은 힙을 가리키는 포인터를 수정할 수 없기 때문에 자연스럽게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0c004d9fe4418301daaece7534ddb42246eb9542" translate="yes" xml:space="preserve">
          <source>One entry per allocator. See &lt;code&gt;Allocator&lt;/code&gt; in section &quot;How to Interpret the Erlang Crash Dumps&quot; in ERTS.</source>
          <target state="translated">할당 자당 하나의 항목. ERTS의 &quot;Erlang 크래시 덤프 해석 방법&quot;섹션의 &lt;code&gt;Allocator&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5ae873b8dbf85d90619c54d5534f4bb29cc5b20" translate="yes" xml:space="preserve">
          <source>One example for this is to pre-process incoming data, for example decrypting chunks or collecting characters up to a line break.</source>
          <target state="translated">이에 대한 한 가지 예는 청크를 해독하거나 줄 바꿈까지 문자를 수집하는 등 수신 데이터를 사전 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a14d428a902184f6d393d8bd6140890e2ae77f4b" translate="yes" xml:space="preserve">
          <source>One exception is pattern matching of binaries. The compiler does not rearrange clauses that match binaries. Placing the clause that matches against the empty binary &lt;strong&gt;last&lt;/strong&gt; is usually slightly faster than placing it &lt;strong&gt;first&lt;/strong&gt;.</source>
          <target state="translated">바이너리의 패턴 일치는 예외입니다. 컴파일러는 이진과 일치하는 절을 재 배열하지 않습니다. 빈 바이너리와 &lt;strong&gt;마지막으로&lt;/strong&gt; 일치하는 절을 배치하는 것이 일반적으로 &lt;strong&gt;먼저&lt;/strong&gt; 배치하는 것보다 약간 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="7d94c70dc04626571d8ea05626b35349d3398b38" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function</source>
          <target state="translated">유한 상태 머신 용 ( &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 과 유사), 상태는 원자 여야하며 해당 상태를 현재 콜백 함수의 이름으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3f8d27506d8e90d0a22e543f80e99c7ae08237b4" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function.</source>
          <target state="translated">하나는 유한 상태 머신 ( &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; 과 유사)을위한 것으로, 상태가 원자 여야하고 해당 상태를 현재 콜백 함수의 이름으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3770c544733aa5fb6e0292ae22987354af0a4e69" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to ignore and pass on directly to the emulator (those following &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 그룹 중 하나 는 무시하고 에뮬레이터에 직접 전달하는 것입니다 ( &lt;code&gt;-erl_args&lt;/code&gt; 다음에 오는 그룹 ).</target>
        </trans-unit>
        <trans-unit id="d6a260162de88ba81cc22f21bd78e10fba85db33" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to process (those preceding &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 가 처리 할 하나의 그룹 (앞의 &lt;code&gt;-erl_args&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="614890ec6bea0b6110430c451657204a01ec779e" translate="yes" xml:space="preserve">
          <source>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</source>
          <target state="translated">후행 LF를 포함하여 파일에서 한 줄이 반환되지만 CRLF 시퀀스가 ​​단일 LF로 대체됩니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="cdb5ea69a08925e346c04bb8f306808dfae21189" translate="yes" xml:space="preserve">
          <source>One log file, &lt;code&gt;run_erl.log&lt;/code&gt;, which logs progress and warnings from the &lt;code&gt;run_erl&lt;/code&gt; program itself.</source>
          <target state="translated">&lt;code&gt;run_erl&lt;/code&gt; 프로그램 자체 의 진행 및 경고를 기록하는 하나의 로그 파일 &lt;code&gt;run_erl.log&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19cc7e16964b3af0e44bb854d9aa8967052724d4" translate="yes" xml:space="preserve">
          <source>One may also convert arbitrary data to XML. So it for instance is easy to make it readable by humans. In this case you first create xmerl data structures out of your data, then transform it to XML.</source>
          <target state="translated">임의의 데이터를 XML로 변환 할 수도 있습니다. 예를 들어 사람이 쉽게 읽을 수 있습니다. 이 경우 먼저 데이터에서 xmerl 데이터 구조를 작성한 다음 XML로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ed6a90e414ee1584a7c5f1f7c5472363c8f0e272" translate="yes" xml:space="preserve">
          <source>One must be careful not to create infinite loops. For example, if we for some reason would want to reverse the operand order for the &lt;code&gt;move&lt;/code&gt; instruction, we must not do like this:</source>
          <target state="translated">무한 루프를 만들지 않도록주의해야합니다. 예를 들어, 어떤 이유로 &lt;code&gt;move&lt;/code&gt; 명령어 의 피연산자 순서를 반대로하려면 다음과 같이하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d6d6f92b8658a1866e9d8146c603570466b38bb9" translate="yes" xml:space="preserve">
          <source>One network RPC (two messages) to acquire the write lock</source>
          <target state="translated">쓰기 잠금을 획득하기위한 네트워크 RPC 1 개 (메시지 2 개)</target>
        </trans-unit>
        <trans-unit id="00a56ba397ce141f9962051dd004c70978ba6dd8" translate="yes" xml:space="preserve">
          <source>One nice thing with the &lt;code&gt;trace_pattern&lt;/code&gt; is that it provides a very simple way of minimizing the amount of generated trace data by allowing you to explicitly control the detail level of the tracing. As you may have seen the &lt;code&gt;et_viewer&lt;/code&gt; have a slider called &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; that allows you to control the detail level of the trace &lt;code&gt;Events&lt;/code&gt; displayed in the &lt;code&gt;Viewer&lt;/code&gt;. On the other hand if you set a low detail level in the &lt;code&gt;trace_pattern&lt;/code&gt;, lots of the trace data will never be generated and thus not sent over the socket to the trace client and stored in the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace_pattern&lt;/code&gt; 의 한 가지 좋은 점 은 추적의 세부 사항 레벨을 명시 적으로 제어 할 수있게하여 생성 된 추적 데이터의 양을 최소화하는 매우 간단한 방법을 제공한다는 것입니다. &lt;code&gt;et_viewer&lt;/code&gt; 본 것처럼 et_viewer 에는 &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; 이라는 슬라이더 가있어 &lt;code&gt;Viewer&lt;/code&gt; 에 표시되는 추적 &lt;code&gt;Events&lt;/code&gt; 의 세부 수준을 제어 할 수 있습니다 . 반면에 &lt;code&gt;trace_pattern&lt;/code&gt; 에서 낮은 세부 수준을 설정하면 많은 추적 데이터가 생성되지 않으므로 소켓을 통해 추적 클라이언트로 전송되지 않고 &lt;code&gt;Collector&lt;/code&gt; 저장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4529738d7c5d95ab24a59e21df7882f76ad41b01" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&quot;Error&quot;&lt;/code&gt;, &lt;code&gt;&quot;Warning&quot;&lt;/code&gt;, &lt;code&gt;&quot;Informational&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; or, in case of a currently unknown Windows NT version &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt;.</source>
          <target state="translated">하나의 &lt;code&gt;&quot;Error&quot;&lt;/code&gt; , &lt;code&gt;&quot;Warning&quot;&lt;/code&gt; , &lt;code&gt;&quot;Informational&quot;&lt;/code&gt; , &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt; , &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; 현재 알 수없는 Windows NT 버전의 경우 또는, &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8715b5dac001f8acd8e786d5f72ce95270b48d8" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_event&lt;/code&gt; 상태 를 가져 오기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . 이 경우 &lt;code&gt;Opt&lt;/code&gt; 는 원자 &lt;code&gt;normal&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4ea7befab7a1376dc38a902be4e17f510f6d524" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 상태 를 가져 오기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . &lt;code&gt;Opt&lt;/code&gt; 는 원자 &lt;code&gt;normal&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1a6b0b2d35c017b6e03a9c4a65c9d58e6870f08" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_event&lt;/code&gt; 상태 를 얻기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;normal&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7da5bbc0da1569bb676eb4407e53fc819a024b48" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 상태 를 얻기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;normal&lt;/code&gt; 로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="eb296f4b0ca5c3593de75916329b44424ed9130b" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_statem&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 상태 를 얻기 위해 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 중 하나 가 호출됩니다 . 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;normal&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdb44fc1b32a8df8e66016b4df34ca5e01e3c2a5" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="4929df166f7d8de83e743d85b22e80a274c8fcf4" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;Host&lt;/code&gt; and &lt;code&gt;Service&lt;/code&gt; may be &lt;code&gt;undefined&lt;/code&gt; but &lt;strong&gt;not&lt;/strong&gt; both.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; 및 &lt;code&gt;Service&lt;/code&gt; 중 하나 가 &lt;code&gt;undefined&lt;/code&gt; 있지만 둘다는 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="56827b36a41cbbd74b980c5f475d1ddd1caffbc8" translate="yes" xml:space="preserve">
          <source>One of the UTF-encodings, which is specified as parameter &lt;code&gt;InEncoding&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;InEncoding&lt;/code&gt; 으로 지정된 UTF 인코딩 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="2585f7fa5d9239f75ea13c3267959aa775292560" translate="yes" xml:space="preserve">
          <source>One of the cornerstones of security in SSH is cryptography. The development in crypto analysis is fast, and yesterday's secure algorithms are unsafe today. Therefore some algorithms are no longer enabled by default and that group grows with time. See the &lt;code&gt;SSH (App)&lt;/code&gt; for a list of supported and of disabled algorithms. In the User's Guide the chapter &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; describes the options for enabling or disabling algorithms - &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SSH 보안의 초석 중 하나는 암호화입니다. 암호화 분석의 발전은 빠르며 어제의 보안 알고리즘은 오늘날 안전하지 않습니다. 따라서 일부 알고리즘은 더 이상 기본적으로 활성화되지 않으며 해당 그룹은 시간이 지남에 따라 증가합니다. 지원 및 비활성화 된 알고리즘 목록은 &lt;code&gt;SSH (App)&lt;/code&gt; 를 참조하십시오 . 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; 장에서는 알고리즘 을 활성화 또는 비활성화하는 옵션 ( &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; )에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="bf5094e20e8e0457a5a8f2279ba88b4ba2472732" translate="yes" xml:space="preserve">
          <source>One of the kernel processes could not start. This is probably because of faulty arguments (like errors in a &lt;code&gt;-config&lt;/code&gt; argument) or faulty configuration files. Check that all files are in their correct location and that the configuration files (if any) are not damaged. Usually messages are also written to the controlling terminal and/or the error log explaining what is wrong.</source>
          <target state="translated">커널 프로세스 중 하나를 시작할 수 없습니다. 이는 인수가 잘못 되었거나 ( &lt;code&gt;-config&lt;/code&gt; 인수의 오류와 같은 ) 구성 파일 이 잘못 되었기 때문일 수 있습니다. 모든 파일이 올바른 위치에 있고 구성 파일 (있는 경우)이 손상되지 않았는지 확인하십시오. 일반적으로 메시지는 제어 터미널 및 / 또는 잘못된 내용을 설명하는 오류 로그에도 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0841995ee62550fe5206c50f4fb1982a4e801b20" translate="yes" xml:space="preserve">
          <source>One of the main reasons for using Erlang instead of other functional languages is Erlang's ability to handle concurrency and distributed programming. By concurrency is meant programs that can handle several threads of execution at the same time. For example, modern operating systems allow you to use a word processor, a spreadsheet, a mail client, and a print job all running at the same time. Each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs at such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an Erlang program and to allow these threads to communicate with each other. In Erlang, each thread of execution is called a &lt;strong&gt;process&lt;/strong&gt;.</source>
          <target state="translated">다른 기능 언어 대신 Erlang을 사용하는 주된 이유 중 하나는 동시성 및 분산 프로그래밍을 처리 할 수있는 Erlang의 기능입니다. 동시성은 여러 실행 스레드를 동시에 처리 할 수있는 프로그램을 의미합니다. 예를 들어 최신 운영 체제에서는 워드 프로세서, 스프레드 시트, 메일 클라이언트 및 인쇄 작업을 모두 동시에 실행할 수 있습니다. 시스템의 각 프로세서 (CPU)는 한 번에 하나의 스레드 (또는 작업) 만 처리 할 수 ​​있지만 동시에 모든 작업을 실행한다는 착각을주는 속도로 작업간에 교환합니다. Erlang 프로그램에서 병렬 실행 스레드를 작성하고 이들 스레드가 서로 통신 할 수 있습니다. Erlang에서는 각 실행 스레드를 &lt;strong&gt;프로세스&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="9c3a03a73b3fd84a50282a6c958644d8dd3d3c26" translate="yes" xml:space="preserve">
          <source>One of the possible &lt;strong&gt;transition actions&lt;/strong&gt; is to postpone the current event. Then it is not retried in the current state. The &lt;code&gt;gen_statem&lt;/code&gt; engine keeps a queue of events divided into the postponed events and the events still to process. After a &lt;strong&gt;state change&lt;/strong&gt; the queue restarts with the postponed events.</source>
          <target state="translated">가능한 &lt;strong&gt;전환 작업&lt;/strong&gt; 중 하나는 현재 이벤트를 연기하는 것입니다. 그러면 현재 상태에서 재 시도되지 않습니다. &lt;code&gt;gen_statem&lt;/code&gt; 의 엔진은 프로세스에 여전히 연기 이벤트와 이벤트로 나누어 이벤트 큐를 유지합니다. 후 &lt;strong&gt;상태 변경&lt;/strong&gt; 연기 된 이벤트와 큐가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="f9c1395f01aa6569ad6f5518bd05795ed28e86fb" translate="yes" xml:space="preserve">
          <source>One of the things you can specify is where Erlang/OTP should be installed. By default Erlang/OTP will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. To keep the same structure but install in a different place, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; say, use the &lt;code&gt;--prefix&lt;/code&gt; argument like this: &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">지정할 수있는 것 중 하나는 Erlang / OTP가 설치되는 위치입니다. 기본적으로 Erlang / OTP는 &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; 에 설치 됩니다. 동일한 구조를 유지하지만 다른 위치에 설치하려면, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; 말의 사용 &lt;code&gt;--prefix&lt;/code&gt; 이 같은 인수 &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eeb7842fcafd703c9e0619139450ba12ea61a05" translate="yes" xml:space="preserve">
          <source>One of the tuples is &lt;code&gt;{timeout, GcTime}&lt;/code&gt;, where &lt;code&gt;GcTime&lt;/code&gt; is the time for the garbage collection in milliseconds. The other tuples are tagged with &lt;code&gt;heap_size&lt;/code&gt;, &lt;code&gt;heap_block_size&lt;/code&gt;, &lt;code&gt;stack_size&lt;/code&gt;, &lt;code&gt;mbuf_size&lt;/code&gt;, &lt;code&gt;old_heap_size&lt;/code&gt;, and &lt;code&gt;old_heap_block_size&lt;/code&gt;. These tuples are explained in the description of trace message &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;). New tuples can be added, and the order of the tuples in the &lt;code&gt;Info&lt;/code&gt; list can be changed at any time without prior notice.</source>
          <target state="translated">튜플 중 하나는 &lt;code&gt;{timeout, GcTime}&lt;/code&gt; . 여기서 &lt;code&gt;GcTime&lt;/code&gt; 은 가비지 콜렉션 시간 (밀리 초)입니다. 다른 튜플에는 &lt;code&gt;heap_size&lt;/code&gt; , &lt;code&gt;heap_block_size&lt;/code&gt; , &lt;code&gt;stack_size&lt;/code&gt; , &lt;code&gt;mbuf_size&lt;/code&gt; , &lt;code&gt;old_heap_size&lt;/code&gt; 및 &lt;code&gt;old_heap_block_size&lt;/code&gt; 태그가 지정됩니다 . 이 튜플은 추적 메시지 &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; 의 설명에 설명되어 있습니다 ( &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 참조 ). 새 튜플을 추가 할 수 있으며 &lt;code&gt;Info&lt;/code&gt; 목록 의 튜플 순서는 언제든지 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69a9014859b12f37b0519806ad1834d826c6c31a" translate="yes" xml:space="preserve">
          <source>One of these MIBs is always loaded. If only SNMPv1 is used, STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.</source>
          <target state="translated">이러한 MIB 중 하나가 항상로드됩니다. SNMPv1 만 사용하면 STANDARD-MIB가로드되고, 그렇지 않으면 SNMPv2-MIB가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="7e580959901caa525ce54698db0283f68f4a7825" translate="yes" xml:space="preserve">
          <source>One option is available:</source>
          <target state="translated">하나의 옵션을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6ff4f2ec7cb45924fc22a9581c0d12e7c6a17439" translate="yes" xml:space="preserve">
          <source>One or more records have possibly been deleted. All records with the key &lt;code&gt;Key&lt;/code&gt; in the table &lt;code&gt;Tab&lt;/code&gt; have been deleted.</source>
          <target state="translated">하나 이상의 레코드가 삭제되었을 수 있습니다. 테이블 &lt;code&gt;Tab&lt;/code&gt; 에서 키 &lt;code&gt;Key&lt;/code&gt; 가있는 모든 레코드 가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="6fa66ab663063997cdb9c048f7104f3433cd5c89" translate="yes" xml:space="preserve">
          <source>One or more selective decode functions can be described in a configuration file. Use the following notation:</source>
          <target state="translated">하나 이상의 선택적 디코딩 기능이 구성 파일에 설명 될 수 있습니다. 다음 표기법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e8538d4b29bcc1590b46f99d089134dbfb209ae" translate="yes" xml:space="preserve">
          <source>One possible use of this function is to compute a fixed layout for a document, which can then be included as part of a larger document. For example:</source>
          <target state="translated">이 기능을 사용할 수있는 한 가지 방법은 문서의 고정 레이아웃을 계산 한 다음 더 큰 문서의 일부로 포함시킬 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f814b315540a519172775a3b2360fd1f8b22e518" translate="yes" xml:space="preserve">
          <source>One process can block multi-scheduling and normal multi-scheduling multiple times. If a process has blocked multiple times, it must unblock exactly as many times as it has blocked before it has released its multi-scheduling block. If a process that has blocked multi-scheduling or normal multi-scheduling exits, it automatically releases its blocking of multi-scheduling and normal multi-scheduling.</source>
          <target state="translated">하나의 프로세스는 다중 예약 및 일반 다중 예약을 여러 번 차단할 수 있습니다. 프로세스가 여러 번 차단 된 경우 다중 예약 블록을 해제하기 전에 차단 된 횟수만큼 정확하게 차단을 해제해야합니다. 다중 예약 또는 일반 다중 예약을 차단 한 프로세스가 종료되면 자동으로 다중 예약 및 일반 다중 예약 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1d0d9b681492f79f0f0d77d94d063833656c4e" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">이것을 사용하는 한 가지 이유는 변경 될 때 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; 을 취소해야하는 상태 항목이 있거나 연기 된 이벤트와 함께 이벤트 처리에 영향을주는 것입니다. 우리는 후자에 대해 구성 가능한 잠금 버튼 (이것은 문제의 상태 항목 임)을 &lt;code&gt;open&lt;/code&gt; 이전 예제를 복잡하게 할 것입니다.이 상태는 열린 상태에서 즉시 문을 잠그고 API 함수 &lt;code&gt;set_lock_button/1&lt;/code&gt; 은 잠금 버튼을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f23d4aa95b25f50a19f9b6b4374f1b88dac66685" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">이를 사용하는 한 가지 이유는 변경시 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; 취소해야하는 상태 항목이 있거나 이벤트 연기와 함께 이벤트 처리에 영향을주는 항목이있을 때 입니다. 후자에 대해 살펴보고 &lt;code&gt;open&lt;/code&gt; 상태에서 즉시 문을 잠그는 구성 가능한 잠금 버튼 (문제의 상태 항목) 과 잠금 버튼을 설정 하는 API 함수 &lt;code&gt;set_lock_button/1&lt;/code&gt; 을 도입하여 이전 예제를 복잡하게 만들 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c6a0ffbab932f1acb483f5ff3812f8940806157e" translate="yes" xml:space="preserve">
          <source>One slight difference is that &lt;code&gt;length(L)&lt;/code&gt; fails if &lt;code&gt;L&lt;/code&gt; is an improper list, while the pattern in the second code fragment accepts an improper list.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 이 부적절한 목록 인 경우 &lt;code&gt;length(L)&lt;/code&gt; 가 실패하는 반면, 두 번째 코드 조각의 패턴은 부적절한 목록을 허용 한다는 점에서 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="131ac9dcf4813fc8eef42652b85941c718619c49" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to make the snmp application a distributed Erlang application, and that means, the agent may be configured to run on one of several nodes. If the node where it runs goes down, another node restarts the agent. This is called &lt;strong&gt;failover&lt;/strong&gt;. When the node starts again, it may &lt;strong&gt;takeover&lt;/strong&gt; the application. This solution to the problem adds another problem. Generally, the new node has another IP address than the first one, which may cause problems in the communication between the SNMP managers and the agent.</source>
          <target state="translated">이 문제점에 대한 한 가지 해결책은 snmp 애플리케이션을 분산 Erlang 애플리케이션으로 만드는 것입니다. 즉, 에이전트가 여러 노드 중 하나에서 실행되도록 구성 될 수 있습니다. 실행중인 노드가 다운되면 다른 노드가 에이전트를 다시 시작합니다. 이를 &lt;strong&gt;장애 조치&lt;/strong&gt; 라고 합니다. 노드가 다시 시작되면 응용 프로그램을 &lt;strong&gt;인계&lt;/strong&gt; 할 수 있습니다 . 이 문제에 대한 해결책은 또 다른 문제를 추가합니다. 일반적으로 새 노드는 첫 번째 노드와 다른 IP 주소를 가지므로 SNMP 관리자와 에이전트 간의 통신에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4512e5220c29e6a7833a429e6e4b986d799dd593" translate="yes" xml:space="preserve">
          <source>One such debug functionality is the &lt;strong&gt;lock checker&lt;/strong&gt;, which can detect locking order violations and thereby potential deadlock bugs. For the lock checker to work the &lt;code&gt;name&lt;/code&gt; should be on the format &lt;code&gt;&quot;App.Type&quot;&lt;/code&gt; or &lt;code&gt;&quot;App.Type[Instance]&quot;&lt;/code&gt;, where App is the name of the application, Type is the name of the lock type and Instance is optional information about each lock instance. &quot;App.Type&quot; should be a unique name for the lock checker to detect lock order violations between locks of different types. The Instance information is currently ignored.</source>
          <target state="translated">이러한 디버그 기능 중 하나는 &lt;strong&gt;잠금 검사기&lt;/strong&gt; 이며, 잠금 순서 위반 및 잠재적 교착 상태 버그를 감지 할 수 있습니다. 잠금 검사기가 작동하려면 &lt;code&gt;name&lt;/code&gt; 은 &lt;code&gt;&quot;App.Type&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;App.Type[Instance]&quot;&lt;/code&gt; 형식이어야합니다. 여기서 App은 응용 프로그램의 이름이고 Type은 잠금 유형의 이름이고 Instance는 선택적 정보입니다. 각 잠금 인스턴스에 대해. &quot;App.Type&quot;은 다른 유형의 잠금간에 잠금 순서 위반을 감지하기 위해 잠금 검사기의 고유 한 이름이어야합니다. 인스턴스 정보는 현재 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6de0b12460a91c3f5fd94e39bda2873b3f5b7b16" translate="yes" xml:space="preserve">
          <source>One that allows the state to be any term and that uses one callback function for all states.</source>
          <target state="translated">상태를 임의의 용어로 허용하고 모든 상태에 대해 하나의 콜백 함수를 사용하는 것.</target>
        </trans-unit>
        <trans-unit id="2ae865e27e4e371daac0c98d141254785bdec512" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log.</source>
          <target state="translated">이 기능의 한 가지 용도는 로그 파일에 큰 상태 용어가 인쇄되지 않도록 간단한 대체 상태 표현을 반환하는 것입니다. 또 다른 용도는 민감한 데이터가 오류 로그에 기록되지 않도록 숨기는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2344ac8a5a53008ccbf114aa5bb4b2144babab77" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.</source>
          <target state="translated">이 함수의 사용 중 하나는 큰 상태 용어가 로그 파일에 인쇄되지 않도록 간단한 대체 상태 표현을 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ecf62d4adfa3a80a6880d79089f74bc1229726c5" translate="yes" xml:space="preserve">
          <source>One valid &lt;code&gt;Item&lt;/code&gt; for events exists:</source>
          <target state="translated">이벤트에 유효한 &lt;code&gt;Item&lt;/code&gt; 하나 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1de3f4f0701ff8998dbe849ff16761b4287d4cb" translate="yes" xml:space="preserve">
          <source>One way to handle this is to use the &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;shutdown&lt;/a&gt;&lt;/code&gt; function (&lt;code&gt;socket:shutdown(Socket, write)&lt;/code&gt;) to signal that no more data is to be sent and then wait for the read side of the socket to be closed.</source>
          <target state="translated">이를 처리하는 한 가지 방법은 &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;shutdown&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;socket:shutdown(Socket, write)&lt;/code&gt; )를 사용하여 더 이상 데이터가 전송되지 않음을 알리고 소켓의 읽기 쪽이 닫힐 때까지 기다리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="78dac560fa843dd6f0f972d52ed8040ce20cb74d" translate="yes" xml:space="preserve">
          <source>One way to reduce the risk of intrusion is to not convey which software and which version the intruder is connected to. This limits the risk of an intruder exploiting known faults or peculiarities learned by reading the public code.</source>
          <target state="translated">침입 위험을 줄이는 한 가지 방법은 침입자가 연결된 소프트웨어 및 버전을 전달하지 않는 것입니다. 이는 침입자가 공개 코드를 읽음으로써 알게 된 알려진 결함이나 특성을 악용 할 위험을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="0530e4915fd69c53963bcd7d20091d18ef6b916a" translate="yes" xml:space="preserve">
          <source>One without restriction on the state data type that uses one callback function for all states</source>
          <target state="translated">모든 상태에 대해 하나의 콜백 함수를 사용하는 상태 데이터 유형에 제한이없는 것</target>
        </trans-unit>
        <trans-unit id="125ef9e0e55df17c031033b5d420b053905b830e" translate="yes" xml:space="preserve">
          <source>Online Help</source>
          <target state="translated">온라인 도움말</target>
        </trans-unit>
        <trans-unit id="6fbd38dfe616170f1b6def311df7bb7a510f025b" translate="yes" xml:space="preserve">
          <source>Online support - &lt;code&gt;release_handler&lt;/code&gt; for unpacking and installing release packages</source>
          <target state="translated">온라인 지원- 릴리스 패키지의 포장 풀기 및 설치를위한 &lt;code&gt;release_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae87ac2b337c683a338363cdb6dd6e6e3a876d81" translate="yes" xml:space="preserve">
          <source>Only a subset is valid.</source>
          <target state="translated">하위 집합 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="85e8ca2afe642fa985ec03b77e6580554e8210e3" translate="yes" xml:space="preserve">
          <source>Only a subset of all &lt;code&gt;erts_alloc&lt;/code&gt; flags can be changed at run time. This subset is currently only the flag &lt;code&gt;sbct&lt;/code&gt;.</source>
          <target state="translated">런타임시 모든 &lt;code&gt;erts_alloc&lt;/code&gt; 플래그 의 서브 세트 만 변경할 수 있습니다. 이 서브 세트는 현재 플래그 &lt;code&gt;sbct&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fc50435c4f101d7fcbdd1178cc4fb637fb7e775" translate="yes" xml:space="preserve">
          <source>Only a subset of the function clauses are show above. The full set of valid combinations of input parameters is as follows:</source>
          <target state="translated">함수 절의 하위 집합 만 위에 표시됩니다. 입력 매개 변수의 유효한 전체 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a71b05d84131dd4964afd0db7b460b38e844ff2b" translate="yes" xml:space="preserve">
          <source>Only actual parameters with other than default values are returned, for example not directives that specify other sources for configuration parameters nor directives that clear parameters.</source>
          <target state="translated">구성 매개 변수의 다른 소스를 지정하는 지시문이나 매개 변수를 지우는 지시문이 아닌 기본값 이외의 실제 매개 변수 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="143811c603bbe64ab0e87b64c4ca39d3733d06c3" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;if&lt;/code&gt; or another &lt;code&gt;elif&lt;/code&gt; directive. If the preceding &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;elif&lt;/code&gt; directives do not evaluate to true, and the &lt;code&gt;Condition&lt;/code&gt; evaluates to true, the lines following the &lt;code&gt;elif&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">만 이후에 허용 된 &lt;code&gt;if&lt;/code&gt; 또는 다른 &lt;code&gt;elif&lt;/code&gt; 지시어. 앞의 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;elif&lt;/code&gt; 지시문이 true로 평가되지 않고 &lt;code&gt;Condition&lt;/code&gt; 이 true 로 평가 되면, &lt;code&gt;elif&lt;/code&gt; 다음의 행 이 대신 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6e65766f3d400fa0c4ec2ec7f3b23a8557087a78" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;ifdef&lt;/code&gt; or &lt;code&gt;ifndef&lt;/code&gt; directive. If that condition is false, the lines following &lt;code&gt;else&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">&lt;code&gt;ifdef&lt;/code&gt; 또는 &lt;code&gt;ifndef&lt;/code&gt; 지시문 이후에만 허용 됩니다. 그 조건이 거짓 인 경우, 다음과 같은 라인 &lt;code&gt;else&lt;/code&gt; 대신 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="03727b1fe9878a4627e85a8cbe80d475296b011b" translate="yes" xml:space="preserve">
          <source>Only allowed for connection-oriented sockets.</source>
          <target state="translated">연결 지향 소켓에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b872c6846f1badf545548103fe27329f7bb9d68b" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags &lt;/code&gt; emulator option.</source>
          <target state="translated">기본적으로 NIF 및 드라이버에서 만든 바이너리 및 할당에만 태그가 지정되지만 &lt;code&gt;+M&amp;lt;S&amp;gt;atags &lt;/code&gt; 에뮬레이터 옵션을 사용하여 할당 자별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a32ac3b85acdfc340d76cd1ade965319d5c1792" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; emulator option.</source>
          <target state="translated">NIF와 드라이버가 만든 바이너리와 할당 만 기본적으로 태그가 지정되지만 &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; 에뮬레이터 옵션을 사용하여 할당 자 단위로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f8fcfa18b8b4298ae4d967d6d04b8aabbe6553a" translate="yes" xml:space="preserve">
          <source>Only exceptions occurring during the evaluation of &lt;code&gt;Exprs&lt;/code&gt; can be caught by the &lt;code&gt;catch&lt;/code&gt; section. Exceptions occurring in a &lt;code&gt;Body&lt;/code&gt; or due to a failed match are not caught.</source>
          <target state="translated">&lt;code&gt;Exprs&lt;/code&gt; 평가 중에 발생하는 예외 만 &lt;code&gt;catch&lt;/code&gt; 섹션 에서 포착 할 수 있습니다 . &lt;code&gt;Body&lt;/code&gt; 에서 발생하는 예외 또는 실패한 일치로 인해 발생하는 예외 는 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5ee0b816fb973da72fef21bb99316a4666d0fe2" translate="yes" xml:space="preserve">
          <source>Only explicit connection set-ups are used.</source>
          <target state="translated">명시 적 연결 설정 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="965fd205ec4a5be006cc4bdca91e080bb904b491" translate="yes" xml:space="preserve">
          <source>Only files with exactly these extensions are compressed.</source>
          <target state="translated">이러한 확장자를 가진 파일 만 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="d800e233c81231deb85380be879f6765bb0a09d1" translate="yes" xml:space="preserve">
          <source>Only if a shell script or &lt;code&gt;.bat&lt;/code&gt; file is executed, the appropriate command interpreter is invoked implicitly, but there is still no command-argument expansion or implicit &lt;code&gt;PATH&lt;/code&gt; search.</source>
          <target state="translated">쉘 스크립트 또는 &lt;code&gt;.bat&lt;/code&gt; 파일이 실행되는 경우에만 적절한 명령 인터프리터가 내재적으로 호출되지만 여전히 명령 인수 확장 또는 내재적 &lt;code&gt;PATH&lt;/code&gt; 검색은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e308954fb7661938a56cab2015555144c20f290" translate="yes" xml:space="preserve">
          <source>Only if a string contains code points &amp;lt; 256, can it be directly converted to a binary by using, for example, &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; or can be sent directly to a port. If the string contains Unicode characters &amp;gt; 255, an encoding must be decided upon and the string is to be converted to a binary in the preferred encoding using &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt;. Strings are not generally lists of bytes, as they were before Erlang/OTP R13, they are lists of characters. Characters are not generally bytes, they are Unicode code points.</source>
          <target state="translated">문자열에 코드 포인트 &amp;lt;256이 포함 된 경우에만 예를 들어 &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; 을 사용하여 이진으로 직접 변환 하거나 포트로 직접 보낼 수 있습니다. 문자열에 유니 코드 문자&amp;gt; 255가 포함 된 경우 인코딩을 결정해야하며 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; 을 사용하여 선호하는 인코딩에서 문자열을 이진으로 변환해야합니다 . 문자열은 일반적으로 Erlang / OTP R13 이전의 바이트 목록이 아니며 문자 목록입니다. 문자는 일반적으로 바이트가 아니며 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="660019367304634239f33b92fdff61cb41611c83" translate="yes" xml:space="preserve">
          <source>Only if the server is in the confirmed commit phase, the configuration is restored to its state before entering the confirmed commit phase. Otherwise, no configuration rollback is performed.</source>
          <target state="translated">서버가 확정 커밋 단계에있는 경우에만 확인 커밋 단계에 들어가기 전에 구성이 해당 상태로 복원됩니다. 그렇지 않으면 구성 롤백이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbd2fd09cd558a21021b0e71892ab5c5ffaa9a70" translate="yes" xml:space="preserve">
          <source>Only matters for matching and when the type is &lt;code&gt;integer&lt;/code&gt;. The default is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">일치 및 유형이 &lt;code&gt;integer&lt;/code&gt; 일 때만 중요합니다 . 기본값은 &lt;code&gt;unsigned&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac47075244f080582d68564475ba1c72e44655e" translate="yes" xml:space="preserve">
          <source>Only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted. Non-interpretable modules are displayed within parenthesis in the Interpret Modules window.</source>
          <target state="translated">옵션 &lt;code&gt;debug_info&lt;/code&gt; 세트로 컴파일 된 모듈 만 해석 할 수 있습니다. 해석 할 수없는 모듈은 해석 모듈 창에서 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2d63c1fd79def5aea280eb8e5551a9a4f8acf4ef" translate="yes" xml:space="preserve">
          <source>Only on 64-bit halfword emulator. The total amount of memory allocated in low memory areas that are restricted to &amp;lt; 4 GB, although the system can have more memory.</source>
          <target state="translated">64 비트 하프 워드 에뮬레이터에서만. 시스템에 더 많은 메모리가있을 수 있지만 4GB 미만으로 제한되는 메모리 부족 영역에 할당 된 총 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="f8b4dc2954832ab8284b54f1deee60e8ee9f12e3" translate="yes" xml:space="preserve">
          <source>Only one &lt;code&gt;MonitorOption&lt;/code&gt; can be specified. It is one of the following:</source>
          <target state="translated">하나의 &lt;code&gt;MonitorOption&lt;/code&gt; 만 지정할 수 있습니다. 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="16b381e1eb19d06546da0fffa061890639f875ed" translate="yes" xml:space="preserve">
          <source>Only one byte long and only two bits are significant, the rest must be 0.</source>
          <target state="translated">1 바이트 길이와 2 비트 만 중요하며 나머지는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e1021bb495145f4a605a8bf15b6c7510ce41d42c" translate="yes" xml:space="preserve">
          <source>Only one copy of T exists on the heap and during the garbage collection only the first time T is encountered will it be copied.</source>
          <target state="translated">힙에는 T의 복사본이 하나만 존재하며 가비지 수집 중에 T가 처음 발견 될 때만 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d1d25510eb44623309c6a466f80982b971e3a79b" translate="yes" xml:space="preserve">
          <source>Only one entry of this type is allowed.</source>
          <target state="translated">이 유형의 항목은 하나만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8db1c5a163c86ad59a6d1922863061872c37b3" translate="yes" xml:space="preserve">
          <source>Only one table is loaded by &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt;. Since committed transactions can have caused updates in several tables, the tables can become inconsistent because of the forced load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 의해 하나의 테이블 만로드됩니다 . 커밋 된 트랜잭션으로 인해 여러 테이블에서 업데이트가 발생할 수 있으므로 강제로드로 인해 테이블이 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="203a271e69e1e6f8cf93e61cb78904664002dc4b" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt; erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt; erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">여기에는 일부 기본값 만 표시되었습니다. 현재 사용되는 설정 및 할당 자의 현재 상태에 대한 정보는 &lt;code&gt; erlang:system_info(allocator)&lt;/code&gt; 및 &lt;code&gt; erlang:system_info({allocator, Alloc})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e92ee7eb3618038b399f136fb76be40e18e1bc01" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">여기에는 일부 기본값 만 제시되어 있습니다. 현재 사용 된 설정 및 할당 자의 현재 상태에 대한 정보는 &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; 및 &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17e89dc2513b107dcc6a0275a1a3c98d68b4387b" translate="yes" xml:space="preserve">
          <source>Only support running Cover on the local node. This function must be called before any modules have been compiled or any nodes added. When running in this mode, modules will be Cover compiled in a more efficient way, but the resulting code will only work on the same node they were compiled on.</source>
          <target state="translated">로컬 노드에서 Cover 실행 만 지원합니다. 이 함수는 모듈이 컴파일되거나 노드가 추가되기 전에 호출되어야합니다. 이 모드에서 실행하면 모듈이보다 효율적인 방식으로 Cover 컴파일되지만 결과 코드는 컴파일 된 동일한 노드에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="39e55a508bb5366d1ba41f1b8cc19d785d5f6e26" translate="yes" xml:space="preserve">
          <source>Only supported if ERTS was compiled with zlib &amp;gt;= 1.2.8.</source>
          <target state="translated">ERTS가 zlib&amp;gt; = 1.2.8로 컴파일 된 경우에만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c3b6c96d4a056b1891213af8fe63652b6f147a" translate="yes" xml:space="preserve">
          <source>Only supported when the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_SPAWN&quot;&gt;DFLAG_SPAWN&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flag&lt;/a&gt;&lt;/code&gt; has been passed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_SPAWN&quot;&gt;DFLAG_SPAWN&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flag&lt;/a&gt;&lt;/code&gt; 가 전달 된 경우에만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="1405eb7cb56be68779595f26b14d02a57896c6d6" translate="yes" xml:space="preserve">
          <source>Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported.</source>
          <target state="translated">DEFLATE (zlib-compression) 및 STORE (압축되지 않은 데이터) zip 메소드 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="be533a124805e79fe90a76852bcb557c73fc2e89" translate="yes" xml:space="preserve">
          <source>Only the Erlang process that opened the file can use it.</source>
          <target state="translated">파일을 연 Erlang 프로세스 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff26c5132f4e18c3af8859f76e7ae06eef0123a" translate="yes" xml:space="preserve">
          <source>Only the currently connected job can 'talk' to the shell.</source>
          <target state="translated">현재 연결된 작업 만 쉘과 '대화'할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03597ea953bd3b370af7ca4b5066ffbc33977b3" translate="yes" xml:space="preserve">
          <source>Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</source>
          <target state="translated">첫 번째 캡처 된 하위 패턴 만 항상 주제와 완전히 일치하는 부분입니다. 명시 적으로 캡처 된 모든 하위 패턴은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b70de51c32ae79e58749256bc1925f2b5088935f" translate="yes" xml:space="preserve">
          <source>Only the following metacharacters are recognized in character classes:</source>
          <target state="translated">문자 클래스에서는 다음 메타 문자 만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c7ec7f774783186ec033a3872a8ed95ec657d5" translate="yes" xml:space="preserve">
          <source>Only the owner process can read or write to the table.</source>
          <target state="translated">소유자 프로세스 만 테이블을 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae72d9870b541f6e2a7d88226bfd5d4e90663a8e" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function unless an alternate input handler process has been registered using &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt;. If an alternate input handler has been registered, only the registered input handler process is allowed to call this function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt; 사용하여 대체 입력 핸들러 프로세스를 등록하지 않은 경우 &lt;code&gt;DHandle&lt;/code&gt; 로 식별 된 분배 채널에 분배 컨트롤러로 등록 된 프로세스 만이 함수를 호출 할 수 있습니다. 대체 입력 핸들러가 등록 된 경우 등록 된 입력 핸들러 프로세스 만이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0120f9c54ff86c06696b34a4219af2378345acdb" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function.</source>
          <target state="translated">&lt;code&gt;DHandle&lt;/code&gt; 이 식별 한 분배 채널에 분배 제어기로 등록 된 프로세스 만이 기능을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a2d2b2787c40ce488cca6bc1ab1989c6ad75b7" translate="yes" xml:space="preserve">
          <source>Only the process that created the digraph is allowed to update it.</source>
          <target state="translated">digraph를 만든 프로세스 만 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7ef46b3f7713cb10f8c8f5e86db36f63612540" translate="yes" xml:space="preserve">
          <source>Only the specified part is searched. Return values still have offsets from the beginning of &lt;code&gt;Subject&lt;/code&gt;. A negative &lt;code&gt;Length&lt;/code&gt; is allowed as described in section Data Types in this manual.</source>
          <target state="translated">지정된 부분 만 검색합니다. 반환 값에는 여전히 &lt;code&gt;Subject&lt;/code&gt; 의 시작 부분부터 오프셋이 있습니다 . 이 매뉴얼의 데이터 유형 섹션에 설명 된대로 음의 &lt;code&gt;Length&lt;/code&gt; 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="92b1c560a3c609b6630ba6369a93d7159051e3e5" translate="yes" xml:space="preserve">
          <source>Only these exact character sequences are recognized. A sequence such as [a[:&amp;lt;:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \b matches at the start and the end of a word (see &quot;Simple assertions&quot; above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour.</source>
          <target state="translated">이 정확한 문자 시퀀스 만 인식됩니다. [a [: &amp;lt;:] b]와 같은 시퀀스는 인식 할 수없는 POSIX 클래스 이름에 대한 오류를 유발합니다. 이 지원은 Perl과 호환되지 않습니다. 다른 환경에서 마이그레이션하는 데 도움이되며 새로운 패턴에는 사용하지 않는 것이 가장 좋습니다. \ b는 단어의 시작과 끝에서 일치하며 (위의 &quot;단순 어설 션&quot;참조) Perl 스타일 패턴에서 앞 또는 다음 문자는 일반적으로 사용되는 어설 션없이 원하는 것을 보여줍니다. POSIX 동작을 정확하게하기 위해</target>
        </trans-unit>
        <trans-unit id="17d1fba9658ded214a434ab7601d513e4c6c5aaf" translate="yes" xml:space="preserve">
          <source>Only total</source>
          <target state="translated">총계</target>
        </trans-unit>
        <trans-unit id="b466165e837dbf10eadb47e4bc9b893d7bb50387" translate="yes" xml:space="preserve">
          <source>Only trace messages from a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">특정 프로세스 &lt;code&gt;Pid&lt;/code&gt; 의 메시지 만 추적하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5bfc32b55921a00a28f4c0d1a74dc4ff5f9f2ba" translate="yes" xml:space="preserve">
          <source>Only trace messages from other nodes:</source>
          <target state="translated">다른 노드의 메시지 만 추적하십시오.</target>
        </trans-unit>
        <trans-unit id="78247ecb104811399c3277cdd7d4c731768a72b0" translate="yes" xml:space="preserve">
          <source>Only trace messages matching &lt;code&gt;{reply, _}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;{reply, _}&lt;/code&gt; 과) 일치하는 추적 메시지 만</target>
        </trans-unit>
        <trans-unit id="7666550505039a9e83e909935389e4f3ca8ed6d8" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to other nodes:</source>
          <target state="translated">다른 노드로 전송 된 추적 메시지 만 :</target>
        </trans-unit>
        <trans-unit id="550dd65f9f1635f5b26d39adb415360c2a92434a" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to the sender itself:</source>
          <target state="translated">발신자 자신에게 보낸 추적 메시지 만 :</target>
        </trans-unit>
        <trans-unit id="2500bda55ee606fa893cbad9220ec886375e6705" translate="yes" xml:space="preserve">
          <source>Only trace messages to a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">특정 프로세스 &lt;code&gt;Pid&lt;/code&gt; 로만 메시지를 추적하십시오 .</target>
        </trans-unit>
        <trans-unit id="42b574e1ef29bfa437b36acb9027769673eb223a" translate="yes" xml:space="preserve">
          <source>Only two arguments, of which one must be &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;false&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt;; otherwise &lt;code&gt;'xor'&lt;/code&gt; returns false.</source>
          <target state="translated">단지 두 개의 인수, 하나가되어야합니다있는 &lt;code&gt;true&lt;/code&gt; 과 다른 &lt;code&gt;false&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;'xor'&lt;/code&gt; 는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a84b39b2c86b869fad86343fd9fef89839964e4b" translate="yes" xml:space="preserve">
          <source>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</source>
          <target state="translated">무엇을하고 있는지 확실하다면이 플래그 만 사용하십시오. 부적절한 설정은 작동 중 언제라도 심각한 성능 저하 및 시스템 충돌을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d7818114df4175719fb624ea7ed7fe90002e953" translate="yes" xml:space="preserve">
          <source>Only used during handshake phase.</source>
          <target state="translated">핸드 셰이크 단계에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63f8061fc22c121f41217cd28e783b48e49934d5" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. It allows the standard input and output (file descriptors 0 and 1) of the spawned (Unix) process for communication with Erlang.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효합니다 . Erlang과의 통신을 위해 생성 된 (Unix) 프로세스의 표준 입력 및 출력 (파일 설명자 0 및 1)을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="18c2212e127b0c910798dbbf1d59d9d69e12fd4b" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The external program starts using &lt;code&gt;Dir&lt;/code&gt; as its working directory. &lt;code&gt;Dir&lt;/code&gt; must be a string.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효합니다 . 외부 프로그램은 &lt;code&gt;Dir&lt;/code&gt; 을 작업 디렉토리로 사용하기 시작합니다 . &lt;code&gt;Dir&lt;/code&gt; 은 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="65484a01cf9bd6e1a83ae6b606310e1c69ff32cf" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The environment of the started process is extended using the environment specifications in &lt;code&gt;Env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효합니다 . 시작된 프로세스의 환경은 &lt;code&gt;Env&lt;/code&gt; 의 환경 스펙을 사용하여 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfc9b2e1dea6a04ba983a9e94d3b648b00ca026f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, where &lt;code&gt;Command&lt;/code&gt; refers to an external program, and for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 에만 유효합니다 . 여기서 &lt;code&gt;Command&lt;/code&gt; 는 외부 프로그램 및 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="ec0538decd2a683ac3d4fc85b7551d506a0ba696" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and explicitly specifies the program name argument when running an executable. This can in some circumstances, on some OSs, be desirable. How the program responds to this is highly system-dependent and no specific effect is guaranteed.</source>
          <target state="translated">&lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효 하며 실행 파일을 실행할 때 프로그램 이름 인수를 명시 적으로 지정합니다. 상황에 따라 일부 OS에서는 바람직 할 수 있습니다. 프로그램이 이에 응답하는 방식은 시스템에 따라 다르며 특정 효과는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94d77dba770e4fddcd3e5b235704abc55a41a06f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and specifies arguments to the executable. Each argument is specified as a separate string and (on Unix) eventually ends up as one element each in the argument vector. On other platforms, a similar behavior is mimicked.</source>
          <target state="translated">&lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 에만 유효 하며 실행 파일에 인수를 지정합니다. 각 인수는 별도의 문자열로 지정되며 (유닉스에서) 결국 인수 벡터에서 하나의 요소로 끝납니다. 다른 플랫폼에서도 유사한 동작이 모방됩니다.</target>
        </trans-unit>
        <trans-unit id="0a16a27763d86648c52acb4eb9a028a14f39f822" translate="yes" xml:space="preserve">
          <source>Only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">Unix의 문자 장치에만 유효합니다. 다른 모든 경우에는이 필드가 0입니다.</target>
        </trans-unit>
        <trans-unit id="7fc2cb0a3d19c899c55c3af5cabac685a4c4024f" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt; bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt; bchunk/2&lt;/a&gt;&lt;/code&gt; 에서 사용하는 불투명 연속 입니다.</target>
        </trans-unit>
        <trans-unit id="ecb3f031c9ac0eb9d790e14595d3fd9dd2d8d7c2" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt; 가 사용하는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="44042d084e920dd3dc985ac504cefdc2ed892dbe" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt; match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt; match/3&lt;/a&gt;&lt;/code&gt; 에서 사용하는 불투명 연속 입니다.</target>
        </trans-unit>
        <trans-unit id="58a550d32afdec41a5ce24c62d98873272eb328a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="2e13e6d3aa42a811de64c1e467938899f3dce98a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; 에서 사용하는 불투명 연속 입니다.</target>
        </trans-unit>
        <trans-unit id="296b6181394c8bc2ef4aa069b7cdea56b08954fb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용하여 불투명 연속 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a762205d0a7ee19acfd273d7e78b6398592b6bb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt; select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt; select_reverse/1,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1,3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속 입니다.</target>
        </trans-unit>
        <trans-unit id="d97c71bb917f1db11558c4c9a89e12c4b7ed4b54" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt; select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt; select/3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속 입니다.</target>
        </trans-unit>
        <trans-unit id="2dfa868a6d8928ac7bb58be05cada3f714825ced" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="403f4b382799774e589923264bc2680b24377bd7" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 에서 사용되는 불투명 연속체 .</target>
        </trans-unit>
        <trans-unit id="0fd3a4cc67ebb2e2dcfc37bc089269155adc35e9" translate="yes" xml:space="preserve">
          <source>Opaque data type containing a compiled regular expression. &lt;code&gt;mp()&lt;/code&gt; is guaranteed to be a tuple() having the atom &lt;code&gt;re_pattern&lt;/code&gt; as its first element, to allow for matching in guards. The arity of the tuple or the content of the other fields can change in future Erlang/OTP releases.</source>
          <target state="translated">컴파일 된 정규식을 포함하는 불투명 한 데이터 유형. &lt;code&gt;mp()&lt;/code&gt; 는 첫 번째 요소로 원자 &lt;code&gt;re_pattern&lt;/code&gt; 을 갖는 tuple () 임을 보장하여 가드에서 일치시킬 수 있습니다. 튜플의 arity 또는 다른 필드의 내용은 향후 Erlang / OTP 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3073e10d40e31139c377d2037ae18a50d90f1eba" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a C-node. A &lt;code&gt;ei_cnode&lt;/code&gt; structure is initialized by calling &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends.</source>
          <target state="translated">C 노드를 나타내는 불투명 데이터 유형. &lt;code&gt;ei_cnode&lt;/code&gt; 의 구조를 호출하여 초기화 &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; 또는 친구.</target>
        </trans-unit>
        <trans-unit id="23206d19a217e18d8ba3621938088efa39a69154" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a channel inside a connection.</source>
          <target state="translated">연결 내부의 채널을 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="10ef7cb1f64bbdc10f27d8dc1ce5e8006717e4e1" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a compiled search pattern. Guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">컴파일 된 검색 패턴을 나타내는 불투명 한 데이터 유형입니다. 프로그램이 사전 컴파일되지 않은 검색 패턴과 구별 할 수 있도록 하는 &lt;code&gt;tuple()&lt;/code&gt; 임을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="11a89fac909edd47d58426bf26b171a05bcc5425" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a connection between a client and a server (daemon).</source>
          <target state="translated">클라이언트와 서버 (데몬) 간의 연결을 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="620b0b7f87aa05da3ff0439d717021eb8fe8e602" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a daemon.</source>
          <target state="translated">데몬을 나타내는 불투명 한 데이터 형식입니다.</target>
        </trans-unit>
        <trans-unit id="782b9c52a05275a07fdb0325126b76a41e598067" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang fun.</source>
          <target state="translated">Erlang 재미를 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4927f104d4050e4e82f5e9b926c4785a9a6cd617" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang port identifier.</source>
          <target state="translated">Erlang 포트 식별자를 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b351d1987076f1dc291eddcbafd24ab67c9d0ca9" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang process identifier.</source>
          <target state="translated">Erlang 프로세스 식별자를 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6eb071ca2ae242d99f495914ddf8221680ce181d" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang reference.</source>
          <target state="translated">Erlang 참조를 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="70e1f3ab4b5c65c16968a9846c8960065afe6262" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang sequential trace token.</source>
          <target state="translated">Erlang 순차 추적 토큰을 나타내는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3857ec812333e693713ca05fedf452c8c2760e48" translate="yes" xml:space="preserve">
          <source>Opaque reference for a connection to a NETCONF server or a NETCONF session.</source>
          <target state="translated">NETCONF 서버 또는 NETCONF 세션 연결에 대한 불투명 한 참조.</target>
        </trans-unit>
        <trans-unit id="1ad02c5216bfba2278b495045671c8cc585c4d19" translate="yes" xml:space="preserve">
          <source>Opaque send handle whose contents is internal for the send module. May be any term.</source>
          <target state="translated">내용이 보내기 모듈 내부에있는 불투명 한 보내기 핸들. 임의의 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="107ba6e41ccc6092a0776c13b1c83f0f2e14171a" translate="yes" xml:space="preserve">
          <source>Opaque types that define experimental options that are not to be used in products.</source>
          <target state="translated">제품에 사용되지 않는 실험 옵션을 정의하는 불투명 한 유형.</target>
        </trans-unit>
        <trans-unit id="7587b20d7be0af5fefb7a8ee2c09b36a8bb78350" translate="yes" xml:space="preserve">
          <source>Opaque value returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 불투명 한 값 .</target>
        </trans-unit>
        <trans-unit id="3550457d3cea02f68e91830d6b92589beceb0ac2" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity (ODBC) is a Microsoft standard for accessing relational databases that has become widely used. The ODBC standard provides a c-level application programming interface (API) for database access. It uses Structured Query Language (SQL) as its database access language.</source>
          <target state="translated">ODBC (Open Database Connectivity)는 널리 사용되는 관계형 데이터베이스에 액세스하기위한 Microsoft 표준입니다. ODBC 표준은 데이터베이스 액세스를위한 c 레벨 API (응용 프로그래밍 인터페이스)를 제공합니다. 데이터베이스 액세스 언어로 SQL (Structured Query Language)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8082c8186bf5acfdb929e31ffd3d59546e0c666b" translate="yes" xml:space="preserve">
          <source>Open an SSH connection to a named NETCONF server.</source>
          <target state="translated">명명 된 NETCONF 서버에 대한 SSH 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="ee2771cae64f2d66b96c7d0fdeb3a995d3b00a84" translate="yes" xml:space="preserve">
          <source>Open files and sockets</source>
          <target state="translated">파일 및 소켓 열기</target>
        </trans-unit>
        <trans-unit id="c2f3ad251a3411a0d3096b7d62ceb15282d3c92b" translate="yes" xml:space="preserve">
          <source>Open ports</source>
          <target state="translated">열린 포트</target>
        </trans-unit>
        <trans-unit id="d5d9049df9a69941f4ebda406f0f9058d7b67428" translate="yes" xml:space="preserve">
          <source>Open punctuation</source>
          <target state="translated">구두점 열기</target>
        </trans-unit>
        <trans-unit id="01b42cf5dcb6fdd0a783f67c992975adaac86c1d" translate="yes" xml:space="preserve">
          <source>OpenSSH Public-Key Format</source>
          <target state="translated">OpenSSH 공개 키 형식</target>
        </trans-unit>
        <trans-unit id="0f83435c5ff89a01a4392cfcdc0fce03d20e7bcf" translate="yes" xml:space="preserve">
          <source>OpenSSH public-key format looks as follows:</source>
          <target state="translated">OpenSSH 공개 키 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3962fc8d7cfd8504f9f8a80c8b447972c82afbc5" translate="yes" xml:space="preserve">
          <source>OpenSSL (optional) You need this to build crypto, ssh and ssl libs.</source>
          <target state="translated">OpenSSL (선택 사항) crypto, ssh 및 ssl libs를 빌드하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="78a8e32789179af6e9a1ec19eccc362f6f09476e" translate="yes" xml:space="preserve">
          <source>OpenSSL -- The opensource toolkit for Secure Socket Layer and Transport Layer Security. Required for building the application &lt;code&gt;crypto&lt;/code&gt;. Further, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; require a working crypto application and will also be skipped if OpenSSL is missing. The &lt;code&gt;public_key&lt;/code&gt; application is available without &lt;code&gt;crypto&lt;/code&gt;, but the functionality will be very limited.</source>
          <target state="translated">OpenSSL-SSL (Secure Socket Layer) 및 전송 계층 보안을위한 오픈 소스 툴킷. 응용 프로그램 &lt;code&gt;crypto&lt;/code&gt; 를 구축하는 데 필요합니다 . 또한 &lt;code&gt;ssl&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; 에는 작동하는 암호화 응용 프로그램이 필요하며 OpenSSL이 없으면 건너 뜁니다. &lt;code&gt;public_key&lt;/code&gt; 응용 프로그램없이 사용할 수 있습니다 &lt;code&gt;crypto&lt;/code&gt; ,하지만 기능은 매우 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ba88f6151c1d4c39311034d5740f6813c1bb3d" translate="yes" xml:space="preserve">
          <source>OpenSSL can be built to provide FIPS 140-2 validated cryptographic services. It is not the OpenSSL application that is validated, but a special software component called the OpenSSL FIPS Object Module. However applications do not use this Object Module directly, but through the regular API of the OpenSSL library.</source>
          <target state="translated">FIPS 140-2 인증 암호화 서비스를 제공하기 위해 OpenSSL을 구축 할 수 있습니다. 검증 된 응용 프로그램은 OpenSSL 응용 프로그램이 아니라 OpenSSL FIPS Object Module이라는 특수 소프트웨어 구성 요소입니다. 그러나 애플리케이션은이 오브젝트 모듈을 직접 사용하지 않고 OpenSSL 라이브러리의 일반 API를 통해 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ec75c958bae528f688b7acd8013d185972516f61" translate="yes" xml:space="preserve">
          <source>OpenSSL exposes an Engine API, which makes it possible to plug in alternative implementations for some or all of the cryptographic operations implemented by OpenSSL. When configured appropriately, OpenSSL calls the engine's implementation of these operations instead of its own.</source>
          <target state="translated">OpenSSL은 엔진 API를 제공하므로 OpenSSL에 의해 구현 된 일부 또는 모든 암호화 작업에 대한 대체 구현을 플러그인 할 수 있습니다. 적절하게 구성되면 OpenSSL은 엔진 대신 이러한 작업의 엔진 구현을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="23dcb6e17a0724721b52791ead27b1179856c026" translate="yes" xml:space="preserve">
          <source>OpenSSL handles these corner cases in FIPS mode, however the Erlang crypto and ssl applications are not prepared for them and therefore you are limited to TLS 1.2 in FIPS mode.</source>
          <target state="translated">OpenSSL은 FIPS 모드에서 이러한 경우를 처리하지만 Erlang 암호화 및 ssl 애플리케이션은이를 준비하지 않으므로 FIPS 모드에서는 TLS 1.2로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3a24b8124364457504f3d77d3e37c9aa2f092c8b" translate="yes" xml:space="preserve">
          <source>OpenSSL. This is if you want the SSL and crypto applications to compile (and run). There are prebuilt binaries, which you can just download and install, available here:</source>
          <target state="translated">OpenSSL. SSL 및 암호화 응용 프로그램을 컴파일 (및 실행)하려는 경우입니다. 미리 빌드 된 바이너리가 있으며 여기에서 다운로드하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc37c058118702102358b15e5a9279ede7fb88f0" translate="yes" xml:space="preserve">
          <source>OpenSource users can ask questions and share experiences on the &lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt; Erlang questions mailing list&lt;/a&gt;.</source>
          <target state="translated">오픈 소스 사용자는 &lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;Erlang 질문 메일 링리스트&lt;/a&gt; 에서 질문을하고 경험을 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f59aad599af06a50017bc066f13ce93de0675e4" translate="yes" xml:space="preserve">
          <source>Opening a connection to the SUT</source>
          <target state="translated">SUT에 대한 연결 열기</target>
        </trans-unit>
        <trans-unit id="16d19c8e7f51506cd01c5e4f542d05b716cdf852" translate="yes" xml:space="preserve">
          <source>Opening files with option &lt;code&gt;encoding&lt;/code&gt; is convenient when writing or reading text files in a known encoding.</source>
          <target state="translated">알려진 인코딩으로 텍스트 파일을 쓰거나 읽을 때 옵션 &lt;code&gt;encoding&lt;/code&gt; 파일을 여는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="67011158e86d9fe5da95333d965bcbbe99127074" translate="yes" xml:space="preserve">
          <source>Opening parentheses are counted from left to right (starting from 1) to obtain numbers for the capturing subpatterns. For example, if the string &quot;the red king&quot; is matched against the following pattern, the captured substrings are &quot;red king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1, 2, and 3, respectively:</source>
          <target state="translated">여는 괄호는 왼쪽에서 오른쪽으로 계산되어 (1부터 시작) 캡처 하위 패턴의 숫자를 얻습니다. 예를 들어, 문자열 &quot;red king&quot;이 다음 패턴과 일치하면 캡처 된 하위 문자열은 &quot;red king&quot;, &quot;red&quot;및 &quot;king&quot;이며 각각 1, 2 및 3으로 번호가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="75588bb57f0a2ad5ebe6ca42cc40d8c3b6d3dc26" translate="yes" xml:space="preserve">
          <source>Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections)</source>
          <target state="translated">대괄호 열기 (Posix 클래스 이름을 소개하거나 특수한 호환성 기능으로 해석 될 수있는 경우에만 다음 두 섹션 참조)</target>
        </trans-unit>
        <trans-unit id="0a4914a57f284d13929c087c4e60d213c9577e76" translate="yes" xml:space="preserve">
          <source>Opens (creates) a registry, which initially is empty. To close the registry later, use &lt;code&gt;ei_reg_close()&lt;/code&gt;.</source>
          <target state="translated">처음에는 비어있는 레지스트리를 엽니 다 (만들기). 나중에 레지스트리를 닫으려면 &lt;code&gt;ei_reg_close()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b46d26782974b469a2ae782f58aa207429f253c" translate="yes" xml:space="preserve">
          <source>Opens a &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;, displaying the contents of the selected module.</source>
          <target state="translated">선택한 모듈의 내용을 표시하는 &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="22a4c7bdc761516d54977e6e3c2f08e31666a769" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">NETCONF 세션을 열고 &lt;code&gt;hello&lt;/code&gt; 메시지를 교환 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
