<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="247d880cbbfe17329068c2a487e83b52be0b8fd0" translate="yes" xml:space="preserve">
          <source>The validity period of the certificate.</source>
          <target state="translated">인증서의 유효 기간</target>
        </trans-unit>
        <trans-unit id="de095b0c0154458957667b823417f32d9c762772" translate="yes" xml:space="preserve">
          <source>The value (in seconds) must be in the range 10 &amp;lt; X &amp;lt;= 65535.</source>
          <target state="translated">값 (초)은 10 &amp;lt;X &amp;lt;= 65535 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c7d9f4f2d7422b47b5c88e4d58854e12adae49bd" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;-1&lt;/code&gt; in any field means &quot;unknown&quot;, and in most cases it means that the dump was truncated somewhere around this field.</source>
          <target state="translated">모든 필드 의 값 &lt;code&gt;-1&lt;/code&gt; 은 &quot;알 수 없음&quot;을 의미하며 대부분의 경우이 필드 주위에서 덤프가 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="86c20a3a7328e6bc498fe9dc567872d5f84e6318" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;extended&lt;/code&gt; means that a special 'process' is also created intended to handle &lt;strong&gt;all&lt;/strong&gt; notifications.</source>
          <target state="translated">&lt;code&gt;extended&lt;/code&gt; 값 은 &lt;strong&gt;모든&lt;/strong&gt; 알림 을 처리하기위한 특수 '프로세스'도 생성됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ebb9639bd59b81ac3f0302e2ea6264dd43e978a9" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;random&lt;/code&gt; will cause a random string to be created at each connection attempt. This is to make it a bit more difficult for a malicious peer to find the ssh software brand and version.</source>
          <target state="translated">&lt;code&gt;random&lt;/code&gt; 값 은 각 연결 시도에서 임의의 문자열을 작성합니다. 이것은 악의적 인 피어가 ssh 소프트웨어 브랜드와 버전을 찾는 것을 좀 더 어렵게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="59cae5c48ebf4d4c60edc8af8c6900b2f10cdd93" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; will make a random string with at least &lt;code&gt;Nmin&lt;/code&gt; characters and at most &lt;code&gt;Nmax&lt;/code&gt; characters.</source>
          <target state="translated">값 &lt;code&gt;{random, Nmin, Nmax}&lt;/code&gt; 적어도와 임의의 문자열 것 &lt;code&gt;Nmin&lt;/code&gt; 을의 문자와 최대 &lt;code&gt;Nmax&lt;/code&gt; 가의 문자.</target>
        </trans-unit>
        <trans-unit id="cc2e81fd931d300e3783349335314abc90033f4a" translate="yes" xml:space="preserve">
          <source>The value associated with key &lt;code&gt;alpha&lt;/code&gt; is fetched for both arguments using the &lt;code&gt;:=&lt;/code&gt; operator. The other keys in the map are ignored, only the key &lt;code&gt;alpha&lt;/code&gt; is required and checked for.</source>
          <target state="translated">키 &lt;code&gt;alpha&lt;/code&gt; 와 관련된 값 은 &lt;code&gt;:=&lt;/code&gt; 연산자를 사용하여 두 인수 모두에 대해 페치됩니다 . 맵의 다른 키는 무시되며 키 &lt;code&gt;alpha&lt;/code&gt; 만 필요하며 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="ae3beea41eb5f49f177e89c9a2690def73d412bd" translate="yes" xml:space="preserve">
          <source>The value associated with this key is used by filters for grouping log events originating from, for example, specific functional areas. See &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt; logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; for a description of how this field can be used.</source>
          <target state="translated">이 키와 연관된 값은 예를 들어 특정 기능 영역에서 발생하는 로그 이벤트를 그룹화하기 위해 필터에서 사용됩니다. 이 필드를 사용하는 방법에 대한 설명은 &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt; logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86b0b34c5895cd8049a0c1760924204afc238fc1" translate="yes" xml:space="preserve">
          <source>The value associated with this key is used by filters for grouping log events originating from, for example, specific functional areas. See &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; for a description of how this field can be used.</source>
          <target state="translated">이 키와 연관된 값은 특정 기능 영역과 같은 로그 이벤트를 그룹화하기 위해 필터에서 사용합니다. 이 필드를 사용하는 방법에 대한 설명은 &lt;code&gt;&lt;a href=&quot;logger_filters#domain-2&quot;&gt;logger_filters:domain/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a9b31d1fc7f3b413bcae938dfe03589bb5285a5" translate="yes" xml:space="preserve">
          <source>The value defaults to &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="73cc3165471e18765106ff9988f4618f4de5f7c9" translate="yes" xml:space="preserve">
          <source>The value defined here can be used in several ways. It can, for example, be used as the value in some &lt;code&gt;DEFAULT&lt;/code&gt; component:</source>
          <target state="translated">여기에 정의 된 값은 여러 가지 방법으로 사용될 수 있습니다. 예를 들어 일부 &lt;code&gt;DEFAULT&lt;/code&gt; 구성 요소 의 값으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00cedad00d133d50963e34c659f0ef80545f6ee4" translate="yes" xml:space="preserve">
          <source>The value denotes a regular expression (see module &lt;code&gt;re&lt;/code&gt;). Tidying will only be applied to those regular files whose names match this pattern. The default value is &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt;, which matches normal Erlang source file names.</source>
          <target state="translated">값은 정규식을 나타냅니다 (모듈 &lt;code&gt;re&lt;/code&gt; 참조 ). 정리는 이름이이 패턴과 일치하는 일반 파일에만 적용됩니다. 기본값은 &lt;code&gt;&quot;.*\\.erl$&quot;&lt;/code&gt; 이며 이는 일반적인 Erlang 소스 파일 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a7fc7c904bc65fe1f04425c2c4301dd4dfba43f3" translate="yes" xml:space="preserve">
          <source>The value has the form required by section 8.8 of RFC 6733. Ident should be the Origin-Host of the peer from which the message containing the returned value will be sent.</source>
          <target state="translated">값은 RFC 6733의 섹션 8.8에 필요한 형식을 갖습니다. 식별자는 반환 된 값이 포함 된 메시지가 전송 될 피어의 Origin-Host 여야합니다.</target>
        </trans-unit>
        <trans-unit id="df5a9468ae2eff2ec8d99706ab1e3ddc685940bb" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;false&lt;/code&gt; if call saving is not active for the process (see &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt; process_flag/3&lt;/a&gt;&lt;/code&gt;). If call saving is active, a list is returned, in which the last element is the most recent called.</source>
          <target state="translated">프로세스에 대해 호출 저장이 활성화되지 않은 경우 값은 &lt;code&gt;false&lt;/code&gt; 입니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt; process_flag/3&lt;/a&gt;&lt;/code&gt; 참조 ). 통화 저장이 활성화 된 경우 마지막 요소가 가장 최근에 호출 된 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="565bd9ff9980988d34e45f60f24a9df4493a532c" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;false&lt;/code&gt; if call saving is not active for the process (see &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt;). If call saving is active, a list is returned, in which the last element is the most recent called.</source>
          <target state="translated">프로세스에 대해 통화 저장이 활성화되지 않은 경우 값은 &lt;code&gt;false&lt;/code&gt; 입니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-3&quot;&gt;process_flag/3&lt;/a&gt;&lt;/code&gt; 참조 ). 통화 저장이 활성화되면 마지막 요소가 가장 최근에 호출 된 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fca5756bcf0742c5fb8a83c510ae9ce36b623343" translate="yes" xml:space="preserve">
          <source>The value is a &lt;code&gt;boolean()&lt;/code&gt;. The value &lt;code&gt;true&lt;/code&gt; will make the client accept any unknown Host Key without any user interaction. The value &lt;code&gt;false&lt;/code&gt; preserves the default behaviour of asking the user on stdio.</source>
          <target state="translated">값은 &lt;code&gt;boolean()&lt;/code&gt; 입니다. &lt;code&gt;true&lt;/code&gt; 값 은 클라이언트가 사용자 개입없이 알 수없는 호스트 키를 수락하도록합니다. &lt;code&gt;false&lt;/code&gt; 값 은 stdio에서 사용자에게 묻는 기본 동작을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4b03c47ccab46f2579d8f24abc755f87cc416f2a" translate="yes" xml:space="preserve">
          <source>The value is a list of pairs, associating tuples &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; with tuples &lt;code&gt;{NewModule, NewName}&lt;/code&gt;, specifying renamings of calls to remote functions. By default, the value is the empty list.</source>
          <target state="translated">값은 튜플 &lt;code&gt;{Module, Name, Arity}&lt;/code&gt; 을 튜플 &lt;code&gt;{NewModule, NewName}&lt;/code&gt; 과 연관 시켜 원격 함수 호출의 이름 바꾸기를 지정하는 쌍 목록입니다 . 기본적으로 값은 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1df1db1ba1c8748b25a7c5b626dd8804fd835229" translate="yes" xml:space="preserve">
          <source>The value is formed from the sftp error codes in the protocol-level responses as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; section 9.1.</source>
          <target state="translated">이 값은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/id/draft-ietf-secsh-filexfer-13.txt&quot;&gt;draft-ietf-secsh-filexfer-13.txt&lt;/a&gt;&lt;/code&gt; 섹션 9.1에 정의 된 프로토콜 수준 응답의 sftp 오류 코드에서 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="148473653e344b665aad6d10ff3c1fcf44e7835b" translate="yes" xml:space="preserve">
          <source>The value is set when the handler is added, and it cannot be changed in runtime.</source>
          <target state="translated">핸들러가 추가 될 때 값이 설정되며 런타임에서 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd41f86d28c143add491ec9132e29dfc8b19621e" translate="yes" xml:space="preserve">
          <source>The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use &lt;code&gt;atom()&lt;/code&gt;s or &lt;code&gt;string()&lt;/code&gt;s to specify the subpatterns to be returned. For example, consider the regular expression:</source>
          <target state="translated">값 목록은 하위 패턴이 리턴 할 색인 목록입니다. 여기서 색인 0은 모든 패턴에 대한 것이고 1은 정규 표현식의 첫 번째 명시 적 캡처 하위 패턴 등입니다. 정규 표현식에서 명명 된 캡처 된 하위 패턴 (아래 참조)을 사용하는 경우 &lt;code&gt;atom()&lt;/code&gt; 또는 &lt;code&gt;string()&lt;/code&gt; 을 사용하여 반환 할 하위 패턴을 지정할 수 있습니다. 예를 들어 정규 표현식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c81f48007ff0ed091ec4764a41dbf0e172a8f0bb" translate="yes" xml:space="preserve">
          <source>The value must be a function with arity 1, returning &lt;code&gt;{Format,Args}&lt;/code&gt;, and it will be called with a report as only argument.</source>
          <target state="translated">값은 arity 1을 가진 함수 여야하며 &lt;code&gt;{Format,Args}&lt;/code&gt; 를 리턴 하며 보고서와 함께 인수로만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="07ff5095c8d8cce91ccc3bf32364fcee41686369" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value is the same as the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver; otherwise the runtime system would have refused to load the driver.</source>
          <target state="translated">런타임 시스템이 컴파일되었을 때 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값입니다 . 이 값은 드라이버를 컴파일 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값과 동일 합니다. 그렇지 않으면 런타임 시스템이 드라이버로드를 거부했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="4212c98e758e516a6abcce4b67d7189dbcf1c3f9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value can differ from the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver.</source>
          <target state="translated">런타임 시스템이 컴파일되었을 때 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값입니다 . 이 값은 드라이버를 컴파일 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt; ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e234819107a6b5dcfa3fe173976c85b1ea1b28f9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value is the same as the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver; otherwise the runtime system would have refused to load the driver.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값입니다 . 이 값은 드라이버를 컴파일 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값과 같습니다 . 그렇지 않으면 런타임 시스템이 드라이버로드를 거부했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="116150239ed1360f1b36349687371da72b694bcd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; when the runtime system was compiled. This value can differ from the value of &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; used when compiling the driver.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 의 값입니다 . 이 값은 드라이버를 컴파일 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/a&gt;&lt;/code&gt; 값과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78be37cd91f4cf995f8b06a4daace135c812602c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="0b2195f8068d2a10ede4ea4cc9fcbf6ff4d98d21" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; when the runtime system was compiled.</source>
          <target state="translated">런타임 시스템이 컴파일 될 때 &lt;code&gt;ERL_NIF_MINOR_VERSION&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="b118746e3fc7bb9edb78696fb5442fd44cb5a3e1" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Misc&lt;/code&gt; varies for different types of processes, for example:</source>
          <target state="translated">&lt;code&gt;Misc&lt;/code&gt; 의 가치는 다음 과 같은 프로세스 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8dae040f4f2546c55f00cef77a0cb74993dea2c6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; multiplied with the unit gives the number of bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size that is evenly divisible by 8.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 와 단위를 곱한 값은 비트 수를 나타냅니다. &lt;code&gt;binary&lt;/code&gt; 유형의 세그먼트는 8로 균등하게 나눌 수있는 크기를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="bed25a5020d26519961367afdf71569ec20e8253" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; multiplied with the unit gives the number of bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size that is evenly divisible by 8. For a segment of type &lt;code&gt;float&lt;/code&gt; the size must be either 64 or 32.</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 에 단위를 곱한 값은 비트 수를 제공합니다. &lt;code&gt;binary&lt;/code&gt; 유형의 세그먼트는 8로 균등하게 나눌 수 있는 크기를 가져야합니다. &lt;code&gt;float&lt;/code&gt; 유형의 세그먼트의 경우 크기는 64 또는 32 여야합니다.</target>
        </trans-unit>
        <trans-unit id="780ca2b28783a99a4c631093f06c672e54bdfc8a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;Size&lt;/code&gt; specifies the size of the segment in units (see below). The default value depends on the type (see below):</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 값은 세그먼트의 크기를 단위로 지정합니다 (아래 참조). 기본값은 유형에 따라 다릅니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="b1854e31941d7fbfcb3749a7e6c4457829e3447d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;State&lt;/code&gt; varies for different types of processes, as follows:</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 의 값은 다음과 같이 프로세스 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="67326e380fdef2e7ca1cffaffc1a499d8945109f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;engine_id&lt;/code&gt; is a string, which should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;engine_id&lt;/code&gt; 의 값은 문자열이며 매우 구체적인 구조를 가져야합니다. 자세한 내용은 RFC 2271/2571을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67a488abfbc3355615ef1fdf9842c10e39f374ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;file&lt;/code&gt; overrides the value of &lt;code&gt;file&lt;/code&gt; as defined in the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">의 값 &lt;code&gt;file&lt;/code&gt; 의 값에 우선 &lt;code&gt;file&lt;/code&gt; 에 정의로 &lt;code&gt;.app&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="ce398bd65bb25721ffa1a8a7e0185e8682912540" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;intAgentTransports&lt;/code&gt; is a list of &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuples, where &lt;code&gt;Domain&lt;/code&gt; is either &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is the address in the domain. &lt;code&gt;Addr&lt;/code&gt; can be specified either as an &lt;code&gt;IpAddr&lt;/code&gt; or as an &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; tuple. &lt;code&gt;IpAddr&lt;/code&gt; is either a regular Erlang/OTP &lt;code&gt;ip_address()&lt;/code&gt; or a traditional SNMP integer list and &lt;code&gt;IpPort&lt;/code&gt; is an integer.</source>
          <target state="translated">&lt;code&gt;intAgentTransports&lt;/code&gt; 값은 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 튜플 의 목록입니다 . 여기서 &lt;code&gt;Domain&lt;/code&gt; 은 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 또는 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 이고 &lt;code&gt;Addr&lt;/code&gt; 은 도메인의 주소입니다. &lt;code&gt;Addr&lt;/code&gt; 은 &lt;code&gt;IpAddr&lt;/code&gt; 또는 &lt;code&gt;{IpAddr, IpPort}&lt;/code&gt; 튜플 로 지정할 수 있습니다 . &lt;code&gt;IpAddr&lt;/code&gt; 은 일반 Erlang / OTP &lt;code&gt;ip_address()&lt;/code&gt; 또는 기존 SNMP 정수 목록이며 &lt;code&gt;IpPort&lt;/code&gt; 는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="fa552c79540af3ff0c608c82bebe09aa87d449b9" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;parent_value&lt;/code&gt; is the value returned by &lt;code&gt;ParentFun&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; if there is no &lt;code&gt;ParentFun&lt;/code&gt;. &lt;code&gt;ParentFun&lt;/code&gt; is called once just before the call of &lt;code&gt;PreFun&lt;/code&gt; in the context of the process calling &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;parent_value&lt;/code&gt; 는 값으로 반환된다 &lt;code&gt;ParentFun&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 전혀 존재하지 않는 경우 &lt;code&gt;ParentFun&lt;/code&gt; . &lt;code&gt;ParentFun&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#eval-1&quot;&gt;eval/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#fold-3&quot;&gt;fold/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#cursor-1&quot;&gt;cursor/1,2&lt;/a&gt;&lt;/code&gt; 를 호출하는 프로세스와 관련하여 &lt;code&gt;PreFun&lt;/code&gt; 호출 직전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="403588e32c3c599137f65e61edac93c0adc811e6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;snmpEngineID&lt;/code&gt; is a string, which for a deployed agent should have a very specific structure. See RFC 2271/2571 for details.</source>
          <target state="translated">&lt;code&gt;snmpEngineID&lt;/code&gt; 의 값은 문자열이며, 배치 된 에이전트의 경우 매우 구체적인 구조를 가져야합니다. 자세한 내용은 RFC 2271/2571을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39576763fb2878e58995adcb19edf7b1f8b5b52e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;stop_fun&lt;/code&gt; is a nullary fun that deletes the cursor if called from the parent, or &lt;code&gt;undefined&lt;/code&gt; if there is no cursor.</source>
          <target state="translated">&lt;code&gt;stop_fun&lt;/code&gt; 의 값은 상위에서 호출 된 경우 커서를 삭제하거나 커서 가없는 경우 &lt;code&gt;undefined&lt;/code&gt; 널 재미입니다 .</target>
        </trans-unit>
        <trans-unit id="bbda166cbb0a64342130a713cafa3ff8a579278c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;tc_group_properties&lt;/code&gt; is a list of status tuples, each with the key &lt;code&gt;ok&lt;/code&gt;, &lt;code&gt;skipped&lt;/code&gt;, and &lt;code&gt;failed&lt;/code&gt;. The value of a status tuple is a list with names of test cases that have been executed with the corresponding status as result.</source>
          <target state="translated">&lt;code&gt;tc_group_properties&lt;/code&gt; 값은 각각 &lt;code&gt;ok&lt;/code&gt; , &lt;code&gt;skipped&lt;/code&gt; 및 &lt;code&gt;failed&lt;/code&gt; 키가있는 상태 튜플 목록입니다 . 상태 튜플의 값은 결과로 해당 상태로 실행 된 테스트 케이스 이름이있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c90e20096422723556a7637012d02aa52ba6cd06" translate="yes" xml:space="preserve">
          <source>The value of a configuration parameter is retrieved by calling &lt;code&gt;application:get_env/1,2&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수의 값은 &lt;code&gt;application:get_env/1,2&lt;/code&gt; 를 호출하여 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e674f5f0ae9761a28b0e34a6e1578f6940f7307" translate="yes" xml:space="preserve">
          <source>The value of a field in a record can be an instance of a record. Retrieval of nested data can be done stepwise, or in a single step, as shown in the following example:</source>
          <target state="translated">레코드의 필드 값은 레코드의 인스턴스 일 수 있습니다. 다음 예제와 같이 중첩 된 데이터 검색은 단계별 또는 단일 단계로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="090fd2fb5e0fd0eb93688d1bfcea8e341fe24db7" translate="yes" xml:space="preserve">
          <source>The value of option &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; is to be &lt;code&gt;'=:='&lt;/code&gt; if the table considers two keys equal if they match, and to be &lt;code&gt;'=='&lt;/code&gt; if two keys are equal if they compare equal. Defaults to &lt;code&gt;'=:='&lt;/code&gt;.</source>
          <target state="translated">옵션의 값 &lt;code id=&quot;key_equality&quot;&gt;key_equality&lt;/code&gt; 이 될 것입니다 &lt;code&gt;'=:='&lt;/code&gt; 테이블에 두 개의 키가 일치하는 경우와 동일하고,로 간주하는 경우 &lt;code&gt;'=='&lt;/code&gt; 가 동일한 비교하면 두 개의 키가 동일한 경우. 기본값은 &lt;code&gt;'=:='&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b5f4463cd58d2c1d9f4f3e85881555f2a7d602d" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;Parserfile&lt;/code&gt; option stripped of the &lt;code&gt;.erl&lt;/code&gt; extension is used by Yecc as the module name of the generated parser file.</source>
          <target state="translated">&lt;code&gt;.erl&lt;/code&gt; 확장자가 제거 된 &lt;code&gt;Parserfile&lt;/code&gt; 옵션 의 값은 Yecc 에서 생성 된 구문 분석기 파일의 모듈 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c64d7956fe51b588938aacaa6f88fb7a9310598" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;closure&lt;/code&gt; operator (the &lt;code&gt;digraph&lt;/code&gt; representation) is represented by the atom &lt;code&gt;'closure()'&lt;/code&gt;.</source>
          <target state="translated">의 값 &lt;code&gt;closure&lt;/code&gt; 조작합니다 ( &lt;code&gt;digraph&lt;/code&gt; 표현) 원자에 의해 표현되는 &lt;code&gt;'closure()'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22be0277bd691cf393301070a38cd39e17abb844" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;mod&lt;/code&gt; key of the including application must be set to &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; as usual is the application callback module. &lt;code&gt;StartArgs&lt;/code&gt; is a term provided as argument to the callback function &lt;code&gt;Module:start/2&lt;/code&gt;:</source>
          <target state="translated">포함 애플리케이션 의 &lt;code&gt;mod&lt;/code&gt; 키 값은 &lt;code&gt;{application_starter,[Module,StartArgs]}&lt;/code&gt; 로 설정해야합니다 . 여기서 &lt;code&gt;Module&lt;/code&gt; 은 일반적으로 애플리케이션 콜백 모듈입니다. &lt;code&gt;StartArgs&lt;/code&gt; 는 콜백 함수 &lt;code&gt;Module:start/2&lt;/code&gt; 에 인수로 제공되는 용어입니다 .</target>
        </trans-unit>
        <trans-unit id="da373a852b7bee0733084683f1b87c03b30e88ac" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;native&lt;/code&gt; time unit gives you more or less no information about the quality of time values. It sets a limit for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; and for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; of time values, but it gives no information about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; of time values. The resolution of the &lt;code&gt;native&lt;/code&gt; time unit and the resolution of time values can differ significantly.</source>
          <target state="translated">의 값 &lt;code&gt;native&lt;/code&gt; 시간 단위는 다소 시간 값의 품질에 대한 정보를 당신에게 제공하지 않습니다. &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; 및 시간 값 의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; 에 대한 한계를 설정 하지만 시간 값의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; 에 대한 정보는 제공하지 않습니다 . 해상도의 &lt;code&gt;native&lt;/code&gt; 시간 단위와 시간 값의 해상도는 크게 다를 수있다.</target>
        </trans-unit>
        <trans-unit id="e1d24fa6cc650f3b91539b4d964f2dd68411a599" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;native&lt;/code&gt; time unit gives you more or less no information about the quality of time values. It sets a limit for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; and for the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; of time values, but it gives no information about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; of time values. The resolution of the &lt;code&gt;native&lt;/code&gt; time unit and the resolution of time values can differ significantly.</source>
          <target state="translated">의 값 &lt;code&gt;native&lt;/code&gt; 시간 단위는 다소 시간 값의 품질에 대한 정보를 당신에게 제공하지 않습니다. &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; 와 시간 값 의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; 에 대한 제한을 설정 하지만 시간 값의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; 에 대한 정보는 제공하지 않습니다 . 해상도의 &lt;code&gt;native&lt;/code&gt; 시간 단위와 시간 값의 해상도는 크게 다를 수있다.</target>
        </trans-unit>
        <trans-unit id="75115f0cbc11f2e0c976711bd383faef47f72f73" translate="yes" xml:space="preserve">
          <source>The value of the Kernel configuration parameter &lt;code&gt;logger&lt;/code&gt; is a list of tuples. It is possible to write the term on the command line when starting an erlang node, but as the term grows, a better approach is to use the system configuration file. See the &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; manual page for more information about this file.</source>
          <target state="translated">커널 구성 매개 변수 &lt;code&gt;logger&lt;/code&gt; 의 값은 튜플 목록입니다. erlang 노드를 시작할 때 명령 행에 용어를 쓸 수 있지만 용어가 커질수록 시스템 구성 파일을 사용하는 것이 더 좋습니다. 참고 항목 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;config(4)&lt;/a&gt;&lt;/code&gt; 이 파일에 대한 자세한 내용은 설명서 페이지를.</target>
        </trans-unit>
        <trans-unit id="096809c94755b1b48047ae78701c25d723875bee" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;offset&lt;/code&gt; option to &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수의 값은 &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt; 의 &lt;code&gt;offset&lt;/code&gt; 옵션으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ed44d3d955ffacf489b8abf33f5d265d4032122" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;offset&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수의 값은 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 에 대한 &lt;code&gt;offset&lt;/code&gt; 옵션으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="de235421fccf5bce601796cc084376b482bb1b5e" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;time_designator&lt;/code&gt; option to &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수의 값은 &lt;code&gt; calendar:system_time_to_rcf3339/2&lt;/code&gt; 의 &lt;code&gt;time_designator&lt;/code&gt; 옵션으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c25e0afe475bdf7bd456a401767e588d0dff287" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as the &lt;code&gt;time_designator&lt;/code&gt; option to &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수의 값은 &lt;code&gt;calendar:system_time_to_rcf3339/2&lt;/code&gt; 에 대한 &lt;code&gt;time_designator&lt;/code&gt; 옵션으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcf4c591c4a3e4e565b4ce6c5bc397552958d5be" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on application level.</source>
          <target state="translated">이 매개 변수의 값은 응용 프로그램 레벨에서 동일한 이름을 가진 매개 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5f26c290284005b85aff4a14161e0e2b51659761" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the parameter with the same name on system level.</source>
          <target state="translated">이 매개 변수의 값은 시스템 레벨에서 동일한 이름을 가진 매개 변수를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="afeb557b1f15dc186755d5f00deaf5e3432d37f3" translate="yes" xml:space="preserve">
          <source>The value range stated at the top of this function description is technically correct, but &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; is a better description of the generated numbers' statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically.</source>
          <target state="translated">이 함수 설명 상단에 명시된 값 범위는 기술적으로 정확하지만 &lt;code&gt;0.0 =&amp;lt; X &amp;lt; 1.0&lt;/code&gt; 은 생성 된 숫자의 통계 분포에 대한 더 나은 설명입니다. 정확히 0.0이 반환되지 않는 한 통계적으로는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7e9882005855e83068faaf2ba230799c0a1530e" translate="yes" xml:space="preserve">
          <source>The value returned from &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; equals the, by this thread, latest confirmed value plus two. The global value may be latest confirmed value or latest confirmed value minus one. In order to be certain that all other managed threads actually will call &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; at least once before we reach the value returned from &lt;code&gt;erts_thr_progress_later()&lt;/code&gt;, the global counter plus one is not enough. This since all other threads may already have confirmed current global value plus one at the time when we call &lt;code&gt;erts_thr_progress_later()&lt;/code&gt;. They are however guaranteed not to have confirmed global value plus two at this time.</source>
          <target state="translated">&lt;code&gt;erts_thr_progress_later()&lt;/code&gt; 에서 반환 된 값 은이 스레드에 의해 최근 확인 된 값에 2를 더한 값과 같습니다. 글로벌 값은 최근 확인 값 또는 최근 확인 값에서 1을 뺀 값일 수 있습니다. 위해서는 다른 모든 관리되는 스레드가 실제로 호출 것을 확신 할 수 있습니다 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; 적어도 우리가에서 반환 된 값에 도달하기 전에 한 번 &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; , 글로벌 카운터를 더하기 하나는 충분하지 않습니다. 이는 다른 모든 스레드가 &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; 호출 할 때 현재 글로벌 값에 1을 더한 값을 이미 확인했을 수 있기 때문 입니다. 그러나 그들은 현재 글로벌 가치에 2를 더한 값을 확인하지 못했음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="de293b0684a913e1bf7ebfb80ee4f6ab7675b8bf" translate="yes" xml:space="preserve">
          <source>The value returned is the number of seconds since 19680120T031408Z, the first value that can be encoded as a Diameter &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, at the time the diameter application was started.</source>
          <target state="translated">리턴 된 값은 19680120T031408Z &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;Time()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 지름 애플리케이션이 시작된 시점에서 지름 시간 () 으로 인코딩 될 수있는 첫 번째 값) 이후의 초 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a55ba7f90cd067fd29a372ba9492df0943f53a10" translate="yes" xml:space="preserve">
          <source>The value specifies a list of source files to be merged with the file being compiled; cf. &lt;code&gt;merge_files/4&lt;/code&gt;.</source>
          <target state="translated">값은 컴파일 할 파일과 병합 할 소스 파일 목록을 지정합니다. cf. &lt;code&gt;merge_files/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9a745307527128e1be0119641ffa2f422dcd359" translate="yes" xml:space="preserve">
          <source>The value(s) correspond to the currently active socket &lt;code&gt;&lt;a href=&quot;#type-socket_setopt&quot;&gt;options&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt;, or for a single send operation the option(s) to override the currently active socket option(s).</source>
          <target state="translated">값은 현재 활성화 된 소켓 &lt;code&gt;&lt;a href=&quot;#type-socket_setopt&quot;&gt;options&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; 에 해당하거나 단일 전송 작업의 경우 현재 활성화 된 소켓 옵션을 재정의하는 옵션에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9f03a18e612b75547971d666854d8f1114a5bb61" translate="yes" xml:space="preserve">
          <source>The values encoded in the fields of generated records depends on the type and number of times the AVP can occur. In particular, an AVP which is specified as occurring exactly once is encoded as a value of the AVP's type while an AVP with any other specification is encoded as a list of values of the AVP's type. The AVP's type is as specified in the AVP definition, the RFC 6733 types being described below.</source>
          <target state="translated">생성 된 레코드의 필드에 인코딩 된 값은 AVP가 발생할 수있는 유형 및 횟수에 따라 다릅니다. 특히 정확히 한 번만 발생하는 것으로 지정된 AVP는 AVP 유형의 값으로 인코딩되고 다른 사양의 AVP는 AVP 유형의 값 목록으로 인코딩됩니다. AVP의 유형은 AVP 정의에 지정된대로 RFC 6733 유형은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="28cbef0507c54b3b51d13679291493de8c4ec6f1" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file and the values in a system configuration file can be overridden directly from the command line:</source>
          <target state="translated">의 값 &lt;code&gt;.app&lt;/code&gt; 시스템 구성 파일의 파일과 값은 명령 줄에서 직접 대체 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="25131865afbeb61db1691607b17034d98faf548c" translate="yes" xml:space="preserve">
          <source>The values in the &lt;code&gt;.app&lt;/code&gt; file can be overridden by values in a &lt;strong&gt;system configuration file&lt;/strong&gt;. This is a file that contains configuration parameters for relevant applications:</source>
          <target state="translated">의 값 &lt;code&gt;.app&lt;/code&gt; 파일은의 값에 의해 대체 될 수 있습니다 &lt;strong&gt;시스템 구성 파일&lt;/strong&gt; . 이것은 관련 응용 프로그램에 대한 구성 매개 변수가 포함 된 파일입니다.</target>
        </trans-unit>
        <trans-unit id="626a57e5be3f05ed3f7f8f360fb873aeecee8e88" translate="yes" xml:space="preserve">
          <source>The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is &lt;code&gt;index&lt;/code&gt;, the tuple &lt;code&gt;{-1,0}&lt;/code&gt; is returned for values with no corresponding subpattern in the regular expression, but for the other types (&lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt;), the values are the empty binary or list, respectively.</source>
          <target state="translated">값 목록은 정규식에없는 색인 또는 이름을 지정할 수 있으며,이 경우 반환 값은 유형에 따라 다릅니다. type이 &lt;code&gt;index&lt;/code&gt; 인 경우 정규식에서 해당하는 서브 패턴이없는 값에 대해 튜플 &lt;code&gt;{-1,0}&lt;/code&gt; 이 리턴되지만 다른 유형 ( &lt;code&gt;binary&lt;/code&gt; 및 &lt;code&gt;list&lt;/code&gt; )의 경우 값은 각각 빈 2 진 또는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="98c64e5c6439b461a184b2c5ad5e2ae137e1bafa" translate="yes" xml:space="preserve">
          <source>The values of L used in the tree is a dense range from &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;Max - 1&lt;/code&gt;, where &lt;code&gt;N =&amp;lt; Max =&amp;lt; N + size(Tree)&lt;/code&gt;. Note that it is possible that no labels are used at all, i.e., &lt;code&gt;N = Max&lt;/code&gt;.</source>
          <target state="translated">트리에 사용 된 L 값은 &lt;code&gt;N&lt;/code&gt; 에서 &lt;code&gt;Max - 1&lt;/code&gt; 까지의 조밀 한 범위입니다 . 여기서 &lt;code&gt;N =&amp;lt; Max =&amp;lt; N + size(Tree)&lt;/code&gt; . 레이블이 전혀 사용되지 않을 수 있습니다 (예 : &lt;code&gt;N = Max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="863d5cefc2b644473a83e6d5a4a11ff192199273" translate="yes" xml:space="preserve">
          <source>The values of each ASN.1 type have their own representation in Erlang, as described in the following sections. Users must provide these values for encoding according to the representation, as shown in the following example:</source>
          <target state="translated">각 ASN.1 유형의 값은 다음 섹션에 설명 된대로 Erlang에서 고유 한 표현을 갖습니다. 사용자는 다음 예제와 같이 표현에 따라 인코딩에 이러한 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cda52f885cae0f363921f91bfa5571c49510a4d" translate="yes" xml:space="preserve">
          <source>The values of the largest multiblock carrier size (&lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">가장 큰 &lt;code&gt;&lt;a href=&quot;#M_lmbcs&quot;&gt;lmbcs&lt;/a&gt;&lt;/code&gt; 블록 캐리어 크기 ( lmbcs )의 값</target>
        </trans-unit>
        <trans-unit id="dcd3ad0ab905a987c601beb85b07dfe07ff7ed75" translate="yes" xml:space="preserve">
          <source>The values of the previously listed thresholds can be specified by the user. This way, a handler can be configured to, for example, not drop or flush messages unless the message queue length of the handler process grows extremely large. Notice that large amounts of memory can be required for the node under such circumstances. Another example of user configuration is when, for performance reasons, the client processes must never be blocked by synchronous log requests. It is possible, perhaps, that dropping or flushing events is still acceptable, since it does not affect the performance of the client processes sending the log events.</source>
          <target state="translated">이전에 나열된 임계 값은 사용자가 지정할 수 있습니다. 이런 식으로 처리기는 처리기 프로세스의 메시지 큐 길이가 너무 커지지 않는 한 메시지를 삭제하거나 플러시하지 않도록 구성 할 수 있습니다. 이러한 상황에서는 노드에 많은 양의 메모리가 필요할 수 있습니다. 사용자 구성의 또 다른 예는 성능상의 이유로 클라이언트 프로세스가 동기식 로그 요청으로 차단되어서는 안되는 경우입니다. 로그 이벤트를 보내는 클라이언트 프로세스의 성능에 영향을 미치지 않으므로 이벤트 삭제 또는 플러시가 여전히 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98636015bbae4c3fb1d161c6f8cb32205bc5b72f" translate="yes" xml:space="preserve">
          <source>The values of unused bits are disregarded and does not need to be cleared.</source>
          <target state="translated">사용되지 않은 비트의 값은 무시되며 지울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b7f02eea975023ab88f97c824c6cf6ba208bfb2" translate="yes" xml:space="preserve">
          <source>The values of unused bits in the first and last byte are undefined and cannot be relied on.</source>
          <target state="translated">첫 번째 및 마지막 바이트에서 사용되지 않은 비트의 값은 정의되지 않으며 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20d445c310ac867e11827b280d08f4096d3c3c12" translate="yes" xml:space="preserve">
          <source>The values stored when &lt;code&gt;put&lt;/code&gt; is evaluated within the scope of a &lt;code&gt;catch&lt;/code&gt; are not retracted if a &lt;code&gt;throw&lt;/code&gt; is evaluated, or if an error occurs.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 를 평가하거나 오류가 발생하면 &lt;code&gt;catch&lt;/code&gt; 범위 내에서 &lt;code&gt;put&lt;/code&gt; 을 평가할 때 저장된 값 이 취소되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f0e48d6dd38ad6c9102722d33252c5ae65615ba8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;$ERL_TOP&lt;/code&gt; will be mentioned a lot of times. It refers to the top directory in the source tree. More information about &lt;code&gt;$ERL_TOP&lt;/code&gt; can be found in the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; section below. If you are building in git you probably want to take a look at the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section below before proceeding.</source>
          <target state="translated">&lt;code&gt;$ERL_TOP&lt;/code&gt; 변수 는 여러 번 언급됩니다. 소스 트리의 최상위 디렉토리를 나타냅니다. &lt;code&gt;$ERL_TOP&lt;/code&gt; 에 대한 자세한 내용은 아래 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_make-and-ERLTOP&quot;&gt;make and $ERL_TOP&lt;/a&gt;&lt;/code&gt; 섹션 에서 확인할 수 있습니다 . git로 빌드하는 경우 계속하기 전에 아래의 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Within-Git&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 섹션을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="b71a4a47f8b57681eb67d0f149cf4d7c4811e3e6" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$$'&lt;/code&gt; expands to a list of the values of all bound variables in order (that is, &lt;code&gt;['$1','$2', ...]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'$$'&lt;/code&gt; 변수 는 모든 바인딩 된 변수의 값 목록 (즉, &lt;code&gt;['$1','$2', ...]&lt;/code&gt; )으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="9e92c9812c408c5ff3803c9050d025112ca40670" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;'$_'&lt;/code&gt; expands to the whole &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; term.</source>
          <target state="translated">&lt;code&gt;'$_'&lt;/code&gt; 변수 는 전체 &lt;code&gt;&lt;a href=&quot;#match_target&quot;&gt;match target&lt;/a&gt;&lt;/code&gt; 용어로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="223547b0ee006d68fdeafe7dbabcdb4195ccc06b" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;Bin&lt;/code&gt; must contain a whole number of bytes, because the &lt;code&gt;binary&lt;/code&gt; type defaults to &lt;code&gt;unit:8&lt;/code&gt;. A &lt;code&gt;badarg&lt;/code&gt; exception is generated if &lt;code&gt;Bin&lt;/code&gt; consist of, for example, 17 bits.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 유형의 기본값은 &lt;code&gt;unit:8&lt;/code&gt; 이므로 변수 &lt;code&gt;Bin&lt;/code&gt; 에는 전체 바이트 수가 포함되어야합니다 . &lt;code&gt;badarg&lt;/code&gt; 의 경우, 예외가 발생 &lt;code&gt;Bin&lt;/code&gt; 예를 들면, 17 비트로 구성.</target>
        </trans-unit>
        <trans-unit id="b327cd3ab139aaaeb5479b3a8cd2e03a44cba9d4" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the bit string comprehensions.</source>
          <target state="translated">생성기 패턴의 변수, 함수 문자열의 그림자 변수, 비트 문자열 이해를 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="ba7b76fc37dd4760f96fd86e277ce66335f21492" translate="yes" xml:space="preserve">
          <source>The variables in the generator patterns, shadow variables in the function clause, surrounding the list comprehensions.</source>
          <target state="translated">생성기 패턴의 변수, 함수 절의 그림자 변수, 목록 이해를 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="c3cbd2f6779e41d23e6821f5cc806aa75af8d5cf" translate="yes" xml:space="preserve">
          <source>The variables in the specified test system configuration files are imported for the test.</source>
          <target state="translated">지정된 테스트 시스템 구성 파일의 변수를 테스트 용으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="16b31340c6df5777f901eec1b8dd72202ecc99a3" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;iodata()&lt;/code&gt; that gives the least copying of data with the current implementation (often a binary, but do not depend on it).</source>
          <target state="translated">현재 구현으로 데이터를 최소한으로 복사하는 &lt;code&gt;iodata()&lt;/code&gt; 의 변형 (종종 이진이지만 의존하지는 않음)</target>
        </trans-unit>
        <trans-unit id="7db0c9c9f81aaee69d11da93235542d480ff9436" translate="yes" xml:space="preserve">
          <source>The variants &lt;code&gt;http_bin&lt;/code&gt; and &lt;code&gt;httph_bin&lt;/code&gt; return strings (&lt;code&gt;HttpString&lt;/code&gt;) as binaries instead of lists.</source>
          <target state="translated">변형 &lt;code&gt;http_bin&lt;/code&gt; 및 &lt;code&gt;httph_bin&lt;/code&gt; 은 문자열 ( &lt;code&gt;HttpString&lt;/code&gt; )을 목록 대신 이진으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="386d7a023ddb83a55d49c04d2e00b77bbc947fdc" translate="yes" xml:space="preserve">
          <source>The verb name comes from the observation that it can be used for a pattern-based if-then-else block:</source>
          <target state="translated">동사 이름은 패턴 기반 if-then-else 블록에 사용될 수 있다는 관찰에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="e53a018823f7d0826b490411f9a345448e7e805f" translate="yes" xml:space="preserve">
          <source>The verbs described above provide four different &quot;strengths&quot; of control when subsequent matching fails:</source>
          <target state="translated">위에 설명 된 동사는 후속 일치에 실패 할 때 네 가지 제어 &quot;강도&quot;를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f2b992bf8000e459ed5b0cdc131fc96ec8dcdccf" translate="yes" xml:space="preserve">
          <source>The verification fun is called during the X509-path validation when an error or an extension unknown to the SSL application is encountered. It is also called when a certificate is considered valid by the path validation to allow access to each certificate in the path to the user application. It differentiates between the peer certificate and the CA certificates by using &lt;code&gt;valid_peer&lt;/code&gt; or &lt;code&gt;valid&lt;/code&gt; as second argument to the verification fun. See the &lt;code&gt;public_key User's Guide&lt;/code&gt; for definition of &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; and &lt;code&gt;#'Extension'{}&lt;/code&gt;.</source>
          <target state="translated">SSL 애플리케이션에 알려지지 않은 오류 또는 확장이 발생하면 X509 경로 유효성 검증 중에 검증 기능이 호출됩니다. 사용자 응용 프로그램 경로의 각 인증서에 대한 액세스를 허용하기 위해 경로 유효성 검사에 의해 인증서가 유효한 것으로 간주 될 때도 호출됩니다. &lt;code&gt;valid_peer&lt;/code&gt; 두 번째 인수로 valid_peer 또는 &lt;code&gt;valid&lt;/code&gt; 를 사용하여 피어 인증서와 CA 인증서를 구별합니다 . &lt;code&gt;#'OTPCertificate'{}&lt;/code&gt; 및 &lt;code&gt;#'Extension'{}&lt;/code&gt; 의 정의에 대해서는 &lt;code&gt;public_key User's Guide&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1de90c0b2842f11f7973bd5edddedba51c5c85c5" translate="yes" xml:space="preserve">
          <source>The verification fun is to be defined as follows:</source>
          <target state="translated">검증 재미는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e534d40ef492be59da6ec155736a8f23e023fdd5" translate="yes" xml:space="preserve">
          <source>The verification process</source>
          <target state="translated">검증 과정</target>
        </trans-unit>
        <trans-unit id="a7587f36555080700643b0019cdfdef45f4827cd" translate="yes" xml:space="preserve">
          <source>The version is defined by the module attribute &lt;code&gt;vsn&lt;/code&gt;, if any. There is no such attribute in &lt;code&gt;ch3&lt;/code&gt;, so in this case the version is the checksum (a huge integer) of the beam file, an uninteresting value, which is ignored.</source>
          <target state="translated">버전은 &lt;code&gt;vsn&lt;/code&gt; 모듈 속성으로 정의됩니다 (있는 경우). &lt;code&gt;ch3&lt;/code&gt; 에는 이러한 속성이 없으므로이 경우 버전은 빔 파일의 체크섬 (거대한 정수)이며 무관심 값으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b6440cebe392d666b5024e49f82c9929c9694517" translate="yes" xml:space="preserve">
          <source>The version numbers differ in your system. Whenever one of the applications included in the script is upgraded, change the script.</source>
          <target state="translated">시스템에서 버전 번호가 다릅니다. 스크립트에 포함 된 응용 프로그램 중 하나가 업그레이드 될 때마다 스크립트를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="81ee8706973e7d65b914ed727a2144141d282b58" translate="yes" xml:space="preserve">
          <source>The version of an application specified in the &lt;code&gt;.rel&lt;/code&gt; file is to be the same as the version specified in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.rel&lt;/code&gt; 파일에 지정된 응용 프로그램 의 버전은 &lt;code&gt;.app&lt;/code&gt; 파일에 지정된 버전과 동일해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d2168251640676c1f75844920669340f83623b6f" translate="yes" xml:space="preserve">
          <source>The version of net-if provided by this application makes no use of this data, with one exception: Any tuple containing the atom &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; may be used by the agent and is therefor &lt;strong&gt;reserved&lt;/strong&gt;.</source>
          <target state="translated">이 응용 프로그램에서 제공하는 net-if 버전은 한 가지 예외를 제외하고이 데이터를 사용하지 않습니다. 원자 &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; 를 포함하는 모든 튜플 은 에이전트가 사용할 수 있으며 &lt;strong&gt;예약되어&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ae167373b6abecea965d3976c2d1e8cb0f8001" translate="yes" xml:space="preserve">
          <source>The version of the application. In an installed system there may exist several versions of an application. The &lt;code&gt;vsn&lt;/code&gt; parameter controls which version of the application will be chosen.</source>
          <target state="translated">응용 프로그램의 버전입니다. 설치된 시스템에는 여러 버전의 응용 프로그램이있을 수 있습니다. &lt;code&gt;vsn&lt;/code&gt; 애플리케이션의 버전을 선택한다 파라미터 조절기.</target>
        </trans-unit>
        <trans-unit id="0f6691af69660ac2dbeef6458e54f6b092b02a7f" translate="yes" xml:space="preserve">
          <source>The version scheme was changed as of OTP 17.0. This implies that application versions used prior to OTP 17.0 do not adhere to this version scheme. &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt; is included at the end of this section</source>
          <target state="translated">버전 체계는 OTP 17.0부터 변경되었습니다. 이는 OTP 17.0 이전에 사용 된 응용 프로그램 버전이이 버전 체계를 따르지 않음을 의미합니다. &lt;code&gt;&lt;a href=&quot;#otp_17_0_app_versions&quot;&gt;A list of application versions used in OTP 17.0&lt;/a&gt;&lt;/code&gt; 은이 섹션의 끝에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="71667a4b4c466db83cfa8dccda4dd2b33a602563" translate="yes" xml:space="preserve">
          <source>The versions are defined in following RFCs</source>
          <target state="translated">버전은 다음 RFC에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4892e73c1831bf8a3d6b46b7aa415cf267e8507" translate="yes" xml:space="preserve">
          <source>The viewed trace data is normally collected from Erlang trace ports or files.</source>
          <target state="translated">조회 된 추적 데이터는 일반적으로 Erlang 추적 포트 또는 파일에서 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0d8d976122d98e4cfd120d6e6af690ee189bd4" translate="yes" xml:space="preserve">
          <source>The virtual binary heap exists in order to &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L364&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; garbage collections earlier when potentially there is a very large amount of off-heap binary data that could be reclaimed. This approach does not catch all problems with binary memory not being released soon enough, but it does catch a lot of them.</source>
          <target state="translated">재 확보 할 수있는 매우 많은 양의 오프 힙 이진 데이터가 잠재적으로있을 때 가비지 콜렉션을 더 일찍 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L364&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; 하기 위해 가상 이진 힙이 존재합니다 . 이 접근법은 바이너리 메모리가 곧 출시되지 않는 모든 문제를 포착하지는 않지만 많은 문제를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="4c8e60b869b23fc7c125b17fff74830d66f135c3" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_NET_RAW&lt;/code&gt;.</source>
          <target state="translated">가상 머신에는 또한 수퍼 유저 또는 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능이있는 (Linux의 경우) 상승 된 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="cc464fdb800c73159385639322d0fc6141087504" translate="yes" xml:space="preserve">
          <source>The virtual machine also needs elevated privileges, either running as superuser or (for Linux) having capability &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; according to the documentation for &lt;code&gt;setns(2)&lt;/code&gt;. However, during testing also &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; and &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; have proven to be necessary.</source>
          <target state="translated">또한 가상 머신에는 &lt;code&gt;setns(2)&lt;/code&gt; 설명서에 따라 수퍼 유저로 실행하거나 &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt; 기능이있는 (Linux의 경우) 상승 된 권한이 필요합니다 . 그러나 테스트 중에 &lt;code&gt;CAP_SYS_PTRACE&lt;/code&gt; 및 &lt;code&gt;CAP_DAC_READ_SEARCH&lt;/code&gt; 도 필요한 것으로 입증되었습니다.</target>
        </trans-unit>
        <trans-unit id="c60aa1ccef629b3d22eb0b09964d1681efe07a87" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using UTF-8 (or some other system-specific Unicode encoding). This is the default on operating systems that enforce Unicode encoding, that is, Windows MacOS X and Android.</source>
          <target state="translated">가상 머신은 UTF-8 (또는 기타 시스템 별 유니 코드 인코딩)을 사용하여 인코딩 된 것처럼 파일 이름으로 작동합니다. 이는 유니 코드 인코딩을 적용하는 운영 체제, 즉 Windows MacOS X 및 Android의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="006ddc155b00e369e7d44f1b15919a8110bdd467" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using UTF-8 (or some other system-specific Unicode encoding). This is the default on operating systems that enforce Unicode encoding, that is, Windows and MacOS X.</source>
          <target state="translated">가상 머신은 파일 이름이 UTF-8 (또는 다른 시스템 고유의 유니 코드 인코딩)을 사용하여 인코딩 된 것처럼 파일 이름과 함께 작동합니다. 이것이 유니 코드 인코딩을 적용하는 운영 체제, 즉 Windows 및 MacOS X의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c517daaf8ca72cb9652e4e1b82ea25a6ea34e353" translate="yes" xml:space="preserve">
          <source>The virtual machine works with filenames as if they are encoded using the ISO Latin-1 encoding, disallowing Unicode characters with code points &amp;gt; 255.</source>
          <target state="translated">가상 머신은 ISO Latin-1 인코딩을 사용하여 인코딩 된 것처럼 파일 이름을 사용하여 코드 포인트가 255보다 큰 유니 코드 문자를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7328722d5a1a5caf291033df806ee0e4a77a5bcb" translate="yes" xml:space="preserve">
          <source>The waiting for thread progress in 4-6 is necessary in order for processes to read &lt;code&gt;the_active_code_index&lt;/code&gt; atomic during normal execution without any expensive memory barriers. When we write a new value into &lt;code&gt;the_active_code_index&lt;/code&gt; in step 6, we know that all schedulers will see an updated and consistent view of all the new active access structures once they become reachable through &lt;code&gt;the_active_code_index&lt;/code&gt;.</source>
          <target state="translated">프로세스가 값 비싼 메모리 장벽없이 정상적인 실행 중에 &lt;code&gt;the_active_code_index&lt;/code&gt; 원자 를 읽기 위해서는 4-6에서 스레드 진행을 기다리는 것이 필요 합니다. 6 단계에서 &lt;code&gt;the_active_code_index&lt;/code&gt; 에 새 값을 쓸 때 모든 스케줄러는 &lt;code&gt;the_active_code_index&lt;/code&gt; 를 통해 도달 할 수있게되면 모든 새 활성 액세스 구조의 업데이트되고 일관된보기를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d97e463a7a60c3b6aea9ab7db9eb585b1ed683" translate="yes" xml:space="preserve">
          <source>The waiting in step 10 is to make sure no lingering thread is still accessing disabled breakpoint structures to be deallocated in step 12.</source>
          <target state="translated">10 단계에서 대기하는 것은 12 단계에서 할당 해제 될 비활성화 된 중단 점 구조에 여전히 액세스중인 느린 스레드가 없는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="72bf42f8550a67bb1de6bfd1cb44b03b77930eb8" translate="yes" xml:space="preserve">
          <source>The waiting in step 4 is to make sure all threads will see an updated view of the breakpoint structures once they become reachable through the &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; instruction written in step 5.</source>
          <target state="translated">4 단계에서 기다리는 것은 5 단계에서 작성된 &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; 명령어를 통해 도달 할 수있게되면 모든 스레드가 중단 점 구조의 업데이트 된보기를 볼 수 있도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="053a67fd8d554f23b57dd15ba93a7604fd04b7ad" translate="yes" xml:space="preserve">
          <source>The waiting in step 6 is to make the activation of the new trace settings &quot;as atomic as possible&quot;. Different cores might see the new value of &lt;code&gt;erts_active_bp_index&lt;/code&gt; at different times as it is read without any memory barrier. But this is the best we can do without more expensive thread synchronization.</source>
          <target state="translated">6 단계에서 대기하는 것은 &quot;가능한 한 원자 적&quot;으로 새 추적 설정을 활성화하는 것입니다. 다른 코어는 메모리 장벽없이 읽을 때 다른 시간 에 &lt;code&gt;erts_active_bp_index&lt;/code&gt; 의 새로운 값을 볼 수 있습니다 . 그러나 이것은 더 비싼 스레드 동기화없이 할 수있는 최선의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8e0755f04339935ab04dbc314aa1c277dab33406" translate="yes" xml:space="preserve">
          <source>The waiting in step 8 is to make sure we dont't restore the original bream instructions for disabled breakpoints until we know that no thread is still accessing the old enabled part of a disabled breakpoint.</source>
          <target state="translated">8 단계에서 기다리는 것은 비활성화 된 중단 점의 이전 활성화 된 부분에 액세스하는 스레드가 없음을 알 때까지 비활성화 된 중단 점에 대한 원래 bream 명령을 복원하지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="13ed31f912a0c3756dff51206169f32f13717017" translate="yes" xml:space="preserve">
          <source>The wanted string encoding is specified by &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt;. The original encoding used in the binary format (Latin-1 or UTF-8) can be obtained from &lt;code&gt;*was&lt;/code&gt;. The encoding of the resulting string (7-bit ASCII, Latin-1, or UTF-8) can be obtained from &lt;code&gt;*result&lt;/code&gt;. Both &lt;code&gt;was&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; can be &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;*result&lt;/code&gt; can differ from &lt;code&gt;want&lt;/code&gt; if &lt;code&gt;want&lt;/code&gt; is a bitwise OR'd combination like &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; or if &lt;code&gt;*result&lt;/code&gt; turns out to be pure 7-bit ASCII (compatible with both Latin-1 and UTF-8).</source>
          <target state="translated">원하는 문자열 인코딩은 &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;want&lt;/a&gt;&lt;/code&gt; 로 지정됩니다 . 이진 형식 (Latin-1 또는 UTF-8)에 사용 된 원래 인코딩은 &lt;code&gt;*was&lt;/code&gt; 에서 얻을 수 있습니다 . 결과 문자열 (7 비트 ASCII, 라틴 -1 또는 UTF-8)의 인코딩은 &lt;code&gt;*result&lt;/code&gt; 에서 얻을 수 있습니다 . 모두 &lt;code&gt;was&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 될 수 &lt;code&gt;NULL&lt;/code&gt; . &lt;code&gt;*result&lt;/code&gt; 다를 수 있습니다 &lt;code&gt;want&lt;/code&gt; 하면 &lt;code&gt;want&lt;/code&gt; 같은 비트 논리합 조합 &lt;code&gt;ERLANG_LATIN1|ERLANG_UTF8&lt;/code&gt; 경우 또는 &lt;code&gt;*result&lt;/code&gt; 순수한 7 비트 ASCII로 밝혀 (와 호환 모두 라틴어-1과 UTF-8).</target>
        </trans-unit>
        <trans-unit id="018d5b3762ed16f8137ce9fdaea1d65522f0b4e2" translate="yes" xml:space="preserve">
          <source>The warning for the first clause says that the creation of a sub binary cannot be delayed, because it will be returned. The warning for the second clause says that a sub binary will not be created (yet).</source>
          <target state="translated">첫 번째 절에 대한 경고는 하위 바이너리의 생성이 반환 될 수 있기 때문에 지연 될 수 없음을 나타냅니다. 두 번째 절에 대한 경고는 하위 바이너리가 아직 생성되지 않는다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="5ce61e8b18d0497bc2e9762acc6fdf3697ac3b7b" translate="yes" xml:space="preserve">
          <source>The warning is given if the number of shift/reduce conflicts differs from 2, or if there are reduce/reduce conflicts.</source>
          <target state="translated">이동 / 감소 충돌 수가 2와 다르거 나 감소 / 감소 충돌이있는 경우 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eac3dbbed6bc0bb402c42ed8978c9b0740688aad" translate="yes" xml:space="preserve">
          <source>The warning message will look like this:</source>
          <target state="translated">경고 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40ff587868921130f6eb1c6a720b2933f27272e9" translate="yes" xml:space="preserve">
          <source>The warnings detected include:</source>
          <target state="translated">감지 된 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57441a0a1920375468fcb3cda7b741895e7ab716" translate="yes" xml:space="preserve">
          <source>The warnings look as follows:</source>
          <target state="translated">경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3bcce3258cf3577717dad6c74c35c711e27cd4cd" translate="yes" xml:space="preserve">
          <source>The way EUnit represents tests and test sets as data is flexible, powerful, and concise. This section describes the representation in detail.</source>
          <target state="translated">데이터가 유연하고 강력하며 간결하기 때문에 EUnit이 테스트 및 테스트 세트를 나타내는 방식입니다. 이 섹션에서는 표현에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="965b7339512f62c1c68183166bad964a056729e8" translate="yes" xml:space="preserve">
          <source>The web-based GUI, Virtual Test Server (VTS), is started with the &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program. From the GUI, you can load configuration files and select directories, suites, and cases to run. You can also state the configuration files, directories, suites, and cases on the command line when starting the web-based GUI.</source>
          <target state="translated">웹 기반 GUI 인 VTS (Virtual Test Server)는 &lt;code&gt;&lt;a href=&quot;run_test_chapter#ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 프로그램으로 시작됩니다 . GUI에서 구성 파일을로드하고 실행할 디렉토리, 스위트 및 케이스를 선택할 수 있습니다. 웹 기반 GUI를 시작할 때 명령 줄에 구성 파일, 디렉토리, 스위트 및 케이스를 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6550d3349d235f242c72f62c04f437d2ce48c34b" translate="yes" xml:space="preserve">
          <source>The well-known quick sort routine can be written as follows:</source>
          <target state="translated">잘 알려진 빠른 정렬 루틴은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1daf9c055686d26205a86325249ab61a258c6aa6" translate="yes" xml:space="preserve">
          <source>The whole list comprehension must be given to the function &lt;code&gt;qlc:q/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;qlc:q/1&lt;/code&gt; 함수에 전체 목록 이해가 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a700c9c164740d8193a70ef5191bc6f87818b7c6" translate="yes" xml:space="preserve">
          <source>The whole original data chunk attempted to be sent.</source>
          <target state="translated">원본 데이터 청크 전체를 보내려고했습니다.</target>
        </trans-unit>
        <trans-unit id="3f50dc8a9a7232f081e9d82f5c58d1d5ab88774d" translate="yes" xml:space="preserve">
          <source>The wildcard string looks like an ordinary filename, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="translated">와일드 카드 문자열은 다음과 같은 &quot;와일드 카드 문자&quot;가 특별한 방식으로 해석된다는 점을 제외하면 일반적인 파일 이름처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="445ca2425df9850fe9ecf76a693661ab20880f20" translate="yes" xml:space="preserve">
          <source>The window is divided into the following five parts:</source>
          <target state="translated">창은 다음 다섯 부분으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="7aff75c1f4395e5c6a248f745c978774f96901a5" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;ANNO&lt;/code&gt; in this section represents an annotation, and denotes among other things the number of the line in the source file where the construction occurred. See &lt;code&gt;erl_anno(3)&lt;/code&gt; for details. Several instances of &lt;code&gt;ANNO&lt;/code&gt; in the same construction can denote different annotations.</source>
          <target state="translated">이 섹션에서 &lt;code&gt;ANNO&lt;/code&gt; 라는 단어 는 주석을 나타내며 무엇보다도 생성이 발생한 소스 파일의 행 번호를 나타냅니다. 자세한 내용은 &lt;code&gt;erl_anno(3)&lt;/code&gt; 를 참조하십시오. 동일한 구성 의 여러 &lt;code&gt;ANNO&lt;/code&gt; 인스턴스 는 다른 주석을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c5d5fc6a6c1a668ddf6252dfa60f0a768f4fd44" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;LINE&lt;/code&gt; in this section represents an integer, and denotes the number of the line in the source file where the construction occurred. Several instances of &lt;code&gt;LINE&lt;/code&gt; in the same construction can denote different lines.</source>
          <target state="translated">이 섹션에서 &lt;code&gt;LINE&lt;/code&gt; 이라는 단어 는 정수를 나타내며 구성이 발생한 소스 파일의 줄 수를 나타냅니다. 동일한 구성에서 &lt;code&gt;LINE&lt;/code&gt; 의 여러 인스턴스 는 다른 선을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eade7caf0a719386f3ed9bf0405c428ad15ea3eb" translate="yes" xml:space="preserve">
          <source>The workflow is as follows:</source>
          <target state="translated">워크 플로우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9930007b7ab7effc4f3827d9e45f7224f2de6c3" translate="yes" xml:space="preserve">
          <source>The working directory for the Erlang emulator. Must be on a local drive (no network drives are mounted when a service starts). Default working directory for services is &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt;. Debug log files will be placed in this directory.</source>
          <target state="translated">Erlang 에뮬레이터의 작업 디렉토리. 로컬 드라이브에 있어야합니다 (서비스가 시작될 때 네트워크 드라이브가 마운트되지 않음). 서비스의 기본 작업 디렉토리는 &lt;code&gt;%SystemDrive%%SystemPath%&lt;/code&gt; 입니다. 디버그 로그 파일이이 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="256bb673e1707d94ab2537efadaa95bffde4c53b" translate="yes" xml:space="preserve">
          <source>The written string is always &lt;code&gt;NULL&lt;/code&gt;-terminated, unless buffer &lt;code&gt;size&lt;/code&gt; is &amp;lt; &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">버퍼 &lt;code&gt;size&lt;/code&gt; 가 &amp;lt; &lt;code&gt;1&lt;/code&gt; 이 아니면 기록 된 문자열은 항상 &lt;code&gt;NULL&lt;/code&gt; 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f7a1436c802ad678039fa82fd904d4269922bbb" translate="yes" xml:space="preserve">
          <source>The wxWidgets-3.1 version should also work if 2.8 compatibility is enabled, add &lt;code&gt;--enable-compat28&lt;/code&gt; to configure commands below.</source>
          <target state="translated">2.8 호환성이 활성화 된 경우 wxWidgets-3.1 버전도 작동해야합니다. &lt;code&gt;--enable-compat28&lt;/code&gt; 을 추가 하여 아래 명령을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8a53a91ff254f2bc93279dc81109c603e90d0d26" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec.</source>
          <target state="translated">xmerl_xpath 모듈은 전체 XPath 1.0 사양을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="119bf8dc786018631b7988a88beda339c2ba800b" translate="yes" xml:space="preserve">
          <source>The xmerl_xpath module handles the entire XPath 1.0 spec. XPath expressions typically occur in XML attributes and are used to address parts of an XML document. The grammar is defined in &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt;. The core functions are defined in &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt;.</source>
          <target state="translated">xmerl_xpath 모듈은 전체 XPath 1.0 사양을 처리합니다. XPath 표현식은 일반적으로 XML 속성에서 발생하며 XML 문서의 일부를 처리하는 데 사용됩니다. 문법은 &lt;code&gt;xmerl_xpath_parse.yrl&lt;/code&gt; 에 정의되어 있습니다 . 핵심 기능은 &lt;code&gt;xmerl_xpath_pred.erl&lt;/code&gt; 에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a5386595bb90d8f1e716194fa384056a3c48037" translate="yes" xml:space="preserve">
          <source>The young heap, or the allocation heap, consists of the stack and heap as described in the Overview. However, it also includes any heap fragments that are attached to the heap. All of the heap fragments are considered to be above the high-watermark and part of the young generation. Heap fragments contain terms that either did not fit on the heap, or were created by another process and then attached to the heap. For instance if the bif &lt;code&gt;binary_to_term/1&lt;/code&gt; created a term which does not fit on the current heap without doing a garbage collection, it will create a heap-fragment for the term and then schedule a garbage collection for later. Also if a message is sent to the process, the payload may be placed in a heap-fragment and that fragment is added to young heap when the message is matched in a receive clause.</source>
          <target state="translated">젊은 힙 또는 할당 힙은 개요에 설명 된대로 스택과 힙으로 구성됩니다. 그러나 힙에 연결된 모든 힙 조각도 포함됩니다. 모든 힙 조각은 고수위 이상이며 젊은 세대의 일부로 간주됩니다. 힙 조각에는 힙에 맞지 않거나 다른 프로세스에서 만든 다음 힙에 연결된 용어가 포함됩니다. 예를 들어 bif &lt;code&gt;binary_to_term/1&lt;/code&gt; 이 가비지 컬렉션을 수행하지 않고 현재 힙에 맞지 않는 용어를 만든 경우 해당 용어에 대한 힙 조각을 만든 다음 나중에 가비지 컬렉션을 예약합니다. 또한 메시지가 프로세스로 전송되는 경우 페이로드는 힙 조각에 배치 될 수 있으며 해당 조각은 메시지가 수신 절에서 일치 할 때 젊은 힙에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a5d4ec5e9af18ded993eb6992af6fcaadb42e4" translate="yes" xml:space="preserve">
          <source>The zip module supports zip archive versions up to 6.1. However, password-protection and Zip64 are not supported.</source>
          <target state="translated">zip 모듈은 최대 6.1의 zip 아카이브 버전을 지원합니다. 그러나 비밀번호 보호 및 Zip64는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f89ec6f488689cc3f3700cb5183e203d59254205" translate="yes" xml:space="preserve">
          <source>The | operator can also be used to add a head to a list:</source>
          <target state="translated">| 연산자를 사용하여 목록에 헤드를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="40fe3907425ba07df22ef0d6959c2d137d54e469" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;m1&lt;/code&gt; is cover compiled in test run &lt;code&gt;s2&lt;/code&gt;, but not shown in the coverage log. Instead, if &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; is called after both &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; test runs are completed, the accumulated result for &lt;code&gt;m1&lt;/code&gt; is available in the cross cover log for test run &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;m1&lt;/code&gt; 은 테스트 실행 &lt;code&gt;s2&lt;/code&gt; 에서 커버 컴파일 되지만 커버리지 로그에는 표시되지 않습니다. 대신 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 테스트 실행이 완료된 후 &lt;code&gt;&lt;a href=&quot;ct_cover#cross_cover_analyse-2&quot;&gt;ct_cover:cross_cover_analyse/2&lt;/a&gt;&lt;/code&gt; 가 호출 되면 &lt;code&gt;m1&lt;/code&gt; 에 대한 누적 결과 는 테스트 실행 &lt;code&gt;s1&lt;/code&gt; 의 교차 커버 로그에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="a8047a09730147dedb7e9d78a5e192ccf03ab6c4" translate="yes" xml:space="preserve">
          <source>Then go to the cross host system and setup the erlang installed in (4) or (5) to be in your &lt;code&gt;$PATH&lt;/code&gt;. Then go to what previously was &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; and issue the following command.</source>
          <target state="translated">그런 다음 교차 호스트 시스템으로 이동하여 (4) 또는 (5)에 설치된 erlang을 &lt;code&gt;$PATH&lt;/code&gt; 에 설정하십시오 . 그런 다음 이전에 &lt;code&gt;$ERL_TOP/release/tests/test_server&lt;/code&gt; 하여 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d8c63d4c24a80d8a897066cde6b4458486a7ca80" translate="yes" xml:space="preserve">
          <source>Then one column per state is printed with a the percentage of time this thread spent in the state out of it's own real-time. After the thread specific time, the accumulated time for each type of thread is printed in a similar format.</source>
          <target state="translated">그런 다음 상태 당 하나의 열이이 스레드가 자체적으로 실시간 상태에서 소비 한 시간의 백분율로 인쇄됩니다. 스레드 특정 시간이 지나면 각 스레드 유형에 대한 누적 시간이 유사한 형식으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="58043576d5fe13fa1a246436e2e8c6ef745d143f" translate="yes" xml:space="preserve">
          <source>Then proceed as follows:</source>
          <target state="translated">그런 다음 다음과 같이 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="7d9412fbd0462825f974f875c15e384433c2ca1a" translate="yes" xml:space="preserve">
          <source>Then read the trace file and create the raw profile data with &lt;code&gt;fprof:profile()&lt;/code&gt;, or perhaps &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; for non-default filename.</source>
          <target state="translated">그런 다음 추적 파일을 읽고 기본 파일 이름이 아닌 경우 &lt;code&gt;fprof:profile()&lt;/code&gt; 또는 &lt;code&gt;fprof:profile(file, &quot;my_fprof.trace&quot;)&lt;/code&gt; 를 사용하여 원시 프로파일 데이터를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5663aeb9e710685d724afdba3fc67379b487af35" translate="yes" xml:space="preserve">
          <source>Then the compact text version without indentation and with short keywords:</source>
          <target state="translated">그런 다음 들여 쓰기가없고 간단한 키워드가 포함 된 간결한 텍스트 버전 :</target>
        </trans-unit>
        <trans-unit id="139ac9c79449e95e5f9e070852b997046b48832a" translate="yes" xml:space="preserve">
          <source>Then the compact version without indentation and with short keywords:</source>
          <target state="translated">그런 다음 들여 쓰기가없고 키워드가 짧은 컴팩트 버전 :</target>
        </trans-unit>
        <trans-unit id="b190b45bdf5a8e168cb79c9debb9d2ba24df930e" translate="yes" xml:space="preserve">
          <source>Then the listing of the atoms comes, starting with 10 and 5 which are the atom refs of the already cached atoms. Then the new atoms are sent.</source>
          <target state="translated">그런 다음 이미 캐시 된 원자의 원자 참조 인 10과 5로 시작하는 원자 목록이 표시됩니다. 그런 다음 새로운 원자가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="641d01dad066a8551404d7310477baa1cb6f8772" translate="yes" xml:space="preserve">
          <source>Then the new event handler &lt;code&gt;Handler2&lt;/code&gt; is added and initiated by calling &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Module2&lt;/code&gt; is the callback module of &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module1:terminate/2&lt;/code&gt;. This makes it possible to transfer information from &lt;code&gt;Handler1&lt;/code&gt; to &lt;code&gt;Handler2&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; 을 호출 하여 새 이벤트 핸들러 &lt;code&gt;Handler2&lt;/code&gt; 를 추가하고 시작합니다 . 여기서 &lt;code&gt;Module2&lt;/code&gt; 는 &lt;code&gt;Handler2&lt;/code&gt; 의 콜백 모듈 이고 &lt;code&gt;Term&lt;/code&gt; 은 &lt;code&gt;Module1:terminate/2&lt;/code&gt; 의 리턴 값입니다 . 이로써에서 정보를 전송 할 수 &lt;code&gt;Handler1&lt;/code&gt; 에 &lt;code&gt;Handler2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c562a001db2c4ae28ac1742e8925ddf8af7163" translate="yes" xml:space="preserve">
          <source>Then the sublists are sorted and the results are combined.</source>
          <target state="translated">그런 다음 하위 목록이 정렬되고 결과가 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="73b24c998d871947414c80ba0ded68c358316e6c" translate="yes" xml:space="preserve">
          <source>Then we continue with the call flow on the destination side:</source>
          <target state="translated">그런 다음 대상 측의 통화 흐름을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="57e50fb97a5f7d14f675710dd9c64d82897d7f75" translate="yes" xml:space="preserve">
          <source>Then we have the updates to the atom cache:</source>
          <target state="translated">그런 다음 아톰 캐시에 대한 업데이트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5acd2104208de4c3faf2546e133d8d457c2a417" translate="yes" xml:space="preserve">
          <source>Then you can add your favorite application my_app to the new PLT:</source>
          <target state="translated">그런 다음 좋아하는 응용 프로그램 my_app를 새 PLT에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31669bbfe7c81803e33f753695ac857feb8b190" translate="yes" xml:space="preserve">
          <source>Then you can proceed as follows:</source>
          <target state="translated">그런 다음 다음과 같이 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78475e203a352f84ea57f7b84f34d9e978f720ec" translate="yes" xml:space="preserve">
          <source>Then you can run it through the export_simple/2 function:</source>
          <target state="translated">그런 다음 export_simple / 2 함수를 통해 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e9e10c047b34e0b14a433931956d6784d8af0a2" translate="yes" xml:space="preserve">
          <source>Then you send events to the &lt;code&gt;Collector&lt;/code&gt; with the function &lt;code&gt;et_collector:report_event/6&lt;/code&gt; like this:</source>
          <target state="translated">그런 다음 &lt;code&gt;et_collector:report_event/6&lt;/code&gt; 함수 를 사용하여 &lt;code&gt;Collector&lt;/code&gt; 이벤트를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="84181b0c3516063c275e5c08beaa5fc4213cccf5" translate="yes" xml:space="preserve">
          <source>Then, add a new handler which prints to file. You can use the handler module &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, and configure it to log to file:</source>
          <target state="translated">그런 다음 파일로 인쇄하는 새 핸들러를 추가하십시오. 핸들러 모듈 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 를 사용하고 파일에 기록하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ec0c3065e7c7e83edd0f5ba55760ca9ae6826d" translate="yes" xml:space="preserve">
          <source>Then, add a new handler which prints to file. You can use the handler module &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, and specify type &lt;code&gt;{file,File}&lt;/code&gt;.:</source>
          <target state="translated">그런 다음 파일로 인쇄하는 새 핸들러를 추가하십시오. 핸들러 모듈 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 를 사용하고 &lt;code&gt;{file,File}&lt;/code&gt; 유형을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff57f64121d7cfa622102225ba9e153cee5fdd8" translate="yes" xml:space="preserve">
          <source>Then, all loaded modules are listed. The following fields exist:</source>
          <target state="translated">그런 다음로드 된 모든 모듈이 나열됩니다. 다음과 같은 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37285406a539aba18b235f1780c7ea66141aed2d" translate="yes" xml:space="preserve">
          <source>Then, an &lt;strong&gt;application specification&lt;/strong&gt; is needed, which is put in an &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt;. Among other things, this file specifies which modules the application consists of and the name of the callback module.</source>
          <target state="translated">그런 다음 &lt;strong&gt;응용 프로그램 스펙&lt;/strong&gt; 이 필요하며 이는 &lt;code&gt;&lt;a href=&quot;#appl_res_file&quot;&gt;application resource file&lt;/a&gt;&lt;/code&gt; 있습니다. 무엇보다도이 파일은 애플리케이션이 구성하는 모듈과 콜백 모듈의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6b038b9a866b08fa7aa12d5de74309b996761d25" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;strong&gt;system event&lt;/strong&gt; to be logged or traced, the following function is to be called.</source>
          <target state="translated">그런 다음 각 &lt;strong&gt;시스템 이벤트&lt;/strong&gt; 가 기록되거나 추적 될 때마다 다음 기능이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b2b275200d1a22a2d00f625e244ca1c19bb04f51" translate="yes" xml:space="preserve">
          <source>Then, for the primary application and each included application in top-down, left-to-right order, the application master calls &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; for each phase defined for the primary application, in that order. If a phase is not defined for an included application, the function is not called for this phase and application.</source>
          <target state="translated">그런 다음 기본 애플리케이션과 포함 된 각 애플리케이션을 위에서 아래로, 왼쪽에서 오른쪽 순서로 애플리케이션 마스터 는 기본 애플리케이션에 대해 정의 된 각 단계에 대해 &lt;code&gt;Module:start_phase(Phase, Type, PhaseArgs)&lt;/code&gt; 를 해당 순서대로 호출합니다 . 포함 된 애플리케이션에 대해 단계가 정의되지 않은 경우이 단계 및 애플리케이션에 대해 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bce82c8d0395aa60449fa59c5a8cfb50a252f9b" translate="yes" xml:space="preserve">
          <source>Then, you can use the &lt;code&gt;?Q(Text)&lt;/code&gt; macros in your code to create ASTs or match on existing ASTs. For example:</source>
          <target state="translated">그런 다음 코드에서 &lt;code&gt;?Q(Text)&lt;/code&gt; 매크로를 사용하여 AST를 만들거나 기존 AST에서 일치시킬 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="54025678c0a48ad36d078ae7c486444ea8302d6e" translate="yes" xml:space="preserve">
          <source>There are 146097 days in a 400 year period.</source>
          <target state="translated">400 년 동안 146097 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4922e83fd8840f5a8507bbf756cb975adb85c4c4" translate="yes" xml:space="preserve">
          <source>There are 1461 days in a 4 year period.</source>
          <target state="translated">4 년 동안 1461 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a006b5eea15a1aff01c844f4450c0802ffc7c5a3" translate="yes" xml:space="preserve">
          <source>There are 3 categories of events: &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;internal&lt;/code&gt;.</source>
          <target state="translated">이벤트 범주에는 &lt;code&gt;&lt;a href=&quot;#type-external_event_type&quot;&gt;external&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-timeout_event_type&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;internal&lt;/code&gt; 세 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e61c510a0f262f537c452aa189ebaa55b2635db" translate="yes" xml:space="preserve">
          <source>There are 3 types of time-out events that the state machine can generate for itself with the corresponding &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">상태 머신이 해당 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt; 사용하여 자체적으로 생성 할 수있는 세 가지 유형의 타임 아웃 이벤트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ff16aed8586d53e007c3bcd2bdd6ec77fd89ba9" translate="yes" xml:space="preserve">
          <source>There are 3 types of time-outs in &lt;code&gt;gen_statem&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 에는 3 가지 유형의 시간 제한이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2631fe7788bb799ec0d53ee0b2da8319a05517e4" translate="yes" xml:space="preserve">
          <source>There are 3 types of timeout events that the state machine can generate for itself with the corresponding &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">상태 머신이 해당 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt;timeout_action()&lt;/a&gt;&lt;/code&gt; 사용하여 자체적으로 생성 할 수있는 3 가지 유형의 시간 초과 이벤트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32e2588a4d8a20d2c12320bd314f5979f4fc80b1" translate="yes" xml:space="preserve">
          <source>There are 365 days in an ordinary year.</source>
          <target state="translated">보통 연중 365 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d970b2470b79eb6a87c891f0b7f5a8f224ef200c" translate="yes" xml:space="preserve">
          <source>There are 36524 days in a 100 year period.</source>
          <target state="translated">100 년 동안 36524 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3485b6c23bf0750711aa938792fc3cb9795cf2" translate="yes" xml:space="preserve">
          <source>There are 366 days in a leap year.</source>
          <target state="translated">윤년에는 366 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fe64c83f46614adbd1fbe2801f7f2ef313c16d" translate="yes" xml:space="preserve">
          <source>There are 719528 days between Jan 1, 0 and Jan 1, 1970.</source>
          <target state="translated">1970 년 1 월 1 일과 1 월 1 일 사이에는 719528 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35333b685e5533111f684a33ff4796d2d156cad" translate="yes" xml:space="preserve">
          <source>There are 86400 seconds in a day.</source>
          <target state="translated">하루에 86400 초가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc84f53d33e39866ff05a650b846f5a9e42e844" translate="yes" xml:space="preserve">
          <source>There are a bunch of different tradeoffs that come into play when trying to figure out which of the strategies you want to use.</source>
          <target state="translated">어떤 전략을 사용하고 싶은지 알아 내려고 할 때 작용하는 다양한 트레이드 오프가 있습니다.</target>
        </trans-unit>
        <trans-unit id="180512e757bce690ec3e5179e5aff8954ea8a216" translate="yes" xml:space="preserve">
          <source>There are a few other shells available, but in all examples below we assume that you use bash.</source>
          <target state="translated">사용 가능한 다른 쉘이 몇 가지 있지만 아래의 모든 예제에서 bash를 사용한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1edf8f04e2a157900339e6be967c14131457929f" translate="yes" xml:space="preserve">
          <source>There are a number of BIFs for type conversions.</source>
          <target state="translated">유형 변환을위한 여러 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="242b6cdf7d5bf2f5010f113ba9575096eca5ab25" translate="yes" xml:space="preserve">
          <source>There are a number of configuration parameter's that control the operation of the transaction sender. In principle, a message with everything stored (ack's and request's) is sent from the process when:</source>
          <target state="translated">트랜잭션 송신자의 조작을 제어하는 ​​여러 구성 매개 변수가 있습니다. 원칙적으로 다음과 같은 경우에 저장된 모든 내용 (ack 및 요청)이 포함 된 메시지가 프로세스에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="14ebd1b2612f7ab9a04862c2c58993cbe8294ef0" translate="yes" xml:space="preserve">
          <source>There are also Erlang plugins for other code editors &lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim (vim-erlang)&lt;/a&gt; , &lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt; Atom &lt;/a&gt; , &lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse (ErlIDE)&lt;/a&gt; and &lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">다른 코드 편집기 &lt;a href=&quot;http://github.com/vim-erlang&quot;&gt;Vim (vim-erlang)&lt;/a&gt; , &lt;a href=&quot;http://atom.io/packages/language-erlang&quot;&gt;Atom&lt;/a&gt; , &lt;a href=&quot;http://erlide.org/index.html&quot;&gt;Eclipse (ErlIDE)&lt;/a&gt; 및 &lt;a href=&quot;http://ignatov.github.io/intellij-erlang/&quot;&gt;IntelliJ IDEA&lt;/a&gt; 용 Erlang 플러그인도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ab85aacb25c2dac1de9193bd4c1c96c59434beb" translate="yes" xml:space="preserve">
          <source>There are also buttons to clear the contents of each window.</source>
          <target state="translated">각 창의 내용을 지우는 버튼도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e9837f18730715ec49993436d5ae3ed6b58962" translate="yes" xml:space="preserve">
          <source>There are also corresponding trace client types that can read the Erlang trace data format from such files or ports. The &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; function makes use of these Erlang trace clients and redirects the trace data to the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">해당 파일 또는 포트에서 Erlang 추적 데이터 형식을 읽을 수있는 해당 추적 클라이언트 유형도 있습니다. &lt;code&gt;et_collector:start_trace_client/3&lt;/code&gt; 기능이 얼랑 추적 클라이언트를 사용한다과에 추적 데이터 리디렉션 &lt;code&gt;Collector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c99ca7c6f5a9145961cb429767668ca00d8aa464" translate="yes" xml:space="preserve">
          <source>There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with &lt;code&gt;ei_x&lt;/code&gt; use a dynamic buffer.</source>
          <target state="translated">동적 버퍼를 사용하는 인코딩 함수도 있습니다. 이것들을 사용하여 데이터를 인코딩하는 것이 더 편리합니다. 모든 인코딩 기능은 두 가지 버전으로 제공됩니다. &lt;code&gt;ei_x&lt;/code&gt; 로 시작 하는 것은 동적 버퍼를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9d5093112a2fcba39a0f2eed1157356fdbc134d" translate="yes" xml:space="preserve">
          <source>There are also encode functions that use a dynamic buffer. It is often more convenient to use these to encode data. All encode functions comes in two versions; those starting with &lt;code&gt;ei_x_&lt;/code&gt; use a dynamic buffer of type &lt;code&gt;&lt;a href=&quot;#ei_x_buff&quot;&gt;ei_x_buff&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동적 버퍼를 사용하는 인코딩 함수도 있습니다. 이를 사용하여 데이터를 인코딩하는 것이 더 편리한 경우가 많습니다. 모든 인코딩 기능은 두 가지 버전으로 제공됩니다. 시작으로 그 &lt;code&gt;ei_x_&lt;/code&gt; 이 타입의 동적 버퍼 사용 &lt;code&gt;&lt;a href=&quot;#ei_x_buff&quot;&gt;ei_x_buff&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7c973e8a6ad46963c3452623094e6dbd1de252e5" translate="yes" xml:space="preserve">
          <source>There are also existing functions in the API that reads from various sources and calls &lt;code&gt;et_collector:report/2&lt;/code&gt;:</source>
          <target state="translated">API에는 다양한 소스에서 읽고 &lt;code&gt;et_collector:report/2&lt;/code&gt; 를 호출하는 기존 함수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b0b6ca2d317b12bcab295cfefa25fba1f494f42" translate="yes" xml:space="preserve">
          <source>There are also several open source tools outside of Erlang/OTP that can be used to help profiling. Some of them are:</source>
          <target state="translated">Erlang / OTP 외부에는 프로파일 링을 돕는 데 사용할 수있는 몇 가지 오픈 소스 도구가 있습니다. 그들 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="142cde2c5e7c063e8b6e633dcb4d8f992d4a63a0" translate="yes" xml:space="preserve">
          <source>There are also some tools that can be used to get a view of the whole system with more or less overhead.</source>
          <target state="translated">오버 헤드가 더 많거나 적은 전체 시스템을 볼 수있는 도구도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d345e5c9462888e4d0e72da3171fd099f28666f6" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;snmp_pdus&quot;&gt;snmp_pdus&lt;/a&gt;&lt;/code&gt; 모듈에는 SNMP 메시지의 인코딩 및 디코딩에 유용한 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2c12c548107750b36f7254260f1588ab2784f00" translate="yes" xml:space="preserve">
          <source>There are also some useful functions for encoding and decoding of SNMP messages in the module &lt;code&gt;snmp_pdus&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;snmp_pdus&lt;/code&gt; 모듈에는 SNMP 메시지의 인코딩 및 디코딩에 유용한 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4b5b08a6ea2fb2b0f10fe9a664d0767cb557d8" translate="yes" xml:space="preserve">
          <source>There are also two optional functions that may be exported:</source>
          <target state="translated">내보낼 수있는 두 가지 선택적 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02924d8e6964e4587d120c6a611e73172eec6d8f" translate="yes" xml:space="preserve">
          <source>There are also unary set operators:</source>
          <target state="translated">단항 집합 연산자도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3acf11feebdd585e34d9bb7c8762ccd18c3ff0dc" translate="yes" xml:space="preserve">
          <source>There are any number of &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-Outs&lt;/a&gt;&lt;/code&gt; differing by their &lt;code&gt;Name&lt;/code&gt;. They have no automatic cancelling.</source>
          <target state="translated">임의의 수 있습니다 &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-Outs&lt;/a&gt;&lt;/code&gt; 자신에 의해 다른 &lt;code&gt;Name&lt;/code&gt; . 자동 취소 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="18a4256a63577ca8fbaba2b8f665cf1ca462e6b4" translate="yes" xml:space="preserve">
          <source>There are basically two reasons for using more than one table replica: fault tolerance and speed. Notice that table replication provides a solution to both of these system requirements.</source>
          <target state="translated">기본적으로 둘 이상의 테이블 복제본을 사용하는 이유는 내결함성과 속도입니다. 테이블 복제는이 두 시스템 요구 사항 모두에 대한 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="efcb011fbe2418732f8e84878ff0611edcbe6375" translate="yes" xml:space="preserve">
          <source>There are basically two ways to avoid copying a binary that is sent to a driver:</source>
          <target state="translated">드라이버로 전송되는 바이너리를 복사하지 않으려면 기본적으로 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f19d4715aab222132c414bca72739542361f550" translate="yes" xml:space="preserve">
          <source>There are cryptographic limits on the amount of plaintext which can be safely encrypted under a given set of keys. If the amount of data surpasses those limits, a key update is triggered and a new set of keys are installed. See also the option &lt;code&gt;key_update_at&lt;/code&gt;.</source>
          <target state="translated">주어진 키 세트에서 안전하게 암호화 할 수있는 일반 텍스트의 양에는 암호화 제한이 있습니다. 데이터 양이 이러한 제한을 초과하면 키 업데이트가 트리거되고 새로운 키 세트가 설치됩니다. &lt;code&gt;key_update_at&lt;/code&gt; 옵션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34bb0f988efea166c1a1ee7437789e3a88d3fdd7" translate="yes" xml:space="preserve">
          <source>There are cryptographic limits on the amount of plaintext which can be safely encrypted under a given set of keys. The current default ensures that data integrity will not be breached with probability greater than 1/2^57. For more information see &lt;code&gt;&lt;a href=&quot;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&quot;&gt;Limits on Authenticated Encryption Use in TLS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 키 세트에서 안전하게 암호화 할 수있는 일반 텍스트의 양에는 암호화 제한이 있습니다. 현재 기본값은 1 / 2 ^ 57보다 큰 확률로 데이터 무결성이 침해되지 않도록합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&quot;&gt;Limits on Authenticated Encryption Use in TLS&lt;/a&gt;&lt;/code&gt; 대한 제한을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="427d1b12162110ab82e9ecb95a1e779c90521928" translate="yes" xml:space="preserve">
          <source>There are different ways to run the mstone1 tool, e.g. with or without the use of drivers, with &lt;strong&gt;only&lt;/strong&gt; flex-empowered configs.</source>
          <target state="translated">flex- powerpowered 구성 &lt;strong&gt;만으로&lt;/strong&gt; 드라이버를 사용하거나 사용하지 않고 mstone1 도구를 실행하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d082ef660d4f3ab42a161139d41ebc8c9796aa24" translate="yes" xml:space="preserve">
          <source>There are different ways to traverse through the objects of a table.</source>
          <target state="translated">테이블의 개체를 탐색하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb3a2985df3c8dbb9f72f40ce1f7662ef09722ea" translate="yes" xml:space="preserve">
          <source>There are directives to classify specific instructions depending on how frequently used they are:</source>
          <target state="translated">사용 빈도에 따라 특정 지침을 분류하는 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83886161e156439b88f864a15f0682e914bef032" translate="yes" xml:space="preserve">
          <source>There are errors in the module.</source>
          <target state="translated">모듈에 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f2059c62b05489c060b2ff7738b1e0f09fb659b" translate="yes" xml:space="preserve">
          <source>There are five capturing substrings, but only one is ever set after a match. (An alternative way of solving this problem is to use a &quot;branch reset&quot; subpattern, as described in the previous section.)</source>
          <target state="translated">5 개의 캡처 하위 문자열이 있지만 일치 후에는 하나만 설정됩니다. (이 문제를 해결하는 다른 방법은 이전 섹션에서 설명한대로 &quot;분기 재설정&quot;하위 패턴을 사용하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="33595bb67b93a0d4d29156619db2bde17172f1a9" translate="yes" xml:space="preserve">
          <source>There are five kinds of atomic literals, which are represented in the same way in patterns, expressions, and guards:</source>
          <target state="translated">5 가지 종류의 원자 리터럴이 있으며, 패턴, 표현 및 가드로 같은 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="51d0a41716062d2a82d15d8d350dc23a6b9ec6b3" translate="yes" xml:space="preserve">
          <source>There are five lists exchanged in the connection setup. Three of them are also divided in two directions, to and from the server.</source>
          <target state="translated">연결 설정에서 교환 된 5 개의 목록이 있습니다. 이들 중 3 개는 서버와의 양방향으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="cf8e92c428bfd92f9fbf9d5334e7e6eb53e744e5" translate="yes" xml:space="preserve">
          <source>There are five other standard MIBs, which also may be loaded into the agent. These MIBs are:</source>
          <target state="translated">에이전트에로드 될 수있는 5 개의 다른 표준 MIB가 있습니다. 이러한 MIB는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="152329e6587feacf4160245f8023f9e4b43d1b9a" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the &lt;code&gt;Application dependencies&lt;/code&gt; page. If the application is used by other applications, these are listed under &lt;code&gt;Used by&lt;/code&gt;. If the application requires other applications be started before it can be started, these are listed under &lt;code&gt;Required&lt;/code&gt;. These applications are listed in the &lt;code&gt;applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application includes other applications, these are listed under &lt;code&gt;Included&lt;/code&gt;. These applications are listed in the &lt;code&gt;included_applications&lt;/code&gt; part of the &lt;code&gt;app&lt;/code&gt; file. If the application uses other applications, these are listed under &lt;code&gt;Uses&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Application dependencies&lt;/code&gt; 페이지 에는 네 가지 범주의 응용 프로그램이 있습니다 . 다른 응용 프로그램에서 응용 프로그램을 사용하는 경우 다음에 의해 &lt;code&gt;Used by&lt;/code&gt; 아래에 나열 됩니다 . 응용 프로그램을 시작하기 전에 다른 응용 프로그램을 시작해야하는 경우 &lt;code&gt;Required&lt;/code&gt; 아래에 나열됩니다 . 이러한 응용 프로그램은 &lt;code&gt;applications&lt;/code&gt; &lt;code&gt;app&lt;/code&gt; 파일 의 응용 프로그램 부분에 나열되어 있습니다. 응용 프로그램에 다른 응용 프로그램이 포함 된 경우 해당 응용 프로그램이 &lt;code&gt;Included&lt;/code&gt; 아래에 나열됩니다 . 이러한 응용 프로그램은 응용 &lt;code&gt;app&lt;/code&gt; 파일 의 &lt;code&gt;included_applications&lt;/code&gt; 부분에 나열되어 있습니다. 응용 프로그램이 다른 응용 프로그램을 사용하는 경우, 다음은 아래에 나열됩니다 &lt;code&gt;Uses&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d82c54f7bd20fbaa9331c2a4418fb92d7a4c19" translate="yes" xml:space="preserve">
          <source>There are four categories of applications on the applications page. &lt;code&gt;Included&lt;/code&gt; contains applications that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains applications that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains applications that either are used directly by explicitly included applications or by other derived applications. &lt;code&gt;Available&lt;/code&gt; contains the remaining applications.</source>
          <target state="translated">응용 프로그램 페이지에는 4 가지 범주의 응용 프로그램이 있습니다. &lt;code&gt;Included&lt;/code&gt; 에는 명시 적으로 포함 된 응용 프로그램이 포함됩니다. &lt;code&gt;Excluded&lt;/code&gt; 에는 명시 적으로 제외 된 응용 프로그램이 포함되어 있습니다. &lt;code&gt;Derived&lt;/code&gt; 에는 명시 적으로 포함 된 응용 프로그램이나 다른 파생 된 응용 프로그램에서 직접 사용하는 응용 프로그램이 포함됩니다. &lt;code&gt;Available&lt;/code&gt; 나머지 응용 프로그램이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b68efc29dbc075cb27e8313dd48ca56abcbcbd47" translate="yes" xml:space="preserve">
          <source>There are four categories of modules on the modules page. &lt;code&gt;Included&lt;/code&gt; contains modules that are explicitly included. &lt;code&gt;Excluded&lt;/code&gt; contains modules that are explicitly excluded. &lt;code&gt;Derived&lt;/code&gt; contains modules that either are used directly by explicitly included modules or by other derived modules. &lt;code&gt;Available&lt;/code&gt; contains the remaining modules.</source>
          <target state="translated">모듈 페이지에는 네 가지 범주의 모듈이 있습니다. &lt;code&gt;Included&lt;/code&gt; 에는 명시 적으로 포함 된 모듈이 포함됩니다. &lt;code&gt;Excluded&lt;/code&gt; 에는 명시 적으로 제외 된 모듈이 포함되어 있습니다. &lt;code&gt;Derived&lt;/code&gt; 에는 명시 적으로 포함 된 모듈이나 다른 파생 모듈에서 직접 사용되는 모듈이 포함됩니다. &lt;code&gt;Available&lt;/code&gt; 나머지 모듈이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2b0337aead7f70c27290d4535794d260d389da6" translate="yes" xml:space="preserve">
          <source>There are four different encodings present during the handling of URIs:</source>
          <target state="translated">URI를 처리하는 동안 다음과 같은 네 가지 인코딩이 있습니다.</target>
        </trans-unit>
        <trans-unit id="413ab333b189c985048445074e9603bae2ba9723" translate="yes" xml:space="preserve">
          <source>There are four kinds of condition: references to subpatterns, references to recursion, a pseudo-condition called DEFINE, and assertions.</source>
          <target state="translated">하위 패턴에 대한 참조, 재귀에 대한 참조, DEFINE이라는 의사 조건 및 어설 션의 네 가지 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3cede13e2f3ea6f18d8aafca7fbdcb89de6d8f" translate="yes" xml:space="preserve">
          <source>There are four rounds of waiting for thread progress in the above sequence. In the code loading sequence we sacrificed memory overhead of three generations to avoid a second round of thread progress. The latency of &lt;code&gt;trace_pattern&lt;/code&gt; should not be such a big problem for however, as it is normally not called in a rapid sequence.</source>
          <target state="translated">위의 순서에서 스레드 진행을 기다리는 네 라운드가 있습니다. 코드 로딩 시퀀스에서 우리는 두 번째 스레드 진행을 피하기 위해 3 세대의 메모리 오버 헤드를 희생했습니다. 그러나 &lt;code&gt;trace_pattern&lt;/code&gt; 의 지연 시간 은 일반적으로 빠른 순서로 호출되지 않으므로 큰 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ff7d1dc7b48a9dea55fd34247a8586111ade0080" translate="yes" xml:space="preserve">
          <source>There are from OTP-23.0 two main ways to set an option:</source>
          <target state="translated">OTP-23.0에서 옵션을 설정하는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afecc58bc3779a5734aaac232e18d7916a22144d" translate="yes" xml:space="preserve">
          <source>There are function clauses, if clauses, case clauses, and catch clauses.</source>
          <target state="translated">함수 절, if 절, case 절 및 catch 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72251a5ed304e5df93ccf96c6a4cfa369e458578" translate="yes" xml:space="preserve">
          <source>There are however attacks that are not detected by those checks. Suppose a bad guy has succeded with a DNS infection. Then the client could belive it is connecting to one host but ends up at another but evil one. Though it is evil, it could have a perfectly legal certificate! The certificate has a valid signature, it is not revoked, the certificate chain is not faked and has a trusted root and so on.</source>
          <target state="translated">그러나 해당 검사에서 탐지되지 않은 공격이 있습니다. 나쁜 사람이 DNS 감염에 성공했다고 가정 해 봅시다. 그러면 클라이언트는 한 호스트에 연결되어 있지만 다른 호스트에 연결되지만 악의적 인 호스트가 될 수 있습니다. 사악하지만 완벽하게 법적인 증명서를 가질 수 있습니다! 인증서에 유효한 서명이 있고 해지되지 않았으며 인증서 체인이 위조되지 않았으며 신뢰할 수있는 루트 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3713f84d148979b203b3befe641b4b77769eb559" translate="yes" xml:space="preserve">
          <source>There are limitations to when you can execute time warp unsafe code using this mode. If it is possible to use time warp safe code only, it is &lt;strong&gt;much&lt;/strong&gt; better to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 모드를 사용하여 안전하지 않은 타임 워프 코드를 실행할 수있는 시점에는 제한이 있습니다. 그것은 단지 시간 워프 안전 코드를 사용할 수 있습니다 경우는 &lt;strong&gt;많이&lt;/strong&gt; 사용하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="cd4bd83b271a665a5b58936e70ef38dadf1155ad" translate="yes" xml:space="preserve">
          <source>There are limitations with this transaction mechanism. If complex dependencies exist between variables, for example between &lt;code&gt;month&lt;/code&gt; and &lt;code&gt;day&lt;/code&gt;, another mechanism is needed. Setting the date to 'Feb 31' can be avoided by a somewhat more generic transaction mechanism. You can continue and find more and more complex situations and construct an N-phase set-mechanism. This toolkit only contains a trivial mechanism.</source>
          <target state="translated">이 트랜잭션 메커니즘에는 제한이 있습니다. 변수간에 복잡한 종속성이 존재하는 경우 (예 : &lt;code&gt;month&lt;/code&gt; 와 &lt;code&gt;day&lt;/code&gt; 사이에 ) 다른 메커니즘이 필요합니다. 좀 더 일반적인 트랜잭션 메커니즘으로 날짜를 '2 월 31 일'로 설정하지 않아도됩니다. 점점 더 복잡한 상황을 계속 찾아서 N- 상 설정 메커니즘을 구성 할 수 있습니다. 이 툴킷에는 간단한 메커니즘 만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="439879eaa90ceaba58052efe3928a2c96e71eaa0" translate="yes" xml:space="preserve">
          <source>There are many different ways of writing back references to named subpatterns. The .NET syntax &lt;code&gt;\k{name}&lt;/code&gt; and the Perl syntax &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt; are supported, as is the Python syntax &lt;code&gt;(?P=name)&lt;/code&gt;. The unified back reference syntax in Perl 5.10, in which \g can be used for both numeric and named references, is also supported. The previous example can be rewritten in the following ways:</source>
          <target state="translated">명명 된 하위 패턴에 대한 참조를 다시 쓰는 방법에는 여러 가지가 있습니다. Python 구문 &lt;code&gt;(?P=name)&lt;/code&gt; 과 같이 .NET 구문 &lt;code&gt;\k{name}&lt;/code&gt; 및 Perl 구문 &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'name'&lt;/code&gt; 이 지원됩니다 . 숫자 및 명명 된 참조 모두에 \ g를 사용할 수있는 Perl 5.10의 통합 된 역 참조 구문도 지원됩니다. 이전 예제는 다음과 같은 방식으로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed05625b139b4d644de6d7f67ce1fa7c2638ef57" translate="yes" xml:space="preserve">
          <source>There are many kinds of test suites. Some concentrate on calling every function or command (in the documented way) in a certain interface. Some others do the same, but use all kinds of illegal parameters, and verify that the server stays alive and rejects the requests with reasonable error codes. Some test suites simulate an application (typically consisting of a few modules of an application), some try to do tricky requests in general, and some test suites even test internal functions with help of special Load Modules on target.</source>
          <target state="translated">많은 종류의 테스트 스위트가 있습니다. 어떤 사람들은 특정 인터페이스에서 모든 기능이나 명령을 (문서화 된 방식으로) 호출하는데 집중합니다. 다른 일부는 동일하지만 모든 종류의 잘못된 매개 변수를 사용하고 서버가 활성 상태를 유지하고 합리적인 오류 코드로 요청을 거부하는지 확인합니다. 일부 테스트 스위트는 애플리케이션 (일반적으로 애플리케이션의 일부 모듈로 구성됨)을 시뮬레이션하고, 일부는 일반적으로 까다로운 요청을 시도하며, 일부 테스트 스위트는 대상의 특수로드 모듈을 사용하여 내부 기능을 테스트하기까지합니다.</target>
        </trans-unit>
        <trans-unit id="7c87c0f774843afd2689dfb3a9a1edad461eb107" translate="yes" xml:space="preserve">
          <source>There are many other BIFs such as &lt;code&gt;trunc&lt;/code&gt;. Only a few BIFs can be used in guards, and you cannot use functions you have defined yourself in guards. (see &lt;code&gt;Guard Sequences&lt;/code&gt;) (For advanced readers: This is to ensure that guards do not have side effects.) Let us play with a few of these functions in the shell:</source>
          <target state="translated">&lt;code&gt;trunc&lt;/code&gt; 와 같은 다른 많은 BIF가 있습니다 . 가드에는 소수의 BIF 만 사용할 수 있으며 가드에서 자신이 정의한 기능은 사용할 수 없습니다. ( &lt;code&gt;Guard Sequences&lt;/code&gt; 참조 ) (고급 독자의 경우 : 가드에 부작용이 없도록하기위한 것입니다.) 쉘에서 다음 기능 중 몇 가지를 가지고 놀도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7ad50dd0c2f864512dffbc3444e8c2dbdeaa7fbe" translate="yes" xml:space="preserve">
          <source>There are many very useful functions in the &lt;code&gt;lists&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;lists&lt;/code&gt; 모듈 에는 매우 유용한 기능이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebf4e0ad405ef3fed32697182bdabfe322f69cbb" translate="yes" xml:space="preserve">
          <source>There are more efficient ways to create tables manually, i.e. to use the module &lt;code&gt;snmp_index&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;snmp_index&lt;/code&gt; 모듈을 사용하여 테이블을 수동으로 작성하는보다 효율적인 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e356f188420ccd305fbbe430543827bbca4a813" translate="yes" xml:space="preserve">
          <source>There are more specific &lt;strong&gt;transition actions&lt;/strong&gt; that a callback function can command the &lt;code&gt;gen_statem&lt;/code&gt; engine to do after the callback function return. These are commanded by returning a list of &lt;code&gt;actions&lt;/code&gt; in the &lt;code&gt; return value &lt;/code&gt; from the &lt;code&gt;callback function&lt;/code&gt;. These are the possible &lt;strong&gt;transition actions&lt;/strong&gt;:</source>
          <target state="translated">콜백 함수가 콜백 함수가 반환 된 후 수행 하도록 &lt;code&gt;gen_statem&lt;/code&gt; 엔진에 명령 할 수있는 더 구체적인 &lt;strong&gt;전환 작업&lt;/strong&gt; 이 있습니다 . 이러한 목록을 반환하여 명령하는 &lt;code&gt;actions&lt;/code&gt; 의 &lt;code&gt; return value &lt;/code&gt; 로부터 &lt;code&gt;callback function&lt;/code&gt; . 가능한 &lt;strong&gt;전환 작업&lt;/strong&gt; 은 다음과 같습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd92c71af502e8043671a8043ed8709a47495a40" translate="yes" xml:space="preserve">
          <source>There are more specific state-transition actions that a callback function can command the &lt;code&gt;gen_statem&lt;/code&gt; engine to do after the callback function return. These are commanded by returning a list of &lt;code&gt;actions&lt;/code&gt; in the &lt;code&gt;return value&lt;/code&gt; from the &lt;code&gt;callback function&lt;/code&gt;. These are the possible state transition actions:</source>
          <target state="translated">콜백 함수가 콜백 함수가 리턴 된 후 &lt;code&gt;gen_statem&lt;/code&gt; 엔진에 명령 할 수있는보다 구체적인 상태 전이 조치가 있습니다 . 이러한 목록을 반환하여 명령하는 &lt;code&gt;actions&lt;/code&gt; 의 &lt;code&gt;return value&lt;/code&gt; 로부터 &lt;code&gt;callback function&lt;/code&gt; . 가능한 상태 전이 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b36a2cfd042d4aa3ef25491b61074f01870dd914" translate="yes" xml:space="preserve">
          <source>There are no errors in the module.</source>
          <target state="translated">모듈에 오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf5c5dc136c77b62a5f73ee583f29675f0867a0a" translate="yes" xml:space="preserve">
          <source>There are no good and explicit ways to declare dependencies, so it can be difficult to see and understand these in test suite code and in test logs.</source>
          <target state="translated">의존성을 선언하는 좋고 명확한 방법은 없으므로 테스트 스위트 코드와 테스트 로그에서이를 이해하고 이해하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccfb4d80adcf6550acd24e6e86b074a68a3505fb" translate="yes" xml:space="preserve">
          <source>There are no guarantees exactly when the destructor of an unreferenced resource is called. It could be called directly by &lt;code&gt;enif_release_resource&lt;/code&gt; but it could also be scheduled to be called at a later time possibly by another thread.</source>
          <target state="translated">참조되지 않은 리소스의 소멸자가 언제 호출되는지 정확히 보장 할 수 없습니다. &lt;code&gt;enif_release_resource&lt;/code&gt; 에서 직접 호출 할 수 있지만 나중에 다른 스레드에서 호출하도록 예약 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="79dc22722039d0f06f11ce0ecbb4a728b9b8c1f7" translate="yes" xml:space="preserve">
          <source>There are no restrictions on the number of bits in the tail.</source>
          <target state="translated">테일의 비트 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5da19bcdc35b1de403b2d378cd184c875b0de577" translate="yes" xml:space="preserve">
          <source>There are no special option values (like zero) to clear an option. Some of the options have a unspecified minimum value. Lower values will be adjusted to the minimum value. For example, it is currently not possible to monitor all garbage collections with &lt;code&gt;{long_gc, 0}&lt;/code&gt;.</source>
          <target state="translated">옵션을 지우는 특별한 옵션 값 (예 : 0)은 없습니다. 일부 옵션에는 지정되지 않은 최소값이 있습니다. 낮은 값은 최소값으로 조정됩니다. 예를 들어, 현재 &lt;code&gt;{long_gc, 0}&lt;/code&gt; 모든 가비지 수집을 모니터링하는 것은 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="9e0f9557377e4510903384f151fd0ecbad27b195" translate="yes" xml:space="preserve">
          <source>There are obvious dependencies between the listed functions. The server cannot be configured if it has not first been started, a client connot be connectd until the server is properly configured, and so on. If we want to have one test case for each function, we might be tempted to try to always run the test cases in the stated order and carry possible data (identities, handles, and so on) between the cases and therefore introduce dependencies between them.</source>
          <target state="translated">나열된 기능간에 명확한 종속성이 있습니다. 서버가 처음 시작되지 않은 경우 서버를 구성 할 수 없으며 서버가 올바르게 구성 될 때까지 클라이언트가 연결되지 않습니다. 각 기능에 대해 하나의 테스트 케이스를 원한다면, 명시된 순서대로 테스트 케이스를 항상 실행하고 케이스 사이에 가능한 데이터 (ID, 핸들 등)를 전달하여 이들 사이의 종속성을 유발하려는 유혹을받을 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="8523e884f51973cbccd87b9cb2dffcddaeb778e9" translate="yes" xml:space="preserve">
          <source>There are often sufficient means to work around the need for test case dependencies. Generally, the problem is related to the state of the System Under Test (SUT). The action of one test case can change the system state. For some other test case to run properly, this new state must be known.</source>
          <target state="translated">테스트 케이스 종속성의 필요성을 해결하기위한 충분한 수단이 종종 있습니다. 일반적으로이 문제는 테스트 대상 시스템 (SUT)의 상태와 관련이 있습니다. 한 테스트 사례의 작업으로 시스템 상태가 변경 될 수 있습니다. 다른 테스트 사례가 제대로 실행 되려면이 새로운 상태를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="e108f06d2e6b2fe834e0d25027b8927df7aa555e" translate="yes" xml:space="preserve">
          <source>There are other types of runtime systems that can be built as well using the similar steps just described.</source>
          <target state="translated">방금 설명한 유사한 단계를 사용하여 빌드 할 수있는 다른 유형의 런타임 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e163c970efe377af5c8f879ce7a54392863fd666" translate="yes" xml:space="preserve">
          <source>There are several algorithms for distributing records in a fragmented table evenly over a pool of nodes. No one is best, it depends on the application needs. The following examples of situations need some attention:</source>
          <target state="translated">조각난 테이블의 레코드를 노드 풀에 균등하게 분배하는 몇 가지 알고리즘이 있습니다. 아무도 최선이 아니며 응용 프로그램 요구에 달려 있습니다. 다음과 같은 상황의 예에는주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ba499c73dc1ea2d5a2d0497363ce986917b4ed09" translate="yes" xml:space="preserve">
          <source>There are several constraints available for testing whether a call is to a BIF or a function.</source>
          <target state="translated">호출이 BIF인지 함수인지 테스트하는 데 사용할 수있는 몇 가지 제약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3da498f3aa13476c3eb92930717e01466d88d04f" translate="yes" xml:space="preserve">
          <source>There are several error cases which may prevent an answer from being received and passed to a &lt;code&gt;handle_answer/4&lt;/code&gt; callback:</source>
          <target state="translated">응답이 수신되지 않고 &lt;code&gt;handle_answer/4&lt;/code&gt; 콜백으로 전달되지 못하게하는 몇 가지 오류 사례가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5e18c76899cc79f203e980d3f385f0b37cfdefe" translate="yes" xml:space="preserve">
          <source>There are several implementations provided with the agent: &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt;, &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; and &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt;.</source>
          <target state="translated">에이전트와 함께 제공되는 구현은 &lt;code&gt;snmpa_mib_storage_ets&lt;/code&gt; , &lt;code&gt;snmpa_mib_storage_dets&lt;/code&gt; 및 &lt;code&gt;snmpa_mib_storage_mnesia&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3ff816ccd8ec855be66bcf7ca689d7727faafd3" translate="yes" xml:space="preserve">
          <source>There are several occasions when &lt;code&gt;Mnesia&lt;/code&gt; can detect that the network has been partitioned because of a communication failure, for example:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 가 통신 실패로 인해 네트워크가 분할되었음을 감지 할 수있는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c57bfac8bb05da0f5a10e7726d24981a1293333" translate="yes" xml:space="preserve">
          <source>There are several other process flags, see &lt;code&gt;erlang(3)&lt;/code&gt;. Changing the default behaviour of a process in this way is usually not done in standard user programs, but is left to the supervisory programs in OTP. However, the ping pong program is modified to illustrate exit trapping.</source>
          <target state="translated">다른 프로세스 플래그가 몇 개 있습니다 &lt;code&gt;erlang(3)&lt;/code&gt; 참조 ) . 이런 방식으로 프로세스의 기본 동작 변경은 일반적으로 표준 사용자 프로그램에서는 수행되지 않지만 OTP의 감독 프로그램에는 맡겨집니다. 그러나 핑퐁 프로그램은 출구 트래핑을 설명하기 위해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ff05058f0f15f23c288c9626be84922c9b765fc" translate="yes" xml:space="preserve">
          <source>There are several pre-made filter rule(s) and one general:</source>
          <target state="translated">미리 만들어진 몇 가지 필터 규칙과 하나의 일반 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e75da42e192bf5430b68298e12cdc636289e3c2" translate="yes" xml:space="preserve">
          <source>There are several ways to send a binary created with &lt;code&gt;driver_alloc_binary()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;driver_alloc_binary()&lt;/code&gt; 생성 된 바이너리를 보내는 몇 가지 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="75f05fa20e3e2427a955f3a2446bd3c23ed22b34" translate="yes" xml:space="preserve">
          <source>There are several ways to write a metavariable in your quoted code:</source>
          <target state="translated">인용 코드로 메타 변수를 작성하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82aa827e8118fb053e3d4c4658ad116b8c399af" translate="yes" xml:space="preserve">
          <source>There are six entry points in the Windows registry, top-level keys. They can be abbreviated in this module as follows:</source>
          <target state="translated">Windows 레지스트리에는 최상위 키인 6 개의 진입 점이 있습니다. 이 모듈에서는 다음과 같이 약어로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70680607de60b05f98568bdca23a84c98a7353e4" translate="yes" xml:space="preserve">
          <source>There are some new data types in SNMPv2 that are useful in SNMPv1 as well. In the STANDARD-MIB, three data types are defined, &lt;code&gt;RowStatus&lt;/code&gt;, &lt;code&gt;TruthValue&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. These data types are originally defined as textual conventions in SNMPv2-TC (RFC1903).</source>
          <target state="translated">SNMPv2에는 SNMPv1에도 유용한 일부 새로운 데이터 유형이 있습니다. STANDARD-MIB에서는 &lt;code&gt;RowStatus&lt;/code&gt; , &lt;code&gt;TruthValue&lt;/code&gt; 및 &lt;code&gt;DateAndTime&lt;/code&gt; 의 세 가지 데이터 유형이 정의됩니다 . 이러한 데이터 유형은 원래 SNMPv2-TC (RFC1903)에서 텍스트 규칙으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0e7ae6c930ff553042b2aaa2a5bab43d6e99da70" translate="yes" xml:space="preserve">
          <source>There are still a few percent-encoded triplets left in the output. At this point, when the URI is already parsed, it is safe to apply application specific decoding on the remaining character triplets. Erlang/OTP provides a function, &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; for raw percent decoding that you can use on the host and path components, or on the whole map:</source>
          <target state="translated">출력에 여전히 몇 퍼센트로 인코딩 된 3 중점이 남아 있습니다. 이 시점에서 URI가 이미 구문 분석 된 경우 나머지 문자 3 개에 애플리케이션 별 디코딩을 적용하는 것이 안전합니다. Erlang / OTP는 호스트 및 경로 구성 요소 또는 전체 맵에서 사용할 수있는 원시 백분율 디코딩을위한 &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; 함수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6d7f436b6808fb57326aab28c43cc3d495d3886b" translate="yes" xml:space="preserve">
          <source>There are three built-in trace patterns: &lt;code&gt;exception_trace&lt;/code&gt;, &lt;code&gt;caller_trace&lt;/code&gt; and &lt;code&gt;caller_exception_trace&lt;/code&gt; (or &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;cx&lt;/code&gt; respectively). Exception trace sets a trace which will show function names, parameters, return values and exceptions thrown from functions. Caller traces display function names, parameters and information about which function called it. An example using a built-in alias:</source>
          <target state="translated">내장 된 추적 패턴에는 &lt;code&gt;exception_trace&lt;/code&gt; , &lt;code&gt;caller_trace&lt;/code&gt; 및 &lt;code&gt;caller_exception_trace&lt;/code&gt; (또는 각각 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;cx&lt;/code&gt; )의 세 가지가 있습니다. 예외 추적은 함수에서 발생한 함수 이름, 매개 변수, 반환 값 및 예외를 표시하는 추적을 설정합니다. 호출자 추적은 함수 이름, 매개 변수 및 호출 한 함수에 대한 정보를 표시합니다. 내장 별명을 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="ce6e977a031f0f78d9783247027132e2871000ad" translate="yes" xml:space="preserve">
          <source>There are three entities: department, employee, and project.</source>
          <target state="translated">부서, 직원 및 프로젝트의 세 가지 엔티티가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95942457dca44926353518936009aaa1a127415" translate="yes" xml:space="preserve">
          <source>There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; is subpattern index 1, &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; is subpattern index 2, and &lt;code&gt;(..d)&lt;/code&gt; is subpattern index 3. When matched against the following string:</source>
          <target state="translated">세 개의 명시 적으로 캡처하는 서브 패턴이 있는데, 여는 괄호 위치가 결과의 순서를 결정하므로 &lt;code&gt;((?&amp;lt;FOO&amp;gt;abdd)|a(..d))&lt;/code&gt; 는 서브 패턴 인덱스 1이고 &lt;code&gt;(?&amp;lt;FOO&amp;gt;abdd)&lt;/code&gt; 는 서브 패턴입니다 인덱스 2 및 &lt;code&gt;(..d)&lt;/code&gt; 는 하위 패턴 인덱스 3입니다. 다음 문자열과 일치하는 경우 :</target>
        </trans-unit>
        <trans-unit id="b9d8071a7cab5fe6bb06cfbf16feb00bf5b9bf05" translate="yes" xml:space="preserve">
          <source>There are three kinds of configuration:</source>
          <target state="translated">구성에는 세 가지 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f596c95045c35d0f6872618b7a800aff23b78f1" translate="yes" xml:space="preserve">
          <source>There are three main reasons for using this mapping:</source>
          <target state="translated">이 매핑을 사용하는 세 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21dcf13609dda19f86b7a0c362b1f37accd05aea" translate="yes" xml:space="preserve">
          <source>There are three relationships between these entities:</source>
          <target state="translated">이 엔티티들 사이에는 세 가지 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6f8a9d2ff844ea14957c3bca79e832dabec9620" translate="yes" xml:space="preserve">
          <source>There are to be no circular dependencies among the applications.</source>
          <target state="translated">응용 프로그램간에 순환 종속성이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a76c3a9ace292c2e0f4031bfd80c3c9f908baded" translate="yes" xml:space="preserve">
          <source>There are to be no duplicated modules, that is, modules with the same name but belonging to different applications.</source>
          <target state="translated">중복 된 모듈, 즉 이름은 같지만 다른 응용 프로그램에 속하는 모듈은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="b018774fca4517707ee8766e662ecc9fb5f61fbf" translate="yes" xml:space="preserve">
          <source>There are to be no undefined applications, that is, dependencies to applications that are not included in the release. (Key &lt;code&gt;applications&lt;/code&gt; in the &lt;code&gt;.app&lt;/code&gt; file).</source>
          <target state="translated">정의되지 않은 응용 프로그램, 즉 릴리스에 포함되지 않은 응용 프로그램에 대한 종속성이 없어야합니다. (키 &lt;code&gt;applications&lt;/code&gt; 에서 &lt;code&gt;.app&lt;/code&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="8657af51c1708a2f767083749fec728b2f15dd21" translate="yes" xml:space="preserve">
          <source>There are two Elisp modules included in this tool package for Emacs. There is erlang.el that defines the actual erlang mode and there is erlang-start.el that makes some nice initializations.</source>
          <target state="translated">이맥스 용 툴 패키지에는 2 개의 Elisp 모듈이 포함되어 있습니다. 실제 erlang 모드를 정의하는 erlang.el과 멋진 초기화를 수행하는 erlang-start.el이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4650ca14e027a543e950b128c780c1aff1d2ced2" translate="yes" xml:space="preserve">
          <source>There are two alternatives for &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 에는 두 가지 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8bf9361085b975630319d83556ce12329f9229c" translate="yes" xml:space="preserve">
          <source>There are two basic ways to use the binary encodings: With package related name and termination id transformation (the 'native' encoding config) or without. This transformation converts package related names and termination id's to a more convenient internal form (equivalent with the decoded text message).</source>
          <target state="translated">바이너리 인코딩을 사용하는 두 가지 기본 방법이 있습니다 : 패키지 관련 이름 및 종료 ID 변환 ( '네이티브'인코딩 구성) 또는없는. 이 변환은 패키지 관련 이름과 종료 ID를보다 편리한 내부 형식 (디코딩 된 문자 메시지와 동일)으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="dd1db3d75a354d15737e7ae7563e82290092028f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dependencies&lt;/code&gt; 페이지 에는 두 가지 범주의 모듈이 있습니다 . 모듈은 다른 모듈에 의해 사용되는 경우, 이들은 아래에 나열되어 &lt;code&gt;Modules using this&lt;/code&gt; . 모듈이 다른 모듈을 사용하는 경우 &lt;code&gt;Used modules&lt;/code&gt; 아래에 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="887d7e8bf421025bcb8d521eeed1d2552d08027f" translate="yes" xml:space="preserve">
          <source>There are two categories of modules on the &lt;code&gt;Module dependencies&lt;/code&gt; page. If the module is used by other modules, these are listed under &lt;code&gt;Modules using this&lt;/code&gt;. If the module uses other modules, these are listed under &lt;code&gt;Used modules&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module dependencies&lt;/code&gt; 페이지 에는 두 가지 범주의 모듈이 있습니다 . 모듈은 다른 모듈에 의해 사용되는 경우, 이들은 아래에 나열되어 &lt;code&gt;Modules using this&lt;/code&gt; . 모듈이 다른 모듈을 사용하는 경우 &lt;code&gt;Used modules&lt;/code&gt; 아래에 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="e74dd0da2a3747be954c0f8457f4880fc1f5333a" translate="yes" xml:space="preserve">
          <source>There are two differences when using Erl_Interface on the C side compared to the example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt; Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port:</source>
          <target state="translated">C 측에서 Erl_Interface 를 사용할 때 일반 포트만 사용 하는 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt; Ports&lt;/a&gt;&lt;/code&gt; 의 예와 비교하면 두 가지 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="599878b5a82e164996281429b80e489ea9c477d5" translate="yes" xml:space="preserve">
          <source>There are two differences when using Erl_Interface on the C side compared to the example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt;, using only the plain port:</source>
          <target state="translated">C 측에서 Erl_Interface 를 사용할 때 일반 포트만 사용 하는 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 의 예제와 비교하여 두 가지 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23c004d4c8512a14978a320110e39b1a0ff94575" translate="yes" xml:space="preserve">
          <source>There are two different measurement tools:</source>
          <target state="translated">두 가지 측정 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a94aa96b73c7ee440863f41a5aef58bc994511af" translate="yes" xml:space="preserve">
          <source>There are two implementations available:</source>
          <target state="translated">사용 가능한 두 가지 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b217d8aaa3bcdc7db2e259b15d48c394ea4df29" translate="yes" xml:space="preserve">
          <source>There are two kinds of variables: predefined variables and user variables.  &lt;strong id=&quot;predefined_variable&quot;&gt;Predefined variables&lt;/strong&gt; hold set up module data, and cannot be assigned to but only used in queries.  &lt;strong id=&quot;user_variable&quot;&gt;User variables&lt;/strong&gt; on the other hand can be assigned to, and are typically used for temporary results while evaluating a query, and for keeping results of queries for use in subsequent queries. The predefined variables are (variables marked with (*) are available in &lt;code&gt;functions&lt;/code&gt; mode only):</source>
          <target state="translated">사전 정의 된 변수와 사용자 변수의 두 가지 변수가 있습니다. &lt;strong id=&quot;predefined_variable&quot;&gt;사전 정의 된 변수&lt;/strong&gt; 는 설정 모듈 데이터를 보유하며 쿼리에는 할당 할 수 없지만 쿼리에만 사용됩니다. 반면에 &lt;strong id=&quot;user_variable&quot;&gt;사용자 변수&lt;/strong&gt; 는 할당 할 수 있으며 일반적으로 쿼리를 평가하는 동안 임시 결과 및 후속 쿼리에 사용하기 위해 쿼리 결과를 유지하는 데 사용됩니다. 사전 정의 된 변수는 다음과 같습니다 ((*)로 표시된 변수는 &lt;code&gt;functions&lt;/code&gt; 모드에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="51e96249f31fef90280598a64efcee667d150bd9" translate="yes" xml:space="preserve">
          <source>There are two known shortcomings in xmerl:</source>
          <target state="translated">xmerl에는 두 가지 알려진 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99e9898726a4d1ec0a543937d2f79fae5062fc44" translate="yes" xml:space="preserve">
          <source>There are two occasions when the young heap grows:</source>
          <target state="translated">젊은 힙이 자라는 두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9f480805fea8601c547a9eb29f50f8f9cd8ca43" translate="yes" xml:space="preserve">
          <source>There are two occasions when the young heap is shrunk:</source>
          <target state="translated">젊은 힙이 축소되는 두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc0e3ffc28ca1f923c575a2ec112ffd273f7f33c" translate="yes" xml:space="preserve">
          <source>There are two options for handling syntax errors (that is when an unexpected event is received when the digit map evaluator is expecting some other event). The unexpected events may either be ignored or rejected. The latter means that the evaluation is aborted and an error is returned.</source>
          <target state="translated">구문 오류를 처리하기위한 두 가지 옵션이 있습니다 (즉, 숫자 맵 평가자가 다른 이벤트를 예상 할 때 예기치 않은 이벤트가 수신 될 때). 예기치 않은 이벤트는 무시되거나 거부 될 수 있습니다. 후자는 평가가 중단되고 오류가 반환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e7ea701d75f10ddf239c1c9acff7a8b7f85969f9" translate="yes" xml:space="preserve">
          <source>There are two reasons why &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; are not to be used: they are not efficient, and they prevent the use of key &lt;code&gt;'$end_of_table'&lt;/code&gt;, as this atom is used to indicate the end of the table. If possible, use functions &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; for traversing tables.</source>
          <target state="translated">&lt;code&gt;first/1&lt;/code&gt; 과 &lt;code&gt;next/2&lt;/code&gt; 가 사용되지 않는 데는 두 가지 이유 가 있습니다. 효율적 &lt;code&gt;'$end_of_table'&lt;/code&gt; 원자가 테이블의 끝을 나타내는 데 사용 되므로 '$ end_of_table' 키를 사용하지 못하게 합니다. 가능하면 사용 기능은 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object&lt;/a&gt;&lt;/code&gt; 를 , 그리고 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 이송 테이블.</target>
        </trans-unit>
        <trans-unit id="80545dc051cca46852b43329d06d54cf9d266b54" translate="yes" xml:space="preserve">
          <source>There are two significant differences when using this function instead of reading the record, performing the arithmetic, and writing the record:</source>
          <target state="translated">레코드를 읽고, 산술을 수행하고, 레코드를 쓰는 대신이 함수를 사용할 때 두 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dad1bd4e1026419dc7de0c5664baefca6532877" translate="yes" xml:space="preserve">
          <source>There are two special cases for the timeout value &lt;code&gt;ExprT&lt;/code&gt;:</source>
          <target state="translated">시간 종료 값 &lt;code&gt;ExprT&lt;/code&gt; 에는 두 가지 특수한 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c56d561a526dd7ff6bad858caa6d005781753b5c" translate="yes" xml:space="preserve">
          <source>There are two types of numeric literals, &lt;strong&gt;integers&lt;/strong&gt; and &lt;strong&gt;floats&lt;/strong&gt;. Besides the conventional notation, there are two Erlang-specific notations:</source>
          <target state="translated">숫자 리터럴에는 &lt;strong&gt;integers&lt;/strong&gt; 및 &lt;strong&gt;floats&lt;/strong&gt; 의 두 가지 유형이 있습니다 . 일반적인 표기법 외에 두 가지 Erlang 관련 표기법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c927021e9667cac0b76e4d583b237c1b874a0a" translate="yes" xml:space="preserve">
          <source>There are two types of unique integers both created using the &lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF:</source>
          <target state="translated">&lt;code&gt;erlang:unique_integer()&lt;/code&gt; BIF를 사용하여 생성 된 두 가지 유형의 고유 정수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adcec4978d9685360563b69cc57cc9c6d0c475d9" translate="yes" xml:space="preserve">
          <source>There are two versions of the &lt;code&gt;server_transfer&lt;/code&gt; function: one with four arguments (&lt;code&gt;server_transfer/4&lt;/code&gt;) and one with five (&lt;code&gt;server_transfer/5&lt;/code&gt;). These are regarded by Erlang as two separate functions.</source>
          <target state="translated">&lt;code&gt;server_transfer&lt;/code&gt; 함수 에는 두 가지 버전이 있습니다. 하나는 인수가 네 &lt;code&gt;server_transfer/4&lt;/code&gt; ( server_transfer / 4 ) 하나는 다섯 개가 있습니다 ( &lt;code&gt;server_transfer/5&lt;/code&gt; ). 이것들은 Erlang에 의해 두 개의 개별 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1b723932d3f965d03f997c2929d90177ac53f1a0" translate="yes" xml:space="preserve">
          <source>There are two ways of shutting down an &lt;code&gt;ssh&lt;/code&gt; daemon, see &lt;strong&gt;Step 5a&lt;/strong&gt; and &lt;strong&gt;Step 5b&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;ssh&lt;/code&gt; 데몬 을 종료하는 두 가지 방법이 있습니다 ( &lt;strong&gt;5a &lt;/strong&gt;&lt;strong&gt;단계&lt;/strong&gt; 및 &lt;strong&gt;5b 단계&lt;/strong&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="ca0c875bf6657b9c2873d094d99069621f5c3b26" translate="yes" xml:space="preserve">
          <source>There are two ways to define internal generic instructions:</source>
          <target state="translated">내부 일반 명령어를 정의하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="67a5f230cec8e69ad074e79327cb344b91c01c42" translate="yes" xml:space="preserve">
          <source>There are two ways to handle the different megaco encoding versions. Either using &lt;strong&gt;dynamic version detection&lt;/strong&gt; (only valid for for incoming messages) or by &lt;strong&gt;explicit version&lt;/strong&gt; setting in the connection info.</source>
          <target state="translated">다른 megaco 인코딩 버전을 처리하는 두 가지 방법이 있습니다. 어느 사용하여 &lt;strong&gt;동적 버전 감지&lt;/strong&gt; (들어오는 메시지에 대한 유효) 또는에 의해 &lt;strong&gt;명시 적 버전&lt;/strong&gt; 연결 정보에서 설정을.</target>
        </trans-unit>
        <trans-unit id="d9e65fcf80d23dd2690fb225a26bd4c0425947c3" translate="yes" xml:space="preserve">
          <source>There are two ways to include comments in patterns that are processed by PCRE. In both cases, the start of the comment must not be in a character class, or in the middle of any other sequence of related characters such as (?: or a subpattern name or number. The characters that make up a comment play no part in the pattern matching.</source>
          <target state="translated">PCRE에서 처리되는 패턴에 주석을 포함시키는 두 가지 방법이 있습니다. 두 경우 모두, 주석의 시작은 문자 클래스 또는 (? : 또는 하위 패턴 이름 또는 번호와 같은 다른 관련 문자 시퀀스의 중간에 있어서는 안됩니다. 주석을 구성하는 문자는 아무런 역할을하지 않습니다. 패턴 일치.</target>
        </trans-unit>
        <trans-unit id="d20c200558da5edbf4cd1004014da1b7247909e5" translate="yes" xml:space="preserve">
          <source>There are two ways to set a timeout for the underlying ssh connection:</source>
          <target state="translated">기본 ssh 연결에 대한 시간 초과를 설정하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f355209178288a170c04f2c9a20a04655a8e5d7d" translate="yes" xml:space="preserve">
          <source>There are two ways to start a restricted shell session:</source>
          <target state="translated">제한된 쉘 세션을 시작하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5c659495ea0b68ab11f6dd415042864496550c" translate="yes" xml:space="preserve">
          <source>There are various reasons for using multi-file compilation:</source>
          <target state="translated">다중 파일 컴파일을 사용하는 데는 여러 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4bd267d265d01937064d3e1fb0e66e780b2cf5c" translate="yes" xml:space="preserve">
          <source>There can be more than one back reference to the same subpattern. If a subpattern has not been used in a particular match, any back references to it always fails. For example, the following pattern always fails if it starts to match &quot;a&quot; rather than &quot;bc&quot;:</source>
          <target state="translated">동일한 서브 패턴에 대한 역 참조가 둘 이상있을 수 있습니다. 하위 패턴이 특정 일치 항목에서 사용되지 않은 경우 하위 패턴에 대한 역 참조는 항상 실패합니다. 예를 들어, 다음 패턴이 &quot;bc&quot;가 아닌 &quot;a&quot;와 일치하기 시작하면 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="23ffd59215d348fa8988a623fd249aee7018b927" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first parameter has to be an integer() and the last a string().</source>
          <target state="translated">모든 유형 (integer () 또는 string ())의 매개 변수는 4 개를 초과 할 수 없으므로 첫 번째 매개 변수는 integer ()이고 마지막은 string ()이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1112d47dc0a89deb75a8a7d00a4b483aae845be6" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first three parameters has to be integer()'s and the last three string()'s.</source>
          <target state="translated">모든 유형 (integer () 또는 string ())의 매개 변수는 4 개를 초과 할 수 없으므로 처음 세 매개 변수는 integer () 및 마지막 세 string ()이어야합니다.</target>
        </trans-unit>
        <trans-unit id="abdb1ae11dc35da6f7877497944147afcc093ef4" translate="yes" xml:space="preserve">
          <source>There can be no more than four parameters of any type (integer() or string()), so the first two parameters has to be integer()'s and the last two string()'s.</source>
          <target state="translated">모든 유형 (integer () 또는 string ())의 매개 변수는 4 개를 초과 할 수 없으므로 처음 두 매개 변수는 integer () 및 마지막 두 string ()이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9363b97aec7cf5ddf082ad0d169c592d9050f71" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary pattern. A binary pattern can occur wherever patterns are allowed, including inside other patterns. Binary patterns cannot be nested. The pattern &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; matches a zero length binary.</source>
          <target state="translated">이진 패턴에는 0 개 이상의 세그먼트가있을 수 있습니다. 이진 패턴은 다른 패턴 내부를 포함하여 패턴이 허용되는 모든 곳에서 발생할 수 있습니다. 이진 패턴은 중첩 될 수 없습니다. &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 패턴 은 길이가 0 인 이진과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e406e24fdab0c44cf1156b1456ae80afb50bb754" translate="yes" xml:space="preserve">
          <source>There can be zero or more segments in a binary to be constructed. The expression &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; constructs a zero length binary.</source>
          <target state="translated">바이너리에 생성 할 세그먼트가 0 개 이상있을 수 있습니다. &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 표현식 은 길이가 0 인 2 진을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="92428ad0a4bfb32617492b37faa92496b8ccd220" translate="yes" xml:space="preserve">
          <source>There exist a number of other &lt;code&gt;spawn&lt;/code&gt; BIFs, for example, &lt;code&gt;spawn/4&lt;/code&gt; for spawning a process at another node.</source>
          <target state="translated">다른 노드에서 프로세스를 &lt;code&gt;spawn/4&lt;/code&gt; 하기위한 다른 &lt;code&gt;spawn&lt;/code&gt; BIF (예 : spawn / 4) 가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf1452fa6d696c476949e9f9eb92d75ee28307f" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate maps.</source>
          <target state="translated">맵을 조작하기위한 많은 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a19838f7ca93f30ce58e7113784f915faaff575" translate="yes" xml:space="preserve">
          <source>There exists a number of BIFs to manipulate tuples.</source>
          <target state="translated">튜플을 조작하기위한 많은 BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71ba36f320e1a48ef1d206a22dd1cb9d13cc9ef" translate="yes" xml:space="preserve">
          <source>There is &lt;strong&gt;no&lt;/strong&gt; automatic mechanism for avoiding priority inversion, such as priority inheritance or priority ceilings. When using priorities, take this into account and handle such scenarios by yourself.</source>
          <target state="translated">우선 순위 상속 또는 우선 순위 상한과 같은 우선 순위 반전을 피하기위한 자동 메커니즘 은 &lt;strong&gt;없습니다&lt;/strong&gt; . 우선 순위를 사용할 때이를 고려하여 직접 이러한 시나리오를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="9a070af877637494ae1a1cb6aabfadc95370405a" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;&lt;a href=&quot;configure_algos#introduction&quot;&gt;separate chapter&lt;/a&gt;&lt;/code&gt; about how &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; co-operate. How the different configuration levels affect them, is described here in this section.</source>
          <target state="translated">가 &lt;code&gt;&lt;a href=&quot;configure_algos#introduction&quot;&gt;separate chapter&lt;/a&gt;&lt;/code&gt; 방법에 대한 &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; 가 공동 운영은. 다양한 구성 수준이 여기에 어떻게 영향을 미치는지이 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e441464fc3e7bb22aba940b66dbb7ca5c94b38df" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;server&lt;/code&gt; config option, &lt;code&gt;&lt;a href=&quot;snmp_config#manager_server_nis&quot;&gt;netif_sup&lt;/a&gt;&lt;/code&gt; that enables &quot;active&quot; Net If supervision. This is very simple mechanism. The (supervising) process simply sends a &lt;code&gt;&lt;a href=&quot;#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; message and expects a &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message response (withing a specific time). The interval between each &lt;code&gt;ping/pong&lt;/code&gt; exhange is user configurable. As is the time that is allowed for the &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message to arrive. Both the NetIf module(s) provided with the app supports active supervision. If a NetIf module/process is used which do not implement this, then the server cannot be configured with active supervision.</source>
          <target state="translated">&quot;활성&quot;Net If 감독을 활성화 하는 &lt;code&gt;server&lt;/code&gt; 구성 옵션 &lt;code&gt;&lt;a href=&quot;snmp_config#manager_server_nis&quot;&gt;netif_sup&lt;/a&gt;&lt;/code&gt; 이 있습니다. 이것은 매우 간단한 메커니즘입니다. (감독) 프로세스는 단순히 &lt;code&gt;&lt;a href=&quot;#im_ping&quot;&gt;ping&lt;/a&gt;&lt;/code&gt; 메시지 를 보내고 &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; 메시지 응답 (특정 시간 포함)을 기대합니다 . 각 &lt;code&gt;ping/pong&lt;/code&gt; 교환 간격 은 사용자가 구성 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; 메시지가 도착할 수있는 시간입니다 . 앱과 함께 제공되는 NetIf 모듈은 모두 활성 감독을 지원합니다. 이를 구현하지 않는 NetIf 모듈 / 프로세스를 사용하는 경우 활성 감독으로 서버를 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea2c52d8c1115defbbd414994b65799bf1261e4f" translate="yes" xml:space="preserve">
          <source>There is a MIB, SNMP-COMMUNITY-MIB, which maps a community string to a &lt;code&gt;contextEngineID&lt;/code&gt; and &lt;code&gt;contextName&lt;/code&gt;. Thus, each message, an SNMPv1, SNMPv2c or an SNMPv3 message, always uniquely identifies a context.</source>
          <target state="translated">커뮤니티 문자열을 &lt;code&gt;contextEngineID&lt;/code&gt; 및 &lt;code&gt;contextName&lt;/code&gt; 에 맵핑하는 MIB, SNMP-COMMUNITY-MIB가 있습니다 . 따라서 SNMPv1, SNMPv2c 또는 SNMPv3 메시지와 같은 각 메시지는 항상 컨텍스트를 고유하게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="4962d5e61edd677f3200f2d2f1cbd369fddee679" translate="yes" xml:space="preserve">
          <source>There is a bit of setup needed to allow filters to decide whether a specific process should be allowed to log. This is because the default primary log level is notice and it is enforced before the primary filters. So in order for the pid filter to be useful we have to raise the primary log level to &lt;code&gt;all&lt;/code&gt; and then add a level filter that only lets certain messages at or greater than notice through. When the setup is done, it is simple to add a filter that allows a certain pid through.</source>
          <target state="translated">필터가 특정 프로세스의 로그 허용 여부를 결정할 수 있도록하려면 약간의 설정이 필요합니다. 이는 기본 기본 로그 수준이 통지이고 기본 필터보다 먼저 적용되기 때문입니다. 따라서 pid 필터를 유용하게 사용하려면 기본 로그 수준을 &lt;code&gt;all&lt;/code&gt; 로 올린 다음 특정 메시지 만 알림을 통과하도록 허용하는 수준 필터를 추가해야합니다. 설정이 완료되면 특정 PID를 허용하는 필터를 추가하는 것은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="9ade9e507a62a79d9f797b73458450166ab26545" translate="yes" xml:space="preserve">
          <source>There is a default hostname matching procedure defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; as well as protocol dependent variations defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt;. The default procedure is implemented in &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt;. It is possible for a client to hook in modified rules using the options list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; 정의 된 기본 호스트 이름 일치 절차 와 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt; 정의 된 프로토콜 종속 변형이 있습니다. 기본 절차는 &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt; 에 구현되어 있습니다. 옵션 목록을 사용하여 클라이언트가 수정 된 규칙을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6736bbeb782d86b747de9c6e8819acd895d1cff" translate="yes" xml:space="preserve">
          <source>There is a default hostname matching procedure defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section/6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; as well as protocol dependent variations defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt;. The default procedure is implemented in &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt;. It is possible for a client to hook in modified rules using the options list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section/6&quot;&gt;RFC 6125, section 6&lt;/a&gt;&lt;/code&gt; 정의 된 기본 호스트 이름 일치 절차 와 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#appendix-B&quot;&gt;RFC 6125 appendix B&lt;/a&gt;&lt;/code&gt; 정의 된 프로토콜 종속 변형이 있습니다. 기본 프로시 저는 &lt;code&gt;public_key:pkix_verify_hostname/2,3&lt;/code&gt; 에 구현 됩니다 . 클라이언트가 옵션 목록을 사용하여 수정 된 규칙에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57b5d67847213c70927a42448b10614ec369aea" translate="yes" xml:space="preserve">
          <source>There is a scaling problem with this database.</source>
          <target state="translated">이 데이터베이스에 스케일링 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2622c0a39c247fb494769606e0e52cccfb438701" translate="yes" xml:space="preserve">
          <source>There is a set of standard MIBs, which are used to control and configure an SNMP agent. All of these MIBs, with the exception of the optional SNMP-PROXY-MIB (which is only used for proxy agents), are implemented in this agent. Further, it is configurable which of these MIBs are actually loaded, and thus made visible to SNMP managers. For example, in a non-secure environment, it might be a good idea to not make MIBs that define access control visible. Note, the data the MIBs define is used internally in the agent, even if the MIBs not are loaded. This chapter describes these standard MIBs, and some aspects of their implementation.</source>
          <target state="translated">SNMP 에이전트를 제어하고 구성하는 데 사용되는 표준 MIB 세트가 있습니다. 선택적인 SNMP-PROXY-MIB (프록시 에이전트에만 사용됨)를 제외한 모든 MIB는이 에이전트에서 구현됩니다. 또한 이러한 MIB 중 어떤 것이 실제로로드되는지 구성 할 수 있으므로 SNMP 관리자가 볼 수 있습니다. 예를 들어, 비보안 환경에서는 액세스 제어를 정의하는 MIB를 표시하지 않는 것이 좋습니다. MIB가 정의되지 않은 데이터는 MIB가로드되지 않은 경우에도 에이전트에서 내부적으로 사용됩니다. 이 장에서는 이러한 표준 MIB와 그 구현의 일부 측면에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="245adc1cc09d9e8cf3fbaea30fefe11a104de911" translate="yes" xml:space="preserve">
          <source>There is a severe performance penalty in using &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; after any modifying operation is done on that table in the same transaction. That is, avoid using &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;mnesia:select&lt;/code&gt; in the same transaction.</source>
          <target state="translated">동일한 트랜잭션에서 해당 테이블에 대해 수정 작업을 수행 한 후 &lt;code&gt;mnesia:select/[1|2|3|4]&lt;/code&gt; 를 사용 하면 성능이 저하 됩니다. 즉 , 동일한 트랜잭션에서 &lt;code&gt;mnesia:select&lt;/code&gt; 전에 mnesia : &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mnesia#delete-1&quot;&gt;mnesia:delete/1&lt;/a&gt;&lt;/code&gt; 을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="fd2145693c339b562c11a1ada444dad48f07688b" translate="yes" xml:space="preserve">
          <source>There is a special case for the argument &lt;code&gt;Length&lt;/code&gt;. If it is set to zero (0), it means &quot;give me everything you currently have&quot;.</source>
          <target state="translated">&lt;code&gt;Length&lt;/code&gt; 인수에 대한 특별한 경우가 있습니다 . 0으로 설정하면 &quot;현재 가지고있는 모든 것을 나에게주십시오&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3e3a6368bd3434309374ec5b9d503fef73c80480" translate="yes" xml:space="preserve">
          <source>There is a special case for this field. When the &lt;code&gt;max_retries&lt;/code&gt; has the value &lt;code&gt;infinity_restartable&lt;/code&gt;, it means that the timer is restartable as long as some external event occurs (e.g. receipt of a pending message for instance). But the timer will never be restarted &quot;by itself&quot;, i.e. when the timer expires (whatever the timeout time), so does the timer. Whenever the timer is restarted, the timeout time will be calculated in the usual way! Also, as mentioned above, beware the consequences of setting the value to &lt;code&gt;infinity&lt;/code&gt; if &lt;strong&gt;incr&lt;/strong&gt; has been set to an negative value.</source>
          <target state="translated">이 분야에는 특별한 경우가 있습니다. 때 &lt;code&gt;max_retries&lt;/code&gt; 값 갖는다 &lt;code&gt;infinity_restartable&lt;/code&gt; 를 , 상기 타이머가 긴 일부 외부 이벤트 (예를 들어 계류중인 메시지의 수신 등)를 발생으로 재시작 것을 의미한다. 그러나 타이머는 &quot;자체로&quot;다시 시작되지 않습니다. 즉, 타이머가 만료 될 때 (시간 초과 시간에 관계없이) 타이머도 다시 시작됩니다. 타이머가 다시 시작될 때마다 시간 초과 시간이 일반적인 방식으로 계산됩니다! 또한, 위에서 언급 한 것처럼 &lt;strong&gt;incr&lt;/strong&gt; 이 음수 값으로 설정된 경우 값을 &lt;code&gt;infinity&lt;/code&gt; 로 설정 한 결과에 유의하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="518160f1e4844414329120e09f304c63bc2e3610" translate="yes" xml:space="preserve">
          <source>There is a way to exclude a varbind from the notification. In the normal &lt;code&gt;varbinds&lt;/code&gt; list, providing the special value &lt;code&gt;'$ignore-oid'&lt;/code&gt; (instead of a normal value) will exclude this varbind from the notification.</source>
          <target state="translated">알림에서 varbind를 제외하는 방법이 있습니다. 일반 &lt;code&gt;varbinds&lt;/code&gt; 목록에서 특수 값 &lt;code&gt;'$ignore-oid'&lt;/code&gt; (일반 값 대신)를 제공하면 알림에서이 varbind가 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="447c2e61ea99ad24abf33df5c7d87ca6d434b459" translate="yes" xml:space="preserve">
          <source>There is also a &quot;default&quot; value, which has the empty string as name. It is read and written with the atom &lt;code&gt;default&lt;/code&gt; instead of the name.</source>
          <target state="translated">&quot;default&quot;값도 있는데,이 문자열은 이름으로 비어 있습니다. 이름 대신 원자 &lt;code&gt;default&lt;/code&gt; 읽고 씁니다 .</target>
        </trans-unit>
        <trans-unit id="72a2dc39e7a01a6896da1efca2f9a2f1bfe9f0eb" translate="yes" xml:space="preserve">
          <source>There is also a file that only contains macro definitions:</source>
          <target state="translated">매크로 정의 만 포함하는 파일도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4ba43d3ad9541719761e12f97fd9eb701de696" translate="yes" xml:space="preserve">
          <source>There is also a interface to system dependent memory data, &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt;. The result is highly dependent on the underlying operating system and the interface is targeted primarily for systems without virtual memory (e.g. VxWorks). The output on other systems is however still valid, although sparse.</source>
          <target state="translated">시스템 종속 메모리 데이터 인 &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; 대한 인터페이스도 있습니다 . 결과는 기본 운영 체제에 따라 크게 달라지며 인터페이스는 주로 가상 메모리가없는 시스템 (예 : VxWorks)을 대상으로합니다. 그러나 다른 시스템의 출력은 희소하지만 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f33caba16ae1707839afdef5cf02caa858272566" translate="yes" xml:space="preserve">
          <source>There is also a interface to system dependent memory data, &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt;. The result is highly dependent on the underlying operating system and the interface is targeted primarily for systems without virtual memory. However, the output on other systems is still valid, although sparse.</source>
          <target state="translated">시스템 종속 메모리 데이터 &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; 대한 인터페이스도 있습니다 . 결과는 기본 운영 체제에 따라 크게 달라지며 인터페이스는 주로 가상 메모리가없는 시스템을 대상으로합니다. 그러나 다른 시스템의 출력은 드물지만 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="52cbe6243fc1056f1d917ea0abcda645d19b3500" translate="yes" xml:space="preserve">
          <source>There is also a low limit. When the amount of queued &lt;code&gt;command&lt;/code&gt; data falls below this limit and the port is in a busy port queue state, the busy port queue state is automatically disabled. The low limit should typically be significantly lower than the high limit in order to prevent frequent oscillation around the busy port queue state.</source>
          <target state="translated">하한도 있습니다. 대기중인 &lt;code&gt;command&lt;/code&gt; 데이터 의 양 이이 제한 아래로 떨어지고 포트가 사용중인 포트 대기열 상태에 있으면 사용중인 포트 대기열 상태가 자동으로 비활성화됩니다. 사용중인 포트 대기열 상태 주변에서 빈번한 진동을 방지하기 위해 하한은 일반적으로 상한보다 상당히 낮아야합니다.</target>
        </trans-unit>
        <trans-unit id="7c9bc41f259857156ea8f5d5261fcd25f2b407e3" translate="yes" xml:space="preserve">
          <source>There is also a module &lt;code&gt;make&lt;/code&gt;, which provides a set of functions similar to the UNIX type Make functions, see the &lt;code&gt;make(3)&lt;/code&gt; manual page in Tools.</source>
          <target state="translated">UNIX 유형 Make 기능과 유사한 기능 세트를 제공 하는 모듈 &lt;code&gt;make&lt;/code&gt; 도 있습니다 &lt;code&gt;make(3)&lt;/code&gt; 도구 의 make (3) 매뉴얼 페이지 참조 ) .</target>
        </trans-unit>
        <trans-unit id="d5ca1aa3efc4be83f80c48a432fa83fd2335f9cf" translate="yes" xml:space="preserve">
          <source>There is also a server start option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after, Timeout} &lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#start_monitor-3&quot;&gt;start_monitor/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4,5,6&lt;/a&gt;&lt;/code&gt;, that may be used to automatically hibernate the server.</source>
          <target state="translated">서버 시작 옵션도있다 &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after, Timeout} &lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#start_monitor-3&quot;&gt;start_monitor/3,4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4,5,6&lt;/a&gt;&lt;/code&gt; , 그것은 자동으로 서버를 최대 절전 모드로 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="0dad695a19ca238ba2a763d955fb786b98d2dc49" translate="yes" xml:space="preserve">
          <source>There is also a server start option &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; that may be used to automatically hibernate the server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 에 대한 서버 시작 옵션 &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after, Timeout}&lt;/a&gt;&lt;/code&gt; 이 있어 서버를 자동으로 최대 절전 모드로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f24b3a3437fd8a632ab4bcd78a41f42013e20b72" translate="yes" xml:space="preserve">
          <source>There is also a type test BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt;.</source>
          <target state="translated">형식 테스트 BIF &lt;code&gt;is_record(Term, RecordTag)&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa23f797927415980ee4810932d3c90b6953794" translate="yes" xml:space="preserve">
          <source>There is also an API to block or unblock users manually. This API can also list blocked users or users who have been authenticated within a configurable amount of time.</source>
          <target state="translated">사용자를 수동으로 차단하거나 차단 해제하는 API도 있습니다. 이 API는 차단 가능한 사용자 또는 구성 가능한 시간 내에 인증 된 사용자를 나열 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7110ad7a4f42b784159bbbf21bed3303346edd8d" translate="yes" xml:space="preserve">
          <source>There is also function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; returning all flags (bitwise or:ed together) corresponding to features that require strict ordering of data over distribution channels.</source>
          <target state="translated">&lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 함수도 배포 채널을 통해 데이터를 엄격하게 정렬해야하는 기능에 해당하는 모든 플래그를 비트 단위 또는 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fa8c8dbb4f5b93ed951ec7e3ddcfaace3c9a8bb" translate="yes" xml:space="preserve">
          <source>There is also the single sequence \N, which matches a non-newline character. This is the same as the &quot;.&quot; metacharacter when &lt;code&gt;dotall&lt;/code&gt; is not set. Perl also uses \N to match characters by name, but PCRE does not support this.</source>
          <target state="translated">줄 바꾸기가 아닌 문자와 일치하는 단일 시퀀스 \ N도 있습니다. 이것은 &quot;.&quot;와 동일합니다. &lt;code&gt;dotall&lt;/code&gt; 이 설정되지 않은 경우 메타 문자 . Perl은 \ N을 사용하여 이름별로 문자를 일치 시키지만 PCRE는이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b98454e1dad347bf57900e7a0165181c58bc516a" translate="yes" xml:space="preserve">
          <source>There is always a process registered under the name of &lt;code&gt;user&lt;/code&gt;. This can be used for sending output to the user.</source>
          <target state="translated">항상 &lt;code&gt;user&lt;/code&gt; 이름으로 등록 된 프로세스가 있습니다 . 출력을 사용자에게 보내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48f05fa36ef8d48104e41cb6957499643b973e55" translate="yes" xml:space="preserve">
          <source>There is an important command to list the actual algorithms and their ordering: &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실제 알고리즘과 순서를 나열하는 중요한 명령이 있습니다 : &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d83f929c7ba80aeba27f85a0a055bddbdc902825" translate="yes" xml:space="preserve">
          <source>There is an information function for the types above:</source>
          <target state="translated">위 유형에 대한 정보 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dacb594bad469f1ce7f5caf10b3b3ec583858f47" translate="yes" xml:space="preserve">
          <source>There is an ordering, which is:</source>
          <target state="translated">다음과 같은 주문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bbb406addbf195bc5bf6f601577bdb5f7463970" translate="yes" xml:space="preserve">
          <source>There is another non-standard property, Xuc, which matches any character that can be represented by a Universal Character Name in C++ and other programming languages. These are the characters $, @, ` (grave accent), and all characters with Unicode code points &amp;gt;= U+00A0, except for the surrogates U+D800 to U+DFFF. Notice that most base (ASCII) characters are excluded. (Universal Character Names are of the form \uHHHH or \UHHHHHHHH, where H is a hexadecimal digit. Notice that the Xuc property does not match these sequences but the characters that they represent.)</source>
          <target state="translated">C ++ 및 기타 프로그래밍 언어에서 범용 문자 이름으로 표시 할 수있는 모든 문자와 일치하는 비표준 속성 인 Xuc가 있습니다. 문자 $, @,`(가중 악센트) 및 대리 문자 U + D800에서 U + DFFF를 제외한 유니 코드 코드 포인트&amp;gt; = U + 00A0 인 모든 문자입니다. 대부분의 기본 (ASCII) 문자는 제외됩니다. (범용 문자 이름은 \ uHHHH 또는 \ UHHHHHHHH 형식입니다. 여기서 H는 16 진수입니다. Xuc 속성은 이러한 시퀀스와 일치하지 않지만 해당 문자를 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="24db043e3e85ec5f96858860abaa48c0bebec77d" translate="yes" xml:space="preserve">
          <source>There is currently &lt;strong&gt;no&lt;/strong&gt; support for Windows.</source>
          <target state="translated">현재 Windows &lt;strong&gt;는&lt;/strong&gt; 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="01441ce6d74363dda8f15648c06b7b0537c64a86" translate="yes" xml:space="preserve">
          <source>There is however a utility module, &lt;code&gt;dist_util&lt;/code&gt;, which does most of the hard work of handling handshakes, cookies, timers, and ticking. Using &lt;code&gt;dist_util&lt;/code&gt; makes implementing a distribution module much easier and that is done in the example application.</source>
          <target state="translated">그러나 &lt;code&gt;dist_util&lt;/code&gt; 유틸리티 모듈이 있습니다.이 모듈 은 핸드 셰이크, 쿠키, 타이머 및 틱 을 처리하는 대부분의 어려운 작업을 수행합니다. &lt;code&gt;dist_util&lt;/code&gt; 을 사용하면 배포 모듈을 훨씬 쉽게 구현할 수 있으며 예제 응용 프로그램에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4ca5bc74ccdc1a7e5bdfd46cd1aa8fff1884417d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;rsh&lt;/code&gt; program on the computer.</source>
          <target state="translated">컴퓨터에 &lt;code&gt;rsh&lt;/code&gt; 프로그램 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="df2ff6a55b257f4164ad71e8f10123efe9394150" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;send&lt;/code&gt; call with a time-out option, use socket option &lt;code&gt;send_timeout&lt;/code&gt; if time-outs are desired. See section &lt;code&gt;&lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시간 종료 옵션이있는 &lt;code&gt;send&lt;/code&gt; 호출 이 없습니다 . 시간 종료가 필요한 경우 소켓 옵션 &lt;code&gt;send_timeout&lt;/code&gt; 을 사용하십시오 . 섹션을 참조하십시오 &lt;code&gt;&lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="788a001e209f8fbfb495d59e087ae4ffbefebb3f" translate="yes" xml:space="preserve">
          <source>There is no Boolean data type in Erlang. Instead the atoms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are used to denote Boolean values.</source>
          <target state="translated">Erlang에는 부울 데이터 유형이 없습니다. 대신 원자 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 는 부울 값을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37147d996eecd281a8ba511598164eac1e447d2f" translate="yes" xml:space="preserve">
          <source>There is no attempt to balance trees after deletions. As deletions do not increase the height of a tree, this should be OK.</source>
          <target state="translated">삭제 후 트리 균형을 조정하려는 시도는 없습니다. 삭제해도 트리의 높이가 증가하지 않으므로 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="caf2aa5b2cbffe36cef8b0ea41ca0022fd85db8a" translate="yes" xml:space="preserve">
          <source>There is no connection to the node where the process is located.</source>
          <target state="translated">프로세스가있는 노드에 연결되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b7a1543335bb44ae5cf0c88c1eac25c65cd7e3b" translate="yes" xml:space="preserve">
          <source>There is no difference between rows in a table and &lt;code&gt;Mnesia&lt;/code&gt; records. Both concepts are the same and are used interchangeably throughout this User's Guide.</source>
          <target state="translated">테이블의 행과 &lt;code&gt;Mnesia&lt;/code&gt; 레코드 에는 차이가 없습니다 . 두 개념은 동일하며이 사용 설명서 전체에서 호환 적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a1861aef615622b38a7ac58736c71ae81c27ee3" translate="yes" xml:space="preserve">
          <source>There is no guarantee of consistency in the returned list. Tables created or deleted by other processes &quot;during&quot; the &lt;code&gt;ets:all()&lt;/code&gt; call either are or are not included in the list. Only tables created/deleted &lt;strong&gt;before&lt;/strong&gt;&lt;code&gt;ets:all()&lt;/code&gt; is called are guaranteed to be included/excluded.</source>
          <target state="translated">리턴 된 목록에서 일관성을 보장하지 않습니다. &lt;code&gt;ets:all()&lt;/code&gt; 호출을 &quot;동안&quot;수행하는 동안 다른 프로세스에 의해 작성되거나 삭제 된 테이블 은 목록에 포함되거나 포함되지 않습니다. &lt;code&gt;ets:all()&lt;/code&gt; 이 호출 &lt;strong&gt;되기 전에&lt;/strong&gt; 생성 / 삭제 된 테이블 만 포함 / 제외가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="23cb6eb28b6463357c5d086be78e4c28d974313b" translate="yes" xml:space="preserve">
          <source>There is no guarantee that this function will return the same encoded representation for the same term.</source>
          <target state="translated">이 함수가 동일한 용어에 대해 동일한 인코딩 된 표현을 리턴한다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a78fbe3d9cb96a901b01d191391ac77c129ae95" translate="yes" xml:space="preserve">
          <source>There is no local function handler.</source>
          <target state="translated">로컬 함수 핸들러가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33d688593567ec97b98492916d41c5719d414cf7" translate="yes" xml:space="preserve">
          <source>There is no non-local function handler.</source>
          <target state="translated">로컬이 아닌 함수 핸들러가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e798f2b7954fbb8128c8deaa8091eb40c413ae4" translate="yes" xml:space="preserve">
          <source>There is no performance advantage of building (and using) a non-reentrant flex scanner over a reentrant flex scanner (if flex supports building such a scanner).</source>
          <target state="translated">재진입 플렉스 스캐너보다 비재 진성 플렉스 스캐너를 구축 (및 사용) 할 때의 성능 이점은 없습니다 (Flex가 그러한 스캐너 구축을 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="c626748bd3f9380817d9836ccd98f9458d1a0bc7" translate="yes" xml:space="preserve">
          <source>There is no space left on the device (if &lt;code&gt;write&lt;/code&gt; access was specified).</source>
          <target state="translated">장치에 남은 공간이 없습니다 ( &lt;code&gt;write&lt;/code&gt; 액세스가 지정된 경우).</target>
        </trans-unit>
        <trans-unit id="2a40eb7111de1638bc04c597cd24719439c9fafa" translate="yes" xml:space="preserve">
          <source>There is not enough memory for the contents of the file.</source>
          <target state="translated">파일 내용을위한 메모리가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="68171e010dd69d363d2cc2e5daa9281d1e1ce0d2" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;start_ssl.boot&lt;/code&gt; file in the current directory.</source>
          <target state="translated">편지가 &lt;code&gt;start_ssl.boot&lt;/code&gt; 의 현재 디렉토리에있는 파일.</target>
        </trans-unit>
        <trans-unit id="894f17b55577d9c71ce16f3c9d0e450cd2e02a30" translate="yes" xml:space="preserve">
          <source>There is often a need to configure some other exec evaluator to tailor the input language or restrict the possible functions to call. There are two ways of doing this which will be shown with examples below. See &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">입력 언어를 조정하거나 호출 할 수있는 기능을 제한하기 위해 다른 실행 평가자를 구성해야하는 경우가 종종 있습니다. 이를 수행하는 두 가지 방법이 있으며 아래 예제와 함께 표시됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec_daemon_option()&lt;/a&gt;&lt;/code&gt; )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e42ae9f7b3d65e666833c9febb65491e9e97dc0" translate="yes" xml:space="preserve">
          <source>There is one &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; that is automatically cancelled by any event. Note that &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;inserted&lt;/a&gt;&lt;/code&gt; events cancel this time-out just as external events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Out&lt;/a&gt;&lt;/code&gt; 의해 자동으로 취소되는 하나의 이벤트 타임 아웃 이 있습니다. 참고 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed &lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;inserted&lt;/a&gt;&lt;/code&gt; 이벤트가 단지 외부 이벤트로이 시간 제한을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94bfc7e6754ca3ea8a6de36cb806cf966b369f7" translate="yes" xml:space="preserve">
          <source>There is one &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; that is automatically cancelled by a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;상태 변경에&lt;/strong&gt; 의해 자동으로 취소되는 &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; 이 하나 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="50c0d56eee94679c32dbfb957c35b23a7c464276" translate="yes" xml:space="preserve">
          <source>There is one exception to the rule that a variable that is as size must be previously bound. It is possible to match and bind a variable, and use it as a size within the the same binary pattern. For example:</source>
          <target state="translated">크기에 해당하는 변수를 미리 바인딩해야한다는 규칙에 대한 한 가지 예외가 있습니다. 변수를 일치 및 바인딩하고 동일한 이진 패턴 내에서 크기로 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="982e604305f35dec38eb296c4a9c3f70aede4f41" translate="yes" xml:space="preserve">
          <source>There is one exception to the rule that the tuple is copied. If the compiler clearly can see that destructively updating the tuple would give the same result as if the tuple was copied, the call to &lt;code&gt;setelement/3&lt;/code&gt; is replaced with a special destructive &lt;code&gt;setelement&lt;/code&gt; instruction. In the following code sequence, the first &lt;code&gt;setelement/3&lt;/code&gt; call copies the tuple and modifies the ninth element:</source>
          <target state="translated">튜플이 복사되는 규칙에는 예외가 있습니다. 컴파일러에서 튜플을 파괴적으로 업데이트하면 튜플을 복사 한 것과 동일한 결과를 얻을 수 있음을 분명히 알 수있는 경우 &lt;code&gt;setelement/3&lt;/code&gt; 에 대한 호출 은 특수한 파괴적인 &lt;code&gt;setelement&lt;/code&gt; 명령으로 대체됩니다 . 다음 코드 시퀀스에서 첫 번째 &lt;code&gt;setelement/3&lt;/code&gt; 호출은 튜플을 복사하고 아홉 번째 요소를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="961aa3429c05e4421a44dd6baffbd85ca75ea3dd" translate="yes" xml:space="preserve">
          <source>There is one exception. &lt;strong&gt;Any&lt;/strong&gt; tuple containing the atom &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; will, in this context, be considered belonging to this application, and may be processed by the agent.</source>
          <target state="translated">한 가지 예외가 있습니다. &lt;strong&gt;상관&lt;/strong&gt; 원자 함유 튜플 &lt;code&gt;snmpa_default_notification_extra_info&lt;/code&gt; 는 이러한 맥락에서,이 응용 프로그램에 속하는 것으로 간주 될 것이고, 에이전트에 의해 처리 될 수있다.</target>
        </trans-unit>
        <trans-unit id="fb83be6c2e955864087572066b00b5e6d77bfed6" translate="yes" xml:space="preserve">
          <source>There is seldom or never any need to use this BIF as other processes have a chance to run in another scheduler thread anyway. Using this BIF without a thorough grasp of how the scheduler works can cause performance degradation.</source>
          <target state="translated">다른 프로세스가 다른 스케줄러 스레드에서 실행될 가능성이 있기 때문에이 BIF를 사용할 필요가 거의 없거나 전혀 없습니다. 스케줄러의 작동 방식을 완전히 파악하지 않고이 BIF를 사용하면 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672d0cbc29fa0c58939d66ddc95453e76a3b8e80" translate="yes" xml:space="preserve">
          <source>There is some support for reading and printing records in the shell. During compilation record expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents a record, and the record definitions used by the compiler are unavailable at runtime. So, to read the record syntax and print tuples as records when possible, record definitions must be maintained by the shell itself.</source>
          <target state="translated">쉘에서 레코드를 읽고 인쇄하기위한 일부 지원이 있습니다. 컴파일 레코드 표현식은 튜플 표현식으로 변환됩니다. 런타임에 튜플이 레코드를 나타내는 지 여부는 알 수 없으며 런타임시 컴파일러가 사용하는 레코드 정의를 사용할 수 없습니다. 따라서 가능한 경우 레코드 구문을 읽고 튜플을 레코드로 인쇄하려면 레코드 정의를 쉘 자체에서 유지 보수해야합니다.</target>
        </trans-unit>
        <trans-unit id="f75ce9844eb4486f4e4b30867918c3e4b3911386" translate="yes" xml:space="preserve">
          <source>There is support for this in xmerl by the &quot;simple-form&quot; format. You can put your data in a simple-form data structure and feed it into &lt;code&gt;xmerl:export_simple(Content,Callback,RootAttributes)&lt;/code&gt;. Content may be a mixture of simple-form and xmerl records as xmlElement and xmlText.</source>
          <target state="translated">&quot;간단한 형식&quot;형식으로 xmerl에서이를 지원합니다. 간단한 형식의 데이터 구조에 데이터를 넣고 &lt;code&gt;xmerl:export_simple(Content,Callback,RootAttributes)&lt;/code&gt; 피드 할 수 있습니다. 내용은 xmlElement 및 xmlText와 같은 단순 형식 및 xmerl 레코드의 혼합 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3edc744598fcc737ca378c211064f17614a02e99" translate="yes" xml:space="preserve">
          <source>There is usually not much difference between a body-recursive list function and tail-recursive function that reverses the list at the end. Therefore, concentrate on writing beautiful code and forget about the performance of your list functions. In the time-critical parts of your code (and only there), &lt;strong&gt;measure&lt;/strong&gt; before rewriting your code.</source>
          <target state="translated">일반적으로 본문 재귀 목록 함수와 끝 재귀 목록을 반전시키는 꼬리 재귀 함수 사이에는 큰 차이가 없습니다. 따라서 아름다운 코드 작성에 집중하고 목록 기능의 성능을 잊어 버리십시오. 코드의 시간 결정적인 부분에서 (그리고 거기에서만) 코드를 다시 작성하기 전에 &lt;strong&gt;측정&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="175f3e4c19799f026ed2193325a08cc18afee059" translate="yes" xml:space="preserve">
          <source>There may be a tuple &lt;code&gt;{saved, N}&lt;/code&gt; in the return value, if the MatchSpec is other than []. The integer &lt;code&gt;N&lt;/code&gt; may then be used in subsequent calls to this function and will stand as an &quot;alias&quot; for the given expression. There are also a couple of built-in aliases for common expressions, see &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; below for details.</source>
          <target state="translated">MatchSpec이 [] 이외의 경우 리턴 값에 튜플 &lt;code&gt;{saved, N}&lt;/code&gt; 이있을 수 있습니다 . 정수 &lt;code&gt;N&lt;/code&gt; 은이 함수에 대한 후속 호출에서 사용될 수 있으며 주어진 표현식에 대해 &quot;별칭&quot;으로 표시됩니다. 공통 표현식에 대한 몇 개의 내장 별명이 있습니다. 자세한 내용은 아래 &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="439af89f2aedc3e47e38162227f9dad598919f3e" translate="yes" xml:space="preserve">
          <source>There may be label characters before or/and after the wildcard. For example: &lt;code&gt;a*d.example.com&lt;/code&gt; matches &lt;code&gt;abcd.example.com&lt;/code&gt; and &lt;code&gt;ad.example.com&lt;/code&gt;, but not &lt;code&gt;ab.cd.example.com&lt;/code&gt;.</source>
          <target state="translated">와일드 카드 앞뒤에 레이블 문자가있을 수 있습니다. 예를 들어 &lt;code&gt;a*d.example.com&lt;/code&gt; 일치 &lt;code&gt;abcd.example.com&lt;/code&gt; 및 &lt;code&gt;ad.example.com&lt;/code&gt; ,하지만 &lt;code&gt;ab.cd.example.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2139ae87af2ed5426b73952d31a1c1937f8c40d6" translate="yes" xml:space="preserve">
          <source>There may only be one wildcard character and that is in the first label, for example: &lt;code&gt;*.example.com&lt;/code&gt;. This matches &lt;code&gt;foo.example.com&lt;/code&gt; but neither &lt;code&gt;example.com&lt;/code&gt; nor &lt;code&gt;foo.bar.example.com&lt;/code&gt;.</source>
          <target state="translated">와일드 카드 문자는 하나만있을 수 있으며 첫 번째 레이블에 있습니다 (예 : &lt;code&gt;*.example.com&lt;/code&gt; ) . &lt;code&gt;foo.example.com&lt;/code&gt; 과 일치 하지만 &lt;code&gt;example.com&lt;/code&gt; 또는 &lt;code&gt;foo.bar.example.com&lt;/code&gt; 과는 일치 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86d38102deb0f5be31f5b5646bc1d23391a9239c" translate="yes" xml:space="preserve">
          <source>There must be no calls to another function in between the calls to &lt;code&gt;setelement/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setelement/3&lt;/code&gt; 에 대한 호출 사이에 다른 함수에 대한 호출이 없어야 합니다.</target>
        </trans-unit>
        <trans-unit id="4379219137f82ad3d5f85ec7793035a5647a5347" translate="yes" xml:space="preserve">
          <source>There were a number of problems in the implementation of the now undocumented algorithms, which is why they are deprecated. The new algorithms are a bit slower but do not have these problems:</source>
          <target state="translated">현재 문서화되지 않은 알고리즘을 구현하는 데 많은 문제가 있었기 때문에 더 이상 사용되지 않습니다. 새로운 알고리즘은 약간 느리지 만 다음과 같은 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8702fd6526747089f634470b6b71a67546749e1" translate="yes" xml:space="preserve">
          <source>There will be three almost identical copies of the code. Given the size of the code, that could be too high cost to pay.</source>
          <target state="translated">거의 동일한 코드 사본 3 개가 있습니다. 코드의 크기를 고려할 때 지불하기에는 너무 많은 비용이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94edc56fd4c7a685211aeb70698042dc2126321d" translate="yes" xml:space="preserve">
          <source>Therefor in the tests, binary codecs are tested with four different encoding configs to determine exactly how the different options effect the performance: with transformation and without driver ([]), without transformation and without driver ([native]), with transformation and with driver ([driver]) and finally without transformation and with driver ([driver,native]).</source>
          <target state="translated">따라서 테스트에서 이진 코덱은 변환 및 드라이버 없음 ([]), 변환 없음 및 드라이버 없음 ([native]), 변형 있음 및 변형 없음 등 다양한 옵션이 성능에 미치는 영향을 정확히 결정하기 위해 4 가지 인코딩 구성으로 테스트됩니다. 드라이버 ([드라이버])로 변환하지 않고 드라이버로 ([드라이버, 기본])</target>
        </trans-unit>
        <trans-unit id="243f02477e6596c18fd3c62ae8ed5666e8ef7097" translate="yes" xml:space="preserve">
          <source>Therefore &lt;code&gt;my_binary_to_list/1&lt;/code&gt; calls itself with the match context instead of with a sub binary. The instruction that initializes the matching operation basically does nothing when it sees that it was passed a match context instead of a binary.</source>
          <target state="translated">따라서 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 은 하위 이진 대신 일치 컨텍스트를 사용하여 자신을 호출합니다. 일치 작업을 초기화하는 명령은 기본적으로 이진 대신 일치 컨텍스트가 전달 된 것을 알 때 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8aae9f4ba098f331d48e185f24980e7223ed137" translate="yes" xml:space="preserve">
          <source>Therefore it is not enough to only recompile drivers written with version management for pre R15B types; the types must be changed in the driver suggesting other rewrites, especially regarding size variables. &lt;strong&gt;Investigate all warnings when recompiling.&lt;/strong&gt;</source>
          <target state="translated">따라서 R15B 이전 버전의 버전 관리로 작성된 드라이버 만 재 컴파일하는 것만으로는 충분하지 않습니다. 드라이버에서 유형을 변경하여 특히 크기 변수와 관련하여 다른 다시 쓰기를 제안해야합니다. &lt;strong&gt;다시 컴파일 할 때 모든 경고를 조사하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8451cc048f68604a8e6f8398bb63201daf908b58" translate="yes" xml:space="preserve">
          <source>Therefore the following call:</source>
          <target state="translated">따라서 다음과 같은 호출이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cac855cec75c6e990039722ee7ddfc227fe28ddc" translate="yes" xml:space="preserve">
          <source>Therefore the old api (see next section) is kept for now but internally implemented with new primitives.</source>
          <target state="translated">따라서 이전 API (다음 섹션 참조)는 현재 유지되지만 내부적으로는 새로운 기본 형식으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f4080dae433bd65ba4f78438abd73a9dcd511aa9" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;after_zero/1&lt;/code&gt; builds one match context and one sub binary (assuming it is passed a binary that contains a zero byte).</source>
          <target state="translated">따라서 &lt;code&gt;after_zero/1&lt;/code&gt; 은 하나의 일치 컨텍스트와 하나의 하위 2 진을 빌드합니다 (0 바이트가 포함 된 2 진을 전달한다고 가정).</target>
        </trans-unit>
        <trans-unit id="9e7c3bfd969d68d13350f73c07ad4f037893dc43" translate="yes" xml:space="preserve">
          <source>Therefore, certain operations on a binary mark it so that any future append operation will be forced to copy the binary. In most cases, the binary object will be shrunk at the same time to reclaim the extra space allocated for growing.</source>
          <target state="translated">따라서 이진에 대한 특정 작업은 나중에 추가 작업이 이진을 복사하도록 표시합니다. 대부분의 경우, 이진 오브젝트는 동시에 증가되어 할당 된 추가 공간을 회수합니다.</target>
        </trans-unit>
        <trans-unit id="1bd6b474df592c0536d4daa44f7c1bfcafdb1fcf" translate="yes" xml:space="preserve">
          <source>Therefore, converting arbitrary input strings to atoms can be dangerous in a system that runs continuously. If only certain well-defined atoms are allowed as input, &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; can be used to guard against a denial-of-service attack. (All atoms that are allowed must have been created earlier, for example, by simply using all of them in a module and loading that module.)</source>
          <target state="translated">따라서 임의의 입력 문자열을 원자로 변환하는 것은 지속적으로 실행되는 시스템에서 위험 할 수 있습니다. 잘 정의 된 특정 원자 만 입력으로 허용되는 경우 &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; 을 사용하여 서비스 거부 공격으로부터 보호 할 수 있습니다. (허용되는 모든 원자는 예를 들어 단순히 모듈에서 모두 사용하고 해당 모듈을로드하여 이전에 생성 된 것이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="92e119795a21e7955d1c30f27f5a24fcb874b645" translate="yes" xml:space="preserve">
          <source>Therefore, converting arbitrary input strings to atoms can be dangerous in a system that runs continuously. If only certain well-defined atoms are allowed as input, &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; can be used to to guard against a denial-of-service attack. (All atoms that are allowed must have been created earlier, for example, by simply using all of them in a module and loading that module.)</source>
          <target state="translated">따라서 연속적으로 실행되는 시스템에서 임의의 입력 문자열을 원자로 변환하는 것은 위험 할 수 있습니다. 잘 정의 된 특정 원자 만 입력으로 허용되는 경우 &lt;code&gt;list_to_existing_atom/1&lt;/code&gt; 을 사용하여 서비스 거부 공격을 방지 할 수 있습니다. (예를 들어, 모듈에서 모든 원자를 사용하고 해당 모듈을로드하여 허용되는 모든 원자가 이전에 작성되어 있어야합니다.)</target>
        </trans-unit>
        <trans-unit id="0afb1e74cde0028071d12983306cbaa758aaee89" translate="yes" xml:space="preserve">
          <source>Therefore, if you want to send both a pre-existing binary and some extra data to a driver without copying the binary, you must call &lt;code&gt;port_control/3&lt;/code&gt; twice; once with the binary and once with the extra data. However, that will only work if there is only one process communicating with the port (because otherwise another process can call the driver in-between the calls).</source>
          <target state="translated">따라서 바이너리를 복사하지 않고 기존 바이너리와 일부 추가 데이터를 드라이버로 보내려면 &lt;code&gt;port_control/3&lt;/code&gt; 을 두 번 호출해야합니다 . 이진으로 한 번 추가 데이터로 한 번. 그러나 포트와 통신하는 프로세스가 하나만있는 경우에만 작동합니다 (다른 프로세스가 호출 사이에서 드라이버를 호출 할 수 있기 때문).</target>
        </trans-unit>
        <trans-unit id="e1058e576d020e27852d4dd63c7e76baf9cb4f3e" translate="yes" xml:space="preserve">
          <source>Therefore, setting this option to &lt;code&gt;true&lt;/code&gt; when creating a socket never fails, except possibly on a platform where you have customized the kernel to only allow &lt;code&gt;false&lt;/code&gt;, which can be doable (but awkward) on, for example, OpenBSD.</source>
          <target state="translated">따라서 소켓을 만들 때이 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 실패하지 않습니다. 커널을 사용자 지정하여 &lt;code&gt;false&lt;/code&gt; 만 허용하도록 커널을 사용자 지정한 플랫폼 (예 : OpenBSD에서 가능하지만 어색 할 수 있음)은 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="fa03132e315d50b20abbcf96beb07d6fa4be6ede" translate="yes" xml:space="preserve">
          <source>Therefore, the following example is a valid Erlang instance of type 'Oid':</source>
          <target state="translated">따라서 다음 예제는 'Oid'유형의 유효한 Erlang 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3d5269f23f196ee210eee4acf06c960dda47d1df" translate="yes" xml:space="preserve">
          <source>These &lt;strong&gt;transition actions&lt;/strong&gt; can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; when it is called with an &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;strong&gt;전환 작업&lt;/strong&gt; 은 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 될 때 &lt;strong&gt;상태 콜백&lt;/strong&gt; 에서, &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 하거나 enter_loop / 5,6 에 제공하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02bc7790d560067efd73b09c97b9c65eaaef9ebf" translate="yes" xml:space="preserve">
          <source>These &lt;strong&gt;transition actions&lt;/strong&gt; can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;strong&gt;전환 작업&lt;/strong&gt; 은 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 에서 반환 하거나 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에 제공하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00c80e549287bbb93dadd392554fafbbbc24b24" translate="yes" xml:space="preserve">
          <source>These Erlang variables are now bound to valid instances of ASN.1 defined types. This style of value can be passed directly to the encoder for transformation into a series of bytes.</source>
          <target state="translated">이 Erlang 변수는 이제 ASN.1 정의 유형의 유효한 인스턴스에 바인딩됩니다. 이 스타일 값은 일련의 바이트로 변환하기 위해 인코더로 직접 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f0a03fdc3b62893e944bf31939f2cfaecae96b7" translate="yes" xml:space="preserve">
          <source>These MIBs are not loaded by default.</source>
          <target state="translated">이러한 MIB는 기본적으로로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ec64a39b7d4c54784cd2ad56d92c227d3e17b9a" translate="yes" xml:space="preserve">
          <source>These MIBs contain the &lt;code&gt;snmp-&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt; groups from MIB-II which is defined in RFC1213 (STANDARD-MIB) or RFC1907 (SNMPv2-MIB). They are implemented in the &lt;code&gt;snmp_standard_mib&lt;/code&gt; module. The &lt;code&gt;snmp&lt;/code&gt; counters all reside in volatile memory and the &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;snmpEnableAuthenTraps&lt;/code&gt; variables in persistent memory, using the SNMP built-in database (refer to the Reference Manual, section &lt;code&gt;snmp&lt;/code&gt;, module &lt;code&gt;snmpa_local_db&lt;/code&gt; for more details).</source>
          <target state="translated">이들의 MIB에 포함 &lt;code&gt;snmp-&lt;/code&gt; 및 &lt;code&gt;system&lt;/code&gt; RFC1213 (STANDARD-MIB) 또는 RFC1907 (은 SNMPv2-MIB)에서 정의 된 MIB-II의 그룹. 이들은 &lt;code&gt;snmp_standard_mib&lt;/code&gt; 모듈 에서 구현됩니다 . &lt;code&gt;snmp&lt;/code&gt; 카운터 휘발성 메모리에있는 모든 상주하며 &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;snmpEnableAuthenTraps&lt;/code&gt; 는 SNMP를 사용하여 영구 메모리에 변수는 내장 된 데이터베이스 (수동 참조, 섹션을 참조 &lt;code&gt;snmp&lt;/code&gt; 모듈 &lt;code&gt;snmpa_local_db&lt;/code&gt; 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="e67a93a99a7e370f0477c918676f4cf69ff8699a" translate="yes" xml:space="preserve">
          <source>These are a few  facts about the predefined variables (the set operators &lt;code id=&quot;simple_facts&quot;&gt;+&lt;/code&gt; (union) and &lt;code&gt;-&lt;/code&gt; (difference) as well as the cast operator &lt;code&gt;(&lt;/code&gt;Type&lt;code&gt;)&lt;/code&gt; are described below):</source>
          <target state="translated">다음은 사전 정의 된 변수 (설정 연산자 &lt;code id=&quot;simple_facts&quot;&gt;+&lt;/code&gt; (연합) 및 &lt;code&gt;-&lt;/code&gt; (차이) 및 캐스트 연산자 &lt;code&gt;(&lt;/code&gt; Type &lt;code&gt;)&lt;/code&gt; 에 대한 몇 가지 사실)에 대한 몇 가지 사실입니다 .</target>
        </trans-unit>
        <trans-unit id="b41fa5eb73a7806528a8254a84f2a17ca0515977" translate="yes" xml:space="preserve">
          <source>These are deprecated because the annoying double meaning of the name servers/time-out argument, and because they have no decent place for a resolver options list.</source>
          <target state="translated">이름 서버 / 시간 초과 인수의 성가신 이중 의미와 리졸버 옵션 목록을위한 적절한 위치가 없기 때문에 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60cf421719fdc337d9a96b28085e43063192f175" translate="yes" xml:space="preserve">
          <source>These are only recognized by Erlang nodes, not by hidden nodes.</source>
          <target state="translated">이들은 숨겨진 노드가 아닌 Erlang 노드 만 인식합니다.</target>
        </trans-unit>
        <trans-unit id="3295d73ec7e802c1f14b2c332abe46ab60bbbcd5" translate="yes" xml:space="preserve">
          <source>These are options effecting discovery &lt;code&gt;originating&lt;/code&gt; in this agent.</source>
          <target state="translated">다음은 검색 초래 옵션입니다 &lt;code&gt;originating&lt;/code&gt; 이 에이전트에.</target>
        </trans-unit>
        <trans-unit id="e5c03f74465d648a5862f1fc098e9296ee6d6bfb" translate="yes" xml:space="preserve">
          <source>These are options effecting discovery &lt;code&gt;terminating&lt;/code&gt; in this agent (i.e. initiated by a manager).</source>
          <target state="translated">이 에이전트에서 감지를 &lt;code&gt;terminating&lt;/code&gt; 하는 데 영향을주는 옵션입니다 (즉, 관리자에 의해 시작됨).</target>
        </trans-unit>
        <trans-unit id="1fced9f787994ac75d8652655a2b16fb12a62921" translate="yes" xml:space="preserve">
          <source>These are read-only and cannot be changed in runtime.</source>
          <target state="translated">이들은 읽기 전용이며 런타임에 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="787f23076fd9f126101a07d4716e5cdc858d0ff6" translate="yes" xml:space="preserve">
          <source>These are the supported entries and their value types:</source>
          <target state="translated">다음은 지원되는 항목과 해당 값 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b54f8e7581e4b11655c99aa67637a8c43ce11aa5" translate="yes" xml:space="preserve">
          <source>These are the tools you need in order to unpack and build Erlang/OTP.</source>
          <target state="translated">Erlang / OTP의 압축을 풀고 빌드하는 데 필요한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="c2b3c62dddfeb24a018a3dfcfce0b24364d8a6b9" translate="yes" xml:space="preserve">
          <source>These are to behave as &lt;code&gt;{get_until, latin1, Prompt, Module, Function, ExtraArgs}&lt;/code&gt;, &lt;code&gt;{get_chars, latin1, Prompt, N}&lt;/code&gt;, and &lt;code&gt;{get_line, latin1, Prompt}&lt;/code&gt;, respectively.</source>
          <target state="translated">이들은 각각 &lt;code&gt;{get_until, latin1, Prompt, Module, Function, ExtraArgs}&lt;/code&gt; , &lt;code&gt;{get_chars, latin1, Prompt, N}&lt;/code&gt; 및 &lt;code&gt;{get_line, latin1, Prompt}&lt;/code&gt; 로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="c1e4b991ff6fe7d1f2495f5a84c72e419f949594" translate="yes" xml:space="preserve">
          <source>These are to behave as &lt;code&gt;{put_chars, latin1, Characters}&lt;/code&gt; and &lt;code&gt;{put_chars, latin1, Module, Function, Args}&lt;/code&gt;, respectively.</source>
          <target state="translated">이들은 각각 &lt;code&gt;{put_chars, latin1, Characters}&lt;/code&gt; 및 &lt;code&gt;{put_chars, latin1, Module, Function, Args}&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="187481b8c7b89208071bec932d3843dbbff8e5a2" translate="yes" xml:space="preserve">
          <source>These are two different SMP performance monitoring tool(s).</source>
          <target state="translated">이들은 서로 다른 두 가지 SMP 성능 모니터링 도구입니다.</target>
        </trans-unit>
        <trans-unit id="8edbe321eae68320d9237c6f46dbbe92c6832bc5" translate="yes" xml:space="preserve">
          <source>These are variants of &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt; where you can supply your own message term &lt;code&gt;msg&lt;/code&gt; that will be sent to the process instead of the predefined tuple &lt;code&gt;{select,_,_,_}.&lt;/code&gt;</source>
          <target state="translated">이들은 미리 정의 된 튜플 &lt;code&gt;{select,_,_,_}.&lt;/code&gt; 대신 프로세스에 전송 될 고유 한 메시지 용어 &lt;code&gt;msg&lt;/code&gt; 를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="4a7d9dd0e596b5ce481a5779ed708189763b4369" translate="yes" xml:space="preserve">
          <source>These behaviors occur regardless if the subpattern is called recursively. The treatment of subroutines in Perl is different in some cases.</source>
          <target state="translated">하위 패턴이 재귀 적으로 호출되는지 여부에 관계없이 이러한 동작이 발생합니다. Perl에서 서브 루틴의 처리는 경우에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4ec49381162072262ed7e981970a8f6edfbd0ee9" translate="yes" xml:space="preserve">
          <source>These books are highly recommended as a start for learning Erlang.</source>
          <target state="translated">이 책들은 Erlang을 배우기위한 시작으로 적극 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="f21525376606a80acbcf6dfcd0372134852c9de3" translate="yes" xml:space="preserve">
          <source>These callback functions are called from local and non-local evaluation function handlers, described in the &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval&lt;/a&gt;&lt;/code&gt; manual page. (Arguments in &lt;code&gt;ArgList&lt;/code&gt; are evaluated before the callback functions are called.)</source>
          <target state="translated">이 콜백 함수는 &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지에 설명 된 로컬 및 비 로컬 평가 함수 핸들러에서 호출 됩니다. 콜백 함수가 호출되기 전에 &lt;code&gt;ArgList&lt;/code&gt; 의 인수 가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="0717b31aef17edf30fcfa1ecdd0c63f7b41ab7a8" translate="yes" xml:space="preserve">
          <source>These case switches only allow &lt;code&gt;?Q(...)&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; as clause patterns, and the guards may contain any expressions, not just Erlang guard expressions.</source>
          <target state="translated">이러한 경우 스위치는 &lt;code&gt;?Q(...)&lt;/code&gt; 또는 &lt;code&gt;_&lt;/code&gt; as 절 패턴 만 허용 하며, 가드에는 Erlang 가드 표현식뿐만 아니라 모든 표현식이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b82509cdccdd98b3f35ff2498648839db3e7e6d5" translate="yes" xml:space="preserve">
          <source>These changes are essential not to crash the emulator or worse cause malfunction. Without them a driver can return garbage in the high 32 bits to the emulator, causing it to build a huge result from random bytes, either crashing on memory allocation or succeeding with a random result from the driver call.</source>
          <target state="translated">이러한 변경은 에뮬레이터에 충돌을 일으키거나 오작동을 유발하지 않기 위해 필수적입니다. 그것들이 없으면 드라이버는 높은 32 비트의 가비지를 에뮬레이터에 반환하여 메모리 할당에서 충돌하거나 드라이버 호출의 임의 결과로 인해 임의 바이트에서 큰 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="573248e1d06102f3107f0a34b228df99492a4b03" translate="yes" xml:space="preserve">
          <source>These choices depend a lot on your problem domain. If you don't have real time monitoring and ability to fix problems quickly, for example in an embedded system, you might want to accept at most one restart per minute before the supervisor should give up and escalate to the next level to try to clear the error automatically. On the other hand, if it is more important that you keep trying even at a high failure rate, you might want a sustained rate of as much as 1-2 restarts per second.</source>
          <target state="translated">이러한 선택은 문제 영역에 따라 다릅니다. 실시간 모니터링 및 내장형 시스템과 같은 문제를 신속하게 해결할 수있는 능력이없는 경우, 관리자가 분당 최대 한 번의 재시작을 수락하여 감독자가 포기하고 다음 단계로 이관해야합니다. 오류가 자동으로 발생합니다. 반면, 높은 실패율로 계속 시도하는 것이 더 중요한 경우 초당 1-2 회의 재시작 속도를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc39d5ee560666c19b1d761a7fa1de1841363b5" translate="yes" xml:space="preserve">
          <source>These commands are only added for convenience, the normal way to manipulate the state of a service is through the control panels services applet.</source>
          <target state="translated">이러한 명령은 편의를 위해서만 추가되며, 서비스 상태를 조작하는 일반적인 방법은 제어판 서비스 애플릿을 통하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0bb49d0ba352c03c469accf5e7d24180534a7f3" translate="yes" xml:space="preserve">
          <source>These constructs makes it possible to define open types, that is, values of that type can be of any ASN.1 type. Also, relationships can be defined between different types and values, as classes can hold types, values, objects, object sets, and other classes in their fields. A class can be defined in ASN.1 as follows:</source>
          <target state="translated">이러한 구성을 통해 개방형, 즉 해당 유형의 값을 ASN.1 유형으로 정의 할 수 있습니다. 또한 클래스는 유형, 값, 객체, 객체 세트 및 기타 클래스를 필드에 보유 할 수 있으므로 다른 유형과 값 사이의 관계를 정의 할 수 있습니다. 클래스는 다음과 같이 ASN.1에서 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="befa22022ba0fc273ee1c740958946648b1b19ef" translate="yes" xml:space="preserve">
          <source>These data types are described in the documentation for the &lt;code&gt;SNMP&lt;/code&gt; application.</source>
          <target state="translated">이러한 데이터 유형은 &lt;code&gt;SNMP&lt;/code&gt; 응용 프로그램 설명서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7607e5152380b649a4dfea1427608d47b7252b27" translate="yes" xml:space="preserve">
          <source>These declarations mean that &lt;code&gt;'='&lt;/code&gt; is defined as a &lt;code&gt;right associative binary&lt;/code&gt; operator with precedence 100, &lt;code&gt;'=='&lt;/code&gt; and &lt;code&gt;'=/='&lt;/code&gt; are operators with &lt;code&gt;no associativity&lt;/code&gt;, &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt; are &lt;code&gt;left associative binary&lt;/code&gt; operators, where &lt;code&gt;'*'&lt;/code&gt; takes precedence over &lt;code&gt;'+'&lt;/code&gt; (the normal case), and &lt;code&gt;'-'&lt;/code&gt; is a &lt;code&gt;unary&lt;/code&gt; operator of higher precedence than &lt;code&gt;'*'&lt;/code&gt;. The fact that '==' has no associativity means that an expression like &lt;code&gt;a == b == c&lt;/code&gt; is considered a syntax error.</source>
          <target state="translated">이러한 선언 의미 &lt;code&gt;'='&lt;/code&gt; A와 정의 &lt;code&gt;right associative binary&lt;/code&gt; 우선 100 연산자 &lt;code&gt;'=='&lt;/code&gt; 및 &lt;code&gt;'=/='&lt;/code&gt; 와 연산자이다 &lt;code&gt;no associativity&lt;/code&gt; , &lt;code&gt;'+'&lt;/code&gt; 및 &lt;code&gt;'*'&lt;/code&gt; 이 된다 &lt;code&gt;left associative binary&lt;/code&gt; , 사업자 여기서 &lt;code&gt;'*'&lt;/code&gt; 는 &lt;code&gt;'+'&lt;/code&gt; (일반적인 경우) 보다 우선 하며 &lt;code&gt;'-'&lt;/code&gt; 는 &lt;code&gt;'*'&lt;/code&gt; 보다 우선 순위가 높은 &lt;code&gt;unary&lt;/code&gt; 연산자입니다 . '=='에 연관성이 없다는 사실은 &lt;code&gt;a == b == c&lt;/code&gt; 와 같은 표현식 이 구문 오류로 간주 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c79b2e48d3b3c9cd539a4e7c436d24545530e8a9" translate="yes" xml:space="preserve">
          <source>These events, of course, need to occur ordered to other memory operations. The operation of determining this begins by initiating the thread progress operation. The thread that initiated the thread progress operation after this poll for the completion of the operation. Both of these events must occur at least once &lt;strong&gt;after&lt;/strong&gt; the thread progress operation has been initiated, and at least once &lt;strong&gt;before&lt;/strong&gt; the operation has completed in each managed thread. This is ordered using communication via memory which makes it possible to draw conclusion about the memory state after the thread progress operation has completed. Lets call the progress made from initiation to comletion for &quot;thread progress&quot;.</source>
          <target state="translated">물론 이러한 이벤트는 다른 메모리 작업에 순서대로 발생해야합니다. 이를 결정하는 작업은 스레드 진행 작업을 시작하여 시작됩니다. 작업 완료를 위해이 폴링 후에 스레드 진행 작업을 시작한 스레드입니다. 이 두 이벤트는 스레드 진행 작업이 시작된 &lt;strong&gt;후&lt;/strong&gt; 한 번 이상 발생해야 하며 각 관리 스레드에서 작업이 완료 &lt;strong&gt;되기 전에&lt;/strong&gt; 한 번 이상 발생해야합니다 . 이것은 스레드 진행 작업이 완료된 후 메모리 상태에 대한 결론을 도출 할 수 있도록 메모리를 통한 통신을 사용하여 정렬됩니다. 시작부터 완료까지의 진행률을 &quot;스레드 진행률&quot;에 대해 호출합니다.</target>
        </trans-unit>
        <trans-unit id="751552b3c6781f0e0e58af55485f1a42f3adbfcd" translate="yes" xml:space="preserve">
          <source>These function simply fetch the appropriate field from the &lt;code&gt;ec&lt;/code&gt; structure. Read the field directly will probably be safe for a long time, so these functions are not really needed.</source>
          <target state="translated">이 함수는 단순히 &lt;code&gt;ec&lt;/code&gt; 구조 에서 적절한 필드를 가져옵니다 . 필드를 직접 읽으면 오랫동안 안전 할 수 있으므로 이러한 기능은 실제로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04605460ad130e7237d6de8796f71c1d7f55abcb" translate="yes" xml:space="preserve">
          <source>These functions are all called in the same manner as &lt;code&gt;printf()&lt;/code&gt;, that is, with a string containing format specifiers followed by a list of corresponding arguments. All output from these functions is to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">이러한 함수는 모두 &lt;code&gt;printf()&lt;/code&gt; 와 동일한 방식으로 , 즉 형식 지정자를 포함하는 문자열과 해당 인수 목록이 차례로 호출됩니다. 이 함수의 모든 출력은 &lt;code&gt;stderr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52fc81f0ba111d2acbf6995d34d870aacab348cf" translate="yes" xml:space="preserve">
          <source>These functions are called for each object in an MIB when the MIB is unloaded or loaded, respectively.</source>
          <target state="translated">MIB가 언로드되거나로드 될 때 MIB의 각 오브젝트에 대해 이러한 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d9faf69dba0c1f70caf123cc3782e49dc958f249" translate="yes" xml:space="preserve">
          <source>These functions are described in detail in &lt;code&gt;&lt;a href=&quot;snmp_def_instr_functions&quot;&gt;Definition of Instrumentation Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 기능은 &lt;code&gt;&lt;a href=&quot;snmp_def_instr_functions&quot;&gt;Definition of Instrumentation Functions&lt;/a&gt;&lt;/code&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd7a6a1b98572c10143c1d93f4f329a609ec28fe" translate="yes" xml:space="preserve">
          <source>These functions are equivalent to the corresponding functions in module &lt;code&gt;dbg&lt;/code&gt;, but all calls are stored in the history. The history buffer makes it easy to create configuration files; the same trace environment can be set up many times, for example, to compare two test runs. It also reduces the amount of typing when using &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell.</source>
          <target state="translated">이 함수는 모듈 &lt;code&gt;dbg&lt;/code&gt; 의 해당 함수와 동일 하지만 모든 호출은 히스토리에 저장됩니다. 히스토리 버퍼를 사용하면 구성 파일을 쉽게 작성할 수 있습니다. 예를 들어 두 테스트 실행을 비교하기 위해 동일한 추적 환경을 여러 번 설정할 수 있습니다. 또한 Erlang 쉘에서 &lt;code&gt;ttb&lt;/code&gt; 를 사용할 때 입력량 을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="158d67977a08a84d4924f2a647ba82873c18061b" translate="yes" xml:space="preserve">
          <source>These functions are explained in the following sections. See also &lt;code&gt;&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt;&lt;/code&gt;, which describes the two functions used to activate and deactivate checkpoints.</source>
          <target state="translated">이러한 기능은 다음 섹션에서 설명합니다. &lt;code&gt;&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt;&lt;/code&gt; 활성화 및 비활성화에 사용되는 두 가지 기능을 설명하는 체크 포인트 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60e3f3ff3408849e7fd9edf60400f772dde55362" translate="yes" xml:space="preserve">
          <source>These functions are further described and exemplified in &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 기능은 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa8057e2cae698872b37c80f8aa0f3fe06d7cf59" translate="yes" xml:space="preserve">
          <source>These functions are intended for interactive use in the Erlang shell only. The module prefix can be omitted.</source>
          <target state="translated">이 기능은 Erlang 쉘에서만 대화식으로 사용하기위한 것입니다. 모듈 접두사는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9545561ba594c4d5a35ac49f33ac5958ae1e125a" translate="yes" xml:space="preserve">
          <source>These functions are intended only to help with debugging, and are not to be called from normal code. They are provided for convenience, allowing developers to avoid having to create their own custom state replacement functions.</source>
          <target state="translated">이러한 함수는 디버깅을 돕기위한 것이며 일반 코드에서 호출해서는 안됩니다. 편리 성을 위해 제공되므로 개발자가 자체 사용자 정의 상태 교체 기능을 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b678d1c2ff800ccba92fa1081c74821cd431ce2f" translate="yes" xml:space="preserve">
          <source>These functions are intended only to help with debugging. They are provided for convenience, allowing developers to avoid having to create their own state extraction functions and also avoid having to interactively extract the state from the return values of &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#get_status-2&quot;&gt;get_status/2&lt;/a&gt;&lt;/code&gt; while debugging.</source>
          <target state="translated">이러한 기능은 디버깅에만 도움이됩니다. 편의상 제공되므로 개발자는 자체 상태 추출 함수를 작성하지 않아도 되고 디버깅 중에 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#get_status-2&quot;&gt;get_status/2&lt;/a&gt;&lt;/code&gt; 의 리턴 값에서 상태를 대화식으로 추출하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="9805074016be864764142bf2ab2b984041e919be" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이러한 함수는 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 대신 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b3ee8c4cccd9aad5a3a976e7ebf9dacddb3f7a5d" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이러한 함수는 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 대신 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_INFO&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82227a3a076544e3bda2b44fe272f5c2177cda00" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이러한 함수는 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 대신 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb8d168e922a05dff4b0cd171803a7675b2fbf08" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이러한 기능은 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 사용 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="35c1fc44955a642a5777cca455981c0556303f1d" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이러한 기능은 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 사용 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; 매크로 나 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="5de333f99c5ead1d8115c4087c9a72a0f601d546" translate="yes" xml:space="preserve">
          <source>These functions are kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이러한 기능은 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 사용 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="2d9a4daca1ac6f764626bf603aa4c73a5aa770a0" translate="yes" xml:space="preserve">
          <source>These functions are much slower than the ordinary store and load functions of &lt;code&gt;Mnesia&lt;/code&gt;. However, this is mainly intended for minor experiments and initial prototyping. The major advantage of these functions is that they are easy to use.</source>
          <target state="translated">이러한 기능은 &lt;code&gt;Mnesia&lt;/code&gt; 의 일반 저장 및로드 기능보다 훨씬 느립니다 . 그러나 이것은 주로 작은 실험과 초기 프로토 타이핑을위한 것입니다. 이 기능의 주요 장점은 사용하기 쉽다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc96780ae3ae54fcc394e1c818c2355204d00877" translate="yes" xml:space="preserve">
          <source>These functions are not thread safe.</source>
          <target state="translated">이 기능들은 스레드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8afae98b4e16a8e03fc3cf30a7699eb78e0fa80a" translate="yes" xml:space="preserve">
          <source>These functions are performed in a transaction context involving mechanisms, such as locking, logging, replication, checkpoints, subscriptions, and commit protocols. However, the same function can also be evaluated in other activity contexts.</source>
          <target state="translated">이러한 기능은 잠금, 로깅, 복제, 검사 점, 구독 및 커밋 프로토콜과 같은 메커니즘과 관련된 트랜잭션 컨텍스트에서 수행됩니다. 그러나 다른 활동 컨텍스트에서도 동일한 기능을 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d43be56fdde5e5de270664b9730584c3eb30df12" translate="yes" xml:space="preserve">
          <source>These functions are primarily intended for simplified testing of &lt;code&gt;.appup&lt;/code&gt; files. They are not run within the context of the &lt;code&gt;release_handler&lt;/code&gt; process. They must therefore &lt;strong&gt;not&lt;/strong&gt; be used together with calls to &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;, as this causes the &lt;code&gt;release_handler&lt;/code&gt; to end up in an inconsistent state.</source>
          <target state="translated">이러한 기능은 주로 &lt;code&gt;.appup&lt;/code&gt; 파일 을 간단하게 테스트하기위한 것입니다 . &lt;code&gt;release_handler&lt;/code&gt; 프로세스 의 컨텍스트 내에서 실행되지 않습니다 . 따라서 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 호출과 함께 사용하면 &lt;strong&gt;안됩니다.&lt;/strong&gt; 이로 인해 &lt;code&gt;release_handler&lt;/code&gt; 가 일관성이없는 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="bfdb7ec140eb86cb272ecdbb50138f14fef17e5c" translate="yes" xml:space="preserve">
          <source>These functions are to be used with trace flag &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;'receive'&lt;/code&gt; for setting and clearing trace patterns.</source>
          <target state="translated">이 기능은 추적 패턴을 설정하고 지우는 추적 플래그 &lt;code&gt;call&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;'receive'&lt;/code&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f17b4d328843c30adfc4895bdc753282346f128" translate="yes" xml:space="preserve">
          <source>These functions can be called to retrieve information about the module.</source>
          <target state="translated">모듈에 대한 정보를 검색하기 위해이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1311856f69e61fe882b7ae9bfc9de73ea32a8732" translate="yes" xml:space="preserve">
          <source>These functions can be used to find records in a table when it is impossible to write constraints for the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt;, or when you want to perform some action on certain records.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; 함수에 대한 제한 조건을 작성하는 것이 불가능 하거나 특정 레코드에 대해 조치를 수행하려는 경우 이러한 함수를 사용하여 테이블에서 레코드를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0186f872732540e967fd668deb3a4c289a66df35" translate="yes" xml:space="preserve">
          <source>These functions create or delete a table index on a field defined by &lt;code&gt;AttributeName&lt;/code&gt;. To illustrate this, add an index to the table definition &lt;code&gt;(employee, {emp_no, name, salary, sex, phone, room_no})&lt;/code&gt;, which is the example table from the &lt;code&gt;Company&lt;/code&gt; database. The function that adds an index on element &lt;code&gt;salary&lt;/code&gt; can be expressed as &lt;code&gt;mnesia:add_table_index(employee, salary)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;AttributeName&lt;/code&gt; 에 의해 정의 된 필드에서 테이블 인덱스를 작성하거나 삭제합니다 . 이를 설명하기 위해 &lt;code&gt;Company&lt;/code&gt; 데이터베이스 의 예제 테이블 인 테이블 정의 &lt;code&gt;(employee, {emp_no, name, salary, sex, phone, room_no})&lt;/code&gt; 색인을 추가하십시오 . 요소 &lt;code&gt;salary&lt;/code&gt; 색인을 추가하는 함수는 &lt;code&gt;mnesia:add_table_index(employee, salary)&lt;/code&gt; 로 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b321dfec9cbea3824adf71432c75a84bb7f39aaa" translate="yes" xml:space="preserve">
          <source>These functions iterate over the &lt;code&gt;Mnesia&lt;/code&gt; table &lt;code&gt;Tab&lt;/code&gt; and apply the function &lt;code&gt;Fun&lt;/code&gt; to each record. &lt;code&gt;Fun&lt;/code&gt; takes two arguments, the first is a record from the table, and the second is the accumulator. &lt;code&gt;Fun&lt;/code&gt; returns a new accumulator.</source>
          <target state="translated">이 함수는 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 &lt;code&gt;Tab&lt;/code&gt; 에서 반복되며 &lt;code&gt;Fun&lt;/code&gt; 함수 를 각 레코드에 적용합니다 . &lt;code&gt;Fun&lt;/code&gt; 은 두 가지 인수를 취합니다. 첫 번째는 테이블의 레코드이고 두 번째는 누산기입니다. &lt;code&gt;Fun&lt;/code&gt; 은 새로운 누산기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2241c04aed6e2c04c16cc3d0bc2e51744dc9b5c" translate="yes" xml:space="preserve">
          <source>These functions match a &lt;code&gt;Pattern&lt;/code&gt; against all records in table &lt;code&gt;Tab&lt;/code&gt;. In a &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;Pattern&lt;/code&gt; is a part of &lt;code&gt;MatchSpecification&lt;/code&gt; described in the following. It is not necessarily performed as an exhaustive search of the entire table. By using indexes and bound values in the key of the pattern, the actual work done by the function can be condensed into a few hash lookups. Using &lt;code&gt;ordered_set&lt;/code&gt; tables can reduce the search space if the keys are partially bound.</source>
          <target state="translated">이 함수 는 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 모든 레코드와 &lt;code&gt;Pattern&lt;/code&gt; 을 일치 시킵니다. A의 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select&lt;/a&gt;&lt;/code&gt; 호출 &lt;code&gt;Pattern&lt;/code&gt; 의 일부입니다 &lt;code&gt;MatchSpecification&lt;/code&gt; 는 다음에 설명. 반드시 전체 테이블을 철저히 검색하는 것은 아닙니다. 패턴의 키에 인덱스 및 바운드 값을 사용하면 함수가 수행 한 실제 작업을 몇 가지 해시 조회로 압축 할 수 있습니다. &lt;code&gt;ordered_set&lt;/code&gt; 테이블을 사용 하면 키가 부분적으로 바인드되면 검색 공간을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4380dbd51df4c218d4fc67f122b3a31fa9dad5e7" translate="yes" xml:space="preserve">
          <source>These functions must return the current values of the associated variables.</source>
          <target state="translated">이 함수는 관련 변수의 현재 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d73e48f290f1971fad9fc4d6418f2f3ddc239932" translate="yes" xml:space="preserve">
          <source>These functions return a negative value indicating that an error occurred.</source>
          <target state="translated">이 함수는 오류가 발생했음을 나타내는 음수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f2d4535f8dedc594af82a7502daf5f4472256bee" translate="yes" xml:space="preserve">
          <source>These functions return an open file descriptor on success, or a negative value indicating that an error occurred. In the latter case they set &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">이 함수는 성공시 열린 파일 설명자를 반환하거나 오류가 발생했음을 나타내는 음수 값을 반환합니다. 후자의 경우 &lt;code&gt;erl_errno&lt;/code&gt; 를 다음 중 하나로 설정 했습니다 .</target>
        </trans-unit>
        <trans-unit id="33b0bf879f0be35d9275b8556a8bb8e4605058f4" translate="yes" xml:space="preserve">
          <source>These functions return the number of bytes written to buffer on success, otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 함수는 성공시 버퍼에 쓴 바이트 수를 반환하고, 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="492a4ea8131a6460ecb2bb728f7492324b79c821" translate="yes" xml:space="preserve">
          <source>These functions returns &lt;code&gt;noError&lt;/code&gt; if the assignment was successful, otherwise an error code.</source>
          <target state="translated">이 함수는 할당이 성공하면 &lt;code&gt;noError&lt;/code&gt; 를 반환하고, 그렇지 않으면 오류 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a52d30d9d64255b930d9d116fb319458b1376b07" translate="yes" xml:space="preserve">
          <source>These functions sends a signal to the outer space and the caller hopes that someone is listening. In other words, they invoke &lt;code&gt;et:trace_me/4&lt;/code&gt; and &lt;code&gt;et:trace_me/5&lt;/code&gt; respectively.</source>
          <target state="translated">이 함수는 외부 공간으로 신호를 보내고 호출자는 누군가가 듣고 있기를 희망합니다. 즉, 각각 &lt;code&gt;et:trace_me/4&lt;/code&gt; 및 &lt;code&gt;et:trace_me/5&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="7c5096edbc3525bc8e760ed1084c3016bcbfb9a7" translate="yes" xml:space="preserve">
          <source>These have the same meanings as the normal returns but the characters in &lt;code&gt;PushBackList&lt;/code&gt; will be prepended to the input characters and scanned for the next token. Note that pushing back a newline will mean the line numbering will no longer be correct.</source>
          <target state="translated">이것들은 일반 리턴과 같은 의미를 &lt;code&gt;PushBackList&lt;/code&gt; 의 문자 는 입력 문자 앞에 추가되고 다음 토큰을 스캔합니다. 줄 바꿈을 뒤로 밀면 줄 번호가 더 이상 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28abed6097a4fa5f0db1c6ca4ce80910586cfeeb" translate="yes" xml:space="preserve">
          <source>These heuristics are also used by &lt;code&gt;io:format/2&lt;/code&gt;, &lt;code&gt;io_lib:format/2&lt;/code&gt;, and friends when modifier &lt;code&gt;t&lt;/code&gt; is used with &lt;code&gt;~p&lt;/code&gt; or &lt;code&gt;~P&lt;/code&gt;:</source>
          <target state="translated">이러한 휴리스틱은 수정 자 &lt;code&gt;t&lt;/code&gt; 가 &lt;code&gt;~p&lt;/code&gt; 또는 &lt;code&gt;~P&lt;/code&gt; 와 함께 사용될 때 &lt;code&gt;io:format/2&lt;/code&gt; , &lt;code&gt;io_lib:format/2&lt;/code&gt; 및 friends에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="216fd64a35c1d2baaf5b3f037d998a945eb81f1e" translate="yes" xml:space="preserve">
          <source>These host entries are searched after all added with &lt;code&gt;{file, hosts, File}&lt;/code&gt; above or &lt;code&gt;{host, IP, Aliases}&lt;/code&gt; below when lookup option &lt;code&gt;file&lt;/code&gt; is used.</source>
          <target state="translated">조회 옵션 &lt;code&gt;file&lt;/code&gt; 을 사용할 때 위의 &lt;code&gt;{file, hosts, File}&lt;/code&gt; 또는 아래의 &lt;code&gt;{host, IP, Aliases}&lt;/code&gt; 추가 한 후 이러한 호스트 항목을 검색 합니다 .</target>
        </trans-unit>
        <trans-unit id="07700975c4ec0500ef74d72b43eae1d34a325990" translate="yes" xml:space="preserve">
          <source>These instructions apply for both 32-bit and 64-bit Windows. Note that even if you build a 64-bit version of Erlang, most of the directories and files involved are still named win32. Some occurances of the name win64 are however present. The installation file for a 64-bit Windows version of Erlang, for example, is &lt;code&gt;otp_win64_21.exe&lt;/code&gt;.</source>
          <target state="translated">이 지침은 32 비트 및 64 비트 Windows 모두에 적용됩니다. Erlang의 64 비트 버전을 빌드하더라도 관련된 대부분의 디렉토리와 파일 이름은 여전히 ​​win32입니다. 그러나 이름 win64의 일부가 존재합니다. 예를 들어 Erlang 64 비트 Windows 버전의 설치 파일은 &lt;code&gt;otp_win64_21.exe&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a77e8aed44d3c5857cf64a2b419ef6f4260faa79" translate="yes" xml:space="preserve">
          <source>These instructions apply for both 32-bit and 64-bit Windows. Note that even if you build a 64-bit version of Erlang, most of the directories and files involved are still named win32. Some occurrences of the name win64 are however present. The installation file for a 64-bit Windows version of Erlang, for example, is &lt;code&gt;otp_win64_23.exe&lt;/code&gt;.</source>
          <target state="translated">이 지침은 32 비트 및 64 비트 Windows에 모두 적용됩니다. 64 비트 버전의 Erlang을 빌드하더라도 관련된 대부분의 디렉토리와 파일은 여전히 ​​win32로 이름이 지정됩니다. 그러나 win64라는 이름의 일부 항목이 있습니다. 예를 들어 64 비트 Windows 버전의 Erlang에 대한 설치 파일은 &lt;code&gt;otp_win64_23.exe&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c394330d6ef054d071d8f890cc4c3711a8bdc95c" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to be used when it is considered an error that ports are open to a driver that no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has loaded. The ports that are still open when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;unload_driver/1&lt;/code&gt; or when the last process having the driver loaded dies, are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가로드 하지 않은 드라이버에 포트가 열려 있다는 오류로 간주 될 때 사용됩니다 . 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;unload_driver/1&lt;/code&gt; 을 호출 할 때 또는 드라이버가로드 된 마지막 프로세스가 종료 될 때 여전히 열려있는 포트 는 driver_unloaded 이유로 &lt;code&gt;driver_unloaded&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="976444f76eef13967574c5a3e92db1199465ca38" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;agent_net_if_filter_module()&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 실제로 사용 된 모듈에 따라 다릅니다. 여기에 표시된 것은 기본 &lt;code&gt;agent_net_if_filter_module()&lt;/code&gt; 적용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="79c5c84c302204b5ad2412f8768bea313cd0255d" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;agent_net_if_module()&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 실제로 사용 된 모듈에 따라 다릅니다. 여기에 표시된 것은 기본 &lt;code&gt;agent_net_if_module()&lt;/code&gt; 적용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="dc7fa27f4823b4c40fb38224a9f2c44f5dc1ff3d" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;manager_net_if_filter_module()&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 실제로 사용 된 모듈에 따라 다릅니다. 여기에 표시된 것은 기본 &lt;code&gt;manager_net_if_filter_module()&lt;/code&gt; 적용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="05b3a993da19e30da69e0542004935e23fe64b41" translate="yes" xml:space="preserve">
          <source>These options are actually specific to the used module. The ones shown here are applicable to the default &lt;code&gt;manager_net_if_module()&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 실제로 사용 된 모듈에 따라 다릅니다. 여기에 표시된 것은 기본 &lt;code&gt;manager_net_if_module()&lt;/code&gt; 적용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f52e46ef3067f96590cea6bfd8ffc4461c4cb9d7" translate="yes" xml:space="preserve">
          <source>These options are available when starting the name server. The name server is normally started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; (if not already available), but it can also be started at system startup.</source>
          <target state="translated">이름 서버를 시작할 때이 옵션을 사용할 수 있습니다. 이름 서버는 일반적으로 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 명령 ( 아직 사용 가능하지 않은 경우 )에 의해 자동으로 시작 되지만 시스템 시작시 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b991dcaf8a3c7fdb1bfc134be14dc32ae7b61b5d" translate="yes" xml:space="preserve">
          <source>These options are described in &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt; create/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt; create/3&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60feb775a5a2a0fc8f58b8ddfb26ab5e82088613" translate="yes" xml:space="preserve">
          <source>These options are described in &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;code&gt;&lt;a href=&quot;#zip_options&quot;&gt;create/3&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6e76727821c709b0e581bace27e5e3b9ee3793f" translate="yes" xml:space="preserve">
          <source>These options are only for debugging and testing &lt;code&gt;epmd&lt;/code&gt; clients. They are not to be used in normal operation.</source>
          <target state="translated">이 옵션은 &lt;code&gt;epmd&lt;/code&gt; 클라이언트 디버깅 및 테스트에만 사용됩니다 . 정상적인 작동에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3184ea6ec742a62558f1e2dbf393dc6981719dd9" translate="yes" xml:space="preserve">
          <source>These options are preset by the &lt;code&gt;rename&lt;/code&gt; function and cannot be overridden by the user.</source>
          <target state="translated">이 옵션은 &lt;code&gt;rename&lt;/code&gt; 기능 으로 사전 설정되며 사용자가 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d74113369f61132f3b23365e982841353df0d4a" translate="yes" xml:space="preserve">
          <source>These options make &lt;code&gt;epmd&lt;/code&gt; run as an interactive command, displaying the results of sending queries to an already running instance of &lt;code&gt;epmd&lt;/code&gt;. The &lt;code&gt;epmd&lt;/code&gt; contacted is always on the local node, but option &lt;code&gt;-port&lt;/code&gt; can be used to select between instances if several are running using different ports on the host.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;epmd&lt;/code&gt; 가 대화식 명령으로 실행되어 이미 실행중인 &lt;code&gt;epmd&lt;/code&gt; 인스턴스에 쿼리를 보낸 결과가 표시 됩니다. 접속 된 &lt;code&gt;epmd&lt;/code&gt; 는 항상 로컬 노드에 있지만 호스트에서 다른 포트를 사용하여 여러 포트가 실행중인 경우 &lt;code&gt;-port&lt;/code&gt; 옵션을 사용하여 인스턴스를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e10be32239987c6f4a5a6c8dce5e7fc454e9dfca" translate="yes" xml:space="preserve">
          <source>These override the default and the options specified to &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt;. For example, the following pattern changes the convention to CR:</source>
          <target state="translated">이것들은 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 에 지정된 기본값과 옵션을 무시합니다 . 예를 들어 다음 패턴은 규칙을 CR로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="76493b00ea7c71eb89b79e6053d97efaadb6e80f" translate="yes" xml:space="preserve">
          <source>These override the default and the options specified to the compiling function, but they can themselves be overridden by options specified to a matching function. Notice that these special settings, which are not Perl-compatible, are recognized only at the very start of a pattern, and that they must be in upper case. If more than one of them is present, the last one is used. They can be combined with a change of newline convention; for example, a pattern can start with:</source>
          <target state="translated">이들은 컴파일 기능에 지정된 기본값과 옵션을 재정의하지만 일치하는 기능에 지정된 옵션으로 재정의 할 수 있습니다. Perl과 호환되지 않는 이러한 특수 설정은 패턴 시작시에만 인식되며 대문자 여야합니다. 둘 이상이 존재하면 마지막 것이 사용됩니다. 그것들은 개행 규칙의 변경과 결합 될 수 있습니다; 예를 들어 패턴은 다음과 같이 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c8826c9e11e1f3d846a339b100ceac99eba779d" translate="yes" xml:space="preserve">
          <source>These packet types only have effect on receiving. When sending a packet, it is the responsibility of the application to supply a correct header. On receiving, however, one message is sent to the controlling process for each complete packet received, and, similarly, each call to &lt;code&gt;gen_tcp:recv/2,3&lt;/code&gt; returns one complete packet. The header is &lt;strong&gt;not&lt;/strong&gt; stripped off.</source>
          <target state="translated">이러한 패킷 유형은 수신에만 영향을 미칩니다. 패킷을 보낼 때 올바른 헤더를 제공하는 것은 응용 프로그램의 책임입니다. 그러나, 수신시, 하나의 메시지가 수신 된 각각의 완전한 패킷에 대한 제어 프로세스로 전송되고, 유사하게, &lt;code&gt;gen_tcp:recv/2,3&lt;/code&gt; 에 대한 각각의 호출 은 하나의 완전한 패킷을 리턴한다. 헤더가 제거 &lt;strong&gt;되지 않았습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="703061c1f2854688bcb586643b95905fd657c226" translate="yes" xml:space="preserve">
          <source>These parameters can be modified by the user with the following configuration term:</source>
          <target state="translated">이 매개 변수는 다음 구성 용어로 사용자가 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="019f3eb722d3988d7298c6a669ca65df0fbbaa93" translate="yes" xml:space="preserve">
          <source>These questions are not always trivial to answer. Some benchmarks might be needed to back up your theory and to avoid making things slower if your theory is wrong. For details, see &lt;code&gt;&lt;a href=&quot;#benchmark&quot;&gt;Benchmarking&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 질문들이 항상 쉬운 것은 아닙니다. 이론을 백업하고 이론이 잘못된 경우 속도를 늦추지 않으려면 일부 벤치 마크가 필요할 수 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#benchmark&quot;&gt;Benchmarking&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="764b3f2b692c282ad0bd05c88a3b6913fb526534" translate="yes" xml:space="preserve">
          <source>These record definitions use the &quot;new&quot; spelling 'adaptation', not the deprecated 'adaption', regardless of which spelling the underlying C API uses.</source>
          <target state="translated">이러한 레코드 정의는 기본 C API가 어떤 철자를 사용하는지에 관계없이 사용되지 않는 '적응'이 아닌 &quot;새로운&quot;철자 '적응'을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dc5ac270ae2ee1136906b421f96b332ee47c42ac" translate="yes" xml:space="preserve">
          <source>These relations are interpreted as follows: if we are in state &lt;code&gt;S&lt;/code&gt; and event &lt;code&gt;E&lt;/code&gt; occurs, we are to perform actions &lt;code&gt;A&lt;/code&gt; and make a transition to state &lt;code&gt;S'&lt;/code&gt;. Notice that &lt;code&gt;S'&lt;/code&gt; can be equal to &lt;code&gt;S&lt;/code&gt; and that &lt;code&gt;A&lt;/code&gt; can be empty.</source>
          <target state="translated">이러한 관계는 다음과 같이 해석됩니다. 상태 &lt;code&gt;S&lt;/code&gt; 에 있고 이벤트 &lt;code&gt;E&lt;/code&gt; 가 발생하면 조치 &lt;code&gt;A&lt;/code&gt; 를 수행 하고 상태 &lt;code&gt;S'&lt;/code&gt; 로 전환해야 합니다. 공지는 것을 &lt;code&gt;S'&lt;/code&gt; 동일 할 수있다 &lt;code&gt;S&lt;/code&gt; 그리고 &lt;code&gt;A&lt;/code&gt; 가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae00fb07c3a51201cd4652ed075fa902a7ed72cb" translate="yes" xml:space="preserve">
          <source>These relations are interpreted as follows: if we are in state &lt;code&gt;S&lt;/code&gt; and event &lt;code&gt;E&lt;/code&gt; occurs, we are to perform actions &lt;code&gt;A&lt;/code&gt;, and make a transition to state &lt;code&gt;S'&lt;/code&gt;. Notice that &lt;code&gt;S'&lt;/code&gt; can be equal to &lt;code&gt;S&lt;/code&gt;, and that &lt;code&gt;A&lt;/code&gt; can be empty.</source>
          <target state="translated">이러한 관계는 다음과 같이 해석됩니다. 만약 우리가 상태 &lt;code&gt;S&lt;/code&gt; 에 있고 이벤트 &lt;code&gt;E&lt;/code&gt; 가 발생한다면, 우리는 행동 &lt;code&gt;A&lt;/code&gt; 를 수행 하고 상태 &lt;code&gt;S'&lt;/code&gt; 로 전환해야 합니다. 주의하는 &lt;code&gt;S'&lt;/code&gt; 동일 할 수있다 &lt;code&gt;S&lt;/code&gt; , 그리고 &lt;code&gt;A&lt;/code&gt; 는 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="663a0dde4969fddd76e6f124e908bc76a6818654" translate="yes" xml:space="preserve">
          <source>These services are controlled through the process &lt;code&gt;global_name_server&lt;/code&gt; that exists on every node. The global name server starts automatically when a node is started. With the term &lt;strong&gt;global&lt;/strong&gt; is meant over a system consisting of many Erlang nodes.</source>
          <target state="translated">이러한 서비스는 모든 노드에 존재 하는 프로세스 &lt;code&gt;global_name_server&lt;/code&gt; 를 통해 제어됩니다 . 노드가 시작되면 글로벌 이름 서버가 자동으로 시작됩니다. &lt;strong&gt;global&lt;/strong&gt; 이라는 용어 는 많은 Erlang 노드로 구성된 시스템을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="18b3db7ac68ef66e01ea9e3110a4d7998bc037fb" translate="yes" xml:space="preserve">
          <source>These state transition actions can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; when it is called with an &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 상태 전이 작업은 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;event&lt;/a&gt;&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 될 때 상태 콜백 에서, &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 또는 이벤트 를 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에 제공하여 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f84a998101580824af52c1efde9742c062b4f3ac" translate="yes" xml:space="preserve">
          <source>These state transition actions can be invoked by returning them from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving them to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 상태 전이 작업은 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 로부터 반환 하거나 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에 제공하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61a80d0c0fec3872bf24b97867cc3c3fed9d0143" translate="yes" xml:space="preserve">
          <source>These tests cannot (always) be done automatically when cross compiling. You usually do not need to set these variables.</source>
          <target state="translated">이러한 컴파일은 교차 컴파일시 자동으로 수행 될 수 없습니다. 일반적으로 이러한 변수를 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d05ecef6dec2328daa1fa8983fc44a7ac6b969f" translate="yes" xml:space="preserve">
          <source>These three BIFs do conversions that would be difficult (or impossible) to do in Erlang.</source>
          <target state="translated">이 세 가지 BIF는 Erlang에서 수행하기 어렵거나 불가능한 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9fc1faee4aad725a39321bd959c62d7b61fc838d" translate="yes" xml:space="preserve">
          <source>These three tables, &lt;code&gt;employees&lt;/code&gt;, &lt;code&gt;dept&lt;/code&gt;, and &lt;code&gt;projects&lt;/code&gt;, are made up of real records. The following database content is stored in the tables and is built on relationships. These tables are &lt;code&gt;manager&lt;/code&gt;, &lt;code&gt;at_dep&lt;/code&gt;, and &lt;code&gt;in_proj&lt;/code&gt;.</source>
          <target state="translated">이 세 개의 테이블 ( &lt;code&gt;employees&lt;/code&gt; , &lt;code&gt;dept&lt;/code&gt; 및 &lt;code&gt;projects&lt;/code&gt; )은 실제 레코드로 구성됩니다. 다음 데이터베이스 컨텐츠는 테이블에 저장되며 관계를 기반으로합니다. 이 테이블은 &lt;code&gt;manager&lt;/code&gt; , &lt;code&gt;at_dep&lt;/code&gt; 및 &lt;code&gt;in_proj&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0128c9fb51c2ef33512e0f9218f6c647c34f70b" translate="yes" xml:space="preserve">
          <source>These time-out actions sets time-out &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 시간 초과 작업은 시간 초과 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2be4aeb784d73a7483bb30162082ef141d284732" translate="yes" xml:space="preserve">
          <source>These timeout actions sets timeout &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 시간 초과 작업은 시간 초과 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition options&lt;/a&gt;&lt;/code&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="e1c1c65f29a414599f1da742468bf0977b89b3ea" translate="yes" xml:space="preserve">
          <source>These tuples are strictly monotonically ordered on the current runtime system instance according to creation time. It is important that the monotonic time is in the first element (the most significant element when comparing two-tuples). Using the monotonic time in the tuples, you can calculate time between events.</source>
          <target state="translated">이 튜플은 생성 시간에 따라 현재 런타임 시스템 인스턴스에서 엄격하게 단조롭게 정렬됩니다. 단조 시간이 첫 번째 요소 (두 튜플을 비교할 때 가장 중요한 요소)에있는 것이 중요합니다. 튜플에서 단조로운 시간을 사용하여 이벤트 사이의 시간을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d52f80b222da3d294b0f671c73049263b3d9e584" translate="yes" xml:space="preserve">
          <source>These two functions are provided in the standard module &lt;code&gt;lists&lt;/code&gt;. &lt;code&gt;foreach&lt;/code&gt; takes a list and applies a fun to every element in the list. &lt;code&gt;map&lt;/code&gt; creates a new list by applying a fun to every element in a list. Going back to the shell, &lt;code&gt;map&lt;/code&gt; is used and a fun to add 3 to every element of a list:</source>
          <target state="translated">이 두 기능은 표준 모듈 &lt;code&gt;lists&lt;/code&gt; 제공됩니다 . &lt;code&gt;foreach&lt;/code&gt; 는 목록을 가져와 목록의 모든 요소에 재미를 적용합니다. &lt;code&gt;map&lt;/code&gt; 은 목록의 모든 요소에 재미를 적용하여 새 목록을 만듭니다. 쉘로 돌아가서 &lt;code&gt;map&lt;/code&gt; 이 사용되며 목록의 모든 요소에 3을 추가하는 재미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4144563beb40dfa20763e7a44f564ed7df7e5fe8" translate="yes" xml:space="preserve">
          <source>These two functions have a similar structure. They both iterate over a list and do something to each element in the list. The &quot;something&quot; is passed on as an extra argument to the function that does this.</source>
          <target state="translated">이 두 기능은 비슷한 구조를 가지고 있습니다. 그들은 목록을 반복하고 목록의 각 요소에 대해 무언가를합니다. &quot;무언가&quot;는이를 수행하는 함수에 대한 추가 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf31d937cdb8656e463da3517deb67f3a158915" translate="yes" xml:space="preserve">
          <source>These two functions look up an executable program, with the specified name and a search path, in the same way as the underlying OS. &lt;code&gt;find_executable/1&lt;/code&gt; uses the current execution path (that is, the environment variable &lt;code&gt;PATH&lt;/code&gt; on Unix and Windows).</source>
          <target state="translated">이 두 함수는 기본 OS와 동일한 방식으로 지정된 이름과 검색 경로를 가진 실행 프로그램을 찾습니다. &lt;code&gt;find_executable/1&lt;/code&gt; 은 현재 실행 경로 (즉, Unix 및 Windows 의 환경 변수 &lt;code&gt;PATH&lt;/code&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0d074a20ddd5e5f33562cc40bc5760ad507e2a6" translate="yes" xml:space="preserve">
          <source>These two pieces work in concert. Basically, the &lt;code&gt;Collector&lt;/code&gt; receives &lt;code&gt;Raw Trace Data&lt;/code&gt; and processes it into &lt;code&gt;Events&lt;/code&gt; in a &lt;code&gt;et&lt;/code&gt; specific format (defined in &lt;code&gt;et/include/et.hrl&lt;/code&gt;). The &lt;code&gt;Viewer&lt;/code&gt; interrogates the &lt;code&gt;Collector&lt;/code&gt; and displays an interactive representation of the data.</source>
          <target state="translated">이 두 작품은 함께 작동합니다. 기본적으로 &lt;code&gt;Collector&lt;/code&gt; 는 &lt;code&gt;Raw Trace Data&lt;/code&gt; 수신 하여 &lt;code&gt;et&lt;/code&gt; 특정 형식 ( &lt;code&gt;et/include/et.hrl&lt;/code&gt; 에 정의) 으로 &lt;code&gt;Events&lt;/code&gt; 로 처리합니다 . &lt;code&gt;Viewer&lt;/code&gt; 심문 &lt;code&gt;Collector&lt;/code&gt; 및 디스플레이 데이터의 상호 작용 표현을.</target>
        </trans-unit>
        <trans-unit id="dda87b11f0a5cbea6a2795c81d6b6e5706e62c96" translate="yes" xml:space="preserve">
          <source>These two types are often not needed, as the socket automatically switches from &lt;code&gt;http&lt;/code&gt;/&lt;code&gt;http_bin&lt;/code&gt; to &lt;code&gt;httph&lt;/code&gt;/&lt;code&gt;httph_bin&lt;/code&gt; internally after the first line is read. However, there can be occasions when they are useful, such as parsing trailers from chunked encoding.</source>
          <target state="translated">소켓 이 첫 번째 행을 읽은 후 내부적으로 &lt;code&gt;http&lt;/code&gt; / &lt;code&gt;http_bin&lt;/code&gt; 에서 &lt;code&gt;httph&lt;/code&gt; / &lt;code&gt;httph_bin&lt;/code&gt; 으로 자동 전환 되므로이 두 유형은 종종 필요하지 않습니다 . 그러나 청크 인코딩에서 트레일러를 구문 분석하는 등 유용한 경우가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c70e7bfedf23869960675efaf18a91ce706b0d2" translate="yes" xml:space="preserve">
          <source>These values can be used to determine order between events on the runtime system instance. That is, if both &lt;code&gt;X = erlang:unique_integer([monotonic])&lt;/code&gt; and &lt;code&gt;Y = erlang:unique_integer([monotonic])&lt;/code&gt; are executed by different processes (or the same process) on the same runtime system instance and &lt;code&gt;X &amp;lt; Y&lt;/code&gt;, we know that &lt;code&gt;X&lt;/code&gt; was created before &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">이 값은 런타임 시스템 인스턴스에서 이벤트 사이의 순서를 결정하는 데 사용될 수 있습니다. 즉, &lt;code&gt;X = erlang:unique_integer([monotonic])&lt;/code&gt; 와 &lt;code&gt;Y = erlang:unique_integer([monotonic])&lt;/code&gt; 가 동일한 런타임 시스템 인스턴스와 &lt;code&gt;X &amp;lt; Y&lt;/code&gt; 에서 다른 프로세스 (또는 동일한 프로세스)에 의해 실행되는 경우 것을 &lt;code&gt;X&lt;/code&gt; 는 이전에 생성 된 &lt;code&gt;Y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64037abeafa784d21870f15a8f477ebe7f35dde2" translate="yes" xml:space="preserve">
          <source>These variables currently have &lt;strong&gt;no&lt;/strong&gt; effect if you configure using the &lt;code&gt;configure&lt;/code&gt; script directly.</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 스크립트를 사용하여 직접 구성하는 경우 이러한 변수는 현재 적용 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e4eeacbbfedd76f9009cc450f49274f9b8f50cf0" translate="yes" xml:space="preserve">
          <source>These verbs differ in exactly what kind of failure occurs when backtracking reaches them. The behavior described below is what occurs when the verb is not in a subroutine or an assertion. Subsequent sections cover these special cases.</source>
          <target state="translated">이러한 동사는 역 추적에 도달 할 때 어떤 종류의 오류가 발생하는지 정확하게 다릅니다. 아래 설명 된 동작은 동사가 서브 루틴 또는 어설 션에 없을 때 발생합니다. 후속 섹션에서는 이러한 특수 사례를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="2fdbca7f7f11b6cf955d9574790794bb8f837662" translate="yes" xml:space="preserve">
          <source>They are deprecated from 23.0 and for removal in 24.0.</source>
          <target state="translated">23.0에서는 더 이상 사용되지 않으며 24.0에서는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb7ed1357b82ff56473fd5066848225a0c020e2" translate="yes" xml:space="preserve">
          <source>They can also be combined with the (*UTF8), (*UTF), or (*UCP) special sequences. Inside a character class, \R is treated as an unrecognized escape sequence, and so matches the letter &quot;R&quot; by default.</source>
          <target state="translated">또한 (* UTF8), (* UTF) 또는 (* UCP) 특수 시퀀스와 결합 될 수 있습니다. 문자 클래스 내에서 \ R은 인식 할 수없는 이스케이프 시퀀스로 취급되므로 기본적으로 문자 &quot;R&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4f19fb9eb943279dbf1aab1f1a7e9449243b24c1" translate="yes" xml:space="preserve">
          <source>They can then be used in either of the following ways:</source>
          <target state="translated">그런 다음 다음 방법 중 하나로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f10af1c6b334490e5b1459d0c8bfcff29264cd5a" translate="yes" xml:space="preserve">
          <source>Thin space</source>
          <target state="translated">얇은 공간</target>
        </trans-unit>
        <trans-unit id="6196f53beeed99bac9dd3ff39c523037e81c3134" translate="yes" xml:space="preserve">
          <source>Think twice before using this function. If you still need to use it, always &lt;code&gt;call os:type()&lt;/code&gt; first.</source>
          <target state="translated">이 기능을 사용하기 전에 두 번 생각하십시오. 그래도 계속 사용해야한다면 항상 &lt;code&gt;call os:type()&lt;/code&gt; 먼저 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ea8743046d2b98d1556841772481beb6c8b7be7" translate="yes" xml:space="preserve">
          <source>Think twice before using this function. Use module &lt;code&gt;filename&lt;/code&gt; if you want to inspect or build filenames in a portable way. Avoid matching on atom &lt;code&gt;Osname&lt;/code&gt;.</source>
          <target state="translated">이 기능을 사용하기 전에 두 번 생각하십시오. 이식 가능한 방식으로 파일 이름을 검사하거나 만들려면 모듈 &lt;code&gt;filename&lt;/code&gt; 사용하십시오 . atom &lt;code&gt;Osname&lt;/code&gt; 과 일치하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="3f8c7ac9b539ff01e43c48a7bf8bc197468de776" translate="yes" xml:space="preserve">
          <source>Third, its possible to alter the global default value in runtime by calling the function &lt;code&gt;&lt;a href=&quot;socket#use_registry-1&quot;&gt;use_registry/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">셋째, &lt;code&gt;&lt;a href=&quot;socket#use_registry-1&quot;&gt;use_registry/1&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 런타임에서 전역 기본값을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b64bf09f4307d3d16c58fc0bfca8ad10a7fe410" translate="yes" xml:space="preserve">
          <source>This &quot;bad&quot; state consists of a cluster of small and/or highly fragmented carriers located at the sentinel in the pool. The largest free block in such a &quot;bad&quot; carrier is rather small, making it unable to satisfy most allocation requests. As the search always started at the sentinel, any such &quot;bad&quot; carriers that had been left in the pool would eventually cluster together at the sentinel. All searches first have to skip past this cluster of &quot;bad&quot; carriers to reach a &quot;good&quot; carrier. When the cluster gets to the same size as the search limit, all searches will essentially fail.</source>
          <target state="translated">이 &quot;나쁜&quot;상태는 풀의 센티넬에 위치한 작고 조각난 반송파 클러스터로 구성됩니다. 이러한 &quot;불량&quot;반송파에서 가장 큰 여유 블록은 다소 작아서 대부분의 할당 요청을 충족 할 수 없습니다. 수색이 항상 센티넬에서 시작 되었기 때문에 풀에 남아 있던 그러한 &quot;나쁜&quot;캐리어는 결국 센티넬에서 함께 모이게됩니다. 모든 검색은 먼저이 &quot;나쁜&quot;캐리어 클러스터를 건너 뛰어 &quot;좋은&quot;캐리어에 도달해야합니다. 클러스터가 검색 제한과 동일한 크기에 도달하면 모든 검색이 기본적으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d592d2f7893043a1b846652e39ab1418e618bc4e" translate="yes" xml:space="preserve">
          <source>This (most common) scenario simply supports that each &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver loads it when needed and unloads it when no longer needed. The driver is always reference counted and as long as a process keeping the driver loaded is still alive, the driver is present in the system.</source>
          <target state="translated">이 (가장 일반적인) 시나리오 는 드라이버의 각 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 필요할 때 드라이버를로드하고 더 이상 필요하지 않은 경우 언로드하도록 지원합니다. 드라이버는 항상 참조 횟수를 계산하며 드라이버를로드 된 상태로 유지하는 프로세스가 여전히 존재하는 한 드라이버는 시스템에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="cb6a47e588a181452c326fa39e3e06a8bbaf215e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;at_dep&lt;/code&gt; record has the Erlang tuple representation &lt;code&gt;{at_dep, klacke, 'B/SFR'}&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;at_dep&lt;/code&gt; 레코드에는 Erlang 튜플 표현 &lt;code&gt;{at_dep, klacke, 'B/SFR'}&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb50969a4322693220f1622878a187ec8ef7865" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;employee&lt;/code&gt; record has the Erlang record/tuple representation &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;employee&lt;/code&gt; 레코드의 Erlang 레코드 / 튜플 표현은 &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6f78a7a573f4788a961abb21d13018ab8263739" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;in_proj&lt;/code&gt; record has the Erlang tuple representation &lt;code&gt;{in_proj, klacke, 'Erlang', klacke, 'otp', klacke, 'mnesia'}&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;in_proj&lt;/code&gt; 레코드의 Erlang 튜플 표현은 &lt;code&gt;{in_proj, klacke, 'Erlang', klacke, 'otp', klacke, 'mnesia'}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30eaf1b61fcff886440404502320b8087244781b" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;Implementation Example&lt;/strong&gt; section describes how a simple manager can be implemented with the SNMP Development Toolkit.</source>
          <target state="translated">이 &lt;strong&gt;구현 예제&lt;/strong&gt; 섹션에서는 SNMP Development Toolkit으로 간단한 관리자를 구현하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ffdeda27af47f2d41561b45e8678ebc080646b29" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;Implementation Example&lt;/strong&gt; section describes how an MIB can be implemented with the SNMP Development Toolkit.</source>
          <target state="translated">이 &lt;strong&gt;구현 예&lt;/strong&gt; 섹션은 SNMP Development Toolkit으로 MIB를 구현하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="90786d1bedc2d134f9012ff5026a27ec4ce6ae1d" translate="yes" xml:space="preserve">
          <source>This &lt;strong&gt;transition action&lt;/strong&gt; can be invoked by returning it from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving it to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;strong&gt;전환 작업&lt;/strong&gt; 은 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 에서 반환 하거나 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에 제공하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8285515d6a8ffd60d079855281d19dbb335db5a" translate="yes" xml:space="preserve">
          <source>This BIF can be removed in a future version of the Beam machine without prior warning. It is unlikely to be implemented in other Erlang implementations.</source>
          <target state="translated">이 BIF는 차후 버전의 Beam 시스템에서 사전 경고없이 제거 할 수 있습니다. 다른 Erlang 구현에서는 구현되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2c9f52ffa82790c5add5ce609c3b465fa6b5f87" translate="yes" xml:space="preserve">
          <source>This BIF is always to be used for hashing terms. It distributes small integers better than &lt;code&gt;phash/2&lt;/code&gt;, and it is faster for bignums and binaries.</source>
          <target state="translated">이 BIF는 항상 해싱 용어에 사용됩니다. &lt;code&gt;phash/2&lt;/code&gt; 보다 작은 정수를 더 잘 분배 하며 bignums 및 이진에 대해 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ca02fa554a6262c386a3db4a859b0b9b57b609dd" translate="yes" xml:space="preserve">
          <source>This BIF is documented for completeness. Usually &lt;code&gt;is_record/2&lt;/code&gt; is to be used.</source>
          <target state="translated">이 BIF는 완전성을 위해 문서화되었습니다. 일반적으로 &lt;code&gt;is_record/2&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83e449dcefb700e8a09d27413d7037f287088ef7" translate="yes" xml:space="preserve">
          <source>This BIF is intended for &lt;strong&gt;debugging only&lt;/strong&gt;. For all other purposes, use &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt; process_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 BIF는 &lt;strong&gt;디버깅 전용&lt;/strong&gt; 입니다. 다른 모든 목적을 위해서는 &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt; process_info/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e919cc7df793008049931bcf01d09ffb06683260" translate="yes" xml:space="preserve">
          <source>This BIF is intended for &lt;strong&gt;debugging only&lt;/strong&gt;. For all other purposes, use &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt;process_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 BIF는 &lt;strong&gt;디버깅 전용&lt;/strong&gt; 입니다. 다른 모든 목적으로 &lt;code&gt;&lt;a href=&quot;#process_info-2&quot;&gt;process_info/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b16cda9185776fda7cf953473f68ed8eae22005c" translate="yes" xml:space="preserve">
          <source>This BIF is intended for debugging and is not to be used in application programs.</source>
          <target state="translated">이 BIF는 디버깅 용이며 응용 프로그램에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a485a9d729fff78ad515ca89ab62a61dc168854" translate="yes" xml:space="preserve">
          <source>This BIF is intended for debugging only.</source>
          <target state="translated">이 BIF는 디버깅 전용입니다.</target>
        </trans-unit>
        <trans-unit id="33eab8a0dcb284396b1bdbf0824f52f98a707748" translate="yes" xml:space="preserve">
          <source>This BIF is intended for the code server (see &lt;code&gt;code(3)&lt;/code&gt;) and is not to be used elsewhere.</source>
          <target state="translated">이 BIF는 코드 서버를위한 것이며 ( &lt;code&gt;code(3)&lt;/code&gt; 참조 ) 다른 곳에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc3f97203615ffb6be54801dfb7bad70393f210" translate="yes" xml:space="preserve">
          <source>This BIF is mainly intended for debugging, but it can sometimes be useful in library functions that need to verify, for example, the arity of a fun.</source>
          <target state="translated">이 BIF는 주로 디버깅을 위해 만들어졌지만 때로는 재미의 예를 들어 검증해야하는 라이브러리 함수에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed42f39086e8ec9c7b1c29cd5a589cf6f72ca9ff" translate="yes" xml:space="preserve">
          <source>This BIF is useful for builders of cross-reference tools.</source>
          <target state="translated">이 BIF는 상호 참조 도구 빌더에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c6cc75865613bc58e0eb7ecb4f457c6d233e733d" translate="yes" xml:space="preserve">
          <source>This DNS client can resolve DNS records even if it is not used for normal name resolving in the node.</source>
          <target state="translated">이 DNS 클라이언트는 노드에서 정상적인 이름 확인에 사용되지 않더라도 DNS 레코드를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="babe61c293ec427280b1edacc01c731077dee4c0" translate="yes" xml:space="preserve">
          <source>This Efficiency Guide cannot really teach you how to write efficient code. It can give you a few pointers about what to avoid and what to use, and some understanding of how certain language features are implemented. This guide does not include general tips about optimization that works in any language, such as moving common calculations out of loops.</source>
          <target state="translated">이 효율성 가이드는 실제로 효율적인 코드 작성 방법을 알려줄 수는 없습니다. 피해야 할 것과 사용할 수있는 것에 대한 몇 가지 지침과 특정 언어 기능이 구현되는 방법에 대한 이해를 제공 할 수 있습니다. 이 가이드에는 일반적인 계산을 루프 밖으로 이동하는 것과 같이 모든 언어에서 작동하는 최적화에 대한 일반적인 팁이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae1ff29eb10c59731ea6c65a3606a80e84b3335c" translate="yes" xml:space="preserve">
          <source>This Erlang/OTP application supplies a framework for building applications that needs to utilize the Megaco/H.248 protocol.</source>
          <target state="translated">이 Erlang / OTP 애플리케이션은 Megaco / H.248 프로토콜을 사용해야하는 애플리케이션을 빌드하기위한 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b18f63f410f90b5069c9dc2f1ae77d811c62158c" translate="yes" xml:space="preserve">
          <source>This MIB is not loaded by default.</source>
          <target state="translated">이 MIB는 기본적으로로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a407b3d8ce92982dd769f80205472707dd33acd9" translate="yes" xml:space="preserve">
          <source>This MIB is now loaded into the agent, and a manager can ask questions. As an example of this, we start another Erlang system and the simple Erlang manager in the toolkit:</source>
          <target state="translated">이 MIB는 이제 에이전트에로드되며 관리자는 질문을 할 수 있습니다. 예를 들어 툴킷에서 다른 Erlang 시스템과 간단한 Erlang 관리자를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="8bee977533f2540fecf48c418b1e1c4b1c9441e8" translate="yes" xml:space="preserve">
          <source>This PCRE pattern solves the nested parentheses problem (assume that option &lt;code&gt;extended&lt;/code&gt; is set so that whitespace is ignored):</source>
          <target state="translated">이 PCRE 패턴은 중첩 괄호 문제를 해결합니다 ( &lt;code&gt;extended&lt;/code&gt; 옵션 이 공백이 무시되도록 설정되어 있다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="ba3b1c781a2b003455c5f276cc7adab4167d61a9" translate="yes" xml:space="preserve">
          <source>This Reference Manual describes the Mnesia API. This includes functions that define and manipulate Mnesia tables.</source>
          <target state="translated">이 참조 매뉴얼은 Mnesia API에 대해 설명합니다. 여기에는 Mnesia 테이블을 정의하고 조작하는 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5a1ea321f8ef4337012dd060505384a468b6d8b6" translate="yes" xml:space="preserve">
          <source>This Reference Manual uses a table of persons to illustrate various examples. The following record definition is assumed:</source>
          <target state="translated">이 참조 매뉴얼은 다양한 예를 설명하기 위해 사람을 사용합니다. 다음과 같은 레코드 정의가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="eba208a5a64a9fe2d23e89684b28919d090b1bf5" translate="yes" xml:space="preserve">
          <source>This User's Guide describes how to build Mnesia database applications, and how to integrate and use the Mnesia database management system with OTP. Programming constructs are described, and numerous programming examples are included to illustrate the use of Mnesia.</source>
          <target state="translated">이 사용자 안내서는 Mnesia 데이터베이스 응용 프로그램을 구축하는 방법 및 Mnesia 데이터베이스 관리 시스템을 OTP와 통합 및 사용하는 방법을 설명합니다. 프로그래밍 구성에 대해 설명하고 Mnesia 사용을 설명하기 위해 수많은 프로그래밍 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f455597a879e8e0b44bd2b0f60e41d0029eaba8" translate="yes" xml:space="preserve">
          <source>This User's Guide describes the documentation storage format initially described in &lt;code&gt;&lt;a href=&quot;https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html&quot;&gt;EEP-48&lt;/a&gt;&lt;/code&gt;. By standardizing how API documentation is stored, it will be possible to write tools that work across languages.</source>
          <target state="translated">이 사용자 가이드는 &lt;code&gt;&lt;a href=&quot;https://www.erlang.org/erlang-enhancement-proposals/eep-0048.html&quot;&gt;EEP-48&lt;/a&gt;&lt;/code&gt; 에서 처음 설명 된 문서 저장 형식을 설명합니다 . API 문서가 저장되는 방식을 표준화하면 여러 언어로 작동하는 도구를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c2e051140679b5fabfd3850166d5e44acd182d" translate="yes" xml:space="preserve">
          <source>This User's Guide is organized as follows:</source>
          <target state="translated">이 사용자 안내서는 다음과 같이 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e07c970a29206fa6177bb430aa23651cee332f1" translate="yes" xml:space="preserve">
          <source>This access functions example shows how &lt;code&gt;&lt;a href=&quot;#lookup-3&quot;&gt;lookup/3&lt;/a&gt;&lt;/code&gt; can be implemented using &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/3&lt;/a&gt;&lt;/code&gt; from outside the module:</source>
          <target state="translated">이 액세스 함수 예제는 모듈 외부에서 &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/3&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;#lookup-3&quot;&gt;lookup/3&lt;/a&gt;&lt;/code&gt; 을 구현 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e453611cc830c0fe9b4a7d78e62c5d3c550a27db" translate="yes" xml:space="preserve">
          <source>This acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the entire table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">이것은 전체 테이블 &lt;code&gt;Tab&lt;/code&gt; 에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 .</target>
        </trans-unit>
        <trans-unit id="f91dd38ac67f0332e475b1b711e06f95a62ba56f" translate="yes" xml:space="preserve">
          <source>This acquires a lock of type &lt;code&gt;LockKind&lt;/code&gt; on the global resource &lt;code&gt;GlobalKey&lt;/code&gt;. The lock is acquired on all active nodes in the &lt;code&gt;Nodes&lt;/code&gt; list.</source>
          <target state="translated">글로벌 자원 &lt;code&gt;GlobalKey&lt;/code&gt; 에서 &lt;code&gt;LockKind&lt;/code&gt; 유형의 잠금을 획득합니다 . 잠금은 &lt;code&gt;Nodes&lt;/code&gt; 목록 의 모든 활성 노드에서 획득됩니다 .</target>
        </trans-unit>
        <trans-unit id="c854770bc65f05e5983d655656fa66f6c7914156" translate="yes" xml:space="preserve">
          <source>This action does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition_option() &lt;/a&gt;&lt;/code&gt; but instead stores the specified &lt;code&gt;EventType&lt;/code&gt; and &lt;code&gt;EventContent&lt;/code&gt; for insertion after all actions have been executed.</source>
          <target state="translated">이 액션은 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt; transition_option() &lt;/a&gt;&lt;/code&gt; 설정하지 않고 대신 모든 액션이 실행 된 후 삽입을 위해 지정된 &lt;code&gt;EventType&lt;/code&gt; 및 &lt;code&gt;EventContent&lt;/code&gt; 를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="52b66d36db3f8d918f682c24c470f8a1a0d1add9" translate="yes" xml:space="preserve">
          <source>This action does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead stores the specified &lt;code&gt;EventType&lt;/code&gt; and &lt;code&gt;EventContent&lt;/code&gt; for insertion after all actions have been executed.</source>
          <target state="translated">이 조치는 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; 설정하지 않고 모든 조치가 실행 된 후 삽입을 위해 지정된 &lt;code&gt;EventType&lt;/code&gt; 및 &lt;code&gt;EventContent&lt;/code&gt; 를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="49d5b8cf3248f457c3e4fd7bf845d80256d7c600" translate="yes" xml:space="preserve">
          <source>This actually is a simulation of the process &lt;code&gt;Events&lt;/code&gt; caused by a &lt;code&gt;Mnesia&lt;/code&gt; transaction that writes a record in a local table:</source>
          <target state="translated">이것은 실제로 로컬 테이블에 레코드를 쓰는 &lt;code&gt;Mnesia&lt;/code&gt; 트랜잭션으로 인해 발생 하는 프로세스 &lt;code&gt;Events&lt;/code&gt; 의 시뮬레이션입니다 .</target>
        </trans-unit>
        <trans-unit id="dbd8d5b06b09c15de60879a1a8a9947df8335726" translate="yes" xml:space="preserve">
          <source>This address family only works on Unix-like systems.</source>
          <target state="translated">이 주소 계열은 유닉스 계열 시스템에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b5576569da19d1b2e935e949277425b3e7400242" translate="yes" xml:space="preserve">
          <source>This address format is for now experimental and for completeness to make all address families have a &lt;code&gt;{Family, Destination}&lt;/code&gt; representation.</source>
          <target state="translated">이 주소 형식은 현재 실험적이며 모든 주소 계열이 &lt;code&gt;{Family, Destination}&lt;/code&gt; 표현을 갖도록 완벽하게 만들기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="63d593ef2ab6f3e8b14006b9f741f5c521ea7089" translate="yes" xml:space="preserve">
          <source>This affects the access logs written by &lt;code&gt;mod_log&lt;/code&gt; and &lt;code&gt;mod_disk_log&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;mod_log&lt;/code&gt; 및 &lt;code&gt;mod_disk_log&lt;/code&gt; 에 의해 작성된 액세스 로그에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="2fd1765db5e4a1421a5a77cd061597e64ef02887" translate="yes" xml:space="preserve">
          <source>This affects the error logs written by &lt;code&gt;mod_log&lt;/code&gt; and &lt;code&gt;mod_disk_log&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;mod_log&lt;/code&gt; 및 &lt;code&gt;mod_disk_log&lt;/code&gt; 에 의해 작성된 오류 로그에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="bbd6bb60897f850ec49a0aac99503d287bd1842d" translate="yes" xml:space="preserve">
          <source>This allows info events to pass through to the default handler, and be printed to the terminal as well. If there are many info events, it can be useful to print these to a file instead.</source>
          <target state="translated">이를 통해 정보 이벤트가 기본 핸들러로 전달되고 터미널에도 인쇄 될 수 있습니다. 많은 정보 이벤트가있는 경우 파일로 인쇄하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e19f7d8ad7331e73f9393236fe1782f10bda23" translate="yes" xml:space="preserve">
          <source>This also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. This is equivalent to Perl's &lt;code&gt;/x&lt;/code&gt; option, and it can be changed within a pattern by a &lt;code&gt;(?x)&lt;/code&gt; option setting.</source>
          <target state="translated">또한 문자 클래스 외부의 이스케이프되지 않은 # 문자와 다음 줄 바꿈 사이의 문자는 무시됩니다. 이것은 Perl의 &lt;code&gt;/x&lt;/code&gt; 옵션 과 동일 하며 &lt;code&gt;(?x)&lt;/code&gt; 옵션 설정 으로 패턴 내에서 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58f3cb66f380a5c19ef8ab400cfe6287edaa6dfa" translate="yes" xml:space="preserve">
          <source>This also means that if a user implement their own transport service then it has to maintain its own statistics.</source>
          <target state="translated">이는 또한 사용자가 자신의 전송 서비스를 구현하는 경우 자체 통계를 유지해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6e14170723475328c130ae9f6473e132cd1b01e7" translate="yes" xml:space="preserve">
          <source>This and also previous implementation do not work well when the table is nearly full. We will both get long search times for free slots, and we will reuse identifiers more frequently since we more frequently wrap during the search. These tables works best when the table is much larger than the amount of simultaneous existing processes. One easy improvement is to always have room for more processes than we allow in the table. This will also be implemented in the next release, but this should probably also be worked more on trying to find an even better solution.</source>
          <target state="translated">테이블이 거의 가득 차면이 구현과 이전 구현이 제대로 작동하지 않습니다. 빈 슬롯에 대한 검색 시간이 길어질 것이며 검색 중에 더 자주 래핑하기 때문에 식별자를 더 자주 재사용 할 것입니다. 이 테이블은 테이블이 동시 기존 프로세스의 양보다 훨씬 클 때 가장 잘 작동합니다. 한 가지 쉬운 개선 사항은 항상 표에서 허용하는 것보다 더 많은 프로세스를위한 공간을 확보하는 것입니다. 이는 다음 릴리스에서도 구현 될 예정이지만 더 나은 솔루션을 찾기 위해 더 노력해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7dd22038e1768c05bfb1a8b06817075c1c09560" translate="yes" xml:space="preserve">
          <source>This appendix describes the conversion of SNMPv2 to SNMPv1 error messages. The instrumentation functions should return v2 error messages.</source>
          <target state="translated">이 부록에서는 SNMPv2를 SNMPv1 오류 메시지로 변환하는 방법에 대해 설명합니다. 계측 기능은 v2 오류 메시지를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="87860fce150658815e0dd8f84b7b2d2085183f77" translate="yes" xml:space="preserve">
          <source>This application covers all features of ASN.1 up to the 1997 edition of the specification. In the 2002 edition, new features were introduced. The following features of the 2002 edition are fully or partly supported:</source>
          <target state="translated">이 애플리케이션은 ASN.1의 모든 기능을 사양의 1997 년판까지 다룹니다. 2002 년판에는 새로운 기능이 도입되었습니다. 2002 버전의 다음 기능이 완전히 또는 부분적으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="569634e92b8ce1ce008d5489ba01f7e7d69d8d45" translate="yes" xml:space="preserve">
          <source>This application has been deprecated and will be removed in a furture release.</source>
          <target state="translated">이 응용 프로그램은 더 이상 사용되지 않으며 furture 릴리스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dfc6af9c7770c0d0747ed2380e862e5393774125" translate="yes" xml:space="preserve">
          <source>This application provides an Erlang interface to communicate with relational SQL-databases. It is built on top of Microsofts ODBC interface and therefore requires that you have an ODBC driver to the database that you want to connect to.</source>
          <target state="translated">이 응용 프로그램은 관계형 SQL 데이터베이스와 통신하기위한 Erlang 인터페이스를 제공합니다. Microsoft의 ODBC 인터페이스 위에 구축되므로 연결할 데이터베이스에 대한 ODBC 드라이버가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="33c8dd3d5797a890a9a711bb22cf2594354b0bee" translate="yes" xml:space="preserve">
          <source>This approach is always preferred over the other alternatives described below. This both from a performance perspective and a system characteristics perspective.</source>
          <target state="translated">이 방법은 아래에 설명 된 다른 대안보다 항상 선호됩니다. 이것은 성능 관점과 시스템 특성 관점에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8068bc8d1c806d61b5dde8f35515f5de0ccd108c" translate="yes" xml:space="preserve">
          <source>This approach is probably easier for an Erlanger but if you need to use real XSLT stylesheets in order to &quot;comply to the standard&quot; there is an adapter available to the Sablotron XSLT package which is written i C++. See also the &lt;code&gt;Tutorial&lt;/code&gt;.</source>
          <target state="translated">이 방법은 Erlanger에서 더 쉬울 수 있지만 &quot;표준을 준수하기&quot;위해 실제 XSLT 스타일 시트를 사용해야하는 경우 i ++++로 작성된 Sablotron XSLT 패키지에 사용 가능한 어댑터가 있습니다. &lt;code&gt;Tutorial&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f62d188dacb48bbbcc2b2321f9f579397d8bbfe1" translate="yes" xml:space="preserve">
          <source>This associates the name &lt;code&gt;a&lt;/code&gt; with the top-level &lt;code&gt;node&lt;/code&gt; entry. For this to work, the configuration file must at least contain:</source>
          <target state="translated">이름 &lt;code&gt;a&lt;/code&gt; 를 최상위 &lt;code&gt;node&lt;/code&gt; 항목 과 연결합니다 . 이것이 작동하려면 구성 파일에 최소한 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e34095000c0319f418ac3ee68cd3bf8ccd8bc10" translate="yes" xml:space="preserve">
          <source>This assumes that this is the first line of the input text, and that &lt;code&gt;'$end'&lt;/code&gt; is the distinguished &lt;code&gt;end_of_input&lt;/code&gt; symbol.</source>
          <target state="translated">이것은 이것이 입력 텍스트의 첫 번째 행이고 &lt;code&gt;'$end'&lt;/code&gt; 는 고유 한 &lt;code&gt;end_of_input&lt;/code&gt; 기호라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="821b03bacc21c4d7e259e58631986fc8983788a2" translate="yes" xml:space="preserve">
          <source>This attribute is to be specified first and is the only mandatory attribute.</source>
          <target state="translated">이 속성은 먼저 지정되어야하며 유일한 필수 속성입니다.</target>
        </trans-unit>
        <trans-unit id="d5e89f840b948b0e856ea77d5bc34a2eb62f41fa" translate="yes" xml:space="preserve">
          <source>This attribute is used by tools, such as Yecc, to inform the compiler that the source program is generated by another tool. It also indicates the correspondence of source files to lines of the original user-written file, from which the source program is produced.</source>
          <target state="translated">이 속성은 Yecc와 같은 도구에서 소스 프로그램이 다른 도구에 의해 생성되었음을 컴파일러에 알리기 위해 사용됩니다. 또한 소스 파일이 소스 프로그램이 생성 된 원래 사용자 작성 파일의 행에 대응함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d9c8cd0265b456f941da20d0c6f623c0e29a3c55" translate="yes" xml:space="preserve">
          <source>This attribute names a function that is to be run automatically when a module is loaded. For more information, see &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt; Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 속성은 모듈이로드 될 때 자동으로 실행되는 함수의 이름을 지정합니다. 자세한 내용 &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt; Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e21a2982771a0d227b0a5afc10f4b081e89b3ac5" translate="yes" xml:space="preserve">
          <source>This attribute names a function that is to be run automatically when a module is loaded. For more information, see &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt;Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 속성은 모듈이로드 될 때 자동으로 실행될 기능의 이름을 지정합니다. 자세한 내용 &lt;code&gt;&lt;a href=&quot;code_loading#on_load&quot;&gt;Running a Function When a Module is Loaded&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1862f101a5a9233b48a831149fc7167f1c97802b" translate="yes" xml:space="preserve">
          <source>This automatically starts the error logger event manager, and adds &lt;code&gt;error_logger&lt;/code&gt; as a handler to Logger, with the following configuration:</source>
          <target state="translated">이렇게하면 오류 로거 이벤트 관리자가 자동으로 시작 되고 다음 구성을 사용하여 &lt;code&gt;error_logger&lt;/code&gt; 를 처리기로 Logger에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ce539a9df53bac997ca6cb301b22b25cdb3ea47c" translate="yes" xml:space="preserve">
          <source>This avoids TCP's TIME_WAIT state, but leaves open the possibility that another &quot;incarnation&quot; of this connection being created.</source>
          <target state="translated">이것은 TCP의 TIME_WAIT 상태를 피하지만이 연결의 또 다른 &quot;화신&quot;이 생성 될 가능성을 열어 둡니다.</target>
        </trans-unit>
        <trans-unit id="3fdb9b714260fc3296ea31ac0070bb8141246799" translate="yes" xml:space="preserve">
          <source>This behavior appeared in Erlang/OTP 19.0.</source>
          <target state="translated">이 동작은 Erlang / OTP 19.0에서 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="b6abecdecbe55a6c353c6503f8fff17fe757dd78" translate="yes" xml:space="preserve">
          <source>This behavior appeared in Erlang/OTP 19.0. In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; was introduced. In OTP 20.0 the &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic timeouts&lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="translated">이 동작은 Erlang / OTP 19.0에 나타났습니다. OTP 19.1에서는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 에서 리턴 튜플의 이전 버전과 호환되지 않는 변경 이 이루어졌으며 필수 콜백 함수 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 이 도입되었습니다. OTP 20.0에서는 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic timeouts&lt;/a&gt;&lt;/code&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="785543b1d2c442c04e0906335bd46635b1eb96f6" translate="yes" xml:space="preserve">
          <source>This behavior can be controlled through command-line flag &lt;code&gt;-code_path_choice Choice&lt;/code&gt;. If the flag is set to &lt;code&gt;relaxed&lt;/code&gt;, the code server instead chooses a suitable directory depending on the actual file structure. If a regular application &lt;code&gt;ebin&lt;/code&gt; directory exists, it is chosen. Otherwise, the directory &lt;code&gt;ebin&lt;/code&gt; in the archive is chosen if it exists. If neither of them exists, the original directory is chosen.</source>
          <target state="translated">이 동작은 명령 행 플래그 &lt;code&gt;-code_path_choice Choice&lt;/code&gt; 를 통해 제어 할 수 있습니다 . 플래그가 &lt;code&gt;relaxed&lt;/code&gt; 로 설정 되면 코드 서버는 실제 파일 구조에 따라 적합한 디렉토리를 대신 선택합니다. 일반 응용 프로그램 &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 존재하면 선택됩니다. 그렇지 않으면, 아카이브 의 디렉토리 &lt;code&gt;ebin&lt;/code&gt; 이 존재하는 경우 선택됩니다. 둘 중 어느 것도 존재하지 않으면 원래 디렉토리가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="53636ccb870bbfa8ce6166a610a444015328245d" translate="yes" xml:space="preserve">
          <source>This behavior module implements the back end of the Erlang tracing system. The functions in this module are called whenever a trace probe is triggered. Both the &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;trace&lt;/code&gt; functions are called in the context of the entity that triggered the trace probe. This means that the overhead by having the tracing enabled is greatly effected by how much time is spent in these functions. So, do as little work as possible in these functions.</source>
          <target state="translated">이 동작 모듈은 Erlang 추적 시스템의 백엔드를 구현합니다. 이 모듈의 기능은 트레이스 프로브가 트리거 될 때마다 호출됩니다. &lt;code&gt;enabled&lt;/code&gt; 및 &lt;code&gt;trace&lt;/code&gt; 기능은 모두 추적 프로브를 트리거 한 엔티티의 컨텍스트에서 호출됩니다. 이는 추적을 사용 가능하게하여 오버 헤드가이 기능에 소요되는 시간에 크게 영향을받습니다. 따라서 이러한 기능에서 가능한 한 적은 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="23ed37aa93d3cb97e2709aafd5c39ba7bb1b8c68" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor bridge, a process that connects a subsystem not designed according to the OTP design principles to a supervision tree. The supervisor bridge sits between a supervisor and the subsystem. It behaves like a real supervisor to its own supervisor, but has a different interface than a real supervisor to the subsystem. For more information, see &lt;code&gt; Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 동작 모듈은 OTP 설계 원칙에 따라 설계되지 않은 서브 시스템을 감독 트리에 연결하는 프로세스 인 감독자 브리지를 제공합니다. 수퍼바이저 브리지는 수퍼바이저와 하위 시스템 사이에 있습니다. 자체 감독자에게는 실제 감독자처럼 작동하지만 서브 시스템에 대한 실제 감독자와는 다른 인터페이스를 가지고 있습니다. 자세한 내용 은 OTP 설계 원칙의 &lt;code&gt; Supervisor Behaviour&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70c20f09b1094d916dd54fcb5f009aa1d7c32e52" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor bridge, a process that connects a subsystem not designed according to the OTP design principles to a supervision tree. The supervisor bridge sits between a supervisor and the subsystem. It behaves like a real supervisor to its own supervisor, but has a different interface than a real supervisor to the subsystem. For more information, see &lt;code&gt;Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 작동 모듈은 OTP 설계 원칙에 따라 설계되지 않은 서브 시스템을 감독 트리에 연결하는 프로세스 인 감독자 브리지를 제공합니다. 수퍼바이저 브리지는 수퍼바이저와 서브 시스템 사이에 있습니다. 자체 수퍼바이저에 대한 실제 수퍼바이저처럼 동작하지만 서브 시스템에 대한 실제 수퍼바이저와 다른 인터페이스를 가지고 있습니다. 자세한 내용 은 OTP 설계 원칙의 &lt;code&gt;Supervisor Behaviour&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d78ebb85e52ea715b460d534876e2e64780e260" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see &lt;code&gt; Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 동작 모듈은 하위 프로세스라고하는 다른 프로세스를 감독하는 프로세스 인 감독자를 제공합니다. 하위 프로세스는 다른 감독자 또는 작업자 프로세스 일 수 있습니다. 작업자 프로세스는 일반적으로 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 동작 중 하나를 사용하여 구현됩니다 . 이 모듈을 사용하여 구현 된 수퍼바이저에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능이 포함되어 있습니다. 감독자는 내결함성 애플리케이션을 구성하는 좋은 방법 인 감독 트리라는 계층 적 프로세스 구조를 구축하는 데 사용됩니다. 자세한 내용 은 OTP 설계 원칙의 &lt;code&gt; Supervisor Behaviour&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce3316c8111b9876ff9b5ef8da2949d18e1dd45d" translate="yes" xml:space="preserve">
          <source>This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see &lt;code&gt;Supervisor Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 비헤이비어 모듈은 자식 프로세스라는 다른 프로세스를 감독하는 프로세스 인 감독자를 제공합니다. 자식 프로세스는 다른 감독자 또는 작업자 프로세스 일 수 있습니다. 작업자 프로세스는 일반적으로 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 동작 중 하나를 사용하여 구현됩니다 . 이 모듈을 사용하여 구현 된 수퍼바이저에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능이 포함되어 있습니다. 감독자는 결함 허용 응용 프로그램을 구성하는 좋은 방법 인 감독 트리라고하는 계층 적 프로세스 구조를 구축하는 데 사용됩니다. 자세한 내용 은 OTP 설계 원칙의 &lt;code&gt;Supervisor Behaviour&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d6df5b9b0f7a74dbafdab8bc790e47d7e7f9481" translate="yes" xml:space="preserve">
          <source>This behavior module provides event handling functionality. It consists of a generic event manager process with any number of event handlers that are added and deleted dynamically.</source>
          <target state="translated">이 비헤이비어 모듈은 이벤트 처리 기능을 제공합니다. 동적으로 추가 및 삭제되는 여러 이벤트 핸들러가있는 일반 이벤트 관리자 프로세스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="80aef52a4a9d2d5e57ced3f744cf231173e5382d" translate="yes" xml:space="preserve">
          <source>This behavior module provides the server of a client-server relation. A generic server process (&lt;code&gt;gen_server&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see section &lt;code&gt; gen_server Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 동작 모듈은 클라이언트-서버 관계의 서버를 제공합니다. 이 모듈을 사용하여 구현 된 일반 서버 프로세스 ( &lt;code&gt;gen_server&lt;/code&gt; )에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능을 포함합니다. 또한 OTP 감독 트리에 적합합니다. 자세한 내용 은 OTP 설계 원칙의 &lt;code&gt; gen_server Behaviour&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abfb5bf41909c33228afc455141ff017bc6cbde2" translate="yes" xml:space="preserve">
          <source>This behavior module provides the server of a client-server relation. A generic server process (&lt;code&gt;gen_server&lt;/code&gt;) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see section &lt;code&gt;gen_server Behaviour&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 동작 모듈은 클라이언트-서버 관계의 서버를 제공합니다. 이 모듈을 사용하여 구현 된 일반 서버 프로세스 ( &lt;code&gt;gen_server&lt;/code&gt; )에는 표준 인터페이스 기능 세트가 있으며 추적 및 오류보고 기능이 포함됩니다. 또한 OTP 감독 트리에도 적합합니다. 자세한 내용 은 OTP 디자인 원칙의 &lt;code&gt;gen_server Behaviour&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73e10e87f957712b985d39a62945e43bbfb9c199" translate="yes" xml:space="preserve">
          <source>This behaviour is different from how it worked prior to Erlang/OTP 19.0. Before 19.0 the literal check was done by checking if the pointer pointed to the young or old heap block. If it did not, then it was considered a literal. This lead to considerable overhead and strange memory usage scenarios, so it was removed in 19.0.</source>
          <target state="translated">이 동작은 Erlang / OTP 19.0 이전의 작동 방식과 다릅니다. 19.0 이전에는 포인터가 젊거나 오래된 힙 블록을 가리키는 지 확인하여 리터럴 검사가 수행되었습니다. 그렇지 않은 경우 문자 그대로 간주되었습니다. 이로 인해 상당한 오버 헤드와 이상한 메모리 사용 시나리오가 발생하므로 19.0에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="cfe536c202221de15418e3b0398e40a018dac1a4" translate="yes" xml:space="preserve">
          <source>This binds variable &lt;code&gt;B&lt;/code&gt; to integer &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">변수 &lt;code&gt;B&lt;/code&gt; 를 정수 &lt;code&gt;2&lt;/code&gt; 에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="5921d4e93c827b7d95c4a9acb4bbf5b9f3ecb5c5" translate="yes" xml:space="preserve">
          <source>This brand and version may be changed with the option &lt;code&gt;&lt;a href=&quot;ssh#type-id_string_common_option&quot;&gt;id_string&lt;/a&gt;&lt;/code&gt;. We start a daemon with that option:</source>
          <target state="translated">이 브랜드와 버전은 &lt;code&gt;&lt;a href=&quot;ssh#type-id_string_common_option&quot;&gt;id_string&lt;/a&gt;&lt;/code&gt; 옵션으로 변경 될 수 있습니다 . 해당 옵션으로 데몬을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="43864d6a93dcab0bbcc900bd0174b5bbab1fdc75" translate="yes" xml:space="preserve">
          <source>This call is equivalent to &lt;code&gt;public_key:pem_entry_decode(CertEntry1)&lt;/code&gt;:</source>
          <target state="translated">이 호출은 &lt;code&gt;public_key:pem_entry_decode(CertEntry1)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5d23eee97c1eb9e0a1493c034b0bfc305e9ddf21" translate="yes" xml:space="preserve">
          <source>This call is used with connection-based socket types (&lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;seqpacket&lt;/code&gt;). It extracs the first pending connection request for the listen socket and returns the (newly) connected socket.</source>
          <target state="translated">이 호출은 연결 기반 소켓 유형 ( &lt;code&gt;stream&lt;/code&gt; 또는 &lt;code&gt;seqpacket&lt;/code&gt; ) 과 함께 사용됩니다 . 청취 소켓에 대한 첫 번째 보류중인 연결 요청을 추가하고 (새로) 연결된 소켓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cb45c675dbc6c57c7e83453d414ea4d5859f32a" translate="yes" xml:space="preserve">
          <source>This callback format consumes much memory, as the whole response must be generated before it is sent to the user. This callback format is deprecated. For new development, use &lt;code&gt;Module:Function/3&lt;/code&gt;.</source>
          <target state="translated">이 콜백 형식은 전체 응답이 사용자에게 전송되기 전에 생성되어야하므로 많은 메모리를 소비합니다. 이 콜백 형식은 더 이상 사용되지 않습니다. 새로 개발하려면 &lt;code&gt;Module:Function/3&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c021922a0bcd25050486be93ca9a01fe228c8b3e" translate="yes" xml:space="preserve">
          <source>This callback function is mandatory.</source>
          <target state="translated">이 콜백 함수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="19c59aed8326cb258e589ba8cff9c5c632aa9fd0" translate="yes" xml:space="preserve">
          <source>This callback function is optional.</source>
          <target state="translated">이 콜백 함수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="f25d747572c59dd9f293a1f0fcfc6c190d3c0ac9" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;. In it any side effects needed by the tracer are to be done. The tracepoint payload is located in the &lt;code&gt;TraceTerm&lt;/code&gt;. The content of the &lt;code&gt;TraceTerm&lt;/code&gt; depends on which &lt;code&gt;TraceTag&lt;/code&gt; is triggered. &lt;code&gt;TraceTerm&lt;/code&gt; corresponds to the fourth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 . 추적자에 필요한 모든 부작용이 수행되어야합니다. 추적 점 페이로드는 &lt;code&gt;TraceTerm&lt;/code&gt; 에 있습니다. &lt;code&gt;TraceTerm&lt;/code&gt; 의 내용 은 트리거 되는 &lt;code&gt;TraceTag&lt;/code&gt; 에 따라 다릅니다 . &lt;code&gt;TraceTerm&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt; 에 설명 된 추적 튜플의 네 번째 요소에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="38e550ff4f657cf80a8775b069566d9feb16c83b" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;. In it any side effects needed by the tracer are to be done. The tracepoint payload is located in the &lt;code&gt;TraceTerm&lt;/code&gt;. The content of the &lt;code&gt;TraceTerm&lt;/code&gt; depends on which &lt;code&gt;TraceTag&lt;/code&gt; is triggered. &lt;code&gt;TraceTerm&lt;/code&gt; corresponds to the fourth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 . 여기에는 추적 프로그램에 필요한 모든 부작용이 수행됩니다. 추적 점 페이로드는 &lt;code&gt;TraceTerm&lt;/code&gt; 에 있습니다. &lt;code&gt;TraceTerm&lt;/code&gt; 의 내용은 어떤 &lt;code&gt;TraceTag&lt;/code&gt; 가 트리거 되는지에 따라 다릅니다 . &lt;code&gt;TraceTerm&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 에 설명 된 추적 튜플의 네 번째 요소에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="b5b2df4ee795088b10e9a8743810a608e160f791" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt; Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt; Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="d37d000bba6ae99564128c8b7446cc5273b6a04e" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt;Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_call-3&quot;&gt;Module:enabled_call/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 한 경우에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="09e7a6fd7ae94a8b204e4555cbdb97edc835e6f0" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt; Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt; Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="15198a7c2fc8240482ba94b944bdfc0b14e586ba" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt;Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_garbage_collection-3&quot;&gt;Module:enabled_garbage_collection/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 리턴 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b7f965ceb723c3e428aae9e712be01c5751a24c" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt; Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt; Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2aa5dde256677cc6703eaf4ec5d19bc2b8283932" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt;Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_ports-3&quot;&gt;Module:enabled_ports/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 한 경우에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="de8b6dabb1b9aedf64269ee027289b838928ff19" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt; Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt; Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dcc032a652781d3a4cff57f32134bdf4ec6b88d" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt;Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_procs-3&quot;&gt;Module:enabled_procs/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 리턴 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c07c7052c71939e18500a6ffce1aa3ea1692a61" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt; Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt; Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cfff3392a7d289ca0c61ca7155845689c03dcb44" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt;Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_receive-3&quot;&gt;Module:enabled_receive/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 리턴 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="389d25478a53bcbad4b00f57b0c975a597be05f0" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt; Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt; Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c24bf92b0df20158eb77c36643c943e9fdb3807a" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt;Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_ports-3&quot;&gt;Module:enabled_running_ports/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 리턴 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="eedf109955855e438df9878211bbefe0268cab51" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt; Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt; Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6742c8972ca63b4eed6ff400182d4ad91035680" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt;Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_running_procs-3&quot;&gt;Module:enabled_running_procs/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 리턴 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9102deaae3699fe52f8c3288eb5f0454907ef640" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt; Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt; Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f48d6f8f965dcfd900008bb64742372d353ae2d" translate="yes" xml:space="preserve">
          <source>This callback is called when a tracepoint is triggered and the &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt;Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; callback returned &lt;code&gt;trace&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 추적 점이 트리거되고 &lt;code&gt;&lt;a href=&quot;#Module:enabled_send-3&quot;&gt;Module:enabled_send/3&lt;/a&gt;&lt;/code&gt; 콜백이 &lt;code&gt;trace&lt;/code&gt; 를 반환 한 경우에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d06f96f4aade9b952b7ce9c8005f3b70b23dcd8" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint is triggered. It allows the tracer to decide whether a trace is to be generated or not. This check is made as early as possible to limit the amount of overhead associated with tracing. If &lt;code&gt;trace&lt;/code&gt; is returned, the necessary trace data is created and the trace callback of the tracer is called. If &lt;code&gt;discard&lt;/code&gt; is returned, this trace call is discarded and no call to trace is done.</source>
          <target state="translated">이 콜백은 추적 점이 트리거 될 때마다 호출됩니다. 추적 프로그램이 추적 생성 여부를 결정할 수 있습니다. 이 검사는 추적과 관련된 오버 헤드의 양을 제한하기 위해 가능한 빨리 이루어집니다. 경우 &lt;code&gt;trace&lt;/code&gt; 반환되고, 필요한 추적 데이터가 생성되고 추적의 추적 콜백이 호출됩니다. 경우 &lt;code&gt;discard&lt;/code&gt; 반환되고,이 추적 호출이 삭제되고 추적에는 호출이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d90dbf0e78bbedf9e4bcbc34379a7cf3dd298fa5" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt; running_procs | running&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그가있는 추적 점이 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt; running_procs | running&lt;/a&gt;&lt;/code&gt; 이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="94e6048cf0014e861feb66ee170c873413ff3161" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;'receive'&lt;/a&gt;&lt;/code&gt; 이 있는 추적 점이 트리거 될 때마다 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="6fa7e2961f153a4436cefe4499cc280336994838" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;call | return_to&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그가있는 추적 점이 호출 될 때마다 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;call | return_to&lt;/a&gt;&lt;/code&gt; 가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="69b3512c1f3ede51a7ecf30950dad7b0634b3377" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;garbage_collection&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그가 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;garbage_collection&lt;/a&gt;&lt;/code&gt; 인 추적 점이 트리거 될 때마다 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="04e6a249465c46d45e283c5f1f0285668b198409" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;ports&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;ports&lt;/a&gt;&lt;/code&gt; 가 있는 추적 점이 트리거 될 때마다 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="af6001baab0a6ade22947ab13bfa31245cf0abe6" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;procs&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;procs&lt;/a&gt;&lt;/code&gt; 가 있는 추적 점이 트리거 될 때마다 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="0be59b7c2110146187e5c0eeaf4bc0878afe0cb6" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_ports&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_ports&lt;/a&gt;&lt;/code&gt; 가 있는 추적 점이 트리거 될 때마다 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="334c413e0dbeba2235f5db1ca4ea0969695570e1" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_procs | running&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;running_procs | running&lt;/a&gt;&lt;/code&gt; 이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="7c04ab99901eac2f63941068c90d7843bba53367" translate="yes" xml:space="preserve">
          <source>This callback is called whenever a tracepoint with trace flag &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; is triggered.</source>
          <target state="translated">이 콜백은 추적 플래그 &lt;code&gt;&lt;a href=&quot;erlang#trace-3&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 이 있는 추적 점이 트리거 될 때마다 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="69eb6ef56ec8902494bd21822d312f399e05340c" translate="yes" xml:space="preserve">
          <source>This callback is delegated to the &lt;code&gt;ssh_file&lt;/code&gt; module.</source>
          <target state="translated">이 콜백은 &lt;code&gt;ssh_file&lt;/code&gt; 모듈에 위임됩니다 .</target>
        </trans-unit>
        <trans-unit id="0eb3991244f8edb7b0e0b02b52e72b978996b94e" translate="yes" xml:space="preserve">
          <source>This callback is mandatory.</source>
          <target state="translated">이 콜백은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="945a522c510e59f03864e9eeb3d8a618307d8e56" translate="yes" xml:space="preserve">
          <source>This callback is optional, so a callback module does not need to export it. The &lt;code&gt;gen_statem&lt;/code&gt; module provides a default implementation of this function that returns &lt;code&gt;{State,Data}&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈을 내 보내지 않아도됩니다. &lt;code&gt;gen_statem&lt;/code&gt; 의 모듈은이 함수의 기본 구현을 제공 반환하는 &lt;code&gt;{State,Data}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53a31bbe3f39f2d360082e09b97e8bd9a8a3c01e" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/4&lt;/code&gt; is not implemented the process will crash with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈이 내보낼 필요가 없습니다. 와 릴리스 업그레이드 / 다운 그레이드하는 경우 &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt; 에 지정된 &lt;code&gt;.appup&lt;/code&gt; 의 경우 파일이 만들어 &lt;code&gt;code_change/4&lt;/code&gt; 가 구현되지 않은 프로세스가 종료 이유 충돌합니다 &lt;code&gt;undef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adab3ff296df418bda26c9ab38b8afebec6b2122" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/3&lt;/code&gt; isn't implemented the event handler will crash with an &lt;code&gt;undef&lt;/code&gt; error reason.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. 와 릴리스 업그레이드 / 다운 그레이드하는 경우 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 에 지정된 &lt;code&gt;.appup&lt;/code&gt; 의 경우 파일이 만들어 &lt;code&gt;code_change/3&lt;/code&gt; 가 구현되지 않은 이벤트 핸들러는과 충돌합니다 &lt;code&gt;undef&lt;/code&gt; 오류 이유.</target>
        </trans-unit>
        <trans-unit id="02bb4941fa7a9741c99ed42c9b52e91f322657b1" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;.appup&lt;/code&gt; file is made when &lt;code&gt;code_change/4&lt;/code&gt; is not implemented the process will crash with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. &lt;code&gt;code_change/4&lt;/code&gt; 가 구현되지 않은 상태 에서 &lt;code&gt;.appup&lt;/code&gt; 파일에 지정된 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 로 릴리스 업그레이드 / 다운 그레이드가 수행되면 종료 이유 &lt;code&gt;undef&lt;/code&gt; 로 프로세스가 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="09246fb26a04b28ca2f447f072f0daaf17b1ea05" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; specified in the &lt;code&gt;appup&lt;/code&gt; file is made when &lt;code&gt;code_change/3&lt;/code&gt; isn't implemented the process will crash with an &lt;code&gt;undef&lt;/code&gt; exit reason.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. 와 릴리스 업그레이드 / 다운 그레이드하는 경우 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 에 지정된 &lt;code&gt;appup&lt;/code&gt; 경우 파일이 만들어 &lt;code&gt;code_change/3&lt;/code&gt; 가 구현되지 않는 프로세스는와 충돌합니다 &lt;code&gt;undef&lt;/code&gt; 종료 이유.</target>
        </trans-unit>
        <trans-unit id="449de06640c440754deb50b818d7f03da9dfc15a" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{noreply, State}&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. &lt;code&gt;gen_event&lt;/code&gt; 모듈은 예기치에 대한 로그 것으로이 함수의 기본 구현을 제공하는 &lt;code&gt;Info&lt;/code&gt; 메시지가 그 반환을 삭제를 &lt;code&gt;{noreply, State}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cfc4d1b1611e681e7a69a610747f2faafb9e670" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈이 내보낼 필요가 없습니다. &lt;code&gt;gen_event&lt;/code&gt; 모듈은 예기치에 대한 로그 것으로이 함수의 기본 구현을 제공하는 &lt;code&gt;Info&lt;/code&gt; 메시지가 그것을 반환 떨어 &lt;code&gt;{ok, State}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="642a938f2c13878b19e630eed4ff743e43a98666" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_event&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. &lt;code&gt;gen_event&lt;/code&gt; 모듈은 정리하지 않고 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33b5eb4eda106379d214a532dea20df13c6ee4a7" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation of this function that logs about the unexpected &lt;code&gt;Info&lt;/code&gt; message, drops it and returns &lt;code&gt;{noreply, State}&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. &lt;code&gt;gen_server&lt;/code&gt; 의 모듈은 예기치에 대한 로그 것으로이 함수의 기본 구현을 제공하는 &lt;code&gt;Info&lt;/code&gt; 메시지가 그 반환을 삭제를 &lt;code&gt;{noreply, State}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0950a9f920ccec0ce58fea7dd4cc52647d84000" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation of this function that returns the callback module state.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. &lt;code&gt;gen_server&lt;/code&gt; 의 모듈은 콜백 모듈 상태를 반환이 함수의 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d3374de84ad48d0fa717caa3233068cba7f0a810" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_server&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. &lt;code&gt;gen_server&lt;/code&gt; 의 모듈은 정리하지 않고 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ed16700adf3de2342c41a38a47218a24b4797c88" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need not export it. The &lt;code&gt;gen_statem&lt;/code&gt; module provides a default implementation without cleanup.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈은 내보낼 필요가 없습니다. &lt;code&gt;gen_statem&lt;/code&gt; 의 모듈은 정리하지 않고 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b14aaa8a71c534451d8b2fa83d586d1d7132b252" translate="yes" xml:space="preserve">
          <source>This callback is optional, so callback modules need to export it only if they return &lt;code&gt;{continue,Continue}&lt;/code&gt; from another callback. If continue is used and the callback is not implemented, the process will exit with &lt;code&gt;undef&lt;/code&gt; error.</source>
          <target state="translated">이 콜백은 선택 사항이므로 콜백 모듈 은 다른 콜백에서 &lt;code&gt;{continue,Continue}&lt;/code&gt; 를 반환하는 경우에만 콜백 모듈을 내 보내야 합니다. continue가 사용되고 콜백이 구현되지 않으면 프로세스는 &lt;code&gt;undef&lt;/code&gt; 오류 와 함께 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="d62e7ff4624439456f6274f30841bc2cd438369b" translate="yes" xml:space="preserve">
          <source>This callback is optional, so event handler modules need not export it. If a handler does not export this function, the &lt;code&gt;gen_event&lt;/code&gt; module uses the handler state directly for the purposes described below.</source>
          <target state="translated">이 콜백은 선택 사항이므로 이벤트 핸들러 모듈은이를 내보낼 필요가 없습니다. 핸들러가이 함수를 내 보내지 않으면 &lt;code&gt;gen_event&lt;/code&gt; 모듈은 아래 설명 된 목적을 위해 핸들러 상태를 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a8935ee23c0cb706a83f87286f51dc3308c662e0" translate="yes" xml:space="preserve">
          <source>This callback is optional. Set the &lt;code&gt;accept_handshake_complete&lt;/code&gt; field in the &lt;code&gt;ei_socket_callbacks&lt;/code&gt; structure to &lt;code&gt;NULL&lt;/code&gt; if not implemented.</source>
          <target state="translated">이 콜백은 선택 사항입니다. 구현되지 않은 경우 &lt;code&gt;ei_socket_callbacks&lt;/code&gt; 구조 의 &lt;code&gt;accept_handshake_complete&lt;/code&gt; 필드 를 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c513a3136958e118a1ed88eed71f06f5a1ba1689" translate="yes" xml:space="preserve">
          <source>This callback is optional. Set the &lt;code&gt;connect_handshake_complete&lt;/code&gt; field in the &lt;code&gt;ei_socket_callbacks&lt;/code&gt; structure to &lt;code&gt;NULL&lt;/code&gt; if not implemented.</source>
          <target state="translated">이 콜백은 선택 사항입니다. 구현되지 않은 경우 &lt;code&gt;ei_socket_callbacks&lt;/code&gt; 구조 의 &lt;code&gt;connect_handshake_complete&lt;/code&gt; 필드 를 &lt;code&gt;NULL&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a0e38e8024185274ef8f80ab9c3c0eabdc425b5d" translate="yes" xml:space="preserve">
          <source>This callback is optional. Set the &lt;code&gt;writev&lt;/code&gt; field in the the &lt;code&gt;ei_socket_callbacks&lt;/code&gt; structure to &lt;code&gt;NULL&lt;/code&gt; if not implemented.</source>
          <target state="translated">이 콜백은 선택 사항입니다. 구현되지 않은 경우 &lt;code&gt;ei_socket_callbacks&lt;/code&gt; 구조 의 &lt;code&gt;writev&lt;/code&gt; 필드 를 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e665adac2e338eb903db4caf99617c276a94da3" translate="yes" xml:space="preserve">
          <source>This callback may also return the port of the given node. In that case &lt;code&gt;port_please/3&lt;/code&gt; may be omitted.</source>
          <target state="translated">이 콜백은 주어진 노드의 포트를 반환 할 수도 있습니다. 이 경우 &lt;code&gt;port_please/3&lt;/code&gt; 는 생략해도됩니다.</target>
        </trans-unit>
        <trans-unit id="220a2abc00984810bc967fbaf4c4a46c06726d6c" translate="yes" xml:space="preserve">
          <source>This can also be achieved in a more customized way by using parameter &lt;code&gt;export&lt;/code&gt; in the cover specification and analysing the result off line. However, the cross cover mechanism is a built-in solution that also provides logging.</source>
          <target state="translated">또한 커버 사양에서 파라미터 &lt;code&gt;export&lt;/code&gt; 를 사용 하고 결과 오프라인을 분석 하여보다 사용자 정의 된 방식으로 달성 할 수 있습니다 . 그러나 교차 커버 메커니즘은 로깅을 제공하는 내장 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="d55911e226611b9c595d6a76da5448bc48c50a57" translate="yes" xml:space="preserve">
          <source>This can be defined as follows, but is faster:</source>
          <target state="translated">이것은 다음과 같이 정의 할 수 있지만 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="051b7b690babeaa0408d0d0c0e8d2f3f38cca0df" translate="yes" xml:space="preserve">
          <source>This can be done, for example, by focusing on one state at the time and for every state ensure that all events are handled. Alternatively, you can focus on one event at the time and ensure that it is handled in every state. You can also use a mix of these strategies.</source>
          <target state="translated">예를 들어, 한 번에 하나의 상태에 집중하고 모든 상태에 대해 모든 이벤트가 처리되도록 할 수 있습니다. 또는 한 번에 하나의 이벤트에만 집중하여 모든 주에서 처리되도록 할 수 있습니다. 이러한 전략을 혼합하여 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4598fb964d80c17b9042cf3810c56c1f2f70ecf" translate="yes" xml:space="preserve">
          <source>This can be the name of a binary log, a list of such logs, or the name of a directory containing one or more binary logs.</source>
          <target state="translated">이진 로그의 이름, 이러한 로그 목록 또는 하나 이상의 이진 로그를 포함하는 디렉토리의 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d49d5ccf3611383b79c9580f8c0026d786e3ee8" translate="yes" xml:space="preserve">
          <source>This can be used for various purposes, for example, writing a term to a file in an efficient way, or sending an Erlang term to some type of communications channel not supported by distributed Erlang.</source>
          <target state="translated">이는 효율적인 방법으로 파일에 용어를 쓰거나 분산 된 Erlang이 지원하지 않는 일부 유형의 통신 채널로 Erlang 용어를 보내는 등의 다양한 목적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a87fd0d612d477544f48342a46839027b50293f1" translate="yes" xml:space="preserve">
          <source>This can be used to detect problems with NIFs or drivers that take too long to execute. 1 ms is considered a good maximum time for a driver callback or a NIF. However, a time-sharing system is usually to consider everything &amp;lt; 100 ms as &quot;possible&quot; and fairly &quot;normal&quot;. However, longer schedule times can indicate swapping or a misbehaving NIF/driver. Misbehaving NIFs and drivers can cause bad resource utilization and bad overall system performance.</source>
          <target state="translated">NIF 또는 드라이버 실행에 시간이 오래 걸리는 문제를 감지하는 데 사용할 수 있습니다. 1ms는 드라이버 콜백 또는 NIF에 대한 최대 시간으로 간주됩니다. 그러나 시분할 시스템은 일반적으로 100ms 미만의 모든 것을 &quot;가능한&quot;그리고 상당히 &quot;정상적인&quot;것으로 간주해야합니다. 그러나 스케줄 시간이 길면 스와핑 또는 NIF / 드라이버의 오작동을 나타낼 수 있습니다. NIF 및 드라이버가 잘못 작동하면 리소스 사용률이 저하되고 전체 시스템 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c309ba8d110cc132caf3f434048be18fd8c888d" translate="yes" xml:space="preserve">
          <source>This can be useful to know, even if &lt;code&gt;systools&lt;/code&gt; is not used, since Erlang/OTP is packaged according to the OTP principles and thus comes with a specific directory structure. The code server (see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel) automatically uses code from the directory with the highest version number, if more than one version of an application is present.</source>
          <target state="translated">Erlang / OTP는 OTP 원칙에 따라 패키지화되어 특정 디렉토리 구조가 제공되므로 &lt;code&gt;systools&lt;/code&gt; 를 사용하지 않아도 알 수 있습니다 . 코드 서버 ( 커널 의 &lt;code&gt;code(3)&lt;/code&gt; 매뉴얼 페이지 참조)는 둘 이상의 응용 프로그램 버전이있는 경우 버전 번호가 가장 높은 디렉토리의 코드를 자동으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c0a78708d83a11d18d7b6fde7a226d981a5c9a17" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to hold arbitrary terms: skip them and copy the binary term data to some buffer.</source>
          <target state="translated">이는 임의의 용어를 유지하려는 경우 유용합니다.이 용어를 건너 뛰고 이진 용어 데이터를 일부 버퍼에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="9dccf3f6d2f60b79a3b5bd80d61cef8142d3c9f1" translate="yes" xml:space="preserve">
          <source>This can occur even if a &lt;code&gt;reload&lt;/code&gt; option is specified, if &lt;code&gt;DriverOptionList&lt;/code&gt; differs from the current.</source>
          <target state="translated">&lt;code&gt;DriverOptionList&lt;/code&gt; 가 현재와 다른 경우 &lt;code&gt;reload&lt;/code&gt; 옵션이 지정된 경우에도 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e696f35629ec0f432c29538e2e6c58a6cd4c896e" translate="yes" xml:space="preserve">
          <source>This can override the configuration parameters &lt;code&gt;nameserver&lt;/code&gt; and &lt;code&gt;search&lt;/code&gt; depending on the contents of the specified file. They can also change any time in the future reflecting the file contents.</source>
          <target state="translated">이 구성 매개 변수를 대체 할 수 있습니다 &lt;code&gt;nameserver&lt;/code&gt; 와 &lt;code&gt;search&lt;/code&gt; 지정된 파일의 내용에 따라 달라집니다. 또한 파일 내용을 반영하여 나중에 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dec9a62f192435d695441ed01fd661a8d8c315a" translate="yes" xml:space="preserve">
          <source>This causes &lt;code&gt;epmd&lt;/code&gt; to close the connection from the far end. Notice that if the name was in fact still in use by a node, the results of this operation are unpredictable. Also, doing this does not cause the local end of the connection to close, so resources can be consumed.</source>
          <target state="translated">이로 인해 &lt;code&gt;epmd&lt;/code&gt; 가 원단 에서 연결을 닫습니다. 실제로 노드에서 이름을 계속 사용중인 경우이 작업의 결과를 예측할 수 없습니다. 또한 이렇게하면 연결의 로컬 끝이 닫히지 않으므로 리소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14b393bb418a216b0875dc8287af117dd7067bb" translate="yes" xml:space="preserve">
          <source>This causes a parse transform to substitute a fun for the QLC. The (compiled) fun is called when the query handle is evaluated.</source>
          <target state="translated">이로 인해 구문 분석 변환이 QLC를 대체 할 수 있습니다. 쿼리 핸들이 평가 될 때 (컴파일 된) fun이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6b5f81b2ddca32cf291bc3217d330648ab91cbde" translate="yes" xml:space="preserve">
          <source>This causes a warning for an unused variable, &lt;code&gt;Elem&lt;/code&gt;, if the code is compiled with the flag &lt;code&gt;warn_unused_vars&lt;/code&gt; set. Instead, the code can be rewritten to:</source>
          <target state="translated">코드가 &lt;code&gt;warn_unused_vars&lt;/code&gt; 플래그 로 설정된 경우 사용되지 않는 변수 &lt;code&gt;Elem&lt;/code&gt; 에 대한 경고가 발생합니다 . 대신 코드를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb1d2e7687337b9f0ef3870a3a41bbcb1151114" translate="yes" xml:space="preserve">
          <source>This causes outstanding megaco:call/3 requests to return. The callback functions UserMod:handle_reply/4 and UserMod:handle_trans_ack/4 are also invoked where it applies. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">이로 인해 뛰어난 megaco : call / 3 요청이 리턴됩니다. 콜백 함수 UserMod : handle_reply / 4 및 UserMod : handle_trans_ack / 4도 적용되는 위치에서 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="68c0a11988374396554e35c1339e4b4d296f9cbb" translate="yes" xml:space="preserve">
          <source>This causes the variable to be lifted (after parsing) to the next higher level in the syntax tree, replacing that entire subtree. In this case, the &lt;code&gt;'@_@Name'/0&lt;/code&gt; will be replaced with &lt;code&gt;'@@Name'&lt;/code&gt;, and the &lt;code&gt;/0&lt;/code&gt; part was just used as dummy notation and will be discarded.</source>
          <target state="translated">이로 인해 구문 트리에서 다음 상위 레벨로 변수가 상승 (구문 분석 후)되어 하위 트리 전체가 대체됩니다. 이 경우, &lt;code&gt;'@_@Name'/0&lt;/code&gt; 으로 대체한다 &lt;code&gt;'@@Name'&lt;/code&gt; , 및 &lt;code&gt;/0&lt;/code&gt; 부를 그냥 더미 표기로 사용하고 폐기한다.</target>
        </trans-unit>
        <trans-unit id="9ae4d618ecb9ded2a891114f68fd094d009bf146" translate="yes" xml:space="preserve">
          <source>This chapter aims at explaining the differences and giving a rationale for why Erlang/OTP handles &quot;user&quot; as it does.</source>
          <target state="translated">이 장은 차이점을 설명하고 Erlang / OTP가 &quot;사용자&quot;를 처리하는 이유에 대한 근거를 제공하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="84078e161475adc15a1fe15da8646e8557d4b551" translate="yes" xml:space="preserve">
          <source>This chapter briefly describes Erlang records derived from ASN.1 specifications used to handle public key infrastructure. The scope is to describe the data types of each component, not the semantics. For information on the semantics, refer to the relevant standards and RFCs linked in the sections below.</source>
          <target state="translated">이 장에서는 공개 키 인프라를 처리하는 데 사용되는 ASN.1 사양에서 파생 된 Erlang 레코드에 대해 간략하게 설명합니다. 범위는 의미가 아닌 각 구성 요소의 데이터 유형을 설명하는 것입니다. 의미에 대한 정보는 아래 섹션에 링크 된 관련 표준 및 RFC를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2f23bd1830ba030caede6017d114b23d96a8156" translate="yes" xml:space="preserve">
          <source>This chapter contains in extenso versions of the OpenSSL and SSLeay licenses.</source>
          <target state="translated">이 장에는 Extenso 버전의 OpenSSL 및 SSLeay 라이센스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b1d044a8e1dfdfc0b3ead8b82c9c3d5d936b5ef" translate="yes" xml:space="preserve">
          <source>This chapter describes FIPS mode support in the crypto application.</source>
          <target state="translated">이 장에서는 암호화 응용 프로그램의 FIPS 모드 지원에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5241988387a67e2c505ee80c2f8d37b1169baacf" translate="yes" xml:space="preserve">
          <source>This chapter describes details of algorithms in the crypto application.</source>
          <target state="translated">이 장에서는 암호화 애플리케이션의 알고리즘에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5f466e689949ed0c106ed58e883f29857cfc9906" translate="yes" xml:space="preserve">
          <source>This chapter describes the new api to encryption and decryption.</source>
          <target state="translated">이 장에서는 암호화 및 암호 해독에 대한 새로운 API를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ffd1f44c4ed57b40721b93cf5c0efd3d78d52a33" translate="yes" xml:space="preserve">
          <source>This chapter describes the support for loading encryption engines in the crypto application.</source>
          <target state="translated">이 장에서는 암호화 응용 프로그램에서 암호화 엔진을로드하기위한 지원에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="84e8d13b539f47c00293308a5f44715292e8675e" translate="yes" xml:space="preserve">
          <source>This chapter describes the support in the crypto application for using public and private keys stored in encryption engines.</source>
          <target state="translated">이 장에서는 암호화 엔진에 저장된 공개 및 개인 키를 사용하기위한 암호화 응용 프로그램의 지원에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="66dda50ba5ba17ea40a6d362cc6e7f81e1f3b82a" translate="yes" xml:space="preserve">
          <source>This chapter is about creating such a system, which is called a &lt;strong&gt;target system&lt;/strong&gt;.</source>
          <target state="translated">이 장은 이러한 시스템을 작성하는 것에 관한 것이며,이를 &lt;strong&gt;대상 시스템&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="303cc2fd7c07d62117308f568c6c7a69cd42b456" translate="yes" xml:space="preserve">
          <source>This checks that the pid &lt;code&gt;From&lt;/code&gt; is in the &lt;code&gt;User_List&lt;/code&gt;:</source>
          <target state="translated">이것은 pid &lt;code&gt;From&lt;/code&gt; 이 &lt;code&gt;User_List&lt;/code&gt; 에 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d13a092e40b41fbf6f89dd0baee37b0578462112" translate="yes" xml:space="preserve">
          <source>This clause is equivalent to &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;send(Socket, Host, Port, [], Packet)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 절은 &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;send(Socket, Host, Port, [], Packet)&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cd754cddd9c96097f025a6b91734f43531e07dcf" translate="yes" xml:space="preserve">
          <source>This closes the Erlang/OTP shell.</source>
          <target state="translated">Erlang / OTP 쉘이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7d1fa1715e259b26d3b25f592aabf2747c705ee2" translate="yes" xml:space="preserve">
          <source>This code adds a set of people to the database. Running this code within one transaction ensures that either the whole family is added to the database, or the whole transaction terminates. For example, if the last child is badly formatted, or the executing process terminates because of an &lt;code&gt;'EXIT'&lt;/code&gt; signal while executing the family code, the transaction terminates. Thus, the situation where half a family is added can never occur.</source>
          <target state="translated">이 코드는 일련의 사람들을 데이터베이스에 추가합니다. 한 트랜잭션 내에서이 코드를 실행하면 전체 제품군이 데이터베이스에 추가되거나 전체 트랜잭션이 종료됩니다. 예를 들어, 마지막 자식의 형식이 잘못되었거나 패밀리 코드를 실행하는 동안 &lt;code&gt;'EXIT'&lt;/code&gt; 신호로 인해 실행 프로세스가 종료 되면 트랜잭션이 종료됩니다. 따라서 반 가족이 추가되는 상황은 절대 발생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98b115ab987715d60781ca89e47fa4411fb40cb5" translate="yes" xml:space="preserve">
          <source>This code behaves differently from &quot;&lt;code&gt;--&lt;/code&gt;&quot; if the lists contain duplicate elements (one occurrence of an element in HugeList2 removes &lt;strong&gt;all&lt;/strong&gt; occurrences in HugeList1.)</source>
          <target state="translated">목록에 중복 요소가 포함 된 경우이 코드는 &quot; &lt;code&gt;--&lt;/code&gt; &quot; 와 다르게 작동 합니다 . HugeList2 에서 한 요소의 항목이 HugeList1의 &lt;strong&gt;모든&lt;/strong&gt; 항목을 제거 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="620f0e09a670821d9a2abe04fa98afa74a5ef2a9" translate="yes" xml:space="preserve">
          <source>This code is easier to write and to understand, and it also executes much faster.</source>
          <target state="translated">이 코드는 작성하고 이해하기가 더 쉬우 며 훨씬 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="92fb78009d0b11b8b67edb3a1a517f7f5d300af8" translate="yes" xml:space="preserve">
          <source>This code lock state machine can be implemented using &lt;code&gt;gen_statem&lt;/code&gt; with the following &lt;strong&gt;callback module&lt;/strong&gt;:</source>
          <target state="translated">이 코드 잠금 상태 머신은 다음 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 과 함께 &lt;code&gt;gen_statem&lt;/code&gt; 을 사용하여 구현할 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2b34933ffae95b8a853f8ff645604fbd952d3ab" translate="yes" xml:space="preserve">
          <source>This code lock state machine can be implemented using &lt;code&gt;gen_statem&lt;/code&gt; with the following callback module:</source>
          <target state="translated">이 코드 잠금 상태 머신은 다음 콜백 모듈과 함께 &lt;code&gt;gen_statem&lt;/code&gt; 을 사용하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b2443919e593a0d589592796a6acfa56ef58bd8" translate="yes" xml:space="preserve">
          <source>This code uses the function &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;s_write/1&lt;/a&gt;&lt;/code&gt; instead of the function &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; The function &lt;code&gt;s_write/1&lt;/code&gt; sets a sticky lock instead of a normal lock. If the table is not replicated, sticky locks have no special effect. If the table is replicated, and a sticky lock is set on node &lt;code&gt;N1&lt;/code&gt;, this lock then sticks to node &lt;code&gt;N1&lt;/code&gt;. The next time you try to set a sticky lock on the same record at node &lt;code&gt;N1&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; detects that the lock is already set and do no network operation to acquire the lock.</source>
          <target state="translated">이 코드는 함수를 사용 &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;s_write/1&lt;/a&gt;&lt;/code&gt; 대신 함수의 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; 함수 &lt;code&gt;s_write/1&lt;/code&gt; 세트 대신 통상 자물쇠의 잠금 스티커. 테이블이 복제되지 않은 경우 고정 잠금은 특별한 영향을 미치지 않습니다. 테이블이 복제되고, 끈적 잠금이 노드에 설정되어있는 경우 &lt;code&gt;N1&lt;/code&gt; , 노드 스틱 다음이 잠금 &lt;code&gt;N1&lt;/code&gt; . 당신이 노드에서 동일한 레코드에 끈적 잠금 설정하려고 다음에 &lt;code&gt;N1&lt;/code&gt; 은 , &lt;code&gt;Mnesia&lt;/code&gt; 는 잠금이 이미 설정하고 잠금을 획득 할 네트워크 작업을 수행 할 않은 것을 감지.</target>
        </trans-unit>
        <trans-unit id="d473cae681409fa329e6bc7b44d312e6bb308a91" translate="yes" xml:space="preserve">
          <source>This command can only be used when contacting &lt;code&gt;epmd&lt;/code&gt; instances started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;.</source>
          <target state="translated">이 명령은 플래그 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 로 시작된 &lt;code&gt;epmd&lt;/code&gt; 인스턴스에 접속할 때만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8da29ec7d90c1769855d7fc9ae5d438b9bb9d86" translate="yes" xml:space="preserve">
          <source>This command file is then set as heart command.</source>
          <target state="translated">그런 다음이 명령 파일은 heart 명령으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="52d8f2983dee948139d1e9e434673f9c52bda692" translate="yes" xml:space="preserve">
          <source>This command will create a file named &lt;code&gt;root.TAGS&lt;/code&gt; in the current directory. The file will contain references to all Erlang source files in the Erlang distribution.</source>
          <target state="translated">이 명령은 현재 디렉토리에 &lt;code&gt;root.TAGS&lt;/code&gt; 라는 파일을 만듭니다 . 이 파일에는 Erlang 배포의 모든 Erlang 소스 파일에 대한 참조가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="aa2bc19b983020ccb9b326fcd4731f0bd1161c57" translate="yes" xml:space="preserve">
          <source>This composes a test set from the exported test functions of the named module, i.e., those functions with arity zero whose names end with &lt;code&gt;_test&lt;/code&gt; or &lt;code&gt;_test_&lt;/code&gt;. Basically, the &lt;code&gt;..._test()&lt;/code&gt; functions become simple tests, while the &lt;code&gt;..._test_()&lt;/code&gt; functions become generators.</source>
          <target state="translated">명명 된 모듈의 내 보낸 테스트 함수, 즉 이름이 &lt;code&gt;_test&lt;/code&gt; 또는 &lt;code&gt;_test_&lt;/code&gt; 로 끝나는 arity 0 인 함수에서 테스트 세트를 구성합니다 . 기본적으로 &lt;code&gt;..._test()&lt;/code&gt; 함수는 간단한 테스트가되고 &lt;code&gt;..._test_()&lt;/code&gt; 함수는 생성자가됩니다.</target>
        </trans-unit>
        <trans-unit id="63c3c21b3eef82be8246811ccf2f3c14d371f943" translate="yes" xml:space="preserve">
          <source>This concludes the example. It is fully runnable and you can read or write to the I/O server by using, for example, the &lt;code&gt;io&lt;/code&gt; module or even the &lt;code&gt;file&lt;/code&gt; module. It is as simple as that to implement a fully fledged I/O server in Erlang.</source>
          <target state="translated">이것으로 예제가 끝납니다. 완전히 실행 가능하며 예를 들어 &lt;code&gt;io&lt;/code&gt; 모듈 또는 &lt;code&gt;file&lt;/code&gt; 모듈 을 사용하여 I / O 서버를 읽거나 쓸 수 있습니다 . Erlang에서 본격적인 I / O 서버를 구현하는 것만 큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1bc6422d46a0ceffe44a706f105bee33bbb50726" translate="yes" xml:space="preserve">
          <source>This concludes the quick tour of the features of &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="translated">이것으로 &lt;strong&gt;beam_makeops&lt;/strong&gt; 의 기능에 대한 빠른 둘러보기를 &lt;strong&gt;마칩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="33f0e49393f960fdbb1f12f5f92189e125a0ce06" translate="yes" xml:space="preserve">
          <source>This configuration function is called as the first function in the suite. It typically contains initializations that are common for all test cases in the suite, and that must only be done once. Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. Whatever is returned from this function is specified as &lt;code&gt;Config&lt;/code&gt; to all configuration functions and test cases in the suite.</source>
          <target state="translated">이 구성 기능을 제품군의 첫 번째 기능이라고합니다. 일반적으로 제품군의 모든 테스트 사례에 공통적 인 초기화가 포함되며 한 번만 수행해야합니다. Parameter &lt;code&gt;Config&lt;/code&gt; 는 수정할 수있는 구성 데이터입니다. 이 기능은 다음과 같이 지정에서 무엇이든은 반환 &lt;code&gt;Config&lt;/code&gt; 제품군의 모든 구성 기능과 테스트 케이스에.</target>
        </trans-unit>
        <trans-unit id="e7813765274dd4ee3556852945789f955a7b535a" translate="yes" xml:space="preserve">
          <source>This configuration function is called before execution of a test case group. It typically contains initializations that are common for all test cases and subgroups in the group, and that must only be performed once. &lt;code&gt;GroupName&lt;/code&gt; is the name of the group, as specified in the group definition (see &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;Module:groups/0&lt;/a&gt;&lt;/code&gt;). Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. The return value of this function is given as &lt;code&gt;Config&lt;/code&gt; to all test cases and subgroups in the group.</source>
          <target state="translated">이 구성 함수는 테스트 케이스 그룹을 실행하기 전에 호출됩니다. 일반적으로 그룹의 모든 테스트 케이스 및 하위 그룹에 공통적이며 한 번만 수행해야하는 초기화가 포함됩니다. &lt;code&gt;GroupName&lt;/code&gt; 은 그룹 정의에 지정된대로 그룹의 이름입니다 ( &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;Module:groups/0&lt;/a&gt;&lt;/code&gt; 참조 ). Parameter &lt;code&gt;Config&lt;/code&gt; 는 수정할 수있는 구성 데이터입니다. 이 함수의 반환 값은 그룹의 모든 테스트 케이스 및 하위 그룹에 &lt;code&gt;Config&lt;/code&gt; 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fc12196aaa3c7c817d997888a6e0c0d511e97b1" translate="yes" xml:space="preserve">
          <source>This configuration function is called before execution of a test case group. It typically contains initializations that are common for all test cases and subgroups in the group, and that must only be performed once. &lt;code&gt;GroupName&lt;/code&gt; is the name of the group, as specified in the group definition (see &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt;). Parameter &lt;code&gt;Config&lt;/code&gt; is the configuration data that can be modified. The return value of this function is given as &lt;code&gt;Config&lt;/code&gt; to all test cases and subgroups in the group.</source>
          <target state="translated">이 구성 함수는 테스트 케이스 그룹을 실행하기 전에 호출됩니다. 일반적으로 그룹의 모든 테스트 사례 및 하위 그룹에 공통적 인 초기화가 포함되며 한 번만 수행해야합니다. &lt;code&gt;GroupName&lt;/code&gt; 은 그룹 정의에 지정된 그룹의 이름입니다 ( &lt;code&gt;&lt;a href=&quot;#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 참조 ). Parameter &lt;code&gt;Config&lt;/code&gt; 는 수정할 수있는 구성 데이터입니다. 이 함수의 반환 값은 그룹의 모든 테스트 사례 및 하위 그룹에 &lt;code&gt;Config&lt;/code&gt; 으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b59f052b21fb5d16deae6ffc52f3f1d17300c30" translate="yes" xml:space="preserve">
          <source>This configuration parameter defaults &lt;code&gt;false&lt;/code&gt; and will do so up until OTP 23. As of OTP 24 this configuration parameter will be removed and &lt;code&gt;get_system_memory_data()&lt;/code&gt; will begin behaving as it does now when the configuration parameter has been set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 구성 매개 변수의 기본값은 &lt;code&gt;false&lt;/code&gt; 이며 OTP 23까지 수행됩니다. OTP 24부터는이 구성 매개 변수가 제거되고 &lt;code&gt;get_system_memory_data()&lt;/code&gt; 는 구성 매개 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정되었을 때와 같이 작동하기 시작 합니다 .</target>
        </trans-unit>
        <trans-unit id="23368b3fe2d449c2692eb8e3e91bed68d4ab16da" translate="yes" xml:space="preserve">
          <source>This conforms to the format used by the scanner in the Erlang &lt;code&gt;io&lt;/code&gt; library module.</source>
          <target state="translated">이것은 Erlang &lt;code&gt;io&lt;/code&gt; 라이브러리 모듈 에서 스캐너가 사용하는 형식을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="89e7ad5998bd8d56a5635438c81b21cdbc5fbf20" translate="yes" xml:space="preserve">
          <source>This construction does not consume any messages, only suspends execution in the process for &lt;code&gt;ExprT&lt;/code&gt; milliseconds. This can be used to implement simple timers.</source>
          <target state="translated">이 구성은 메시지를 소비하지 않으며 &lt;code&gt;ExprT&lt;/code&gt; 밀리 초 동안 프로세스에서 실행을 일시 중단 합니다. 간단한 타이머를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b232bbe87386ece629cac0a167c63032d6651c" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT2&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;EXIT2&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 가 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="31e56f278047c16bfcdee2f58fb054509e25ef75" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT2_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;EXIT2_TT&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 가 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f2c61e7c0a9740ed09540a374d303740287e237" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;EXIT&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 가 협상 되었을 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="900bb411e26a0ffdc2a46615c860d514eaa89642" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;EXIT_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;EXIT_TT&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 가 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="b27db693ded90f8d66758ebab03e1e0cfcb72730" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;MONITOR_P_EXIT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;MONITOR_P_EXIT&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_EXIT_PAYLOAD&lt;/a&gt;&lt;/code&gt; 가 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ba4af6a7f34aa01d96e5575c3aff6bb9e026456" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;SEND&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;SEND&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 가 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="13ed13e3031f229e67c3f6d88ff54ba590b010d0" translate="yes" xml:space="preserve">
          <source>This control message replaces the &lt;code&gt;SEND_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;SEND_TT&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 가 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff79977655b81c53aa0929475789c463d4c65ccd" translate="yes" xml:space="preserve">
          <source>This control messages replace the &lt;code&gt;SEND&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;SEND&lt;/code&gt; 제어 메시지를 대체하며 분배 설정 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 가 연결 설정 핸드 셰이크에서 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="61b1bf1e5da0665206d28c63a8251c70f9437da9" translate="yes" xml:space="preserve">
          <source>This control messages replace the &lt;code&gt;SEND_TT&lt;/code&gt; control message and will be sent when the distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; has been negotiated in the connection setup handshake.</source>
          <target state="translated">이 제어 메시지는 &lt;code&gt;SEND_TT&lt;/code&gt; 제어 메시지를 대체 하며 연결 ​​설정 핸드 셰이크에서 분배 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;DFLAG_SEND_SENDER&lt;/a&gt;&lt;/code&gt; 가 협상 될 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="3811bd05c74f86fcbc14a9c1b9034f65fa2fcd06" translate="yes" xml:space="preserve">
          <source>This could be accomplished with the option &lt;code&gt;fail_callback&lt;/code&gt; which will be called if the hostname verification fails:</source>
          <target state="translated">호스트 이름 확인에 실패한 경우 호출되는 &lt;code&gt;fail_callback&lt;/code&gt; 옵션을 사용하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51a1cc36e31cb197216b50eb9eb632d0459ddabc" translate="yes" xml:space="preserve">
          <source>This creates a boot script, both the readable version, &lt;code&gt;ch_rel-1.script&lt;/code&gt;, and the binary version, &lt;code&gt;ch_rel-1.boot&lt;/code&gt;, used by the runtime system.</source>
          <target state="translated">이렇게하면 런타임 시스템에서 사용되는 읽기 가능한 버전 &lt;code&gt;ch_rel-1.script&lt;/code&gt; 및 이진 버전 인 &lt;code&gt;ch_rel-1.boot&lt;/code&gt; 의 부트 스크립트가 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="8f83e183c685a8bf96ad1d1d03b74d255f5c951a" translate="yes" xml:space="preserve">
          <source>This creates a test set from all the modules belonging to the specified application, by consulting the application's &lt;code&gt;.app&lt;/code&gt; file (see &lt;code&gt;{file, FileName}&lt;/code&gt;), or if no such file exists, by testing all object files in the application's &lt;code&gt;ebin&lt;/code&gt;-directory (see &lt;code&gt;{dir, Path}&lt;/code&gt;); if that does not exist, the &lt;code&gt;code:lib_dir(AppName)&lt;/code&gt; directory is used.</source>
          <target state="translated">애플리케이션의 &lt;code&gt;.app&lt;/code&gt; 파일 ( &lt;code&gt;{file, FileName}&lt;/code&gt; 참조)을 참조 하거나 해당 파일이없는 경우 애플리케이션의 &lt;code&gt;ebin&lt;/code&gt; -directory ( 참조 &lt;code&gt;{dir, Path}&lt;/code&gt; ); 존재하지 않으면 &lt;code&gt;code:lib_dir(AppName)&lt;/code&gt; 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7dfbabbf55ded6bc40cb089b7e7b9db65720b207" translate="yes" xml:space="preserve">
          <source>This creates a tuple with the brand of the motorcycle and the output format. We use the brand name only for sorting purpose. We have to end the template function with the &quot;built in clause&quot; &lt;code&gt;template(E) -&amp;gt; built_in_rules(fun template/1, E).&lt;/code&gt;</source>
          <target state="translated">이것은 오토바이 브랜드와 출력 형식으로 튜플을 만듭니다. 우리는 분류 목적으로 만 브랜드 이름을 사용합니다. &quot;built in clause&quot; &lt;code&gt;template(E) -&amp;gt; built_in_rules(fun template/1, E).&lt;/code&gt; 템플릿 함수를 종료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd1d3feb38283e93bdf7380a9a3f2767d2d85c6a" translate="yes" xml:space="preserve">
          <source>This creates an &lt;code&gt;(ETERM *)&lt;/code&gt; structure corresponding to the Erlang term &lt;code&gt;[{name,madonna},{age,21},{data,[{adr,&quot;E-street&quot;,42}]}]&lt;/code&gt;</source>
          <target state="translated">그러면 Erlang 용어 &lt;code&gt;[{name,madonna},{age,21},{data,[{adr,&quot;E-street&quot;,42}]}]&lt;/code&gt; 에 해당 하는 &lt;code&gt;(ETERM *)&lt;/code&gt; 구조 가 생성 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae606f82f5ea62f5942a0adf3b9e512950c71e07" translate="yes" xml:space="preserve">
          <source>This creates an additional folder in &lt;code&gt;$ERL_TOP/release&lt;/code&gt; called &lt;code&gt;tests&lt;/code&gt;. Now, it's time to start the smoke test.</source>
          <target state="translated">&lt;code&gt;$ERL_TOP/release&lt;/code&gt; &lt;code&gt;tests&lt;/code&gt; 라는 추가 폴더가 생성 됩니다. 이제 연기 테스트를 시작할 차례입니다.</target>
        </trans-unit>
        <trans-unit id="ef73a8deed0f6aa219ae36f5994c464c421d1dae" translate="yes" xml:space="preserve">
          <source>This creates an anonymous function of &lt;code&gt;N&lt;/code&gt; arguments and binds it to the variable &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 &lt;code&gt;N&lt;/code&gt; 개의 인수로 구성된 익명 함수가 만들어 지고 변수 &lt;code&gt;F&lt;/code&gt; 에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="524be8f1a981b01e7043d75c61d487bdaac91459" translate="yes" xml:space="preserve">
          <source>This creates:</source>
          <target state="translated">이것은 다음을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c46e82b8048ee48e1624490a06ae6b4a6e2f1c62" translate="yes" xml:space="preserve">
          <source>This daemon acts as a name server on all hosts involved in distributed Erlang computations. When an Erlang node starts, the node has a name and it obtains an address from the host OS kernel. The name and address are sent to the &lt;code&gt;epmd&lt;/code&gt; daemon running on the local host. In a TCP/IP environment, the address consists of the IP address and a port number. The node name is an atom on the form of &lt;code&gt;Name@Node&lt;/code&gt;. The job of the &lt;code&gt;epmd&lt;/code&gt; daemon is to keep track of which node name listens on which address. Hence, &lt;code&gt;epmd&lt;/code&gt; maps symbolic node names to machine addresses.</source>
          <target state="translated">이 데몬은 분산 Erlang 계산에 관련된 모든 호스트에서 이름 서버 역할을합니다. Erlang 노드가 시작되면 노드 이름이 있으며 호스트 OS 커널에서 주소를 얻습니다. 이름과 주소는 로컬 호스트에서 실행중인 &lt;code&gt;epmd&lt;/code&gt; 데몬으로 전송됩니다 . TCP / IP 환경에서 주소는 IP 주소와 포트 번호로 구성됩니다. 노드 이름은 &lt;code&gt;Name@Node&lt;/code&gt; 형식의 원자입니다 . &lt;code&gt;epmd&lt;/code&gt; 데몬 의 작업은 어떤 노드 이름이 어떤 주소에서 수신하는지 추적하는 것입니다. 따라서 &lt;code&gt;epmd&lt;/code&gt; 는 기호 노드 이름을 시스템 주소에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="be132e0b64312cab1412b3c061af9dbcd07c2db2" translate="yes" xml:space="preserve">
          <source>This data can also be specified explicitly in the user configuration file. This file is to contain lines of configuration parameters (each terminated with a full stop). Some parameters add data to the configuration (such as host and nameserver), others overwrite any previous settings (such as domain and lookup). The user configuration file is always examined last in the configuration process, making it possible for the user to override any default values or previously made settings. Call &lt;code&gt;inet:get_rc()&lt;/code&gt; to view the state of the &lt;code&gt;inet&lt;/code&gt; configuration database.</source>
          <target state="translated">이 데이터는 사용자 구성 파일에서 명시 적으로 지정할 수도 있습니다. 이 파일은 구성 매개 변수의 행을 포함합니다 (각각 완전히 중지로 종료 됨). 일부 매개 변수는 호스트 및 이름 서버와 같은 구성에 데이터를 추가하고 다른 매개 변수는 도메인 및 조회와 같은 이전 설정을 덮어 씁니다. 사용자 구성 파일은 항상 구성 프로세스의 마지막에서 검사되므로 사용자가 기본값이나 이전에 설정 한 설정을 무시할 수 있습니다. &lt;code&gt;inet:get_rc()&lt;/code&gt; 를 호출 하여 &lt;code&gt;inet&lt;/code&gt; 구성 데이터베이스 의 상태를보십시오 .</target>
        </trans-unit>
        <trans-unit id="48f25fc645975c60f249d68b5dd230f51d28d68c" translate="yes" xml:space="preserve">
          <source>This date and time identifier has the same format as the XML type &lt;code&gt;dateTime&lt;/code&gt; and is compliant with RFC 3339 Date and Time on the Internet Timestamps. The format is as follows:</source>
          <target state="translated">이 날짜 및 시간 식별자는 XML 유형 &lt;code&gt;dateTime&lt;/code&gt; 과 형식이 동일 하며 인터넷 타임 스탬프의 RFC 3339 날짜 및 시간을 준수합니다. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="738523548a30e709bb5b81f10988c30ec76d3772" translate="yes" xml:space="preserve">
          <source>This defines a local function handler that is called with:</source>
          <target state="translated">이것은 다음과 같이 호출되는 로컬 함수 핸들러를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="948cd7e2c415cc3a421a26b31393fafc514d648b" translate="yes" xml:space="preserve">
          <source>This defines a non-local function handler that is called with:</source>
          <target state="translated">이것은 다음과 같이 호출되는 비 로컬 함수 핸들러를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="662f224ab983c6f766721b42aada149c79c7000c" translate="yes" xml:space="preserve">
          <source>This description is far from complete. It will be updated if the protocol is updated. However, the protocols, both from Erlang nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes are stable since many years.</source>
          <target state="translated">이 설명은 완전하지 않습니다. 프로토콜이 업데이트되면 업데이트됩니다. 그러나 Erlang 노드에서 EPDM (Erlang Port Mapper Daemon) 및 Erlang 노드 사이의 프로토콜은 수년 동안 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="e8b60a37d6f9b5dab9afb438915682d979c1ca85" translate="yes" xml:space="preserve">
          <source>This diagnostic warns that the variable &lt;code&gt;X&lt;/code&gt; in the pattern is not the same as the variable &lt;code&gt;X&lt;/code&gt; that occurs in the function head.</source>
          <target state="translated">이 진단 변수 있다고 경고 &lt;code&gt;X&lt;/code&gt; 패턴의 변수와 동일하지 &lt;code&gt;X&lt;/code&gt; 함수 헤드에서 발생한다.</target>
        </trans-unit>
        <trans-unit id="9c0a88d7e60d7e7f1439fe6fcfcc1a50b22440f9" translate="yes" xml:space="preserve">
          <source>This directory is the &lt;strong&gt;installation directory&lt;/strong&gt; of the embedded environment.</source>
          <target state="translated">이 디렉토리는 임베디드 환경 의 &lt;strong&gt;설치 디렉토리&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a3cf407193e52ba658ffaccdcac32c81fba9803" translate="yes" xml:space="preserve">
          <source>This disables the use of style sheets and JavaScripts (see &lt;code&gt;&lt;a href=&quot;#table_sorting&quot;&gt;Sorting HTML Table Columns&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">스타일 시트 및 JavaScript를 사용할 수 없습니다 ( &lt;code&gt;&lt;a href=&quot;#table_sorting&quot;&gt;Sorting HTML Table Columns&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5ecec3c07eff61196ca0de8babf79aab0e2d1d31" translate="yes" xml:space="preserve">
          <source>This document describes how to build and install Erlang/OTP-21. Erlang/OTP should be possible to build from source on any Unix/Linux system, including OS X. You are advised to read the whole document before attempting to build and install Erlang/OTP.</source>
          <target state="translated">이 문서는 Erlang / OTP-21을 구축하고 설치하는 방법을 설명합니다. Erlang / OTP는 OS X를 포함한 모든 Unix / Linux 시스템의 소스에서 빌드 할 수 있어야합니다. Erlang / OTP를 빌드하고 설치하기 전에 전체 문서를 읽어 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b4d112b823ab84ed3043a977bee18b4c73f73d72" translate="yes" xml:space="preserve">
          <source>This document describes how to build and install Erlang/OTP-23. Erlang/OTP should be possible to build from source on any Unix/Linux system, including OS X. You are advised to read the whole document before attempting to build and install Erlang/OTP.</source>
          <target state="translated">이 문서는 Erlang / OTP-23을 빌드하고 설치하는 방법을 설명합니다. Erlang / OTP는 OS X를 포함한 모든 Unix / Linux 시스템의 소스에서 빌드 할 수 있어야합니다. Erlang / OTP를 빌드하고 설치하기 전에 전체 문서를 읽어 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="154342527042516d1b93b9115b8c8965ef041d9a" translate="yes" xml:space="preserve">
          <source>This document describes how to cross compile Erlang/OTP-21. You are advised to read the whole document before attempting to cross compile Erlang/OTP. However, before reading this document, you should read the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document which describes building and installing Erlang/OTP in general. &lt;code&gt;$ERL_TOP&lt;/code&gt; is the top directory in the source tree.</source>
          <target state="translated">이 문서는 Erlang / OTP-21을 크로스 컴파일하는 방법을 설명합니다. Erlang / OTP를 크로스 컴파일하기 전에 전체 문서를 읽는 것이 좋습니다. 그러나이 문서를 읽기 전에 Erlang / OTP의 일반적인 빌드 및 설치를 설명 하는 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 문서를 읽어야합니다 . &lt;code&gt;$ERL_TOP&lt;/code&gt; 은 소스 트리의 최상위 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="8a45990179b4af3d1fed1b433dba16b703f213db" translate="yes" xml:space="preserve">
          <source>This document describes how to cross compile Erlang/OTP-23. You are advised to read the whole document before attempting to cross compile Erlang/OTP. However, before reading this document, you should read the &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; document which describes building and installing Erlang/OTP in general. &lt;code&gt;$ERL_TOP&lt;/code&gt; is the top directory in the source tree.</source>
          <target state="translated">이 문서는 Erlang / OTP-23을 크로스 컴파일하는 방법을 설명합니다. Erlang / OTP를 크로스 컴파일하기 전에 전체 문서를 읽어 보는 것이 좋습니다. 그러나이 문서를 읽기 전에 일반적으로 Erlang / OTP 빌드 및 설치를 설명 하는 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 문서를 읽어야합니다 . &lt;code&gt;$ERL_TOP&lt;/code&gt; 는 소스 트리의 최상위 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="191135bf8635f2eb1fba713547f0e7f062a60990" translate="yes" xml:space="preserve">
          <source>This document describes strategy regarding supported Releases, compatibility, deprecations and removal of functionality. This document was introduced in OTP 21. Actions taken regarding these issues before OTP 21 did not adhere this document.</source>
          <target state="translated">이 문서에서는 지원되는 릴리스, 호환성, 사용 중단 및 기능 제거와 관련된 전략을 설명합니다. 이 문서는 OTP 21에서 도입되었습니다. OTP 21이이 문서를 준수하지 않기 전에 이러한 문제에 대해 취해진 조치.</target>
        </trans-unit>
        <trans-unit id="fc5c2a0c7bfb9a9029380c09ce1ef9700c0544c7" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;strong&gt;beam_makeops&lt;/strong&gt; script.</source>
          <target state="translated">이 문서는 &lt;strong&gt;beam_makeops&lt;/strong&gt; 스크립트를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="71a24568f8a61fe472275bbbf1ab8d95f3724c6d" translate="yes" xml:space="preserve">
          <source>This document describes the process of patching an existing OTP installation with one or more Erlang/OTP applications of newer versions than already installed. The tool &lt;code&gt;otp_patch_apply&lt;/code&gt; is available for this specific purpose. It resides in the top directory of the Erlang/OTP source tree.</source>
          <target state="translated">이 문서는 기존 OTP 설치에 이미 설치된 것보다 최신 버전의 하나 이상의 Erlang / OTP 응용 프로그램을 패치하는 프로세스를 설명합니다. &lt;code&gt;otp_patch_apply&lt;/code&gt; 도구 는이 특정 목적으로 사용 가능합니다. Erlang / OTP 소스 트리의 최상위 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3d8a881ed785c2bbf80ae1ed7354f59f5918b23" translate="yes" xml:space="preserve">
          <source>This document does not give an introduction to XML. There are a lot of books available that describe XML from different views. At the &lt;code&gt;&lt;a href=&quot;http://www.w3.org&quot;&gt;www.W3.org&lt;/a&gt;&lt;/code&gt; site you will find the &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/REC-xml/&quot;&gt;XML 1.0 specification&lt;/a&gt;&lt;/code&gt; and other related specs. One site were you can find tutorials on XML and related specs is &lt;code&gt;&lt;a href=&quot;http://www.zvon.org&quot;&gt;ZVON.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 문서는 XML을 소개하지 않습니다. 다른 관점에서 XML을 설명하는 책들이 많이 있습니다. 상기 &lt;code&gt;&lt;a href=&quot;http://www.w3.org&quot;&gt;www.W3.org&lt;/a&gt;&lt;/code&gt; 의 사이트 당신은 발견 할 것이다 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/REC-xml/&quot;&gt;XML 1.0 specification&lt;/a&gt;&lt;/code&gt; 및 기타 관련 사양. 한 사이트에서 XML에 대한 자습서를 찾을 수 있었고 관련 사양은 &lt;code&gt;&lt;a href=&quot;http://www.zvon.org&quot;&gt;ZVON.org&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="143fad2c70e90531f505c4657ec791c944d5326a" translate="yes" xml:space="preserve">
          <source>This document focuses on the graphical parts of the tool. The concepts are explained in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt;.</source>
          <target state="translated">이 문서는 도구의 그래픽 부분에 중점을 둡니다. 개념은 모듈 &lt;code&gt;reltool&lt;/code&gt; 의 참조 매뉴얼에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0852a621150eac160bbaa6ef0c4a98523bb7541" translate="yes" xml:space="preserve">
          <source>This document list all functionality in Erlang/OTP that currently are scheduled for removal. For more information regarding the strategy regarding removal of functionality see the documentation of &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt;.</source>
          <target state="translated">이 문서는 현재 제거 예정인 Erlang / OTP의 모든 기능을 나열합니다. 기능 제거 전략에 대한 자세한 내용은 &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb9c1c47dda29ee89c688498445546e5263115a7" translate="yes" xml:space="preserve">
          <source>This document lists all deprecated functionality in Erlang/OTP. For more information regarding the strategy regarding deprecations see the documentation of &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt;.</source>
          <target state="translated">이 문서는 Erlang / OTP에서 더 이상 사용되지 않는 모든 기능을 나열합니다. &lt;code&gt;Support, Compatibility, Deprecations, and Removal&lt;/code&gt; 중단 전략에 대한 자세한 내용은 지원, 호환성, 지원 중단 및 제거 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="d0a13f41d530fac43cd74427e80d4e61f60e1273" translate="yes" xml:space="preserve">
          <source>This does not reduce the overall time for the upgrade, but it allows checks and purge to be executed in the background before the real upgrade is started.</source>
          <target state="translated">이렇게하면 전체 업그레이드 시간이 줄어들지는 않지만 실제 업그레이드가 시작되기 전에 백그라운드에서 검사 및 제거가 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05624a0b5087d8c82b1545072e5dc7e9346c97f4" translate="yes" xml:space="preserve">
          <source>This driver is called like the others from Erlang. However, as we use &lt;code&gt;driver_output_term&lt;/code&gt;, there is no need to call &lt;code&gt;binary_to_term&lt;/code&gt;. The Erlang code is in the sample file &lt;code&gt;next_perm.erl&lt;/code&gt;.</source>
          <target state="translated">이 드라이버는 Erlang의 다른 드라이버와 비슷합니다. 그러나 &lt;code&gt;driver_output_term&lt;/code&gt; 을 사용 하므로 &lt;code&gt;binary_to_term&lt;/code&gt; 을 호출 할 필요가 없습니다 . Erlang 코드는 샘플 파일 &lt;code&gt;next_perm.erl&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d94d056a098777bcb956ee04ca4b41885a25660" translate="yes" xml:space="preserve">
          <source>This driver uses the &lt;code&gt;writev&lt;/code&gt; system call to send data onto the socket. A combination of &lt;code&gt;writev&lt;/code&gt; and the driver output queues is very convenient. An &lt;code&gt;ErlIOVec&lt;/code&gt; structure contains a &lt;code&gt;SysIOVec&lt;/code&gt; (which is equivalent to the &lt;code&gt;struct iovec&lt;/code&gt; structure defined in &lt;code&gt;uio.h&lt;/code&gt;. The &lt;code&gt;ErlIOVec&lt;/code&gt; also contains an array of &lt;code&gt;ErlDrvBinary&lt;/code&gt; pointers, of the same length as the number of buffers in the I/O vector itself. One can use this to allocate the binaries for the queue &quot;manually&quot; in the driver, but here the binary array is filled with &lt;code&gt;NULL&lt;/code&gt; values (line 7). The runtime system then allocates its own buffers when &lt;code&gt;driver_enqv&lt;/code&gt; is called (line 37).</source>
          <target state="translated">이 드라이버는 &lt;code&gt;writev&lt;/code&gt; 시스템 호출을 사용 하여 소켓으로 데이터를 보냅니다. &lt;code&gt;writev&lt;/code&gt; 와 드라이버 출력 큐 의 조합 이 매우 편리합니다. &lt;code&gt;ErlIOVec&lt;/code&gt; 의 구조는 포함 &lt;code&gt;SysIOVec&lt;/code&gt; 받는 동등 ( &lt;code&gt;struct iovec&lt;/code&gt; 정의 구조 &lt;code&gt;uio.h&lt;/code&gt; 를 . &lt;code&gt;ErlIOVec&lt;/code&gt; 은 또한 배열 포함 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 의 상기 I / O 벡터 자체 버퍼의 수와 동일한 길이의 포인터. 한 캔 이것을 사용하여 드라이버에서 &quot;수동으로&quot;큐의 바이너리를 할당하지만 여기서 바이너리 배열은 &lt;code&gt;NULL&lt;/code&gt; 값으로 채워집니다 (7 행) 런타임 시스템은 &lt;code&gt;driver_enqv&lt;/code&gt; 일 때 자체 버퍼를 할당합니다. 라고합니다 (37 행).</target>
        </trans-unit>
        <trans-unit id="93162ce71b1395d9e7f9c6b572069d33e4ac790f" translate="yes" xml:space="preserve">
          <source>This driver was written before the runtime system had SMP support. The driver will still function in the runtime system with SMP support, but performance will suffer from lock contention on the driver lock used for the driver. This can be alleviated by reviewing and perhaps rewriting the code so that each instance of the driver safely can execute in parallel. When instances safely can execute in parallel, it is safe to enable instance-specific locking on the driver. This is done by passing &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; as a driver flag. This is left as an exercise for the reader.</source>
          <target state="translated">이 드라이버는 런타임 시스템이 SMP를 지원하기 전에 작성되었습니다. 드라이버는 SMP를 지원하는 런타임 시스템에서 계속 작동하지만 드라이버에 사용되는 드라이버 잠금에 대한 잠금 경합으로 인해 성능이 저하됩니다. 이는 드라이버의 각 인스턴스가 안전하게 병렬로 실행될 수 있도록 코드를 검토하고 다시 작성하여 완화 할 수 있습니다. 인스턴스가 안전하게 병렬로 실행될 수있는 경우 드라이버에서 인스턴스 별 잠금을 활성화하는 것이 안전합니다. 이는 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; 을 드라이버 플래그로 전달하여 수행됩니다 . 이것은 독자를위한 연습 문제로 남겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="08f20d866bfb101e15cb4fdb27b1335c719c4f1c" translate="yes" xml:space="preserve">
          <source>This driver was written before the runtime system had SMP support. The driver will still function in the runtime system with SMP support, but performance will suffer from lock contention on the driver lock used for the driver. This can be alleviated by reviewing and perhaps rewriting the code so that each instance of the driver safely can execute in parallel. When instances safely can execute in parallel, it is safe to enable instance-specific locking on the driver. This is done by passing &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; as a driver flag. This is left as an exercise for the reader.</source>
          <target state="translated">이 드라이버는 런타임 시스템이 SMP를 지원하기 전에 작성되었습니다. 드라이버는 SMP를 지원하는 런타임 시스템에서 계속 작동하지만 드라이버에 사용 된 드라이버 잠금에서 잠금 경합이 발생합니다. 드라이버의 각 인스턴스가 안전하게 병렬로 실행될 수 있도록 코드를 검토하고 다시 작성하여이를 완화 할 수 있습니다. 인스턴스를 안전하게 병렬로 실행할 수 있으면 드라이버에서 인스턴스 별 잠금을 활성화하는 것이 안전합니다. &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/a&gt;&lt;/code&gt; 을 드라이버 플래그로 전달 하면 됩니다. 이것은 독자를위한 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="c64c900bac343dda7e6756119d5d4e6241d815d7" translate="yes" xml:space="preserve">
          <source>This effectively closes down the Erlang node. Therefore, use the erl scheme instead, until this security breach is fixed.</source>
          <target state="translated">이것은 Erlang 노드를 효과적으로 닫습니다. 따라서이 보안 침해가 해결 될 때까지 erl 체계를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc0795bd08428b2fedc177925549e5f08fa86748" translate="yes" xml:space="preserve">
          <source>This element has a total size of 4*8 = 32 bits, and it contains a signed integer in little-endian order.</source>
          <target state="translated">이 요소의 총 크기는 4 * 8 = 32 비트이며 리틀 엔디안 순서로 부호있는 정수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="60545e850b697ee47719a2ce1a4b108461f703aa" translate="yes" xml:space="preserve">
          <source>This enables references to the fields of the record by name. For example, if &lt;code&gt;P&lt;/code&gt; is a variable whose value is a &lt;code&gt;person&lt;/code&gt; record, the following code access the name and address fields of the records:</source>
          <target state="translated">이름으로 레코드 필드를 참조 할 수 있습니다. 예를 들어, &lt;code&gt;P&lt;/code&gt; 가 값이 &lt;code&gt;person&lt;/code&gt; 레코드 인 변수 인 경우 다음 코드는 레코드의 이름 및 주소 필드에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="aa641702f4a74845596c27dedfc3c223048bd207" translate="yes" xml:space="preserve">
          <source>This encoding has many similarities to UTF-8, but the basic unit is a 16-bit number. This means that all characters occupy at least two bytes, and some high numbers four bytes. Some programs, libraries, and operating systems claiming to use UTF-16 only allow for characters that can be stored in one 16-bit entity, which is usually sufficient to handle living languages. As the basic unit is more than one byte, byte-order issues occur, which is why UTF-16 exists in both a big-endian and a little-endian variant.</source>
          <target state="translated">이 인코딩은 UTF-8과 많은 유사점이 있지만 기본 단위는 16 비트 숫자입니다. 이는 모든 문자가 최소 2 바이트를 차지하고 일부는 4 바이트를 차지함을 의미합니다. UTF-16을 사용한다고 주장하는 일부 프로그램, 라이브러리 및 운영 체제는 하나의 16 비트 엔터티에 저장할 수있는 문자 만 허용하며 일반적으로 살아있는 언어를 처리하기에 충분합니다. 기본 단위가 2 바이트 이상이므로 바이트 순서 문제가 발생하므로 UTF-16이 빅 엔디안 및 리틀 엔디안 변형 모두에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="57b04c69f42e5cd6d283dd11cf050111e35a9d54" translate="yes" xml:space="preserve">
          <source>This entry is normally not shown. It signifies that getting the rest of the information about this scheduler failed for some reason.</source>
          <target state="translated">이 항목은 일반적으로 표시되지 않습니다. 이 스케줄러에 대한 나머지 정보를 가져 오는 데 어떤 이유로 실패했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5a4d6d82470e813a7acad87293099d4181101f42" translate="yes" xml:space="preserve">
          <source>This entry is shown only if there is a current process. It is similar to &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt; &lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that only the function frames are shown (that is, the stack variables are omitted). Also, only the top and bottom part of the stack are shown. If the stack is small (&amp;lt; 512 slots), the entire stack is shown. Otherwise the entry &lt;strong&gt;skipping ## slots&lt;/strong&gt; is shown, where &lt;code&gt;##&lt;/code&gt; is replaced by the number of slots that has been skipped.</source>
          <target state="translated">이 항목은 현재 프로세스가있는 경우에만 표시됩니다. 함수 프레임 만 표시된다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt; &lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 과 유사합니다 (즉, 스택 변수가 생략 됨). 또한 스택의 상단 및 하단 부분 만 표시됩니다. 스택이 작은 경우 (512 슬롯 미만) 전체 스택이 표시됩니다. 그렇지 않으면 &lt;strong&gt;## 슬롯을 건너 뛰는&lt;/strong&gt; 항목 이 표시됩니다. 여기서 &lt;code&gt;##&lt;/code&gt; 은 건너 뛴 슬롯 수로 대체됩니다. &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ee6d539dd946aea2f2282406d3b99f607f84e26" translate="yes" xml:space="preserve">
          <source>This entry is shown only if there is a current process. It is similar to &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt;&lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, except that only the function frames are shown (that is, the stack variables are omitted). Also, only the top and bottom part of the stack are shown. If the stack is small (&amp;lt; 512 slots), the entire stack is shown. Otherwise the entry &lt;strong&gt;skipping ## slots&lt;/strong&gt; is shown, where &lt;code&gt;##&lt;/code&gt; is replaced by the number of slots that has been skipped.</source>
          <target state="translated">이 항목은 현재 프로세스가있는 경우에만 표시됩니다. 함수 프레임 만 표시됩니다 (즉, 스택 변수가 생략 됨)는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;#proc_data&quot;&gt;&lt;strong&gt;=proc_stack&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 과 유사합니다 . 또한 스택의 맨 위와 맨 아래 만 표시됩니다. 스택이 작은 경우 (&amp;lt;512 슬롯) 전체 스택이 표시됩니다. 그렇지 않으면 &lt;strong&gt;## 슬롯을 건너 뛰는&lt;/strong&gt; 항목 이 표시되며 여기서 &lt;code&gt;##&lt;/code&gt; 은 건너 뛴 슬롯 수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f4c1826f8578bafadcea5382ece74a9e3ca2e0c8" translate="yes" xml:space="preserve">
          <source>This equals:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ee9f6a74af74dded0ab21396013fd65cb0cdb5f" translate="yes" xml:space="preserve">
          <source>This error is very similar to &lt;code&gt;match_limit&lt;/code&gt;, but occurs when the internal match function of PCRE is &quot;recursively&quot; called more times than the &lt;code&gt;match_limit_recursion&lt;/code&gt; limit, which defaults to 10,000,000 as well. Notice that as long as the &lt;code&gt;match_limit&lt;/code&gt; and &lt;code&gt;match_limit_default&lt;/code&gt; values are kept at the default values, the &lt;code&gt;match_limit_recursion&lt;/code&gt; error cannot occur, as the &lt;code&gt;match_limit&lt;/code&gt; error occurs before that (each recursive call is also a call, but not conversely). Both limits can however be changed, either by setting limits directly in the regular expression string (see section &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Eexpression Details&lt;/a&gt;&lt;/code&gt;) or by specifying options to &lt;code&gt;run/3&lt;/code&gt;.</source>
          <target state="translated">이 오류는 &lt;code&gt;match_limit&lt;/code&gt; 와 매우 유사 하지만 PCRE의 내부 일치 함수가 &lt;code&gt;match_limit_recursion&lt;/code&gt; 한계 ( &quot;기본&quot;10,000,000) 보다 &quot;재귀 적으로&quot;호출 될 때 발생합니다 . 긴 한 것을 알 수 &lt;code&gt;match_limit&lt;/code&gt; 및 &lt;code&gt;match_limit_default&lt;/code&gt; 값은 기본값으로 유지의 &lt;code&gt;match_limit_recursion&lt;/code&gt; 의 는 AS 오류가 발생할 수 없습니다 &lt;code&gt;match_limit&lt;/code&gt; 의 오류가 발생하는 (각 재귀 호출도 전화입니다,하지만 반대로)하기 전에. 그러나 정규 표현식 문자열에서 직접 한계를 설정하거나 ( &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Eexpression Details&lt;/a&gt;&lt;/code&gt; 섹션 참조 ) &lt;code&gt;run/3&lt;/code&gt; 옵션을 지정하여 두 한계를 모두 변경할 수 있습니다..</target>
        </trans-unit>
        <trans-unit id="b2c6321b6b0826055e2105517a81fb4bbe80e26b" translate="yes" xml:space="preserve">
          <source>This event gives initial test run information that can be interpreted as: &quot;This test run will execute &lt;code&gt;Tests&lt;/code&gt; separate tests, in total containing &lt;code&gt;Cases&lt;/code&gt; number of test cases, in &lt;code&gt;Suites&lt;/code&gt; number of suites&quot;. However, if a test case group with a repeat property exists in any test, the total number of test cases cannot be calculated (unknown).</source>
          <target state="translated">이 이벤트는 다음과 같이 해석 될 수있는 초기 테스트 실행 정보를 제공합니다. &quot;이 테스트 실행은 전체 &lt;code&gt;Suites&lt;/code&gt; 수 에서 테스트 &lt;code&gt;Cases&lt;/code&gt; 수를 포함하는 전체 &lt;code&gt;Tests&lt;/code&gt; 개별 테스트로 실행 합니다&quot;. 그러나 반복 특성이있는 테스트 케이스 그룹이 테스트에 존재하면 총 테스트 케이스 수를 알 수 없습니다 (알 수 없음).</target>
        </trans-unit>
        <trans-unit id="157a7ac786729b7a02e45935d66765ea641c0a63" translate="yes" xml:space="preserve">
          <source>This event indicates that &lt;code&gt;Common Test&lt;/code&gt; has finished initial preparations and begins executing test cases.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;Common Test&lt;/code&gt; 가 초기 준비를 완료했으며 테스트 케이스 실행을 시작 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a311dceedd521d1962d136632b3e667b19bb56be" translate="yes" xml:space="preserve">
          <source>This event indicates that the last test case has been executed and &lt;code&gt;Common Test&lt;/code&gt; is shutting down.</source>
          <target state="translated">이 이벤트는 마지막 테스트 사례가 실행되었고 &lt;code&gt;Common Test&lt;/code&gt; 가 종료 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e53e8156bb201879d980af4d7b34c6aceaecd401" translate="yes" xml:space="preserve">
          <source>This event indicates that the logging process of &lt;code&gt;Common Test&lt;/code&gt; has started successfully and is ready to receive I/O messages.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;Common Test&lt;/code&gt; 의 로깅 프로세스가 성공적으로 시작되었으며 I / O 메시지를받을 준비가 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="76a023ae70d60675cb788ca95f5784d5e17403bb" translate="yes" xml:space="preserve">
          <source>This event indicates that the logging process of &lt;code&gt;Common Test&lt;/code&gt; was shut down at the end of the test run.</source>
          <target state="translated">이 이벤트는 테스트 실행이 끝날 때 &lt;code&gt;Common Test&lt;/code&gt; 의 로깅 프로세스 가 종료 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1defde33c0ddbc9bf09303976e2df4c21eb56168" translate="yes" xml:space="preserve">
          <source>This event informs about the end of a test case or a configuration function (see event &lt;code&gt;tc_start&lt;/code&gt; for details on element &lt;code&gt;FuncOrGroup&lt;/code&gt;). With this event comes the final result of the function in question. It is possible to determine on the top level of &lt;code&gt;Result&lt;/code&gt; if the function was successful, skipped (by the user), or if it failed.</source>
          <target state="translated">테스트 케이스 또는 기능 구성의 끝이 이벤트에 대한 정보 용은 (이벤트 참조 &lt;code&gt;tc_start&lt;/code&gt; 요소에 대한 자세한 내용 &lt;code&gt;FuncOrGroup&lt;/code&gt; 을 ). 이 이벤트와 함께 해당 기능의 최종 결과가 제공됩니다. 기능의 성공, 건너 뛰기 (사용자가) 또는 실패한 경우 &lt;code&gt;Result&lt;/code&gt; 의 최상위 레벨을 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="196853db3112d60fc49c52cb43e5304105859b69" translate="yes" xml:space="preserve">
          <source>This event informs about the start of a test case, or a group configuration function. The event is sent also for &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt;, but not for &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt;. If a group configuration function starts, the group name and execution properties are also specified.</source>
          <target state="translated">이 이벤트는 테스트 케이스의 시작 또는 그룹 구성 기능에 대해 알려줍니다. 이 행사는 위해도 전송됩니다 &lt;code&gt;init_per_suite&lt;/code&gt; 및 &lt;code&gt;end_per_suite&lt;/code&gt; ,하지만하지 않는 &lt;code&gt;init_per_testcase&lt;/code&gt; 및 &lt;code&gt;end_per_testcase&lt;/code&gt; . 그룹 구성 기능이 시작되면 그룹 이름 및 실행 속성도 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="55e3d00fdb284c9c490ae4f7d70ddb7a214409ea" translate="yes" xml:space="preserve">
          <source>This event is generated by &lt;code&gt;alarm_handler:clear_alarm(AlarmId)&lt;/code&gt;.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;alarm_handler:clear_alarm(AlarmId)&lt;/code&gt; 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c14d9a9fed395d121d6715f83a9e812993ef517" translate="yes" xml:space="preserve">
          <source>This event is generated by &lt;code&gt;alarm_handler:set_alarm({AlarmId, AlarmDecsr})&lt;/code&gt;.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;alarm_handler:set_alarm({AlarmId, AlarmDecsr})&lt;/code&gt; 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="87c6d6cfcfdec46a1017f209d71402b88e99f222" translate="yes" xml:space="preserve">
          <source>This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt;. Both the handling of this event and sending it are taken care of by the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 . 이 이벤트의 처리 및 전송은 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 작동 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bce9afff012f4ef208193d1a3f362891fa380a1" translate="yes" xml:space="preserve">
          <source>This event is sent at the start of each test case (and configuration function except &lt;code&gt;init/end_per_testcase&lt;/code&gt;) and carries information about the full name (that is, the file name including the absolute directory path) of the current test case log file.</source>
          <target state="translated">이 이벤트는 각 테스트 케이스 시작시 (및 &lt;code&gt;init/end_per_testcase&lt;/code&gt; 제외 구성 기능 ) 전송되며 현재 테스트 케이스 로그 파일의 전체 이름 (절대 디렉토리 경로를 포함한 파일 이름)에 대한 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e4a38f01911d280761b98159e93b62180b939625" translate="yes" xml:space="preserve">
          <source>This event is sent for every test case or configuration function that &lt;code&gt;Common Test&lt;/code&gt; has skipped automatically because of either a failed &lt;code&gt;init_per_suite&lt;/code&gt; or &lt;code&gt;init_per_group&lt;/code&gt;, a failed &lt;code&gt;require&lt;/code&gt; in &lt;code&gt;suite/0&lt;/code&gt;, or a failed test case in a sequence. Notice that this event is never received as a result of a test case getting skipped because of &lt;code&gt;init_per_testcase&lt;/code&gt; failing, as that information is carried with event &lt;code&gt;tc_done&lt;/code&gt;. If a failed test case belongs to a test case group, the second data element is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;init_per_suite&lt;/code&gt; 또는 &lt;code&gt;init_per_group&lt;/code&gt; 실패 , &lt;code&gt;suite/0&lt;/code&gt; &lt;code&gt;require&lt;/code&gt; 실패 또는 테스트 케이스 실패 로 인해 &lt;code&gt;Common Test&lt;/code&gt; 가 자동으로 건너 뛴 모든 테스트 케이스 또는 구성 기능 에 대해 전송됩니다. 이 이벤트는 정보가 이벤트 &lt;code&gt;tc_done&lt;/code&gt; 과 함께 전달 되므로 &lt;code&gt;init_per_testcase&lt;/code&gt; 실패로 인해 테스트 케이스를 건너 뛴 결과로 수신되지 않습니다 . 실패한 테스트 케이스가 테스트 케이스 그룹에 속하는 경우 두 번째 데이터 요소는 튜플 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; 이고 그렇지 않은 경우 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="85637c33d8358bfa807af40ed5b12cab4e94ad14" translate="yes" xml:space="preserve">
          <source>This event occurs when a transaction that caused a modification to the database is completed. It is useful for determining when a set of table events (see the next section), caused by a given activity, have been sent. Once this event is received, it is guaranteed that no further table events with the same &lt;code&gt;ActivityID&lt;/code&gt; will be received. Notice that this event can still be received even if no table events with a corresponding &lt;code&gt;ActivityID&lt;/code&gt; were received, depending on the tables to which the receiving process is subscribed.</source>
          <target state="translated">이 이벤트는 데이터베이스를 수정 한 트랜잭션이 완료 될 때 발생합니다. 주어진 활동으로 인한 테이블 이벤트 세트 (다음 섹션 참조)가 전송 된시기를 판별하는 데 유용합니다. 이 이벤트가 수신되면 동일한 &lt;code&gt;ActivityID&lt;/code&gt; 를 가진 추가 테이블 이벤트가 수신되지 않습니다 . 수신 프로세스가 등록 된 테이블에 따라 해당 &lt;code&gt;ActivityID&lt;/code&gt; 가 있는 테이블 이벤트 가 수신 되지 않은 경우에도이 이벤트를 계속 수신 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f45e922ec57563cdea35247f1f7ed0e1f7d09af7" translate="yes" xml:space="preserve">
          <source>This event specifies that a test case was skipped by the user. It is only received if the skip is declared in a test specification. Otherwise, user skip information is received as a &lt;code&gt;{skipped,SkipReason}&lt;/code&gt; result in event &lt;code&gt;tc_done&lt;/code&gt; for the test case. If a skipped test case belongs to a test case group, the second data element is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">이 이벤트는 사용자가 테스트 사례를 건너 뛰도록 지정합니다. 건너 뛰기가 테스트 스펙에서 선언 된 경우에만 수신됩니다. 그렇지 않으면 사용자 건너 뛰기 정보가 테스트 사례에 대한 이벤트 &lt;code&gt;tc_done&lt;/code&gt; 의 &lt;code&gt;{skipped,SkipReason}&lt;/code&gt; 결과 로 수신됩니다 . 건너 뛴 테스트 케이스가 테스트 케이스 그룹에 속하는 경우 두 번째 데이터 요소는 튜플 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; 이고 그렇지 않은 경우 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="33a5b9cb740e8f063e9a381622f742f49651eec3" translate="yes" xml:space="preserve">
          <source>This example and all other examples in the document assumes a 64-bit archictecture, and furthermore that pointers to C code fit in 32 bits.</source>
          <target state="translated">이 예제와 문서의 다른 모든 예제는 64 비트 아키텍처를 가정하고 C 코드에 대한 포인터가 32 비트에 맞는다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9a24b66f55b1608bf70f4eb21d0c378bcfcc90e0" translate="yes" xml:space="preserve">
          <source>This example back up the contents of the registry to the specified &lt;code&gt;Mnesia&lt;/code&gt; table &lt;code&gt;&quot;mtab&quot;&lt;/code&gt;. Once a registry has been backed up to &lt;code&gt;Mnesia&lt;/code&gt; like this, more backups only affect objects that have been modified since the most recent backup, that is, objects that have been created, changed, or deleted. The backup operation is done as a single atomic transaction, so that either the entire backup is performed or none of it.</source>
          <target state="translated">이 예에서는 레지스트리의 내용을 지정된 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; 에백업 합니다 . 레지스트리가 &lt;code&gt;Mnesia&lt;/code&gt; 같이 Mnesia 에 백업되면 , 더 많은 백업은 가장 최근 백업 이후 수정 된 오브젝트, 즉 작성, 변경 또는 삭제 된 오브젝트에만 영향을줍니다. 백업 작업은 단일 원자 트랜잭션으로 수행되므로 전체 백업이 수행되거나 전혀 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e5008e4f2f2212bcc7d9051d31593661ec6ce4d" translate="yes" xml:space="preserve">
          <source>This example concerns the body of the fun. Assume that all employee numbers beginning with zero (&lt;code&gt;0&lt;/code&gt;) must be changed to begin with one (&lt;code&gt;1&lt;/code&gt;) instead, and that we want to create the list &lt;code&gt;[{&amp;lt;Old empno&amp;gt;,&amp;lt;New empno&amp;gt;}]&lt;/code&gt;:</source>
          <target state="translated">이 예는 재미의 몸에 관한 것입니다. 제로 (로 시작하는 모든 직원 수 있다고 가정 &lt;code&gt;0&lt;/code&gt; ) 하나 (로 시작하는 변경해야합니다 &lt;code&gt;1&lt;/code&gt; 우리는 목록을 작성하려는 대신) 및 &lt;code&gt;[{&amp;lt;Old empno&amp;gt;,&amp;lt;New empno&amp;gt;}]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9cd78123d895f5c9e7c353280ff2f48b8ea86e8" translate="yes" xml:space="preserve">
          <source>This example concerns the use of raw options. Consider a Linux system where you want to set option &lt;code&gt;TCP_LINGER2&lt;/code&gt; on protocol level &lt;code&gt;IPPROTO_TCP&lt;/code&gt; in the stack. You know that on this particular system it defaults to 60 (seconds), but you want to lower it to 30 for a particular socket. Option &lt;code&gt;TCP_LINGER2&lt;/code&gt; is not explicitly supported by &lt;code&gt;inet&lt;/code&gt;, but you know that the protocol level translates to number 6, the option number to number 8, and the value is to be specified as a 32-bit integer. You can use this code line to set the option for the socket named &lt;code&gt;Sock&lt;/code&gt;:</source>
          <target state="translated">이 예제는 원시 옵션 사용에 관한 것입니다. 스택의 프로토콜 레벨 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 에서 &lt;code&gt;TCP_LINGER2&lt;/code&gt; 옵션을 설정하려는 Linux 시스템을 고려하십시오 . 이 특정 시스템에서는 기본값이 60 (초)이지만 특정 소켓의 경우 30으로 낮추려고합니다. &lt;code&gt;TCP_LINGER2&lt;/code&gt; 옵션 은 &lt;code&gt;inet&lt;/code&gt; 에서 명시 적으로 지원하지 않지만 프로토콜 레벨은 숫자 6으로, 옵션 숫자는 숫자 8로 변환되며 값은 32 비트 정수로 지정됩니다. 이 코드 행을 사용하여 &lt;code&gt;Sock&lt;/code&gt; 이라는 소켓의 옵션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="530266a6d25402966cea0cb8b232a85a4ff316d8" translate="yes" xml:space="preserve">
          <source>This example gives a rough idea of how the new primitives can be used and what kind of output it produces.</source>
          <target state="translated">이 예제는 새로운 프리미티브가 어떻게 사용될 수 있고 어떤 종류의 출력을 생성하는지에 대한 대략적인 아이디어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ddfeb93d9d64b8470aa81333fa112e188816f26" translate="yes" xml:space="preserve">
          <source>This example has two functions:</source>
          <target state="translated">이 예제에는 두 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2408082cfd117d50361179146f7eb693e76f1486" translate="yes" xml:space="preserve">
          <source>This example illustrates the most used calls in match specifications for &lt;code&gt;dbg&lt;/code&gt;. The other, more esoteric, calls are listed and explained in &lt;code&gt;Match specifications in Erlang&lt;/code&gt; in ERTS User's Guide, as they are beyond the scope of this description.</source>
          <target state="translated">이 예는 &lt;code&gt;dbg&lt;/code&gt; 에 대한 일치 스펙에서 가장 많이 사용 된 호출을 보여줍니다 . 좀 더 난해한 다른 통화는 이 설명의 범위를 벗어나므로 ERTS 사용 설명서의 &lt;code&gt;Match specifications in Erlang&lt;/code&gt; 나와 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="033dde8b7dbcadc4f83a911a11c711666e02a4d2" translate="yes" xml:space="preserve">
          <source>This example is, as can be seen, run in an environment where the terminal supports Unicode input and output.</source>
          <target state="translated">이 예제는 알 수 있듯이 터미널이 유니 코드 입력 및 출력을 지원하는 환경에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="140c4136b4fe3317fa34f309b20873f708ff5543" translate="yes" xml:space="preserve">
          <source>This example only shows the message passing logic - no attempt has been made to provide a nice graphical user interface, although this can also be done in Erlang.</source>
          <target state="translated">이 예제는 메시지 전달 논리 만 보여줍니다. Erlang에서도 가능하지만 멋진 그래픽 사용자 인터페이스를 제공하려는 시도는 없었습니다.</target>
        </trans-unit>
        <trans-unit id="d78541768b15176d63561103133f9d3936557387" translate="yes" xml:space="preserve">
          <source>This example requires no special knowledge of match specifications to understand. The head of the fun matches what you want to filter out and the body returns what you want returned. As long as the fun can be kept within the limits of the match specifications, there is no need to transfer all table data to the process for filtering as in the &lt;code&gt;ets:foldr/3&lt;/code&gt; example. It is easier to read than the &lt;code&gt;ets:foldr/3&lt;/code&gt; example, as the select call in itself discards anything that does not match, while the fun of the &lt;code&gt;ets:foldr/3&lt;/code&gt; call needs to handle both the elements matching and the ones not matching.</source>
          <target state="translated">이 예에서는 이해하기 위해 일치 사양에 대한 특별한 지식이 필요하지 않습니다. 재미의 머리는 당신이 걸러 내고 싶은 것과 일치하고 몸은 당신이 돌려주고 싶은 것을 돌려줍니다. 재미가 일치 스펙의 한계 내에서 유지 될 수있는 한, &lt;code&gt;ets:foldr/3&lt;/code&gt; 예제 에서와 같이 필터링을 위해 프로세스로 모든 테이블 데이터를 전송할 필요는 없습니다 . &lt;code&gt;ets:foldr/3&lt;/code&gt; 호출의 재미는 일치하는 요소와 일치하지 않는 요소를 모두 처리해야하는 반면, select 호출 자체는 일치하지 않는 것을 버리기 때문에 ets : foldr / 3 예제 보다 읽기 쉽습니다 &lt;code&gt;ets:foldr/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf3189bf5037bf6c221e85b916b6c16513c6b111" translate="yes" xml:space="preserve">
          <source>This example showed that we could augment the set of algorithms with a config-file without the need to change the actual call.</source>
          <target state="translated">이 예는 실제 호출을 변경할 필요없이 구성 파일을 사용하여 알고리즘 세트를 확장 할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="742fc993326979930f137bea9115c77d5cbe9464" translate="yes" xml:space="preserve">
          <source>This example showed the use of &lt;code&gt;trunc&lt;/code&gt;. It is easier to use the Erlang operator &lt;code&gt;rem&lt;/code&gt; that gives the remainder after division, for example:</source>
          <target state="translated">이 예는 &lt;code&gt;trunc&lt;/code&gt; 사용을 보여줍니다 . 분할 후 나머지를 제공하는 Erlang 연산자 &lt;code&gt;rem&lt;/code&gt; 을 사용하는 것이 더 쉽습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="1657ddee206598159941c1bc09bfc039bda09595" translate="yes" xml:space="preserve">
          <source>This example shows first the encryption of two blocks and then decryptions of the cipher text, but divided into three blocks just to show that it is possible to divide the plain text and cipher text differently for some ciphers:</source>
          <target state="translated">이 예는 먼저 두 블록의 암호화를 보여준 다음 암호 텍스트의 복호화를 보여 주지만, 일부 암호에 대해 일반 텍스트와 암호 텍스트를 다르게 분할 할 수 있음을 보여주기 위해 세 블록으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="576a654b801abd888323686420eb2be87d1e88d9" translate="yes" xml:space="preserve">
          <source>This example shows how to construct a key reference that is used in a sign operation. The actual key is stored in the engine that is loaded at prompt 1.</source>
          <target state="translated">이 예는 부호 연산에 사용되는 키 참조를 구성하는 방법을 보여줍니다. 실제 키는 프롬프트 1에서로드 된 엔진에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc9c6e1c892b5ff940b330284e799595fb70aed" translate="yes" xml:space="preserve">
          <source>This example shows how to create a database called &lt;code&gt;Company&lt;/code&gt; and the relationships shown in the following diagram:</source>
          <target state="translated">이 예제는 &lt;code&gt;Company&lt;/code&gt; 라는 데이터베이스를 작성하는 방법 과 다음 다이어그램에 표시된 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4ce8c4280e865227838d76a758d3b12d799a6916" translate="yes" xml:space="preserve">
          <source>This example shows that a function is generated by the compiler that returns a valid Erlang representation of the value, although the value is of a complex type.</source>
          <target state="translated">이 예는 값이 복잡한 유형이지만 값의 유효한 Erlang 표현을 반환하는 컴파일러에 의해 함수가 생성됨을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="50ace829c34f91c2367e23e83ddbe5d2a03a399f" translate="yes" xml:space="preserve">
          <source>This example specifies the same tests as the original example. But now if started with a call to &lt;code&gt;ct_master:run(TestSpecName)&lt;/code&gt;, test &lt;code&gt;t1&lt;/code&gt; is executed on node &lt;code&gt;ct_node@host_x&lt;/code&gt; (&lt;code&gt;node1&lt;/code&gt;), test &lt;code&gt;t2&lt;/code&gt; on &lt;code&gt;ct_node@host_y&lt;/code&gt; (&lt;code&gt;node2&lt;/code&gt;) and test &lt;code&gt;t3&lt;/code&gt; on both &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;. Configuration file &lt;code&gt;t1&lt;/code&gt; is only read on &lt;code&gt;node1&lt;/code&gt; and configuration file &lt;code&gt;t2&lt;/code&gt; only on &lt;code&gt;node2&lt;/code&gt;, while the configuration file &lt;code&gt;t3&lt;/code&gt; is read on both &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;. Both test nodes write log files to the same directory. (However, the &lt;code&gt;Common Test&lt;/code&gt; Master node uses a different log directory than the test nodes.)</source>
          <target state="translated">이 예제는 원래 예제와 동일한 테스트를 지정합니다. 그러나 이제 &lt;code&gt;ct_master:run(TestSpecName)&lt;/code&gt; 호출로 시작하면 테스트 &lt;code&gt;t1&lt;/code&gt; 은 노드 &lt;code&gt;ct_node@host_x&lt;/code&gt; ( &lt;code&gt;node1&lt;/code&gt; )에서 실행되고 , 테스트 &lt;code&gt;t2&lt;/code&gt; 는 &lt;code&gt;ct_node@host_y&lt;/code&gt; ( &lt;code&gt;node2&lt;/code&gt; )에서 테스트 &lt;code&gt;t3&lt;/code&gt; 는 &lt;code&gt;node1&lt;/code&gt; 및 &lt;code&gt;node2&lt;/code&gt; 모두에서 테스트 t3 입니다 . 구성 파일 &lt;code&gt;t1&lt;/code&gt; 은 &lt;code&gt;node1&lt;/code&gt; 에서만 읽히고 구성 파일 &lt;code&gt;t2&lt;/code&gt; 는 &lt;code&gt;node2&lt;/code&gt; 에서만 읽히지 만 구성 파일 &lt;code&gt;t3&lt;/code&gt; 은 &lt;code&gt;node1&lt;/code&gt; 과 &lt;code&gt;node2&lt;/code&gt; 모두에서 읽 힙니다.. 두 테스트 노드 모두 동일한 디렉토리에 로그 파일을 씁니다. 그러나 &lt;code&gt;Common Test&lt;/code&gt; Master 노드는 테스트 노드와 다른 로그 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f919e3be6e1b9a58c077da63d3fa4b652b1b834d" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;gen_statem:call/2&lt;/code&gt;, which waits for a reply from the server. The reply is sent with a &lt;code&gt;{reply,From,Reply}&lt;/code&gt; tuple in an action list in the &lt;code&gt;{keep_state, ...}&lt;/code&gt; tuple that retains the current state. This return form is convenient when you want to stay in the current state but do not know or care about what it is.</source>
          <target state="translated">이 예제는 &lt;code&gt;gen_statem:call/2&lt;/code&gt; 를 사용 하여 서버의 응답을 기다립니다. 응답은 현재 상태를 유지하는 &lt;code&gt;{keep_state, ...}&lt;/code&gt; 튜플 의 조치 목록에 &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 튜플 과 함께 전송됩니다 . 이 반환 양식은 현재 상태를 유지하고 싶지만 현재 상태를 알거나 신경 쓰지 않을 때 편리합니다.</target>
        </trans-unit>
        <trans-unit id="7e5afbec3d662e48a79fce4ee47d58154c988214" translate="yes" xml:space="preserve">
          <source>This example warrants some explanation:</source>
          <target state="translated">이 예제는 몇 가지 설명을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="b3dcc44bb471a63d75b0052d4b54fe647a04cb07" translate="yes" xml:space="preserve">
          <source>This example with the &lt;code&gt;file&lt;/code&gt; module operations is not necessary to use directly, as that is what function &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; in principle does.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 모듈 조작을 사용한이 예제 는 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 기능 이 원칙적으로 수행 하므로 직접 사용할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9e9ac426961d89606271dd5da2f24c9429dfc0a7" translate="yes" xml:space="preserve">
          <source>This expression matches if the expression &lt;code&gt;Expr&lt;/code&gt; is of type map, otherwise it fails with an exception &lt;code&gt;badmatch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 표현식 이 map 유형 인 경우이 표현식이 일치하고 , 그렇지 않으면 예외 &lt;code&gt;badmatch&lt;/code&gt; 로 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="6184c20ff4fb14fe7267625d422557cd4d0fc7b2" translate="yes" xml:space="preserve">
          <source>This expression must be rewritten into the following, to be accepted by the compiler:</source>
          <target state="translated">컴파일러가 승인하려면이 표현식을 다음으로 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="87be2665458e0e8a04daa6def7ad816271a337f0" translate="yes" xml:space="preserve">
          <source>This feature also requires &lt;code&gt;&lt;a href=&quot;#M_t&quot;&gt;multiple thread specific instances&lt;/a&gt;&lt;/code&gt; to be enabled. When enabling this feature, multiple thread-specific instances are enabled if not already enabled, and the &lt;code&gt;aoffcbf&lt;/code&gt; strategy is enabled if the current strategy does not support abandoned carriers. This feature can be enabled on all allocators based on the &lt;code&gt;alloc_util&lt;/code&gt; framework, except &lt;code&gt;temp_alloc&lt;/code&gt; (which would be pointless).</source>
          <target state="translated">이 기능을 사용하려면 &lt;code&gt;&lt;a href=&quot;#M_t&quot;&gt;multiple thread specific instances&lt;/a&gt;&lt;/code&gt; 를 활성화해야합니다. 이 기능을 활성화하면 아직 활성화되지 않은 경우 여러 스레드 별 인스턴스가 활성화 되고 현재 전략이 포기 된 캐리어를 지원하지 않으면 &lt;code&gt;aoffcbf&lt;/code&gt; 전략이 활성화됩니다. 이 기능은 기반으로하는 모든 할당 자에 사용할 수 있습니다 &lt;code&gt;alloc_util&lt;/code&gt; 를 제외하고, 프레임 워크 &lt;code&gt;temp_alloc&lt;/code&gt; (무의미 할 것이다).</target>
        </trans-unit>
        <trans-unit id="bab1aaa22d7c52e3e995a41f937d2e85596d7686" translate="yes" xml:space="preserve">
          <source>This feature has been introduced as a temporary workaround for long-executing native code, and native code that does not bump reductions properly in OTP. When these bugs have be fixed, this flag will be removed.</source>
          <target state="translated">이 기능은 오래 실행되는 원시 코드와 OTP에서 제대로 축소되지 않는 원시 코드에 대한 임시 해결 방법으로 도입되었습니다. 이러한 버그가 수정되면이 플래그가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f75f84efbe70a72e01ed3ffc4edbe4eb52121806" translate="yes" xml:space="preserve">
          <source>This feature is similar to a lookbehind assertion (described below). However, in this case, the part of the subject before the real match does not have to be of fixed length, as lookbehind assertions do. The use of \K does not interfere with the setting of captured substrings. For example, when the following pattern matches &quot;foobar&quot;, the first substring is still set to &quot;foo&quot;:</source>
          <target state="translated">이 기능은 lookbehind 어설 션과 유사합니다 (아래 설명 참조). 그러나,이 경우, 실제 매치 이전의 주제 부분은 룩 어설 션과 같이 고정 길이 일 필요는 없다. \ K를 사용하더라도 캡처 된 하위 문자열 설정을 방해하지 않습니다. 예를 들어 다음 패턴이 &quot;foobar&quot;와 일치하는 경우 첫 번째 하위 문자열은 여전히 ​​&quot;foo&quot;로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="495e6e419f3ba6bc2ae861673f26fe3c4b80e6f5" translate="yes" xml:space="preserve">
          <source>This feature is temporary and will be removed in a future release</source>
          <target state="translated">이 기능은 일시적이며 이후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="bd4f30e27a6dd0784703ad9bdea45ca916a2edb1" translate="yes" xml:space="preserve">
          <source>This feature is temporary and will be removed in future releases.</source>
          <target state="translated">이 기능은 일시적인 기능으로 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="77b5f46e3e133913367475d2045dfdc254bfa20f" translate="yes" xml:space="preserve">
          <source>This feature must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">이 기능은 소스 모듈 의 컴파일러 옵션 또는 &lt;code&gt;-compile()&lt;/code&gt; 속성을 사용하여 명시 적으로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aa96a44c28979dae84ca1a2a0e7d8160bebc38ef" translate="yes" xml:space="preserve">
          <source>This feature was added in Erlang 5.0/OTP R7.</source>
          <target state="translated">이 기능은 Erlang 5.0 / OTP R7에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1fc9bd5588c9ab451cbffd844cd0ccc06f39f29c" translate="yes" xml:space="preserve">
          <source>This field is either to be equal to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;. An old driver (not aware of the extended driver interface) is to set this field to &lt;code&gt;0&lt;/code&gt;. If this field is &lt;code&gt;0&lt;/code&gt;, all the following fields &lt;strong&gt;must&lt;/strong&gt; also be &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if it is a pointer field.</source>
          <target state="translated">이 필드는 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 과 같습니다 . 이전 드라이버 (확장 드라이버 인터페이스를 인식하지 못함)는이 필드를 &lt;code&gt;0&lt;/code&gt; 으로 설정해야합니다 . 이 필드가 &lt;code&gt;0&lt;/code&gt; 이면 다음의 모든 필드 도 &lt;code&gt;0&lt;/code&gt; 이거나 포인터 필드 인 경우 &lt;code&gt;NULL&lt;/code&gt; &lt;strong&gt;이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0406d7a19c673109ce77b1bb24bda04bd2987652" translate="yes" xml:space="preserve">
          <source>This field is reserved for the emulator's internal use. The emulator modifies this field, so it is important that the &lt;code&gt;driver_entry&lt;/code&gt; is not declared &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">이 필드는 에뮬레이터의 내부 용으로 예약되어 있습니다. 에뮬레이터는이 필드를 수정하므로 &lt;code&gt;driver_entry&lt;/code&gt; 가 &lt;code&gt;const&lt;/code&gt; 로 선언되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="881f24225a8501e9d8e685397754715f57019f9b" translate="yes" xml:space="preserve">
          <source>This field is reserved for the emulator's internal use. The emulator will modify this field, so it is important that the &lt;code&gt;driver_entry&lt;/code&gt; is not declared &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">이 필드는 에뮬레이터의 내부 용으로 예약되어 있습니다. 에뮬레이터는이 필드를 수정하므로 &lt;code&gt;driver_entry&lt;/code&gt; 가 &lt;code&gt;const&lt;/code&gt; 로 선언되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="d71232de0ecbfffa5c29cf32c925bafa8bc48c5f" translate="yes" xml:space="preserve">
          <source>This field is to equal &lt;code&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/code&gt; if field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;.</source>
          <target state="translated">이 필드는 동일이다 &lt;code&gt;ERL_DRV_EXTENDED_MAJOR_VERSION&lt;/code&gt; 필드의 경우 &lt;code&gt;extended_marker&lt;/code&gt; 이 동일 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ad9c786ae5049c8d53b5e5f11b7a559ebf7746cc" translate="yes" xml:space="preserve">
          <source>This field is to equal &lt;code&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/code&gt; if field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;.</source>
          <target state="translated">이 필드는 동일이다 &lt;code&gt;ERL_DRV_EXTENDED_MINOR_VERSION&lt;/code&gt; 필드의 경우 &lt;code&gt;extended_marker&lt;/code&gt; 이 동일 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="8e98f5c415766c2c77bb045a0e8a36481a3244e3" translate="yes" xml:space="preserve">
          <source>This field is used to pass driver capability and other information to the runtime system. If field &lt;code&gt;extended_marker&lt;/code&gt; equals &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;, it is to contain &lt;code&gt;0&lt;/code&gt; or driver flags (&lt;code&gt;ERL_DRV_FLAG_*&lt;/code&gt;) OR'ed bitwise. The following driver flags exist:</source>
          <target state="translated">이 필드는 드라이버 기능 및 기타 정보를 런타임 시스템으로 전달하는 데 사용됩니다. 필드의 경우 &lt;code&gt;extended_marker&lt;/code&gt; 이 동일 &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; 을 , 그것을 포함하는 것입니다 &lt;code&gt;0&lt;/code&gt; 또는 드라이버 플래그 ( &lt;code&gt;ERL_DRV_FLAG_*&lt;/code&gt; ) 비트를 OR로합니다. 다음과 같은 드라이버 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e33ba3e6e3853e3483bf977da426923d2e9210" translate="yes" xml:space="preserve">
          <source>This file can be &lt;code&gt;exported&lt;/code&gt; to a file structure by calling the &lt;code&gt;&lt;a href=&quot;megaco_codec_transform#export_messages&quot;&gt;export_messages&lt;/a&gt;&lt;/code&gt; function. This can be usefull if a measurement shall be done with an external tool. Exporting the messages creates a directory tree with the following structure:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;megaco_codec_transform#export_messages&quot;&gt;export_messages&lt;/a&gt;&lt;/code&gt; 함수 를 호출 하여이 파일을 파일 구조 로 &lt;code&gt;exported&lt;/code&gt; 수 있습니다 . 외부 도구를 사용하여 측정을 수행하는 경우 유용 할 수 있습니다. 메시지를 내 보내면 다음 구조의 디렉토리 트리가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0a51732516468cf6dd3707af7a833e061746c186" translate="yes" xml:space="preserve">
          <source>This file does not need to be created manually, it can be generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. The relevant versions of the &lt;code&gt;.rel&lt;/code&gt; file, &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;.appup&lt;/code&gt; files are used as input. It is deduced which applications are to be added and deleted, and which applications that must be upgraded and/or downgraded. The instructions for this are fetched from the &lt;code&gt;.appup&lt;/code&gt; files and transformed into a single list of low-level instructions in the right order.</source>
          <target state="translated">이 파일은 수동으로 생성 할 필요가 없으며 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 로 생성 할 수 있습니다 . &lt;code&gt;.rel&lt;/code&gt; 파일, &lt;code&gt;.app&lt;/code&gt; 파일 및 &lt;code&gt;.appup&lt;/code&gt; 파일 의 관련 버전이 입력으로 사용됩니다. 추가 및 삭제해야하는 애플리케이션과 업그레이드 및 / 또는 다운 그레이드해야하는 애플리케이션을 추론합니다. 이에 대한 지침은 &lt;code&gt;.appup&lt;/code&gt; 파일 에서 가져 와서 올바른 순서의 단일 하위 수준 지침 목록으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1b4a5fcbbcbba39461ee90e5035cbad9ed093754" translate="yes" xml:space="preserve">
          <source>This file does not need to be created manually, it can be generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. The relevant versions of the &lt;code&gt;.rel&lt;/code&gt; file, &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;.appup&lt;/code&gt; files are used as input. It is deducted which applications are to be added and deleted, and which applications that must be upgraded and/or downgraded. The instructions for this are fetched from the &lt;code&gt;.appup&lt;/code&gt; files and transformed into a single list of low-level instructions in the right order.</source>
          <target state="translated">이 파일은 수동으로 만들 필요가 없으며 &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 에 의해 생성 될 수 있습니다 . 관련 버전의 &lt;code&gt;.rel&lt;/code&gt; 파일, &lt;code&gt;.app&lt;/code&gt; 파일 및 &lt;code&gt;.appup&lt;/code&gt; 파일이 입력으로 사용됩니다. 추가 및 삭제 될 응용 프로그램과 업그레이드 및 / 또는 다운 그레이드해야하는 응용 프로그램이 차감됩니다. 이에 대한 지침은 &lt;code&gt;.appup&lt;/code&gt; 파일 에서 가져와 올바른 순서로 하나의 하위 수준 지침 목록으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9fb48b81944131df296ecee7753475785f0204cf" translate="yes" xml:space="preserve">
          <source>This file is automatically generated by &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt;, using a release resource file (&lt;code&gt;.rel&lt;/code&gt;), application resource files (&lt;code&gt;.app&lt;/code&gt;), and application upgrade files (&lt;code&gt;.appup&lt;/code&gt;) as input.</source>
          <target state="translated">이 파일은 릴리스 자원 파일 ( &lt;code&gt;.rel&lt;/code&gt; ), 응용 프로그램 자원 파일 ( &lt;code&gt;.app&lt;/code&gt; ) 및 응용 프로그램 업그레이드 파일 ( &lt;code&gt;.appup&lt;/code&gt; )을 입력 으로 사용하여 &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 에 의해 자동으로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3aeac0892cbf387cc4689f055a52de4d8bad4eb9" translate="yes" xml:space="preserve">
          <source>This file is included in &lt;code&gt;mess_server.erl&lt;/code&gt;:</source>
          <target state="translated">이 파일은 &lt;code&gt;mess_server.erl&lt;/code&gt; 에 포함되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0a6831b7fc3cca45884bb8df55f7ae10d0fb0b2b" translate="yes" xml:space="preserve">
          <source>This file is used by the functions in &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; when generating a release upgrade file &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="translated">이 파일은 릴리스 업그레이드 파일 &lt;code&gt;relup&lt;/code&gt; 을 생성 할 때 &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; 의 기능에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="efd4a3fe5e769769e91e2007d57ff8d294a747ea" translate="yes" xml:space="preserve">
          <source>This file is used by the functions in &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; when generating start scripts (&lt;code&gt;.script&lt;/code&gt;, &lt;code&gt;.boot&lt;/code&gt;) and release upgrade files (&lt;code&gt;relup&lt;/code&gt;).</source>
          <target state="translated">이 파일은 시작 스크립트 ( &lt;code&gt;.script&lt;/code&gt; , &lt;code&gt;.boot&lt;/code&gt; ) 및 릴리스 업그레이드 파일 ( &lt;code&gt;relup&lt;/code&gt; )을 생성 할 때 &lt;code&gt;&lt;a href=&quot;systools&quot;&gt;systools&lt;/a&gt;&lt;/code&gt; 의 함수에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d508ac4a54e356dd39279346e885dd774ae9ca6" translate="yes" xml:space="preserve">
          <source>This file must be compiled before it can be used. The ASN.1 compiler checks that the syntax is correct and that the text represents proper ASN.1 code before generating an abstract syntax tree. The code-generator then uses the abstract syntax tree to generate code.</source>
          <target state="translated">이 파일을 사용하려면 먼저 컴파일해야합니다. ASN.1 컴파일러는 구문이 올바른지, 추상 구문 트리를 생성하기 전에 텍스트가 올바른 ASN.1 코드를 나타내는 지 확인합니다. 그런 다음 코드 생성기는 추상 구문 트리를 사용하여 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="868c84f12466baa660608254f7e7fa45a1ab087f" translate="yes" xml:space="preserve">
          <source>This filter matches all events originating from a process that has its group leader on a remote node.</source>
          <target state="translated">이 필터는 그룹 리더가 원격 노드에있는 프로세스에서 발생하는 모든 이벤트를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="41612185cf4eec8055aef32ce6a1e85ef2253041" translate="yes" xml:space="preserve">
          <source>This filter matches all progress reports from &lt;code&gt;supervisor&lt;/code&gt; and &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="translated">이 필터는 &lt;code&gt;supervisor&lt;/code&gt; 및 &lt;code&gt;application_controller&lt;/code&gt; 의 모든 진행 보고서와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3139608738bfff344c3bbc9f537737137e32b777" translate="yes" xml:space="preserve">
          <source>This filter provides a way of filtering log events based on a &lt;code&gt;domain&lt;/code&gt; field in &lt;code&gt;Metadata&lt;/code&gt;. This field is optional, and the purpose of using it is to group log events from, for example, a specific functional area. This allows filtering or other specialized treatment in a Logger handler.</source>
          <target state="translated">이 필터는 &lt;code&gt;Metadata&lt;/code&gt; 의 &lt;code&gt;domain&lt;/code&gt; 필드를 기반으로 로그 이벤트를 필터링하는 방법을 제공합니다 . 이 필드는 선택 사항이며이 필드를 사용하는 목적은 예를 들어 특정 기능 영역에서 로그 이벤트를 그룹화하는 것입니다. 이를 통해 로거 핸들러에서 필터링 또는 기타 특수 처리가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d6c38d318267fc9b1e770c2f91391135ae4bc653" translate="yes" xml:space="preserve">
          <source>This filter provides a way of filtering log events based on the log level. It matches log events by comparing the log level with a specified &lt;code&gt;MatchLevel&lt;/code&gt;</source>
          <target state="translated">이 필터는 로그 레벨을 기반으로 로그 이벤트를 필터링하는 방법을 제공합니다. 로그 수준을 지정된 &lt;code&gt;MatchLevel&lt;/code&gt; 과 비교하여 로그 이벤트를 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d91f4f911f4f31e3b8fc52c8256e3280febf9a2b" translate="yes" xml:space="preserve">
          <source>This first command enables microstate accounting for 1000 milliseconds. See &lt;code&gt;&lt;a href=&quot;#start-0&quot;&gt;start/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#reset-0&quot;&gt;reset/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; for more details. The second command prints the statistics gathered during that time. First three general statistics are printed.</source>
          <target state="translated">이 첫 번째 명령은 1000 밀리 초 동안 마이크로 스테이트 계정을 활성화합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#start-0&quot;&gt;start/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#reset-0&quot;&gt;reset/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오. 두 번째 명령은 해당 시간 동안 수집 된 통계를 인쇄합니다. 처음 세 가지 일반 통계가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1bcacf63cfd99cc81866dfa553a1b3c4711304ba" translate="yes" xml:space="preserve">
          <source>This flag affects how the filenames are to be interpreted. On operating systems with transparent file naming, this must be specified to allow for file naming in Unicode characters (and for correct interpretation of filenames containing characters &amp;gt; 255).</source>
          <target state="translated">이 플래그는 파일 이름을 해석하는 방법에 영향을줍니다. 파일 이름이 투명한 운영 체제에서는 유니 코드 문자로 파일 이름을 지정할 수 있고 문자가 255보다 큰 파일 이름을 올바르게 해석하려면이를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="401ad721e8e42c6f1dc3f91e171c1c2bd9b985da" translate="yes" xml:space="preserve">
          <source>This flag affects what is interpreted as string data when doing heuristic string detection in the shell and in &lt;code&gt;io&lt;/code&gt;/ &lt;code&gt;io_lib:format&lt;/code&gt; with the &lt;code&gt;&quot;~tp&quot;&lt;/code&gt; and &lt;code&gt;~tP&lt;/code&gt; formatting instructions, as described earlier.</source>
          <target state="translated">이 플래그는 쉘과의 휴리스틱 문자열 검색을 수행 할 때 문자열 데이터로 해석됩니다 어떤 영향을 &lt;code&gt;io&lt;/code&gt; / &lt;code&gt;io_lib:format&lt;/code&gt; 와 &lt;code&gt;&quot;~tp&quot;&lt;/code&gt; 와 &lt;code&gt;~tP&lt;/code&gt; 서식 지침 앞에서 설명한대로.</target>
        </trans-unit>
        <trans-unit id="b90bcd3825735414823381e680fcf705ea0d5299" translate="yes" xml:space="preserve">
          <source>This flag can be removed or changed at any time without prior notice.</source>
          <target state="translated">이 플래그는 사전 통지없이 언제든지 제거하거나 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a25b86654b752dec058dc76f9788b85101c1cf33" translate="yes" xml:space="preserve">
          <source>This flag determines how messages in the message queue are stored, as follows:</source>
          <target state="translated">이 플래그는 다음과 같이 메시지 큐의 메시지 저장 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="af384f81db1d48b161cd5aace187074a44597516" translate="yes" xml:space="preserve">
          <source>This flag field is optional.</source>
          <target state="translated">이 플래그 필드는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="26248d39ec39b326e49e6de9a0200d4728253816" translate="yes" xml:space="preserve">
          <source>This flag has effect only when the emulator is linked with the GNU C library, and uses its &lt;code&gt;malloc&lt;/code&gt; implementation.</source>
          <target state="translated">이 플래그는 에뮬레이터가 GNU C 라이브러리와 연결되어 있고 &lt;code&gt;malloc&lt;/code&gt; 구현을 사용하는 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e70f57e7a7cbebfcc2d03ba88bc253eef993a7f7" translate="yes" xml:space="preserve">
          <source>This flag is only valid for allocators that have an associated carrier pool. Besides that, there are no restrictions on carrier pools to use for an allocator.</source>
          <target state="translated">이 플래그는 연결된 캐리어 풀이있는 할당 자에만 유효합니다. 그 외에도 할당 자에 사용할 캐리어 풀에 대한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4f9950c6c7df7d55c31f657a13915f580c4acd7" translate="yes" xml:space="preserve">
          <source>This flag is particular useful when you want to elaborate with code loading from archives without editing the &lt;code&gt;boot script&lt;/code&gt;. For more information about interpretation of boot scripts, see &lt;code&gt;script(4)&lt;/code&gt;. The flag has also a similar effect on how the code server works; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 &lt;code&gt;boot script&lt;/code&gt; 를 편집하지 않고 아카이브에서 코드를로드하는 작업을 수행 할 때 특히 유용합니다 . 부팅 스크립트 해석에 대한 자세한 내용은 &lt;code&gt;script(4)&lt;/code&gt; 참조하십시오 . 이 플래그는 코드 서버의 작동 방식에도 비슷한 영향을 미칩니다. &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dbde97932c8eaba9606eccfc93ef4a1443c2369" translate="yes" xml:space="preserve">
          <source>This flag sets the maximum heap size for the calling process. If &lt;code&gt;MaxHeapSize&lt;/code&gt; is an integer, the system default values for &lt;code&gt;kill&lt;/code&gt; and &lt;code&gt;error_logger&lt;/code&gt; are used.</source>
          <target state="translated">이 플래그는 호출 프로세스의 최대 힙 크기를 설정합니다. 경우 &lt;code&gt;MaxHeapSize&lt;/code&gt; 가 정수에 대한 시스템 디폴트 값 &lt;code&gt;kill&lt;/code&gt; 및 &lt;code&gt;error_logger&lt;/code&gt; 이 사용된다.</target>
        </trans-unit>
        <trans-unit id="f9f03daf9384ca8f19df9da9a248cad12c12009a" translate="yes" xml:space="preserve">
          <source>This following definition of a &lt;code&gt;person&lt;/code&gt; is used in several examples in this section. Three fields are included, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;phone&lt;/code&gt;, and &lt;code&gt;address&lt;/code&gt;. The default values for &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;phone&lt;/code&gt; is &quot;&quot; and [], respectively. The default value for &lt;code&gt;address&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;, since no default value is supplied for this field:</source>
          <target state="translated">이 &lt;code&gt;person&lt;/code&gt; 의 다음 정의는 이 섹션의 여러 예에서 사용됩니다. &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;phone&lt;/code&gt; 및 &lt;code&gt;address&lt;/code&gt; 의 세 필드가 포함 됩니다. &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;phone&lt;/code&gt; 의 기본값 은 각각 &quot;&quot;와 []입니다. 이 필드에 대한 기본값이 제공되지 않으므로 &lt;code&gt;address&lt;/code&gt; 의 기본값 은 atom &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02f5811e131af42f984f54f852032dfcb1311211" translate="yes" xml:space="preserve">
          <source>This form can also be used in header files (.hrl) to declare type information for exported functions. Then these header files can be included in files that (implicitly or explicitly) import these functions.</source>
          <target state="translated">이 형식은 헤더 파일 (.hrl)에서 사용하여 내 보낸 함수의 유형 정보를 선언 할 수도 있습니다. 그런 다음 이러한 헤더 파일을 이러한 기능을 (내재적으로 또는 명시 적으로) 가져 오는 파일에 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2059c23a56cf58a2c4674e36d5fde6d6cdf2124b" translate="yes" xml:space="preserve">
          <source>This form is the one mostly used in the &lt;code&gt;&lt;a href=&quot;#Example&quot;&gt;Example&lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">이 양식은 &lt;code&gt;&lt;a href=&quot;#Example&quot;&gt;Example&lt;/a&gt;&lt;/code&gt; 섹션 에서 주로 사용되는 양식입니다 .</target>
        </trans-unit>
        <trans-unit id="966c16aa39dbb79b8cefa816f56010ae727285a2" translate="yes" xml:space="preserve">
          <source>This format can be used for printing any object and truncating the output so it fits a specified field:</source>
          <target state="translated">이 형식은 모든 객체를 인쇄하고 지정된 필드에 맞도록 출력을자를 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0b18a70e2d41ab8912dadf086b908126403976" translate="yes" xml:space="preserve">
          <source>This format of the EdDSA curves is temporary and may change without prior notice!</source>
          <target state="translated">이 EdDSA 곡선 형식은 일시적이며 사전 고지없이 변경 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="96bf1314fc9e30514fade10f4ed25bb52dc94221" translate="yes" xml:space="preserve">
          <source>This formats the text like &lt;code&gt;io:format(FmtString, Args)&lt;/code&gt; and outputs it like &lt;code&gt;debugMsg&lt;/code&gt;. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io:format(FmtString, Args)&lt;/code&gt; 와 같은 텍스트 형식을 지정하고 &lt;code&gt;debugMsg&lt;/code&gt; 와 같이 출력합니다 . 결과는 항상 &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1dba461392e21176e94cffd9044c02a52e238da" translate="yes" xml:space="preserve">
          <source>This fun can also be used to make delays in authentication tries for example by calling &lt;code&gt;timer:sleep/1&lt;/code&gt;.</source>
          <target state="translated">이 재미는 또한 인증 시도를 지연시키는 데 사용될 수 있습니다 (예 &lt;code&gt;timer:sleep/1&lt;/code&gt; 호출) .</target>
        </trans-unit>
        <trans-unit id="336ab36451349be053fe7e9e786bb4268ca4fe0b" translate="yes" xml:space="preserve">
          <source>This function (&lt;code&gt;mnesia:activity/4&lt;/code&gt;) differs in an important way from the functions &lt;code&gt;mnesia:transaction&lt;/code&gt;, &lt;code&gt;mnesia:sync_transaction&lt;/code&gt;, &lt;code&gt;mnesia:async_dirty&lt;/code&gt;, &lt;code&gt;mnesia:sync_dirty&lt;/code&gt;, and &lt;code&gt;mnesia:ets&lt;/code&gt;. Argument &lt;code&gt;AccessMod&lt;/code&gt; is the name of a callback module, which implements the &lt;code&gt;mnesia_access&lt;/code&gt; behavior.</source>
          <target state="translated">이 함수 ( &lt;code&gt;mnesia:activity/4&lt;/code&gt; )는 &lt;code&gt;mnesia:transaction&lt;/code&gt; , &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; , &lt;code&gt;mnesia:async_dirty&lt;/code&gt; , &lt;code&gt;mnesia:sync_dirty&lt;/code&gt; 및 &lt;code&gt;mnesia:ets&lt;/code&gt; 함수와 중요한 방식이 다릅니다 . 인수 &lt;code&gt;AccessMod&lt;/code&gt; 는 콜백 모듈의 이름으로 &lt;code&gt;mnesia_access&lt;/code&gt; 동작 을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a856a99360229d9e49c9035cef153bdfeb299a54" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;never&lt;/strong&gt; returns. It calls either of the following functions:</source>
          <target state="translated">이 함수는 &lt;strong&gt;절대&lt;/strong&gt; 반환 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 다음 함수 중 하나를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="dfd2b9df4a36c64900ffcea705f4eb600cd796ec" translate="yes" xml:space="preserve">
          <source>This function adds a remote node (&lt;code&gt;Nodename&lt;/code&gt;) to the list of nodes where tracing is performed. It starts a tracer process on the remote node, which will send all trace messages to the tracer process on the local node (via the Erlang distribution). If no tracer process is running on the local node, the error reason &lt;code&gt;no_local_tracer&lt;/code&gt; is returned. The tracer process on the local node must be started with the &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/0/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이 기능은 원격 노드 ( &lt;code&gt;Nodename&lt;/code&gt; )를 추적이 수행되는 노드 목록에 추가합니다 . 원격 노드에서 추적 프로그램 프로세스를 시작하여 모든 추적 메시지를 로컬 노드의 추적 프로그램 프로세스 (Erlang 분배를 통해)로 보냅니다. 로컬 노드에서 추적 프로그램 프로세스가 실행되고 있지 않으면 오류 이유 &lt;code&gt;no_local_tracer&lt;/code&gt; 가 리턴됩니다. 국지 노드의 추적 프로그램 프로세스는 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/0/2&lt;/a&gt;&lt;/code&gt; 기능 으로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e377bf478ddc23f833b9b7a7f1af28105f09ad03" translate="yes" xml:space="preserve">
          <source>This function always creates a new binary, even if &lt;code&gt;N = 1&lt;/code&gt;. By using &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; on a binary referencing a larger binary, one can free up the larger binary for garbage collection.</source>
          <target state="translated">이 함수는 &lt;code&gt;N = 1&lt;/code&gt; 경우에도 항상 새로운 이진을 만듭니다 . 사용하여 &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; 보다 큰 바이너리를 참조하는 바이너리에, 하나는 가비지 컬렉션에 대한 더 큰 바이너리를 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72153fe9aa2fe79a7632e3bef35203ef37b284e3" translate="yes" xml:space="preserve">
          <source>This function and the related &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#data-1&quot;&gt;data/1&lt;/a&gt;&lt;/code&gt; provide a uniform way to extend the set of &lt;code&gt;erl_parse&lt;/code&gt; node types. The associated data is any term, whose format may depend on the type tag.</source>
          <target state="translated">이 함수와 관련 &lt;code&gt;&lt;a href=&quot;#is_tree-1&quot;&gt;is_tree/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#data-1&quot;&gt;data/1&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;erl_parse&lt;/code&gt; 노드 유형 세트를 확장하는 균일 한 방법을 제공합니다 . 연관된 데이터는 형식 태그에 따라 형식이 달라질 수있는 모든 용어입니다.</target>
        </trans-unit>
        <trans-unit id="433b989897815cc9d57ace923542cbea3cc51b3e" translate="yes" xml:space="preserve">
          <source>This function associates a match specification with trace event &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt;. By default all executed &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; events are traced if enabled for a process. A match specification can be used to filter traced events based on sender, receiver and/or message content.</source>
          <target state="translated">이 함수는 일치 스펙을 추적 이벤트 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;'receive'&lt;/code&gt; 와 연관시킵니다 . 기본적 으로 프로세스에 대해 활성화 된 경우 실행 된 모든 &lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;'receive'&lt;/code&gt; 이벤트가 추적됩니다. 일치 스펙을 사용하여 발신자, 수신자 및 / 또는 메시지 컨텐츠를 기반으로 추적 된 이벤트를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6a6435d8001a9dac7c73b8bb892f7ef3f27946" translate="yes" xml:space="preserve">
          <source>This function behaves like &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt; erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt;, but takes a third parameter, a list of options. The only option is &lt;code&gt;noconnect&lt;/code&gt;, which makes the function return &lt;code&gt;false&lt;/code&gt; if the remote node is not currently reachable by the local node. The normal behavior is to try to connect to the node, which can stall the process during a short period. The use of option &lt;code&gt;noconnect&lt;/code&gt; makes it possible to be sure not to get the slightest delay when sending to a remote process. This is especially useful when communicating with nodes that expect to always be the connecting part (that is, nodes written in C or Java).</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt; erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt; 처럼 동작 하지만 세 번째 매개 변수 인 옵션 목록을 사용합니다. 유일한 옵션은 &lt;code&gt;noconnect&lt;/code&gt; 이며, 원격 노드가 현재 로컬 노드에 도달 할 수없는 경우 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환하도록합니다. 정상적인 동작은 노드에 연결을 시도하는 것이며, 이로 인해 짧은 시간 동안 프로세스가 중단 될 수 있습니다. &lt;code&gt;noconnect&lt;/code&gt; 옵션을 사용 하면 원격 프로세스로 전송할 때 약간의 지연이 발생하지 않도록 할 수 있습니다. 이는 항상 연결 부분이 될 것으로 예상되는 노드 (즉, C 또는 Java로 작성된 노드)와 통신 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89635cf270dd169c3a41d472bf8e396339e0014e" translate="yes" xml:space="preserve">
          <source>This function behaves like &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt;, but takes a third parameter, a list of options. The only option is &lt;code&gt;noconnect&lt;/code&gt;, which makes the function return &lt;code&gt;false&lt;/code&gt; if the remote node is not currently reachable by the local node. The normal behavior is to try to connect to the node, which can stall the process during a short period. The use of option &lt;code&gt;noconnect&lt;/code&gt; makes it possible to be sure not to get the slightest delay when sending to a remote process. This is especially useful when communicating with nodes that expect to always be the connecting part (that is, nodes written in C or Java).</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2&lt;/a&gt;&lt;/code&gt; 처럼 작동 하지만 옵션 목록 인 세 번째 매개 변수를 사용합니다. 유일한 옵션은 &lt;code&gt;noconnect&lt;/code&gt; 이며, 원격 노드가 현재 로컬 노드에 도달 할 수없는 경우 함수가 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다. 정상적인 동작은 짧은 시간 동안 프로세스를 중단시킬 수있는 노드에 연결을 시도하는 것입니다. &lt;code&gt;noconnect&lt;/code&gt; 옵션을 사용 하면 원격 프로세스로 보낼 때 약간의 지연이 발생하지 않도록 할 수 있습니다. 이는 항상 연결 부분이 될 것으로 예상되는 노드 (C 또는 Java로 작성된 노드)와 통신 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83333525c2547e13927665951a088eb3ec49c561" translate="yes" xml:space="preserve">
          <source>This function broadcasts a message to a list of processes:</source>
          <target state="translated">이 함수는 메시지를 프로세스 목록으로 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="925f375ec656eb11d5f62a0c683bf9b5d73e0618" translate="yes" xml:space="preserve">
          <source>This function calls the &lt;code&gt;inet:getopts/2&lt;/code&gt;, read that documentation.</source>
          <target state="translated">이 함수는 &lt;code&gt;inet:getopts/2&lt;/code&gt; 를 호출하고 해당 문서를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fbb073505ffa4a104f2a1483e1c97422cdc3c61a" translate="yes" xml:space="preserve">
          <source>This function calls the &lt;code&gt;inet:setopts/2&lt;/code&gt;, read that documentation and for &lt;code&gt;gen_tcp:option()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;inet:setopts/2&lt;/code&gt; 를 호출하고 해당 문서를 읽고 &lt;code&gt;gen_tcp:option()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="acaeb65b7a88cf8025f411bf5bf4220c48f96174" translate="yes" xml:space="preserve">
          <source>This function can also be used to add a replica of the table named &lt;code&gt;schema&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용하여 &lt;code&gt;schema&lt;/code&gt; 라는 테이블의 복제본을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0129c56bbfa8049fef6fe88075e59972e7cc29c" translate="yes" xml:space="preserve">
          <source>This function can also be used to change the storage type of the table named &lt;code&gt;schema&lt;/code&gt;. The schema table can only have &lt;code&gt;ram_copies&lt;/code&gt; or &lt;code&gt;disc_copies&lt;/code&gt; as the storage type. If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, no other table can be disc-resident on that node.</source>
          <target state="translated">이 함수를 사용하여 &lt;code&gt;schema&lt;/code&gt; 라는 테이블의 스토리지 유형을 변경할 수도 있습니다 . 스키마 테이블 에는 스토리지 유형으로 &lt;code&gt;ram_copies&lt;/code&gt; 또는 &lt;code&gt;disc_copies&lt;/code&gt; 만있을 수 있습니다 . 스키마의 스토리지 유형이 &lt;code&gt;ram_copies&lt;/code&gt; 인 경우 해당 노드에서 다른 테이블을 디스크 상주 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="298f0bbfcd306bc36a218e1e5c945f51e02abf73" translate="yes" xml:space="preserve">
          <source>This function can also be used to delete a replica of the table named &lt;code&gt;schema&lt;/code&gt;. The Mnesia node is then removed. Notice that Mnesia must be stopped on the node first.</source>
          <target state="translated">이 함수를 사용하여 &lt;code&gt;schema&lt;/code&gt; 라는 테이블의 복제본을 삭제할 수도 있습니다 . 그런 다음 Mnesia 노드가 제거됩니다. Mnesia는 먼저 노드에서 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="81355cc6547701f3b5dbcf62012e8964f7fd6864" translate="yes" xml:space="preserve">
          <source>This function can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="translated">이 기능은 프로세스가 로컬 호스트의 EPMD에서 지정된 노드를 등록 해제하기 위해 호출 할 수 있습니다. 그러나 EPMD가 플래그 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 로 시작되지 않는 한 일반적으로 허용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b9254d1fc6a965191d944b7d91a6f039c16821e" translate="yes" xml:space="preserve">
          <source>This function can be called from any thread if a &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;port data lock&lt;/a&gt;&lt;/code&gt; associated with the &lt;code&gt;port&lt;/code&gt; is locked by the calling thread during the call.</source>
          <target state="translated">이 기능은 호출 중에 호출 스레드가 &lt;code&gt;port&lt;/code&gt; 와 연관된 &lt;code&gt;&lt;a href=&quot;#ErlDrvPDL&quot;&gt;port data lock&lt;/a&gt;&lt;/code&gt; 경우 모든 스레드에서 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6c82e6849bd9680e104431bbaa2e398b9142d98" translate="yes" xml:space="preserve">
          <source>This function can be called from the net_if process at start-up. The options list defines which versions to use.</source>
          <target state="translated">이 함수는 시작할 때 net_if 프로세스에서 호출 할 수 있습니다. 옵션 목록은 사용할 버전을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f2ad971b905f90b5afe4b3c7ffde91a0186892d8" translate="yes" xml:space="preserve">
          <source>This function can be called from the shell as follows:</source>
          <target state="translated">이 함수는 다음과 같이 쉘에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="522d795e31428058f3384591f93786fc5c38e61f" translate="yes" xml:space="preserve">
          <source>This function can be called multiple times per tracepoint, so it is important that it is both fast and without side effects.</source>
          <target state="translated">이 기능은 트레이스 포인트 당 여러 번 호출 할 수 있으므로 부작용없이 빠르지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="19493e2b3285e45af7ae976c2c5428e204167ea2" translate="yes" xml:space="preserve">
          <source>This function can be described as a &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; function that does not delete any elements, but only counts them.</source>
          <target state="translated">이 함수는 요소를 삭제하지 않고 개수 만 계산 하는 &lt;code&gt;&lt;a href=&quot;#match_delete-2&quot;&gt;match_delete/2&lt;/a&gt;&lt;/code&gt; 함수 로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce984ece3bfa8ffe74ac15019b28eb788ccbbd1c" translate="yes" xml:space="preserve">
          <source>This function can be used as follows:</source>
          <target state="translated">이 기능은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="921fb0259ece312d46dac0b38aa1e96766ac7ff6" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_server&lt;/code&gt; process to explicitly send a reply to a client that called &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt;, when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 응답을 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 의 반환 값에 정의 할 수없는 경우 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에서 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt; 를호출 한 클라이언트에 명시 적으로 응답을 보내는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85a27177a667f0e1465cbdbd2008515b2cc73a28" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_server&lt;/code&gt; process to explicitly send a reply to a client that called &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt;, when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에서 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 의 리턴 값에 응답을 정의 할 수없는 경우 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt; 라는 클라이언트에 응답을 명시 적으로 보내는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2456490ca8943865684bc759cd5cd3ada4a8a3f8" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_statem&lt;/code&gt; to explicitly send a reply to a process that waits in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; when the reply cannot be defined in the return value of a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 의 반환 값에 응답을 정의 할 수 없을 때 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 에서 대기하는 프로세스에 응답을 명시 적으로 보내기 위해 &lt;code&gt;gen_statem&lt;/code&gt; 에서 사용할 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08f1b8ca49849c35cc0d4d177f183a0add904508" translate="yes" xml:space="preserve">
          <source>This function can be used by a &lt;code&gt;gen_statem&lt;/code&gt; to explicitly send a reply to a process that waits in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; when the reply cannot be defined in the return value of a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 의 반환 값에 응답을 정의 할 수 없을 때 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 에서 대기하는 프로세스에 응답을 명시 적으로 보내는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ea9dc0753a135b5574eec22abe8e746d04ba274" translate="yes" xml:space="preserve">
          <source>This function can be used by a channel to send a reply to a client that called &lt;code&gt;call/[2,3]&lt;/code&gt; when the reply cannot be defined in the return value of &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 채널이 응답을 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 의 반환 값에 정의 할 수 없을 때 &lt;code&gt;call/[2,3]&lt;/code&gt; 이라는 클라이언트에 응답을 보내는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc2835de3bfc4793d24e098729054ecbb7df5c48" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. The crash report is sent using &lt;code&gt; logger(3)&lt;/code&gt;, and the event to be handled is of the format &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt;, where &lt;code&gt;GL&lt;/code&gt; is the group leader pid of process &lt;code&gt;Pid&lt;/code&gt; that sent the crash report.</source>
          <target state="translated">이 함수는 사용자 정의 레거시 &lt;code&gt;error_logger&lt;/code&gt; 이벤트 핸들러에서 충돌 보고서 형식을 지정하는 데 사용할 수 있습니다 . 충돌 보고서는 &lt;code&gt; logger(3)&lt;/code&gt; 사용하여 전송 되며 처리 할 이벤트는 &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt; . 여기서 &lt;code&gt;GL&lt;/code&gt; 은 충돌 보고서를 보낸 프로세스 &lt;code&gt;Pid&lt;/code&gt; 의 그룹 리더 pid입니다. .</target>
        </trans-unit>
        <trans-unit id="db47f123c4d7737adc530bd1064733d21b41df5e" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. The crash report is sent using &lt;code&gt;logger(3)&lt;/code&gt;, and the event to be handled is of the format &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt;, where &lt;code&gt;GL&lt;/code&gt; is the group leader pid of process &lt;code&gt;Pid&lt;/code&gt; that sent the crash report.</source>
          <target state="translated">이 함수는 사용자 정의 레거시 &lt;code&gt;error_logger&lt;/code&gt; 이벤트 핸들러에서 충돌 보고서를 형식화하는 데 사용할 수 있습니다 . 충돌 보고서는 &lt;code&gt;logger(3)&lt;/code&gt; 사용하여 전송 되며 처리 할 이벤트는 &lt;code&gt;{error_report, GL, {Pid, crash_report, CrashReport}}&lt;/code&gt; . 여기서 &lt;code&gt;GL&lt;/code&gt; 은 충돌 보고서를 보낸 프로세스 &lt;code&gt;Pid&lt;/code&gt; 의 그룹 리더 pid입니다. .</target>
        </trans-unit>
        <trans-unit id="9ee5cef59a670b3b68b71dece0a9f5e79fdb8155" translate="yes" xml:space="preserve">
          <source>This function can be used by a user-defined legacy &lt;code&gt;error_logger&lt;/code&gt; event handler to format a crash report. When Depth is specified as a positive integer, it is used in the format string to limit the output as follows: &lt;code&gt;io_lib:format(&quot;~P&quot;, [Term,Depth])&lt;/code&gt;.</source>
          <target state="translated">이 함수는 사용자 정의 레거시 &lt;code&gt;error_logger&lt;/code&gt; 이벤트 핸들러에서 충돌 보고서를 형식화하는 데 사용할 수 있습니다 . 깊이가 양의 정수로 지정되면 형식 문자열에서 &lt;code&gt;io_lib:format(&quot;~P&quot;, [Term,Depth])&lt;/code&gt; 와 같이 출력을 제한하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="617658033c030647cebceeeec015013360ae0d7a" translate="yes" xml:space="preserve">
          <source>This function can be used for sending &lt;code&gt;rpc&lt;/code&gt; requests that cannot be expressed by other interface functions in this module.</source>
          <target state="translated">이 함수는 이 모듈의 다른 인터페이스 함수로는 표현할 수없는 &lt;code&gt;rpc&lt;/code&gt; 요청 을 보내는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42e7b32dc0277f5046892f45b1b0cb119299d8f7" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;undo&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; to check if the status column of a table is modified.</source>
          <target state="translated">이 함수에 대한 계측 기능에 사용될 수 &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;undo&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 테이블의 상태 항목이 변경되는 경우에 확인.</target>
        </trans-unit>
        <trans-unit id="fc3c92535fa29f8db696545ba3457c73577af82b" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions to retrieve a given part of the table info.</source>
          <target state="translated">이 함수는 인스 트루먼 테이션 함수에서 테이블 정보의 주어진 부분을 검색하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cdbbfa3213f416586603dfe437066c58b3bceec" translate="yes" xml:space="preserve">
          <source>This function can be used in instrumentation functions to retrieve the index types part of the table info.</source>
          <target state="translated">이 함수는 인스 트루먼 테이션 함수에서 테이블 정보의 인덱스 유형 부분을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7be1756bfcf7a6c64caef1e2a4983a257ac163e" translate="yes" xml:space="preserve">
          <source>This function can be used to add an AGENT-CAPABILITY statement to the sysORTable in the agent. The table is defined in the SNMPv2-MIB.</source>
          <target state="translated">이 함수는 에이전트의 sysORTable에 AGENT-CAPABILITY 문을 추가하는 데 사용할 수 있습니다. 테이블은 SNMPv2-MIB에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7dac437f7278e03fe570daafa7cce023be74ce5" translate="yes" xml:space="preserve">
          <source>This function can be used to delete an AGENT-CAPABILITY statement to the sysORTable in the agent. This table is defined in the SNMPv2-MIB.</source>
          <target state="translated">이 함수는 에이전트의 sysORTable에 대한 AGENT-CAPABILITY 문을 삭제하는 데 사용할 수 있습니다. 이 테이블은 SNMPv2-MIB에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c31d13d96b292d87ce9f4d791883f49fbaeb4b3" translate="yes" xml:space="preserve">
          <source>This function can be used to do a basic validation of the doc content of &lt;code&gt;application/erlang+html&lt;/code&gt; format.</source>
          <target state="translated">이 함수는 &lt;code&gt;application/erlang+html&lt;/code&gt; 형식 의 문서 내용에 대한 기본 유효성 검사를 수행하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="840ed8b7989fdd1ae020baa41575fc56dc513298" translate="yes" xml:space="preserve">
          <source>This function can be used to do whitespace normalization of &lt;code&gt;application/erlang+html&lt;/code&gt; documentation.</source>
          <target state="translated">이 함수는 &lt;code&gt;application/erlang+html&lt;/code&gt; 문서 의 공백 정규화를 수행하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72de58b341af03e3b7cb427708c4b243cb6b024a" translate="yes" xml:space="preserve">
          <source>This function can be used to explicitly start a key update on a TLS 1.3 connection. There are two types of the key update: if &lt;strong&gt;Type&lt;/strong&gt; is set to &lt;strong&gt;write&lt;/strong&gt;, only the writing key is updated; if &lt;strong&gt;Type&lt;/strong&gt; is set to &lt;strong&gt;read_write&lt;/strong&gt;, both the reading and writing keys are updated.</source>
          <target state="translated">이 기능은 TLS 1.3 연결에서 키 업데이트를 명시 적으로 시작하는 데 사용할 수 있습니다. 키 업데이트에는 두 가지 유형이 있습니다. &lt;strong&gt;Type&lt;/strong&gt; 이 &lt;strong&gt;write&lt;/strong&gt; 로 설정된 경우 쓰기 키만 업데이트됩니다. 경우 &lt;strong&gt;유형이&lt;/strong&gt; 설정되어 &lt;strong&gt;READ_WRITE&lt;/strong&gt; , 읽기와 쓰기 키를 모두 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1102b37c65aef3cec918cc4b7670f14b8a81dbe0" translate="yes" xml:space="preserve">
          <source>This function can be used to load object code on remote Erlang nodes. Argument &lt;code&gt;Binary&lt;/code&gt; must contain object code for &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Filename&lt;/code&gt; is only used by the code server to keep a record of from which file the object code for &lt;code&gt;Module&lt;/code&gt; comes. Thus, &lt;code&gt;Filename&lt;/code&gt; is not opened and read by the code server.</source>
          <target state="translated">이 기능은 원격 Erlang 노드에 객체 코드를로드하는 데 사용할 수 있습니다. 인수 &lt;code&gt;Binary&lt;/code&gt; 에는 &lt;code&gt;Module&lt;/code&gt; 의 객체 코드가 포함되어야합니다 . &lt;code&gt;Filename&lt;/code&gt; 은 코드 서버에 의해서만 사용되어 &lt;code&gt;Module&lt;/code&gt; 의 오브젝트 코드가 어떤 파일에서 왔는지 기록 합니다. 따라서 &lt;code&gt;Filename&lt;/code&gt; 서버는 파일 이름을 열고 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a7a1c49364121587618310df79e658f758f578a" translate="yes" xml:space="preserve">
          <source>This function can be used to manually dump the database to file.</source>
          <target state="translated">이 기능은 데이터베이스를 파일로 수동 덤프하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b39cd5560dc28e0d7d30d0cfa028ea7e687fcd3a" translate="yes" xml:space="preserve">
          <source>This function can be used to receive asynchronous notifications when OS-specific event objects become ready for either read or write operations.</source>
          <target state="translated">이 기능은 OS 특정 이벤트 오브젝트가 읽기 또는 쓰기 조작을 준비 할 때 비동기 알림을 수신하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3a58dc913baae062f654243c29c7f5eb0a4f46" translate="yes" xml:space="preserve">
          <source>This function can be used to restore an opaque continuation returned by &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; if the continuation has passed through external term format (been sent between nodes or stored on disk).</source>
          <target state="translated">연속이 외부 용어 형식 (노드간에 전송되거나 디스크에 저장 됨)을 통과 한 경우 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 불투명 연속을 복원하는 데이 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd7807ec473936d9df7098fd46d3b3b79853551d" translate="yes" xml:space="preserve">
          <source>This function can be useful when a node is started, and the names of the other network nodes are not initially known.</source>
          <target state="translated">이 기능은 노드가 시작되고 다른 네트워크 노드의 이름을 처음 알 수 없을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2f62afda090010612a0f62b821ddb83bdcfdcffb" translate="yes" xml:space="preserve">
          <source>This function can fail with one of the following error reasons:</source>
          <target state="translated">이 기능은 다음 오류 이유 중 하나로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba63a9a987b164fc62f29fa35526154bc8f7f106" translate="yes" xml:space="preserve">
          <source>This function can introduce some output latency (reading input without producing any output).</source>
          <target state="translated">이 기능은 일부 출력 대기 시간 (출력을 생성하지 않고 입력 읽기)을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="988314974f83c89323479c44bd0becefb3b2384f" translate="yes" xml:space="preserve">
          <source>This function can not change the result of the test case by returning skip or fail tuples, but it may insert items in &lt;code&gt;Config&lt;/code&gt; that can be read in &lt;code&gt;end_per_testcase/2&lt;/code&gt; or in &lt;code&gt;post_end_per_testcase/5&lt;/code&gt;.</source>
          <target state="translated">이 함수는 건너 뛰기 또는 실패 튜플을 반환하여 테스트 사례의 결과를 변경할 수 없지만 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 또는 &lt;code&gt;post_end_per_testcase/5&lt;/code&gt; 에서 읽을 수있는 항목을 &lt;code&gt;Config&lt;/code&gt; 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e10609e0797e589efd9411b6aba855461126929" translate="yes" xml:space="preserve">
          <source>This function can only be used from a NIF-calling thread, and with an environment corresponding to currently executing processes.</source>
          <target state="translated">이 함수는 NIF 호출 스레드 및 현재 실행중인 프로세스에 해당하는 환경에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e042388a21a809a3fccbdc2d157a9abe40eeec97" translate="yes" xml:space="preserve">
          <source>This function can return multiple addresses for multihomed sockets, such as SCTP sockets. For other sockets it returns a one-element list.</source>
          <target state="translated">이 함수는 SCTP 소켓과 같은 멀티 홈 소켓에 대해 여러 주소를 반환 할 수 있습니다. 다른 소켓의 경우 단일 요소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11d63c52aba2de9f19866ae14e84baa28f340645" translate="yes" xml:space="preserve">
          <source>This function cannot be used on &lt;code&gt;local_content&lt;/code&gt; tables.</source>
          <target state="translated">&lt;code&gt;local_content&lt;/code&gt; 테이블 에서는이 함수를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="87440255dae77d1bf8907255759052234cd4e35c" translate="yes" xml:space="preserve">
          <source>This function cannot change the result of the test case by returning skip or fail tuples, but it may insert items in &lt;code&gt;Config&lt;/code&gt; that can be read in &lt;code&gt;end_per_testcase/2&lt;/code&gt; or in &lt;code&gt;post_end_per_testcase/5&lt;/code&gt;.</source>
          <target state="translated">이 함수는 skip 또는 fail 튜플을 반환하여 테스트 케이스의 결과를 변경할 수 없지만 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 또는 &lt;code&gt;post_end_per_testcase/5&lt;/code&gt; 에서 읽을 수있는 항목을 &lt;code&gt;Config&lt;/code&gt; 에 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe1d649e804662b3a5a46052ca328e2902ff015f" translate="yes" xml:space="preserve">
          <source>This function checks if a date is a valid.</source>
          <target state="translated">이 기능은 날짜가 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3517712921153c86ac3e375c1576c43c6781f969" translate="yes" xml:space="preserve">
          <source>This function checks that the</source>
          <target state="translated">이 기능은</target>
        </trans-unit>
        <trans-unit id="ddd56f29dbf260ed1f448685268e0f12bf606e89" translate="yes" xml:space="preserve">
          <source>This function checks whether microstate accounting is available or not.</source>
          <target state="translated">이 기능은 소액 회계를 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e7a6086739c9e28533ed8c3e368502ee3f910824" translate="yes" xml:space="preserve">
          <source>This function clears match specifications for the specified trace event (&lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt;). It will revert back to the default behavior of tracing all triggered events.</source>
          <target state="translated">이 함수는 지정된 추적 이벤트 ( &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;'receive'&lt;/code&gt; )에 대한 일치 스펙을 지 웁니다 . 트리거 된 모든 이벤트를 추적하는 기본 동작으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="4c77841076843635a1a94dc794341ef980b21d96" translate="yes" xml:space="preserve">
          <source>This function connects the socket to the address specied by the &lt;code&gt;SockAddr&lt;/code&gt; argument.</source>
          <target state="translated">이 함수는 소켓을 &lt;code&gt;SockAddr&lt;/code&gt; 인수로 지정된 주소에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="6638616d01daa0310e5374bdd67d7c94f4479869" translate="yes" xml:space="preserve">
          <source>This function controls if user tags are to be spread to other processes with the next message. Spreading of user tags work like spreading of sequential trace tokens, so that a received user tag will be active in the process until the next message arrives (if that message does not also contain the user tag.</source>
          <target state="translated">이 기능은 다음 메시지를 통해 사용자 태그를 다른 프로세스로 전파할지 여부를 제어합니다. 사용자 태그의 확산은 순차적 추적 토큰의 확산과 같이 작동하므로 수신 된 사용자 태그는 다음 메시지가 도착할 때까지 프로세스에서 활성화됩니다 (해당 메시지에 사용자 태그도 포함되어 있지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="3f633655709ac9db491c14cd930f2f22fb70ea32" translate="yes" xml:space="preserve">
          <source>This function creates a trace port generating &lt;strong&gt;fun&lt;/strong&gt;. The &lt;strong&gt;fun&lt;/strong&gt; takes no arguments and returns a newly opened trace port. The return value from this function is suitable as a second parameter to tracer/2, i.e. &lt;code&gt;dbg:tracer(port, dbg:trace_port(ip, 4711))&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;strong&gt;재미를&lt;/strong&gt; 생성하는 추적 포트를 만듭니다 . &lt;strong&gt;재미는&lt;/strong&gt; 인수를 취하지 않고 새롭게 문을 연 추적 포트를 반환합니다. 이 함수의 리턴 값은 tracer / 2에 대한 두 번째 매개 변수, 즉 &lt;code&gt;dbg:tracer(port, dbg:trace_port(ip, 4711))&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c39c3cc91bfce26f7b990777dc0e4b36098e14e8" translate="yes" xml:space="preserve">
          <source>This function destructively update the object with key &lt;code&gt;Key&lt;/code&gt; in table &lt;code&gt;Tab&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at position &lt;code&gt;Pos&lt;/code&gt;. The new counter value is returned. If no position is specified, the element directly following key (&lt;code&gt;&amp;lt;keypos&amp;gt;+1&lt;/code&gt;) is updated.</source>
          <target state="translated">이 함수 는 &lt;code&gt;Pos&lt;/code&gt; 위치의 요소에 &lt;code&gt;Incr&lt;/code&gt; 을 추가하여 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 키 &lt;code&gt;Key&lt;/code&gt; 로 객체를 파괴적으로 업데이트합니다 . 새로운 카운터 값이 반환됩니다. 위치를 지정하지 않으면 바로 다음 키 ( &lt;code&gt;&amp;lt;keypos&amp;gt;+1&lt;/code&gt; ) 의 요소 가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ae92bc5423506c0c5495964ace9028451dd49af5" translate="yes" xml:space="preserve">
          <source>This function destructively updates the object with key &lt;code&gt;Key&lt;/code&gt; in table &lt;code&gt;Tab&lt;/code&gt;. The element at position &lt;code&gt;Pos&lt;/code&gt; is given the value &lt;code&gt;Value&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 키 &lt;code&gt;Key&lt;/code&gt; 를 사용 하여 오브젝트를 파괴적으로 업데이트합니다 . 위치의 요소 &lt;code&gt;Pos&lt;/code&gt; 값 주어진 &lt;code&gt;Value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dbc5b017b8dfa31be93dfdf684be5e007a7e9bb" translate="yes" xml:space="preserve">
          <source>This function determines the set of modules to compile and the compile options to use, by first looking for the &lt;code&gt;emake&lt;/code&gt; make option, if not present reads the configuration from a file named &lt;code&gt;Emakefile&lt;/code&gt; (see below). If no such file is found, the set of modules to compile defaults to all modules in the current working directory.</source>
          <target state="translated">이 함수는 존재하지 않는 경우 먼저 &lt;code&gt;emake&lt;/code&gt; make 옵션을 찾아서 컴파일 할 모듈 세트와 사용할 컴파일 옵션을 결정합니다 ( 없는 경우 &lt;code&gt;Emakefile&lt;/code&gt; 파일에서 구성을 읽습니다 (아래 참조)). 이러한 파일이 없으면 컴파일 할 모듈 세트는 현재 작업 디렉토리의 모든 모듈로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64faa483024d3289527baea651fb01006a7adc8e" translate="yes" xml:space="preserve">
          <source>This function disables call tracing on the specified functions. The semantics of the parameter is the same as for the corresponding function specification in &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt;. Both local and global call trace is disabled.</source>
          <target state="translated">이 함수는 지정된 함수에서 콜 추적을 비활성화합니다. 매개 변수의 의미는 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 의 해당 기능 스펙과 동일 합니다. 로컬 및 전역 통화 추적이 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="730e9eafa28a60b99c0ff8551559f6cf3f087431" translate="yes" xml:space="preserve">
          <source>This function does not address the problem of a deadlock. A deadlock can never occur as long as processes only lock one resource at a time. A deadlock can occur if some processes try to lock two or more resources. It is up to the application to detect and rectify a deadlock.</source>
          <target state="translated">이 기능은 교착 상태 문제를 해결하지 않습니다. 프로세스가 한 번에 하나의 리소스 만 잠그면 교착 상태가 발생할 수 없습니다. 일부 프로세스가 둘 이상의 자원을 잠그려고하면 교착 상태가 발생할 수 있습니다. 교착 상태를 감지하고 수정하는 것은 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="35227fc1f3835cb57763b0f1a4bfacec807769bc" translate="yes" xml:space="preserve">
          <source>This function does not return. It handles the system message and then either calls the following if process execution is to continue:</source>
          <target state="translated">이 함수는 반환되지 않습니다. 프로세스 실행을 계속하려면 시스템 메시지를 처리 ​​한 후 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0b16f3df149c3928770bb6f3facb54e082bb7a4e" translate="yes" xml:space="preserve">
          <source>This function does the same as (and does call) the &lt;code&gt; hibernate/3&lt;/code&gt; BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up.</source>
          <target state="translated">이 함수는 &lt;code&gt; hibernate/3&lt;/code&gt; BIF 와 동일하며 호출을 수행 하지만 프로세스가 깨어날 때 예외 처리 및 로깅이 예상대로 계속 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="faacbdb3dacf5784f01df9011f0ba223b7d60c23" translate="yes" xml:space="preserve">
          <source>This function does the same as (and does call) the &lt;code&gt;hibernate/3&lt;/code&gt; BIF, but ensures that exception handling and logging continues to work as expected when the process wakes up.</source>
          <target state="translated">이 함수는 &lt;code&gt;hibernate/3&lt;/code&gt; BIF와 동일하지만 호출 하지만 프로세스가 깨어날 때 예외 처리 및 로깅이 계속 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="36733f4f0e4a47c473ebe622e8727d51028dd793" translate="yes" xml:space="preserve">
          <source>This function enables call trace for one or more functions. All exported functions matching the &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; argument will be concerned, but the &lt;code&gt;match_spec()&lt;/code&gt; may further narrow down the set of function calls generating trace messages.</source>
          <target state="translated">이 기능은 하나 이상의 기능에 대한 호출 추적을 활성화합니다. &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 인수 와 일치하는 내 보낸 모든 함수 가 관련되지만 &lt;code&gt;match_spec()&lt;/code&gt; 은 추적 메시지를 생성하는 함수 호출 세트를 더 좁힐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="368666e6ad2867a60cda73d9bf0c86e3149c145a" translate="yes" xml:space="preserve">
          <source>This function ensures that the results displayed by &lt;code&gt;analyze/0,1,2&lt;/code&gt; are printed both to the file &lt;code&gt;File&lt;/code&gt; and the screen.</source>
          <target state="translated">이 기능은 &lt;code&gt;analyze/0,1,2&lt;/code&gt; 로 표시되는 결과 가 &lt;code&gt;File&lt;/code&gt; 과 화면 모두에 인쇄되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="1a7330bbeab182a749c3e5f5deba94d5a86ea474" translate="yes" xml:space="preserve">
          <source>This function extracts the initial call of a process that was started using one of the spawn or start functions in this module, and translates it to more useful information. &lt;code&gt;Process&lt;/code&gt; can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process &lt;code&gt;Pid&lt;/code&gt; fetched through an &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; function call.</source>
          <target state="translated">이 함수는이 모듈에서 생성 또는 시작 함수 중 하나를 사용하여 시작된 프로세스의 초기 호출을 추출하여보다 유용한 정보로 변환합니다. &lt;code&gt;Process&lt;/code&gt; 는 pid, 정수 튜플 (pid를 작성할 수 있음) 또는 &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; 함수 호출을 통해 페치 된 프로세스 &lt;code&gt;Pid&lt;/code&gt; 의 프로세스 정보 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0051f23484a69ef2e8f6f7524656de38ffd28765" translate="yes" xml:space="preserve">
          <source>This function fail with a &lt;code&gt;badarg&lt;/code&gt; exception if &lt;code&gt;ReqId&lt;/code&gt; is not a reference.</source>
          <target state="translated">&lt;code&gt;ReqId&lt;/code&gt; 가 참조가 아닌 &lt;code&gt;badarg&lt;/code&gt; 함수는 badarg 예외 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="e682f273c8e96989f5d96e73eb77713bc1444f02" translate="yes" xml:space="preserve">
          <source>This function fails if the atom is too long for the buffer or if it cannot be represented with encoding &lt;code&gt;want&lt;/code&gt;.</source>
          <target state="translated">아톰이 버퍼에 비해 너무 길거나 인코딩 &lt;code&gt;want&lt;/code&gt; 것으로 표현할 수없는 경우이 함수는 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="83106e1343a863599453b8ae91e66534e53d1ef0" translate="yes" xml:space="preserve">
          <source>This function fails with a &lt;code&gt;badarg&lt;/code&gt; exception if no term has been stored with the key &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 &lt;code&gt;Key&lt;/code&gt; 로 저장된 용어가없는 경우 &lt;code&gt;badarg&lt;/code&gt; 예외 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="0da14902361aba9b7fcf3f2ac32b625e0ac51f73" translate="yes" xml:space="preserve">
          <source>This function first attempts to autoload &lt;code&gt;Module&lt;/code&gt;. If that is not possible, an &lt;code&gt;undef&lt;/code&gt; exception is raised.</source>
          <target state="translated">이 기능은 먼저 &lt;code&gt;Module&lt;/code&gt; 자동로드를 시도합니다 . 이것이 가능하지 않으면 &lt;code&gt;undef&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d26740fa881de95c3af6c29ab8da1324a33cbdf" translate="yes" xml:space="preserve">
          <source>This function first spawns a process &lt;code&gt;P&lt;/code&gt; which evaluates &lt;code&gt;Fun()&lt;/code&gt; or &lt;code&gt;apply(Module,Function,Args)&lt;/code&gt;. Then, it starts profiling for &lt;code&gt;P&lt;/code&gt; and the processes in &lt;code&gt;Rootset&lt;/code&gt; (and any new processes spawned from them). Information about activity in any profiled process is stored in the Eprof database.</source>
          <target state="translated">이 함수는 먼저 &lt;code&gt;Fun()&lt;/code&gt; 또는 &lt;code&gt;apply(Module,Function,Args)&lt;/code&gt; 를 평가 하는 프로세스 &lt;code&gt;P&lt;/code&gt; 를 생성합니다 . 그런 다음 &lt;code&gt;P&lt;/code&gt; 와 &lt;code&gt;Rootset&lt;/code&gt; 의 프로세스 (및 그로부터 생성 된 새 프로세스) 에 대한 프로파일 링을 시작 합니다. 프로파일 링 된 프로세스의 활동에 대한 정보는 Eprof 데이터베이스에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a51eb8328b3ca7e73bd2ddec9c6cd1f1f6bce2fa" translate="yes" xml:space="preserve">
          <source>This function generates a &lt;code&gt;not_implemented&lt;/code&gt; error exception when the jump function is not implemented for the algorithm specified in the state in the process dictionary.</source>
          <target state="translated">이 함수 는 프로세스 사전의 상태에 지정된 알고리즘에 대해 점프 함수가 구현되지 않은 경우 &lt;code&gt;not_implemented&lt;/code&gt; 오류 예외를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="886d1bea974ef611ef862bdf736eeb1b8ee5deb0" translate="yes" xml:space="preserve">
          <source>This function generates a &lt;code&gt;not_implemented&lt;/code&gt; error exception when the jump function is not implemented for the algorithm specified in the state.</source>
          <target state="translated">이 함수 는 상태에 지정된 알고리즘에 대해 점프 함수가 구현되지 않은 경우 &lt;code&gt;not_implemented&lt;/code&gt; 오류 예외를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="6058a385a21e4246b670869f65aa6fd981a5a8b7" translate="yes" xml:space="preserve">
          <source>This function has limited use in normal code. It is used by the &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; module to perform the &lt;code&gt;dets:select()&lt;/code&gt; operations and by Mnesia during transactions.</source>
          <target state="translated">이 기능은 일반 코드에서 사용이 제한되어 있습니다. 의해 사용 &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; 의 수행 모듈 &lt;code&gt;dets:select()&lt;/code&gt; 조작 트랜잭션 동안 Mnesia 의해.</target>
        </trans-unit>
        <trans-unit id="523fd33cf3afa46e759133c868d60920d18b1dc7" translate="yes" xml:space="preserve">
          <source>This function has limited use in normal code. It is used by the &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; module to perform the &lt;code&gt;dets:select()&lt;/code&gt; operations.</source>
          <target state="translated">이 기능은 일반 코드에서 사용이 제한되어 있습니다. &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;dets&lt;/a&gt;&lt;/code&gt; 모듈에서 &lt;code&gt;dets:select()&lt;/code&gt; 조작 을 수행하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d58459e2ceed77eb8305bceed246e818de9ca01c" translate="yes" xml:space="preserve">
          <source>This function implements case normalization, percent-encoding normalization, path segment normalization and scheme based normalization for HTTP(S) with basic support for FTP, SSH, SFTP and TFTP.</source>
          <target state="translated">이 기능은 FTP, SSH, SFTP 및 TFTP에 대한 기본 지원을 통해 대소 문자 표준화, 퍼센트 인코딩 정규화, 경로 세그먼트 정규화 및 HTTP (S)에 대한 체계 기반 정규화를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c8514d81ff22e1ff67620750cdc3dfb27e9e6f77" translate="yes" xml:space="preserve">
          <source>This function initiates the DBMS locally.</source>
          <target state="translated">이 기능은 DBMS를 로컬로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="57afe95d276fab56b0cc11453585653b09b00be9" translate="yes" xml:space="preserve">
          <source>This function investigates if support is available for either &lt;code&gt;&lt;a href=&quot;http://www.quviq.com&quot;&gt;QuickCheck&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://proper-testing.github.io&quot;&gt;PropEr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://github.com/krestenkrab/triq&quot;&gt;Triq&lt;/a&gt;&lt;/code&gt; and compiles the properties with the first tool found. It is supposed to be called in the &lt;code&gt;init_per_suite/1&lt;/code&gt; function in a CommonTest test suite.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;http://www.quviq.com&quot;&gt;QuickCheck&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://proper-testing.github.io&quot;&gt;PropEr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://github.com/krestenkrab/triq&quot;&gt;Triq&lt;/a&gt;&lt;/code&gt; 에 대한 지원이 가능한지 조사 하고 발견 된 첫 번째 도구로 속성을 컴파일합니다. CommonTest 테스트 스위트 의 &lt;code&gt;init_per_suite/1&lt;/code&gt; 함수에서 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fcbc273861fed1e51bf947867b1a084c27622209" translate="yes" xml:space="preserve">
          <source>This function investigates if support is available for either Quickcheck, PropEr, or Triq. The options &lt;code&gt;{property_dir,AbsPath}&lt;/code&gt; and &lt;code&gt;{property_test_tool,Tool}&lt;/code&gt; are set in the &lt;code&gt;Config&lt;/code&gt; returned.</source>
          <target state="translated">이 기능은 Quickcheck, PropEr 또는 Triq에 대한 지원이 가능한지 조사합니다. 옵션 &lt;code&gt;{property_dir,AbsPath}&lt;/code&gt; 과 &lt;code&gt;{property_test_tool,Tool}&lt;/code&gt; 에서 설정 &lt;code&gt;Config&lt;/code&gt; 돌려 보냈다.</target>
        </trans-unit>
        <trans-unit id="6a7d3a4b7f3328d175ce6a9a9eb8e20886f3bda3" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;&lt;a href=&quot;#lowercase-1&quot;&gt;lowercase/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uppercase-1&quot;&gt;uppercase/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#titlecase-1&quot;&gt;titlecase/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; 사용 되지 않습니다. &lt;code&gt;&lt;a href=&quot;#lowercase-1&quot;&gt;lowercase/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#uppercase-1&quot;&gt;uppercase/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#titlecase-1&quot;&gt;titlecase/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="423ca16d197ccc978bd5081d6b3eb1c403bc0744" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#find-2&quot;&gt;find/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#find-2&quot;&gt;find/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a516abdfc30d7c9e3685abf6e57bb1e1d0b658e" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#find-3&quot;&gt;find/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#find-3&quot;&gt;find/3&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="52d494db0c1567d04ee40812bdffbefd6c016473" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#length-1&quot;&gt;length/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#length-1&quot;&gt;length/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab94cedb464e4260389af7be6dfaf6ffb7bd2291" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#lexemes-2&quot;&gt;lexemes/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#lexemes-2&quot;&gt;lexemes/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="205cdd304fd7174c14274c85d2328b2a17ae0a9e" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#nth_lexeme-3&quot;&gt;nth_lexeme/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#nth_lexeme-3&quot;&gt;nth_lexeme/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef02bd0b5153d37d1fa93514bd445ad29bc64930" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#pad-2&quot;&gt;pad/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#pad-2&quot;&gt;pad/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba5aba1911d9f1f71e6680b8d5f950e286eccad6" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#pad-3&quot;&gt;pad/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0297c83560fb40b3e25160700b963d4d28d8cb3d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#slice-3&quot;&gt;slice/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#slice-3&quot;&gt;slice/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9483920738b267719838628a8df6eae176da3415" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#take-2&quot;&gt;take/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#take-2&quot;&gt;take/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29b69004da0d2e1742321c5e08d6472bd345f1bd" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#take-3&quot;&gt;take/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#take-3&quot;&gt;take/3&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1fca9e1ff35bcfc01c17bd46889f3070478dc5b" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#trim-3&quot;&gt;trim/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#trim-3&quot;&gt;trim/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="206343ba93558e03d83b7d9b6041c45a9f4e4762" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;lists#duplicate-2&quot;&gt;lists:duplicate/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;lists#duplicate-2&quot;&gt;lists:duplicate/2&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdc288f4c8566ab96ad5a3c012d039a6f14b114d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;lists#join-2&quot;&gt;lists:join/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;lists#join-2&quot;&gt;lists:join/2&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad0121ab408cec82bbe0b526be72140c81e0eb43" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;[String1, String2]&lt;/code&gt; as &lt;code&gt;Data&lt;/code&gt; argument, and call &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt; unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt; unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; to flatten the output.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . 사용 &lt;code&gt;[String1, String2]&lt;/code&gt; 같은 &lt;code&gt;Data&lt;/code&gt; 인수 및 통화 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt; unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt; unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; 출력을 평탄화한다.</target>
        </trans-unit>
        <trans-unit id="be41039c1c345076e4346d099bd59b24ee69b28b" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;[String1, String2]&lt;/code&gt; as &lt;code&gt;Data&lt;/code&gt; argument, and call &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt;unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt;unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; to flatten the output.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;obsolete&lt;/a&gt;&lt;/code&gt; . 사용 &lt;code&gt;[String1, String2]&lt;/code&gt; 같은 &lt;code&gt;Data&lt;/code&gt; 인수 및 통화 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_list-2&quot;&gt;unicode:characters_to_list/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;unicode#characters_to_binary-2&quot;&gt;unicode:characters_to_binary/2&lt;/a&gt;&lt;/code&gt; 출력을 평탄화한다.</target>
        </trans-unit>
        <trans-unit id="0fe0ff73852f97430972aade26b365aeb9d4dcca" translate="yes" xml:space="preserve">
          <source>This function is &lt;strong&gt;not&lt;/strong&gt; to have any side effects, as it can be called multiple times by &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;Common Test&lt;/code&gt; 로 여러 번 호출 할 수 있으므로 부작용 이 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d1601bc7321a92135715173d0e057687db27b297" translate="yes" xml:space="preserve">
          <source>This function is &lt;strong&gt;only&lt;/strong&gt; intended to be used from functions called by the Erl Scheme interface to deliver parts of the content to the user.</source>
          <target state="translated">이 기능은 컨텐츠의 일부를 사용자에게 전달하기 위해 Erl Scheme 인터페이스에서 호출 한 기능 &lt;strong&gt;에서만&lt;/strong&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c89b38cb90d4a8e0a8fc69ed167ebc21578ef61c" translate="yes" xml:space="preserve">
          <source>This function is a convenience function that calls &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;logger:set_module_level/2&lt;/a&gt;&lt;/code&gt; for each module associated with an application.</source>
          <target state="translated">이 함수는 응용 프로그램과 관련된 각 모듈에 대해 &lt;code&gt;&lt;a href=&quot;#set_module_level-2&quot;&gt;logger:set_module_level/2&lt;/a&gt;&lt;/code&gt; 를 호출하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="d39ae8bfc4be5823eb01c3edca7562d0f24640b9" translate="yes" xml:space="preserve">
          <source>This function is a convinience function that calls &lt;code&gt;&lt;a href=&quot;#unset_module_level-1&quot;&gt;logger:unset_module_level/2&lt;/a&gt;&lt;/code&gt; for each module associated with an application.</source>
          <target state="translated">이 함수는 애플리케이션과 관련된 각 모듈에 대해 &lt;code&gt;&lt;a href=&quot;#unset_module_level-1&quot;&gt;logger:unset_module_level/2&lt;/a&gt;&lt;/code&gt; 를 호출하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="aef47781d467db25a7963a68f242afbbc794ce0b" translate="yes" xml:space="preserve">
          <source>This function is a shortcut allowing to start a trace with one command. Each tuple in &lt;code&gt;Patterns&lt;/code&gt; is converted to a list, which in turn is passed to &lt;code&gt;ttb:tpl/2,3,4&lt;/code&gt;.</source>
          <target state="translated">이 기능은 하나의 명령으로 추적을 시작할 수있는 바로 가기입니다. &lt;code&gt;Patterns&lt;/code&gt; 의 각 튜플은 목록으로 변환되어 &lt;code&gt;ttb:tpl/2,3,4&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="b43d5979e9394159963538ec618354c0f2550802" translate="yes" xml:space="preserve">
          <source>This function is a utility to test a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; used in calls to &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;. The function both tests &lt;code&gt;MatchSpec&lt;/code&gt; for &quot;syntactic&quot; correctness and runs the match specification against object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt; 호출에 사용 된 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 을 테스트하는 유틸리티 입니다. 이 함수는 모두 &quot;구문&quot;정확성에 대해 &lt;code&gt;MatchSpec&lt;/code&gt; 을 테스트 하고 &lt;code&gt;Tuple&lt;/code&gt; 객체에 대해 일치 사양을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="d988191fa0dabe515db4af812656eff83c34cb63" translate="yes" xml:space="preserve">
          <source>This function is always called before any other callback function. Use it to initiate any common state. It is to return a state for this CTH.</source>
          <target state="translated">이 함수는 항상 다른 콜백 함수보다 먼저 호출됩니다. 공통 상태를 시작하는 데 사용하십시오. 이 CTH의 상태를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b516bc2e9034c1590527ec443de2c6737bcd4f59" translate="yes" xml:space="preserve">
          <source>This function is asynchronous, and does not return any information. If an error occurs, &lt;code&gt;user_err/2&lt;/code&gt; of the error report module is called and the notification is discarded.</source>
          <target state="translated">이 함수는 비동기식이며 정보를 반환하지 않습니다. 오류가 발생 하면 오류 보고서 모듈의 &lt;code&gt;user_err/2&lt;/code&gt; 가 호출되고 알림이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="85c98f3d29d4a07045be121e9e487541dab759e4" translate="yes" xml:space="preserve">
          <source>This function is automatically run by program &lt;code&gt;ct_run&lt;/code&gt;.</source>
          <target state="translated">이 기능은 프로그램 &lt;code&gt;ct_run&lt;/code&gt; 에 의해 자동으로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="3279d0d6b02338f13c8bc53782a187d1879ee456" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 이있는 경우 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="9188edb1cc0ebdde86ffdb4193d6c9cead6cb834" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; (있는 경우) 후에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5632d3f19a46e6a63364561ccdcd84c5cbd07239" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; (있는 경우) 후에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="ed2c8cbf6eea27fe25c9e2e37745c13758f418bf" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 이 있으면 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 함수에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb41891de5f47fa39556ecfa785a92f82d5ca45" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains extra checks to ensure that all the correct dependencies are started correctly.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 다음에 호출 됩니다. 일반적으로 모든 올바른 종속성이 올바르게 시작되었는지 확인하기위한 추가 검사가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ab712217cf24a26d75845255e5f1d384ed7df651" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 다음에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3219df17fd8b1eea0c06b8129d77d9cbe10e0bf9" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt;. It is used to modify the set of test cases and test group to be executed, for instance to add or remove test cases and groups, change group properties, or even skip all tests in the suite.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다. 테스트 케이스 및 그룹을 추가 또는 제거하거나 그룹 속성을 변경하거나 스위트의 모든 테스트를 건너 뛰는 등 실행할 테스트 케이스 및 테스트 그룹 세트를 수정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9805b08693eb6111d0c6f22681e3bb9e3c04afab" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="2965ff805c434996c492ec9bfa82d7f12ef9f74a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="519b61330b5ab107e5552267a7095ddb95972fc7" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_end_per_suite-4&quot;&gt;post_end_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="c3ff042e6f427cdbf0b138b5e0423a5307d82d20" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt;. It is used to modify the test group definitions, for instance to add or remove groups or change group properties.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:groups-0&quot;&gt;groups/0&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다. 예를 들어 그룹을 추가 또는 제거하거나 그룹 속성을 변경하기 위해 테스트 그룹 정의를 수정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0db9c38b62ae93794067200327fd462e7ff4fe" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 다음에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a5820559120dedeb2862c70d6818189112741a21" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains extra checks to ensure that all the correct dependencies are started correctly.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다. 일반적으로 모든 올바른 종속성이 올바르게 시작되었는지 확인하기위한 추가 검사가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3c20b079f55383c227fa6f9819a5bdb26e2f8e5a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="aeda1395509b804f56af9852e8e45793868dfa12" translate="yes" xml:space="preserve">
          <source>This function is called after each test case, and can be used to clean up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and the test case. Any return value (besides &lt;code&gt;{fail, Reason}&lt;/code&gt; and &lt;code&gt;{save_config, SaveConfig}&lt;/code&gt;) is ignored. By returning &lt;code&gt;{fail, Reason}&lt;/code&gt;, &lt;code&gt;TestCase&lt;/code&gt; is marked as faulty (even though it was successful in the sense that it returned a value instead of terminating).</source>
          <target state="translated">이 함수는 각 테스트 케이스 후에 호출되며 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 및 테스트 케이스 후에 정리하는 데 사용할 수 있습니다 . &lt;code&gt;{fail, Reason}&lt;/code&gt; 및 &lt;code&gt;{save_config, SaveConfig}&lt;/code&gt; 이외의 모든 반환 값 은 무시됩니다. 반환하여 &lt;code&gt;{fail, Reason}&lt;/code&gt; , &lt;code&gt;TestCase&lt;/code&gt; 에은 (그것 대신 종료 값 반환한다는 점에 성공하더라도) 결함으로 표시된다.</target>
        </trans-unit>
        <trans-unit id="ac4e91297af25f1c85d719157b005b8f81db41e7" translate="yes" xml:space="preserve">
          <source>This function is called after each test case, and can be used to clean up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and the test case. Any return value (besides &lt;code&gt;{fail,Reason}&lt;/code&gt; and &lt;code&gt;{save_config,SaveConfig}&lt;/code&gt;) is ignored. By returning &lt;code&gt;{fail,Reason}&lt;/code&gt;, &lt;code&gt;TestCase&lt;/code&gt; is marked as faulty (even though it was successful in the sense that it returned a value instead of terminating).</source>
          <target state="translated">이 함수는 각 테스트 사례 후에 호출되며 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 및 테스트 사례 후에 정리하는 데 사용할 수 있습니다 . &lt;code&gt;{fail,Reason}&lt;/code&gt; 및 &lt;code&gt;{save_config,SaveConfig}&lt;/code&gt; 이외의 리턴 값 은 무시됩니다. 반환하여 &lt;code&gt;{fail,Reason}&lt;/code&gt; , &lt;code&gt;TestCase&lt;/code&gt; 에은 (그것 대신 종료 값 반환한다는 점에 성공하더라도) 결함으로 표시된다.</target>
        </trans-unit>
        <trans-unit id="7e30b5449913eda1e06199d0387c5463aed4235b" translate="yes" xml:space="preserve">
          <source>This function is called after the execution of a test case group is finished. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt;. A status value for a nested subgroup can be returned with &lt;code&gt;{return_group_result, Status}&lt;/code&gt;. The status can be retrieved in &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; for the group on the level above. The status is also used by &lt;code&gt;Common Test&lt;/code&gt; for deciding if execution of a group is to proceed if property &lt;code&gt;sequence&lt;/code&gt; or &lt;code&gt;repeat_until_*&lt;/code&gt; is set.</source>
          <target state="translated">이 함수는 테스트 케이스 그룹의 실행이 완료된 후에 호출됩니다. &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; 이후 정리에 사용됩니다 . 중첩 된 하위 그룹의 상태 값은 &lt;code&gt;{return_group_result, Status}&lt;/code&gt; 로 반환 될 수 있습니다 . 위 수준의 그룹에 대한 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; 에서 상태를 검색 할 수 있습니다 . 상태는 &lt;code&gt;Common Test&lt;/code&gt; 에서 속성 &lt;code&gt;sequence&lt;/code&gt; 또는 &lt;code&gt;repeat_until_*&lt;/code&gt; 가 설정된 경우 그룹 실행을 계속할지 여부를 결정 하는데도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="648d9b19e4f1798cccb4aa970ca13730d675986d" translate="yes" xml:space="preserve">
          <source>This function is called after the execution of a test case group is finished. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;. A status value for a nested subgroup can be returned with &lt;code&gt;{return_group_result,Status}&lt;/code&gt;. The status can be retrieved in &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; for the group on the level above. The status is also used by &lt;code&gt;Common Test&lt;/code&gt; for deciding if execution of a group is to proceed if property &lt;code&gt;sequence&lt;/code&gt; or &lt;code&gt;repeat_until_*&lt;/code&gt; is set.</source>
          <target state="translated">이 기능은 테스트 케이스 그룹의 실행이 완료된 후에 호출됩니다. &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 이후 정리에 사용됩니다 . 중첩 된 하위 그룹의 상태 값은 &lt;code&gt;{return_group_result,Status}&lt;/code&gt; 와 함께 반환 될 수 있습니다 . 위 레벨의 그룹에 대해 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; 에서 상태를 검색 할 수 있습니다 . 속성 &lt;code&gt;sequence&lt;/code&gt; 또는 &lt;code&gt;repeat_until_*&lt;/code&gt; 가 설정된 경우 그룹 실행이 진행되는지 여부를 결정하기 위해 &lt;code&gt;Common Test&lt;/code&gt; 에서 상태를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="345b7139db6080b24fa35a4e0da978a876eccf7f" translate="yes" xml:space="preserve">
          <source>This function is called as the last test case in the suite. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 스위트의 마지막 테스트 케이스로 호출됩니다. &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; 이후에 정리하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="897cf1fddb4813f2f697f362b138508da5c7dd0a" translate="yes" xml:space="preserve">
          <source>This function is called as the last test case in the suite. It is meant to be used for cleaning up after &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제품군의 마지막 테스트 사례라고합니다. &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 이후의 정리에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0372e5f1383e52f209cab7781bd11e0c4ba8e71" translate="yes" xml:space="preserve">
          <source>This function is called at the end of a CTH &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 CTH &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt; 의 끝에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0807a57b644a344571e1467f9b13cb9f18d17f0" translate="yes" xml:space="preserve">
          <source>This function is called at the end of stage 1 of the discovery process. It should return either the atom &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;{ok, usm_entry() | [usm_entry()]}&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#usm&quot;&gt;usm_entry()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpa_conf#usm_entry&quot;&gt;usm_entry/13&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">이 기능은 발견 프로세스의 1 단계 종료시 호출됩니다. 원자 &lt;code&gt;ignore&lt;/code&gt; 또는 &lt;code&gt;{ok, usm_entry() | [usm_entry()]}&lt;/code&gt; . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#usm&quot;&gt;usm_entry()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpa_conf#usm_entry&quot;&gt;usm_entry/13&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb32881cf0a426df77fb1522665bfe4e0e2538b1" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; ( 존재하는 경우) 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e874f35f84af17d413fa61bed6f2c2a545583190" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; ( 존재하는 경우) 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5d541acf0f757f563f08bac98ff0a9411ac868f8" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; ( 존재하는 경우) 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="6d4fd2c714fc08ec0ac6579748777b65c3366a58" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 함수에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="c4fada08cbaf8b15ce7f51c95c9fe3b326d58378" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains initialization/logging that must be done before &lt;code&gt;init_per_suite&lt;/code&gt; is called. If &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, &lt;code&gt;init_per_suite&lt;/code&gt; and all test cases of the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; printed in the overview log of the suite.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 전에 호출 됩니다. 일반적으로 &lt;code&gt;init_per_suite&lt;/code&gt; 를 호출 하기 전에 수행해야하는 초기화 / 로깅이 포함됩니다 . 경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 또는 &lt;code&gt;{fail,Reason}&lt;/code&gt; , 반환 &lt;code&gt;init_per_suite&lt;/code&gt; 과 스위트의 모든 테스트 케이스는 생략하고있는 &lt;code&gt;Reason&lt;/code&gt; 제품군의 개요 로그에 인쇄.</target>
        </trans-unit>
        <trans-unit id="14766708da0b30b7e24b398d506799e96916c97e" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="7d6fc181db4b0ff6e75db5d82c2a426d2f669226" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 보다 먼저 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="f27a4871105482ca23e5467359a27c568a72b833" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a88007750928f37d5492b2d8205ae78bccd986b1" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_end_per_suite-3&quot;&gt;pre_end_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="ccff703964dc8daaeec8f102943579dce11bf4b9" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 보다 먼저 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="eb9adcaaae996c1718d810cc082dbbef5007dab0" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; if it exists. It typically contains initialization/logging that must be done before &lt;code&gt;init_per_suite&lt;/code&gt; is called. If &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, &lt;code&gt;init_per_suite&lt;/code&gt; and all test cases of the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; printed in the overview log of the suite.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 전에 호출 됩니다. 일반적으로 &lt;code&gt;init_per_suite&lt;/code&gt; 가 호출 되기 전에 수행해야하는 초기화 / 로깅이 포함됩니다 . 경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 또는 &lt;code&gt;{fail,Reason}&lt;/code&gt; , 반환 &lt;code&gt;init_per_suite&lt;/code&gt; 과 스위트의 모든 테스트 케이스는 생략하고있는 &lt;code&gt;Reason&lt;/code&gt; 제품군의 개요 로그에 인쇄.</target>
        </trans-unit>
        <trans-unit id="5865db8d52a4bd048de6b63002a57691f1a85fd1" translate="yes" xml:space="preserve">
          <source>This function is called before &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; if it exists. It behaves the same way as &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt;, but for function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 존재하는 경우 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 전에 호출 됩니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:pre_init_per_suite-3&quot;&gt;pre_init_per_suite&lt;/a&gt;&lt;/code&gt; 와 동일한 방식으로 작동 하지만 대신 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 함수에 대해 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="bcb7e548f11fe13eae236fe02392162189ee68cc" translate="yes" xml:space="preserve">
          <source>This function is called before each test case. Argument &lt;code&gt;TestCase&lt;/code&gt; is the test case name, and &lt;code&gt;Config&lt;/code&gt; (list of key-value tuples) is the configuration data that can be modified. The &lt;code&gt;NewConfig&lt;/code&gt; list returned from this function is given as &lt;code&gt;Config&lt;/code&gt; to the test case. If &lt;code&gt;{fail, Reason}&lt;/code&gt; is returned, the test case is marked as failed without being executed.</source>
          <target state="translated">이 함수는 각 테스트 케이스 전에 호출됩니다. 인수 &lt;code&gt;TestCase&lt;/code&gt; 는 테스트 케이스 이름이고 &lt;code&gt;Config&lt;/code&gt; (키-값 튜플 목록)는 수정할 수있는 구성 데이터입니다. 이 함수에서 반환 된 &lt;code&gt;NewConfig&lt;/code&gt; 목록 은 테스트 케이스에 &lt;code&gt;Config&lt;/code&gt; 로 제공됩니다 . 경우 &lt;code&gt;{fail, Reason}&lt;/code&gt; 실행하지 않고 실패로 반환됩니다, 테스트 케이스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec02031e2fa8bc763f23eebb36182a4725659b4" translate="yes" xml:space="preserve">
          <source>This function is called before each test case. Argument &lt;code&gt;TestCase&lt;/code&gt; is the test case name, and &lt;code&gt;Config&lt;/code&gt; (list of key-value tuples) is the configuration data that can be modified. The &lt;code&gt;NewConfig&lt;/code&gt; list returned from this function is given as &lt;code&gt;Config&lt;/code&gt; to the test case. If &lt;code&gt;{fail,Reason}&lt;/code&gt; is returned, the test case is marked as failed without being executed.</source>
          <target state="translated">이 함수는 각 테스트 케이스 전에 호출됩니다. 인수 &lt;code&gt;TestCase&lt;/code&gt; 는 테스트 케이스 이름이고 &lt;code&gt;Config&lt;/code&gt; (키-값 튜플 목록)는 수정할 수있는 구성 데이터입니다. 이 함수에서 반환 된 &lt;code&gt;NewConfig&lt;/code&gt; 목록 은 테스트 케이스에 대한 &lt;code&gt;Config&lt;/code&gt; 으로 제공됩니다 . 경우 &lt;code&gt;{fail,Reason}&lt;/code&gt; 실행하지 않고 실패로 반환됩니다, 테스트 케이스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7cef0bc6ae48b3bc1a5099f8d9c601b37d907e07" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_event&lt;/code&gt; process in the following situations:</source>
          <target state="translated">이 함수는 다음 상황에서 &lt;code&gt;gen_event&lt;/code&gt; 프로세스에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e47279564d310806f28fccb0940fabd880414dd" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process in the following situations:</source>
          <target state="translated">이 함수는 다음 상황에서 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a51ead4642d619f15354dcc0634fe8062618949d" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when a time-out occurs or when it receives any other message than a synchronous or asynchronous request (or a system message).</source>
          <target state="translated">이 함수는 시간 종료가 발생하거나 동기 또는 비동기 요청 (또는 시스템 메시지) 이외의 다른 메시지를 수신 할 때 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="81f55aa9a3503931bbd4c62f78241c8bfccce378" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is about to terminate. It is to be the opposite of &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; and do any necessary cleaning up. When it returns, the &lt;code&gt;gen_server&lt;/code&gt; process terminates with &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">이 함수는 종료하려고 할 때 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에 의해 호출 됩니다. &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 과 반대 가되며 필요한 정리를 수행하십시오. 리턴되면 &lt;code&gt;gen_server&lt;/code&gt; 프로세스는 &lt;code&gt;Reason&lt;/code&gt; 으로 종료됩니다 . 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7103be2d22d49472aeafdc33422e8317e9a60060" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specifed in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see section &lt;code&gt; Release Handling Instructions&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 함수는 릴리스 업그레이드 / 다운 그레이드 중에 내부 상태를 업데이트 할 때, 즉 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 명령이있을 때 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에 의해 호출됩니다. 여기서 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; , &lt;code&gt;appup&lt;/code&gt; 파일 에 지정되어 있습니다. 자세한 내용 은 OTP 설계 원칙의 &lt;code&gt; Release Handling Instructions&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="854175a561611b0f58880036cbf8c4836509caea" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specifed in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see section &lt;code&gt;Release Handling Instructions&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 기능은 릴리스 업그레이드 / 다운 그레이드 중, 즉 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 명령 (여기서 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; ) 에서 내부 상태를 업데이트 할 때 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에 의해 호출됩니다. &lt;code&gt;appup&lt;/code&gt; 파일 에 지정되어 있습니다. 자세한 내용 은 OTP 디자인 원칙의 &lt;code&gt;Release Handling Instructions&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4c34ae1c200b76e11bc231bee8bd2807964c89" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_server&lt;/code&gt; process whenever a previous callback returns &lt;code&gt;{continue, Continue}&lt;/code&gt;. &lt;code&gt;handle_continue/2&lt;/code&gt; is invoked immediately after the previous callback, which makes it useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">이 함수는 이전 콜백이 &lt;code&gt;{continue, Continue}&lt;/code&gt; 반환 할 때마다 &lt;code&gt;gen_server&lt;/code&gt; 프로세스에 의해 호출됩니다 . &lt;code&gt;handle_continue/2&lt;/code&gt; 는 이전 콜백 직후에 호출되므로 초기화 후 작업을 수행하거나 콜백에서 작업을 여러 단계로 분할하여 프로세스 상태를 업데이트하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7c755e5f75a4b9ab817fb2fc0f0f130048764892" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; process when any of the following apply:</source>
          <target state="translated">이 함수는 다음 중 하나가 적용될 때 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스에 의해 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="012052cb437447cd791b721593de5a645b47fd05" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is about to terminate. It is to be the opposite of &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; and do any necessary cleaning up. When it returns, the &lt;code&gt;gen_statem&lt;/code&gt; terminates with &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">이 함수는 종료 &lt;code&gt;gen_statem&lt;/code&gt; 할 때 gen_statem에 의해 호출 됩니다. &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 과 반대 가되며 필요한 정리를 수행하십시오. 반환되면 &lt;code&gt;gen_statem&lt;/code&gt; 은 &lt;code&gt;Reason&lt;/code&gt; 으로 종료됩니다 . 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5286eefe6ed32df7949b89004772557939570746" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이 함수는 릴리스 업그레이드 / 다운 그레이드 중에 내부 상태를 업데이트 할 때, 즉 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 명령이 다음과 &lt;code&gt;gen_statem&lt;/code&gt; 때 gen_statem에 의해 호출됩니다. 여기서 &lt;code&gt;Change = {advanced,Extra}&lt;/code&gt; 는 &lt;code&gt;appup&lt;/code&gt; 파일에 지정 됩니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ca2b78a5bbaa99a4fbd81da5ab6158558318d3b" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이 기능은 릴리스 업그레이드 / 다운 그레이드 중, 즉 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 명령 에서 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 인 내부 상태를 업데이트 할 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 호출됩니다. &lt;code&gt;appup&lt;/code&gt; 파일에 지정되어 있습니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1029bd58312f364737a518c22f5aea571963829" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it needs to find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; of the callback module. The value is cached by &lt;code&gt;gen_statem&lt;/code&gt; for efficiency reasons, so this function is only called once after server start and after code change, but before the first &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in the current code version is called. More occasions may be added in future versions of &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">이 함수는 콜백 모듈 의 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 를 찾아야 할 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 호출됩니다 . 효율성을 위해 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 값이 캐시 되므로이 함수는 서버 시작 후 및 코드 변경 후 한 번만 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 되고 현재 코드 버전 의 첫 번째 상태 콜백이 호출 되기 전에 호출됩니다. 향후 버전의 &lt;code&gt;gen_statem&lt;/code&gt; 에 더 많은 경우가 추가 될 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e7042442cd0c5a7ca8465130a637143865c36ff" translate="yes" xml:space="preserve">
          <source>This function is called by a &lt;code&gt;gen_statem&lt;/code&gt; when it needs to find out the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; of the callback module. The value is cached by &lt;code&gt;gen_statem&lt;/code&gt; for efficiency reasons, so this function is only called once after server start, after code change, and after changing the callback module, but before the first &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; in the current callback module's code version is called. More occasions may be added in future versions of &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">이 함수는 콜백 모듈 의 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 를 찾아야 할 때 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 호출됩니다 . 이 값은 효율성을 위해 &lt;code&gt;gen_statem&lt;/code&gt; 에 의해 캐시 되므로이 함수는 서버 시작 후, 코드 변경 후, 콜백 모듈 변경 후 한 번만 호출되지만 현재 콜백 모듈의 코드 버전에서 첫 번째 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 되기 전에 호출됩니다. &lt;code&gt;gen_statem&lt;/code&gt; 의 향후 버전에서 더 많은 경우가 추가 될 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86e4a64914f5fa58c43e59cda9e1371225dd82b8" translate="yes" xml:space="preserve">
          <source>This function is called by a channel process when it is about to terminate. Before this function is called, &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt; ssh_connection:close/2 &lt;/a&gt;&lt;/code&gt; is called, if it has not been called earlier. This function does any necessary cleaning up. When it returns, the channel process terminates with reason &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">이 함수는 종료 되려고 할 때 채널 프로세스에 의해 호출됩니다. 이 함수가 호출되기 전에 이전에 호출되지 않은 경우 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt; ssh_connection:close/2 &lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 이 기능은 필요한 정리를 수행합니다. 반환되면 채널 프로세스는 &lt;code&gt;Reason&lt;/code&gt; 이유 와 함께 종료됩니다 . 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="46850b150e8f033a9f9fa7fa23905fcd27c1aa8d" translate="yes" xml:space="preserve">
          <source>This function is called by a channel process when it is about to terminate. Before this function is called, &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; is called, if it has not been called earlier. This function does any necessary cleaning up. When it returns, the channel process terminates with reason &lt;code&gt;Reason&lt;/code&gt;. The return value is ignored.</source>
          <target state="translated">이 기능은 채널 프로세스가 종료하려고 할 때 호출됩니다. 이 함수가 호출되기 전에 &lt;code&gt;&lt;a href=&quot;ssh_connection#close-2&quot;&gt;ssh_connection:close/2&lt;/a&gt;&lt;/code&gt; 가 호출되지 않은 경우 호출됩니다. 이 기능은 필요한 정리 작업을 수행합니다. 이 반환 될 때, 채널 프로세스는 이유와 함께 종료 &lt;code&gt;Reason&lt;/code&gt; . 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="56c006741953e55f77a4441e9b362d11c170439b" translate="yes" xml:space="preserve">
          <source>This function is called by a client-side channel when it is to update its internal state during a release upgrade or downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is given in the &lt;code&gt;appup&lt;/code&gt; file. For more information, refer to Section 9.11.6 Release Handling Instructions in the &lt;code&gt;System Documentation&lt;/code&gt;.</source>
          <target state="translated">이 기능은이 릴리스 업그레이드하거나 다운 그레이드 동안 내부 상태를 업데이트하는 것입니다 클라이언트 측 채널에 의해 호출 될 때 명령 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 여기서 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; 는 &lt;code&gt;appup&lt;/code&gt; 파일에 있습니다. 자세한 내용은 &lt;code&gt;System Documentation&lt;/code&gt; 9.11.6 릴리스 취급 지침을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98e32bc0ee74da52ca9a13438eac65dfb07d4d9a" translate="yes" xml:space="preserve">
          <source>This function is called by a process when it generates a system event. &lt;code&gt;FormFunc&lt;/code&gt; is a formatting function, called as &lt;code&gt;FormFunc(Device, Event, Extra)&lt;/code&gt; to print the events, which is necessary if tracing is activated. &lt;code&gt;Extra&lt;/code&gt; is any extra information that the process needs in the format function, for example, the process name.</source>
          <target state="translated">이 함수는 시스템 이벤트를 생성 할 때 프로세스에 의해 호출됩니다. &lt;code&gt;FormFunc&lt;/code&gt; 는 &lt;code&gt;FormFunc(Device, Event, Extra)&lt;/code&gt; 를 인쇄하기 위해 FormFunc (Device, Event, Extra) 라고하는 형식화 기능으로, 추적이 활성화 된 경우 필요합니다. &lt;code&gt;Extra&lt;/code&gt; 는 프로세스 이름과 같이 형식 기능에서 프로세스에 필요한 추가 정보입니다.</target>
        </trans-unit>
        <trans-unit id="ed0e0eb61ef16ef99456d0c2364049ed3a1ebf47" translate="yes" xml:space="preserve">
          <source>This function is called by an application after a code replacement, if the configuration parameters have changed.</source>
          <target state="translated">이 매개 변수는 구성 매개 변수가 변경된 경우 코드 교체 후 애플리케이션에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3225937a4973dfc80a61d8815ee667cbb935393b" translate="yes" xml:space="preserve">
          <source>This function is called by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior when the channel is terminated, see &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt;. Thus, channels implemented with the behavior are not to call this function explicitly.</source>
          <target state="translated">이 함수는 채널이 종료 될 때 &lt;code&gt;ssh_client_channel&lt;/code&gt; 동작에 의해 호출됩니다 . &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt; ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 따라서 비헤이비어로 구현 된 채널은이 함수를 명시 적으로 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6621bfc9a122170668fcc8fc8225320a135fa869" translate="yes" xml:space="preserve">
          <source>This function is called by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior when the channel is terminated, see &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt;. Thus, channels implemented with the behavior are not to call this function explicitly.</source>
          <target state="translated">이 기능은 채널이 종료 될 때 &lt;code&gt;ssh_client_channel&lt;/code&gt; 작동에 의해 호출됩니다 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel(3)&lt;/a&gt;&lt;/code&gt; 참조 ) . 따라서 동작으로 구현 된 채널은이 함수를 명시 적으로 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="dc9dece5047c3cb54dec0afd24b5a01788985144" translate="yes" xml:space="preserve">
          <source>This function is called by the runtime system if a call is made to &lt;code&gt;Module:Function(Arg1,.., ArgN)&lt;/code&gt; and &lt;code&gt;Module:Function/N&lt;/code&gt; is undefined. Notice that this function is evaluated inside the process making the original call.</source>
          <target state="translated">이 함수는 &lt;code&gt;Module:Function(Arg1,.., ArgN)&lt;/code&gt; 하고 &lt;code&gt;Module:Function/N&lt;/code&gt; 이 정의되지 않은 경우 런타임 시스템에서 호출 합니다. 이 함수는 원래 호출하는 프로세스 내에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="932dde8834dd201f9618df3e2b729505b50863cc" translate="yes" xml:space="preserve">
          <source>This function is called by the supervisor bridge when it is about to terminate. It is to be the opposite of &lt;code&gt;Module:init/1&lt;/code&gt; and stop the subsystem and do any necessary cleaning up. The return value is ignored.</source>
          <target state="translated">이 기능은 수퍼바이저 브리지가 종료 되려고 할 때 호출됩니다. 이는 &lt;code&gt;Module:init/1&lt;/code&gt; 과 반대이며 서브 시스템을 중지하고 필요한 정리를 수행하십시오. 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea3c4634990a20391de600270693f41ff61a2a1d" translate="yes" xml:space="preserve">
          <source>This function is called for an installed event handler that is to update its internal state during a release upgrade/downgrade, that is, when the instruction &lt;code&gt;{update,Module,Change,...}&lt;/code&gt;, where &lt;code&gt;Change={advanced,Extra}&lt;/code&gt;, is specified in the &lt;code&gt;.appup&lt;/code&gt; file. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이 기능은 릴리스 업그레이드 / 다운 그레이드 중, 즉 &lt;code&gt;{update,Module,Change,...}&lt;/code&gt; 명령 (여기서 &lt;code&gt;Change={advanced,Extra}&lt;/code&gt; , &lt;code&gt;.appup&lt;/code&gt; 파일에 지정되어 있습니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cea3d7b3ef2cbf8699a32c34a5ebc6edac5d50d7" translate="yes" xml:space="preserve">
          <source>This function is called for each installed event handler when an event manager receives any other message than an event or a synchronous request (or a system message).</source>
          <target state="translated">이 기능은 이벤트 관리자가 이벤트 또는 동기 요청 (또는 시스템 메시지) 이외의 다른 메시지를 수신 할 때 설치된 각 이벤트 핸들러에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ce473b5b5bef5c09e6ef1d61b1ed1c647a383af4" translate="yes" xml:space="preserve">
          <source>This function is called for each target in the &lt;code&gt;Targets&lt;/code&gt; argument of the &lt;code&gt;delivery_targets/3&lt;/code&gt; function, see above.</source>
          <target state="translated">이 함수는 &lt;code&gt;delivery_targets/3&lt;/code&gt; 함수 의 &lt;code&gt;Targets&lt;/code&gt; 인수 에서 각 대상에 대해 호출됩니다 ( 위 참조).</target>
        </trans-unit>
        <trans-unit id="1d6462e692fd6e4e41ce5594f4b497bff94fb6d6" translate="yes" xml:space="preserve">
          <source>This function is called for every event sent by the parser. The error handling is done through exceptions. Use throw/1 to send the following tuple {Tag = atom(), Reason = string()} if the application encounters a fatal error. Tag is an atom that identifies the functional entity that sends the exception and Reason is a string that describes the problem.</source>
          <target state="translated">이 함수는 파서가 보낸 모든 이벤트에 대해 호출됩니다. 오류 처리는 예외를 통해 수행됩니다. 응용 프로그램에 치명적인 오류가 발생하면 throw / 1을 사용하여 다음 튜플 {Tag = atom (), Reason = string ()}을 보내십시오. Tag는 예외를 보내는 기능적 엔티티를 식별하는 원자이고 Reason은 문제를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="93bdecc9d17882d1b467ebb3869ace1d974136a0" translate="yes" xml:space="preserve">
          <source>This function is called from the supervisor at system start-up.</source>
          <target state="translated">이 기능은 시스템 시작시 수퍼바이저에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a217044c5be614a5f094b6a72163b7e4bdd7856f" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before &lt;code&gt;init_per_suite is run&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">이 함수는 &lt;code&gt;init_per_suite is run&lt;/code&gt; 되기 전에 CTH가 추가 된 경우에만 호출됩니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9e0725950962171a0e0acbaccc22d9af6bc48c9" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before &lt;code&gt;init_per_suite&lt;/code&gt; is run. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">이 함수는 &lt;code&gt;init_per_suite&lt;/code&gt; 가 실행 되기 전에 CTH가 추가 된 경우에만 호출됩니다 . 자세한 내용 은 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9151faa7459c76d911ec31cbf5c69110f9a96417" translate="yes" xml:space="preserve">
          <source>This function is called only if the CTH is added before or in &lt;code&gt;init_per_suite&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">이 함수는 CTH가 &lt;code&gt;init_per_suite&lt;/code&gt; 이전 또는 init_per_suite에 추가 된 경우에만 호출됩니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#scope&quot;&gt;CTH Scope&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d413292a54f27c9406de8cff392ae42d2f42729" translate="yes" xml:space="preserve">
          <source>This function is called to perform the set in phase two of the set-request processing. It is only called if the corresponding &lt;code&gt;is_set_ok&lt;/code&gt; function is present and returns &lt;code&gt;noError&lt;/code&gt;.</source>
          <target state="translated">이 기능은 세트 요청 처리의 2 단계에서 세트를 수행하기 위해 호출됩니다. 해당하는 경우에만라고 &lt;code&gt;is_set_ok&lt;/code&gt; 함수가 존재하고 반환 &lt;code&gt;noError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19d4b60d6e3de5df91e369f01d6f092302794154" translate="yes" xml:space="preserve">
          <source>This function is called when a log event has passed through all primary filters, and all handler filters attached to the handler in question. The function call is executed on the client process, and it is up to the handler implementation if other processes are involved or not.</source>
          <target state="translated">이 함수는 로그 이벤트가 모든 기본 필터와 해당 처리기에 연결된 모든 처리기 필터를 통과 할 때 호출됩니다. 함수 호출은 클라이언트 프로세스에서 실행되며 다른 프로세스가 관련되어 있는지 여부는 핸들러 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="c295250b137bf52da997b24c29441addd734d55e" translate="yes" xml:space="preserve">
          <source>This function is called when a message is received from an unknown agent.</source>
          <target state="translated">이 기능은 알 수없는 에이전트로부터 메시지가 수신 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5d70c9d97d9b9a958c936b8de051f3ed8d7ea9af" translate="yes" xml:space="preserve">
          <source>This function is called when a segment reply has been received if the &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;segment_reply_ind&lt;/a&gt;&lt;/code&gt; config option has been set to true.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;segment_reply_ind&lt;/a&gt;&lt;/code&gt; 구성 옵션이 true로 설정된 경우 세그먼트 응답이 수신되면이 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a9e596fa34499a1e902a649a40ec5eaea84dc1d" translate="yes" xml:space="preserve">
          <source>This function is called when an application is about to be stopped, before shutting down the processes of the application.</source>
          <target state="translated">이 함수는 응용 프로그램 프로세스를 종료하기 전에 응용 프로그램을 중지하려고 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e52a273e8b54ca8a87814403662bc4639ec75915" translate="yes" xml:space="preserve">
          <source>This function is called when the handshake has completed and the distribution channel is up. The distribution controller can begin dispatching traffic over the channel. This function is optional.</source>
          <target state="translated">이 기능은 핸드 셰이크가 완료되고 분배 채널이 작동 될 때 호출됩니다. 배포 컨트롤러는 채널을 통해 트래픽을 디스패치 할 수 있습니다. 이 기능은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="78b766c6378e4e694c5a1f56cd06d012c7c1210f" translate="yes" xml:space="preserve">
          <source>This function is called when the manager needs to communicate an &quot;asynchronous&quot; error to the user: e.g. failure to send an asynchronous message (i.e. encoding error), a received message was discarded due to security error, the manager failed to generate a response message to a received inform-request, or when receiving an unexpected PDU from an agent (could be an expired async request).</source>
          <target state="translated">이 기능은 관리자가 사용자에게 &quot;비동기&quot;오류를 전달해야하는 경우에 호출됩니다. 예 : 비동기 메시지 전송 실패 (예 : 인코딩 오류), 보안 오류로 인해 수신 된 메시지가 삭제되었으며 관리자가 응답 메시지를 생성하지 못했습니다. 수신 된 정보 요청, 또는 에이전트로부터 예기치 않은 PDU를 수신 할 때 (만료 된 비동기 요청 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="c1bd23363bb35671fd7a263f768278217cdab156" translate="yes" xml:space="preserve">
          <source>This function is called whenever Mnesia needs to determine which fragments that need to be searched for a &lt;code&gt;MatchSpec&lt;/code&gt;. It is typically called by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;.</source>
          <target state="translated">이 기능은 Mnesia는 검색 할 필요가있는 어떤 조각을 결정해야 할 때마다 호출 &lt;code&gt;MatchSpec&lt;/code&gt; . 일반적으로 &lt;code&gt;select&lt;/code&gt; 및 &lt;code&gt;match_object&lt;/code&gt; 에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="01c69191566d604ec0e4348c19597985d6671a38" translate="yes" xml:space="preserve">
          <source>This function is called whenever a test case (or configuration function) fails. It is called after the post function is called for the failed test case, that is:</source>
          <target state="translated">이 기능은 테스트 케이스 (또는 구성 기능)가 실패 할 때마다 호출됩니다. 실패한 테스트 케이스에 대해 사후 함수가 호출 된 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3efafaf0939c64a4ad9d5c14688207c28754d4e" translate="yes" xml:space="preserve">
          <source>This function is called whenever a test case (or configuration function) is skipped. It is called after the post function is called for the skipped test case, that is:</source>
          <target state="translated">이 기능은 테스트 케이스 (또는 구성 기능)를 건너 뛸 때마다 호출됩니다. 건너 뛴 테스트 케이스에 대해 사후 함수가 호출 된 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c606577dcdb814f628921da1d374fa61eef9bcbd" translate="yes" xml:space="preserve">
          <source>This function is called whenever an application has stopped. It is intended to be the opposite of &lt;code&gt;Module:start/2&lt;/code&gt; and is to do any necessary cleaning up. The return value is ignored.</source>
          <target state="translated">이 기능은 응용 프로그램이 중지 될 때마다 호출됩니다. 이것은 &lt;code&gt;Module:start/2&lt;/code&gt; 와 반대되는 것이며 필요한 정리 작업을 수행하는 것입니다. 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5ee521594d1ddf2a7d2b5598240a35e803ba7648" translate="yes" xml:space="preserve">
          <source>This function is called whenever an application is started using &lt;code&gt;start/1,2&lt;/code&gt;, and is to start the processes of the application. If the application is structured according to the OTP design principles as a supervision tree, this means starting the top supervisor of the tree.</source>
          <target state="translated">이 함수는 &lt;code&gt;start/1,2&lt;/code&gt; 를 사용하여 응용 프로그램을 시작할 때마다 호출되며 응용 프로그램 의 프로세스를 시작합니다. 응용 프로그램이 OTP 설계 원칙에 따라 감독 트리로 구성된 경우 이는 트리의 최고 감독자를 시작하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5ce2ffe3ef06f25d257eea92fe03c94bd042a9ba" translate="yes" xml:space="preserve">
          <source>This function is called whenever the parser runs out of input data. If the function can't get hold of more input an empty list or binary (depends on start input in stream/2) is returned. Other types of errors is handled through exceptions. Use throw/1 to send the following tuple {Tag = atom(), Reason = string()} if the continuation function encounters a fatal error. Tag is an atom that identifies the functional entity that sends the exception and Reason is a string that describes the problem.</source>
          <target state="translated">이 함수는 파서에 입력 데이터가 부족할 때마다 호출됩니다. 함수가 더 많은 입력을받지 못하면 빈 목록 또는 이진 (스트림 / 2의 시작 입력에 따라 다름)이 반환됩니다. 다른 유형의 오류는 예외를 통해 처리됩니다. 연속 함수에 치명적인 오류가 발생하면 throw / 1을 사용하여 다음 튜플 {Tag = atom (), Reason = string ()}을 보내십시오. Tag는 예외를 보내는 기능적 엔티티를 식별하는 원자이고 Reason은 문제를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="112c32a0ac8f37302565069e1af7c3d11d8ddc14" translate="yes" xml:space="preserve">
          <source>This function is completely synchronous, that is, when this function returns, the name is either registered on all nodes or none.</source>
          <target state="translated">이 함수는 완전히 동기화됩니다. 즉,이 함수가 리턴되면 이름이 모든 노드에 등록되거나 없음입니다.</target>
        </trans-unit>
        <trans-unit id="d629551f45aed938b0210e2c4a23a00e3421b297" translate="yes" xml:space="preserve">
          <source>This function is completely synchronous.</source>
          <target state="translated">이 기능은 완전히 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f35d4e7d98bb703e34921dfd922b82cf2abffe2a" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="d2dfc217a2570094e6cc323282a9ac2ec312cf13" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:adler32/1&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 사용 &lt;code&gt; erlang:adler32/1&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="a54ef9e0b04f05df35a0d8799f78f72ccd50b3d8" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:adler32/2&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 사용 &lt;code&gt; erlang:adler32/2&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="91fa6bf33569c121fe19cc7254b8b99d02f91829" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:adler32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 사용 &lt;code&gt; erlang:adler32_combine/3&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="9f68676907fa9644a72b09b3e8e55084c3793ca2" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32/1&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 사용 &lt;code&gt; erlang:crc32/1&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="dd82f4f6a6495fb95de1365c7dd445daddaeb507" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32/1&lt;/code&gt; on the uncompressed data instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 대신 압축되지 않은 데이터에 &lt;code&gt; erlang:crc32/1&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6bb5b48be5041ad67a139ae21d87cea520ccac4" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32/2&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 사용 &lt;code&gt; erlang:crc32/2&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="3e83cccb5a8d4e621eb6a5d9a0a7f3e0d9c4470d" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt; erlang:crc32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 사용 &lt;code&gt; erlang:crc32_combine/3&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="b70e6afc905702f524a5b9ff1b7ae5b183cbf540" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2 &lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거됩니다. 대신 &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2 &lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cf9e7b62dba47009024375097e3299049fe0a22" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 대신 &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="57c472f59dd3d2f6ad17dc07c92e4c60fcf49729" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32/1&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 사용 &lt;code&gt;erlang:adler32/1&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="db4675d63f920313a1ea26e962187e1aa011dcdd" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32/2&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 사용 &lt;code&gt;erlang:adler32/2&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="5ce49a62899e9f8f936f7b7c515c2cbbf4ad75dc" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:adler32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 사용 &lt;code&gt;erlang:adler32_combine/3&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="9a65b47bbbfbb54ad15ea7e9136f81e2f3a04ac4" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/1&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 사용 &lt;code&gt;erlang:crc32/1&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="9b52957272e25d9092e5e990877e3939651cbfce" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/1&lt;/code&gt; on the uncompressed data instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 압축되지 않은 데이터에 대신 &lt;code&gt;erlang:crc32/1&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f67f68973bfc4a8137b6bf187f50333109258a7" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32/2&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 사용 &lt;code&gt;erlang:crc32/2&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="fb4d9b393f14dc50ae3c01015c208fd2e887250e" translate="yes" xml:space="preserve">
          <source>This function is deprecated and will be removed in a future release. Use &lt;code&gt;erlang:crc32_combine/3&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다. 사용 &lt;code&gt;erlang:crc32_combine/3&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="2cf4312fba04cc8c15fd9776029ba4bd244d245c" translate="yes" xml:space="preserve">
          <source>This function is deprecated in the sense that the &lt;code&gt;error_logger&lt;/code&gt; is no longer the preferred interface for logging in Erlang/OTP. A new &lt;code&gt;logging API&lt;/code&gt; was added in Erlang/OTP 21.0, but legacy &lt;code&gt;error_logger&lt;/code&gt; handlers can still be used. New Logger handlers do not need to use this function, since the formatting callback (&lt;code&gt;report_cb&lt;/code&gt;) is included as metadata in the log event.</source>
          <target state="translated">&lt;code&gt;error_logger&lt;/code&gt; 가 더 이상 Erlang / OTP에 로그인하기 위해 선호되는 인터페이스가 아니라는 점에서이 기능은 더 이상 사용되지 않습니다 . Erlang / OTP 21.0에 새로운 &lt;code&gt;logging API&lt;/code&gt; 가 추가되었지만 레거시 &lt;code&gt;error_logger&lt;/code&gt; 핸들러를 계속 사용할 수 있습니다. 형식 지정 콜백 ( &lt;code&gt;report_cb&lt;/code&gt; )이 로그 이벤트에 메타 데이터로 포함되므로 새 로거 핸들러는이 함수를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="797c275c3663aa3f1286ac6e8f576a1c8979a3e4" translate="yes" xml:space="preserve">
          <source>This function is deprecated in the sense that the &lt;code&gt;error_logger&lt;/code&gt; is no longer the preferred interface for logging in Erlang/OTP. A new &lt;code&gt;logging API&lt;/code&gt; was added in Erlang/OTP 21.0, but legacy &lt;code&gt;error_logger&lt;/code&gt; handlers can still be used. New Logger handlers do not need to used this function, since the formatting callback (&lt;code&gt;report_cb&lt;/code&gt;) is included as metadata in the log event.</source>
          <target state="translated">&lt;code&gt;error_logger&lt;/code&gt; 가 더 이상 Erlang / OTP에 로그인하기 위해 선호되는 인터페이스가 아니라는 점에서이 기능은 더 이상 사용되지 않습니다 . Erlang / OTP 21.0에 새로운 &lt;code&gt;logging API&lt;/code&gt; 가 추가되었지만 레거시 &lt;code&gt;error_logger&lt;/code&gt; 핸들러를 계속 사용할 수 있습니다. 형식 지정 콜백 ( &lt;code&gt;report_cb&lt;/code&gt; )이 로그 이벤트에 메타 데이터로 포함되므로 새 로거 핸들러는이 함수를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5e0a6ac180dc5b3447b4979a16254d508048fc" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt; local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; instead, as it gives a more correct and complete result. Especially for the period that does not exist, as it is skipped during the switch &lt;strong&gt;to&lt;/strong&gt; daylight saving time, this function still returns a result.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 더 정확하고 완전한 결과를 제공하므로 대신 &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt; local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 . 특히 존재하지 않는 기간의 경우 일광 절약 시간 제로 전환 &lt;strong&gt;하는&lt;/strong&gt; 동안 건너 뛰기 때문에이 함수는 여전히 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93275cd4e56a52fc18f140562459cc7469aef3e4" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt;local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; instead, as it gives a more correct and complete result. Especially for the period that does not exist, as it is skipped during the switch &lt;strong&gt;to&lt;/strong&gt; daylight saving time, this function still returns a result.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 보다 정확하고 완전한 결과를 제공하므로 &lt;code&gt;&lt;a href=&quot;#local_time_to_universal_time_dst-1&quot;&gt;local_time_to_universal_time_dst/1&lt;/a&gt;&lt;/code&gt; 을 대신 사용하십시오 . 특히 존재하지 않는 기간 동안 일광 절약 시간으로 전환 &lt;strong&gt;하는&lt;/strong&gt; 동안 건너 뛰므로이 함수는 여전히 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="107787156b19ddd4b875082324ae72f8e4e9d678" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt; filelib:find_source/1&lt;/a&gt;&lt;/code&gt; instead for finding source files.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 사용 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt; filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 대신에 소스 파일을 찾기위한.</target>
        </trans-unit>
        <trans-unit id="c812739c6fd83de52547a755970ceca008f0b790" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; instead for finding source files.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 사용 &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; 대신에 소스 파일을 찾기위한.</target>
        </trans-unit>
        <trans-unit id="7862d9b3a29dd09774fab5841e177464de1a0d4c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;&lt;a href=&quot;filelib#safe_relative_path-2&quot;&gt; filelib:safe_relative_path/2&lt;/a&gt;&lt;/code&gt; instead for sanitizing paths.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 경로 삭제 대신 &lt;code&gt;&lt;a href=&quot;filelib#safe_relative_path-2&quot;&gt; filelib:safe_relative_path/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bad5bec42b08c1e7fcdb1abc8d7d5c436046ff91" translate="yes" xml:space="preserve">
          <source>This function is designed to be used by the KERNEL &lt;code&gt;logger&lt;/code&gt;. Be careful if you change it to something else as log messages may be lost. If you want to intercept emulator log messages, do it by adding a specialized handler to the KERNEL logger.</source>
          <target state="translated">이 기능은 KERNEL &lt;code&gt;logger&lt;/code&gt; 사용하도록 설계되었습니다 . 로그 메시지가 손실 될 수 있으므로 다른 것으로 변경하는 경우주의하십시오. 에뮬레이터 로그 메시지를 가로 채려면 특수 처리기를 KERNEL 로거에 추가하여 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e693393ef522640c54a2f9b1422caf298b96748a" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;#send-4-AncData&quot;&gt;send(Socket, Destination, [], Packet)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#send-4-AncData&quot;&gt;send(Socket, Destination, [], Packet)&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2f4e6b180074e2f9f3f128b4c971b69623e3ec1e" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;, but acts on the given node. A tracer is started on the node (&lt;code&gt;Nodename&lt;/code&gt;) and the node is added to the list of traced nodes.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 와 동일 하지만 지정된 노드에서 작동합니다. 추적 프로그램이 노드 ( &lt;code&gt;Nodename&lt;/code&gt; ) 에서 시작되고 추적 된 노드 목록에 노드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c92d04be5c71ca9752e01679ace3dd192a2701dc" translate="yes" xml:space="preserve">
          <source>This function is evaluated if a call is made to &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; when the module defining the fun is not loaded. The function is evaluated inside the process making the original call.</source>
          <target state="translated">fun을 정의하는 모듈이로드되지 않은 경우 &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; 을 호출하면이 함수가 평가됩니다 . 함수는 원래 호출하는 프로세스 내에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="397de6af2f56ed299f26a66779fa39dc2d87c829" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging only.</source>
          <target state="translated">이 기능은 디버깅 전용입니다.</target>
        </trans-unit>
        <trans-unit id="6f93c6fcd137c8978ef002f7f0267507232415ce" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging only. It produces a slightly processed dump of the session database. The first list of the session information tuple will contain session information on an internal format. The last two lists of the session information tuple should always be empty if the code is working as intended. If no profile is specified, the default profile is used.</source>
          <target state="translated">이 함수는 디버깅 전용입니다. 세션 데이터베이스의 약간 처리 된 덤프를 생성합니다. 세션 정보 튜플의 첫 번째 목록에는 내부 형식에 대한 세션 정보가 포함됩니다. 세션 정보 튜플의 마지막 두 목록은 코드가 의도 한대로 작동하는 경우 항상 비어 있어야합니다. 프로필을 지정하지 않으면 기본 프로필이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e70db1a93c8f76d23e7c3d3fb2baea3f7a6af2b" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging purposes only.</source>
          <target state="translated">이 기능은 디버깅 목적으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f60000c240fa5a82e86efdce70cc54b8977641c" translate="yes" xml:space="preserve">
          <source>This function is intended for send operations to an unreliable remote node without ever blocking the sending (Erlang) process. If the connection to the remote node (usually not a real Erlang node, but a node written in C or Java) is overloaded, this function &lt;strong&gt;does not send the message&lt;/strong&gt; and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 기능은 전송 (Erlang) 프로세스를 차단하지 않고 신뢰할 수없는 원격 노드로 전송 작업을하기위한 것입니다. 원격 노드 (일반적으로 실제 Erlang 노드는 아니지만 C 또는 Java로 작성된 노드)에 대한 연결이 과부하되면이 함수 &lt;strong&gt;는 메시지를 보내지 않고 &lt;/strong&gt; &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="81171218c09769a1d5b4af85d5937f41eeaa5f09" translate="yes" xml:space="preserve">
          <source>This function is intended to be called by a process belonging to an application, when the application is started, to determine the start type, which is &lt;code&gt;StartType&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;.</source>
          <target state="translated">이 함수는 애플리케이션이 시작될 때 시작 유형 ( &lt;code&gt;StartType&lt;/code&gt; 또는 &lt;code&gt;local&lt;/code&gt; ) 을 판별하기 위해 애플리케이션에 속하는 프로세스에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4c87f0aca040e4bc019e958efeaad03d57b852a" translate="yes" xml:space="preserve">
          <source>This function is intended to be called in test cases in test suites.</source>
          <target state="translated">이 함수는 테스트 스위트의 테스트 케이스에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e10f123bbee56ea9b87adef7c85f24ef9a0bea62" translate="yes" xml:space="preserve">
          <source>This function is intended to be called in the test cases in the test suite.</source>
          <target state="translated">이 기능은 테스트 스위트의 테스트 케이스에서 호출하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b921fbf118e94cca94277c181ed0c5045bbfaba" translate="yes" xml:space="preserve">
          <source>This function is intended to be invoked at strategic places in user applications in order to enable simplified tracing. The functions are extremely light weight as they do nothing besides returning an atom. The functions are designed for being traced. The global tracing mechanism in &lt;code&gt;et_collector&lt;/code&gt; defaults to set its trace pattern to these functions.</source>
          <target state="translated">이 기능은 단순화 된 추적을 가능하게하기 위해 사용자 애플리케이션의 전략적 위치에서 호출되도록 고안되었습니다. 원자를 돌려주는 것 외에는 아무것도하지 않기 때문에 함수는 매우 가볍습니다. 기능은 추적되도록 설계되었습니다. &lt;code&gt;et_collector&lt;/code&gt; 의 전역 추적 메커니즘은 기본적으로 추적 패턴을 이러한 기능으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="36a555885bb62cc8fb0d04fa074ce553eafe397b" translate="yes" xml:space="preserve">
          <source>This function is intended to be invoked by some transport modules when get an incoming message. Which transport that actually is used is up to the user to choose.</source>
          <target state="translated">이 기능은 들어오는 메시지를받을 때 일부 전송 모듈에 의해 호출됩니다. 실제로 사용되는 전송은 사용자가 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d3f5fd62fd46c21ebd6dea29aa844aba60cb08c" translate="yes" xml:space="preserve">
          <source>This function is invoked as this module is added as a child of the &lt;code&gt;erl_distribution&lt;/code&gt; supervisor.</source>
          <target state="translated">이 기능은이 모듈이 &lt;code&gt;erl_distribution&lt;/code&gt; 수퍼바이저 의 자식으로 추가 될 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d32e0beab2a86c2649b5c5e66d99028d158f64c" translate="yes" xml:space="preserve">
          <source>This function is invoked if the originating pending limit has been exceeded. This usually means that a request has taken abnormally long time to complete.</source>
          <target state="translated">이 함수는 시작 보류 제한을 초과 한 경우 호출됩니다. 이는 일반적으로 요청 완료에 오랜 시간이 걸린다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7fe0a088ee8a115443a4b7c28bd5e240eaea2ffd" translate="yes" xml:space="preserve">
          <source>This function is mandatory.</source>
          <target state="translated">이 기능은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="23ddde2c73699705374784b1a6630cfc5af08e7d" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string directly from a test case to the test case log file.</source>
          <target state="translated">이 기능은 테스트 케이스에서 테스트 케이스 로그 파일로 직접 문자열을 인쇄하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c8ca547da965f042e95bb1424e4289fdf1c4a1b" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string from a test case to the console.</source>
          <target state="translated">이 기능은 테스트 케이스에서 콘솔로 문자열을 인쇄하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="200109fd126bab7ec37db1035c7afff40cc8667c" translate="yes" xml:space="preserve">
          <source>This function is meant for printing a string from a test case, both to the test case log file and to the console.</source>
          <target state="translated">이 기능은 테스트 케이스에서 테스트 케이스 로그 파일 및 콘솔로 문자열을 인쇄하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2dbc6b277a2853a0b6bf11d0b8a4589a39100a82" translate="yes" xml:space="preserve">
          <source>This function is meant to be used for debugging only.</source>
          <target state="translated">이 기능은 디버깅에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="353984c9a0fb4f2aea1206112d183a058e95d4a0" translate="yes" xml:space="preserve">
          <source>This function is mostly for debugging purposes, Normally &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;next&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt;/&lt;code&gt;prev&lt;/code&gt; are to be used instead.</source>
          <target state="translated">이 함수는 주로 디버깅 목적으로 사용되며 일반적으로 &lt;code&gt;first&lt;/code&gt; / &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;last&lt;/code&gt; / &lt;code&gt;prev&lt;/code&gt; 가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="932f20a018c847fbfb4197a37b0d2d604f5eb9f7" translate="yes" xml:space="preserve">
          <source>This function is normally not called by the user. The user only needs to call if the channel process needs to be started with help of &lt;code&gt;proc_lib&lt;/code&gt; instead of calling &lt;code&gt;start/4&lt;/code&gt; or &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">이 기능은 일반적으로 사용자가 호출하지 않습니다. 사용자는 채널 프로세스 요구의 도움으로 시작하는 경우 호출해야 &lt;code&gt;proc_lib&lt;/code&gt; 를 호출하는 대신 &lt;code&gt;start/4&lt;/code&gt; 또는 &lt;code&gt;start_link/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42f571587b780a1e6f46d35b2d96fbee773dc95d" translate="yes" xml:space="preserve">
          <source>This function is not equivalent to &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt;. While &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; starts a process tracer which redirects all trace information to a process tracer on the local node (i.e. the trace control node), &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; starts a tracer of any type which is independent of the tracer on the trace control node.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 과 동일하지 않습니다 . 반면 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; , 로컬 노드에서 프로세스 추적 모든 추적 정보 (즉, 추적 제어 노드) 리디렉션 프로세스 추적 시작 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 추적 제어 노드 트레이서 독립적 인 임의의 타입의 추적을 시작한다.</target>
        </trans-unit>
        <trans-unit id="bc4cccc5c4f2f3772a98e697fd645208ffc7bcd9" translate="yes" xml:space="preserve">
          <source>This function is obsolete. Use the conversion functions for gregorian days and seconds instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 그레고리 안 일과 초에 변환 기능을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1410613873cd68c550a08bd7e69d18ff526645c9" translate="yes" xml:space="preserve">
          <source>This function is occasionally useful when it is necessary to have annotations on the subnodes of a list constructor node, even when the subnodes are constant literals. Note however that &lt;code&gt;is_literal/1&lt;/code&gt; will yield &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;concrete/1&lt;/code&gt; will fail if passed the result from this function.</source>
          <target state="translated">이 함수는 하위 노드가 상수 리터럴 인 경우에도 목록 생성자 노드의 하위 노드에 대한 주석이 필요할 때 유용합니다. 그러나 &lt;code&gt;is_literal/1&lt;/code&gt; 은이 함수의 결과를 전달하면 &lt;code&gt;false&lt;/code&gt; 를 생성 하고 &lt;code&gt;concrete/1&lt;/code&gt; 은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="da720859fde23616eefcd04feb5000fa3d749010" translate="yes" xml:space="preserve">
          <source>This function is occasionally useful when it is necessary to have annotations on the subnodes of a tuple node, even when all the subnodes are constant literals. Note however that &lt;code&gt;is_literal/1&lt;/code&gt; will yield &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;concrete/1&lt;/code&gt; will fail if passed the result from this function.</source>
          <target state="translated">이 함수는 모든 하위 노드가 상수 리터럴 인 경우에도 튜플 노드의 하위 노드에 대한 주석이 필요한 경우에 유용합니다. 그러나 &lt;code&gt;is_literal/1&lt;/code&gt; 은이 함수의 결과를 전달하면 &lt;code&gt;false&lt;/code&gt; 를 생성 하고 &lt;code&gt;concrete/1&lt;/code&gt; 은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ce7c408302373e6adf8e0f46e04cfc34dc2748e9" translate="yes" xml:space="preserve">
          <source>This function is only intended for testing purposes. It's supposed to have a same kind of interface as the &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; functions (with the additions of the &lt;code&gt;EncodingMod&lt;/code&gt; and &lt;code&gt;EncodingConfig&lt;/code&gt; arguments). It composes a complete megaco message end attempts to encode it. The return value, will be a tuple of the composed megaco message and the encode result.</source>
          <target state="translated">이 기능은 테스트 목적으로 만 사용됩니다. &lt;code&gt;EncodingMod&lt;/code&gt; 및 &lt;code&gt;EncodingConfig&lt;/code&gt; 인수를 추가 하여 &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; 함수와 동일한 종류의 인터페이스를 가져야합니다 . 그것은 완전한 메가 코 메시지 엔드의 인코딩 시도를 구성합니다. 리턴 값은 구성된 megaco 메시지와 인코딩 결과의 튜플이됩니다.</target>
        </trans-unit>
        <trans-unit id="f9e0331af836baa2d84d1f916d61996854b6352b" translate="yes" xml:space="preserve">
          <source>This function is only intended for testing purposes. It's supposed to test the &lt;code&gt;actual_reply()&lt;/code&gt; return value of the callback functions &lt;code&gt;&lt;a href=&quot;megaco_user#trans_request&quot;&gt;handle_trans_request&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco_user#trans_long_request&quot;&gt;handle_trans_long_request&lt;/a&gt;&lt;/code&gt; functions (with the additions of the &lt;code&gt;EncodingMod&lt;/code&gt; and &lt;code&gt;EncodingConfig&lt;/code&gt; arguments). It composes a complete megaco message end attempts to encode it. The return value, will be a tuple of the composed megaco message and the encode result.</source>
          <target state="translated">이 기능은 테스트 목적으로 만 사용됩니다. 콜백 함수 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_request&quot;&gt;handle_trans_request&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_long_request&quot;&gt;handle_trans_long_request&lt;/a&gt;&lt;/code&gt; 함수 의 &lt;code&gt;actual_reply()&lt;/code&gt; 반환 값 을 테스트해야 합니다 ( &lt;code&gt;EncodingMod&lt;/code&gt; 및 &lt;code&gt;EncodingConfig&lt;/code&gt; 인수 추가). 그것은 완전한 메가 코 메시지 엔드의 인코딩 시도를 구성합니다. 리턴 값은 구성된 megaco 메시지와 인코딩 결과의 튜플이됩니다.</target>
        </trans-unit>
        <trans-unit id="df58ae53df4ed25f773afed230f30889dcd5ca99" translate="yes" xml:space="preserve">
          <source>This function is only thread-safe when the emulator with SMP support is used.</source>
          <target state="translated">이 기능은 SMP를 지원하는 에뮬레이터를 사용하는 경우에만 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aef102baa9fb64ea372514334c60d7b3b9f264e9" translate="yes" xml:space="preserve">
          <source>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</source>
          <target state="translated">이 기능은 SMP를 지원하는 에뮬레이터를 사용하는 경우에만 스레드로부터 안전합니다. NIF 호출 스레드의 비 SMP 에뮬레이터에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c95c65aaea895304dfbed57d7ceb302b881182" translate="yes" xml:space="preserve">
          <source>This function is only to be used in rare circumstances where a process communicates with Erlang nodes that can disappear without any trace, causing the TCP buffers and the drivers queue to be over-full before the node is shut down (because of tick time-outs) by &lt;code&gt;net_kernel&lt;/code&gt;. The normal reaction to take when this occurs is some kind of premature shutdown of the other node.</source>
          <target state="translated">이 기능은 프로세스가 추적없이 사라질 수있는 Erlang 노드와 통신하는 드문 상황에서만 사용되며, 노드가 종료되기 전에 TCP 버퍼 및 드라이버 큐가 가득 찼습니다 (틱 시간 초과로 인해) )에 의해 &lt;code&gt;net_kernel&lt;/code&gt; . 이러한 상황이 발생하면 정상적인 반응은 다른 노드의 조기 종료입니다.</target>
        </trans-unit>
        <trans-unit id="b91ea27388e04da4e23c43f3cd2a1b24a1b3f051" translate="yes" xml:space="preserve">
          <source>This function is only to be used on short lists, as a copy is created of the list, which is not released until after the NIF returns.</source>
          <target state="translated">이 함수는 NIF가 리턴 될 때까지 릴리스되지 않는리스트의 사본이 작성되므로 짧은리스트에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c2b27f3795376fc611944f7d7c38e8f0670e208" translate="yes" xml:space="preserve">
          <source>This function is optional.</source>
          <target state="translated">이 기능은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="c8eb9533643d424e90f80bd181b73132613e7c18" translate="yes" xml:space="preserve">
          <source>This function is optional. The return value is discarded.</source>
          <target state="translated">이 기능은 옵션입니다. 반환 값은 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b3a473185dfec37318ffd01ffc565de71b54e4" translate="yes" xml:space="preserve">
          <source>This function is optional. Used when connection is up.</source>
          <target state="translated">이 기능은 옵션입니다. 연결시 사용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
