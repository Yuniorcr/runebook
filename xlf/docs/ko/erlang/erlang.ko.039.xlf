<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="916ee7c748bb5e7a2bf22555efc9c7ba3e8e1d3f" translate="yes" xml:space="preserve">
          <source>The file is opened with another &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; and the data in the file cannot be translated to the byte-oriented data that this function returns.</source>
          <target state="translated">&lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 파일이 열리고 파일의 데이터를이 함수가 반환하는 바이트 지향 데이터로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af4cd6106424f7957ea5b09a69738ba162a42d0a" translate="yes" xml:space="preserve">
          <source>The file is opened with another &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt; and the data on the file cannot be translated to the byte-oriented data that this function returns.</source>
          <target state="translated">&lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 파일이 열리고 파일의 데이터를이 함수가 반환하는 바이트 지향 데이터로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1447089fad09b9920a3125bbbcb71e40fcf03b8" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file and &lt;code&gt;Value&lt;/code&gt; the value of the last expression.</source>
          <target state="translated">파일을 읽고 평가합니다. &lt;code&gt;FullName&lt;/code&gt; 은 파일의 전체 이름이며 마지막 식의 값은 &lt;code&gt;Value&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab1ff8d4200f6f26fb7134240fe2228fd2ecd31d" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">파일을 읽고 평가합니다. &lt;code&gt;FullName&lt;/code&gt; 은 파일의 전체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2975a465dfe23956015ba6c274ed78e16024bfa9" translate="yes" xml:space="preserve">
          <source>The file is read and evaluated. &lt;code&gt;Value&lt;/code&gt; is the value of the last expression.</source>
          <target state="translated">파일을 읽고 평가합니다. &lt;code&gt;Value&lt;/code&gt; 은 마지막 표현식의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e333fb72ddfdad9f98da967fd861cc9cecde73c6" translate="yes" xml:space="preserve">
          <source>The file is read by the application controller when an application is loaded/started. It is also used by the functions in &lt;code&gt;systools&lt;/code&gt;, for example when generating start scripts.</source>
          <target state="translated">응용 프로그램이로드 / 시작될 때 응용 프로그램 제어기가 파일을 읽습니다. 또한 시작 스크립트를 생성 할 때 와 같이 &lt;code&gt;systools&lt;/code&gt; 의 함수에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d522dbd681f4cd878e0a0aeb3cbd943d113a8c38" translate="yes" xml:space="preserve">
          <source>The file is successfully read. &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">파일을 읽습니다. &lt;code&gt;FullName&lt;/code&gt; 은 파일의 전체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e117edda70b67ee50f9d2f7fce2e7996b73bd637" translate="yes" xml:space="preserve">
          <source>The file must be in &lt;code&gt;ssh-keygen moduli file format&lt;/code&gt;. The file is read when the daemon starts.</source>
          <target state="translated">파일은 &lt;code&gt;ssh-keygen moduli file format&lt;/code&gt; 이어야 합니다 . 데몬이 시작될 때 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="80ee3eac8f806ec9cde470e2d7d3f7c22d220194" translate="yes" xml:space="preserve">
          <source>The file must be named &lt;code&gt;Rel.rel&lt;/code&gt;, where &lt;code&gt;Rel&lt;/code&gt; is a unique name.</source>
          <target state="translated">파일 이름은 &lt;code&gt;Rel.rel&lt;/code&gt; 이어야합니다 . 여기서 &lt;code&gt;Rel&lt;/code&gt; 은 고유 한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7582f5f80d20de2502ad5d3c778be456df031796" translate="yes" xml:space="preserve">
          <source>The file must contain a single Erlang term, which is called an &lt;strong&gt;application specification&lt;/strong&gt;:</source>
          <target state="translated">파일에는 단일 Erlang 용어가 포함되어야하며이를 &lt;strong&gt;애플리케이션 사양&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="d15a1263b243302ad1b99430abd18bc925e32e3e" translate="yes" xml:space="preserve">
          <source>The file must have one or more three-tuples &lt;code&gt;{Size=integer(),G=integer(),P=integer()}&lt;/code&gt; terminated by a dot. The file is read when the daemon starts.</source>
          <target state="translated">파일 에는 점으로 끝나는 하나 이상의 3 개 튜플 &lt;code&gt;{Size=integer(),G=integer(),P=integer()}&lt;/code&gt; 가 있어야합니다 . 데몬이 시작될 때 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="56458bdbcf5690ec8658261e5325164ce2a2a111" translate="yes" xml:space="preserve">
          <source>The file name of the current module.</source>
          <target state="translated">현재 모듈의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a5d1d6d598f59230fdf0a71188330092a7de64cf" translate="yes" xml:space="preserve">
          <source>The file name requirement on the engine dynamic library can differ between SSL versions.</source>
          <target state="translated">엔진 동적 라이브러리의 파일 이름 요구 사항은 SSL 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf117b829fc2877fe7b8ccf793bd866ee82bf7d" translate="yes" xml:space="preserve">
          <source>The file names consist of eight hexadecimal digits followed by &lt;code&gt;.rN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer, e.g. &lt;code&gt;1a2b3c4d.r0&lt;/code&gt;. For the first version of the CRL, &lt;code&gt;N&lt;/code&gt; starts at zero, and for each new version, &lt;code&gt;N&lt;/code&gt; is incremented by one. The OpenSSL utility &lt;code&gt;c_rehash&lt;/code&gt; creates symlinks according to this pattern.</source>
          <target state="translated">파일 이름은 8 개의 16 진 숫자와 &lt;code&gt;.rN&lt;/code&gt; 으로 구성되며 &lt;code&gt;N&lt;/code&gt; 은 정수입니다 (예 : &lt;code&gt;1a2b3c4d.r0&lt;/code&gt; ) . CRL의 첫 번째 버전에서 &lt;code&gt;N&lt;/code&gt; 은 0에서 시작하고 새 버전마다 &lt;code&gt;N&lt;/code&gt; 씩 1 씩 증가합니다. OpenSSL 유틸리티 &lt;code&gt;c_rehash&lt;/code&gt; 는이 패턴에 따라 심볼릭 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d7d30bf4111cf6d645a316a6236bd904ed813968" translate="yes" xml:space="preserve">
          <source>The file offset in the zip archive (used internally)</source>
          <target state="translated">zip 아카이브의 파일 오프셋 (내부적으로 사용)</target>
        </trans-unit>
        <trans-unit id="98c7f36c4669e374fe284c2ff98a9ddaef5cf51f" translate="yes" xml:space="preserve">
          <source>The file permissions as the sum of the following bit values:</source>
          <target state="translated">파일은 다음 비트 값의 합으로 사용 권한입니다.</target>
        </trans-unit>
        <trans-unit id="9515e875a26b329b033fd7640f399fd9edd7196e" translate="yes" xml:space="preserve">
          <source>The file privileges and ownership of the &lt;code&gt;mod_syslog&lt;/code&gt; utility must be modified.</source>
          <target state="translated">&lt;code&gt;mod_syslog&lt;/code&gt; 유틸리티 의 파일 권한 및 소유권을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4f22a3c177173ba882d73ea3867a6b6cb6d9dc7" translate="yes" xml:space="preserve">
          <source>The file suffix of the incoming URL mapped into a &lt;code&gt;MimeType&lt;/code&gt;</source>
          <target state="translated">들어오는 URL의 파일 접미사가 &lt;code&gt;MimeType&lt;/code&gt; 에 매핑되었습니다.</target>
        </trans-unit>
        <trans-unit id="f4eba4c3a153db010c6d9b7a15465b2d5b3ce266" translate="yes" xml:space="preserve">
          <source>The file suffix of the incoming URL mapped into a &lt;code&gt;MimeType&lt;/code&gt;.</source>
          <target state="translated">들어오는 URL의 파일 접미사가 &lt;code&gt;MimeType&lt;/code&gt; 에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="f294360a334b35b807188de18da95f7579b0fb4d" translate="yes" xml:space="preserve">
          <source>The file system on the other host has a different structure to the the master.</source>
          <target state="translated">다른 호스트의 파일 시스템은 마스터와 다른 구조를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c75ca2cbc895f2093ee4a98814185b1afc3a8e1a" translate="yes" xml:space="preserve">
          <source>The file system path to the directory where the driver object file is located. The filename of the object file (minus extension) must correspond to the driver name (used in parameter &lt;code&gt;Name&lt;/code&gt;) and the driver must identify itself with the same name. &lt;code&gt;Path&lt;/code&gt; can be provided as an &lt;strong&gt;iolist()&lt;/strong&gt;, meaning it can be a list of other &lt;code&gt;iolist()&lt;/code&gt;s, characters (8-bit integers), or binaries, all to be flattened into a sequence of characters.</source>
          <target state="translated">드라이버 오브젝트 파일이있는 디렉토리의 파일 시스템 경로입니다. 오브젝트 파일의 파일 이름 (확장자 빼기)은 드라이버 이름 (매개 변수 &lt;code&gt;Name&lt;/code&gt; 에서 사용 )과 일치해야하며 드라이버 는 동일한 이름으로 자신을 식별해야합니다. &lt;code&gt;Path&lt;/code&gt; 는 &lt;strong&gt;iolist ()&lt;/strong&gt; 로 제공 될 수 있습니다 . 즉, 다른 &lt;code&gt;iolist()&lt;/code&gt; , 문자 (8 비트 정수) 또는 이진의 목록 일 수 있으며 모두 일련의 문자로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="bf2eb9cc34b90180610fbc75837cbfad30b948cc" translate="yes" xml:space="preserve">
          <source>The file trace driver expects a filename or a wrap files specification as parameter. A file is written with a high degree of buffering, why all trace messages are &lt;strong&gt;not&lt;/strong&gt; guaranteed to be saved in the file in case of a system crash. That is the price to pay for low tracing overhead.</source>
          <target state="translated">파일 추적 드라이버는 파일 이름 또는 랩 파일 스펙을 매개 변수로 예상합니다. 파일은 높은 수준의 버퍼링으로 작성 되므로 시스템 충돌시 모든 추적 메시지가 파일에 저장 &lt;strong&gt;되지 않을&lt;/strong&gt; 수 있습니다. 이것이 낮은 추적 오버 헤드에 대한 대가입니다.</target>
        </trans-unit>
        <trans-unit id="083d3049caca9cb4909e07d982cf1c0a253eda8d" translate="yes" xml:space="preserve">
          <source>The file transfer type is set to the default of the FTP server when the session is opened. This is usually ASCCI mode.</source>
          <target state="translated">파일 전송 유형은 세션이 열릴 때 FTP 서버의 기본값으로 설정됩니다. 일반적으로 ASCCI 모드입니다.</target>
        </trans-unit>
        <trans-unit id="d7d87c17221873fd0d28c7a0cf27f97994b73b47" translate="yes" xml:space="preserve">
          <source>The file used must be opened using the &lt;code&gt;raw&lt;/code&gt; flag, and the process calling &lt;code&gt;sendfile&lt;/code&gt; must be the controlling process of the socket. See &lt;code&gt;&lt;a href=&quot;gen_tcp#controlling_process-2&quot;&gt;gen_tcp:controlling_process/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용 된 파일은 &lt;code&gt;raw&lt;/code&gt; 플래그를 사용하여 열어야하며 &lt;code&gt;sendfile&lt;/code&gt; 을 호출하는 프로세스 는 소켓의 제어 프로세스 여야합니다. &lt;code&gt;&lt;a href=&quot;gen_tcp#controlling_process-2&quot;&gt;gen_tcp:controlling_process/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0739dac79b5f4f1aa7ca70031ae5a16c934c399" translate="yes" xml:space="preserve">
          <source>The file was read and evaluated.</source>
          <target state="translated">파일을 읽고 평가했습니다.</target>
        </trans-unit>
        <trans-unit id="4e58a2f1e91ddce67de54ef340e3da2cb9cb63a1" translate="yes" xml:space="preserve">
          <source>The file was successfully read.</source>
          <target state="translated">파일을 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="d6065777a4960e5c157c07fd30dae24b515e8523" translate="yes" xml:space="preserve">
          <source>The file(s) in the &lt;code&gt;property_test&lt;/code&gt; subdirectory could, or should, include the ct_property_test include file:</source>
          <target state="translated">의 파일 (들) &lt;code&gt;property_test&lt;/code&gt; 하위 디렉토리, 또는, ct_property_test 포함 파일을 포함해야한다 수 :</target>
        </trans-unit>
        <trans-unit id="c72d65e1c03281b49322438db24cb3e3334edd0b" translate="yes" xml:space="preserve">
          <source>The file, which must exist, is opened for reading.</source>
          <target state="translated">존재해야하는 파일을 읽기 위해 열립니다.</target>
        </trans-unit>
        <trans-unit id="552bd26b6c475a1374de92e4954676c79da00420" translate="yes" xml:space="preserve">
          <source>The filename</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="26016e882c6ac80280490e30771a8dba2723ae37" translate="yes" xml:space="preserve">
          <source>The filename must be &lt;code&gt;syslog.conf.OTP&lt;/code&gt;. The path must be the same as the backup copy.</source>
          <target state="translated">파일 이름은 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 이어야합니다 . 경로는 백업 사본과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="29478f77cee4c57798b46ebd0b4dff9c27a01cc8" translate="yes" xml:space="preserve">
          <source>The filename of the copy must be &lt;code&gt;syslog.conf.ORIG&lt;/code&gt;. The directory location is optional; usually it is &lt;code&gt;/etc&lt;/code&gt;. A simple way to do this is to issue the following command:</source>
          <target state="translated">복사본의 파일 이름은 &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 이어야합니다 . 디렉토리 위치는 선택 사항입니다. 일반적으로 &lt;code&gt;/etc&lt;/code&gt; 입니다. 이를 수행하는 간단한 방법은 다음 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5af1d694b8b3cdebbfc3c0f00daedcbcdd080514" translate="yes" xml:space="preserve">
          <source>The filename of the crashdump.</source>
          <target state="translated">크래시 덤프의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f51e4a22a3fd6a63b9b7c7d8ef4afc50be94d9de" translate="yes" xml:space="preserve">
          <source>The filename translation mode can be read with function &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;, which returns &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding) or &lt;code&gt;utf8&lt;/code&gt;.</source>
          <target state="translated">파일 이름 변환 모드는 함수 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 으로 읽을 수 있으며 &lt;code&gt;latin1&lt;/code&gt; (바이트 별 인코딩) 또는 &lt;code&gt;utf8&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0bbf7541fe0325c793eec29d4cd8ad35ed00aa5e" translate="yes" xml:space="preserve">
          <source>The files are unzipped to memory or to file, depending on the options specified to function &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; when opening the archive.</source>
          <target state="translated">아카이브를 열 때 &lt;code&gt;&lt;a href=&quot;#zip_open-1&quot;&gt;zip_open/1,2&lt;/a&gt;&lt;/code&gt; 기능으로 지정된 옵션에 따라 파일이 메모리 또는 파일로 압축 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8c783c92fcd9bf942dd424f42fc61d302ddafc6" translate="yes" xml:space="preserve">
          <source>The files are:</source>
          <target state="translated">파일은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="c0b32d670fd0928ee57d4da38842a479ce59c02a" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;did not pass&lt;/strong&gt;, and the log event is immediately discarded.</source>
          <target state="translated">필터 &lt;strong&gt;가 전달되지 않아&lt;/strong&gt; 로그 이벤트가 즉시 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="2fec5992ce5b4648b9da53b9fca03126f14195c8" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;passed&lt;/strong&gt;. The next handler filter, if any, is applied. If no more filters exist for this handler, the log event is forwarded to the handler callback.</source>
          <target state="translated">필터가 &lt;strong&gt;통과했습니다&lt;/strong&gt; . 다음 핸들러 필터 (있는 경우)가 적용됩니다. 이 핸들러에 대한 필터가 더 이상 없으면 로그 이벤트가 핸들러 콜백으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c64e728f01227118a6f0a504e74466c80ec0c979" translate="yes" xml:space="preserve">
          <source>The filter &lt;strong&gt;passed&lt;/strong&gt;. The next primary filter, if any, is applied. If no more primary filters exist, the log event is forwarded to the handler part of Logger, where handler filters are applied.</source>
          <target state="translated">필터가 &lt;strong&gt;통과했습니다&lt;/strong&gt; . 다음 기본 필터 (있는 경우)가 적용됩니다. 기본 필터가 더 이상 없으면 로그 이벤트는 Logger의 핸들러 부분으로 전달되며 여기서 핸들러 필터가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4778fe9a2d1bb2efd40561548fc65defaa0949" translate="yes" xml:space="preserve">
          <source>The filter compares the value of the &lt;code&gt;domain&lt;/code&gt; field in the log event's metadata (&lt;code&gt;Domain&lt;/code&gt;) against &lt;code&gt;MatchDomain&lt;/code&gt;. The filter matches if the value of &lt;code&gt;Compare&lt;/code&gt; is:</source>
          <target state="translated">이 필터는 로그 이벤트 메타 데이터 ( &lt;code&gt;Domain&lt;/code&gt; ) 의 &lt;code&gt;domain&lt;/code&gt; 필드 값을 &lt;code&gt;MatchDomain&lt;/code&gt; 과 비교 합니다. &lt;code&gt;Compare&lt;/code&gt; 값 이 다음 과 같은 경우 필터가 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="51a93150ad29f0ccf2e63c9c4ef6e74ec818ee46" translate="yes" xml:space="preserve">
          <source>The filter compares the value of the event's log level (&lt;code&gt;Level&lt;/code&gt;) to &lt;code&gt;MatchLevel&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt;. The filter matches if the value of &lt;code&gt;Operator&lt;/code&gt; is:</source>
          <target state="translated">필터는 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt; 을 호출 하여 이벤트의 로그 수준 ( &lt;code&gt;Level&lt;/code&gt; ) 값을 &lt;code&gt;MatchLevel&lt;/code&gt; 과 비교합니다 . &lt;code&gt;Operator&lt;/code&gt; 의 값 이 다음 과 같은 경우 필터가 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="fb57b499845a0930b0e37c62f80d02bcd2cb10f3" translate="yes" xml:space="preserve">
          <source>The filter compares the value of the event's log level (&lt;code&gt;Level&lt;/code&gt;) to &lt;code&gt;MatchLevel&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt;. The filter matches if the value of &lt;code&gt;Operator&lt;/code&gt; is:</source>
          <target state="translated">필터는 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels(Level, MatchLevel)&lt;/a&gt;&lt;/code&gt; 을 호출 하여 이벤트 로그 레벨 ( &lt;code&gt;Level&lt;/code&gt; ) 의 값 을 &lt;code&gt;MatchLevel&lt;/code&gt; 과 비교합니다 . &lt;code&gt;Operator&lt;/code&gt; 값 이 다음 과 같은 경우 필터가 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="beafc4357de407d81ed4a70bb524b690f9b684ec" translate="yes" xml:space="preserve">
          <source>The filter fun is called with the log event as the first parameter, and the specified &lt;code&gt;filter_args()&lt;/code&gt; as the second parameter.</source>
          <target state="translated">필터 이벤트는 로그 이벤트를 첫 번째 매개 변수로 지정하고 지정된 &lt;code&gt;filter_args()&lt;/code&gt; 를 두 번째 매개 변수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="109bfa797ec0aa4b76af245de1501f0741f1a95b" translate="yes" xml:space="preserve">
          <source>The filter function can return &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;ignore&lt;/code&gt; or the (possibly modified) log event.</source>
          <target state="translated">필터 함수는 &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;ignore&lt;/code&gt; 또는 (수정 가능) 로그 이벤트를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd11c27d7fbe5210f24b8d1e40d0d071f2e3ec4c" translate="yes" xml:space="preserve">
          <source>The filter has no knowledge of the log event. The next handler filter, if any, is applied. If no more filters exist for this handler, the value of the &lt;code&gt;filter_default&lt;/code&gt; configuration parameter for the handler specifies if the log event shall be discarded or forwarded to the handler callback.</source>
          <target state="translated">필터는 로그 이벤트를 알지 못합니다. 다음 핸들러 필터 (있는 경우)가 적용됩니다. 이 핸들러에 더 이상 필터가 없으면 핸들러에 대한 &lt;code&gt;filter_default&lt;/code&gt; 구성 매개 변수 의 값은 로그 이벤트를 버릴 것인지 핸들러 콜백으로 전달할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ddc0b8589e411612b38fdd950c86be1e96f3d934" translate="yes" xml:space="preserve">
          <source>The filter has no knowledge of the log event. The next primary filter, if any, is applied. If no more primary filters exist, the value of the primary &lt;code&gt;filter_default&lt;/code&gt; configuration parameter specifies if the log event shall be discarded or forwarded to the handler part.</source>
          <target state="translated">필터는 로그 이벤트를 알지 못합니다. 다음 기본 필터 (있는 경우)가 적용됩니다. 기본 필터가 더 이상 없으면 기본 &lt;code&gt;filter_default&lt;/code&gt; 구성 매개 변수 의 값은 로그 이벤트를 버릴 것인지 처리기 파트로 전달할 것인지를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="41d4a36552fad1262f02d4b7fdc2ca2fb3a329a9" translate="yes" xml:space="preserve">
          <source>The filter returns &lt;code&gt;ignore&lt;/code&gt; for all other log events.</source>
          <target state="translated">필터는 다른 모든 로그 이벤트에 대해 &lt;code&gt;ignore&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="dfb975166536b9370277fc5b05c55860c6bb1974" translate="yes" xml:space="preserve">
          <source>The final result is automatically compacted (compare &lt;code&gt;&lt;a href=&quot;#compact-1&quot;&gt;compact/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">최종 결과는 자동으로 압축됩니다 ( &lt;code&gt;&lt;a href=&quot;#compact-1&quot;&gt;compact/1&lt;/a&gt;&lt;/code&gt; 비교 ).</target>
        </trans-unit>
        <trans-unit id="1526dc18038f8fccad4ff828c37ad6dc7b944d4a" translate="yes" xml:space="preserve">
          <source>The final use of backslash is for certain simple assertions. An assertion specifies a condition that must be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The following are the backslashed assertions:</source>
          <target state="translated">백 슬래시의 최종 사용은 특정 간단한 어설 션입니다. 어설 션은 제목 문자열에서 문자를 소비하지 않고 일치하는 특정 지점에서 충족해야하는 조건을 지정합니다. 보다 복잡한 어설 션에 하위 패턴을 사용하는 방법은 다음과 같습니다. 다음은 백 슬래시 된 어설 션입니다.</target>
        </trans-unit>
        <trans-unit id="e6d536c130f15c0094632e977773d39a9eb1e1bc" translate="yes" xml:space="preserve">
          <source>The finish time can be specified as &lt;code&gt;HHMMSS&lt;/code&gt; and is then interpreted as a time today (or possibly tomorrow), but can also be specified as &lt;code&gt;YYMoMoDDHHMMSS&lt;/code&gt;, for example, &lt;code&gt;-until 071001120000&lt;/code&gt; or &lt;code&gt;{until,&quot;071001120000&quot;}&lt;/code&gt;. This means that the tests are executed and (if time allows) repeated, until 12 o'clock on the 1st of October 2007.</source>
          <target state="translated">완료 시간은 &lt;code&gt;HHMMSS&lt;/code&gt; 로 지정 될 수 있으며 오늘 (또는 내일) 시간으로 해석 될 수 있지만 &lt;code&gt;YYMoMoDDHHMMSS&lt;/code&gt; 로 지정 될 수도 있습니다 ( 예 : &lt;code&gt;-until 071001120000&lt;/code&gt; 또는 &lt;code&gt;{until,&quot;071001120000&quot;}&lt;/code&gt; ) . 이는 2007 년 10 월 1 일 12 시까 지 테스트가 실행되고 (시간이 허용되는 경우) 반복됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="452542fc2e01d92307cf4ab881b859d812957716" translate="yes" xml:space="preserve">
          <source>The finishing phase is carried out in the following sequence by the BIF &lt;code&gt;erlang:finish_loading&lt;/code&gt;:</source>
          <target state="translated">마무리 단계는 BIF &lt;code&gt;erlang:finish_loading&lt;/code&gt; 에 의해 다음 순서로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e0ddb058b574885245c8e1eb45a6f332a495743" translate="yes" xml:space="preserve">
          <source>The first 4-bits segment of &lt;code&gt;Dgram&lt;/code&gt; is not equal to 4.</source>
          <target state="translated">&lt;code&gt;Dgram&lt;/code&gt; 의 첫 4 비트 세그먼트는 4가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8565b4f54aaccfcff566979872a65ab909534a87" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;[&lt;/code&gt; bracket is read as &quot;build the list&quot;.</source>
          <target state="translated">첫 번째 &lt;code&gt;[&lt;/code&gt; 대괄호는 &quot;목록 작성&quot;으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="97b9da02f0f552217d5f6a05e46d62406ee40ed2" translate="yes" xml:space="preserve">
          <source>The first and longest match is preferred to a shorter, which is illustrated by the following example:</source>
          <target state="translated">첫 번째 및 가장 긴 일치 항목이 짧을수록 선호되며 다음 예에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6694406df610cd0f2b38fa2673a9cd35f9806c5a" translate="yes" xml:space="preserve">
          <source>The first argument is &lt;code&gt;{down,Vsn}&lt;/code&gt; if there is a downgrade, or &lt;code&gt;Vsn&lt;/code&gt; if there is a upgrade. The term &lt;code&gt;Vsn&lt;/code&gt; is fetched from the 'original' version of the module, that is, the version you are upgrading from, or downgrading to.</source>
          <target state="translated">다운 그레이드가있는 경우 첫 번째 인수는 &lt;code&gt;{down,Vsn}&lt;/code&gt; 이고, 업그레이드가있는 경우 &lt;code&gt;Vsn&lt;/code&gt; 입니다. &lt;code&gt;Vsn&lt;/code&gt; 이라는 용어 는 모듈의 '원본'버전, 즉 업그레이드하거나 다운 그레이드하는 버전에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ce41fd29eb3e83bdeb71be9c3fb406a35efdd54a" translate="yes" xml:space="preserve">
          <source>The first argument is &lt;strong&gt;not&lt;/strong&gt; a problem. It is variable, but it is a variable in all clauses. The problem is the variable in the second argument, &lt;code&gt;Xs&lt;/code&gt;, in the middle clause. Because the variable can match anything, the compiler is not allowed to rearrange the clauses, but must generate code that matches them in the order written.</source>
          <target state="translated">첫 번째 주장은 문제 가 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 변수이지만 모든 절의 변수입니다. 문제는 중간 절에서 두 번째 인수 인 &lt;code&gt;Xs&lt;/code&gt; 의 변수입니다 . 변수는 무엇이든 일치 할 수 있으므로 컴파일러는 절을 재 배열 할 수 없지만 작성된 순서대로 해당 절과 일치하는 코드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="32cd604e114cd5b8cc3d471ee8e9bda4b1cee80b" translate="yes" xml:space="preserve">
          <source>The first argument is the host name.</source>
          <target state="translated">첫 번째 인수는 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d1c68fc721622601f7d260f14b31c96cc4eaab50" translate="yes" xml:space="preserve">
          <source>The first argument is the integer used to construct the node name.</source>
          <target state="translated">첫 번째 인수는 노드 이름을 구성하는 데 사용되는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="f32a2498eb521e7ca9e58ea1c17356aedb30f6e1" translate="yes" xml:space="preserve">
          <source>The first argument is the internal state &lt;code&gt;State&lt;/code&gt;, passed from function &lt;code&gt;sys:handle_system_msg(Request, From, Parent, Module, Deb, State)&lt;/code&gt;, and called by the special process when a system message is received. In &lt;code&gt;ch4&lt;/code&gt;, the internal state is the set of available channels &lt;code&gt;Chs&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수는 내부 상태 &lt;code&gt;State&lt;/code&gt; 이며, 함수 &lt;code&gt;sys:handle_system_msg(Request, From, Parent, Module, Deb, State)&lt;/code&gt; 에서 전달되고 시스템 메시지가 수신 될 때 특수 프로세스에 의해 호출됩니다. 에서는 &lt;code&gt;ch4&lt;/code&gt; , 내부 상태는 이용 가능한 채널들의 세트이다 &lt;code&gt;Chs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60e83b7f6d533faf198f67e36c18a3048889f5d4" translate="yes" xml:space="preserve">
          <source>The first argument is the name of the &lt;code&gt;gen_statem&lt;/code&gt; and must agree with the name used to start it. So, we use the same macro &lt;code&gt;?NAME&lt;/code&gt; as when starting. &lt;code&gt;{button,Button}&lt;/code&gt; is the event content.</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;gen_statem&lt;/code&gt; 의 이름이며 시작하는 데 사용 된 이름과 일치해야합니다. 따라서 시작할 때 와 동일한 매크로 &lt;code&gt;?NAME&lt;/code&gt; 을 사용합니다 . &lt;code&gt;{button,Button}&lt;/code&gt; 은 이벤트 내용입니다.</target>
        </trans-unit>
        <trans-unit id="c12ca04f8508bcca65e776d0a609f335e9ddf7b5" translate="yes" xml:space="preserve">
          <source>The first argument is the name of the &lt;code&gt;gen_statem&lt;/code&gt; and must agree with the name used to start it. So, we use the same macro &lt;code&gt;?NAME&lt;/code&gt; as when starting. &lt;code&gt;{button,Digit}&lt;/code&gt; is the event content.</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;gen_statem&lt;/code&gt; 의 이름이며 이를 시작하는 데 사용 된 이름과 일치해야합니다. 따라서 시작할 때 와 같은 매크로 &lt;code&gt;?NAME&lt;/code&gt; 을 사용합니다 . &lt;code&gt;{button,Digit}&lt;/code&gt; 는 이벤트 내용입니다.</target>
        </trans-unit>
        <trans-unit id="aefd6aec912ef4431dbd33b887c26f8e830aec81" translate="yes" xml:space="preserve">
          <source>The first argument must be the name of the Erlang module as a C-identifier. It will be stringified by the macro.</source>
          <target state="translated">첫 번째 인수는 C 식별자 인 Erlang 모듈의 이름이어야합니다. 매크로로 문자열 화됩니다.</target>
        </trans-unit>
        <trans-unit id="6d796fe4c495cce6f5931a9ed26cf94f76f97e87" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;ttb:format/1,2&lt;/code&gt; specifies which binary log(s) to format. This is usually the name of a directory that &lt;code&gt;ttb&lt;/code&gt; created during log fetch. Unless option &lt;code&gt;disable_sort&lt;/code&gt; is provided, the logs from different files are always sorted according to time-stamp in traces.</source>
          <target state="translated">&lt;code&gt;ttb:format/1,2&lt;/code&gt; 의 첫 번째 인수는 포맷 할 바이너리 로그를 지정합니다. 이것은 일반적으로 &lt;code&gt;ttb&lt;/code&gt; 가 로그 페치 중에 작성한 디렉토리의 이름입니다 . &lt;code&gt;disable_sort&lt;/code&gt; 옵션을 제공 하지 않으면 다른 파일의 로그는 항상 타임 스탬프에 따라 추적으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="f1fc18bc1a4475d49a5401a7876f067a569b9a43" translate="yes" xml:space="preserve">
          <source>The first argument to these functions is the name of the test case. This value can be used with pattern matching in function clauses or conditional expressions to choose different initialization and cleanup routines for different test cases, or perform the same routine for many, or all, test cases.</source>
          <target state="translated">이 함수들에 대한 첫 번째 주장은 테스트 케이스의 이름입니다. 이 값은 함수 절 또는 조건식의 패턴 일치와 함께 사용하여 다른 테스트 케이스에 대해 다른 초기화 및 정리 루틴을 선택하거나 많은 또는 모든 테스트 케이스에 대해 동일한 루틴을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecdfdb297a347255c9331f18e2ac5e6afd881831" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;ch_sup&lt;/code&gt;, is the name of the callback module, that is, the module where the &lt;code&gt;init&lt;/code&gt; callback function is located.</source>
          <target state="translated">첫 번째 인수 인 &lt;code&gt;ch_sup&lt;/code&gt; 은 콜백 모듈의 이름, 즉 &lt;code&gt;init&lt;/code&gt; 콜백 함수가 있는 모듈 입니다.</target>
        </trans-unit>
        <trans-unit id="283cb26772a001cdc7fe1371d58b95c0c89083e7" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;{local, ch3}&lt;/code&gt;, specifies the name. The gen_server is then locally registered as &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;{local, ch3}&lt;/code&gt; 은 이름을 지정합니다. gen_server는 &lt;code&gt;ch3&lt;/code&gt; 으로 로컬에 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9747ca5abb30d92b09649a3fe92d54bbd6136b7" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;{local,?NAME}&lt;/code&gt;, specifies the name. In this case, the &lt;code&gt;gen_statem&lt;/code&gt; is locally registered as &lt;code&gt;code_lock&lt;/code&gt; through the macro &lt;code&gt;?NAME&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;{local,?NAME}&lt;/code&gt; 은 이름을 지정합니다. 이 경우, &lt;code&gt;gen_statem&lt;/code&gt; 는 로컬로 등록 &lt;code&gt;code_lock&lt;/code&gt; 매크로 통해 &lt;code&gt;?NAME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ca3d86d73fb6916b758fcb99bcfa439ed00207d" translate="yes" xml:space="preserve">
          <source>The first byte says that we have 5 atoms that are part of the cache. Then follows three bytes that are the atom cache ref flags. Each of the flags uses 4 bits so they are a bit hard to read in decimal byte form. In binary half-byte form they look like this:</source>
          <target state="translated">첫 번째 바이트는 캐시의 일부인 5 개의 원자가 있음을 나타냅니다. 그런 다음 원자 캐시 참조 플래그 인 3 바이트를 따릅니다. 각 플래그는 4 비트를 사용하므로 10 진수 바이트 형식으로 읽기가 약간 어렵습니다. 이진 하프 바이트 형식에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81bf6f9dd47061daa5ebed0dbe0e76693e63afed" translate="yes" xml:space="preserve">
          <source>The first call to &lt;code&gt;enif_select&lt;/code&gt; for a specific OS &lt;code&gt;event&lt;/code&gt; will establish a relation between the event object and the containing resource. All subsequent calls for an &lt;code&gt;event&lt;/code&gt; must pass its containing resource as argument &lt;code&gt;obj&lt;/code&gt;. The relation is dissolved when &lt;code&gt;enif_select&lt;/code&gt; has been called with &lt;code&gt;mode&lt;/code&gt; as &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; and the corresponding &lt;code&gt;stop&lt;/code&gt; callback has returned. A resource can contain several event objects but one event object can only be contained within one resource. A resource will not be destructed until all its contained relations have been dissolved.</source>
          <target state="translated">특정 OS &lt;code&gt;event&lt;/code&gt; 대한 &lt;code&gt;enif_select&lt;/code&gt; 에 대한 첫 번째 호출 은 이벤트 오브젝트와 포함 자원 사이의 관계를 설정합니다. &lt;code&gt;event&lt;/code&gt; 대한 모든 후속 호출 은 포함하는 자원을 인수 &lt;code&gt;obj&lt;/code&gt; 로 전달해야합니다 . &lt;code&gt;enif_select&lt;/code&gt; 가 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 과 같은 &lt;code&gt;mode&lt;/code&gt; 로 호출 되고 해당 &lt;code&gt;stop&lt;/code&gt; 콜백이 리턴 되면 관계가 해소됩니다 . 하나의 자원은 여러 이벤트 오브젝트를 포함 할 수 있지만 하나의 이벤트 오브젝트는 하나의 자원에만 포함될 수 있습니다. 포함 된 모든 관계가 해소 될 때까지 리소스가 소멸되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bd2696be64fe7162dc1485b1d2c990c6c549132" translate="yes" xml:space="preserve">
          <source>The first call to an interpreted function by this process. (&lt;code&gt;Module:Function/Arity&lt;/code&gt;)</source>
          <target state="translated">이 프로세스에 의해 해석 된 함수에 대한 첫 번째 호출. ( &lt;code&gt;Module:Function/Arity&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f928094b6da781dfbc891a4120343ae4cc293b55" translate="yes" xml:space="preserve">
          <source>The first case is when we have the identity-function (&lt;code&gt;SecName&lt;/code&gt; = &lt;code&gt;UserName&lt;/code&gt;).</source>
          <target state="translated">첫 번째 경우는 identity-function ( &lt;code&gt;SecName&lt;/code&gt; = &lt;code&gt;UserName&lt;/code&gt; )이있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="ca46c0129957e9588b59f378385edde7afb5bd78" translate="yes" xml:space="preserve">
          <source>The first component is if linger is enabled, the second component is the flushing time-out, in seconds. There are 3 alternatives:</source>
          <target state="translated">첫 번째 구성 요소는 지연이 활성화 된 경우이고 두 번째 구성 요소는 플러시 제한 시간 (초)입니다. 3 가지 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0fbbc3247a8beb8eb5ac78e663feb3fa54615a2" translate="yes" xml:space="preserve">
          <source>The first element in the list is isolated and the list is split into two sublists.</source>
          <target state="translated">목록의 첫 번째 요소가 분리되고 목록이 두 개의 하위 목록으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="014ba2d1758d0deccfe95265702308ef94fdf898" translate="yes" xml:space="preserve">
          <source>The first element of &lt;code&gt;Type_List&lt;/code&gt; is the top type of the encoded message. In &lt;code&gt;Element_List&lt;/code&gt;, it is followed by each of the component names that leads to selected type.</source>
          <target state="translated">&lt;code&gt;Type_List&lt;/code&gt; 의 첫 번째 요소 는 인코딩 된 메시지의 최상위 유형입니다. 에서는 &lt;code&gt;Element_List&lt;/code&gt; , 이것은 각 성분 이름 뒤에 그 선택된 유형으로 이끈다.</target>
        </trans-unit>
        <trans-unit id="dc44175b8c8ad2a17dc68dd4333970027d3739a1" translate="yes" xml:space="preserve">
          <source>The first element of a non-empty &lt;code&gt;Host-IP-Address&lt;/code&gt; list in &lt;code&gt;Svc&lt;/code&gt; provides the local IP address if an &lt;code&gt;ip&lt;/code&gt; option is not specified. The local address is either returned from&lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; or passed in a &lt;code&gt;connected&lt;/code&gt; message over the transport interface.</source>
          <target state="translated">&lt;code&gt;ip&lt;/code&gt; 옵션이 지정되지 않은 경우 &lt;code&gt;Svc&lt;/code&gt; 에서 비어 있지 않은 &lt;code&gt;Host-IP-Address&lt;/code&gt; 목록 의 첫 번째 요소 는 로컬 IP 주소를 제공 합니다. 로컬 주소는 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 에서 리턴 되거나 전송 인터페이스를 통해 &lt;code&gt;connected&lt;/code&gt; 메시지로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="750dbcc4ae2394bb0bb5244812808592768fc67a" translate="yes" xml:space="preserve">
          <source>The first element of the tuple that is sent is your own pid. This enables &lt;code&gt;my_server&lt;/code&gt; to reply. For more information about the primitives, see the &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">전송되는 튜플의 첫 번째 요소는 자신의 pid입니다. 이렇게하면 &lt;code&gt;my_server&lt;/code&gt; 가 응답 할 수 있습니다 . 프리미티브에 대한 자세한 정보는 &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fb0352349ee5a8c0a7eb65cc210b44843f0b004" translate="yes" xml:space="preserve">
          <source>The first element of the tuple that is sent is your own pid. This enables &lt;code&gt;my_server&lt;/code&gt; to reply. For more information about the primitives, see the &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">전송되는 튜플의 첫 번째 요소는 자신의 pid입니다. 그러면 &lt;code&gt;my_server&lt;/code&gt; 가 응답 할 수 있습니다 . 기본 요소에 대한 자세한 정보는 &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35c3d22f06a7d30ce2b647923cf3347f78831669" translate="yes" xml:space="preserve">
          <source>The first field of a record is the second element of the tuple, which is the representation of the record.</source>
          <target state="translated">레코드의 첫 번째 필드는 레코드의 두 번째 요소 인 튜플의 두 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2595903ccef1ec77d7c52522a5524a8e9b27b8b6" translate="yes" xml:space="preserve">
          <source>The first filter that the trace data is exposed for is the &lt;code&gt;Collector Filter&lt;/code&gt;. When a trace &lt;code&gt;Event&lt;/code&gt; is reported with &lt;code&gt;et_collector:report/2&lt;/code&gt; (or &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt;) the first thing that happens, is that a message is sent to the &lt;code&gt;Collector&lt;/code&gt; process to fetch a handle that contains some useful stuff, such as the &lt;code&gt;Collector Filter Fun&lt;/code&gt; and an Ets table identifier. Then the &lt;code&gt;Collector Filter Fun&lt;/code&gt; is applied and if it returns &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;{true, NewEvent}&lt;/code&gt;), the &lt;code&gt;Event&lt;/code&gt; will be stored in an Ets table. As an optimization, subsequent calls to &lt;code&gt;et_collector:report&lt;/code&gt;-functions can use the handle directly instead of the &lt;code&gt;Collector Pid&lt;/code&gt;.</source>
          <target state="translated">추적 데이터가 노출되는 첫 번째 필터는 &lt;code&gt;Collector Filter&lt;/code&gt; 입니다. 추적 &lt;code&gt;Event&lt;/code&gt; 가 &lt;code&gt;et_collector:report/2&lt;/code&gt; (또는 &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; ) 로보 고 될 때 가장 먼저 발생하는 것은 메시지가 &lt;code&gt;Collector&lt;/code&gt; 프로세스로 전송되어 다음 과 같은 유용한 항목이 포함 된 핸들을 가져 오는 것입니다. &lt;code&gt;Collector Filter Fun&lt;/code&gt; 와 ETS 테이블 식별자. 그런 다음 &lt;code&gt;Collector Filter Fun&lt;/code&gt; 이 적용되고 &lt;code&gt;true&lt;/code&gt; (또는 &lt;code&gt;{true, NewEvent}&lt;/code&gt; )를 반환 하면 &lt;code&gt;Event&lt;/code&gt; 가 Ets 테이블에 저장됩니다. 최적화로서 &lt;code&gt;et_collector:report&lt;/code&gt; 에 대한 후속 호출기능은 &lt;code&gt;Collector Pid&lt;/code&gt; 대신 핸들을 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e93729010b78d1e9fdfb6095e599e11dc46611ef" translate="yes" xml:space="preserve">
          <source>The first has the effect of clearing any previous inherits, the second of replacing a previous inherits of &lt;code&gt;Prev&lt;/code&gt; to one of &lt;code&gt;Mod&lt;/code&gt;. This allows the semantics of the input dictionary to be changed without modifying the file itself.</source>
          <target state="translated">첫 번째는 이전 상속을 지우는 효과가 있고, 두 번째는 이전 상속을 &lt;code&gt;Prev&lt;/code&gt; 의 대체 를 &lt;code&gt;Mod&lt;/code&gt; 중 하나로 바꿉니다 . 이를 통해 파일 자체를 수정하지 않고 입력 사전의 의미를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb71912301094043ae2a458700ad5b6cfbe752e" translate="yes" xml:space="preserve">
          <source>The first implementation of DTrace probes for the Erlang virtual machine was presented at the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/euc/08/&quot;&gt;2008 Erlang User Conference&lt;/a&gt;&lt;/code&gt;. That work, based on the Erlang/OTP R12 release, was discontinued due to what appears to be miscommunication with the original developers.</source>
          <target state="translated">Erlang 가상 머신에 대한 첫 번째 DTrace 프로브 구현은 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/euc/08/&quot;&gt;2008 Erlang User Conference&lt;/a&gt;&lt;/code&gt; 에서 발표되었습니다 . Erlang / OTP R12 릴리스를 기반으로하는이 작업은 원래 개발자와의 잘못된 통신으로 인해 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ede817e0e310c707f5e3a52490c6b67ab4efaa9" translate="yes" xml:space="preserve">
          <source>The first improvement is to fix the guarantee so that insert operations will be guaranteed to terminate. When the operation starts we verify that there actually exist a free slot that we can use. The problem is that we might not find it since it may move when multiple threads modify the table at the same time as we are trying to find the slot. The easy fix is to abort the operation if an empty slot could not be found in a finite number operation, and then restart the operation under a write lock. This will be implemented in next release, but furter work should be made trying to find a better solution.</source>
          <target state="translated">첫 번째 개선 사항은 삽입 작업이 종료되도록 보장을 수정하는 것입니다. 작업이 시작되면 사용할 수있는 빈 슬롯이 실제로 있는지 확인합니다. 문제는 슬롯을 찾으려고 할 때 여러 스레드가 동시에 테이블을 수정할 때 이동할 수 있기 때문에 찾을 수 없다는 것입니다. 간단한 해결 방법은 유한 번호 작업에서 빈 슬롯을 찾을 수없는 경우 작업을 중단 한 다음 쓰기 잠금 상태에서 작업을 다시 시작하는 것입니다. 이는 다음 릴리스에서 구현 될 예정이지만 더 나은 솔루션을 찾기 위해 더 많은 작업을해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f97c49dffef8a26851ac783d21a876b74a6d528" translate="yes" xml:space="preserve">
          <source>The first instruction, &lt;code&gt;{selected_decode_Window1,['Window',status,buttonList,[1],number]}&lt;/code&gt; is described in the previous section.</source>
          <target state="translated">첫 번째 명령어 인 &lt;code&gt;{selected_decode_Window1,['Window',status,buttonList,[1],number]}&lt;/code&gt; 는 이전 섹션에서 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="e790f114bc8cf3a2ce28aebcfae1d5a3836f6a2d" translate="yes" xml:space="preserve">
          <source>The first is the current value.</source>
          <target state="translated">첫 번째는 현재 값입니다.</target>
        </trans-unit>
        <trans-unit id="314cc6cc859765f9b7338047d208d202513bf56d" translate="yes" xml:space="preserve">
          <source>The first level is at the UDP entry / exit point, i.e. immediately after the receipt of the message, before any message processing is done (accept_recv) and immediately before sending the message, after all message processing is done (accept_send).</source>
          <target state="translated">첫 번째 레벨은 모든 메시지 처리가 완료된 후 (accept_send) 메시지 처리가 완료되기 전 (accept_recv) 및 메시지를 보내기 직전의 UDP 시작 / 종료 지점에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16552c0f99d14efe5fd0c93c7ebdd486a4076a9" translate="yes" xml:space="preserve">
          <source>The first level is at the transport entry / exit point, i.e. immediately after the receipt of the message before any message processing is done (accept_recv) and immediately before sending the message after all message processing is done (accept_send).</source>
          <target state="translated">첫 번째 레벨은 전송 시작 ​​/ 종료 지점에 있습니다. 즉, 메시지 처리가 완료되기 전 (accept_recv) 및 모든 메시지 처리가 완료된 후 (accept_send) 메시지를 보내기 직전의 메시지 수신 직후.</target>
        </trans-unit>
        <trans-unit id="88dc6a7560da2f499e8520d95b8aad4ac645715c" translate="yes" xml:space="preserve">
          <source>The first part -</source>
          <target state="translated">첫 번째 부분-</target>
        </trans-unit>
        <trans-unit id="bbb474799d3c2ceaecdb69173050f2d2cde6ff68" translate="yes" xml:space="preserve">
          <source>The first part matches an optional opening parenthesis, and if that character is present, sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did, that is, if subject started with an opening parenthesis, the condition is true, and so the yes-pattern is executed and a closing parenthesis is required. Otherwise, as no-pattern is not present, the subpattern matches nothing. That is, this pattern matches a sequence of non-parentheses, optionally enclosed in parentheses.</source>
          <target state="translated">첫 번째 부분은 선택적인 여는 괄호와 일치하며 해당 문자가 있으면이를 첫 번째 캡처 된 하위 문자열로 설정합니다. 두 번째 부분은 괄호가 아닌 하나 이상의 문자와 일치합니다. 세 번째 부분은 첫 번째 괄호 세트가 일치하는지 테스트하는 조건부 하위 패턴입니다. 만일 그들이 주제를 시작 괄호로 시작하면, 조건은 참이므로 yes-pattern이 실행되고 종결 괄호가 필요합니다. 그렇지 않으면, 비 패턴이 존재하지 않기 때문에 서브 패턴은 아무것도 일치하지 않습니다. 즉,이 패턴은 선택적으로 괄호로 묶인 일련의 비 괄호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f02f68659112d26dce19edf7fe8cbae93aa2769c" translate="yes" xml:space="preserve">
          <source>The first part of the 64 bit template is identical to the 32 bit one, but there are some environment variable differences:</source>
          <target state="translated">64 비트 템플릿의 첫 번째 부분은 32 비트와 동일하지만 환경 변수 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f65a1941d5d1778fd847b32c5e58a7ed60e551a2" translate="yes" xml:space="preserve">
          <source>The first part of the crash dump shows the following:</source>
          <target state="translated">크래시 덤프의 첫 번째 부분은 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2cc97c1e58d4679396d3bf61c813a63a062816e6" translate="yes" xml:space="preserve">
          <source>The first part of the pattern is a DEFINE group inside which is a another group named &quot;byte&quot; is defined. This matches an individual component of an IPv4 address (a number &amp;lt; 256). When matching takes place, this part of the pattern is skipped, as DEFINE acts like a false condition. The remaining pattern uses references to the named group to match the four dot-separated components of an IPv4 address, insisting on a word boundary at each end.</source>
          <target state="translated">패턴의 첫 번째 부분은 내부에 &quot;byte&quot;라는 다른 그룹 인 DEFINE 그룹입니다. 이는 IPv4 주소의 개별 구성 요소 (숫자 &amp;lt;256)와 일치합니다. 일치가 발생하면 DEFINE이 잘못된 조건처럼 작동하므로 패턴의이 부분을 건너 뜁니다. 나머지 패턴은 명명 된 그룹에 대한 참조를 사용하여 각 끝에서 단어 경계를 지정하여 IPv4 주소의 4 개의 점으로 구분 된 구성 요소를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="7724368c62d5b897d69875d863fc670d000c0a9f" translate="yes" xml:space="preserve">
          <source>The first part of the reference number in ref &lt;code&gt;t&lt;/code&gt;. Use only for compatibility.</source>
          <target state="translated">참조 번호의 첫 번째 부분은 ref &lt;code&gt;t&lt;/code&gt; 입니다. 호환성을 위해서만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="232ebbaa469296f40c7a1846dbf2fa546b56c045" translate="yes" xml:space="preserve">
          <source>The first part says that the factorial of 1 is 1.:</source>
          <target state="translated">첫 번째 부분은 1의 계승이 1이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="dac65be594adc3151ec035f4511e37fe28d74a93" translate="yes" xml:space="preserve">
          <source>The first program contains some inadequacies regarding handling of nodes which disappear. These are corrected in a later version of the program.</source>
          <target state="translated">첫 번째 프로그램에는 사라지는 노드 처리와 관련하여 일부 부족한 점이 있습니다. 이 프로그램은 이후 버전의 프로그램에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="90106de27192d6ca833e750e4d48c96656c2317b" translate="yes" xml:space="preserve">
          <source>The first record attribute is the primary key, or key for short.</source>
          <target state="translated">첫 번째 레코드 속성은 기본 키 또는 짧은 키입니다.</target>
        </trans-unit>
        <trans-unit id="ed1cb5e2f4466b9952a0dc278fff4d1ccfd35509" translate="yes" xml:space="preserve">
          <source>The first state that is entered will get a &lt;strong&gt;state enter call&lt;/strong&gt; with &lt;code&gt;OldState&lt;/code&gt; equal to the current state.</source>
          <target state="translated">입력 된 첫 번째 상태는 &lt;code&gt;OldState&lt;/code&gt; 가 현재 상태 와 동일한 &lt;strong&gt;상태 입력 호출&lt;/strong&gt; 을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="3a82a7bb7498f5fc4876294f7dfadf942e9bd19c" translate="yes" xml:space="preserve">
          <source>The first state that is entered will get a state enter call with &lt;code&gt;OldState&lt;/code&gt; equal to the current state.</source>
          <target state="translated">입력 된 첫 번째 상태는 &lt;code&gt;OldState&lt;/code&gt; 가 현재 상태 와 같은 상태 입력 호출을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="6086c2b9bf8be61602b6ebcc9d1ba07de24d3cb9" translate="yes" xml:space="preserve">
          <source>The first sublist contains all elements that are smaller than the first element in the list.</source>
          <target state="translated">첫 번째 하위 목록에는 목록의 첫 번째 요소보다 작은 모든 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7c16a3275bdd107763aa82124e29bdb96e0aa246" translate="yes" xml:space="preserve">
          <source>The first subsection will give a short background of the SSH protocol while later sections describes the implementation and provides some examples</source>
          <target state="translated">첫 번째 하위 섹션에서는 SSH 프로토콜에 대한 간단한 배경 지식을 제공하고 이후 섹션에서는 구현에 대해 설명하고 몇 가지 예를 제공합니다</target>
        </trans-unit>
        <trans-unit id="ea7284e31b879942988ef1c4ac5a9d9ef85d8089" translate="yes" xml:space="preserve">
          <source>The first test to run includes all suites for system &lt;code&gt;t1&lt;/code&gt;. Suites &lt;code&gt;t1B&lt;/code&gt; and &lt;code&gt;t1D&lt;/code&gt; are excluded from the test. Test cases &lt;code&gt;test3&lt;/code&gt; and &lt;code&gt;test4&lt;/code&gt; in &lt;code&gt;t1A&lt;/code&gt; and &lt;code&gt;test1&lt;/code&gt; case in &lt;code&gt;t1C&lt;/code&gt; are also excluded from the test.</source>
          <target state="translated">실행할 첫 번째 테스트에는 시스템 &lt;code&gt;t1&lt;/code&gt; 에 대한 모든 제품군이 포함됩니다 . 스위트 &lt;code&gt;t1B&lt;/code&gt; 및 &lt;code&gt;t1D&lt;/code&gt; 는 테스트에서 제외됩니다. 테스트 케이스의 &lt;code&gt;test3&lt;/code&gt; 및 &lt;code&gt;test4&lt;/code&gt; 에서 &lt;code&gt;t1A&lt;/code&gt; 와 &lt;code&gt;test1&lt;/code&gt; 의 경우 &lt;code&gt;t1C&lt;/code&gt; 또한 테스트에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca5c4abe4913702f7baf25de35a02c261b509bb" translate="yes" xml:space="preserve">
          <source>The first thing &lt;code&gt;blend/2&lt;/code&gt; does is to calculate the resulting alpha channel:</source>
          <target state="translated">&lt;code&gt;blend/2&lt;/code&gt; 가하는 첫 번째 일은 결과 알파 채널을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="39ceda5701132f42099520c75ed5fefa2f0ce8cf" translate="yes" xml:space="preserve">
          <source>The first thing you need to do, is to make sure you have an ODBC driver installed for the database that you want to access. Both the client machine where you plan to run your erlang node and the server machine running the database needs the the ODBC driver. (In some cases the client and the server may be the same machine).</source>
          <target state="translated">가장 먼저해야 할 일은 액세스하려는 데이터베이스에 ODBC 드라이버가 설치되어 있는지 확인하는 것입니다. erlang 노드를 실행하려는 클라이언트 시스템과 데이터베이스를 실행하는 서버 시스템에는 모두 ODBC 드라이버가 필요합니다. (경우에 따라 클라이언트와 서버가 동일한 시스템 일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="2aae989cc7522942aff9cad7059abdf3f11420db" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;Fun&lt;/code&gt; is applied, &lt;code&gt;Acc0&lt;/code&gt; is the second argument. The next time &lt;code&gt;Fun&lt;/code&gt; is called, the return value from the previous call is used as the second argument. The term the last call to &lt;code&gt;Fun&lt;/code&gt; returns is the return value of the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl-3&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr-3&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Fun&lt;/code&gt; 이 처음 적용되면 &lt;code&gt;Acc0&lt;/code&gt; 이 두 번째 인수입니다. 다음에 &lt;code&gt;Fun&lt;/code&gt; 을 호출하면 이전 호출의 반환 값이 두 번째 인수로 사용됩니다. &lt;code&gt;Fun&lt;/code&gt; 이 마지막으로 호출 한 용어는 &lt;code&gt;&lt;a href=&quot;mnesia#foldl-3&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mnesia#foldr-3&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; 함수의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="50b73034e77a90f94080fa89965c6eaf0283e9d6" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;bchunk/2&lt;/code&gt; is called, an initial continuation, the atom &lt;code&gt;start&lt;/code&gt;, must be provided.</source>
          <target state="translated">처음 &lt;code&gt;bchunk/2&lt;/code&gt; 는 초기 연속, 원자, 호출 &lt;code&gt;start&lt;/code&gt; 제공되어야한다.</target>
        </trans-unit>
        <trans-unit id="0c2f550699da636c0cd8e01902373a891091a02a" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;chunk()&lt;/code&gt; (or &lt;code&gt;bchunk()&lt;/code&gt;) is called, an initial continuation, the atom &lt;code&gt;start&lt;/code&gt;, must be provided. If a disk log process is running on the current node, terms are read from that log. Otherwise, an individual distributed log on some other node is chosen, if such a log exists.</source>
          <target state="translated">처음 &lt;code&gt;chunk()&lt;/code&gt; (또는 &lt;code&gt;bchunk()&lt;/code&gt; )라고하며, 초기 지속, 원자 &lt;code&gt;start&lt;/code&gt; 제공되어야한다. 디스크 로그 프로세스가 현재 노드에서 실행중인 경우 해당 로그에서 용어를 읽습니다. 그렇지 않으면, 그러한 로그가 존재하는 경우 다른 노드의 개별 분산 로그가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae42b9440fbcdcd3aef0e04e0d47cfcd6b93638" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;chunk()&lt;/code&gt; is called, an initial continuation returned from &lt;code&gt;open/1&lt;/code&gt; or &lt;code&gt;open/2&lt;/code&gt; must be provided.</source>
          <target state="translated">&lt;code&gt;chunk()&lt;/code&gt; 가 처음 호출 될 때 &lt;code&gt;open/1&lt;/code&gt; 또는 &lt;code&gt;open/2&lt;/code&gt; 에서 리턴 된 초기 연속 이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f24cb290ca20c81eb6b4416fabb904d4e10dd7ea" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;my_binary_to_list/1&lt;/code&gt; is called, a &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; is created. The match context points to the first byte of the binary. 1 byte is matched out and the match context is updated to point to the second byte in the binary.</source>
          <target state="translated">&lt;code&gt;my_binary_to_list/1&lt;/code&gt; 을 처음 호출하면 &lt;code&gt;&lt;a href=&quot;#match_context&quot;&gt;match context&lt;/a&gt;&lt;/code&gt; 가 작성됩니다. 일치 컨텍스트는 이진의 첫 번째 바이트를 가리 킵니다. 1 바이트가 일치하고 이진에서 두 번째 바이트를 가리 키도록 일치 컨텍스트가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1823ded8e66bfbd9fc7ce09687bb9aaa31338fbb" translate="yes" xml:space="preserve">
          <source>The first time &lt;code&gt;save_scenario/0&lt;/code&gt; is called a server will be started. This server will save runtime scenarios. All saved scenarios can be removed by calling &lt;code&gt;&lt;a href=&quot;#make_config-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save_scenario/0&lt;/code&gt; 을 처음 호출하면 서버가 시작됩니다. 이 서버는 런타임 시나리오를 저장합니다. &lt;code&gt;&lt;a href=&quot;#make_config-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; 을 호출하여 저장된 모든 시나리오를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2da631291d48912dfb7f5e3e966ba2a0afa5f92f" translate="yes" xml:space="preserve">
          <source>The first time this function is called, &lt;code&gt;error_logger&lt;/code&gt; is added as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is started.</source>
          <target state="translated">이 함수를 처음 호출하면 &lt;code&gt;error_logger&lt;/code&gt; 가 로거 핸들러로 추가되고 &lt;code&gt;error_logger&lt;/code&gt; 프로세스가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0ac2627c749c91f8bf457c1c48d430daa18c89a6" translate="yes" xml:space="preserve">
          <source>The first user &quot;sends&quot; the message in the example above by:</source>
          <target state="translated">첫 번째 사용자는 위의 예에서 다음과 같이 메시지를 &quot;보냅니다&quot;.</target>
        </trans-unit>
        <trans-unit id="03cb12d8f1c72fe9141e80abe570426dd8888741" translate="yes" xml:space="preserve">
          <source>The first value indicates the default &lt;code&gt;priv_dir&lt;/code&gt; behavior, that is, one private directory created per test run. The two latter values tell &lt;code&gt;Common Test&lt;/code&gt; to generate a unique test directory name per test case and execution. If the auto version is used, &lt;strong&gt;all&lt;/strong&gt; private directories are created automatically. This can become very inefficient for test runs with many test cases or repetitions, or both. Therefore, if the manual version is used instead, the test case must tell &lt;code&gt;Common Test&lt;/code&gt; to create &lt;code&gt;priv_dir&lt;/code&gt; when it needs it. It does this by calling the function &lt;code&gt;&lt;a href=&quot;ct#make_priv_dir-0&quot;&gt;ct:make_priv_dir/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 값은 기본 &lt;code&gt;priv_dir&lt;/code&gt; 동작, 즉 테스트 실행마다 작성된 하나의 개인 디렉토리를 나타냅니다 . 후자의 두 값은 &lt;code&gt;Common Test&lt;/code&gt; 에게 테스트 케이스 및 실행마다 고유 한 테스트 디렉토리 이름을 생성하도록 지시합니다. 자동 버전이 사용되면 &lt;strong&gt;모든&lt;/strong&gt; 개인 디렉토리가 자동으로 작성됩니다. 많은 테스트 사례 또는 반복 또는 둘 다를 사용하여 테스트를 실행하는 경우 매우 비효율적 일 수 있습니다. 따라서 수동 버전을 대신 사용하는 경우 테스트 케이스는 &lt;code&gt;Common Test&lt;/code&gt; 에게 &lt;code&gt;priv_dir&lt;/code&gt; 때 priv_dir 을 작성 하도록 지시 해야합니다. &lt;code&gt;&lt;a href=&quot;ct#make_priv_dir-0&quot;&gt;ct:make_priv_dir/0&lt;/a&gt;&lt;/code&gt; 함수를 호출하여이를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="5b7f2b74f4ad7fcb69baccbea779f423b38f85de" translate="yes" xml:space="preserve">
          <source>The first value is limited to the values 0, 1, or 2. The second value must be in the range 0..39 when the first value is 0 or 1.</source>
          <target state="translated">첫 번째 값은 0, 1 또는 2 값으로 제한됩니다. 첫 번째 값이 0 또는 1 인 경우 두 번째 값은 0..39 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="76cac286407464f1a3cab30ae6ed03a1a8b426a4" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-extra&lt;/code&gt; is treated in special way. Its scope ends at the end of the file. Arguments following an &lt;code&gt;-extra&lt;/code&gt; flag are moved on the command line into the &lt;code&gt;-extra&lt;/code&gt; section, that is, the end of the command line following after an &lt;code&gt;-extra&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;-extra&lt;/code&gt; 플래그 는 특별한 방식으로 처리됩니다. 범위는 파일 끝에서 끝납니다. &lt;code&gt;-extra&lt;/code&gt; 플래그 다음의 인수 는 명령 행에서 &lt;code&gt;-extra&lt;/code&gt; 섹션으로, 즉 &lt;code&gt;-extra&lt;/code&gt; 플래그 다음에 오는 명령 행의 끝으로 이동 됩니다.</target>
        </trans-unit>
        <trans-unit id="095fd71fa9f6ba7fe4c40943793a2bb698c7bbdc" translate="yes" xml:space="preserve">
          <source>The flag can also be set by the STDLIB application variable &lt;code&gt;shell_strings&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;, which means that lists of integers are printed using the string syntax, when possible. Value &lt;code&gt;false&lt;/code&gt; means that no lists are printed using the string syntax.</source>
          <target state="translated">플래그는 STDLIB 응용 프로그램 변수 &lt;code&gt;shell_strings&lt;/code&gt; 에 의해 설정 될 수도 있습니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 이며, 가능하면 문자열 구문을 사용하여 정수 목록이 인쇄됩니다. &lt;code&gt;false&lt;/code&gt; 값 은 문자열 구문을 사용하여 목록이 인쇄되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="16ee325443e908603dacad16b814927c10a42e37" translate="yes" xml:space="preserve">
          <source>The flag field of an atom cache reference has the following format:</source>
          <target state="translated">아톰 캐시 참조의 플래그 필드는 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a080305c71ef71f1663e7718a0bc9d58d29dd1e8" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;suite&lt;/code&gt;, and &lt;code&gt;group/case&lt;/code&gt; can be combined. For example, to run &lt;code&gt;x_SUITE&lt;/code&gt; and &lt;code&gt;y_SUITE&lt;/code&gt; in directory &lt;code&gt;testdir&lt;/code&gt;, as follows:</source>
          <target state="translated">&lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;suite&lt;/code&gt; 및 &lt;code&gt;group/case&lt;/code&gt; 플래그를 결합 할 수 있습니다. 예를 들어, &lt;code&gt;testdir&lt;/code&gt; 디렉토리에서 &lt;code&gt;x_SUITE&lt;/code&gt; 및 &lt;code&gt;y_SUITE&lt;/code&gt; 를 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b93b96139f6762ecd80290edd696f2ed98f35890" translate="yes" xml:space="preserve">
          <source>The flags specific to the MIB compiler can be specified by using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">MIB 컴파일러 고유의 플래그는 &lt;code&gt;+&lt;/code&gt; 구문 을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="428847ac69b6b0b0a5e6c4145d8ec6d570f6c395" translate="yes" xml:space="preserve">
          <source>The flex libraries. Without it, the flex powered codecs cannot be used.</source>
          <target state="translated">플렉스 라이브러리. 그렇지 않으면 플렉스 전원 코덱을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c159710396ee724ac90ec79947b2b5b4c1587632" translate="yes" xml:space="preserve">
          <source>The flex scanner is written using a tool called &lt;strong&gt;flex&lt;/strong&gt;. In order to be able to compile the flex scanner driver, this tool has to be available.</source>
          <target state="translated">플렉스 스캐너라는 도구 사용하여 작성 &lt;strong&gt;플렉스&lt;/strong&gt; . Flex 스캐너 드라이버를 컴파일하려면이 도구를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7c4ca511a9bd4686762da41fca66fa99a0af1b0" translate="yes" xml:space="preserve">
          <source>The floating point generating functions in this module waste the lowest bits when converting from an integer so they avoid this snag.</source>
          <target state="translated">이 모듈의 부동 소수점 생성 기능은 정수에서 변환 할 때 가장 낮은 비트를 낭비하므로 이러한 걸림을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c041ae86c5f8c7016b0e10add46c29cac233bc88" translate="yes" xml:space="preserve">
          <source>The floating point value of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">의 부동 소수점 값 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e419b2fab0b36bcecd87f0c3d0efca53ec378a69" translate="yes" xml:space="preserve">
          <source>The focus of the Erlang reference manual is on the language itself, not the implementation of it. The language constructs are described in text and with examples rather than formally specified. This is to make the manual more readable. The Erlang reference manual is not intended as a tutorial.</source>
          <target state="translated">Erlang 참조 매뉴얼의 초점은 언어 자체가 아니라 구현에 있습니다. 언어 구성은 공식적으로 지정되지 않고 텍스트와 예제로 설명됩니다. 이것은 매뉴얼을 더 읽기 쉽게하기위한 것입니다. Erlang 참조 매뉴얼은 튜토리얼을위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="14233773185c2d086e35c41f6b44cd3cb166311c" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;#hs_data{}&lt;/code&gt; record fields need to be set unless otherwise stated:</source>
          <target state="translated">달리 명시되지 않는 한 다음 &lt;code&gt;#hs_data{}&lt;/code&gt; 레코드 필드를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="755882894d7fd28bede6b99ec073119565eb9367" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;MSAcc_Thread_State&lt;/code&gt;s are available. All states are exclusive, meaning that a thread cannot be in two states at once. So, if you add the numbers of all counters in a thread, you get the total runtime for that thread.</source>
          <target state="translated">다음과 같은 &lt;code&gt;MSAcc_Thread_State&lt;/code&gt; 를 사용할 수 있습니다. 모든 상태는 배타적이므로 스레드는 한 번에 두 가지 상태에있을 수 없습니다. 따라서 스레드의 모든 카운터 수를 추가하면 해당 스레드의 총 런타임이 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="9f76f02eae75217eb2a5f3c4fb6a601b97548d9f" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ct_hooks&lt;/code&gt; statement causes pretty printing of NETCONF traffic to separate logs for the connections named &lt;code&gt;nc_server1&lt;/code&gt; and &lt;code&gt;nc_server2&lt;/code&gt;. Any other connections are logged to default NETCONF log.</source>
          <target state="translated">다음 &lt;code&gt;ct_hooks&lt;/code&gt; 문은 &lt;code&gt;nc_server1&lt;/code&gt; 및 &lt;code&gt;nc_server2&lt;/code&gt; 연결에 대한 로그를 분리하기 위해 NETCONF 트래픽을 꽤 인쇄 합니다. 다른 모든 연결은 기본 NETCONF 로그에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="60898a22579d212b66c103e94e65e3704c005128" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ct_hooks&lt;/code&gt; statement causes printing of Telnet traffic to separate logs for the connections &lt;code&gt;server1&lt;/code&gt; and &lt;code&gt;server2&lt;/code&gt;. Traffic for any other connections is logged in the default Telnet log.</source>
          <target state="translated">다음 &lt;code&gt;ct_hooks&lt;/code&gt; 문은 Telnet 트래픽을 인쇄하여 연결 &lt;code&gt;server1&lt;/code&gt; 및 &lt;code&gt;server2&lt;/code&gt; 에 대한 로그를 분리 합니다. 다른 연결에 대한 트래픽은 기본 Telnet 로그에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="1bc4e72d8d4d5620576eec368f8680635ae64598" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;upgrade&lt;/code&gt; instruction is used for supervisors:</source>
          <target state="translated">다음 &lt;code&gt;upgrade&lt;/code&gt; 지침이 감독자에게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7721dfe03e9c154ea4e1c34f92eac19aef611c75" translate="yes" xml:space="preserve">
          <source>The following ASN.1 type is used for real numbers:</source>
          <target state="translated">다음 ASN.1 유형은 실수에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da76d97e2e28f2e89ed233e203305a30d4111d61" translate="yes" xml:space="preserve">
          <source>The following BIFs, which are used to create processes, return values of this data type:</source>
          <target state="translated">프로세스를 작성하는 데 사용되는 다음 BIF는이 데이터 유형의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ca462812b4b616c1a4a1c09a1f4a79f0f85f0e72" translate="yes" xml:space="preserve">
          <source>The following CTH logs information about a test run into a format parseable by &lt;code&gt;file:consult/1&lt;/code&gt; (in Kernel):</source>
          <target state="translated">다음 CTH는 테스트 실행에 대한 정보를 &lt;code&gt;file:consult/1&lt;/code&gt; (커널)로 구문 분석 할 수있는 형식으로 기록 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e71ecc8d7cab4d72922ae4ed2e33319f8122346" translate="yes" xml:space="preserve">
          <source>The following I/O request is optional to implement and a client is to be prepared for an error return:</source>
          <target state="translated">다음 I / O 요청은 선택적으로 구현할 수 있으며 클라이언트는 오류 리턴을 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="0827ebd08d8a02057148a27dc548b0eb839f8cf1" translate="yes" xml:space="preserve">
          <source>The following Item's are valid:</source>
          <target state="translated">다음 품목이 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="8931f5659efe1bfa45e91bfba89a696d04a3885e" translate="yes" xml:space="preserve">
          <source>The following Kernel configuration parameters apply to Logger:</source>
          <target state="translated">다음 커널 구성 매개 변수가 로거에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f963b53749dee80b3ebd6d93009cb72dd723e7e" translate="yes" xml:space="preserve">
          <source>The following Logger API functions can trigger this callback:</source>
          <target state="translated">다음과 같은 로거 API 함수가이 콜백을 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d2e24198262f39e955cdd7b2bb38352780ad95" translate="yes" xml:space="preserve">
          <source>The following MIBs are built-ins of the Erlang SNMP compiler: SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF, and RFC1155-SMI. They cannot therefore be compiled separately.</source>
          <target state="translated">Erlang SNMP 컴파일러에 내장 된 MIB는 SNMPv2-SMI, RFC-1215, RFC-1212, SNMPv2-TC, SNMPv2-CONF 및 RFC1155-SMI입니다. 따라서 따로 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="52d19d789c25255eed9a979999ac8863363f1228" translate="yes" xml:space="preserve">
          <source>The following MIBs are defined in the OTP system:</source>
          <target state="translated">다음 MIB가 OTP 시스템에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f58c9a6d16d6a288dad320d6e8998be16e44721f" translate="yes" xml:space="preserve">
          <source>The following PEM file has only one entry, a private DSA key:</source>
          <target state="translated">다음 PEM 파일에는 개인 DSA 키 항목이 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a1e06caf4405f8154436d98b0b535f1d1da5766" translate="yes" xml:space="preserve">
          <source>The following PEM file has only one entry, a private RSA key:</source>
          <target state="translated">다음 PEM 파일에는 개인 RSA 키 항목이 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6e0ebe475e308588ade6bad38f0a1b0d7fad83" translate="yes" xml:space="preserve">
          <source>The following activity access contexts are currently supported:</source>
          <target state="translated">다음 활동 액세스 컨텍스트가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9f7f3d9893eedee1a260cc5b49377b2f1f743ccc" translate="yes" xml:space="preserve">
          <source>The following algorithms are provided:</source>
          <target state="translated">다음과 같은 알고리즘이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="390e0b5eb1e3b7230aad019d3e06855c658180f0" translate="yes" xml:space="preserve">
          <source>The following allocators are present:</source>
          <target state="translated">다음과 같은 할당자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="36398232558556592a65d630a38e59c406ca80e9" translate="yes" xml:space="preserve">
          <source>The following applies to daemons (servers).</source>
          <target state="translated">다음은 데몬 (서버)에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="76ee8987dc9d6df07cd6d0206a431e8aa313a2bb" translate="yes" xml:space="preserve">
          <source>The following apply:</source>
          <target state="translated">다음이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4821bb8c6c116cef14beeab931818f4969279b8" translate="yes" xml:space="preserve">
          <source>The following are primitives, which do not contain other test sets as arguments:</source>
          <target state="translated">다음은 다른 테스트 세트를 인수로 포함하지 않는 기본 요소입니다.</target>
        </trans-unit>
        <trans-unit id="b988567cb4ebfa83309f7036c88dc38f105b9489" translate="yes" xml:space="preserve">
          <source>The following are reserved words in Erlang:</source>
          <target state="translated">다음은 Erlang의 예약어입니다.</target>
        </trans-unit>
        <trans-unit id="23a58c2300ac41928639f29dbe01e89240b2ddfc" translate="yes" xml:space="preserve">
          <source>The following are some of the most important and attractive capabilities provided by Mnesia:</source>
          <target state="translated">다음은 Mnesia가 제공하는 가장 중요하고 매력적인 기능 중 일부입니다.</target>
        </trans-unit>
        <trans-unit id="446aea39bd6d645ca35077d4770c830fb9a617e9" translate="yes" xml:space="preserve">
          <source>The following are the fun clauses parameter lists:</source>
          <target state="translated">다음은 fun clauses 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b9a2d4753855996ec68919109001bdcfdfab1176" translate="yes" xml:space="preserve">
          <source>The following are the horizontal space characters:</source>
          <target state="translated">가로 공백 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e7dca09b462b81dbf316dd39e6aa81ce86d2e59" translate="yes" xml:space="preserve">
          <source>The following are the main features of Trace Tool Builder:</source>
          <target state="translated">다음은 Trace Tool Builder의 주요 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4e925277c492d9e6356d76bfacfb3ab772525403" translate="yes" xml:space="preserve">
          <source>The following are the most widely spread encodings:</source>
          <target state="translated">다음은 가장 널리 사용되는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="1d30a8b8e3b663292a1ad0bd4a17fb0b5f2c8ae2" translate="yes" xml:space="preserve">
          <source>The following are the possible runtime errors:</source>
          <target state="translated">가능한 런타임 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11e4ce827beb7d257dafdeafaf65224573e225ee" translate="yes" xml:space="preserve">
          <source>The following are the predefined sets of subpatterns:</source>
          <target state="translated">다음은 사전 정의 된 하위 패턴 세트입니다.</target>
        </trans-unit>
        <trans-unit id="b8aeeeb29a22d61e4651a7f7c64491c002da04f2" translate="yes" xml:space="preserve">
          <source>The following are the supported class names:</source>
          <target state="translated">지원되는 클래스 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ae73677bdb343efa75ef5239df98c3995eb5a45" translate="yes" xml:space="preserve">
          <source>The following are the vertical space characters:</source>
          <target state="translated">다음은 세로 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="e13eea1a0552634ec49861dfedef83923f03fb36" translate="yes" xml:space="preserve">
          <source>The following argument is required:</source>
          <target state="translated">다음과 같은 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b3fe3a25174fa0e4b7397791cbe163414c93cae5" translate="yes" xml:space="preserve">
          <source>The following behavior applies if &lt;code&gt;Reason&lt;/code&gt; is any term, except &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;kill&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 이 &lt;code&gt;normal&lt;/code&gt; 또는 &lt;code&gt;kill&lt;/code&gt; 을 제외한 임의의 용어 인 경우 다음 동작이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed43b5794a433578fe75d6227c8f8fec9b973992" translate="yes" xml:space="preserve">
          <source>The following built-in handlers exist:</source>
          <target state="translated">다음과 같은 내장 핸들러가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e48df9c121f20b43e9189951e6b161ed4e78306b" translate="yes" xml:space="preserve">
          <source>The following built-in list types also exist, but they are expected to be rarely used. Hence, they have long names:</source>
          <target state="translated">다음과 같은 내장 목록 유형도 있지만 거의 사용되지 않을 것으로 예상됩니다. 따라서 그들은 긴 이름을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="56efeb40efc4a8607cb2cf3d6a1bbfa58461fecd" translate="yes" xml:space="preserve">
          <source>The following call would create a table that is replicated on two nodes, has an extra index on attribute &lt;code&gt;y&lt;/code&gt;, and is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">다음 호출은 두 노드에 복제되고 속성 &lt;code&gt;y&lt;/code&gt; 에 대한 추가 색인이 있고 &lt;code&gt;bag&lt;/code&gt; 유형 인 테이블을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="b93cef34769b4ac84bcc58e1f7579a27e1900915" translate="yes" xml:space="preserve">
          <source>The following calls use the default client profile. Use the proxy &lt;code&gt;&quot;www-proxy.mycompany.com:8000&quot;&lt;/code&gt;, except from requests to localhost. This applies to all the following requests.</source>
          <target state="translated">다음 호출은 기본 클라이언트 프로파일을 사용합니다. localhost에 대한 요청을 제외하고 &lt;code&gt;&quot;www-proxy.mycompany.com:8000&quot;&lt;/code&gt; 프록시를 사용하십시오 . 이것은 다음의 모든 요청에 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce6762a2b45b2a9419ebd342a2248363882b1ec" translate="yes" xml:space="preserve">
          <source>The following can be done from the shell:</source>
          <target state="translated">쉘에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f1ccb49a8a37c5657c1e09929d43e77df7e6d3" translate="yes" xml:space="preserve">
          <source>The following can help you estimate the buffer requirements for a term. Notice that this information is implementation-specific, and can change in future versions. If you are unsure, use &lt;code&gt;erl_term_len()&lt;/code&gt;.</source>
          <target state="translated">다음은 용어의 버퍼 요구 사항을 추정하는 데 도움이 될 수 있습니다. 이 정보는 구현에 따라 다르며 향후 버전에서 변경 될 수 있습니다. 확실하지 않으면 &lt;code&gt;erl_term_len()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f875dcb652b105150192f44a7e364beec117361" translate="yes" xml:space="preserve">
          <source>The following capability flags are defined:</source>
          <target state="translated">다음과 같은 기능 플래그가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b153457b0c6c74e16cf68b399d11c4fdbeda5276" translate="yes" xml:space="preserve">
          <source>The following capability identifiers, defined in RFC 4741 NETCONF Configuration Protocol, can be returned:</source>
          <target state="translated">RFC 4741 NETCONF 구성 프로토콜에 정의 된 다음 기능 ID가 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="729ccfc9617ba57afc9d1a89abcf609beb87615d" translate="yes" xml:space="preserve">
          <source>The following causes an error at compile time:</source>
          <target state="translated">다음은 컴파일시 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="46da2b6d47972d1cbb42e35ed601e935a7066068" translate="yes" xml:space="preserve">
          <source>The following changes are added:</source>
          <target state="translated">다음 변경 사항이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="223954bbc5bf81b4921c410a25f0bd6051babb47" translate="yes" xml:space="preserve">
          <source>The following code adds a parser interface to the grammar:</source>
          <target state="translated">다음 코드는 문법에 파서 인터페이스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="132d723fbc5d22b21ca88cffc9fa6e6381b81134" translate="yes" xml:space="preserve">
          <source>The following code defines a function &lt;code&gt;pconst(X)&lt;/code&gt; in the module &lt;code&gt;funparse&lt;/code&gt;, which returns a fun that parses a list of tokens:</source>
          <target state="translated">다음 코드는 함수 정의 &lt;code&gt;pconst(X)&lt;/code&gt; 모듈에서 &lt;code&gt;funparse&lt;/code&gt; 토큰의 목록을 구문 분석 재미를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="56844778b2176882fb2364c894e6a3f1cbf9d20a" translate="yes" xml:space="preserve">
          <source>The following code exemplifies a search with a non-normalized data model. To find all employees at department &lt;code&gt;Dep&lt;/code&gt; with a salary higher than &lt;code&gt;Salary&lt;/code&gt;, use the following code:</source>
          <target state="translated">다음 코드는 정규화되지 않은 데이터 모델을 사용한 검색을 보여줍니다. 부서의 모든 직원 찾으려면 &lt;code&gt;Dep&lt;/code&gt; 보다 높은 급여와 &lt;code&gt;Salary&lt;/code&gt; , 다음 코드를 사용 :</target>
        </trans-unit>
        <trans-unit id="3cf0020bc55d0fa1c895bb9fac0126cb39735295" translate="yes" xml:space="preserve">
          <source>The following code fragment is a simple example of a client connecting to a server at port 5678, transferring a binary, and closing the connection:</source>
          <target state="translated">다음 코드 조각은 클라이언트가 포트 5678에서 서버에 연결하고 바이너리를 전송 한 후 연결을 닫는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="aa22415381d6bc1bea3d2a6fcf7c7cf3cea03a9e" translate="yes" xml:space="preserve">
          <source>The following code illustrates how a &lt;code&gt;Mnesia&lt;/code&gt; table is converted to be a fragmented table and how more fragments are added later:</source>
          <target state="translated">다음 코드는 &lt;code&gt;Mnesia&lt;/code&gt; 테이블이 조각화 된 테이블로 변환되는 방법과 나중에 더 많은 조각이 추가되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4edc8cb91e65e300012f8cc9f371bfd50b18952b" translate="yes" xml:space="preserve">
          <source>The following code is executed to achieve this:</source>
          <target state="translated">이를 달성하기 위해 다음 코드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bf087b2d7139054e72c10f87277f4e9105ae6aae" translate="yes" xml:space="preserve">
          <source>The following code is from the sample file &lt;code&gt;next_perm.cc&lt;/code&gt;. The driver entry looks like before, but also contains the callback &lt;code&gt;ready_async&lt;/code&gt;.</source>
          <target state="translated">다음 코드는 샘플 파일 &lt;code&gt;next_perm.cc&lt;/code&gt; 의 코드입니다 . 드라이버 항목은 이전과 같지만 콜백 &lt;code&gt;ready_async&lt;/code&gt; 도 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="fd629e06b526d07e792ece40b307e86e30aa4c96" translate="yes" xml:space="preserve">
          <source>The following code is slightly slower because the shape of the list of arguments is unknown at compile time.</source>
          <target state="translated">다음 코드는 인수 목록의 모양을 컴파일 타임에 알 수 없으므로 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="1c15d7bb6d9f5ccee5265bb8903dc3f1c45a0ae2" translate="yes" xml:space="preserve">
          <source>The following code is the Erlang part of the synchronous postgres driver, &lt;code&gt;pg_sync.erl&lt;/code&gt;:</source>
          <target state="translated">다음 코드는 동기 postgres 드라이버 &lt;code&gt;pg_sync.erl&lt;/code&gt; 의 Erlang 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="dca40145d4c0653ae61a32b900aff83a1d19f042" translate="yes" xml:space="preserve">
          <source>The following code reduces the search space and is more efficient:</source>
          <target state="translated">다음 코드는 검색 공간을 줄이고 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">다음 코드 :</target>
        </trans-unit>
        <trans-unit id="10e52292e9dee4a0e3fd6642d8202ab55d1217aa" translate="yes" xml:space="preserve">
          <source>The following command are directly available for indentation.</source>
          <target state="translated">들여 쓰기에는 다음 명령을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54ee1055259696f0cf635190505ae13de7c7874" translate="yes" xml:space="preserve">
          <source>The following commands and functions are used to initiate the &lt;code&gt;Company&lt;/code&gt; database:</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스 를 시작하는 데 다음 명령 및 기능이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="a32fdf2e9df498e6565b300a038b14cb68a1735d" translate="yes" xml:space="preserve">
          <source>The following compilers are supported:</source>
          <target state="translated">다음과 같은 컴파일러가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8cfc763d98ab927b97e114c3d3db99c10685fbd5" translate="yes" xml:space="preserve">
          <source>The following configuration file causes raw logging of all NETCONF traffic in to one single text file:</source>
          <target state="translated">다음 구성 파일은 모든 NETCONF 트래픽을 하나의 단일 텍스트 파일로 원시 로깅합니다.</target>
        </trans-unit>
        <trans-unit id="f14322549f377ad730735aaebaa29c12d04adf7a" translate="yes" xml:space="preserve">
          <source>The following configuration parameters can be used to change the default values for time interval and threshold:</source>
          <target state="translated">다음 구성 매개 변수를 사용하여 시간 간격 및 임계 값의 기본값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="193ce5872a1a6b1151ebfa805bdd3ed1418c9a2b" translate="yes" xml:space="preserve">
          <source>The following configuration parameters can be used to change the default values for time intervals and thresholds:</source>
          <target state="translated">다음 구성 매개 변수를 사용하여 시간 간격 및 임계 값의 기본값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8d3f81dcc2fefa92fa2bf61c616cec96c1c09f3" translate="yes" xml:space="preserve">
          <source>The following custom metadata keys have special meaning:</source>
          <target state="translated">다음 사용자 정의 메타 데이터 키에는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9245e4a9bd60ce63efee4dfb325d04bbf467167e" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions below:</source>
          <target state="translated">아래 기능에서 사용되는 데이터 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48be2dc36e35956a8e3588aca9cfc84f77c588b6" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for &lt;code&gt;public_key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;public_key&lt;/code&gt; 의 함수에는 다음 데이터 유형이 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbde7c9ddb7eaf9bcf77f4db441bfdef5bb61047" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for &lt;code&gt;ssl_session_cache_api&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ssl_session_cache_api&lt;/code&gt; 의 함수에는 다음 데이터 유형이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ae4ee24ac66de733888ad1963744fbfbce6e5f4" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for SSL/TLS/DTLS:</source>
          <target state="translated">SSL / TLS / DTLS의 기능에는 다음 데이터 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f214626dc0835db98c5ea380264f0633bf284ba" translate="yes" xml:space="preserve">
          <source>The following data types are used in the functions for mod_esi:</source>
          <target state="translated">다음 데이터 유형이 mod_esi의 함수에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="79cd8536de4f9b5bd968aa07ab5a04ff86d91140" translate="yes" xml:space="preserve">
          <source>The following data types concern the DNS client:</source>
          <target state="translated">다음 데이터 유형은 DNS 클라이언트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d37752ba97444275d3af617925c81e1b46edf9" translate="yes" xml:space="preserve">
          <source>The following data types concern the resolver:</source>
          <target state="translated">다음 데이터 유형은 리졸버와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ceb88a84344840ee75edbb731e8eaf81fb9c735" translate="yes" xml:space="preserve">
          <source>The following data-types are used in the functions below:</source>
          <target state="translated">아래 함수에서 사용되는 데이터 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1484bd1263f6980852c4824bd6d929836444bb83" translate="yes" xml:space="preserve">
          <source>The following definitions are used in the SNMP User's Guide.</source>
          <target state="translated">다음 정의는 SNMP 사용 설명서에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="39b4ce09657d83e126a92760457f3f4da1a2f574" translate="yes" xml:space="preserve">
          <source>The following dialog within the Erlang shell illustrates the functionality of the Erlang ODBC interface. The table used in the example does not have any relevance to anything that exist in reality, it is just a simple example. The example was created using &lt;code&gt;sqlserver 7.0 with servicepack 1&lt;/code&gt; as database and the ODBC driver for &lt;code&gt;sqlserver&lt;/code&gt; with version &lt;code&gt;2000.80.194.00&lt;/code&gt;.</source>
          <target state="translated">Erlang 셸 내의 다음 대화 상자는 Erlang ODBC 인터페이스의 기능을 보여줍니다. 예제에 사용 된 테이블은 실제로 존재하는 것과 관련이 없으며 단순한 예제 일뿐입니다. 이 예제는 &lt;code&gt;sqlserver 7.0 with servicepack 1&lt;/code&gt; 을 데이터베이스로 sqlserver 7.0 과 버전 &lt;code&gt;2000.80.194.00&lt;/code&gt; 을 가진 &lt;code&gt;sqlserver&lt;/code&gt; 용 ODBC 드라이버를 사용하여 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="99bffcf83f746fcc6153881b4b1631f84352b58c" translate="yes" xml:space="preserve">
          <source>The following directory must exist in the system to run the manager:</source>
          <target state="translated">관리자를 실행하려면 시스템에 다음 디렉토리가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4067663f255bf23f8ace734d9a80cb7e8eb13f2" translate="yes" xml:space="preserve">
          <source>The following distinct values are recognised:</source>
          <target state="translated">다음과 같은 고유 한 값이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="5bbdb173d3c169abec87c3f3bd04716fdb1d1176" translate="yes" xml:space="preserve">
          <source>The following elements are always present in the list for both local and external funs:</source>
          <target state="translated">로컬 및 외부 재미를 위해 다음 요소가 항상 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="314e2c48845f15727630c647a2291eeb21cc401b" translate="yes" xml:space="preserve">
          <source>The following elements are only present in the list if &lt;code&gt;Fun&lt;/code&gt; is local:</source>
          <target state="translated">다음 요소는 &lt;code&gt;Fun&lt;/code&gt; 이 로컬 인 경우에만 목록에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="f117ec12e436f6ca90db1a4bc190e20fe521a5b3" translate="yes" xml:space="preserve">
          <source>The following encoding modules are provided:</source>
          <target state="translated">다음과 같은 인코딩 모듈이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="77da27c3c246440f97582892c2d759bcdbc2e044" translate="yes" xml:space="preserve">
          <source>The following environment variables are recognized by &lt;code&gt;run_erl&lt;/code&gt; and change the logging behavior. For more information, see the previous section.</source>
          <target state="translated">다음 환경 변수는 &lt;code&gt;run_erl&lt;/code&gt; 에 의해 인식되고 로깅 동작을 변경합니다. 자세한 내용은 이전 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="555e6e3612dc9741d46001a128eafcf81c3f1408" translate="yes" xml:space="preserve">
          <source>The following equalities hold for all sequences:</source>
          <target state="translated">모든 시퀀스에 대해 다음과 같은 평등이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="514df84a2b14f584709cf8e0a980decde643a888" translate="yes" xml:space="preserve">
          <source>The following example checks if a specific Erlang process is alive:</source>
          <target state="translated">다음 예제는 특정 Erlang 프로세스가 활성 상태인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="31645542bb6c8a8301b513644f9cd8b30b64cec9" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the basic functionality used to run the Erlang ASN.1 compiler.</source>
          <target state="translated">다음 예는 Erlang ASN.1 컴파일러를 실행하는 데 사용되는 기본 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="80f9ad21016f571b21439d39ef29483bf86436fd" translate="yes" xml:space="preserve">
          <source>The following example generates all permutations of the elements in a list:</source>
          <target state="translated">다음 예제는 목록에서 요소의 모든 순열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c404080201f0735af63fd0d67d38459effaabe41" translate="yes" xml:space="preserve">
          <source>The following example illustrate how code can be divided into a generic and a specific part. Consider the following code (written in plain Erlang) for a simple server, which keeps track of a number of &quot;channels&quot;. Other processes can allocate and free the channels by calling the functions &lt;code&gt;alloc/0&lt;/code&gt; and &lt;code&gt;free/1&lt;/code&gt;, respectively.</source>
          <target state="translated">다음 예제는 코드를 일반 부분과 특정 부분으로 나누는 방법을 보여줍니다. 간단한 서버의 경우 다음과 같은 코드 (일반 Erlang으로 작성)를 고려하여 여러 &quot;채널&quot;을 추적합니다. 다른 프로세스는 각각 &lt;code&gt;alloc/0&lt;/code&gt; 및 &lt;code&gt;free/1&lt;/code&gt; 함수를 호출하여 채널을 할당하고 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49ac7049a1dcc2d7a9ce14f9a85fbfcae1153db4" translate="yes" xml:space="preserve">
          <source>The following example illustrates a simple, functional parser that parses the grammar:</source>
          <target state="translated">다음 예제는 문법을 구문 분석하는 간단한 기능적 구문 분석기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8140848b7fdb3cf3311bc85e2c217120f0d742dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates a situation in which we have an SNMP table that we wish to implement as a Mnesia table. The table stores information about employees at a company. Each employee is indexed with the department number and the name.</source>
          <target state="translated">다음 예는 Mnesia 테이블로 구현하려는 SNMP 테이블이있는 상황을 보여줍니다. 이 테이블에는 회사 직원에 대한 정보가 저장됩니다. 각 직원은 부서 번호와 이름으로 색인됩니다.</target>
        </trans-unit>
        <trans-unit id="e0bf2809ff12bfda2aa29b8a9ba782d668e893f5" translate="yes" xml:space="preserve">
          <source>The following example illustrates how this function and &lt;code&gt;proc_lib:start_link/3&lt;/code&gt; are used:</source>
          <target state="translated">다음 예제는이 함수와 &lt;code&gt;proc_lib:start_link/3&lt;/code&gt; 가 사용되는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="474a94a5e901e0dd50063b0b025da701b6e45408" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between type &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;bag&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 유형 &lt;code&gt;set&lt;/code&gt; 와 &lt;code&gt;bag&lt;/code&gt; 의 차이점을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="39a99dfd22c81e72385e303daaf447a32f1dcfba" translate="yes" xml:space="preserve">
          <source>The following example illustrates this idea:</source>
          <target state="translated">다음 예제는이 아이디어를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0064c1a1c0bd35406debf90dd3f22d06ce617d65" translate="yes" xml:space="preserve">
          <source>The following example illustrates use of option &lt;code&gt;{active,once}&lt;/code&gt; and multiple accepts by implementing a server as a number of worker processes doing accept on a single listening socket. Function &lt;code&gt;start/2&lt;/code&gt; takes the number of worker processes and the port number on which to listen for incoming connections. If &lt;code&gt;LPort&lt;/code&gt; is specified as &lt;code&gt;0&lt;/code&gt;, an ephemeral port number is used, which is why the start function returns the actual port number allocated:</source>
          <target state="translated">다음 예제 는 단일 청취 소켓에서 승인을 수행하는 여러 작업자 프로세스로 서버를 구현하여 옵션 &lt;code&gt;{active,once}&lt;/code&gt; 및 다중 승인의 사용을 보여줍니다 . &lt;code&gt;start/2&lt;/code&gt; 기능 은 작업자 프로세스 수와 들어오는 연결을 수신 대기하는 포트 번호를 사용합니다. 경우 &lt;code&gt;LPort&lt;/code&gt; 가 로 지정된 &lt;code&gt;0&lt;/code&gt; , 임시 포트 번호는 시작 기능이 할당 된 실제 포트 번호를 반환하는 이유입니다, 사용된다 :</target>
        </trans-unit>
        <trans-unit id="86c0c5045f0b4867ff5d5e4af410f343d35c255f" translate="yes" xml:space="preserve">
          <source>The following example is a long dialog with the shell. Commands starting with &lt;code&gt;&amp;gt;&lt;/code&gt; are inputs to the shell. All other lines are output from the shell.</source>
          <target state="translated">다음 예제는 쉘이있는 긴 대화 상자입니다. &lt;code&gt;&amp;gt;&lt;/code&gt; 로 시작하는 명령 은 쉘에 대한 입력입니다. 다른 모든 줄은 셸에서 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="10240151e7e7d2b5c92ad81d3640bc34e05d9082" translate="yes" xml:space="preserve">
          <source>The following example is more complex:</source>
          <target state="translated">다음 예제는 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="2d992e491915820ad2afb49cfea9c8e41cff67a2" translate="yes" xml:space="preserve">
          <source>The following example is useful when new object code is to be loaded on all nodes in the network, and indicates some side effects that RPCs can produce:</source>
          <target state="translated">다음 예제는 새 객체 코드가 네트워크의 모든 노드에로드 될 때 유용하며 RPC가 생성 할 수있는 부작용을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1bc5ca4ed5e654ab061544449ba776cebd53a7ec" translate="yes" xml:space="preserve">
          <source>The following example selects UTF-8 as default encoding:</source>
          <target state="translated">다음 예제는 UTF-8을 기본 인코딩으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="51e5b893c5c0823be8635b7d769cf2d225ca2947" translate="yes" xml:space="preserve">
          <source>The following example shows a &quot;manual&quot; implementation of the EX1-MIB in Erlang. In this example, the values of the objects are stored in an Erlang server. The server has a 2-tuple as loop data, where the first element is the value of variable &lt;code&gt;myName&lt;/code&gt;, and the second is a sorted list of rows in the table &lt;code&gt;friendsTable&lt;/code&gt;. Each row is a 4-tuple.</source>
          <target state="translated">다음 예는 Erlang에서 EX1-MIB의 &quot;수동&quot;구현을 보여줍니다. 이 예에서 객체 값은 Erlang 서버에 저장됩니다. 서버에는 루프 데이터로 2 개의 튜플이 있으며, 첫 번째 요소는 변수 &lt;code&gt;myName&lt;/code&gt; 의 값이고 두 번째 요소는 테이블 &lt;code&gt;friendsTable&lt;/code&gt; 의 정렬 된 행 목록입니다 . 각 행은 4 개의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="0dda83918f4c357871181a8e692213f82ec6620d" translate="yes" xml:space="preserve">
          <source>The following example shows a &lt;code&gt;manager.conf&lt;/code&gt; file:</source>
          <target state="translated">다음 예제는 &lt;code&gt;manager.conf&lt;/code&gt; 파일을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3692690cff3bbc46fbe7542193823a072dbd398f" translate="yes" xml:space="preserve">
          <source>The following example shows a C program communicating with an Erlang program over a plain port with home made encoding:</source>
          <target state="translated">다음 예제는 집에서 만든 인코딩으로 일반 포트를 통해 Erlang 프로그램과 통신하는 C 프로그램을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f6be2fbeb6192c8a5cb94de6b9da0c5dd128e807" translate="yes" xml:space="preserve">
          <source>The following example shows a C program communicating with an Erlang program over a plain port with the Erlang external term format encoding:</source>
          <target state="translated">다음 예제는 Erlang 외부 용어 형식 인코딩을 사용하여 일반 포트를 통해 Erlang 프로그램과 통신하는 C 프로그램을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4d9615b54f64438d5e8028f7a0519b6178976cdb" translate="yes" xml:space="preserve">
          <source>The following example shows a process performing a certain action, and if this action is not completed within a certain limit, the process is killed:</source>
          <target state="translated">다음 예제는 특정 조치를 수행하는 프로세스를 보여 주며이 조치가 특정 한계 내에서 완료되지 않으면 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1096089eeb70a3303a9760156d2d4be7631f7e69" translate="yes" xml:space="preserve">
          <source>The following example shows a simple pushbutton model for a toggling pushbutton implemented with &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;state_functions&lt;/code&gt;. You can push the button and it replies if it went on or off, and you can ask for a count of how many times it has been pushed to switch on.</source>
          <target state="translated">다음 예는 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;state_functions&lt;/code&gt; 로 구현 된 토글 푸시 버튼에 대한 간단한 푸시 버튼 모델을 보여줍니다 . 버튼을 누르면 버튼이 켜지거나 꺼 졌을 때 응답하며, 버튼을 눌렀을 때 횟수를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd42ec45016c93db472143966e5ca24703f9ed4" translate="yes" xml:space="preserve">
          <source>The following example shows a simple tool for &quot;debug tracing&quot;, that is, tracing of function calls with return values:</source>
          <target state="translated">다음 예제는 &quot;디버그 추적&quot;을위한 간단한 도구, 즉 반환 값을 가진 함수 호출 추적을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="19d3f1e8b5799f072b4359cce670be47936dfd69" translate="yes" xml:space="preserve">
          <source>The following example shows a slightly different solution:</source>
          <target state="translated">다음 예제는 약간 다른 솔루션을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5d4636c02ccef3bb3a01dfd35e9b59f4a603be21" translate="yes" xml:space="preserve">
          <source>The following example shows a test suite that uses configuration functions to open and close a log file for the test cases (an operation that is unnecessary and irrelevant to perform by each test case):</source>
          <target state="translated">다음 예제는 구성 기능을 사용하여 테스트 케이스에 대한 로그 파일을 열고 닫는 테스트 스위트를 보여줍니다 (각 테스트 케이스에서 수행하지 않아도되는 조작).</target>
        </trans-unit>
        <trans-unit id="e3b94c02f704d04153b1383ced31f3788f464a7b" translate="yes" xml:space="preserve">
          <source>The following example shows a transaction that raises the salary of certain employee numbers:</source>
          <target state="translated">다음 예는 특정 직원 수의 급여를 올리는 거래를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f6d9b06dc36617a94b5e02afafc0ad8dfc4a0dad" translate="yes" xml:space="preserve">
          <source>The following example shows a valid &lt;code&gt;standard.conf&lt;/code&gt; file:</source>
          <target state="translated">다음 예제는 유효한 &lt;code&gt;standard.conf&lt;/code&gt; 파일을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="bace4401d809de6e0147dcd93d7d2ad50c7143ee" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;agent.conf&lt;/code&gt; file:</source>
          <target state="translated">다음 예제는 &lt;code&gt;agent.conf&lt;/code&gt; 파일을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="847239863685661d182c63f6a400e539c34b547a" translate="yes" xml:space="preserve">
          <source>The following example shows an Erlang program communicating with a C program over a plain port with home made encoding:</source>
          <target state="translated">다음 예는 홈 인코딩으로 일반 포트를 통해 C 프로그램과 통신하는 Erlang 프로그램을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="53825087d6b7108771ca3d6e0c8ef6217b528b80" translate="yes" xml:space="preserve">
          <source>The following example shows an implementation of a table which is stored in Mnesia, but with some checks performed at set-request operations.</source>
          <target state="translated">다음 예는 Mnesia에 저장되어 있지만 요청이 설정 요청 작업에서 수행되는 테이블의 구현을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="595ffdab36e0d6fd3473bedf69696fe4094f27bb" translate="yes" xml:space="preserve">
          <source>The following example shows how &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup&lt;/a&gt;&lt;/code&gt; can be used to rename a &lt;code&gt;db_node&lt;/code&gt; in a backup file:</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;mnesia#traverse_backup-4&quot;&gt;mnesia:traverse_backup&lt;/a&gt;&lt;/code&gt; 을 사용하여 백업 파일에서 &lt;code&gt;db_node&lt;/code&gt; 의 이름을 바꾸는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9fa86a2eb1c462e43e94db58a5942b848857fdbd" translate="yes" xml:space="preserve">
          <source>The following example shows how a shared subterm can be created:</source>
          <target state="translated">다음 예는 공유 하위 용어를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6776554b0d8b27d6e71dbb65c3430e626c70d4bf" translate="yes" xml:space="preserve">
          <source>The following example shows how it works. Assume the following specification is in file &lt;code&gt;PrimStrings.asn1&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 작동 방식을 보여줍니다. 다음 스펙이 &lt;code&gt;PrimStrings.asn1&lt;/code&gt; 파일에 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="065c20024091e430c70da54bb041e138781615cf" translate="yes" xml:space="preserve">
          <source>The following example shows how lock contention for ETS tables can be minimized by having one ETS table for each scheduler. The table identifiers for the ETS tables are stored as a single persistent term:</source>
          <target state="translated">다음 예는 각 스케줄러에 대해 하나의 ETS 테이블을 사용하여 ETS 테이블에 대한 잠금 경합을 최소화 할 수있는 방법을 보여줍니다. ETS 테이블의 테이블 식별자는 단일 영구 용어로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d86195a9ba7fbeb4a3a2a88335f091528178a8bf" translate="yes" xml:space="preserve">
          <source>The following example shows how the &lt;code&gt;Erl_Interface&lt;/code&gt; library supports remote procedure calls:</source>
          <target state="translated">다음 예제는 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리가 원격 프로 시저 호출을 지원 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d2278792ed447b1b0474672cdb32370ece1d60bb" translate="yes" xml:space="preserve">
          <source>The following example shows how these tasks are performed:</source>
          <target state="translated">다음 예제는 이러한 작업이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0eb710a17335cffa4195147f0b090692db507fb0" translate="yes" xml:space="preserve">
          <source>The following example shows how to access a record field:</source>
          <target state="translated">다음 예제는 레코드 필드에 액세스하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5dc0d07b42694dec0693419e5a61930ecf09e7b5" translate="yes" xml:space="preserve">
          <source>The following example shows how to calculate alpha blending using maps to reference color and alpha channels. Enter the code in a file named &lt;code&gt;color.erl&lt;/code&gt;):</source>
          <target state="translated">다음 예제는 맵을 사용하여 색상 및 알파 채널을 참조하는 알파 블렌딩을 계산하는 방법을 보여줍니다. &lt;code&gt;color.erl&lt;/code&gt; 파일에 코드를 입력하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c239b66af7053b04b58eb08cb9f4bfdfc1ec12a9" translate="yes" xml:space="preserve">
          <source>The following example shows how to change all letters in &lt;code&gt;L&lt;/code&gt; to upper case and then count them.</source>
          <target state="translated">다음 예는 &lt;code&gt;L&lt;/code&gt; 의 모든 문자를 대문자로 변경 한 다음 세는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a2b77ebb5034759887438d2b947908450b7a2b16" translate="yes" xml:space="preserve">
          <source>The following example shows how to find the length of a list. Enter the following code in a file named &lt;code&gt;tut4.erl&lt;/code&gt;):</source>
          <target state="translated">다음 예제는 목록의 길이를 찾는 방법을 보여줍니다. &lt;code&gt;tut4.erl&lt;/code&gt; 파일에 다음 코드를 입력하십시오 .)</target>
        </trans-unit>
        <trans-unit id="cabff7d830edf1695f519312aec99e8c8a4f83ba" translate="yes" xml:space="preserve">
          <source>The following example shows how to override properties in a scenario with deeply nested groups:</source>
          <target state="translated">다음 예제는 깊이 중첩 된 그룹이있는 시나리오에서 특성을 대체하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5c2ed5f4e4ba13285a99659d63cce80153eafd62" translate="yes" xml:space="preserve">
          <source>The following example shows how to print &quot;Hello World!&quot; in 5 seconds:</source>
          <target state="translated">다음 예는 &quot;Hello World!&quot;를 인쇄하는 방법을 보여줍니다. 5 초 안에 :</target>
        </trans-unit>
        <trans-unit id="42718ac464a329f1e12022f8904c812c6a41cbb0" translate="yes" xml:space="preserve">
          <source>The following example shows how to reconstruct Erlang source code from the debug information in a BEAM file &lt;code&gt;Beam&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 BEAM 파일 &lt;code&gt;Beam&lt;/code&gt; 의 디버그 정보에서 Erlang 소스 코드를 재구성하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="36d0968402854fd2204e4f8284f220657779d484" translate="yes" xml:space="preserve">
          <source>The following example shows how to set up a trace that is automatically stopped and formatted after 5 seconds:</source>
          <target state="translated">다음 예제는 5 초 후에 자동으로 중지 및 형식화 된 추적을 설정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="df6f58ee5cbd6c36262b198728ebe89b5c130696" translate="yes" xml:space="preserve">
          <source>The following example shows how to start an event manager and add an event handler to it by using the shell:</source>
          <target state="translated">다음 예제는 쉘을 사용하여 이벤트 관리자를 시작하고 이벤트 핸들러를 추가하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5fc528ca550abf4d7a434c41bd619acd146ef168" translate="yes" xml:space="preserve">
          <source>The following example shows how to update a record:</source>
          <target state="translated">다음 예제는 레코드를 업데이트하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cbb352e84c7618cb263e59542ab972df29182936" translate="yes" xml:space="preserve">
          <source>The following example shows that the guard succeeds if &lt;code&gt;P&lt;/code&gt; is record of type &lt;code&gt;person&lt;/code&gt;:</source>
          <target state="translated">다음 예는 &lt;code&gt;P&lt;/code&gt; 가 &lt;code&gt;person&lt;/code&gt; 유형의 레코드 인 경우 가드가 성공 함을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c27427b8d967e296729a0172b87b5c1cb7821f6e" translate="yes" xml:space="preserve">
          <source>The following example shows the basic use of &lt;code&gt;ttb&lt;/code&gt; from the Erlang shell. Default options are used both for starting the tracer and for formatting (the custom fetch directory is however provided). This gives a trace log named &lt;code&gt;Node-ttb&lt;/code&gt; in the newly created directory, where &lt;code&gt;Node&lt;/code&gt; is the node name. The default handler prints the formatted trace messages in the shell:</source>
          <target state="translated">다음 예는 Erlang 쉘에서 &lt;code&gt;ttb&lt;/code&gt; 의 기본 사용법을 보여줍니다 . 기본 옵션은 추적 프로그램 시작 및 형식화에 모두 사용됩니다 (그러나 사용자 정의 페치 디렉토리가 제공됨). 이것은 새로 작성된 디렉토리에 &lt;code&gt;Node-ttb&lt;/code&gt; 라는 추적 로그를 제공합니다 . 여기서 &lt;code&gt;Node&lt;/code&gt; 는 노드 이름입니다. 기본 핸들러는 형식화 된 추적 메시지를 쉘에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="33c400b4d7bc90cf1fb4285d622a80e1394cc3a9" translate="yes" xml:space="preserve">
          <source>The following example shows the reports generated when a process crashes. The example process is a &lt;code&gt;permanent&lt;/code&gt; process supervised by the &lt;code&gt;test_sup&lt;/code&gt; supervisor. A division by zero is executed and the error is first reported by the faulty process. A crash report is generated, as the process was started using function &lt;code&gt;proc_lib:spawn/3&lt;/code&gt;. The supervisor generates a supervisor report showing the crashed process. A progress report is generated when the process is finally restarted.</source>
          <target state="translated">다음 예는 프로세스가 충돌 할 때 생성 된 보고서를 보여줍니다. 예제 프로세스는 &lt;code&gt;test_sup&lt;/code&gt; 감독자가 감독 하는 &lt;code&gt;permanent&lt;/code&gt; 프로세스 입니다. 0으로 나누기가 실행되고 오류는 먼저 잘못된 프로세스에 의해보고됩니다. &lt;code&gt;proc_lib:spawn/3&lt;/code&gt; 함수를 사용하여 프로세스가 시작되면 충돌 보고서가 생성됩니다 . 수퍼바이저는 충돌 된 프로세스를 표시하는 수퍼바이저 보고서를 생성합니다. 프로세스가 마지막으로 다시 시작되면 진행률 보고서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="862f8553aec4c38b6ab11aac95b152a39de64479" translate="yes" xml:space="preserve">
          <source>The following example successfully constructs a bitstring of 7 bits, provided that all of X and Y are integers:</source>
          <target state="translated">다음 예제는 X와 Y가 모두 정수인 경우 7 비트의 비트 열을 성공적으로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b791c8b4e90272c4405c7aeae4b46da3f6bb6c8f" translate="yes" xml:space="preserve">
          <source>The following example test suite shows some tests of a database server:</source>
          <target state="translated">다음 테스트 스위트 예제는 데이터베이스 서버의 일부 테스트를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b6d5422eedcad9f5caa434fa7b207125a77682b5" translate="yes" xml:space="preserve">
          <source>The following example uses an explicit match specification to traverse the table:</source>
          <target state="translated">다음 예제는 명시 적 일치 스펙을 사용하여 테이블을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="03a4faf8451b45afff5a5b66483b40e3d0740248" translate="yes" xml:space="preserve">
          <source>The following example was run on OTP/R8 on Solaris 8, all OTP internals in this example are very version dependent.</source>
          <target state="translated">다음 예는 Solaris 8의 OTP / R8에서 실행되었으며이 예의 모든 OTP 내부는 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="46aa402444b6b984aa7f78159a16377f4c23a61a" translate="yes" xml:space="preserve">
          <source>The following example would match a simple Erlang integer or float and return a token which could be sent to the Erlang parser:</source>
          <target state="translated">다음 예제는 간단한 Erlang 정수 또는 float과 일치하여 Erlang 파서로 보낼 수있는 토큰을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ed0171fcebc0acc5e68cccfc60c0381e6097256" translate="yes" xml:space="preserve">
          <source>The following examples assume that the current directory is the top of an Erlang/OTP installation.</source>
          <target state="translated">다음 예는 현재 디렉토리가 Erlang / OTP 설치의 최상위 디렉토리라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9e3429edd1596d9bb7aa13fb024e8021be184516" translate="yes" xml:space="preserve">
          <source>The following examples define simplified versions of a few Erlang data types:</source>
          <target state="translated">다음 예제는 몇 가지 Erlang 데이터 유형의 단순화 된 버전을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f8bd6a0797d263a055952885390142cbff7bc575" translate="yes" xml:space="preserve">
          <source>The following examples illustrate a function that returns an error, and the method to retrieve more detailed error information:</source>
          <target state="translated">다음 예제는 오류를 반환하는 함수와보다 자세한 오류 정보를 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="02e03cbd265b56591c07a5d42abac6e2a5b935ba" translate="yes" xml:space="preserve">
          <source>The following examples illustrate how binaries are constructed, or matched, and how elements and tails are specified.</source>
          <target state="translated">다음 예제는 바이너리가 구성되거나 일치되는 방법과 요소 및 꼬리가 지정되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8d07d5eba80d244e874b251ee11faf436794868c" translate="yes" xml:space="preserve">
          <source>The following examples illustrate these rules:</source>
          <target state="translated">다음 예제는 이러한 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3f52213112fefdbc53dc8c9767c67e39d0c5dce9" translate="yes" xml:space="preserve">
          <source>The following examples show a dialogue with the Erlang shell. All the higher order functions discussed are exported from the module &lt;code&gt;lists&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 Erlang 쉘과의 대화를 보여줍니다. 논의 된 모든 고차 함수는 모듈 &lt;code&gt;lists&lt;/code&gt; 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="4e3ffd9c68f42312446cc6dbf3d84bd42d447765" translate="yes" xml:space="preserve">
          <source>The following examples show parsers of the following type:</source>
          <target state="translated">다음 예제는 다음 유형의 구문 분석기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="18a677a2dd5f46875b6af8f8c34c6eb70fbe49be" translate="yes" xml:space="preserve">
          <source>The following examples show the resulting C programs. First a C node server using short node names:</source>
          <target state="translated">다음 예제는 결과 C 프로그램을 보여줍니다. 먼저 짧은 노드 이름을 사용하는 C 노드 서버 :</target>
        </trans-unit>
        <trans-unit id="379499ad8751de711870d7f29677a3a780a463f0" translate="yes" xml:space="preserve">
          <source>The following examples show the two startup options:</source>
          <target state="translated">다음 예제는 두 가지 시작 옵션을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1cdf118319fd331ed388451fe6b82def7ded6fa8" translate="yes" xml:space="preserve">
          <source>The following examples use the utility function &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt; ssh:start/0&lt;/a&gt;&lt;/code&gt; to start all needed applications (&lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;). All examples are run in an Erlang shell, or in a bash shell, using &lt;strong&gt;openssh&lt;/strong&gt; to illustrate how the &lt;code&gt;ssh&lt;/code&gt; application can be used. The examples are run as the user &lt;code&gt;otptest&lt;/code&gt; on a local network where the user is authorized to log in over &lt;code&gt;ssh&lt;/code&gt; to the host &lt;strong&gt;tarlop&lt;/strong&gt;.</source>
          <target state="translated">다음 예제는 유틸리티 함수 &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt; ssh:start/0&lt;/a&gt;&lt;/code&gt; 을 사용하여 필요한 모든 애플리케이션 ( &lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;public_key&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; ) 을 시작합니다 . 모든 예제는 &lt;code&gt;ssh&lt;/code&gt; 애플리케이션 사용 방법을 설명하기 위해 &lt;strong&gt;openssh&lt;/strong&gt; 를 사용하여 Erlang 쉘 또는 bash 쉘에서 실행 됩니다. 예제는 사용자가 &lt;code&gt;ssh&lt;/code&gt; 를 통해 호스트 &lt;strong&gt;tarlop&lt;/strong&gt; 에 로그인 할 권한이있는 로컬 네트워크에서 사용자 &lt;code&gt;otptest&lt;/code&gt; 로 실행됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2e4438a8f07510d88683d4b04f8f84085bdfc63" translate="yes" xml:space="preserve">
          <source>The following examples use the utility function &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;ssh:start/0&lt;/a&gt;&lt;/code&gt; to start all needed applications (&lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;). All examples are run in an Erlang shell, or in a bash shell, using &lt;strong&gt;openssh&lt;/strong&gt; to illustrate how the &lt;code&gt;ssh&lt;/code&gt; application can be used. The examples are run as the user &lt;code&gt;otptest&lt;/code&gt; on a local network where the user is authorized to log in over &lt;code&gt;ssh&lt;/code&gt; to the host &lt;strong&gt;tarlop&lt;/strong&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;ssh:start/0&lt;/a&gt;&lt;/code&gt; 유틸리티 기능을 사용하여 필요한 모든 애플리케이션 ( &lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;public_key&lt;/code&gt; 및 &lt;code&gt;ssh&lt;/code&gt; ) 을 시작합니다 . 모든 예제는 &lt;code&gt;ssh&lt;/code&gt; 애플리케이션 사용 방법을 설명하기 위해 &lt;strong&gt;openssh&lt;/strong&gt; 를 사용하여 Erlang 쉘 또는 bash 쉘에서 실행 됩니다. 예제는 사용자가 &lt;code&gt;ssh&lt;/code&gt; 를 통해 호스트 &lt;strong&gt;tarlop&lt;/strong&gt; 에 로그인 할 수있는 권한이 부여 된 로컬 네트워크에서 &lt;code&gt;otptest&lt;/code&gt; 사용자로 실행됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5cd0b11976b5319f2006d2a53413541627fed4ce" translate="yes" xml:space="preserve">
          <source>The following executes &lt;code&gt;tc12&lt;/code&gt;&lt;strong&gt;only&lt;/strong&gt; in group &lt;code&gt;top1&lt;/code&gt;:</source>
          <target state="translated">다음이 실행은 &lt;code&gt;tc12&lt;/code&gt; &lt;strong&gt;에만&lt;/strong&gt; 그룹에서 &lt;code&gt;top1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88857e0adb91607265c1fd3c40132140d6d97f6c" translate="yes" xml:space="preserve">
          <source>The following executes one test for all cases and subgroups under &lt;code&gt;top1&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;top1&lt;/code&gt; 아래의 모든 케이스 및 하위 그룹에 대해 하나의 테스트를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="25e14a4c0f0dd8657c260321ddf24593cbf2714d" translate="yes" xml:space="preserve">
          <source>The following executes only the test cases for &lt;code&gt;sub22&lt;/code&gt; and in reverse order compared to the group definition:</source>
          <target state="translated">다음은 그룹 정의와 비교하여 &lt;code&gt;sub22&lt;/code&gt; 의 테스트 케이스 만 역순으로 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="9d59ae5da72969b4283c1cf98a39c82e69b73434" translate="yes" xml:space="preserve">
          <source>The following executes two tests, one for all cases and all subgroups under &lt;code&gt;top1&lt;/code&gt;, and one for all under &lt;code&gt;top2&lt;/code&gt;:</source>
          <target state="translated">다음의 두 가지 테스트가 실행하는 모든 경우에 대해 하나 및 아래에있는 모든 서브 그룹 &lt;code&gt;top1&lt;/code&gt; 및 아래 모두 하나 &lt;code&gt;top2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88efd1d16122c7dfa20482784039de0e7578cec9" translate="yes" xml:space="preserve">
          <source>The following executes two tests, one including all cases and subgroups under &lt;code&gt;sub12&lt;/code&gt;, and one with &lt;strong&gt;only&lt;/strong&gt; the test cases in &lt;code&gt;sub12&lt;/code&gt;:</source>
          <target state="translated">다음의 두 가지 테스트가 실행하는 모든 경우 미만 서브 그룹을 포함하는 하나 &lt;code&gt;sub12&lt;/code&gt; 및 하나 &lt;strong&gt;에서만&lt;/strong&gt; 의 테스트 케이스 &lt;code&gt;sub12&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a7ba64d043b7996c073a0f4af0d073005f423a1" translate="yes" xml:space="preserve">
          <source>The following expression creates a new &lt;code&gt;Name&lt;/code&gt; record where the value of each field &lt;code&gt;FieldI&lt;/code&gt; is the value of evaluating the corresponding expression &lt;code&gt;ExprI&lt;/code&gt;:</source>
          <target state="translated">다음 표현식은 각 필드 &lt;code&gt;FieldI&lt;/code&gt; 의 값이 해당 표현식 &lt;code&gt;ExprI&lt;/code&gt; 를 평가하는 값인 새 &lt;code&gt;Name&lt;/code&gt; 레코드를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ae6de457c01e1fb1a3e00546eff8958609de12b0" translate="yes" xml:space="preserve">
          <source>The following expression returns the position of the specified field in the tuple representation of the record:</source>
          <target state="translated">다음 표현식은 레코드의 튜플 표현에서 지정된 필드의 위치를 ​​리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c58518dfed86937c32c0b6a021322cd7beecbd65" translate="yes" xml:space="preserve">
          <source>The following expression yields &lt;code&gt;true&lt;/code&gt;::</source>
          <target state="translated">다음 식을 얻을 수 &lt;code&gt;true&lt;/code&gt; ::</target>
        </trans-unit>
        <trans-unit id="dd1a2e6659306c0be27370e1c7239f7c64f5c457" translate="yes" xml:space="preserve">
          <source>The following expressions are translated equally:</source>
          <target state="translated">다음 표현식은 동일하게 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="f600fa95580d128a5b55c2d2a3bd52715c966b7f" translate="yes" xml:space="preserve">
          <source>The following expressions yield &lt;code&gt;false&lt;/code&gt;, as variable &lt;code&gt;Broken&lt;/code&gt; contains a compiled match specification that has passed through external representation:</source>
          <target state="translated">다음 변수는 &lt;code&gt;Broken&lt;/code&gt; 변수에 외부 표현을 통과 한 컴파일 된 일치 스펙이 포함 되므로 &lt;code&gt;false&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b9eb1676778caddf159cfe9acf52d248a3850a31" translate="yes" xml:space="preserve">
          <source>The following fapply:</source>
          <target state="translated">다음과 같은 일이 일어납니다 :</target>
        </trans-unit>
        <trans-unit id="f3d7d3c3deb0a0a629d81950bc6b6134511197b1" translate="yes" xml:space="preserve">
          <source>The following fields are not described in the ERTS User's Guide:</source>
          <target state="translated">다음 필드는 ERTS 사용 설명서에 설명되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61d54bcd350d6740f125ef1579264955f1c65547" translate="yes" xml:space="preserve">
          <source>The following fields are used from the record, if they are specified:</source>
          <target state="translated">다음 필드는 지정된 경우 레코드에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="579212e906c367c5e65524f9d589806b1a4dfd60" translate="yes" xml:space="preserve">
          <source>The following fields can exist for a process:</source>
          <target state="translated">프로세스에 대해 다음 필드가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cec82fe0d57eb1d23921e0d50a78837999069a1" translate="yes" xml:space="preserve">
          <source>The following fields typically must be specified by the sender:</source>
          <target state="translated">다음 필드는 일반적으로 발신자가 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="08329a98a990baea9fd4cf44d504f845faefdaf6" translate="yes" xml:space="preserve">
          <source>The following figure shows a conceptual overview of Logger. The figure shows two log handlers, but any number of handlers can be installed.</source>
          <target state="translated">다음 그림은 로거의 개념 개요를 보여줍니다. 이 그림은 두 개의 로그 처리기를 보여 주지만 원하는 수의 처리기를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bef9dc10cd953efe4cb861873187dfba852609d" translate="yes" xml:space="preserve">
          <source>The following figure shows the bytes of a &lt;code&gt;Window:status&lt;/code&gt; message. The components &lt;code&gt;buttonList&lt;/code&gt; and &lt;code&gt;actions&lt;/code&gt; are excluded from decode. Only &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt; are decoded when &lt;code&gt;decode__Window_exclusive&lt;/code&gt; is called.</source>
          <target state="translated">다음 그림은 &lt;code&gt;Window:status&lt;/code&gt; 메시지 의 바이트를 보여줍니다 . 구성 요소 &lt;code&gt;buttonList&lt;/code&gt; 및 &lt;code&gt;actions&lt;/code&gt; 은 디코딩에서 제외됩니다. 만 &lt;code&gt;state&lt;/code&gt; 및 &lt;code&gt;enabled&lt;/code&gt; 되면 디코드 &lt;code&gt;decode__Window_exclusive&lt;/code&gt; 가 호출된다.</target>
        </trans-unit>
        <trans-unit id="5e130f9f78c1692a150e4f0eeb068783cb173914" translate="yes" xml:space="preserve">
          <source>The following figure shows which components are in &lt;code&gt;TypeList&lt;/code&gt;&lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt;:</source>
          <target state="translated">다음 그림은 &lt;code&gt;TypeList&lt;/code&gt; &lt;code&gt;['Window',status,actions,possibleActions,[1],handle,number]&lt;/code&gt; 에 있는 구성 요소를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b445689ad7fd0436cd7641f643a07c0561a2fe9a" translate="yes" xml:space="preserve">
          <source>The following file includes two certificates:</source>
          <target state="translated">다음 파일에는 두 가지 인증서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3db502e7fd49532c31554150f0c64ab687cd78ab" translate="yes" xml:space="preserve">
          <source>The following file types are defined in Erlang/OTP:</source>
          <target state="translated">Erlang / OTP에는 다음과 같은 파일 형식이 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="71254e9506c929f7f52ca316b3c356b831887b19" translate="yes" xml:space="preserve">
          <source>The following flags are available:</source>
          <target state="translated">다음과 같은 플래그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719ce2e093c09df2408e42a7406958a700ac71ea" translate="yes" xml:space="preserve">
          <source>The following flags are defined automatically and can be retrieved using this function:</source>
          <target state="translated">다음 플래그는 자동으로 정의되며이 기능을 사용하여 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe356642f0df6916029c9299326bc02952f156d" translate="yes" xml:space="preserve">
          <source>The following flags are recognised:</source>
          <target state="translated">다음과 같은 플래그가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="2791d823738fc796e3aff5cac56fe1c0dc58c276" translate="yes" xml:space="preserve">
          <source>The following flags are supported:</source>
          <target state="translated">다음과 같은 플래그가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9a37b4b5f5db6694294b80fe420424b434a55049" translate="yes" xml:space="preserve">
          <source>The following flags are useful in special situations, such as rebuilding the OTP system:</source>
          <target state="translated">다음 플래그는 OTP 시스템 재 구축과 같은 특수 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e3e7ff31b4722f8ae27b4760d8e2609571bf918c" translate="yes" xml:space="preserve">
          <source>The following flags can also be used with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 과 함께 다음 플래그를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe0b90a260b51ac7fbb2626eba5e49455fbc6475" translate="yes" xml:space="preserve">
          <source>The following four installation procedures require super user privilege:</source>
          <target state="translated">다음 4 가지 설치 절차에는 수퍼 유저 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="857a38dd46b2870a572b2281f80d819712f630b7" translate="yes" xml:space="preserve">
          <source>The following fun expressions are also allowed:</source>
          <target state="translated">다음과 같은 재미있는 표현도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e53e9cb8d584334c556a4497982894d55fd0779" translate="yes" xml:space="preserve">
          <source>The following function extracts a list of female employees from the database:</source>
          <target state="translated">다음 함수는 데이터베이스에서 여성 직원 목록을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="504f3189fc42a4b1e4cebcb03cdadcfe20e2ff16" translate="yes" xml:space="preserve">
          <source>The following function extracts the names of the female employees stored in the database:</source>
          <target state="translated">다음 함수는 데이터베이스에 저장된 여성 직원의 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="e7ccfae3bc62070f3a6d6f25984d604af2dca20b" translate="yes" xml:space="preserve">
          <source>The following function must be exported from a &lt;code&gt;supervisor&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;supervisor&lt;/code&gt; 콜백 모듈 에서 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="07aad394cfc87e43c34047ccb79c6f62e522e12b" translate="yes" xml:space="preserve">
          <source>The following function takes a list of &lt;code&gt;person&lt;/code&gt; records and searches for the phone number of a person with a particular name:</source>
          <target state="translated">다음 기능은 &lt;code&gt;person&lt;/code&gt; 레코드 목록을 가져와 특정 이름을 가진 사람의 전화 번호를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d42b26451a776d64cc4668a7081444af7e2c2a1e" translate="yes" xml:space="preserve">
          <source>The following function, &lt;code&gt;add_one&lt;/code&gt;, adds one to every element in a list:</source>
          <target state="translated">&lt;code&gt;add_one&lt;/code&gt; 함수 는 목록의 모든 요소에 하나를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fdcde9b058d15df816f05ecda9bd41f522994a81" translate="yes" xml:space="preserve">
          <source>The following function, &lt;code&gt;double&lt;/code&gt;, doubles every element in a list:</source>
          <target state="translated">다음 &lt;code&gt;double&lt;/code&gt; 함수 는 목록의 모든 요소를 ​​두 배로 늘립니다.</target>
        </trans-unit>
        <trans-unit id="4a3f4a02410e47e9c3849742c5727d2c0861cf66" translate="yes" xml:space="preserve">
          <source>The following functionally equivalent code writes 128 bytes per call to &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; and so does the same work in 0.08 seconds, which is roughly 30 times faster:</source>
          <target state="translated">다음과 같은 기능적으로 동등한 코드는 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 에 대한 호출 당 128 바이트를 작성 하므로 0.08 초 안에 동일한 작업을 수행하므로 약 30 배 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4851a85cacd7cea8fbbb07ff6c65612ebb17807b" translate="yes" xml:space="preserve">
          <source>The following functions are exported by the generated scanner.</source>
          <target state="translated">생성 된 스캐너에서 다음 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5f67bcd3deeb0c90fe208811b94f6ecb50fdd70e" translate="yes" xml:space="preserve">
          <source>The following functions are inlined:</source>
          <target state="translated">다음 기능이 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8f6071853dc23038c690be527eb7aed97d99f5" translate="yes" xml:space="preserve">
          <source>The following functions are mandatory:</source>
          <target state="translated">다음 기능은 필수입니다 :</target>
        </trans-unit>
        <trans-unit id="f7564bfdee2fc04335ad865192d312010f773791" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;ct_suite&lt;/code&gt; callback module in order to define the callback interface for a test suite.</source>
          <target state="translated">다음 함수는 테스트 스위트에 대한 콜백 인터페이스를 정의하기 위해 &lt;code&gt;ct_suite&lt;/code&gt; 콜백 모듈에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="6ab66b86479cb4b8966432e55db73f7b8eac0221" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_event&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;gen_event&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="eaf6f53e0685fd921f6065ec533398767638e814" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_server&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;gen_server&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="baab9084b49f784e0a7049c6d9a71e4b999906d7" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;gen_statem&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;gen_statem&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="f6d8fd0dedca27c09b82ec5cdf80b62654de4c23" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;ssh_client_channel&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;ssh_client_channel&lt;/code&gt; 콜백 모듈 에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="b8fd8927d0a9812c875db0dd32e79d269aceb81c" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a &lt;code&gt;ssh_server_channel&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;ssh_server_channel&lt;/code&gt; 콜백 모듈 에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e23fa44c13429a2fd437dba0988c988e7a312614" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a formatter callback module.</source>
          <target state="translated">다음 함수는 포맷터 콜백 모듈에서 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f3a0c7ead32b20d4fc3d927da2c12376abf896b9" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from a handler callback module.</source>
          <target state="translated">다음 함수는 핸들러 콜백 모듈에서 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="324102d29dfa0e459c285f94eb4c3c3798cd41d3" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from an &lt;code&gt;application&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;application&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="623497a405a43189792a81522e86a8b9226d067f" translate="yes" xml:space="preserve">
          <source>The following functions are to be exported from an &lt;code&gt;erl_tracer&lt;/code&gt; callback module:</source>
          <target state="translated">다음 함수는 &lt;code&gt;erl_tracer&lt;/code&gt; 콜백 모듈 에서 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="64dc45bde2a752b8cec35e2e33de402f72f6cc40" translate="yes" xml:space="preserve">
          <source>The following functions are used for convenience.</source>
          <target state="translated">편의를 위해 다음 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c872bca07adade7d8cc574c2485887affd6e5d83" translate="yes" xml:space="preserve">
          <source>The following functions are used to back up data, to install a backup as fallback, and for disaster recovery:</source>
          <target state="translated">다음 기능은 데이터를 백업하고 폴백으로 백업을 설치하고 재해 복구에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="02628df42092a5c994d8e891c4403f91bfbbbb66" translate="yes" xml:space="preserve">
          <source>The following functions are used when implementing a special process. This is an ordinary process, which does not use a standard behavior, but a process that understands the standard system messages.</source>
          <target state="translated">특수 프로세스를 구현할 때 다음 기능이 사용됩니다. 이는 표준 동작을 사용하지 않고 표준 시스템 메시지를 이해하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="26b92712bb4c99562ee4a3caab022028754f5836" translate="yes" xml:space="preserve">
          <source>The following functions can be used to test upgrade and downgrade of single applications (instead of upgrading/downgrading an entire release). A script corresponding to the instructions in the &lt;code&gt;relup&lt;/code&gt; file is created on-the-fly, based on the &lt;code&gt;.appup&lt;/code&gt; file for the application, and evaluated exactly in the same way as &lt;code&gt;release_handler&lt;/code&gt; does.</source>
          <target state="translated">전체 릴리스를 업그레이드 / 다운 그레이드하는 대신 단일 기능의 업그레이드 및 다운 그레이드를 테스트하는 데 다음 기능을 사용할 수 있습니다. &lt;code&gt;relup&lt;/code&gt; 파일 의 명령어에 해당하는 스크립트 는 응용 프로그램 의 &lt;code&gt;.appup&lt;/code&gt; 파일을 기반으로 즉석에서 작성 되며 &lt;code&gt;release_handler&lt;/code&gt; 와 동일한 방식으로 정확하게 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="24d76d64ddf59c8af9a65858beb15de37d52e968" translate="yes" xml:space="preserve">
          <source>The following functions control the behavior of the internal counters.</source>
          <target state="translated">다음 기능은 내부 카운터의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="c8f7d8e59ac7e38340a3c25c101d522f5875e82c" translate="yes" xml:space="preserve">
          <source>The following functions define the callback interface for a CTH.</source>
          <target state="translated">다음 함수는 CTH에 대한 콜백 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="02a00b734983835a88dfd4ba08c110451f346e89" translate="yes" xml:space="preserve">
          <source>The following functions define the callback interface for a test suite.</source>
          <target state="translated">다음 함수는 테스트 스위트의 콜백 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="647d81b837420325efd90808d2b34ee3893c58a1" translate="yes" xml:space="preserve">
          <source>The following functions describe the interface to &lt;code&gt;snmpa_local_db&lt;/code&gt;. Each function has a Mnesia equivalent. The argument &lt;code&gt;NameDb&lt;/code&gt; is a tuple &lt;code&gt;{Name, Db}&lt;/code&gt; where &lt;code&gt;Name&lt;/code&gt; is the symbolic name of the managed object (as defined in the MIB), and &lt;code&gt;Db&lt;/code&gt; is either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;persistent&lt;/code&gt;. &lt;code&gt;mnesia&lt;/code&gt; is not possible since all these functions are &lt;code&gt;snmpa_local_db&lt;/code&gt; specific.</source>
          <target state="translated">다음 함수는 &lt;code&gt;snmpa_local_db&lt;/code&gt; 에 대한 인터페이스를 설명합니다 . 각 기능에는 Mnesia 기능이 있습니다. &lt;code&gt;NameDb&lt;/code&gt; 인수 는 튜플 &lt;code&gt;{Name, Db}&lt;/code&gt; 이며 , 여기서 &lt;code&gt;Name&lt;/code&gt; 은 MIB에 정의 된대로 관리 오브젝트의 기호 이름이며 &lt;code&gt;Db&lt;/code&gt; 는 &lt;code&gt;volatile&lt;/code&gt; 이거나 &lt;code&gt;persistent&lt;/code&gt; 입니다. &lt;code&gt;mnesia&lt;/code&gt; 는 이러한 모든 기능이기 때문에 가능하지 않다 &lt;code&gt;snmpa_local_db&lt;/code&gt; 특정.</target>
        </trans-unit>
        <trans-unit id="a1100a11b4b80e1ec32b674331fc67603b3198a3" translate="yes" xml:space="preserve">
          <source>The following functions in this module also exist and provides the same functionality in the &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; modules. That is, by only changing the module name for each call, you can try out different set representations.</source>
          <target state="translated">이 모듈에는 다음 기능도 있으며 &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; 모듈 에서 동일한 기능을 제공합니다 . 즉, 각 호출에 대한 모듈 이름 만 변경하여 다른 세트 표현을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403a88e7d4193643f2441bbe4104eef783bcc30f" translate="yes" xml:space="preserve">
          <source>The following functions must be exported from a &lt;code&gt;mib-server&lt;/code&gt; data callback module:</source>
          <target state="translated">&lt;code&gt;mib-server&lt;/code&gt; 데이터 콜백 모듈 에서 다음 함수를 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="211427edb5cce5619a96cf4257a0132f6686ca2a" translate="yes" xml:space="preserve">
          <source>The following functions must be exported from a &lt;code&gt;supervisor_bridge&lt;/code&gt; callback module.</source>
          <target state="translated">다음 함수는 &lt;code&gt;supervisor_bridge&lt;/code&gt; 콜백 모듈 에서 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e7c33747a8a7210784ba4d3e34376c30cdfd02d" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_edist_compress&lt;/code&gt; callback module:</source>
          <target state="translated">&lt;code&gt;megaco_edist_compress&lt;/code&gt; 콜백 모듈 에서 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c2eb550d5e0fd353c08fabab97a3148ca0012e2" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_encoder&lt;/code&gt; callback module:</source>
          <target state="translated">&lt;code&gt;megaco_encoder&lt;/code&gt; 콜백 모듈 에서 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="36e94e447d27f2ba2ddd7dbee957d9efa47d84bf" translate="yes" xml:space="preserve">
          <source>The following functions should be exported from a &lt;code&gt;megaco_transport&lt;/code&gt; callback module:</source>
          <target state="translated">&lt;code&gt;megaco_transport&lt;/code&gt; 콜백 모듈 에서 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="f8ee1e36bf47047325c371be3bfaa01a6b15fc9a" translate="yes" xml:space="preserve">
          <source>The following functions, &lt;code&gt;read_cmd()&lt;/code&gt; and &lt;code&gt;write_cmd()&lt;/code&gt;, from the &lt;code&gt;erl_comm.c&lt;/code&gt; example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; can still be used for reading from and writing to the port:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;erl_comm.c&lt;/code&gt; 예제에서 &lt;code&gt;read_cmd()&lt;/code&gt; 및 &lt;code&gt;write_cmd()&lt;/code&gt; 함수를 사용하여 포트에서 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0cc9a33559cd30dd7c5dee49a32a3678fc0996" translate="yes" xml:space="preserve">
          <source>The following general category property codes are supported:</source>
          <target state="translated">다음과 같은 일반 카테고리 특성 코드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="485d675e1e288b4464e0d6976f961540aa46e469" translate="yes" xml:space="preserve">
          <source>The following guard BIFs handle maps:</source>
          <target state="translated">다음 가드 BIF는 맵을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="00b20eb40ed0d659393e7ede6b8509b03c2165e1" translate="yes" xml:space="preserve">
          <source>The following illustration shows how a system can look in runtime.</source>
          <target state="translated">다음 그림은 시스템이 런타임에서 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d0fc102c368e541c6de8ef4f6fd846441148303d" translate="yes" xml:space="preserve">
          <source>The following information is given for each child specification/process:</source>
          <target state="translated">각 하위 사양 / 프로세스에 대해 다음 정보가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0cce2ff92e643403b8a8a43b7b39a2cc520dd904" translate="yes" xml:space="preserve">
          <source>The following information is returned for every application:</source>
          <target state="translated">모든 응용 프로그램에 대해 다음 정보가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b3fbdd770d4e0e0bb91f42f7653cca9a0fa8d845" translate="yes" xml:space="preserve">
          <source>The following information is returned for every library module:</source>
          <target state="translated">모든 라이브러리 모듈에 대해 다음 정보가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b25c49ec2d0414911fc31e80509041b6c00e1677" translate="yes" xml:space="preserve">
          <source>The following information is returned for every release:</source>
          <target state="translated">모든 릴리스에 대해 다음 정보가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e22fc9271f190429a4be85a97f17d1b778ca80" translate="yes" xml:space="preserve">
          <source>The following instructions are for building &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_21.0.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 지침은 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_21.0.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt; 을 제작 하기 위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ed0ab9d59cb82f2960e2d92ecb88bb528745679a" translate="yes" xml:space="preserve">
          <source>The following instructions are for building &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_23.2.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 지침은 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_src_23.2.tar.gz&quot;&gt;the released source tar ball&lt;/a&gt;&lt;/code&gt; 을 빌드 하기 위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9bb6feade4582730097dc79e92bae679305ea48e" translate="yes" xml:space="preserve">
          <source>The following is a checklist for rewriting a pre ERTS 5.9 driver, most important first:</source>
          <target state="translated">다음은 가장 중요한 첫 번째 ERTS 5.9 드라이버를 다시 작성하기위한 점검 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3b1759541f1940201849307e8f98dd17638ad123" translate="yes" xml:space="preserve">
          <source>The following is a complete &lt;code&gt;Fun&lt;/code&gt; parameter for reading and writing on files using the &lt;code&gt;file&lt;/code&gt; module:</source>
          <target state="translated">다음은 &lt;code&gt;file&lt;/code&gt; 모듈을 사용하여 파일 을 읽고 쓰는 데 사용 되는 완전한 &lt;code&gt;Fun&lt;/code&gt; 매개 변수입니다 .</target>
        </trans-unit>
        <trans-unit id="e5dec4fa9682464bd8811fb1940ba59ef25ee7c6" translate="yes" xml:space="preserve">
          <source>The following is a complete list of &lt;strong&gt;event types&lt;/strong&gt; and where they come from:</source>
          <target state="translated">다음은 &lt;strong&gt;이벤트 유형&lt;/strong&gt; 및 출처 의 전체 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="fc7d7129dd6f6c58173a187543c25f188276eaf0" translate="yes" xml:space="preserve">
          <source>The following is a complete list of event types and where they come from:</source>
          <target state="translated">다음은 이벤트 유형의 전체 목록과 이벤트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c8a14f55bfff88da1be28bb766800640bcd62c50" translate="yes" xml:space="preserve">
          <source>The following is a list of the ANSI data types. For details turn to the ANSI standard documentation. Usage of other data types is of course possible, but you should be aware that this makes your application dependent on the database you are using at the moment.</source>
          <target state="translated">다음은 ANSI 데이터 유형의 목록입니다. 자세한 내용은 ANSI 표준 설명서를 참조하십시오. 다른 데이터 유형의 사용은 물론 가능하지만 이로 인해 현재 사용중인 데이터베이스에 따라 응용 프로그램이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="9dffda4d1a563c216467972b2fef4d25fa28c442" translate="yes" xml:space="preserve">
          <source>The following is a rather unnatural example to show another exception:</source>
          <target state="translated">다음은 또 다른 예외를 보여주는 다소 부 자연스러운 예입니다.</target>
        </trans-unit>
        <trans-unit id="fc5496457b8761bac15ca387a14c23e2f06d56e0" translate="yes" xml:space="preserve">
          <source>The following is a shell session when running it:</source>
          <target state="translated">다음은 실행시 쉘 세션입니다.</target>
        </trans-unit>
        <trans-unit id="1c1afe341a3a40e5c215a483f55d3776b92db0f3" translate="yes" xml:space="preserve">
          <source>The following is a short program to show the workings of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;if&lt;/code&gt; 의 작동을 보여주는 간단한 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="92e3b552e54cc6f54aad0df369b0b7192bcf382d" translate="yes" xml:space="preserve">
          <source>The following is a simple example of an FTP session, where the user &lt;code&gt;guest&lt;/code&gt; with password &lt;code&gt;password&lt;/code&gt; logs on to the remote host &lt;code&gt;erlang.org&lt;/code&gt;:</source>
          <target state="translated">다음은 FTP 비밀번호 의 간단한 예입니다. 비밀번호 &lt;code&gt;password&lt;/code&gt; 가있는 사용자 &lt;code&gt;guest&lt;/code&gt; 가 원격 호스트 &lt;code&gt;erlang.org&lt;/code&gt; 에 로그온합니다 .</target>
        </trans-unit>
        <trans-unit id="af00308e7be83b75dde0c794afc64df924d05311" translate="yes" xml:space="preserve">
          <source>The following is a simpler example of a handler which logs to a file through one single process:</source>
          <target state="translated">다음은 하나의 단일 프로세스를 통해 파일에 로그하는 처리기의 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="2985e72c56df70fad7f40fc868951b90ac475392" translate="yes" xml:space="preserve">
          <source>The following is a slightly more complicated example of an &lt;code&gt;.erlang.crypt&lt;/code&gt; providing one key for module &lt;code&gt;t&lt;/code&gt; and another key for all other modules:</source>
          <target state="translated">다음은 모듈 &lt;code&gt;t&lt;/code&gt; 에 대한 하나의 키 와 다른 모든 모듈에 대한 다른 키를 제공 하는 &lt;code&gt;.erlang.crypt&lt;/code&gt; 의 약간 더 복잡한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c2e759eba9876095f44fce0efab73cd548a24130" translate="yes" xml:space="preserve">
          <source>The following is a template example of how to create and return a resource object.</source>
          <target state="translated">다음은 자원 객체를 생성하고 반환하는 방법에 대한 템플릿 예입니다.</target>
        </trans-unit>
        <trans-unit id="407235d853511b8f33bb270ef89fc50a0d62af2a" translate="yes" xml:space="preserve">
          <source>The following is an easy way of obtaining a unique value to seed with:</source>
          <target state="translated">다음은 시드 할 고유 한 값을 얻는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="559fe21097f15ddc3169882128ef5ed665f04654" translate="yes" xml:space="preserve">
          <source>The following is an example module to trace on:</source>
          <target state="translated">다음은 추적 할 예제 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="80aa757f4a9a7af17950895f0cec0bc27ec18d99" translate="yes" xml:space="preserve">
          <source>The following is an example of Erlang code that assigns values for the types in the previous list:</source>
          <target state="translated">다음은 이전 목록의 유형에 값을 지정하는 Erlang 코드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="d01528f16015b5f29f1097c6ec1da0702097e439" translate="yes" xml:space="preserve">
          <source>The following is an example of X509 certificates:</source>
          <target state="translated">다음은 X509 인증서의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b27cba48368a69cfcb442391037a03176a6a6532" translate="yes" xml:space="preserve">
          <source>The following is an example of a callback module for a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor:</source>
          <target state="translated">다음은 &lt;code&gt;simple_one_for_one&lt;/code&gt; 수퍼바이저에 대한 콜백 모듈의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1f30318b19c32d664f2f54026ca7ff0b8355f643" translate="yes" xml:space="preserve">
          <source>The following is an example of an &lt;code&gt;.erlang.crypt&lt;/code&gt; file that returns the same key for all modules:</source>
          <target state="translated">다음은 모든 모듈에 대해 동일한 키를 반환 하는 &lt;code&gt;.erlang.crypt&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="beaf428bf8cc669201276ed3d29a25f483cbffc1" translate="yes" xml:space="preserve">
          <source>The following is an example of how the functions in the previous example can be rewritten if it is necessary to open multiple connections to the FTP server:</source>
          <target state="translated">다음은 FTP 서버에 대한 여러 연결을 열어야하는 경우 이전 예의 기능을 다시 작성할 수있는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="7f7272e68f14b299a421c24c15d68c41acc39f20" translate="yes" xml:space="preserve">
          <source>The following is an example of how to assert that the configuration data is available and can be used for an FTP session:</source>
          <target state="translated">다음은 구성 데이터가 사용 가능하고 FTP 세션에 사용될 수 있는지 확인하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="006f54e284f6eaf59f32808c04b6087a85040dff" translate="yes" xml:space="preserve">
          <source>The following is an example of how to return the status from a group:</source>
          <target state="translated">다음은 그룹에서 상태를 반환하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="de8c4707aa64df488804045d788d163861ba1459" translate="yes" xml:space="preserve">
          <source>The following is an example session using it on Linux:</source>
          <target state="translated">다음은 Linux에서이를 사용하는 예제 세션입니다.</target>
        </trans-unit>
        <trans-unit id="22fa03b054cca550539d61bd30740fe445725fe1" translate="yes" xml:space="preserve">
          <source>The following is an ordinary asynchronous request:</source>
          <target state="translated">다음은 일반적인 비동기 요청입니다.</target>
        </trans-unit>
        <trans-unit id="1617114c5fde90021a15fd0405960852bae70f6c" translate="yes" xml:space="preserve">
          <source>The following is an ordinary synchronous request:</source>
          <target state="translated">다음은 일반적인 동기 요청입니다.</target>
        </trans-unit>
        <trans-unit id="25cf5f91df4951ef8502f305f460dc3e467e107b" translate="yes" xml:space="preserve">
          <source>The following is another special sequence that can appear at the start of a pattern:</source>
          <target state="translated">다음은 패턴의 시작 부분에 나타날 수있는 또 다른 특수 순서입니다.</target>
        </trans-unit>
        <trans-unit id="25f3a545690924d83cc64312bc56248e3f69655a" translate="yes" xml:space="preserve">
          <source>The following is called when the application is stopped.</source>
          <target state="translated">응용 프로그램이 중지되면 다음이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a7bb8990a6d72dd204c6cca6df9719f6eb039d12" translate="yes" xml:space="preserve">
          <source>The following is the complete callback module file &lt;code&gt;pushbutton.erl&lt;/code&gt;:</source>
          <target state="translated">다음은 완전한 콜백 모듈 파일 &lt;code&gt;pushbutton.erl&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="eba1404bcd0f1c2d40b6a68a0e51cd8231cb108f" translate="yes" xml:space="preserve">
          <source>The following is the instruction for adding an application:</source>
          <target state="translated">다음은 응용 프로그램을 추가하기위한 지침입니다.</target>
        </trans-unit>
        <trans-unit id="eef8732ed7e4037c0a3fb4336a9e4dba89b8f906" translate="yes" xml:space="preserve">
          <source>The following is the instruction for removing an application:</source>
          <target state="translated">다음은 응용 프로그램을 제거하기위한 지침입니다.</target>
        </trans-unit>
        <trans-unit id="314b2a42ea1284b836958c707ebdeebfb1e761a9" translate="yes" xml:space="preserve">
          <source>The following is the instruction for restarting an application:</source>
          <target state="translated">다음은 응용 프로그램을 다시 시작하기위한 지침입니다.</target>
        </trans-unit>
        <trans-unit id="04b2d72b40a1cd44a0454da6f08a0b030bd3218c" translate="yes" xml:space="preserve">
          <source>The following is to be put in the Erlang node application configuration file to start a profile at application startup:</source>
          <target state="translated">다음은 Erlang 노드 애플리케이션 구성 파일에 넣어 애플리케이션 시작시 프로파일을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="062b29997a05c71efe23ac3949d3086ab3d47473" translate="yes" xml:space="preserve">
          <source>The following is to be put in the Erlang node application configuration file to start an HTTP server at application startup:</source>
          <target state="translated">다음은 Erlang 노드 애플리케이션 구성 파일에 넣어 애플리케이션 시작시 HTTP 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d3155b2a460c30a139bad84db61b5cb13f89e622" translate="yes" xml:space="preserve">
          <source>The following items are returned:</source>
          <target state="translated">다음 품목이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cd7738cf632ddaa8eb52ecadbb7505cd9d32c89a" translate="yes" xml:space="preserve">
          <source>The following items are valid:</source>
          <target state="translated">다음 항목이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d92f3821629cd1061963d687bd668819ef18ef41" translate="yes" xml:space="preserve">
          <source>The following line defines a regular expression that will recognize a call to a function that does a garbage collection:</source>
          <target state="translated">다음 줄은 가비지 수집을 수행하는 함수에 대한 호출을 인식하는 정규식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4561a64f009cfbd6722c632e8eb5a471d1923a59" translate="yes" xml:space="preserve">
          <source>The following list details the application versions that were part of OTP 17.0. If the normal part of an application version number compares as smaller than the corresponding application version in the list, the version number does not adhere to the version scheme introduced in OTP 17.0 and is to be considered as not having an order against versions used as of OTP 17.0.</source>
          <target state="translated">다음 목록은 OTP 17.0의 일부인 응용 프로그램 버전을 자세히 보여줍니다. 응용 프로그램 버전 번호의 일반 부분이 목록의 해당 응용 프로그램 버전보다 작은 경우 버전 번호는 OTP 17.0에 도입 된 버전 체계를 따르지 않으며 현재 사용 된 버전과 순서가없는 것으로 간주됩니다. OTP 17.0.</target>
        </trans-unit>
        <trans-unit id="d0920398e14dd6ebf569f67f91d59c6473d12cc4" translate="yes" xml:space="preserve">
          <source>The following macro can be used within a test case to retreive the output written to standard output.</source>
          <target state="translated">다음 매크로는 테스트 케이스 내에서 표준 출력에 기록 된 출력을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f5aff715179f741e21746f788a0d571fc3772d" translate="yes" xml:space="preserve">
          <source>The following macro directives are supplied:</source>
          <target state="translated">다음과 같은 매크로 지시문이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5caf4dc52eb6520bf2183669475a7745283e0cdb" translate="yes" xml:space="preserve">
          <source>The following macros are defined in &lt;code&gt;logger.hrl&lt;/code&gt;, which is included in a module with the directive</source>
          <target state="translated">다음 매크로는 지시문이있는 모듈에 포함 된 &lt;code&gt;logger.hrl&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="361a3fd4702c110455bbcea82ba2c037e63e708b" translate="yes" xml:space="preserve">
          <source>The following macros are defined:</source>
          <target state="translated">다음 매크로가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c28f5023d2a208f7eb90d1c1666a542586bef327" translate="yes" xml:space="preserve">
          <source>The following macros are predefined:</source>
          <target state="translated">다음 매크로가 사전 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee950191de94f676ee96776b15e0ccba25dfb73" translate="yes" xml:space="preserve">
          <source>The following macros can be used for retrieving parts of Erlang terms. None of these do any type checking. Results are undefined if you pass an &lt;code&gt;ETERM*&lt;/code&gt; containing the wrong type. For example, passing a tuple to &lt;code&gt;ERL_ATOM_PTR()&lt;/code&gt; likely results in garbage.</source>
          <target state="translated">Erlang 용어의 일부를 검색하는 데 다음 매크로를 사용할 수 있습니다. 이들 중 어느 것도 유형 검사를 수행하지 않습니다. 잘못된 유형을 포함 하는 &lt;code&gt;ETERM*&lt;/code&gt; 을 전달하면 결과가 정의되지 않습니다 . 예를 들어, 튜플을 &lt;code&gt;ERL_ATOM_PTR()&lt;/code&gt; 전달하면 가비지가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e5655e09259732c78235fc15eeeb16532c8c59" translate="yes" xml:space="preserve">
          <source>The following macros can make tests more compact and readable:</source>
          <target state="translated">다음 매크로는 테스트를보다 간결하고 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca8309f3b4453ebe12d39150b4c1a41828a11c5" translate="yes" xml:space="preserve">
          <source>The following matches &lt;code&gt;Expr1&lt;/code&gt;, a pattern, against &lt;code&gt;Expr2&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Expr2&lt;/code&gt; 에 대한 패턴 인 &lt;code&gt;Expr1&lt;/code&gt; 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="b69739288091f88fd2e2b7df4c33b95efbcb7de9" translate="yes" xml:space="preserve">
          <source>The following matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;:</source>
          <target state="translated">다음은 &quot;bar&quot;다음에 나오는 &quot;foo&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="484da9e33049d8639a65d77742562fb2909ccd89" translate="yes" xml:space="preserve">
          <source>The following matches exactly eight digits:</source>
          <target state="translated">다음은 정확히 8 자리와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a06f765490e0bde0129ff3bc5255ac6d9e037e52" translate="yes" xml:space="preserve">
          <source>The following matchings are performed:</source>
          <target state="translated">다음 일치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="10508667a9f0cb2b801a082330c255eed8059206" translate="yes" xml:space="preserve">
          <source>The following menu items apply to the currently selected process, provided it is stopped at a breakpoint (for details, see section &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">다음 메뉴 항목은 중단 점에서 중지 된 경우 현재 선택된 프로세스에 적용됩니다 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="012b9ddb6f5b2f9ff9b23f710bee122c826518c8" translate="yes" xml:space="preserve">
          <source>The following menu items apply to the currently selected process:</source>
          <target state="translated">다음 메뉴 항목은 현재 선택된 프로세스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="961db581de293dbe681aab0fe7f1fa5413883ae0" translate="yes" xml:space="preserve">
          <source>The following message is sent to fred's client:</source>
          <target state="translated">다음 메시지는 fred의 클라이언트에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="040a3190564c92ea22bf0b64f131001c6c8e6bcc" translate="yes" xml:space="preserve">
          <source>The following message is sent to peter's client:</source>
          <target state="translated">다음 메시지가 peter의 클라이언트에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="46e910fb5b7dc40614e76e8f199ed8c133275031" translate="yes" xml:space="preserve">
          <source>The following message is taken care of by the &lt;code&gt;ssh_client_channel&lt;/code&gt; behavior.</source>
          <target state="translated">다음 메시지는 &lt;code&gt;ssh_client_channel&lt;/code&gt; 작동 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="568021cb728093af7ccf7e34bcf43fc6d465a610" translate="yes" xml:space="preserve">
          <source>The following message is taken care of by the &lt;code&gt;ssh_server_channel&lt;/code&gt; behavior.</source>
          <target state="translated">다음 메시지는 &lt;code&gt;ssh_server_channel&lt;/code&gt; 작동 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="95574b85a29dc16b146c7d05b6e10a7f4673d155" translate="yes" xml:space="preserve">
          <source>The following message is used to report that a response to a request has been received. The only request an agent can send is an Inform-Request.</source>
          <target state="translated">다음 메시지는 요청에 대한 응답이 수신되었음을보고하는 데 사용됩니다. 상담원이 보낼 수있는 유일한 요청은 정보 요청입니다.</target>
        </trans-unit>
        <trans-unit id="0c7528a0e8b223caeddcbcb738daf3c373f6236b" translate="yes" xml:space="preserve">
          <source>The following options are accepted by &lt;code&gt;&lt;a href=&quot;#cursor-2&quot;&gt;cursor/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#eval-2&quot;&gt;eval/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#fold-4&quot;&gt;fold/4&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cursor-2&quot;&gt;cursor/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#eval-2&quot;&gt;eval/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#fold-4&quot;&gt;fold/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt; 에서는 다음 옵션이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="61183e21017b0486797e22d4c6cd3d34960e2bbe" translate="yes" xml:space="preserve">
          <source>The following options are also available, but their use is not recommended (they are mostly for Dialyzer developers and internal debugging):</source>
          <target state="translated">다음 옵션도 사용할 수 있지만 사용하지 않는 것이 좋습니다 (대부분 Dialyzer 개발자 및 내부 디버깅 용).</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd679e7b65020adaa7caadfb8cc5ecd8137541b1" translate="yes" xml:space="preserve">
          <source>The following options are client-specific or have a slightly different meaning in the client than in the server:</source>
          <target state="translated">다음 옵션은 클라이언트마다 다르거 나 클라이언트와 서버에서 약간 다른 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="43fc95d7126c192227c57609b602277d7d9fc9c6" translate="yes" xml:space="preserve">
          <source>The following options are relevant for execution:</source>
          <target state="translated">다음 옵션은 실행과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08de76658d5ff2a86a979ad65f0c82faad76c53" translate="yes" xml:space="preserve">
          <source>The following options are server-specific or have a slightly different meaning in the server than in the client:</source>
          <target state="translated">다음 옵션은 서버마다 다르거 나 서버에서 클라이언트와 약간 다른 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="05f80f80cb76aee8e2eb49065b6adb6528a602a4" translate="yes" xml:space="preserve">
          <source>The following options are valid for specifying an SSH/SFTP connection (that is, can be used as configuration elements):</source>
          <target state="translated">다음 옵션은 SSH / SFTP 연결을 지정하는 데 유효합니다 (즉, 구성 요소로 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="64236fe6def7f266116ddf3fd4dbff2f206d4ac0" translate="yes" xml:space="preserve">
          <source>The following options can also be specified with the suite information list:</source>
          <target state="translated">제품군 정보 목록으로 다음 옵션을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="043cc144ef71fec58f8bf8029dbf8e2faa8691c0" translate="yes" xml:space="preserve">
          <source>The following options can be given:</source>
          <target state="translated">다음 옵션이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f19a5edc418a6bcc2f47d78030913af7ccd1058" translate="yes" xml:space="preserve">
          <source>The following options can be used:</source>
          <target state="translated">다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c58ec5e85924908f7ac6436290b127a355d50e" translate="yes" xml:space="preserve">
          <source>The following options have the same meaning in the client and the server:</source>
          <target state="translated">다음 옵션은 클라이언트와 서버에서 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cc3e03d64e601199200fd4b43567e38970933b0e" translate="yes" xml:space="preserve">
          <source>The following options modify the defaults for the extraction as follows:</source>
          <target state="translated">다음 옵션은 추출의 기본값을 다음과 같이 수정합니다.</target>
        </trans-unit>
        <trans-unit id="ce8906ae4045d2d535cd313e6ec00213370b53c4" translate="yes" xml:space="preserve">
          <source>The following options must be present:</source>
          <target state="translated">다음과 같은 옵션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a2f1d45ea56db7e397408b134364d0f8afeb1b3" translate="yes" xml:space="preserve">
          <source>The following output is shown:</source>
          <target state="translated">다음과 같은 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e25b43e0cc5f60f33a4f8cad836e1610d7400d5" translate="yes" xml:space="preserve">
          <source>The following pair is returned for halt logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 모드 에서 열린 정지 로그에 대해 다음 쌍이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="c33b12b3e0b9d36e7372996a4a7abaf00697933a" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for all logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 모드로 열린 모든 로그에 대해 다음 쌍이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="7611c3aa913240353c120613c97a195274c20308" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for all logs:</source>
          <target state="translated">모든 로그에 대해 다음 쌍이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="91a838c6cf493f03c500bbdbcdd502edf542e0fe" translate="yes" xml:space="preserve">
          <source>The following pairs are returned for wrap logs opened in &lt;code&gt;read_write&lt;/code&gt; mode:</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 모드 에서 열린 랩 로그에 대해 다음 쌍이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="224537c90399cde228dbede4c53cbc30f714374c" translate="yes" xml:space="preserve">
          <source>The following parameters can be specified for each Erlang service:</source>
          <target state="translated">각 Erlang 서비스에 대해 다음 매개 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7561aff36c4e31e9b40cf0d53c766582f8727228" translate="yes" xml:space="preserve">
          <source>The following parameters represents the SNMP configuration files &lt;code&gt;context.conf&lt;/code&gt;, &lt;code&gt;standard.conf&lt;/code&gt;, &lt;code&gt;community.conf&lt;/code&gt;, &lt;code&gt;vacm.conf&lt;/code&gt;, &lt;code&gt;usm.conf&lt;/code&gt;, &lt;code&gt;notify.conf&lt;/code&gt;, &lt;code&gt;target_addr.conf&lt;/code&gt;, and &lt;code&gt;target_params.conf&lt;/code&gt;. Notice that all values in &lt;code&gt;agent.conf&lt;/code&gt; can be modified by the parameters listed above. All these configuration files have default values set by the &lt;code&gt;SNMP&lt;/code&gt; application. These values can be overridden by suppling a list of valid configuration values or a file located in the test suites data directory, which can produce a list of valid configuration values if you apply function &lt;code&gt;file:consult/1&lt;/code&gt; to the file.</source>
          <target state="translated">다음 매개 변수는 SNMP 구성 파일 &lt;code&gt;context.conf&lt;/code&gt; , &lt;code&gt;standard.conf&lt;/code&gt; , &lt;code&gt;community.conf&lt;/code&gt; , &lt;code&gt;vacm.conf&lt;/code&gt; , &lt;code&gt;usm.conf&lt;/code&gt; , &lt;code&gt;notify.conf&lt;/code&gt; , &lt;code&gt;target_addr.conf&lt;/code&gt; 및 &lt;code&gt;target_params.conf&lt;/code&gt; 를 나타 냅니다. &lt;code&gt;agent.conf&lt;/code&gt; 의 모든 값은 위에 나열된 매개 변수로 수정할 수 있습니다. 이러한 모든 구성 파일에는 &lt;code&gt;SNMP&lt;/code&gt; 응용 프로그램에서 설정 한 기본값이 있습니다 . 이 값은 유효한 구성 값 목록 또는 테스트 스위트 데이터 디렉토리에있는 파일을 제공하여 대체 할 수 있습니다. 함수 &lt;code&gt;file:consult/1&lt;/code&gt; 을 적용하면 유효한 구성 값 목록이 생성 될 수 있습니다 . 파일에.</target>
        </trans-unit>
        <trans-unit id="cf9b8bf83a4a013f2ea8d7a63a8c6eceb1e8ce5f" translate="yes" xml:space="preserve">
          <source>The following pattern matches &quot;foo&quot; preceded by three digits and any three characters that are not &quot;999&quot;:</source>
          <target state="translated">다음 패턴은 &quot;foo&quot;앞에 세 자리 숫자와 &quot;999&quot;가 아닌 세 문자가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b6c387fc7cb1c2a0aaf335c75b4b32deefd1c2b6" translate="yes" xml:space="preserve">
          <source>The following picture gives an overview of the mechanism to select an MIB view:</source>
          <target state="translated">다음 그림은 MIB보기를 선택하는 메커니즘에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="343b7de69e7382fea1083cf8cb82178662515737" translate="yes" xml:space="preserve">
          <source>The following picture illustrates the idea:</source>
          <target state="translated">다음 그림은 아이디어를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4b30adf5dd015c5f072d818ec045884b44dff621" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; User's Guide:</source>
          <target state="translated">&lt;code&gt;Event Tracer (ET)&lt;/code&gt; 사용자 안내서 의 자료를 이해하려면 다음 전제 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f494d18baeb5626e63a43266d42eed96b8ed12a2" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the Megaco User's Guide:</source>
          <target state="translated">Megaco 사용 설명서의 내용을 이해하려면 다음 전제 조건이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1cbd57540b48d0efa55b14338c8830cec00d8547" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the Reltool User's Guide:</source>
          <target state="translated">Reltool 사용자 안내서의 자료를 이해하려면 다음 전제 조건이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7e4d733e362ec6903442fab3ca35dcd536f3cdbe" translate="yes" xml:space="preserve">
          <source>The following prerequisites is required for understanding the material in the SNMP User's Guide:</source>
          <target state="translated">SNMP 사용 설명서의 내용을 이해하려면 다음 전제 조건이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fab1a3516c76bbdd3d05df3eae1d2f555b42050e" translate="yes" xml:space="preserve">
          <source>The following procedure does not require root privilege:</source>
          <target state="translated">다음 절차에는 루트 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8602668ad76f501ac94f891d7bfbf36be343c4f" translate="yes" xml:space="preserve">
          <source>The following program illustrates the different ways of creating funs:</source>
          <target state="translated">다음 프로그램은 재미를 만드는 여러 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dbcee6e28420ee50b59b118c6bd9505eaeb1f3e3" translate="yes" xml:space="preserve">
          <source>The following program module creates and populates previously defined tables:</source>
          <target state="translated">다음 프로그램 모듈은 이전에 정의 된 테이블을 작성하고 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="872226e20506f4791f4924b86b65d0e2ff5aeff1" translate="yes" xml:space="preserve">
          <source>The following queries are accepted from remote nodes:</source>
          <target state="translated">원격 노드에서 다음 쿼리가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="34fcb8ab715f637bf664ee99fb64aae24ae2711f" translate="yes" xml:space="preserve">
          <source>The following record definitions can be created:</source>
          <target state="translated">다음과 같은 레코드 정의를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aba38102e6596c004eb1b74efe69102547563ee" translate="yes" xml:space="preserve">
          <source>The following records are generated because of type &lt;code&gt;Emb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Emb&lt;/code&gt; 유형으로 인해 다음 레코드가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="52b8b7242e195bbd29d16d5919c21b7b689163ef" translate="yes" xml:space="preserve">
          <source>The following records used by xmerl to save the parsed data are defined in &lt;code&gt;xmerl.hrl&lt;/code&gt;</source>
          <target state="translated">분석 된 데이터를 저장하기 위해 xmerl이 사용하는 다음 레코드는 xmerl.hrl에 정의되어 &lt;code&gt;xmerl.hrl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a7943f947fe72299ad61ae324cdc2eb219124" translate="yes" xml:space="preserve">
          <source>The following representations control how and where tests are executed:</source>
          <target state="translated">다음 표현은 테스트 실행 방법 및 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="86bacadf1ea90a3c97d82c63773f210e42c2a214" translate="yes" xml:space="preserve">
          <source>The following representations specify fixture handling for test sets:</source>
          <target state="translated">다음 표현은 테스트 세트에 대한 조명기 처리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="010a5b84d478f42d2d6af978a84f08199f613d86" translate="yes" xml:space="preserve">
          <source>The following requirements apply to the &lt;code&gt;.app&lt;/code&gt; file for an included application:</source>
          <target state="translated">포함 된 응용 프로그램 의 &lt;code&gt;.app&lt;/code&gt; 파일 에는 다음 요구 사항이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="47012e55fe1825d2922f7d5fb219850e8c4ce7ee" translate="yes" xml:space="preserve">
          <source>The following runs a test executing &lt;code&gt;tc12&lt;/code&gt; in &lt;code&gt;top1&lt;/code&gt; and any subgroup under &lt;code&gt;top1&lt;/code&gt; where it can be found (&lt;code&gt;sub11&lt;/code&gt; and &lt;code&gt;sub121&lt;/code&gt;):</source>
          <target state="translated">다음은 실행 테스트 실행 &lt;code&gt;tc12&lt;/code&gt; 에서 &lt;code&gt;top1&lt;/code&gt; 와 아래의 모든 하위 그룹 &lt;code&gt;top1&lt;/code&gt; 이 찾을 수 있습니다 ( &lt;code&gt;sub11&lt;/code&gt; 및 &lt;code&gt;sub121&lt;/code&gt; 을 ) :</target>
        </trans-unit>
        <trans-unit id="0e90b96a7f25790f2708f620c0e643b1c7f52c18" translate="yes" xml:space="preserve">
          <source>The following script illustrates a modification where the node is given the name &lt;code&gt;cp1&lt;/code&gt;, and where the environment variables &lt;code&gt;HEART_COMMAND&lt;/code&gt; and &lt;code&gt;TERM&lt;/code&gt; have been added to the previous script:</source>
          <target state="translated">다음 스크립트는 노드에 이름이 &lt;code&gt;cp1&lt;/code&gt; 이고 환경 변수 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 및 &lt;code&gt;TERM&lt;/code&gt; 이 이전 스크립트에 추가 된 수정을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5db13a72ee33e776ce2ddcad2d3b2330d02936db" translate="yes" xml:space="preserve">
          <source>The following script illustrates the behaviour of the program:</source>
          <target state="translated">다음 스크립트는 프로그램의 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4cb6bb01c4a2fc6f1d31fffabe3ea35bf47bbd99" translate="yes" xml:space="preserve">
          <source>The following script illustrates the default behaviour of the program:</source>
          <target state="translated">다음 스크립트는 프로그램의 기본 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1730c3be7b670e5f6ed8dc96c7503a465a16bfb5" translate="yes" xml:space="preserve">
          <source>The following searches &lt;code&gt;top1&lt;/code&gt; and all its subgroups for &lt;code&gt;tc16&lt;/code&gt; resulting in that this test case executes in group &lt;code&gt;sub121&lt;/code&gt;:</source>
          <target state="translated">다음 검색 &lt;code&gt;top1&lt;/code&gt; 및 모든 하위 그룹 &lt;code&gt;tc16&lt;/code&gt; 결과 그룹이 테스트 케이스 실행하는 &lt;code&gt;sub121&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="526a47fb0328941b790c466199e779b1931bd0e8" translate="yes" xml:space="preserve">
          <source>The following section describes the mandatory and optional test suite functions that &lt;code&gt;Common Test&lt;/code&gt; calls during test execution. For more details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">다음 섹션에서는 테스트 실행 중에 &lt;code&gt;Common Test&lt;/code&gt; 가 호출 하는 필수 및 선택적 테스트 스위트 기능에 대해 설명합니다 . 자세한 내용 은 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;write_test_chapter&quot;&gt;Writing Test Suites&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72c1a7ce03d50e78be89c8cc10dbc16d75c4a19c" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material for the regular expressions used by this module. The information is based on the PCRE documentation, with changes where this module behaves differently to the PCRE library.</source>
          <target state="translated">다음 섹션에는이 모듈에서 사용되는 정규식에 대한 참조 자료가 포함되어 있습니다. 이 정보는 PCRE 문서를 기반으로하며이 모듈이 PCRE 라이브러리와 다르게 작동하는 위치를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="83810d4821d49c1738acda1b065dd05f79bc8cd1" translate="yes" xml:space="preserve">
          <source>The following sections deal with target systems with different requirements of functionality:</source>
          <target state="translated">다음 섹션에서는 기능 요구 사항이 다른 대상 시스템을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="38eecd6e67f72292d41c686c8caab1a223f8a8a9" translate="yes" xml:space="preserve">
          <source>The following sections describe how the instrumentation functions should be defined in Erlang for the different operations. In the following, &lt;code&gt;RowIndex&lt;/code&gt; is a list of key values for the table, and &lt;code&gt;Column&lt;/code&gt; is a column number.</source>
          <target state="translated">다음 섹션에서는 다양한 작업을 위해 Erlang에서 계측 기능을 정의하는 방법에 대해 설명합니다. 다음에서 &lt;code&gt;RowIndex&lt;/code&gt; 는 테이블의 키 값 목록이고 &lt;code&gt;Column&lt;/code&gt; 은 열 번호입니다.</target>
        </trans-unit>
        <trans-unit id="93b41da5ab42cf67eae696be1649b8c0efaf1bfc" translate="yes" xml:space="preserve">
          <source>The following sections describe how to use CTHs, when they are run, and how to manipulate the test results in a CTH.</source>
          <target state="translated">다음 섹션에서는 CTH 사용 방법, 실행시기 및 CTH에서 테스트 결과를 조작하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="31ea898329f4b3682826cd0bafcd93ad163d085b" translate="yes" xml:space="preserve">
          <source>The following sections describe sequential tracing and its most fundamental concepts.</source>
          <target state="translated">다음 섹션에서는 순차적 추적 및 가장 기본적인 개념에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9600ad9c1d4332036b9e8528fa9289370114665e" translate="yes" xml:space="preserve">
          <source>The following sections describe some of the fields in the information tabs. These are fields that do not exist in the raw crashdump, or in some way differ from the fields in the raw crashdump. For details about other fields, see the &lt;code&gt;ERTS User's Guide&lt;/code&gt;, section &quot;How to interpret the Erlang crash dumps&quot;. That section can also be opened from the &lt;strong&gt;Help&lt;/strong&gt; menu in the main window. There are also links from the following sections to related information in &quot;How to interpret the Erlang crash dumps&quot;.</source>
          <target state="translated">다음 섹션에서는 정보 탭의 일부 필드에 대해 설명합니다. 이는 원시 크래시 덤프에 존재하지 않거나 어떤 방식 으로든 원시 크래시 덤프의 필드와 다른 필드입니다. 다른 필드에 대한 자세한 내용은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; &quot;Erlang 크래시 덤프 해석 방법&quot;섹션을 참조하십시오 . 기본 창의 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴에서 해당 섹션을 열 수도 있습니다 . 다음 섹션의 &quot;Erlang 크래시 덤프 해석 방법&quot;에있는 관련 정보로 연결되는 링크도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e038c99195f68fa297f2e5f9e78c69595a14730e" translate="yes" xml:space="preserve">
          <source>The following sections describe the mandatory and optional CTH functions that &lt;code&gt;Common Test&lt;/code&gt; calls during test execution. For more details, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">다음 섹션에서는 테스트 실행 중 &lt;code&gt;Common Test&lt;/code&gt; 호출 하는 필수 및 선택적 CTH 기능에 대해 설명합니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ca82394dc00f1e6d08913e914b59a46cf6c2484" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each metacharacter.</source>
          <target state="translated">다음 섹션에서는 각 메타 문자 사용에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="57bd03425adcf43ca596408a2b02f2936cfeb5dd" translate="yes" xml:space="preserve">
          <source>The following sections describe these steps.</source>
          <target state="translated">다음 섹션에서는 이러한 단계를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ef3caea09c20221894e510d93d0376e9f32ba13c" translate="yes" xml:space="preserve">
          <source>The following sections show some examples of how to profile with Fprof. See also the reference manual &lt;code&gt;&lt;a href=&quot;fprof&quot;&gt;fprof(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 섹션에서는 Fprof로 프로파일 링하는 방법에 대한 몇 가지 예를 보여줍니다. 참조 설명서 &lt;code&gt;&lt;a href=&quot;fprof&quot;&gt;fprof(3)&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98275a3598f57cab63cd60d26cf4b95397a5db2f" translate="yes" xml:space="preserve">
          <source>The following sections show some examples of profiling with &lt;code&gt;cprof&lt;/code&gt;. See also &lt;code&gt;&lt;a href=&quot;cprof&quot;&gt;cprof(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 섹션에서는 &lt;code&gt;cprof&lt;/code&gt; 로 프로파일 링하는 몇 가지 예를 보여줍니다 . &lt;code&gt;&lt;a href=&quot;cprof&quot;&gt;cprof(3)&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3346c4bffa9bbaca48b8099eae111ab7c83c1879" translate="yes" xml:space="preserve">
          <source>The following sections show some features of Xref, beginning with a module check and a predefined analysis. Then follow examples that can be skipped on the first reading; not all of the concepts used are explained, and it is assumed that the &lt;code&gt;&lt;a href=&quot;xref&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; has been at least skimmed.</source>
          <target state="translated">다음 섹션에서는 모듈 확인 및 사전 정의 된 분석으로 시작하는 외부 참조의 일부 기능을 보여줍니다. 그런 다음 첫 번째 판독에서 건너 뛸 수있는 예를 따르십시오. 사용 된 모든 개념이 설명되는 것은 아니며, &lt;code&gt;&lt;a href=&quot;xref&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 이 최소한 스키밍 된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="4f224d7ff4347a5d76be2a01609f9bb95ab48bc8" translate="yes" xml:space="preserve">
          <source>The following sequence of calls fails:</source>
          <target state="translated">다음과 같은 호출 순서는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1024b17ae9d252d4afcd5d6cdfbf0b7552256b7e" translate="yes" xml:space="preserve">
          <source>The following sequence of calls may fail:</source>
          <target state="translated">다음 호출 순서가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f684598ccd6c3370add4d7675b782860903e544" translate="yes" xml:space="preserve">
          <source>The following sequence works, as the call to &lt;code&gt;repair_continuation/2&lt;/code&gt; reestablishes the (deliberately) invalidated continuation &lt;code&gt;Broken&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;repair_continuation/2&lt;/code&gt; 에 대한 호출 이 (고의적으로) 무효화 된 연속 &lt;code&gt;Broken&lt;/code&gt; 재설정 함에 따라 다음 순서가 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="36de49fc63b14d805bc91f85891a3ad4b6c71807" translate="yes" xml:space="preserve">
          <source>The following sequence works, as the call to &lt;code&gt;repair_continuation/2&lt;/code&gt; reestablishes the &lt;code&gt;MaybeBroken&lt;/code&gt; continuation.</source>
          <target state="translated">&lt;code&gt;repair_continuation/2&lt;/code&gt; 에 대한 호출 이 &lt;code&gt;MaybeBroken&lt;/code&gt; 연속을 다시 설정하므로 다음 시퀀스가 ​​작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d8d34878ccc7af10841358fe32d20c8e85617519" translate="yes" xml:space="preserve">
          <source>The following session with the Erlang shell shows how to load the &lt;code&gt;FRUITS&lt;/code&gt; database:</source>
          <target state="translated">Erlang 쉘을 사용한 다음 세션에서는 &lt;code&gt;FRUITS&lt;/code&gt; 데이터베이스 를로드하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1ca2b9cadd413c828114f5fdadb155510f45b89f" translate="yes" xml:space="preserve">
          <source>The following shell interaction starts &lt;code&gt;Mnesia&lt;/code&gt; and initializes the schema for the &lt;code&gt;Company&lt;/code&gt; database:</source>
          <target state="translated">다음 셸 상호 작용은 &lt;code&gt;Mnesia&lt;/code&gt; 를 시작 하고 &lt;code&gt;Company&lt;/code&gt; 데이터베이스 의 스키마를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="3e56ec35aa2570200adfb4251b42d9a7a4dbc048" translate="yes" xml:space="preserve">
          <source>The following shows an example &lt;code&gt;.rel&lt;/code&gt; file with TLS added:</source>
          <target state="translated">다음은 TLS가 추가 된 &lt;code&gt;.rel&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e94749126c9966bcf63f22766109b91add03d6be" translate="yes" xml:space="preserve">
          <source>The following shows examples of how UTF-8 encoded binaries can be created and manipulated:</source>
          <target state="translated">다음은 UTF-8로 인코딩 된 바이너리를 만들고 조작하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="53b230af1628e298070b4609c7e79b754d5b0d07" translate="yes" xml:space="preserve">
          <source>The following shows how the compiler can be called from the Erlang shell:</source>
          <target state="translated">다음은 Erlang 쉘에서 컴파일러를 호출하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="729768340129de2ea35b78f26817f116e7bf52b6" translate="yes" xml:space="preserve">
          <source>The following simple code illustrates the relationship between the simplified access functions used in most of the examples and their more flexible counterparts:</source>
          <target state="translated">다음의 간단한 코드는 대부분의 예제에서 사용 된 단순화 된 액세스 기능과보다 유연한 대응 기능 간의 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b84b8caa8b26cb602514d1eab6fc03a38ae48762" translate="yes" xml:space="preserve">
          <source>The following small module is used in the subsequent example:</source>
          <target state="translated">다음 예제에서는 다음과 같은 작은 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1dfc37e671a01a444893fce16128adaeffd6fa" translate="yes" xml:space="preserve">
          <source>The following steps are needed to get a running agent:</source>
          <target state="translated">실행중인 에이전트를 가져 오려면 다음 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc08bddc5161d849d8adaf8a442d077969754d3f" translate="yes" xml:space="preserve">
          <source>The following steps are needed to get the manager running:</source>
          <target state="translated">관리자를 실행하려면 다음 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a39039b95c7681d9ca35239506450ca1ffc99ef1" translate="yes" xml:space="preserve">
          <source>The following symbols are always defined.</source>
          <target state="translated">다음 기호는 항상 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f7bbf8b199c9798edd4d7f0d37698a1bff7dfbe7" translate="yes" xml:space="preserve">
          <source>The following table describes the current state of standards compliance for TLS 1.3.</source>
          <target state="translated">다음 표는 TLS 1.3에 대한 현재 표준 준수 상태를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fa6e913607cc215db5650f46601c1682dec9a4c4" translate="yes" xml:space="preserve">
          <source>The following tags appears in the list:</source>
          <target state="translated">다음 태그가 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="59f95e04d57dcd84839504590aa3ea9df899aa69" translate="yes" xml:space="preserve">
          <source>The following tags have special meaning:</source>
          <target state="translated">다음 태그는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e75dc33e0130efecbbf3b0c117aa1a4317b0d14" translate="yes" xml:space="preserve">
          <source>The following terms are allowed in a cover specification file:</source>
          <target state="translated">표지 사양 파일에는 다음 용어가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="082dcb2df904c716cc9a3e85c660d6af2e65ff42" translate="yes" xml:space="preserve">
          <source>The following top level &lt;code&gt;options&lt;/code&gt; are supported:</source>
          <target state="translated">다음과 같은 최상위 &lt;code&gt;options&lt;/code&gt; 이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="49a42c98aae1a012fca04ff4fc1c26473f67efa7" translate="yes" xml:space="preserve">
          <source>The following topics are included:</source>
          <target state="translated">다음과 같은 주제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="05245f82bf6574a4a5eff794c54d89c9d6171eb9" translate="yes" xml:space="preserve">
          <source>The following topics are not treated in this section:</source>
          <target state="translated">이 항목에서는 다음 주제를 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab7564645416f18d8a1c44a537bed7227fcf3ddd" translate="yes" xml:space="preserve">
          <source>The following trace output is received during test:</source>
          <target state="translated">테스트 중에 다음과 같은 추적 출력이 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="b466650d4111c63d9300f7fbae0b73cc83cacf0c" translate="yes" xml:space="preserve">
          <source>The following two Kernel configuration parameters affect the behavior of all sockets opened on an Erlang node:</source>
          <target state="translated">다음 두 커널 구성 매개 변수는 Erlang 노드에서 열린 모든 소켓의 작동에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4a11518ecf3b3d71056ddbfd18678d2117872201" translate="yes" xml:space="preserve">
          <source>The following two calls give the same result (but certainly not the same execution time):</source>
          <target state="translated">다음 두 호출은 동일한 결과를 제공하지만 반드시 동일한 실행 시간은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5507869e7948c09fc8040111e6b2cadd35e4aff0" translate="yes" xml:space="preserve">
          <source>The following two directories must exist in the system to run the agent:</source>
          <target state="translated">에이전트를 실행하려면 시스템에 다음 두 디렉토리가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="113cb904554a59290d2e213118f8d8428037b8fb" translate="yes" xml:space="preserve">
          <source>The following two functions can be used to retrieve system information. For details, see the Reference Manual.</source>
          <target state="translated">다음 두 가지 기능을 사용하여 시스템 정보를 검색 할 수 있습니다. 자세한 내용은 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71cd872babc8d6113efd7cead6cf75e880db8ea3" translate="yes" xml:space="preserve">
          <source>The following two functions manipulate indexes on existing tables:</source>
          <target state="translated">다음 두 함수는 기존 테이블의 인덱스를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="706b90dd5c946a37fcc3ef255278e31f7c9293de" translate="yes" xml:space="preserve">
          <source>The following two notations are available for representation of &lt;code&gt;BIT STRING&lt;/code&gt; values in Erlang and as input to the encode functions:</source>
          <target state="translated">Erlang에서 &lt;code&gt;BIT STRING&lt;/code&gt; 값 을 표시 하고 인코딩 함수에 대한 입력으로 다음 두 가지 표기법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9929e878110d22fef5c962cd4c16eef48be74d8c" translate="yes" xml:space="preserve">
          <source>The following two pairs of functions support this scenario:</source>
          <target state="translated">다음 두 쌍의 기능이이 시나리오를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="09ba41aca160585c0b08fc3e3fe758e0deed5098" translate="yes" xml:space="preserve">
          <source>The following type definitions are used by more than one function in the FTP client API:</source>
          <target state="translated">다음 유형 정의는 FTP 클라이언트 API에서 둘 이상의 함수에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="04de34ef25f9ef07a1ca24a2f09beb4aec1f11d5" translate="yes" xml:space="preserve">
          <source>The following types are defined at the moment:</source>
          <target state="translated">현재 다음 유형이 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9226ce7513015120a190ef4af2c57e38cf1718d8" translate="yes" xml:space="preserve">
          <source>The following values are allowed for &lt;code&gt;Key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 에는 다음 값이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c84aa8502d90e7ba6f618344ec9f0990938b08f" translate="yes" xml:space="preserve">
          <source>The following verb causes a matching failure, forcing backtracking to occur. It is equivalent to (?!) but easier to read.</source>
          <target state="translated">다음 동사는 일치하는 실패를 일으켜 역 추적을 강제합니다. (?!)와 동일하지만 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c74b31c10443669b849931e80db4cb844acc7e6d" translate="yes" xml:space="preserve">
          <source>The following verb causes a skip to the next innermost alternative when backtracking reaches it. That is, it cancels any further backtracking within the current alternative.</source>
          <target state="translated">다음 동사는 역 추적에 도달하면 다음으로 가장 안쪽에있는 대안으로 건너 뜁니다. 즉, 현재 대안 내에서 추가 역 추적을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="3626ed56739d6ce7e205e1a6154059baf311b051" translate="yes" xml:space="preserve">
          <source>The following verb causes the match to fail at the current starting position in the subject if there is a later matching failure that causes backtracking to reach it:</source>
          <target state="translated">다음 동사는 역 추적에 도달하는 이후의 일치 실패가있는 경우 주제의 현재 시작 위치에서 일치를 실패시킵니다.</target>
        </trans-unit>
        <trans-unit id="20e32c99b23fb1cb8aa4ff4619bdeb76fe057cfe" translate="yes" xml:space="preserve">
          <source>The following verb, when specified without a name, is like (*PRUNE), except that if the pattern is unanchored, the &quot;bumpalong&quot; advance is not to the next character, but to the position in the subject where (*SKIP) was encountered.</source>
          <target state="translated">이름없이 지정 될 때 다음 동사는 패턴이 고정되지 않은 경우 &quot;bumpalong&quot;진행이 다음 문자가 아니라 (* SKIP) 인 주제의 위치에 있다는 점을 제외하고는 (* PRUNE)과 같습니다. 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="56e82a4845f59e054a6c2a8f1874cfef875f8736" translate="yes" xml:space="preserve">
          <source>The following verb, which must not be followed by a name, causes the whole match to fail outright if there is a later matching failure that causes backtracking to reach it. Even if the pattern is unanchored, no further attempts to find a match by advancing the starting point take place.</source>
          <target state="translated">뒤에 나오는 이름이 없어야하는 다음 동사는 역 추적에 도달하는 나중에 일치하는 실패가있는 경우 전체 일치를 완전히 실패하게합니다. 패턴이 고정되어 있지 않더라도 시작점을 진행하여 더 이상 매치를 찾으려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d2ee15663a5b3e2b4b9ab4b42fcb763860ca710" translate="yes" xml:space="preserve">
          <source>The following verbs act as soon as they are encountered. They must not be followed by a name.</source>
          <target state="translated">다음 동사는 마주 치면 바로 작동합니다. 이름 뒤에는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc631f8808db5a059db58a11cb23a25b194b9bc" translate="yes" xml:space="preserve">
          <source>The following verbs do nothing when they are encountered. Matching continues with what follows, but if there is no subsequent match, causing a backtrack to the verb, a failure is forced. That is, backtracking cannot pass to the left of the verb. However, when one of these verbs appears inside an atomic group or an assertion that is true, its effect is confined to that group, as once the group has been matched, there is never any backtracking into it. In this situation, backtracking can &quot;jump back&quot; to the left of the entire atomic group or assertion. (Remember also, as stated above, that this localization also applies in subroutine calls.)</source>
          <target state="translated">다음 동사는 마주 칠 때 아무 것도하지 않습니다. 일치하는 내용은 다음과 계속되지만 후속 일치 항목이 없으면 동사에 대한 역 추적을 유발하면 실패가 발생합니다. 즉, 역 추적은 동사의 왼쪽으로 전달할 수 없습니다. 그러나 이러한 동사 중 하나가 원자 그룹 또는 어설 션 내에 표시되면 그룹이 일치하면 그 역효과가 해당 그룹에 국한되지 않습니다. 이 상황에서 역 추적은 전체 원자 그룹 또는 어설 션의 왼쪽으로 &quot;점프 백&quot;할 수 있습니다. (위에서 언급했듯이이 현지화는 서브 루틴 호출에도 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="e618ac47f63af62ceb8671ae5e22050d8ff5aec4" translate="yes" xml:space="preserve">
          <source>The following warnings and restrictions apply to the funs used in with &lt;code&gt;ets:fun2ms/1&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">다음 경고 및 제한 사항은 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 및 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 과 함께 사용되는 기능에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="58ed2789e1ec56e8739ba6ba58818f4844d3585c" translate="yes" xml:space="preserve">
          <source>The following will appear at the console on the node that started the trace client:</source>
          <target state="translated">추적 클라이언트를 시작한 노드의 콘솔에 다음이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4f6cfe143c1844487af6c9d7af979551cc8a56ef" translate="yes" xml:space="preserve">
          <source>The foreign key</source>
          <target state="translated">외래 키</target>
        </trans-unit>
        <trans-unit id="d5bbce337b986ce05bfb1074200a1cd8e6ba791d" translate="yes" xml:space="preserve">
          <source>The format and value of &lt;code&gt;FixationTime&lt;/code&gt; depends on &lt;code&gt;Item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FixationTime&lt;/code&gt; 의 형식과 값은 &lt;code&gt;Item&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="403056f7b6145ea80b76c6096562c79850393812" translate="yes" xml:space="preserve">
          <source>The format function is also optional. It is called by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; to give feedback at runtime of how the query is to be evaluated. Try to give as good feedback as possible without showing too much details. In the example, at most seven objects of the table are shown. The format function handles two cases: &lt;code&gt;all&lt;/code&gt; means that all objects of the table are traversed; &lt;code&gt;{lookup,&amp;nbsp;1,&amp;nbsp;KeyValues}&lt;/code&gt; means that the lookup function is used for looking up key values.</source>
          <target state="translated">포맷 기능도 옵션입니다. &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; 에 의해 호출되어 런타임에 쿼리 평가 방법에 대한 피드백을 제공합니다. 너무 많은 세부 사항을 표시하지 않고 가능한 한 좋은 피드백을 제공하십시오. 이 예에서는 최대 7 개의 테이블 개체가 표시됩니다. format 함수는 두 가지 경우를 처리합니다. &lt;code&gt;all&lt;/code&gt; 은 테이블의 모든 오브젝트가 순회 함을 의미합니다. &lt;code&gt;{lookup,&amp;nbsp;1,&amp;nbsp;KeyValues}&lt;/code&gt; 는 조회 기능이 키 값을 찾는 데 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a28925d546a087448d542d4ec3fe58c4d1daac9b" translate="yes" xml:space="preserve">
          <source>The format is parsable with the standard Erlang parsing tools &lt;code&gt;erl_scan&lt;/code&gt; and &lt;code&gt;erl_parse&lt;/code&gt;, &lt;code&gt;file:consult/1&lt;/code&gt; or &lt;code&gt;io:read/2&lt;/code&gt;. The parse format is not explained here - it should be easy for the interested to try it out. Note that some flags to &lt;code&gt;analyse/1&lt;/code&gt; will affect the format.</source>
          <target state="translated">형식은 표준 Erlang 구문 분석 도구 &lt;code&gt;erl_scan&lt;/code&gt; 및 &lt;code&gt;erl_parse&lt;/code&gt; , &lt;code&gt;file:consult/1&lt;/code&gt; 또는 &lt;code&gt;io:read/2&lt;/code&gt; 로 구문 분석 할 수 있습니다 . 구문 분석 형식은 여기에 설명되어 있지 않습니다. 관심있는 사용자가 쉽게 시도해 볼 수 있습니다. &lt;code&gt;analyse/1&lt;/code&gt; 에 대한 일부 플래그 는 형식에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="92dfc6d682f5117a1d9acce5f8982068227b718b" translate="yes" xml:space="preserve">
          <source>The format of &quot;System Events&quot; as defined in the man page for &lt;code&gt;sys&lt;/code&gt; has been clarified and cleaned up. Due to this, code that relied on the internal badly documented previous (before this change) format of OTP's &quot;System Events&quot;, needs to be changed.</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 의 man 페이지에 정의 된 &quot;시스템 이벤트&quot;의 형식 이 명확 해지고 정리되었습니다. 이로 인해 OTP의 &quot;시스템 이벤트&quot;의 내부 잘못 문서화 된 이전 (이 변경 전) 형식에 의존했던 코드를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd5e5f8070fec3acf0e1ec232310a61ff03f8b85" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Drive&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;Drive&lt;/code&gt; 형식 이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="dbaf4dd1e5a91b60292984d5a8e1ea127c178da5" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Listing&lt;/code&gt; depends on the operating system. On UNIX, it is typically produced from the output of the &lt;code&gt;ls -l&lt;/code&gt; shell command.</source>
          <target state="translated">&lt;code&gt;Listing&lt;/code&gt; 의 형식은 운영 체제에 따라 다릅니다. UNIX에서는 일반적으로 &lt;code&gt;ls -l&lt;/code&gt; shell 명령 의 출력에서 ​​생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a8dac735cad80fa64163e77b01f6b5b6e6b931f" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;Listing&lt;/code&gt; is a stream of filenames where each filename is separated by &amp;lt;CRLF&amp;gt; or &amp;lt;NL&amp;gt;. Contrary to function &lt;code&gt;ls&lt;/code&gt;, the purpose of &lt;code&gt;nlist&lt;/code&gt; is to enable a program to process filename information automatically.</source>
          <target state="translated">&lt;code&gt;Listing&lt;/code&gt; 의 형식은 각 파일 이름이 &amp;lt;CRLF&amp;gt; 또는 &amp;lt;NL&amp;gt;으로 구분되는 파일 이름 스트림입니다. 함수 &lt;code&gt;ls&lt;/code&gt; 와는 반대로 &lt;code&gt;nlist&lt;/code&gt; 의 목적은 프로그램이 파일 이름 정보를 자동으로 처리 할 수 ​​있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca6bda514e36415bd8dfddbfd465c752506ba14c" translate="yes" xml:space="preserve">
          <source>The format of an audit trail log text item is as follows:</source>
          <target state="translated">감사 추적 로그 텍스트 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44015ed1506dab2702bf874c622404e1cdd4a16b" translate="yes" xml:space="preserve">
          <source>The format of decoded messages and grouped AVPs in the &lt;code&gt;msg&lt;/code&gt; field of diameter_packet records and &lt;code&gt;value&lt;/code&gt; field of diameter_avp records respectively. If &lt;code&gt;record&lt;/code&gt; then a record whose definition is generated from the dictionary file in question. If &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; then a &lt;code&gt;[Name | Avps]&lt;/code&gt; pair where &lt;code&gt;Avps&lt;/code&gt; is a list of AVP name/values pairs or a map keyed on AVP names respectively. If &lt;code&gt;none&lt;/code&gt; then the atom-value message name, or &lt;code&gt;undefined&lt;/code&gt; for a Grouped AVP. See also &lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">diameter_packet 레코드 의 &lt;code&gt;msg&lt;/code&gt; 필드와 diameter_avp 레코드의 &lt;code&gt;value&lt;/code&gt; 필드에 각각 디코딩 된 메시지 및 그룹화 된 AVP의 형식입니다 . 만약 &lt;code&gt;record&lt;/code&gt; 후 그 정의 문제의 사전 파일에서 생성되는 기록을. 만약 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;map&lt;/code&gt; 다음 &lt;code&gt;[Name | Avps]&lt;/code&gt; pair 여기서 &lt;code&gt;Avps&lt;/code&gt; 는 각각 AVP 이름 / 값 쌍 또는 AVP 이름을 입력 한 맵 목록입니다. 않으면 &lt;code&gt;none&lt;/code&gt; 그 원자 값 메시지 이름 또는 &lt;code&gt;undefined&lt;/code&gt; 그룹화 된 AVP에 대한. &lt;code&gt;&lt;a href=&quot;diameter_codec#message&quot;&gt;diameter_codec:message()&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="317788b6344114efeaf6f36e9948bb10fc231c82" translate="yes" xml:space="preserve">
          <source>The format of file &lt;code&gt;.hosts.erlang&lt;/code&gt; must be one host name per line. The host names must be within quotes.</source>
          <target state="translated">파일 &lt;code&gt;.hosts.erlang&lt;/code&gt; 의 형식은 한 줄에 하나의 호스트 이름이어야합니다. 호스트 이름은 따옴표 안에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2487f5cf9c75d813920c0dba73a01025e41c80a7" translate="yes" xml:space="preserve">
          <source>The format of received events is not defined.</source>
          <target state="translated">수신 된 이벤트의 형식이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9bfd68e235d56611f777394a5db1608f345a2ba3" translate="yes" xml:space="preserve">
          <source>The format of the &lt;code&gt;otp_versions.table&lt;/code&gt; might be subject to changes during the OTP 17 release.</source>
          <target state="translated">&lt;code&gt;otp_versions.table&lt;/code&gt; 의 형식은 OTP 17 릴리스 중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="689c1f8b385b83aa3589eb65a1746eb08236ca62" translate="yes" xml:space="preserve">
          <source>The format of the configuration file is found in the &lt;code&gt;syslog.conf(5)&lt;/code&gt; manual page, by issuing the command &lt;code&gt;man syslog.conf&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 형식은 &lt;code&gt;man syslog.conf&lt;/code&gt; 명령을 실행하여 &lt;code&gt;syslog.conf(5)&lt;/code&gt; 매뉴얼 페이지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f90e37b89af3e970911fe6712a87407f263ba3" translate="yes" xml:space="preserve">
          <source>The format of the crash dump evolves between OTP releases. Some information described here may not apply to your version. A description like this will never be complete; it is meant as an explanation of the crash dump in general and as a help when trying to find application errors, not as a complete specification.</source>
          <target state="translated">크래시 덤프의 형식은 OTP 릴리스간에 발전합니다. 여기에 설명 된 일부 정보는 사용중인 버전에 적용되지 않을 수 있습니다. 이와 같은 설명은 절대 완료되지 않습니다. 일반적으로 크래시 덤프에 대한 설명과 완전한 사양이 아니라 응용 프로그램 오류를 찾을 때 도움을주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb9b12cb8d3ac8423ae8bea95db89eaec323992a" translate="yes" xml:space="preserve">
          <source>The format of the messages is one of the following, depending on if flag &lt;code&gt;timestamp&lt;/code&gt; of the trace token is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">추적 토큰의 플래그 &lt;code&gt;timestamp&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있는지 여부에 따라 메시지 형식은 다음 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="168262e7bb4ad03b8f9aa164f315f9eabe54fc52" translate="yes" xml:space="preserve">
          <source>The format of the node name is an atom &lt;code&gt;name@host&lt;/code&gt;. &lt;code&gt;name&lt;/code&gt; is the name given by the user. &lt;code&gt;host&lt;/code&gt; is the full host name if long names are used, or the first part of the host name if short names are used. &lt;code&gt;node()&lt;/code&gt; returns the name of the node.</source>
          <target state="translated">노드 이름의 형식은 atom &lt;code&gt;name@host&lt;/code&gt; 입니다. &lt;code&gt;name&lt;/code&gt; 은 사용자가 제공 한 이름 입니다. &lt;code&gt;host&lt;/code&gt; 는 긴 이름을 사용하는 경우 전체 호스트 이름이거나 짧은 이름을 사용하는 경우 호스트 이름의 첫 부분입니다. &lt;code&gt;node()&lt;/code&gt; 는 노드 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e18dae497a998ac661c28b510144fccadd65f4ce" translate="yes" xml:space="preserve">
          <source>The format of the node status change messages depends on &lt;code&gt;Options&lt;/code&gt;. If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, which is the default, the format is as follows:</source>
          <target state="translated">노드 상태 변경 메시지의 형식은 &lt;code&gt;Options&lt;/code&gt; 따라 다릅니다 . 경우 &lt;code&gt;Options&lt;/code&gt; 인 &lt;code&gt;[]&lt;/code&gt; , 기본값 인을, 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="765472921ad5d1b4e5d1dc40a24f50b66dda836a" translate="yes" xml:space="preserve">
          <source>The format of the status message is as follows:</source>
          <target state="translated">상태 메시지의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f119a1fe58fd91d2d32fa64f2417a092c14ccb82" translate="yes" xml:space="preserve">
          <source>The format of the text file is as follows:</source>
          <target state="translated">텍스트 파일의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4333a537987dd2c37f631936cd505a940685024b" translate="yes" xml:space="preserve">
          <source>The format stored in the &lt;code&gt;debug_info&lt;/code&gt; chunk. To retrieve particular code representation from the backend, &lt;code&gt;Backend:debug_info(Format, Module, Data, Opts)&lt;/code&gt; must be invoked. &lt;code&gt;Format&lt;/code&gt; is an atom, such as &lt;code&gt;erlang_v1&lt;/code&gt; for the Erlang Abstract Format or &lt;code&gt;core_v1&lt;/code&gt; for Core Erlang. &lt;code&gt;Module&lt;/code&gt; is the module represented by the beam file and &lt;code&gt;Data&lt;/code&gt; is the value stored in the debug info chunk. &lt;code&gt;Opts&lt;/code&gt; is any list of values supported by the &lt;code&gt;Backend&lt;/code&gt;. &lt;code&gt;Backend:debug_info/4&lt;/code&gt; must return &lt;code&gt;{ok, Code}&lt;/code&gt; or &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 청크에 저장된 형식 입니다. 백엔드에서 특정 코드 표현을 검색하려면 &lt;code&gt;Backend:debug_info(Format, Module, Data, Opts)&lt;/code&gt; 를 호출해야합니다. &lt;code&gt;Format&lt;/code&gt; 과 같은 원자이다 &lt;code&gt;erlang_v1&lt;/code&gt; 얼랑 추상적 포맷 용 또는 &lt;code&gt;core_v1&lt;/code&gt; 코어 얼랑 대. &lt;code&gt;Module&lt;/code&gt; 은 빔 파일로 표시되는 모듈이고 &lt;code&gt;Data&lt;/code&gt; 는 디버그 정보 청크에 저장된 값입니다. &lt;code&gt;Opts&lt;/code&gt; 는 &lt;code&gt;Backend&lt;/code&gt; 에서 지원하는 모든 값 목록입니다 . &lt;code&gt;Backend:debug_info/4&lt;/code&gt; 는 &lt;code&gt;{ok, Code}&lt;/code&gt; 또는 &lt;code&gt;{error, Term}&lt;/code&gt; 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8e6ead11c3e1eac26901161b759833474cba3a4" translate="yes" xml:space="preserve">
          <source>The formatter information consist of a formatter module, &lt;code&gt;FModule&lt;/code&gt; and its configuration, &lt;code&gt;FConfig&lt;/code&gt;. &lt;code&gt;FModule&lt;/code&gt; must export the following function, which can be called by the handler:</source>
          <target state="translated">포맷터 정보는 포맷터 모듈 &lt;code&gt;FModule&lt;/code&gt; 및 해당 구성 &lt;code&gt;FConfig&lt;/code&gt; 로 구성 됩니다 . &lt;code&gt;FModule&lt;/code&gt; 은 핸들러에서 호출 할 수있는 다음 함수를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="08eb54b5af19c1955cfb0d28c30545c43ca2cd83" translate="yes" xml:space="preserve">
          <source>The formatter information for a handler is set as a part of its configuration when the handler is added. It can also be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt; logger:set_handler_config(HandlerId,formatter,{FModule,FConfig}) &lt;/a&gt;&lt;/code&gt;, which overwrites the current formatter information, or with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt; logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, which only modifies the formatter configuration.</source>
          <target state="translated">핸들러에 대한 포맷터 정보는 핸들러가 추가 될 때 구성의 일부로 설정됩니다. 현재 포맷터 정보를 덮어 쓰는 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt; logger:set_handler_config(HandlerId,formatter,{FModule,FConfig}) &lt;/a&gt;&lt;/code&gt; 또는 포맷터 구성 만 수정하는 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt; logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; 을 사용 하여 런타임 중에 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d115f8a8e36f58c079d74b58f98933595ecc3ef9" translate="yes" xml:space="preserve">
          <source>The formatter information for a handler is set as a part of its configuration when the handler is added. It can also be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,formatter,{FModule,FConfig})&lt;/a&gt;&lt;/code&gt;, which overwrites the current formatter information, or with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, which only modifies the formatter configuration.</source>
          <target state="translated">핸들러의 포맷터 정보는 핸들러가 추가 될 때 구성의 일부로 설정됩니다. 런타임 중에 현재 포맷터 정보를 겹쳐 쓰는 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config(HandlerId,formatter,{FModule,FConfig})&lt;/a&gt;&lt;/code&gt; 또는 포맷터 구성 만 수정하는 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; 으로 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f4f8dac91f32ead5de8dd50ed11e0572d80a431" translate="yes" xml:space="preserve">
          <source>The formatter information is specified when adding the handler. The formatter configuration can be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt; logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, or the complete formatter information can be overwritten with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt; logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포맷터 정보는 핸들러를 추가 할 때 지정됩니다. 포맷터 구성은 런타임 중에 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt; logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; 으로 변경하거나 전체 포맷터 정보를 예를 들어 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt; logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt; 로 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31df239ad5b8271efa81cda13e999773cde8976a" translate="yes" xml:space="preserve">
          <source>The formatter information is specified when adding the handler. The formatter configuration can be changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt;, or the complete formatter information can be overwritten with, for instance, &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러를 추가 할 때 포맷터 정보가 지정됩니다. 포맷터 구성은 런타임 중에 &lt;code&gt;&lt;a href=&quot;logger#update_formatter_config-2&quot;&gt;logger:update_formatter_config/2,3&lt;/a&gt;&lt;/code&gt; 으로 변경하거나 전체 포맷터 정보를 예를 들어 &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-3&quot;&gt;logger:set_handler_config/3&lt;/a&gt;&lt;/code&gt; 로 겹쳐 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8f30a9a1bf44181155aa2e71449137d3512f394" translate="yes" xml:space="preserve">
          <source>The formatting succeeded.</source>
          <target state="translated">포맷이 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="dc0d9a77b06641779f3ff429581cfe2152aeca03" translate="yes" xml:space="preserve">
          <source>The former is a classical standard with a proper formal syntax, using the so called &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2234.txt&quot;&gt;Augmented Backus-Naur Form (ABNF)&lt;/a&gt;&lt;/code&gt; for describing the grammar, while the latter is a living document describing the current pratice, that is, how a majority of Web browsers work with URIs. WHAT WG URL is Web focused and it has no formal grammar but a plain english description of the algorithms that should be followed.</source>
          <target state="translated">전자는 문법을 설명하기 위해 소위 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2234.txt&quot;&gt;Augmented Backus-Naur Form (ABNF)&lt;/a&gt;&lt;/code&gt; 를 사용하는 적절한 형식 구문이있는 고전적인 표준 이고, 후자는 현재의 관행, 즉 대부분의 웹 브라우저를 설명하는 살아있는 문서입니다. URI와 함께 작동합니다. WHAT WG URL은 웹 중심이며 공식적인 문법은 없지만 따라야 할 알고리즘에 대한 일반 영어 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="10bd3287c5d5cb11c97ef91fb582e7bddc5c508a" translate="yes" xml:space="preserve">
          <source>The fourth argument &lt;code&gt;NULL&lt;/code&gt; is ignored. It was earlier used for the deprecated &lt;code&gt;reload&lt;/code&gt; callback which is no longer supported since OTP 20.</source>
          <target state="translated">네 번째 인수 &lt;code&gt;NULL&lt;/code&gt; 은 무시됩니다. 더 이상 사용되지 않는 &lt;code&gt;reload&lt;/code&gt; 콜백에 사용 되었으며 OTP 20부터 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd6d48968ca41cf916b0c1706ee59abd18b5be81" translate="yes" xml:space="preserve">
          <source>The fourth argument is a pointer to an &lt;code&gt;in_addr&lt;/code&gt; struct with the IP address of the host.</source>
          <target state="translated">네 번째 인수는 호스트의 IP 주소를 가진 &lt;code&gt;in_addr&lt;/code&gt; 구조체에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="e236ba0b32b561d73bf0d206f0aebabfe0c3ba82" translate="yes" xml:space="preserve">
          <source>The fourth argument, &lt;code&gt;[]&lt;/code&gt;, is a list of options. For the available options, see &lt;code&gt;gen_statem:start_link/3&lt;/code&gt;.</source>
          <target state="translated">네 번째 인수 인 &lt;code&gt;[]&lt;/code&gt; 는 옵션 목록입니다. 사용 가능한 옵션은 &lt;code&gt;gen_statem:start_link/3&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ce7182b37b9940508d39bc849560d216ed57126" translate="yes" xml:space="preserve">
          <source>The fourth argument, &lt;code&gt;[]&lt;/code&gt;, is a list of options. See the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page for available options.</source>
          <target state="translated">네 번째 인수 인 &lt;code&gt;[]&lt;/code&gt; 는 옵션 목록입니다. 사용 가능한 옵션 은 &lt;code&gt;gen_server(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa28b3ee82d6cace84ec1443af25bb2eb0eafaac" translate="yes" xml:space="preserve">
          <source>The fragment size of 128 is only used as an example. Any fragments size may be used when sending fragmented messages.</source>
          <target state="translated">128의 조각 크기는 예제로만 사용됩니다. 조각난 메시지를 보낼 때 모든 조각 크기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aecfffdedf7cb9fd61cb29aa23ebcd2cef310301" translate="yes" xml:space="preserve">
          <source>The fragments must be delivered in the correct order, so if an unordered distribution carrier is used, they must be ordered before delivered to the Erlang run-time.</source>
          <target state="translated">조각은 올바른 순서로 배달되어야하므로 순서가 지정되지 않은 배포 캐리어를 사용하는 경우 Erlang 런타임으로 배달하기 전에 주문해야합니다.</target>
        </trans-unit>
        <trans-unit id="9100d905b13d1377220d70070d7d60982d6749a4" translate="yes" xml:space="preserve">
          <source>The framework consists of:</source>
          <target state="translated">프레임 워크는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="819321d08c2b7b1c092e7b0fa0f720e66c56015b" translate="yes" xml:space="preserve">
          <source>The full definitions of those instructions can be found in &lt;code&gt;bs_instrs.tab&lt;/code&gt;. The generated code can be found in &lt;code&gt;beam_warm.h&lt;/code&gt;.</source>
          <target state="translated">이러한 지침의 전체 정의는 &lt;code&gt;bs_instrs.tab&lt;/code&gt; 에서 찾을 수 있습니다 . 생성 된 코드는 &lt;code&gt;beam_warm.h&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c8d31fc362ef9b832d0b697fa5e6ecb8f8d5cf1" translate="yes" xml:space="preserve">
          <source>The full log entry is composed according to the &lt;code&gt;&lt;a href=&quot;#template&quot;&gt;template&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 로그 항목은 &lt;code&gt;&lt;a href=&quot;#template&quot;&gt;template&lt;/a&gt;&lt;/code&gt; 에 따라 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="700f5d03995315807276176315f6bb17647929bf" translate="yes" xml:space="preserve">
          <source>The full name for the Solaris standard configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;syslogd&lt;/code&gt; 에 대한 Solaris 표준 구성 파일의 전체 이름</target>
        </trans-unit>
        <trans-unit id="0e81e9ea5253fb51f8c99babc5aff5902bbe7489" translate="yes" xml:space="preserve">
          <source>The full name of the binary executable file is derived from the position of application &lt;code&gt;os_mon&lt;/code&gt; in the file system by adding &lt;code&gt;/priv/bin/mod_syslog&lt;/code&gt;. The generic full name of the binary executable file is thus:</source>
          <target state="translated">이진 실행 파일의 전체 이름은 &lt;code&gt;/priv/bin/mod_syslog&lt;/code&gt; 를 추가하여 파일 시스템에서 &lt;code&gt;os_mon&lt;/code&gt; 응용 프로그램의 위치에서 파생됩니다 . 바이너리 실행 파일의 일반적인 전체 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="563d73d181f3e9108cba87d81726b482ec3d260c" translate="yes" xml:space="preserve">
          <source>The full name of the minor log file (that is, the name of the file including the absolute directory path) can be read during execution of the test case. It comes as value in tuple &lt;code&gt;{tc_logfile,LogFileName}&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; list (which means it can also be read by a pre- or post &lt;code&gt;Common Test Hook&lt;/code&gt; function). Also, at the start of a test case, this data is sent with an event to any installed event handler. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 케이스 실행 중에 부 로그 파일의 전체 이름 (즉, 절대 디렉토리 경로를 포함한 파일 이름)을 읽을 수 있습니다. 그것은 튜플의 값으로 제공 &lt;code&gt;{tc_logfile,LogFileName}&lt;/code&gt; 의 &lt;code&gt;Config&lt;/code&gt; (그것도 사전에 의해 읽거나 게시 할 수 있음을 의미하는 목록 &lt;code&gt;Common Test Hook&lt;/code&gt; 기능). 또한 테스트 사례가 시작될 때이 데이터는 이벤트와 함께 설치된 모든 이벤트 핸들러로 전송됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="add619cb56fecf8eaa2173268a66512e2ca14e79" translate="yes" xml:space="preserve">
          <source>The full path to the &lt;code&gt;erlsrv.exe&lt;/code&gt;, which can be used to manipulate the service. This comes in handy when defining a heart command for your service.</source>
          <target state="translated">서비스를 조작하는 데 사용할 수있는 &lt;code&gt;erlsrv.exe&lt;/code&gt; 의 전체 경로 입니다. 서비스에 대한 핵심 명령을 정의 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="504f71220986791fe2ea8dea00b27516f0e65c24" translate="yes" xml:space="preserve">
          <source>The fun &lt;code&gt;F&lt;/code&gt; can be evaluated with the following syntax:</source>
          <target state="translated">fun &lt;code&gt;F&lt;/code&gt; 는 다음 구문으로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8ca975ecc3e8edf173345a968b651e47f611e5" translate="yes" xml:space="preserve">
          <source>The fun can have many clauses. Assume that we want to do the following:</source>
          <target state="translated">재미는 많은 절을 가질 수 있습니다. 다음을 수행한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a7bc8a3f1e4f51084c68a1c0c777f1a27337cb3c" translate="yes" xml:space="preserve">
          <source>The fun has the following type specification:</source>
          <target state="translated">재미는 다음과 같은 유형 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f32b8a5a9bbfbf624a0644c5247fde5edb3a429" translate="yes" xml:space="preserve">
          <source>The fun is very restricted, it can take only a single parameter (the object to match): a sole variable or a tuple. It must use the &lt;code&gt;is_&lt;/code&gt; guard tests. Language constructs that have no representation in a match specification (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt;, and so on) are not allowed.</source>
          <target state="translated">재미는 매우 제한적이며 단일 변수 또는 일치하는 단일 매개 변수 (단일 변수 또는 튜플) 만 사용할 수 있습니다. &lt;code&gt;is_&lt;/code&gt; guard 테스트를 사용해야합니다 . 일치 스펙에 표현이없는 언어 구문 ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; 등)은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71d9e7bf1fc41cd7eae3c3b2faa71bd3df3e1269" translate="yes" xml:space="preserve">
          <source>The fun must be defined as:</source>
          <target state="translated">재미는 다음과 같이 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="07c9bc55442a1b08276f48311f68a88a3fb5ef18" translate="yes" xml:space="preserve">
          <source>The fun must be literally constructed inside the parameter list to the pseudo functions. The fun cannot be bound to a variable first and then passed to &lt;code&gt;ets:fun2ms/1&lt;/code&gt; or &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;. For example, &lt;code&gt;ets:fun2ms(fun(A) -&amp;gt; A end)&lt;/code&gt; works, but not &lt;code&gt;F = fun(A) -&amp;gt; A end, ets:fun2ms(F)&lt;/code&gt;. The latter results in a compile-time error if the header is included, otherwise a runtime error.</source>
          <target state="translated">재미는 말 그대로 매개 변수 목록 내에서 의사 함수로 구성되어야합니다. fun은 변수에 먼저 바인딩 된 다음 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 또는 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 로 전달할 수 없습니다 . 예를 들어, &lt;code&gt;ets:fun2ms(fun(A) -&amp;gt; A end)&lt;/code&gt; 는 작동하지만 &lt;code&gt;F = fun(A) -&amp;gt; A end, ets:fun2ms(F)&lt;/code&gt; 는 작동하지 않습니다 . 후자는 헤더가 포함되어 있으면 컴파일 타임 오류가 발생하고 그렇지 않으면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c2fc65e668d470b6dcc72f27bda164d6dff73c81" translate="yes" xml:space="preserve">
          <source>The fun must handle the following arguments:</source>
          <target state="translated">재미는 다음 인수를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="51f57611564f84c521d11cdc1d94f053c16d5dac" translate="yes" xml:space="preserve">
          <source>The fun must obey the &lt;code&gt;depth&lt;/code&gt; and &lt;code&gt;chars_limit&lt;/code&gt; parameters provided in the second argument, as the formatter cannot do anything useful of these parameters with the returned string. The extra data also contains a field named &lt;code&gt;single_line&lt;/code&gt;, indicating if the printed log message may contain line breaks or not. This variant is used when the formatting of the report depends on the size or single line parameters.</source>
          <target state="translated">재미는 두 번째 인수에 제공된 &lt;code&gt;depth&lt;/code&gt; 및 &lt;code&gt;chars_limit&lt;/code&gt; 매개 변수를 따라야합니다 . 포맷터는 반환 된 문자열로 이러한 매개 변수에 유용한 작업을 수행 할 수 없기 때문입니다. 추가 데이터에는 인쇄 된 로그 메시지에 줄 바꿈이 포함되어 있는지 여부를 나타내는 &lt;code&gt;single_line&lt;/code&gt; 이라는 필드도 포함 됩니다. 이 변형은 보고서의 형식이 크기 또는 한 줄 매개 변수에 따라 달라지는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="737c0846a588f1657ff7845917aac0579f2be1af" translate="yes" xml:space="preserve">
          <source>The fun returns the root certificate and certificate chain that has signed the CRL.</source>
          <target state="translated">이 재미는 CRL에 서명 한 루트 인증서 및 인증서 체인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efd695af69ad480c89612803c86acd8baa7d18ec" translate="yes" xml:space="preserve">
          <source>The fun should return:</source>
          <target state="translated">재미는 돌아와야한다 :</target>
        </trans-unit>
        <trans-unit id="d737e56a33d9100f6b6abcd80be538364e25ad0c" translate="yes" xml:space="preserve">
          <source>The fun uses the information in the distribution point to access the latest possible version of the CRL. If this fun is not specified, Public Key uses the default implementation:</source>
          <target state="translated">재미는 배포 지점의 정보를 사용하여 가능한 최신 버전의 CRL에 액세스합니다. 이 재미를 지정하지 않으면 공개 키는 기본 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f1a8e313c80aee065197a6cfd60c195f83fb231" translate="yes" xml:space="preserve">
          <source>The funcion &lt;code&gt;&lt;a href=&quot;mnesia#dirty_update_counter-2&quot;&gt;dirty_update_counter/2&lt;/a&gt;&lt;/code&gt; is performed as an atomic operation although it is not protected by a transaction. Therfore no table update is lost if two processes simultaneously execute the function &lt;code&gt;dirty_update_counter/2&lt;/code&gt;.</source>
          <target state="translated">funcion &lt;code&gt;&lt;a href=&quot;mnesia#dirty_update_counter-2&quot;&gt;dirty_update_counter/2&lt;/a&gt;&lt;/code&gt; 는 트랜잭션에 의해 보호되지 않지만 원 자성 작업으로 수행됩니다. 따라서 두 프로세스가 &lt;code&gt;dirty_update_counter/2&lt;/code&gt; 함수를 동시에 실행하면 테이블 업데이트가 손실되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0013b0c35bbaebef0c54217eeb1d56ac822fe5f" translate="yes" xml:space="preserve">
          <source>The function 'undefined' that has called &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; is an unknown function because that call was not recorded in the trace. It was only recorded that the execution returned from &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; to some other function above in the call stack, or that the process exited from there.</source>
          <target state="translated">&lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; 를 호출 한 'undefined' 함수는 해당 호출이 추적에 기록되지 않았으므로 알 수없는 함수입니다. 실행이 &lt;code&gt;fprof:apply_start_stop/4&lt;/code&gt; 에서 호출 스택의 위의 다른 함수 로 리턴 되었거나 프로세스가 종료 된 것으로 기록되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f8485bc87eedde1f2b8ad275904de4b91765212" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; is called when starting the &lt;code&gt;gen_statem&lt;/code&gt;, after code change and after changing the callback module with any of the actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;. The result is cached for subsequent calls to &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callbacks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 함수 는 &lt;code&gt;gen_statem&lt;/code&gt; 을 시작할 때 , 코드 변경 후 , &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt; 작업으로 콜백 모듈을 변경 한 후에 호출 됩니다. 결과는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callbacks&lt;/a&gt;&lt;/code&gt; 대한 후속 호출을 위해 캐시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0261fe5fd43cd9c6d832aa2e6f9286179956437a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#cipher_suites-2&quot;&gt; ssl:cipher_suites/2 &lt;/a&gt;&lt;/code&gt; can be used to find all cipher suites that are supported by default and all cipher suites that may be configured.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cipher_suites-2&quot;&gt; ssl:cipher_suites/2 &lt;/a&gt;&lt;/code&gt; 함수를 사용하여 기본적으로 지원되는 모든 암호 제품군과 구성 할 수있는 모든 암호 제품군을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae773ba648b2dd3111bf9ff1bd1ae44f3998a92d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter requires to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 는 직경 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; 을 Erlang 소스로 컴파일하는 데 사용됩니다 . 결과 소스는 사전의 메시지와 AVP를 인코딩하고 디코딩하는 데 필요한 인터페이스 직경을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b1eeb1350e2bae25f92e23b1d2b563721196dfbc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#create_table-2&quot;&gt;mnesia:create_table(bar, [{attributes, 3.14}])&lt;/a&gt;&lt;/code&gt; returns the tuple &lt;code&gt;{aborted,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is the tuple &lt;code&gt;{bad_type,bar,3.14000}&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;#create_table-2&quot;&gt;mnesia:create_table(bar, [{attributes, 3.14}])&lt;/a&gt;&lt;/code&gt; 튜플 반환 &lt;code&gt;{aborted,Reason}&lt;/code&gt; , &lt;code&gt;Reason&lt;/code&gt; 튜플이다 &lt;code&gt;{bad_type,bar,3.14000}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab82066f7afa34b039ac973980ff4ef53ba41e38" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#error_description-1&quot;&gt;mnesia:error_description(Reason)&lt;/a&gt;&lt;/code&gt; returns the term &lt;code&gt;{&quot;Bad type on some provided arguments&quot;,bar,3.14000}&lt;/code&gt;, which is an error description suitable for display.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;#error_description-1&quot;&gt;mnesia:error_description(Reason)&lt;/a&gt;&lt;/code&gt; 용어 반환 &lt;code&gt;{&quot;Bad type on some provided arguments&quot;,bar,3.14000}&lt;/code&gt; 디스플레이에 적합한 오류 설명이다.</target>
        </trans-unit>
        <trans-unit id="416085a9cc04b82b99ed7eea9c9814ce71342d35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#get_memory_data-0&quot;&gt;get_memory_data()&lt;/a&gt;&lt;/code&gt; can be used to retrieve the result of the latest periodic memory check.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#get_memory_data-0&quot;&gt;get_memory_data()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 최신주기 메모리 점검 결과를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d90d9bd2e78e7f66c786fdc154ab3630fd58d990" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; and the constructor functions &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; can be a great help if one wants to traverse a syntax tree, visiting all its subtrees, but treat nodes of the tree in a uniform way in most or all cases. Using these functions makes this simple, and also assures that your code is not overly sensitive to extensions of the syntax tree data type, because any node types not explicitly handled by your code can be left to a default case.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; 함수 와 생성자 함수 &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#update_tree-2&quot;&gt;update_tree/2&lt;/a&gt;&lt;/code&gt; 는 구문 트리를 탐색하고 모든 하위 트리를 방문하지만 대부분 또는 모든 경우에 균일 한 방식으로 트리 노드를 처리하려는 경우 큰 도움이 될 수 있습니다. . 이러한 함수를 사용하면 코드가 명시 적으로 처리되지 않은 모든 노드 유형이 기본 사례로 유지 될 수 있으므로 코드가 구문 트리 데이터 유형의 확장에 지나치게 민감하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9d557c07ad7843b1aa33917e03437c2191df84" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; returns one of the following values:</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#activate_checkpoint-1&quot;&gt;mnesia:activate_checkpoint(Args)&lt;/a&gt;&lt;/code&gt; 다음 값 중 하나를 반환 :</target>
        </trans-unit>
        <trans-unit id="7829e947c9fda3671f982c368ab35a66949366af" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#all_keys-1&quot;&gt;mnesia:all_keys(Tab)&lt;/a&gt;&lt;/code&gt; returns all keys in a table.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#all_keys-1&quot;&gt;mnesia:all_keys(Tab)&lt;/a&gt;&lt;/code&gt; 테이블의 모든 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29d2bb31f2eb0b09a4594530fbd096f08be20052" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#backup-1&quot;&gt;mnesia:backup(Opaque [,Mod])&lt;/a&gt;&lt;/code&gt; activates a new checkpoint that covers all &lt;code&gt;Mnesia&lt;/code&gt; tables with maximum degree of redundancy and performs a backup. Maximum redundancy means that each table replica has a checkpoint retainer. Tables with property &lt;code&gt;local_contents&lt;/code&gt; are backed up as they look on the current node.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#backup-1&quot;&gt;mnesia:backup(Opaque [,Mod])&lt;/a&gt;&lt;/code&gt; 새로운 체크 포인트를 활성화하는 모든 표지 &lt;code&gt;Mnesia&lt;/code&gt; 의 이중화 행하고 백업의 최대치와 테이블. 최대 중복성은 각 테이블 복제본에 체크 포인트 보유자가 있음을 의미합니다. &lt;code&gt;local_contents&lt;/code&gt; 특성이있는 테이블 은 현재 노드를 볼 때 백업됩니다.</target>
        </trans-unit>
        <trans-unit id="36376c0ad23644747aaadff922c6c829e1451912" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; creates tables. When executing this function, it returns one of the following responses:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table(Name, ArgList)&lt;/a&gt;&lt;/code&gt; 함수는 테이블을 생성합니다. 이 함수를 실행할 때 다음 응답 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1a6864b3dbbae165f2d507c1a853d0af094ec0c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; creates a brand new fragmented table, by setting table property &lt;code&gt;frag_properties&lt;/code&gt; to some proper values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#create_table-2&quot;&gt;mnesia:create_table/2&lt;/a&gt;&lt;/code&gt; 함수는 테이블 속성 &lt;code&gt;frag_properties&lt;/code&gt; 를 적절한 값 으로 설정하여 새로운 조각 테이블을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fd24999a16cc29e37c736949b94f5785cba2b786" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#delete_table-1&quot;&gt;mnesia:delete_table/1&lt;/a&gt;&lt;/code&gt; deletes a fragmented table including all its fragments. There must however not exist any other fragmented tables that refer to this table in their foreign key.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#delete_table-1&quot;&gt;mnesia:delete_table/1&lt;/a&gt;&lt;/code&gt; 함수 는 모든 조각을 포함하여 조각난 테이블을 삭제합니다. 그러나 외래 키에서이 테이블을 참조하는 다른 조각화 된 테이블이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="30691173c7709ef9a4f3af204d9b1fcd4e7de68a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables/1&lt;/a&gt;&lt;/code&gt; can be used to dump RAM table replicas to disc.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#dump_tables-1&quot;&gt;mnesia:dump_tables/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 RAM 테이블 복제본을 디스크에 덤프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bca628c2f6585264d68c5ff447dbb6e315d490b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to force load the table regardless of which table load mechanism that is activated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 함수 는 활성화 된 테이블로드 메커니즘에 관계없이 테이블을 강제로드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da340c660c7601de0e1ab6532b1b4defd72ac7f" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#info-0&quot;&gt;mnesia:info/0&lt;/a&gt;&lt;/code&gt; can now be used to print some system information even before &lt;code&gt;Mnesia&lt;/code&gt; is started. When &lt;code&gt;Mnesia&lt;/code&gt; is started, the function prints more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#info-0&quot;&gt;mnesia:info/0&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 &lt;code&gt;Mnesia&lt;/code&gt; 가 시작 되기 전에도 일부 시스템 정보를 인쇄 할 수 있습니다 . 때 &lt;code&gt;Mnesia&lt;/code&gt; 가 시작되고 기능이 추가 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="60a3e9499c0d1ca23244a4d32bf0a317d6112fb3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#install_fallback-2&quot;&gt;mnesia:install_fallback(Opaque, [Mod])&lt;/a&gt;&lt;/code&gt; installs a backup as fallback. It uses the backup module &lt;code&gt;Mod&lt;/code&gt;, or the default backup module, to access the backup media. The function returns &lt;code&gt;ok&lt;/code&gt; if successful, or &lt;code&gt;{error, Reason}&lt;/code&gt; if there is an error.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#install_fallback-2&quot;&gt;mnesia:install_fallback(Opaque, [Mod])&lt;/a&gt;&lt;/code&gt; 대체로서 백업을 설치한다. 백업 모듈 &lt;code&gt;Mod&lt;/code&gt; 또는 기본 백업 모듈을 사용하여 백업 미디어에 액세스합니다. 이 함수는 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 반환 하고 오류가 있으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f2ed7053b64d799ffc3ded34968b7ea59f0d544" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#lock-2&quot;&gt;mnesia:lock/2&lt;/a&gt;&lt;/code&gt; is intended to support table locks (as mentioned previously) but also for situations when locks need to be acquired regardless of how tables have been replicated:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#lock-2&quot;&gt;mnesia:lock/2&lt;/a&gt;&lt;/code&gt; 함수 는 테이블 잠금을 지원하기위한 것이며 (앞서 언급 한대로) 테이블 복제 방법에 관계없이 잠금을 획득해야하는 상황에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a04c9c87e126ea98a8324770baffee72b7c15012" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; lacks some important features that &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select/3&lt;/a&gt;&lt;/code&gt; have. For example, &lt;code&gt;mnesia:match_object/3&lt;/code&gt; can only return the matching records, and it cannot express constraints other than equality. To find the names of the male employees on the second floor:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#match_object-3&quot;&gt;mnesia:match_object/3&lt;/a&gt;&lt;/code&gt; 함수에는 mnesia : select / 3의 중요한 기능이 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;mnesia:select/3&lt;/a&gt;&lt;/code&gt; . 예를 들어, &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 는 일치하는 레코드 만 반환 할 수 있으며 동등 이외의 제약 조건을 표현할 수 없습니다. 2 층에서 남성 직원의 이름을 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0917cc1d0fa48c8f542630d30c1cd7b2345a64a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-1&quot;&gt;mnesia:set_master_nodes(Nodes)&lt;/a&gt;&lt;/code&gt; sets master nodes for all tables. For each table it determines its replica nodes and starts &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, TabNodes)&lt;/a&gt;&lt;/code&gt; with those replica nodes that are included in the &lt;code&gt;Nodes&lt;/code&gt; list (that is, &lt;code&gt;TabNodes&lt;/code&gt; is the intersection of &lt;code&gt;Nodes&lt;/code&gt; and the replica nodes of the table). If the intersection is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-1&quot;&gt;mnesia:set_master_nodes(Nodes)&lt;/a&gt;&lt;/code&gt; 함수 는 모든 테이블에 대한 마스터 노드를 설정합니다. 각 테이블에 대해 복제본 노드를 결정하고 &lt;code&gt;Nodes&lt;/code&gt; 목록에 포함 된 복제본 노드와 함께 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, TabNodes)&lt;/a&gt;&lt;/code&gt; 를 시작 합니다 (즉, &lt;code&gt;TabNodes&lt;/code&gt; 는 &lt;code&gt;Nodes&lt;/code&gt; 와 테이블의 복제본 노드의 교차점입니다 ). 교차점이 비어 있으면 특정 테이블의 마스터 노드 복구 메커니즘이 재설정되고 다음에 다시 시작할 때 일반로드 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3124976c6cc4afa58829120e681ccee3319f8f32" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 함수 는 두 노드에서 모두 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="362b910adc258b676d8a22204af77b93afeab4c8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#stop-0&quot;&gt;mnesia:stop()&lt;/a&gt;&lt;/code&gt; stops &lt;code&gt;Mnesia&lt;/code&gt; on the node where the function is executed. The functions &lt;code&gt;mnesia:start/0&lt;/code&gt; and &lt;code&gt;mnesia:stop/0&lt;/code&gt; work on the &quot;local&quot; &lt;code&gt;Mnesia&lt;/code&gt; system. No functions start or stop a set of nodes.</source>
          <target state="translated">함수 &lt;code&gt;&lt;a href=&quot;mnesia#stop-0&quot;&gt;mnesia:stop()&lt;/a&gt;&lt;/code&gt; 정지 &lt;code&gt;Mnesia&lt;/code&gt; 을 함수가 실행되는 노드. 기능은 &lt;code&gt;mnesia:start/0&lt;/code&gt; 및 &lt;code&gt;mnesia:stop/0&lt;/code&gt; 은 &quot;로컬&quot;작업을 &lt;code&gt;Mnesia&lt;/code&gt; 의 시스템. 노드 세트를 시작하거나 중지하는 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5acaf5a283731e99e901e6928e2526a7dcf95f24" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info/2&lt;/a&gt;&lt;/code&gt; now understands item &lt;code&gt;frag_properties&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info/2&lt;/a&gt;&lt;/code&gt; 함수는 이제 &lt;code&gt;frag_properties&lt;/code&gt; 항목을 이해 합니다.</target>
        </trans-unit>
        <trans-unit id="a1334bf42da6253566700391caa3cba76ccf9209" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;Callback:read_config/1&lt;/code&gt; is to be exported from the callback module to read configuration data, initially before the tests start, or as a result of data being reloaded during test execution. The input argument is the same as for function &lt;code&gt;check_parameter/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Callback:read_config/1&lt;/code&gt; 함수 는 콜백 모듈에서 익스포트되어 테스트가 시작되기 전에 또는 테스트 실행 중에 데이터가 다시로드 된 결과로 구성 데이터를 읽습니다. 입력 인수는 &lt;code&gt;check_parameter/1&lt;/code&gt; 함수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7fbf758a3229cc65bafd27a8b6bc7ae6dded54d7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;ModuleName:FunctionName()&lt;/code&gt; is called to produce a test set.</source>
          <target state="translated">함수 &lt;code&gt;ModuleName:FunctionName()&lt;/code&gt; 테스트 세트를 생성하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="41ef4085ec8a8d22de70a87050ca088731db21f2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;check_process_code/3&lt;/code&gt; returns the value &lt;code&gt;async&lt;/code&gt; immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form &lt;code&gt;{check_process_code, RequestId, CheckResult}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;check_process_code/3&lt;/code&gt; 함수 는 요청이 전송 된 직후 &lt;code&gt;async&lt;/code&gt; 값을 리턴합니다 . 요청이 처리되면이 함수를 호출 한 프로세스에 &lt;code&gt;{check_process_code, RequestId, CheckResult}&lt;/code&gt; 형식의 메시지가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6002fc8f958da3877d27d37d914957a73927e2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;company:init/0&lt;/code&gt; creates the tables. Two tables are of type &lt;code&gt;bag&lt;/code&gt;. This is the &lt;code&gt;manager&lt;/code&gt; relation as well the &lt;code&gt;in_proj&lt;/code&gt; relation. This is interpreted as: an employee can be manager over several departments, and an employee can participate in several projects. However, the &lt;code&gt;at_dep&lt;/code&gt; relation is &lt;code&gt;set&lt;/code&gt;, as an employee can only work in one department. In this data model, there are examples of relations that are 1-to-1 (&lt;code&gt;set&lt;/code&gt;) and 1-to-many (&lt;code&gt;bag&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;company:init/0&lt;/code&gt; 함수 는 테이블을 작성합니다. 두 개의 테이블은 &lt;code&gt;bag&lt;/code&gt; 유형 입니다. 이것은 &lt;code&gt;in_proj&lt;/code&gt; 관계 뿐만 아니라 &lt;code&gt;manager&lt;/code&gt; 관계입니다. 직원은 여러 부서의 관리자 일 수 있으며 직원은 여러 프로젝트에 참여할 수 있습니다. 그러나 직원은 한 부서에서만 작업 할 수 있으므로 &lt;code&gt;at_dep&lt;/code&gt; 관계가 &lt;code&gt;set&lt;/code&gt; 됩니다. 이 데이터 모델에는 일대일 ( &lt;code&gt;set&lt;/code&gt; ) 및 일대 다 ( &lt;code&gt;bag&lt;/code&gt; ) 인 관계의 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b3a72aa7ba46bfc3b05ebd94c234d7bb780fb0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;erl_decode()&lt;/code&gt; from &lt;code&gt;erl_marshal&lt;/code&gt; converts the binary into an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">함수 &lt;code&gt;erl_decode()&lt;/code&gt; 에서 &lt;code&gt;erl_marshal&lt;/code&gt; 는 로 이진 변환 &lt;code&gt;ETERM&lt;/code&gt; 의 구조체 :</target>
        </trans-unit>
        <trans-unit id="c72f7b6a5b6f347ed0767231df7d01b1b2dde191" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is unloaded from the agent. This makes it possible to perform any necessary clean-up.</source>
          <target state="translated">MIB가 에이전트에서 언로드 될 때 MIB의 각 오브젝트에 대해 &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 이렇게하면 필요한 정리 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af08e789dab44b8458cb66f5d674a989015f5322" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is unloaded from the agent. This makes it possible to perform necessary clean-up.</source>
          <target state="translated">MIB가 에이전트에서 언로드 될 때 MIB의 각 오브젝트에 대해 &lt;code&gt;f(delete [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 필요한 청소를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5b6c8f67651723c9f3e56c22f4f4ab0b1c577a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get [, ExtraArgs])&lt;/code&gt; is called when a get-request or a get-next request refers to the variable.</source>
          <target state="translated">함수 &lt;code&gt;f(get [, ExtraArgs])&lt;/code&gt; 는 get-request 또는 get-next 요청이 변수를 참조 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7f44a9f942983582de9a504377c1237da5bfe42a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called when a get-request refers to a table.</source>
          <target state="translated">get-request가 테이블을 참조 할 때 함수 &lt;code&gt;f(get, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f9472e8e9d7e877a982c1ad293026a6058a914d6" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(get_next, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called when a get-next- or a get-bulk-request refers to the table.</source>
          <target state="translated">get-next- 또는 get-bulk-request가 테이블을 참조 할 때 &lt;code&gt;f(get_next, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dc9c0fe89d1c4041733fa53cdcec2b986419a3b1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(is_set_ok, NewValue [, ExtraArgs])&lt;/code&gt; is called in phase one of the set-request processing so that the new value can be checked for inconsistencies.</source>
          <target state="translated">함수 &lt;code&gt;f(is_set_ok, NewValue [, ExtraArgs])&lt;/code&gt; 는 설정 요청 처리의 1 단계에서 호출되므로 새 값이 일치하지 않는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d16c30ff848f270285384e5cc25e325a037b629" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(is_set_ok, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called in phase one of the set-request processing so that new values can be checked for inconsistencies.</source>
          <target state="translated">함수 &lt;code&gt;f(is_set_ok, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 는 설정 요청 처리의 1 단계에서 호출되므로 새 값이 불일치인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5330b2475c665d4944e0a229f93d0602e0e5fa" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; is called for each object in an MIB when the MIB is loaded into the agent. This makes it possible to perform the necessary initialization.</source>
          <target state="translated">MIB가 에이전트에로드 될 때 MIB의 각 오브젝트에 대해 &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 이를 통해 필요한 초기화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1ebb83f7fcf0843f0835365552c7f4c0cad7ca" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; is called for each variable in the MIB when the MIB is loaded into the agent. This makes it possible to perform necessary initialization.</source>
          <target state="translated">MIB가 에이전트에로드 될 때 MIB의 각 변수에 대해 &lt;code&gt;f(new [, ExtraArgs])&lt;/code&gt; 함수 가 호출됩니다. 이를 통해 필요한 초기화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="133213fffa730c11eb89996e85007a915e9f1756" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f(set, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called to perform the set in phase two of the set-request processing. It is only called if the corresponding &lt;code&gt;is_set_ok&lt;/code&gt; function did not exist, or returned &lt;code&gt;{noError, 0}&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;f(set, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 는 세트 요청 처리의 2 단계에서 세트를 수행하기 위해 호출됩니다. 해당 &lt;code&gt;is_set_ok&lt;/code&gt; 함수가 존재하지 않거나 &lt;code&gt;{noError, 0}&lt;/code&gt; 리턴 한 경우에만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="beb994d1c8d031347e7906599f79761b788164a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;find_max_and_min&lt;/code&gt; works out the maximum and minimum temperature. A new construct, &lt;code&gt;if&lt;/code&gt;, is introduced here. If works as follows:</source>
          <target state="translated">&lt;code&gt;find_max_and_min&lt;/code&gt; 함수 는 최대 및 최소 온도를 계산합니다. 새로운 구문 인 &lt;code&gt;if&lt;/code&gt; 가 여기에 소개됩니다. 다음과 같이 작동하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e3c365109eb0604df295111a6b478883a0063173" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;foreach&lt;/code&gt; expresses this similarity:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 함수 는 다음과 같은 유사성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32b248029fdb79694c3f91257a1b49d6e08c1720" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;format/2&lt;/code&gt; (that is, &lt;code&gt;format&lt;/code&gt; with two arguments) takes two lists. The first one is nearly always a list written between &quot; &quot;. This list is printed out as it is, except that each ~w is replaced by a term taken in order from the second list. Each ~n is replaced by a new line. The &lt;code&gt;io:format/2&lt;/code&gt; function itself returns the atom &lt;code&gt;ok&lt;/code&gt; if everything goes as planned. Like other functions in Erlang, it crashes if an error occurs. This is not a fault in Erlang, it is a deliberate policy. Erlang has sophisticated mechanisms to handle errors which are shown later. As an exercise, try to make &lt;code&gt;io:format&lt;/code&gt; crash, it should not be difficult. But notice that although &lt;code&gt;io:format&lt;/code&gt; crashes, the Erlang shell itself does not crash.</source>
          <target state="translated">함수 &lt;code&gt;format/2&lt;/code&gt; (즉, 두 개의 인수가있는 &lt;code&gt;format&lt;/code&gt; )는 두 개의 목록을 갖습니다. 첫 번째는 거의 항상 &quot;&quot;사이에 작성된 목록입니다. 이 목록은 각 ~ w가 두 번째 목록에서 순서대로 가져온 용어로 대체된다는 점을 제외하고는 그대로 인쇄됩니다. 각 ~ n은 새 줄로 바뀝니다. &lt;code&gt;io:format/2&lt;/code&gt; 함수 자체는 원자 반환 &lt;code&gt;ok&lt;/code&gt; 계획대로 모든 것이 진행합니다. Erlang의 다른 기능과 마찬가지로 오류가 발생하면 충돌합니다. 이것은 Erlang의 결함이 아니며, 의도적 인 정책입니다. Erlang은 나중에 보여지는 오류를 처리하는 정교한 메커니즘을 가지고 있습니다. 실습으로 &lt;code&gt;io:format&lt;/code&gt; 충돌을 시도해보십시오 . 어렵지 않아야합니다. 그러나 &lt;code&gt;io:format&lt;/code&gt; 이지만 Erlang 쉘 자체가 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3aac06ca8d394b3646df1b427f505d8cf51b76fc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/1&lt;/code&gt; is deprecated and will be removed in next version.</source>
          <target state="translated">&lt;code&gt;g/1&lt;/code&gt; 기능 은 더 이상 사용되지 않으며 다음 버전에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="88abc7d88e609edf90b5266ee54f52aa2a6dcc51" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/2&lt;/code&gt; is deprecated and will be removed in next major release.</source>
          <target state="translated">&lt;code&gt;g/2&lt;/code&gt; 기능 은 더 이상 사용되지 않으며 다음 주요 릴리스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="81d897d03e553a2581073072bbd55d8966c2a444" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g/3&lt;/code&gt; is deprecated and will eventually be removed.</source>
          <target state="translated">&lt;code&gt;g/3&lt;/code&gt; 함수 는 더 이상 사용되지 않으며 결국 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dd9a50875733e809d1405bf85bfdecd386ca67c2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;garbage_collect/2&lt;/code&gt; returns the value &lt;code&gt;async&lt;/code&gt; immediately after the request has been sent. When the request has been processed, the process that called this function is passed a message on the form &lt;code&gt;{garbage_collect, RequestId, GCResult}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;garbage_collect/2&lt;/code&gt; 함수 는 요청이 전송 된 직후 &lt;code&gt;async&lt;/code&gt; 값을 반환합니다 . 요청이 처리되면이 함수를 호출 한 프로세스에 &lt;code&gt;{garbage_collect, RequestId, GCResult}&lt;/code&gt; 형식의 메시지가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="25a3548064393431c03ef0a701e0096414b17490" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert_emp/3&lt;/code&gt; creates a Functional Object (Fun). &lt;code&gt;Fun&lt;/code&gt; is passed as a single argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt;. This means that &lt;code&gt;Fun&lt;/code&gt; is run as a transaction with the following properties:</source>
          <target state="translated">함수 &lt;code&gt;insert_emp/3&lt;/code&gt; 은 기능적 개체 (재미)를 생성한다. &lt;code&gt;Fun&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt; 함수에 단일 인수로 전달됩니다 . 이것은 &lt;code&gt;Fun&lt;/code&gt; 이 다음 속성을 가진 트랜잭션으로 실행 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="fd04d9687a79d761d32b2c43de1576259fb5f864" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;insert_emp/3&lt;/code&gt; creates a Functional Object (Fun). &lt;code&gt;Fun&lt;/code&gt; is passed as a single argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt;. This means that &lt;code&gt;Fun&lt;/code&gt; is run as a transaction with the following properties:</source>
          <target state="translated">함수 &lt;code&gt;insert_emp/3&lt;/code&gt; 은 기능적 개체 (재미)를 생성한다. &lt;code&gt;Fun&lt;/code&gt; 은 함수 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction(Fun)&lt;/a&gt;&lt;/code&gt; 단일 인수로 전달됩니다 . 즉, &lt;code&gt;Fun&lt;/code&gt; 은 다음 속성을 가진 트랜잭션으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ea55fdab4365faa7f773834a49baba846da23b95" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:change_table_frag(Tab, Change)&lt;/code&gt; is intended to be used for reconfiguration of fragmented tables. Argument &lt;code&gt;Change&lt;/code&gt; is to have one of the following values:</source>
          <target state="translated">&lt;code&gt;mnesia:change_table_frag(Tab, Change)&lt;/code&gt; 함수 는 조각난 테이블의 재구성에 사용됩니다. 인수 &lt;code&gt;Change&lt;/code&gt; 은 다음 값 중 하나를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b1c90e4ee481c7da73002efc510d14130a3a01a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:dirty_*&lt;/code&gt; always executes with &lt;code&gt;async_dirty&lt;/code&gt; semantics regardless of which activity access contexts that are started. It can even start contexts without any enclosing activity access context.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_*&lt;/code&gt; 함수 는 시작된 활동 액세스 컨텍스트에 관계없이 항상 &lt;code&gt;async_dirty&lt;/code&gt; 시맨틱으로 실행됩니다 . 또한 주변 액티비티 액세스 컨텍스트없이 컨텍스트를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="670d344917e31e9f9f7bd59eee0e7cb0d02a6cdf" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:lock/2&lt;/code&gt; is intended to support explicit locking on tables, but is also intended for situations when locks need to be acquired regardless of how tables are replicated. Currently, two kinds of &lt;code&gt;LockKind&lt;/code&gt; are supported:</source>
          <target state="translated">&lt;code&gt;mnesia:lock/2&lt;/code&gt; 함수 는 테이블에 대한 명시 적 잠금을 지원하기위한 것이지만 테이블 복제 방법에 관계없이 잠금을 획득해야하는 상황을위한 것입니다. 현재 두 종류의 &lt;code&gt;LockKind&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d77603a1f02efb7a0e1f99f991914c28109971d3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;mnesia:match_object/3&lt;/code&gt; automatically uses indexes if these exist. However, no heuristics are performed to select the best index.</source>
          <target state="translated">&lt;code&gt;mnesia:match_object/3&lt;/code&gt; 함수 는 인덱스가 존재하면 자동으로 인덱스를 사용합니다. 그러나 최상의 인덱스를 선택하기위한 휴리스틱은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6edabfd9b5590580f8f9657171a96caa4b74ebe3" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;new/4&lt;/code&gt; creates a new map term and lets the keys &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, and &lt;code&gt;alpha&lt;/code&gt; be associated with an initial value. In this case, only float values between and including 0.0 and 1.0 are allowed, as ensured by the &lt;code&gt;?is_channel/1&lt;/code&gt; macro for each argument. Only the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is allowed when creating a new map.</source>
          <target state="translated">&lt;code&gt;new/4&lt;/code&gt; 함수 는 새로운 맵 용어를 작성하고 &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; 및 &lt;code&gt;alpha&lt;/code&gt; 키를 초기 값과 연관시킵니다. 이 경우 각 인수에 대해 &lt;code&gt;?is_channel/1&lt;/code&gt; 매크로에 의해 보장되는 0.0과 1.0 사이의 float 값만 허용됩니다 . 새 맵을 만들 때는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e4f0d7c8457880dafad073945fded626331720" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;pyth(N)&lt;/code&gt; generates a list of all integers &lt;code&gt;{A,B,C}&lt;/code&gt; such that &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; and where the sum of the sides is equal to, or less than, &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">함수 &lt;code&gt;pyth(N)&lt;/code&gt; 모든 정수의리스트를 생성한다 &lt;code&gt;{A,B,C}&lt;/code&gt; 되도록 &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; 측면의 합, 또는 이하와 같고, &lt;code&gt;N&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6137179b93256e30bc3aeec2790f9eeac4bbcd5d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;raise/2&lt;/code&gt; contains a Fun made up of four code lines. This Fun is called by the statement &lt;code&gt;mnesia:transaction(F)&lt;/code&gt; and returns a value.</source>
          <target state="translated">&lt;code&gt;raise/2&lt;/code&gt; 함수 는 4 개의 코드 라인으로 구성된 Fun을 포함합니다. 이 Fun은 &lt;code&gt;mnesia:transaction(F)&lt;/code&gt; 문에 의해 호출되며 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99cf9b671e2d9b419e9dca0fedf06d36961f6433" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;raise_females/1&lt;/code&gt; returns the tuple &lt;code&gt;{atomic, Number}&lt;/code&gt;, where &lt;code&gt;Number&lt;/code&gt; is the number of female employees who received a salary increase. If an error occurs, the value &lt;code&gt;{aborted, Reason}&lt;/code&gt; is returned, and &lt;code&gt;Mnesia&lt;/code&gt; guarantees that the salary is not raised for any employee.</source>
          <target state="translated">함수 &lt;code&gt;raise_females/1&lt;/code&gt; 반환 튜플 &lt;code&gt;{atomic, Number}&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; 급여 인상을받은 여성 직원의 수입니다. 오류가 발생하면 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 값 이 반환되고 &lt;code&gt;Mnesia&lt;/code&gt; 는 직원에 대해 급여가 인상되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="a03f0af918ed9a2c831249c7c193fd4857632c71" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;select&lt;/code&gt; can be used to add more constraints and create output that cannot be done with &lt;code&gt;mnesia:match_object/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 함수 는 더 많은 제한 조건을 추가하고 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 로 수행 할 수없는 출력을 작성하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a509a3ad87b3c1678e41395b1c17d5a940026b1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;send_message/3&lt;/code&gt; will only be called if the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option has been set to the value &lt;code&gt;flag&lt;/code&gt;. The third argument, &lt;code&gt;Resend&lt;/code&gt; then indicates if the message send is a resend or not.</source>
          <target state="translated">&lt;code&gt;send_message/3&lt;/code&gt; 함수 는 &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; 구성 옵션이 value &lt;code&gt;flag&lt;/code&gt; 로 설정된 경우에만 호출됩니다 . 세 번째 인수 인 &lt;code&gt;Resend&lt;/code&gt; 는 메시지 전송이 다시 전송되는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7470406d16d9455cca5984d08f7d4c3396313445" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;send_trap&lt;/code&gt; is kept for backwards compatibility and should not be used in new code. Applications that use this function will continue to work. The &lt;code&gt;snmpNotifyName&lt;/code&gt; is used as the community string by the agent when a notification is sent.</source>
          <target state="translated">&lt;code&gt;send_trap&lt;/code&gt; 함수 는 이전 버전과의 호환성을 위해 유지되므로 새 코드에서 사용해서는 안됩니다. 이 기능을 사용하는 응용 프로그램은 계속 작동합니다. &lt;code&gt;snmpNotifyName&lt;/code&gt; 는 통지를 보낼 때 에이전트에 의해 커뮤니티 문자열로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="103c9badd4ad12f4e6468c8e8de6801ce063239b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;start&lt;/code&gt; first creates a process, let us call it &quot;pong&quot;:</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 함수는 먼저 프로세스를 생성하고 &quot;퐁&quot;이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="eb32c2f2d1549c3a5030e2171eab2d919298928c" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;subsystem/4&lt;/code&gt; and subsequent calls of &lt;code&gt;send/3,4,5&lt;/code&gt; must be executed in the same process.</source>
          <target state="translated">기능 &lt;code&gt;subsystem/4&lt;/code&gt; 및 후속 &lt;code&gt;send/3,4,5&lt;/code&gt; 호출은 동일한 프로세스에서 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9ecc0a2f71c6348929469f92678095577b5215a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;subtrees/1&lt;/code&gt; and the constructor functions &lt;code&gt;make_tree/2&lt;/code&gt; and &lt;code&gt;update_tree/2&lt;/code&gt; can be a great help if one wants to traverse a syntax tree, visiting all its subtrees, but treat nodes of the tree in a uniform way in most or all cases. Using these functions makes this simple, and also assures that your code is not overly sensitive to extensions of the syntax tree data type, because any node types not explicitly handled by your code can be left to a default case.</source>
          <target state="translated">함수 &lt;code&gt;subtrees/1&lt;/code&gt; 및 생성자 함수 &lt;code&gt;make_tree/2&lt;/code&gt; 및 &lt;code&gt;update_tree/2&lt;/code&gt; 는 구문 트리를 탐색하고 모든 하위 트리를 방문하지만 대부분의 경우 또는 모든 경우에 트리의 노드를 동일한 방식으로 처리하려는 경우 큰 도움이 될 수 있습니다. . 이러한 함수를 사용하면이를 간단하게 만들 수 있으며 코드에서 명시 적으로 처리하지 않는 노드 유형은 기본 케이스로 남겨질 수 있으므로 코드가 구문 트리 데이터 유형의 확장에 지나치게 민감하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="338ff9986a9cbcb124e3833af89e3fbd5600e24b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;target_system:create/1&lt;/code&gt; performs the following:</source>
          <target state="translated">&lt;code&gt;target_system:create/1&lt;/code&gt; 함수 는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0cd28e869f41fdc007104b6030c49cc7a75a7292" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;target_system:install/2&lt;/code&gt; performs the following:</source>
          <target state="translated">&lt;code&gt;target_system:install/2&lt;/code&gt; 기능 은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4199649f879206d3b2fa3c3bd5824df5cda6d3e9" translate="yes" xml:space="preserve">
          <source>The function accepts the following parameters:</source>
          <target state="translated">이 함수는 다음 매개 변수를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="094a87c2e8a4a6a2a6be76b4ad60bd189810ef39" translate="yes" xml:space="preserve">
          <source>The function arguments are as follows:</source>
          <target state="translated">함수 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8347209966cf7f71c1646053d74ccb363214ea1" translate="yes" xml:space="preserve">
          <source>The function arguments passed to a NIF appears in an array &lt;code&gt;argv&lt;/code&gt;, with &lt;code&gt;argc&lt;/code&gt; as the length of the array, and thus the arity of the function. The Nth argument of the function can be accessed as &lt;code&gt;argv[N-1]&lt;/code&gt;. NIFs also take an environment argument that serves as an opaque handle that is needed to be passed on to most API functions. The environment contains information about the calling Erlang process:</source>
          <target state="translated">NIF에 전달 된 함수 인수는 배열 의 길이 가 &lt;code&gt;argc&lt;/code&gt; 인 함수 &lt;code&gt;argv&lt;/code&gt; 와 함께 배열 argv에 나타납니다 . 함수의 N 번째 인수는 &lt;code&gt;argv[N-1]&lt;/code&gt; 으로 액세스 할 수 있습니다 . NIF는 또한 대부분의 API 함수에 전달해야하는 불투명 한 핸들 역할을하는 환경 인수를 사용합니다. 환경에는 호출 Erlang 프로세스에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa68aed990974c1565915491205a9e47d95de75c" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;mnesia:del_table_copy(schema, mynode@host)&lt;/code&gt; deletes node &lt;code&gt;mynode@host&lt;/code&gt; from the &lt;code&gt;Mnesia&lt;/code&gt; system. The call fails if &lt;code&gt;Mnesia&lt;/code&gt; is running on &lt;code&gt;mynode@host&lt;/code&gt;. The other &lt;code&gt;Mnesia&lt;/code&gt; nodes never try to connect to that node again. Notice that if there is a disc resident schema on node &lt;code&gt;mynode@host&lt;/code&gt;, the entire &lt;code&gt;Mnesia&lt;/code&gt; directory is to be deleted. This is done with the function &lt;code&gt;&lt;a href=&quot;mnesia#delete_schema-1&quot;&gt;mnesia:delete_schema/1&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Mnesia&lt;/code&gt; is started again on node &lt;code&gt;mynode@host&lt;/code&gt; and the directory has not been cleared, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;mnesia:del_table_copy(schema, mynode@host)&lt;/code&gt; 함수 호출 은 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 에서 &lt;code&gt;mynode@host&lt;/code&gt; 노드를 삭제합니다 . &lt;code&gt;Mnesia&lt;/code&gt; 가 &lt;code&gt;mynode@host&lt;/code&gt; 에서 실행 중이 면 호출이 실패합니다 . 다른 &lt;code&gt;Mnesia&lt;/code&gt; 노드는 해당 노드에 다시 연결을 시도하지 않습니다. 노드 &lt;code&gt;mynode@host&lt;/code&gt; 에 디스크 상주 스키마가 있으면 전체 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리가 삭제됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;mnesia#delete_schema-1&quot;&gt;mnesia:delete_schema/1&lt;/a&gt;&lt;/code&gt; 함수로 수행됩니다 . 경우 &lt;code&gt;Mnesia&lt;/code&gt; 이 노드에서 다시 시작됩니다 &lt;code&gt;mynode@host&lt;/code&gt; 및 디렉토리가 삭제되지 않았의 동작 &lt;code&gt;Mnesia&lt;/code&gt; 가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc50b6ebf32dde9a3ad360a39afe42dd265bea37" translate="yes" xml:space="preserve">
          <source>The function can also return &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;ignore&lt;/code&gt; 를 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7a8505e2fcf77bbdba5fdbba0e6dcaae66b46f6" translate="yes" xml:space="preserve">
          <source>The function can be called by a log handler to convert a log event term to a printable string. The returned value can, for example, be printed as a log entry to the console or a file using &lt;code&gt; io:put_chars/1,2&lt;/code&gt;.</source>
          <target state="translated">이 함수는 로그 핸들러가 로그 이벤트 용어를 인쇄 가능한 문자열로 변환하기 위해 호출 할 수 있습니다. 예를 들어 반환 된 값은 &lt;code&gt; io:put_chars/1,2&lt;/code&gt; 를 사용하여 콘솔 또는 파일에 대한 로그 항목으로 인쇄 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54500a01f09be1a2bd2f0c1abfeddba6e33a00fa" translate="yes" xml:space="preserve">
          <source>The function can be called by a log handler to convert a log event term to a printable string. The returned value can, for example, be printed as a log entry to the console or a file using &lt;code&gt;io:put_chars/1,2&lt;/code&gt;.</source>
          <target state="translated">로그 핸들러를 사용하여 로그 이벤트 용어를 인쇄 가능한 문자열로 변환 할 수 있습니다. 리턴 된 값은 예를 들어 콘솔에 대한 로그 항목 또는 &lt;code&gt;io:put_chars/1,2&lt;/code&gt; 를 사용하여 파일로 인쇄 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c504308064f08c5f9ea9e812d1f6e5a760e998d0" translate="yes" xml:space="preserve">
          <source>The function can be called, for example, when these files are generated at the target. The function is to be called after &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; has been called.</source>
          <target state="translated">예를 들어, 이러한 파일이 대상에서 생성 될 때 함수를 호출 할 수 있습니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; 가 호출 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dfcfdf84d3a74a872f6ce266bc40953da7783b4c" translate="yes" xml:space="preserve">
          <source>The function can be used as follows:</source>
          <target state="translated">이 기능은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f3fe03e8503c073eac107ed5ad24dbaeb411a0" translate="yes" xml:space="preserve">
          <source>The function can be used on a running system, or by copying the entire log directory and calling this function. SNMP must be running in order to provide MIB information.</source>
          <target state="translated">이 기능은 실행중인 시스템에서 사용하거나 전체 로그 디렉토리를 복사하고이 기능을 호출하여 사용할 수 있습니다. MIB 정보를 제공하려면 SNMP가 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8fb21fb19b96fc3f558cb35f3055df39d441e2b" translate="yes" xml:space="preserve">
          <source>The function can be used on files opened in &lt;code&gt;raw&lt;/code&gt; mode. However, it is inefficient to use it on &lt;code&gt;raw&lt;/code&gt; files if the file is not opened with option &lt;code&gt;{read_ahead, Size}&lt;/code&gt; specified. Thus, combining &lt;code&gt;raw&lt;/code&gt; and &lt;code&gt;{read_ahead, Size}&lt;/code&gt; is highly recommended when opening a text file for raw line-oriented reading.</source>
          <target state="translated">이 기능은 &lt;code&gt;raw&lt;/code&gt; 모드로 열린 파일에서 사용할 수 있습니다 . 그러나 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 옵션을 지정 하여 파일을 열지 않으면 &lt;code&gt;raw&lt;/code&gt; 파일에서 파일 을 사용하는 것이 비효율적 입니다. 따라서 원시 행 지향 읽기를 위해 텍스트 파일을 열 때는 &lt;code&gt;raw&lt;/code&gt; 및 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 를 결합하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a30119da22bc70b60e3eb0a2546500296120c22" translate="yes" xml:space="preserve">
          <source>The function can return any term. If the event handler is deleted because of a call to &lt;code&gt;gen_event:delete_handler/3&lt;/code&gt;, the return value of that function becomes the return value of this function. If the event handler is to be replaced with another event handler because of a swap, the return value is passed to the &lt;code&gt;init&lt;/code&gt; function of the new event handler. Otherwise the return value is ignored.</source>
          <target state="translated">이 함수는 모든 용어를 반환 할 수 있습니다. &lt;code&gt;gen_event:delete_handler/3&lt;/code&gt; 호출로 인해 이벤트 핸들러가 삭제 되면 해당 함수의 리턴 값이이 함수의 리턴 값이됩니다. 스왑으로 인해 이벤트 핸들러를 다른 이벤트 핸들러로 바꾸면 리턴 값이 새 이벤트 핸들러 의 &lt;code&gt;init&lt;/code&gt; 함수로 전달됩니다 . 그렇지 않으면 반환 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ed95f32e82d2850058944611e44392a4e4ff3345" translate="yes" xml:space="preserve">
          <source>The function can return numerous errors, some can only be returned given a certain combination of options.</source>
          <target state="translated">이 함수는 수많은 오류를 반환 할 수 있으며 일부 옵션은 특정 조합으로 만 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea57ec1a4ff4fb3ef55b1134a75586251178e601" translate="yes" xml:space="preserve">
          <source>The function can return the following error conditions, all well specified (no opaque values):</source>
          <target state="translated">이 함수는 다음과 같은 오류 조건을 반환 할 수 있습니다. 모두 올바르게 지정되어 있습니다 (불투명 값 없음).</target>
        </trans-unit>
        <trans-unit id="c5c489b2375429e225473997aebd4b0f058730b3" translate="yes" xml:space="preserve">
          <source>The function cannot be found when evaluating a function call.</source>
          <target state="translated">함수 호출을 평가할 때 함수를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="900b2cc1343be73658d225cf863655824f14c352" translate="yes" xml:space="preserve">
          <source>The function check provides an error tuple if Unicode code points &amp;gt; 255 are to be returned if the client requested &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 &lt;code&gt;latin1&lt;/code&gt; 을 요청한 경우 유니 코드 코드 포인트&amp;gt; 255가 리턴되는 경우 함수 점검은 오류 튜플을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d2f0030f1dc39e1c15798593d550e2c64df3c720" translate="yes" xml:space="preserve">
          <source>The function creates a copy of &lt;code&gt;channel.erl&lt;/code&gt; where it for each executable line is specified how many times that line has been executed. The output file is called &lt;code&gt;channel.COVER.out&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 각 실행 가능 행마다 해당 행이 몇 번 실행되었는지 지정되는 &lt;code&gt;channel.erl&lt;/code&gt; 의 사본을 작성합니다 . 출력 파일은 &lt;code&gt;channel.COVER.out&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4bf61d20b6e51c3f3e2be4195443a2547ef5d88" translate="yes" xml:space="preserve">
          <source>The function creates an Erlang list object, whose length &lt;code&gt;arrsize&lt;/code&gt; and whose elements are taken from the terms in &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">이 함수는 길이가 &lt;code&gt;arrsize&lt;/code&gt; 이고 &lt;code&gt;array&lt;/code&gt; 의 항에서 요소를 가져 오는 Erlang 목록 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e824f3f61fcb9a0cc2524376c6e7e48b567c62f2" translate="yes" xml:space="preserve">
          <source>The function creates an Erlang tuple, whose arity is &lt;code&gt;size&lt;/code&gt; and whose elements are taken from the terms in &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;size&lt;/code&gt; 가 ar이고 &lt;code&gt;array&lt;/code&gt; 의 항에서 요소를 가져 오는 Erlang 튜플을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a0c7fe697609b06db41d8d42bbc188f96462c7d5" translate="yes" xml:space="preserve">
          <source>The function descriptions are sorted in alphabetical order. It is recommended to start to read about &lt;code&gt;mnesia:create_table/2&lt;/code&gt;, &lt;code&gt;mnesia:lock/2&lt;/code&gt;, and &lt;code&gt;mnesia:activity/4&lt;/code&gt; before you continue and learn about the rest.</source>
          <target state="translated">기능 설명은 알파벳 순서로 정렬됩니다. 계속 진행하기 전에 &lt;code&gt;mnesia:create_table/2&lt;/code&gt; , &lt;code&gt;mnesia:lock/2&lt;/code&gt; 및 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 에 대해 읽어 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a4a4d3bf61b03f1db00124a05a395c3a8430b995" translate="yes" xml:space="preserve">
          <source>The function does not return until the application is started, stopped, or successfully moved to another node. However, in some cases where permission is set to &lt;code&gt;true&lt;/code&gt;, the function returns &lt;code&gt;ok&lt;/code&gt; even though the application is not started. This is true when an application cannot start because of dependencies to other applications that are not yet started. When they are started, &lt;code&gt;Application&lt;/code&gt; is started as well.</source>
          <target state="translated">응용 프로그램이 시작, 중지 또는 다른 노드로 성공적으로 이동 될 때까지 함수는 리턴되지 않습니다. 그러나 권한이 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우에는 응용 프로그램이 시작되지 않은 경우에도 함수가 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 아직 시작되지 않은 다른 응용 프로그램에 대한 종속성으로 인해 응용 프로그램을 시작할 수없는 경우에 해당됩니다. 시작되면 &lt;code&gt;Application&lt;/code&gt; 도 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1a469b96b6bc66c5e0081f41213671f5c1c3834d" translate="yes" xml:space="preserve">
          <source>The function evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the specified nodes and collects the answers. It returns &lt;code&gt;{ResL, BadNodes}&lt;/code&gt;, where &lt;code&gt;BadNodes&lt;/code&gt; is a list of the nodes that do not exist, and &lt;code&gt;ResL&lt;/code&gt; is a list of the return values, or &lt;code&gt;{badrpc, Reason}&lt;/code&gt; for failing calls. &lt;code&gt;Timeout&lt;/code&gt; is a time (integer) in milliseconds, or &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 지정된 노드에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 하고 답을 수집합니다. &lt;code&gt;{ResL, BadNodes}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;BadNodes&lt;/code&gt; 는 존재하지 않는 노드 목록이고 &lt;code&gt;ResL&lt;/code&gt; 은 리턴 값 목록 또는 호출 실패에 대한 &lt;code&gt;{badrpc, Reason}&lt;/code&gt; 입니다. &lt;code&gt;Timeout&lt;/code&gt; 은 밀리 초 또는 &lt;code&gt;infinity&lt;/code&gt; 의 시간 (정수)입니다 .</target>
        </trans-unit>
        <trans-unit id="bfd306c3cfcdf7cb094583b8a0337221382f9540" translate="yes" xml:space="preserve">
          <source>The function fails if the calling process was not started by a &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; start function, or if it is not registered according to &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스가 &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; 시작 함수에 의해 시작되지 않았 거나 &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; 에 따라 등록 되지 않은 경우 함수가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="0d8167d08507c4718349622be594e2c2117b70ec" translate="yes" xml:space="preserve">
          <source>The function fails if the calling process was not started by a &lt;code&gt;proc_lib&lt;/code&gt; start function, or if it is not registered according to &lt;code&gt;ServerName&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스가 &lt;code&gt;proc_lib&lt;/code&gt; 시작 함수에 의해 시작되지 않았 거나 &lt;code&gt;ServerName&lt;/code&gt; 에 따라 등록 되지 않은 경우 함수가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="5ed33b0170b87b32a6fff91a9848a8bb7508e2c1" translate="yes" xml:space="preserve">
          <source>The function fails if the mandatory applications Kernel and STDLIB are not included in the &lt;code&gt;.rel&lt;/code&gt; file and have start type &lt;code&gt;permanent&lt;/code&gt; (which is default).</source>
          <target state="translated">필수 응용 프로그램 커널 및 STDLIB가 &lt;code&gt;.rel&lt;/code&gt; 파일에 포함되어 있지 않고 시작 유형이 &lt;code&gt;permanent&lt;/code&gt; (기본값) 인 경우 함수가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="6976675cebc3455eafac8b880bffae5936b6e076" translate="yes" xml:space="preserve">
          <source>The function fails with a &lt;code&gt;badarg&lt;/code&gt; run-time error if &lt;code&gt;Dest&lt;/code&gt; is an atom name, but this name is not registered. This is the only case when &lt;code&gt;send&lt;/code&gt; fails for an unreachable destination &lt;code&gt;Dest&lt;/code&gt; (of correct type).</source>
          <target state="translated">&lt;code&gt;Dest&lt;/code&gt; 가 아톰 이름 인 경우이 이름이 등록되지 않은 경우 &lt;code&gt;badarg&lt;/code&gt; 런타임 오류와 함께 함수가 실패합니다 . 때 유일한 경우입니다 &lt;code&gt;send&lt;/code&gt; 도달 할 수없는 목적지 실패 &lt;code&gt;Dest&lt;/code&gt; (올바른 유형의).</target>
        </trans-unit>
        <trans-unit id="f9fbf6c475826079470707701e2d9650785e7704" translate="yes" xml:space="preserve">
          <source>The function fails with reason &lt;code&gt;badarg&lt;/code&gt; in the following situations:</source>
          <target state="translated">다음 상황에서 reason &lt;code&gt;badarg&lt;/code&gt; 와 함께 함수가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="fe345735a6f8cc2af489da60647a5b2eb92480ca" translate="yes" xml:space="preserve">
          <source>The function is applied to each argument in the list. &lt;code&gt;foreach&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt;. It is only used for its side-effect:</source>
          <target state="translated">이 함수는 목록의 각 인수에 적용됩니다. &lt;code&gt;foreach&lt;/code&gt; 는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 부작용에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ed286726d563576b74209031d0c844b5706bbb8" translate="yes" xml:space="preserve">
          <source>The function is asynchronous in the sense that it does not invoke a disk check, but returns the latest available value.</source>
          <target state="translated">이 기능은 디스크 검사를 호출하지 않지만 사용 가능한 최신 값을 반환한다는 점에서 비동기식입니다.</target>
        </trans-unit>
        <trans-unit id="b851161538f61def55e8def7663e88f86cb96f48" translate="yes" xml:space="preserve">
          <source>The function is called by Logger when the formatter configuration for a handler is set or modified. It returns &lt;code&gt;ok&lt;/code&gt; if the configuration is valid, and &lt;code&gt;{error,term()}&lt;/code&gt; if it is faulty.</source>
          <target state="translated">핸들러의 포맷터 구성이 설정되거나 수정 될 때 로거가 함수를 호출합니다. 구성이 유효하면 &lt;code&gt;ok&lt;/code&gt; 를 리턴 하고 결함이 있으면 &lt;code&gt;{error,term()}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="685ab0b87ed3c05c293ea5d73e5639b4e1ff9576" translate="yes" xml:space="preserve">
          <source>The function is called by a Logger when formatter configuration is set or modified. The formatter must validate the given configuration and return &lt;code&gt;ok&lt;/code&gt; if it is correct, and &lt;code&gt;{error,Reason}&lt;/code&gt; if it is faulty.</source>
          <target state="translated">이 기능은 포맷터 구성이 설정되거나 수정 될 때 로거에 의해 호출됩니다. 포맷터는 지정된 구성을 검증하고 올바른 경우 &lt;code&gt;ok&lt;/code&gt; 를 리턴 하고 결함이있는 경우 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fcd6de716b12c9ffa6272634f06715a4cc1ce07" translate="yes" xml:space="preserve">
          <source>The function is called for each start phase (as defined for the primary application) for the primary application and all included applications, for which the start phase is defined.</source>
          <target state="translated">기본 응용 프로그램 및 시작 단계가 정의 된 모든 포함 된 응용 프로그램의 각 시작 단계 (기본 응용 프로그램에 정의 된대로)에 대해 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c011a777dda4570cb71bfb1ec0fb55355e1ee1d3" translate="yes" xml:space="preserve">
          <source>The function is called if a user related error occurs at run-time, for example if a user defined instrumentation function returns erroneous.</source>
          <target state="translated">런타임시 사용자 관련 오류가 발생하면 함수가 호출됩니다 (예 : 사용자 정의 계측 기능이 오류를 반환하는 경우).</target>
        </trans-unit>
        <trans-unit id="af4ce4e1efa0b48a530a0c78c675702975921a0a" translate="yes" xml:space="preserve">
          <source>The function is called if an error occurs during the configuration phase, for example if a syntax error is found in a configuration file.</source>
          <target state="translated">구성 단계에서 오류가 발생하면 (예 : 구성 파일에서 구문 오류가 발견 된 경우) 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="66a34ca9f0458ec66fedbe0a7a5d4d658f1bc216" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when a handler is about to be removed. The purpose is to release all resources used by the handler.</source>
          <target state="translated">핸들러가 제거 되려고 할 때 임시 프로세스에서 함수가 호출됩니다. 목적은 핸들러가 사용하는 모든 자원을 해제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad2afb8b57f9d81965d61a6dce572893b3ec7c89" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when an new handler is about to be added. The purpose is to verify the configuration and initiate all resources needed by the handler.</source>
          <target state="translated">새 핸들러가 추가 될 때 임시 프로세스에서 함수가 호출됩니다. 목적은 구성을 확인하고 핸들러에 필요한 모든 자원을 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdbb67b2c606784fb7d08c84801ed6ce232a3ebb" translate="yes" xml:space="preserve">
          <source>The function is called on a temporary process when the configuration for a handler is about to change. The purpose is to verify and act on the new configuration.</source>
          <target state="translated">핸들러의 구성이 변경 되려고 할 때 함수는 임시 프로세스에서 호출됩니다. 목적은 새 구성을 확인하고 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="80c74d3f2c316470e0f2a09c6499b88b08ed5921" translate="yes" xml:space="preserve">
          <source>The function is called when all primary filters and all handler filters for the handler in question have passed for the given log event. It is called on the client process, that is, the process that issued the log event.</source>
          <target state="translated">해당 로그 이벤트에 대해 모든 기본 필터 및 해당 핸들러의 모든 핸들러 필터가 전달 된 경우 함수가 호출됩니다. 클라이언트 프로세스, 즉 로그 이벤트를 발행 한 프로세스에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="15a03b831c49c7001a624e54ead2c7724ae063ff" translate="yes" xml:space="preserve">
          <source>The function is called when one of the Logger API functions for fetching the handler configuration is called, for example &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt; logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 핸들러 구성을 가져 오기위한 Logger API 함수 중 하나가 호출 될 때 호출됩니다 (예 &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt; logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729c9968acf86cfc5b4d0b16abd57720e8543995" translate="yes" xml:space="preserve">
          <source>The function is called with the current line, up to the cursor, as a reversed string. It is to return a three-tuple: &lt;code&gt;{yes|no, string(), [string(), ...]}&lt;/code&gt;. The first element gives a beep if &lt;code&gt;no&lt;/code&gt;, otherwise the expansion is silent; the second is a string that will be entered at the cursor position; the third is a list of possible expansions. If this list is not empty, it is printed and the current input line is written once again.</source>
          <target state="translated">이 함수는 현재 줄에서 커서까지의 반전 된 문자열로 호출됩니다. &lt;code&gt;{yes|no, string(), [string(), ...]}&lt;/code&gt; 의 세 튜플을 반환해야합니다 . 첫 번째 요소는 &lt;code&gt;no&lt;/code&gt; 인 경우 경고음을냅니다 . 그렇지 않으면 확장이 자동입니다. 두 번째는 커서 위치에 입력 될 문자열입니다. 세 번째는 가능한 확장 목록입니다. 이 목록이 비어 있지 않으면 인쇄되고 현재 입력 행이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5bcd5b77b7b4d998e29896caa372504ff0881133" translate="yes" xml:space="preserve">
          <source>The function is called with the data the I/O server finds on its I/O device, returning one of:</source>
          <target state="translated">이 기능은 I / O 서버가 I / O 장치에서 찾은 데이터와 함께 호출되어 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="05b6947d52059ff05be463986c224ccf19b497f6" translate="yes" xml:space="preserve">
          <source>The function is called with two arguments. The first argument is the successive elements in the list. The second argument is the accumulator. The function must return a new accumulator, which is used the next time the function is called.</source>
          <target state="translated">이 함수는 두 개의 인수로 호출됩니다. 첫 번째 인수는 목록의 연속 요소입니다. 두 번째 주장은 누산기입니다. 함수는 다음에 함수가 호출 될 때 사용되는 새 누산기를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="de8a39fed4f5b52894d7b463343f490ef2f87adb" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;#crypto_init-4&quot;&gt;crypto_init(Cipher, Key, undefined, FlagOrOptions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#crypto_init-4&quot;&gt;crypto_init(Cipher, Key, undefined, FlagOrOptions)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d7045b7530f750d5c794463ab3ef61f6f0030e" translate="yes" xml:space="preserve">
          <source>The function is intended to be called in function &lt;code&gt;init_per_suite&lt;/code&gt; in the test suite.</source>
          <target state="translated">이 함수는 테스트 스위트의 &lt;code&gt;init_per_suite&lt;/code&gt; 함수 에서 호출하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="91d0a41107672655c3969ea037e3566edb95fc7c" translate="yes" xml:space="preserve">
          <source>The function is normally asynchronous in the sense that it does not invoke a memory check, but returns the latest available value. The one exception if is the function is called before a first memory check is finished, in which case it does not return a value until the memory check is finished.</source>
          <target state="translated">이 함수는 일반적으로 메모리 검사를 호출하지 않지만 사용 가능한 최신 값을 반환한다는 점에서 비동기식입니다. 첫 번째 메모리 검사가 완료되기 전에 함수가 호출되는 경우 예외는 메모리 검사가 완료 될 때까지 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34af02f93e44d91dfb2270e53d1db1bc513f0b80" translate="yes" xml:space="preserve">
          <source>The function is optional and can be omitted when implementing an application callback module.</source>
          <target state="translated">이 기능은 선택 사항이며 응용 프로그램 콜백 모듈을 구현할 때 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="982df6f9c963401aaf5cd8cce719f4c21d1397c5" translate="yes" xml:space="preserve">
          <source>The function is optional. If it is not defined, the processes are terminated and then &lt;code&gt;Module:stop(State)&lt;/code&gt; is called.</source>
          <target state="translated">이 기능은 선택 사항입니다. 정의되어 있지 않으면 프로세스가 종료 된 다음 &lt;code&gt;Module:stop(State)&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c75677662ff31b49062b31fc1d308b57eded17" translate="yes" xml:space="preserve">
          <source>The function is synchronous and all the nodes, and all the system servers, are running when it returns a value.</source>
          <target state="translated">이 함수는 동기식이며 값을 리턴 할 때 모든 노드와 모든 시스템 서버가 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="4bd22d2a35c5c88266eecbb86f7699a4e9f4d949" translate="yes" xml:space="preserve">
          <source>The function is synchronous in the sense that it is known that all servers have received the message when the call returns. It is not possible to know that the servers have processed the message.</source>
          <target state="translated">이 함수는 호출이 리턴 될 때 모든 서버가 메시지를 수신 한 것으로 알려져 있다는 점에서 동기식입니다. 서버가 메시지를 처리했음을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a3e80a528bd9ed8d253ab3a636d365b349c0df48" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that change the details of the current state of the event handler. Any term is allowed for &lt;code&gt;Status&lt;/code&gt;. The &lt;code&gt;gen_event&lt;/code&gt; module uses &lt;code&gt;Status&lt;/code&gt; as follows:</source>
          <target state="translated">이 함수는 이벤트 핸들러의 현재 상태에 대한 세부 사항을 변경하는 용어 인 &lt;code&gt;Status&lt;/code&gt; 를 리턴 하는 것입니다. 모든 용어는 &lt;code&gt;Status&lt;/code&gt; 에 허용됩니다 . &lt;code&gt;gen_event&lt;/code&gt; 의 모듈은 사용 &lt;code&gt;Status&lt;/code&gt; 다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="f5e6848577b63036dd2df41149bfea0f17b8cf85" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that changes the details of the current state and status of the &lt;code&gt;gen_server&lt;/code&gt; process. There are no restrictions on the form &lt;code&gt;Status&lt;/code&gt; can take, but for the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; case (when &lt;code&gt;Opt&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;), the recommended form for the &lt;code&gt;Status&lt;/code&gt; value is &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; provides relevant details of the &lt;code&gt;gen_server&lt;/code&gt; state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value.</source>
          <target state="translated">이 함수는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 의 현재 상태 및 상태의 세부 사항을 변경하는 용어 인 &lt;code&gt;Status&lt;/code&gt; 를 리턴 하는 것입니다. &lt;code&gt;Status&lt;/code&gt; 는 취할 수 있는 양식에는 제한이 없지만 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 사례 ( &lt;code&gt;Opt&lt;/code&gt; 가 &lt;code&gt;normal&lt;/code&gt; )의 경우 권장되는 &lt;code&gt;Status&lt;/code&gt; 값은 &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt; , 여기서 &lt;code&gt;Term&lt;/code&gt; 은 &lt;code&gt;gen_server&lt;/code&gt; 상태 의 관련 세부 사항을 제공합니다 . 이 권장 사항을 따를 필요는 없지만 콜백 모듈 상태는 나머지 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 반환 값 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="22b229f5a7773458a1b22bbef3b9114da9d0467f" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;Status&lt;/code&gt;, a term that contains the appropriate details of the current state and status of the &lt;code&gt;gen_statem&lt;/code&gt;. There are no restrictions on the form &lt;code&gt;Status&lt;/code&gt; can take, but for the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; case (when &lt;code&gt;Opt&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;), the recommended form for the &lt;code&gt;Status&lt;/code&gt; value is &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; provides relevant details of the &lt;code&gt;gen_statem&lt;/code&gt; state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; return value.</source>
          <target state="translated">이 함수는 현재 상태 및 &lt;code&gt;gen_statem&lt;/code&gt; 상태에 대한 적절한 세부 사항을 포함하는 용어 인 &lt;code&gt;Status&lt;/code&gt; 를 리턴 합니다 . &lt;code&gt;Status&lt;/code&gt; 는 취할 수 있는 양식에는 제한이 없지만 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 사례 ( &lt;code&gt;Opt&lt;/code&gt; 가 &lt;code&gt;normal&lt;/code&gt; )의 경우 권장되는 &lt;code&gt;Status&lt;/code&gt; 값은 &lt;code&gt;[{data, [{&quot;State&quot;, Term}]}]&lt;/code&gt; , 여기서 &lt;code&gt;Term&lt;/code&gt; 은 &lt;code&gt;gen_statem&lt;/code&gt; 상태 의 관련 세부 사항을 제공합니다 . 이 권장 사항을 따를 필요는 없지만 콜백 모듈 상태는 나머지 &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 반환 값 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="2e735ad6e373adc70cb8848117759dd2a569193e" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;{ok,Pid,State}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the main process in the subsystem and &lt;code&gt;State&lt;/code&gt; is any term.</source>
          <target state="translated">함수는 &lt;code&gt;{ok,Pid,State}&lt;/code&gt; 를 리턴하는 것입니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 서브 시스템에서 기본 프로세스의 pid이고 &lt;code&gt;State&lt;/code&gt; 는 임의의 용어입니다.</target>
        </trans-unit>
        <trans-unit id="b33f514bbf6653a3186283c4cae20e76aa53b9a4" translate="yes" xml:space="preserve">
          <source>The function is to return &lt;code&gt;{ok,Pid}&lt;/code&gt; or &lt;code&gt;{ok,Pid,State}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the top supervisor and &lt;code&gt;State&lt;/code&gt; is any term. If omitted, &lt;code&gt;State&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt;. If the application is stopped later, &lt;code&gt;State&lt;/code&gt; is passed to &lt;code&gt;Module:prep_stop/1&lt;/code&gt;.</source>
          <target state="translated">함수는 &lt;code&gt;{ok,Pid}&lt;/code&gt; 또는 &lt;code&gt;{ok,Pid,State}&lt;/code&gt; 를 리턴하는 것입니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 최고 감독자의 pid이고 &lt;code&gt;State&lt;/code&gt; 는 임의의 용어입니다. 생략하면 &lt;code&gt;State&lt;/code&gt; 의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다. 애플리케이션이 나중에 중지되면 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;Module:prep_stop/1&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="29043cd3dfeb40d4aadad45c2081e6be85789b31" translate="yes" xml:space="preserve">
          <source>The function is to return the updated internal state.</source>
          <target state="translated">이 기능은 업데이트 된 내부 상태를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0abf3dd01db775a71cf749a86135b99f1e7db1dc" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find a downgrade script from the current application version. High-level instructions are translated to low-level instructions. The instructions are sorted in the same manner as when generating a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 현재 응용 프로그램 버전에서 다운 그레이드 스크립트를 찾습니다. 높은 수준의 명령어는 낮은 수준의 명령어로 변환됩니다. 이 명령은 &lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 때와 같은 방식으로 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="ad728199fe8cc2addea2e4edf8ccc9c3d563c12d" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find a downgrade script to the previous version of the application using &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt;. This script is evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;, exactly in the same way as &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt; 를 사용하여 이전 버전의 응용 프로그램으로 다운 그레이드 스크립트를 찾으려고합니다 . 이 스크립트는 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 와 정확히 동일한 방식으로 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="043e22dee6e39d2801de5bf62c0f13acd1fb7f3e" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find an upgrade script from the current application version. High-level instructions are translated to low-level instructions. The instructions are sorted in the same manner as when generating a &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 현재 응용 프로그램 버전에서 업그레이드 스크립트를 찾으려고합니다. 높은 수준의 명령어는 낮은 수준의 명령어로 변환됩니다. 이 명령은 &lt;code&gt;relup&lt;/code&gt; 파일을 생성 할 때와 같은 방식으로 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c31fe3b9fb91cec2a465fbf77df750e586faa18" translate="yes" xml:space="preserve">
          <source>The function looks in the &lt;code&gt;.appup&lt;/code&gt; file and tries to find an upgrade script from the current version of the application using &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt;. This script is evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;, exactly in the same way as &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">이 함수는 &lt;code&gt;.appup&lt;/code&gt; 파일을보고 &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 버전의 애플리케이션에서 업그레이드 스크립트를 찾으려고합니다 . 이 스크립트는 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 와 정확히 동일한 방식으로 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="dae77798ddae832b867b1859c814067bb73455e5" translate="yes" xml:space="preserve">
          <source>The function megaco:connect/4 is used to tell the Megaco application about which control process it should supervise, which MID the remote user has, which callback module it should use to send messages etc. When this &quot;virtual&quot; connection is established the user may use megaco:call/3 and megaco:cast/3 in order to send messages to the other side. Then it is up to the MG to send its first Service Change Request message after applying some clever algorithm in order to fight the problem with startup avalanche (as discussed in the RFC).</source>
          <target state="translated">megaco : connect / 4 함수는 Megaco 응용 프로그램이 감독해야하는 제어 프로세스, 원격 사용자가 가지고있는 MID, 메시지를 보내는 데 사용해야하는 콜백 모듈 등을 알려주는 데 사용됩니다.이 &quot;가상&quot;연결이 설정되면 사용자는 상대방에게 메시지를 보내기 위해 megaco : call / 3 및 megaco : cast / 3를 사용할 수 있습니다. 그런 다음 RFC에서 논의한 것처럼 시작 애벌 런치 문제를 해결하기 위해 영리한 알고리즘을 적용한 후 첫 번째 서비스 변경 요청 메시지를 보내는 것은 MG의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="8ccc872bcbfbd97b2f8f68cc4d29e1cdf3b26f8a" translate="yes" xml:space="preserve">
          <source>The function must return &lt;code&gt;ok&lt;/code&gt; if the module is to become the new current code for the module and become callable.</source>
          <target state="translated">모듈이 모듈의 새로운 현재 코드가되어 호출 가능 해야하는 경우 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd0b359eea39bf0334c200db138df73b605bda4d" translate="yes" xml:space="preserve">
          <source>The function name is an atom. Each argument is a pattern.</source>
          <target state="translated">함수 이름은 원자입니다. 각 인수는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="9406ba0cad4fe7e53495b5806fdfd8af528e2c11" translate="yes" xml:space="preserve">
          <source>The function names &lt;code&gt;load_driver&lt;/code&gt; and &lt;code&gt;unload_driver&lt;/code&gt; are kept for backward compatibility.</source>
          <target state="translated">함수 이름 &lt;code&gt;load_driver&lt;/code&gt; 및 &lt;code&gt;unload_driver&lt;/code&gt; 는 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="79180ba05daadaf9ff778778be432cdae4488b2e" translate="yes" xml:space="preserve">
          <source>The function notifying the code lock about a button event is implemented using &lt;code&gt;gen_statem:cast/2&lt;/code&gt;:</source>
          <target state="translated">버튼 이벤트에 대해 코드 잠금을 알리는 기능은 &lt;code&gt;gen_statem:cast/2&lt;/code&gt; 를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="9bcdf8490fa58034ee65eebf4713860825158535" translate="yes" xml:space="preserve">
          <source>The function print_version_info/0 uses the result of function version1/0 as &lt;code&gt;VersionInfo&lt;/code&gt;.</source>
          <target state="translated">print_version_info / 0 함수는 version1 / 0 함수의 결과를 &lt;code&gt;VersionInfo&lt;/code&gt; 로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d4a4124fa895f394038737b2a3c8f1d3ab62f5b7" translate="yes" xml:space="preserve">
          <source>The function produces lines of &lt;code&gt;Key: Value&lt;/code&gt; from key-value lists. Strings are printed with &lt;code&gt;~ts&lt;/code&gt; and other terms with &lt;code&gt;~tp&lt;/code&gt;.</source>
          <target state="translated">이 함수는 키-값 목록에서 키 &lt;code&gt;Key: Value&lt;/code&gt; 행을 생성 합니다. 문자열은 &lt;code&gt;~ts&lt;/code&gt; 로 인쇄 되고 다른 용어는 &lt;code&gt;~tp&lt;/code&gt; 로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cb60460defa522f2257f4190da9c81a7ebadbf4" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource destructor function.</source>
          <target state="translated">자원 소멸자 함수의 함수 프로토 타입입니다.</target>
        </trans-unit>
        <trans-unit id="e640ff27ceffaa7aa30ce884e4779de12c7a6bcc" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource down function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;pid&lt;/code&gt; is the identity of the monitored process that is exiting, and &lt;code&gt;mon&lt;/code&gt; is the identity of the monitor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt; enif_monitor_process&lt;/a&gt;&lt;/code&gt; 대신 호출되는 자원 작동 중지 함수의 함수 프로토 타입 . &lt;code&gt;obj&lt;/code&gt; 는 리소스이고 &lt;code&gt;pid&lt;/code&gt; 는 종료중인 모니터링되는 프로세스 의 ID 이며 &lt;code&gt;mon&lt;/code&gt; 은 모니터의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="251a711b61dad3eb243d0cc657f90de99a8cb62d" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource down function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;pid&lt;/code&gt; is the identity of the monitored process that is exiting, and &lt;code&gt;mon&lt;/code&gt; is the identity of the monitor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 대신에 호출되는 자원 중지 기능의 함수 프로토 타입입니다 . &lt;code&gt;obj&lt;/code&gt; 는 자원이고, &lt;code&gt;pid&lt;/code&gt; 는 종료중인 모니터 된 프로세스 의 ID 이고 &lt;code&gt;mon&lt;/code&gt; 은 모니터의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="8c03be216975d81bfe2ad5fc4388456380863a94" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource stop function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt; enif_select&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;event&lt;/code&gt; is OS event, &lt;code&gt;is_direct_call&lt;/code&gt; is true if the call is made directly from &lt;code&gt;enif_select&lt;/code&gt; or false if it is a scheduled call (potentially from another thread).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt; enif_select&lt;/a&gt;&lt;/code&gt; 대신 호출되는 자원 중지 함수의 함수 프로토 타입 . &lt;code&gt;obj&lt;/code&gt; 는 리소스, &lt;code&gt;event&lt;/code&gt; 는 OS 이벤트, &lt;code&gt;is_direct_call&lt;/code&gt; 은 &lt;code&gt;enif_select&lt;/code&gt; 에서 직접 호출 한 경우 true이고 예약 된 호출 인 경우 false (잠재적으로 다른 스레드에서)입니다.</target>
        </trans-unit>
        <trans-unit id="c45bd32e6496942fbb5d72602a01f8593df7f20d" translate="yes" xml:space="preserve">
          <source>The function prototype of a resource stop function, called on the behalf of &lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;obj&lt;/code&gt; is the resource, &lt;code&gt;event&lt;/code&gt; is OS event, &lt;code&gt;is_direct_call&lt;/code&gt; is true if the call is made directly from &lt;code&gt;enif_select&lt;/code&gt; or false if it is a scheduled call (potentially from another thread).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_select&quot;&gt;enif_select&lt;/a&gt;&lt;/code&gt; 대신 호출되는 자원 중지 기능의 함수 프로토 타입입니다 . &lt;code&gt;obj&lt;/code&gt; 는 자원, &lt;code&gt;event&lt;/code&gt; 는 OS 이벤트, &lt;code&gt;is_direct_call&lt;/code&gt; 은 &lt;code&gt;enif_select&lt;/code&gt; 에서 직접 호출하는 경우 true이고 예약 된 호출 인 경우 (다른 스레드에서 발생할 수있는 경우) false입니다.</target>
        </trans-unit>
        <trans-unit id="1a542d8fe620d3418f5d464c1378f2333ef053e8" translate="yes" xml:space="preserve">
          <source>The function raises a &lt;code&gt;error:badarg&lt;/code&gt; if the parameter is in wrong format. It may also raise the exception &lt;code&gt;error:notsup&lt;/code&gt; in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">매개 변수의 형식이 잘못된 경우 함수는 &lt;code&gt;error:badarg&lt;/code&gt; . 또한 기본 OpenSSL 구현에 엔진 지원이없는 경우 예외 &lt;code&gt;error:notsup&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fcf70416fe3769e7b0289554175c5f55debdb16" translate="yes" xml:space="preserve">
          <source>The function raises a &lt;code&gt;error:badarg&lt;/code&gt; if the parameters are in wrong format. It may also raise the exception &lt;code&gt;error:notsup&lt;/code&gt; in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">이 함수 는 매개 변수가 잘못된 형식 인 경우 &lt;code&gt;error:badarg&lt;/code&gt; . 또한 기본 OpenSSL 구현에 엔진 지원이없는 경우 예외 &lt;code&gt;error:notsup&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48037bd5e6edfdffb2f1110aafc54b00f51f984c" translate="yes" xml:space="preserve">
          <source>The function randomly selects one of the pids for registration and kills the other one.</source>
          <target state="translated">이 함수는 등록 할 pid 중 하나를 임의로 선택하고 다른 pid를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="305e01bbc8fe93b497a733f359ad553dd0edafee" translate="yes" xml:space="preserve">
          <source>The function randomly selects one of the pids for registration, and sends the message &lt;code&gt;{global_name_conflict, Name}&lt;/code&gt; to the other pid.</source>
          <target state="translated">이 함수는 등록 할 pid 중 하나를 임의로 선택하고 &lt;code&gt;{global_name_conflict, Name}&lt;/code&gt; 메시지 를 다른 pid로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8abbebafab7e64fd67ec141e6747533671416e1f" translate="yes" xml:space="preserve">
          <source>The function removes the &lt;code&gt;Key&lt;/code&gt;, if it exists, and its associated value from &lt;code&gt;Map1&lt;/code&gt; and returns a tuple with the removed &lt;code&gt;Value&lt;/code&gt; and the new map &lt;code&gt;Map2&lt;/code&gt; without key &lt;code&gt;Key&lt;/code&gt;. If the key does not exist &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">이 함수는 &lt;code&gt;Key&lt;/code&gt; 가있는 경우 &lt;code&gt;Map1&lt;/code&gt; 에서 관련 값을 제거 하고 &lt;code&gt;Key&lt;/code&gt; 가 없는 새로운 Map &lt;code&gt;Map2&lt;/code&gt; 가 제거 된 &lt;code&gt;Value&lt;/code&gt; 와 함께 튜플을 반환합니다 . 키가 없으면 &lt;code&gt;error&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e238717dba0649170fc233d2b4fe4554b94fb51d" translate="yes" xml:space="preserve">
          <source>The function reports &lt;code&gt;{error, {AppName,Reason}}&lt;/code&gt; for errors, where &lt;code&gt;Reason&lt;/code&gt; is any possible reason returned by &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; when starting a specific dependency.</source>
          <target state="translated">함수는 &lt;code&gt;{error, {AppName,Reason}}&lt;/code&gt; 대해 {error, {AppName, Reason}} 을보고합니다. 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 특정 종속성을 시작할 때 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴되는 가능한 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="76d19e4d2aef11065f3b75825b4b1412100e2c14" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; for &lt;code&gt;latin1&lt;/code&gt; encoding, as there is no BOM for ISO Latin-1.</source>
          <target state="translated">ISO Latin-1에 대한 BOM이 &lt;code&gt;latin1&lt;/code&gt; 함수는 latin1 인코딩에 대해 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cea6a4ed4ab166dce1a5c11aa39053c9e188fc54" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;1&lt;/code&gt; on successful decoding, &lt;code&gt;-1&lt;/code&gt; on error, and &lt;code&gt;0&lt;/code&gt; if the term seems alright, but does not fit in the &lt;code&gt;term&lt;/code&gt; structure. If &lt;code&gt;1&lt;/code&gt; is returned, the &lt;code&gt;index&lt;/code&gt; is incremented, and &lt;code&gt;term&lt;/code&gt; contains the decoded term.</source>
          <target state="translated">함수가 반환 &lt;code&gt;1&lt;/code&gt; 성공적인 디코딩에 &lt;code&gt;-1&lt;/code&gt; 오류에, 그리고 &lt;code&gt;0&lt;/code&gt; 이 용어는 괜찮아 보이지만에 맞지 않을 경우 &lt;code&gt;term&lt;/code&gt; 구조. 경우 &lt;code&gt;1&lt;/code&gt; 이 반환되면, &lt;code&gt;index&lt;/code&gt; 증가하고, &lt;code&gt;term&lt;/code&gt; 디코딩 된 용어가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0efff847bddce6b19a713a0f0517e02e510df4" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; if the event manager terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued using &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">이벤트 관리자가 예상 된 이유로 종료되면 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 이유로 &lt;code&gt;logger(3)&lt;/code&gt; 사용하여 오류 보고서가 발행됩니다 . 기본 &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c7b3421431470de3120253d455529b919367ac1" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; if the server terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued using &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">서버가 예상 된 이유로 종료되면 함수는 &lt;code&gt;ok&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 이유로 &lt;code&gt;logger(3)&lt;/code&gt; 사용하여 오류 보고서가 발행됩니다 . 기본 &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd73f7ab11de774d64402ce75fdbcce6bc66eb53" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt; or an error tuple where the second element contains the I/O error that made the writing impossible.</source>
          <target state="translated">이 함수는 &lt;code&gt;ok&lt;/code&gt; 또는 오류 튜플을 반환 하며, 두 번째 요소에는 쓰기 불가능한 I / O 오류가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8bcc68d7d1e1c02534b3299d71875a81aa57c0" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;ok&lt;/code&gt;, or terminates if an error occurs. For example, the transaction terminates if no &lt;code&gt;person&lt;/code&gt; table exists.</source>
          <target state="translated">이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환 하거나 오류가 발생하면 종료됩니다. 예를 들어 &lt;code&gt;person&lt;/code&gt; 테이블이 없으면 트랜잭션이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae9ce4bfa4732575d07ad75abe832d18209cf6d5" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;profiling&lt;/code&gt; if tracing could be enabled for all processes in &lt;code&gt;Rootset&lt;/code&gt;, or &lt;code&gt;error&lt;/code&gt; otherwise.</source>
          <target state="translated">함수가 반환 &lt;code&gt;profiling&lt;/code&gt; 추적 경우는 모두 프로세스를 가능하게 할 수 &lt;code&gt;Rootset&lt;/code&gt; , 또는 &lt;code&gt;error&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="82b7eb2d16fbf6159cd686bcbf5282210683decd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if all of the following apply:</source>
          <target state="translated">다음 사항이 모두 적용되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ade0bfc225f1f56359228ebdf66a4c04b123ddc2" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;yes&lt;/code&gt; if successful, &lt;code&gt;no&lt;/code&gt; if it fails. For example, &lt;code&gt;no&lt;/code&gt; is returned if an attempt is made to register an already registered process or to register a process with a name that is already in use.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;yes&lt;/code&gt; 를 , 실패하면 &lt;code&gt;no&lt;/code&gt; 를 리턴 합니다. 예를 들어, 이미 등록 된 프로세스를 등록하거나 이미 사용중인 이름으로 프로세스를 등록하려고하면 &lt;code&gt;no&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="00e48b1c0bb58c163a4b66da8eb059d14d44d0a7" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{Pos, Length}&lt;/code&gt; for the binary in &lt;code&gt;Pattern&lt;/code&gt;, starting at the lowest position in &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;Subject&lt;/code&gt; 의 가장 낮은 위치에서 시작하여 &lt;code&gt;Pattern&lt;/code&gt; 의 이진에 대해 &lt;code&gt;{Pos, Length}&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="51c7380f6ccd2c685f838a5778eff11acc171a3c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{SourceFile, Options}&lt;/code&gt; if it succeeds. &lt;code&gt;SourceFile&lt;/code&gt; is the absolute path to the source file without extension &lt;code&gt;&quot;.erl&quot;&lt;/code&gt;. &lt;code&gt;Options&lt;/code&gt; includes the options that are necessary to recompile the file with &lt;code&gt;compile:file/2&lt;/code&gt;, but excludes options such as &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;verbose&lt;/code&gt;, which do not change the way code is generated. The paths in options &lt;code&gt;{outdir, Path}&lt;/code&gt; and &lt;code&gt;{i, Path}&lt;/code&gt; are guaranteed to be absolute.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;{SourceFile, Options}&lt;/code&gt; 리턴 합니다. &lt;code&gt;SourceFile&lt;/code&gt; 은 확장자가 &lt;code&gt;&quot;.erl&quot;&lt;/code&gt; 없는 소스 파일의 절대 경로 입니다. &lt;code&gt;Options&lt;/code&gt; 에는 &lt;code&gt;compile:file/2&lt;/code&gt; 로 파일을 다시 컴파일하는 데 필요한 옵션이 포함 되지만 코드 생성 방식을 변경하지 않는 &lt;code&gt;report&lt;/code&gt; 및 &lt;code&gt;verbose&lt;/code&gt; 와 같은 옵션은 제외 됩니다. &lt;code&gt;{outdir, Path}&lt;/code&gt; 및 &lt;code&gt;{i, Path}&lt;/code&gt; 옵션의 경로는 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="95f12585f0eeb736eca25c313b53ecf1f8719509" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{error,Reason}&lt;/code&gt; if the module cannot be interpreted. &lt;code&gt;Reason&lt;/code&gt; can have the following values:</source>
          <target state="translated">모듈을 해석 할 수없는 경우 함수는 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;Reason&lt;/code&gt; 는 다음 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="327593fcc1fe364e7a22ff37db545a09532407de" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{error,eacces}&lt;/code&gt; if the directory is not readable or &lt;code&gt;{error,enoent}&lt;/code&gt; if the directory does not exist.</source>
          <target state="translated">디렉토리를 읽을 수 없으면 함수는 &lt;code&gt;{error,eacces}&lt;/code&gt; 를, 디렉토리가 없으면 &lt;code&gt;{error,enoent}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="9a6679cb30215fd3bbce3430d53f63d245192cc6" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{ok, Node}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the new node, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; can be one of:</source>
          <target state="translated">이 함수는 &lt;code&gt;{ok, Node}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;Node&lt;/code&gt; 는 새 노드의 이름이고, 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; . 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="926a41dded8f50f5bd40efe538f9bd8d662e5429" translate="yes" xml:space="preserve">
          <source>The function returns a list with one element for each matching object, where each element is an ordered list of pattern variable bindings, for example:</source>
          <target state="translated">이 함수는 일치하는 각 객체에 대해 하나의 요소가있는 목록을 반환합니다. 여기서 각 요소는 패턴 변수 바인딩의 순서가 지정된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c01260885c607c47bbd11e7381cdc0b60fb8c504" translate="yes" xml:space="preserve">
          <source>The function returns a map with each info item as a key-value binding. It reflects the &quot;current&quot; state of the socket.</source>
          <target state="translated">이 함수는 각 정보 항목이있는지도를 키-값 바인딩으로 반환합니다. 소켓의 &quot;현재&quot;상태를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="ef467049df8eebfb47a732dfe257b75164507468" translate="yes" xml:space="preserve">
          <source>The function returns a new list.</source>
          <target state="translated">이 함수는 새로운 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e921d3a34acd22129663174bed5a4222ddb5120" translate="yes" xml:space="preserve">
          <source>The function returns a tuple &lt;code&gt;{Replies,BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of &lt;code&gt;{Node,Reply}&lt;/code&gt; and &lt;code&gt;BadNodes&lt;/code&gt; is a list of node that either did not exist, or where the &lt;code&gt;gen_server&lt;/code&gt;&lt;code&gt;Name&lt;/code&gt; did not exist or did not reply.</source>
          <target state="translated">이 함수는 튜플 &lt;code&gt;{Replies,BadNodes}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Replies&lt;/code&gt; 는 &lt;code&gt;{Node,Reply}&lt;/code&gt; 의 목록 이고 &lt;code&gt;BadNodes&lt;/code&gt; 는 존재하지 않거나 &lt;code&gt;gen_server&lt;/code&gt; &lt;code&gt;Name&lt;/code&gt; 이 없거나 응답하지 않은 노드의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="b1e8d384f3de9f24fc9976775486188b88a64ca7" translate="yes" xml:space="preserve">
          <source>The function returns according to the specification of an instrumentation function.</source>
          <target state="translated">이 기능은 계측 기능의 사양에 따라 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba15e145974c7c4548255818d03130da786830bb" translate="yes" xml:space="preserve">
          <source>The function returns an Erlang term, or &lt;code&gt;NULL&lt;/code&gt; if &lt;code&gt;FormatStr&lt;/code&gt; does not describe a valid Erlang term.</source>
          <target state="translated">이 함수는 얼랑 용어, 또는 반환 &lt;code&gt;NULL&lt;/code&gt; 을 경우 &lt;code&gt;FormatStr&lt;/code&gt; 이 유효한 얼랑 용어를 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20d4b4c1eb81a80672dfa3e1318640bf99f38f85" translate="yes" xml:space="preserve">
          <source>The function returns an error if the &lt;code&gt;gen_server&lt;/code&gt; dies before or during this request.</source>
          <target state="translated">이 요청 이전 또는 도중에 &lt;code&gt;gen_server&lt;/code&gt; 가 종료 되면 함수는 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ae52a90d30017820af1ffe0ce8677dcbf3b9b5b1" translate="yes" xml:space="preserve">
          <source>The function returns an error if the &lt;code&gt;gen_statem&lt;/code&gt; dies before or during this function call.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 이이 함수 호출 전이나 도중에 죽으면 함수는 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="11a81e87db2b38c5cec76146c753586ae76e4c9f" translate="yes" xml:space="preserve">
          <source>The function returns an error if the &lt;code&gt;gen_statem&lt;/code&gt; dies before or during this request.</source>
          <target state="translated">이 요청 이전 또는 도중에 &lt;code&gt;gen_statem&lt;/code&gt; 이 종료 되면 함수는 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="84b04ee2da4370d4c96804f7728600a7d4958614" translate="yes" xml:space="preserve">
          <source>The function returns either an error tuple or a tuple &lt;code&gt;{ok, List}&lt;/code&gt;. The &lt;code&gt;List&lt;/code&gt; consists of specifications of how many functions that matched, in the same way as the processes and ports are presented in the return value of &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 오류 튜플 또는 튜플 &lt;code&gt;{ok, List}&lt;/code&gt; 반환합니다 . &lt;code&gt;List&lt;/code&gt; 프로세스와 포트의 반환 값에 표시되는 것과 같은 방식으로, 일치하는 것이 얼마나 많은 기능의 사양으로 구성되어 &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d21dcef371a5ecd35b72bec7696fdaf8da45b8eb" translate="yes" xml:space="preserve">
          <source>The function returns either an error tuple or a tuple &lt;code&gt;{ok, List}&lt;/code&gt;. The &lt;code&gt;List&lt;/code&gt; consists of specifications of how many processes and ports that matched (in the case of a pure pid() exactly 1). The specification of matched processes is &lt;code&gt;{matched, Node, N}&lt;/code&gt;. If the remote processor call, &lt;code&gt;rpc&lt;/code&gt;, to a remote node fails, the &lt;code&gt;rpc&lt;/code&gt; error message is delivered as a fourth argument and the number of matched processes are 0. Note that the result {ok, List} may contain a list where &lt;code&gt;rpc&lt;/code&gt; calls to one, several or even all nodes failed.</source>
          <target state="translated">이 함수는 오류 튜플 또는 튜플 &lt;code&gt;{ok, List}&lt;/code&gt; 반환합니다 . &lt;code&gt;List&lt;/code&gt; (순수 PID () 정확히 1의 경우) 일치하는 것이 얼마나 많은 프로세스와 포트의 사양으로 구성되어 있습니다. 일치하는 프로세스의 사양은 &lt;code&gt;{matched, Node, N}&lt;/code&gt; 입니다. 원격 노드에 대한 원격 프로세서 호출 &lt;code&gt;rpc&lt;/code&gt; 가 실패하면 &lt;code&gt;rpc&lt;/code&gt; 오류 메시지가 네 번째 인수로 전달되고 일치하는 프로세스 수는 0입니다. 결과 {ok, List}에는 &lt;code&gt;rpc&lt;/code&gt; 가 호출 하는 목록이 포함될 수 있습니다. 하나, 여러 또는 심지어 모든 노드가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="dff9f8ac1b740a28f21f75b322ee576a5c1a3db8" translate="yes" xml:space="preserve">
          <source>The function returns either an error tuple or a tuple &lt;code&gt;{ok, List}&lt;/code&gt;. The &lt;code&gt;List&lt;/code&gt; consists of specifications of how many processes and ports that matched (in the case of a pure pid() exactly 1). The specification of matched processes is &lt;code&gt;{matched, Node, N}&lt;/code&gt;. If the remote processor call,&lt;code&gt;rpc&lt;/code&gt;, to a remote node fails, the &lt;code&gt;rpc&lt;/code&gt; error message is delivered as a fourth argument and the number of matched processes are 0. Note that the result {ok, List} may contain a list where &lt;code&gt;rpc&lt;/code&gt; calls to one, several or even all nodes failed.</source>
          <target state="translated">이 함수는 오류 튜플 또는 튜플 &lt;code&gt;{ok, List}&lt;/code&gt; 반환합니다 . &lt;code&gt;List&lt;/code&gt; (순수 PID () 정확히 1의 경우) 일치하는 것이 얼마나 많은 프로세스와 포트의 사양으로 구성되어 있습니다. 일치하는 프로세스의 스펙은 &lt;code&gt;{matched, Node, N}&lt;/code&gt; 입니다. 원격 노드에 대한 원격 프로세서 호출 &lt;code&gt;rpc&lt;/code&gt; 가 실패하면 &lt;code&gt;rpc&lt;/code&gt; 오류 메시지가 네 번째 인수로 전달되고 일치하는 프로세스 수가 0입니다. 결과 {ok, List}에는 &lt;code&gt;rpc&lt;/code&gt; 가 호출 하는 목록이 포함될 수 있습니다. 하나, 여러 개 또는 모든 노드가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="47ce2b2bb012a9e9a4743dfb100ef52ab194f4a8" translate="yes" xml:space="preserve">
          <source>The function returns one of the following statuses upon success:</source>
          <target state="translated">이 함수는 성공하면 다음 상태 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af80ca7f3d62f6cac6e62e9f90f2843e1b33444b" translate="yes" xml:space="preserve">
          <source>The function returns the answer &lt;code&gt;Reply&lt;/code&gt; as produced by the server &lt;code&gt;Name&lt;/code&gt;, or &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">이 함수는 서버 &lt;code&gt;Name&lt;/code&gt; 또는 &lt;code&gt;{error, Reason}&lt;/code&gt; 의해 생성 된 응답 &lt;code&gt;Reply&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6fa69a661585fbc212f6bcd6110e5d9551001a6f" translate="yes" xml:space="preserve">
          <source>The function returns the list of file names of all created modules, including any automatically created stub modules. The file name of the target module is always first in the list.</source>
          <target state="translated">이 함수는 자동으로 작성된 스텁 모듈을 포함하여 작성된 모든 모듈의 파일 이름 목록을 리턴합니다. 대상 모듈의 파일 이름은 항상 목록에서 첫 번째입니다.</target>
        </trans-unit>
        <trans-unit id="67e6d37d8f8ed9b75d952e7999fb2087c89daf86" translate="yes" xml:space="preserve">
          <source>The function returns the number of objects deleted from the table.</source>
          <target state="translated">이 함수는 테이블에서 삭제 된 개체 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f97fd237860bed04d4fc7be045423bcf8705b592" translate="yes" xml:space="preserve">
          <source>The function returns the number of objects matched.</source>
          <target state="translated">이 함수는 일치하는 개체 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c874ae6f3ce13ecf61704660eadd7378f687f995" translate="yes" xml:space="preserve">
          <source>The function returns the pid() of a handler process, that does the supervision on behalf of the client application. Note that the client application is linked to this handler.</source>
          <target state="translated">이 함수는 클라이언트 응용 프로그램 대신 감독을 수행하는 처리기 프로세스의 pid ()를 반환합니다. 클라이언트 애플리케이션은이 핸들러에 링크되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8826e27f40bae39e6afc8b99ead67cefc85ed51f" translate="yes" xml:space="preserve">
          <source>The function returns the test result, represented by the tuple &lt;code&gt;{Ok,Failed,{UserSkipped,AutoSkipped}}&lt;/code&gt;, where each element is an integer. If test execution fails, the function returns the tuple &lt;code&gt;{error,Reason}&lt;/code&gt;, where the term &lt;code&gt;Reason&lt;/code&gt; explains the failure.</source>
          <target state="translated">이 함수는 튜플 &lt;code&gt;{Ok,Failed,{UserSkipped,AutoSkipped}}&lt;/code&gt; 로 표시되는 테스트 결과를 리턴합니다 . 여기서 각 요소는 정수입니다. 테스트 실행이 실패하면이 함수는 튜플 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴하며 , 여기서 &lt;code&gt;Reason&lt;/code&gt; 라는 용어 는 실패를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="66053340efa519d76743820bb26595016a5a05f7" translate="yes" xml:space="preserve">
          <source>The function returns the total number of replaced objects.</source>
          <target state="translated">이 함수는 교체 된 총 객체 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13b54d91784d634be011a5d8f40eca029f4c1437" translate="yes" xml:space="preserve">
          <source>The function returns when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled.</source>
          <target state="translated">이 함수는 응답이 도착할 때, 요청 타이머가 결국 시간 초과되거나 미해결 요청이 명시 적으로 취소 될 때 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0e911cfd5f3fbfe1f052ffaa063943cb8b0fe46c" translate="yes" xml:space="preserve">
          <source>The function returns:</source>
          <target state="translated">이 함수는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9be9148ebe8c1af83ecb810b37aa82c15bf5d001" translate="yes" xml:space="preserve">
          <source>The function should now return:</source>
          <target state="translated">함수는 이제 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="89ceb7fdfb37fece3ab74b229b8cea9443cca0bd" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the driver is not present in the system or if the tag is not supported.</source>
          <target state="translated">드라이버가 시스템에 없거나 태그가 지원되지 않으면 이 함수는 &lt;code&gt;badarg&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="95ce52efa32ec5a1e922545d8dfcff54dd9fa145" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the driver is not present in the system.</source>
          <target state="translated">시스템에 드라이버가없는 &lt;code&gt;badarg&lt;/code&gt; 함수는 잘못된 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e2803735d718719dbf8ff59057508925d737d41f" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the parameter is not a &lt;code&gt;reference()&lt;/code&gt;.</source>
          <target state="translated">매개 변수가 &lt;code&gt;reference()&lt;/code&gt; 가 아닌 경우 함수는 &lt;code&gt;badarg&lt;/code&gt; 예외를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="66d20dcf7ad9c489aba044486ad7cfb8ef93a242" translate="yes" xml:space="preserve">
          <source>The function throws a &lt;code&gt;badarg&lt;/code&gt; exception if the parameters are not specified as described here.</source>
          <target state="translated">여기에 설명 된대로 매개 변수를 지정하지 않으면 함수에서 &lt;code&gt;badarg&lt;/code&gt; 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5d9e44a0ad0773f97c4f379d41e06e651c358097" translate="yes" xml:space="preserve">
          <source>The function throws a badarg if the parameter is in wrong format. It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">매개 변수의 형식이 잘못된 경우 함수는 잘못된 인수를 발생시킵니다. 기본 OpenSSL 구현에서 엔진을 지원하지 않는 경우 예외가 발생하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda733b256a520d564c901fe8c2c263fe4e56cd1" translate="yes" xml:space="preserve">
          <source>The function throws a badarg if the parameters are in wrong format. It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">매개 변수의 형식이 잘못된 경우 함수에서 잘못된 인수를 표시합니다. 기본 OpenSSL 구현에서 엔진을 지원하지 않는 경우 예외가 발생하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c1041afe84cb2dbdbb948e8208c9f84bf59ebd" translate="yes" xml:space="preserve">
          <source>The function unregisters both pids and sends the message &lt;code&gt;{global_name_conflict, Name, OtherPid}&lt;/code&gt; to both processes.</source>
          <target state="translated">이 함수는 두 pid를 모두 등록 취소하고 &lt;code&gt;{global_name_conflict, Name, OtherPid}&lt;/code&gt; 메시지 를 두 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c3a1f79b06aa96385eb181ed86fb6eae9b5e9415" translate="yes" xml:space="preserve">
          <source>The function waits for user input, and does not return until the remote shell is ended (that is, exit from the shell).</source>
          <target state="translated">이 함수는 사용자 입력을 대기하고 원격 쉘이 종료 될 때까지 (즉, 쉘에서 나갈 때까지) 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8892ca0441d17488cdcc2015a61701f971adb9a" translate="yes" xml:space="preserve">
          <source>The function will also return an error if the node &lt;code&gt;Nodename&lt;/code&gt; is not reachable.</source>
          <target state="translated">노드 &lt;code&gt;Nodename&lt;/code&gt; 에 도달 할 수없는 경우이 함수는 오류를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fe48f3115cf0be1263ce3632f413691699d232ac" translate="yes" xml:space="preserve">
          <source>The function will also return the &lt;code&gt;Name&lt;/code&gt; instead of the table identifier. To get the table identifier of a named table, use &lt;code&gt;&lt;a href=&quot;#whereis-1&quot;&gt;whereis/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 또한 테이블 식별자 대신 &lt;code&gt;Name&lt;/code&gt; 을 반환합니다 . 명명 된 테이블의 테이블 식별자를 얻으려면 &lt;code&gt;&lt;a href=&quot;#whereis-1&quot;&gt;whereis/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc605a27b48f7b91fedc8d92d1b0ced2f10b5eee" translate="yes" xml:space="preserve">
          <source>The function will return an error, either due to I/O problems (like a non existing or non readable file) or due to file format problems. The errors from a bad format file are in a more or less textual format, which will give a hint to what's causing the problem.</source>
          <target state="translated">함수는 I / O 문제 (기존 파일이 아니거나 읽을 수없는 파일과 같은) 또는 파일 형식 문제로 인해 오류를 반환합니다. 잘못된 형식 파일의 오류는 다소 텍스트 형식으로되어있어 문제의 원인에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1192b2e61e715c06fc73aea33efb68d8d4e10a72" translate="yes" xml:space="preserve">
          <source>The function will throw an exception if the &lt;code&gt;dyntrace&lt;/code&gt; NIF library could not be loaded by the on_load function of this module.</source>
          <target state="translated">이 모듈의 on_load 함수로 &lt;code&gt;dyntrace&lt;/code&gt; NIF 라이브러리를로드 할 수없는 경우 함수에서 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="877225bff459640b7fb2492bce96b16257fca8af" translate="yes" xml:space="preserve">
          <source>The function works as &lt;code&gt;ei_reg_send&lt;/code&gt; with one exception. Instead of taking &lt;code&gt;ei_cnode&lt;/code&gt; as first argument, it takes a second argument, an &lt;code&gt;erlang_pid&lt;/code&gt;, which is to be the process identifier of the sending process (in the Erlang distribution protocol).</source>
          <target state="translated">이 함수는 한 가지 예외를 제외 하고 &lt;code&gt;ei_reg_send&lt;/code&gt; 로 작동합니다 . &lt;code&gt;ei_cnode&lt;/code&gt; 를 첫 번째 인수로 사용 하는 대신 두 번째 인수 인 &lt;code&gt;erlang_pid&lt;/code&gt; 를 사용하여 송신 프로세스의 프로세스 식별자 (Erlang 배포 프로토콜)가됩니다.</target>
        </trans-unit>
        <trans-unit id="96c1202d0cd6c2fd8c2454e3ec64b0d84b6bd072" translate="yes" xml:space="preserve">
          <source>The functionality described in EEP10 was implemented in Erlang/OTP R13A.</source>
          <target state="translated">EEP10에 설명 된 기능은 Erlang / OTP R13A에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="f4c5930ab45c4ff48e920b1f1f0e771ba10a38ad" translate="yes" xml:space="preserve">
          <source>The functionality of &lt;code&gt;server&lt;/code&gt; can be extended without having to change &lt;code&gt;ch2&lt;/code&gt; or any other callback module.</source>
          <target state="translated">&lt;code&gt;ch2&lt;/code&gt; 또는 다른 콜백 모듈 을 변경하지 않고도 &lt;code&gt;server&lt;/code&gt; 의 기능을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48f14231d4eef3bc5aa0ed1eace23a7c88ba429a" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;crypto#crypto_init-4&quot;&gt;crypto_init/4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; are intended to be used for encrypting or decrypting a sequence of blocks. First one call of &lt;code&gt;crypto_init/4&lt;/code&gt; initialises the crypto context. One or more calls &lt;code&gt;crypto_update/2&lt;/code&gt; does the actual encryption or decryption for each block.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;crypto#crypto_init-4&quot;&gt;crypto_init/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; 함수 는 일련의 블록을 암호화하거나 해독하는 데 사용됩니다. &lt;code&gt;crypto_init/4&lt;/code&gt; 의 첫 번째 호출은 암호화 컨텍스트를 초기화합니다. 하나 이상의 호출 &lt;code&gt;crypto_update/2&lt;/code&gt; 가 각 블록에 대해 실제 암호화 또는 복호화를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="42a7b913d2b289987ee5e2464734af014db9f20b" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;ct#set_verbosity-2&quot;&gt;ct:set_verbosity/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#get_verbosity-1&quot;&gt;ct:get_verbosity/1&lt;/a&gt;&lt;/code&gt; may be used to modify and read verbosity levels during test execution.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct#set_verbosity-2&quot;&gt;ct:set_verbosity/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct#get_verbosity-1&quot;&gt;ct:get_verbosity/1&lt;/a&gt;&lt;/code&gt; 함수 는 테스트 실행 중 자세한 레벨을 수정하고 읽는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1225e34207e05c6490636b16c61c626ac7fd8103" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt; anno_from_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt; anno_to_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt; mapfold_anno()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt;, in the &lt;code&gt;erl_parse&lt;/code&gt; module can be used for manipulating annotations in abstract code.</source>
          <target state="translated">[함수 &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt; anno_from_term()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt; anno_to_term()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt; mapfold_anno()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt; 는에 &lt;code&gt;erl_parse&lt;/code&gt; 의 모듈 추상 코드에 주석을 조작하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4e9c838a14637c7a4c6ed49ae71fd28e08b8189c" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt;anno_from_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt;anno_to_term()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt;mapfold_anno()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt;, in the &lt;code&gt;erl_parse&lt;/code&gt; module can be used for manipulating annotations in abstract code.</source>
          <target state="translated">[함수 &lt;code&gt;&lt;a href=&quot;erl_parse#anno_from_term-1&quot;&gt;anno_from_term()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#anno_to_term-1&quot;&gt;anno_to_term()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#fold_anno-3&quot;&gt;fold_anno()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#map_anno-2&quot;&gt;map_anno()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_parse#mapfold_anno-3&quot;&gt;mapfold_anno()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erl_parse#new_anno-1&quot;&gt;new_anno()&lt;/a&gt;&lt;/code&gt; 는에 &lt;code&gt;erl_parse&lt;/code&gt; 의 모듈 추상 코드에 주석을 조작하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4ef5f76ccaeeff0245cc5352fd37788847bc8dd4" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;erl_scan#column-1&quot;&gt;column()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#end_location-1&quot;&gt;end_location()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#line-1&quot;&gt;line()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_scan#location-1&quot;&gt;location()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;erl_scan#text-1&quot;&gt;text()&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;erl_scan&lt;/code&gt; module can be used for inspecting annotations in tokens.</source>
          <target state="translated">기능의 &lt;code&gt;&lt;a href=&quot;erl_scan#column-1&quot;&gt;column()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_scan#end_location-1&quot;&gt;end_location()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_scan#line-1&quot;&gt;line()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;erl_scan#location-1&quot;&gt;location()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;erl_scan#text-1&quot;&gt;text()&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;erl_scan&lt;/code&gt; 모듈 토큰에 특수 효과를 검사하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="8f1eb93f5b31a056ece4e165a375a5884952e8c6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; can be used to add and delete replicas of the schema table. Adding a node to the list of nodes where the schema is replicated affects the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 스키마 테이블의 복제본을 추가하고 삭제할 수 있습니다. 스키마가 복제되는 노드 목록에 노드를 추가하면 다음에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="1886785ff0b77240f1ec57a522b97c8411209098" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#select-4&quot;&gt;select/4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; are used to get a limited number of results, where &lt;code&gt;Continuation&lt;/code&gt; gets the next chunk of results. &lt;code&gt;Mnesia&lt;/code&gt; uses &lt;code&gt;NObjects&lt;/code&gt; as a recommendation only. Thus, more or less results than specified with &lt;code&gt;NObjects&lt;/code&gt; can be returned in the result list, even the empty list can be returned even if there are more results to collect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#select-4&quot;&gt;select/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#select-2&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 함수 는 제한된 수의 결과를 얻는 데 사용되며, 여기서 &lt;code&gt;Continuation&lt;/code&gt; 은 다음 결과 덩어리를 가져옵니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 사용 &lt;code&gt;NObjects&lt;/code&gt; 을 만 추천한다. 따라서 &lt;code&gt;NObjects&lt;/code&gt; 지정된 것보다 많거나 적은 결과가 결과 목록에 리턴 될 수 있으며, 수집 할 결과가 더 있어도 빈 목록이 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="902b2335f36e3393b5572f1006845ff1177285c7" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(master_node_tables)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, master_nodes)&lt;/a&gt;&lt;/code&gt; can be used to obtain information about the potential master nodes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#system_info-1&quot;&gt;mnesia:system_info(master_node_tables)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, master_nodes)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 잠재적 마스터 노드에 대한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7162f97290d0f08d1d6fce536552b6112fd005e" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;add_one&lt;/code&gt; can now be expressed in terms of &lt;code&gt;map&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;add_one&lt;/code&gt; 함수 는 이제 다음과 같이 &lt;code&gt;map&lt;/code&gt; 으로 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="222156c9e6dd9e3d178176d3e89b557b47249290" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;add_one&lt;/code&gt; have a similar structure. This can be used by writing a function &lt;code&gt;map&lt;/code&gt; that expresses this similarity:</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;add_one&lt;/code&gt; 함수 는 유사한 구조를 갖습니다. 이 유사성을 나타내는 함수 &lt;code&gt;map&lt;/code&gt; 을 작성하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="648f7da232361f38f861a299d3f2d536886a367c" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;first/[1,2]&lt;/code&gt;, &lt;code&gt;last/[1,2]&lt;/code&gt;, &lt;code&gt;next/[1,2]&lt;/code&gt;, &lt;code&gt;prev[1,2]&lt;/code&gt; and &lt;code&gt;select/[3,4]&lt;/code&gt; assumes there is a result set associated with the connection to work on. Calling the function &lt;code&gt;select_count/[2,3]&lt;/code&gt; associates such a result set with the connection. Calling select_count again will remove the current result set association and create a new one. Calling a function which dose not operate on an associated result sets, such as &lt;code&gt;sql_query/[2,3]&lt;/code&gt;, will remove the current result set association.</source>
          <target state="translated">기능 &lt;code&gt;first/[1,2]&lt;/code&gt; , &lt;code&gt;last/[1,2]&lt;/code&gt; , &lt;code&gt;next/[1,2]&lt;/code&gt; , &lt;code&gt;prev[1,2]&lt;/code&gt; 및 &lt;code&gt;select/[3,4]&lt;/code&gt; 접속과 연관된 결과 세트가 있다고 가정 작업합니다. &lt;code&gt;select_count/[2,3]&lt;/code&gt; 함수를 호출하면 이러한 결과 세트가 연결과 연관됩니다. select_count를 다시 호출하면 현재 결과 세트 연관이 제거되고 새로 작성됩니다. &lt;code&gt;sql_query/[2,3]&lt;/code&gt; 과 같이 연관된 결과 세트에서 작동하지 않는 함수를 호출 하면 현재 결과 세트 연관이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f5fc6fff1054bde43efdc57cd822c6d67516d395" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;get_s&lt;/code&gt; and &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; are utilities that are used to make the code shorter. &lt;code&gt;get_s&lt;/code&gt; duplicates the string and zero-terminates it, as the postgres client library wants that. &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; takes an &lt;code&gt;ei_x_buff&lt;/code&gt; buffer, allocates a binary, and copies the data there. This binary is returned in &lt;code&gt;*rbuf&lt;/code&gt;. (Notice that this binary is freed by the emulator, not by us.)</source>
          <target state="translated">&lt;code&gt;get_s&lt;/code&gt; 및 &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; 함수 는 코드를 더 짧게 만드는 데 사용되는 유틸리티입니다. &lt;code&gt;get_s&lt;/code&gt; 는 postgres 클라이언트 라이브러리가 원하는대로 문자열을 복제하고 0으로 종료합니다. &lt;code&gt;ei_x_to_new_binary&lt;/code&gt; 는 &lt;code&gt;ei_x_buff&lt;/code&gt; 버퍼를 가져와 이진을 할당 한 다음 여기에 데이터를 복사합니다. 이 바이너리는 &lt;code&gt;*rbuf&lt;/code&gt; 로 반환됩니다 . (이 바이너리는 우리가 아닌 에뮬레이터에 의해 해제됩니다.)</target>
        </trans-unit>
        <trans-unit id="5096e39491b69e094a3f98629aa50fa1108f0a5e" translate="yes" xml:space="preserve">
          <source>The functions above have an optional argument, &lt;code&gt;Options&lt;/code&gt;. It is a list which can contain the following elements:</source>
          <target state="translated">위의 함수에는 옵션 인수 &lt;code&gt;Options&lt;/code&gt; 있습니다. 다음 요소를 포함 할 수있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4cf9cf212abd94252e34e02e2e21ec1dc4af5994" translate="yes" xml:space="preserve">
          <source>The functions allowed in &lt;code&gt;match_spec&lt;/code&gt; work as follows:</source>
          <target state="translated">&lt;code&gt;match_spec&lt;/code&gt; 에서 허용되는 함수 는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b49c5e0b193b751df77e5b417fa995fca0d1e1a2" translate="yes" xml:space="preserve">
          <source>The functions allowed only for tracing work as follows:</source>
          <target state="translated">추적 작업에만 허용되는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c59774d7c82f25fd515f4adf4619a3b207d21571" translate="yes" xml:space="preserve">
          <source>The functions are</source>
          <target state="translated">기능은</target>
        </trans-unit>
        <trans-unit id="c38557bf4878ec1f68819130f6538837da45503c" translate="yes" xml:space="preserve">
          <source>The functions are also used as input and output for parse transforms, see the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">함수는 구문 분석 변환의 입력 및 출력으로도 사용됩니다 &lt;code&gt;compile(3)&lt;/code&gt; 모듈 참조 ) .</target>
        </trans-unit>
        <trans-unit id="b767ef0cfc20ad008772285b7b151d13f3e95f0c" translate="yes" xml:space="preserve">
          <source>The functions are deliberately kept as simple as possible, for readability reasons.</source>
          <target state="translated">가독성을 위해 기능은 가능한 한 단순하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="45f09a589c0917e05c505ec254a5e8229659ac40" translate="yes" xml:space="preserve">
          <source>The functions are executed sequentially in an initialization process, which then terminates normally and passes control to the user. This means that a &lt;code&gt;-run&lt;/code&gt; call that does not return blocks further processing; to avoid this, use some variant of &lt;code&gt;spawn&lt;/code&gt; in such cases.</source>
          <target state="translated">기능은 초기화 프로세스에서 순차적으로 실행 된 다음 정상적으로 종료되고 사용자에게 제어를 전달합니다. 이는 리턴하지 않는 &lt;code&gt;-run&lt;/code&gt; 호출이 추가 처리를 차단 함을 의미합니다 . 이런 경우를 피하기 위해 &lt;code&gt;spawn&lt;/code&gt; 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="926aaaf3b21fb32d1bbb6e4c88da0fdf9d06509c" translate="yes" xml:space="preserve">
          <source>The functions are executed sequentially in an initialization process, which then terminates normally and passes control to the user. This means that a &lt;code&gt;-s&lt;/code&gt; call that does not return blocks further processing; to avoid this, use some variant of &lt;code&gt;spawn&lt;/code&gt; in such cases.</source>
          <target state="translated">기능은 초기화 프로세스에서 순차적으로 실행 된 다음 정상적으로 종료되고 사용자에게 제어를 전달합니다. 이는 리턴하지 않는 &lt;code&gt;-s&lt;/code&gt; 호출이 추가 처리를 차단 함을 의미합니다 . 이런 경우를 피하기 위해 &lt;code&gt;spawn&lt;/code&gt; 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="16b3d921f3dab11c8bd9dcd981b467c9ea9eb69b" translate="yes" xml:space="preserve">
          <source>The functions are kept for backward compatibility, but are not recommended. They will be deprecated in a future release.</source>
          <target state="translated">기능은 이전 버전과의 호환성을 위해 유지되지만 권장되지는 않습니다. 향후 릴리스에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e16c3bfea1464fe2701a69fbec438e22d449fa1c" translate="yes" xml:space="preserve">
          <source>The functions can crash for non-valid input strings. For example, the functions expect UTF-8 binaries but not all functions verify that all binaries are encoded correctly.</source>
          <target state="translated">유효하지 않은 입력 문자열에 대해 함수가 충돌 할 수 있습니다. 예를 들어, 함수는 UTF-8 바이너리를 예상하지만 모든 함수가 모든 바이너리가 올바르게 인코딩되었는지 확인하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dd2b5b372777bf5bb017e0da931269beb671e840" translate="yes" xml:space="preserve">
          <source>The functions for receiving and sending data are combined into a function, pointed out by the driver structure. The data sent into the port is given as arguments, and the replied data is sent with the C-function &lt;code&gt;driver_output&lt;/code&gt;.</source>
          <target state="translated">데이터 수신 및 전송 기능은 드라이버 구조에 의해 지적 된 기능으로 결합됩니다. 포트로 전송 된 데이터는 인수로 제공되며 응답 된 데이터는 C 함수 &lt;code&gt;driver_output&lt;/code&gt; 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebbfff7f1d8a39c016464e3f5cebc0cf7001e164" translate="yes" xml:space="preserve">
          <source>The functions implemented by this module cover the following use cases:</source>
          <target state="translated">이 모듈로 구현 된 기능은 다음 사용 사례를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c86b667b04bbb8c7ab1bce69786f4f6966eec074" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;systools&lt;/code&gt; require more information. If they are used, the following keys are mandatory:</source>
          <target state="translated">&lt;code&gt;systools&lt;/code&gt; 의 기능 에는 추가 정보가 필요합니다. 이들이 사용되는 경우 다음 키는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="2c1aa340d685d0c3733736a0ada3b9ea70cc9c9a" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;io&lt;/code&gt; module cannot be used, as they can only talk to an Erlang process. Instead, use functions &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈 의 기능 은 Erlang 프로세스와 만 대화 할 수 있으므로 사용할 수 없습니다. 대신, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#read_line-1&quot;&gt;read_line/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a25876dba4377f3e108142ac910ecc80fd99f8dd" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;timer&lt;/code&gt; module that do not manage timers (such as &lt;code&gt;timer:tc/3&lt;/code&gt; or &lt;code&gt;timer:sleep/1&lt;/code&gt;), do not call the timer-server process and are therefore harmless.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 관리하지 않는 타이머 모듈 의 기능 (예 : &lt;code&gt;timer:tc/3&lt;/code&gt; 또는 &lt;code&gt;timer:sleep/1&lt;/code&gt; )은 타이머 서버 프로세스를 호출하지 않으므로 무해합니다.</target>
        </trans-unit>
        <trans-unit id="bc5c8ab81c744e8799da4f1bbc208d8534384ca8" translate="yes" xml:space="preserve">
          <source>The functions in the module &lt;code&gt;file&lt;/code&gt; usually treat binaries as raw filenames, that is, they are passed &quot;as is&quot; even when the encoding of the binary does not agree with &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding()&lt;/a&gt;&lt;/code&gt;. However, this function expects binaries to be encoded according to the value returned by &lt;code&gt;native_name_encoding()&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;file&lt;/code&gt; 의 함수는 일반적으로 바이너리를 원시 파일 이름으로 취급합니다. 즉, 바이너리의 인코딩이 &lt;code&gt;&lt;a href=&quot;#native_name_encoding-0&quot;&gt;native_name_encoding()&lt;/a&gt;&lt;/code&gt; 과 일치하지 않더라도 &quot;있는 그대로&quot;전달됩니다 . 그러나이 함수는 &lt;code&gt;native_name_encoding()&lt;/code&gt; 반환 한 값에 따라 바이너리가 인코딩 될 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="59fe37bf337f659a6dcf2745738cdc7eba91db8e" translate="yes" xml:space="preserve">
          <source>The functions in this module are invoked automatically by the Erlang compiler. There is no reason to invoke these functions separately unless you have written your own Erlang compiler.</source>
          <target state="translated">이 모듈의 함수는 Erlang 컴파일러에 의해 자동으로 호출됩니다. Erlang 컴파일러를 직접 작성하지 않은 경우 이러한 함수를 별도로 호출 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="83d017ac05dd2cacc80880c2e28d8a757b9c1403" translate="yes" xml:space="preserve">
          <source>The functions in this module are operating system-specific. Careless use of these functions results in programs that will only run on a specific platform. On the other hand, with careful use, these functions can be of help in enabling a program to run on most platforms.</source>
          <target state="translated">이 모듈의 기능은 운영 체제별로 다릅니다. 이러한 기능을 부주의하게 사용하면 특정 플랫폼에서만 실행되는 프로그램이 생성됩니다. 반면에 이러한 기능은주의해서 사용하면 대부분의 플랫폼에서 프로그램을 실행하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0090b523e8b96e6009643e2f865f32e534e6e35f" translate="yes" xml:space="preserve">
          <source>The functions in this module are used to generate aesthetically attractive representations of abstract forms, which are suitable for printing. All functions return (possibly deep) lists of characters and generate an error if the form is wrong.</source>
          <target state="translated">이 모듈의 기능은 인쇄에 적합한 추상 형태의 미적으로 매력적인 표현을 생성하는 데 사용됩니다. 모든 함수는 문자 목록을 리턴하고 (양식이 깊은 경우) 양식이 잘못된 경우 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6379807804d510c1358bcad10b50d619a7c10261" translate="yes" xml:space="preserve">
          <source>The functions in this module exits with reason &lt;code&gt;badarg&lt;/code&gt; if any argument has the wrong format, if the table identifier is invalid, or if the operation is denied because of table access rights (&lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 모듈의 함수는 인수의 형식이 올바르지 않거나 테이블 ID가 유효하지 않거나 테이블 액세스 권한 ( &lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt; )으로 인해 조작이 거부 된 경우 이유 &lt;code&gt;badarg&lt;/code&gt; 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc4e34b42033b4ee07c7be4497100db14c7aae27" translate="yes" xml:space="preserve">
          <source>The functions make references to a debug structure. The debug structure is a list of &lt;code&gt;dbg_opt()&lt;/code&gt;, which is an internal data type used by function &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt;. No debugging is performed if it is an empty list.</source>
          <target state="translated">함수는 디버그 구조를 참조합니다. 디버그 구조는 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 함수에서 사용하는 내부 데이터 유형 인 &lt;code&gt;dbg_opt()&lt;/code&gt; 목록입니다 . 목록이 비어 있으면 디버깅이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="407acf4eb1d452f08e4cd9870e0fbf1bd80ec28b" translate="yes" xml:space="preserve">
          <source>The functions make references to a debug structure. The debug structure is a list of &lt;code&gt;dbg_opt()&lt;/code&gt;, which is an internal data type used by function &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt;. No debugging is performed if it is an empty list.</source>
          <target state="translated">함수는 디버그 구조를 참조합니다. 디버그 구조는 &lt;code&gt;dbg_opt()&lt;/code&gt; 의 목록이며 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 함수가 사용하는 내부 데이터 유형 입니다. 빈 목록이면 디버깅이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95e0480086d8c1cfed57c30b1e75f554c1263ba9" translate="yes" xml:space="preserve">
          <source>The functions of this module exit the process with a &lt;code&gt;badarg&lt;/code&gt;, &lt;code&gt;bad_function&lt;/code&gt;, or &lt;code&gt;type_mismatch&lt;/code&gt; message when given badly formed arguments or sets the types of which are not compatible.</source>
          <target state="translated">이 모듈의 함수는 잘못 구성된 인수가 제공되거나 호환되지 않는 유형을 설정하면 &lt;code&gt;badarg&lt;/code&gt; , &lt;code&gt;bad_function&lt;/code&gt; 또는 &lt;code&gt;type_mismatch&lt;/code&gt; 메시지 와 함께 프로세스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="8bcd836e7cff1f3fb60829e13f437e52a77a3d68" translate="yes" xml:space="preserve">
          <source>The functions returns &lt;code&gt;{module,Module}&lt;/code&gt; if the module was interpreted, otherwise &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">모듈이 해석되면 함수는 &lt;code&gt;{module,Module}&lt;/code&gt; 을 리턴 하고 그렇지 않으면 &lt;code&gt;error&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c5ba17f384a51d8defb699da21623e5d4d6f29" translate="yes" xml:space="preserve">
          <source>The functions with explicit state never use the process dictionary.</source>
          <target state="translated">명시 적 상태의 함수는 프로세스 사전을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1dee609877073beca17837c5cc489fd792ebd7be" translate="yes" xml:space="preserve">
          <source>The functions with implicit state use the process dictionary variable &lt;code&gt;rand_seed&lt;/code&gt; to remember the current state.</source>
          <target state="translated">암시 적 상태의 함수는 프로세스 사전 변수 &lt;code&gt;rand_seed&lt;/code&gt; 를 사용하여 현재 상태를 기억합니다.</target>
        </trans-unit>
        <trans-unit id="3598aafeb02f3f06b45b8fa49e0ea66cd9f4c8c2" translate="yes" xml:space="preserve">
          <source>The fundamental difference between this API and &lt;code&gt;connect/*&lt;/code&gt; is that the return value is that of the underlying OS &lt;code&gt;connect(2)&lt;/code&gt; system call. If &lt;code&gt;ok&lt;/code&gt; is returned, the result of the association establishment is received by the calling process as an &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; event. The calling process must be prepared to receive this, or poll for it using &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;, depending on the value of the active option.</source>
          <target state="translated">이 API와 &lt;code&gt;connect/*&lt;/code&gt; 의 근본적인 차이점 은 반환 값이 기본 OS &lt;code&gt;connect(2)&lt;/code&gt; 시스템 호출 의 값이라는 것입니다 . 경우에 &lt;code&gt;ok&lt;/code&gt; 리턴 된 관계 성립의 결과로는 호출 프로세스에 의해 수신 &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; 이벤트. 호출 프로세스는이를 수신하거나 활성 옵션의 값에 따라 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 를 사용하여 폴링하도록 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="988b6a9c1d9ecd81d685b26b761fdee058fdc894" translate="yes" xml:space="preserve">
          <source>The gain is twofold:</source>
          <target state="translated">이득은 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="bcf404e4d234a44441e22cb6261963b4fedd0d7d" translate="yes" xml:space="preserve">
          <source>The gain of using selective and exclusive decode instead of a complete decode is greater the bigger the value and the less deep in the structure you have to decode.</source>
          <target state="translated">완전한 디코딩 대신 선택적 및 배타적 디코딩을 사용하면 값이 클수록 디코딩해야하는 구조의 깊이가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="fe50c99cca6dabfaacf57c3d4d8ac0b0024f73ef" translate="yes" xml:space="preserve">
          <source>The garbage collector can also shrink the heap if it is much larger than the amount of data stored on it; setting the minimum heap size prevents that.</source>
          <target state="translated">가비지 수집기는 힙에 저장된 데이터 양보다 훨씬 큰 경우 힙을 축소 할 수도 있습니다. 최소 힙 크기를 설정하면이를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977899977ecd5bafb69cd4c8bac5e829e78b713f" translate="yes" xml:space="preserve">
          <source>The general events are as follows:</source>
          <target state="translated">일반적인 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="149747bf3dd15b14e96b6d254e71d9518355ab2e" translate="yes" xml:space="preserve">
          <source>The general filter rule.</source>
          <target state="translated">일반 필터 규칙.</target>
        </trans-unit>
        <trans-unit id="0a45457862e4fc4686a75b757e6f11948bde74a0" translate="yes" xml:space="preserve">
          <source>The general form of bit strings is &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are positive integers. It denotes a bit string that is &lt;code&gt;M + (k*N)&lt;/code&gt; bits long (that is, a bit string that starts with &lt;code&gt;M&lt;/code&gt; bits and continues with &lt;code&gt;k&lt;/code&gt; segments of &lt;code&gt;N&lt;/code&gt; bits each, where &lt;code&gt;k&lt;/code&gt; is also a positive integer). The notations &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; are convenient shorthands for the cases that &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt;, or both, are zero.</source>
          <target state="translated">비트 문자열의 일반적인 형식은 &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt; 이며 여기서 &lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;N&lt;/code&gt; 은 양의 정수입니다. 이는 &lt;code&gt;M + (k*N)&lt;/code&gt; 비트 길이 의 비트 열을 나타냅니다 (즉, &lt;code&gt;M&lt;/code&gt; 비트로 시작하고 각각 &lt;code&gt;N&lt;/code&gt; 비트 의 &lt;code&gt;k&lt;/code&gt; 세그먼트로 계속되는 비트 열 ). &lt;code&gt;k&lt;/code&gt; 는 양의 정수입니다. &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 표기법 은 &lt;code&gt;M&lt;/code&gt; 또는 &lt;code&gt;N&lt;/code&gt; 또는 둘 모두가 0 인 경우 편리한 속기입니다 .</target>
        </trans-unit>
        <trans-unit id="fdbe665310c13decea46f0a344ac730f430a21b1" translate="yes" xml:space="preserve">
          <source>The general form of bit strings is &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; must evaluate to positive integers. It denotes a bit string that is &lt;code&gt;M + (k*N)&lt;/code&gt; bits long (that is, a bit string that starts with &lt;code&gt;M&lt;/code&gt; bits and continues with &lt;code&gt;k&lt;/code&gt; segments of &lt;code&gt;N&lt;/code&gt; bits each, where &lt;code&gt;k&lt;/code&gt; is also a positive integer). The notations &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; are convenient shorthands for the cases that &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt;, or both, are zero.</source>
          <target state="translated">비트 문자열의 일반적인 형식은 &lt;code&gt;&amp;lt;&amp;lt;_:M, _:_*N&amp;gt;&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;M&lt;/code&gt; 과 &lt;code&gt;N&lt;/code&gt; 은 양의 정수로 평가되어야합니다. &lt;code&gt;M + (k*N)&lt;/code&gt; 비트 길이 의 비트 문자열을 나타냅니다 (즉, &lt;code&gt;M&lt;/code&gt; 비트로 시작하고 각각 &lt;code&gt;N&lt;/code&gt; 비트 의 &lt;code&gt;k&lt;/code&gt; 세그먼트로 계속되는 비트 문자열 , 여기서 &lt;code&gt;k&lt;/code&gt; 도 양의 정수임). 표기법 &lt;code&gt;&amp;lt;&amp;lt;_:_*N&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;_:M&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 또는 &lt;code&gt;N&lt;/code&gt; 또는 둘 다 0 인 경우에 대한 편리한 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="5c496d2449f6d9b0afc626a9e7f68cb4481df6a7" translate="yes" xml:space="preserve">
          <source>The general form of map types is &lt;code&gt;#{AssociationList}&lt;/code&gt;. The key types in &lt;code&gt;AssociationList&lt;/code&gt; are allowed to overlap, and if they do, the leftmost association takes precedence. A map association has a key in &lt;code&gt;AssociationList&lt;/code&gt; if it belongs to this type. &lt;code&gt;AssociationList&lt;/code&gt; can contain both mandatory &lt;code&gt;(:=)&lt;/code&gt; and optional &lt;code&gt;(=&amp;gt;)&lt;/code&gt; association types. If an association type is mandatory, an association with that type needs to be present. In the case of an optional association type it is not required for the key type to be present.</source>
          <target state="translated">지도 유형의 일반적인 형식은 &lt;code&gt;#{AssociationList}&lt;/code&gt; 입니다. &lt;code&gt;AssociationList&lt;/code&gt; 의 키 유형은 겹칠 수 있으며 중복되는 경우 가장 왼쪽에있는 연관이 우선합니다. 맵 연관 이이 유형에 속하는 경우 &lt;code&gt;AssociationList&lt;/code&gt; 에 키가 있습니다. &lt;code&gt;AssociationList&lt;/code&gt; 는 필수 &lt;code&gt;(:=)&lt;/code&gt; 및 선택적 &lt;code&gt;(=&amp;gt;)&lt;/code&gt; 연관 유형을 모두 포함 할 수 있습니다 . 연관 유형이 필수 인 경우 해당 유형과의 연관이 있어야합니다. 선택적 연관 유형의 경우 키 유형이 존재하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="15c107121f9e396eb9a5cd9589f0c40d15c3390b" translate="yes" xml:space="preserve">
          <source>The general form of map types is &lt;code&gt;#{AssociationList}&lt;/code&gt;. The key types in &lt;code&gt;AssociationList&lt;/code&gt; are allowed to overlap, and if they do, the leftmost association takes precedence. A map association has a key in &lt;code&gt;AssociationList&lt;/code&gt; if it belongs to this type. &lt;code&gt;AssociationList&lt;/code&gt; can contain both mandatory and optional association types. If an association type is mandatory, an association with that type is to be present. In the case of an optional association type it is not required for the key type to be present.</source>
          <target state="translated">맵 유형의 일반적인 형식은 &lt;code&gt;#{AssociationList}&lt;/code&gt; 입니다. &lt;code&gt;AssociationList&lt;/code&gt; 의 키 유형은 겹칠 수 있으며, 그 경우 가장 왼쪽의 연결이 우선합니다. 맵 연관 이이 유형에 속하는 경우 &lt;code&gt;AssociationList&lt;/code&gt; 에 키가 있습니다. &lt;code&gt;AssociationList&lt;/code&gt; 는 필수 및 선택적 연관 유형을 모두 포함 할 수 있습니다. 연결 유형이 필수 인 경우 해당 유형과의 연결이 있어야합니다. 선택적 연결 유형의 경우 키 유형이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd29c112a6f953361a2bf7c31389b1ff11da8c85" translate="yes" xml:space="preserve">
          <source>The general form of the 'socket' message is:</source>
          <target state="translated">'소켓'메시지의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa26e067e726a95a6d2e3dc44ecd0d512cccd537" translate="yes" xml:space="preserve">
          <source>The general format of a control sequence is &lt;code&gt;~F.P.PadModC&lt;/code&gt;.</source>
          <target state="translated">제어 순서의 일반적인 형식은 &lt;code&gt;~F.P.PadModC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48292e72b50e679a5bd265d2003a203029b9008b" translate="yes" xml:space="preserve">
          <source>The general repetition quantifier specifies a minimum and maximum number of permitted matches, by giving the two numbers in curly brackets (braces), separated by a comma. The numbers must be &amp;lt; 65536, and the first must be less than or equal to the second. For example, the following matches &quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;:</source>
          <target state="translated">일반 반복 수량 화기는 두 개의 숫자를 중괄호 (중괄호)로 묶어 쉼표로 구분하여 허용되는 일치 항목의 최소 및 최대 수를 지정합니다. 숫자는 &amp;lt;65536이어야하고 첫 번째는 두 번째보다 작거나 같아야합니다. 예를 들어, 다음은 &quot;zz&quot;, &quot;zzz&quot;또는 &quot;zzzz&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e8ceed6edc3f642d5944e6d5d983920ce28f447b" translate="yes" xml:space="preserve">
          <source>The general verbosity level is not associated with any particular category. This level sets the threshold for the standard I/O printouts, uncategorized &lt;code&gt;ct:log/print/pal&lt;/code&gt; printouts, and printouts for categories with undefined verbosity level.</source>
          <target state="translated">일반적인 상세 수준은 특정 범주와 관련이 없습니다. 이 레벨은 표준 I / O 출력, 분류되지 않은 &lt;code&gt;ct:log/print/pal&lt;/code&gt; 출력 및 정의되지 않은 상세 레벨이있는 ​​카테고리의 출력에 대한 임계 값을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="15f1ac9edee948d6f4ef43892cbf77bf286d9bf4" translate="yes" xml:space="preserve">
          <source>The generated .script (and .boot) file uses the environment variable &lt;code&gt;$RELTOOL_EXT_LIB&lt;/code&gt; as prefix for the paths to all applications. The &lt;code&gt;-boot_var&lt;/code&gt; option to &lt;code&gt;erl&lt;/code&gt; can be used for specifying the value of this variable, typically &lt;code&gt;-boot_var RELTOOL_EXT_LIB &amp;lt;target-dir&amp;gt;/lib&lt;/code&gt;.</source>
          <target state="translated">생성 된 .script (및 .boot) 파일은 환경 변수 &lt;code&gt;$RELTOOL_EXT_LIB&lt;/code&gt; 를 모든 애플리케이션에 대한 경로의 접두어로 사용합니다. &lt;code&gt;erl&lt;/code&gt; 에 대한 &lt;code&gt;-boot_var&lt;/code&gt; 옵션 은이 변수의 값을 지정하는 데 사용할 수 있습니다 (일반적으로 &lt;code&gt;-boot_var RELTOOL_EXT_LIB &amp;lt;target-dir&amp;gt;/lib&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="0c99eee4f85e52f6340a9da42977768f1eebdd2c" translate="yes" xml:space="preserve">
          <source>The generated Erlang files are placed in the current directory or in the directory specified with option &lt;code&gt;{outdir,Dir}&lt;/code&gt;.</source>
          <target state="translated">생성 된 Erlang 파일은 현재 디렉토리 또는 &lt;code&gt;{outdir,Dir}&lt;/code&gt; 옵션으로 지정된 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c577f200898187404181ae175171d50fcb091818" translate="yes" xml:space="preserve">
          <source>The generated Erlang module always gets the same name as the &lt;code&gt;ASN.1&lt;/code&gt; module. Therefore, only one encoding rule per &lt;code&gt;ASN.1&lt;/code&gt; module can be used at runtime.</source>
          <target state="translated">생성 된 Erlang 모듈은 항상 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 과 동일한 이름을 갖습니다 . 따라서 런타임시 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 당 하나의 인코딩 규칙 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b514f46ec7f6b4c60827848dbf2c26c322ce6aab" translate="yes" xml:space="preserve">
          <source>The generated code looks like this:</source>
          <target state="translated">생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fc9a629a78265b39c4931fa85c066a035d12976" translate="yes" xml:space="preserve">
          <source>The generated conversion functions are named &lt;code&gt;name2num_EnumTypeName/1&lt;/code&gt; and &lt;code&gt;num2name_EnumTypeName/1&lt;/code&gt;.</source>
          <target state="translated">생성 된 변환 함수의 이름은 &lt;code&gt;name2num_EnumTypeName/1&lt;/code&gt; 및 &lt;code&gt;num2name_EnumTypeName/1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="70590dbda20778e7131e69e54b148688eb50a6db" translate="yes" xml:space="preserve">
          <source>The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval.</source>
          <target state="translated">생성 된 숫자는 N * 2.0 ^ (-53) 형식입니다. 간격이 똑같습니다.</target>
        </trans-unit>
        <trans-unit id="d46f1c06452ab11c5b4b6ecb5baaa5c431f8b627" translate="yes" xml:space="preserve">
          <source>The generated numbers from this function has got better granularity for small numbers than the regular &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example &lt;code&gt;1.0 / X&lt;/code&gt; or &lt;code&gt;math:log(X)&lt;/code&gt;.</source>
          <target state="translated">가수의 모든 비트가 무작위이기 때문에이 함수에서 생성 된 숫자는 일반 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자에 대해 더 세분화되었습니다 . 이 속성은 정확히 0이 반환되지 않는다는 사실과 함께 &lt;code&gt;1.0 / X&lt;/code&gt; 또는 &lt;code&gt;math:log(X)&lt;/code&gt; 와 같은 알고리즘에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="73171ef35be5bd8ba621019aa17e69f855a0576a" translate="yes" xml:space="preserve">
          <source>The generated numbers from this function has got better granularity for small numbers than the regular &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example &lt;code&gt;1.0 / X&lt;/code&gt; or &lt;code&gt;math:log(X)&lt;/code&gt;.</source>
          <target state="translated">가수의 모든 비트가 무작위이기 때문에이 함수에서 생성 된 숫자는 일반 &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자에 대해 더 세분화되었습니다 . 이 속성은 정확히 0이 반환되지 않는다는 사실과 함께 &lt;code&gt;1.0 / X&lt;/code&gt; 또는 &lt;code&gt;math:log(X)&lt;/code&gt; 와 같은 알고리즘에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="9601b63aa3ab5a33ac60d263c74f85eedd8bb618" translate="yes" xml:space="preserve">
          <source>The generation of default functions for tables works for tables which use the &lt;code&gt;RowStatus&lt;/code&gt; textual convention from SNMPv2, defined in STANDARD-MIB and SNMPv2-TC.</source>
          <target state="translated">테이블의 기본 기능 생성은 STANDARD-MIB 및 SNMPv2-TC에 정의 된 SNMPv2 의 &lt;code&gt;RowStatus&lt;/code&gt; 텍스트 규칙 을 사용하는 테이블에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eba83a7da2528325534c6072ae7bcfeeb1f8ae2" translate="yes" xml:space="preserve">
          <source>The generational hypothesis predicts that most terms tend to die young (see D. Ungar in &lt;code&gt;&lt;a href=&quot;#References&quot;&gt;References&lt;/a&gt;&lt;/code&gt;), and for an immutable language such as Erlang, young terms die even faster than in other languages. So for most usage patterns the data in the new heap will die very soon after it is allocated. This is good because it limits the amount of data copied to the old heap and also because the garbage collection algorithm used is proportional to the amount of live data on the heap.</source>
          <target state="translated">세대 별 가설은 대부분의 용어가 어릴 때 죽는 경향이 있으며 (참조 D. Ungar &lt;code&gt;&lt;a href=&quot;#References&quot;&gt;References&lt;/a&gt;&lt;/code&gt; ) Erlang과 같은 불변 언어의 경우 젊은 용어가 다른 언어보다 훨씬 더 빨리 죽는다고 예측합니다 . 따라서 대부분의 사용 패턴에서 새 힙의 데이터는 할당 된 직후에 사라집니다. 이는 이전 힙에 복사되는 데이터의 양을 제한하고 사용되는 가비지 수집 알고리즘이 힙의 라이브 데이터 양에 비례하기 때문에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="821e9c0846e4f65c9117ead5ceea8748b753ad3a" translate="yes" xml:space="preserve">
          <source>The generator does not need 58-bit rotates so it is faster than the Xoroshiro116 generator, and when combined with the StarStar scrambler it does not have any weak low bits like &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116+).</source>
          <target state="translated">생성기는 58 비트 회전이 필요하지 않으므로 Xoroshiro116 생성기보다 빠르며 StarStar 스크램블러와 결합하면 &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116 +) 과 같은 약한 낮은 비트가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a98f897827fbccc29809d0ff98a0c6185bd547f8" translate="yes" xml:space="preserve">
          <source>The generator function &lt;code&gt;GenFun&lt;/code&gt; is called to produce a test set.</source>
          <target state="translated">생성기 함수 &lt;code&gt;GenFun&lt;/code&gt; 은 테스트 세트를 생성하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1f65b0f29d2eaf723597fb4ded6e5f61662cb2a0" translate="yes" xml:space="preserve">
          <source>The generator now contains unbound variables and the test has been moved into the filter.</source>
          <target state="translated">제너레이터는 이제 언 바운드 변수를 포함하고 테스트는 필터로 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="df67d175f37e161fc283f4c21214ba8ff79c07f4" translate="yes" xml:space="preserve">
          <source>The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment:</source>
          <target state="translated">일반 URI 구문은 체계, 권한, 경로, 쿼리 및 조각이라고하는 계층 적 구성 요소 시퀀스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="edcc58c1f9412f2d84d5eca2fbc303265ca32bc7" translate="yes" xml:space="preserve">
          <source>The generic encode and decode functions can be called as follows:</source>
          <target state="translated">일반 인코딩 및 디코딩 기능은 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6a0f25dc460ac798f2b85a01f268cff421ca237" translate="yes" xml:space="preserve">
          <source>The generic full name of the file is thus:</source>
          <target state="translated">파일의 일반 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="953d4c56983eabeb70f721a6678334568e77d77a" translate="yes" xml:space="preserve">
          <source>The given BEAM file (with or without the &lt;code&gt;.beam&lt;/code&gt; extension) or the file found by calling &lt;code&gt;code:which(Module)&lt;/code&gt; is checked for calls to &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt;, calls to &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt;, and for unused local functions. The code path is used as &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 BEAM 파일 ( &lt;code&gt;.beam&lt;/code&gt; 확장자 가 있거나없는 ) 또는 &lt;code&gt;code:which(Module)&lt;/code&gt; 을 호출하여 찾은 파일 은 &lt;code&gt;&lt;a href=&quot;#deprecated_function&quot;&gt;deprecated functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 , &lt;code&gt;&lt;a href=&quot;#undefined_function&quot;&gt;undefined functions&lt;/a&gt;&lt;/code&gt; 에 대한 호출 및 사용되지 않은 로컬 함수에 대해 검사됩니다. 코드 경로는 &lt;code&gt;&lt;a href=&quot;#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c55cafbe9ce836bf9c8c850c2f1eba5d102da3a" translate="yes" xml:space="preserve">
          <source>The global atomic variables &lt;code&gt;erts_active_bp_index&lt;/code&gt; will determine which generation of breakpoints running code will use.</source>
          <target state="translated">전역 원자 변수 &lt;code&gt;erts_active_bp_index&lt;/code&gt; 는 코드를 실행할 중단 점 생성을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e66a4ab696e12e0f12a8dd69e7f5bb33fedf0273" translate="yes" xml:space="preserve">
          <source>The global name server also performs the critical task of continuously monitoring changes in node configuration. If a node that runs a globally registered process goes down, the name is globally unregistered. To this end, the global name server subscribes to &lt;code&gt;nodeup&lt;/code&gt; and &lt;code&gt;nodedown&lt;/code&gt; messages sent from module &lt;code&gt;net_kernel&lt;/code&gt;. Relevant Kernel application variables in this context are &lt;code&gt;net_setuptime&lt;/code&gt;, &lt;code&gt;net_ticktime&lt;/code&gt;, and &lt;code&gt;dist_auto_connect&lt;/code&gt;. See also &lt;code&gt;kernel(6)&lt;/code&gt;.</source>
          <target state="translated">글로벌 이름 서버는 또한 노드 구성의 변경 사항을 지속적으로 모니터링하는 중요한 작업을 수행합니다. 전역으로 등록 된 프로세스를 실행하는 노드가 작동 중지되면 이름이 전체적으로 등록 취소됩니다. 이를 위해 글로벌 네임 서버가 등록한 정보는 다음의 제품에 &lt;code&gt;nodeup&lt;/code&gt; 및 &lt;code&gt;nodedown&lt;/code&gt; 메시지는 모듈에서 전송 &lt;code&gt;net_kernel&lt;/code&gt; . 이 컨텍스트에서 관련 커널 응용 프로그램 변수는 &lt;code&gt;net_setuptime&lt;/code&gt; , &lt;code&gt;net_ticktime&lt;/code&gt; 및 &lt;code&gt;dist_auto_connect&lt;/code&gt; 입니다. &lt;code&gt;kernel(6)&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f36454620d0c52943c78b70c7b2d67415456c6b" translate="yes" xml:space="preserve">
          <source>The global name server keeps track of all processes sharing the same lock, that is, if two processes set the same lock, both processes must delete the lock.</source>
          <target state="translated">전역 이름 서버는 동일한 잠금을 공유하는 모든 프로세스를 추적합니다. 즉, 두 프로세스가 동일한 잠금을 설정하면 두 프로세스 모두 잠금을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="46c28148b1520b8f7f30b407f534c21425582a89" translate="yes" xml:space="preserve">
          <source>The global state of the scanner, represented by the #xmerl_scanner{} record.</source>
          <target state="translated">#xmerl_scanner {} 레코드로 표시되는 스캐너의 전역 상태입니다.</target>
        </trans-unit>
        <trans-unit id="162600e8983ca6d0de97e2e5c21045cca4665270" translate="yes" xml:space="preserve">
          <source>The global state of the validator. It is representated by the &lt;code&gt;#xsd_state{}&lt;/code&gt; record.</source>
          <target state="translated">유효성 검사기의 전역 상태입니다. 그것은에 의해 representated됩니다 &lt;code&gt;#xsd_state{}&lt;/code&gt; 기록.</target>
        </trans-unit>
        <trans-unit id="1531d8568b38b4970f1055504bbf9c235ba48c8c" translate="yes" xml:space="preserve">
          <source>The grammar starts with an optional &lt;code&gt;header&lt;/code&gt; section. The header is put first in the generated file, before the module declaration. The purpose of the header is to provide a means to make the documentation generated by EDoc look nicer. Each header line should be enclosed in double quotes, and newlines will be inserted between the lines. For example:</source>
          <target state="translated">문법은 선택적인 &lt;code&gt;header&lt;/code&gt; 섹션 으로 시작 합니다. 헤더는 생성 된 파일에서 먼저 모듈 선언 전에 배치됩니다. 헤더의 목적은 EDoc에 의해 생성 된 문서를 더보기 좋게 만드는 수단을 제공하는 것입니다. 각 머리글 줄은 큰 따옴표로 묶어야하며 줄 사이에 줄 바꿈이 삽입됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95e4974bf09526a8ed59c2c706017450837fabc7" translate="yes" xml:space="preserve">
          <source>The granularity of both measurement types can be high. Therefore, ensure that each individual measurement lasts for at least several seconds.</source>
          <target state="translated">두 측정 유형의 입도는 높을 수 있습니다. 따라서 각 개별 측정이 최소한 몇 초 동안 지속되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="db89aebec1f27ef7ea7b0173203949ea669de4bc" translate="yes" xml:space="preserve">
          <source>The graphical library &lt;code&gt;wx&lt;/code&gt; has extensive support for Unicode text.</source>
          <target state="translated">그래픽 라이브러리 &lt;code&gt;wx&lt;/code&gt; 는 유니 코드 텍스트를 광범위하게 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3809a7766a11eb66968ebebc3b973ccfe307fc2b" translate="yes" xml:space="preserve">
          <source>The group information properties override those set with the suite information function, and can in turn be overridden by test case information properties. For a list of valid information properties and more general information, see the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그룹 정보 특성은 스위트 정보 기능으로 설정된 특성을 대체하며 테스트 케이스 정보 특성으로 대체 될 수 있습니다. 유효한 정보 특성 및보다 일반적인 정보의 목록은 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1851720cf81d08f4729a487b12a49fba130b63d" translate="yes" xml:space="preserve">
          <source>The group leader should be rarely changed in applications with a supervision tree, because OTP assumes the group leader of their processes is their application master.</source>
          <target state="translated">OTP는 프로세스의 그룹 리더가 애플리케이션 마스터라고 가정하기 때문에 감독 트리가있는 애플리케이션에서는 그룹 리더를 거의 변경하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e52640716213a6b8b724c7b3e51f40080bcd9da2" translate="yes" xml:space="preserve">
          <source>The group path specification does not necessarily have to include &lt;strong&gt;all&lt;/strong&gt; groups in the path to the terminating group. &lt;code&gt;Common Test&lt;/code&gt; searches for all matching paths if an incomplete group path is specified.</source>
          <target state="translated">그룹 경로 지정은 반드시 종료 그룹에 대한 경로에 &lt;strong&gt;모든&lt;/strong&gt; 그룹 을 포함 할 필요는 없습니다 . 불완전한 그룹 경로가 지정되면 &lt;code&gt;Common Test&lt;/code&gt; 는 일치하는 모든 경로를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="6fc0b568a02963a296071a7bbdb0400eec8c4cbb" translate="yes" xml:space="preserve">
          <source>The group specification feature, as presented in this section, can also be used in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; (with some extra features added).</source>
          <target state="translated">이 섹션에 제시된 그룹 사양 기능은 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 에서도 사용할 수 있습니다 (일부 추가 기능이 추가됨).</target>
        </trans-unit>
        <trans-unit id="75d39fc54f161038ac9929455075c4ce189bfbf6" translate="yes" xml:space="preserve">
          <source>The groups are given explicitly in this list. There may be several elements with the same &lt;code&gt;Size&lt;/code&gt;. In such a case, the server will choose one randomly in the negotiated Size.</source>
          <target state="translated">그룹은이 목록에 명시 적으로 제공됩니다. &lt;code&gt;Size&lt;/code&gt; 가 같은 여러 요소가있을 수 있습니다 . 이 경우 서버는 협상 된 크기에서 임의로 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="57c1aab7095657e5f03ad172fdff464c6e0393b1" translate="yes" xml:space="preserve">
          <source>The guard BIFs: &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;element&lt;/code&gt;, &lt;code&gt;hd&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;tl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">가드 BIF : &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;element&lt;/code&gt; , &lt;code&gt;hd&lt;/code&gt; , &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; , &lt;code&gt;tl&lt;/code&gt; , &lt;code&gt;trunc&lt;/code&gt; , &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf11284c55c81df64e31546d61edba51bacfcf93" translate="yes" xml:space="preserve">
          <source>The guard section can contain any guard expression of Erlang. The following is a list of BIFs and expressions:</source>
          <target state="translated">가드 섹션에는 Erlang의 가드 표현이 포함될 수 있습니다. 다음은 BIF 및 표현식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="08f011ebed41a7bf74303ee2b30d0e5329b2ea66" translate="yes" xml:space="preserve">
          <source>The guard sequence, if any, is true.</source>
          <target state="translated">가드 시퀀스 (있는 경우)는 true입니다.</target>
        </trans-unit>
        <trans-unit id="62bcf1415cac5f3dd57f1ebc576c5455597afa32" translate="yes" xml:space="preserve">
          <source>The guard test &lt;code&gt;literal_is_map/1&lt;/code&gt; tests whether the given literal is a map. If the literal is a map, the instruction is unnecessary and can be removed.</source>
          <target state="translated">가드 테스트 &lt;code&gt;literal_is_map/1&lt;/code&gt; 은 주어진 리터럴이 맵인지 여부를 테스트합니다. 리터럴이 맵이면 명령이 필요하지 않으며 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8132b6cdea54ba22a3ae68fa6e8356318a3eb501" translate="yes" xml:space="preserve">
          <source>The halfword emulator uses the super carrier implementation to manage its low memory mappings thar are needed for all term storage. The super carrier can here not be configured by command line options. One could imagine a second configurable instance of the super carrier used by high memory allocation, but that has not been implemented.</source>
          <target state="translated">하프 워드 에뮬레이터는 슈퍼 캐리어 구현을 사용하여 모든 용어 저장소에 필요한 낮은 메모리 매핑을 관리합니다. 여기서 슈퍼 캐리어는 명령 줄 옵션으로 구성 할 수 없습니다. 높은 메모리 할당에 사용되는 슈퍼 캐리어의 두 번째 구성 가능한 인스턴스를 상상할 수 있지만 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e7b45f8da83fb548c37fb358ea6dfad545fe99af" translate="yes" xml:space="preserve">
          <source>The handler has an overload protection mechanism that keeps the handler process and the Kernel application alive during high loads of log events. How overload protection works, and how to configure it, is described in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러에는 로그 이벤트가 많이로드되는 동안 핸들러 프로세스와 커널 애플리케이션을 활성 상태로 유지하는 과부하 보호 메커니즘이 있습니다. 과부하 보호의 작동 방식과 구성 방법은 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="49c4b028972dd181f72352fd5792e1cbd70780a8" translate="yes" xml:space="preserve">
          <source>The handler has an overload protection mechanism that keeps the handler process and the Kernel application alive during high loads of log events. How overload protection works, and how to configure it, is described in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">처리기에는 과부하 로그 메커니즘이있어 처리기 프로세스와 커널 응용 프로그램이 로그 이벤트가 많을 때에도 활성 상태를 유지합니다. 과부하 보호 작동 방식 및 구성 방법은 사용 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2de57b137d6629cde5167564ce3d26dcfae749ef" translate="yes" xml:space="preserve">
          <source>The handler identity is associated with the &lt;code&gt;id&lt;/code&gt; key in &lt;code&gt;Config1&lt;/code&gt;.</source>
          <target state="translated">핸들러 ID는 &lt;code&gt;Config1&lt;/code&gt; 의 &lt;code&gt;id&lt;/code&gt; 키 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eeb6be906051436af44ca3913114022b11b4c8a" translate="yes" xml:space="preserve">
          <source>The handler identity is associated with the &lt;code&gt;id&lt;/code&gt; key in &lt;code&gt;Config&lt;/code&gt;.</source>
          <target state="translated">핸들러 ID는 &lt;code&gt;Config&lt;/code&gt; 의 &lt;code&gt;id&lt;/code&gt; 키 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba56ddadb179e3c4c78c9f3318f09f731a34f26a" translate="yes" xml:space="preserve">
          <source>The handler identity is associated with the &lt;code&gt;id&lt;/code&gt; key in &lt;code&gt;OldConfig&lt;/code&gt;.</source>
          <target state="translated">핸들러 ID는 &lt;code&gt;OldConfig&lt;/code&gt; 의 &lt;code&gt;id&lt;/code&gt; 키와 연결 됩니다.</target>
        </trans-unit>
        <trans-unit id="88387fc69eaf6d2117329bee1a573a3818611863" translate="yes" xml:space="preserve">
          <source>The handler is not overload protected.</source>
          <target state="translated">처리기는 과부하 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7cc7f26c0b9fef31e9d9003214e5eb8f80f6985" translate="yes" xml:space="preserve">
          <source>The handler must log the event.</source>
          <target state="translated">핸들러는 이벤트를 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="91c3bfd8524a78feb62740d6ae1b2a4f89bcfb08" translate="yes" xml:space="preserve">
          <source>The handler process keeps track of the length of its message queue and takes some form of action when the current length exceeds a configurable threshold. The purpose is to keep the handler in, or to as quickly as possible get the handler into, a state where it can keep up with the pace of incoming log events. The memory use of the handler must never grow larger and larger, since that will eventually cause the handler to crash. These three thresholds, with associated actions, exist:</source>
          <target state="translated">핸들러 프로세스는 메시지 큐 길이를 추적하고 현재 길이가 구성 가능한 임계 값을 초과 할 때 어떤 형태의 조치를 취합니다. 처리기는 들어오는 로그 이벤트의 속도에 따라 처리기를 유지하거나 가능한 빨리 처리기를 가져 오는 것입니다. 핸들러의 메모리 사용은 커져서는 안됩니다. 결국 핸들러가 충돌 할 수 있습니다. 연관된 조치와 함께 다음 세 가지 임계 값이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="d669a7746b992304543fe0d69213b6644ee12b90" translate="yes" xml:space="preserve">
          <source>The handlers are called in sequence, and the order is not defined.</source>
          <target state="translated">핸들러는 순서대로 호출되며 순서는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa6b9a858fe6ebad4a9654a225cc08daa061a060" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated, and Perl has changed in recent releases, causing PCRE also to change. Outside a character class, PCRE reads the digit and any following digits as a decimal number. If the number is &amp;lt; 8, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a &lt;strong&gt;back reference&lt;/strong&gt;. A description of how this works is provided later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">백 슬래시 다음에 0 이외의 숫자를 처리하는 것은 복잡하며 Perl은 최근 릴리스에서 변경되어 PCRE도 변경되었습니다. 문자 클래스 외부에서 PCRE는 숫자와 다음 숫자를 10 진수로 읽습니다. 숫자가 &amp;lt;8이거나 표현식에 이전에 캡처 된 왼쪽 괄호가 많으면 전체 시퀀스가 &lt;strong&gt;역 참조로 사용&lt;/strong&gt; 됩니다. 이것의 작동 방식에 대한 설명은 괄호로 묶인 하위 패턴에 대한 설명에 따라 나중에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ce133ffa97494a3447425009d85e45fe4a4884e0" translate="yes" xml:space="preserve">
          <source>The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship is that both involve newlines. Dot has no special meaning in a character class.</source>
          <target state="translated">도트 처리는 곡절 및 달러 처리와 완전히 독립적이며, 유일한 관계는 둘 다 줄 바꿈과 관련이 있다는 것입니다. 도트는 문자 클래스에서 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="75675acc51f4abea249c539fbe54b590467b1b3e" translate="yes" xml:space="preserve">
          <source>The handshake will continue, but &lt;code&gt;A&lt;/code&gt; is informed that &lt;code&gt;B&lt;/code&gt; has another ongoing connection attempt that will be shut down (simultaneous connect where &lt;code&gt;A&lt;/code&gt;'s name is greater than &lt;code&gt;B&lt;/code&gt;'s name, compared literally).</source>
          <target state="translated">핸드 셰이크는 계속되지만 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;B&lt;/code&gt; 에 또 다른 연결 시도가 종료된다는 알림을받습니다 ( &lt;code&gt;A&lt;/code&gt; 의 이름이 &lt;code&gt;B&lt;/code&gt; 의 이름 보다 큰 동시 연결 은 문자 그대로 비교).</target>
        </trans-unit>
        <trans-unit id="aff3a3821cc248a671eac45e5517c958f3438bd4" translate="yes" xml:space="preserve">
          <source>The handshake will continue.</source>
          <target state="translated">핸드 셰이크가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c48205cabd15c9a3f6c801a9934891e2a4ee54fe" translate="yes" xml:space="preserve">
          <source>The handshake will not continue, as &lt;code&gt;B&lt;/code&gt; already has an ongoing handshake, which it itself has initiated (simultaneous connect where &lt;code&gt;B&lt;/code&gt;'s name is greater than &lt;code&gt;A&lt;/code&gt;'s).</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 에는 이미 핸드 셰이크가 진행 중이므로 핸드 셰이크가 계속되지 않습니다 ( &lt;code&gt;B&lt;/code&gt; 의 이름이 &lt;code&gt;A&lt;/code&gt; 보다 큰 동시 연결 ).</target>
        </trans-unit>
        <trans-unit id="72e0eb34a71e071e1bf667f76e1e7cd53ed3e052" translate="yes" xml:space="preserve">
          <source>The handshake willl continue, but &lt;code&gt;A&lt;/code&gt; requested a dynamic node name by setting flag &lt;code&gt;&lt;a href=&quot;#DFLAG_NAME_ME&quot;&gt; DFLAG_NAME_ME&lt;/a&gt;&lt;/code&gt;. The dynamic node name of &lt;code&gt;A&lt;/code&gt; is supplied at the end of the status message from &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">핸드 셰이크는 계속되지만 &lt;code&gt;A&lt;/code&gt; 는 플래그 &lt;code&gt;&lt;a href=&quot;#DFLAG_NAME_ME&quot;&gt; DFLAG_NAME_ME&lt;/a&gt;&lt;/code&gt; 를 설정하여 동적 노드 이름을 요청했습니다 . &lt;code&gt;A&lt;/code&gt; 의 동적 노드 이름은 &lt;code&gt;B&lt;/code&gt; 의 상태 메시지 끝에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a492d4993cb9390498042b969391a3f2772dbec" translate="yes" xml:space="preserve">
          <source>The hardware watchdog timer, which is controlled by the &lt;code&gt;heart&lt;/code&gt; port program, requires package &lt;code&gt;FORCEvme&lt;/code&gt;, which contains the VME bus driver, to be installed. However, this driver can clash with the Sun &lt;code&gt;mcp&lt;/code&gt; driver and cause the system to refuse to boot. To cure this problem, the following lines are to be added to &lt;code&gt;/etc/system&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;heart&lt;/code&gt; 포트 프로그램으로 제어되는 하드웨어 감시 타이머 에는 VME 버스 드라이버가 포함 된 &lt;code&gt;FORCEvme&lt;/code&gt; 패키지 가 설치되어 있어야합니다. 그러나이 드라이버는 Sun &lt;code&gt;mcp&lt;/code&gt; 드라이버와 충돌 하여 시스템 부팅을 거부 할 수 있습니다. 이 문제를 해결하려면 &lt;code&gt;/etc/system&lt;/code&gt; 에 다음 행을 추가해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="125af3159613fc9036721ee12ed405dbec75519c" translate="yes" xml:space="preserve">
          <source>The head contains pointers to beginning of the list (&lt;code&gt;head.first&lt;/code&gt;), and to the first block which other threads may refer to (&lt;code&gt;head.unref_end&lt;/code&gt;). Blocks between these pointers are only refered to by the head part of the data structure which is only used by the thread owning the allocator instance. When these two pointers are not equal the thread owning the allocator instance deallocate block after block until &lt;code&gt;head.first&lt;/code&gt; reach &lt;code&gt;head.unref_end&lt;/code&gt;.</source>
          <target state="translated">헤드리스트 (의 시작에 대한 포인터를 포함 &lt;code&gt;head.first&lt;/code&gt; ), 및 다른 스레드 (참조있다 첫번째 블록 &lt;code&gt;head.unref_end&lt;/code&gt; ). 이러한 포인터 사이의 블록은 할당 자 인스턴스를 소유 한 스레드에서만 사용되는 데이터 구조의 헤드 부분에 의해서만 참조됩니다. 이 두 포인터가 같지 않으면 할당 자 인스턴스를 소유 한 스레드 가 &lt;code&gt;head.unref_end&lt;/code&gt; &lt;code&gt;head.first&lt;/code&gt; 도달 할 때까지 블록마다 할당 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="9e6408f5b48151485bdfcfab3159c61f5c8fa341" translate="yes" xml:space="preserve">
          <source>The head element of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">리스트의 헤드 요소 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5798187c9bcc3504a1324e24484f637b68bd2984" translate="yes" xml:space="preserve">
          <source>The head of the &lt;code&gt;modify_algs_list()&lt;/code&gt; modifies &lt;code&gt;A&lt;/code&gt; giving the result &lt;code&gt;A'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modify_algs_list()&lt;/code&gt; 의 헤드 는 &lt;code&gt;A&lt;/code&gt; 에 결과 &lt;code&gt;A'&lt;/code&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4983c0390f19223c1a70e5dfad48870fe4110265" translate="yes" xml:space="preserve">
          <source>The head of the fun is a head matching (or mismatching) &lt;strong&gt;one&lt;/strong&gt; parameter, one object of the table we select from. The object is always a single variable (can be &lt;code&gt;_&lt;/code&gt;) or a tuple, as ETS, Dets, and Mnesia tables include that. The match specification returned by &lt;code&gt;ets:fun2ms/1&lt;/code&gt; can be used with &lt;code&gt;dets:select/2&lt;/code&gt; and &lt;code&gt;mnesia:select/2&lt;/code&gt;, and with &lt;code&gt;ets:select/2&lt;/code&gt;. The use of &lt;code&gt;=&lt;/code&gt; in the head is allowed (and encouraged) at the top-level.</source>
          <target state="translated">재미의 머리는 우리가 선택한 테이블의 한 개체 인 &lt;strong&gt;하나의&lt;/strong&gt; 매개 변수와 일치하는 (또는 일치하지 않는) &lt;strong&gt;것&lt;/strong&gt; 입니다. ETS, Dets 및 Mnesia 테이블에 포함되어 있으므로 오브젝트는 항상 단일 변수 ( &lt;code&gt;_&lt;/code&gt; 가능 ) 또는 튜플입니다. &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 에서 리턴 한 일치 스펙 은 &lt;code&gt;dets:select/2&lt;/code&gt; 및 &lt;code&gt;mnesia:select/2&lt;/code&gt; 와 함께 사용할 수 있으며 &lt;code&gt;ets:select/2&lt;/code&gt; 와 함께 사용할 수 있습니다 . 헤드에서 &lt;code&gt;=&lt;/code&gt; 사용은 최상위 레벨에서 허용 (및 권장)됩니다.</target>
        </trans-unit>
        <trans-unit id="91864c391383ab349ccd4d45371e04aafcfcc9ac" translate="yes" xml:space="preserve">
          <source>The header and objects in the file are checksummed using the built-in MD5 functions. The MD5 sum of all objects is written in the file footer, so that verification while reading detects the slightest bitflip in the file data. Using this costs a fair amount of CPU time.</source>
          <target state="translated">파일의 헤더와 객체는 내장 MD5 기능을 사용하여 체크섬됩니다. 모든 개체의 MD5 합계가 파일 바닥 글에 기록되므로 읽는 동안 확인하면 파일 데이터에서 가장 작은 비트 플립이 감지됩니다. 이를 사용하면 상당한 양의 CPU 시간이 소요됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb240ffbba0a0a325acedfed500d5fbbd4064ac" translate="yes" xml:space="preserve">
          <source>The header includes some system information:</source>
          <target state="translated">헤더에는 몇 가지 시스템 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="68595adcb3ea51d515a7e1ae094708cbf3e1144b" translate="yes" xml:space="preserve">
          <source>The header is &lt;strong&gt;not&lt;/strong&gt; stripped off.</source>
          <target state="translated">헤더가 제거 &lt;strong&gt;되지 않았습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="882ae0c9d1778c987cd41c3f90417de21ef032f7" translate="yes" xml:space="preserve">
          <source>The header name will be in lower case and should not be altered.</source>
          <target state="translated">헤더 이름은 소문자이므로 변경하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="af3ed8fba11aa29a77ab51965b8edb72b975c8e9" translate="yes" xml:space="preserve">
          <source>The header of the Erlang script in the example differs from a normal Erlang module. The first line is intended to be the interpreter line, which invokes &lt;code&gt;escript&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 Erlang 스크립트의 헤더는 일반적인 Erlang 모듈과 다릅니다. 첫 번째 줄은 &lt;code&gt;escript&lt;/code&gt; 를 호출하는 인터프리터 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="aef96215b80c7223d8af26cee2243d32f40daa22" translate="yes" xml:space="preserve">
          <source>The heap size of a process is quite hard to predict, especially the amount of memory that is used during the garbage collection. When contemplating using this option, it is recommended to first run it in production with &lt;code&gt;kill&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and inspect the log events to see what the normal peak sizes of the processes in the system is and then tune the value accordingly.</source>
          <target state="translated">프로세스의 힙 크기, 특히 가비지 수집 중에 사용되는 메모리 양을 예측하기는 매우 어렵습니다. 이 옵션을 사용하여 고려할 때는 &lt;code&gt;kill&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 프로덕션 환경에서 먼저 실행 하고 로그 이벤트를 검사하여 시스템에서 프로세스의 최대 피크 크기가 무엇인지 확인한 다음 그에 따라 값을 조정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5e2e37a09af7e8f1d009a1717a88fe618ed3d52c" translate="yes" xml:space="preserve">
          <source>The heavyweight commit protocol is also non-blocking, which allows the surviving participants and their coordinator to finish the transaction regardless (even if a node crashes in the middle of the commit protocol). When a node fails at startup, &lt;code&gt;Mnesia&lt;/code&gt; determines the outcome of the transaction and recovers it. Lightweight protocols, heavyweight protocols, and dirty updates, are dependent on other nodes to be operational to make the correct heavyweight transaction recovery decision.</source>
          <target state="translated">헤비급 커밋 프로토콜은 또한 비 블로킹으로, 남아있는 참가자와 코디네이터가 노드가 커밋 프로토콜의 중간에 충돌하더라도 관계없이 트랜잭션을 완료 할 수 있습니다. 시작시 노드가 실패하면 &lt;code&gt;Mnesia&lt;/code&gt; 는 트랜잭션 결과를 판별하고 복구합니다. 간단한 프로토콜, 무거운 프로토콜 및 더티 업데이트는 올바른 무거운 트랜잭션 복구 결정을 내릴 수 있도록 다른 노드에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="cafb3c516580a793b7de731b14722e5eebd23ea8" translate="yes" xml:space="preserve">
          <source>The hexadecimal value &lt;code&gt;h...&lt;/code&gt;.</source>
          <target state="translated">16 진수 값의 &lt;code&gt;h...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11e5e2ec0fa10fbdd5f8dd78491bb19a12164f59" translate="yes" xml:space="preserve">
          <source>The hexadecimal value &lt;code&gt;hh&lt;/code&gt;.</source>
          <target state="translated">16 진수 값 &lt;code&gt;hh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="128b69f04629a68e0279c96ec1a253f91d734366" translate="yes" xml:space="preserve">
          <source>The highest distribution protocol version this node can handle. The value in OTP 23 and later is 6. Older nodes only support version 5.</source>
          <target state="translated">이 노드가 처리 할 수있는 가장 높은 배포 프로토콜 버전입니다. OTP 23 이상의 값은 6입니다. 이전 노드는 버전 5 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="74f0a534d2309926a7d494022615e9a9b4923160" translate="yes" xml:space="preserve">
          <source>The highest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</source>
          <target state="translated">이 노드가 처리 할 수있는 가장 높은 배포 버전입니다. Erlang / OTP R6B 이상의 값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="e6d5e73148170da646be47d0d2820dd158b592f1" translate="yes" xml:space="preserve">
          <source>The highest possible value an atomic in this array can hold.</source>
          <target state="translated">이 배열의 원자가 보유 할 수있는 가장 높은 값입니다.</target>
        </trans-unit>
        <trans-unit id="c600ee0b23d77b0cbea4eb9c31cc63a396e63200" translate="yes" xml:space="preserve">
          <source>The home directory (on Unix, the value of $HOME):</source>
          <target state="translated">홈 디렉토리 (Unix에서 $ HOME의 값) :</target>
        </trans-unit>
        <trans-unit id="0a981eec686f456d91d8a6bc03a6775c554a6fb0" translate="yes" xml:space="preserve">
          <source>The home directory:</source>
          <target state="translated">홈 디렉토리 :</target>
        </trans-unit>
        <trans-unit id="2e797c1729cd1e5a1ad1f79c83782a1c6c07da5c" translate="yes" xml:space="preserve">
          <source>The hook function should return either the data to be exported, or a tuple &lt;code&gt;{'#xml-alias#', NewTag::atom()}&lt;/code&gt;, or a tuple &lt;code&gt;{'#xml-redefine#', Content}&lt;/code&gt;, where &lt;code&gt;Content&lt;/code&gt; is a content list (which can be on simple-form; see &lt;code&gt;export_simple/2&lt;/code&gt; for details).</source>
          <target state="translated">후크 함수는 내보낼 데이터 또는 튜플 &lt;code&gt;{'#xml-alias#', NewTag::atom()}&lt;/code&gt; 또는 튜플 &lt;code&gt;{'#xml-redefine#', Content}&lt;/code&gt; 를 반환해야합니다 . 여기서 &lt;code&gt;Content&lt;/code&gt; 는 컨텐츠 목록 (간단한 형식 일 수 있음, 자세한 내용은 &lt;code&gt;export_simple/2&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="4a1cb12a27b6d6707a5d80ba125a5cfb6386b02f" translate="yes" xml:space="preserve">
          <source>The hook options can also be specified in a configuration file with configuration variable &lt;code&gt;ct_conn_log&lt;/code&gt;:</source>
          <target state="translated">구성 변수 &lt;code&gt;ct_conn_log&lt;/code&gt; 를 사용하여 구성 파일에 후크 옵션을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44ea7e5b4f10ff2cea08d024c8bb140192260555" translate="yes" xml:space="preserve">
          <source>The host &lt;code&gt;123.34.56.11&lt;/code&gt; and all machines on the &lt;code&gt;150.100.23&lt;/code&gt; subnet are allowed access.</source>
          <target state="translated">호스트 &lt;code&gt;123.34.56.11&lt;/code&gt; 및 &lt;code&gt;150.100.23&lt;/code&gt; 서브넷의 모든 시스템에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e966a241193fc6bb63b6fabbd2c9e1a2a953a3a8" translate="yes" xml:space="preserve">
          <source>The host &lt;code&gt;123.34.56.11&lt;/code&gt; and all machines on the &lt;code&gt;150.100.23&lt;/code&gt; subnet are not allowed access.</source>
          <target state="translated">호스트 &lt;code&gt;123.34.56.11&lt;/code&gt; 및 &lt;code&gt;150.100.23&lt;/code&gt; 서브넷의 모든 시스템에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b0786bc370f61e14470bf6a8ad6a449f7a915d2" translate="yes" xml:space="preserve">
          <source>The host keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">호스트 키 디렉토리는 &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 옵션으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1ce6f26ae1c1552959452d15ed1085c717ae10b" translate="yes" xml:space="preserve">
          <source>The host keys directory could be changed with the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">호스트 키 디렉토리는 &lt;code&gt;&lt;a href=&quot;ssh_file#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 옵션으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9b604c4b74d9d11babfaabdf3ff82c0f49b1f9b" translate="yes" xml:space="preserve">
          <source>The host that owns the &lt;code&gt;PublicHostKey&lt;/code&gt;. One or more IP addresses or hostnames.</source>
          <target state="translated">&lt;code&gt;PublicHostKey&lt;/code&gt; 를 소유하는 호스트입니다 . 하나 이상의 IP 주소 또는 호스트 이름.</target>
        </trans-unit>
        <trans-unit id="d878e97eeb73ea425731416807f352daf86ada0a" translate="yes" xml:space="preserve">
          <source>The hrl generated from a dictionary specification defines records for the messages and grouped AVPs defined in &lt;code&gt;@messages&lt;/code&gt; and &lt;code&gt;@grouped&lt;/code&gt; sections. For each message or grouped AVP definition, a record is defined whose name is the message or AVP name, prefixed with any dictionary prefix defined with &lt;code&gt;@prefix&lt;/code&gt;, and whose fields are the names of the AVPs contained in the message or grouped AVP in the order specified in the definition in question. For example, the grouped AVP</source>
          <target state="translated">사전 스펙에서 생성 된 hrl은 &lt;code&gt;@messages&lt;/code&gt; 및 &lt;code&gt;@grouped&lt;/code&gt; 섹션에 정의 된 메시지 및 그룹화 된 AVP에 대한 레코드를 정의 합니다. 각 메시지 또는 그룹화 된 AVP 정의에 대해 이름이 메시지 또는 AVP 이름이고 &lt;code&gt;@prefix&lt;/code&gt; 로 정의 된 사전 접두어가 앞에 붙고 필드가 메시지에 포함 된 AVP 이름 또는 순서대로 그룹화 된 AVP 인 레코드가 정의 됩니다. 해당 정의에 지정되어 있습니다. 예를 들어 그룹화 된 AVP</target>
        </trans-unit>
        <trans-unit id="962862212161f4c21176923512e551b47c09f8ac" translate="yes" xml:space="preserve">
          <source>The id of the child specification cannot be changed.</source>
          <target state="translated">하위 스펙의 ID는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b60d5fddce9e99cfeb5e02e09f9b009acf730f39" translate="yes" xml:space="preserve">
          <source>The id string</source>
          <target state="translated">ID 문자열</target>
        </trans-unit>
        <trans-unit id="ec73c64ab8b44c752ff6fc144d3c09d981d3ce09" translate="yes" xml:space="preserve">
          <source>The idea is that &lt;code&gt;prepare_loading&lt;/code&gt; could be called in parallel for different modules and returns a &quot;magic binary&quot; containing the internal state of each prepared module. Function &lt;code&gt;finish_loading&lt;/code&gt; could take a list of such states and do the finishing of all of them in one go.</source>
          <target state="translated">다른 모듈에 대해 &lt;code&gt;prepare_loading&lt;/code&gt; 을 병렬로 호출하고 준비된 각 모듈의 내부 상태를 포함하는 &quot;매직 바이너리&quot;를 반환 할 수 있다는 아이디어입니다 . &lt;code&gt;finish_loading&lt;/code&gt; 함수 는 이러한 상태 목록을 가져 와서 한 번에 모두 마무리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f091d047abb87ec231553541a5fdb6a8b0e0548d" translate="yes" xml:space="preserve">
          <source>The idea is that it either matches a single character, or two identical characters surrounding a subpalindrome. In Perl, this pattern works; in PCRE it does not work if the pattern is longer than three characters. Consider the subject string &quot;abcba&quot;.</source>
          <target state="translated">아이디어는 단일 문자 또는 하위 회문을 둘러싼 두 개의 동일한 문자와 일치한다는 것입니다. Perl에서는이 패턴이 작동합니다. PCRE에서는 패턴이 3자를 초과하면 작동하지 않습니다. 제목 문자열 &quot;abcba&quot;를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b7b5bed6fe9a9f3870ec94f665573cd5c7dd092c" translate="yes" xml:space="preserve">
          <source>The idea is to have a &lt;code&gt;Common Test&lt;/code&gt; test suite calling a property testing tool with special property test suites as defined by that tool. The usual Erlang application directory structure is assumed. The tests are collected in the &lt;code&gt;test&lt;/code&gt; directory of the application. The &lt;code&gt;test&lt;/code&gt; directory has a subdirectory &lt;code&gt;property_test&lt;/code&gt;, where everything needed for the property tests is collected.</source>
          <target state="translated">아이디어는 해당 도구에서 정의한 특수 특성 테스트 스위트를 사용하여 특성 테스트 도구를 호출 하는 &lt;code&gt;Common Test&lt;/code&gt; 테스트 스위트 를 갖도록하는 것입니다 . 일반적인 Erlang 애플리케이션 디렉토리 구조가 가정됩니다. 테스트는 응용 프로그램 의 &lt;code&gt;test&lt;/code&gt; 디렉토리에 수집됩니다 . &lt;code&gt;test&lt;/code&gt; 디렉토리 하위 디렉토리가 &lt;code&gt;property_test&lt;/code&gt; 속성 테스트에 필요한 모든 것을 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="874f09de1158faee11366ea5b25b0d18155a826f" translate="yes" xml:space="preserve">
          <source>The idea is to write something like:</source>
          <target state="translated">아이디어는 다음과 같이 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b43394949b432b86ec282a4b358fba39ed208e0" translate="yes" xml:space="preserve">
          <source>The idea with this module is to have a &lt;code&gt;Common Test&lt;/code&gt; test suite calling a property testing tool with special property test suites as defined by that tool. The tests are collected in the &lt;code&gt;test&lt;/code&gt; directory of the application. The &lt;code&gt;test&lt;/code&gt; directory has a subdirectory &lt;code&gt;property_test&lt;/code&gt;, where everything needed for the property tests are collected. The usual Erlang application directory structure is assumed.</source>
          <target state="translated">이 모듈의 아이디어는 해당 도구에 의해 정의 된 특수 속성 테스트 스위트가있는 속성 테스트 도구를 호출 하는 &lt;code&gt;Common Test&lt;/code&gt; 테스트 스위트를 갖는 것입니다. 테스트는 애플리케이션 의 &lt;code&gt;test&lt;/code&gt; 디렉토리에 수집됩니다 . &lt;code&gt;test&lt;/code&gt; 디렉토리 하위 디렉토리가 &lt;code&gt;property_test&lt;/code&gt; 속성 테스트를 위해 필요한 모든 것을 수집하고 있습니다. 일반적인 Erlang 응용 프로그램 디렉터리 구조가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="35794ac2165e7b77623ae5db4356014c0f1e5071" translate="yes" xml:space="preserve">
          <source>The identifier for the table. If the table is a &lt;code&gt;named_table&lt;/code&gt;, this is the name.</source>
          <target state="translated">테이블의 식별자입니다. 테이블이 &lt;code&gt;named_table&lt;/code&gt; 인 경우 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c9265c27cb6d21fb4993c197dde03dc4b3fe86fb" translate="yes" xml:space="preserve">
          <source>The identifier of a process group.</source>
          <target state="translated">프로세스 그룹의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="948f1754e2dc2f5e9da0d93fd230e4e30fc1f680" translate="yes" xml:space="preserve">
          <source>The identifier of the distribution controller identifier created by the acceptor process. To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">억 셉터 프로세스에 의해 작성된 분배 제어기 식별자의 식별자. &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcd66a26de4ddbf0baac1e4c1845007eafbabac4" translate="yes" xml:space="preserve">
          <source>The identifier of the distribution controller.</source>
          <target state="translated">배포 컨트롤러의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="727ced51237452469691fc0707b1de9d7db70736" translate="yes" xml:space="preserve">
          <source>The identifier, an arbitrary string, should be reused whenever the same application (or node) wants to start the process. &lt;code&gt;nteventlog&lt;/code&gt; is informed about all events that have arrived to the eventlog since the last accepted message for the current identifier. As long as the same identifier is used, the same eventlog record will not be sent to &lt;code&gt;nteventlog&lt;/code&gt; more than once (with the exception of when graved system failures arise, in which case the last records written before the failure may be sent to Erlang again after reboot).</source>
          <target state="translated">동일한 애플리케이션 (또는 노드)이 프로세스를 시작하려고 할 때마다 임의의 문자열 인 식별자를 재사용해야합니다. &lt;code&gt;nteventlog&lt;/code&gt; 는 현재 식별자에 대해 마지막으로 승인 된 메시지 이후에 이벤트 로그에 도착한 모든 이벤트에 대해 알려줍니다. 동일한 식별자가 사용되는 한 동일한 이벤트 로그 레코드는 &lt;code&gt;nteventlog&lt;/code&gt; 에 두 번 이상 전송되지 않습니다 (중대한 시스템 오류가 발생한 경우를 제외하고는 실패 전에 작성된 마지막 레코드가 Erlang에 다시 전송 될 수 있음) 재부팅).</target>
        </trans-unit>
        <trans-unit id="cf2c592a7835be79474c810d342bb74da9b68ee0" translate="yes" xml:space="preserve">
          <source>The identity (handle) of a connection.</source>
          <target state="translated">연결의 ID (핸들)</target>
        </trans-unit>
        <trans-unit id="3eb95f3e4536f6c8da749dd457d7ca442d214ff2" translate="yes" xml:space="preserve">
          <source>The identity of a generic instruction is its name combined with its arity. That means that it is allowed to define two distinct generic instructions having the same name but with different arities. For example:</source>
          <target state="translated">일반 명령어의 ID는 이름과 배열이 결합 된 것입니다. 즉, 이름은 같지만 arities가 다른 두 개의 고유 한 일반 명령어를 정의 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="8db0de3330260ae6e24af59a9d387dbcefe2afa7" translate="yes" xml:space="preserve">
          <source>The identity of a server, specified in a configuration file.</source>
          <target state="translated">구성 파일에 지정된 서버의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="b7f13243df50ba1e63562b3ea5688ee42281b3c8" translate="yes" xml:space="preserve">
          <source>The immediate execution of signals may also cause a scheduler that is about to execute scheduled tasks to block waiting for the port lock. This is however more or less the only scenario where a scheduler needs to wait for the port lock. The maximum time it has to wait is the time it takes to execute one signal, since we always schedule signals when contention occurs.</source>
          <target state="translated">신호를 즉시 실행하면 예약 된 작업을 실행하려는 스케줄러가 포트 잠금 대기를 차단할 수도 있습니다. 그러나 이것은 스케줄러가 포트 잠금을 기다려야하는 유일한 시나리오입니다. 대기해야하는 최대 시간은 하나의 신호를 실행하는 데 걸리는 시간입니다. 경쟁이 발생할 때 항상 신호를 예약하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="be2c0371fbc7fc4fed32a1fa7d6f534addbd004b" translate="yes" xml:space="preserve">
          <source>The implemenation of the distribution driver is not completely covered here, details about buffering and other things unrelated to driver writing are not explained. Likewise are some peculiarities of the UDS protocol not explained in detail. The chosen protocol is not important.</source>
          <target state="translated">배포 드라이버의 구현은 여기에서 완전히 다루지 않으며, 버퍼링 및 드라이버 작성과 관련이없는 기타 사항에 대해서는 자세히 설명하지 않습니다. 마찬가지로 UDS 프로토콜의 특징은 자세히 설명하지 않습니다. 선택한 프로토콜은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8024f6f807f5eee458a55b3f38fa11d2c9f7c8b5" translate="yes" xml:space="preserve">
          <source>The implementation based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__atomic_*&lt;/code&gt; builtins.</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; &lt;code&gt;__atomic_*&lt;/code&gt; 내장을 기반으로 한 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="d22b507e359bf39c3398b52ef33d5269e6b83f2b" translate="yes" xml:space="preserve">
          <source>The implementation changed in Erlang/OTP R15. Upgrading to R15 breaks applications that expect a specific output for a specified seed. The output is still deterministic number series, but different compared to releases older than R15. Seed &lt;code&gt;{0,0,0}&lt;/code&gt; does, for example, no longer produce a flawed series of only zeros.</source>
          <target state="translated">Erlang / OTP R15에서 구현이 변경되었습니다. R15로 업그레이드하면 지정된 시드에 대한 특정 출력이 필요한 응용 프로그램이 중단됩니다. 출력은 여전히 ​​결정적인 숫자 시리즈이지만 R15 이전 릴리스와는 다릅니다. 예를 들어, 종자 &lt;code&gt;{0,0,0}&lt;/code&gt; 은 더 이상 결함이있는 일련의 0만을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e57239593fac73e93851550cca7543d1553b2c2" translate="yes" xml:space="preserve">
          <source>The implementation for an instruction largely follows the C syntax, except that the variables in the function head don't have any types. The &lt;code&gt;$&lt;/code&gt; before an identifier denotes a macro expansion. Thus, &lt;code&gt;$Src&lt;/code&gt; will expand to the code to pick up the source operand for the instruction and &lt;code&gt;$Dst&lt;/code&gt; to the code for the destination register.</source>
          <target state="translated">명령어에 대한 구현은 함수 헤드의 변수에 유형이 없다는 점을 제외하고는 주로 C 구문을 따릅니다. 식별자 앞 의 &lt;code&gt;$&lt;/code&gt; 는 매크로 확장을 나타냅니다. 따라서 &lt;code&gt;$Src&lt;/code&gt; 는 코드로 확장되어 명령어의 소스 피연산자를 선택하고 &lt;code&gt;$Dst&lt;/code&gt; 는 대상 레지스터의 코드를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="17794ee5af2140bd9337aefc9afc392b9c6a3f30" translate="yes" xml:space="preserve">
          <source>The implementation of a system tracer process that produces this printout can look like this:</source>
          <target state="translated">이 출력을 생성하는 시스템 추적 프로그램 프로세스의 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b110452523f370779c51e763c1f9fff3540f763c" translate="yes" xml:space="preserve">
          <source>The implementation of a test case. Call the functions to test and check the result. If something fails, ensure the function causes a runtime error or call &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; (which also causes the test case process to terminate).</source>
          <target state="translated">테스트 케이스의 구현 함수를 호출하여 결과를 테스트하고 확인하십시오. 문제가 발생하면 함수가 런타임 오류를 유발하는지 확인하거나 &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; 를 호출하십시오 (이 경우 테스트 케이스 프로세스가 종료 됨).</target>
        </trans-unit>
        <trans-unit id="7fde479db40a86f01a45d84f1970e3229f422aaa" translate="yes" xml:space="preserve">
          <source>The implementation of different asynchronous signals in the virtual machine can vary over time, but the behavior always respects this concept of asynchronous signals being passed between entities as described above.</source>
          <target state="translated">가상 머신에서 서로 다른 비동기 신호의 구현은 시간이 지남에 따라 달라질 수 있지만 동작은 위에서 설명한대로 엔티티간에 전달되는 비동기 신호의이 개념을 항상 존중합니다.</target>
        </trans-unit>
        <trans-unit id="78fb563a772c1aec013eb172f1594ea4c2023024" translate="yes" xml:space="preserve">
          <source>The implementation of lookbehind assertions is, for each alternative, to move the current position back temporarily by the fixed length and then try to match. If there are insufficient characters before the current position, the assertion fails.</source>
          <target state="translated">lookbehind 어설 션의 구현은 각 대안에서 현재 위치를 고정 된 길이만큼 일시적으로 뒤로 이동 한 다음 일치 시키려고합니다. 현재 위치 앞에 문자가 충분하지 않으면 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3d2de14800dacea35c160c2ae6466067a774afa3" translate="yes" xml:space="preserve">
          <source>The implementation of specific instructions.</source>
          <target state="translated">특정 지침의 구현.</target>
        </trans-unit>
        <trans-unit id="47c1e5901ab1f453c1b563ce5cd6710f3f98aaf0" translate="yes" xml:space="preserve">
          <source>The implementation of the port mechanism depends on the platform. For UNIX, pipes are used and the external program is assumed to read from standard input and write to standard output. The external program can be written in any programming language as long as it can handle the interprocess communication mechanism with which the port is implemented.</source>
          <target state="translated">포트 메커니즘의 구현은 플랫폼에 따라 다릅니다. UNIX의 경우 파이프가 사용되고 외부 프로그램은 표준 입력에서 읽고 표준 출력에 쓰는 것으로 가정합니다. 외부 프로그램은 포트가 구현되는 프로세스 간 통신 메커니즘을 처리 할 수있는 한 모든 프로그래밍 언어로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478af3e7f92746327d6e9ba13837a8097b170322" translate="yes" xml:space="preserve">
          <source>The implementation of the statistic counters is lightweight. I.e. the statistic counters are handled separately by different entities of the application. For instance our two transport module(s) (see &lt;code&gt;&lt;a href=&quot;megaco_tcp#stats&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco_udp#stats&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt;) maintain their own counters and the application engine (see &lt;code&gt;&lt;a href=&quot;megaco#stats&quot;&gt;megaco&lt;/a&gt;&lt;/code&gt;) maintain its own counters.</source>
          <target state="translated">통계 카운터의 구현은 가볍습니다. 즉, 통계 카운터는 애플리케이션의 다른 엔티티에 의해 개별적으로 처리됩니다. 예를 들어, 두 개의 전송 모듈 ( &lt;code&gt;&lt;a href=&quot;megaco_tcp#stats&quot;&gt;megaco_tcp&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;megaco_udp#stats&quot;&gt;megaco_udp&lt;/a&gt;&lt;/code&gt; 참조 )은 자체 카운터를 유지하고 애플리케이션 엔진 ( &lt;code&gt;&lt;a href=&quot;megaco#stats&quot;&gt;megaco&lt;/a&gt;&lt;/code&gt; 참조 )은 자체 카운터를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="716cda84a5a3ce734872d0714b71a2c1fee89dd9" translate="yes" xml:space="preserve">
          <source>The implementation of this function is based on the &lt;code&gt;terminate&lt;/code&gt; system message, and requires that the process handles system messages correctly. For information about system messages, see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; and section &lt;code&gt; sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 기능의 구현은 시스템 &lt;code&gt;terminate&lt;/code&gt; 메시지를 기반으로 하며 프로세스가 시스템 메시지를 올바르게 처리해야합니다. 시스템 메시지에 대한 정보 는 OTP 설계 원칙의 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 및 섹션 &lt;code&gt; sys and proc_lib&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="298d2d2a07f7dd0f09f6657d3ded4573b0d17570" translate="yes" xml:space="preserve">
          <source>The implementation of this function is based on the &lt;code&gt;terminate&lt;/code&gt; system message, and requires that the process handles system messages correctly. For information about system messages, see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; and section &lt;code&gt;sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 기능의 구현은 시스템 &lt;code&gt;terminate&lt;/code&gt; 메시지를 기반으로 하며 프로세스가 시스템 메시지를 올바르게 처리해야합니다. 시스템 메시지에 대한 자세한 내용은 OTP 디자인 원칙의 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;sys and proc_lib&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8382bdd6585df4f1f98e136541a6143a6f059e2f" translate="yes" xml:space="preserve">
          <source>The implementation provided by Erlang/OTP.</source>
          <target state="translated">Erlang / OTP에서 제공하는 구현입니다.</target>
        </trans-unit>
        <trans-unit id="104f3b2e40ab2c947482e817a2a795a82f73cf00" translate="yes" xml:space="preserve">
          <source>The implementation tries to generate compact code with respect to literals and lists.</source>
          <target state="translated">구현은 리터럴 및 목록과 관련하여 압축 코드를 생성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8260c038977748412f519079cece24fe64e2829f" translate="yes" xml:space="preserve">
          <source>The implementation using ets tables introduces a semantic incompatibility with older implementations. In those older implementations, using pure Erlang terms, the index was garbage collected like any other Erlang term and did not have to be deleted when discarded. An ets table is deleted only when the process creating it explicitly deletes it or when the creating process terminates.</source>
          <target state="translated">ets 테이블을 사용한 구현은 이전 구현과 의미 상 호환되지 않습니다. 순수한 Erlang 용어를 사용하는 이전 구현에서 인덱스는 다른 Erlang 용어와 같이 가비지 수집되었으며 삭제 될 때 삭제할 필요가 없었습니다. ets 테이블은 테이블을 작성하는 프로세스가 명시 적으로 삭제하거나 작성 프로세스가 종료 될 때만 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d24ced9c8492598a6342e78545fd97461c5c3534" translate="yes" xml:space="preserve">
          <source>The important line is the last line in the function: the &lt;code&gt;do_read&lt;/code&gt; routine is called to handle new input. The remaining function handles input on a listen socket, which means that it is to be possible to do an accept on the socket, which is also recognized as a read event.</source>
          <target state="translated">중요한 행은 함수의 마지막 행입니다 . 새 입력을 처리하기 위해 &lt;code&gt;do_read&lt;/code&gt; 루틴이 호출됩니다. 나머지 함수는 청취 소켓의 입력을 처리하므로 소켓에서 승인을 수행 할 수 있으며 이는 읽기 이벤트로도 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e9c528ecacf2cef07eb906cdbaca615ae9bccf" translate="yes" xml:space="preserve">
          <source>The imported variables are replaced by match specification &lt;code&gt;const&lt;/code&gt; expressions, which is consistent with the static scoping for Erlang funs. However, local or global function calls cannot be in the guard or body of the fun. Calls to built-in match specification functions is of course allowed:</source>
          <target state="translated">가져온 변수는 일치 스펙 &lt;code&gt;const&lt;/code&gt; 표현식 으로 대체되며 , 이는 Erlang 재미에 대한 정적 범위와 일치합니다. 그러나 로컬 또는 전역 함수 호출은 재미의 보호 또는 신체에있을 수 없습니다. 내장 된 일치 스펙 함수에 대한 호출은 물론 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="acfda62ec5b11dd2be3e7e609916ea872e30b97c" translate="yes" xml:space="preserve">
          <source>The imported variables will be replaced by match_spec &lt;code&gt;const&lt;/code&gt; expressions, which is consistent with the static scoping for Erlang &lt;code&gt;fun()&lt;/code&gt;s. Local or global function calls can not be in the guard or body of the fun however. Calls to builtin match_spec functions of course is allowed:</source>
          <target state="translated">가져온 변수는 match_spec &lt;code&gt;const&lt;/code&gt; 표현식 으로 대체되어 Erlang &lt;code&gt;fun()&lt;/code&gt; 의 정적 범위와 일치합니다 . 그러나 로컬 또는 전역 함수 호출은 재미의 경비 또는 몸에있을 수 없습니다. 물론 내장 match_spec 함수에 대한 호출이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6ac95d884fd736e90ac950cd4423c02c0280f1d" translate="yes" xml:space="preserve">
          <source>The imported variables will be replaced by match_spec &lt;code&gt;const&lt;/code&gt; expressions, which is consistent with the static scoping for Erlang &lt;code&gt;fun()&lt;/code&gt;s. Local or global function calls cannot be in the guard or body of the fun however. Calls to builtin match_spec functions of course is allowed:</source>
          <target state="translated">가져온 변수는 Erlang &lt;code&gt;fun()&lt;/code&gt; 대한 정적 범위 지정과 일치하는 match_spec &lt;code&gt;const&lt;/code&gt; 표현식 으로 대체됩니다 . 그러나 로컬 또는 글로벌 함수 호출은 재미의 가드 또는 본문에있을 수 없습니다. 물론 내장 match_spec 함수에 대한 호출이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="19bfe86fb1471efac1e72c2d15460bf77e3a9408" translate="yes" xml:space="preserve">
          <source>The improved &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; module is to be used instead of this module.</source>
          <target state="translated">이 모듈 대신 개선 된 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15c1fb9f30dd76e79041f3806d5e4590f2c710b6" translate="yes" xml:space="preserve">
          <source>The included application can be started in two ways. This is described in the next two sections.</source>
          <target state="translated">포함 된 응용 프로그램은 두 가지 방법으로 시작할 수 있습니다. 이에 대해서는 다음 두 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="06e8644e190d6991435ff4de5c47198aaef4670f" translate="yes" xml:space="preserve">
          <source>The incoming message prior to encode or the outgoing message after encode.</source>
          <target state="translated">인코딩 전의 수신 메시지 또는 인코딩 후의 발신 메시지</target>
        </trans-unit>
        <trans-unit id="4f31b1830353b2c8d2b0ce96b3ddc62f7dea448b" translate="yes" xml:space="preserve">
          <source>The incoming/outgoing message. For an incoming message, a term corresponding to the configured &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; if the message can be decoded in a non-relay application, &lt;code&gt;undefined&lt;/code&gt; otherwise. For an outgoing message, setting a &lt;code&gt;[&lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt;]&lt;/code&gt; list is equivalent to setting the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;avps&lt;/code&gt; fields to the corresponding values.</source>
          <target state="translated">수신 / 발신 메시지 들어오는 메시지의 경우, 메시지가 릴레이 &lt;code&gt;undefined&lt;/code&gt; 않은 응용 프로그램에서 디코딩 될 수있는 경우 구성된 &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; 해당하는 용어 는 달리 정의되지 않습니다. 발신 메시지의 경우 &lt;code&gt;[&lt;code&gt;&lt;a href=&quot;#header&quot;&gt;header()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#avp&quot;&gt;avp()&lt;/a&gt;&lt;/code&gt;]&lt;/code&gt; 목록은 &lt;code&gt;header&lt;/code&gt; 및 &lt;code&gt;avps&lt;/code&gt; 필드를 해당 값 으로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ed6f20fe9042257fdf8f4d534ef82f96072c8261" translate="yes" xml:space="preserve">
          <source>The increment value when calculating the new timer time (&lt;code&gt;wait_for&lt;/code&gt;). Note that this value &lt;strong&gt;can&lt;/strong&gt; be negative and that a timer restart can therefor lead to a &lt;code&gt;wait_for&lt;/code&gt; value of zero! It is up to the user to be aware of the consequences of a &lt;code&gt;wait_for&lt;/code&gt; value of zero.</source>
          <target state="translated">새 타이머 시간을 계산할 때의 증가 값 ( &lt;code&gt;wait_for&lt;/code&gt; ). 이 값 &lt;strong&gt;은&lt;/strong&gt; 음수 일 &lt;strong&gt;수&lt;/strong&gt; 있으며, 타이머 재시작으로 인해 &lt;code&gt;wait_for&lt;/code&gt; 값이 0이 될 수 있습니다! &lt;code&gt;wait_for&lt;/code&gt; 값 0 의 결과를 아는 것은 사용자의 몫 입니다.</target>
        </trans-unit>
        <trans-unit id="b2b8955465cefc3c169ad13d16bfd76b94516280" translate="yes" xml:space="preserve">
          <source>The indentation features can be used to reindent large sections of a file. If some lines use nonstandard indentation they will be reindented.</source>
          <target state="translated">들여 쓰기 기능을 사용하여 파일의 큰 섹션을 다시 들여 쓸 수 있습니다. 일부 라인이 비표준 들여 쓰기를 사용하는 경우 다시 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="3228c669ff974e48e8faf71906a7cfa3fca40c98" translate="yes" xml:space="preserve">
          <source>The indexing capabilities of &lt;code&gt;Mnesia&lt;/code&gt; are used with the following three functions, which retrieve and match records based on index entries in the database:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 색인 기능은 데이터베이스의 색인 항목을 기반으로 레코드를 검색하고 일치시키는 다음 세 가지 기능과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66a67c598f5e1e4fe6dac7c8d61746c5da5f3c1a" translate="yes" xml:space="preserve">
          <source>The indices must be given in descending order.</source>
          <target state="translated">인덱스는 내림차순으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9802ae4d36471d390cc5236f59166f9448cefa" translate="yes" xml:space="preserve">
          <source>The indices must be integer literals, not variables or expressions.</source>
          <target state="translated">인덱스는 변수 또는 표현식이 아닌 정수 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d32435d41ff7d589ba94cc7995cb7739a9bc6203" translate="yes" xml:space="preserve">
          <source>The info returned by this function is returned together with other info collected by the agent when the &lt;code&gt;&lt;a href=&quot;snmpa#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; function is called (tagged with with the key &lt;code&gt;net_if&lt;/code&gt;).</source>
          <target state="translated">이 함수가 반환 한 &lt;code&gt;&lt;a href=&quot;snmpa#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; 는 info 함수가 호출 될 때 ( &lt;code&gt;net_if&lt;/code&gt; 키로 태그가 지정됨 ) 에이전트가 수집 한 다른 정보와 함께 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec9fdae2e67074ae99c5bacfc96a607916bd07f0" translate="yes" xml:space="preserve">
          <source>The info returned by this function is returned together with other info collected by the manager when the &lt;code&gt;&lt;a href=&quot;snmpm#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; function is called (tagged with the key &lt;code&gt;net_if&lt;/code&gt;).</source>
          <target state="translated">이 함수가 반환 한 &lt;code&gt;&lt;a href=&quot;snmpm#info&quot;&gt;info&lt;/a&gt;&lt;/code&gt; 는 info 함수가 호출 될 때 ( &lt;code&gt;net_if&lt;/code&gt; 키로 태그가 지정됨 ) 관리자가 수집 한 다른 정보와 함께 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4969c27d9e2b93f6c0c9f0dd0ae52939b796209" translate="yes" xml:space="preserve">
          <source>The info returned is basically up to the implementer to decide. The implementation provided by this application provides info about memory allocation and various socket information.</source>
          <target state="translated">반환 된 정보는 기본적으로 구현자가 결정해야합니다. 이 응용 프로그램에서 제공하는 구현은 메모리 할당 및 다양한 소켓 정보에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b94457081093b8de25115749fb7f0e65291a036f" translate="yes" xml:space="preserve">
          <source>The info returned is basically up to the implementer to decide. This implementation provided by the application provides info about memory allocation and various socket information.</source>
          <target state="translated">반환 된 정보는 기본적으로 구현자가 결정해야합니다. 응용 프로그램에서 제공하는이 구현은 메모리 할당 및 다양한 소켓 정보에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8953da75c34f8aaee4e44739d4a4db94876e2705" translate="yes" xml:space="preserve">
          <source>The information about MIB Views for VACM should be stored in a file called &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="translated">VACM의 MIB보기에 대한 정보는 &lt;code&gt;vacm.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1a593d35263cd423914377045097ffa123820496" translate="yes" xml:space="preserve">
          <source>The information about Notify Definitions should be stored in a file called &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="translated">통지 정의에 대한 정보는 &lt;code&gt;notify.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db26f39dea524ffb501a0d56ccb46e2ba20ceda2" translate="yes" xml:space="preserve">
          <source>The information about Security data for USM should be stored in a file called &lt;code&gt;usm.conf&lt;/code&gt;, which must be present if the agent is configured for SNMPv3.</source>
          <target state="translated">USM의 보안 데이터에 대한 정보는 &lt;code&gt;usm.conf&lt;/code&gt; 파일에 저장 해야하며 에이전트가 SNMPv3에 대해 구성된 경우 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="307e4d8639265e2a32ea9ca56343b6ede5418d77" translate="yes" xml:space="preserve">
          <source>The information about Security data for USM should be stored in a file called &lt;code&gt;usm.conf&lt;/code&gt;, which must be present if the manager wishes to use SNMPv3 when communicating with agents. It is also possible to add usm data in run-time by calling the &lt;code&gt;&lt;a href=&quot;snmpm#register_usm_user&quot;&gt;register_usm_user&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">USM의 보안 데이터에 대한 정보는 &lt;code&gt;usm.conf&lt;/code&gt; 파일에 저장해야합니다.이 파일 은 관리자가 에이전트와 통신 할 때 SNMPv3을 사용하려는 경우 존재해야합니다. &lt;code&gt;&lt;a href=&quot;snmpm#register_usm_user&quot;&gt;register_usm_user&lt;/a&gt;&lt;/code&gt; 를 호출하여 런타임에 usm 데이터를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba12704a027dbf1ed0fe4c7e9af52e49cba83222" translate="yes" xml:space="preserve">
          <source>The information about Target Address Definitions should be stored in a file called &lt;code&gt;target_addr.conf&lt;/code&gt;.</source>
          <target state="translated">대상 주소 정의에 대한 정보는 &lt;code&gt;target_addr.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a40d6040ee67551c129f61fc60a30d2acba9667f" translate="yes" xml:space="preserve">
          <source>The information about Target Parameters Definitions should be stored in a file called &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="translated">대상 매개 변수 정의에 대한 정보는 &lt;code&gt;target_params.conf&lt;/code&gt; 파일에 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3aa4d245e100d97d0412e925606bc4810d337eae" translate="yes" xml:space="preserve">
          <source>The information about the new application specifications is fetched from the boot script included in the release package. Thus, it is important that the boot script is generated from the same &lt;code&gt;.rel&lt;/code&gt; file as is used to build the release package itself.</source>
          <target state="translated">새 응용 프로그램 사양에 대한 정보는 릴리스 패키지에 포함 된 부팅 스크립트에서 가져옵니다. 따라서 릴리스 패키지 자체를 빌드하는 데 사용되는 것과 동일한 &lt;code&gt;.rel&lt;/code&gt; 파일 에서 부팅 스크립트를 생성하는 것이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="391611f6929211ce72507251e567123fcf0c63db" translate="yes" xml:space="preserve">
          <source>The information from the analysis is displayed in the &lt;strong&gt;Log&lt;/strong&gt; window and the &lt;strong&gt;Warnings&lt;/strong&gt; window.</source>
          <target state="translated">분석 정보가 &lt;strong&gt;로그&lt;/strong&gt; 창과 &lt;strong&gt;경고&lt;/strong&gt; 창에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="14c6d60f6fb1b8c358808ee0563e8e58bb01c1ed" translate="yes" xml:space="preserve">
          <source>The information from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt; is removed from the PLT. Notice that this can cause a reanalysis of the remaining dependent files.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-r&lt;/code&gt; 로 지정된 파일의 정보 가 PLT에서 제거됩니다. 이로 인해 나머지 종속 파일이 재분석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35a417a84c4c7c4decb79621743a9dd3565ee6be" translate="yes" xml:space="preserve">
          <source>The information function &lt;code&gt;init/end_per_suite()&lt;/code&gt; is called for &lt;code&gt;init/end_per_suite(Config)&lt;/code&gt;, and information function &lt;code&gt;init/end_per_group(GroupName)&lt;/code&gt; is called for &lt;code&gt;init/end_per_group(GroupName,Config)&lt;/code&gt;. However, information functions cannot be used with &lt;code&gt;init/end_per_testcase(TestCase, Config)&lt;/code&gt;, as these configuration functions execute on the test case process and use the same properties as the test case (that is, the properties set by the test case information function, &lt;code&gt;TestCase()&lt;/code&gt;). For a list of valid information properties and more general information, see the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정보 함수 &lt;code&gt;init/end_per_suite()&lt;/code&gt; 가 &lt;code&gt;init/end_per_suite(Config)&lt;/code&gt; 대해 호출 되고 정보 함수 &lt;code&gt;init/end_per_group(GroupName)&lt;/code&gt; 이 &lt;code&gt;init/end_per_group(GroupName,Config)&lt;/code&gt; 대해 호출됩니다 . 그러나 정보 구성 함수는 &lt;code&gt;init/end_per_testcase(TestCase, Config)&lt;/code&gt; 와 함께 사용할 수 없습니다. 이러한 구성 함수는 테스트 케이스 프로세스에서 실행되고 테스트 케이스와 동일한 특성 (즉, 테스트 케이스 정보 함수에 의해 설정된 특성, &lt;code&gt;TestCase()&lt;/code&gt; ). 유효한 정보 특성 및보다 일반적인 정보의 목록은 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="580ee4de3515f41920aad05c4796ca8a83145041" translate="yes" xml:space="preserve">
          <source>The information has the form of an Erlang expression where QLCs most likely occur. Depending on the format functions of mentioned QLC tables, it is not certain that the information is absolutely accurate.</source>
          <target state="translated">이 정보는 QLC가 발생할 가능성이 가장 높은 Erlang 표현식 형식입니다. 언급 된 QLC 테이블의 형식 함수에 따라 정보가 절대적으로 정확하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="305d9bd7c8803717b9892f1b41b37ab6f87fe9d8" translate="yes" xml:space="preserve">
          <source>The information needed to handle agents should be stored in a file called &lt;code&gt;agents.conf&lt;/code&gt;. It is also possible to add agents in run-time by calling the &lt;code&gt;&lt;a href=&quot;snmpm#register_agent&quot;&gt;register_agent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에이전트를 처리하는 데 필요한 정보는 &lt;code&gt;agents.conf&lt;/code&gt; 파일에 저장해야합니다 . &lt;code&gt;&lt;a href=&quot;snmpm#register_agent&quot;&gt;register_agent&lt;/a&gt;&lt;/code&gt; 를 호출하여 런타임에 에이전트를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c58f25be105f880c4313e388829ec4c71197bfd3" translate="yes" xml:space="preserve">
          <source>The information presented here is as in the &lt;code&gt;connect&lt;/code&gt; case except that the client connections are grouped under an &lt;code&gt;accept&lt;/code&gt; tuple.</source>
          <target state="translated">여기에 제시된 정보는 클라이언트 연결이 &lt;code&gt;accept&lt;/code&gt; 튜플 아래에 그룹화된다는 점을 제외하고 는 &lt;code&gt;connect&lt;/code&gt; 사례와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3c59dd2aeba1c3a9f59f5d5103b732b653592744" translate="yes" xml:space="preserve">
          <source>The information returned by the current invocation of function &lt;code&gt;info/1&lt;/code&gt; is gathered from the disk log process running on &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;info/1&lt;/code&gt; 함수의 현재 호출에 의해 리턴 된 정보는 &lt;code&gt;Node&lt;/code&gt; 에서 실행중인 디스크 로그 프로세스에서 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="384d84cf094e7d37c004a133a85246195c3cf123" translate="yes" xml:space="preserve">
          <source>The information shown in a detail window can contain links to processes or ports. Clicking one of these links opens the detail window for the process or port in question. If the process or port resides on a remote node, no information is available. Clicking the link then displays a dialog where you can choose to open the detail window for the remote node.</source>
          <target state="translated">세부 사항 창에 표시된 정보에는 프로세스 또는 포트에 대한 링크가 포함될 수 있습니다. 이 링크 중 하나를 클릭하면 해당 프로세스 또는 포트에 대한 세부 사항 창이 열립니다. 프로세스 또는 포트가 원격 노드에 있으면 정보를 사용할 수 없습니다. 링크를 클릭하면 원격 노드의 세부 사항 창을 열 수있는 대화 상자가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="60dd152dbc53269695c73395a416d9ac7faea4b7" translate="yes" xml:space="preserve">
          <source>The init Term</source>
          <target state="translated">초기화 기간</target>
        </trans-unit>
        <trans-unit id="49a50cd6647973c69a1bf7b4354e70d711a6ebe4" translate="yes" xml:space="preserve">
          <source>The init process evaluates &lt;code&gt;apply(Mod, Func, Args)&lt;/code&gt;. The system terminates if this results in an error. The boot procedure hangs if this function never returns.</source>
          <target state="translated">초기화 프로세스는 &lt;code&gt;apply(Mod, Func, Args)&lt;/code&gt; 평가 합니다 . 오류가 발생하면 시스템이 종료됩니다. 이 기능이 반환되지 않으면 부팅 절차가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="037f99c518dfc7896af931406a5af91aa71d2104" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;crypto_state()&lt;/code&gt; returned from the &lt;code&gt;&lt;a href=&quot;#type-init_fun&quot;&gt;init_fun()&lt;/a&gt;&lt;/code&gt; is folded into repeated applications of the &lt;code&gt;crypto_fun()&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt;. The binary returned from that fun is sent to the remote SFTP server and the new &lt;code&gt;crypto_state()&lt;/code&gt; is used in the next call of the &lt;code&gt;crypto_fun()&lt;/code&gt;.</source>
          <target state="translated">초기 &lt;code&gt;crypto_state()&lt;/code&gt; 로부터 반환 &lt;code&gt;&lt;a href=&quot;#type-init_fun&quot;&gt;init_fun()&lt;/a&gt;&lt;/code&gt; 의 반복 된 적용에 접어 &lt;code&gt;crypto_fun()&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; . 그 fun에서 반환 된 바이너리는 원격 SFTP 서버로 전송되고 새로운 &lt;code&gt;crypto_state()&lt;/code&gt; 는 &lt;code&gt;crypto_fun()&lt;/code&gt; 의 다음 호출에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="70767c9929b242def2046198ed888e89eaa4092e" translate="yes" xml:space="preserve">
          <source>The initial Erlang shell does not read user input until the system boot procedure has been completed (Erlang/OTP 5.4 and later). This flag disables the start synchronization feature and lets the shell start in parallel with the rest of the system.</source>
          <target state="translated">초기 Erlang 쉘은 시스템 부팅 절차가 완료 될 때까지 (Erlang / OTP 5.4 이상) 사용자 입력을 읽지 않습니다. 이 플래그는 동기화 시작 기능을 비활성화하고 쉘이 나머지 시스템과 동시에 시작되도록합니다.</target>
        </trans-unit>
        <trans-unit id="736895f627174e578045de3e4408955d43bc90d8" translate="yes" xml:space="preserve">
          <source>The initial configuration of the Megaco should be defined in the Erlang system configuration file. The following configured parameters are defined for the Megaco application:</source>
          <target state="translated">Megaco의 초기 구성은 Erlang 시스템 구성 파일에서 정의해야합니다. 다음 구성 매개 변수가 Megaco 애플리케이션에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d81e5c16ade0725185a698be4a1277d1047896" translate="yes" xml:space="preserve">
          <source>The initial default values are set when creating an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">초기 기본값은 &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 만들 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="555d7eb44ef4a30035e00a3ca666e72b873a31f0" translate="yes" xml:space="preserve">
          <source>The initial goal is to trace file I/O operations.</source>
          <target state="translated">초기 목표는 파일 I / O 작업을 추적하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c36732c8977a8d6008e73d867a36b382f99ddb9b" translate="yes" xml:space="preserve">
          <source>The initial motivation for this feature was customers asking for a way to pre-allocate physcial memory at VM start for it to use.</source>
          <target state="translated">이 기능의 초기 동기는 VM 시작시 물리적 메모리를 사용하기 위해 미리 할당하는 방법을 요구하는 고객이었습니다.</target>
        </trans-unit>
        <trans-unit id="919c9a9b4091b878cb8ab57915d353c6c990a71d" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_level&quot;&gt; logger_level&lt;/a&gt;&lt;/code&gt;. It is changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_primary_config-2&quot;&gt; logger:set_primary_config(level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 초기 값은 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_level&quot;&gt; logger_level&lt;/a&gt;&lt;/code&gt; 로 설정됩니다 . &lt;code&gt;&lt;a href=&quot;logger#set_primary_config-2&quot;&gt; logger:set_primary_config(level,Level)&lt;/a&gt;&lt;/code&gt; 런타임 중에 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="f43375679765975926ed43276d2e3e97141d5efc" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_level&quot;&gt;logger_level&lt;/a&gt;&lt;/code&gt;. It is changed during runtime with &lt;code&gt;&lt;a href=&quot;logger#set_primary_config-2&quot;&gt;logger:set_primary_config(level,Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 초기 값은 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_level&quot;&gt;logger_level&lt;/a&gt;&lt;/code&gt; 에 의해 설정됩니다 . 런타임 중에 &lt;code&gt;&lt;a href=&quot;logger#set_primary_config-2&quot;&gt;logger:set_primary_config(level,Level)&lt;/a&gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b351bcf0a82253ef55d20c6de174d9148b8d48cc" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;. During runtime, primary filters are added and removed with &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt; logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">이 옵션의 초기 값은 Kernel 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 에 의해 설정됩니다 . 런타임 중에 기본 필터는 각각 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt; logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 로 추가 및 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="be84bb7f590bd193861c25c169900eba0112bb1a" translate="yes" xml:space="preserve">
          <source>The initial value of this option is set by the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;. During runtime, primary filters are added and removed with &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">이 옵션의 초기 값은 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 에 의해 설정됩니다 . 런타임 동안 기본 필터는 각각 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 로 추가 및 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b46dedd594f319e350068f1193c873d34aee425" translate="yes" xml:space="preserve">
          <source>The initial values for fields are to be compatible with (that is, a member of) the corresponding types. This is checked by the compiler and results in a compilation error if a violation is detected.</source>
          <target state="translated">필드의 초기 값은 해당 유형과 호환 가능해야합니다 (즉, 멤버). 이는 컴파일러에 의해 확인되며 위반이 감지되면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b8dd5640afe4eb44c50f0dc55a49ff96c25b7ecf" translate="yes" xml:space="preserve">
          <source>The initial values for the managed objects defined in these tables, are read at start-up from a set of configuration files. These are described in &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 테이블에 정의 된 관리 대상 객체의 초기 값은 시작시 구성 파일 세트에서 읽습니다. 이것들은 &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc56027c40e88b952495c29f19f297d464ec0de" translate="yes" xml:space="preserve">
          <source>The initial working directory of the Erlang emulator. Defaults to the system directory.</source>
          <target state="translated">Erlang 에뮬레이터의 초기 작업 디렉토리. 시스템 디렉토리가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bbe26b329d2acb042c7bfd92ae3556c450f2a952" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;State&lt;/code&gt; is the last returned &lt;code&gt;State&lt;/code&gt;, in it the callback can include any data that it needs to keep track of when handling the chunks.</source>
          <target state="translated">입력 &lt;code&gt;State&lt;/code&gt; 는 마지막으로 반환 된 &lt;code&gt;State&lt;/code&gt; 이며, 콜백에는 청크를 처리 할 때 추적해야하는 모든 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ab1d9b79595ee9a80512a32c4f00246f558b37e" translate="yes" xml:space="preserve">
          <source>The input argument is passed from &lt;code&gt;Common Test&lt;/code&gt;, as defined in the test specification, or specified as an option to &lt;code&gt;ct_run&lt;/code&gt; or &lt;code&gt;ct:run_test&lt;/code&gt;.</source>
          <target state="translated">입력 인수는 테스트 스펙에 정의 된대로 &lt;code&gt;Common Test&lt;/code&gt; 에서 전달 되거나 &lt;code&gt;ct_run&lt;/code&gt; 또는 &lt;code&gt;ct:run_test&lt;/code&gt; 옵션으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b8a4a85bbd859e117dae9edd6f4ddaeebc656ee" translate="yes" xml:space="preserve">
          <source>The input characters. If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of whether the I/O device supports Unicode).</source>
          <target state="translated">입력 문자 I / O 장치가 유니 코드를 지원하는 경우 데이터는&amp;gt; 255 ( &lt;code&gt;latin1&lt;/code&gt; 범위)를 나타낼 수 있습니다 . I / O 서버가 바이너리를 전달하도록 설정된 경우 I / O 장치가 유니 코드를 지원하는지 여부에 관계없이 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="9a54dcf56c159353e0ace601f3572dfb662f8a6c" translate="yes" xml:space="preserve">
          <source>The input file is expected to be assembler code (default file suffix &quot;.S&quot;). Notice that the format of assembler files is not documented, and can change between releases.</source>
          <target state="translated">입력 파일은 어셈블러 코드 (기본 파일 접미사 &quot;.S&quot;) 여야합니다. 어셈블러 파일의 형식은 문서화되어 있지 않으며 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="401c0d476b7d6af409b8af21342fa3b0e4602412" translate="yes" xml:space="preserve">
          <source>The input file is expected to be core code (default file suffix &quot;.core&quot;). Notice that the format of core files is not documented, and can change between releases.</source>
          <target state="translated">입력 파일은 코어 코드 (기본 파일 접미사 &quot;.core&quot;) 여야합니다. 코어 파일의 형식은 문서화되어 있지 않으며 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d442ac0809ab496e2c13f718d563d47da7c5db" translate="yes" xml:space="preserve">
          <source>The input file should only contain the definition of BEAM&lt;strong&gt;FORMAT&lt;/strong&gt;NUMBER and external generic instructions. (Everything else would be ignored.)</source>
          <target state="translated">입력 파일에는 BEAM &lt;strong&gt;FORMAT&lt;/strong&gt; NUMBER 의 정의 와 외부 일반 명령어 만 포함되어야합니다 . (다른 모든 것은 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="c34408a478470bcd1e23311cfada88e1b775acef" translate="yes" xml:space="preserve">
          <source>The input is a valid URI but how can you decode those percent-encoded octets? You can try to normalize the input with &lt;code&gt;&lt;a href=&quot;uri_string#normalize-1&quot;&gt;uri_string:normalize/1&lt;/a&gt;&lt;/code&gt;. The normalize operation decodes those percent-encoded triplets that correspond to a character in the unreserved set. Normalization is a safe, idempotent operation that converts a URI into its canonical form:</source>
          <target state="translated">입력은 유효한 URI이지만 백분율로 인코딩 된 8 진수를 어떻게 디코딩 할 수 있습니까? &lt;code&gt;&lt;a href=&quot;uri_string#normalize-1&quot;&gt;uri_string:normalize/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 입력을 정규화 할 수 있습니다 . 정규화 작업은 예약되지 않은 집합의 문자에 해당하는 백분율로 인코딩 된 세 쌍을 디코딩합니다. 정규화는 URI를 표준 형식으로 변환하는 안전하고 멱등 한 작업입니다.</target>
        </trans-unit>
        <trans-unit id="f68ee0fd471148681af709e832d148fec4d81211" translate="yes" xml:space="preserve">
          <source>The input is changed into a list of integers and sent to the driver.</source>
          <target state="translated">입력이 정수 목록으로 변경되어 드라이버로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="895f0498a8445706072f6a486a101f535049625a" translate="yes" xml:space="preserve">
          <source>The input is complete. The result is one of the following:</source>
          <target state="translated">입력이 완료되었습니다. 결과는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="4ee231fcc37d80538054d899a6aa444060d44d7f" translate="yes" xml:space="preserve">
          <source>The installation directory of Erlang/OTP, &lt;code&gt;$ROOT&lt;/code&gt;:</source>
          <target state="translated">Erlang / OTP, &lt;code&gt;$ROOT&lt;/code&gt; 의 설치 디렉토리 :</target>
        </trans-unit>
        <trans-unit id="b211abaa6268b0cb1eb68387738a79dd87d7b54d" translate="yes" xml:space="preserve">
          <source>The installation of a new release can restart the system. Which program to use is specified by the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, which defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;.</source>
          <target state="translated">새 릴리스를 설치하면 시스템을 다시 시작할 수 있습니다. 사용할 프로그램은 SASL 구성 매개 변수 &lt;code&gt;start_prg&lt;/code&gt; 에 의해 지정되며 기본값은 &lt;code&gt;$ROOT/bin/start&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6426a93a1ac8fd4371599a87da39ac5721577a7" translate="yes" xml:space="preserve">
          <source>The installation procedure is automated. Double-click the &lt;code&gt;.exe&lt;/code&gt; file icon and follow the instructions.</source>
          <target state="translated">설치 절차가 자동화되었습니다. &lt;code&gt;.exe&lt;/code&gt; 파일 아이콘을 두 번 클릭 하고 지시 사항을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="8df4540e0f132ae38a44f67dc8db64d1677a955e" translate="yes" xml:space="preserve">
          <source>The installation will be created in a location prefixed by &lt;code&gt;$DESTDIR&lt;/code&gt;. It can, however, not be run from there. It needs to be moved into the correct location before it can be run. If &lt;code&gt;DESTDIR&lt;/code&gt; have not been set but &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; has been set, &lt;code&gt;DESTDIR&lt;/code&gt; will be set to &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. Note that &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; in pre R13B04 was buggy and behaved as &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; (see below). There are lots of areas of use for an installation procedure using &lt;code&gt;DESTDIR&lt;/code&gt;, e.g. when creating a package, cross compiling, etc. Here is an example where the installation should be located under &lt;code&gt;/opt/local&lt;/code&gt;:</source>
          <target state="translated">설치는 &lt;code&gt;$DESTDIR&lt;/code&gt; 접두사가있는 위치에 작성됩니다 . 그러나 거기에서 실행할 수는 없습니다. 실행하기 전에 올바른 위치로 이동해야합니다. 경우 &lt;code&gt;DESTDIR&lt;/code&gt; 이 설정되어 있지하지만 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 이 설정을하고있다, &lt;code&gt;DESTDIR&lt;/code&gt; 이 설정됩니다 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; . 참고 &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 사전에 R13B04은 버이고대로 동작 &lt;code&gt;EXTRA_PREFIX&lt;/code&gt; (아래 참조). 패키지 작성, 교차 컴파일 등 &lt;code&gt;DESTDIR&lt;/code&gt; 을 사용하는 설치 절차에는 사용 영역이 많이 있습니다 . 다음은 설치가 &lt;code&gt;/opt/local&lt;/code&gt; 아래에 있어야하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="fc927e07960f46bc214f273ddf993919105c4192" translate="yes" xml:space="preserve">
          <source>The instruction loads the module and is necessary when running Erlang in embedded mode. It is not strictly required when running Erlang in interactive (default) mode, since the code server then automatically searches for and loads unloaded modules.</source>
          <target state="translated">이 명령은 모듈을로드하며 내장 모드에서 Erlang을 실행할 때 필요합니다. 코드 서버는 언로드 된 모듈을 자동으로 검색하고로드하기 때문에 대화식 (기본) 모드에서 Erlang을 실행할 때 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ad8974dbde3476a5985cc107445f129c6aef0af" translate="yes" xml:space="preserve">
          <source>The instruction must be a valid Erlang term ended by a dot.</source>
          <target state="translated">명령은 점으로 끝나는 유효한 Erlang 용어 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0d51d691ce36ba72ff972c51e18b40a26c5a340a" translate="yes" xml:space="preserve">
          <source>The instruction, and thus the &lt;code&gt;.appup&lt;/code&gt; file, when changing an existing child specification, is the same as when changing properties as described earlier:</source>
          <target state="translated">기존 하위 스펙을 변경할 때 지시 사항 및 &lt;code&gt;.appup&lt;/code&gt; 파일은 앞에서 설명한 특성을 변경할 때와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bbfa8f2272191cf84529341c05c12c77d1783819" translate="yes" xml:space="preserve">
          <source>The instructions apply to Windows 10 (v.1809 and later) supporting the WSL.1 (Windows Subsystem for Linux v.1) and using Ubuntu 18.04 release.</source>
          <target state="translated">지침은 WSL.1 (Linux v.1 용 Windows 하위 시스템)을 지원하고 Ubuntu 18.04 릴리스를 사용하는 Windows 10 (v.1809 이상)에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5573a2cd0a733b9336e3b438f659165c812e003" translate="yes" xml:space="preserve">
          <source>The instructions apply to versions of Windows supporting the Cygwin emulated gnuish environment or the MSYS or MSYS2 ditto. We&amp;rsquo;ve built on the following platforms: Windows 2012, Windows 7, Windows 8 and Windows 10. It&amp;rsquo;s probably possible to build on older platforms too, but you might not be able to install the appropriate Microsoft SDK, Visual Studio or OpenSSL, in which case you will need to go back to earlier compilers etc.</source>
          <target state="translated">이 지시 사항은 Cygwin 에뮬레이트 된 gnuish 환경 또는 MSYS 또는 MSYS2 ditto를 지원하는 Windows 버전에 적용됩니다. Windows 2012, Windows 7, Windows 8 및 Windows 10 플랫폼을 기반으로 구축되었습니다. 이전 플랫폼에서도 구축 할 수 있지만 적절한 Microsoft SDK, Visual Studio 또는 OpenSSL을 설치하지 못할 수도 있습니다. 어떤 경우에는 이전 컴파일러 등으로 돌아 가야합니다.</target>
        </trans-unit>
        <trans-unit id="090f796df70e9e8b7e64375ada66ca8ada156c50" translate="yes" xml:space="preserve">
          <source>The instructions are defined like this (formatted with extra spaces for clarity):</source>
          <target state="translated">지침은 다음과 같이 정의됩니다 (명확성을 위해 추가 공백으로 형식 지정됨).</target>
        </trans-unit>
        <trans-unit id="4d3f1d3485a54f5c6e38f89d6780900e703d6266" translate="yes" xml:space="preserve">
          <source>The integer interval for signed atomics are from &lt;code&gt;-(1 bsl 63)&lt;/code&gt; to &lt;code&gt;(1 bsl 63)-1&lt;/code&gt; and for unsigned atomics from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;(1 bsl 64)-1&lt;/code&gt;.</source>
          <target state="translated">부호있는 원자의 정수 간격은 &lt;code&gt;-(1 bsl 63)&lt;/code&gt; ~ &lt;code&gt;(1 bsl 63)-1&lt;/code&gt; 이고 부호없는 원자의 경우 &lt;code&gt;0&lt;/code&gt; ~ &lt;code&gt;(1 bsl 64)-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e507f2e1bdeb41dfac8c8cfdf517a26d52c4a6f" translate="yes" xml:space="preserve">
          <source>The integer of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">의 정수 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="477d8b618ecfd772da7e539d868fb58baec9416c" translate="yes" xml:space="preserve">
          <source>The integers in all multibyte fields are in big-endian order.</source>
          <target state="translated">모든 멀티 바이트 필드의 정수는 빅 엔디안 순서입니다.</target>
        </trans-unit>
        <trans-unit id="a0118a7c55cd48f94a9248f5a7bb88a1090af613" translate="yes" xml:space="preserve">
          <source>The intent is that it shall be as &quot;close as possible&quot; to the OS level socket interface. The only significant addition is that some of the functions, e.g. &lt;code&gt;&lt;a href=&quot;#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt;, has a timeout argument.</source>
          <target state="translated">의도는 OS 레벨 소켓 인터페이스에 &quot;가능한 한 가깝게&quot;하는 것입니다. 중요한 추가 사항은 일부 함수 (예 : &lt;code&gt;&lt;a href=&quot;#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt; )에 시간 초과 인수가 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3faa469139bae1ec03d139d0a1bed92c79383290" translate="yes" xml:space="preserve">
          <source>The intention is to be compatible with the &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; storage in files. Therefore it mimics directories and filenames of &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의도는 파일 의 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 스토리지 와 호환되는 것입니다 . 따라서 &lt;code&gt;&lt;a href=&quot;http://www.openssh.com&quot;&gt;OpenSSH&lt;/a&gt;&lt;/code&gt; 의 디렉토리와 파일 이름을 모방 합니다 .</target>
        </trans-unit>
        <trans-unit id="8e32bedc7955d7223fe090b7e55010b6b9e5ac12" translate="yes" xml:space="preserve">
          <source>The intention of Trace Tool Builder is to serve as a base for tailor-made trace tools, but it can also be used directly from the Erlang shell (it can mimic &lt;code&gt;dbg&lt;/code&gt; behaviour while still providing useful additions, such as match specification shortcuts). Trace Tool Builder only allows the use of file port tracer, so to use other types of trace clients it is better to use &lt;code&gt;dbg&lt;/code&gt; directly.</source>
          <target state="translated">Trace Tool Builder의 목적은 맞춤형 추적 도구의 기반이되지만 Erlang 셸에서 직접 사용할 수도 있습니다 ( 일치 지정 바로 가기와 같은 유용한 추가 기능을 제공하면서 &lt;code&gt;dbg&lt;/code&gt; 동작을 모방 할 수 있음 ). Trace Tool Builder는 파일 포트 추적 프로그램 만 사용할 수 있으므로 다른 유형의 추적 클라이언트를 사용하려면 &lt;code&gt;dbg&lt;/code&gt; 를 직접 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cd559a381bf43260a8e8db813fe8999b82c7f1c0" translate="yes" xml:space="preserve">
          <source>The intention of the restart mechanism is to prevent a situation where a process repeatedly dies for the same reason, only to be restarted again.</source>
          <target state="translated">재시작 메커니즘의 목적은 프로세스가 동일한 이유로 반복적으로 종료되는 상황을 방지하고 다시 시작하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f04e21c615bcaa3bab7ffca923abd7b20f74b1c4" translate="yes" xml:space="preserve">
          <source>The interaction of option &lt;code&gt;global&lt;/code&gt; with a regular expression that matches an empty string surprises some users. When option &lt;code&gt;global&lt;/code&gt; is specified, &lt;code&gt;run/3&lt;/code&gt; handles empty matches in the same way as Perl: a zero-length match at any point is also retried with options &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt;. If that search gives a result of length &amp;gt; 0, the result is included. Example:</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 옵션 과 빈 문자열과 일치하는 정규식 의 상호 작용은 일부 사용자를 놀라게합니다. &lt;code&gt;global&lt;/code&gt; 옵션 이 지정되면 &lt;code&gt;run/3&lt;/code&gt; 은 Perl과 동일한 방식으로 빈 일치를 처리합니다. 모든 지점에서 길이가 0 인 일치도 &lt;code&gt;[anchored, notempty_atstart]&lt;/code&gt; 옵션으로 재 시도됩니다 . 해당 검색 결과 길이가 0보다 큰 경우 결과가 포함됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="645847dee511adf6054272dd5554738165580583" translate="yes" xml:space="preserve">
          <source>The interactive Erlang shell, when started to a terminal or started using command &lt;code&gt;werl&lt;/code&gt; on Windows, can support Unicode input and output.</source>
          <target state="translated">대화식 Erlang 쉘은 터미널에서 시작하거나 Windows에서 &lt;code&gt;werl&lt;/code&gt; 명령을 사용하여 시작할 때 유니 코드 입력 및 출력을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c05014950fec7099736bfea7380c02569c92e76" translate="yes" xml:space="preserve">
          <source>The interface address description tuples are documented under the type of the &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt; Ifopts &lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">인터페이스 주소 설명 튜플은 &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt; Ifopts &lt;/a&gt;&lt;/code&gt; 값 유형 아래에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85316f7b39c18cba3ed8c41e6e00aa4508657f73" translate="yes" xml:space="preserve">
          <source>The interface between the &lt;code&gt;Collector&lt;/code&gt; and its &lt;code&gt;Viewers&lt;/code&gt; is public in order to enable other types of &lt;code&gt;Viewers&lt;/code&gt;. However in the following text we will focus on usage of the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 &lt;code&gt;Viewers&lt;/code&gt; 를 사용하기 위해 &lt;code&gt;Collector&lt;/code&gt; 와 &lt;code&gt;Viewers&lt;/code&gt; 간의 인터페이스 는 공용입니다 . 그러나 다음 텍스트에서는 &lt;code&gt;et_viewer&lt;/code&gt; 사용법에 중점을 둘 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0d929ebaedeeb26c076c849c65d6a880fabbe836" translate="yes" xml:space="preserve">
          <source>The interface function &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, corresponding to the &lt;code&gt;ct_run&lt;/code&gt; program, is used for starting &lt;code&gt;Common Test&lt;/code&gt; from the Erlang shell (or an Erlang program). For details, see the &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 프로그램에 해당하는 인터페이스 함수 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 은 Erlang 쉘 (또는 Erlang 프로그램)에서 &lt;code&gt;Common Test&lt;/code&gt; 를 시작하는 데 사용됩니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8d5bf454a2abaa2d99599aa77da439bfb1b0e39" translate="yes" xml:space="preserve">
          <source>The interface functions (&lt;code&gt;start_link/1&lt;/code&gt; and &lt;code&gt;button/1&lt;/code&gt;) are located in the same module as the callback functions (&lt;code&gt;init/1&lt;/code&gt;, &lt;code&gt;locked/3&lt;/code&gt;, and &lt;code&gt;open/3&lt;/code&gt;). It is normally good programming practice to have the client-side code and the server-side code contained in one module.</source>
          <target state="translated">인터페이스 기능 ( &lt;code&gt;start_link/1&lt;/code&gt; 및 &lt;code&gt;button/1&lt;/code&gt; )은 콜백 기능 ( &lt;code&gt;init/1&lt;/code&gt; , &lt;code&gt;locked/3&lt;/code&gt; 및 &lt;code&gt;open/3&lt;/code&gt; ) 과 동일한 모듈에 있습니다. 일반적으로 클라이언트 측 코드와 서버 측 코드를 하나의 모듈에 포함시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3ffe36fe5fb02811ee7cbe99d87ab60dfaf7743" translate="yes" xml:space="preserve">
          <source>The interface functions (&lt;code&gt;start_link&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt;, and &lt;code&gt;free&lt;/code&gt;) are then located in the same module as the callback functions (&lt;code&gt;init&lt;/code&gt;, &lt;code&gt;handle_call&lt;/code&gt;, and &lt;code&gt;handle_cast&lt;/code&gt;). This is normally good programming practice, to have the code corresponding to one process contained in one module.</source>
          <target state="translated">인터페이스 함수 ( &lt;code&gt;start_link&lt;/code&gt; , &lt;code&gt;alloc&lt;/code&gt; 및 &lt;code&gt;free&lt;/code&gt; )는 콜백 함수 ( &lt;code&gt;init&lt;/code&gt; , &lt;code&gt;handle_call&lt;/code&gt; 및 &lt;code&gt;handle_cast&lt;/code&gt; ) 와 동일한 모듈에 있습니다. 이것은 일반적으로 하나의 모듈에 포함 된 하나의 프로세스에 해당하는 코드를 갖는 좋은 프로그래밍 관행입니다.</target>
        </trans-unit>
        <trans-unit id="81df0f8bc6de0b4acea945c7c93ea405daa969a9" translate="yes" xml:space="preserve">
          <source>The interface of the filter function is the same as the the filter functions for the good old &lt;code&gt;lists:filtermap/2&lt;/code&gt;. If the filter returns &lt;code&gt;false&lt;/code&gt; it means that the trace data should silently be dropped. &lt;code&gt;true&lt;/code&gt; means that the trace data data already is an &lt;code&gt;Event Record&lt;/code&gt; and that it should be kept as it is. &lt;code&gt;true&lt;/code&gt; means that the &lt;code&gt;TraceData&lt;/code&gt; already is an &lt;code&gt;Event Record&lt;/code&gt; and that it should be kept as it is. &lt;code&gt;{true, NewEvent}&lt;/code&gt; means that the original trace data should be replaced with &lt;code&gt;Event&lt;/code&gt;. This provides means to get rid of unwanted &lt;code&gt;Events&lt;/code&gt; as well as enabling alternate views of an &lt;code&gt;Event&lt;/code&gt;.</source>
          <target state="translated">필터 함수의 인터페이스는 이전 &lt;code&gt;lists:filtermap/2&lt;/code&gt; 대한 필터 함수와 동일합니다 . 필터가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하면 추적 데이터를 자동으로 삭제해야 함을 의미합니다. &lt;code&gt;true&lt;/code&gt; 는 추적 데이터 데이터가 이미 &lt;code&gt;Event Record&lt;/code&gt; 이며 그대로 유지되어야 함을 의미합니다. &lt;code&gt;true&lt;/code&gt; 는 &lt;code&gt;TraceData&lt;/code&gt; 가 이미 &lt;code&gt;Event Record&lt;/code&gt; 이며 그대로 유지해야 함을 의미합니다. &lt;code&gt;{true, NewEvent}&lt;/code&gt; 는 원래 추적 데이터가 &lt;code&gt;Event&lt;/code&gt; 로 대체되어야 함을 의미합니다 . 이를 통해 원하지 않는 &lt;code&gt;Events&lt;/code&gt; 를 제거 하고 &lt;code&gt;Event&lt;/code&gt; 다른보기를 활성화 할 수 있습니다..</target>
        </trans-unit>
        <trans-unit id="631992b55633d87ae608966e2309f0f4727adc29" translate="yes" xml:space="preserve">
          <source>The interface supports two basic scenarios of loading and unloading. Each scenario can also have the option of either killing ports when the driver is unloading, or waiting for the ports to close themselves. The scenarios are as follows:</source>
          <target state="translated">이 인터페이스는로드 및 언로드의 두 가지 기본 시나리오를 지원합니다. 각 시나리오에는 드라이버가 언로드 될 때 포트를 종료하거나 포트가 닫힐 때까지 기다리는 옵션도 있습니다. 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6996c2e840da27c2e132b6627f75acd9d9d5a71" translate="yes" xml:space="preserve">
          <source>The intermediate stage for a connected socket. There is to be no processing of input for this socket.</source>
          <target state="translated">연결된 소켓의 중간 단계. 이 소켓에 대한 입력 처리가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a87821499f533dec180c9e450557e45ce8484c82" translate="yes" xml:space="preserve">
          <source>The internal events are as follows:</source>
          <target state="translated">내부 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c740abc33f39344410422e82491682fb38f4e44d" translate="yes" xml:space="preserve">
          <source>The internal index of the port.</source>
          <target state="translated">포트의 내부 색인</target>
        </trans-unit>
        <trans-unit id="c0af405b79f15b6b1de096cfb80a2c7686eca2a0" translate="yes" xml:space="preserve">
          <source>The internal representations of abstract syntax trees are subject to change without notice, and should not be documented outside this module. Furthermore, we do not give any guarantees on how an abstract syntax tree may or may not be represented, &lt;strong&gt;with the following exceptions&lt;/strong&gt;: no syntax tree is represented by a single atom, such as &lt;code&gt;none&lt;/code&gt;, by a list constructor &lt;code&gt;[X | Y]&lt;/code&gt;, or by the empty list &lt;code&gt;[]&lt;/code&gt;. This can be relied on when writing functions that operate on syntax trees.</source>
          <target state="translated">추상 구문 트리의 내부 표현은 예고없이 변경 될 수 있으며이 모듈 외부에서 문서화해서는 안됩니다. 또한, 우리는 추상 구문 트리 또는 표시되지 않을 수 있습니다 방법에 대한 보증을 제공하지 않는 &lt;strong&gt;다음과 같은 예외&lt;/strong&gt; : 어떤 구문 트리가 하나의 원자에 의해 표현되지 않는, 같은 &lt;code&gt;none&lt;/code&gt; , 목록 생성자 &lt;code&gt;[X | Y]&lt;/code&gt; , 또는 빈 목록 &lt;code&gt;[]&lt;/code&gt; . 이것은 구문 트리에서 작동하는 함수를 작성할 때 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="965c55683139a0161e61ded48632af4d225cdd1d" translate="yes" xml:space="preserve">
          <source>The internal service name can be seen in the Windows service manager if viewing &lt;code&gt;Properties&lt;/code&gt; for an Erlang service.</source>
          <target state="translated">Erlang 서비스의 &lt;code&gt;Properties&lt;/code&gt; 을 볼 경우 Windows 서비스 관리자에서 내부 서비스 이름을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41156700bf653a3e0e4298bb097606750ea7e9b5" translate="yes" xml:space="preserve">
          <source>The interpretation in some detail for the three operators:</source>
          <target state="translated">세 연산자에 대한 자세한 해석은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebf147e57bc82f05aaff52b7bfcaac8dbd9b6556" translate="yes" xml:space="preserve">
          <source>The interpretation is left as an exercise.</source>
          <target state="translated">해석은 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="1933de0224d21786fb43f077472bddf757fd1f65" translate="yes" xml:space="preserve">
          <source>The interpretation of a URI depends only on the characters used and not on how those characters are represented in a network protocol.</source>
          <target state="translated">URI의 해석은 사용 된 문자에만 의존하며 해당 문자가 네트워크 프로토콜로 표현되는 방식에는 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26e3837ab6ca4df148db60d98c6975bec751a92b" translate="yes" xml:space="preserve">
          <source>The interpretation of constants and variables are sets, and those sets can be used as the basis for forming new sets by the application of  &lt;strong id=&quot;set_operator&quot;&gt;set operators&lt;/strong&gt;. The syntax:</source>
          <target state="translated">상수 및 변수의 해석은 세트이며, 이러한 세트는 &lt;strong id=&quot;set_operator&quot;&gt;세트 연산자를&lt;/strong&gt; 적용하여 새 세트를 형성하기위한 기초로 사용할 수 있습니다 . 문법 :</target>
        </trans-unit>
        <trans-unit id="e923c1f615d5158c088a332c75e5ac9dd307ac63" translate="yes" xml:space="preserve">
          <source>The interpretation of some LineOp operator applied to a set of function calls assigns to each call the set of line numbers where the first function calls the second function. Not all calls are assigned line numbers by all operators:</source>
          <target state="translated">함수 호출 세트에 적용된 일부 LineOp 연산자의 해석은 각 호출에 첫 번째 함수가 두 번째 함수를 호출하는 행 번호 세트를 지정합니다. 모든 오퍼레이터가 모든 통화에 회선 번호를 할당하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="aa994c33b9388f94e332b012c066b84d979eb038" translate="yes" xml:space="preserve">
          <source>The interpretation of the  &lt;strong id=&quot;count&quot;&gt;counting operator&lt;/strong&gt; is the number of elements of a set. The operator is undefined for closures. The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators are interpreted as the obvious arithmetical operators when applied to numbers. The syntax of the counting operator:</source>
          <target state="translated">&lt;strong id=&quot;count&quot;&gt;카운팅 연산자&lt;/strong&gt; 의 해석은 세트의 요소 수입니다. 연산자는 클로저에 대해 정의되지 않았습니다. &lt;code&gt;+&lt;/code&gt; 는 , &lt;code&gt;-&lt;/code&gt; 그리고 &lt;code&gt;*&lt;/code&gt; 숫자에 적용 할 때 사업자는 명백한 산술 연산자로 해석됩니다. 계산 연산자의 구문 :</target>
        </trans-unit>
        <trans-unit id="029af9da1d3b7dfa078a55f2dfafcadb44b815ca" translate="yes" xml:space="preserve">
          <source>The interpretation of the  &lt;strong id=&quot;restriction&quot;&gt;restriction operators&lt;/strong&gt; is a subset of the first operand, a set of calls. The second operand, a set of vertices, is converted to the type of the first operand. The syntax of the restriction operators:</source>
          <target state="translated">&lt;strong id=&quot;restriction&quot;&gt;제한 연산자&lt;/strong&gt; 의 해석은 첫 번째 피연산자의 하위 집합 인 일련의 호출입니다. 두 번째 피연산자 (정점 집합)는 첫 번째 피연산자의 유형으로 변환됩니다. 제한 연산자의 구문 :</target>
        </trans-unit>
        <trans-unit id="42a357f828f4be5cdec9a066f8f31849364dc8f3" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;Lin&lt;/code&gt; operator applied to a set of functions assigns to each function the line number where the function is defined. Unknown functions and functions of library modules are assigned the number 0.</source>
          <target state="translated">함수 세트에 적용된 &lt;code&gt;Lin&lt;/code&gt; 연산자 의 해석은 각 함수에 함수가 정의 된 행 번호를 지정합니다. 라이브러리 모듈의 알 수없는 기능에는 0이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="79e7f897549e217090e266a6ea8b4df3f84a5e55" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;closure&lt;/code&gt; operator is the transitive closure of the operand.</source>
          <target state="translated">&lt;code&gt;closure&lt;/code&gt; 연산자 의 해석은 피연산자의 전이 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="3da3bce7de2dcd2a2e677818a4ae2d0bdc921895" translate="yes" xml:space="preserve">
          <source>The interpretation of the &lt;code&gt;of&lt;/code&gt; operator is a chain of calls of the second operand (a set of calls) that passes throw all of the vertices of the first operand (a tuple of constants), in the given order. The second operand is converted to the type of the first operand. For instance, the &lt;code&gt;of&lt;/code&gt; operator can be used for finding out whether a function calls another function indirectly, and the chain of calls demonstrates how. The syntax of the graph analyzing operators:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; 연산자 의 해석은 주어진 순서대로 첫 번째 피연산자 (상수 튜플)의 모든 정점을 전달하는 두 번째 피연산자 (호출 집합)의 호출 체인입니다. 두 번째 피연산자는 첫 번째 피연산자의 유형으로 변환됩니다. 예를 들어, &lt;code&gt;of&lt;/code&gt; 연산자를 사용하여 함수가 다른 함수를 간접적으로 호출하는지 여부를 확인할 수 있으며 호출 체인이 방법을 보여줍니다. 연산자를 분석하는 그래프의 구문 :</target>
        </trans-unit>
        <trans-unit id="0eda32350bebfe83b0d81b3598e00fc83971c333" translate="yes" xml:space="preserve">
          <source>The interpretation of the cast operator depends on the named type &lt;code&gt;Type&lt;/code&gt;, the type of &lt;code&gt;Expression&lt;/code&gt;, and the structure of the elements of the interpretation of &lt;code&gt;Expression&lt;/code&gt;. If the named type is equal to the expression type, no conversion is done. Otherwise, the conversion is done one step at a time; &lt;code&gt;(Fun)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt;, for instance, is equivalent to &lt;code&gt;(Fun)&amp;nbsp;(Mod)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt;. Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of constants (functions, modules, applications or releases). If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of modules that have at least one of their functions mentioned in the interpretation of the expression. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all the functions of the modules (in &lt;code&gt;modules&lt;/code&gt; mode, the conversion is partial since the local functions are not known). The conversions to and from applications and releases work analogously. For instance, &lt;code&gt;(App) &quot;xref_.*&quot; : Mod&lt;/code&gt; returns all applications containing at least one module such that &lt;code&gt;xref_&lt;/code&gt; is a prefix of the module name.</source>
          <target state="translated">캐스트 연산자의 해석은 명명 된 형식에 따라 &lt;code&gt;Type&lt;/code&gt; , 유형 &lt;code&gt;Expression&lt;/code&gt; , 그리고 해석의 요소의 구조 &lt;code&gt;Expression&lt;/code&gt; . 명명 된 형식이 식 형식과 같으면 변환이 수행되지 않습니다. 그렇지 않으면 한 번에 한 단계 씩 변환이 수행됩니다. &lt;code&gt;(Fun)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt; 는 &lt;code&gt;(Fun)&amp;nbsp;(Mod)&amp;nbsp;(App)&amp;nbsp;RE&lt;/code&gt; . 이제 &lt;code&gt;Expression&lt;/code&gt; 의 해석이 상수 세트 (함수, 모듈, 응용 프로그램 또는 릴리스)라고 가정하십시오. 명명 된 유형이 표현식 유형보다 일반적인 경우 &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; 캐스트 표현식의 해석은 각각 표현식 해석에 언급 된 기능 중 하나 이상을 갖는 모듈 세트입니다. 명명 된 유형이 표현식 유형보다 더 특수한 경우 ( &lt;code&gt;Fun&lt;/code&gt; 및 &lt;code&gt;Mod&lt;/code&gt; ) , 해석은 모듈의 모든 기능 세트입니다 ( &lt;code&gt;modules&lt;/code&gt; 모드에서는 로컬 기능을 알 수 없으므로 변환이 부분적 임). 응용 프로그램과 릴리스 간의 변환은 유사하게 작동합니다. 예를 들어 &lt;code&gt;(App) &quot;xref_.*&quot; : Mod&lt;/code&gt; 는 &lt;code&gt;xref_&lt;/code&gt; 가 모듈 이름의 접두사가되도록 모듈을 하나 이상 포함하는 모든 응용 프로그램을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6993da444161dc204cc03e12d5fc3810b9cd2d1f" translate="yes" xml:space="preserve">
          <source>The interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the &lt;code&gt;inode&lt;/code&gt; was changed. In Windows, it is the create time.</source>
          <target state="translated">이 시간 필드의 해석은 운영 체제에 따라 다릅니다. Unix에서는 파일 또는 &lt;code&gt;inode&lt;/code&gt; 가 마지막 으로 변경된 시간입니다. Windows에서는 생성 시간입니다.</target>
        </trans-unit>
        <trans-unit id="91054e3a873098417a4f5c515e5ee9a48b04d7dd" translate="yes" xml:space="preserve">
          <source>The interpreted function call has returned a value, and the process is no longer executing interpreted code.</source>
          <target state="translated">해석 된 함수 호출이 값을 리턴했으며 프로세스가 해석 된 코드를 더 이상 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cabfaea9757a021ed3e404bb4e938889922f05f" translate="yes" xml:space="preserve">
          <source>The interpreter depends on the Kernel, STDLIB, and GS applications. This means that modules belonging to any of these applications are not allowed to be interpreted, as it could lead to a deadlock or emulator crash. This also applies to modules belonging to the Debugger application.</source>
          <target state="translated">인터프리터는 커널, STDLIB 및 GS 애플리케이션에 따라 다릅니다. 이는 교착 상태 또는 에뮬레이터 충돌로 이어질 수 있으므로 이러한 응용 프로그램에 속하는 모듈을 해석 할 수 없음을 의미합니다. 이것은 디버거 응용 프로그램에 속하는 모듈에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b74c0c5597c96d6ab8e51a9cb5a0af4d7d7773f" translate="yes" xml:space="preserve">
          <source>The interpreter requires both the source code and the object code. The object code &lt;strong&gt;must&lt;/strong&gt; include debug information, that is, only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted.</source>
          <target state="translated">인터프리터에는 소스 코드와 객체 코드가 모두 필요합니다. 오브젝트 코드 에는 디버그 정보 &lt;strong&gt;가&lt;/strong&gt; 포함 &lt;strong&gt;되어야합니다&lt;/strong&gt; . 즉, 옵션 &lt;code&gt;debug_info&lt;/code&gt; 세트로 컴파일 된 모듈 만 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a87e9cf7deb8f947251ab88b658e53f7027d6b5d" translate="yes" xml:space="preserve">
          <source>The introduction of Erlang monotonic time allows us to adjust the two Erlang times (Erlang monotonic time and Erlang system time) separately. By doing this, the accuracy of elapsed time does not have to suffer just because the system time happened to be wrong at some point in time. Separate adjustments of the two times are only performed in the time warp modes, and only fully separated in the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;. All other modes than the multi-time warp mode are for backward compatibility reasons. When using these modes, the accuracy of Erlang monotonic time suffer, as the adjustments of Erlang monotonic time in these modes are more or less tied to Erlang system time.</source>
          <target state="translated">Erlang 단조 시간을 도입하면 두 개의 Erlang 시간 (Erlang 단조 시간 및 Erlang 시스템 시간)을 개별적으로 조정할 수 있습니다. 이렇게하면 특정 시점에서 시스템 시간이 잘못되었다고해서 경과 시간의 정확도가 저하 될 필요가 없습니다. 두 번의 개별 조정은 시간 왜곡 모드에서만 수행되며 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 에서만 완전히 분리 됩니다 . 다중 시간 왜곡 모드 이외의 다른 모든 모드는 이전 버전과의 호환성을위한 것입니다. 이 모드를 사용하는 경우,이 모드에서 Erlang 단조 시간의 조정이 Erlang 시스템 시간과 거의 연관되어 있기 때문에 Erlang 단조 시간의 정확도가 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="4aa282f4900a445d575232fb66e91f370519721d" translate="yes" xml:space="preserve">
          <source>The inverse case of assertEqual, for convenience.</source>
          <target state="translated">편의를 위해 assertEqual의 역 경우.</target>
        </trans-unit>
        <trans-unit id="6c146628c3a85cf3e58449747def90c476aa8e70" translate="yes" xml:space="preserve">
          <source>The inverse case of assertMatch, for convenience.</source>
          <target state="translated">편의를 위해 assertMatch의 반대 경우.</target>
        </trans-unit>
        <trans-unit id="2bf283e78cc5757549c9cd4cea259895effeb450" translate="yes" xml:space="preserve">
          <source>The ip trace driver has a queue of &lt;code&gt;QueSize&lt;/code&gt; messages waiting to be delivered. If the driver cannot deliver messages as fast as they are produced by the runtime system, a special message is sent, which indicates how many messages that are dropped. That message will arrive at the handler function specified in &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; as the tuple &lt;code&gt;{drop, N}&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of consecutive messages dropped. In case of heavy tracing, drop's are likely to occur, and they surely occur if no client is reading the trace messages. The default value of &lt;code&gt;QueSize&lt;/code&gt; is 200.</source>
          <target state="translated">ip 추적 드라이버에는 전달 대기중인 &lt;code&gt;QueSize&lt;/code&gt; 메시지 큐 가 있습니다. 드라이버가 런타임 시스템에서 생성 된 것만 큼 빠르게 메시지를 전달할 수없는 경우 삭제되는 메시지 수를 나타내는 특수 메시지가 전송됩니다. 이 메시지는 &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; 에 튜플 &lt;code&gt;{drop, N}&lt;/code&gt; 으로 지정된 핸들러 함수에 도착합니다. 여기서 &lt;code&gt;N&lt;/code&gt; 은 삭제 된 연속 메시지 수입니다. 추적 량이 많을 경우 삭제가 발생할 가능성이 높으며 클라이언트가 추적 메시지를 읽지 않으면 반드시 발생합니다. &lt;code&gt;QueSize&lt;/code&gt; 의 기본값 은 200입니다.</target>
        </trans-unit>
        <trans-unit id="1cc4bd29058e4c95bb51a0143db9193819039f9d" translate="yes" xml:space="preserve">
          <source>The isolation property ensures that transactions that execute on different nodes in a network, and access and manipulate the same data records, do not interfere with each other. The isolation property makes it possible to execute the function &lt;code&gt;raise/2&lt;/code&gt; concurrently. A classical problem in concurrency control theory is the &quot;lost update problem&quot;.</source>
          <target state="translated">격리 속성은 네트워크의 서로 다른 노드에서 실행되고 동일한 데이터 레코드에 액세스하고 조작하는 트랜잭션이 서로 간섭하지 않도록합니다. 격리 속성을 사용하면 &lt;code&gt;raise/2&lt;/code&gt; 함수를 동시에 실행할 수 있습니다. 동시성 제어 이론의 고전적인 문제는 &quot;손실 된 업데이트 문제&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2b7ca45a26b149b7bec285f808a539b088d510f6" translate="yes" xml:space="preserve">
          <source>The isolation property is compromised, because other Erlang processes, which use transaction to manipulate the data, do not get the benefit of isolation if dirty operations simultaneously are used to read and write records from the same table.</source>
          <target state="translated">트랜잭션을 사용하여 데이터를 조작하는 다른 Erlang 프로세스는 더티 조작이 동시에 동일한 테이블에서 레코드를 읽고 쓰는 경우 격리의 이점을 얻지 못하므로 격리 특성이 손상됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
