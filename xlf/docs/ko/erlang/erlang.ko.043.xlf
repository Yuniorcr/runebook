<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="96944a938969e87b4c95a2f4e616168d80a2498e" translate="yes" xml:space="preserve">
          <source>This function is prefered to the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; since it also uses the peer host port number and may return an error message.</source>
          <target state="translated">이 함수는 피어 호스트 포트 번호를 사용하고 오류 메시지를 반환 할 수 있으므로 이전 &lt;code&gt;Module:add_host_key/3&lt;/code&gt; 보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f73d9ee417d276ccc051fe8c7286c91cdfa3ca2" translate="yes" xml:space="preserve">
          <source>This function is prefered to the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; since it also uses the peer host port number and may return an error message.</source>
          <target state="translated">이 함수는 피어 호스트 포트 번호를 사용하고 오류 메시지를 반환 할 수 있으므로 이전 &lt;code&gt;Module:is_host_key/4&lt;/code&gt; 보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="98cecf54e230f7f661ec7cac637bf313533f3b79" translate="yes" xml:space="preserve">
          <source>This function is primarily intended for debugging purpose.</source>
          <target state="translated">이 함수는 주로 디버깅 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17f026cbf93039d50d6677012488768de3756669" translate="yes" xml:space="preserve">
          <source>This function is primarily intended for debugging purpose. It is not recommended to print very large terms with &lt;code&gt;%T&lt;/code&gt;. The function may change &lt;code&gt;errno&lt;/code&gt;, even if successful.</source>
          <target state="translated">이 함수는 주로 디버깅 목적으로 사용됩니다. &lt;code&gt;%T&lt;/code&gt; 매우 큰 용어를 인쇄하는 것은 권장되지 않습니다 . 이 함수는 성공하더라도 &lt;code&gt;errno&lt;/code&gt; 를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c84159cb077e05ce5ab18f138db97ded3cd0f6a" translate="yes" xml:space="preserve">
          <source>This function is primarily useful in load regulation scenarios.</source>
          <target state="translated">이 기능은 주로 부하 조절 시나리오에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6d1c283b0d188ab1dc083d2737684fc3b5d9bcb5" translate="yes" xml:space="preserve">
          <source>This function is primarily useful in testing/debugging scenarios.</source>
          <target state="translated">이 기능은 주로 테스트 / 디버깅 시나리오에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="11584ee6be5c439d09214f1f99df3af124d2da3b" translate="yes" xml:space="preserve">
          <source>This function is probably mainly useful when called from outside of Erlang, for example from a driver written in C.</source>
          <target state="translated">이 함수는 Erlang 외부에서 호출 할 때 주로 유용합니다 (예 : C로 작성된 드라이버에서).</target>
        </trans-unit>
        <trans-unit id="4f09fd5f852628b21d18838bb6ca42850a7a35b0" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and make it easier to prevent misbehaviors of the VM because of a NIF monopolizing a scheduler thread. It can be used to divide &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt; length work&lt;/a&gt;&lt;/code&gt; into a number of repeated NIF calls without the need to create threads.</source>
          <target state="translated">이 기능은 협업 스케줄링을 더 잘 지원하고, 시스템 응답 성을 개선하며, 스케줄러 스레드를 독점하는 NIF로 인한 VM의 오작동을보다 쉽게 ​​방지하기 위해 제공됩니다. 스레드를 만들 필요없이 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt; length work&lt;/a&gt;&lt;/code&gt; 을 반복되는 NIF 호출 수로 나누는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="353504af3c988d4810cedc709216e313aaafe762" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and make it easier to prevent misbehaviors of the VM because of a NIF monopolizing a scheduler thread. It can be used to divide &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;length work&lt;/a&gt;&lt;/code&gt; into a number of repeated NIF calls without the need to create threads.</source>
          <target state="translated">이 기능은 협력 스케줄링을 더 잘 지원하고 시스템 응답 성을 개선하며 NIF가 스케줄러 스레드를 독점함으로써 VM의 오작동을보다 쉽게 ​​예방할 수 있도록 제공됩니다. 스레드를 작성할 필요없이 &lt;code&gt;&lt;a href=&quot;#lengthy_work&quot;&gt;length work&lt;/a&gt;&lt;/code&gt; 을 여러 개의 반복 된 NIF 호출로 나누는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5db90f14f3c432301e447b05ad0cb6592973631a" translate="yes" xml:space="preserve">
          <source>This function is provided to better support co-operative scheduling, improve system responsiveness, and to make it easier to prevent misbehaviors of the VM because of a port monopolizing a scheduler thread. It can be used when dividing lengthy work into some repeated driver callback calls, without the need to use threads.</source>
          <target state="translated">이 기능은 협업 스케줄링을보다 잘 지원하고 시스템 응답 성을 향상 시키며 스케줄러 스레드를 독점하는 포트로 인해 VM의 오작동을보다 쉽게 ​​예방할 수 있도록 제공됩니다. 긴 작업을 반복되는 드라이버 콜백 호출로 나눌 때 스레드를 사용할 필요없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bd60d1367a2a2c9bf42897b1642d4f588cea06f" translate="yes" xml:space="preserve">
          <source>This function is rarely needed in application code. It is used by Mnesia to provide distributed &lt;code&gt;select/3&lt;/code&gt; and &lt;code&gt;select/1&lt;/code&gt; sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</source>
          <target state="translated">이 기능은 응용 프로그램 코드에서 거의 필요하지 않습니다. Mnesia는 분산 &lt;code&gt;select/3&lt;/code&gt; 및 &lt;code&gt;select/1&lt;/code&gt; 시퀀스 를 제공하기 위해 사용 합니다. 일반적인 응용 프로그램은 Mnesia를 사용하거나 연속 형식이 외부 형식으로 변환되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="5802ba7a3becc5d64b340383668b0fe991f19bfe" translate="yes" xml:space="preserve">
          <source>This function is rarely needed in application code. It is used by application Mnesia to provide distributed &lt;code&gt;select/3&lt;/code&gt; and &lt;code&gt;select/1&lt;/code&gt; sequences. A normal application would either use Mnesia or keep the continuation from being converted to external format.</source>
          <target state="translated">이 기능은 응용 프로그램 코드에서 거의 필요하지 않습니다. 응용 프로그램 Mnesia에서 분산 &lt;code&gt;select/3&lt;/code&gt; 및 &lt;code&gt;select/1&lt;/code&gt; 시퀀스 를 제공하는 데 사용됩니다 . 일반적인 응용 프로그램은 Mnesia를 사용하거나 연속 형식이 외부 형식으로 변환되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="650535937ca4ee466c191b80e09fe3d66b3c7b8e" translate="yes" xml:space="preserve">
          <source>This function is retained for backward compatibility. Function &lt;code&gt;&lt;a href=&quot;#keyfind-3&quot;&gt;keyfind/3&lt;/a&gt;&lt;/code&gt; is usually more convenient.</source>
          <target state="translated">이 기능은 이전 버전과의 호환성을 위해 유지됩니다. 기능 키 &lt;code&gt;&lt;a href=&quot;#keyfind-3&quot;&gt;keyfind/3&lt;/a&gt;&lt;/code&gt; 가 일반적으로 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="6fd26f567334e9666b6ef2abb401ce9925581958" translate="yes" xml:space="preserve">
          <source>This function is retained for compatibility with code generated by the interface compiler and with code following examples in the same application.</source>
          <target state="translated">이 함수는 인터페이스 컴파일러에 의해 생성 된 코드 및 동일한 응용 프로그램의 예제 다음 코드와의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2ec3a9c47a6657144eaa21b3b30c6a1d0a500e42" translate="yes" xml:space="preserve">
          <source>This function is retired in favour for &lt;code&gt;Module:add_host_key/4&lt;/code&gt; which is the prefered API function. The calling SSH application will still try the &lt;code&gt;add_host_key/3&lt;/code&gt; if the call to &lt;code&gt;add_host_key/4&lt;/code&gt; failed.</source>
          <target state="translated">이 함수는 선호되는 API 함수 인 &lt;code&gt;Module:add_host_key/4&lt;/code&gt; 를 위해 폐기되었습니다 . 호출하는 SSH 애플리케이션은 &lt;code&gt;add_host_key/4&lt;/code&gt; 에 대한 호출이 실패한 경우에도 &lt;code&gt;add_host_key/3&lt;/code&gt; 을 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8e78105846a08290dcf6601bbb2dd5b4df92b17b" translate="yes" xml:space="preserve">
          <source>This function is retired in favour for &lt;code&gt;Module:is_host_key/5&lt;/code&gt; which is the prefered API function. The calling SSH application will still try the &lt;code&gt;is_host_key/4&lt;/code&gt; if the call to &lt;code&gt;is_host_key/5&lt;/code&gt; failed.</source>
          <target state="translated">이 함수는 선호되는 API 함수 인 &lt;code&gt;Module:is_host_key/5&lt;/code&gt; 를 위해 폐기되었습니다 . &lt;code&gt;is_host_key/5&lt;/code&gt; 에 대한 호출이 실패한 경우 호출 SSH 애플리케이션은 여전히 &lt;code&gt;is_host_key/4&lt;/code&gt; 를 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="04dbb81151f11a2a8e21a08672e2edd99a02d468" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;init:stop()&lt;/code&gt;, that is, it causes the node to stop in a controlled fashion.</source>
          <target state="translated">이 함수는 &lt;code&gt;init:stop()&lt;/code&gt; 약자입니다 . 즉, 제어 된 방식으로 노드가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="4e31e42d4190f9153fc006e0f381fb267c91b114" translate="yes" xml:space="preserve">
          <source>This function is synchronous, which means that it will return when the discovery process has been completed or failed.</source>
          <target state="translated">이 기능은 동기식이므로 감지 프로세스가 완료되거나 실패하면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="150a92472ac42c9c7a48db8f21312fa587e954eb" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;code&gt;&lt;a href=&quot;#getaddrinfo-1&quot;&gt;getaddrinfo&lt;/a&gt;&lt;/code&gt;. It converts a socket address to a corresponding host and service.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#getaddrinfo-1&quot;&gt;getaddrinfo&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 소켓 주소를 해당 호스트 및 서비스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1b12149d93ef786b7d3d69bbe25e8a31d0409df0" translate="yes" xml:space="preserve">
          <source>This function is the inverse of &lt;code&gt;&lt;a href=&quot;#getnameinfo-1&quot;&gt;getnameinfo&lt;/a&gt;&lt;/code&gt;. It converts host and service to a corresponding socket address.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#getnameinfo-1&quot;&gt;getnameinfo&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 호스트와 서비스를 해당 소켓 주소로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="83e3218f152791a8b7bcc054591cf10cd806a3e6" translate="yes" xml:space="preserve">
          <source>This function is the only way for a driver to send data to &lt;strong&gt;other&lt;/strong&gt; processes than the port owner process. Parameter &lt;code&gt;receiver&lt;/code&gt; specifies the process to receive the data.</source>
          <target state="translated">이 기능은 드라이버가 포트 소유자 프로세스 이외의 &lt;strong&gt;다른&lt;/strong&gt; 프로세스 로 데이터를 보낼 수있는 유일한 방법입니다 . 매개 변수 &lt;code&gt;receiver&lt;/code&gt; 는 데이터를 수신 할 프로세스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5d488a4d40159f9a0721dbdd5dad71579d3aee31" translate="yes" xml:space="preserve">
          <source>This function is thread-safe.</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="b9706d58a2352e8890b72cebf3416ed3ffff9ffe" translate="yes" xml:space="preserve">
          <source>This function is to be repeatedly called, while it returns &lt;code&gt;{more, Decompressed}&lt;/code&gt;.</source>
          <target state="translated">이 함수는 반복적으로 호출되는 반면 &lt;code&gt;{more, Decompressed}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6fe9a923027f6092daec4890f5b0a9af15bfddae" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;code&gt;erl_interface&lt;/code&gt; to create the Mnesia table if it does not already exist.</source>
          <target state="translated">이 함수는 &lt;code&gt;erl_interface&lt;/code&gt; 에서 Mnesia 테이블이없는 경우이를 작성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0ea944547ae0efb5c6ac097415a9890edb2fa66" translate="yes" xml:space="preserve">
          <source>This function is used by a process module to take care of system messages. The process receives a &lt;code&gt;{system, From, Msg}&lt;/code&gt; message and passes &lt;code&gt;Msg&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; to this function.</source>
          <target state="translated">이 기능은 프로세스 모듈에서 시스템 메시지를 처리하는 데 사용됩니다. 프로세스는 &lt;code&gt;{system, From, Msg}&lt;/code&gt; 메시지를 수신하고 &lt;code&gt;Msg&lt;/code&gt; 및 &lt;code&gt;From&lt;/code&gt; 을이 함수로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="e2a112b495b39abcd5586ec3664e29d01231ac87" translate="yes" xml:space="preserve">
          <source>This function is used by a server process to accept a connection from a client process.</source>
          <target state="translated">이 기능은 서버 프로세스에서 클라이언트 프로세스의 연결을 수락하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="898bb0d30e504dc801429a9370b05b766f512338" translate="yes" xml:space="preserve">
          <source>This function is used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling this function, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="translated">이 기능은 서버 프로세스에서 로컬 이름 서버 EPMD에 등록하는 데 사용되므로 다른 프로세스가 등록 된 이름을 사용하여 메시지를 보낼 수 있습니다. 이 함수를 호출하기 전에 프로세스는 열린 소켓에서 &lt;code&gt;bind()&lt;/code&gt; 및 &lt;code&gt;listen()&lt;/code&gt; 을 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="70ccee3033b802a87c1b5086a81572b1cdf9f072" translate="yes" xml:space="preserve">
          <source>This function is used by drivers to provide the emulator with events to check for. This enables the emulator to call the driver when something has occurred asynchronously.</source>
          <target state="translated">이 기능은 드라이버가 확인할 이벤트를 에뮬레이터에 제공하기 위해 사용합니다. 이를 통해 에뮬레이터는 무언가 비동기 적으로 발생했을 때 드라이버를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="563d0e5f94af6836101c3632fc208eb6264d3ee8" translate="yes" xml:space="preserve">
          <source>This function is used by functions &lt;code&gt;&lt;a href=&quot;c#i-0&quot;&gt;c:i/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c#regs-0&quot;&gt;c:regs/0&lt;/a&gt;&lt;/code&gt; to present process information.</source>
          <target state="translated">이 기능은 기능 &lt;code&gt;&lt;a href=&quot;c#i-0&quot;&gt;c:i/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;c#regs-0&quot;&gt;c:regs/0&lt;/a&gt;&lt;/code&gt; 에서 프로세스 정보를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73986afc84809f75a6e12a693ebaed3b04b098c2" translate="yes" xml:space="preserve">
          <source>This function is used by the &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; function to prepare a document before being laid out as text.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; 기능에서 텍스트로 배치하기 전에 문서를 준비하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="af91dcbbafd0b245aac20abd673102bff806bdf0" translate="yes" xml:space="preserve">
          <source>This function is used for closing an active TPKT connection.</source>
          <target state="translated">이 기능은 활성 TPKT 연결을 닫는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="341959533bbd5fb6c13fba9bb6518b33337f67e1" translate="yes" xml:space="preserve">
          <source>This function is used for closing an active UDP socket.</source>
          <target state="translated">이 기능은 활성 UDP 소켓을 닫는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c203b5dc275784f420edfae2f16a2aed1ae6aa56" translate="yes" xml:space="preserve">
          <source>This function is used for starting new TPKT listening socket for TCP/IP. The option list contains the socket definitions.</source>
          <target state="translated">이 기능은 TCP / IP 용 새 TPKT 수신 소켓을 시작하는 데 사용됩니다. 옵션 목록에는 소켓 정의가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="77b263a5f923ead126acb1e02db37792ff404de1" translate="yes" xml:space="preserve">
          <source>This function is used for starting the TCP/IP transport service. Use exit(TransportRef, Reason) to stop the transport service.</source>
          <target state="translated">이 기능은 TCP / IP 전송 서비스를 시작하는 데 사용됩니다. 운송 서비스를 중지하려면 exit (TransportRef, Reason)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="03f7bc8e389fa4c3de41f19125ec838b559c7fc6" translate="yes" xml:space="preserve">
          <source>This function is used for starting the UDP/IP transport service. Use exit(TransportRef, Reason) to stop the transport service.</source>
          <target state="translated">이 기능은 UDP / IP 전송 서비스를 시작하는 데 사용됩니다. 운송 서비스를 중지하려면 exit (TransportRef, Reason)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8eb43517a5b84f85e08e21015c8ab03e885b41f1" translate="yes" xml:space="preserve">
          <source>This function is used for stepping over one or more encoded terms in a buffer, to directly access later term.</source>
          <target state="translated">이 함수는 버퍼에서 하나 이상의 인코딩 된 용어를 스테핑하여 나중에 용어에 직접 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9487b4eae0bc40d60b1b4e845725399492924f17" translate="yes" xml:space="preserve">
          <source>This function is used in conjunction with the monitor function.</source>
          <target state="translated">이 기능은 모니터 기능과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9f35e4a07c284d87e14bf146829705627cc610" translate="yes" xml:space="preserve">
          <source>This function is used to change the megaco trace level.</source>
          <target state="translated">이 기능은 megaco 추적 레벨을 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe77e313940172591551e60898f1f31caf15867" translate="yes" xml:space="preserve">
          <source>This function is used to check if a previously received message, for example by &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;handle_info/2&lt;/code&gt;, is a result of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is a reply to the handle &lt;code&gt;RequestId&lt;/code&gt; the result of the request is returned in &lt;code&gt;Reply&lt;/code&gt;. Otherwise returns &lt;code&gt;no_reply&lt;/code&gt; and no cleanup is done, and thus the function must be invoked repeatedly until a reply is returned.</source>
          <target state="translated">이 함수는 이전에 수신 된 메시지 (예 : &lt;code&gt;receive&lt;/code&gt; 또는 &lt;code&gt;handle_info/2&lt;/code&gt; )가 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; 로 이루어진 요청의 결과 인지 확인하는 데 사용됩니다 . 경우 &lt;code&gt;Msg&lt;/code&gt; 있는 핸들에 대한 응답은 &lt;code&gt;RequestId&lt;/code&gt; 요청의 결과가 반환됩니다 &lt;code&gt;Reply&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;no_reply&lt;/code&gt; 가 반환 되고 정리가 수행되지 않으므로 응답이 반환 될 때까지 함수를 반복적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d0589fc6f384589ed19cac5275eb2aa5617dc52" translate="yes" xml:space="preserve">
          <source>This function is used to check if a previously received message, for example by &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;handle_info/2&lt;/code&gt;, is a result of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is a reply to the handle &lt;code&gt;RequestId&lt;/code&gt; the result of the request is returned in &lt;code&gt;Reply&lt;/code&gt;. Otherwise returns &lt;code&gt;no_reply&lt;/code&gt; and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned.</source>
          <target state="translated">이 함수는 이전에 수신 된 메시지 (예 : &lt;code&gt;receive&lt;/code&gt; 또는 &lt;code&gt;handle_info/2&lt;/code&gt; )가 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; 로 이루어진 요청의 결과 인지 확인하는 데 사용됩니다 . 경우 &lt;code&gt;Msg&lt;/code&gt; 있는 핸들에 대한 응답은 &lt;code&gt;RequestId&lt;/code&gt; 요청의 결과가 반환됩니다 &lt;code&gt;Reply&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;no_reply&lt;/code&gt; 가 반환 되고 정리가 수행되지 않으므로 응답이 반환 될 때까지 함수가 반복적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c0870f45ffc4ca4a9ca9e31e399ae3114cd98e" translate="yes" xml:space="preserve">
          <source>This function is used to check if a previously received message, for example by &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;handle_info/2&lt;/code&gt;, is a result of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is a reply to the handle &lt;code&gt;RequestId&lt;/code&gt; the result of the request is returned in &lt;code&gt;Reply&lt;/code&gt;. Otherwise returns &lt;code&gt;no_reply&lt;/code&gt; and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned.</source>
          <target state="translated">이 함수는 이전에 수신 된 메시지 (예 : &lt;code&gt;receive&lt;/code&gt; 또는 &lt;code&gt;handle_info/2&lt;/code&gt; )가 &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt; 를 사용한 요청의 결과 인지 확인하는 데 사용됩니다 . 경우 &lt;code&gt;Msg&lt;/code&gt; 있는 핸들에 대한 응답은 &lt;code&gt;RequestId&lt;/code&gt; 요청의 결과가 반환됩니다 &lt;code&gt;Reply&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;no_reply&lt;/code&gt; 가 반환 되고 정리가 수행되지 않으므로 응답이 반환 될 때까지 함수가 반복적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9905970e8ef361713ff0dc6a231017daa7b1f422" translate="yes" xml:space="preserve">
          <source>This function is used to convert a socket_handle() to a inet_socket(). inet_socket() is a plain socket, see the inet module for more info.</source>
          <target state="translated">이 함수는 socket_handle ()을 inet_socket ()으로 변환하는 데 사용됩니다. inet_socket ()은 일반 소켓입니다. 자세한 내용은 inet 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="872fb743adffaedcd340beb243b7412272596a11" translate="yes" xml:space="preserve">
          <source>This function is used to do a control operation on the active trace port driver on the given node (&lt;code&gt;Nodename&lt;/code&gt;). Which operations are allowed as well as their return values depend on which trace driver is used.</source>
          <target state="translated">이 기능은 지정된 노드 ( &lt;code&gt;Nodename&lt;/code&gt; ) 의 활성 추적 포트 드라이버에서 제어 조작을 수행하는 데 사용됩니다 . 허용되는 작업과 반환 값은 사용되는 추적 드라이버에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="322561e5d565d22195eae197df02cf59dd3cfda9" translate="yes" xml:space="preserve">
          <source>This function is used to flush the internal buffers held by a trace port driver. Currently only the file trace driver supports this operation. Returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">이 기능은 트레이스 포트 드라이버가 보유한 내부 버퍼를 플러시하는 데 사용됩니다. 현재 파일 추적 드라이버 만이 작업을 지원합니다. 반환 &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34e95da5a86e41022a5ff2d5944cdec50a72a3f2" translate="yes" xml:space="preserve">
          <source>This function is used to get the machines interface addresses, possibly filtered according to &lt;code&gt;Filter&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;Filter&lt;/code&gt; 에 따라 필터링 될 수있는 머신 인터페이스 주소를 가져 오는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d09103efe5f0276f6c79d552dc6e48c891087e8e" translate="yes" xml:space="preserve">
          <source>This function is used to open a TPKT connection.</source>
          <target state="translated">이 기능은 TPKT 연결을 여는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="757eb6e7834e636a4181b74283f0227f0e2ffefa" translate="yes" xml:space="preserve">
          <source>This function is used to open an UDP/IP socket.</source>
          <target state="translated">이 기능은 UDP / IP 소켓을 여는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="810c1759ff4f2ee4359ad6e55e1e0716e8de8e16" translate="yes" xml:space="preserve">
          <source>This function is used to perform pattern matching similar to that done in Erlang. For matching rules and more examples, see section &lt;code&gt;Pattern Matching&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">이 기능은 Erlang과 비슷한 패턴 일치를 수행하는 데 사용됩니다. 일치 규칙과 더 많은 예제 는 Erlang 참조 매뉴얼의 &lt;code&gt;Pattern Matching&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8225c2b0b7a823b2c3db31843555cf08b0b1c58a" translate="yes" xml:space="preserve">
          <source>This function is used to reset (disable) trace for the given module(s).</source>
          <target state="translated">이 기능은 주어진 모듈에 대한 추적을 재설정 (비활성화)하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4eb0cb134962fb3cf2970562621b143268d3f7" translate="yes" xml:space="preserve">
          <source>This function is used to set up default trace on function(s) for the given module or modules. The scope of the trace will be all &lt;strong&gt;exported&lt;/strong&gt; functions (both the call info and the return value). Timestamp info will also be included.</source>
          <target state="translated">이 기능은 주어진 모듈에 대한 기능에 대한 기본 추적을 설정하는 데 사용됩니다. 추적 범위는 모든 &lt;strong&gt;내 보낸&lt;/strong&gt; 함수 (호출 정보 및 반환 값)입니다. 타임 스탬프 정보도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8a8d71cb3f7af3283d816d0841f08d24b9568d" translate="yes" xml:space="preserve">
          <source>This function is used to set up trace on function(s) for the given module or modules.</source>
          <target state="translated">이 기능은 주어진 모듈에 대한 기능에 대한 추적을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03c0831d3d5485f7597cd0b7a56cfb11e2d8d606" translate="yes" xml:space="preserve">
          <source>This function is used to start megaco tracing at a given &lt;code&gt;Level&lt;/code&gt; and direct result to the given &lt;code&gt;Destination&lt;/code&gt;.</source>
          <target state="translated">이 기능은 주어진 &lt;code&gt;Level&lt;/code&gt; 에서 megaco 추적을 시작 하고 주어진 &lt;code&gt;Destination&lt;/code&gt; 결과를 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5198a41fa4397f2b825350859ef9349761d440d3" translate="yes" xml:space="preserve">
          <source>This function is used to start the flex scanner. It locates the library and loads the linked in driver.</source>
          <target state="translated">이 기능은 플렉스 스캐너를 시작하는 데 사용됩니다. 라이브러리를 찾고 링크 된 드라이버를로드합니다.</target>
        </trans-unit>
        <trans-unit id="9cbb65fd2f2f55ed5a8fdfcfbb54dede2d39cbef" translate="yes" xml:space="preserve">
          <source>This function is used to stop megaco tracing.</source>
          <target state="translated">이 기능은 megaco 추적을 중지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa9a7f11a1203465f0dab2a3fff9289e46f67958" translate="yes" xml:space="preserve">
          <source>This function is used to stop the flex scanner. It also unloads the driver.</source>
          <target state="translated">이 기능은 플렉스 스캐너를 중지하는 데 사용됩니다. 또한 드라이버를 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="e8a075a6ae0116d88a212adb66cf154d84ef51cc" translate="yes" xml:space="preserve">
          <source>This function is used to wait for a reply of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;gen_server&lt;/code&gt; process. This function must be called from the same process from which &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; was made.</source>
          <target state="translated">이 함수는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 에서 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; 로 이루어진 요청의 응답을 기다리는 데 사용됩니다 . 이 함수는 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; 가 만들어진 동일한 프로세스에서 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="518ba4fb55f90139dcdab88d5abe032b9b970f77" translate="yes" xml:space="preserve">
          <source>This function is used to wait for a reply of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt; process. This function must be called from the same process from which &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; was made.</source>
          <target state="translated">이 함수는 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스 에서 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; 로 이루어진 요청의 응답을 기다리는 데 사용됩니다 . 이 함수는 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; 가 만들어진 동일한 프로세스에서 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8fbf7b175bd6a91d71de3da23ac87dc3b0142537" translate="yes" xml:space="preserve">
          <source>This function is used to wait for a reply of a request made with &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt; from the event manager. This function must be called from the same process from which &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt; was made.</source>
          <target state="translated">이 함수는 이벤트 관리자로부터 &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt; 로 요청한 요청의 응답을 기다리는 데 사용됩니다 . 이 함수는 &lt;code&gt;&lt;a href=&quot;#send_request-3&quot;&gt;send_request/3&lt;/a&gt;&lt;/code&gt; 가 만들어진 동일한 프로세스에서 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1834d21edb25fe321739aff4973157dc0f8ba281" translate="yes" xml:space="preserve">
          <source>This function is used when implementing an alternative distribution carrier using processes as distribution controllers. &lt;code&gt;DHandle&lt;/code&gt; is retrived via the callback &lt;code&gt;f_handshake_complete&lt;/code&gt;. More information can be found in the documentation of &lt;code&gt;ERTS User's Guide ➜ How to implement an Alternative Carrier for the Erlang Distribution ➜ Distribution Module&lt;/code&gt;.</source>
          <target state="translated">이 기능은 프로세스를 분배 제어기로 사용하여 대체 분배 매체를 구현할 때 사용됩니다. &lt;code&gt;DHandle&lt;/code&gt; 는 콜백을 통해 자궁강됩니다 &lt;code&gt;f_handshake_complete&lt;/code&gt; . 자세한 내용은 &lt;code&gt;ERTS User's Guide ➜ How to implement an Alternative Carrier for the Erlang Distribution ➜ Distribution Module&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44824ba63eb3b307aabd6873ec5a1a332b6ba401" translate="yes" xml:space="preserve">
          <source>This function is used when segmentation has been configured. So, for this to work, this function &lt;strong&gt;must&lt;/strong&gt; be fully supported!</source>
          <target state="translated">이 기능은 세그먼테이션이 구성된 경우에 사용됩니다. 따라서 이것이 작동 &lt;strong&gt;하려면&lt;/strong&gt; 이 기능 이 완전히 지원 &lt;strong&gt;되어야합니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="12a35f0dbe51b5e3f1ecec001171f5281b1d71b2" translate="yes" xml:space="preserve">
          <source>This function is useful as a shortcut during development and testing, but must not be used in a production system. See section &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide, and the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; manual page for information about how to configure Logger for live systems.</source>
          <target state="translated">이 기능은 개발 및 테스트 중에 바로 가기로 유용하지만 프로덕션 시스템에서 사용해서는 안됩니다. 라이브 시스템 용 로거를 구성하는 방법에 대한 정보 는 커널 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 섹션 및 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e08d85e1b9bab386f133ff706c8c19be0cec717" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the &lt;code&gt;gen_server&lt;/code&gt; status for these cases. A callback module wishing to change the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value, as well as how its status appears in termination error logs, exports an instance of &lt;code&gt;format_status/2&lt;/code&gt; that returns a term describing the current status of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">이 기능은 이러한 경우 &lt;code&gt;gen_server&lt;/code&gt; 상태 의 형태와 모양을 변경하는 데 유용합니다 . &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 반환 값 을 변경하려는 콜백 모듈 과 상태가 종료 오류 로그에 표시되는 방식 은 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 의 현재 상태를 설명하는 용어를 반환하는 &lt;code&gt;format_status/2&lt;/code&gt; 인스턴스를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="09f573635e783a4ad23c419f9139aab803708c3f" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the &lt;code&gt;gen_statem&lt;/code&gt; status for these cases. A callback module wishing to change the &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; return value and how its status appears in termination error logs exports an instance of &lt;code&gt;format_status/2&lt;/code&gt;, which returns a term describing the current status of the &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">이 기능은 이러한 경우 &lt;code&gt;gen_statem&lt;/code&gt; 상태 의 형태와 모양을 변경하는 데 유용합니다 . &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; 반환 값 을 변경하고 종료 오류 로그에 상태가 표시되는 방식 을 변경하려는 콜백 모듈은 &lt;code&gt;gen_statem&lt;/code&gt; 의 현재 상태를 설명하는 용어를 반환하는 &lt;code&gt;format_status/2&lt;/code&gt; 인스턴스를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="b7792553fb70da23062b7be9ff4e7b99b4bb7f20" translate="yes" xml:space="preserve">
          <source>This function is useful for changing the form and appearance of the event handler state for these cases. An event handler callback module wishing to change the the &lt;code&gt;sys:get_status/1,2&lt;/code&gt; return value as well as how its state appears in termination error logs, exports an instance of &lt;code&gt;format_status/2&lt;/code&gt; that returns a term describing the current state of the event handler.</source>
          <target state="translated">이 함수는 이러한 경우 이벤트 핸들러 상태의 모양과 모양을 변경하는 데 유용합니다. &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 반환 값과 상태가 종료 오류 로그에 표시되는 방식 을 변경하려는 이벤트 핸들러 콜백 모듈은 이벤트 핸들러 의 현재 상태를 설명하는 용어를 반환하는 &lt;code&gt;format_status/2&lt;/code&gt; 의 인스턴스를 내 보냅니다. .</target>
        </trans-unit>
        <trans-unit id="610385401f6f02f433fd707df3e351fe5fa74f60" translate="yes" xml:space="preserve">
          <source>This function is useful if coverage data from different systems is to be merged.</source>
          <target state="translated">이 기능은 다른 시스템의 커버리지 데이터를 병합 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="98a04423b1194d9a1f5fa9b90393dfa8d11918f4" translate="yes" xml:space="preserve">
          <source>This function is useful when a more complex initialization procedure is needed than the &lt;code&gt;gen_server&lt;/code&gt; process behavior provides.</source>
          <target state="translated">이 기능은 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 동작이 제공 하는 것보다 더 복잡한 초기화 절차가 필요할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="8e0b171472c534adf0757b7201fbb51bc8b8ffd0" translate="yes" xml:space="preserve">
          <source>This function is useful when a more complex initialization procedure is needed than the &lt;code&gt;gen_statem&lt;/code&gt; behavior provides.</source>
          <target state="translated">이 함수는 &lt;code&gt;gen_statem&lt;/code&gt; 동작이 제공 하는 것보다 더 복잡한 초기화 절차가 필요할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="cea361e65fc7577a23ace8db8f6fec22077e2877" translate="yes" xml:space="preserve">
          <source>This function is usefull for flow control.</source>
          <target state="translated">이 기능은 흐름 제어에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eb2ddaa9fc04efddf630666c492e456ec637176e" translate="yes" xml:space="preserve">
          <source>This function makes sure the engine is loaded just once and the ID is added to the internal engine list of OpenSSL. The following calls to the function will check if the ID is loaded and then just get a new reference to the engine.</source>
          <target state="translated">이 함수는 엔진이 한 번만로드되고 ID가 OpenSSL의 내부 엔진 목록에 추가되도록합니다. 함수에 대한 다음 호출은 ID가로드되었는지 확인한 다음 엔진에 대한 새 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f46b30ae03aba38f2d6dbaebe599182eb938575a" translate="yes" xml:space="preserve">
          <source>This function may return an updated &lt;code&gt;NewExtraInfo&lt;/code&gt; that will be used in subsequent calls to the callback functions. Intended for future use.</source>
          <target state="translated">이 함수는 후속 콜백 함수 호출에 사용될 업데이트 된 &lt;code&gt;NewExtraInfo&lt;/code&gt; 를 반환 할 수 있습니다. 나중에 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ffae6b0af7395d12b556d9a92b8b8453169f33e" translate="yes" xml:space="preserve">
          <source>This function may return exactly &lt;code&gt;0.0&lt;/code&gt; which can be fatal for certain applications. If that is undesired you can use &lt;code&gt;(1.0 - rand:uniform())&lt;/code&gt; to get the interval &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt;, or instead use &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 정확히 &lt;code&gt;0.0&lt;/code&gt; 을 반환 하여 특정 응용 프로그램에 치명적일 수 있습니다. 이것이 바람직하지 않은 경우 &lt;code&gt;(1.0 - rand:uniform())&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; : uniform ()) 을 사용하여 &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt; 간격을 얻 거나 대신 uniform_real / 0을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca39a4b036275d0803e561bc49de6198f5110e47" translate="yes" xml:space="preserve">
          <source>This function may return exactly &lt;code&gt;0.0&lt;/code&gt; which can be fatal for certain applications. If that is undesired you can use &lt;code&gt;(1.0 - rand:uniform(State))&lt;/code&gt; to get the interval &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt;, or instead use &lt;code&gt;&lt;a href=&quot;#uniform_real_s-1&quot;&gt;uniform_real_s/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 정확히 &lt;code&gt;0.0&lt;/code&gt; 을 반환 하여 특정 응용 프로그램에 치명적일 수 있습니다. 이것이 바람직하지 않은 경우 &lt;code&gt;(1.0 - rand:uniform(State))&lt;/code&gt; 을 사용하여 &lt;code&gt;0.0 &amp;lt; X =&amp;lt; 1.0&lt;/code&gt; 간격을 얻 거나 대신 &lt;code&gt;&lt;a href=&quot;#uniform_real_s-1&quot;&gt;uniform_real_s/1&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31ce28b85ea3b55e10e44c23baa40c3964f84d6e" translate="yes" xml:space="preserve">
          <source>This function modifies the emulated environment used by &lt;code&gt;os:putenv/2&lt;/code&gt; and not the environment used by libc's &lt;code&gt;putenv(3)&lt;/code&gt; or similar. Drivers that &lt;strong&gt;require&lt;/strong&gt; that these are in sync will need to do so themselves, but keep in mind that they are segregated for a reason; &lt;code&gt;putenv(3)&lt;/code&gt; and its friends are &lt;strong&gt;not thread-safe&lt;/strong&gt; and may cause unrelated code to misbehave or crash the emulator.</source>
          <target state="translated">이 함수는 libc의 &lt;code&gt;putenv(3)&lt;/code&gt; 또는 이와 유사한 환경이 아닌 &lt;code&gt;os:putenv/2&lt;/code&gt; 가 사용하는 에뮬레이트 된 환경을 수정합니다 . 드라이버 &lt;strong&gt;가 필요&lt;/strong&gt; 이러한 동기화되어 있는지 스스로 그렇게, 그러나 이유가 분리되는 것을 명심해야합니다; &lt;code&gt;putenv(3)&lt;/code&gt; 와 그 친구는 &lt;strong&gt;스레드로부터 안전하지 않으며&lt;/strong&gt; 관련 코드가 오작동하거나 에뮬레이터를 중단시킬 수 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d9bfad73b174be24fda46b6c6997bb2f07b83e7" translate="yes" xml:space="preserve">
          <source>This function must be called before any of the others in the &lt;code&gt;Erl_Interface&lt;/code&gt; library to initialize the library functions. The arguments must be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">라이브러리 함수를 초기화하려면 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리 의 다른 함수 보다 먼저이 함수를 호출해야합니다 . 인수는 &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; 으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ebd9a39191cb32abe8a7e5735ecc342ac8656f1e" translate="yes" xml:space="preserve">
          <source>This function must be called by the same process from which &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; was made otherwise it will never return.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 와 동일한 프로세스에서 호출해야합니다 . 그렇지 않으면 절대 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19959c57c9d15d692c85ae027062ec2bc955b6f2" translate="yes" xml:space="preserve">
          <source>This function must be called by the same process from which &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; was made otherwise it will only return &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 와 동일한 프로세스에서 호출해야합니다. 그렇지 않으면 &lt;code&gt;timeout&lt;/code&gt; 만 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="3bb3502ac60b18fe8cef093c946cf825538bc7b7" translate="yes" xml:space="preserve">
          <source>This function must be called immediately after &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt;, before any call of &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt; 호출 전에 &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; 직후에 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b75dd99eca2ff3b13955cd576db05e608645330" translate="yes" xml:space="preserve">
          <source>This function must be called to continue after a test case (not executing in a parallel group) has called function &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 케이스 (병렬 그룹에서 실행되지 않음)가 함수 &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;ct:break/1&lt;/a&gt;&lt;/code&gt; 을 호출 한 후에 계속하려면이 함수를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="05df078881db876012ab67fef726a729b94ff9d8" translate="yes" xml:space="preserve">
          <source>This function must be called to continue after a test case has called &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt;. If the paused test case, &lt;code&gt;TestCase&lt;/code&gt;, executes in a parallel group, this function, rather than &lt;code&gt;continue/0&lt;/code&gt;, must be used to let the test case proceed.</source>
          <target state="translated">테스트 케이스가 &lt;code&gt;&lt;a href=&quot;#break-2&quot;&gt;ct:break/2&lt;/a&gt;&lt;/code&gt; 라는 이후에 계속하려면이 함수를 호출해야합니다 . 일시 정지 된 테스트 케이스 인 &lt;code&gt;TestCase&lt;/code&gt; 가 병렬 그룹에서 실행되는 경우 &lt;code&gt;continue/0&lt;/code&gt; 대신이 기능을 사용하여 테스트 케이스를 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="df6ca91336232bf4dc1b262219129b2c8bee458f" translate="yes" xml:space="preserve">
          <source>This function must be used by a process that has been started by a &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start[_link]/3,4,5&lt;/a&gt;&lt;/code&gt; function. It tells &lt;code&gt;Parent&lt;/code&gt; that the process has initialized itself, has started, or has failed to initialize itself.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;start[_link]/3,4,5&lt;/a&gt;&lt;/code&gt; 기능 으로 시작된 프로세스에서 사용해야합니다 . 프로세스가 자체 초기화되었거나 시작되었거나 자체 초기화에 실패했음을 &lt;code&gt;Parent&lt;/code&gt; 에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="4eb57f4a5bbafdd8247f55548e5ee187fd56dc8b" translate="yes" xml:space="preserve">
          <source>This function needs to be called as a transaction. Assume that you wish to write a function that both calls the function &lt;code&gt;add_subscriber/1&lt;/code&gt; and is in itself protected by the context of a transaction. By calling &lt;code&gt;add_subscriber/1&lt;/code&gt; from within another transaction, a nested transaction is created.</source>
          <target state="translated">이 함수는 트랜잭션으로 호출해야합니다. &lt;code&gt;add_subscriber/1&lt;/code&gt; 함수를 호출하고 자체적으로 트랜잭션 컨텍스트에 의해 보호되는 함수를 작성한다고 가정하십시오 . 다른 트랜잭션 내에서 &lt;code&gt;add_subscriber/1&lt;/code&gt; 을 호출 하면 중첩 트랜잭션이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="17d0fec42839f72178e4fd55a2c5164e6b9bf6ce" translate="yes" xml:space="preserve">
          <source>This function only succeeds in platforms that provide this feature.</source>
          <target state="translated">이 기능은이 기능을 제공하는 플랫폼에서만 성공합니다.</target>
        </trans-unit>
        <trans-unit id="bdb288dde170ca25e8a4e8d2927079c35992755a" translate="yes" xml:space="preserve">
          <source>This function only succeeds in platforms that provide this feature. When it succeeds, space is preallocated for the file but the file size might not be updated. This behaviour depends on the preallocation implementation. To guarantee that the file size is updated, truncate the file to the new size.</source>
          <target state="translated">이 기능은이 기능을 제공하는 플랫폼에서만 성공합니다. 성공하면 파일에 대한 공간이 미리 할당되지만 파일 크기가 업데이트되지 않을 수 있습니다. 이 동작은 사전 할당 구현에 따라 다릅니다. 파일 크기가 업데이트되도록하려면 파일을 새 크기로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="b9d0851586e3645c6e0718dc09f5fec49d8fc898" translate="yes" xml:space="preserve">
          <source>This function performs the following transformation:</source>
          <target state="translated">이 함수는 다음과 같은 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="681ee068d504344b07045ef0edae3fb7a6646520" translate="yes" xml:space="preserve">
          <source>This function prints all elements of a list onto a stream:</source>
          <target state="translated">이 함수는 목록의 모든 요소를 ​​스트림에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="826961bd42fe30f9ebbd7b4d33db709f59c3b696" translate="yes" xml:space="preserve">
          <source>This function produce the same encoding as &lt;code&gt;&lt;a href=&quot;#term_to_binary-1&quot;&gt;term_to_binary/1&lt;/a&gt;&lt;/code&gt;, but with another return type. The call &lt;code&gt;iolist_to_binary(term_to_iovec(Term))&lt;/code&gt; will produce exactly the same result as the call &lt;code&gt;term_to_binary(Term)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#term_to_binary-1&quot;&gt;term_to_binary/1&lt;/a&gt;&lt;/code&gt; 과 동일한 인코딩을 생성 하지만 다른 반환 유형을 사용합니다. 호출 &lt;code&gt;iolist_to_binary(term_to_iovec(Term))&lt;/code&gt; 정확하게 호출과 같은 결과를 생성합니다 &lt;code&gt;term_to_binary(Term)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a527ff828c71994c974c257269fdedc8e4cd10" translate="yes" xml:space="preserve">
          <source>This function produce the same encoding as &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt;, but with another return type. The call &lt;code&gt;iolist_to_binary(term_to_iovec(Term, Opts))&lt;/code&gt; will produce exactly the same result as &lt;code&gt;term_to_binary(Term, Opts)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt; 와 동일한 인코딩을 생성 하지만 다른 반환 유형을 사용합니다. &lt;code&gt;iolist_to_binary(term_to_iovec(Term, Opts))&lt;/code&gt; 호출은 term_to_binary (Term, Opts) 와 정확히 동일한 결과를 생성 &lt;code&gt;term_to_binary(Term, Opts)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abd07fdc0e97d4adf4e29f31e2cc86ba2b8eaea2" translate="yes" xml:space="preserve">
          <source>This function produces a list of information about the megaco application. Such as users and their config, connections and their config, statistics and so on.</source>
          <target state="translated">이 기능은 megaco 애플리케이션에 대한 정보 목록을 생성합니다. 사용자 및 구성, 연결 및 구성, 통계 등.</target>
        </trans-unit>
        <trans-unit id="4aec40bb5deb9daace1e8128ff80ca5cbdbd3ab4" translate="yes" xml:space="preserve">
          <source>This function provides a low-level interface to the pretty printer, returning a flexible representation of possible layouts, independent of the paper width eventually to be used for formatting. This can be included as part of another document and/or further processed directly by the functions in the &lt;code&gt;prettypr&lt;/code&gt; module, or used in a hook function (see &lt;code&gt;format/2&lt;/code&gt; for details).</source>
          <target state="translated">이 기능은 예쁜 프린터에 낮은 수준의 인터페이스를 제공하여 궁극적으로 서식 지정에 사용되는 용지 너비에 관계없이 가능한 레이아웃을 유연하게 표현합니다. 이것은 다른 문서의 일부로 포함되거나 &lt;code&gt;prettypr&lt;/code&gt; 모듈 의 기능에 의해 직접 처리 되거나 후크 기능에 사용될 수 있습니다 (자세한 내용은 &lt;code&gt;format/2&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="292e6a8f5a93138af65b2381d7cdb5c0c6c34358" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more counters, without the trouble of having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again. (The update is done atomically, that is, no process can access the ETS table in the middle of the operation.)</source>
          <target state="translated">이 기능을 사용하면 개체를 조회하거나, 요소를 증가시켜 개체를 업데이트하고, 결과 개체를 테이블에 다시 삽입 할 필요없이 하나 이상의 카운터를 효율적으로 업데이트 할 수 있습니다. (업데이트는 원자 적으로 수행됩니다. 즉, 조작 중에 프로세스가 ETS 테이블에 액세스 할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="de1914d725b6a19d0c54d0cc47eafecc7c8a1cad" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more counters, without the trouble of having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again. The operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 개체를 조회하고, 요소를 증가시켜 개체를 업데이트하고, 결과 개체를 테이블에 다시 삽입 할 필요없이 하나 이상의 카운터를 업데이트하는 효율적인 방법을 제공합니다. 작업은 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9e675f31114737aa33341ede5a5aba5db53e0d" translate="yes" xml:space="preserve">
          <source>This function provides an efficient way to update one or more elements within an object, without the trouble of having to look up, update, and write back the entire object.</source>
          <target state="translated">이 기능을 사용하면 전체 객체를 조회, 업데이트 및 다시 작성하지 않고도 객체 내의 하나 이상의 요소를 효율적으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2ad4c84411a21e47a169513c1d529c2c69b36bc" translate="yes" xml:space="preserve">
          <source>This function reads &quot;messages&quot;, which means that regardless of how much we want to read, it returns when we get a message (if the buffer size is too small, the message will be truncated).</source>
          <target state="translated">이 함수는 &quot;메시지&quot;를 읽습니다. 즉, 읽고 자하는 양에 관계없이 메시지를받을 때 반환합니다 (버퍼 크기가 너무 작 으면 메시지가 잘림).</target>
        </trans-unit>
        <trans-unit id="b2bfd8b3c8c6d13aec0aa1766324ac529d7e9c46" translate="yes" xml:space="preserve">
          <source>This function reads &quot;messages&quot;, which means that regardless of how much we want to read, it returns when we get a message.</source>
          <target state="translated">이 함수는 &quot;메시지&quot;를 읽습니다. 즉, 우리가 읽고 자하는 양에 관계없이 메시지를 받으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1b5d7fcc798e3adcd6205abd49a5e2a97894217" translate="yes" xml:space="preserve">
          <source>This function reads match specifications from a file (possibly) generated by the &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; function. It checks the syntax of all match specifications and verifies that they are correct. The error handling principle is &quot;all or nothing&quot;, i. e. if some of the match specifications are wrong, none of the specifications are added to the list of saved match specifications for the running system.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#wtp-1&quot;&gt;wtp/1&lt;/a&gt;&lt;/code&gt; 함수에 의해 생성 된 파일에서 일치 스펙을 읽습니다 . 모든 일치 스펙의 구문을 점검하고 올바른지 검증합니다. 오류 처리 원칙은 &quot;모두 또는 아무것도&quot;입니다. 즉, 일부 일치 사양이 잘못된 경우 실행중인 시스템의 저장된 일치 사양 목록에 해당 사양이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c87d8b732e8491a29379bc4f4e018b87a77b776" translate="yes" xml:space="preserve">
          <source>This function reads the emulated environment used by &lt;code&gt;os:getenv/1&lt;/code&gt; and not the environment used by libc's &lt;code&gt;getenv(3)&lt;/code&gt; or similar. Drivers that &lt;strong&gt;require&lt;/strong&gt; that these are in sync will need to do so themselves, but keep in mind that they are segregated for a reason; &lt;code&gt;getenv(3)&lt;/code&gt; and its friends are &lt;strong&gt;not thread-safe&lt;/strong&gt; and may cause unrelated code to misbehave or crash the emulator.</source>
          <target state="translated">이 함수 는 libc의 &lt;code&gt;getenv(3)&lt;/code&gt; 또는 이와 유사한 환경이 아닌 &lt;code&gt;os:getenv/1&lt;/code&gt; 에 의해 사용 된 에뮬레이트 된 환경을 읽습니다 . 드라이버 &lt;strong&gt;가 필요&lt;/strong&gt; 이러한 동기화되어 있는지 스스로 그렇게, 그러나 이유가 분리되는 것을 명심해야합니다; &lt;code&gt;getenv(3)&lt;/code&gt; 및 그 친구는 &lt;strong&gt;스레드로부터 안전하지 않으며&lt;/strong&gt; 관련없는 코드가 잘못 작동하거나 에뮬레이터를 중단시킬 수 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a11b74ad5663559d5b504d02b42b896b8198c8" translate="yes" xml:space="preserve">
          <source>This function requires root privileges to succeed.</source>
          <target state="translated">이 기능을 사용하려면 루트 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d15610f3a7143920acbea774174ec7657558cf9c" translate="yes" xml:space="preserve">
          <source>This function retreives information about what the platform supports, such as if SCTP is supported, or which socket options are supported.</source>
          <target state="translated">이 함수는 SCTP가 지원되는지 여부 또는 지원되는 소켓 옵션과 같이 플랫폼이 지원하는 것에 대한 정보를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="33e0d6537277d523e6c2dd7e69081c04d55238d6" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;Default&lt;/code&gt; if no term has been stored with the key &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;Key&lt;/code&gt; 키로 저장된 용어가없는 경우 &lt;code&gt;Default&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="062c8ae0406bce16cb74fa7ee50a7f220f4495f9" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;ok&lt;/code&gt; if the server terminates with the expected reason. Any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt; causes an error report to be issued through &lt;code&gt;logger(3)&lt;/code&gt;. The default &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">이 함수는 서버가 예상 된 이유로 종료되면 &lt;code&gt;ok&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 이유로 인해 &lt;code&gt;logger(3)&lt;/code&gt; 통해 오류 보고서가 발행됩니다 . 기본 &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b619b8eb3b06a0c1f9ee95ad936ded887fe9b1f" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{continue | finished, Output}&lt;/code&gt;, where Output is the data that was decompressed in this call. New input can be queued up on each call if desired, and the function will return &lt;code&gt;{finished, Output}&lt;/code&gt; once all queued data has been decompressed.</source>
          <target state="translated">이 함수는 &lt;code&gt;{continue | finished, Output}&lt;/code&gt; . 여기서 Output은이 호출에서 압축 해제 된 데이터입니다. 원하는 경우 각 호출에서 새 입력을 대기시킬 수 있으며, 대기중인 모든 데이터가 압축 해제되면 함수는 &lt;code&gt;{finished, Output}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="1fe5f1399ea4e26d1526efcdd913ad89693dd38c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{more, Decompressed}&lt;/code&gt;, when there is more output available, and &lt;code&gt;&lt;a href=&quot;#inflateChunk-1&quot;&gt;inflateChunk/1&lt;/a&gt;&lt;/code&gt; is to be used to read it.</source>
          <target state="translated">이 함수는 사용 가능한 출력이 더 있고 &lt;code&gt;&lt;a href=&quot;#inflateChunk-1&quot;&gt;inflateChunk/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 읽을 때 &lt;code&gt;{more, Decompressed}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="57c7b411ef596e9d3dc2dccd3a829fab7afcf559" translate="yes" xml:space="preserve">
          <source>This function returns a non-zero value if the time-slice has been exhausted, and zero if the callback is allowed to continue execution. If a non-zero value is returned, the driver callback is to return as soon as possible in order for the port to be able to yield.</source>
          <target state="translated">이 함수는 시간 분할이 소진 된 경우 0이 아닌 값을 반환하고 콜백이 계속 실행될 수 있으면 0을 반환합니다. 0이 아닌 값이 반환되면 포트를 생성 할 수 있도록 드라이버 콜백이 가능한 빨리 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b34ef5ebb7e9ff07df93e070c922fe104914c7bc" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;&lt;a href=&quot;#type-tid&quot;&gt;tid()&lt;/a&gt;&lt;/code&gt; of the named table identified by &lt;code&gt;TableName&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; if no such table exists. The &lt;code&gt;tid()&lt;/code&gt; can be used in place of the table name in all operations, which is slightly faster since the name does not have to be resolved on each call.</source>
          <target state="translated">이 함수는 &lt;code&gt;TableName&lt;/code&gt; 으로 식별 된 명명 된 테이블 의 &lt;code&gt;&lt;a href=&quot;#type-tid&quot;&gt;tid()&lt;/a&gt;&lt;/code&gt; 를 반환 하거나 해당 테이블이 없으면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다. &lt;code&gt;tid()&lt;/code&gt; 빠르게 이름이 각 호출에 해결 될 필요가 없기 때문에 약간 모든 작업, 테이블 이름 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50dd77bc2f5d6e06a832906b2c12c471d8aa9340" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;Adler&lt;/code&gt; checksum of &lt;code&gt;[Data1,Data2]&lt;/code&gt;, requiring only &lt;code&gt;Adler1&lt;/code&gt;, &lt;code&gt;Adler2&lt;/code&gt;, and &lt;code&gt;Size2&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;Adler1&lt;/code&gt; , &lt;code&gt;Adler2&lt;/code&gt; 및 &lt;code&gt;Size2&lt;/code&gt; 만 필요한 &lt;code&gt;[Data1,Data2]&lt;/code&gt; 의 &lt;code&gt;Adler&lt;/code&gt; 체크섬을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="254134ddf194a5bc8b6a55dc528e9535675c6294" translate="yes" xml:space="preserve">
          <source>This function returns the &lt;code&gt;CRC&lt;/code&gt; checksum of &lt;code&gt;[Data1,Data2]&lt;/code&gt;, requiring only &lt;code&gt;CRC1&lt;/code&gt;, &lt;code&gt;CRC2&lt;/code&gt;, and &lt;code&gt;Size2&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;CRC1&lt;/code&gt; , &lt;code&gt;CRC2&lt;/code&gt; 및 &lt;code&gt;Size2&lt;/code&gt; 만 필요한 &lt;code&gt;[Data1,Data2]&lt;/code&gt; 의 &lt;code&gt;CRC&lt;/code&gt; 체크섬을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bfe8f7ec0382a52a177f156ebe5c3e11685e6528" translate="yes" xml:space="preserve">
          <source>This function returns the default encoding for Erlang source files (if no encoding comment is present) in the currently running release. In Erlang/OTP R16B, &lt;code&gt;latin1&lt;/code&gt; (bytewise encoding) was returned. As from Erlang/OTP 17.0, &lt;code&gt;utf8&lt;/code&gt; is returned.</source>
          <target state="translated">이 함수는 현재 실행중인 릴리스에서 Erlang 소스 파일의 기본 인코딩 (인코딩 주석이없는 경우)을 반환합니다. Erlang / OTP R16B에서 &lt;code&gt;latin1&lt;/code&gt; ( 바이트 별 인코딩)이 리턴되었습니다. Erlang / OTP 17.0에서와 같이 &lt;code&gt;utf8&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="24ac5e4c95ff19314b1e92b03b1fbc6ddb4df1f4" translate="yes" xml:space="preserve">
          <source>This function returns the user tag set in the current process or, if no user tag is present, the last user tag sent to the process together with a message (in the same way as &lt;code&gt;sequential trace tokens&lt;/code&gt; are spread to other processes together with messages. For an explanation of how user tags can be spread together with messages, see &lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt;. If no tag is found or dynamic tracing is not available, it returns &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">이 함수는 현재 프로세스에서 설정 한 사용자 태그를 반환하거나 사용자 태그가없는 경우 메시지와 함께 프로세스에 전송 된 마지막 사용자 태그 ( &lt;code&gt;sequential trace tokens&lt;/code&gt; 이 메시지와 함께 다른 프로세스로 확산 되는 것과 동일한 방식으로)를 반환 합니다. 사용자 태그를 메시지와 함께 전파하는 방법에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#spread_tag-1&quot;&gt;spread_tag/1&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 태그가 없거나 동적 추적을 사용할 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad3f3a41d62bdc7c42feabe41234fd9722d7cb98" translate="yes" xml:space="preserve">
          <source>This function returns the user tag set in the current process. If no tag is set or dynamic tracing is not available, it returns &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">이 함수는 현재 프로세스에서 설정된 사용자 태그를 반환합니다. 태그가 설정되어 있지 않거나 동적 추적을 사용할 수 없으면 &lt;code&gt;undefined&lt;/code&gt; 을 반환합니다</target>
        </trans-unit>
        <trans-unit id="644324c7c6a31f16ffa3ae52932ba3909ce2be83" translate="yes" xml:space="preserve">
          <source>This function returns the verbosity level for the specified logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt; User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to read the general verbosity level.</source>
          <target state="translated">이 함수는 지정된 로깅 범주에 대한 자세한 수준을 반환합니다. 자세한 내용은 사용 &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt; User's Guide&lt;/a&gt;&lt;/code&gt; 를 참조하십시오. 일반 상세 수준을 읽으려면 &lt;code&gt;default&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fd79f4e47f62cf59b521bcb089167a8d5c5fd14f" translate="yes" xml:space="preserve">
          <source>This function returns the verbosity level for the specified logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to read the general verbosity level.</source>
          <target state="translated">이 함수는 지정된 로깅 범주에 대한 상세 수준을 반환합니다. 자세한 내용은 사용 &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 를 참조하십시오. 일반 상세 레벨을 읽으려면 &lt;code&gt;default&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9213458608b1e7bf5d8b4e1a7eb828c4aad8ff78" translate="yes" xml:space="preserve">
          <source>This function returns value from dictionary and a new dictionary without this value. Returns &lt;code&gt;error&lt;/code&gt; if the key is not present in the dictionary.</source>
          <target state="translated">이 함수는이 값이없는 사전과 새 사전의 값을 반환합니다. 키가 사전에 없으면 &lt;code&gt;error&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf35b3402a76d292262e9d707c75231902c52bf" translate="yes" xml:space="preserve">
          <source>This function returns value from dictionary and new dictionary without this value. Returns &lt;code&gt;error&lt;/code&gt; if the key is not present in the dictionary.</source>
          <target state="translated">이 함수는이 값없이 사전과 새 사전에서 값을 반환합니다. 키가 사전에 없으면 &lt;code&gt;error&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="4620a951555900d51d4b19f86794013a12f92c5b" translate="yes" xml:space="preserve">
          <source>This function runs the measurement on all the &lt;strong&gt;official&lt;/strong&gt; codecs; pretty, compact, ber, per and erlang.</source>
          <target state="translated">이 기능은 모든 &lt;strong&gt;공식&lt;/strong&gt; 코덱 에서 측정을 실행합니다 . 예쁘고 콤팩트하고, 베르당, 얼랑.</target>
        </trans-unit>
        <trans-unit id="4d644d2c0042513fa733b8a7d873cf8a04730f5c" translate="yes" xml:space="preserve">
          <source>This function sends a message to the event manager registered as &lt;code&gt;error_man&lt;/code&gt;, telling it to add the event handler &lt;code&gt;terminal_logger&lt;/code&gt;. The event manager calls the callback function &lt;code&gt;terminal_logger:init([])&lt;/code&gt;, where the argument &lt;code&gt;[]&lt;/code&gt; is the third argument to &lt;code&gt;add_handler&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the event handler.</source>
          <target state="translated">이 함수는 &lt;code&gt;error_man&lt;/code&gt; 으로 등록 된 이벤트 관리자에게 메시지를 보내서 이벤트 핸들러 &lt;code&gt;terminal_logger&lt;/code&gt; 를 추가하도록 지시합니다 . 이벤트 관리자는 콜백 함수 &lt;code&gt;terminal_logger:init([])&lt;/code&gt; 호출합니다 . 여기서 인수 &lt;code&gt;[]&lt;/code&gt; 는 &lt;code&gt;add_handler&lt;/code&gt; 의 세 번째 인수 입니다. &lt;code&gt;init&lt;/code&gt; 는 &lt;code&gt;{ok, State}&lt;/code&gt; 를 리턴 할 것으로 예상되며 , 여기서 &lt;code&gt;State&lt;/code&gt; 는 이벤트 핸들러의 내부 상태입니다.</target>
        </trans-unit>
        <trans-unit id="9488c1c7cd2d72dbd05ee8b3a4cf579cbfcc3089" translate="yes" xml:space="preserve">
          <source>This function sends a message to the event manager registered as &lt;code&gt;error_man&lt;/code&gt;, telling it to delete the event handler &lt;code&gt;terminal_logger&lt;/code&gt;. The event manager calls the callback function &lt;code&gt;terminal_logger:terminate([], State)&lt;/code&gt;, where the argument &lt;code&gt;[]&lt;/code&gt; is the third argument to &lt;code&gt;delete_handler&lt;/code&gt;. &lt;code&gt;terminate&lt;/code&gt; is to be the opposite of &lt;code&gt;init&lt;/code&gt; and do any necessary cleaning up. Its return value is ignored.</source>
          <target state="translated">이 함수는 &lt;code&gt;error_man&lt;/code&gt; 으로 등록 된 이벤트 관리자에게 메시지를 보내서 이벤트 핸들러 &lt;code&gt;terminal_logger&lt;/code&gt; 를 삭제하도록 지시합니다 . 이벤트 관리자는 콜백 함수 &lt;code&gt;terminal_logger:terminate([], State)&lt;/code&gt; 호출합니다 . 여기서 인수 &lt;code&gt;[]&lt;/code&gt; 는 &lt;code&gt;delete_handler&lt;/code&gt; 의 세 번째 인수 입니다. &lt;code&gt;terminate&lt;/code&gt; 는 &lt;code&gt;init&lt;/code&gt; 의 반대 여야하며 필요한 정리를 수행해야합니다. 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="01064956f3c5f10087dfedd98caeabdab20043f6" translate="yes" xml:space="preserve">
          <source>This function sets the user tag of the current process. The user tag is a binary(), but can be specified as any iodata(), which is automatically converted to a binary by this function.</source>
          <target state="translated">이 기능은 현재 프로세스의 사용자 태그를 설정합니다. 사용자 태그는 binary ()이지만이 함수에 의해 바이너리로 자동 변환되는 iodata ()로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61313460b8aa3e37c5b58b57b47f109e6ec0573c" translate="yes" xml:space="preserve">
          <source>This function sets up a subscription for NETCONF event notifications of the specified stream type, matching the specified filter. The calling process receives notifications as messages of type &lt;code&gt;&lt;a href=&quot;#type-notification&quot;&gt;notification()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 지정된 필터와 일치하는 지정된 스트림 유형의 NETCONF 이벤트 알림에 대한 구독을 설정합니다. 호출 프로세스는 &lt;code&gt;&lt;a href=&quot;#type-notification&quot;&gt;notification()&lt;/a&gt;&lt;/code&gt; 유형의 메시지로 알림을받습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2f0db4a2d6577440241530db91576d86c351bc" translate="yes" xml:space="preserve">
          <source>This function should be used by custom Logger handlers to make configuration consistent no matter which handler the system uses. Normal usage is to add a call to &lt;code&gt;logger:add_handlers/1&lt;/code&gt; just after the processes that the handler needs are started, and pass the application's &lt;code&gt;logger&lt;/code&gt; configuration as the argument. For example:</source>
          <target state="translated">이 함수는 시스템이 사용하는 핸들러에 관계없이 구성을 일관되게하기 위해 사용자 정의 로거 핸들러에서 사용해야합니다. 일반적인 사용법은 핸들러가 필요한 프로세스가 시작된 직후 &lt;code&gt;logger:add_handlers/1&lt;/code&gt; 에 대한 호출을 추가 하고 애플리케이션의 &lt;code&gt;logger&lt;/code&gt; 구성을 인수로 전달하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f301b3f0b8c0209d0cf4fd9f62efd0855d383514" translate="yes" xml:space="preserve">
          <source>This function should be used whenever the &lt;code&gt;ScopedPDU&lt;/code&gt; is encrypted.</source>
          <target state="translated">이 기능은 &lt;code&gt;ScopedPDU&lt;/code&gt; 가 암호화 될 때마다 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92119a39fe094fc4b7f2725a3cd542c77c8004c7" translate="yes" xml:space="preserve">
          <source>This function should be used with care!</source>
          <target state="translated">이 기능은주의해서 사용해야합니다!</target>
        </trans-unit>
        <trans-unit id="6163aa7d8dcc271f09c1955760210bfef0a047d1" translate="yes" xml:space="preserve">
          <source>This function should only be used for micro-benchmarks; it sets &lt;code&gt;copy_save&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for the duration of the call, which can quickly lead to running out of memory.</source>
          <target state="translated">이 기능은 마이크로 벤치 마크에만 사용해야합니다. 호출하는 동안 &lt;code&gt;copy_save&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 메모리가 빨리 소진 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="378340ac7df7630dbeb8cb5d900d9bad24c77182" translate="yes" xml:space="preserve">
          <source>This function should, besides spawning the connection supervisor, also create a distribution controller. The distribution controller is either a process or a port which is responsible for dispatching traffic.</source>
          <target state="translated">이 기능은 연결 관리자를 생성하는 것 외에도 배포 컨트롤러를 만들어야합니다. 배포 컨트롤러는 프로세스를 전달하거나 트래픽을 처리하는 포트입니다.</target>
        </trans-unit>
        <trans-unit id="d4d47d2b2af731fd5c9c26e6262581d877c04f00" translate="yes" xml:space="preserve">
          <source>This function shuts down a previously started trace client. The &lt;code&gt;Pid&lt;/code&gt; argument is the process id returned from the &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">이 기능은 이전에 시작된 추적 클라이언트를 종료합니다. &lt;code&gt;Pid&lt;/code&gt; 인수는 반환 된 프로세스 ID입니다 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#trace_client-3&quot;&gt;trace_client/3&lt;/a&gt;&lt;/code&gt; 호.</target>
        </trans-unit>
        <trans-unit id="1762fe9d329cecf345c08b9b7958cf3995f81b8e" translate="yes" xml:space="preserve">
          <source>This function spawns and links to a new process, an event manager.</source>
          <target state="translated">이 함수는 새로운 프로세스 인 이벤트 관리자를 생성하고 연결합니다.</target>
        </trans-unit>
        <trans-unit id="550809e278a777ab2f212797a3d8588ff2bdddcd" translate="yes" xml:space="preserve">
          <source>This function starts a server on the local node that will be the recipient of all trace messages. All subsequent calls to &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; will result in messages sent to the newly started trace server.</source>
          <target state="translated">이 기능은 모든 추적 메시지의 수신자가 될 로컬 노드에서 서버를 시작합니다. &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 에 대한 모든 후속 호출 은 새로 시작된 추적 서버로 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="02bf735444f615dc9059203b498c83b1b1c490d8" translate="yes" xml:space="preserve">
          <source>This function starts a trace client that reads the output created by a trace port driver and handles it in mostly the same way as a tracer process created by the &lt;code&gt;&lt;a href=&quot;#tracer-0&quot;&gt;tracer/0&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이 기능은 추적 포트 드라이버로 작성된 출력을 읽고 추적 &lt;code&gt;&lt;a href=&quot;#tracer-0&quot;&gt;tracer/0&lt;/a&gt;&lt;/code&gt; 기능으로 작성된 추적 프로그램 프로세스와 거의 같은 방식으로 처리하는 추적 클라이언트를 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="71ed1ace1cba19901a1c4410fa55742720248a3e" translate="yes" xml:space="preserve">
          <source>This function starts a tracer server with additional parameters on the local node. The first parameter, the &lt;code&gt;Type&lt;/code&gt;, indicates if trace messages should be handled by a receiving process (&lt;code&gt;process&lt;/code&gt;), by a tracer port (&lt;code&gt;port&lt;/code&gt;) or by a tracer module (&lt;code&gt;module&lt;/code&gt;). For a description about tracer ports see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; and for a tracer modules see &lt;code&gt;erl_tracer&lt;/code&gt;.</source>
          <target state="translated">이 기능은 로컬 노드에서 추가 매개 변수를 사용하여 추적 프로그램 서버를 시작합니다. 첫 번째 매개 변수 인 &lt;code&gt;Type&lt;/code&gt; 은 추적 메시지를 수신 프로세스 ( &lt;code&gt;process&lt;/code&gt; ), 추적기 포트 ( &lt;code&gt;port&lt;/code&gt; ) 또는 추적기 모듈 ( &lt;code&gt;module&lt;/code&gt; )에 의해 처리해야하는지 여부를 나타냅니다 . 추적 프로그램 포트에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 를 참조하고 추적 프로그램 모듈은 &lt;code&gt;erl_tracer&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b87e561423bace774990128b77e86ad6df9e413" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with all codec configs. &lt;code&gt;Factor&lt;/code&gt; (defaults to &lt;code&gt;1&lt;/code&gt;) processes are started for every supported codec config.</source>
          <target state="translated">이 기능은 모든 코덱 구성으로 &lt;strong&gt;mstone1&lt;/strong&gt; 성능 테스트를 시작합니다 . 지원되는 모든 코덱 구성에 대해 &lt;code&gt;Factor&lt;/code&gt; (기본값은 &lt;code&gt;1&lt;/code&gt; ) 프로세스가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="792ed4cb1314be5885f62ea62a3ebeadcd5147c2" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with codec configs not using any drivers (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; without &lt;code&gt;flex&lt;/code&gt;, &lt;code&gt;ber&lt;/code&gt; and &lt;code&gt;per&lt;/code&gt; without &lt;code&gt;driver&lt;/code&gt; and &lt;code&gt;erlang&lt;/code&gt; without &lt;code&gt;compressed&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">이 기능은 드라이버를 사용하지 않는 코덱 구성으로 &lt;strong&gt;mstone1&lt;/strong&gt; 성능 테스트를 시작합니다 (예 : &lt;code&gt;flex&lt;/code&gt; , &lt;code&gt;ber&lt;/code&gt; 및 &lt;code&gt;per&lt;/code&gt; 없이 &lt;code&gt;driver&lt;/code&gt; 및 &lt;code&gt;erlang&lt;/code&gt; 없이 &lt;code&gt;compressed&lt;/code&gt; 및 &lt;code&gt;compact&lt;/code&gt; 되지 않은 &lt;code&gt;pretty&lt;/code&gt; 컴팩트 함 ). 표준 테스트를 실행할 때와 동일한 수의 프로세스가 시작됩니다 ( &lt;code&gt;start/0,1&lt;/code&gt; 기능 사용). 각 프로세스는 메시지를 인코딩하고 디코딩합니다. 전체적으로 (모든 프로세스에 대해) 처리 된 메시지 수는 mstone 값입니다.</target>
        </trans-unit>
        <trans-unit id="ad7b4c53c1b5220bc2673b30cb62ee3a8a2764a4" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with only the driver using codec configs (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; with &lt;code&gt;flex&lt;/code&gt;, and &lt;code&gt;ber&lt;/code&gt; and &lt;code&gt;per&lt;/code&gt; with &lt;code&gt;driver&lt;/code&gt; and &lt;code&gt;erlang&lt;/code&gt; with &lt;code&gt;compressed&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">이 기능은 시작 &lt;strong&gt;mstone1의&lt;/strong&gt; (즉, 코덱 CONFIGS를 사용하여 드라이버 만에 성능 테스트를 &lt;code&gt;pretty&lt;/code&gt; 하고 &lt;code&gt;compact&lt;/code&gt; 와 &lt;code&gt;flex&lt;/code&gt; 및 &lt;code&gt;ber&lt;/code&gt; 및 &lt;code&gt;per&lt;/code&gt; 과 &lt;code&gt;driver&lt;/code&gt; 와 &lt;code&gt;erlang&lt;/code&gt; 로 &lt;code&gt;compressed&lt;/code&gt; ). 표준 테스트를 실행할 때와 동일한 수의 프로세스가 시작됩니다 ( &lt;code&gt;start/0,1&lt;/code&gt; 기능 사용). 각 프로세스는 메시지를 인코딩하고 디코딩합니다. 전체적으로 (모든 프로세스에 대해) 처리 된 메시지 수는 mstone 값입니다.</target>
        </trans-unit>
        <trans-unit id="a169f04fb06754d3d77f607833509158a7205503" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone1&lt;/strong&gt; performance test with only the flex codec configs (i.e. &lt;code&gt;pretty&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; with &lt;code&gt;flex&lt;/code&gt;). The same number of processes are started as when running the standard test (using the &lt;code&gt;start/0,1&lt;/code&gt; function). Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">이 기능은 시작 &lt;strong&gt;mstone1의&lt;/strong&gt; 와 성능 테스트 만 플렉스 코덱 CONFIGS (즉, &lt;code&gt;pretty&lt;/code&gt; 및 &lt;code&gt;compact&lt;/code&gt; 와 &lt;code&gt;flex&lt;/code&gt; ). 표준 테스트를 실행할 때와 동일한 수의 프로세스가 시작됩니다 ( &lt;code&gt;start/0,1&lt;/code&gt; 기능 사용). 각 프로세스는 메시지를 인코딩하고 디코딩합니다. 전체적으로 (모든 프로세스에 대해) 처리 된 메시지 수는 mstone 값입니다.</target>
        </trans-unit>
        <trans-unit id="198cdb7eaaa9d51f54f530ef45039bacb833b143" translate="yes" xml:space="preserve">
          <source>This function starts the &lt;strong&gt;mstone2&lt;/strong&gt; performance test with all codec configs. Processes are created dynamically. Each process make &lt;strong&gt;one&lt;/strong&gt; run through their messages (decoding and encoding messages) and then exits. When one process exits, a new is created with the same codec config and set of messages.</source>
          <target state="translated">이 기능은 모든 코덱 구성으로 &lt;strong&gt;mstone2&lt;/strong&gt; 성능 테스트를 시작합니다 . 프로세스는 동적으로 생성됩니다. 각 프로세스의 메이크업을 &lt;strong&gt;한&lt;/strong&gt; 자신의 메시지 (디코딩 및 메시지를 인코딩) 한 후 종료하고를 실행합니다. 하나의 프로세스가 종료되면 동일한 코덱 구성 및 메시지 세트로 새 프로세스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f645d23afcc815891f3acc3933eab5ba5bdfcf9" translate="yes" xml:space="preserve">
          <source>This function starts the evaluation of a digit map with megaco:eval_digit_map/1 and sends a sequence of events to it megaco:report_digit_event/2 in order to simplify testing of digit maps.</source>
          <target state="translated">이 함수는 megaco : eval_digit_map / 1을 사용하여 숫자 맵의 평가를 시작하고 숫자 맵의 테스트를 단순화하기 위해 일련의 이벤트를 megaco : report_digit_event / 2로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4a3fae66ed7c3cc4e51664a7096a153b2497b47c" translate="yes" xml:space="preserve">
          <source>This function starts the standalone &lt;code&gt;nteventlog&lt;/code&gt; process and, if &lt;code&gt;start_link/2&lt;/code&gt; is used, links to it.</source>
          <target state="translated">이 함수는 독립형 &lt;code&gt;nteventlog&lt;/code&gt; 프로세스를 시작하고 &lt;code&gt;start_link/2&lt;/code&gt; 를 사용하는 경우 해당 프로세스 에 링크합니다.</target>
        </trans-unit>
        <trans-unit id="51eab0810670dc8d97c68c1365bff9e556a60d4b" translate="yes" xml:space="preserve">
          <source>This function takes a list of 'ActionRequest' records and has three main options:</source>
          <target state="translated">이 함수는 'ActionRequest'레코드 목록을 가져오고 세 가지 주요 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b830d311ae4ee73ecebdc71d2c40db38f6b5103e" translate="yes" xml:space="preserve">
          <source>This function tries to register the specified managed agents, without checking if any of them exist. To change a registered managed agent, the agent must first be unregistered.</source>
          <target state="translated">이 기능은 지정된 관리 에이전트가 있는지 확인하지 않고 지정된 관리 에이전트를 등록하려고합니다. 등록 된 관리 에이전트를 변경하려면 먼저 에이전트를 등록 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="97a729927e14b719ca944a21f7b5b57eca599bd8" translate="yes" xml:space="preserve">
          <source>This function tries to register the specified users, without checking if any of them exist. To change a registered user, the user must first be unregistered.</source>
          <target state="translated">이 기능은 지정된 사용자가 있는지 확인하지 않고 지정된 사용자를 등록하려고합니다. 등록 된 사용자를 변경하려면 먼저 사용자 등록을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b10454e8f4725b8a0eb4da465ee57ecb2b75d61c" translate="yes" xml:space="preserve">
          <source>This function updates the configuration data from which the specified configuration variable was read, and returns the (possibly) new value of this variable.</source>
          <target state="translated">이 함수는 지정된 구성 변수를 읽은 구성 데이터를 업데이트하고이 변수의 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca81e8a0f9544f8a61bc496a4e260c146099af94" translate="yes" xml:space="preserve">
          <source>This function used to return &lt;code&gt;false&lt;/code&gt; for BIFs before Erlang/OTP 18.0.</source>
          <target state="translated">이 함수는 Erlang / OTP 18.0 이전의 BIF에 대해 &lt;code&gt;false&lt;/code&gt; 를 리턴하는 데 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ae9274ef2248b4bd36f346fff38a572567648823" translate="yes" xml:space="preserve">
          <source>This function uses resolver option &lt;code&gt;search&lt;/code&gt; just like &lt;code&gt;&lt;a href=&quot;#getbyname-2&quot;&gt;getbyname/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#getbyname-2&quot;&gt;getbyname/2,3&lt;/a&gt;&lt;/code&gt; 과 같은 리졸버 옵션 &lt;code&gt;search&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="21fc2b9bb4c2e8f025026e93df306e88dd67e182" translate="yes" xml:space="preserve">
          <source>This function uses resolver option &lt;code&gt;search&lt;/code&gt; that is a list of domain names. If the name to resolve contains no dots, it is prepended to each domain name in the search list, and they are tried in order. If the name contains dots, it is first tried as an absolute name and if that fails, the search list is used. If the name has a trailing dot, it is supposed to be an absolute name and the search list is not used.</source>
          <target state="translated">이 기능은 도메인 이름 목록 인 확인자 옵션 &lt;code&gt;search&lt;/code&gt; 을 사용 합니다. 확인할 이름에 점이 없으면 검색 목록의 각 도메인 이름 앞에 붙고 순서대로 시도합니다. 이름에 점이 포함되어 있으면 먼저 절대 이름으로 시도되고 실패하면 검색 목록이 사용됩니다. 이름에 후행 점이 있으면 절대 이름이어야하며 검색 목록이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66f0f7dcf3e6aeb3b05425d374f015271bc5c8f8" translate="yes" xml:space="preserve">
          <source>This function uses the NIF library to determine if dynamic tracing is available. Usually calling &lt;code&gt;erlang:system_info/1&lt;/code&gt; is a better indicator of the availability of dynamic tracing.</source>
          <target state="translated">이 함수는 NIF 라이브러리를 사용하여 동적 추적이 사용 가능한지 판별합니다. 일반적으로 &lt;code&gt;erlang:system_info/1&lt;/code&gt; 을 호출 하는 것이 동적 추적의 가용성에 대한 더 나은 지표입니다.</target>
        </trans-unit>
        <trans-unit id="21d638edd5b52a38a30d020b01f40281508b0f05" translate="yes" xml:space="preserve">
          <source>This function uses the module &lt;code&gt;rand&lt;/code&gt; to generate new keys. The seed it uses may be initialized by calling &lt;code&gt;rand:seed/1&lt;/code&gt; or &lt;code&gt;rand:seed/2&lt;/code&gt; before this function is first called.</source>
          <target state="translated">이 기능은 모듈 &lt;code&gt;rand&lt;/code&gt; 를 사용하여 새 키를 생성합니다. 이 함수가 처음 호출되기 전에 &lt;code&gt;rand:seed/1&lt;/code&gt; 또는 &lt;code&gt;rand:seed/2&lt;/code&gt; 를 호출하여 사용하는 시드를 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="971c66faa137257bfd2753c3d5426c0e180b495e" translate="yes" xml:space="preserve">
          <source>This function was introduced in Erlang/OTP R16 as part of a first step to support UTF-8 atoms.</source>
          <target state="translated">이 기능은 UTF-8 원자를 지원하는 첫 단계의 일부로 Erlang / OTP R16에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d681ac22ff0dcd99cf6793970b0001c494cacadb" translate="yes" xml:space="preserve">
          <source>This function was originally intenden for debugging purpose. It is not recommended to print very large terms with &lt;code&gt;%T&lt;/code&gt;. The function may change &lt;code&gt;errno&lt;/code&gt;, even if successful.</source>
          <target state="translated">이 기능은 원래 디버깅 목적으로 사용되었습니다. &lt;code&gt;%T&lt;/code&gt; 매우 큰 용어를 인쇄하지 않는 것이 좋습니다 . 성공하더라도 함수가 &lt;code&gt;errno&lt;/code&gt; 를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59044a92e08961dca9d0df91cd84e6bdf2e387c0" translate="yes" xml:space="preserve">
          <source>This function will fail with a &lt;code&gt;badarg&lt;/code&gt; exception if:</source>
          <target state="translated">이 함수는 다음과 같은 경우 &lt;code&gt;badarg&lt;/code&gt; 예외 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="ecc1aaa0050da285abdb43a70baab76906a3247e" translate="yes" xml:space="preserve">
          <source>This function will return the identity of test- and group leader processes that are still running at the time of this call. &lt;code&gt;TestProcs&lt;/code&gt; are processes in the system that have a Common Test IO process as group leader. &lt;code&gt;SharedGL&lt;/code&gt; is the central Common Test IO process, responsible for printing to log files for configuration functions and sequentially executing test cases. &lt;code&gt;OtherGLs&lt;/code&gt; are Common Test IO processes that print to log files for test cases in parallel test case groups.</source>
          <target state="translated">이 함수는이 호출시 여전히 실행중인 테스트 및 그룹 리더 프로세스의 ID를 반환합니다. &lt;code&gt;TestProcs&lt;/code&gt; 는 그룹 리더로서 공통 테스트 IO 프로세스가있는 시스템의 프로세스입니다. &lt;code&gt;SharedGL&lt;/code&gt; 은 중앙 공통 테스트 IO 프로세스로서 구성 기능을 위해 로그 파일로 인쇄하고 테스트 케이스를 순차적으로 실행합니다. &lt;code&gt;OtherGLs&lt;/code&gt; 은 병렬 테스트 케이스 그룹에서 테스트 케이스의 로그 파일에 인쇄하는 공통 테스트 IO 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="f14e5a0a13df62695dcaadc50e2282e18baef924" translate="yes" xml:space="preserve">
          <source>This function will save all match specifications saved during the session (during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;) and built-in match specifications in a text file with the name designated by &lt;code&gt;Name&lt;/code&gt;. The format of the file is textual, why it can be edited with an ordinary text editor, and then restored with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 세션 중에 저장된 경기 사양을 저장합니다 (호출시 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 등) 내장 경기 규격에 의해 지정된 이름의 텍스트 파일에 &lt;code&gt;Name&lt;/code&gt; . 파일 형식은 텍스트 형식이므로 일반 텍스트 편집기로 편집 한 다음 &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; 로 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe5d78839a608e23473c4be1eb43fd59136f1578" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;, but only disables tracing set up with &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; (not with &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 로 작동 하지만 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 로 설정된 추적 만 비활성화합니다 ( &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 가 아닌 ).</target>
        </trans-unit>
        <trans-unit id="4f73b00efb28d22de61c21b36ad8a83ee49cefed" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt;, but only disables tracing set up with &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; (not with &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;#ctp-1&quot;&gt;ctp/1&lt;/a&gt;&lt;/code&gt; 로 작동 하지만 &lt;code&gt;&lt;a href=&quot;#tpl-2&quot;&gt;tpl/2&lt;/a&gt;&lt;/code&gt; 로 설정된 추적 만 비활성화합니다 ( &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 제외).</target>
        </trans-unit>
        <trans-unit id="7f3521fe756e0c4e17603d964e71f79b819ca2cc" translate="yes" xml:space="preserve">
          <source>This function works as &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, but enables tracing for local calls (and local functions) as well as for global calls (and functions).</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; 로 작동 하지만, 글로벌 호출 (및 함수)뿐만 아니라 로컬 호출 (및 로컬 함수)에 대한 추적을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="649cc8a65ee1157009a2026f80b85a94281bddef" translate="yes" xml:space="preserve">
          <source>This function works exactly as &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt;, but allows you to write your own handler function. The handler function works mostly as the one described in &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;, but will also have to be prepared to handle trace messages of the form &lt;code&gt;{drop, N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of dropped messages. This pseudo trace message will only occur if the ip trace driver is used.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 와 동일하게 작동 하지만 고유 한 핸들러 함수를 작성할 수 있습니다. 핸들러 함수는 대부분 &lt;code&gt;&lt;a href=&quot;#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 에 설명 된 것과 같이 작동 하지만 &lt;code&gt;{drop, N}&lt;/code&gt; 형식의 추적 메시지를 처리 ​​할 준비가되어야 합니다. 여기서 &lt;code&gt;N&lt;/code&gt; 은 삭제 된 메시지 수입니다. 이 유사 추적 메시지는 ip 추적 드라이버가 사용되는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3613eb939658a1c4e7abb497a6aeaed611fdecc" translate="yes" xml:space="preserve">
          <source>This function works exactly the same way as &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; except that it is asynchronous instead of synchronous. The spawned process will link with the caller when created. If an &lt;code&gt;Error&lt;/code&gt; occurs while doing the cover analysis the process will crash with the same error reason as &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; would return.</source>
          <target state="translated">이 기능은 정확히 같은 방식으로 작동 &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 대신 동기의 비동기 것을 제외한다. 스폰 된 프로세스는 생성 될 때 호출자와 연결됩니다. 경우 &lt;code&gt;Error&lt;/code&gt; 커버 분석을하는 동안 발생하는 프로세스는 동일한 오류 이유 충돌합니다 &lt;code&gt;&lt;a href=&quot;#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41248f0d6e585aea101cd90cc6b6f5d6fd5821da" translate="yes" xml:space="preserve">
          <source>This function, similar to &lt;code&gt;timer:sleep/1&lt;/code&gt; in STDLIB, suspends the test case for a specified time. However, this function also multiplies &lt;code&gt;Time&lt;/code&gt; with the &lt;code&gt;multiply_timetraps&lt;/code&gt; value (if set) and under certain circumstances also scales up the time automatically if &lt;code&gt;scale_timetraps&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; (default is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">STDLIB의 &lt;code&gt;timer:sleep/1&lt;/code&gt; 과 유사한이 함수 는 지정된 시간 동안 테스트 케이스를 일시 중단합니다. 그러나이 함수는 또한 &lt;code&gt;Time&lt;/code&gt; 에 &lt;code&gt;multiply_timetraps&lt;/code&gt; 값을 곱하고 (설정된 경우) 특정 상황에서 &lt;code&gt;scale_timetraps&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; )로 설정 되면 시간을 자동으로 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="285cbe2f9f5c577e4d9b2e978e114e422218a0dd" translate="yes" xml:space="preserve">
          <source>This functionality can be used to avoid that one process overloads a database on another node.</source>
          <target state="translated">이 기능은 한 프로세스가 다른 노드의 데이터베이스를 오버로드하지 않도록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e696e3030e058d7399f33e7d6312da8bd0dec58" translate="yes" xml:space="preserve">
          <source>This functionality is deprecated as of OTP 23, and will be removed in OTP 24. Reasonably new &lt;code&gt;gcc&lt;/code&gt; compilers will issue deprecation warnings. In order to disable these warnings, define the macro &lt;code&gt;EI_NO_DEPR_WARN&lt;/code&gt;.</source>
          <target state="translated">이 기능은 OTP 23에서 더 이상 사용되지 않으며 OTP 24에서 제거됩니다. 합리적으로 새로운 &lt;code&gt;gcc&lt;/code&gt; 컴파일러는 지원 중단 경고를 발행합니다. 이러한 경고를 비활성화하려면 &lt;code&gt;EI_NO_DEPR_WARN&lt;/code&gt; 매크로를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f663a6b926446bfebbbdc0b7d15882ae1bccc35" translate="yes" xml:space="preserve">
          <source>This functionality is only provided when using &lt;code&gt;BER&lt;/code&gt; (option &lt;code&gt;ber&lt;/code&gt;).</source>
          <target state="translated">이 기능은 &lt;code&gt;BER&lt;/code&gt; (옵션 &lt;code&gt;ber&lt;/code&gt; )을 사용할 때만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="03d45e2ad58e3bd143a9c7b2c50773493705e610" translate="yes" xml:space="preserve">
          <source>This functionality is used both when the transaction sender is used and for segmentation. So, for either of those to work, this function &lt;strong&gt;must&lt;/strong&gt; be fully supported!</source>
          <target state="translated">이 기능은 트랜잭션 전송자가 사용될 때와 분할에 모두 사용됩니다. 따라서 둘 중 하나가 작동 &lt;strong&gt;하려면&lt;/strong&gt; 이 기능 이 완전히 지원 &lt;strong&gt;되어야합니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="018c73d63f139a3baee06c9daba146659fa3ed6c" translate="yes" xml:space="preserve">
          <source>This functionality is used when a client process communicates with a file i/o-server to spread the user tag to the I/O-server and then down to the efile_drv driver. By using &lt;code&gt;spread_tag/1&lt;/code&gt; and &lt;code&gt;restore_tag/1&lt;/code&gt;, one can enable or disable spreading of user tags to other processes and then restore the previous state of the user tag. The TagData returned from this call contains all previous information so the state (including any previously spread user tags) will be completely restored by a later call to &lt;code&gt;restore_tag/1&lt;/code&gt;.</source>
          <target state="translated">이 기능은 클라이언트 프로세스가 파일 i / o-server와 통신하여 사용자 태그를 I / O-server로 펼친 다음 efile_drv 드라이버로 펼칠 때 사용됩니다. 사용하여 &lt;code&gt;spread_tag/1&lt;/code&gt; 및 &lt;code&gt;restore_tag/1&lt;/code&gt; 번 활성화하거나 비활성화 다른 프로세스 사용자 태그 확산 후 사용자 태그의 이전 상태를 복원. 이 호출에서 반환 된 TagData에는 이전의 모든 정보가 포함되므로 상태 (이전의 스프레드 사용자 태그 포함)는 나중에 &lt;code&gt;restore_tag/1&lt;/code&gt; 호출로 완전히 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bfce0af83883f449ffeeed0bed57f3f0c60c686" translate="yes" xml:space="preserve">
          <source>This functionality works together with option &lt;code&gt;ber&lt;/code&gt;. It enables the specialized decodes, see Section &lt;code&gt;&lt;a href=&quot;asn1_spec&quot;&gt;Specialized Decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;ber&lt;/code&gt; 옵션과 함께 작동합니다 . &lt;code&gt;&lt;a href=&quot;asn1_spec&quot;&gt;Specialized Decode&lt;/a&gt;&lt;/code&gt; 합니다. 섹션 특수화 된 디코드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b7b1c65d65cff1e78b722d7d85e687fe5927d13" translate="yes" xml:space="preserve">
          <source>This functions differs from &lt;code&gt;token&lt;/code&gt; in that it will continue to scan tokens upto and including an &lt;code&gt;{end_token,Token}&lt;/code&gt; has been scanned (see next section). It will then return all the tokens. This is typically used for scanning grammars like Erlang where there is an explicit end token, &lt;code&gt;'.'&lt;/code&gt;. If no end token is found then the whole file will be scanned and returned. If an error occurs then all tokens upto and including the next end token will be skipped.</source>
          <target state="translated">이 기능은 &lt;code&gt;token&lt;/code&gt; 을 스캔하고 &lt;code&gt;{end_token,Token}&lt;/code&gt; 을 포함하여 토큰을 계속 스캔한다는 점에서 토큰 과 다릅니다 (다음 섹션 참조). 그런 다음 모든 토큰을 반환합니다. 이는 일반적으로 명시적인 최종 토큰 &lt;code&gt;'.'&lt;/code&gt; 이있는 Erlang과 같은 문법을 스캔하는 데 사용됩니다 . . 종료 토큰이 없으면 전체 파일이 스캔되고 리턴됩니다. 오류가 발생하면 다음 끝 토큰을 포함하여 모든 토큰을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="78c42db04efcc05657be0800818fa1802af33516" translate="yes" xml:space="preserve">
          <source>This functions discards all options in the begining of the lines of thoose files when reading them.</source>
          <target state="translated">이 함수는 파일을 읽을 때 thoose 파일 줄의 시작 부분에있는 모든 옵션을 버립니다.</target>
        </trans-unit>
        <trans-unit id="7a3c88f30a1cd5b57516c27de9ff90f9c75fa259" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 대신 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4f5b9819acc50428faeeffeac0e065c79843eb3c" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 대신 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_INFO&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d18e02167a85c9b4d903d206ff737224c9a5b3ea" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 대신 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt; ?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e988c48e237b3372b652c8e3639563f7969c8f32" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 사용 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_ERROR&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#error-1&quot;&gt;logger:error/1,2,3&lt;/a&gt;&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="e1aa52c0f139d5d8a6f71a168c88c9470f952129" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 사용 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_INFO&lt;/a&gt;&lt;/code&gt; 매크로 나 &lt;code&gt;&lt;a href=&quot;logger#info-1&quot;&gt;logger:info/1,2,3&lt;/a&gt;&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="75829b451d464b595a1024dec90085ca0093abce" translate="yes" xml:space="preserve">
          <source>This functions is kept for backwards compatibility and must not be used by new code. Use the &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; macro or &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 이전 버전과의 호환성을 위해 유지되며 새 코드에서 사용해서는 안됩니다. 사용 &lt;code&gt;&lt;a href=&quot;logger#macros&quot;&gt;?LOG_WARNING&lt;/a&gt;&lt;/code&gt; 매크로 또는 &lt;code&gt;&lt;a href=&quot;logger#warning-1&quot;&gt;logger:warning/1,2,3&lt;/a&gt;&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="66d11c99d3b8bf1e2077d0f21b72e0ab032ea87c" translate="yes" xml:space="preserve">
          <source>This functions provides a way of updating a counter, without having to look up an object, update the object by incrementing an element, and insert the resulting object into the table again.</source>
          <target state="translated">이 함수는 개체를 조회하지 않고 카운터를 업데이트하고 요소를 증가시켜 개체를 업데이트 한 다음 결과 개체를 다시 테이블에 삽입하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2b70ec5aa36c1075bf590864c6a36436ad975b12" translate="yes" xml:space="preserve">
          <source>This generates a &lt;code&gt;relup&lt;/code&gt; file with instructions for how to upgrade from version &quot;A&quot; (&quot;ch_rel-1&quot;) to version &quot;B&quot; (&quot;ch_rel-2&quot;) and how to downgrade from version &quot;B&quot; to version &quot;A&quot;.</source>
          <target state="translated">버전 &quot;A&quot;( &quot;ch_rel-1&quot;)에서 버전 &quot;B&quot;( &quot;ch_rel-2&quot;)로 업그레이드하는 방법 및 버전 &quot;B&quot;에서 버전 &quot;A&quot;로 다운 그레이드하는 방법에 대한 지침 이 포함 된 &lt;code&gt;relup&lt;/code&gt; 파일 이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="c116938db051375fe0e1532d328cb08b14b31015" translate="yes" xml:space="preserve">
          <source>This gives &lt;code&gt;D = 273&lt;/code&gt;, &lt;code&gt;E = 00&lt;/code&gt;, and F binds to a binary of size 1: &lt;code&gt;binary_to_list(F) = [42]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;D = 273&lt;/code&gt; , &lt;code&gt;E = 00&lt;/code&gt; 을 제공하고 F는 1 크기의 이진에 바인딩합니다 : &lt;code&gt;binary_to_list(F) = [42]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b265622dae76f6ead2d5384e91874a0a56b738" translate="yes" xml:space="preserve">
          <source>This gives a binary of size 4. Here, a &lt;strong&gt;size expression&lt;/strong&gt; is used for the variable &lt;code&gt;C&lt;/code&gt; to specify a 16-bits segment of &lt;code&gt;Bin2&lt;/code&gt;.</source>
          <target state="translated">이것은 크기 4의 2 진을 제공합니다. 여기서, &lt;strong&gt;크기 &lt;/strong&gt; &lt;code&gt;C&lt;/code&gt; 는 변수 C 에 &lt;code&gt;Bin2&lt;/code&gt; 의 16 비트 세그먼트를 지정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9304ac5067de60ffef75db2d0f27153eea8fd249" translate="yes" xml:space="preserve">
          <source>This gives a set of binary logs, for example:</source>
          <target state="translated">예를 들어 다음과 같은 이진 로그 세트가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="efb5947a696c40715e3fb71363beaeb5efc4f051" translate="yes" xml:space="preserve">
          <source>This gives an entry for &lt;code&gt;m1&lt;/code&gt; also in the cover log for test run &lt;code&gt;s2&lt;/code&gt;. The problem is that this only reflects the coverage by &lt;code&gt;s2&lt;/code&gt; tests, not the accumulated result over &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;. This is where the cross cover mechanism comes in handy.</source>
          <target state="translated">테스트 실행 &lt;code&gt;s2&lt;/code&gt; 에 대한 커버 로그에도 &lt;code&gt;m1&lt;/code&gt; 에 대한 항목이 제공 됩니다. 문제는 이것이 &lt;code&gt;s1&lt;/code&gt; 과 &lt;code&gt;s2&lt;/code&gt; 에 대한 누적 결과가 아니라 &lt;code&gt;s2&lt;/code&gt; 테스트에 의한 적용 범위 만 반영한다는 것 입니다. 크로스 커버 메커니즘이 유용한 곳입니다.</target>
        </trans-unit>
        <trans-unit id="713b4a71335dbed07b61ab42f009c85295637765" translate="yes" xml:space="preserve">
          <source>This gives no result of length &amp;gt; 0 and we are at the last position, so the global search is complete.</source>
          <target state="translated">이로 인해 길이가 0보다 크지 않고 마지막 위치에 있으므로 전체 검색이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="e365e009b84d303f259288c46a5cf1337ae2825c" translate="yes" xml:space="preserve">
          <source>This gives the list of all elements in L1 that are not contained in L2.</source>
          <target state="translated">L2에 포함되지 않은 L1의 모든 요소 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="79f96c1766aa59b316c1112142e724a0ac8f12f4" translate="yes" xml:space="preserve">
          <source>This gives the same result. &lt;code&gt;[{'&amp;lt;', '$2', 2000}]&lt;/code&gt; is in the guard part and therefore discards anything that does not have an &lt;code&gt;empyear&lt;/code&gt; (bound to &lt;code&gt;'$2'&lt;/code&gt; in the head) less than 2000, as the guard in the &lt;code&gt;foldr/3&lt;/code&gt; example.</source>
          <target state="translated">이것은 동일한 결과를 제공합니다. &lt;code&gt;[{'&amp;lt;', '$2', 2000}]&lt;/code&gt; 은 가드 부분에 있으므로 &lt;code&gt;empyear&lt;/code&gt; &lt;code&gt;foldr/3&lt;/code&gt; 의 가드와 같이 empyear ( 머리에 &lt;code&gt;'$2'&lt;/code&gt; 에 바인딩 됨 )가 2000 미만인 것을 버립니다. 예.</target>
        </trans-unit>
        <trans-unit id="22d1dda5ab8530e1e0b433f6ea95f6b6b7eda6d3" translate="yes" xml:space="preserve">
          <source>This gives two binaries of size 3, with the following evaluations:</source>
          <target state="translated">이것은 다음과 같은 평가와 함께 크기가 3 인 2 개의 바이너리를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5bdfea051354f0bf5fa426336e15ae7b72111a2a" translate="yes" xml:space="preserve">
          <source>This grammar can be used to generate a parser which parses list expressions, such as &lt;code&gt;(), (a), (peter charles), (a (b c) d (())), ...&lt;/code&gt; provided that your scanner tokenizes, for example, the input &lt;code&gt;(peter charles)&lt;/code&gt; as follows:</source>
          <target state="translated">이 문법은 다음과 같은리스트의 표현을 파싱 파서를 생성 할 수있다 &lt;code&gt;(), (a), (peter charles), (a (b c) d (())), ...&lt;/code&gt; 을 위해, 스캐너 토큰 화 것을 구비 예를 들어, 입력 &lt;code&gt;(peter charles)&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5c33f8292424d5d8afd6fb208cfbfa703f594e5" translate="yes" xml:space="preserve">
          <source>This handler behaves much like &lt;code&gt;logger_std_h&lt;/code&gt;, except it uses &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; as its destination.</source>
          <target state="translated">이 핸들러 는 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 를 대상으로 사용 한다는 점을 제외하고 &lt;code&gt;logger_std_h&lt;/code&gt; 와 매우 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="dcaca3a309669115a5d10a160b27e110b7d53cd4" translate="yes" xml:space="preserve">
          <source>This handler ignores events that do not originate from the &lt;code&gt;error_logger&lt;/code&gt; API, or from within OTP. This means that if your code uses the Logger API for logging, then your log events will be discarded by this handler.</source>
          <target state="translated">이 핸들러는 &lt;code&gt;error_logger&lt;/code&gt; API 또는 OTP에서 시작되지 않은 이벤트를 무시합니다 . 이는 코드에서 로깅을 위해 로거 API를 사용하는 경우이 핸들러에서 로그 이벤트를 버립니다.</target>
        </trans-unit>
        <trans-unit id="575502000290e2f076b35060118636479ce93a20" translate="yes" xml:space="preserve">
          <source>This handler is provided for backwards compatibility only. It is not started by default, but will be automatically started the first time an &lt;code&gt;error_logger&lt;/code&gt; event handler is added with &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt; error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 핸들러는 이전 버전과의 호환성을 위해서만 제공됩니다. 그것은 기본적으로 시작되지 않지만 자동으로 처음으로 시작됩니다 &lt;code&gt;error_logger&lt;/code&gt; 의 이벤트 핸들러에 추가됩니다 &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt; error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29807c3684400c3becd59e5edf9ba096157cab01" translate="yes" xml:space="preserve">
          <source>This handler is provided for backwards compatibility only. It is not started by default, but will be automatically started the first time an &lt;code&gt;error_logger&lt;/code&gt; event handler is added with &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt;error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 핸들러는 이전 버전과의 호환성을 위해서만 제공됩니다. 그것은 기본적으로 시작되지 않지만 자동으로 처음으로 시작됩니다 &lt;code&gt;error_logger&lt;/code&gt; 의 이벤트 핸들러에 추가됩니다 &lt;code&gt;&lt;a href=&quot;error_logger#add_report_handler-1&quot;&gt;error_logger:add_report_handler/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87e5ec8533eb6addfe606eccdf0a8555b2e81bc0" translate="yes" xml:space="preserve">
          <source>This has the same effect as setting option &lt;code&gt;ucp&lt;/code&gt;: it causes sequences such as \d and \w to use Unicode properties to determine character types, instead of recognizing only characters with codes &amp;lt; 256 through a lookup table.</source>
          <target state="translated">이것은 옵션 &lt;code&gt;ucp&lt;/code&gt; 설정과 같은 효과를 갖습니다. 조회 테이블을 통해 코드가 256보다 작은 문자 만 인식하는 대신 \ d 및 \ w와 같은 시퀀스가 ​​유니 코드 속성을 사용하여 문자 유형을 결정하게합니다.</target>
        </trans-unit>
        <trans-unit id="0c156c0c2fc33946d9fbadad8702601855c80e09" translate="yes" xml:space="preserve">
          <source>This has the same effect as the above, &lt;strong&gt;if and only if&lt;/strong&gt; megaco has sent at least one pending message for this request (during the processing of the request). If no pending message has been sent, then immediate acknowledgement will &lt;strong&gt;not&lt;/strong&gt; be requested.</source>
          <target state="translated">megaco가 요청을 처리하는 동안이 요청에 대해 하나 이상의 보류중인 메시지를 보낸 &lt;strong&gt;경우에만&lt;/strong&gt; 위와 동일한 효과를 갖습니다. 보류중인 메시지가 전송 &lt;strong&gt;되지 않으면&lt;/strong&gt; 즉시 승인을 요청 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4ede3cfedbb971a104b9a8ef6799913490ca75be" translate="yes" xml:space="preserve">
          <source>This has the same effect as the following:</source>
          <target state="translated">이것은 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d90b246b1198d103c86bc16c013de08162e8ce" translate="yes" xml:space="preserve">
          <source>This has the value &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, &lt;code&gt;{file,LogFileName}&lt;/code&gt;, or &lt;code&gt;{file,LogFileName,LogFileOpts}&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;code&gt;standard_io&lt;/code&gt; , &lt;code&gt;standard_error&lt;/code&gt; , &lt;code&gt;{file,LogFileName}&lt;/code&gt; 또는 &lt;code&gt;{file,LogFileName,LogFileOpts}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa9ae8726a4cc0244638ba67ad2025c382e5beef" translate="yes" xml:space="preserve">
          <source>This implementation-dependent function increments the reduction counter for the calling process. In the Beam emulator, the reduction counter is normally incremented by one for each function and BIF call. A context switch is forced when the counter reaches the maximum number of reductions for a process (2000 reductions in Erlang/OTP R12B).</source>
          <target state="translated">이 구현 종속 함수는 호출 프로세스에 대한 감소 카운터를 증가시킵니다. Beam 에뮬레이터에서 감소 카운터는 일반적으로 각 기능 및 BIF 호출마다 하나씩 증가합니다. 카운터가 프로세스의 최대 감소 수 (Erlang / OTP R12B에서 2000 감소)에 도달하면 컨텍스트 스위치가 강제 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d3c24a386f367f78241d2e4bac7b7d69305c8c" translate="yes" xml:space="preserve">
          <source>This implies that for an included application, the set of start phases must be a subset of the set of phases defined for the primary application. For more information, see &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">이는 포함 된 애플리케이션의 경우 시작 단계 세트가 기본 애플리케이션에 대해 정의 된 단계 세트의 서브 세트 여야 함을 의미합니다. 자세한 내용은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="394da9d3e5810d24a5bd1b236db1807f4d4bd66f" translate="yes" xml:space="preserve">
          <source>This included file will:</source>
          <target state="translated">이 포함 된 파일은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="60cc03c618eaaba02c392d8b6d5e3541aa6478d4" translate="yes" xml:space="preserve">
          <source>This index is used to separate the implementation of the SNMP ordering from the actual implementation of the table. The SNMP ordering, that is implementation of GET NEXT, is implemented in this module.</source>
          <target state="translated">이 색인은 테이블의 실제 구현에서 SNMP 순서 구현을 분리하는 데 사용됩니다. GET NEXT의 구현 인 SNMP 순서는이 모듈에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="4da9986920c604b316098093467baaddac2eb487" translate="yes" xml:space="preserve">
          <source>This indicates that the variable &lt;code&gt;File&lt;/code&gt;, which is defined inside the fun, collides with the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside the fun.</source>
          <target state="translated">이 나타내는 변수가 &lt;code&gt;File&lt;/code&gt; 재미 내부 정의, 변수의 충돌 &lt;code&gt;File&lt;/code&gt; 재미 외부에 정의되어있다.</target>
        </trans-unit>
        <trans-unit id="cfea72aa373ef570cea99287f1170facd64d6eef" translate="yes" xml:space="preserve">
          <source>This inform the user which target addresses the notification was sent to.</source>
          <target state="translated">알림이 전송 된 대상 주소를 사용자에게 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="0d129bafd72948232df4b45a85096033eb4d3888" translate="yes" xml:space="preserve">
          <source>This information can be invalid for some implementations.</source>
          <target state="translated">이 정보는 일부 구현에 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aae2c9ba176a7a3f9d606f61a083bbbedd09c9d" translate="yes" xml:space="preserve">
          <source>This information can be produced by the functions &lt;code&gt;&lt;a href=&quot;#user_info&quot;&gt;user_info&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#conn_info&quot;&gt;conn_info&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_stats&quot;&gt;get_stats&lt;/a&gt;&lt;/code&gt; but this is a simple way to get it all at once.</source>
          <target state="translated">이 정보는 &lt;code&gt;&lt;a href=&quot;#user_info&quot;&gt;user_info&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#conn_info&quot;&gt;conn_info&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#system_info&quot;&gt;system_info&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#get_stats&quot;&gt;get_stats&lt;/a&gt;&lt;/code&gt; 함수로 생성 할 수 있지만 한 번에 모든 정보를 얻을 수있는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="710dd978424ecc04fc2bf1003714cbd1fde00ea0" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 정보는 &lt;code&gt;&lt;a href=&quot;megaco#conn_info&quot;&gt;megaco:conn_info&lt;/a&gt;&lt;/code&gt; 를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61fde3bec5255dca0919656dc9b966cbee0da75a" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;megaco:system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 정보는 &lt;code&gt;&lt;a href=&quot;megaco#system_info&quot;&gt;megaco:system_info&lt;/a&gt;&lt;/code&gt; 를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaf22384b8506971667ec0cacf5790e4084dc39b" translate="yes" xml:space="preserve">
          <source>This information can be retrieved using &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 정보는 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;megaco:user_info&lt;/a&gt;&lt;/code&gt; 를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="962a2ecfcacf4f2ae7569863ad3b0745fd8bd9b5" translate="yes" xml:space="preserve">
          <source>This information can be used to traverse the chain of function calls, using the &lt;strong&gt;Up&lt;/strong&gt; and &lt;strong&gt;Down&lt;/strong&gt; buttons in the &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 정보는 &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 에서 &lt;strong&gt;위로&lt;/strong&gt; 및 &lt;strong&gt;아래로&lt;/strong&gt; 단추를 사용하여 함수 호출 체인을 통과하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a325aae80341287a8eab869857564f9b28b86fd" translate="yes" xml:space="preserve">
          <source>This information is used by the release handler during upgrades and downgrades, see &lt;code&gt;&lt;a href=&quot;release_handling&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 정보는 업그레이드 및 다운 그레이드 중에 릴리스 핸들러가 사용합니다 ( &lt;code&gt;&lt;a href=&quot;release_handling&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="201452c6ed23592af55381e4e0078166857bb6b2" translate="yes" xml:space="preserve">
          <source>This information is useful when an external entity (for example, an IDE) provides additional code for a running node. If the code server is in interactive mode, it only has to add the path to the code. If the code server is in embedded mode, the code must be loaded with &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 정보는 외부 엔티티 (예 : IDE)가 실행중인 노드에 추가 코드를 제공 할 때 유용합니다. 코드 서버가 대화식 모드 인 경우 코드 경로 만 추가하면됩니다. 코드 서버가 임베디드 모드 인 경우 코드는 &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; 로로드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a8323563f351cf2bca8245a5765d1e7287f26f8" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address acknowledged the notification.</source>
          <target state="translated">이 대상 주소가 알림을 승인했음을 사용자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="1baf8ed33916a0e4003152e45bbc117558b69aff" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address did not acknowledge notification.</source>
          <target state="translated">이렇게하면이 대상 주소가 알림을 승인하지 않았 음을 사용자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="e9c0fbf4edafb48f201f8b1170f9bfbfe552c23a" translate="yes" xml:space="preserve">
          <source>This informs the user that this target address did not acknowledge the notification.</source>
          <target state="translated">이 대상 주소가 알림을 승인하지 않았다는 것을 사용자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="083ac1279739f945b13a461e8bb4339d8dfde4a8" translate="yes" xml:space="preserve">
          <source>This informs the user which target addresses the notification was sent to.</source>
          <target state="translated">알림이 전송 된 대상 주소를 사용자에게 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="d7e452d2d7924302fbdea18276d798ae79408dc5" translate="yes" xml:space="preserve">
          <source>This instruction is not related to upgrades of ERTS or any of the core applications. It can be used by any application to force a restart of the emulator after all upgrade instructions are executed.</source>
          <target state="translated">이 지침은 ERTS 또는 핵심 응용 프로그램의 업그레이드와 관련이 없습니다. 모든 업그레이드 명령이 실행 된 후 모든 응용 프로그램에서 에뮬레이터를 강제로 다시 시작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27e8eb36b131c032f8c3fba207f37d792a31d2a" translate="yes" xml:space="preserve">
          <source>This instruction is similar to &lt;code&gt;restart_new_emulator&lt;/code&gt;, except it must be placed at the end of the &lt;code&gt;relup&lt;/code&gt; file. It is not related to an upgrade of the emulator or the core applications, but can be used by any application when a complete reboot of the system is required.</source>
          <target state="translated">이 명령어는 &lt;code&gt;relup&lt;/code&gt; 파일 의 끝에 배치되어야한다는 점을 제외하고 &lt;code&gt;restart_new_emulator&lt;/code&gt; 와 유사 합니다. 에뮬레이터 또는 핵심 응용 프로그램의 업그레이드와 관련이 없지만 시스템을 완전히 재부팅해야하는 경우 모든 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e2ff5aadab857bef7cc042cfddbfd7f94365d61" translate="yes" xml:space="preserve">
          <source>This instruction is used when changing to a new emulator version, or when any of the core applications Kernel, STDLIB, or SASL is upgraded. If a system reboot is needed for another reason, the &lt;code&gt;restart_emulator&lt;/code&gt; instruction is to be used instead.</source>
          <target state="translated">이 명령어는 새 에뮬레이터 버전으로 변경하거나 핵심 애플리케이션 Kernel, STDLIB 또는 SASL이 업그레이드 될 때 사용됩니다. 다른 이유로 시스템을 다시 부팅해야하는 경우 &lt;code&gt;restart_emulator&lt;/code&gt; 명령이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="538ffcc030d6ff15bd0bfff773ddaca2d61087a9" translate="yes" xml:space="preserve">
          <source>This instruction is used when the application ERTS, Kernel, STDLIB, or SASL is upgraded. It shuts down the current emulator and starts a new one. All processes are terminated gracefully, and the new version of ERTS, Kernel, STDLIB, and SASL are used when the emulator restarts. Only one &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is allowed in the &lt;code&gt;relup&lt;/code&gt; file, and it must be placed first. &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures this when the &lt;code&gt;relup&lt;/code&gt; file is generated. The rest of the instructions in the &lt;code&gt;relup&lt;/code&gt; file is executed after the restart as a part of the boot script.</source>
          <target state="translated">이 명령은 응용 프로그램 ERTS, 커널, STDLIB 또는 SASL이 업그레이드 될 때 사용됩니다. 현재 에뮬레이터를 종료하고 새로운 에뮬레이터를 시작합니다. 모든 프로세스가 정상적으로 종료되고 에뮬레이터가 다시 시작될 때 새 버전의 ERTS, Kernel, STDLIB 및 SASL이 사용됩니다. &lt;code&gt;relup&lt;/code&gt; 파일에는 하나의 &lt;code&gt;restart_new_emulator&lt;/code&gt; 명령 만 허용되며 먼저 배치해야합니다. &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;relup&lt;/code&gt; 파일이 생성 될 때이를 보장합니다 . &lt;code&gt;relup&lt;/code&gt; 파일 의 나머지 명령 은 부팅 스크립트의 일부로 다시 시작한 후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="395215bf28142de440c81ef55b87f4169a80aec6" translate="yes" xml:space="preserve">
          <source>This instruction is written in the configuration file in the following format:</source>
          <target state="translated">이 명령어는 구성 파일에 다음 형식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="45862ec3de83aecdeb3f0430fc20ad3e86777590" translate="yes" xml:space="preserve">
          <source>This instruction requires that the system is started with heartbeat monitoring, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS and the &lt;code&gt;heart(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">이 지침에서는 시스템이 하트 비트 모니터링으로 시작되어야 합니다. ERTS 의 &lt;code&gt;erl(1)&lt;/code&gt; 매뉴얼 페이지 및 커널 의 &lt;code&gt;heart(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb9abbefd34b9022f0d676607ac6737850a70742" translate="yes" xml:space="preserve">
          <source>This instruction synchronizes the release installation with other nodes. Each &lt;code&gt;Node&lt;/code&gt; must evaluate this command with the same &lt;code&gt;Id&lt;/code&gt;. The local node waits for all other nodes to evaluate the instruction before execution continues. If a node goes down, it is considered to be an unrecoverable error, and the local node is restarted from the old release. There is no time-out for this instruction, which means that it can hang forever.</source>
          <target state="translated">이 명령은 릴리스 설치를 다른 노드와 동기화합니다. 각 &lt;code&gt;Node&lt;/code&gt; 는 동일한 &lt;code&gt;Id&lt;/code&gt; 로이 명령을 평가해야합니다 . 로컬 노드는 실행이 계속되기 전에 다른 모든 노드가 명령을 평가할 때까지 기다립니다. 노드가 다운되면 복구 할 수없는 오류로 간주되며 로컬 릴리스는 이전 릴리스에서 다시 시작됩니다. 이 명령에는 시간 초과가 없으므로 영원히 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72381508b412cca34ddf14083712fc31b9f93e31" translate="yes" xml:space="preserve">
          <source>This interface (or at least the name of the functions) is kept for backward compatibility. Using &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{driver_options,[kill_ports]}&lt;/code&gt; in the option list gives the same effect regarding the port killing.</source>
          <target state="translated">이 인터페이스 (또는 최소한 함수 이름)는 이전 버전과의 호환성을 위해 유지됩니다. 옵션 목록에서 &lt;code&gt;{driver_options,[kill_ports]}&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 를 사용하면 포트 강제 종료 와 동일한 효과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="986a779296a267e9889a055a42330bfd68321abf" translate="yes" xml:space="preserve">
          <source>This internal event is used by the &lt;code&gt;Common Test&lt;/code&gt; Master process to synchronize particular file operations.</source>
          <target state="translated">이 내부 이벤트는 &lt;code&gt;Common Test&lt;/code&gt; 마스터 프로세스에서 특정 파일 조작을 동기화 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c34c80ee3e756933a25868fd55ba9046da3c1c47" translate="yes" xml:space="preserve">
          <source>This internal event says that &lt;code&gt;Common Test&lt;/code&gt; is finished compiling modules in directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">이 내부 이벤트는 &lt;code&gt;Common Test&lt;/code&gt; 가 디렉토리 &lt;code&gt;Dir&lt;/code&gt; 에서 모듈 컴파일을 완료 했다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="19fd863c53f0cce4ca256baeac321a61b8c0e924" translate="yes" xml:space="preserve">
          <source>This internal event says that &lt;code&gt;Common Test&lt;/code&gt; starts compiling modules in directory &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">이 내부 이벤트는 &lt;code&gt;Common Test&lt;/code&gt; 가 디렉토리 &lt;code&gt;Dir&lt;/code&gt; 에서 모듈 컴파일을 시작 한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="918379111cbe178fe4429e0dda42e1bb45186e43" translate="yes" xml:space="preserve">
          <source>This internal name cannot be changed, it is fixed even if the service is renamed. &lt;code&gt;erlsrv&lt;/code&gt; generates a unique internal name when a service is created. It is recommended to keep to the default if release handling is to be used for the application.</source>
          <target state="translated">이 내부 이름은 변경할 수 없으며 서비스 이름이 바뀌어도 수정됩니다. &lt;code&gt;erlsrv&lt;/code&gt; 는 서비스가 작성 될 때 고유 한 내부 이름을 생성합니다. 응용 프로그램에 릴리스 처리를 사용하려면 기본값을 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1c853aa37495f77100d3057f3fa259e2e5e59b2e" translate="yes" xml:space="preserve">
          <source>This is 86 % of the total run time, and as we saw before it is the close operation the absolutely biggest contributor. We find a comparison ratio a little bit up in the call stack:</source>
          <target state="translated">이는 전체 실행 시간의 86 %이며, 이전에 본 바와 같이 가장 큰 기여를 한 사람은 근접 작업입니다. 호출 스택에서 비교 비율이 약간 높아졌습니다.</target>
        </trans-unit>
        <trans-unit id="4e69295f5174adc14ac6944e7fdc5af01c54eae9" translate="yes" xml:space="preserve">
          <source>This is a 4-component structure called &lt;code&gt;Pdu&lt;/code&gt;. By default, a &lt;code&gt;SEQUENCE&lt;/code&gt; is represented by a record in Erlang. It can also be represented as a map; see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt; Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt;. For each &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; in an ASN.1 module an Erlang record declaration is generated. For &lt;code&gt;Pdu&lt;/code&gt;, a record like the following is defined:</source>
          <target state="translated">이것은 &lt;code&gt;Pdu&lt;/code&gt; 라는 4 개의 구성 요소 구조 입니다. 기본적으로 &lt;code&gt;SEQUENCE&lt;/code&gt; 는 Erlang의 레코드로 표시됩니다. 지도로 표시 할 수도 있습니다. &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt; Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; 참조하십시오 . ASN.1 모듈의 각 &lt;code&gt;SEQUENCE&lt;/code&gt; 및 &lt;code&gt;SET&lt;/code&gt; 에 대해 Erlang 레코드 선언이 생성됩니다. 들어 &lt;code&gt;Pdu&lt;/code&gt; , 다음과 같은 기록이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="e9ef9e4644f03eaf56584c4a5bfb4c37698548ad" translate="yes" xml:space="preserve">
          <source>This is a 4-component structure called &lt;code&gt;Pdu&lt;/code&gt;. By default, a &lt;code&gt;SEQUENCE&lt;/code&gt; is represented by a record in Erlang. It can also be represented as a map; see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt;. For each &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; in an ASN.1 module an Erlang record declaration is generated. For &lt;code&gt;Pdu&lt;/code&gt;, a record like the following is defined:</source>
          <target state="translated">이것은 &lt;code&gt;Pdu&lt;/code&gt; 라는 4 구성 요소 구조 입니다. 기본적으로 &lt;code&gt;SEQUENCE&lt;/code&gt; 는 Erlang의 레코드로 표시됩니다. 또한지도로 표현 될 수도 있습니다. &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; 참조하십시오 . ASN.1 모듈의 각 &lt;code&gt;SEQUENCE&lt;/code&gt; 및 &lt;code&gt;SET&lt;/code&gt; 에 대해 Erlang 레코드 선언이 생성됩니다. 들어 &lt;code&gt;Pdu&lt;/code&gt; , 다음과 같은 기록이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="0b39193a0d84108c992a285788d5dba07f9d62b4" translate="yes" xml:space="preserve">
          <source>This is a 58 bit version of Xoroshiro1024**, from the 2018 paper by David Blackman and Sebastiano Vigna: &lt;code&gt;&lt;a href=&quot;http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf&quot;&gt; Scrambled Linear Pseudorandom Number Generators &lt;/a&gt;&lt;/code&gt; that on a 64 bit Erlang system executes only about 40% slower than the default &lt;code&gt;exsss&lt;/code&gt; algorithm but with much longer period and better statistical properties, and on the flip side a larger state.</source>
          <target state="translated">이것은 David Blackman과 Sebastiano Vigna의 2018 년 논문에서 가져온 Xoroshiro1024 **의 58 비트 버전입니다 . 64 비트 Erlang 시스템에서 기본 &lt;code&gt;exsss&lt;/code&gt; 알고리즘 보다 약 40 % 더 느리지 만 훨씬 더 긴 기간을 실행하는 &lt;code&gt;&lt;a href=&quot;http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf&quot;&gt; Scrambled Linear Pseudorandom Number Generators &lt;/a&gt;&lt;/code&gt; 난수 생성기 입니다. 더 나은 통계적 속성과 더 큰 상태를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d9073fcd29e4e73c44d40722439de79f01a5b836" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt; monotonically increasing&lt;/a&gt;&lt;/code&gt; time, but &lt;strong&gt;not&lt;/strong&gt; a &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt; strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; time. That is, consecutive calls to &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; can produce the same result.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt; monotonically increasing&lt;/a&gt;&lt;/code&gt; 시간이지만 &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt; strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; 시간 은 &lt;strong&gt;아닙니다&lt;/strong&gt; . 즉, &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; 에 대한 연속 호출 은 동일한 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fccf5d389b6bb13934731f8a21547b98c0616cd1" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt;monotonically increasing&lt;/a&gt;&lt;/code&gt; time, but &lt;strong&gt;not&lt;/strong&gt; a &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; time. That is, consecutive calls to &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; can produce the same result.</source>
          <target state="translated">이것은이다 &lt;code&gt;&lt;a href=&quot;time_correction#Monotonically_Increasing&quot;&gt;monotonically increasing&lt;/a&gt;&lt;/code&gt; 하지만, 시간이 &lt;strong&gt;없는 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;time_correction#Strictly_Monotonically_Increasing&quot;&gt;strictly monotonically increasing&lt;/a&gt;&lt;/code&gt; 시간입니다. 즉, &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; 에 대한 연속 호출 은 동일한 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e773a13c08b29bd1b0b27e610e6a3ca5907aef0" translate="yes" xml:space="preserve">
          <source>This is a callback function intended to be invoked by some transport modules when get an incoming message. Which transport that actually is used is up to the user to choose.</source>
          <target state="translated">이것은 들어오는 메시지를받을 때 일부 전송 모듈에서 호출하기위한 콜백 함수입니다. 실제로 사용되는 전송은 사용자가 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="6aaabdad85afb5297ef14e644ed60c642bdf1f64" translate="yes" xml:space="preserve">
          <source>This is a change from signed to unsigned. This can cause problems for, for example, loop termination conditions and error conditions if you only change the types all over the place.</source>
          <target state="translated">이것은 부호있는 것에서 부호없는 것으로 바뀐 것입니다. 예를 들어, 장소 전체에서 유형 만 변경하면 루프 종료 조건 및 오류 조건에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3196a6c5d44daf25b6d6681360eca21c5be5b270" translate="yes" xml:space="preserve">
          <source>This is a common error in test suites. It is assumed that the current directory is the same as the author used as current directory when the test case was developed. Many test cases even try to write scratch files to this directory. Instead &lt;code&gt;data_dir&lt;/code&gt; and &lt;code&gt;priv_dir&lt;/code&gt; are to be used to locate data and for writing scratch files.</source>
          <target state="translated">테스트 스위트에서 일반적인 오류입니다. 현재 디렉토리는 테스트 케이스가 개발 될 때 현재 디렉토리로 사용 된 작성자와 동일하다고 가정합니다. 많은 테스트 사례가이 디렉토리에 스크래치 파일을 쓰려고 시도하기까지합니다. 대신 &lt;code&gt;data_dir&lt;/code&gt; 및 &lt;code&gt;priv_dir&lt;/code&gt; 을 사용하여 데이터를 찾고 스크래치 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="360f48fae93411aaa84a534df910e9385d6dd358" translate="yes" xml:space="preserve">
          <source>This is a corrected version of the previous default algorithm, that now has been superseded by Xoroshiro116+ (&lt;code&gt;exrop&lt;/code&gt;). Since there is no native 58 bit rotate instruction this algorithm executes a little (say &amp;lt; 15%) faster than &lt;code&gt;exrop&lt;/code&gt;. See the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt;algorithms' homepage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 이전 기본 알고리즘의 수정 된 버전으로, 현재 Xoroshiro116 + ( &lt;code&gt;exrop&lt;/code&gt; ) 로 대체되었습니다 . 기본 58 비트 회전 명령이 &lt;code&gt;exrop&lt;/code&gt; 알고리즘은 exrop 보다 약간 (예 : &amp;lt;15 %) 빠르게 실행 됩니다. &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt;algorithms' homepage&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab7aa23baa63f4887daf2bf3feb0b72e5a926fef" translate="yes" xml:space="preserve">
          <source>This is a dangerous feature that must be used with care. By unintentional mixing of directories, you can easily end up with an inconsistent database, if the same backup is installed on more than one directory.</source>
          <target state="translated">이것은주의해서 사용해야하는 위험한 기능입니다. 의도하지 않게 디렉토리를 혼합하면 동일한 백업이 둘 이상의 디렉토리에 설치된 경우 일관성이없는 데이터베이스로 쉽게 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05cf3f16d8e8cf9241491563959ff3c97154893" translate="yes" xml:space="preserve">
          <source>This is a definition of an external generic BEAM instruction. Most importantly it specifices that the opcode is 64. It also defines that it has two operands. The BEAM assembler will use the opcode when creating &lt;code&gt;.beam&lt;/code&gt; files. The compiler does not really need the arity, but it will use it as an internal sanity check when assembling the BEAM code.</source>
          <target state="translated">이것은 외부 일반 BEAM 명령어의 정의입니다. 가장 중요한 것은 opcode가 64임을 특정합니다. 또한 두 개의 피연산자가 있음을 정의합니다. BEAM 어셈블러는 &lt;code&gt;.beam&lt;/code&gt; 파일을 생성 할 때 opcode를 사용 합니다. 컴파일러는 실제로 arity가 필요하지 않지만 BEAM 코드를 어셈블 할 때 내부 온 전성 검사로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="00205e610ec0a95f3eebcf63dbbba8372b336cc5" translate="yes" xml:space="preserve">
          <source>This is a handler for Logger that offers circular (wrapped) logs by using &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt;. Multiple instances of this handler can be added to Logger, and each instance prints to its own disk log file, created with the name and settings specified in the handler configuration.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 를 사용하여 순환 (랩핑 된) 로그를 제공하는 로거의 핸들러입니다 . 이 핸들러의 여러 인스턴스를 Logger에 추가 할 수 있으며 각 인스턴스는 핸들러 구성에 지정된 이름과 설정으로 작성된 고유 한 디스크 로그 파일로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f1702c7d8fabc70bf82459bbec9093c02074634c" translate="yes" xml:space="preserve">
          <source>This is a large reference document. For casual use of this module, and for most real world applications, the descriptions of functions &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#unload-1&quot;&gt;unload/1&lt;/a&gt;&lt;/code&gt; are enough to getting started.</source>
          <target state="translated">이것은 큰 참조 문서입니다. 이 모듈의 일반적인 사용과 대부분의 실제 응용 프로그램의 경우 &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#unload-1&quot;&gt;unload/1&lt;/a&gt;&lt;/code&gt; 함수에 대한 설명 만으로도 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9ae3bc7ed27ccefa917b875115824ef1a0ed8195" translate="yes" xml:space="preserve">
          <source>This is a legacy clause mostly for &lt;code&gt;Destination = {local, Binary}&lt;/code&gt; where &lt;code&gt;PortZero&lt;/code&gt; is superfluous. It is equivalent to &lt;code&gt;&lt;a href=&quot;#send-4-AncData&quot;&gt;send(Socket, Destination, [], Packet)&lt;/a&gt;&lt;/code&gt;, the clause right above here.</source>
          <target state="translated">이것은 대부분의 기존 조항이다 &lt;code&gt;Destination = {local, Binary}&lt;/code&gt; &lt;code&gt;PortZero&lt;/code&gt; 가 불필요하다. 와 등가이다 &lt;code&gt;&lt;a href=&quot;#send-4-AncData&quot;&gt;send(Socket, Destination, [], Packet)&lt;/a&gt;&lt;/code&gt; , 오른쪽 위의 여기 절.</target>
        </trans-unit>
        <trans-unit id="92aeefe62fe3eb6482bb9d89ca3cfa9570836ae6" translate="yes" xml:space="preserve">
          <source>This is a more developed variant of the older &lt;code&gt;&lt;a href=&quot;#type-run_time_error&quot;&gt;run_time_error()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 이전 &lt;code&gt;&lt;a href=&quot;#type-run_time_error&quot;&gt;run_time_error()&lt;/a&gt;&lt;/code&gt; 의 더 개발 된 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="bfe64ae08d8239e916a24e614514fb557dd71251" translate="yes" xml:space="preserve">
          <source>This is a normal Erlang/OTP application descriptor, as found in an &lt;code&gt;.app&lt;/code&gt; file. The resulting test set consists of the modules listed in the &lt;code&gt;modules&lt;/code&gt; entry in &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 파일에 있는 일반적인 Erlang / OTP 응용 프로그램 설명자 입니다. 결과 테스트 세트는 &lt;code&gt;Info&lt;/code&gt; 의 &lt;code&gt;modules&lt;/code&gt; 항목에 나열된 모듈로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc0886c68b7d31b43eac50f2f501f0e29c21db91" translate="yes" xml:space="preserve">
          <source>This is a normal, healthy, return value if the call was just placed to inform the emulator that you have no further use of the driver. It is the most common return value in the most common &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; described in the introduction.</source>
          <target state="translated">에뮬레이터에 드라이버를 더 이상 사용하지 않는다고 알리기 위해 호출 한 경우 정상적이고 정상적인 반환 값입니다. 소개에 설명 된 가장 일반적인 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;scenario&lt;/a&gt;&lt;/code&gt; 에서 가장 일반적인 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a74b91a12c8bd155dd6272fb26f51914a5b6669f" translate="yes" xml:space="preserve">
          <source>This is a re-entrant call to try and scan one token from &lt;code&gt;Chars&lt;/code&gt;. If there are enough characters in &lt;code&gt;Chars&lt;/code&gt; to either scan a token or detect an error then this will be returned with &lt;code&gt;{done,...}&lt;/code&gt;. Otherwise &lt;code&gt;{cont,Cont}&lt;/code&gt; will be returned where &lt;code&gt;Cont&lt;/code&gt; is used in the next call to &lt;code&gt;token()&lt;/code&gt; with more characters to try an scan the token. This is continued until a token has been scanned. &lt;code&gt;Cont&lt;/code&gt; is initially &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Chars&lt;/code&gt; 에서 하나의 토큰을 시도하고 스캔하기위한 재진입 호출 입니다. &lt;code&gt;Chars&lt;/code&gt; 에 토큰을 스캔하거나 오류를 감지하기에 충분한 문자가 있으면 &lt;code&gt;{done,...}&lt;/code&gt; 과 함께 리턴됩니다 . 그렇지 않으면 &lt;code&gt;{cont,Cont}&lt;/code&gt; 경우 반환됩니다 &lt;code&gt;Cont&lt;/code&gt; 에 대한 다음 호출에 사용되는 &lt;code&gt;token()&lt;/code&gt; 토큰 스캔 하를 시도하는 더 많은 문자. 토큰이 스캔 될 때까지 계속됩니다. &lt;code&gt;Cont&lt;/code&gt; 는 처음에는 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dd5f47604323fa85263c477df2f49651a6e3df8c" translate="yes" xml:space="preserve">
          <source>This is a re-entrant call to try and scan tokens from &lt;code&gt;Chars&lt;/code&gt;. If there are enough characters in &lt;code&gt;Chars&lt;/code&gt; to either scan tokens or detect an error then this will be returned with &lt;code&gt;{done,...}&lt;/code&gt;. Otherwise &lt;code&gt;{cont,Cont}&lt;/code&gt; will be returned where &lt;code&gt;Cont&lt;/code&gt; is used in the next call to &lt;code&gt;tokens()&lt;/code&gt; with more characters to try an scan the tokens. This is continued until all tokens have been scanned. &lt;code&gt;Cont&lt;/code&gt; is initially &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;Chars&lt;/code&gt; 의 토큰을 시도하고 스캔하기위한 재진입 호출 입니다. &lt;code&gt;Chars&lt;/code&gt; 에 토큰을 스캔하거나 오류를 감지하기에 충분한 문자가 있으면 &lt;code&gt;{done,...}&lt;/code&gt; 과 함께 반환됩니다 . 그렇지 않으면 &lt;code&gt;{cont,Cont}&lt;/code&gt; 경우 반환됩니다 &lt;code&gt;Cont&lt;/code&gt; 에 대한 다음 호출에 사용되는 &lt;code&gt;tokens()&lt;/code&gt; 이상의 문자와 토큰 스캔을 시도합니다. 이것은 모든 토큰이 스캔 될 때까지 계속됩니다. &lt;code&gt;Cont&lt;/code&gt; 는 처음에는 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed7d83881b92d8f8849b160af3bcd9a10b096707" translate="yes" xml:space="preserve">
          <source>This is a short form for both &lt;code&gt;report_errors&lt;/code&gt; and &lt;code&gt;report_warnings&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;report_errors&lt;/code&gt; 및 &lt;code&gt;report_warnings&lt;/code&gt; 에 대한 짧은 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="274dc8f24a407d0b1cda6dac95a4fedcd1f99a11" translate="yes" xml:space="preserve">
          <source>This is a short form for both &lt;code&gt;return_errors&lt;/code&gt; and &lt;code&gt;return_warnings&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;return_errors&lt;/code&gt; 및 &lt;code&gt;return_warnings&lt;/code&gt; 에 대한 짧은 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="161cf6b2273cd2e876452ed9511de7c5f7ad17eb" translate="yes" xml:space="preserve">
          <source>This is a shorter and clearer form of &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt; timeout_action() &lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Time = infinity&lt;/code&gt; which cancels a time-out.</source>
          <target state="translated">이것은 &lt;code&gt;Time = infinity&lt;/code&gt; 아웃을 취소하는 Time = infinity 를 사용 하는 더 짧고 명확한 형태의 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt; timeout_action() &lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b415593166c4a9ddd5fa9eb4f27a156aba749468" translate="yes" xml:space="preserve">
          <source>This is a simple example of starting the TFTP server and reading the content of a sample file using the TFTP client.</source>
          <target state="translated">TFTP 서버를 시작하고 TFTP 클라이언트를 사용하여 샘플 파일의 내용을 읽는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="3281f2cefa8864b51e113449543fc81b263cbe51" translate="yes" xml:space="preserve">
          <source>This is a simplified sequence describing what &lt;code&gt;trace_pattern&lt;/code&gt; goes through when adding a new breakpoint.</source>
          <target state="translated">이것은 새로운 중단 점을 추가 할 때 &lt;code&gt;trace_pattern&lt;/code&gt; 이 거치는 과정을 설명하는 간단한 시퀀스 입니다.</target>
        </trans-unit>
        <trans-unit id="808da979a84710e3348d8f0999feea04935b391f" translate="yes" xml:space="preserve">
          <source>This is a slight modification of the ping pong program where both processes are spawned from the same &lt;code&gt;start/1&lt;/code&gt; function, and the &quot;ping&quot; process can be spawned on a separate node. Notice the use of the &lt;code&gt;link&lt;/code&gt; BIF. &quot;Ping&quot; calls &lt;code&gt;exit(ping)&lt;/code&gt; when it finishes and this causes an exit signal to be sent to &quot;pong&quot;, which also terminates.</source>
          <target state="translated">이것은 두 프로세스가 동일한 &lt;code&gt;start/1&lt;/code&gt; 함수에서 생성되고 &quot;ping&quot;프로세스가 별도의 노드에 생성 될 수있는 핑퐁 프로그램의 약간 수정입니다 . &lt;code&gt;link&lt;/code&gt; BIF 사용을 확인하십시오 . &quot;Ping&quot;은 끝나면 &lt;code&gt;exit(ping)&lt;/code&gt; 호출 하고 종료 신호가 &quot;pong&quot;으로 전송되고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="73a9a1cddaa9852a0011d5e8ce12699ed0d05497" translate="yes" xml:space="preserve">
          <source>This is a so-called Erlang I/O ErrorInfo structure; see the &lt;code&gt;io(3)&lt;/code&gt; module for details.</source>
          <target state="translated">이것은 소위 Erlang I / O ErrorInfo 구조입니다. 자세한 내용은 &lt;code&gt;io(3)&lt;/code&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e343f368517e25b67cf5e58932e33d7c4ed349a4" translate="yes" xml:space="preserve">
          <source>This is a standard macro (that is, defined by the system, not by the user). &lt;code&gt;?MODULE&lt;/code&gt; is always replaced by the name of the current module (that is, the &lt;code&gt;-module&lt;/code&gt; definition near the start of the file). There are more advanced ways of using macros with, for example, parameters (*manual*).</source>
          <target state="translated">이것은 표준 매크로입니다 (즉, 사용자가 아니라 시스템에 의해 정의 됨). &lt;code&gt;?MODULE&lt;/code&gt; 은 항상 현재 모듈의 이름 (즉 , 파일 시작 부근의 &lt;code&gt;-module&lt;/code&gt; 정의)으로 바뀝니다 . 예를 들어 매개 변수 (* manual *)와 같이 매크로를 사용하는 고급 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b7150a1e2635ac10627a958161be921d3a386e" translate="yes" xml:space="preserve">
          <source>This is a statistics event with current count of successful, skipped, and failed test cases so far. This event is sent after the end of each test case, immediately following event &lt;code&gt;tc_done&lt;/code&gt;.</source>
          <target state="translated">현재까지 성공, 건너 뛰기 및 실패한 테스트 케이스 수를 가진 통계 이벤트입니다. 이 이벤트는 각 테스트 사례가 끝난 후 이벤트 &lt;code&gt;tc_done&lt;/code&gt; 바로 뒤에 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="d357df916eaf2872bc4e68740c1b378e80709c63" translate="yes" xml:space="preserve">
          <source>This is a stronger method where the ssh protocol brings the user name, the user's public key and some cryptographic information which we could ignore here.</source>
          <target state="translated">이것은 ssh 프로토콜이 사용자 이름, 사용자의 공개 키 및 여기서 무시할 수있는 일부 암호화 정보를 가져 오는 더 강력한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="398909e587f906e89bc126a8eb8fdfd6b8204296" translate="yes" xml:space="preserve">
          <source>This is a useful debugging and test tool, especially when writing complicated &lt;code&gt;select/2&lt;/code&gt; calls.</source>
          <target state="translated">이 기능은 특히 복잡한 &lt;code&gt;select/2&lt;/code&gt; 호출을 작성할 때 유용한 디버깅 및 테스트 도구 입니다.</target>
        </trans-unit>
        <trans-unit id="ef77778e97bbcd3de76e5cb922449c0969559f39" translate="yes" xml:space="preserve">
          <source>This is a useful debugging and test tool, especially when writing complicated match specifications.</source>
          <target state="translated">이 기능은 특히 복잡한 일치 사양을 작성할 때 유용한 디버깅 및 테스트 도구입니다.</target>
        </trans-unit>
        <trans-unit id="cc0b0332cdc379fcfaab7b7f81af77dfd65580d0" translate="yes" xml:space="preserve">
          <source>This is a useful way to test a generated boot script locally.</source>
          <target state="translated">생성 된 부팅 스크립트를 로컬에서 테스트하는 유용한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="978194809925fd52d8e900a08a5d143726fc77cb" translate="yes" xml:space="preserve">
          <source>This is a utility function meant to be used in the shell for printing the allowed characters in each major URI component, and also in the most important characters sets. Please note that this function does not replace the ABNF rules defined by the standards, these character sets are derived directly from those aformentioned rules. For more information see the &lt;code&gt;&lt;a href=&quot;uri_string_usage#percent_encoding&quot;&gt;Uniform Resource Identifiers&lt;/a&gt;&lt;/code&gt; chapter in stdlib's Users Guide.</source>
          <target state="translated">이것은 각 주요 URI 구성 요소 및 가장 중요한 문자 세트에서 허용되는 문자를 인쇄하기 위해 쉘에서 사용되는 유틸리티 함수입니다. 이 기능은 표준에 정의 된 ABNF 규칙을 대체하지 않으며, 이러한 문자 집합은 앞에서 언급 한 규칙에서 직접 파생됩니다. 자세한 내용은 stdlib의 사용자 가이드에서 &lt;code&gt;&lt;a href=&quot;uri_string_usage#percent_encoding&quot;&gt;Uniform Resource Identifiers&lt;/a&gt;&lt;/code&gt; 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1d072ab39ba63d2cf9e54937425fb41a6e24e0" translate="yes" xml:space="preserve">
          <source>This is a utility function used to inspect, for instance, memory usage, in a simple way.</source>
          <target state="translated">이것은 간단한 방법으로 메모리 사용량 등을 검사하는 데 사용되는 유틸리티 기능입니다.</target>
        </trans-unit>
        <trans-unit id="1e82946d829123c6910c06194e9e7cebf010cb22" translate="yes" xml:space="preserve">
          <source>This is a utility function, that can be useful when e.g. debugging instrumentation functions.</source>
          <target state="translated">이것은 계측 기능을 디버깅 할 때 유용 할 수있는 유틸리티 기능입니다.</target>
        </trans-unit>
        <trans-unit id="638f44b006e9ddc55b07c2ecf8dd004cd4e662bc" translate="yes" xml:space="preserve">
          <source>This is a utility function; see &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; for further details.</source>
          <target state="translated">이것은 유틸리티 기능입니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9a4ecf4af35ccbc508f0f2a3b4017f2147f96a8d" translate="yes" xml:space="preserve">
          <source>This is accomplished as follows:</source>
          <target state="translated">이는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c701533d2b77a06763413555d9faee562dbae932" translate="yes" xml:space="preserve">
          <source>This is accomplished by dispatching the work to another thread managed by the NIF library, return from the NIF, and wait for the result. The thread can send the result back to the Erlang process using &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt; enif_send&lt;/a&gt;&lt;/code&gt;. Information about thread primitives is provided below.</source>
          <target state="translated">이것은 작업을 NIF 라이브러리가 관리하는 다른 스레드로 디스패치하고 NIF에서 반환 한 다음 결과를 기다림으로써 수행됩니다. 스레드는 &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt; enif_send&lt;/a&gt;&lt;/code&gt; 를 사용하여 결과를 Erlang 프로세스로 다시 보낼 수 있습니다 . 스레드 프리미티브에 대한 정보는 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1661232769f6d1b51ba5b2ab390488adc40b1764" translate="yes" xml:space="preserve">
          <source>This is accomplished by dispatching the work to another thread managed by the NIF library, return from the NIF, and wait for the result. The thread can send the result back to the Erlang process using &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt;. Information about thread primitives is provided below.</source>
          <target state="translated">이는 작업을 NIF 라이브러리가 관리하는 다른 스레드로 디스패치하고 NIF에서 리턴 한 후 결과를 기다림으로써 수행됩니다. 스레드는 &lt;code&gt;&lt;a href=&quot;#enif_send&quot;&gt;enif_send&lt;/a&gt;&lt;/code&gt; 를 사용하여 결과를 Erlang 프로세스로 다시 보낼 수 있습니다 . 스레드 기본 요소에 대한 정보는 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a3a5884eaf41dfb2c20bb095d899f4bb1aee0421" translate="yes" xml:space="preserve">
          <source>This is all that has to be done! Now the manager can read, add, and modify rows. Also, you can use the ordinary Mnesia API to access the table from your programs. The only explicit action is to create the Mnesia table, an action the user has to perform in order to create the required table schemas.</source>
          <target state="translated">이 모든 것이 완료되어야합니다! 이제 관리자는 행을 읽고 추가하고 수정할 수 있습니다. 또한 일반 Mnesia API를 사용하여 프로그램에서 테이블에 액세스 할 수 있습니다. 명시 적 조치는 필요한 테이블 스키마를 작성하기 위해 사용자가 수행해야하는 조치 인 Mnesia 테이블을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b23a1bbf224deed4021f7affe8851472e761554" translate="yes" xml:space="preserve">
          <source>This is allowed in ASN.1 and the ASN.1-to-Erlang compiler supports this recursive type. A value for this type is assigned in Erlang as follows:</source>
          <target state="translated">이것은 ASN.1에서 허용되며 ASN.1-to-Erlang 컴파일러는이 재귀 유형을 지원합니다. 이 유형의 값은 다음과 같이 Erlang에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b9c60488fe7be932bfbb686280514f6095ca5c3b" translate="yes" xml:space="preserve">
          <source>This is also handled automatically by the megaco application. First of all, segmentation is only attempted if so configured, see the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_send&lt;/a&gt;&lt;/code&gt; option. Secondly, megaco relies on the ability of the used codec to encode action replies, which is the smallest component the megaco application handles when segmenting. Thirdly, the reply will be segmented only if the sum of the size of the action replies (plus an arbitrary message header size) are greater then the specified max message size (see the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;max_pdu_size&lt;/a&gt;&lt;/code&gt; option). Finally, if segmentation is decided, then each action reply will make up its own (segment) message.</source>
          <target state="translated">또한 megaco 응용 프로그램에서 자동으로 처리합니다. 우선, 세그먼테이션은 구성된 경우에만 시도됩니다 . &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_send&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 . 둘째, megaco는 사용 된 코덱이 동작 응답을 인코딩하는 기능에 의존합니다. 이는 동작을 메가 코 애플리케이션이 세그먼트화할 때 처리하는 가장 작은 구성 요소입니다. 셋째, 조치 응답 크기 (임의의 메시지 헤더 크기)의 합계가 지정된 최대 메시지 크기보다 큰 경우에만 응답이 분할됩니다 ( &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;max_pdu_size&lt;/a&gt;&lt;/code&gt; 옵션 참조 ). 마지막으로 세그먼테이션이 결정되면 각 조치 응답이 자체 (세그먼트) 메시지를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c22b40b578529e2c84690ed6b337febcebea2978" translate="yes" xml:space="preserve">
          <source>This is also the case for functions &lt;code&gt;red/2&lt;/code&gt;, &lt;code&gt;blue/2&lt;/code&gt;, and &lt;code&gt;green/2&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;red/2&lt;/code&gt; , &lt;code&gt;blue/2&lt;/code&gt; 및 &lt;code&gt;green/2&lt;/code&gt; 도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="66cae3829517c0c1511c6c613a5e64f898384f8a" translate="yes" xml:space="preserve">
          <source>This is an abstract representation of syntax tree node attributes; see the function &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 구문 트리 노드 속성의 추상 표현입니다. &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f87e2d574185c8fa053abdd8e9a5dea9632b99eb" translate="yes" xml:space="preserve">
          <source>This is an enhanced subset of the operations provided by the &lt;code&gt;&lt;a href=&quot;rpc&quot;&gt;rpc&lt;/a&gt;&lt;/code&gt; module. Enhanced in the sense that it makes it possible to distinguish between returned value, raised exceptions, and other errors. &lt;code&gt;erpc&lt;/code&gt; also has better performance and scalability than the original &lt;code&gt;rpc&lt;/code&gt; implementation. However, current &lt;code&gt;rpc&lt;/code&gt; module will utilize &lt;code&gt;erpc&lt;/code&gt; in order to also provide these properties when possible.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;rpc&quot;&gt;rpc&lt;/a&gt;&lt;/code&gt; 모듈에서 제공하는 작업의 향상된 하위 집합입니다 . 반환 된 값, 발생한 예외 및 기타 오류를 구별 할 수 있다는 점에서 향상되었습니다. &lt;code&gt;erpc&lt;/code&gt; 는 원래 &lt;code&gt;rpc&lt;/code&gt; 구현 보다 더 나은 성능과 확장 성을 제공합니다 . 그러나 현재 &lt;code&gt;rpc&lt;/code&gt; 모듈은 가능한 경우 이러한 속성도 제공하기 위해 &lt;code&gt;erpc&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="2128cfc6cbe9e874c7e25ecf50f44f2ff9c59c9d" translate="yes" xml:space="preserve">
          <source>This is an enhancement of &lt;code&gt;&lt;a href=&quot;#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. It gives the possibility to:</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 의 향상입니다 . 다음과 같은 가능성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bb4355c46a241b6ccaa141fa3ca19310a4e18377" translate="yes" xml:space="preserve">
          <source>This is an example of an &quot;atomic group&quot;, details are provided below.</source>
          <target state="translated">이것은 &quot;원자 그룹&quot;의 예이며, 세부 사항은 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2afe84bec16e754c046d7de19fb9588006197ad9" translate="yes" xml:space="preserve">
          <source>This is an example of writing and then reading a tar file:</source>
          <target state="translated">다음은 tar 파일을 쓰고 읽는 예입니다.</target>
        </trans-unit>
        <trans-unit id="bf1ddb6f8bac020a202291b264051bd5948a4982" translate="yes" xml:space="preserve">
          <source>This is an extremly dangerous function. You use it on your own risk.</source>
          <target state="translated">이것은 매우 위험한 기능입니다. 당신은 당신 자신의 책임하에 그것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7cdd0e3d179b7cbbf8f37996643142fe64dc77b4" translate="yes" xml:space="preserve">
          <source>This is an intentionally rough guide to the relative costs of different calls. It is based on benchmark figures run on Solaris/Sparc:</source>
          <target state="translated">이것은 서로 다른 통화의 상대적 비용을 의도적으로 대략적으로 안내합니다. Solaris / Sparc에서 실행되는 벤치 마크 수치를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="f4c4ab4d5f5e4f366b3c529f50a5c1512948dcaf" translate="yes" xml:space="preserve">
          <source>This is an interface module for the Reltool application.</source>
          <target state="translated">Reltool 응용 프로그램을위한 인터페이스 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="03e3358ac9f51a5518985ca7ba361683826cf828" translate="yes" xml:space="preserve">
          <source>This is an opaque data type that identifies a monitor.</source>
          <target state="translated">모니터를 식별하는 불투명 한 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="45feb4b3d79044c88ed9b57379b548682c9417a6" translate="yes" xml:space="preserve">
          <source>This is an optimization to achieve very efficient concurrent &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#sub-3&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operations at the expense of potential read inconsistency and memory consumption per counter.</source>
          <target state="translated">이는 잠재적 인 읽기 불일치 및 카운터 당 메모리 소비를 희생하면서 매우 효율적인 동시 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#sub-3&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 작업 을 달성하기위한 최적화 입니다.</target>
        </trans-unit>
        <trans-unit id="26ef7d5997459d409e40c1dbe84146420ac9b4f9" translate="yes" xml:space="preserve">
          <source>This is any extra info the user wants to have supplied when the functions in the callback module is called.</source>
          <target state="translated">콜백 모듈의 함수가 호출 될 때 사용자가 제공하고자하는 추가 정보입니다.</target>
        </trans-unit>
        <trans-unit id="08a7da6db995a217d09a30c00205bf365c46e13e" translate="yes" xml:space="preserve">
          <source>This is as of Erlang/OTP 17.0 the default. It forces any floats in the term to be encoded in a more space-efficient and exact way (namely in the 64-bit IEEE format, rather than converted to a textual representation). As from Erlang/OTP R11B-4, &lt;code&gt;binary_to_term/1&lt;/code&gt; can decode this representation.</source>
          <target state="translated">이것은 Erlang / OTP 17.0의 기본값입니다. 용어의 부동 소수점을보다 공간 효율적이고 정확한 방식으로 (즉, 텍스트 표현으로 변환하지 않고 64 비트 IEEE 형식으로) 인코딩하도록합니다. Erlang / OTP R11B-4에서와 같이 &lt;code&gt;binary_to_term/1&lt;/code&gt; 은이 표현을 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="113749aad29dc1cdbedc3b815e734a581ecdd057" translate="yes" xml:space="preserve">
          <source>This is bad luck, the process was garbage collecting when the crash dump was written. The rest of the information for this process is limited.</source>
          <target state="translated">이것은 불행한 일입니다. 크래시 덤프가 작성되었을 때 프로세스는 가비지 수집이었습니다. 이 프로세스에 대한 나머지 정보는 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b06c013992850341fe5a82bf55411c7f74bcdc5" translate="yes" xml:space="preserve">
          <source>This is because record definitions are only available at compile time, not at runtime. For details on records in the shell, see the &lt;code&gt;shell(3)&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">레코드 정의는 런타임이 아닌 컴파일 타임에만 사용할 수 있기 때문입니다. 쉘의 레코드에 대한 자세한 내용 은 STDLIB 의 &lt;code&gt;shell(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8afd6050f97c61cdb32e6c96ba6b457c161482c6" translate="yes" xml:space="preserve">
          <source>This is called &lt;strong&gt;synchronized code replacement&lt;/strong&gt; and for this the following instructions are used:</source>
          <target state="translated">이를 &lt;strong&gt;동기화 된 코드 교체&lt;/strong&gt; 라고 하며이를 위해 다음 지침이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="646259e147d9a776464db65bc4bea0ac6f13d14c" translate="yes" xml:space="preserve">
          <source>This is done by adding or deleting the &lt;code&gt;error_logger_file_h&lt;/code&gt; event handler, and thus indirectly adding &lt;code&gt;error_logger&lt;/code&gt; as a Logger handler.</source>
          <target state="translated">이것은 추가하거나 삭제하여 수행됩니다 &lt;code&gt;error_logger_file_h&lt;/code&gt; 의 이벤트 핸들러를, 따라서 간접적으로 추가 &lt;code&gt;error_logger&lt;/code&gt; 를 로거 핸들러로.</target>
        </trans-unit>
        <trans-unit id="681acf8836c69537b79e14e48dcac39812f986dc" translate="yes" xml:space="preserve">
          <source>This is done by manipulating the Logger configuration. The function is useful as a shortcut during development and testing, but must not be used in a production system. See section &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide, and the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; manual page for information about how to configure Logger for live systems.</source>
          <target state="translated">이것은 로거 구성을 조작하여 수행됩니다. 이 기능은 개발 및 테스트 중에 바로 가기로 유용하지만 프로덕션 시스템에서 사용해서는 안됩니다. 라이브 시스템 용 로거를 구성하는 방법에 대한 정보 는 커널 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;logger_chapter&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 섹션 및 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;logger(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="180abcd23e113c6f5993e0e4b65009873a53afdd" translate="yes" xml:space="preserve">
          <source>This is done in the CTH functions called &lt;code&gt;post_&amp;lt;name of function&amp;gt;&lt;/code&gt;. These functions take the arguments &lt;code&gt;SuiteName&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; (group or test case name, if applicable), &lt;code&gt;Config&lt;/code&gt;, &lt;code&gt;Return&lt;/code&gt;, and &lt;code&gt;CTHState&lt;/code&gt;. &lt;code&gt;Config&lt;/code&gt; in this case is the same &lt;code&gt;Config&lt;/code&gt; as the testcase is called with. &lt;code&gt;Return&lt;/code&gt; is the value returned by the testcase. If the testcase fails by crashing, &lt;code&gt;Return&lt;/code&gt; is &lt;code&gt;{'EXIT',{{Error,Reason},Stacktrace}}&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;post_&amp;lt;name of function&amp;gt;&lt;/code&gt; 이라는 CTH 함수에서 수행됩니다 . 이 함수는 &lt;code&gt;SuiteName&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; (해당되는 경우 그룹 또는 테스트 케이스 이름), &lt;code&gt;Config&lt;/code&gt; , &lt;code&gt;Return&lt;/code&gt; 및 &lt;code&gt;CTHState&lt;/code&gt; 인수를 사용 합니다. &lt;code&gt;Config&lt;/code&gt; 이 경우에하는 것은 동일 &lt;code&gt;Config&lt;/code&gt; 테스트 케이스가 호출 될 때. &lt;code&gt;Return&lt;/code&gt; 은 테스트 케이스가 리턴 한 값입니다. 테스트 케이스가 충돌하여 실패하면 &lt;code&gt;Return&lt;/code&gt; 은 &lt;code&gt;{'EXIT',{{Error,Reason},Stacktrace}}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36ab57d9407d3cc2fec5c4c069b356365d21838b" translate="yes" xml:space="preserve">
          <source>This is done in the CTH functions called &lt;code&gt;pre_&amp;lt;name of function&amp;gt;&lt;/code&gt;. These functions take the arguments &lt;code&gt;SuiteName&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; (group or test case name, if applicable), &lt;code&gt;Config&lt;/code&gt;, and &lt;code&gt;CTHState&lt;/code&gt;. The return value of the CTH function is always a combination of a result for the suite/group/test and an updated &lt;code&gt;CTHState&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;pre_&amp;lt;name of function&amp;gt;&lt;/code&gt; 이라는 CTH 함수에서 수행됩니다 . 이 함수는 &lt;code&gt;SuiteName&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; (해당되는 경우 그룹 또는 테스트 케이스 이름), &lt;code&gt;Config&lt;/code&gt; 및 &lt;code&gt;CTHState&lt;/code&gt; 인수를 사용 합니다. CTH 함수의 반환 값은 항상 suite / group / test에 대한 결과와 업데이트 된 &lt;code&gt;CTHState&lt;/code&gt; 의 조합 입니다.</target>
        </trans-unit>
        <trans-unit id="bfd349ddda4246be97d235609d023e3a44aa81a6" translate="yes" xml:space="preserve">
          <source>This is done until the end of the list is reached, that is, the list is empty:</source>
          <target state="translated">이것은 목록의 끝에 도달 할 때까지, 즉 목록이 비어있을 때까지 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="d11de2ea50c52f849f3bde4848fccd123f17645d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;set_pos(Target, get_pos(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">이것은 &lt;code&gt;set_pos(Target, get_pos(Source))&lt;/code&gt; 와 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="5c2e34b39e7cb8fbbca41e01630396e57161f9bd" translate="yes" xml:space="preserve">
          <source>This is equivalent to a call to:</source>
          <target state="translated">이것은 다음에 대한 호출과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b89997f1aaabac9326c311cc6347ce9ddb0e3b91" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;public_key:ssh_decode(SshBin, openssh_public_key)&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;public_key:ssh_decode(SshBin, openssh_public_key)&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7b99c8c34be448e6bbcfec89b94bf9160fbaeb4a" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;public_key:ssh_decode(SshBin, rfc4716_public_key)&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;public_key:ssh_decode(SshBin, rfc4716_public_key)&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="97a7c564e0e141ccb4b750a31aa63ab870cbb904" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following specification:</source>
          <target state="translated">이것은 다음 사양과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b93967cb769ce4a169bcbd657ff004f71b25464" translate="yes" xml:space="preserve">
          <source>This is expanded to:</source>
          <target state="translated">이것은 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="732ce2a7a4465b34c1eb7162718b1da76d4ed1e9" translate="yes" xml:space="preserve">
          <source>This is experimental code that can be changed or removed anytime without any warning.</source>
          <target state="translated">이것은 경고없이 언제든지 변경하거나 제거 할 수있는 실험용 코드입니다.</target>
        </trans-unit>
        <trans-unit id="1093a321a621a1d24d25a283757e5229ec776381" translate="yes" xml:space="preserve">
          <source>This is followed by a call to &lt;code&gt;open/4&lt;/code&gt; before any read/write access is performed. &lt;code&gt;AcceptedOptions&lt;/code&gt; is sent to the server, which replies with the options that it accepts. These are then forwarded to &lt;code&gt;open/4&lt;/code&gt; as &lt;code&gt;SuggestedOptions&lt;/code&gt;.</source>
          <target state="translated">그런 다음 읽기 / 쓰기 액세스가 수행되기 전에 &lt;code&gt;open/4&lt;/code&gt; 에 대한 호출이 이어집니다 . &lt;code&gt;AcceptedOptions&lt;/code&gt; 는 서버로 전송되며 서버는 수락하는 옵션으로 응답합니다. 이들은 다음을 전달 &lt;code&gt;open/4&lt;/code&gt; 로 &lt;code&gt;SuggestedOptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef43207effbfa0c4bc3102645253272383b860ee" translate="yes" xml:space="preserve">
          <source>This is handled automatically by the megaco application. There is however one thing that need to be configured by the user, the &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_recv_timer&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이것은 megaco 응용 프로그램에 의해 자동으로 처리됩니다. 그러나 사용자가 &lt;code&gt;&lt;a href=&quot;megaco#user_info&quot;&gt;segment_recv_timer&lt;/a&gt;&lt;/code&gt; 옵션 으로 구성해야 할 것이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29f190ed43ce30d7d9b9d196be4fa299d1c36697" translate="yes" xml:space="preserve">
          <source>This is if it is used in the context of the match operator as in the example.</source>
          <target state="translated">예와 같이 일치 연산자의 컨텍스트에서 사용되는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="7b6a3bc9957c826c254223da8d53ebcc53f4e171" translate="yes" xml:space="preserve">
          <source>This is illustrated in the following table:</source>
          <target state="translated">다음 표에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9346a5e9e0ffd489af06c1ad2635ffc6b9ae2c" translate="yes" xml:space="preserve">
          <source>This is implementattion depended. That is, it depends on the module. For each module a specific set of options are valid. For the module provided with the app, these options are supported:</source>
          <target state="translated">이것은 구현에 의존합니다. 즉, 모듈에 따라 다릅니다. 각 모듈에 대해 특정 옵션 세트가 유효합니다. 앱과 함께 제공된 모듈의 경우 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="114d08a8e002db6d0c9182141940ed632dd9d634" translate="yes" xml:space="preserve">
          <source>This is in effect a progress report.</source>
          <target state="translated">이것은 실제로 진행 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="a159e1612a81f8d86b525155c551f0929580069d" translate="yes" xml:space="preserve">
          <source>This is no longer the case. If you require &lt;code&gt;'undefined'&lt;/code&gt; in your record field type, you must explicitly add it to the typespec, as in the 2nd example.</source>
          <target state="translated">이것은 더 이상 사실이 아닙니다. 레코드 필드 유형에 &lt;code&gt;'undefined'&lt;/code&gt; 이 필요한 경우 , 두 번째 예에서와 같이 명시 적으로 typespec에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="33403ecb7959eebc92f2663aeded4a8c6c3bee94" translate="yes" xml:space="preserve">
          <source>This is normally a wise decision, but it can be disastrous if the nodes have been disconnected because of a communication failure, as the &lt;code&gt;Mnesia&lt;/code&gt; normal table load mechanism does not cope with communication failures.</source>
          <target state="translated">이는 일반적으로 현명한 결정이지만 &lt;code&gt;Mnesia&lt;/code&gt; 정상 테이블로드 메커니즘이 통신 실패에 대응하지 않으므로 통신 실패로 인해 노드의 연결이 끊어지면 재앙이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="868d49c485867e5bfe4e2b7dfc7ac02d90106823" translate="yes" xml:space="preserve">
          <source>This is normally the default &lt;code&gt;malloc&lt;/code&gt; implementation used on the specific OS.</source>
          <target state="translated">일반적으로 특정 OS에서 사용되는 기본 &lt;code&gt;malloc&lt;/code&gt; 구현입니다.</target>
        </trans-unit>
        <trans-unit id="9dde21bfce3c688dc390548f3494e7bf552bd9fc" translate="yes" xml:space="preserve">
          <source>This is not a full-fledged resolver, only a DNS client that relies on asking trusted recursive name servers.</source>
          <target state="translated">본격적인 확인자가 아니며 신뢰할 수있는 재귀 이름 서버를 요구하는 DNS 클라이언트 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="836326e8e7b02322f5679431a9ac0cf2a7bdaf26" translate="yes" xml:space="preserve">
          <source>This is not a proper Unicode representation, but the representation used for characters before the Unicode standard. It can still be used to represent character code points in the Unicode standard with numbers &amp;lt; 256, which exactly corresponds to the ISO Latin-1 character set. In Erlang, this is commonly denoted &lt;code&gt;latin1&lt;/code&gt; encoding, which is slightly misleading as ISO Latin-1 is a character code range, not an encoding.</source>
          <target state="translated">이것은 올바른 유니 코드 표현이 아니라 유니 코드 표준 이전의 문자에 사용되는 표현입니다. 이 문자는 ISO 라틴 -1 문자 집합에 정확히 일치하는 숫자 &amp;lt;256의 유니 코드 표준에서 문자 코드 포인트를 나타내는 데 여전히 사용될 수 있습니다. Erlang에서 이는 일반적으로 &lt;code&gt;latin1&lt;/code&gt; 인코딩 으로 표시 되며 ISO Latin-1은 인코딩이 아닌 문자 코드 범위이므로 약간 오해의 소지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c58e7e1b5e3d20a4fa526ed7b8e2cfc77c34073" translate="yes" xml:space="preserve">
          <source>This is not entirely safe, as it is vulnerable against takeover attacks, but it is a tradeoff between fair safety and performance.</source>
          <target state="translated">이는 인계 공격에 취약하기 때문에 완전히 안전하지는 않지만 공정한 안전과 성능 간의 균형을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="43d40b61a5fa7c9dc787ea193a5ed313e523277b" translate="yes" xml:space="preserve">
          <source>This is not important if you do not postpone events. But if you later decide to start postponing some events, then the design flaw of not having separate states when they should be, might become a hard to find bug.</source>
          <target state="translated">이벤트를 연기하지 않는 경우에는 중요하지 않습니다. 그러나 나중에 일부 이벤트 연기를 시작하기로 결정하면 별도의 상태가 없어야하는 디자인 결함으로 인해 버그를 찾기가 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a61dc5f6b213458abec4f8eccdc89fe38585fdf1" translate="yes" xml:space="preserve">
          <source>This is not important if you do not postpone events. But if you later decide to start postponing some events, then the design flaw of not having separate states when they should be, might become a hard-to-find bug.</source>
          <target state="translated">이벤트를 연기하지 않으면 중요하지 않습니다. 그러나 나중에 일부 이벤트를 연기하기로 결정하면 별도의 상태가 있어야 할 때 별도의 상태를 갖지 않는 디자인 결함이 찾기 어려운 버그가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f78e9c138cff8dcc48b10d2119a79c6c5f383e" translate="yes" xml:space="preserve">
          <source>This is not the wanted result. To achieve the desired effect, &lt;code&gt;select&lt;/code&gt; must be written as follows:</source>
          <target state="translated">이것은 원하는 결과가 아닙니다. 원하는 효과를 얻으려면 다음과 같이 &lt;code&gt;select&lt;/code&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7f69a6080f0d1385f2abcc049f00ad9be5341c1" translate="yes" xml:space="preserve">
          <source>This is perhaps the most central module in the entirety of the &lt;code&gt;et&lt;/code&gt; suite. The &lt;code&gt;Collector&lt;/code&gt; needs &quot;filters&quot; to convert the &lt;code&gt;Raw Trace Data&lt;/code&gt; into &quot;events&quot; that it can display. The &lt;code&gt;et_selector&lt;/code&gt; module provides the default &lt;code&gt;Filter&lt;/code&gt; and some API calls to manage the &lt;code&gt;Trace Pattern&lt;/code&gt;. The &lt;code&gt;Selector&lt;/code&gt; provides various functions that achieve the following:</source>
          <target state="translated">이것은 아마의 전체에서 가장 중앙 모듈 &lt;code&gt;et&lt;/code&gt; 제품군. &lt;code&gt;Collector&lt;/code&gt; 변환 &quot;필터&quot;를 필요로 &lt;code&gt;Raw Trace Data&lt;/code&gt; 가 표시 할 수있는 &quot;이벤트&quot;로. &lt;code&gt;et_selector&lt;/code&gt; 의 모듈은 기본 제공 &lt;code&gt;Filter&lt;/code&gt; 일부 API는 관리 호출 &lt;code&gt;Trace Pattern&lt;/code&gt; . &lt;code&gt;Selector&lt;/code&gt; 다음을 달성 다양한 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="bd78b41da72f8f6a1b1b335bee4881061346e4af" translate="yes" xml:space="preserve">
          <source>This is possibly a little clearer.</source>
          <target state="translated">이것은 아마도 조금 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="7063cc576e9b11f727c2ae0cabc7e8bc7b76b64e" translate="yes" xml:space="preserve">
          <source>This is primarily a way to show the effects of using the reentrant flex scanner instead of the non-reentrant.</source>
          <target state="translated">이것은 주로 재진입자가 아닌 재진입 플렉스 스캐너 사용의 효과를 보여주는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7f43cbca3b6fcf016e7da8036914af019823f1d9" translate="yes" xml:space="preserve">
          <source>This is read as follows: The list of X such that X is taken from the list &lt;code&gt;[1,2,a,...]&lt;/code&gt; and X is greater than 3.</source>
          <target state="translated">다음과 같이 읽습니다. X가 목록 &lt;code&gt;[1,2,a,...]&lt;/code&gt; 에서 가져 오고 X가 3보다 큰 X 목록 .</target>
        </trans-unit>
        <trans-unit id="e5bbd1957b21e024367be0eb839936ca962e71f8" translate="yes" xml:space="preserve">
          <source>This is received by the client, which in turn does &lt;code&gt;exit(normal)&lt;/code&gt; and terminates. If &lt;code&gt;keysearch&lt;/code&gt; returns &lt;code&gt;{value,{From,Name}}&lt;/code&gt; it is certain that the user is logged on and that his name (peter) is in variable &lt;code&gt;Name&lt;/code&gt;.</source>
          <target state="translated">이것은 클라이언트에 의해 수신되어 &lt;code&gt;exit(normal)&lt;/code&gt; 하고 종료됩니다. 만약 &lt;code&gt;keysearch&lt;/code&gt; 반환 &lt;code&gt;{value,{From,Name}}&lt;/code&gt; 는 사용자에 그의 이름 (피터) 변수에 있다고 기록 될 것이 확실 &lt;code&gt;Name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81a8f87d1727d52beaa427ce4936112ae848bc0b" translate="yes" xml:space="preserve">
          <source>This is received by the client.</source>
          <target state="translated">이것은 클라이언트에 의해 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="6c40d6a299f26d7b05469a35afc3ecd07bd6f779" translate="yes" xml:space="preserve">
          <source>This is simply an erlang compatible text-file with the following structure: &lt;code&gt;{codec_name(), messages_list()}&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;{codec_name(), messages_list()}&lt;/code&gt; 구조의 erlang 호환 텍스트 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="44863f1a9281f46194959277b2c84306dd047f31" translate="yes" xml:space="preserve">
          <source>This is slightly faster for probably the most common case that the input lists are not empty or very short. (Another advantage is that Dialyzer can deduce a better type for the &lt;code&gt;Xs&lt;/code&gt; variable.)</source>
          <target state="translated">입력 목록이 비어 있거나 매우 짧지 않은 가장 일반적인 경우에는이 방법이 약간 더 빠릅니다. (또 다른 장점은 Dialyzer가 &lt;code&gt;Xs&lt;/code&gt; 변수에 대해 더 나은 유형을 추론 할 수 있다는 것입니다 .)</target>
        </trans-unit>
        <trans-unit id="709cd27ea3760e45f8fdbf83a2674e3dd14b99e2" translate="yes" xml:space="preserve">
          <source>This is slightly more efficient because here you do not build a list element only to copy it directly. (Or it would be more efficient if the compiler did not automatically rewrite &lt;code&gt;[H]++Acc&lt;/code&gt; to &lt;code&gt;[H|Acc]&lt;/code&gt;.)</source>
          <target state="translated">리스트 요소를 직접 복사하기 위해서만 빌드하지 않기 때문에 이것은 약간 더 효율적입니다. (또는 컴파일러가 &lt;code&gt;[H]++Acc&lt;/code&gt; 를 &lt;code&gt;[H|Acc]&lt;/code&gt; 자동으로 다시 쓰지 않으면 더 효율적 입니다.)</target>
        </trans-unit>
        <trans-unit id="4f59ec1eb2875e58bffaa8ecb426dbb6d7dc8700" translate="yes" xml:space="preserve">
          <source>This is sometimes the only way to run distributed Erlang if the Domain Name System (DNS) is not running. No communication can exist between nodes running with flag &lt;code&gt;-sname&lt;/code&gt; and those running with flag &lt;code&gt;-name&lt;/code&gt;, as node names must be unique in distributed Erlang systems.</source>
          <target state="translated">DNS (Domain Name System)가 실행 중이 아닌 경우 분산 Erlang을 실행하는 유일한 방법입니다. 분산 Erlang 시스템에서 노드 이름은 고유해야하므로 플래그 &lt;code&gt;-sname&lt;/code&gt; 으로 실행되는 노드 와 flag &lt;code&gt;-name&lt;/code&gt; 으로 실행되는 노드간에 통신이 존재하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="570f8642744ae6cd3a9675f1aad4ee8419ad33a1" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for the equivalent, but harder to read:</source>
          <target state="translated">이것은 동등하지만 읽기가 어려운 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="9e186bc5c4bbfebc187d81afa7fc46f64f868bc5" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for the following:</source>
          <target state="translated">이것은 다음에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="922370e690d4cc53426a28eb4d41e24f43cfe114" translate="yes" xml:space="preserve">
          <source>This is syntactic sugar for:</source>
          <target state="translated">이것은 다음에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="bb54970de95599c4474802466e4b9431c5e1008a" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;SSL/TLS&lt;/code&gt; connectin configuration option.</source>
          <target state="translated">이것이 &lt;code&gt;SSL/TLS&lt;/code&gt; 연결 구성 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="5b502c6950dc7c3f81c03175a62672f14e273c7b" translate="yes" xml:space="preserve">
          <source>This is the Xorshift116 generator combined with the StarStar scrambler from the 2018 paper by David Blackman and Sebastiano Vigna: &lt;code&gt;&lt;a href=&quot;http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf&quot;&gt; Scrambled Linear Pseudorandom Number Generators &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이것은 David Blackman과 Sebastiano Vigna의 2018 년 논문에서 StarStar 스크램블러와 결합 된 Xorshift116 생성기입니다 : &lt;code&gt;&lt;a href=&quot;http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf&quot;&gt; Scrambled Linear Pseudorandom Number Generators &lt;/a&gt;&lt;/code&gt; 난수 생성기</target>
        </trans-unit>
        <trans-unit id="aac881df38163ed7b3cad0912165225c572fc928" translate="yes" xml:space="preserve">
          <source>This is the default handler used by OTP. Multiple instances can be started, and each instance will write log events to a given destination, terminal or file.</source>
          <target state="translated">OTP에서 사용하는 기본 핸들러입니다. 여러 인스턴스를 시작할 수 있으며 각 인스턴스는 지정된 대상, 터미널 또는 파일에 로그 이벤트를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c4d57523639a2e8a475bc6496773bdbfcedee6d9" translate="yes" xml:space="preserve">
          <source>This is the default instrumentation function for tables.</source>
          <target state="translated">이것이 테이블의 기본 계측 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8a590bd244aa7fba225f4a56cad227855876f150" translate="yes" xml:space="preserve">
          <source>This is the default instrumentation function for variables.</source>
          <target state="translated">변수에 대한 기본 계측 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0ea769a678284ef3199b2e2888a8634fc4803cb9" translate="yes" xml:space="preserve">
          <source>This is the default. It means the &lt;code&gt;Time&lt;/code&gt; value is interpreted as a time in milliseconds &lt;strong&gt;relative&lt;/strong&gt; current &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것이 기본값입니다. 이는 &lt;code&gt;Time&lt;/code&gt; 값이 &lt;strong&gt;상대&lt;/strong&gt; 전류 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 밀리 초 단위의 시간으로 해석 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0db12e389b3a4261d748d8d5279be613afd3e185" translate="yes" xml:space="preserve">
          <source>This is the directory holding the files:</source>
          <target state="translated">다음은 파일을 보관하는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="f95887b28149dccf1da49196a8c57540f2278c1d" translate="yes" xml:space="preserve">
          <source>This is the directory holding the server's files:</source>
          <target state="translated">다음은 서버의 파일을 보관하는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="31b3e5ab542a5f0debc59c85dd91647f80797616" translate="yes" xml:space="preserve">
          <source>This is the disk log type, &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;halt&lt;/code&gt;. The option corresponds to the &lt;code&gt;type&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">디스크 로그 유형 &lt;code&gt;wrap&lt;/code&gt; 또는 &lt;code&gt;halt&lt;/code&gt; 입니다. 이 옵션 은 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 데이터 유형 의 &lt;code&gt;type&lt;/code&gt; 속성에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="79cf40aec82f5e3c6c095b9a7f24df20c5c7f299" translate="yes" xml:space="preserve">
          <source>This is the fastest way of calling a driver and get a response. It makes no context switch in the Erlang emulator and requires no message passing. It is suitable for calling C function to get faster execution, when Erlang is too slow.</source>
          <target state="translated">이것은 가장 빠른 드라이버 호출 방법이며 응답을받습니다. Erlang 에뮬레이터에서 컨텍스트 전환을 수행하지 않으며 메시지 전달이 필요하지 않습니다. Erlang이 너무 느릴 때 C 함수를 호출하여 더 빠른 실행을 얻는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f997eb6e8d88cc346ac8a25ffea65575e19dddfd" translate="yes" xml:space="preserve">
          <source>This is the first function called when a notification delivery is in progress. It informs the &lt;code&gt;receiver&lt;/code&gt; which targets will get the notification. The result of the delivery will be provided via successive calls to &lt;code&gt;delivery_info/4&lt;/code&gt; function, see below.</source>
          <target state="translated">이것은 알림 전달이 진행 중일 때 가장 먼저 호출되는 기능입니다. &lt;code&gt;receiver&lt;/code&gt; 에게 알림을받을 대상을 알려줍니다 . 전달 결과는 &lt;code&gt;delivery_info/4&lt;/code&gt; 함수에 대한 연속적인 호출을 통해 제공됩니다 ( 아래 참조).</target>
        </trans-unit>
        <trans-unit id="ba21277d355183275053e3909ab979314fa50468" translate="yes" xml:space="preserve">
          <source>This is the first message that the channel receives. It is sent just before the &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; function returns successfully. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario, ignore it by immediately returning &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">채널이받는 첫 번째 메시지입니다. &lt;code&gt;&lt;a href=&quot;#init-1&quot;&gt;init/1&lt;/a&gt;&lt;/code&gt; 함수가 성공적으로 리턴 되기 직전에 전송 됩니다. 이것은 서버가 먼저 메시지를받지 않고 클라이언트에게 메시지를 보내려는 경우에 특히 유용합니다. 메시지가 특정 시나리오에 유용하지 않으면 &lt;code&gt;{ok, State}&lt;/code&gt; 즉시 리턴하여 무시하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff43ffc2013d60b90dbeef0ec3d72ae3abfda509" translate="yes" xml:space="preserve">
          <source>This is the first message that the channel receives. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario, ignore it by immediately returning &lt;code&gt;{ok, State}&lt;/code&gt;.</source>
          <target state="translated">채널이받는 첫 번째 메시지입니다. 이것은 서버가 먼저 메시지를받지 않고 클라이언트에게 메시지를 보내려는 경우에 특히 유용합니다. 메시지가 특정 시나리오에 유용하지 않으면 &lt;code&gt;{ok, State}&lt;/code&gt; 즉시 리턴하여 무시하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4993527ae602c81dada40230c7e4b229f40c09c" translate="yes" xml:space="preserve">
          <source>This is the full name of the disk log file. The option corresponds to the &lt;code&gt;name&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">디스크 로그 파일의 전체 이름입니다. 이 옵션 은 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 데이터 유형 의 &lt;code&gt;name&lt;/code&gt; 속성에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="5982af784f6f1a00b591611686e14f6193a9f84c" translate="yes" xml:space="preserve">
          <source>This is the interface module for the &lt;code&gt;SSH&lt;/code&gt; application. The Secure Shell (SSH) Protocol is a protocol for secure remote login and other secure network services over an insecure network. See &lt;code&gt;ssh(6)&lt;/code&gt; for details of supported RFCs, versions, algorithms and unicode handling.</source>
          <target state="translated">&lt;code&gt;SSH&lt;/code&gt; 응용 프로그램 의 인터페이스 모듈입니다 . SSH (Secure Shell) 프로토콜은 안전하지 않은 네트워크를 통한 보안 원격 로그인 및 기타 보안 네트워크 서비스를위한 프로토콜입니다. 참조 &lt;code&gt;ssh(6)&lt;/code&gt; 지원 RFC는, 버전, 알고리즘과 유니 코드 처리의 세부 사항을.</target>
        </trans-unit>
        <trans-unit id="f80630a3cb0a4f72ab077d535fc76e765cca2dca" translate="yes" xml:space="preserve">
          <source>This is the low-level function to unload (or decrement reference counts of) a driver. It can be used to force port killing, in much the same way as the driver option &lt;code&gt;kill_ports&lt;/code&gt; implicitly does. Also, it can trigger a monitor either because other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; still have the driver loaded or because open ports use the driver.</source>
          <target state="translated">드라이버를 언로드 (또는 참조 카운트 감소)하는 저수준 기능입니다. 드라이버 옵션 &lt;code&gt;kill_ports&lt;/code&gt; 가 내재적으로 수행 하는 것과 거의 같은 방식으로 포트 강제 종료에 사용될 수 있습니다 . 또한 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 드라이버를로드했거나 열린 포트가 드라이버를 사용하기 때문에 모니터를 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eacd6f28e2e16d27200f6b33be43d951190f1539" translate="yes" xml:space="preserve">
          <source>This is the magic macro to initialize a NIF library. It is to be evaluated in global file scope.</source>
          <target state="translated">NIF 라이브러리를 초기화하는 마법의 매크로입니다. 전역 파일 범위에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ed06a82672ebce7c45ad63610c5550104e76dd" translate="yes" xml:space="preserve">
          <source>This is the main option and it controls the configuration of Reltool. It can either be a &lt;code&gt;sys&lt;/code&gt; tuple or a name of a &lt;code&gt;file&lt;/code&gt; containing a sys tuple.</source>
          <target state="translated">이것이 주요 옵션이며 Reltool의 구성을 제어합니다. &lt;code&gt;sys&lt;/code&gt; 튜플이거나 sys 튜플을 포함하는 &lt;code&gt;file&lt;/code&gt; 이름 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c9044a0169d5c61331b09923e7b20b8bc8aa7f2" translate="yes" xml:space="preserve">
          <source>This is the maximum allowed queue length. If the message queue grows larger than this, the handler process is terminated.</source>
          <target state="translated">허용되는 최대 큐 길이입니다. 메시지 큐가 이보다 커지면 핸들러 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b9f45ed64c3e0c4da54fbe1eb312ba76516ad0e2" translate="yes" xml:space="preserve">
          <source>This is the maximum memory size that the handler process is allowed to use. If the handler grows larger than this, the process is terminated.</source>
          <target state="translated">핸들러 프로세스에서 사용할 수있는 최대 메모리 크기입니다. 핸들러가 이보다 커지면 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="16038a3786bdd4dedf260d26283b919a880bb676" translate="yes" xml:space="preserve">
          <source>This is the maximum number of bytes that is written to a log file before disk_log proceeds with the next file in order, or generates an error in case of a full halt log. The option corresponds to the &lt;code&gt;MaxNoBytes&lt;/code&gt; element in the &lt;code&gt;size&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">disk_log가 다음 파일을 순서대로 진행하기 전에 로그 파일에 기록되는 최대 바이트 수입니다. 또는 전체 정지 로그의 경우 오류를 생성합니다. 받는 옵션 대응 &lt;code&gt;MaxNoBytes&lt;/code&gt; 의 의 소자 &lt;code&gt;size&lt;/code&gt; 재산 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="459f135a3a42608f2bd3388de6fc151cb8110783" translate="yes" xml:space="preserve">
          <source>This is the maximum number of events to handle within a &lt;code&gt;burst_limit_window_time&lt;/code&gt; time frame. After the limit is reached, successive events are dropped until the end of the time frame.</source>
          <target state="translated">이것은 &lt;code&gt;burst_limit_window_time&lt;/code&gt; 시간 프레임 내에서 처리 할 최대 이벤트 수입니다 . 한도에 도달하면 기간이 끝날 때까지 연속 이벤트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d007efced8ad7291f6b7473c324b69730b4bdb" translate="yes" xml:space="preserve">
          <source>This is the maximum number of files that disk_log uses for its circular logging. The option corresponds to the &lt;code&gt;MaxNoFiles&lt;/code&gt; element in the &lt;code&gt;size&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; datatype.</source>
          <target state="translated">disk_log가 순환 로깅에 사용하는 최대 파일 수입니다. 받는 옵션 대응 &lt;code&gt;MaxNoFiles&lt;/code&gt; 의 의 소자 &lt;code&gt;size&lt;/code&gt; 재산 &lt;code&gt;&lt;a href=&quot;disk_log#open-1&quot;&gt;dlog_option()&lt;/a&gt;&lt;/code&gt; 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="88ddfe714e0b66558fbe57136603410b11130d4d" translate="yes" xml:space="preserve">
          <source>This is the new encoding of internal funs: &lt;code&gt;fun F/A&lt;/code&gt; and &lt;code&gt;fun(Arg1,..) -&amp;gt; ... end&lt;/code&gt;.</source>
          <target state="translated">이것은 내부 &lt;code&gt;fun F/A&lt;/code&gt; 의 새로운 인코딩입니다 : fun F / A and &lt;code&gt;fun(Arg1,..) -&amp;gt; ... end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="837460bd7445a65a68a00b613c75a7744d0ed82a" translate="yes" xml:space="preserve">
          <source>This is the printout header of one process. The printout contains only this one process since we did &lt;code&gt;fprof:apply/3&lt;/code&gt; which traces only the current process. Therefore the CNT and OWN columns perfectly matches the totals above. The ACC column is undefined since summing the ACC times of all calls in the process makes no sense - you would get something like the ACC value from totals above multiplied by the average depth of the call stack, or something.</source>
          <target state="translated">한 프로세스의 출력 헤더입니다. 현재 프로세스 만 추적하는 &lt;code&gt;fprof:apply/3&lt;/code&gt; 를 수행 한 이후 인쇄물에는이 하나의 프로세스 만 포함됩니다 . 따라서 CNT 및 OWN 열은 위의 총계와 완벽하게 일치합니다. ACC 열은 프로세스의 모든 통화에 대한 ACC 시간을 합산하는 것이 의미가 없으므로 정의되지 않습니다. 위의 총계에서 ACC 값과 같은 평균 또는 통화 스택의 깊이를 곱한 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee530acee221ac3457f1090f43fd370b8436c96d" translate="yes" xml:space="preserve">
          <source>This is the re-entrant formatted reader. The continuation of the first call to the functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding, Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">재진입 형식의 리더입니다. 함수에 대한 첫 번째 호출의 연속은 &lt;code&gt;[]&lt;/code&gt; 이어야합니다 . 재진입 입력 체계의 작동 방식에 대한 자세한 설명은 암스트롱, 비디오, 윌리엄스 : 'Erlang의 동시 프로그래밍', 13 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecd4a7ad5696bedde8f5f313930da44fe12f224d" translate="yes" xml:space="preserve">
          <source>This is the re-entrant scanner, which scans characters until either a &lt;strong&gt;dot&lt;/strong&gt; ('.' followed by a white space) or &lt;code&gt;eof&lt;/code&gt; is reached. It returns:</source>
          <target state="translated">재진입 스캐너로, &lt;strong&gt;점&lt;/strong&gt; ( '.'다음에 공백)이나 &lt;code&gt;eof&lt;/code&gt; 에 도달 할 때까지 문자를 스캔합니다 . 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c87585c82ab9ef5b43a4d3bd9e435a0da3d966d" translate="yes" xml:space="preserve">
          <source>This is the return type from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; and selects &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; and whether to do &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, or not.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 의 반환 유형 이며 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 여부를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="6ad3ae21f4d6378b9390fab772b58bcf9e24057d" translate="yes" xml:space="preserve">
          <source>This is the return type from &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; and selects &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback mode&lt;/a&gt;&lt;/code&gt; and whether to do &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, or not.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; 의 리턴 유형 이며 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;callback mode&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt; 수행 여부를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="04e8ab784b5603c6b44491c28cae41829d1e3589" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;sol&lt;/code&gt;, but only for the first call to &lt;code&gt;link/1&lt;/code&gt; by the traced process.</source>
          <target state="translated">이는 &lt;code&gt;sol&lt;/code&gt; 과 동일 하지만 추적 된 프로세스 에서 &lt;code&gt;link/1&lt;/code&gt; 을 처음 호출하는 경우에만 해당 됩니다.</target>
        </trans-unit>
        <trans-unit id="5d44ec075c5224429b7e914e2c0f01b386f3e0fd" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;sos&lt;/code&gt;, but only for the first process spawned by the traced process.</source>
          <target state="translated">이는 &lt;code&gt;sos&lt;/code&gt; 와 동일 하지만 추적 된 프로세스에서 생성 된 첫 번째 프로세스에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="5c9a7f10551e6fef6526100ea65361d85f3b3c5e" translate="yes" xml:space="preserve">
          <source>This is the same as calling &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config(group_leader())&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config(group_leader())&lt;/a&gt;&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="ae7c485681a5d5be425044d9a2ecba3267612e5e" translate="yes" xml:space="preserve">
          <source>This is the same as doing, e.g.:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="750c9c2130115cb398cd55807f2f8cb0dffbe5fd" translate="yes" xml:space="preserve">
          <source>This is the same as mapfold/4, with an identity function as the pre-operation.</source>
          <target state="translated">이는 mapfold / 4와 동일하며 사전 작업과 같은 식별 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70feac208b0fafbbf1031f0ed7f8654773e27d3" translate="yes" xml:space="preserve">
          <source>This is the same as:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b5a14eeead1c5ce60108308f333bdf8d18e6154" translate="yes" xml:space="preserve">
          <source>This is the short story though, for the experienced and impatient:</source>
          <target state="translated">그러나 이것은 경험이 많고 참을성이없는 사람들을위한 짧은 이야기입니다.</target>
        </trans-unit>
        <trans-unit id="5cabfd28d4ff30cee5147e828bd4dda97a0b5763" translate="yes" xml:space="preserve">
          <source>This is the standard handler for Logger. Multiple instances of this handler can be added to Logger, and each instance prints logs to &lt;code&gt;standard_io&lt;/code&gt;, &lt;code&gt;standard_error&lt;/code&gt;, or to file.</source>
          <target state="translated">이것은 Logger의 표준 핸들러입니다. 이 핸들러의 여러 인스턴스를 Logger에 추가 할 수 있으며 각 인스턴스는 로그를 &lt;code&gt;standard_io&lt;/code&gt; , &lt;code&gt;standard_error&lt;/code&gt; 또는 file에 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="7d0bc914b2bcbf775df160b6a080adcaa1ab6b48" translate="yes" xml:space="preserve">
          <source>This is the start of a hiearchy of opaque data structures that can be examined with access functions in &lt;code&gt;inet_dns&lt;/code&gt;, which return lists of &lt;code&gt;{Field,Value}&lt;/code&gt; tuples. The arity 2 functions only return the value for a specified field.</source>
          <target state="translated">이것은 &lt;code&gt;{Field,Value}&lt;/code&gt; 튜플의 목록을 리턴하는 &lt;code&gt;inet_dns&lt;/code&gt; 의 액세스 함수로 검사 할 수있는 불투명 한 데이터 구조의 시작입니다 . arity 2 함수는 지정된 필드의 값만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d98c71268352e941036bfc46f7ac63a11dac3adf" translate="yes" xml:space="preserve">
          <source>This is the sum of the runtime for all threads in the Erlang runtime system and can therefore be greater than the wall clock time.</source>
          <target state="translated">이것은 Erlang 런타임 시스템의 모든 스레드에 대한 런타임의 합이므로 벽시계 시간보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f65cd2322c237b869a90671095b9d99fc32d6542" translate="yes" xml:space="preserve">
          <source>This is the top supervisor for the agent part of the SNMP application. There is always one supervisor at each node with an SNMP agent (master agent or sub-agent).</source>
          <target state="translated">이것은 SNMP 응용 프로그램의 에이전트 부분에 대한 최고 감독자입니다. SNMP 에이전트 (마스터 에이전트 또는 하위 에이전트)가있는 각 노드에는 항상 하나의 감독자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c91fd8459d792120c638965b077037f75eb8c7b" translate="yes" xml:space="preserve">
          <source>This is the type definition for the supervisor flags:</source>
          <target state="translated">이것은 감독자 플래그의 유형 정의입니다.</target>
        </trans-unit>
        <trans-unit id="8fcf634babe6dda8ecdbe08e51d07e7fe457d1af" translate="yes" xml:space="preserve">
          <source>This is to allow a transport process to keep count of the number of incoming request messages that have not yet been answered or discarded, to allow it to regulate the amount of incoming traffic. Both diameter_tcp and diameter_sctp request acknowledgements when a &lt;code&gt;message_cb&lt;/code&gt; is configured, turning send/recv message into callbacks that can be used to regulate traffic.</source>
          <target state="translated">이는 전송 프로세스가 아직 응답 또는 삭제되지 않은 수신 요청 메시지의 수를 유지하여 수신 트래픽의 양을 조절할 수 있도록하기위한 것입니다. diameter_tcp와 diameter_sctp는 모두 &lt;code&gt;message_cb&lt;/code&gt; 가 구성 될 때 승인을 요청 하여 전송 / 수신 메시지를 트래픽을 조절하는 데 사용할 수있는 콜백으로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="9847ce6094bdf607fe5e13ee0e480c77d4dbdfd9" translate="yes" xml:space="preserve">
          <source>This is to be added to the &lt;code&gt;start&lt;/code&gt; script.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 스크립트에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cc5dbd4b0a6027790eeb7362903f65abf0802cc" translate="yes" xml:space="preserve">
          <source>This is to provide options that changes its general behavior and &quot;sticks&quot; to the driver throughout its lifespan.</source>
          <target state="translated">이는 일반적인 동작과 수명주기 동안 운전자에게 &quot;고착&quot;을 변경하는 옵션을 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="63ab71f3a67c414cba27c6d8e2befb9085535d6d" translate="yes" xml:space="preserve">
          <source>This is transformed into one call to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;my_table&lt;/code&gt; 에 대한 하나의 호출로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fad7abe2a96807b6a5b8ac7472f217897f8a19e9" translate="yes" xml:space="preserve">
          <source>This is used for &lt;strong&gt;three-way-handshake&lt;/strong&gt;.</source>
          <target state="translated">이것은 &lt;strong&gt;3 방향 핸드 셰이크에 사용&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="72036e52d82b37ea2fc4d48dfb5499c608ebb71d" translate="yes" xml:space="preserve">
          <source>This is used to determine if the call to non-local function &lt;code&gt;FuncSpec&lt;/code&gt; (&lt;code&gt;{Module,Func}&lt;/code&gt; or a fun) with arguments &lt;code&gt;ArgList&lt;/code&gt; is to be allowed. The return value &lt;code&gt;{redirect,NewFuncSpec,NewArgList}&lt;/code&gt; can be used to let the shell evaluate some other function than the one specified by &lt;code&gt;FuncSpec&lt;/code&gt; and &lt;code&gt;ArgList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgList&lt;/code&gt; 인수를 사용하여 로컬이 아닌 함수 &lt;code&gt;FuncSpec&lt;/code&gt; ( &lt;code&gt;{Module,Func}&lt;/code&gt; 또는 fun)에 대한 호출이 허용되는지 여부를 판별하는 데 사용됩니다 . 리턴 값 &lt;code&gt;{redirect,NewFuncSpec,NewArgList}&lt;/code&gt; 를 사용하여 쉘이 &lt;code&gt;FuncSpec&lt;/code&gt; 및 &lt;code&gt;ArgList&lt;/code&gt; 로 지정된 함수 이외의 다른 함수를 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d65885f8646585ffb41393b4d943ab7b9e09ca48" translate="yes" xml:space="preserve">
          <source>This is used to determine if the call to the local function &lt;code&gt;Func&lt;/code&gt; with arguments &lt;code&gt;ArgList&lt;/code&gt; is to be allowed.</source>
          <target state="translated">&lt;code&gt;ArgList&lt;/code&gt; 인수 를 사용하여 로컬 함수 &lt;code&gt;Func&lt;/code&gt; 에 대한 호출 이 허용 되는지 여부를 판별하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4567b676fadac5a76d27950b200211f3a0074958" translate="yes" xml:space="preserve">
          <source>This just tests that the function &lt;code&gt;lists:reverse(List)&lt;/code&gt; does not crash when &lt;code&gt;List&lt;/code&gt; is &lt;code&gt;[1,2,3]&lt;/code&gt;. It is not a great test, but many people write simple functions like this one to test the basic functionality of their code, and those tests can be used directly by EUnit, without changes, as long as their function names match.</source>
          <target state="translated">이 단지 테스트 함수 것을 &lt;code&gt;lists:reverse(List)&lt;/code&gt; 때 충돌하지 않는 &lt;code&gt;List&lt;/code&gt; 있다 &lt;code&gt;[1,2,3]&lt;/code&gt; . 훌륭한 테스트는 아니지만 많은 사람들이 이와 같은 간단한 함수를 작성하여 코드의 기본 기능을 테스트하며, 함수 이름이 일치하는 한 변경없이 EUnit에서 직접 해당 테스트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9522c485cb7d376d5642accb7a321aad5a05ed" translate="yes" xml:space="preserve">
          <source>This kind of parenthesis &quot;locks up&quot; the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.</source>
          <target state="translated">이러한 종류의 괄호는 패턴이 일치하면 포함 된 패턴 부분을 &quot;고정&quot;하여 패턴에 대한 추가 실패가 역 추적되는 것을 방지합니다. 그러나 이전 항목으로 역 추적하면 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f0a2c7bf5aba6f668f53ccf49a4fb9c6251f30d9" translate="yes" xml:space="preserve">
          <source>This kind of transformation is useful when it is rare that an operand can be anything else but a register. In the case of &lt;code&gt;is_number/2&lt;/code&gt;, the second operand is always a register unless the compiler optimizations have been disabled.</source>
          <target state="translated">이러한 종류의 변환은 피연산자가 레지스터가 아닌 다른 것이 될 수있는 경우가 드문 경우에 유용합니다. &lt;code&gt;is_number/2&lt;/code&gt; 의 경우 컴파일러 최적화가 비활성화되지 않는 한 두 번째 피연산자는 항상 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="acbfa7bf9a0333e3f4da00679d91e91a638c7487" translate="yes" xml:space="preserve">
          <source>This last example is a quite common case in during normal operation. For example, when a scheduler thread runs out of work it tries to steal work from another scheduler threads run queue. When searching for a victim to steal from there was a lot of juggling of run queue locks involved, and during the actual theft finalized by having to lock both run queues and the process. When one scheduler runs out of work, often others also do, causing lots of lock contention.</source>
          <target state="translated">이 마지막 예는 정상 작동 중에 매우 일반적인 경우입니다. 예를 들어, 스케줄러 스레드가 작업을 다하면 다른 스케줄러 스레드 실행 큐에서 작업을 훔치려 고합니다. 훔칠 피해자를 검색 할 때 실행 대기열 잠금을 많이 저글링했으며 실제 도난 중에 실행 대기열과 프로세스를 모두 잠 가야했습니다. 한 스케줄러가 작동하지 않으면 다른 스케줄러도 작동하여 많은 잠금 경합이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="82013b529d675da98d4511e184ab7425bf09102f" translate="yes" xml:space="preserve">
          <source>This list is actually two - one for each direction server-to-client and client-to-server. Therefore it is possible but rare to have different algorithms in the two directions in one connection.</source>
          <target state="translated">이 목록은 실제로 서버 대 클라이언트와 클라이언트 대 서버에 대해 하나씩 두 개입니다. 따라서 한 연결에서 두 방향으로 다른 알고리즘을 갖는 것은 가능하지만 드물다.</target>
        </trans-unit>
        <trans-unit id="cc0444143c5a31fc19d9928f133e7fc40ea61901" translate="yes" xml:space="preserve">
          <source>This list is also divided into two for the both directions</source>
          <target state="translated">이 목록은 또한 양방향으로 두 가지로 나뉩니다</target>
        </trans-unit>
        <trans-unit id="b6fab8016bf79d1847d2c2ce6e88690dbf155eba" translate="yes" xml:space="preserve">
          <source>This list is not inspected by snmp (other then checking that its a list). Its the users responsibility to ensure that these are valid options and does not conflict with the &quot;normal&quot; options.</source>
          <target state="translated">이 목록은 snmp에 의해 검사되지 않습니다 (그렇지 않으면 목록이 있는지 확인). 이것이 유효한 옵션이고 &quot;일반&quot;옵션과 충돌하지 않는지 확인하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="4f65aaceb7dbec6b1fb6792cf70ed6c05f03495f" translate="yes" xml:space="preserve">
          <source>This list is subject to change at any time, as is the category any given lock may belong to.</source>
          <target state="translated">이 목록은 주어진 잠금이 속하는 범주와 마찬가지로 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8667cb466629d5430d9bcf4d289713494e360097" translate="yes" xml:space="preserve">
          <source>This macro can also be used for conditional compilation, but is more typically used to disable testing: If &lt;code&gt;NOTEST&lt;/code&gt; is defined &lt;strong&gt;before&lt;/strong&gt; the EUnit header file is included, and &lt;code&gt;TEST&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; defined, then the code will be compiled with EUnit disabled. See also &lt;code&gt;&lt;a href=&quot;#Disabling_testing&quot;&gt;Disabling testing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 매크로는 조건부 컴파일에도 사용할 수 있지만 일반적으로 테스트를 비활성화하는 데 사용됩니다 . EUnit 헤더 파일이 포함 &lt;strong&gt;되기 전에 &lt;/strong&gt; &lt;code&gt;NOTEST&lt;/code&gt; 가 정의 되고 &lt;code&gt;TEST&lt;/code&gt; 가 정의 &lt;strong&gt;되지 않은&lt;/strong&gt; 경우 코드가 EUnit 비활성화 된 상태로 컴파일됩니다. &lt;code&gt;&lt;a href=&quot;#Disabling_testing&quot;&gt;Disabling testing&lt;/a&gt;&lt;/code&gt; 참조하십시오 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cea55c428a4bdb4cf9d02f848100f0c0c617b095" translate="yes" xml:space="preserve">
          <source>This macro could be used like this in order to share code:</source>
          <target state="translated">이 매크로는 코드를 공유하기 위해 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5114889d9a6e68c62a0a1992ed05dd66a4ea6679" translate="yes" xml:space="preserve">
          <source>This macro is always defined (to &lt;code&gt;true&lt;/code&gt;, unless previously defined by the user to have another value) whenever EUnit is &lt;strong&gt;disabled&lt;/strong&gt; at compile time. (Compare the &lt;code&gt;TEST&lt;/code&gt; macro.)</source>
          <target state="translated">이 매크로는 컴파일시 EUnit이 &lt;strong&gt;비활성화&lt;/strong&gt; 될 때마다 항상 사용자가 다른 값을 갖도록 정의하지 않는 한 항상 &lt;code&gt;true&lt;/code&gt; 로 정의됩니다 . ( &lt;code&gt;TEST&lt;/code&gt; 매크로를 비교하십시오 .)&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ace903cd27c28d656c86413693b1c2b7cebb1c45" translate="yes" xml:space="preserve">
          <source>This macro is always defined (to &lt;code&gt;true&lt;/code&gt;, unless previously defined by the user to have another value) whenever EUnit is enabled at compile time. This can be used to place testing code within conditional compilation; see also the macros &lt;code&gt;NOTEST&lt;/code&gt; and &lt;code&gt;EUNIT&lt;/code&gt;.</source>
          <target state="translated">이 매크로는 컴파일시 EUnit이 활성화 될 때마다 항상 사용자가 다른 값을 갖도록 정의하지 않는 한 항상 &lt;code&gt;true&lt;/code&gt; 로 정의됩니다. 조건부 컴파일 내에 테스트 코드를 배치하는 데 사용할 수 있습니다. &lt;code&gt;NOTEST&lt;/code&gt; 및 &lt;code&gt;EUNIT&lt;/code&gt; 매크로도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce0e6792b17f6782871d2727d10c5675a63bdafd" translate="yes" xml:space="preserve">
          <source>This macro is always defined to &lt;code&gt;true&lt;/code&gt; whenever EUnit is enabled at compile time. This is typically used to place testing code within conditional compilation, as in:</source>
          <target state="translated">이 매크로는 컴파일시 EUnit이 활성화 될 때마다 항상 &lt;code&gt;true&lt;/code&gt; 로 정의됩니다 . 일반적으로 다음과 같이 조건부 컴파일 내에 테스트 코드를 배치하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9a17853871676c0efbbea7592f31b8e2c70ba24" translate="yes" xml:space="preserve">
          <source>This macro is useful in the setup and cleanup sections of fixtures, e.g., for creating and deleting files or perform similar operating system specific tasks, to make sure that the test system is informed of any failures.</source>
          <target state="translated">이 매크로는 테스트 시스템에 오류가 있는지 확인하기 위해 파일의 생성 및 삭제 또는 유사한 운영 체제 특정 작업을 수행하는 등 조명기의 설정 및 정리 섹션에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3e065ddbb311347232c6065a89455d54a53e02c6" translate="yes" xml:space="preserve">
          <source>This makes it possible to extend the protocol with optional requests and for the clients to be somewhat backward compatible.</source>
          <target state="translated">이를 통해 선택적 요청으로 프로토콜을 확장하고 클라이언트가 이전 버전과 다소 호환되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4d660f58a84c58c9d56e335532b3deb651bfa98" translate="yes" xml:space="preserve">
          <source>This makes the &lt;code&gt;gen_statem&lt;/code&gt; call callback function &lt;code&gt;terminate/3&lt;/code&gt; just like for a supervised server and waits for the process to terminate.</source>
          <target state="translated">이렇게하면 감독 서버와 마찬가지로 &lt;code&gt;gen_statem&lt;/code&gt; 호출 콜백 함수 &lt;code&gt;terminate/3&lt;/code&gt; 로 종료되고 프로세스가 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d7f81c6c5bf6cf515d1e9f111e538332017866ee" translate="yes" xml:space="preserve">
          <source>This makes the fragment independent of the parentheses in the larger pattern.</source>
          <target state="translated">이렇게하면 조각이 더 큰 패턴으로 괄호와 무관하게됩니다.</target>
        </trans-unit>
        <trans-unit id="49587f7146156380abd9cd71341e113bb523de56" translate="yes" xml:space="preserve">
          <source>This manual describes the &lt;code&gt;Event Tracer (ET)&lt;/code&gt; application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">이 매뉴얼 은 Erlang / Open Telecom Platform 개발 환경의 구성 요소로서 &lt;code&gt;Event Tracer (ET)&lt;/code&gt; 애플리케이션을 설명 합니다. 독자는 별도의 사용자 안내서에 설명되어있는 Erlang 개발 환경에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f54f98ecb63f059bc0f3f16893d00b0178de2ead" translate="yes" xml:space="preserve">
          <source>This manual describes the Megaco application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">이 매뉴얼은 Megaco 어플리케이션을 Erlang / Open Telecom Platform 개발 환경의 구성 요소로 설명합니다. 독자는 별도의 사용자 안내서에 설명되어있는 Erlang 개발 환경에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3565b9c0bcf6e9edf6874ed477820b3f0f6afff4" translate="yes" xml:space="preserve">
          <source>This manual describes the Reltool application, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">이 매뉴얼은 Reltool 애플리케이션을 Erlang / Open Telecom Platform 개발 환경의 구성 요소로 설명합니다. 독자는 별도의 사용자 안내서에 설명되어있는 Erlang 개발 환경에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="15184424397c18e9f422c74e5e74ac83b7f03ff2" translate="yes" xml:space="preserve">
          <source>This manual describes the SNMP development tool, as a component of the Erlang/Open Telecom Platform development environment. It is assumed that the reader is familiar with the Erlang Development Environment, which is described in a separate User's Guide.</source>
          <target state="translated">이 매뉴얼은 Erlang / Open Telecom Platform 개발 환경의 구성 요소로서 SNMP 개발 도구를 설명합니다. 독자는 별도의 사용자 안내서에 설명되어있는 Erlang 개발 환경에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="193220694d15266d7cc69378ef8f2e63c4cd4f53" translate="yes" xml:space="preserve">
          <source>This match specification can be specified as the last argument to &lt;code&gt;tp&lt;/code&gt; or &lt;code&gt;tpl&lt;/code&gt;. The activated &lt;code&gt;Item&lt;/code&gt; then becomes a &lt;strong&gt;trigger&lt;/strong&gt; for sequential tracing. This means that if the item is called on a process with trace flag &lt;code&gt;call&lt;/code&gt; set, the process is &quot;contaminated&quot; with token &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">이 일치 스펙은 &lt;code&gt;tp&lt;/code&gt; 또는 &lt;code&gt;tpl&lt;/code&gt; 의 마지막 인수로 지정할 수 있습니다 . 활성화 된 &lt;code&gt;Item&lt;/code&gt; 다음이된다 &lt;strong&gt;트리거&lt;/strong&gt; 순차적으로 추적합니다. 즉 , 추적 플래그 &lt;code&gt;call&lt;/code&gt; 설정된 프로세스에서 항목을 호출하면 &lt;code&gt;seq_trace&lt;/code&gt; 토큰으로 프로세스가 &quot;오염&quot;됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5770f3057dc3732a2c219c409191a4bcf36e051" translate="yes" xml:space="preserve">
          <source>This matches &quot;xxaab&quot; but not &quot;aacaab&quot;. It can be thought of as a kind of dynamic anchor, or &quot;I've started, so I must finish&quot;. The name of the most recently passed (*MARK) in the path is passed back when (*COMMIT) forces a match failure.</source>
          <target state="translated">&quot;xxaab&quot;와 일치하지만 &quot;aacaab&quot;와는 일치하지 않습니다. 그것은 일종의 역동적 인 앵커 또는 &quot;시작했습니다, 그래서 끝내야합니다&quot;라고 생각할 수 있습니다. 경로에서 가장 최근에 전달 된 (* MARK) 이름은 (* COMMIT)가 강제로 실패 할 때 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5a54f8d6fa87944f3859d8aacba8377d13f4ab03" translate="yes" xml:space="preserve">
          <source>This matches all characters that have the Unicode P (punctuation) property, plus those characters whose code points are less than 128 that have the S (Symbol) property.</source>
          <target state="translated">이것은 유니 코드 P (문장) 특성이있는 모든 문자와 코드 포인트가 128 미만인 문자 (S (기호) 특성이있는 문자)와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4060f37dc8e959716bd75592eaf33dbbe9422b23" translate="yes" xml:space="preserve">
          <source>This matches characters that have glyphs that mark the page when printed. In Unicode property terms, it matches all characters with the L, M, N, P, S, or Cf properties, except for:</source>
          <target state="translated">인쇄시 페이지를 표시하는 글리프가있는 문자와 일치합니다. 유니 코드 속성 용어에서는 다음을 제외하고 모든 문자를 L, M, N, P, S 또는 Cf 속성과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="80aa7005a5a9b662614697fc0718ba90f2d5eb3f" translate="yes" xml:space="preserve">
          <source>This matches the same characters as [:graph:] plus space characters that are not controls, that is, characters with the Zs property.</source>
          <target state="translated">이것은 [: graph :]와 동일한 문자와 제어되지 않는 공백 문자, 즉 Zs 속성을 가진 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="596241cc1fad7ba2b8c15f7e59f64a7ddc1befdd" translate="yes" xml:space="preserve">
          <source>This means that if there is more than one way to locate a group (and its test cases) in a path, the result of the group search operation is a number of tests, all of which are to be performed. &lt;code&gt;Common Test&lt;/code&gt; interprets a group specification that consists of a single name as follows:</source>
          <target state="translated">즉, 경로에서 그룹 (및 테스트 케이스)을 찾는 방법이 둘 이상인 경우 그룹 검색 조작의 결과는 여러 테스트이며 모두 수행해야합니다. &lt;code&gt;Common Test&lt;/code&gt; 는 단일 이름으로 구성된 그룹 스펙을 다음과 같이 해석합니다.</target>
        </trans-unit>
        <trans-unit id="22a98636e075cad89494908c0027932db4587e6e" translate="yes" xml:space="preserve">
          <source>This means that no bit higher than 31 can be set.</source>
          <target state="translated">이는 31보다 높은 비트를 설정할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="df996ca43fed811b9266d44d0025a342f366a979" translate="yes" xml:space="preserve">
          <source>This means that parameter values set in the other system configuration files and values set using &lt;code&gt;application:set_env/3&lt;/code&gt; are disregarded.</source>
          <target state="translated">이는 다른 시스템 구성 파일에 설정된 매개 변수 값과 &lt;code&gt;application:set_env/3&lt;/code&gt; 을 사용하여 설정된 값 은 무시 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="8f13bbc91d440e811da4676f3e7ca92ea54d9f50" translate="yes" xml:space="preserve">
          <source>This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM.</source>
          <target state="translated">이는이 옵션을 사용하여 한계를 낮추면 런 어웨이 정규식 일치가 더 빨리 실패 할 수 있음을 의미합니다. 기본값 10,000,000이 Erlang VM에 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="932d8129dcaf5494e901e2360eca271fe2d0ad88" translate="yes" xml:space="preserve">
          <source>This means that specifying another &lt;code&gt;.config&lt;/code&gt; file, or more &lt;code&gt;.config&lt;/code&gt; files, leads to inconsistent update of application configurations. There is, however, a syntax for &lt;code&gt;sys.config&lt;/code&gt; that allows pointing out other &lt;code&gt;.config&lt;/code&gt; files:</source>
          <target state="translated">즉 , 다른 &lt;code&gt;.config&lt;/code&gt; 파일 또는 더 많은 &lt;code&gt;.config&lt;/code&gt; 파일 을 지정 하면 응용 프로그램 구성이 일관되지 않게 업데이트됩니다. 그러나 다른 &lt;code&gt;.config&lt;/code&gt; 파일을 가리킬 수있는 &lt;code&gt;sys.config&lt;/code&gt; 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2200dc5ecc3e0975342e26ce8ac3610348c991da" translate="yes" xml:space="preserve">
          <source>This means that the application is preferably to be started at &lt;code&gt;cp1@cave&lt;/code&gt;. If &lt;code&gt;cp1@cave&lt;/code&gt; is down, the application is to be started at &lt;code&gt;cp2@cave&lt;/code&gt; or &lt;code&gt;cp3@cave&lt;/code&gt;.</source>
          <target state="translated">이것은 어플리케이션이 &lt;code&gt;cp1@cave&lt;/code&gt; 에서 시작되는 것이 바람직하다는 것을 의미합니다 . 경우 &lt;code&gt;cp1@cave&lt;/code&gt; 다운, 응용 프로그램에서 시작되도록 &lt;code&gt;cp2@cave&lt;/code&gt; 이나 &lt;code&gt;cp3@cave&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="106bb3bedaf49597cebe6d920a66bd4eef59b102" translate="yes" xml:space="preserve">
          <source>This means that the context (an opaque type) returned from streaming crypto functions (&lt;code&gt;hash_(init|update|final)&lt;/code&gt;, &lt;code&gt;hmac_(init|update|final)&lt;/code&gt; and &lt;code&gt;stream_(init|encrypt|decrypt)&lt;/code&gt;) is different and incompatible with regular builds when compiling crypto with FIPS support.</source>
          <target state="translated">이는 스트리밍 암호화 함수 ( &lt;code&gt;hash_(init|update|final)&lt;/code&gt; , &lt;code&gt;hmac_(init|update|final)&lt;/code&gt; 및 &lt;code&gt;stream_(init|encrypt|decrypt)&lt;/code&gt; ) 에서 리턴 된 컨텍스트 (불투명 한 유형 )가 다르고 일반 빌드와 호환되지 않음을 의미합니다. FIPS 지원으로 암호화를 컴파일 할 때.</target>
        </trans-unit>
        <trans-unit id="36077c72e710c444ae2797c20c5e8799b4acfa03" translate="yes" xml:space="preserve">
          <source>This means that the match specification is always a list of one or more tuples (of arity 3). The first element of the tuple is to be a pattern as described in &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;. The second element of the tuple is to be a list of 0 or more guard tests (described below). The third element of the tuple is to be a list containing a description of the value to return. In almost all normal cases, the list contains exactly one term that fully describes the value to return for each object.</source>
          <target state="translated">이는 일치 스펙이 항상 하나 이상의 튜플 (arity 3)의 목록임을 의미합니다. 튜플의 첫 번째 요소는 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 에 설명 된 패턴 입니다. 튜플의 두 번째 요소는 0 개 이상의 가드 테스트 목록입니다 (아래 설명 참조). 튜플의 세 번째 요소는 반환 할 값에 대한 설명이 포함 된 목록입니다. 거의 모든 일반적인 경우에 목록에는 각 객체에 대해 반환 할 값을 완전히 설명하는 용어가 정확히 하나만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f7aa9f1a915ce26bfe5ca3abc7eefe46479cfe4b" translate="yes" xml:space="preserve">
          <source>This means that when running, an included application is in fact part of the primary application, and a process in an included application considers itself belonging to the primary application.</source>
          <target state="translated">이는 실행시 포함 된 응용 프로그램이 실제로 기본 응용 프로그램의 일부이며 포함 된 응용 프로그램의 프로세스가 기본 응용 프로그램에 속하는 것으로 간주 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8c76b8edc5c31749772c3e7c79034a31599a007d" translate="yes" xml:space="preserve">
          <source>This mechanism causes the new versions of the emulator and core applications to run with the old version of other applications during startup. Thus, take extra care to avoid incompatibility. Incompatible changes in the core applications can in some situations be necessary. If possible, such changes are preceded by deprecation over two major releases before the actual change. To ensure the application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">이 메커니즘으로 인해 새 버전의 에뮬레이터와 핵심 응용 프로그램이 시작시 다른 응용 프로그램의 이전 버전과 함께 실행됩니다. 따라서 비 호환성을 피하기 위해 특별한주의를 기울이십시오. 일부 상황에서는 핵심 응용 프로그램의 호환되지 않는 변경이 필요할 수 있습니다. 가능한 경우 이러한 변경에 앞서 실제 변경 전에 두 개의 주요 릴리스에 대한 지원이 중단됩니다. 호환되지 않는 변경으로 인해 응용 프로그램이 중단되지 않도록하려면 가능한 빨리 사용되지 않는 기능에 대한 호출을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a72670e4d484ccee65dddc81403839166360c723" translate="yes" xml:space="preserve">
          <source>This mechanism is available with stateful session tickets. Session tickets can only be used once, subsequent use of the same ticket results in a full handshake. Stateful servers enforce this rule by maintaining a database of outstanding valid tickets.</source>
          <target state="translated">이 메커니즘은 상태 저장 세션 티켓과 함께 사용할 수 있습니다. 세션 티켓은 한 번만 사용할 수 있으며 이후에 동일한 티켓을 사용하면 완전한 핸드 셰이크가 발생합니다. 상태 저장 서버는 미해결 유효 티켓의 데이터베이스를 유지하여이 규칙을 시행합니다.</target>
        </trans-unit>
        <trans-unit id="afb636d25dca103bb579d81c3c480e31e05614f3" translate="yes" xml:space="preserve">
          <source>This mechanism is available with stateless session tickets. The server records a unique value derived from the ClientHello (PSK binder) in a given time window. The ticket's age is verified by using both the &quot;obsfuscated_ticket_age&quot; and an additional timestamp encrypted in the ticket data. As the used datastore allows false positives, apparent replays will be answered by doing a full 1-RTT handshake.</source>
          <target state="translated">이 메커니즘은 상태 비 저장 세션 티켓에서 사용할 수 있습니다. 서버는 주어진 시간 창에서 ClientHello (PSK 바인더)에서 파생 된 고유 한 값을 기록합니다. 티켓의 나이는 &quot;obsfuscated_ticket_age&quot;와 티켓 데이터에서 암호화 된 추가 타임 스탬프를 모두 사용하여 확인됩니다. 사용 된 데이터 저장소가 오 탐지를 허용하므로 전체 1-RTT 핸드 셰이크를 수행하여 명백한 재생에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="bc8bf1c9c18b4055ffc901b397bc2abd52dda424" translate="yes" xml:space="preserve">
          <source>This mechanism is available with the stateless session tickets. As the ticket data has an embedded timestamp, the server can determine if a ClientHello was sent reasonably recently and accept the 0-RTT handshake, otherwise if falls back to a full 1-RTT handshake. This mechanism is tightly coupled with the previous one, it prevents storing an unlimited number of ClientHellos.</source>
          <target state="translated">이 메커니즘은 상태 비 저장 세션 티켓에서 사용할 수 있습니다. 티켓 데이터에 포함 된 타임 스탬프가 있으므로 서버는 ClientHello가 합리적으로 최근에 전송되었는지 확인하고 0-RTT 핸드 셰이크를 수락 할 수 있습니다. 그렇지 않으면 전체 1-RTT 핸드 셰이크로 대체됩니다. 이 메커니즘은 이전 메커니즘과 밀접하게 결합되어 있으므로 ClientHello를 무제한으로 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3157f67a5eef33bc0f27dfb7ed55e0358006331" translate="yes" xml:space="preserve">
          <source>This message appears if &lt;code&gt;{ok, pending_driver}&lt;/code&gt; was returned from &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; for the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and then &lt;code&gt;{ok, already_loaded}&lt;/code&gt; is returned from a call to &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메시지 는 드라이버 의 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 가 리턴 된 후 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 에 대한 호출에서 &lt;code&gt;{ok, already_loaded}&lt;/code&gt; 가 리턴되는 경우에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="7443815abce9a78b8f12e9b4a8006f7ab0678558" translate="yes" xml:space="preserve">
          <source>This message arrives if reloading was underway but the loading for some reason failed. The &lt;code&gt;Failure&lt;/code&gt; term is one of the errors that can be returned from &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;. The error term can be passed to &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; for translation into human readable form. Notice that the translation must be done in the same running Erlang virtual machine as the error was detected in.</source>
          <target state="translated">다시로드가 진행 중이지만 어떤 이유로로드에 실패한 경우이 메시지가 나타납니다. &lt;code&gt;Failure&lt;/code&gt; 용어에서 리턴 될 수있는 오류 중 하나입니다 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; . 사람이 읽을 수있는 형태로 변환 하기 위해 오류 용어를 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 로 전달할 수 있습니다 . 오류가 감지 된 것과 동일한 실행중인 Erlang 가상 머신에서 변환을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1fd84b520be9e9ea3d84c401734e82ebe7eac97d" translate="yes" xml:space="preserve">
          <source>This message arrives if reloading was underway, but the requesting &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; cancelled it by dying or calling &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;unload/1&lt;/code&gt;/&lt;code&gt;unload_driver/1&lt;/code&gt;) again before it was reloaded.</source>
          <target state="translated">이 메시지는 다시로드가 진행중인 경우에 도착하지만 요청하는 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 는 다시로드하기 전에 &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;unload/1&lt;/code&gt; / &lt;code&gt;unload_driver/1&lt;/code&gt; )를 다시 호출하거나 호출하여 취소했습니다 .</target>
        </trans-unit>
        <trans-unit id="f4a65175ce43b7599632ccc7699bb308e42c19d5" translate="yes" xml:space="preserve">
          <source>This message format unfortunately differs slightly from the &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp&lt;/a&gt;&lt;/code&gt; message format with ancillary data, and from the &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; return tuple format.</source>
          <target state="translated">이 메시지 형식은 안타깝게도 보조 데이터 가있는 &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp&lt;/a&gt;&lt;/code&gt; 메시지 형식 및 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; 반환 튜플 형식 과 약간 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b2fc14d584e2b14f026925a19521a06f0dcdade4" translate="yes" xml:space="preserve">
          <source>This message indicates that the (asynchronous) operation has been aborted. If, for instance, the socket has been closed (by another process), &lt;code&gt;Info&lt;/code&gt; will be &lt;code&gt;{SelectRef, closed}&lt;/code&gt;.</source>
          <target state="translated">이 메시지는 (비동기) 작업이 중단되었음을 나타냅니다. 예를 들어 소켓이 닫혔다면 (다른 프로세스에 의해) &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;{SelectRef, closed}&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d6bd04f8e274c08cef04fc4e45d10c02182267ab" translate="yes" xml:space="preserve">
          <source>This message is only sent to a transport process over whose &lt;code&gt;Inband-Security-Id&lt;/code&gt; configuration has indicated support for TLS.</source>
          <target state="translated">이 메시지는 &lt;code&gt;Inband-Security-Id&lt;/code&gt; 구성이 TLS 지원을 나타내는 전송 프로세스로만 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9fe7d956f6a48c7301aa47c203d863f991af167" translate="yes" xml:space="preserve">
          <source>This message is sent either immediately if the driver is already loaded and no reloading is pending, or when reloading is executed if reloading is pending.</source>
          <target state="translated">이 메시지는 드라이버가 이미로드되어 있고 재로드가 보류되지 않은 경우 또는 재로드가 보류중인 경우 재로드가 실행될 때 즉시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b59c3f75f12fd3dcb8bfccc7fe935cad829ca36a" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent if it for some reason decided to discard the pdu.</source>
          <target state="translated">이 메시지는 어떤 이유로 pdu를 삭제하기로 결정한 경우 마스터 에이전트에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="829114beb9c3f31023ae657dbb8e8d0e25c1f282" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent when a request is to be sent. The only request an agent can send is Inform-Request. The net if process needs to remember the request id and the Pid, and when a response is received for the request id, send it to Pid, using a &lt;code&gt;snmp_response_received&lt;/code&gt; message.</source>
          <target state="translated">이 메시지는 요청이 전송 될 때 마스터 에이전트에서 전송됩니다. 상담원이 보낼 수있는 유일한 요청은 Inform-Request입니다. net if 프로세스는 요청 ID와 Pid를 기억해야하며 요청 ID에 대한 응답이 수신되면 &lt;code&gt;snmp_response_received&lt;/code&gt; 메시지를 사용하여 Pid로 요청을 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="e5f157b9c3b08af7fd2a99ceb91dfce727fcf26b" translate="yes" xml:space="preserve">
          <source>This message is sent from a master agent when a trap is to be sent.</source>
          <target state="translated">이 메시지는 트랩이 전송 될 때 마스터 에이전트에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d441c31108c7576d3cbad8491a4c4b23596427f8" translate="yes" xml:space="preserve">
          <source>This message is sent if reloading was expected, but the (old) driver made itself permanent before reloading. It is also sent if the driver was permanent or statically linked-in when trying to create the monitor.</source>
          <target state="translated">이 메시지는 다시로드가 필요한 경우에 전송되지만 다시로드하기 전에 (이전) 드라이버 자체가 영구적으로 만들어졌습니다. 모니터를 작성할 때 드라이버가 영구적이거나 정적으로 링크 된 경우에도 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9a7c62be17cb4236568289a04568a0ca14d646" translate="yes" xml:space="preserve">
          <source>This message is sent if unloading was expected, but the driver made itself permanent before unloading. It is also sent if trying to monitor a permanent or statically linked-in driver.</source>
          <target state="translated">언로드가 예상 된 경우이 메시지가 전송되지만 언로드하기 전에 드라이버가 영구적으로 만들어졌습니다. 영구적이거나 정적으로 링크 된 드라이버를 모니터하려고 할 때도 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="55cf023d178c69ab93cb5f5b6795668204cbf186" translate="yes" xml:space="preserve">
          <source>This message is sent if unloading was expected, but while the driver was waiting for all ports to get closed, a new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver appeared, and the unloading was cancelled.</source>
          <target state="translated">언로드가 예상 된 경우이 메시지가 전송되지만 드라이버가 모든 포트가 닫히기를 기다리는 동안 새 드라이버 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 나타나고 언로드가 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="dedc90e7f76a59946b54f6f05a80249175f6e9ab" translate="yes" xml:space="preserve">
          <source>This message is sent to the Net If process by a process that has been configured to perfor &quot;active supervision&quot; of the Net If process. The Net If process should respond immediately with a &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; message.</source>
          <target state="translated">이 메시지는 Net If 프로세스의 &quot;활성 감독&quot;을 수행하도록 구성된 프로세스에 의해 Net If 프로세스로 전송됩니다. Net If 프로세스는 &lt;code&gt;&lt;a href=&quot;#om_pong&quot;&gt;pong&lt;/a&gt;&lt;/code&gt; 메시지로 즉시 응답해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f4e7b699a7ae096287dd7808194507f6d50b3e91" translate="yes" xml:space="preserve">
          <source>This message is sent to the Net if process from a master agent as a response to a previously received request.</source>
          <target state="translated">이 메시지는 이전에 수신 된 요청에 대한 응답으로 마스터 에이전트의 프로세스 인 경우 Net으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9a28b745a2e2cc7649e2af78230f7339cfe78c45" translate="yes" xml:space="preserve">
          <source>This message is used by the release handler to find which processes that execute a certain module. The process can later be suspended and ordered to perform a code change for one of its modules.</source>
          <target state="translated">이 메시지는 릴리스 핸들러에서 특정 모듈을 실행하는 프로세스를 찾기 위해 사용됩니다. 프로세스는 나중에 중지되고 해당 모듈 중 하나에 대한 코드 변경을 수행하도록 명령 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="425958047f9810b0d871ee948d2497599b8d63d0" translate="yes" xml:space="preserve">
          <source>This message requests that the server starts execution of the given command. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메시지는 서버가 주어진 명령의 실행을 시작하도록 요청합니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4 &lt;/a&gt;&lt;/code&gt; 호출의 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="afd8dba6b75e3f001a723a1efc9d9ff4abf7b225" translate="yes" xml:space="preserve">
          <source>This message requests that the server starts execution of the given command. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메시지는 서버가 주어진 명령의 실행을 시작하도록 요청합니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#exec-4&quot;&gt;ssh_connection:exec/4&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="e80a2cab18ba8e56bb44cddb1d3f6a9bf9eb9c7d" translate="yes" xml:space="preserve">
          <source>This message requests that the user default shell is started at the other end. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt; ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메시지는 사용자 기본 쉘이 다른 쪽 끝에서 시작되도록 요청합니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt; ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt; 호출의 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="e505234f686d8ab1a451d96190a8bff8adf1ec9a" translate="yes" xml:space="preserve">
          <source>This message requests that the user default shell is started at the other end. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt;ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메시지는 다른 쪽 끝에서 사용자 기본 쉘을 시작하도록 요청합니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#shell-2&quot;&gt;ssh_connection:shell/2&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fc986c5547b793c1d6d354a196fdaa59d4a31d9" translate="yes" xml:space="preserve">
          <source>This mode can also be activated with flag &lt;code&gt;silent&lt;/code&gt; to &lt;code&gt;erlang:trace/3&lt;/code&gt;.</source>
          <target state="translated">이 모드는 플래그를 활성화 할 수 &lt;code&gt;silent&lt;/code&gt; 에 &lt;code&gt;erlang:trace/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a11330d6901fd7311c10340dd7bf642645e942b" translate="yes" xml:space="preserve">
          <source>This mode fits well when you have a regular state diagram, like the ones in this chapter, which describes all events and actions belonging to a state visually around that state, and each state has its unique name.</source>
          <target state="translated">이 모드는이 장에있는 것과 같은 일반 상태 다이어그램이있을 때 적합합니다.이 다이어그램은 해당 상태 주변의 상태에 속하는 모든 이벤트와 작업을 설명하며 각 상태는 고유 한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bb204752ab758821e61472ec417419d5f3d9971e" translate="yes" xml:space="preserve">
          <source>This mode is more or less a backward compatibility mode as from its introduction.</source>
          <target state="translated">이 모드는 처음부터 이전 버전과의 호환성 모드입니다.</target>
        </trans-unit>
        <trans-unit id="1fd3b3df65466b11a5eaf44e2aee1317b4d62efd" translate="yes" xml:space="preserve">
          <source>This mode works equally well when you want to focus on one event at the time or on one state at the time, but function &lt;code&gt; Module:handle_event/4 &lt;/code&gt; quickly grows too large to handle without branching to helper functions.</source>
          <target state="translated">이 모드는 한 번에 하나의 이벤트 또는 한 번에 한 상태에 초점을 맞추고 싶을 때 똑같이 잘 작동하지만 &lt;code&gt; Module:handle_event/4 &lt;/code&gt; 함수는 도우미 함수로 분기하지 않고 처리 할 수 ​​없을 정도로 빠르게 커집니다.</target>
        </trans-unit>
        <trans-unit id="172f14b940b1b2c6900b1372fa3316ca07a87e44" translate="yes" xml:space="preserve">
          <source>This mode works equally well when you want to focus on one event at the time or on one state at the time, but function &lt;code&gt;Module:handle_event/4&lt;/code&gt; quickly grows too large to handle without branching to helper functions.</source>
          <target state="translated">이 모드는 한 번에 하나의 이벤트 또는 한 번에 하나의 상태에만 집중하려고 할 때 동일하게 작동하지만 &lt;code&gt;Module:handle_event/4&lt;/code&gt; 분기하지 않고 처리 할 수 ​​있도록 Module : handle_event / 4 함수가 너무 빨리 커집니다.</target>
        </trans-unit>
        <trans-unit id="5fdef418c42eba77018e8e42460b63d278950bac" translate="yes" xml:space="preserve">
          <source>This model has only three different tables, and the employee records contain references to other records. The record has the following references:</source>
          <target state="translated">이 모델에는 세 개의 다른 테이블 만 있으며 직원 레코드에는 다른 레코드에 대한 참조가 포함됩니다. 레코드는 다음과 같은 참조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b3ce72021e00b147c9199fb77c9a3762a844a3df" translate="yes" xml:space="preserve">
          <source>This module also provides facilities for displaying status information about interpreted processes and break points.</source>
          <target state="translated">이 모듈은 해석 된 프로세스 및 중단 점에 대한 상태 정보를 표시하는 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="817190ceec75c6fa4d3197e4a1b86534327d94e7" translate="yes" xml:space="preserve">
          <source>This module also supports the following annotations, which are used by various modules:</source>
          <target state="translated">이 모듈은 또한 다양한 주석에서 사용되는 다음 주석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c1519372f968a7c83f80d29c6d04dbd62347e6bd" translate="yes" xml:space="preserve">
          <source>This module archives and extract files to and from a tar file. This module supports reading most common tar formats, namely v7, STAR, USTAR, and PAX, as well as some of GNU tar's extensions to the USTAR format (sparse files most notably). It produces tar archives in USTAR format, unless the files being archived require PAX format due to restrictions in USTAR (such as unicode metadata, filename length, and more). As such, &lt;code&gt;erl_tar&lt;/code&gt; supports tar archives produced by most all modern tar utilities, and produces tarballs which should be similarly portable.</source>
          <target state="translated">이 모듈은 tar 파일과 파일을 아카이브하고 추출합니다. 이 모듈은 v7, STAR, USTAR 및 PAX와 같은 가장 일반적인 tar 형식과 USTAR 형식에 대한 일부 GNU tar 확장 (가장 주목할만한 파일)을 읽을 수 있도록 지원합니다. 아카이브되는 파일에 USTAR 제한 사항 (예 : 유니 코드 메타 데이터, 파일 이름 길이 등)으로 인해 PAX 형식이 필요한 경우가 아니면 USTAR 형식의 tar 아카이브가 생성됩니다. 따라서 &lt;code&gt;erl_tar&lt;/code&gt; 는 대부분의 모든 최신 tar 유틸리티에서 생성 된 tar 아카이브를 지원하며 , 이식성이 뛰어난 tarball을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c93dc94853da5f65dd0f19dd1ea05a3d6a2b52f1" translate="yes" xml:space="preserve">
          <source>This module archives and extracts files to and from a zip archive. The zip format is specified by the &quot;ZIP Appnote.txt&quot; file, available on the PKWARE web site &lt;code&gt;&lt;a href=&quot;http://www.pkware.com&quot;&gt;www.pkware.com&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 zip 아카이브와 파일을 아카이브하고 추출합니다. zip 형식은 PKWARE 웹 사이트 &lt;code&gt;&lt;a href=&quot;http://www.pkware.com&quot;&gt;www.pkware.com&lt;/a&gt;&lt;/code&gt; 에있는 &quot;ZIP Appnote.txt&quot;파일로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ebed77e7881e24d9d50b032e03940e9bdf36b09" translate="yes" xml:space="preserve">
          <source>This module can also be found in the &lt;code&gt;examples&lt;/code&gt; directory of the SASL application.</source>
          <target state="translated">이 모듈은 SASL 응용 프로그램 의 &lt;code&gt;examples&lt;/code&gt; 디렉토리 에서도 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1aca0b6e822b7c6d0a2dee5904564049e299817d" translate="yes" xml:space="preserve">
          <source>This module can also be viewed as a behaviour for an application implemented according to the OTP design principles as a supervision tree. The definition of how to start and stop the tree is to be located in an &lt;strong&gt;application callback module&lt;/strong&gt;, exporting a predefined set of functions.</source>
          <target state="translated">이 모듈은 OTP 설계 원칙에 따라 감독 트리로 구현 된 응용 프로그램의 동작으로 볼 수도 있습니다. 트리를 시작하고 중지하는 방법에 대한 정의는 사전 정의 된 함수 세트를 내보내는 &lt;strong&gt;응용 프로그램 콜백 모듈&lt;/strong&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="46fe9ebbf441b09ed18ab05af78ee6b86682c8d6" translate="yes" xml:space="preserve">
          <source>This module can be used as follows:</source>
          <target state="translated">이 모듈은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64bd57a5a7fb8d785ba9c0f9a34dddc82e8e4902" translate="yes" xml:space="preserve">
          <source>This module can be used to render function and type documentation to be printed in a shell. It can only render EEP-48 documentation of the format &lt;code&gt;application/erlang+html&lt;/code&gt;. For more information about this format see &lt;code&gt;Documentation Storage&lt;/code&gt; in Erl_Docgen's User's Guide.</source>
          <target state="translated">이 모듈은 셸에서 인쇄 할 함수 및 유형 문서를 렌더링하는 데 사용할 수 있습니다. &lt;code&gt;application/erlang+html&lt;/code&gt; 형식의 EEP-48 문서 만 렌더링 할 수 있습니다 . 이 형식에 대한 자세한 내용은 Erl_Docgen 사용자 가이드의 &lt;code&gt;Documentation Storage&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="686c65b4a65c34ff9cf138f3076e44dd59452f8f" translate="yes" xml:space="preserve">
          <source>This module can be used to run a set of Erlang nodes as a pool of computational processors. It is organized as a master and a set of slave nodes and includes the following features:</source>
          <target state="translated">이 모듈은 Erlang 노드 세트를 계산 프로세서 풀로 실행하는 데 사용할 수 있습니다. 마스터 및 슬레이브 노드 세트로 구성되며 다음 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="534f04f7c34a17a45122c6b169fa5d57730b66cd" translate="yes" xml:space="preserve">
          <source>This module communicates with the EPMD daemon, see &lt;code&gt;epmd&lt;/code&gt;. To implement your own epmd module please see &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Node Discovery for Erlang Distribution&lt;/code&gt;</source>
          <target state="translated">이 모듈은 EPMD 데몬과 통신합니다 . &lt;code&gt;epmd&lt;/code&gt; 를 참조하십시오 . 자신의 epmd 모듈을 구현하려면 &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Node Discovery for Erlang Distribution&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af82f371bff5810258c512bac2aa2370e799470c" translate="yes" xml:space="preserve">
          <source>This module communicates with the EPMD daemon, see &lt;code&gt;epmd&lt;/code&gt;. To implement your own epmd module please see &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Service Discovery for Erlang Distribution&lt;/code&gt;</source>
          <target state="translated">이 모듈은 EPMD 데몬과 통신합니다 ( &lt;code&gt;epmd&lt;/code&gt; 참조) . 자체 epmd 모듈을 구현하려면 &lt;code&gt;ERTS User's Guide: How to Implement an Alternative Service Discovery for Erlang Distribution&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b4ce3dec0f26e77853815afd7b3cb63b31d970f" translate="yes" xml:space="preserve">
          <source>This module considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 두 요소가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교되지 않는 경우에만 다른 것으로 간주 합니다.</target>
        </trans-unit>
        <trans-unit id="0be9d79105e371fa97debd95b84b58219b4279ea" translate="yes" xml:space="preserve">
          <source>This module considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 두 키가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교하지 않는 경우에만 두 개의 키를 다르게 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="f7838291047ac4d60e0139ec156a7e643ad4faaa" translate="yes" xml:space="preserve">
          <source>This module consists of the following services:</source>
          <target state="translated">이 모듈은 다음 서비스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ff598a317fac529d717bd1f848d0ec9eaa2f5e61" translate="yes" xml:space="preserve">
          <source>This module contains functions for converting between different character representations. It converts between ISO Latin-1 characters and Unicode characters, but it can also convert between different Unicode encodings (like UTF-8, UTF-16, and UTF-32).</source>
          <target state="translated">이 모듈에는 다른 문자 표현을 변환하는 기능이 포함되어 있습니다. ISO Latin-1 문자와 유니 코드 문자 사이를 변환하지만 UTF-8, UTF-16 및 UTF-32와 같은 다른 유니 코드 인코딩 사이에서도 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5b9240d86d995a89ac9eb37eda08d6f1ac2c51e" translate="yes" xml:space="preserve">
          <source>This module contains functions for converting to and from strings (lists of characters). They are used for implementing the functions in the &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; module. There is no guarantee that the character lists returned from some of the functions are flat, they can be deep lists. Function &lt;code&gt;&lt;a href=&quot;lists#flatten-1&quot;&gt;lists:flatten/1&lt;/a&gt;&lt;/code&gt; can be used for flattening deep lists.</source>
          <target state="translated">이 모듈에는 문자열 (문자 목록)과의 변환 기능이 포함되어 있습니다. 그것들은 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; 모듈 에서 기능을 구현하는 데 사용됩니다 . 일부 함수에서 반환 된 문자 목록이 단순하다는 보장은 없으며 딥 목록 일 수 있습니다. 기능 &lt;code&gt;&lt;a href=&quot;lists#flatten-1&quot;&gt;lists:flatten/1&lt;/a&gt;&lt;/code&gt; 은 딥 목록을 병합하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="837f779fb53a71d0c4ae19998076438feb1919ac" translate="yes" xml:space="preserve">
          <source>This module contains functions for encoding Erlang terms into a sequence of bytes, and for decoding Erlang terms from a sequence of bytes.</source>
          <target state="translated">이 모듈에는 Erlang 용어를 바이트 시퀀스로 인코딩하고 Erlang 용어를 바이트 시퀀스에서 디코딩하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="de911f7e348fe07047fba5ab0f536e33890e3df9" translate="yes" xml:space="preserve">
          <source>This module contains functions for inserting comments, described by position, indentation and text, as attachments on an abstract syntax tree, at the correct places.</source>
          <target state="translated">이 모듈에는 위치, 들여 쓰기 및 텍스트로 설명 된 주석을 올바른 위치에 추상 구문 트리에 첨부하여 삽입하는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59032641754c334d2119d69e35fd6099ad62842c" translate="yes" xml:space="preserve">
          <source>This module contains functions for list processing.</source>
          <target state="translated">이 모듈에는 목록 처리 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="81e43c82257cd393c01258396233b38bac085577" translate="yes" xml:space="preserve">
          <source>This module contains functions for manipulating byte-oriented binaries. Although the majority of functions could be provided using bit-syntax, the functions in this library are highly optimized and are expected to either execute faster or consume less memory, or both, than a counterpart written in pure Erlang.</source>
          <target state="translated">이 모듈에는 바이트 지향 바이너리를 조작하는 기능이 포함되어 있습니다. 비트 구문을 사용하여 대부분의 기능을 제공 할 수 있지만이 라이브러리의 기능은 고도로 최적화되어 있으며 순수한 Erlang으로 작성된 기능보다 더 빠르게 실행하거나 더 적은 메모리를 사용하거나 둘 다 사용할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="50ccc7ec1143773aaedcc8657aa657008607be3a" translate="yes" xml:space="preserve">
          <source>This module contains functions for maps processing.</source>
          <target state="translated">이 모듈에는 맵 처리 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="50f0b83fe2516bf67a941d2bd6474f61aeee90ee" translate="yes" xml:space="preserve">
          <source>This module contains functions for parsing and handling URIs (&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;) and form-urlencoded query strings (&lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 모듈에는 URI 구문 분석 및 처리 ( &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; ) 및 양식 인코딩 된 쿼리 문자열 ( &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; )에 대한 기능이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca7843662571b136297297d4631b70479e539fd0" translate="yes" xml:space="preserve">
          <source>This module contains functions for sending system messages used by programs, and messages used for debugging purposes.</source>
          <target state="translated">이 모듈에는 프로그램에서 사용하는 시스템 메시지를 전송하는 기능과 디버깅 목적으로 사용되는 메시지가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="49fe7206d616c14253dcbc198d4a64077934564a" translate="yes" xml:space="preserve">
          <source>This module contains functions for sorting terms on files, merging already sorted files, and checking files for sortedness. Chunks containing binary terms are read from a sequence of files, sorted internally in memory and written on temporary files, which are merged producing one sorted file as output. Merging is provided as an optimization; it is faster when the files are already sorted, but it always works to sort instead of merge.</source>
          <target state="translated">이 모듈에는 파일에서 용어를 정렬하고, 이미 정렬 된 파일을 병합하고, 정렬을 위해 파일을 검사하는 기능이 있습니다. 이진 용어를 포함하는 청크는 일련의 파일에서 읽은 다음 내부적으로 메모리에 정렬되어 임시 파일에 기록됩니다.이 파일은 병합되어 하나의 정렬 된 파일을 출력으로 생성합니다. 병합은 최적화로 제공됩니다. 파일이 이미 정렬되어 있으면 빠르지 만 병합 대신 항상 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5326d602d1276804a6e5daef142fc199cc00ce06" translate="yes" xml:space="preserve">
          <source>This module contains functions for tokenizing (scanning) characters into Erlang tokens.</source>
          <target state="translated">이 모듈에는 문자를 Erlang 토큰으로 토큰 화 (스캔)하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="994f1f991d1dfea12bae127e267a7c21607503f3" translate="yes" xml:space="preserve">
          <source>This module contains functions to generate boot scripts (&lt;code&gt;.boot&lt;/code&gt;, &lt;code&gt;.script&lt;/code&gt;), a release upgrade file (&lt;code&gt;relup&lt;/code&gt;), and release packages.</source>
          <target state="translated">이 모듈에는 부트 스크립트 ( &lt;code&gt;.boot&lt;/code&gt; , &lt;code&gt;.script&lt;/code&gt; ), 릴리스 업그레이드 파일 ( &lt;code&gt;relup&lt;/code&gt; ) 및 릴리스 패키지 를 생성하는 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfb41f0bba62101238346d92d97629a2935e3299" translate="yes" xml:space="preserve">
          <source>This module contains interface functions for the SSL/TLS/DTLS protocol. For detailed information about the supported standards see &lt;code&gt;ssl(6)&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는 SSL / TLS / DTLS 프로토콜에 대한 인터페이스 기능이 포함되어 있습니다. 지원되는 표준에 대한 자세한 내용은 &lt;code&gt;ssl(6)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e018edcfc853c04e93bf82d4c3548bfbe011ff7" translate="yes" xml:space="preserve">
          <source>This module contains interface functions for the TLS/DTLS protocol. For detailed information about the supported standards see &lt;code&gt;ssl(6)&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는 TLS / DTLS 프로토콜에 대한 인터페이스 기능이 포함되어 있습니다. 지원되는 표준에 대한 자세한 내용은 &lt;code&gt;ssl(6)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb4c286324503fe5462bf11f1a2d003718ad9829" translate="yes" xml:space="preserve">
          <source>This module contains regular expression matching functions for strings and binaries.</source>
          <target state="translated">이 모듈에는 문자열 및 이진에 대한 정규식 일치 함수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef53274b9322e757bb4063af4f3183c6e84d40a8" translate="yes" xml:space="preserve">
          <source>This module contains services similar to Remote Procedure Calls. It also contains broadcast facilities and parallel evaluators. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node.</source>
          <target state="translated">이 모듈에는 원격 프로 시저 호출과 유사한 서비스가 포함되어 있습니다. 또한 방송 기능과 병렬 평가 기가 포함되어 있습니다. 원격 프로 시저 호출은 원격 노드에서 함수를 호출하고 응답을 수집하는 방법입니다. 원격 노드에서 정보를 수집하거나 원격 노드에서 특정 부작용이있는 기능을 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d58b9a536ce590d194f2de76046ad6eb75d92d75" translate="yes" xml:space="preserve">
          <source>This module contains some error printing routines taken from &quot;Advanced Programming in the UNIX Environment&quot; by W. Richard Stevens.</source>
          <target state="translated">이 모듈에는 W. Richard Stevens의 &quot;UNIX 환경의 고급 프로그래밍&quot;에서 가져온 오류 인쇄 루틴이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4648e09f07ca512b563c45755d232665770d52a" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the Erlang &lt;strong&gt;code server&lt;/strong&gt;, which deals with the loading of compiled code into a running Erlang runtime system.</source>
          <target state="translated">이 모듈에는 실행중인 Erlang 런타임 시스템으로 컴파일 된 코드로드를 처리 하는 Erlang &lt;strong&gt;코드 서버에&lt;/strong&gt; 대한 인터페이스가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f512252f459f62899c4ec02d14e4f592e80d6fd9" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the TPKT (TCP/IP) version transport protocol for Megaco/H.248.</source>
          <target state="translated">이 모듈에는 Megaco / H.248 용 TPKT (TCP / IP) 버전 전송 프로토콜에 대한 공용 인터페이스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64245c6a67eefbaeb52b73410ca5898d27decb3" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the UDP/IP version transport protocol for Megaco/H.248.</source>
          <target state="translated">이 모듈에는 Megaco / H.248 용 UDP / IP 버전 전송 프로토콜에 대한 공용 인터페이스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c49b48d28a03a73e07c75bceac59af417062b9" translate="yes" xml:space="preserve">
          <source>This module contains the public interface to the flex scanner linked in driver. The flex scanner performs the scanning phase of text message decoding.</source>
          <target state="translated">이 모듈에는 드라이버에 연결된 플렉스 스캐너에 대한 공용 인터페이스가 포함되어 있습니다. 플렉스 스캐너는 문자 메시지 디코딩의 스캔 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="028411a6308d39aee0db1a739a433763a7fa1e96" translate="yes" xml:space="preserve">
          <source>This module contains two routines: one general function for creating Erlang terms and one for pattern matching Erlang terms.</source>
          <target state="translated">이 모듈에는 두 가지 루틴이 있습니다. 하나는 Erlang 용어를 작성하기위한 일반 함수와 하나는 Erlang 용어를 패턴 일치시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43a0c1ee918b2bf11b8612b0b536425a9de08920" translate="yes" xml:space="preserve">
          <source>This module contains utilities on a higher level than the &lt;code&gt;file&lt;/code&gt; module.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;file&lt;/code&gt; 모듈 보다 높은 수준의 유틸리티가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="573d1a53ea7dfdc3e3251968a013dc54e7ff9915" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for easier measurement and calculation of scheduler utilization, otherwise obtained from calling the more primitive &lt;code&gt; statistics(scheduler_wall_time)&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는보다 원시적 인 &lt;code&gt; statistics(scheduler_wall_time)&lt;/code&gt; 를 호출하여 얻은 스케줄러 사용률을보다 쉽게 ​​측정하고 계산할 수있는 유틸리티 함수가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75ca3e4fb9bfa2cb08015503e443bec03d7d012f" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for easier measurement and calculation of scheduler utilization, otherwise obtained from calling the more primitive &lt;code&gt;statistics(scheduler_wall_time)&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 그렇지 않은 원시적 호출에서 얻은 쉽게 측정 및 스케줄러 활용의 계산을위한 유틸리티 함수가 포함되어 &lt;code&gt;statistics(scheduler_wall_time)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8466a816803c9602c9c5da297825fe2d8738a12f" translate="yes" xml:space="preserve">
          <source>This module contains utility functions for working with the abstract data type defined in the module &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 모듈에 정의 된 추상 데이터 유형으로 작업하기위한 유틸리티 함수가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6db7bd57b934dc58f231a5b9efdb7c6ce8fb29e8" translate="yes" xml:space="preserve">
          <source>This module contains various network utility functions.</source>
          <target state="translated">이 모듈에는 다양한 네트워크 유틸리티 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d60840cdb8394c4bebe2baf925c2e4db6023faa" translate="yes" xml:space="preserve">
          <source>This module controls that the conditions in the requests are fulfilled. For example, a request can specify that the answer only is of interest if the content is unchanged since the last retrieval. If the content is changed, the range request is to be converted to a request for the whole file instead.</source>
          <target state="translated">이 모듈은 요청의 조건이 충족되도록 제어합니다. 예를 들어 요청은 마지막 검색 이후 내용이 변경되지 않은 경우에만 답변에 관심이 있음을 지정할 수 있습니다. 내용이 변경되면 범위 요청이 대신 전체 파일에 대한 요청으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="fe422acfcd694c2630daf21b44a7f9f2a2d5de80" translate="yes" xml:space="preserve">
          <source>This module deals with the composition and decomposition of &lt;strong&gt;syntactic&lt;/strong&gt; entities (as opposed to semantic ones); its purpose is to hide all direct references to the data structures used to represent these entities. With few exceptions, the functions in this module perform no semantic interpretation of their inputs, and in general, the user is assumed to pass type-correct arguments - if this is not done, the effects are not defined.</source>
          <target state="translated">이 모듈은 (시맨틱 한 것과는 대조적으로) &lt;strong&gt;구문 론적&lt;/strong&gt; 엔티티 의 구성과 분해를 다룬다 . 그 목적은 이러한 엔티티를 나타내는 데 사용되는 데이터 구조에 대한 모든 직접 참조를 숨기는 것입니다. 몇 가지 예외를 제외하고이 모듈의 함수는 입력에 대한 의미 해석을 수행하지 않으며 일반적으로 사용자는 유형이 올바른 인수를 전달한다고 가정합니다.이를 수행하지 않으면 효과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfa2f96a0a3bfeb4a366115418ce75043dff5047" translate="yes" xml:space="preserve">
          <source>This module defines Erlang BIFs, guard tests, and operators. This module is only of interest to programmers who manipulate Erlang code.</source>
          <target state="translated">이 모듈은 Erlang BIF, 가드 테스트 및 연산자를 정의합니다. 이 모듈은 Erlang 코드를 조작하는 프로그래머에게만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b03bc08e3947730353e9a2f08b1653a85fdf21af" translate="yes" xml:space="preserve">
          <source>This module defines a callback behavior for user-defined hash functions of fragmented tables.</source>
          <target state="translated">이 모듈은 조각난 테이블의 사용자 정의 해시 함수에 대한 콜백 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7910088bd4b8dc833f45c393721faa0c8e4f3457" translate="yes" xml:space="preserve">
          <source>This module defines a callback handler for the communication with an &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-miller-ssh-agent-02&quot;&gt;SSH Agent&lt;/a&gt;&lt;/code&gt; and can be used to replace the &lt;code&gt;default callback&lt;/code&gt;. This allows to issue signing requests to an agent that stores SSH private keys to perform authentication.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-miller-ssh-agent-02&quot;&gt;SSH Agent&lt;/a&gt;&lt;/code&gt; 와 의 통신을위한 콜백 핸들러를 정의하며 &lt;code&gt;default callback&lt;/code&gt; 을 대체하는 데 사용할 수 있습니다 . 이를 통해 인증을 수행하기 위해 SSH 개인 키를 저장하는 에이전트에 서명 요청을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="161d77445ffa506093b357c536b61e4224bc87e7" translate="yes" xml:space="preserve">
          <source>This module defines an abstract data type for representing Core Erlang source code as syntax trees.</source>
          <target state="translated">이 모듈은 Core Erlang 소스 코드를 구문 트리로 표현하기위한 추상 데이터 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="76441fb4ee13017766943030861f4ce7688ed9bd" translate="yes" xml:space="preserve">
          <source>This module defines an abstract data type for representing Erlang source code as syntax trees, in a way that is backwards compatible with the data structures created by the Erlang standard library parser module &lt;code&gt;erl_parse&lt;/code&gt; (often referred to as &quot;parse trees&quot;, which is a bit of a misnomer). This means that all &lt;code&gt;erl_parse&lt;/code&gt; trees are valid abstract syntax trees, but the reverse is not true: abstract syntax trees can in general not be used as input to functions expecting an &lt;code&gt;erl_parse&lt;/code&gt; tree. However, as long as an abstract syntax tree represents a correct Erlang program, the function &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; should be able to transform it to the corresponding &lt;code&gt;erl_parse&lt;/code&gt; representation.</source>
          <target state="translated">이 모듈은 Erlang 표준 라이브러리 구문 분석기 모듈 &lt;code&gt;erl_parse&lt;/code&gt; (종종 &quot;파싱 트리&quot;라고 함)에 의해 작성된 데이터 구조와 역 호환되는 방식으로 Erlang 소스 코드를 구문 트리로 표시하기위한 추상 데이터 유형을 정의합니다. 잘못된 이름). 이것은 모든 &lt;code&gt;erl_parse&lt;/code&gt; 트리가 유효한 추상 구문 트리이지만 그 반대는 사실이 아닙니다. 추상 구문 트리는 일반적으로 &lt;code&gt;erl_parse&lt;/code&gt; 트리를 예상하는 함수의 입력으로 사용할 수 없습니다 . 그러나 추상 구문 트리가 올바른 Erlang 프로그램을 나타내는 한, &lt;code&gt;&lt;a href=&quot;#revert-1&quot;&gt;revert/1&lt;/a&gt;&lt;/code&gt; 함수 는이를 해당 &lt;code&gt;erl_parse&lt;/code&gt; 표현 으로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e69c1a93aecab552763a38625c306d9fb09103f6" translate="yes" xml:space="preserve">
          <source>This module defines the Erlang Server Interface (ESI) API. It is a more efficient way of writing Erlang scripts for your &lt;code&gt;Inets&lt;/code&gt; web server than writing them as common CGI scripts.</source>
          <target state="translated">이 모듈은 Erlang 서버 인터페이스 (ESI) API를 정의합니다. 일반적인 CGI 스크립트로 작성하는 것보다 &lt;code&gt;Inets&lt;/code&gt; 웹 서버용 Erlang 스크립트를 작성하는 것이보다 효율적인 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="392313e4002a7778328cfb59fce4c77f8c1952d5" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the SNMP agent mib storage.</source>
          <target state="translated">이 모듈은 SNMP 에이전트 mib 스토리지의 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7eff1b562e4fe0566ee0da7f6a9daaa2439e2f8b" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the SNMP agent mib-server data module. A &lt;code&gt;snmpa_mib_data&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 SNMP 에이전트 mib-server 데이터 모듈의 동작을 정의합니다. &lt;code&gt;snmpa_mib_data&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="b0d76e366c3f9dcdfb5f12def1540b4e052163ce" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent discovery handler. A &lt;code&gt;snmpa_discovery_handler&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 에이전트 발견 핸들러의 작동을 정의합니다. &lt;code&gt;snmpa_discovery_handler&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="e43530aefc8fe67ce3e1a2b7e5683063982513d3" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent error reporting. A &lt;code&gt;snmpa_error_report&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 에이전트 오류보고의 동작을 정의합니다. &lt;code&gt;snmpa_error_report&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="d81fb92749352083b3ab6bc64e61e21bf25c9749" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent network interface filter. A &lt;code&gt;snmpa_network_interface_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 에이전트 네트워크 인터페이스 필터의 동작을 정의합니다. &lt;code&gt;snmpa_network_interface_filter&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="5412a13932b854a89270a84f2ceaaa33588e1121" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent network interface. A &lt;code&gt;snmpa_network_interface&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 에이전트 네트워크 인터페이스의 동작을 정의합니다. &lt;code&gt;snmpa_network_interface&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="3c921e60f1fd55471b897ea29e000de7226f0bb1" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the agent notification filters. A &lt;code&gt;snmpa_notification_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 에이전트 알림 필터의 동작을 정의합니다. &lt;code&gt;snmpa_notification_filter&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="8c813e504362483e091dd45b65c32a63841d6a1d" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager network interface filter. A &lt;code&gt;snmpm_network_interface_filter&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 관리자 네트워크 인터페이스 필터의 동작을 정의합니다. &lt;code&gt;snmpm_network_interface_filter&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="1efae6ac4d1c40501e88954337a2c493e68e0103" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager network interface. A &lt;code&gt;snmpm_network_interface&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 관리자 네트워크 인터페이스의 동작을 정의합니다. &lt;code&gt;snmpm_network_interface&lt;/code&gt; 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="70cf854e5d6063f7072b44e1cece8ac9b81a70b7" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the manager user. A &lt;code&gt;snmpm_user&lt;/code&gt; compliant module must export the following functions:</source>
          <target state="translated">이 모듈은 관리자 사용자의 동작을 정의합니다. &lt;code&gt;snmpm_user&lt;/code&gt; 의 준수 모듈은 다음과 같은 기능을 내 보내야합니다 :</target>
        </trans-unit>
        <trans-unit id="468ccfe9ae0121bf6da5c3aaba9a0e4a3f14050d" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour of the notification delivery information receiver.</source>
          <target state="translated">이 모듈은 알림 전달 정보 수신자의 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="118517391ac279d58d25f1693b404c970b02d3e5" translate="yes" xml:space="preserve">
          <source>This module defines the callback behaviour of Megaco users. A megaco_user compliant callback module must export the following functions:</source>
          <target state="translated">이 모듈은 Megaco 사용자의 콜백 동작을 정의합니다. megaco_user 호환 콜백 모듈은 다음 기능을 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="4c8aaa7d34274a9f4bb7dc956dc47a8e7e1445eb" translate="yes" xml:space="preserve">
          <source>This module defines what happens when certain types of errors occur.</source>
          <target state="translated">이 모듈은 특정 유형의 오류가 발생할 때 발생하는 상황을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5ffa259dadc9ae103670240a5de8cb07d4a0a997" translate="yes" xml:space="preserve">
          <source>This module does not support &quot;raw&quot; filenames (that is, files whose names do not comply with the expected encoding). Such files are ignored by the functions in this module.</source>
          <target state="translated">이 모듈은 &quot;원시&quot;파일 이름 (즉, 이름이 예상 인코딩과 일치하지 않는 파일)을 지원하지 않습니다. 이러한 파일은이 모듈의 기능에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d6653760221ddc3d83e211cede6e8be096bb7928" translate="yes" xml:space="preserve">
          <source>This module enables C-programs to communicate with Erlang nodes, using the Erlang distribution over TCP/IP.</source>
          <target state="translated">이 모듈을 사용하면 C 프로그램이 TCP / IP를 통한 Erlang 배포를 사용하여 Erlang 노드와 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="263e76116a98bb1fd881761f209bf1ba1fce107d" translate="yes" xml:space="preserve">
          <source>This module enables users to enter the short form of some commonly used commands.</source>
          <target state="translated">이 모듈을 사용하면 일반적으로 사용되는 일부 명령의 짧은 형식을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3343ff3168dd5f14d02286d39c2ac78ec614ecd9" translate="yes" xml:space="preserve">
          <source>This module expands records in a module.</source>
          <target state="translated">이 모듈은 모듈에서 레코드를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="a3732061720e8ab1db0a300e706fb90768269889" translate="yes" xml:space="preserve">
          <source>This module exports functions for running &lt;code&gt;Common Test&lt;/code&gt; nodes on multiple hosts in parallel.</source>
          <target state="translated">이 모듈 은 여러 호스트에서 &lt;code&gt;Common Test&lt;/code&gt; 노드 를 실행하기위한 기능을 병렬로 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="0503901901ce52a8d8d522c2fc6e6ad11e2ed29f" translate="yes" xml:space="preserve">
          <source>This module exports functions used by the &lt;code&gt;Common Test&lt;/code&gt; Master to start and stop &quot;slave&quot; nodes. It is the default callback module for the &lt;code&gt;{init, node_start}&lt;/code&gt; term in the Test Specification.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Common Test&lt;/code&gt; 마스터가 &quot;슬레이브&quot;노드를 시작 및 중지하기 위해 사용하는 기능을 내 보냅니다 . 테스트 스펙에서 &lt;code&gt;{init, node_start}&lt;/code&gt; 용어 의 기본 콜백 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="5c1c8fa2fdb9c360a27bfb55873d503a480bf994" translate="yes" xml:space="preserve">
          <source>This module exports help functions for parsing of test specifications.</source>
          <target state="translated">이 모듈은 테스트 사양 구문 분석을위한 도움말 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a7e44b5175c847fa8191a306063c634fed83971d" translate="yes" xml:space="preserve">
          <source>This module exports help functions for performing code coverage analysis.</source>
          <target state="translated">이 모듈은 코드 범위 분석을 수행하기위한 도움말 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="eb5bfcc59cc41439eaa702f52ecbd01d0b73eb7d" translate="yes" xml:space="preserve">
          <source>This module generates an HTML directory listing (Apache-style) if a client sends a request for a directory instead of a file. This module must be removed from the Modules config directive if directory listings is unwanted.</source>
          <target state="translated">이 모듈은 클라이언트가 파일 대신 디렉토리에 대한 요청을 보내는 경우 HTML 디렉토리 목록 (아파치 스타일)을 생성합니다. 디렉토리 목록을 원하지 않는 경우이 모듈을 모듈 구성 지시문에서 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="ebf8cc7dad040f1beca78868efd260f249334a6e" translate="yes" xml:space="preserve">
          <source>This module handles invoking of CGI scripts.</source>
          <target state="translated">이 모듈은 CGI 스크립트의 호출을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="474f6eb9d78d082e8b16b40b4a1c3de1a0cc963c" translate="yes" xml:space="preserve">
          <source>This module has been deprecated and will be removed in a furture release.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않으며 furture 릴리스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4ead8db89a63c65e38113715680218a6fa71339b" translate="yes" xml:space="preserve">
          <source>This module has been reworked in Erlang/OTP 20 to handle &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; and operate on grapheme clusters. The &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt; old functions&lt;/a&gt;&lt;/code&gt; that only work on Latin-1 lists as input are still available but should not be used, they will be deprecated in a future release.</source>
          <target state="translated">이 모듈은 Erlang / OTP 20에서 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; 를 처리 하고 grapheme 클러스터에서 작동 하도록 재 작업되었습니다 . 입력으로 Latin-1 목록에서만 작동 하는 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt; old functions&lt;/a&gt;&lt;/code&gt; 은 여전히 ​​사용할 수 있지만 사용해서는 안되며 향후 릴리스에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20277e2186104d73a70c009c74886d168752fafa" translate="yes" xml:space="preserve">
          <source>This module has been reworked in Erlang/OTP 20 to handle &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; and operate on grapheme clusters. The &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;old functions&lt;/a&gt;&lt;/code&gt; that only work on Latin-1 lists as input are still available but should not be used, they will be deprecated in a future release.</source>
          <target state="translated">이 모듈은 Erlang / OTP 20에서 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 를 처리 하고 grapheme 클러스터에서 작동 하도록 재 작업되었습니다 . Latin-1 목록에서만 입력으로 작동 하는 &lt;code&gt;&lt;a href=&quot;#oldapi&quot;&gt;old functions&lt;/a&gt;&lt;/code&gt; 은 계속 사용할 수 있지만 사용해서는 안되며, 향후 릴리스에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e92193f0e2766adbb07bff2f6dfb2e47b5b38666" translate="yes" xml:space="preserve">
          <source>This module has three sets of interface functions: the &quot;Original API&quot;, the &quot;Extended API&quot;, and the &quot;Okasaki API&quot;.</source>
          <target state="translated">이 모듈에는 &quot;Original API&quot;, &quot;Extended API&quot;및 &quot;Okasaki API&quot;의 세 가지 인터페이스 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5308b8befdbb88760705def10e558c7d6f76c3f" translate="yes" xml:space="preserve">
          <source>This module helps running property-based tests in the &lt;code&gt;Common Test&lt;/code&gt; framework. One (or more) of the property testing tools</source>
          <target state="translated">이 모듈은 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 에서 속성 기반 테스트를 실행하는 데 도움이됩니다 . 속성 테스트 도구 중 하나 (또는 ​​그 이상)</target>
        </trans-unit>
        <trans-unit id="e94b28ea5c396cd8b2c46ddc4551b34a14bfd479" translate="yes" xml:space="preserve">
          <source>This module implements a client for file transfer according to a subset of the File Transfer Protocol (FTP), see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc959.txt&quot;&gt;RFC 959&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 FTP (File Transfer Protocol)의 서브 세트에 따라 파일 전송을위한 클라이언트를 구현합니다 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc959.txt&quot;&gt;RFC 959&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b25912bf3af7bf1193b3fff50e47205181300228" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco codec measurement tool.</source>
          <target state="translated">이 모듈은 간단한 megaco 코덱 측정 도구를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="871eeb782d63d6630dd6a5d492a7b58d86850778" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco codec-based performance tool.</source>
          <target state="translated">이 모듈은 간단한 megaco 코덱 기반 성능 도구를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f9179ddef6a9ee16329a9f709abd6d55eba87a03" translate="yes" xml:space="preserve">
          <source>This module implements a simple megaco message transformation utility.</source>
          <target state="translated">이 모듈은 간단한 megaco 메시지 변환 유틸리티를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="509079930c0c0a8b4797c4ad9534704e9e78b720" translate="yes" xml:space="preserve">
          <source>This module implements a text based interface to the &lt;code&gt;trace/3&lt;/code&gt; and the &lt;code&gt;trace_pattern/2&lt;/code&gt; BIFs. It makes it possible to trace functions, processes, ports and messages.</source>
          <target state="translated">이 모듈은 &lt;code&gt;trace/3&lt;/code&gt; 및 &lt;code&gt;trace_pattern/2&lt;/code&gt; BIF에 대한 텍스트 기반 인터페이스를 구현합니다 . 기능, 프로세스, 포트 및 메시지를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d643bd7191e32f2c51494e11bf58ee73f4a435" translate="yes" xml:space="preserve">
          <source>This module implements an SSH FTP (SFTP) client. SFTP is a secure, encrypted file transfer service available for SSH.</source>
          <target state="translated">이 모듈은 SFTP (SSH FTP) 클라이언트를 구현합니다. SFTP는 SSH에 사용할 수있는 안전한 암호화 파일 전송 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="03ef132a9564d822dda1f23634bee22efb87c0be" translate="yes" xml:space="preserve">
          <source>This module implements diameter transport over SCTP using &lt;code&gt;gen_sctp(3)&lt;/code&gt;. It can be specified as the value of a transport_module option to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; and implements the behaviour documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;gen_sctp(3)&lt;/code&gt; 사용하여 SCTP를 통한 직경 전송을 구현 합니다. transport_module 옵션의 값으로 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 에 지정할 수 있으며 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 설명 된 동작을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="88cb8b49f73b329262758743b81d712fdab5c653" translate="yes" xml:space="preserve">
          <source>This module implements diameter transport over TCP using &lt;code&gt;gen_tcp(3)&lt;/code&gt;. It can be specified as the value of a &lt;code&gt;transport_module&lt;/code&gt; option to &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; and implements the behaviour documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;. TLS security is supported, either as an upgrade following capabilities exchange or at connection establishment.</source>
          <target state="translated">이 모듈은 &lt;code&gt;gen_tcp(3)&lt;/code&gt; 사용하여 TCP를 통한 직경 전송을 구현 합니다. &lt;code&gt;transport_module&lt;/code&gt; 옵션 의 값 으로 &lt;code&gt;&lt;a href=&quot;diameter#add_transport-2&quot;&gt;diameter:add_transport/2&lt;/a&gt;&lt;/code&gt; 에 지정할 수 있으며 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 설명 된 동작을 구현합니다 . TLS 보안은 기능 교환에 따른 업그레이드 또는 연결 설정시 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9266c44a4ba8cd9ee1a5c81b4c58c87a30706c84" translate="yes" xml:space="preserve">
          <source>This module implements dynamic hashing, which is a kind of hashing that grows nicely when new fragments are added. It is well suited for scalable hash tables.</source>
          <target state="translated">이 모듈은 동적 해싱을 구현하는데, 이는 새로운 조각이 추가 될 때 잘 자라는 일종의 해싱입니다. 확장 가능한 해시 테이블에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="237af1ed7b14daa8c6a596b37b3d9e9e2855eee1" translate="yes" xml:space="preserve">
          <source>This module implements interfaces to dynamic tracing, should such be compiled into the virtual machine. For a standard and/or commercial build, no dynamic tracing is available, in which case none of the functions in this module is usable or give any effect.</source>
          <target state="translated">이 모듈은 동적 추적에 대한 인터페이스를 구현하며 가상 머신으로 컴파일해야합니다. 표준 및 / 또는 상용 빌드의 경우 동적 추적을 사용할 수 없습니다.이 경우이 모듈의 기능을 사용할 수 없거나 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e063dd1183a5694a263767c4e6d75bf203f69f0d" translate="yes" xml:space="preserve">
          <source>This module implements process groups. A message can be sent to one, some, or all group members.</source>
          <target state="translated">이 모듈은 프로세스 그룹을 구현합니다. 하나, 일부 또는 모든 그룹 구성원에게 메시지를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5567e19229f23540f47010e8b1ddd342e185fa20" translate="yes" xml:space="preserve">
          <source>This module implements process groups. Each message can be sent to one, some, or all group members.</source>
          <target state="translated">이 모듈은 프로세스 그룹을 구현합니다. 각 메시지는 하나, 일부 또는 모든 그룹 구성원에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d68eba5044da7ce7cbcdeb1e9cede6cbfa2c8b7" translate="yes" xml:space="preserve">
          <source>This module implements some convenience functions for analyzing microstate accounting data. For details about how to use the basic api and what the different states represent see &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 미시 상태 회계 데이터를 분석하기위한 몇 가지 편의 기능을 구현합니다. 기본 API를 사용하는 방법과 다른 상태가 나타내는 것에 대한 자세한 내용은 &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81520061930d4cb81104030ae03956c22721f688" translate="yes" xml:space="preserve">
          <source>This module implements some convenience functions for analyzing microstate accounting data. For details about how to use the basic api and what the different states represent see &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 마이크로 스테이트 회계 데이터를 분석하기위한 일부 편의 기능을 구현합니다. 기본 API를 사용하는 방법과 다양한 상태가 나타내는 것에 대한 자세한 내용은 &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d15b1e9aa28423920ee271c9eb3d3a739153bbd9" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;strong&gt;mstone1&lt;/strong&gt; tool, a simple megaco codec-based performance tool.</source>
          <target state="translated">이 모듈 은 간단한 megaco 코덱 기반 성능 도구 인 &lt;strong&gt;mstone1&lt;/strong&gt; 도구를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="251e35996e11df5d3eaaaf86f280ba3afa349ebe" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;strong&gt;mstone2&lt;/strong&gt; tool, a simple megaco codec-based performance tool.</source>
          <target state="translated">이 모듈 은 간단한 megaco 코덱 기반 성능 도구 인 &lt;strong&gt;mstone2&lt;/strong&gt; 도구를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a53a9f4087442a15c8d05293fde6edfea4bb383c" translate="yes" xml:space="preserve">
          <source>This module implements the command-line interface for running tests and basic functions for &lt;code&gt;Common Test&lt;/code&gt; case issues, such as configuration and logging.</source>
          <target state="translated">이 모듈 은 구성 및 로깅과 같은 &lt;code&gt;Common Test&lt;/code&gt; 사례 문제에 대한 테스트 및 기본 기능을 실행하기위한 명령 줄 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c9a16d56697c4875fd3dc95099670093ace6758a" translate="yes" xml:space="preserve">
          <source>This module implements the main API for logging in Erlang/OTP. To create a log event, use the &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; or the log &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">이 모듈은 Erlang / OTP에 로그인하기위한 기본 API를 구현합니다. 로그 이벤트를 작성하려면 &lt;code&gt;&lt;a href=&quot;#logging_API&quot;&gt;API functions&lt;/a&gt;&lt;/code&gt; 또는 로그 &lt;code&gt;&lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="34096d8559e322df745393832ab2c6dfe7da7fb5" translate="yes" xml:space="preserve">
          <source>This module is a &lt;code&gt;gen_event&lt;/code&gt; handler module that can be installed in any &lt;code&gt;gen_event&lt;/code&gt; process. It logs onto disk all events that are sent to an event manager. Each event is written as a binary, which makes the logging very fast. However, a tool such as the Report Browser (&lt;code&gt;rb(3)&lt;/code&gt;) must be used to read the files. The events are written to multiple files. When all files have been used, the first one is reused and overwritten. The directory location, the number of files, and the size of each file are configurable. The directory will include one file called &lt;code&gt;index&lt;/code&gt;, and report files &lt;code&gt;1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;gen_event&lt;/code&gt; 프로세스에 설치할 수 있는 &lt;code&gt;gen_event&lt;/code&gt; 핸들러 모듈입니다 . 이벤트 관리자에게 전송 된 모든 이벤트를 디스크에 로그온합니다. 각 이벤트는 바이너리로 작성되므로 로깅 속도가 매우 빠릅니다. 그러나 파일을 읽으려면 보고서 브라우저 ( &lt;code&gt;rb(3)&lt;/code&gt; ) 와 같은 도구를 사용해야합니다. 이벤트는 여러 파일에 기록됩니다. 모든 파일이 사용되면 첫 번째 파일을 재사용하고 덮어 씁니다. 디렉토리 위치, 파일 수 및 각 파일의 크기를 구성 할 수 있습니다. 디렉토리에는 &lt;code&gt;index&lt;/code&gt; 라는 하나의 파일 과 보고서 파일 &lt;code&gt;1, 2, ...&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="91f4aea2b0c25de578d81458879b8b8a6606f33f" translate="yes" xml:space="preserve">
          <source>This module is a first step to run property-based tests in the &lt;code&gt;Common Test&lt;/code&gt; framework. A property testing tool like QuickCheck or PropEr is assumed to be installed.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 에서 특성 기반 테스트를 실행하기위한 첫 번째 단계 입니다. QuickCheck 또는 PropEr과 같은 속성 테스트 도구가 설치된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="745e849710741c8126631867ff49314e84421edc" translate="yes" xml:space="preserve">
          <source>This module is a front end to the pretty-printing library module &lt;code&gt;prettypr&lt;/code&gt;, for text formatting of abstract syntax trees defined by the module &lt;code&gt;erl_syntax&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 꽤 - 인쇄 라이브러리 모듈에 대한 프론트 엔드입니다 &lt;code&gt;prettypr&lt;/code&gt; 모듈에 의해 정의 된 추상 구문 트리의 서식 텍스트, &lt;code&gt;erl_syntax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="771c2457f87cf1d0281342c6af1f3ab5bb5e2564" translate="yes" xml:space="preserve">
          <source>This module is also used by the test module described in the next section.</source>
          <target state="translated">이 모듈은 다음 섹션에서 설명하는 테스트 모듈에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="029ed3af3c0fa1d9308479815ba39c6258f71e21" translate="yes" xml:space="preserve">
          <source>This module is an interface to the Erlang built-in term storage BIFs. These provide the ability to store very large quantities of data in an Erlang runtime system, and to have constant access time to the data. (In the case of &lt;code&gt;ordered_set&lt;/code&gt;, see below, access time is proportional to the logarithm of the number of stored objects.)</source>
          <target state="translated">이 모듈은 Erlang 내장 용어 스토리지 BIF에 대한 인터페이스입니다. 이를 통해 Erlang 런타임 시스템에 대량의 데이터를 저장하고 데이터에 지속적으로 액세스 할 수 있습니다. ( &lt;code&gt;ordered_set&lt;/code&gt; 의 경우 아래 참조, 액세스 시간은 저장된 오브젝트 수의 로그에 비례합니다.)</target>
        </trans-unit>
        <trans-unit id="ab06f0be8cb17b619659641efccfa5a0d94a8229" translate="yes" xml:space="preserve">
          <source>This module is deprecated since OTP 23. Use the module &lt;code&gt;uri_string&lt;/code&gt; to properly handle URIs, this is the recommended module since OTP 21.</source>
          <target state="translated">이 모듈은 OTP 23부터 더 이상 사용되지 않습니다. &lt;code&gt;uri_string&lt;/code&gt; 모듈을 사용하여 URI를 적절하게 처리합니다. OTP 21 이후 권장되는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="2bf3be01bc933bf9be0bb2caf2dc7622f94a43df" translate="yes" xml:space="preserve">
          <source>This module is deprecated. For a description of the Magic Cookie system, refer to &lt;code&gt;Distributed Erlang&lt;/code&gt; in the Erlang Reference Manual.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. Magic Cookie 시스템에 대한 설명은 Erlang Reference Manual의 &lt;code&gt;Distributed Erlang&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a93d2db2466d23d6026908c314c14a83563ca6b" translate="yes" xml:space="preserve">
          <source>This module is mainly intended for internal use within OTP, but it has two functions that are exported for public use.</source>
          <target state="translated">이 모듈은 주로 OTP 내부에서 사용하기위한 것이지만 공용으로 내보내는 두 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a37f6b1919b03e1a3eef60f562daa64d563a0b3" translate="yes" xml:space="preserve">
          <source>This module is preloaded and contains the code for the &lt;code&gt;init&lt;/code&gt; system process that coordinates the startup of the system. The first function evaluated at startup is &lt;code&gt;boot(BootArgs)&lt;/code&gt;, where &lt;code&gt;BootArgs&lt;/code&gt; is a list of command-line arguments supplied to the Erlang runtime system from the local operating system; see &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 사전로드되어 있으며 시스템 시작을 조정하는 &lt;code&gt;init&lt;/code&gt; 시스템 프로세스에 대한 코드를 포함합니다 . 시작할 때 평가되는 첫 번째 함수는 &lt;code&gt;boot(BootArgs)&lt;/code&gt; . 여기서 &lt;code&gt;BootArgs&lt;/code&gt; 는 로컬 운영 체제에서 Erlang 런타임 시스템에 제공되는 명령 행 인수 목록입니다. &lt;code&gt;erl(1)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f8550670270cc6c0c154e6b678e3322ac083e01" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling GET requests to regular files. GET requests for parts of files is handled by &lt;code&gt;mod_range&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 일반 파일에 대한 GET 요청을 처리합니다. 파일의 일부에 대한 GET 요청은 &lt;code&gt;mod_range&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="539b25aff993fcacaf4286ade9ec0f542cedebde" translate="yes" xml:space="preserve">
          <source>This module is responsible for handling HEAD requests to regular files. HEAD requests for dynamic content is handled by each module responsible for dynamic content.</source>
          <target state="translated">이 모듈은 일반 파일에 대한 HEAD 요청을 처리합니다. 동적 컨텐츠에 대한 HEAD 요청은 동적 컨텐츠를 담당하는 각 모듈에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d192cc2f42a8d904da0e0162e8485626f5ec3af9" translate="yes" xml:space="preserve">
          <source>This module is similar to &lt;code&gt;ets&lt;/code&gt; in that it provides a storage for Erlang terms that can be accessed in constant time, but with the difference that &lt;code&gt;persistent_term&lt;/code&gt; has been highly optimized for reading terms at the expense of writing and updating terms. When a persistent term is updated or deleted, a global garbage collection pass is run to scan all processes for the deleted term, and to copy it into each process that still uses it. Therefore, &lt;code&gt;persistent_term&lt;/code&gt; is suitable for storing Erlang terms that are frequently accessed but never or infrequently updated.</source>
          <target state="translated">이 모듈은 유사하다 &lt;code&gt;ets&lt;/code&gt; 는 일정 시간에 액세스 할 수 있습니다 얼랑 용어에 대한 스토리지를 제공하는 것을,하지만 그 차이가 &lt;code&gt;persistent_term&lt;/code&gt; 이 매우 작성 및 업데이트 용어의 비용으로 용어를 읽기에 최적화되었습니다. 영구 용어가 업데이트되거나 삭제되면 글로벌 가비지 수집 단계가 실행되어 삭제 된 용어에 대한 모든 프로세스를 검색하고이를 여전히 사용하는 각 프로세스에 복사합니다. 따라서, &lt;code&gt;persistent_term&lt;/code&gt; 는 자주 액세스하지만 결코 또는 자주 업데이트되지 얼랑 조건을 저장하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="758181cc746f5e39f0bd67af3c9cff191b5c70fa" translate="yes" xml:space="preserve">
          <source>This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. Notice that a token list must end with the &lt;strong&gt;dot&lt;/strong&gt; token to be acceptable to the parse functions (see the &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt; erl_scan(3)&lt;/a&gt;&lt;/code&gt;) module.</source>
          <target state="translated">이 모듈은 토큰을 양식 (즉, 최상위 구조), 표현식 또는 용어의 추상 형식으로 변환하는 기본 Erlang 파서입니다. 추상 형식은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다. 토큰 목록은 구문 분석 함수 ( &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt; erl_scan(3)&lt;/a&gt;&lt;/code&gt; ) 모듈에서 허용 할 수 있도록 &lt;strong&gt;점&lt;/strong&gt; 토큰으로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="5ce2d8127480b9b1949b76303752c4240c4a9505" translate="yes" xml:space="preserve">
          <source>This module is the basic Erlang parser that converts tokens into the abstract form of either forms (that is, top-level constructs), expressions, or terms. The Abstract Format is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;. Notice that a token list must end with the &lt;strong&gt;dot&lt;/strong&gt; token to be acceptable to the parse functions (see the &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt;) module.</source>
          <target state="translated">이 모듈은 토큰을 추상 형태의 형태 (즉, 최상위 구조), 표현식 또는 용어로 변환하는 기본 Erlang 파서입니다. 초록 형식은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다. 구문 분석 함수 ( &lt;code&gt;&lt;a href=&quot;erl_scan&quot;&gt;erl_scan(3)&lt;/a&gt;&lt;/code&gt; ) 모듈에 허용 되려면 토큰 목록이 &lt;strong&gt;도트&lt;/strong&gt; 토큰으로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="c5088feb51b7d364ba0408f5823e446921051046" translate="yes" xml:space="preserve">
          <source>This module is the default callback handler for the client's and the server's user and host &quot;database&quot; operations. All data, for instance key pairs, are stored in files in the normal file system. This page documents the files, where they are stored and configuration options for this callback module.</source>
          <target state="translated">이 모듈은 클라이언트와 서버의 사용자 및 호스트 &quot;데이터베이스&quot;작업을위한 기본 콜백 핸들러입니다. 모든 데이터 (예 : 키 쌍)는 일반 파일 시스템의 파일에 저장됩니다. 이 페이지는 파일이 저장되는 위치와이 콜백 모듈에 대한 구성 옵션을 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="bc2b019e4ec5090f2acbc77c196c921bcb3de610" translate="yes" xml:space="preserve">
          <source>This module is the default error report module, but can be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 기본 오류 보고서 모듈이지만 명시 적으로 구성 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84c431043a09432c4f87c8d3c357236a55bbfcb6" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0.</source>
          <target state="translated">이 모듈은 XML 파서에 대한 인터페이스이며 XML 1.0을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3104bc131d319b6e5efc35816fb7e2161d34e06f" translate="yes" xml:space="preserve">
          <source>This module is the interface to the XML parser, it handles XML 1.0. The XML parser is activated through &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; or &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. It returns records of the type defined in xmerl.hrl. See also &lt;code&gt;tutorial&lt;/code&gt; on customization functions.</source>
          <target state="translated">이 모듈은 XML 파서에 대한 인터페이스이며 XML 1.0을 처리합니다. XML 파서는 &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; 또는 &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; 를 통해 활성화됩니다 . xmerl.hrl에 정의 된 유형의 레코드를 리턴합니다. 사용자 정의 기능에 대한 &lt;code&gt;tutorial&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c37b4a9c779ad7673d2176f38ce64f13f8e8ff9a" translate="yes" xml:space="preserve">
          <source>This module is the main EUnit user interface.</source>
          <target state="translated">이 모듈은 기본 EUnit 사용자 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="380eae6ed1f14f5abc43a6827952590fc885d0c2" translate="yes" xml:space="preserve">
          <source>This module is used as the Windows backend for &lt;code&gt;os_sup&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;os_sup&lt;/code&gt; 의 Windows 백엔드로 사용됩니다 &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="418bac64df42298bb2e47d356802d620e125c0b8" translate="yes" xml:space="preserve">
          <source>This module is used as the Windows backend for &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;os_sup&lt;/code&gt; 의 Windows 백엔드로 사용됩니다 . &lt;code&gt;&lt;a href=&quot;os_sup&quot;&gt;os_sup(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85cabe69b73c75cfce665849059c6c267e570fc3" translate="yes" xml:space="preserve">
          <source>This module is used by module &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; for managing distributed disk logs. The disk log names are used as group names, which means that some action can be needed to avoid name clashes.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log&lt;/a&gt;&lt;/code&gt; 모듈에서 분산 디스크 로그를 관리하는 데 사용됩니다 . 디스크 로그 이름은 그룹 이름으로 사용되므로 이름 충돌을 피하기 위해 몇 가지 조치가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2facc0dce78b1734ff96c5e2c414eea0b55cfeef" translate="yes" xml:space="preserve">
          <source>This module is used by the Mnesia application, and is provided &quot;as is&quot; for users who are interested in efficient storage of Erlang terms on disk only. Many applications only need to store some terms in a file. Mnesia adds transactions, queries, and distribution. The size of Dets files cannot exceed 2 GB. If larger tables are needed, table fragmentation in Mnesia can be used.</source>
          <target state="translated">이 모듈은 Mnesia 응용 프로그램에서 사용되며 디스크에만 Erlang 용어를 효율적으로 저장하려는 사용자에게 &quot;있는 그대로&quot;제공됩니다. 많은 응용 프로그램은 파일에 일부 용어 만 저장하면됩니다. Mnesia는 트랜잭션, 쿼리 및 배포를 추가합니다. Dets 파일의 크기는 2GB를 초과 할 수 없습니다. 더 큰 테이블이 필요한 경우 Mnesia에서 테이블 조각화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a4a5f76c2f39ee7d14410f547c13073a7f0ccea" translate="yes" xml:space="preserve">
          <source>This module is used to check Erlang code for illegal syntax and other bugs. It also warns against coding practices that are not recommended.</source>
          <target state="translated">이 모듈은 Erlang 코드에서 잘못된 구문 및 기타 버그가 있는지 확인하는 데 사용됩니다. 또한 권장하지 않는 코딩 관행에 대해서도 경고합니다.</target>
        </trans-unit>
        <trans-unit id="eeb466b5da365f466e8f7e7ccc932ed35a24cf1b" translate="yes" xml:space="preserve">
          <source>This module is used to load all Erlang modules into the system. The start script is also fetched with this low-level loader.</source>
          <target state="translated">이 모듈은 모든 Erlang 모듈을 시스템에로드하는 데 사용됩니다. 시작 스크립트는이 하위 수준 로더와 함께 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2290e1725f60788cc5c925cb7d57804f016396a1" translate="yes" xml:space="preserve">
          <source>This module is used to profile a program to find out how the execution time is used. Trace to file is used to minimize runtime performance impact.</source>
          <target state="translated">이 모듈은 프로그램을 프로파일 링하여 실행 시간이 어떻게 사용되는지 알아내는 데 사용됩니다. 파일 추적은 런타임 성능 영향을 최소화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf791b13f3d789dba7e7d40b898243584bd114e9" translate="yes" xml:space="preserve">
          <source>This module is used to start processes adhering to the &lt;code&gt; OTP Design Principles&lt;/code&gt;. Specifically, the functions in this module are used by the OTP standard behaviors (for example, &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_statem&lt;/code&gt;) when starting new processes. The functions can also be used to start &lt;strong&gt;special processes&lt;/strong&gt;, user-defined processes that comply to the OTP design principles. For an example, see section &lt;code&gt; sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 모듈은 &lt;code&gt; OTP Design Principles&lt;/code&gt; 준수하는 프로세스를 시작하는 데 사용됩니다 . &lt;code&gt;gen_server&lt;/code&gt; 모듈의 함수는 새 프로세스를 시작할 때 OTP 표준 동작 (예 : gen_server 및 &lt;code&gt;gen_statem&lt;/code&gt; )에서 사용됩니다. 이 기능은 OTP 설계 원칙을 준수하는 &lt;strong&gt;특수 프로세스&lt;/strong&gt; , 사용자 정의 프로세스 를 시작하는데도 사용할 수 있습니다 . 예를 들어 OTP 설계 원칙의 &lt;code&gt; sys and proc_lib&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c89a4f0fda18575f2da9f933c35be2fd6e70e09" translate="yes" xml:space="preserve">
          <source>This module is used to start processes adhering to the &lt;code&gt;OTP Design Principles&lt;/code&gt;. Specifically, the functions in this module are used by the OTP standard behaviors (for example, &lt;code&gt;gen_server&lt;/code&gt; and &lt;code&gt;gen_statem&lt;/code&gt;) when starting new processes. The functions can also be used to start &lt;strong&gt;special processes&lt;/strong&gt;, user-defined processes that comply to the OTP design principles. For an example, see section &lt;code&gt;sys and proc_lib&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">이 모듈은 &lt;code&gt;OTP Design Principles&lt;/code&gt; 준수하는 프로세스를 시작하는 데 사용됩니다 . &lt;code&gt;gen_server&lt;/code&gt; 모듈의 기능은 새 프로세스를 시작할 때 OTP 표준 동작 (예 : gen_server 및 &lt;code&gt;gen_statem&lt;/code&gt; )에 의해 사용됩니다 . 또한이 기능을 사용 하여 OTP 설계 원칙을 준수하는 &lt;strong&gt;특수 프로세스&lt;/strong&gt; , 사용자 정의 프로세스 를 시작할 수 있습니다 . 예를 들어, OTP 설계 원칙의 &lt;code&gt;sys and proc_lib&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f4ab243ee6586ee79497742f5b5a43934de147b" translate="yes" xml:space="preserve">
          <source>This module is usually part of the &lt;code&gt;erl_interface&lt;/code&gt; application, but is currently part of the Mnesia application.</source>
          <target state="translated">이 모듈은 일반적으로 &lt;code&gt;erl_interface&lt;/code&gt; 응용 프로그램의 일부이지만 현재 Mnesia 응용 프로그램의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="1e34649b10e11074b5eecec6992267ea5de9baf9" translate="yes" xml:space="preserve">
          <source>This module maintains a cache of CRLs. CRLs can be added to the cache using the function &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt;, and optionally automatically fetched through HTTP if the following argument is specified:</source>
          <target state="translated">이 모듈은 CRL 캐시를 유지 관리합니다. &lt;code&gt;ssl_crl_cache:insert/1&lt;/code&gt; 함수를 사용하여 CRL을 캐시에 추가 할 수 있으며 다음 인수가 지정된 경우 HTTP를 통해 자동으로 페치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48cfe86ff08451c66cbfbd564bce30700dcbc33c" translate="yes" xml:space="preserve">
          <source>This module makes it possible to partition the nodes of a system into &lt;strong&gt;global groups&lt;/strong&gt;. Each global group has its own global namespace, see &lt;code&gt;&lt;a href=&quot;global&quot;&gt; global(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하면 시스템의 노드를 &lt;strong&gt;글로벌 그룹&lt;/strong&gt; 으로 분할 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 각 글로벌 그룹에는 자체 글로벌 네임 스페이스가 있습니다. &lt;code&gt;&lt;a href=&quot;global&quot;&gt; global(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99468bcd97490a51d234dfa1e1aa1f1b75181a01" translate="yes" xml:space="preserve">
          <source>This module makes it possible to partition the nodes of a system into &lt;strong&gt;global groups&lt;/strong&gt;. Each global group has its own global namespace, see &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하면 시스템의 노드를 &lt;strong&gt;전역 그룹&lt;/strong&gt; 으로 분할 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 각 글로벌 그룹에는 자체 글로벌 네임 스페이스가 있습니다 ( &lt;code&gt;&lt;a href=&quot;global&quot;&gt;global(3)&lt;/a&gt;&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="8ac57e5b97d1c2443f197da3b8016c360ca297b4" translate="yes" xml:space="preserve">
          <source>This module makes it possible to read internally formatted wrap disk logs, see &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;wrap_log_reader&lt;/code&gt; does not interfere with &lt;code&gt;disk_log&lt;/code&gt; activities; there is however a bug in this version of the &lt;code&gt;wrap_log_reader&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈을 사용하면 내부 형식의 랩 디스크 로그를 읽을 수 있습니다 &lt;code&gt;&lt;a href=&quot;disk_log&quot;&gt;disk_log(3)&lt;/a&gt;&lt;/code&gt; 참조 ) . &lt;code&gt;wrap_log_reader&lt;/code&gt; 는 &lt;code&gt;disk_log&lt;/code&gt; 활동을 방해하지 않습니다 . 그러나이 버전의 &lt;code&gt;wrap_log_reader&lt;/code&gt; 에는 버그가 있습니다. &lt;code&gt;&lt;a href=&quot;#bugs&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="989e49030b5db914fe14f640feffac69f14c2c8d" translate="yes" xml:space="preserve">
          <source>This module makes use of a directory where CRLs are stored in files named by the hash of the issuer name.</source>
          <target state="translated">이 모듈은 CRL이 발급자 이름의 해시로 이름이 지정된 파일에 저장된 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3e4a8e573560a8571cd9ef1e8a9e51dcf07a77f3" translate="yes" xml:space="preserve">
          <source>This module needs to be explicitly configured, see &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 명시 적으로 구성해야합니다 . &lt;code&gt;&lt;a href=&quot;snmpa_error#desc&quot;&gt;snmpa_error&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b605512fe66b8682ce8b37c4cf3e4fbe2e01d42" translate="yes" xml:space="preserve">
          <source>This module operates on grapheme clusters. A &lt;strong&gt;grapheme cluster&lt;/strong&gt; is a user-perceived character, which can be represented by several codepoints.</source>
          <target state="translated">이 모듈은 grapheme 클러스터에서 작동합니다. &lt;strong&gt;자소 클러스터가&lt;/strong&gt; 여러 코드 포인트로 표현 될 수있는 사용자가인지 된 문자이다.</target>
        </trans-unit>
        <trans-unit id="bb1c46b6a237b6087130260dff45a5cc687d6cba" translate="yes" xml:space="preserve">
          <source>This module performs DNS name resolving to recursive name servers.</source>
          <target state="translated">이 모듈은 재귀 이름 서버로 DNS 이름 확인을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4ab7b3a5e783c28b801aa97ce3c793f0d6d021bc" translate="yes" xml:space="preserve">
          <source>This module performs an identity parse transformation of Erlang code. It is included as an example for users who wants to write their own parse transformers. If option &lt;code&gt;{parse_transform,Module}&lt;/code&gt; is passed to the compiler, a user-written function &lt;code&gt;parse_transform/2&lt;/code&gt; is called by the compiler before the code is checked for errors.</source>
          <target state="translated">이 모듈은 Erlang 코드의 신원 구문 분석 변환을 수행합니다. 자체 구문 분석 변환기를 작성하려는 사용자를위한 예제로 포함되어 있습니다. &lt;code&gt;{parse_transform,Module}&lt;/code&gt; 옵션 이 컴파일러에 전달 되면 코드에서 오류를 검사하기 전에 컴파일러가 사용자 작성 함수 &lt;code&gt;parse_transform/2&lt;/code&gt; 를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="db95c0c571d0edee3b86863284018ac0d738f900" translate="yes" xml:space="preserve">
          <source>This module provide services similar to Remote Procedure Calls. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node.</source>
          <target state="translated">이 모듈은 원격 프로 시저 호출과 유사한 서비스를 제공합니다. 원격 프로 시저 호출은 원격 노드에서 함수를 호출하고 응답을 수집하는 방법입니다. 원격 노드에서 정보를 수집하거나 원격 노드에서 특정 부작용이있는 기능을 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0037900bad0730ea9a030ba4069f75cb17a7f8b" translate="yes" xml:space="preserve">
          <source>This module provides (double-ended) FIFO queues in an efficient manner.</source>
          <target state="translated">이 모듈은 효율적인 방식으로 (더블 엔드) FIFO 대기열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86963c4e13e1aeb4e47cbb6c0a5df6d5e8a947ad" translate="yes" xml:space="preserve">
          <source>This module provides API functions to send SSH Connection Protocol events to the other side of an SSH channel.</source>
          <target state="translated">이 모듈은 SSH 연결 프로토콜 이벤트를 SSH 채널의 다른쪽에 보내는 API 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce8b320b968902deab02747f5036f5e0f055ee88" translate="yes" xml:space="preserve">
          <source>This module provides Prof. Arne Andersson's General Balanced Trees. These have no storage overhead compared to unbalanced binary trees, and their performance is better than AVL trees.</source>
          <target state="translated">이 모듈은 Arne Andersson 교수의 일반 균형 트리를 제공합니다. 이들은 불평형 이진 트리에 비해 스토리지 오버 헤드가 없으며 AVL 트리보다 성능이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="781b6c37f92636bd37c09e7bf44c27d67bf8df9d" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. An &lt;code&gt;orddict&lt;/code&gt; is a representation of a dictionary, where a list of pairs is used to store the keys and values. The list is ordered after the keys in the &lt;strong&gt;Erlang term order&lt;/strong&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 사전을 제공합니다 . &lt;code&gt;orddict&lt;/code&gt; 는 쌍 목록의 키 값을 저장하는 데 사용되는 사전의 표현이다. 목록은 &lt;strong&gt;Erlang 용어 순서&lt;/strong&gt; 의 키 다음에 &lt;strong&gt;정렬&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="54ac9b6927419ddb4103884312f8097df3f2bb5a" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;Key&lt;/code&gt;-&lt;code&gt;Value&lt;/code&gt; dictionary. The representation of a dictionary is not defined.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Key&lt;/code&gt; - &lt;code&gt;Value&lt;/code&gt; 사전을 제공합니다 . 사전의 표현은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="393cc80d6eca92a704f69151bc3d7efe95ae4615" translate="yes" xml:space="preserve">
          <source>This module provides a client api to the Lightweight Directory Access Protocol (LDAP).</source>
          <target state="translated">이 모듈은 LDAP (Lightweight Directory Access Protocol)에 클라이언트 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="015ecfc007c07144fe6ae22676ba1b983919f2ff" translate="yes" xml:space="preserve">
          <source>This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms are based on the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; Xoroshiro and Xorshift algorithms &lt;/a&gt;&lt;/code&gt; by Sebastiano Vigna. The normal distribution algorithm uses the &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; on top of the uniform distribution algorithm.</source>
          <target state="translated">이 모듈은 의사 난수 생성기를 제공합니다. 모듈에는 여러 알고리즘이 포함되어 있습니다. 균일 분포 알고리즘은 Sebastiano Vigna 의 &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; Xoroshiro and Xorshift algorithms &lt;/a&gt;&lt;/code&gt; 을 기반으로합니다 . 정규 분포 알고리즘은 균등 분포 알고리즘 위에 &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; 의 Ziggurat Method를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f62d79bfd7ef0367f3e971c525740d763d760116" translate="yes" xml:space="preserve">
          <source>This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms use the &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; The normal distribution algorithm uses the &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; on top of the uniform distribution algorithm.</source>
          <target state="translated">이 모듈은 의사 난수 생성기를 제공합니다. 이 모듈에는 여러 알고리즘이 포함되어 있습니다. 균일 분포 알고리즘 &lt;code&gt;&lt;a href=&quot;http://xorshift.di.unimi.it&quot;&gt; xoroshiro116+ and xorshift1024* algorithms by Sebastiano Vigna. &lt;/a&gt;&lt;/code&gt; 의 xoroshiro116 + 및 xorshift1024 * 알고리즘을 사용합니다 . 정규 분포 알고리즘은 균일 분포 알고리즘 위에 &lt;code&gt;&lt;a href=&quot;http://www.jstatsoft.org/v05/i08&quot;&gt; Ziggurat Method by Marsaglia and Tsang &lt;/a&gt;&lt;/code&gt; 의 Ziggurat 방법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f99a3f1888d10fffd183a70ef4c3a34c9ed1aee3" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;code&gt;Mnesia&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt;, and other data structures that provide an iterator style traversal of objects.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Mnesia&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;dets&quot;&gt;Dets&lt;/a&gt;&lt;/code&gt; 및 객체의 반복자 스타일 순회를 제공하는 기타 데이터 구조에 대한 쿼리 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b710ecaed2fa7dbc6a10afe4f44c9844447837ab" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;strong&gt;QLC tables&lt;/strong&gt;. Typical QLC tables are Mnesia, ETS, and Dets tables. Support is also provided for user-defined tables, see section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt; Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.  A &lt;strong id=&quot;query_list_comprehension&quot;&gt;query&lt;/strong&gt; is expressed using &lt;strong&gt;Query List Comprehensions&lt;/strong&gt; (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in &lt;code&gt; Erlang Reference Manual&lt;/code&gt; and &lt;code&gt; Programming Examples&lt;/code&gt;, except that variables introduced in patterns cannot be used in list expressions. In the absence of optimizations and options such as &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; (see section &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;, every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension.</source>
          <target state="translated">이 모듈은 &lt;strong&gt;QLC 테이블에&lt;/strong&gt; 대한 조회 인터페이스를 제공합니다 . 일반적인 QLC 테이블은 Mnesia, ETS 및 Dets 테이블입니다. 사용자 정의 테이블에 대한 지원도 제공됩니다 . &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt; Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 . &lt;strong id=&quot;query_list_comprehension&quot;&gt;쿼리를&lt;/strong&gt; 사용하여 표현되는 &lt;strong&gt;쿼리 목록 함축&lt;/strong&gt; (QLCs을). 쿼리에 대한 응답은 쿼리의 QLC로 표현 된 제한 조건을 충족하는 QLC 테이블의 데이터에 의해 결정됩니다. QLC는 패턴에 도입 된 변수를 목록 표현식에서 사용할 수 없다는 점을 제외하면 &lt;code&gt; Erlang Reference Manual&lt;/code&gt; 및 &lt;code&gt; Programming Examples&lt;/code&gt; 설명 된 일반 목록 이해와 유사합니다 . 최적화 및 옵션 (예 : &lt;code&gt;cache&lt;/code&gt; 및 &lt;code&gt;unique&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; 섹션 참조 , QLC 테이블이없는 모든 QLC는 동일한 일반 목록 이해력과 동일한 답변 목록으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="4250319025eafcb7ae410e50274c9a7bdf114b1e" translate="yes" xml:space="preserve">
          <source>This module provides a query interface to &lt;strong&gt;QLC tables&lt;/strong&gt;. Typical QLC tables are Mnesia, ETS, and Dets tables. Support is also provided for user-defined tables, see section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.  A &lt;strong id=&quot;query_list_comprehension&quot;&gt;query&lt;/strong&gt; is expressed using &lt;strong&gt;Query List Comprehensions&lt;/strong&gt; (QLCs). The answers to a query are determined by data in QLC tables that fulfill the constraints expressed by the QLCs of the query. QLCs are similar to ordinary list comprehensions as described in &lt;code&gt;Erlang Reference Manual&lt;/code&gt; and &lt;code&gt;Programming Examples&lt;/code&gt;, except that variables introduced in patterns cannot be used in list expressions. In the absence of optimizations and options such as &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; (see section &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;, every QLC free of QLC tables evaluates to the same list of answers as the identical ordinary list comprehension.</source>
          <target state="translated">이 모듈은 &lt;strong&gt;QLC 테이블에&lt;/strong&gt; 대한 조회 인터페이스를 제공합니다 . 일반적인 QLC 테이블은 Mnesia, ETS 및 Dets 테이블입니다. 사용자 정의 테이블에 대한 지원도 제공됩니다 ( &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 섹션 참조) . &lt;strong id=&quot;query_list_comprehension&quot;&gt;쿼리를&lt;/strong&gt; 사용하여 표현되는 &lt;strong&gt;쿼리 목록 함축&lt;/strong&gt; (QLCs을). 조회에 대한 응답은 조회의 QLC가 나타내는 제한 조건을 충족시키는 QLC 테이블의 데이터에 의해 결정됩니다. QLC는 패턴에 도입 된 변수를 목록 표현식에 사용할 수 없다는 점을 제외하고 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 및 &lt;code&gt;Programming Examples&lt;/code&gt; 설명 된 일반 목록 이해와 유사합니다 . &lt;code&gt;cache&lt;/code&gt; 및 &lt;code&gt;unique&lt;/code&gt; 와 같은 최적화 및 옵션이없는 경우( QLC 테이블이없는 모든 QLC는 동일한 일반 목록 이해와 동일한 답변 목록으로 평가되는 &lt;code&gt;&lt;a href=&quot;#common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="047710b1ad9fd2f027b84c9368779228a800a4da" translate="yes" xml:space="preserve">
          <source>This module provides a random number generator. The method is attributed to B.A. Wichmann and I.D. Hill in 'An efficient and portable pseudo-random number generator', Journal of Applied Statistics. AS183. 1982. Also Byte March 1987.</source>
          <target state="translated">이 모듈은 난수 생성기를 제공합니다. 이 방법은 BA Wichmann과 ID Hill의 '효과적이고 휴대 가능한 의사 난수 생성기'(Journal of Applied Statistics)에 있습니다. AS183. 1982 년 3 월 바이트.</target>
        </trans-unit>
        <trans-unit id="52aa0232673b318eae9c0f57627c3e65f31b22a8" translate="yes" xml:space="preserve">
          <source>This module provides a set of cryptographic functions.</source>
          <target state="translated">이 모듈은 일련의 암호화 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c9cba1fc7e1e6375fe2609ded1dd8583269f1e82" translate="yes" xml:space="preserve">
          <source>This module provides a set of functions to do atomic operations towards mutable atomic variables. The implementation utilizes only atomic hardware instructions without any software level locking, which makes it very efficient for concurrent access. The atomics are organized into arrays with the following semantics:</source>
          <target state="translated">이 모듈은 가변 원자 변수에 대한 원자 연산을 수행하는 함수 세트를 제공합니다. 이 구현은 소프트웨어 수준 잠금없이 원자 하드웨어 명령 만 사용하므로 동시 액세스에 매우 효율적입니다. 원자는 다음과 같은 의미를 가진 배열로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fe4f8c5f2a61de92835e1cf4cdaa069d643860a4" translate="yes" xml:space="preserve">
          <source>This module provides a set of functions to do operations towards shared mutable counter variables. The implementation does not utilize any software level locking, which makes it very efficient for concurrent access. The counters are organized into arrays with the following semantics:</source>
          <target state="translated">이 모듈은 공유 가변 카운터 변수에 대한 작업을 수행하는 함수 세트를 제공합니다. 이 구현은 소프트웨어 수준 잠금을 사용하지 않으므로 동시 액세스에 매우 효율적입니다. 카운터는 다음과 같은 의미를 가진 배열로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2efbf1cf06a7e77fc1af683651fd7cc8b8da3411" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are sent to the &lt;code&gt;error_logger&lt;/code&gt; after a size check. Messages are truncated after 1024 chars. It is provided as an example.</source>
          <target state="translated">이 모듈은 SNMP 오류보고를위한 간단한 메커니즘을 제공합니다. 크기 확인 후 오류가 &lt;code&gt;error_logger&lt;/code&gt; 에 전송됩니다 . 1024 자 뒤에 메시지가 잘립니다. 예제로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="096fb2e3550a9bb0e5272f77db40c6b69c2ccf79" translate="yes" xml:space="preserve">
          <source>This module provides a simple mechanism for reporting SNMP errors. Errors are written to stdout using the &lt;code&gt;io&lt;/code&gt; module. It is provided as an simple example.</source>
          <target state="translated">이 모듈은 SNMP 오류보고를위한 간단한 메커니즘을 제공합니다. &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 오류가 stdout에 기록됩니다 . 간단한 예제로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1286f91cbc25e7fd94773e366acdb66f0cb92b07" translate="yes" xml:space="preserve">
          <source>This module provides a term storage on file. The stored terms, in this module called &lt;strong&gt;objects&lt;/strong&gt;, are tuples such that one element is defined to be the key. A Dets &lt;strong&gt;table&lt;/strong&gt; is a collection of objects with the key at the same position stored on a file.</source>
          <target state="translated">이 모듈은 파일에 용어 스토리지를 제공합니다. 이 모듈에서 &lt;strong&gt;objects&lt;/strong&gt; 라는 저장된 용어 는 하나의 요소가 키로 정의되도록 튜플입니다. Dets &lt;strong&gt;테이블&lt;/strong&gt; 은 키가 파일에 저장된 동일한 위치에있는 개체의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="70f7f82b88797a35a1dc7be25685b1a8d3dd545e" translate="yes" xml:space="preserve">
          <source>This module provides a version of labeled directed graphs (&quot;digraphs&quot;).</source>
          <target state="translated">이 모듈은 레이블이 지정된 방향 그래프 ( &quot;digraphs&quot;) 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1620c061e4de1e2d509ff847686aeef840c94ae4" translate="yes" xml:space="preserve">
          <source>This module provides a version of labeled directed graphs. What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here.</source>
          <target state="translated">이 모듈은 레이블이 지정된 직접 그래프 버전을 제공합니다. 여기에 그래프를 적절하지 않은 방향으로 제공하는 그래프는 정점 사이의 여러 가장자리가 허용된다는 것입니다. 그러나 유 방향 그래프의 관례적인 정의가 여기에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cf7ab2f5fd96a0860285a8e510288d8e51d560" translate="yes" xml:space="preserve">
          <source>This module provides access to TCP/IP protocols.</source>
          <target state="translated">이 모듈은 TCP / IP 프로토콜에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce4f070d6f9440d796d3f2ff1b4d9fe245970d26" translate="yes" xml:space="preserve">
          <source>This module provides algorithms based on depth-first traversal of directed graphs. For basic functions on directed graphs, see the &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 방향 그래프의 깊이 우선 탐색을 기반으로 알고리즘을 제공합니다. 유 방향 그래프에 대한 기본 기능은 &lt;code&gt;&lt;a href=&quot;digraph&quot;&gt;digraph(3)&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="590c0955f816427dea3514fb29ccfa4c0c1b4c12" translate="yes" xml:space="preserve">
          <source>This module provides an API for network socket. Functions are provided to create, delete and manupilate the sockets aswell as sending and reciving data on them.</source>
          <target state="translated">이 모듈은 네트워크 소켓 용 API를 제공합니다. 소켓을 생성, 삭제 및 조작하고 소켓에 대한 데이터를 보내고받는 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c872a39dd86a1b96a68b0996c9785f1de2375352" translate="yes" xml:space="preserve">
          <source>This module provides an API for the network interface.</source>
          <target state="translated">이 모듈은 네트워크 인터페이스를위한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="750641c760c68123c0ef647455d03f63c154be54" translate="yes" xml:space="preserve">
          <source>This module provides an API for the zlib library (&lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt;). It is used to compress and decompress data. The data format is described by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 zlib 라이브러리 ( &lt;code&gt;&lt;a href=&quot;http://www.zlib.net&quot;&gt;www.zlib.net&lt;/a&gt;&lt;/code&gt; ) 용 API를 제공합니다 . 데이터를 압축 및 압축 해제하는 데 사용됩니다. 데이터 포맷은 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;&lt;/code&gt; 에 의해 설명된다 .</target>
        </trans-unit>
        <trans-unit id="faf120ddebe052c8dc6014a2841d031820c05adf" translate="yes" xml:space="preserve">
          <source>This module provides an Erlang shell.</source>
          <target state="translated">이 모듈은 Erlang 쉘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce785837b5ff1a707a464ab7d4098ba53cf3ddeb" translate="yes" xml:space="preserve">
          <source>This module provides an abstract type that is used by the Erlang Compiler and its helper modules for holding data such as column, line number, and text. The data type is a collection of &lt;strong id=&quot;annotations&quot;&gt;annotations&lt;/strong&gt; as described in the following.</source>
          <target state="translated">이 모듈은 열, 줄 번호 및 텍스트와 같은 데이터를 보유하기 위해 Erlang Compiler 및 해당 도우미 모듈에서 사용하는 추상 유형을 제공합니다. 데이터 유형은 다음에 설명 된 &lt;strong id=&quot;annotations&quot;&gt;주석&lt;/strong&gt; 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="c240161f74f286924b1ecba60c9826a37e901d2d" translate="yes" xml:space="preserve">
          <source>This module provides an interface for loading and unloading &lt;strong&gt;Erlang linked-in drivers&lt;/strong&gt; in runtime.</source>
          <target state="translated">이 모듈은 런타임 &lt;strong&gt;에서 Erlang 링크드 드라이버&lt;/strong&gt; 를로드 및 언로드하기위한 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="0d50e0a3798c5432e0aff3d79f28ece00952d5f8" translate="yes" xml:space="preserve">
          <source>This module provides an interface to a number of mathematical functions.</source>
          <target state="translated">이 모듈은 여러 수학 함수에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5733344375dbedf0030d51fc4fa5b63269782bb" translate="yes" xml:space="preserve">
          <source>This module provides an interface to files created by the BEAM Compiler (&quot;BEAM files&quot;). The format used, a variant of &quot;EA IFF 1985&quot; Standard for Interchange Format Files, divides data into chunks.</source>
          <target state="translated">이 모듈은 BEAM 컴파일러가 작성한 파일 ( &quot;BEAM 파일&quot;)에 대한 인터페이스를 제공합니다. 교환 형식 파일에 대한 &quot;EA IFF 1985&quot;표준의 변형 인 사용 된 형식은 데이터를 청크로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="4c0abe15371bacb3988f25e8e42f9bd6deaa06d4" translate="yes" xml:space="preserve">
          <source>This module provides an interface to standard Erlang I/O servers. The output functions all return &lt;code&gt;ok&lt;/code&gt; if they are successful, or exit if they are not.</source>
          <target state="translated">이 모듈은 표준 Erlang I / O 서버에 대한 인터페이스를 제공합니다. 출력 기능은 모두 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 반환하고, 실패하면 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bb92749dec61f65e77f765c953d790353efc379f" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the file system.</source>
          <target state="translated">이 모듈은 파일 시스템에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ea2060b34505717f9518e88bbe84cae8d4301f7" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the standard Erlang compiler. It can generate either a new file, which contains the object code, or return a binary, which can be loaded directly.</source>
          <target state="translated">이 모듈은 표준 Erlang 컴파일러에 대한 인터페이스를 제공합니다. 객체 코드가 포함 된 새 파일을 생성하거나 직접로드 할 수있는 이진을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e596baf52d2a5d67161fc159d66bc7111b7496e" translate="yes" xml:space="preserve">
          <source>This module provides an interpreter for Erlang expressions. The expressions are in the abstract syntax as returned by &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt;, the Erlang parser, or &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 Erlang 표현식에 대한 인터프리터를 제공합니다. 표현식은 &lt;code&gt;&lt;a href=&quot;erl_parse&quot;&gt;erl_parse&lt;/a&gt;&lt;/code&gt; , Erlang 파서 또는 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;io&lt;/a&gt;&lt;/code&gt; 에 의해 리턴되는 추상 구문에 있습니다.</target>
        </trans-unit>
        <trans-unit id="71c532b071cf1e2933fea5e0754fde5565914b25" translate="yes" xml:space="preserve">
          <source>This module provides computation of local and universal time, day of the week, and many time conversion functions.</source>
          <target state="translated">이 모듈은 현지 및 표준시, 요일 및 많은 시간 변환 기능의 계산을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f095529d267dab0aeb8e3b8b1364f61d105a9b58" translate="yes" xml:space="preserve">
          <source>This module provides for basic user authentication using textual files, Dets databases, or Mnesia databases.</source>
          <target state="translated">이 모듈은 텍스트 파일, Dets 데이터베이스 또는 Mnesia 데이터베이스를 사용한 기본 사용자 인증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c9257a7b2b5d2a4ae1e7c3b4a499e70e6fee999d" translate="yes" xml:space="preserve">
          <source>This module provides functions for allocating and deallocating memory.</source>
          <target state="translated">이 모듈은 메모리 할당 및 할당 해제 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d1acd3ec02989ce1863b1f9978f7179ed4f16a75" translate="yes" xml:space="preserve">
          <source>This module provides functions for analyzing and manipulating filenames. These functions are designed so that the Erlang code can work on many different platforms with different filename formats. With filename is meant all strings that can be used to denote a file. The filename can be a short relative name like &lt;code&gt;foo.erl&lt;/code&gt;, a long absolute name including a drive designator, a directory name like &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt;, or any variations in between.</source>
          <target state="translated">이 모듈은 파일 이름을 분석하고 조작하는 기능을 제공합니다. 이러한 기능은 Erlang 코드가 다른 파일 이름 형식을 가진 다양한 플랫폼에서 작동 할 수 있도록 설계되었습니다. 파일 이름은 파일을 나타내는 데 사용할 수있는 모든 문자열을 의미합니다. 파일 이름은 &lt;code&gt;foo.erl&lt;/code&gt; 과 같은 짧은 상대 이름 , 드라이브 지정자를 포함하는 긴 절대 이름, &lt;code&gt;D:\usr/local\bin\erl/lib\tools\foo.erl&lt;/code&gt; 과 같은 디렉토리 이름 또는 그 사이의 모든 변형 일 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="ba26786354c2721a7cffffe073a2f1107136ad72" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the SCTP protocol. The implementation assumes that the OS kernel supports SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; through the user-level &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 SCTP 프로토콜을 사용하여 소켓과 통신하기위한 기능을 제공합니다. 이 구현에서는 OS 커널 이 사용자 수준 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions&lt;/a&gt;&lt;/code&gt; 통해 SCTP &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;(RFC 2960)&lt;/a&gt;&lt;/code&gt; 를 지원한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="6237d5a917a923f45f8684296ea4f397f5ee1fec" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the TCP/IP protocol.</source>
          <target state="translated">이 모듈은 TCP / IP 프로토콜을 사용하여 소켓과 통신하기위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="047ce7d569f63519c312507e77fc10e7a0abdd77" translate="yes" xml:space="preserve">
          <source>This module provides functions for communicating with sockets using the UDP protocol.</source>
          <target state="translated">이 모듈은 UDP 프로토콜을 사용하여 소켓과 통신하기위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4170af0d02bb4471c502310e774e78bff4f783ba" translate="yes" xml:space="preserve">
          <source>This module provides functions for creating and manipulating Erlang terms.</source>
          <target state="translated">이 모듈은 Erlang 용어를 작성하고 조작하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1e4339ab7b3c28859324758d30d70eff072c8031" translate="yes" xml:space="preserve">
          <source>This module provides functions for starting Erlang slave nodes. All slave nodes that are started by a master terminate automatically when the master terminates. All terminal output produced at the slave is sent back to the master node. File I/O is done through the master.</source>
          <target state="translated">이 모듈은 Erlang 슬레이브 노드를 시작하는 기능을 제공합니다. 마스터가 시작한 모든 슬레이브 노드는 마스터가 종료되면 자동으로 종료됩니다. 슬레이브에서 생성 된 모든 터미널 출력은 마스터 노드로 다시 전송됩니다. 파일 I / O는 마스터를 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b46a173f5bc0dfe98e3415de1917b5e2303db97e" translate="yes" xml:space="preserve">
          <source>This module provides functions for string processing.</source>
          <target state="translated">이 모듈은 문자열 처리 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb4e067fc4ce218df6cee6a75080152b7287b4b0" translate="yes" xml:space="preserve">
          <source>This module provides operations on finite sets and relations represented as sets. Intuitively, a set is a collection of elements; every element belongs to the set, and the set contains every element.</source>
          <target state="translated">이 모듈은 유한 세트 및 세트로 표시되는 관계에 대한 조작을 제공합니다. 직관적으로, 집합은 요소의 모음입니다. 모든 요소는 세트에 속하며 세트에는 모든 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7c8f4236f4ac7c20019baf55ac92c3062eac4e" translate="yes" xml:space="preserve">
          <source>This module provides ordered sets using Prof. Arne Andersson's General Balanced Trees. Ordered sets can be much more efficient than using ordered lists, for larger sets, but depends on the application.</source>
          <target state="translated">이 모듈은 Arne Andersson 교수의 일반 균형 트리를 사용하여 주문 된 세트를 제공합니다. 정렬 된 세트는 더 큰 세트의 경우 정렬 된 목록을 사용하는 것보다 훨씬 효율적일 수 있지만 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ba40f5b3e99d275a596aa07c0dff3f599128accf" translate="yes" xml:space="preserve">
          <source>This module provides per-directory user configurable access control.</source>
          <target state="translated">이 모듈은 디렉토리 별 사용자 구성 가능 액세스 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c12c2072886f929b57ed6b57be79da289e76ef8" translate="yes" xml:space="preserve">
          <source>This module provides read and write access to the registry on Windows. It is essentially a port driver wrapped around the Win32 API calls for accessing the registry.</source>
          <target state="translated">이 모듈은 Windows에서 레지스트리에 대한 읽기 및 쓰기 액세스를 제공합니다. 기본적으로 레지스트리 액세스를위한 Win32 API 호출을 감싸는 포트 드라이버입니다.</target>
        </trans-unit>
        <trans-unit id="c778b6bf3c6ceb257250b7ae833621c36f93fd49" translate="yes" xml:space="preserve">
          <source>This module provides some limited support for concurrent access. All updates to single objects are guaranteed to be both &lt;strong&gt;atomic&lt;/strong&gt; and &lt;strong&gt;isolated&lt;/strong&gt;. This means that an updating operation to a single object either succeeds or fails completely without any effect (atomicity) and that no intermediate results of the update can be seen by other processes (isolation). Some functions that update many objects state that they even guarantee atomicity and isolation for the entire operation. In database terms the isolation level can be seen as &quot;serializable&quot;, as if all isolated operations are carried out serially, one after the other in a strict order.</source>
          <target state="translated">이 모듈은 동시 액세스에 대한 일부 제한된 지원을 제공합니다. 단일 객체에 대한 모든 업데이트는 &lt;strong&gt;원자 적&lt;/strong&gt; 이며 &lt;strong&gt;격리 된&lt;/strong&gt; 것이 &lt;strong&gt;어야&lt;/strong&gt; 합니다. 즉, 단일 개체에 대한 업데이트 작업이 아무런 효과 (원 자성)없이 성공하거나 실패하며 다른 프로세스 (격리)에서 업데이트의 중간 결과를 볼 수 없습니다. 많은 객체를 업데이트하는 일부 함수는 전체 작업에서 원자 성과 격리를 보장한다고 말합니다. 데이터베이스 용어에서 격리 수준은 &quot;일련 화 가능&quot;으로 볼 수 있습니다. 마치 모든 격리 된 작업이 엄격한 순서대로 순차적으로 수행되는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="e080461e2e77686f66945fda37287e52c6b43e16" translate="yes" xml:space="preserve">
          <source>This module provides support for communication between distributed Erlang nodes and C-nodes, in a manner that is transparent to Erlang processes.</source>
          <target state="translated">이 모듈은 Erlang 프로세스에 투명한 방식으로 분산 Erlang 노드와 C- 노드 간의 통신을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9dd15c5a43f249c41879dce22695542c08e92337" translate="yes" xml:space="preserve">
          <source>This module provides support for registering, looking up, and unregistering names in the &lt;code&gt;global&lt;/code&gt; module. For more information, see &lt;code&gt;kernel:global&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;global&lt;/code&gt; 모듈 에서 이름을 등록, 조회 및 등록 취소하는 기능을 지원 합니다. 자세한 정보는 &lt;code&gt;kernel:global&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="acc44f686954a04de29fbc3692f9d04d65486748" translate="yes" xml:space="preserve">
          <source>This module provides support for storing key-value pairs in a table known as a registry, backing up registries to &lt;code&gt;Mnesia&lt;/code&gt; in an atomic manner, and later restoring the contents of a registry from &lt;code&gt;Mnesia&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 레지스트리로 알려진 테이블에 키-값 쌍을 저장하고 레지스트리를 원자적인 방식으로 &lt;code&gt;Mnesia&lt;/code&gt; 에 백업 한 다음 나중에 &lt;code&gt;Mnesia&lt;/code&gt; 에서 레지스트리의 내용을 복원하는 기능을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="c4fb892b992e614adc88b69df82b17ae13945733" translate="yes" xml:space="preserve">
          <source>This module provides the API to an HTTP/1.1 compatible client according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt;. Caching is not supported.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 에 따라 HTTP / 1.1 호환 클라이언트에 API를 제공합니다 . 캐싱은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6480b6d56431c3c7e09177c0ce29744efb2ce799" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with miscellaneous utility functions.</source>
          <target state="translated">이 모듈은 Erlang 웹 서버 API 모듈 프로그래머에게 기타 유틸리티 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b8c5916e2632e665c5b2f5f52d5c56b0a93bc00" translate="yes" xml:space="preserve">
          <source>This module provides the Erlang web server API module programmer with utility functions for generic sockets communication. The appropriate communication mechanism is transparently used, that is, &lt;code&gt;ip_comm&lt;/code&gt; or &lt;code&gt;ssl&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 Erlang 웹 서버 API 모듈 프로그래머에게 일반 소켓 통신을위한 유틸리티 기능을 제공합니다. 적절한 통신 메커니즘, 즉 &lt;code&gt;ip_comm&lt;/code&gt; 또는 &lt;code&gt;ssl&lt;/code&gt; 이 투명하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a178749a79e6fb26e39ef05fff26033dce75ac3" translate="yes" xml:space="preserve">
          <source>This module provides the interface with which a user can implement a Diameter node that sends and receives messages using the Diameter protocol as defined in RFC 6733.</source>
          <target state="translated">이 모듈은 RFC 6733에 정의 된대로 Diameter 프로토콜을 사용하여 메시지를 보내고받는 Diameter 노드를 사용자가 구현할 수있는 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2290d99631f95e83db0417df2bd64d3d9576bcac" translate="yes" xml:space="preserve">
          <source>This module provides the most basic API to the clients and servers that are part of the &lt;code&gt;Inets&lt;/code&gt; application, such as start and stop.</source>
          <target state="translated">이 모듈은 시작 및 중지와 같이 &lt;code&gt;Inets&lt;/code&gt; 응용 프로그램의 일부인 클라이언트 및 서버에 가장 기본적인 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c2dc289d587182daff0825395e7477905794ef0d" translate="yes" xml:space="preserve">
          <source>This module provides the parse transformation that makes calls to &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; translate into literal match specifications. It also provides the back end for the same functions when called from the Erlang shell.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 에 대한 호출을 리터럴 일치 스펙으로 변환하는 구문 분석 변환을 제공합니다 . 또한 Erlang 쉘에서 호출 될 때 동일한 기능에 대한 백엔드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="721a3117429eceb8f061f5e2899bcbfb40bdf110" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;dict&lt;/code&gt; considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;dict&quot;&gt;dict(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공 하지만 정의 된 표현을 제공합니다. 한 가지 차이점은 &lt;code&gt;dict&lt;/code&gt; 에서 두 키가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 서로 다른 것으로 간주하지만이 모듈은 두 키가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교하지 않는 경우에만 다른 것으로 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f2cfe02c9b447eb5cee32eb141157e31208af9a7" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; module. One difference is that while this module considers two keys as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;orddict&lt;/code&gt; considers two keys as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;orddict&quot;&gt;orddict(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공합니다 . 한 가지 차이점은이 모듈이 두 개의 키가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 서로 다른 것으로 간주 하지만 &lt;code&gt;orddict&lt;/code&gt; 는 두 키가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교하지 않는 경우에만 두 개의 키를 다르게 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="38d6e52db1a80893122e1c828b20e43583ef95f9" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; module but with an undefined representation. One difference is that while this module considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), &lt;code&gt;ordsets&lt;/code&gt; considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;ordsets&quot;&gt;ordsets(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공 하지만 정의되지 않은 표현을 제공합니다. 한 가지 차이점은이 모듈이 두 요소가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 두 요소를 다르게 간주 하지만 &lt;code&gt;ordsets&lt;/code&gt; 는 두 요소가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교하지 않는 경우에만 두 요소를 다르게 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6fff0aaa0429816efbfd85cd732dd006ea6157aa" translate="yes" xml:space="preserve">
          <source>This module provides the same interface as the &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; module but with a defined representation. One difference is that while &lt;code&gt;sets&lt;/code&gt; considers two elements as different if they do not match (&lt;code&gt;=:=&lt;/code&gt;), this module considers two elements as different if and only if they do not compare equal (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;sets&quot;&gt;sets(3)&lt;/a&gt;&lt;/code&gt; 모듈 과 동일한 인터페이스를 제공 하지만 정의 된 표현을 제공합니다. 한 가지 차이점은 &lt;code&gt;sets&lt;/code&gt; 두 요소가 일치하지 않으면 ( &lt;code&gt;=:=&lt;/code&gt; ) 서로 다른 것으로 간주하지만이 모듈은 두 요소가 같거나 ( &lt;code&gt;==&lt;/code&gt; ) 비교되지 않는 경우에만 다른 것으로 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="742e632c6552d16bd6d478a7d1daf12903965f79" translate="yes" xml:space="preserve">
          <source>This module provides useful functions related to time. Unless otherwise stated, time is always measured in &lt;strong&gt;milliseconds&lt;/strong&gt;. All timer functions return immediately, regardless of work done by another process.</source>
          <target state="translated">이 모듈은 시간과 관련된 유용한 기능을 제공합니다. 달리 명시되지 않는 한, 시간은 항상 &lt;strong&gt;밀리 초 단위로&lt;/strong&gt; 측정됩니다 . 다른 프로세스에서 수행 한 작업에 관계없이 모든 타이머 기능이 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d4e83f9e995a297aeebc8e6a32d2dba035f338" translate="yes" xml:space="preserve">
          <source>This module provides utility functions for working with URIs, according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 에 따라 URI 작업을위한 유틸리티 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="69116d4fbcf6560d1469aa6a1f54ad5b50520175" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_channel.</source>
          <target state="translated">이 모듈은 ssh_channel을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e4595252d25beb7eb4255174f697d15c0830a38f" translate="yes" xml:space="preserve">
          <source>This module replaces ssh_daemon_channel.</source>
          <target state="translated">이 모듈은 ssh_daemon_channel을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="8aeeae3a06e268738003ec9e46ac483c94be8f5b" translate="yes" xml:space="preserve">
          <source>This module responses to requests for one or many ranges of a file. This is especially useful when downloading large files, as a broken download can be resumed.</source>
          <target state="translated">이 모듈은 하나 이상의 파일 범위에 대한 요청에 응답합니다. 깨진 파일을 다시 다운로드 할 수 있으므로 큰 파일을 다운로드 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="181bfa906d54214c120e83123d1185ab071fc48e" translate="yes" xml:space="preserve">
          <source>This module runs CGI scripts whenever a file of a certain type or HTTP method (see &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt;) is requested.</source>
          <target state="translated">이 모듈은 특정 유형의 파일 또는 HTTP 메소드 ( &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;&lt;/code&gt; 참조 )가 요청 될 때마다 CGI 스크립트를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="6cf32be7983eb16f31b4b6b42dc9e21cb5289f56" translate="yes" xml:space="preserve">
          <source>This module tokenises and parses most Erlang source code without expanding preprocessor directives and macro applications, as long as these are syntactically &quot;well-behaved&quot;. Because the normal parse trees of the &lt;code&gt;erl_parse&lt;/code&gt; module cannot represent these things (normally, they are expanded by the Erlang preprocessor &lt;code&gt;epp(3)&lt;/code&gt; before the parser sees them), an extended syntax tree is created, using the &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 구문 상 &quot;잘 동작&quot;하는 한 전 처리기 지시문 및 매크로 응용 프로그램을 확장하지 않고도 대부분의 Erlang 소스 코드를 토큰 화하고 구문 분석합니다. &lt;code&gt;erl_parse&lt;/code&gt; 모듈 의 일반 구문 분석 트리는 이러한 것들을 나타낼 수 없기 때문에 (일반적으로 파서가보기 전에 Erlang 프리 프로세서 &lt;code&gt;epp(3)&lt;/code&gt; )에 의해 확장됩니다) 확장 구문 트리는 &lt;code&gt;&lt;a href=&quot;erl_syntax&quot;&gt;erl_syntax&lt;/a&gt;&lt;/code&gt; 모듈을 사용하여 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="5da9ff3bf77e5f995d90689278c7a23b1597c8bb" translate="yes" xml:space="preserve">
          <source>This module uses a current key. It works much like the current directory. From the current key, values can be fetched, subkeys can be listed, and so on.</source>
          <target state="translated">이 모듈은 현재 키를 사용합니다. 현재 디렉토리와 매우 유사합니다. 현재 키에서 값을 가져올 수 있고 하위 키를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba20fa4df70d15689e43b0f44c7517efe1b08358" translate="yes" xml:space="preserve">
          <source>This module uses application &lt;code&gt;SSH&lt;/code&gt;, which provides detailed information about, for example, functions, types, and options.</source>
          <target state="translated">이 모듈은 기능, 유형 및 옵션과 같은 자세한 정보를 제공 하는 애플리케이션 &lt;code&gt;SSH&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c27440a34997ba37bea9913114676bb50554dcae" translate="yes" xml:space="preserve">
          <source>This module was written for one-to-many style sockets (type &lt;code&gt;seqpacket&lt;/code&gt;). With the addition of &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt;, one-to-one style sockets (type &lt;code&gt;stream&lt;/code&gt;) were introduced.</source>
          <target state="translated">이 모듈은 일대 다 스타일 소켓 ( &lt;code&gt;seqpacket&lt;/code&gt; 유형 ) 을 위해 작성되었습니다 . &lt;code&gt;&lt;a href=&quot;#peeloff-2&quot;&gt;peeloff/2&lt;/a&gt;&lt;/code&gt; 의 추가로 , 일대일 스타일 소켓 (타입 &lt;code&gt;stream&lt;/code&gt; )이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="606223ff437db337a77e6be8dc6a090de4bc5931" translate="yes" xml:space="preserve">
          <source>This modules contains the interface to the &lt;code&gt;heart&lt;/code&gt; process. &lt;code&gt;heart&lt;/code&gt; sends periodic heartbeats to an external port program, which is also named &lt;code&gt;heart&lt;/code&gt;. The purpose of the &lt;code&gt;heart&lt;/code&gt; port program is to check that the Erlang runtime system it is supervising is still running. If the port program has not received any heartbeats within &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds (defaults to 60 seconds), the system can be rebooted.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;heart&lt;/code&gt; 프로세스에 대한 인터페이스가 포함되어 있습니다 . &lt;code&gt;heart&lt;/code&gt; 는 정기적 인 하트 비트를 외부 포트 프로그램으로 보내며,이 프로그램은 &lt;code&gt;heart&lt;/code&gt; 라고도 합니다. &lt;code&gt;heart&lt;/code&gt; 포트 프로그램 의 목적 은 감시중인 Erlang 런타임 시스템이 여전히 실행 중인지 확인하는 것입니다. 포트 프로그램이 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 초 (기본값은 60 초) 내에 하트 비트를 수신하지 않으면 시스템을 재부팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f8a20f0be71ce686a1d45af49ce482f6a78d69" translate="yes" xml:space="preserve">
          <source>This must however be done with care, as function &lt;code&gt;{return_trace}&lt;/code&gt; in the match specification destroys tail recursiveness.</source>
          <target state="translated">그러나 일치 스펙의 함수 &lt;code&gt;{return_trace}&lt;/code&gt; 가 테일 재귀를 파괴 하므로주의해서 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="68582ac86e79db46d57ee06207c511b4a861bfb5" translate="yes" xml:space="preserve">
          <source>This node uses some master nodes to store and fetch release information. All master nodes must be operational whenever release information is written by this node.</source>
          <target state="translated">이 노드는 일부 마스터 노드를 사용하여 릴리스 정보를 저장하고 가져옵니다. 이 노드가 릴리스 정보를 쓸 때마다 모든 마스터 노드가 작동 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2b52bf50e58c3cc457e61abee1b9f82215c9813" translate="yes" xml:space="preserve">
          <source>This node.</source>
          <target state="translated">이 노드.</target>
        </trans-unit>
        <trans-unit id="768833241e4c41a51c30053841c9a5be0a33a799" translate="yes" xml:space="preserve">
          <source>This now works as expected:</source>
          <target state="translated">이제 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4858903cb179e40729be5206f937b3196b299dba" translate="yes" xml:space="preserve">
          <source>This of course requires your editor to support UTF-8 as well. The same comment is also interpreted by functions like &lt;code&gt;file:consult/1&lt;/code&gt;, the release handler, and so on, so that you can have all text files in your source directories in UTF-8 encoding.</source>
          <target state="translated">물론 에디터는 UTF-8도 지원해야합니다. 동일한 주석은 &lt;code&gt;file:consult/1&lt;/code&gt; , 릴리스 핸들러 등과 같은 함수로 해석 되므로 소스 디렉토리의 모든 텍스트 파일을 UTF-8 인코딩으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfffe74a9c7d9d5e838ee7506a86798e8b02c78d" translate="yes" xml:space="preserve">
          <source>This off-line utility function can be used to convert the old snmp application config (pre snmp-4.0) to the new snmp agent config (as of snmp-4.0).</source>
          <target state="translated">이 오프라인 유틸리티 기능을 사용하여 이전 snmp 응용 프로그램 구성 (snmp-4.0 이전)을 새로운 snmp 에이전트 구성 (snmp-4.0 기준)으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb2b5100380724d761bb0b871c669f6341e1d19e" translate="yes" xml:space="preserve">
          <source>This only applies if Erlang is started as a distributed node, i.e. if &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt; is specified. Otherwise, epmd is not started even if &lt;code&gt;-start_epmd true&lt;/code&gt; is given.</source>
          <target state="translated">이는 Erlang이 분산 노드로 시작된 경우, 즉 &lt;code&gt;-name&lt;/code&gt; 또는 &lt;code&gt;-sname&lt;/code&gt; 이 지정된 경우에만 적용됩니다 . 그렇지 않으면, -start_epmd &lt;code&gt;-start_epmd true&lt;/code&gt; 가 제공 되더라도 epmd가 시작되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36578cd782b1b1c7c098e80e28d83efcfb473d12" translate="yes" xml:space="preserve">
          <source>This operation is best described with an example.</source>
          <target state="translated">이 작업은 예제와 함께 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="726740b93f9a38ad69503060d61e78fcfc4ed2e8" translate="yes" xml:space="preserve">
          <source>This operation returns both configuration and state data from the server.</source>
          <target state="translated">이 작업은 서버에서 구성 및 상태 데이터를 모두 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c28d8949e39a67d4d2b916902211267c2c1b4e17" translate="yes" xml:space="preserve">
          <source>This option and option &lt;code&gt;match_limit&lt;/code&gt; are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits.</source>
          <target state="translated">이 옵션 및 옵션 &lt;code&gt;match_limit&lt;/code&gt; 는 드문 경우에만 사용됩니다. 이러한 한계를 변경하기 전에 PCRE 라이브러리 내부를 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b28bd6e66a4a300d7c55eecf5ec9dbf9fcd4dd0a" translate="yes" xml:space="preserve">
          <source>This option appears to be VERY Linux specific, and its existence in future Linux kernel versions is also worrying since the option is part of RFC 2292 which is since long (2003) obsoleted by RFC 3542 that &lt;strong&gt;explicitly&lt;/strong&gt; removes this possibility to get packet information from a stream socket. For comparision: it has existed in FreeBSD but is now removed, at least since FreeBSD 10.</source>
          <target state="translated">이 옵션은 옵션이 RFC 2292의 일부이기 때문에도 걱정 매우 리눅스 특정, 미래의 리눅스 커널 버전에서 그 존재가 될 것으로 보인다 오래 전부터 (2003) RFC 3542에 의해 대체 &lt;strong&gt;명시 적으로&lt;/strong&gt; A로부터 패킷 정보를 얻기 위해 이러한 가능성을 제거 스트림 소켓. 비교를 위해 : FreeBSD에 존재했지만 지금은 최소한 FreeBSD 10 이후로 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="6f9af6a987f2d3bf6639d97909039e3b4c47dc6a" translate="yes" xml:space="preserve">
          <source>This option augments the host name extraction from URIs and other Reference IDs. It could for example be a very special URI that is not standardised. The fun takes a Reference ID as argument and returns one of:</source>
          <target state="translated">이 옵션은 URI 및 기타 참조 ID에서 호스트 이름 추출을 향상시킵니다. 예를 들어 표준화되지 않은 매우 특수한 URI 일 수 있습니다. 재미는 참조 ID를 인수로 사용하여 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21da80d80de6786a8c35eb55211f1719f7ad6a3e" translate="yes" xml:space="preserve">
          <source>This option can also be used to override the default renaming of calls which use obsolete function names.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않는 함수 이름을 사용하는 기본 호출 이름 바꾸기를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb004a99221b3f8badd722205d40d87fd8410dc" translate="yes" xml:space="preserve">
          <source>This option can be used for adding members to a distributed disk log. Defaults to &lt;code&gt;[]&lt;/code&gt;, which means that the log is local on the current node.</source>
          <target state="translated">이 옵션은 분산 디스크 로그에 구성원을 추가하는 데 사용할 수 있습니다. 기본값은 &lt;code&gt;[]&lt;/code&gt; 로 , 현재 노드에서 로그가 로컬임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="23765e948e554b57ee502bc4f444d5a5c23a77a3" translate="yes" xml:space="preserve">
          <source>This option changes how the daemon execute exec-requests from clients. The term in the return value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-case but in the error case.</source>
          <target state="translated">이 옵션은 데몬이 클라이언트로부터 실행 요청을 실행하는 방법을 변경합니다. 리턴 값의 용어는 문자열이 아닌 유형 인 경우 문자열로 형식화됩니다. ok-case에는 후행 줄 바꿈이 추가되지 않지만 오류의 경우에는 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cf09fbce9857f3de6b83082c36031fa1a2e47db0" translate="yes" xml:space="preserve">
          <source>This option changes how the daemon executes exec-requests from clients. The term in the return value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-case.</source>
          <target state="translated">이 옵션은 데몬이 클라이언트의 exec-request를 실행하는 방법을 변경합니다. 반환 값의 용어는 문자열이 아닌 유형 인 경우 문자열로 형식이 지정됩니다. ok-case에는 후행 개행이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53106c8ee8480a565ca1694a5aee9779aed8d667" translate="yes" xml:space="preserve">
          <source>This option changes the representation of the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; to use maps (instead of records). This option also suppresses the generation of &lt;code&gt;.hrl&lt;/code&gt; files.</source>
          <target state="translated">이 옵션은 맵 대신 레코드를 사용하도록 &lt;code&gt;SEQUENCE&lt;/code&gt; 및 &lt;code&gt;SET&lt;/code&gt; 유형의 표시를 변경합니다 . 이 옵션은 또한 &lt;code&gt;.hrl&lt;/code&gt; 파일 생성을 억제 합니다.</target>
        </trans-unit>
        <trans-unit id="91dab051c90259277cd95566eff3cf880c2a9995" translate="yes" xml:space="preserve">
          <source>This option controls the debug level of &lt;code&gt;wx&lt;/code&gt;. As its name indicates it is only useful for debugging. See &lt;code&gt;wx:debug/1&lt;/code&gt; for more info.</source>
          <target state="translated">이 옵션은 &lt;code&gt;wx&lt;/code&gt; 의 디버그 레벨을 제어합니다 . 이름에서 알 수 있듯이 디버깅에만 유용합니다. 자세한 정보는 &lt;code&gt;wx:debug/1&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7ec5e0644c323d96923ea009ec73a058e3e14790" translate="yes" xml:space="preserve">
          <source>This option controls the error handling behavior of Reltool. By default the window processes traps exit, but this behavior can altered by setting &lt;code&gt;trap_exit&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 Reltool의 오류 처리 동작을 제어합니다. 기본적으로 창은 트랩 종료를 처리하지만 &lt;code&gt;trap_exit&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e73575c5bb05401f153a1b408d8ff447357a91" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;true&lt;/code&gt; for backwards compatibility but we intend to remove the exception behavior in a future release. New code that needs to handle dictionaries manually should always specify &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해이 옵션의 기본값은 &lt;code&gt;true&lt;/code&gt; 이지만 이후 릴리스에서는 예외 동작을 제거하려고합니다. 사전을 수동으로 처리해야하는 새 코드는 항상 &lt;code&gt;{exception_on_need_dict,false}&lt;/code&gt; 를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="24e5307f642c6711e98aa1e1851a0012231dc221" translate="yes" xml:space="preserve">
          <source>This option defines how the manager will handle the sending of response (acknowledgment) to received inform-requests.</source>
          <target state="translated">이 옵션은 관리자가 수신 된 정보 요청에 대한 응답 (확인) 전송을 처리하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0b065ec1d28b81abfd2469427265be5e95f2a102" translate="yes" xml:space="preserve">
          <source>This option determines which &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; are to be received (through &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;) along with the data. The only exception is &lt;code&gt;data_io_event&lt;/code&gt;, which enables or disables receiving of &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; ancillary data, not events. By default, all flags except &lt;code&gt;adaptation_layer_event&lt;/code&gt; are enabled, although &lt;code&gt;sctp_data_io_event&lt;/code&gt; and &lt;code&gt;association_event&lt;/code&gt; are used by the driver itself and not exported to the user level.</source>
          <target state="translated">이 옵션 은 데이터와 함께 수신 할 &lt;code&gt;&lt;a href=&quot;#sctp_events&quot;&gt;SCTP Events&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 를 통해 )를 결정합니다. 유일한 예외는 &lt;code&gt;data_io_event&lt;/code&gt; 입니다.이 이벤트는 이벤트가 아닌 &lt;code&gt;&lt;a href=&quot;#record-sctp_sndrcvinfo&quot;&gt;#sctp_sndrcvinfo{}&lt;/a&gt;&lt;/code&gt; 보조 데이터 수신을 활성화 또는 비활성화 합니다. &lt;code&gt;sctp_data_io_event&lt;/code&gt; 및 &lt;code&gt;association_event&lt;/code&gt; 는 드라이버 자체에서 사용되며 사용자 레벨로 내 보내지 않지만 &lt;code&gt;adaptation_layer_event&lt;/code&gt; 를 제외한 모든 플래그가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f54c1964a5e915a3b9d8124e81def1141091a66" translate="yes" xml:space="preserve">
          <source>This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. &lt;code&gt;run/3&lt;/code&gt; always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system.</source>
          <target state="translated">이 옵션은 &quot;장기 실행 BIF&quot;측면에서 Erlang VM의 실행에 영향을 미치지 않습니다. &lt;code&gt;run/3&lt;/code&gt; 은 항상 Erlang 시스템의 실시간 속성을 보장하는 간격으로 Erlang 프로세스의 스케줄러를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="6af47b199e89cf536046513882864286cab54688" translate="yes" xml:space="preserve">
          <source>This option does not guarantee exclusiveness on file systems not supporting &lt;code&gt;O_EXCL&lt;/code&gt; properly, such as NFS. Do not depend on this option unless you know that the file system supports it (in general, local file systems are safe).</source>
          <target state="translated">이 옵션은 NFS와 같이 &lt;code&gt;O_EXCL&lt;/code&gt; 을 제대로 지원하지 않는 파일 시스템에서만 사용할 수있는 것은 아닙니다 . 파일 시스템이 해당 파일 시스템을 지원한다는 것을 모르면이 옵션에 의존하지 마십시오 (일반적으로 로컬 파일 시스템은 안전합니다).</target>
        </trans-unit>
        <trans-unit id="170942e99acf8590a0f93f95af96a97ad9b43a74" translate="yes" xml:space="preserve">
          <source>This option guides the &lt;code&gt;connect&lt;/code&gt; function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for specifying the path to the file &lt;code&gt;known_hosts&lt;/code&gt; where previously accepted Host Keys are recorded. See also the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; for the general way to handle keys.</source>
          <target state="translated">이 옵션 은 연결된 서버가 클라이언트가 이전에 보지 못한 호스트 키를 제시 할 때 작동하는 방법에 대한 &lt;code&gt;connect&lt;/code&gt; 기능을 안내합니다 . 기본값은 새 호스트 키를 허용할지 거부할지 stdio에 대한 질문을 사용자에게 요청하는 것입니다. 이전에 승인 된 호스트 키가 기록되는 &lt;code&gt;known_hosts&lt;/code&gt; 파일의 경로를 지정하려면 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 . 키를 처리하는 일반적인 방법은 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e49306537910a313e44ea71c528fe60f8dac74f8" translate="yes" xml:space="preserve">
          <source>This option guides the &lt;code&gt;connect&lt;/code&gt; function on how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for specifying the path to the file &lt;code&gt;known_hosts&lt;/code&gt; where previously accepted Host Keys are recorded. See also the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; for the general way to handle keys.</source>
          <target state="translated">이 옵션 은 연결된 서버가 클라이언트가 이전에 본 적이없는 호스트 키를 제공 할 때 작동하는 방법에 대한 &lt;code&gt;connect&lt;/code&gt; 기능을 안내합니다 . 기본값은 stdio에서 새 호스트 키를 수락할지 거부할지에 대한 질문을 사용자에게 묻는 것입니다. 이전에 승인 된 호스트 키가 기록되는 &lt;code&gt;known_hosts&lt;/code&gt; 파일의 경로를 지정하려면 &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 . 키를 처리하는 일반적인 방법은 &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; 옵션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a3735f5d136203b9a8fbbbce887101fdaa70466" translate="yes" xml:space="preserve">
          <source>This option handles padding in the last block. If not set, no padding is done and any bytes in the last unfilled block is silently discarded.</source>
          <target state="translated">이 옵션은 마지막 블록의 패딩을 처리합니다. 설정하지 않으면 패딩이 수행되지 않고 마지막 채워지지 않은 블록의 모든 바이트가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f90278834c86b23c99e6715014b42f0de28741" translate="yes" xml:space="preserve">
          <source>This option has no effect when the function is given an I/O device instead of a file name. Use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;raw&lt;/code&gt; mode to obtain a file descriptor first.</source>
          <target state="translated">이 옵션은 함수에 파일 이름 대신 I / O 장치가 주어지면 효과가 없습니다. 사용 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;raw&lt;/code&gt; 먼저 파일 기술자를 얻을 모드.</target>
        </trans-unit>
        <trans-unit id="9f681818b307476626695654e1f4af8954537ac9" translate="yes" xml:space="preserve">
          <source>This option implies option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 옵션을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1b7df27500f11cd0120772f370d99f496bc69623" translate="yes" xml:space="preserve">
          <source>This option indicates weather the request should be resent until the reply is received, &lt;strong&gt;even&lt;/strong&gt; though a pending message has been received.</source>
          <target state="translated">이 옵션은 응답이 수신 될 때까지 요청을 재전송한다 날씨를 나타내는 &lt;strong&gt;도&lt;/strong&gt; 보류중인 메시지가 수신되었습니다 불구하고.</target>
        </trans-unit>
        <trans-unit id="6ee2dcf0c6730f63f33d0e9b597dde90cc7553c6" translate="yes" xml:space="preserve">
          <source>This option indicates weather the transport module should be told if a message send is a resend or not.</source>
          <target state="translated">이 옵션은 메시지 전송이 재전송되는지 여부에 따라 전송 모듈에 알려야하는 날씨를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f41d25f928d777038d78ec54aa87e0b2645ebe41" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; (in either order) results in 2 scheduler threads (50% of 4) and 1 scheduler thread online (25% of 4).</source>
          <target state="translated">이 옵션은 &lt;code&gt;&lt;a href=&quot;#+S&quot;&gt;+S&lt;/a&gt;&lt;/code&gt; 설정 과 상호 작용 합니다. 예를 들어, 8 개의 논리 코어가 구성되고 8 개의 논리 코어를 사용할 수있는 시스템에서 &lt;code&gt;+S 4:4 +SP 50:25&lt;/code&gt; 옵션을 조합하면 2 개의 스케줄러 스레드 (4의 50 %)와 1이 생성됩니다. 스케줄러 스레드 온라인 (4의 25 %).</target>
        </trans-unit>
        <trans-unit id="f69d8c25bc614477e7fde4538f00fb8866b22040" translate="yes" xml:space="preserve">
          <source>This option interacts with &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; settings. For example, on a system with 8 logical cores configured and 8 logical cores available, the combination of the options &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; (in either order) results in 2 dirty CPU scheduler threads (50% of 4) and 1 dirty CPU scheduler thread online (25% of 4).</source>
          <target state="translated">이 옵션은 &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;+SDcpu&lt;/a&gt;&lt;/code&gt; 설정 과 상호 작용 합니다. 예를 들어, 8 개의 논리 코어가 구성되고 8 개의 논리 코어가 사용 가능한 시스템에서 &lt;code&gt;+SDcpu 4:4 +SDPcpu 50:25&lt;/code&gt; 옵션을 조합하면 2 개의 더티 CPU 스케줄러 스레드 (4의 50 %)가 발생합니다. 1 개의 더티 CPU 스케줄러 스레드가 온라인 상태입니다 (4의 25 %).</target>
        </trans-unit>
        <trans-unit id="1b1652a93096a292ea9f23a8fb30440e0918cbec" translate="yes" xml:space="preserve">
          <source>This option is a fast way to test whether a module will compile successfully. This is useful for code generators that want to verify the code that they emit. No code is generated. If warnings are enabled, warnings generated by the &lt;code&gt;erl_lint&lt;/code&gt; module (such as warnings for unused variables and functions) are also returned.</source>
          <target state="translated">이 옵션은 모듈이 성공적으로 컴파일되는지 테스트하는 빠른 방법입니다. 이는 생성하는 코드를 확인하려는 코드 생성기에 유용합니다. 코드가 생성되지 않습니다. 경고가 활성화되면 &lt;code&gt;erl_lint&lt;/code&gt; 모듈에서 생성 된 경고 (예 : 사용하지 않는 변수 및 함수에 대한 경고)도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0bc4c98f53e89f54019044a7876ab12f92896246" translate="yes" xml:space="preserve">
          <source>This option is experimental.</source>
          <target state="translated">이 옵션은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="bebef7a4d11a54b9572f9f20a10693f30204b1e4" translate="yes" xml:space="preserve">
          <source>This option is highly recommended. It makes &lt;code&gt;run_erl&lt;/code&gt; run in the background completely detached from any controlling terminal and the command returns to the caller immediately. Without this option, &lt;code&gt;run_erl&lt;/code&gt; must be started using several tricks in the shell to detach it completely from the terminal in use when starting it. The option must be the first argument to &lt;code&gt;run_erl&lt;/code&gt; on the command line.</source>
          <target state="translated">이 옵션을 적극 권장합니다. 그것은 만드는 &lt;code&gt;run_erl&lt;/code&gt; 완전히 즉시 발신자에 대한 제어 단자와 명령 반환에서 분리 백그라운드에서 실행. 이 옵션이 없으면 &lt;code&gt;run_erl&lt;/code&gt; 을 시작할 때 사용중인 터미널에서 완전히 분리하기 위해 쉘에서 여러 가지 트릭을 사용하여 시작해야합니다. 옵션은 명령 행 에서 &lt;code&gt;run_erl&lt;/code&gt; 의 첫 번째 인수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="799c0d875ea63318c2c432ae65671fb00f9b1962" translate="yes" xml:space="preserve">
          <source>This option is more useful. Here, reloading is queued if the driver is &lt;strong&gt;not&lt;/strong&gt; loaded by any other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt;, but the driver has opened ports, in which case &lt;code&gt;{ok, pending_driver}&lt;/code&gt; is returned (a &lt;code&gt;monitor&lt;/code&gt; option is recommended).</source>
          <target state="translated">이 옵션이 더 유용합니다. 여기서 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 드라이버를 로드 &lt;strong&gt;하지&lt;/strong&gt; 않았지만 드라이버가 포트를 열면 다시로드가 대기됩니다. 이 경우 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 가 반환됩니다 ( &lt;code&gt;monitor&lt;/code&gt; 옵션 권장).</target>
        </trans-unit>
        <trans-unit id="25d785f39f2ca30f9744131492e2e56cf2d21d95" translate="yes" xml:space="preserve">
          <source>This option is not allowed on &lt;code&gt;raw&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 파일 에는이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="66882999b7df0a61e482c56ef50205c317d913f0" translate="yes" xml:space="preserve">
          <source>This option is not normally supported (see why below). OTP has to be explicitly built with the &lt;code&gt;--enable-esock-rcvsndtime&lt;/code&gt; configure option for this to be available. Since our implementation is &lt;strong&gt;nonblocking&lt;/strong&gt;, its unknown if and how this option works, or even if it may cause malfunctions. Therefor, we do not recommend setting this option. Instead, use the &lt;code&gt;Timeout&lt;/code&gt; argument to, for instance, the &lt;code&gt;&lt;a href=&quot;socket#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이 옵션은 일반적으로 지원되지 않습니다 (아래 이유 참조). OTP를 사용하려면 &lt;code&gt;--enable-esock-rcvsndtime&lt;/code&gt; 구성 옵션을 사용하여 명시 적으로 빌드 해야합니다. 우리의 구현은 &lt;strong&gt;nonblocking&lt;/strong&gt; 이기 때문에이 옵션이 작동하는지, 어떻게 작동하는지 또는 오작동을 일으킬 수 있는지 알 수 없습니다. 따라서이 옵션을 설정하지 않는 것이 좋습니다. 대신, 예를 들어 &lt;code&gt;&lt;a href=&quot;socket#recv-3&quot;&gt;recv/3&lt;/a&gt;&lt;/code&gt; 함수에 &lt;code&gt;Timeout&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3f57200882dc1e247d7d39a885535f951742ea8" translate="yes" xml:space="preserve">
          <source>This option is not normally supported (see why below). OTP has to be explicitly built with the &lt;code&gt;--enable-esock-rcvsndtime&lt;/code&gt; configure option for this to be available. Since our implementation is &lt;strong&gt;nonblocking&lt;/strong&gt;, its unknown if and how this option works, or even if it may cause malfunctions. Therefor, we do not recommend setting this option. Instead, use the &lt;code&gt;Timeout&lt;/code&gt; argument to, for instance, the &lt;code&gt;&lt;a href=&quot;socket#send-3&quot;&gt;send/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이 옵션은 일반적으로 지원되지 않습니다 (아래 이유 참조). OTP를 사용하려면 &lt;code&gt;--enable-esock-rcvsndtime&lt;/code&gt; 구성 옵션을 사용하여 명시 적으로 빌드 해야합니다. 우리의 구현은 &lt;strong&gt;nonblocking&lt;/strong&gt; 이기 때문에이 옵션이 작동하는지, 어떻게 작동하는지 또는 오작동을 일으킬 수 있는지 알 수 없습니다. 따라서이 옵션을 설정하지 않는 것이 좋습니다. 대신, 예를 들어 &lt;code&gt;&lt;a href=&quot;socket#send-3&quot;&gt;send/3&lt;/a&gt;&lt;/code&gt; 함수에 &lt;code&gt;Timeout&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f286491eda734e921e24014e8a8a1eb9199ffbe" translate="yes" xml:space="preserve">
          <source>This option is not recommended.</source>
          <target state="translated">이 옵션은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f578117bb772460a22238ad9cfabbec82d626246" translate="yes" xml:space="preserve">
          <source>This option is only meaningful if option &lt;code&gt;binary&lt;/code&gt; was specified when the socket was created. If option &lt;code&gt;header&lt;/code&gt; is specified, the first &lt;code&gt;Size&lt;/code&gt; number bytes of data received from the socket are elements of a list, and the remaining data is a binary specified as the tail of the same list. For example, if &lt;code&gt;Size == 2&lt;/code&gt;, the data received matches &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 소켓이 작성 될 때 옵션 &lt;code&gt;binary&lt;/code&gt; 진이 지정된 경우에만 의미가 있습니다 . 옵션 &lt;code&gt;header&lt;/code&gt; 가 지정되면 소켓에서 수신 된 데이터 의 첫 번째 &lt;code&gt;Size&lt;/code&gt; 번호 바이트는 목록의 요소이며 나머지 데이터는 동일한 목록의 꼬리로 지정된 이진입니다. 예를 들어, &lt;code&gt;Size == 2&lt;/code&gt; 인 경우 수신 된 데이터는 &lt;code&gt;[Byte1,Byte2|Binary]&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="6aa3b24e42c5627fceb7d3a4c574f35704adb386" translate="yes" xml:space="preserve">
          <source>This option is only supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;).</source>
          <target state="translated">이 옵션은 표준 쉘 ( &lt;code&gt;group.erl&lt;/code&gt; ) 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="b072703d1b18dfc3f9f5977b6079b835f0224f83" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the parameters specific to the peer address specified by &lt;code&gt;address&lt;/code&gt; within the association specified by &lt;code&gt;assoc_id&lt;/code&gt;. Field &lt;code&gt;address&lt;/code&gt; fmust be set by the caller; all other fields are filled in on return. If &lt;code&gt;assoc_id = 0&lt;/code&gt; (default), the &lt;code&gt;address&lt;/code&gt; is automatically translated into the corresponding association ID. This option is rarely used. For the semantics of all fields, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 읽기 전용입니다. 이것은 피어에 의해 지정된 주소로 특정 파라미터 결정 &lt;code&gt;address&lt;/code&gt; 로 지정된 관계 내의 &lt;code&gt;assoc_id&lt;/code&gt; 를 . 발신자가 필드 &lt;code&gt;address&lt;/code&gt; 설정해야합니다. 다른 모든 필드는 반환시 채워집니다. 경우 &lt;code&gt;assoc_id = 0&lt;/code&gt; (디폴트)은 &lt;code&gt;address&lt;/code&gt; 자동 대응하는 연관 ID로 변환된다. 이 옵션은 거의 사용되지 않습니다. 모든 필드의 의미에 대해서는 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="195222e570592e1300b4b25ab1af9e1c8e8e90bb" translate="yes" xml:space="preserve">
          <source>This option is read-only. It determines the status of the SCTP association specified by &lt;code&gt;assoc_id&lt;/code&gt;. The following are the possible values of &lt;code&gt;state&lt;/code&gt; (the state designations are mostly self-explanatory):</source>
          <target state="translated">이 옵션은 읽기 전용입니다. &lt;code&gt;assoc_id&lt;/code&gt; 로 지정된 SCTP 연관 상태를 판별합니다 . 다음은 가능한 &lt;code&gt;state&lt;/code&gt; 값입니다 (상태 지정은 대부분 설명이 필요함).</target>
        </trans-unit>
        <trans-unit id="2a7c2f54502986cac56e74f74f0507e617134fa9" translate="yes" xml:space="preserve">
          <source>This option is removed, it generates a fatal error if used.</source>
          <target state="translated">이 옵션은 제거되어 사용하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d0dc8c0d9bb7eab4181aa210080e8a3266e279c" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">이 옵션은 기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa903c4555e4c89c59fa07465d374edfda939a99" translate="yes" xml:space="preserve">
          <source>This option is supported by TLS 1.3 and above and only with stateless session tickets. Ticket lifetime, the number of tickets sent by the server and the maximum number of tickets stored by the server in stateful mode are configured by &lt;code&gt;application variables&lt;/code&gt;. See also &lt;code&gt; SSL's Users Guide, Anti-Replay Protection in TLS 1.3&lt;/code&gt;</source>
          <target state="translated">이 옵션은 TLS 1.3 이상에서 상태 비 저장 세션 티켓에서만 지원됩니다. 티켓 수명, 서버가 보낸 티켓 수 및 상태 저장 모드에서 서버가 저장하는 최대 티켓 수는 &lt;code&gt;application variables&lt;/code&gt; 로 구성됩니다 . &lt;code&gt; SSL's Users Guide, Anti-Replay Protection in TLS 1.3&lt;/code&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="70e6a186e299c39a9ea4c11bb023a5500cff5bee" translate="yes" xml:space="preserve">
          <source>This option is supported by TLS 1.3 and above. See also &lt;code&gt; SSL's Users Guide, Session Tickets and Session Resumption in TLS 1.3&lt;/code&gt;</source>
          <target state="translated">이 옵션은 TLS 1.3 이상에서 지원됩니다. &lt;code&gt; SSL's Users Guide, Session Tickets and Session Resumption in TLS 1.3&lt;/code&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0aa3e98f799062b3c35a4a811d03b341b1e599" translate="yes" xml:space="preserve">
          <source>This option is supported by the standard shell (&lt;code&gt;group.erl&lt;/code&gt;), the 'oldshell' (&lt;code&gt;user.erl&lt;/code&gt;), and the file I/O servers.</source>
          <target state="translated">이 옵션은 표준 쉘 ( &lt;code&gt;group.erl&lt;/code&gt; ), 'oldshell'( &lt;code&gt;user.erl&lt;/code&gt; ) 및 파일 I / O 서버에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a3a12611755048747534c6172534fba6193da6" translate="yes" xml:space="preserve">
          <source>This option is to be used only while running &lt;code&gt;erts_alloc_config(3)&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt; when using the created configuration.</source>
          <target state="translated">이 옵션을 실행하는 동안에 만 사용되는 &lt;code&gt;erts_alloc_config(3)&lt;/code&gt; , &lt;strong&gt;하지&lt;/strong&gt; 생성 된 구성을 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="889aee4f7fdaed4924ebd813f97d33cc589d7043" translate="yes" xml:space="preserve">
          <source>This option is typically used when building or modifying a PLT as in:</source>
          <target state="translated">이 옵션은 일반적으로 다음과 같이 PLT를 작성하거나 수정할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="edf2a03815bd1d16fe28550db84f5fb84528060e" translate="yes" xml:space="preserve">
          <source>This option is used to &lt;strong&gt;reload&lt;/strong&gt; a driver from disk, most often in a code upgrade scenario. Having a &lt;code&gt;reload&lt;/code&gt; option also implies that parameter &lt;code&gt;Path&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; need to be consistent with earlier loads of the driver.</source>
          <target state="translated">이 옵션은 코드 업그레이드 시나리오에서 디스크에서 드라이버 를 &lt;strong&gt;다시로드&lt;/strong&gt; 하는 데 사용됩니다 . 갖는 &lt;code&gt;reload&lt;/code&gt; 옵션도 해당 매개 변수의 의미 &lt;code&gt;Path&lt;/code&gt; 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 드라이버의 이전 부하와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf140f37714af5051b513ac4d8ca12c2978c9cf5" translate="yes" xml:space="preserve">
          <source>This option only affects decentralized counters used for the counters that are keeping track of the memory consumption and the number of terms in ETS tables of type ordered_set with the write_concurrency option activated.</source>
          <target state="translated">이 옵션은 write_concurrency 옵션이 활성화 된 ordered_set 유형의 ETS 테이블에서 메모리 소비 및 용어 수를 추적하는 카운터에 사용되는 분산 카운터에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d51f4b2d1bb2d48353207aa92dd60bc3873e9f8f" translate="yes" xml:space="preserve">
          <source>This option should be set to &lt;code&gt;false&lt;/code&gt; since a sufficiently malicious peer can otherwise cause large amounts of memory to be consumed when decoded Diameter messages are passed between processes. The default value is for backwards compatibility.</source>
          <target state="translated">디코딩 된 직경 메시지가 프로세스간에 전달 될 때 충분히 악의적 인 피어가 많은 양의 메모리를 소비 할 수 있으므로이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 . 기본값은 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="57817b80cdc930329e3a4d5793e370393a3211f0" translate="yes" xml:space="preserve">
          <source>This option specifies how basic mib data is stored. This option is used by two parts of the snmp agent: The mib-server and the symbolic-store.</source>
          <target state="translated">이 옵션은 기본 mib 데이터가 저장되는 방법을 지정합니다. 이 옵션은 snmp 에이전트의 두 부분 (mib-server 및 symbolic-store)에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="058b954e4120837a0a6cb03a7efdf187ce8adda6" translate="yes" xml:space="preserve">
          <source>This option specifies how the server will handle callback calls.</source>
          <target state="translated">이 옵션은 서버가 콜백 호출을 처리하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="16bffdd8047471540c8529b9376dd26910c55b7e" translate="yes" xml:space="preserve">
          <source>This option specifies if the server should actively supervise the net-if process. Note that this will only work if the used net-if process actually supports the protocol. See &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; behaviour for more info.</source>
          <target state="translated">이 옵션은 서버가 net-if 프로세스를 적극적으로 감독해야하는지 여부를 지정합니다. 이것은 사용 된 net-if 프로세스가 실제로 프로토콜을 지원하는 경우에만 작동합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;snmpm_network_interface&quot;&gt;snmpm_network_interface&lt;/a&gt;&lt;/code&gt; 동작을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff5c27e867a6f1798699a8d8412847ef2c9f83ca" translate="yes" xml:space="preserve">
          <source>This option specifies if the user shall be notified of received segment replies or not.</source>
          <target state="translated">이 옵션은 사용자에게 수신 된 세그먼트 응답에 대한 통지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e191bd75bc4b33a8992d72798fec2d5cb030668d" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific socket option &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt;, such as in Linux kernel 2.0.30 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">이 옵션은 Linux 커널 2.0.30 이상에서와 같이 Linux 특정 소켓 옵션 &lt;code&gt;SO_BINDTODEVICE&lt;/code&gt; 를 사용 하므로 런타임 시스템이 해당 운영 체제 용으로 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2b531690e0f1058c69b2d245e35526e30090198c" translate="yes" xml:space="preserve">
          <source>This option uses the Linux-specific syscall &lt;code&gt;setns()&lt;/code&gt;, such as in Linux kernel 3.0 or later, and therefore only exists when the runtime system is compiled for such an operating system.</source>
          <target state="translated">이 옵션은 Linux 커널 3.0 이상과 같은 Linux 특정 syscall &lt;code&gt;setns()&lt;/code&gt; 하므로 런타임 시스템이 해당 운영 체제 용으로 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="44252bdcc3d79897b51179b686a1c2db9495ee64" translate="yes" xml:space="preserve">
          <source>This option will be removed in a future release. The return value will always be &lt;code&gt;false&lt;/code&gt;, as the &lt;code&gt;elib_malloc&lt;/code&gt; allocator has been removed.</source>
          <target state="translated">이 옵션은 다음 릴리스에서 제거 될 예정입니다. 반환 값은 항상있을 것입니다 &lt;code&gt;false&lt;/code&gt; 은 AS, &lt;code&gt;elib_malloc&lt;/code&gt; 의 할당이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0dabdcd13ff03271c7b6e7a946847dbd231dc01" translate="yes" xml:space="preserve">
          <source>This option will use a lot of memory when enabled, which must be reclaimed with &lt;code&gt;lcnt:rt_clear&lt;/code&gt;. Note that it makes no distinction between locks that were destroyed and locks for which counting was disabled, so enabling this option will disable changes to the lock category mask.</source>
          <target state="translated">이 옵션은 활성화 될 때 많은 메모리를 사용하며, &lt;code&gt;lcnt:rt_clear&lt;/code&gt; 로 교정해야합니다 . 소멸 된 잠금과 계산이 비활성화 된 잠금을 구분하지 않으므로이 옵션을 사용하면 잠금 범주 마스크에 대한 변경이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="63372d9f26162432c70de9dd21cb0a2fa14e443c" translate="yes" xml:space="preserve">
          <source>This package contains modules for handling abstract syntax trees (ASTs) in Erlang, in a way that is compatible with the &quot;abstract format&quot; parse trees of the stdlib module &lt;code&gt;erl_parse&lt;/code&gt;, together with utilities for reading source files, &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt;, and doing &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; in Erlang.</source>
          <target state="translated">이 패키지에는 Erdlan의 추상 구문 트리 (AST)를 처리하기위한 모듈이 포함되어 있으며, stdlib 모듈 &lt;code&gt;erl_parse&lt;/code&gt; 의 &quot;추상 형식&quot;구문 분석 트리와 호환되며 소스 파일을 읽기위한 유틸리티, &lt;code&gt;&lt;a href=&quot;erl_prettypr&quot;&gt;pretty-printing syntax trees&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;igor&quot;&gt;merging and renaming modules&lt;/a&gt;&lt;/code&gt; Erlang에서 모듈 이름 바꾸기 , &lt;code&gt;&lt;a href=&quot;erl_tidy&quot;&gt;cleaning up obsolete constructs&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;merl&quot;&gt;metaprogramming&lt;/a&gt;&lt;/code&gt; 수행 .</target>
        </trans-unit>
        <trans-unit id="2aa90d46e1988deecd458f84f25660e5efaeb6ec" translate="yes" xml:space="preserve">
          <source>This page presents a summary of values from all allocators underneath it.</source>
          <target state="translated">이 페이지에는 그 아래에있는 모든 할당 자의 값이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="239f6919f70832c0fd44ac0346db01f8572c3052" translate="yes" xml:space="preserve">
          <source>This pair of functions are used when open ports to the driver are to be killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; to allow for new driver code to get loaded.</source>
          <target state="translated">이 드라이버 쌍은 &lt;code&gt;driver_unloaded&lt;/code&gt; 이유와 함께 드라이버에 대한 열린 포트를 강제 종료 하여 새 드라이버 코드를로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1602bf3b2d8c23237b0a61febcf52e3e006d8036" translate="yes" xml:space="preserve">
          <source>This pair of functions is used when reloading is to be done after the last open port to the driver is closed.</source>
          <target state="translated">이 기능 쌍은 드라이버에 대한 마지막 열린 포트가 닫힌 후 다시로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f14b771e39c5dc99621a28cd9cae451233b4cbb8" translate="yes" xml:space="preserve">
          <source>This parameter contains a list of options that are given to &lt;code&gt;zip:create/3&lt;/code&gt; when application specific files are packaged into an archive. Only a subset of the options are supported. The most useful options in this context are the ones that control which types of files should be compressed. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 응용 프로그램 특정 파일이 아카이브에 패키지 될 때 &lt;code&gt;zip:create/3&lt;/code&gt; 에 제공되는 옵션 목록이 있습니다 . 옵션의 일부만 지원됩니다. 이 컨텍스트에서 가장 유용한 옵션은 압축 할 파일 형식을 제어하는 ​​옵션입니다. 이 매개 변수의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58e5c112e068eb199424c98749e9d0931666cadb" translate="yes" xml:space="preserve">
          <source>This parameter controls the application and escript inclusion policy. It defaults to &lt;code&gt;derived&lt;/code&gt; which means that the applications that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting, will only be included if any other (explicitly or implicitly included) application uses it. The value &lt;code&gt;include&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be included. &lt;code&gt;exclude&lt;/code&gt; implies that all applications and escripts that do not have any explicit &lt;code&gt;incl_cond&lt;/code&gt; setting will be excluded.</source>
          <target state="translated">이 매개 변수는 응용 프로그램 및 escript 포함 정책을 제어합니다. 기본적으로 &lt;code&gt;derived&lt;/code&gt; &lt;code&gt;incl_cond&lt;/code&gt; 명시 적 incl_cond 설정 이없는 응용 프로그램이 다른 응용 프로그램에서 명시 적 또는 암시 적으로 포함 된 경우에만 포함됨을 의미합니다. &lt;code&gt;include&lt;/code&gt; 값 은 명시적인 &lt;code&gt;incl_cond&lt;/code&gt; 설정이 없는 모든 응용 프로그램 및 escript가 포함됨을 의미합니다 . &lt;code&gt;exclude&lt;/code&gt; 는 명시적인 &lt;code&gt;incl_cond&lt;/code&gt; 설정이 없는 모든 응용 프로그램 및 escript가 제외됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="43b8b48e3d3e4e5f584a2110e61fc94f1dda52fb" translate="yes" xml:space="preserve">
          <source>This parameter controls the default handling of the &lt;code&gt;app&lt;/code&gt; files when a target system is generated. It defaults to &lt;code&gt;keep&lt;/code&gt; which means that &lt;code&gt;app&lt;/code&gt; files are copied to the target system and their contents are kept as they are. &lt;code&gt;strip&lt;/code&gt; means that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file where the non included modules are removed from the file. &lt;code&gt;all&lt;/code&gt; does also imply that a new &lt;code&gt;app&lt;/code&gt; file is generated from the contents of the original &lt;code&gt;app&lt;/code&gt; file, with the difference that all included modules are added to the file. If the application does not have any &lt;code&gt;app&lt;/code&gt; file a file will be created for &lt;code&gt;all&lt;/code&gt; but not for &lt;code&gt;keep&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 대상 시스템이 생성 될 때 &lt;code&gt;app&lt;/code&gt; 파일 의 기본 처리를 제어합니다 . 기본값은 &lt;code&gt;keep&lt;/code&gt; 입니다. 즉, &lt;code&gt;app&lt;/code&gt; 파일이 대상 시스템에 복사되고 해당 내용이 그대로 유지됩니다. &lt;code&gt;strip&lt;/code&gt; 은 포함되지 않은 모듈이 파일에서 제거 된 원본 &lt;code&gt;app&lt;/code&gt; 파일 의 내용에서 새 &lt;code&gt;app&lt;/code&gt; 파일이 생성됨을 의미 합니다. &lt;code&gt;all&lt;/code&gt; 는 포함 된 모든 모듈이 파일에 추가되는 차이와 함께 원래 &lt;code&gt;app&lt;/code&gt; 파일 의 내용에서 새 &lt;code&gt;app&lt;/code&gt; 파일이 생성됨을 의미 합니다. 애플리케이션에 &lt;code&gt;app&lt;/code&gt; 이없는 경우파일은 &lt;code&gt;keep&lt;/code&gt; 및 &lt;code&gt;strip&lt;/code&gt; 위한 것이 아니라 &lt;code&gt;all&lt;/code&gt; 위해 생성 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="178517341ccd2e5776c2cccf896941a880130c85" translate="yes" xml:space="preserve">
          <source>This parameter controls the module inclusion policy. It defaults to &lt;code&gt;all&lt;/code&gt; which means that if an application is included (either explicitly or implicitly) all modules in that application will be included. This implies that both modules that exist in the &lt;code&gt;ebin&lt;/code&gt; directory of the application, as well as modules that are named in the &lt;code&gt;app&lt;/code&gt; file will be included. If the parameter is set to &lt;code&gt;ebin&lt;/code&gt;, both modules in the &lt;code&gt;ebin&lt;/code&gt; directory and derived modules are included. If the parameter is set to &lt;code&gt;app&lt;/code&gt;, both modules in the &lt;code&gt;app&lt;/code&gt; file and derived modules are included. &lt;code&gt;derived&lt;/code&gt; means that only modules that are used by other included modules are included. The &lt;code&gt;mod_cond&lt;/code&gt; setting on system level is used as default for all applications.</source>
          <target state="translated">이 매개 변수는 모듈 포함 정책을 제어합니다. 기본값은 &lt;code&gt;all&lt;/code&gt; 입니다. 즉, 응용 프로그램이 명시 적 또는 암시 적으로 포함 된 경우 해당 응용 프로그램의 모든 모듈이 포함됩니다. 이는 애플리케이션 의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에 존재 하는 모듈과 &lt;code&gt;app&lt;/code&gt; 파일에 이름이 지정된 모듈이 모두 포함됨을 의미합니다. 매개 변수가 &lt;code&gt;ebin&lt;/code&gt; 으로 설정 되면 &lt;code&gt;ebin&lt;/code&gt; 디렉토리의 모듈과 파생 모듈이 모두 포함됩니다. 매개 변수가 &lt;code&gt;app&lt;/code&gt; 으로 설정 되면 &lt;code&gt;app&lt;/code&gt; 파일의 모듈과 파생 모듈이 모두 포함됩니다. &lt;code&gt;derived&lt;/code&gt; 포함 된 다른 모듈에서 사용하는 모듈 만 포함됨을 의미합니다. 시스템 레벨 의 &lt;code&gt;mod_cond&lt;/code&gt; 설정은 모든 응용 프로그램의 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f35dbde0b2e6b7417fe1079d2c8cb135463fb518" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the &lt;code&gt;erl&lt;/code&gt; executable in the target system should automatically determine where it is installed or if it should use a hardcoded path to the installation. In the latter case the target system must be installed with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be used. If the system is relocatable, the file tree containing the target system can be moved to another location without re-installation. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 대상 시스템 의 &lt;code&gt;erl&lt;/code&gt; 실행 파일이 설치 위치를 자동으로 결정해야하는지 또는 하드 코딩 된 설치 경로를 사용 해야하는지 여부를 제어합니다 . 후자의 경우 대상 시스템을 사용하기 전에 &lt;code&gt;reltool:install/2&lt;/code&gt; 와 함께 설치해야합니다 . 시스템을 재배치 할 수 있으면 대상 시스템을 포함하는 파일 트리를 다시 설치하지 않고 다른 위치로 이동할 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18eec3d4c813ec5a22514b8e2727f74034894ae8" translate="yes" xml:space="preserve">
          <source>This parameter controls whether the module is included or not. By default the &lt;code&gt;mod_cond&lt;/code&gt; parameter on application and system level will be used to control whether the module is included or not. The value of &lt;code&gt;incl_cond&lt;/code&gt; overrides the module inclusion policy. &lt;code&gt;include&lt;/code&gt; implies that the module is included, while &lt;code&gt;exclude&lt;/code&gt; implies that the module is not included. &lt;code&gt;derived&lt;/code&gt; implies that the module is included if it is used by any other included module.</source>
          <target state="translated">이 매개 변수는 모듈의 포함 여부를 제어합니다. 기본적 으로 응용 프로그램 및 시스템 레벨 의 &lt;code&gt;mod_cond&lt;/code&gt; 매개 변수는 모듈의 포함 여부를 제어하는 ​​데 사용됩니다. &lt;code&gt;incl_cond&lt;/code&gt; 값은 모듈 포함 정책을 재정의합니다. &lt;code&gt;include&lt;/code&gt; 은 모듈이 포함되어 있음을 의미하고 &lt;code&gt;exclude&lt;/code&gt; 는 모듈이 포함되어 있지 않음을 의미합니다. &lt;code&gt;derived&lt;/code&gt; 은 포함 된 다른 모듈에서 모듈을 사용하는 경우 포함 된 모듈임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="40145ab28fcdbc933f15879eca2c3243c28ec539" translate="yes" xml:space="preserve">
          <source>This parameter defines the error report type used when messages are sent to error logger using the default callback function. Default is &lt;code&gt;std_error&lt;/code&gt;, which means the events are handled by the standard event handler.</source>
          <target state="translated">이 매개 변수는 기본 콜백 함수를 사용하여 메시지가 오류 로거에 전송 될 때 사용되는 오류 보고서 유형을 정의합니다. 기본값은 &lt;code&gt;std_error&lt;/code&gt; 입니다 . 이는 표준 이벤트 핸들러가 이벤트를 처리 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d8e1e13f6286b2183d8789f9f0f1c181e848b5c7" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;lib_dir&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;lib_dir&lt;/code&gt; 과 상호 배타적입니다 . 경우 &lt;code&gt;vsn&lt;/code&gt; 및 &lt;code&gt;lib_dir&lt;/code&gt; 가 모두 생략 최신 버전이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e97c191330c9143719f39676fbf0d64a524888a9" translate="yes" xml:space="preserve">
          <source>This parameter is mutual exclusive with &lt;code&gt;vsn&lt;/code&gt;. If &lt;code&gt;vsn&lt;/code&gt; and &lt;code&gt;lib_dir&lt;/code&gt; are both omitted, the latest version will be chosen.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;vsn&lt;/code&gt; 과 상호 배타적입니다 . 경우 &lt;code&gt;vsn&lt;/code&gt; 및 &lt;code&gt;lib_dir&lt;/code&gt; 가 모두 생략 최신 버전이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fccea6e9894e7980e5b72b89472e98f04ef2c3ca" translate="yes" xml:space="preserve">
          <source>This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;dateTime&lt;/code&gt; 유형 이며 RFC 3339를 준수합니다. 구현은 시간대를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="950fdba8a7f8faa27a2238104e4fbd9416d168d5" translate="yes" xml:space="preserve">
          <source>This parameter is the name of the driver to be used in subsequent calls to function &lt;code&gt;erlang:open_port&lt;/code&gt; in ERTS. The name can be specified as an &lt;code&gt;iolist()&lt;/code&gt; or an &lt;code&gt;atom()&lt;/code&gt;. The name specified when loading is used to find the object file (with the help of &lt;code&gt;Path&lt;/code&gt; and the system-implied extension suffix, that is, &lt;code&gt;.so&lt;/code&gt;). The name by which the driver identifies itself must also be consistent with this &lt;code&gt;Name&lt;/code&gt; parameter, much as the module name of a Beam file much corresponds to its filename.</source>
          <target state="translated">이 매개 변수는 ERTS의 &lt;code&gt;erlang:open_port&lt;/code&gt; 함수에 대한 후속 호출에 사용될 드라이버의 이름입니다 . 이름은 &lt;code&gt;iolist()&lt;/code&gt; 또는 &lt;code&gt;atom()&lt;/code&gt; 으로 지정할 수 있습니다 . 로드 할 때 지정된 이름은 &lt;code&gt;Path&lt;/code&gt; 및 시스템 암시 적 확장자 접미어 (즉, &lt;code&gt;.so&lt;/code&gt; )를 사용하여 오브젝트 파일을 찾는 데 사용됩니다 . 빔 파일의 모듈 이름이 해당 파일 이름과 거의 일치하므로 드라이버가 자신을 식별하는 이름도이 &lt;code&gt;Name&lt;/code&gt; 매개 변수 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="44b3acd62887c89fa3ae2ebe622fc74f4ca003b3" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_app_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수는 일반적으로 대상 시스템에 포함하지 않아야하는 응용 프로그램 특정 파일을 제어하는 ​​정규식 목록을 포함합니다. 주문을 포함하여, 파일은 몇 가지 필터와 일치해야합니다 &lt;code&gt;incl_app_filters&lt;/code&gt; 하지만 어떤 필터 &lt;code&gt;excl_app_filters&lt;/code&gt; 을 . 이 매개 변수의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f82af56ab8d93da6eddb3eddde55461bf95b47f" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which application specific files that should be included. Each file in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 포함 할 애플리케이션 특정 파일을 제어하는 ​​정규식 목록이 포함됩니다. 포함 시키려면 응용 프로그램의 각 파일이 나열된 정규식 중 하나 이상과 일치해야합니다. 또한 파일이 포함되기 위해 &lt;code&gt;excl_app_filters&lt;/code&gt; 의 필터와 일치하지 않을 수 있습니다. 이 매개 변수의 기본값은 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a274c6a75bab058057d8bad1dd9c6f7fc4d783d1" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should be included. Each file in the target system must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt; in order to be included. Which application files should be included is controlled with the parameters &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 시스템에 포함 할 파일을 제어하는 ​​정규식 목록이 포함됩니다. 대상 시스템의 각 파일이 포함 되려면 나열된 정규식 중 하나 이상과 일치해야합니다. 또한 파일이 포함되기 위해 &lt;code&gt;excl_sys_filters&lt;/code&gt; 의 필터와 일치하지 않을 수 있습니다. 포함 할 애플리케이션 파일은 &lt;code&gt;incl_app_filters&lt;/code&gt; 및 &lt;code&gt;excl_app_filters&lt;/code&gt; 매개 변수로 제어됩니다 . 이 매개 변수의 기본값은 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="110f1ed95034cf6ba82c260c7d3422382ccf8b06" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which files in the system should not be included in the target system. In order to be included, a file must match some filter in &lt;code&gt;incl_sys_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_sys_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 대상 시스템에 포함되지 않아야하는 시스템의 파일을 제어하는 ​​정규식 목록이 포함됩니다. 주문을 포함하여, 파일은 몇 가지 필터와 일치해야합니다 &lt;code&gt;incl_sys_filters&lt;/code&gt; 하지만 어떤 필터 &lt;code&gt;excl_sys_filters&lt;/code&gt; 을 . 이 매개 변수의 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff17bba9924b137232a805ed2fc26cbf5b146168" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should be included in an archive file (as opposed to being included as a regular directory outside the archive). Each top directory in the application must match at least one of the listed regular expressions in order to be included. Further the files may not match any filter in &lt;code&gt;excl_app_filters&lt;/code&gt; in order to be included. This parameter defaults to &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 아카이브 외부의 일반 디렉토리로 포함되는 것과 달리 아카이브 파일에 포함되어야하는 애플리케이션의 최상위 디렉토리를 제어하는 ​​정규식 목록이 포함됩니다. 포함 시키려면 응용 프로그램의 각 최상위 디렉토리가 나열된 정규식 중 하나 이상과 일치해야합니다. 또한 파일이 포함되기 위해 &lt;code&gt;excl_app_filters&lt;/code&gt; 의 필터와 일치하지 않을 수 있습니다. 이 매개 변수의 기본값은 &lt;code&gt;[&quot;.*&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8cccf208765941cdf1852be703e61e2a97e335ee" translate="yes" xml:space="preserve">
          <source>This parameter normally contains a list of regular expressions that controls which top level directories in an application should not be included in an archive file. In order to be included in the application archive, a top directory must match some filter in &lt;code&gt;incl_archive_filters&lt;/code&gt; but not any filter in &lt;code&gt;excl_archive_filters&lt;/code&gt;. This parameter defaults to &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에는 일반적으로 아카이브 파일에 포함하지 않아야하는 애플리케이션의 최상위 디렉토리를 제어하는 ​​정규식 목록이 포함됩니다. 주문이 응용 프로그램 아카이브에 포함하여, 최고 디렉토리는 몇 가지 필터와 일치해야합니다 &lt;code&gt;incl_archive_filters&lt;/code&gt; 하지만 어떤 필터 &lt;code&gt;excl_archive_filters&lt;/code&gt; 을 . 이 매개 변수의 기본값은 &lt;code&gt;[&quot;^include$&quot;,&quot;^priv$&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28343ed29b2c1e141aa76f8b0c8cab09dcd45849" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the Erlang emulator is statically installed at the client node. A node with a static emulator cannot dynamically switch to a new emulator, as the executable files are statically written into memory.</source>
          <target state="translated">이 매개 변수는 Erlang 에뮬레이터가 클라이언트 노드에 정적으로 설치되는지 여부를 지정합니다. 실행 파일이 정적으로 메모리에 기록되므로 정적 에뮬레이터가있는 노드는 새 에뮬레이터로 동적으로 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="755487bd7f381a96e683a265b03a5e040919d127" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the log file should be rotated or not. The value &lt;code&gt;infinity&lt;/code&gt; means the log file will grow indefinitely, while an integer value specifies at which file size (bytes) the file is rotated.</source>
          <target state="translated">이 매개 변수는 로그 파일을 회전해야하는지 여부를 지정합니다. &lt;code&gt;infinity&lt;/code&gt; 값 은 로그 파일이 무한정 커짐을 의미하고 정수 값은 파일이 회전되는 파일 크기 (바이트)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6df65b46110e980f8fa356aae1f4cdb59fbe6f4f" translate="yes" xml:space="preserve">
          <source>This parameter specifies if the rotated log file archives shall be compressed or not. If set to &lt;code&gt;true&lt;/code&gt;, all archives are compressed with &lt;code&gt;gzip&lt;/code&gt;, and renamed to &lt;code&gt;FileName.N.gz&lt;/code&gt;</source>
          <target state="translated">이 매개 변수는 회전 된 로그 파일 아카이브를 압축할지 여부를 지정합니다. &lt;code&gt;true&lt;/code&gt; 로 설정하면 모든 아카이브가 &lt;code&gt;gzip&lt;/code&gt; 으로 압축 되고 &lt;code&gt;FileName.N.gz&lt;/code&gt; 로 이름이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5a315afc7296583223ac7e17b44b0708aad5cc71" translate="yes" xml:space="preserve">
          <source>This parameter specifies the number of rotated log file archives to keep. This has meaning only if &lt;code&gt;&lt;a href=&quot;#max_no_bytes&quot;&gt;max_no_bytes&lt;/a&gt;&lt;/code&gt; is set to an integer value.</source>
          <target state="translated">이 매개 변수는 보관할 회전 된 로그 파일 아카이브의 수를 지정합니다. 이것은 &lt;code&gt;&lt;a href=&quot;#max_no_bytes&quot;&gt;max_no_bytes&lt;/a&gt;&lt;/code&gt; 가 정수 값으로 설정된 경우에만 의미 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e064a3cd06dea7253b5c26ccbc32ee1140753f4" translate="yes" xml:space="preserve">
          <source>This part is done on the target node, and for this example we want the node to be running as an embedded system with the &lt;code&gt;-heart&lt;/code&gt; option, allowing automatic restart of the node. For more information, see &lt;code&gt;&lt;a href=&quot;#start&quot;&gt; Starting a Target System&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 부분은 대상 노드에서 수행 &lt;code&gt;-heart&lt;/code&gt; 예에서는 노드가 노드를 자동으로 다시 시작할 수 있도록 -heart 옵션을 사용하여 임베디드 시스템으로 실행되기를 원합니다 . 자세한 내용 &lt;code&gt;&lt;a href=&quot;#start&quot;&gt; Starting a Target System&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d50377640826220d17a47ef2e3ec41045600adb8" translate="yes" xml:space="preserve">
          <source>This part is done on the target node, and for this example we want the node to be running as an embedded system with the &lt;code&gt;-heart&lt;/code&gt; option, allowing automatic restart of the node. For more information, see &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 부분은 대상 노드에서 수행 &lt;code&gt;-heart&lt;/code&gt; 예제에서는 노드가 자동으로 다시 시작될 수 있도록 -heart 옵션을 사용하여 임베디드 시스템으로 실행되도록 합니다. 자세한 정보 &lt;code&gt;&lt;a href=&quot;#start&quot;&gt;Starting a Target System&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bac7f8bcb72cbf602859c2bbd2ca1accde6e195" translate="yes" xml:space="preserve">
          <source>This particular example pattern that we have studied contains nested unlimited repeats, and so the use of a possessive quantifier for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when this pattern is applied to</source>
          <target state="translated">우리가 연구 한이 특정 예제 패턴에는 중첩 된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치시키기 위해 소유 수량화 도구를 사용하는 것이 중요합니다. 예를 들어이 패턴이</target>
        </trans-unit>
        <trans-unit id="cafdded1913809a983e1e03ea48bb5d4d797a73a" translate="yes" xml:space="preserve">
          <source>This particular group matches either the two-character sequence CR followed by LF, or one of the single characters LF (line feed, U+000A), VT (vertical tab, U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next line, U+0085). The two-character sequence is treated as a single unit that cannot be split.</source>
          <target state="translated">이 특정 그룹은 두 문자 시퀀스 CR 다음에 LF 또는 단일 문자 LF (행 피드, U + 000A), VT (수직 탭, U + 000B), FF (양식 피드, U + 000C) 중 하나와 일치합니다. , CR (캐리지 리턴, U + 000D) 또는 NEL (다음 줄, U + 0085). 두 문자 시퀀스는 분리 할 수없는 단일 단위로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a1fd9cfe743405ab50e9a660ad376f4821d6a0dd" translate="yes" xml:space="preserve">
          <source>This particular server probably does not use heap memory worth hibernating for. To gain anything from hibernation, your server would have to produce non-insignificant garbage during callback execution, for which this example server can serve as a bad example.</source>
          <target state="translated">이 특정 서버는 아마도 최대 절전 모드의 힙 메모리를 사용하지 않을 것입니다. 최대 절전 모드에서 무언가를 얻으려면 서버가 콜백 실행 중에 중요하지 않은 가비지를 생성해야합니다.이 예제 서버는 나쁜 예제로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dff69f09f8373963a046e44d87eb56b39d18544d" translate="yes" xml:space="preserve">
          <source>This pattern matches &lt;code&gt;a\nb&lt;/code&gt;, as LF is no longer a newline. If more than one of them is present, the last one is used.</source>
          <target state="translated">LF는 더 이상 줄 바꿈이 아니므 &lt;code&gt;a\nb&lt;/code&gt; 패턴은 a \ nb 와 일치 합니다 . 둘 이상이 존재하면 마지막 것이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="426d65d492f0b3f8687db736206883352d79afcb" translate="yes" xml:space="preserve">
          <source>This pattern will match if the operands for &lt;code&gt;move&lt;/code&gt; are the same. If the pattern match, the instruction will be removed. (That used to be an actual rule a long time ago when the compiler would occasionally produce instructions such as &lt;code&gt;{move,{x,2},{x,2}}&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 피연산자 가 동일한 경우이 패턴이 일치합니다 . 패턴이 일치하면 명령이 제거됩니다. (오래 전에 컴파일러가 &lt;code&gt;{move,{x,2},{x,2}}&lt;/code&gt; 와 같은 명령어를 가끔 생성하는 실제 규칙 이었습니다.)</target>
        </trans-unit>
        <trans-unit id="67f2d1b249ea341993b06eb398c25dbdc1e0f0e5" translate="yes" xml:space="preserve">
          <source>This phase begins when the user finalizes the time offset by calling &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt; erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt;. The finalization can only be performed once.</source>
          <target state="translated">이 단계는 사용자가 &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt; erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt; 를 호출하여 시간 오프셋을 완료 할 때 시작됩니다 . 마무리는 한 번만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5f3552b260ce80c8512e7857145bb94d23327e2" translate="yes" xml:space="preserve">
          <source>This phase begins when the user finalizes the time offset by calling &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt;. The finalization can only be performed once.</source>
          <target state="translated">이 단계는 사용자가 &lt;code&gt;&lt;a href=&quot;erlang#system_flag_time_offset&quot;&gt;erlang:system_flag(time_offset, finalize)&lt;/a&gt;&lt;/code&gt; 를 호출하여 시간 오프셋을 완료하면 시작됩니다 . 마무리는 한 번만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac25d4a9fb597e683c9984270c084780c2dc2975" translate="yes" xml:space="preserve">
          <source>This phase starts when the runtime system starts. A preliminary time offset based on current OS system time is determined. This offset is from now on to be fixed during the whole preliminary phase.</source>
          <target state="translated">이 단계는 런타임 시스템이 시작될 때 시작됩니다. 현재 OS 시스템 시간에 따른 예비 시간 오프셋이 결정됩니다. 이 오프셋은 지금부터 전체 예비 단계에서 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="a659cf785f049a86d756b9c813aaeb6a80c02b1c" translate="yes" xml:space="preserve">
          <source>This port is to represent the result of an accept operation. It is created when one wants to accept from a listen socket, and it is converted to a &lt;code&gt;portTypeCommand&lt;/code&gt; when the accept succeeds.</source>
          <target state="translated">이 포트는 승인 조작의 결과를 나타냅니다. 청취 소켓에서 승인하려고 할 때 작성 되며 승인이 성공하면 &lt;code&gt;portTypeCommand&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d46acb6abe2d76532e14cb270ed2c145b67edbb" translate="yes" xml:space="preserve">
          <source>This prevents creation of new atoms directly, creation of new atoms indirectly (as they are embedded in certain structures, such as process identifiers, refs, and funs), and creation of new external function references. None of those resources are garbage collected, so unchecked creation of them can exhaust available memory.</source>
          <target state="translated">이것은 새로운 원자의 생성, 간접적으로 새로운 원자의 생성 (프로세스 식별자, 참조 및 펀 (fun)과 같은 특정 구조에 내장되어 있음) 및 새로운 외부 함수 참조의 생성을 방지합니다. 이러한 리소스는 가비지 수집되지 않으므로 확인하지 않은 생성은 사용 가능한 메모리를 소모 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="161ffdf8aa7fe91e902cf0c46062cf3c8c9ce913" translate="yes" xml:space="preserve">
          <source>This problem does not exist if all nodes are Erlang nodes.</source>
          <target state="translated">모든 노드가 Erlang 노드 인 경우이 문제가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="970e9bfda49ef81fc9970f5d3a17505b795bc146" translate="yes" xml:space="preserve">
          <source>This problem is best solved by using Mnesia instead.</source>
          <target state="translated">이 문제는 대신 Mnesia를 사용하여 해결하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0b478a2b86cabc9871e0e9c3bdbf7e7c1549913b" translate="yes" xml:space="preserve">
          <source>This procedure differs from how it worked prior to Erlang/OTP 19.0. Before 19.0, only a contiguous memory block where the young heap and stack resided was considered to be part of the young heap. Heap fragments and messages were immediately copied into the young heap before they could be inspected by the Erlang program. The behaviour introduced in 19.0 is superior in many ways - most significantly it reduces the number of necessary copy operations and the root set for garbage collection.</source>
          <target state="translated">이 절차는 Erlang / OTP 19.0 이전의 작동 방식과 다릅니다. 19.0 이전에는 젊은 힙과 스택이 상주하는 연속 메모리 블록 만 젊은 힙의 일부로 간주되었습니다. 힙 조각과 메시지는 Erlang 프로그램에서 검사하기 전에 즉시 젊은 힙에 복사되었습니다. 19.0에 도입 된 동작은 여러면에서 우수합니다. 가장 중요한 것은 필요한 복사 작업 수와 가비지 수집을위한 루트 집합을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="9c05999f98fd47b44ec0f00834f055638c5316ef" translate="yes" xml:space="preserve">
          <source>This process cannot run in multiple instances on the same hardware. OS_Mon must be configured to start &lt;code&gt;os_sup&lt;/code&gt; on one node only if two or more Erlang nodes execute on the same machine.</source>
          <target state="translated">이 프로세스는 동일한 하드웨어의 여러 인스턴스에서 실행될 수 없습니다. 동일한 기계에서 둘 이상의 Erlang 노드가 실행되는 경우에만 하나의 노드에서 &lt;code&gt;os_sup&lt;/code&gt; 을 시작하도록 OS_Mon 을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3bb9e5caa10f9724817c37ffd6b5d433a1304dd3" translate="yes" xml:space="preserve">
          <source>This process executes &lt;code&gt;tut15:pong()&lt;/code&gt;. &lt;code&gt;Pong_PID&lt;/code&gt; is the process identity of the &quot;pong&quot; process. The function &lt;code&gt;start&lt;/code&gt; now creates another process &quot;ping&quot;:</source>
          <target state="translated">이 프로세스는 &lt;code&gt;tut15:pong()&lt;/code&gt; 실행 합니다. &lt;code&gt;Pong_PID&lt;/code&gt; 는 &quot;pong&quot;프로세스의 프로세스 ID입니다. 함수 &lt;code&gt;start&lt;/code&gt; 이제 다른 프로세스 &quot;ping&quot;을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="54ffc50690eb1a1de62954626b5c9e0167a4eba5" translate="yes" xml:space="preserve">
          <source>This process executes:</source>
          <target state="translated">이 프로세스는 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="327419876abc14c730314a0010b944c17b63d4fa" translate="yes" xml:space="preserve">
          <source>This program aids release handling on Windows systems. The program is to be called by the &lt;code&gt;erlsrv&lt;/code&gt; program, read up the release data file &lt;code&gt;start_erl.data&lt;/code&gt;, and start Erlang. Some options to &lt;code&gt;start_erl&lt;/code&gt; are added and removed by the release handler during upgrade with emulator restart (more specifically option &lt;code&gt;-data&lt;/code&gt;).</source>
          <target state="translated">이 프로그램은 Windows 시스템에서의 릴리스 처리에 도움이됩니다. 이 프로그램은 &lt;code&gt;erlsrv&lt;/code&gt; 프로그램에 의해 호출되고 릴리스 데이터 파일 &lt;code&gt;start_erl.data&lt;/code&gt; 를 읽고 Erlang을 시작합니다. &lt;code&gt;start_erl&lt;/code&gt; 에 대한 일부 옵션 은 에뮬레이터 재시작으로 업그레이드하는 동안 릴리스 핸들러에 의해 추가 및 제거됩니다 (특히 &lt;code&gt;-data&lt;/code&gt; 옵션 ).</target>
        </trans-unit>
        <trans-unit id="670a2482a63126e58239dc332359f8bc1dff0e73" translate="yes" xml:space="preserve">
          <source>This program is called when the machine is started. It can be modified or rewritten to suit a special system. By default, it must be called &lt;code&gt;start&lt;/code&gt; and reside in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. Another start program can be used, by using configuration parameter &lt;code&gt;start_prg&lt;/code&gt; in application SASL.</source>
          <target state="translated">이 프로그램은 기계가 시작될 때 호출됩니다. 특수 시스템에 맞게 수정하거나 다시 작성할 수 있습니다. 기본적으로 &lt;code&gt;start&lt;/code&gt; 라고 하며 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 에 있어야합니다 . 응용 프로그램 SASL에서 구성 매개 변수 &lt;code&gt;start_prg&lt;/code&gt; 를 사용하여 다른 시작 프로그램을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4747c1263fbc28b515ca78f638cbd9259a9eb523" translate="yes" xml:space="preserve">
          <source>This program is distributed both in compiled form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\bin) and in source form (under &amp;lt;Erlang root&amp;gt;\\erts-&amp;lt;version&amp;gt;\\src). The purpose of the source code is to ease customization of the program for local needs, such as cyclic restart detection. There is also a &quot;make&quot;-file, written for the &lt;code&gt;nmake&lt;/code&gt; program distributed with Microsoft Visual C++. This program can, however, be compiled with any Win32 C compiler (possibly with minor modifications).</source>
          <target state="translated">이 프로그램은 컴파일 된 형태 (&amp;lt;Erlang root&amp;gt; \\ erts- &amp;lt;version&amp;gt; \\ bin)와 소스 형태 (&amp;lt;Erlang root&amp;gt; \\ erts- &amp;lt;version&amp;gt; \\ src)로 배포됩니다. 소스 코드의 목적은 주기적 재시작 감지와 같은 로컬 요구에 맞게 프로그램을 쉽게 사용자 정의 할 수 있도록하는 것입니다. Microsoft Visual C ++로 배포 된 &lt;code&gt;nmake&lt;/code&gt; 프로그램 용으로 작성된 &quot;make&quot;파일도 있습니다 . 그러나이 프로그램은 모든 Win32 C 컴파일러로 컴파일 할 수 있습니다 (사소한 수정이있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="5fbfadc49450aec422c508001aa868916550a963" translate="yes" xml:space="preserve">
          <source>This program is to set static parameters and environment variables such as &lt;code&gt;-sname Name&lt;/code&gt; and &lt;code&gt;HEART_COMMAND&lt;/code&gt; to reboot the machine.</source>
          <target state="translated">이 프로그램은 &lt;code&gt;-sname Name&lt;/code&gt; 및 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 와 같은 정적 매개 변수 및 환경 변수를 설정 하여 시스템을 재부팅합니다.</target>
        </trans-unit>
        <trans-unit id="c3f3c1fffec91449fdead388f394beeb915ca247" translate="yes" xml:space="preserve">
          <source>This program is used to attach to a running Erlang runtime system, started with &lt;code&gt;run_erl&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 &lt;code&gt;run_erl&lt;/code&gt; 로 시작하여 실행중인 Erlang 런타임 시스템에 연결하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f003599afc35a270db5f4b7d7b284e4c9e32aee" translate="yes" xml:space="preserve">
          <source>This program is used to start the emulator, but you will not be connected to the shell. &lt;code&gt;to_erl&lt;/code&gt; is used to connect to the Erlang shell.</source>
          <target state="translated">이 프로그램은 에뮬레이터를 시작하는 데 사용되지만 셸에 연결되지는 않습니다. &lt;code&gt;to_erl&lt;/code&gt; 은 Erlang 쉘에 연결하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6687161d9309502a24c4f52312cb9d9b40349c81" translate="yes" xml:space="preserve">
          <source>This program starts the Erlang emulator with parameters &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; set. It reads data about where these files are located from a file named &lt;code&gt;start_erl.data&lt;/code&gt;, which is located in &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt;. Each new release introduces a new data file. This file is automatically generated by the release handler in Erlang.</source>
          <target state="translated">이 프로그램은 매개 변수 &lt;code&gt;-boot&lt;/code&gt; 및 &lt;code&gt;-config&lt;/code&gt; 를 사용 하여 Erlang 에뮬레이터를 시작합니다 . &lt;code&gt;&amp;lt;RELDIR&amp;gt;&lt;/code&gt; 에있는 &lt;code&gt;start_erl.data&lt;/code&gt; 파일에서 이러한 파일이있는 위치에 대한 데이터를 읽습니다 . 각각의 새로운 릴리스에는 새로운 데이터 파일이 도입되었습니다. 이 파일은 Erlang의 릴리스 핸들러에 의해 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8f257f89dea065885b66a0cd478fca5389333698" translate="yes" xml:space="preserve">
          <source>This property is only valid if &lt;code&gt;auto_ack&lt;/code&gt; is true.</source>
          <target state="translated">이 속성은 &lt;code&gt;auto_ack&lt;/code&gt; 이 true 인 경우에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="5810ec17d7cb173c4fccedc7a14810f5d07c123d" translate="yes" xml:space="preserve">
          <source>This puts less load on the filesystem, but much more on the Erlang runtime system.</source>
          <target state="translated">이것은 파일 시스템에 적은 부하를 주지만 Erlang 런타임 시스템에는 더 많은 부하를줍니다.</target>
        </trans-unit>
        <trans-unit id="fe519e24650180a3fcf221d96e6f790286d56794" translate="yes" xml:space="preserve">
          <source>This query also removes duplicates but the answers are sorted. If there are many answers, temporary files are used. Notice that to get the first unique answer, all answers must be found and sorted. Both alternatives find duplicates by comparing answers, that is, if &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt; are answers found in that order, then &lt;code&gt;A2&lt;/code&gt; is a removed if &lt;code&gt;A1 == A2&lt;/code&gt;.</source>
          <target state="translated">이 쿼리는 중복 항목도 제거하지만 답변은 정렬됩니다. 많은 답변이있는 경우 임시 파일이 사용됩니다. 첫 번째 고유 답변을 얻으려면 모든 답변을 찾아서 정렬해야합니다. 두 대안 모두 답을 비교하여 중복을 찾습니다. 즉 &lt;code&gt;A1&lt;/code&gt; 과 &lt;code&gt;A2&lt;/code&gt; 가 순서대로 찾은 답 이면 &lt;code&gt;A1 == A2&lt;/code&gt; 경우 &lt;code&gt;A2&lt;/code&gt; 가 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2f6bad75f3fbef13092a6a4222f43094d545fae" translate="yes" xml:space="preserve">
          <source>This query hits the feature of partially bound keys in table type &lt;code&gt;ordered_set&lt;/code&gt;, so that not the whole table needs to be searched, only the part containing keys beginning with &lt;code&gt;0&lt;/code&gt; is looked into.</source>
          <target state="translated">이 쿼리는 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형에서 부분적으로 바인딩 된 키의 기능을 수행 하므로 전체 테이블을 검색 할 필요가 없으며 &lt;code&gt;0&lt;/code&gt; 으로 시작하는 키를 포함하는 부분 만 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="671f4cec79d07856674afe86714dc175a1654c1b" translate="yes" xml:space="preserve">
          <source>This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the &lt;code&gt;crypto&lt;/code&gt; module, for example, &lt;code&gt; crypto:strong_rand_bytes/1&lt;/code&gt;.</source>
          <target state="translated">이 난수 생성기는 암호 학적으로 강력하지 않습니다. 강력한 암호화 난수 생성기가 필요한 경우 &lt;code&gt; crypto:strong_rand_bytes/1&lt;/code&gt; 과 같은 &lt;code&gt;crypto&lt;/code&gt; 모듈 의 함수 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e6a7904ebcd7549f287cc377bc5ea8dfe7feaba" translate="yes" xml:space="preserve">
          <source>This random number generator is not cryptographically strong. If a strong cryptographic random number generator is needed, use one of functions in the &lt;code&gt;crypto&lt;/code&gt; module, for example, &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt;.</source>
          <target state="translated">이 난수 생성기는 암호화 적으로 강력하지 않습니다. 강력한 암호화 난수 생성기가 필요한 경우 &lt;code&gt;crypto&lt;/code&gt; 모듈 의 기능 중 하나를 사용하십시오 ( 예 &lt;code&gt;crypto:strong_rand_bytes/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4aeff4461a7bf1567cdb7c34105213973f7dd8" translate="yes" xml:space="preserve">
          <source>This reads the &lt;code&gt;logger&lt;/code&gt; configuration parameter from the &lt;code&gt;my_all&lt;/code&gt; application and starts the configured handlers. The contents of the configuration use the same rules as the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;my_all&lt;/code&gt; 애플리케이션 에서 &lt;code&gt;logger&lt;/code&gt; 구성 매개 변수를 읽고 구성된 핸들러를 시작합니다. 구성의 내용은 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt; 과 동일한 규칙을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c00434ba7af79d001ca617ae07f4509311aeefbf" translate="yes" xml:space="preserve">
          <source>This reads the &lt;code&gt;logger&lt;/code&gt; configuration parameter from the &lt;code&gt;my_app&lt;/code&gt; application and starts the configured handlers. The contents of the configuration use the same rules as the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;my_app&lt;/code&gt; 애플리케이션 에서 &lt;code&gt;logger&lt;/code&gt; 구성 매개 변수를 읽고 구성된 핸들러를 시작합니다. 구성 내용은 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler-configuration&quot;&gt;logger handler configuration&lt;/a&gt;&lt;/code&gt; 과 동일한 규칙을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dd05537434a4630f9db4b01dfd929c70a6829e0d" translate="yes" xml:space="preserve">
          <source>This reads the entire contents of &lt;code&gt;&quot;mtab&quot;&lt;/code&gt; into the specified registry. After the restore, all the objects in the registry are marked as unmodified, so a later backup only affects objects that you have modified since the restore.</source>
          <target state="translated">&lt;code&gt;&quot;mtab&quot;&lt;/code&gt; 의 전체 내용을 지정된 레지스트리로 읽습니다 . 복원 후 레지스트리의 모든 오브젝트가 수정되지 않은 것으로 표시되므로 이후 백업은 복원 이후 수정 한 오브젝트에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="e5017094927d4a8eb77c34c12688c26a383cd09d" translate="yes" xml:space="preserve">
          <source>This reference manual contains type descriptions generated from types in the &lt;code&gt;gen_statem&lt;/code&gt; source code, so they are correct. However, the generated descriptions also reflect the type hierarchy, which sometimes makes it hard to get a good overview. If so, see the section &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; in the &lt;code&gt; OTP Design Principles &lt;/code&gt; User's Guide.</source>
          <target state="translated">이 참조 매뉴얼에는 &lt;code&gt;gen_statem&lt;/code&gt; 소스 코드의 유형에서 생성 된 유형 설명이 포함되어 있으므로 정확합니다. 그러나 생성 된 설명은 또한 유형 계층 구조를 반영하므로 때로는 좋은 개요를 얻기가 어렵습니다. 이 경우, 섹션 참조 &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; 에서 &lt;code&gt; OTP Design Principles &lt;/code&gt; 사용자 안내서를.</target>
        </trans-unit>
        <trans-unit id="13a79d754831b14cd54b94d9e66117a733bf984b" translate="yes" xml:space="preserve">
          <source>This reference manual describes types generated from the types in the &lt;code&gt;gen_statem&lt;/code&gt; source code, so they are correct. However, the generated descriptions also reflect the type hiearchy, which makes them kind of hard to read.</source>
          <target state="translated">이 참조 매뉴얼은 &lt;code&gt;gen_statem&lt;/code&gt; 소스 코드 의 유형에서 생성 된 유형을 설명 하므로 올바른 유형입니다. 그러나 생성 된 설명은 유형의 귀를 반영하기 때문에 읽기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="1c8060b97047d75217dfaa592520c89dd24db028" translate="yes" xml:space="preserve">
          <source>This renders a result similar to the following:</source>
          <target state="translated">결과는 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9f783544c6147fb46866ca14f57f1cf28fd64491" translate="yes" xml:space="preserve">
          <source>This request asks for a complete list of all options supported by the I/O server as well as their current values.</source>
          <target state="translated">이 요청은 I / O 서버가 지원하는 모든 옵션과 현재 값의 전체 목록을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="c9ef467065f7f3147aa63fa765e54a5cacd5c45f" translate="yes" xml:space="preserve">
          <source>This request is not really used, it is to be regarded as a debug feature.</source>
          <target state="translated">이 요청은 실제로 사용되지 않으며 디버그 기능으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d449ed2883b9cc55517ccad2ba93e587a2d92524" translate="yes" xml:space="preserve">
          <source>This request is used through the Erlang function &lt;code&gt; net_adm:names/1,2&lt;/code&gt;. A TCP connection is opened to the EPMD and this request is sent.</source>
          <target state="translated">이 요청은 Erlang 함수 &lt;code&gt; net_adm:names/1,2&lt;/code&gt; 를 통해 사용됩니다 . EPMD에 대한 TCP 연결이 열리고이 요청이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed5461b3e3a2705d00654ef7851baa95f3c5a7b" translate="yes" xml:space="preserve">
          <source>This request is used through the Erlang function &lt;code&gt;net_adm:names/1,2&lt;/code&gt;. A TCP connection is opened to the EPMD and this request is sent.</source>
          <target state="translated">이 요청은 Erlang 함수 &lt;code&gt;net_adm:names/1,2&lt;/code&gt; 를 통해 사용됩니다 . EPMD에 대한 TCP 연결이 열리고이 요청이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fa4697a836ae0380ae5f8e0e273aa79c5259e1e7" translate="yes" xml:space="preserve">
          <source>This request kills the running EPMD. It is almost never used.</source>
          <target state="translated">이 요청은 실행중인 EPMD를 종료합니다. 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c37139085c2a33777870615ebb189dd29f4711b3" translate="yes" xml:space="preserve">
          <source>This results in the following record:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6a3367c426977d974ddf7ae39a973d34adfaba6" translate="yes" xml:space="preserve">
          <source>This results in the following records:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4754bd22d399a2af6e9567cb4368afe4e9a97e68" translate="yes" xml:space="preserve">
          <source>This return value is valid even if option &lt;code&gt;kill_ports&lt;/code&gt; was used, as killing ports can be a process that does not complete immediately. However, the condition is in that case transient. Monitors are always useful to detect when the driver is really unloaded.</source>
          <target state="translated">killing port는 즉시 완료되지 않는 프로세스 일 수 있으므로 &lt;code&gt;kill_ports&lt;/code&gt; 옵션 이 사용 된 경우 에도이 리턴 값은 유효 합니다. 그러나이 경우 조건은 일시적입니다. 모니터는 드라이버가 실제로 언로드되는시기를 감지하는 데 항상 유용합니다.</target>
        </trans-unit>
        <trans-unit id="61bce59fa6b3bc349ada24ae6e1accf7342572aa" translate="yes" xml:space="preserve">
          <source>This returns the driver structure. The macro &lt;code&gt;DRIVER_INIT&lt;/code&gt; defines the only exported function. All the other functions are static, and will not be exported from the library.</source>
          <target state="translated">드라이버 구조를 반환합니다. 매크로 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 는 내 보낸 유일한 함수를 정의합니다. 다른 모든 함수는 정적이며 라이브러리에서 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="236d4116cd1bd104778ca12a47df3dca542bc4b6" translate="yes" xml:space="preserve">
          <source>This saves the trouble of first fetching a keyed value, appending a new value to the list of stored values, and storing the result.</source>
          <target state="translated">이렇게하면 먼저 키 값을 가져 와서 저장된 값 목록에 새 값을 추가하고 결과를 저장하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="31f5366cf36758d97de45b416b180fe5021204ef" translate="yes" xml:space="preserve">
          <source>This scenario can occur if the driver code needs replacement during operation of the Erlang emulator. Implementing driver code replacement is a little more tedious than Beam code replacement, as one driver cannot be loaded as both &quot;old&quot; and &quot;new&quot; code. All &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of a driver must have it closed (no open ports) before the old code can be unloaded and the new code can be loaded.</source>
          <target state="translated">이 시나리오는 Erlang 에뮬레이터 작동 중에 드라이버 코드를 교체해야하는 경우 발생할 수 있습니다. 하나의 드라이버를 &quot;오래된&quot;코드와 &quot;새로운&quot;코드로로드 할 수 없으므로 드라이버 코드 대체를 구현하는 것이 Beam 코드 대체보다 약간 지루합니다. 이전 코드를 언로드하고 새 코드를로드하려면 드라이버의 모든 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 포트를 열지 않은 상태에서 드라이버를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="503f88b8d41295f847befbf0174f96b5e1d17d21" translate="yes" xml:space="preserve">
          <source>This section also describes the locking functions, including table locks and sticky locks, as well as alternative functions that bypass the transaction system in favor of improved speed and reduced overhead. These functions are called &quot;dirty operations&quot;. The use of nested transactions is also described. The following topics are included:</source>
          <target state="translated">이 섹션에서는 또한 테이블 잠금 및 고정 잠금을 포함한 잠금 기능과 속도 향상 및 오버 헤드 감소를 위해 트랜잭션 시스템을 우회하는 대체 기능에 대해 설명합니다. 이러한 기능을 &quot;더러운 작업&quot;이라고합니다. 중첩 트랜잭션 사용에 대해서도 설명합니다. 다음과 같은 주제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ca13c61387c20120a915aa2aba2a70b09cc77ff8" translate="yes" xml:space="preserve">
          <source>This section contains information about all loaded modules.</source>
          <target state="translated">이 섹션에는로드 된 모든 모듈에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0afb7bdb78aa30270d4c5341a78528374ecd48c" translate="yes" xml:space="preserve">
          <source>This section contains information about all the ETS tables in the system. The following fields are of interest for each table:</source>
          <target state="translated">이 섹션에는 시스템의 모든 ETS 테이블에 대한 정보가 있습니다. 각 테이블에서 다음 필드가 관심 대상입니다.</target>
        </trans-unit>
        <trans-unit id="c705a253aaab772432302fcb590c6d71895de050" translate="yes" xml:space="preserve">
          <source>This section contains information about all the timers started with the BIFs &lt;code&gt;erlang:start_timer/3&lt;/code&gt; and &lt;code&gt;erlang:send_after/3&lt;/code&gt;. The following fields exist for each timer:</source>
          <target state="translated">이 절에는 BIF &lt;code&gt;erlang:start_timer/3&lt;/code&gt; 및 &lt;code&gt;erlang:send_after/3&lt;/code&gt; 로 시작된 모든 타이머에 대한 정보가 있습니다 . 각 타이머에 대해 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e593d062792a79977388f9b736ca5fdb84956c5e" translate="yes" xml:space="preserve">
          <source>This section contains simple introductory examples only. For a full description of the QLC query language, see the &lt;code&gt;qlc&lt;/code&gt; manual page in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">이 섹션에는 간단한 소개 예제 만 포함되어 있습니다. QLC 조회 언어에 대한 전체 설명은 &lt;code&gt;STDLIB&lt;/code&gt; 의 &lt;code&gt;qlc&lt;/code&gt; 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="388bc7f1102a9ae9f2581325e4b4730cdd3f0142" translate="yes" xml:space="preserve">
          <source>This section demonstrates how simple it is to write a basic (yet for many module testing purposes, often sufficiently complex) test suite and execute its test cases. This is not necessarily obvious when you read the remaining sections in this User's Guide.</source>
          <target state="translated">이 섹션에서는 기본 (많은 모듈 테스트 목적으로, 종종 복잡한 경우) 테스트 스위트를 작성하고 테스트 사례를 실행하는 것이 얼마나 간단한지를 보여줍니다. 이 사용 설명서의 나머지 섹션을 읽을 때 반드시 명확하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e57241c5a98cbdf10642d048108a7272df13ecae" translate="yes" xml:space="preserve">
          <source>This section describes a simple driver for accessing a postgres database using the libpq C client library. Postgres is used because it is free and open source. For information on postgres, see &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 절에서는 libpq C 클라이언트 라이브러리를 사용하여 postgres 데이터베이스에 액세스하기위한 간단한 드라이버에 대해 설명합니다. Postgres는 무료이며 오픈 소스이기 때문에 사용됩니다. postgres에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;http://www.postgres.org&quot;&gt;www.postgres.org&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8941b0891a6ff874af251fbb759dca478d13c6f3" translate="yes" xml:space="preserve">
          <source>This section describes examples of how to use the Public Key API. Keys and certificates used in the following sections are generated only for testing the Public Key application.</source>
          <target state="translated">이 섹션에서는 공개 키 API를 사용하는 방법에 대한 예를 설명합니다. 다음 섹션에서 사용되는 키와 인증서는 공개 키 응용 프로그램을 테스트하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ba0088de53a90de56e1f80e0ac3933382d74faf7" translate="yes" xml:space="preserve">
          <source>This section describes how an embedded system is started. Four programs are involved and they normally reside in the directory &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt;. The only exception is the &lt;code&gt;start&lt;/code&gt; program, which can be located anywhere, and is also the only program that must be modified by the user.</source>
          <target state="translated">이 절에서는 내장 시스템이 시작되는 방법에 대해 설명합니다. 네 개의 프로그램이 관련되며 일반적으로 &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/bin&lt;/code&gt; 디렉토리에 있습니다. 유일한 예외는 &lt;code&gt;start&lt;/code&gt; 프로그램이며 어디에서나 찾을 수 있으며 사용자가 수정해야하는 유일한 프로그램이기도합니다.</target>
        </trans-unit>
        <trans-unit id="5dffe6465a9a88971444b067aa33f3c613e2da6a" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang distribution can use TLS to get extra verification and security.</source>
          <target state="translated">이 섹션에서는 Erlang 배포가 TLS를 사용하여 추가 확인 및 보안을 얻는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7ba1b8e520e730aff5ce60b5891f8456502ebe16" translate="yes" xml:space="preserve">
          <source>This section describes how the Erlang runtime system is configured for IP communication. It also explains how you can configure it for your needs by a configuration file. The information is primarily intended for users with special configuration needs or problems. There is normally no need for specific settings for Erlang to function properly on a correctly IP-configured platform.</source>
          <target state="translated">이 섹션에서는 Erlang 런타임 시스템이 IP 통신을 위해 구성되는 방법에 대해 설명합니다. 또한 구성 파일로 필요에 맞게 구성하는 방법에 대해서도 설명합니다. 이 정보는 주로 특수한 구성 요구 또는 문제가있는 사용자를위한 것입니다. Erlang이 올바르게 IP 구성 플랫폼에서 제대로 작동하기 위해서는 특정 설정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9ba9d8ce48a5e18d389572e80e439e457082f15" translate="yes" xml:space="preserve">
          <source>This section describes how to build the Erlang emulator and the OTP libraries on Windows. Note that the Windows binary releases are still a preferred alternative if one does not have Microsoft&amp;rsquo;s development tools and/or don&amp;rsquo;t want to install Cygwin, MSYS or MSYS2.</source>
          <target state="translated">이 섹션에서는 Windows에서 Erlang 에뮬레이터 및 OTP 라이브러리를 빌드하는 방법에 대해 설명합니다. Windows 바이너리 릴리스는 Microsoft의 개발 도구가 없거나 Cygwin, MSYS 또는 MSYS2를 설치하지 않으려는 경우 여전히 선호되는 대안입니다.</target>
        </trans-unit>
        <trans-unit id="dcc931582562f8a25cb00d5b918e90edbe2d35fd" translate="yes" xml:space="preserve">
          <source>This section describes how to build the Erlang emulator and the OTP libraries on Windows. Note that the Windows binary releases are still a preferred alternative if one does not have Microsoft&amp;rsquo;s development tools and/or don&amp;rsquo;t want to install WSL.</source>
          <target state="translated">이 섹션에서는 Windows에서 Erlang 에뮬레이터 및 OTP 라이브러리를 빌드하는 방법을 설명합니다. Microsoft의 개발 도구가 없거나 WSL을 설치하지 않으려는 경우 Windows 바이너리 릴리스가 여전히 선호되는 대안입니다.</target>
        </trans-unit>
        <trans-unit id="23b49078ad714b83061016b41c527ea88a0ef01c" translate="yes" xml:space="preserve">
          <source>This section describes how to build your own driver for Erlang.</source>
          <target state="translated">이 섹션에서는 Erlang 용 고유 드라이버를 작성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9ea8a2e527669401063f6aeee8dc65aebcbab675" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative carrier protocol for the Erlang distribution. The distribution is normally carried by TCP/IP. Here is explained a method for replacing TCP/IP with another protocol.</source>
          <target state="translated">이 섹션에서는 Erlang 배포를위한 대체 반송파 프로토콜을 구현하는 방법에 대해 설명합니다. 분배는 일반적으로 TCP / IP에 의해 수행됩니다. 다음은 TCP / IP를 다른 프로토콜로 바꾸는 방법에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="ef9194590c5bbba89fd68a31ae7705b884e62724" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative discovery mechanism for Erlang distribution. Discovery is normally done using DNS and the Erlang Port Mapper Daemon (EPMD) for port discovery.</source>
          <target state="translated">이 섹션에서는 Erlang 배포를위한 대체 검색 메커니즘을 구현하는 방법에 대해 설명합니다. 감지는 일반적으로 포트 감지를 위해 DNS 및 EPMD (Erlang Port Mapper Daemon)를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="da8047f598c0cf0b64db9a2f17dfe37a85e55406" translate="yes" xml:space="preserve">
          <source>This section describes how to implement an alternative node discovery mechanism for Erlang distribution. Node discovery is normally done using DNS and the Erlang Port Mapper Daemon (EPMD) for port registration and lookup.</source>
          <target state="translated">이 섹션에서는 Erlang 배포를위한 대체 노드 검색 메커니즘을 구현하는 방법을 설명합니다. 노드 검색은 일반적으로 포트 등록 및 조회를 위해 DNS 및 EPMD (Erlang Port Mapper Daemon)를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="62a63b1a98e975cb1778e4a9f8ed67fec8fb504f" translate="yes" xml:space="preserve">
          <source>This section describes how to write a Net if process.</source>
          <target state="translated">이 섹션에서는 Net if 프로세스를 작성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a5a2806882d6d1e2d41fb571e953fc2694d49bf3" translate="yes" xml:space="preserve">
          <source>This section describes how to write a process that complies to the OTP design principles, without using a standard behaviour. Such a process is to:</source>
          <target state="translated">이 섹션에서는 표준 동작을 사용하지 않고 OTP 설계 원칙을 준수하는 프로세스를 작성하는 방법에 대해 설명합니다. 이러한 과정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db110007d4cae55a5cd2784be2448b1464cdeff4" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;Mnesia&lt;/code&gt; transaction system and the transaction properties that make &lt;code&gt;Mnesia&lt;/code&gt; a fault-tolerant, distributed Database Management System (DBMS).</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 트랜잭션 시스템 및 &lt;code&gt;Mnesia&lt;/code&gt; 를 내결함성 분산 데이터베이스 관리 시스템 (DBMS)으로 만드는 트랜잭션 속성에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="145559b08f0e7daceea91964fac1205f05f73a6b" translate="yes" xml:space="preserve">
          <source>This section describes the &lt;code&gt;erl_crash.dump&lt;/code&gt; file generated upon abnormal exit of the Erlang runtime system.</source>
          <target state="translated">이 절에서는 Erlang 런타임 시스템이 비정상 종료 될 때 생성되는 &lt;code&gt;erl_crash.dump&lt;/code&gt; 파일에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="615a4d70bf1eb0943d565d942619e06723c44a20" translate="yes" xml:space="preserve">
          <source>This section describes the ASN.1 types including their functionality, purpose, and how values are assigned in Erlang.</source>
          <target state="translated">이 섹션에서는 기능, 목적 및 Erlang에서 값이 할당되는 방법을 포함하여 ASN.1 유형에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4973acdcae6787712641efb91993666da08e3527" translate="yes" xml:space="preserve">
          <source>This section describes the basic steps when designing a &lt;code&gt;Mnesia&lt;/code&gt; database and the programming constructs that make different solutions available to the programmer. The following topics are included:</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 데이터베이스를 설계 할 때의 기본 단계 와 프로그래머가 다양한 솔루션을 사용할 수 있도록하는 프로그래밍 구조에 대해 설명합니다 . 다음과 같은 주제가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="734f476df2959a2662d969893e8e7029abc0685e" translate="yes" xml:space="preserve">
          <source>This section describes the current state of standards compliance of the ssl application.</source>
          <target state="translated">이 섹션에서는 SSL 애플리케이션의 현재 표준 준수 상태를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="faf94ee7a5d096d374f74f2312ed2c9e2ebd27de" translate="yes" xml:space="preserve">
          <source>This section describes the distribution handshake protocol introduced in Erlang/OTP R6. This description was previously located in &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; and has more or less been copied and &quot;formatted&quot; here. It has been almost unchanged since 1999, but the handshake has not changed much since then either.</source>
          <target state="translated">이 섹션에서는 Erlang / OTP R6에 도입 된 배포 핸드 셰이크 프로토콜에 대해 설명합니다. 이 설명은 이전에 &lt;code&gt;$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt&lt;/code&gt; 있으며 여기에서 다소 복사 및 &quot;포맷&quot;되었습니다. 1999 년 이래로 거의 변하지 않았지만 그 이후로 악수는 크게 변하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c5d7bec7b79a0ae59b92c5e5f67ae7a72f8453de" translate="yes" xml:space="preserve">
          <source>This section describes the distribution handshake protocol used between nodes to establishing a connection. The protocol was introduced in Erlang/OTP R6 and has remained unchanged until OTP 23. The changes made in OTP 23 were designed to be compatible with the older protocol version. That is an old node can still connect toward a new node and vice versa.</source>
          <target state="translated">이 섹션에서는 연결을 설정하기 위해 노드간에 사용되는 분산 핸드 셰이크 프로토콜에 대해 설명합니다. 프로토콜은 Erlang / OTP R6에 도입되었으며 OTP 23까지 변경되지 않았습니다. OTP 23에서 변경된 사항은 이전 프로토콜 버전과 호환되도록 설계되었습니다. 그것은 이전 노드가 여전히 새 노드로 연결될 수 있으며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="d76e009e16bdd01f805b9e968741d4585ed774f4" translate="yes" xml:space="preserve">
          <source>This section describes the functions available for schema management, all which return either of the following tuples:</source>
          <target state="translated">이 섹션에서는 스키마 관리에 사용할 수있는 기능에 대해 설명합니다.이 기능은 모두 다음 튜플 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b453da50a4aa889b5bfe6fc3855f07b9e605aebd" translate="yes" xml:space="preserve">
          <source>This section describes the incoming messages which a Net If process may choose to respond to.</source>
          <target state="translated">이 섹션에서는 Net If 프로세스가 응답하도록 선택할 수있는 수신 메시지에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6589e4219f2138e744e1d40f56f69ff33d9cd04f" translate="yes" xml:space="preserve">
          <source>This section describes the incoming messages which a Net if process must be able to receive.</source>
          <target state="translated">이 섹션에서는 Net if 프로세스가 수신 할 수 있어야하는 수신 메시지에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ba803131ede9177f9bd28303113e3a91a6271ee1" translate="yes" xml:space="preserve">
          <source>This section describes the internal files that are created and maintained by the &lt;code&gt;Mnesia&lt;/code&gt; system. In particular, the workings of the &lt;code&gt;Mnesia&lt;/code&gt; log are described.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 에서 만들고 유지 관리하는 내부 파일에 대해 설명합니다 . 특히, &lt;code&gt;Mnesia&lt;/code&gt; 로그 의 작동 이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="16c349c9cdb2076b95c930dc72ed84bdd0fd6a91" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Solaris.</source>
          <target state="translated">이 절에서는 Solaris와 관련된 운영 체제 별 OTP 부분에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35c4d999a1922f58afda1ed0555720ff15b4c949" translate="yes" xml:space="preserve">
          <source>This section describes the operating system-specific parts of OTP that relate to Windows NT.</source>
          <target state="translated">이 절에서는 Windows NT와 관련된 운영 체제 별 OTP 부분에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="40285644d87303c5462b5e3de0dc15016aecc45b" translate="yes" xml:space="preserve">
          <source>This section describes the output format of the analyse command. See &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 절에서는 분석 명령의 출력 형식에 대해 설명합니다. &lt;code&gt;&lt;a href=&quot;#analyse&quot;&gt;analyse/0&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56322ae43abba91cc149a5278e951f77e9967920" translate="yes" xml:space="preserve">
          <source>This section describes the rules for constructing binaries using the bit syntax. Unlike when constructing lists or tuples, the construction of a binary can fail with a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">이 섹션에서는 비트 구문을 사용하여 바이너리를 구성하는 규칙에 대해 설명합니다. 리스트 나 튜플을 구성 할 때와 달리 바이너리 구성은 &lt;code&gt;badarg&lt;/code&gt; 예외로 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c65c0615f3b377f5b341fdeacc78b3636ed30f2" translate="yes" xml:space="preserve">
          <source>This section describes the rules for matching binaries, using the bit syntax.</source>
          <target state="translated">이 섹션에서는 비트 구문을 사용하여 바이너리를 일치시키는 규칙에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c4785eaeac1329ade355f9bd89d5b3faa13bbcad" translate="yes" xml:space="preserve">
          <source>This section describes the slightly different match specifications translated by &lt;code&gt; dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt; dbg:fun2ms/1&lt;/code&gt; 로 번역 된 약간 다른 일치 스펙을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="3efdb6c16651b89d1df8757e4dbe192b22b7b9d8" translate="yes" xml:space="preserve">
          <source>This section describes the slightly different match specifications translated by &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;.</source>
          <target state="translated">이 절에서는 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 로 변환 된 약간 다른 일치 스펙에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="56316fa96e48fce5d8864ec5f5ab650e8bc4aac3" translate="yes" xml:space="preserve">
          <source>This section describes the standard representation of parse trees for Erlang programs as Erlang terms. This representation is known as the &lt;strong&gt;abstract format&lt;/strong&gt;. Functions dealing with such parse trees are &lt;code&gt; compile:forms/1,2&lt;/code&gt; and functions in the following modules:</source>
          <target state="translated">이 섹션에서는 Erlang 프로그램에 대한 구문 분석 트리의 표준 표현을 Erlang 용어로 설명합니다. 이 표현을 &lt;strong&gt;추상 형식&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 이러한 구문 분석 트리를 처리하는 함수는 &lt;code&gt; compile:forms/1,2&lt;/code&gt; 이고 다음 모듈의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2b3b7f437eda66334d0b64118f5de15fc1fc7fab" translate="yes" xml:space="preserve">
          <source>This section describes the standard representation of parse trees for Erlang programs as Erlang terms. This representation is known as the &lt;strong&gt;abstract format&lt;/strong&gt;. Functions dealing with such parse trees are &lt;code&gt;compile:forms/1,2&lt;/code&gt; and functions in the following modules:</source>
          <target state="translated">이 섹션에서는 Erlang 프로그램에 대한 구문 분석 트리의 표준 표현을 Erlang 용어로 설명합니다. 이 표현을 &lt;strong&gt;추상 형식&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 이러한 구문 분석 트리를 처리하는 함수는 &lt;code&gt;compile:forms/1,2&lt;/code&gt; 이며 다음 모듈의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2174d2f040729649ef711f3e5635d25b5e2b5fd1" translate="yes" xml:space="preserve">
          <source>This section describes the use of the registry, a simple mechanism for storing key-value pairs in a C-node, as well as backing them up or restoring them from an &lt;code&gt;Mnesia&lt;/code&gt; table on an Erlang node. For more detailed information about the individual API functions, see the &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">이 섹션에서는 C- 노드에 키-값 쌍을 저장 하고 Erlang 노드 의 &lt;code&gt;Mnesia&lt;/code&gt; 테이블에서 키-값 쌍을 백업 또는 복원하기위한 간단한 메커니즘 인 레지스트리 사용에 대해 설명 합니다. 개별 API 함수에 대한 자세한 정보는 &lt;code&gt;&lt;a href=&quot;registry&quot;&gt;registry&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9871ac4ba76bd34221092f66dc88616fc9822501" translate="yes" xml:space="preserve">
          <source>This section describes what to change in the example to use one &lt;code&gt;handle_event/4&lt;/code&gt; function. The previously used approach to first branch depending on event does not work that well here because of the &lt;strong&gt;state enter calls&lt;/strong&gt;, so this example first branches depending on state:</source>
          <target state="translated">이 섹션에서는 하나의 &lt;code&gt;handle_event/4&lt;/code&gt; 함수 를 사용하기 위해 예제에서 변경해야 할 사항을 설명 합니다. 이전에 사용 된 이벤트에 따라 첫 번째 분기에 대한 접근 방식은 &lt;strong&gt;state enter calls로&lt;/strong&gt; 인해 여기에서 잘 작동하지 않으므로이 예제는 먼저 상태에 따라 분기됩니다.</target>
        </trans-unit>
        <trans-unit id="6e54bfa17aaa2c2d40ded61fef98685a45ccab20" translate="yes" xml:space="preserve">
          <source>This section describes what to change in the example to use one &lt;code&gt;handle_event/4&lt;/code&gt; function. The previously used approach to first branch depending on event does not work that well here because of the state enter calls, so this example first branches depending on state:</source>
          <target state="translated">이 섹션에서는 하나의 &lt;code&gt;handle_event/4&lt;/code&gt; 함수 를 사용하기 위해 예제에서 변경해야 할 사항에 대해 설명 합니다. 이벤트에 따라 이전에 사용한 첫 번째 브랜치 접근 방식은 상태 입력 호출로 인해 여기서 제대로 작동하지 않으므로이 예제는 상태에 따라 첫 번째 브랜치입니다.</target>
        </trans-unit>
        <trans-unit id="62fe5fd22b036a47305b864aea85d4d04ebc8617" translate="yes" xml:space="preserve">
          <source>This section illustrates procedural abstraction. Initially, the following two examples are written as conventional functions.</source>
          <target state="translated">이 섹션에서는 절차 적 추상화를 보여줍니다. 처음에는 다음 두 가지 예가 일반적인 기능으로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="cceb1f5cb17e39dece66daf2562fc578ef8e2eb3" translate="yes" xml:space="preserve">
          <source>This section includes examples of &lt;code&gt;.appup&lt;/code&gt; files for typical cases of upgrades/downgrades done in runtime.</source>
          <target state="translated">이 섹션에는 런타임에서 수행되는 일반적인 업그레이드 / 다운 그레이드 사례에 대한 &lt;code&gt;.appup&lt;/code&gt; 파일의 예가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea33b2a0ec7d517340851621821d8be874ccf07" translate="yes" xml:space="preserve">
          <source>This section includes the example after most of the mentioned modifications and some more using &lt;strong&gt;state enter calls&lt;/strong&gt;, which deserves a new state diagram:</source>
          <target state="translated">이 섹션에는 언급 된 대부분의 수정 및 &lt;strong&gt;상태 입력 호출을&lt;/strong&gt; 사용하는 일부 추가 이후의 예가 포함되어 있습니다. 이 경우 새 상태 다이어그램이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e8307ab1487485b0ab0c191a87d10ed0db502873" translate="yes" xml:space="preserve">
          <source>This section includes the example after most of the mentioned modifications and some more using state enter calls, which deserves a new state diagram:</source>
          <target state="translated">이 섹션에는 언급 된 대부분의 수정 이후의 예와 더 많은 상태 입력 호출을 사용하는 예가 포함되며, 새로운 상태 다이어그램이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="46836c7cf8344b6ce7b90b07cbf3092bf8c64800" translate="yes" xml:space="preserve">
          <source>This section informs on interoperability, that is, information exchange, between Erlang and other programming languages. The included examples mainly treat interoperability between Erlang and C.</source>
          <target state="translated">이 섹션에서는 Erlang과 다른 프로그래밍 언어 간의 상호 운용성, 즉 정보 교환에 대해 설명합니다. 포함 된 예제는 주로 Erlang과 C 간의 상호 운용성을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="89f49f8072fe70dfd2c365690f214b5fdc461dd8" translate="yes" xml:space="preserve">
          <source>This section introduces &lt;code&gt;Mnesia&lt;/code&gt; with an example database. This example is referenced in the following sections, where the example is modified to illustrate various program constructs. This section illustrates the following mandatory procedures through examples:</source>
          <target state="translated">이 섹션에서는 예제 데이터베이스가있는 &lt;code&gt;Mnesia&lt;/code&gt; 를 소개 합니다. 이 예제는 다음 섹션에서 참조되며 여기서 다양한 프로그램 구성을 보여주기 위해 예제가 수정되었습니다. 이 섹션에서는 예제를 통해 다음과 같은 필수 절차를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9ce26ca011dda9632c352924ddce457d60697ee5" translate="yes" xml:space="preserve">
          <source>This section is a quick start tutorial to get you started with Erlang. Everything in this section is true, but only part of the truth. For example, only the simplest form of the syntax is shown, not all esoteric forms. Also, parts that are greatly simplified are indicated with *manual*. This means that a lot more information on the subject is to be found in the Erlang book or in &lt;code&gt; Erlang Reference Manual&lt;/code&gt;.</source>
          <target state="translated">이 섹션은 Erlang을 시작하기위한 빠른 시작 자습서입니다. 이 섹션의 모든 것은 사실이지만 진실의 일부일뿐입니다. 예를 들어, 모든 난해한 형식이 아닌 가장 간단한 형식의 구문 만 표시됩니다. 또한 크게 단순화 된 부분은 * manual *로 표시됩니다. 이것은 주제에 대한 더 많은 정보가 Erlang 책이나 &lt;code&gt; Erlang Reference Manual&lt;/code&gt; 에서 찾을 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4b9ffc517c7f7beea672bf3a45f0d5c54e6718e6" translate="yes" xml:space="preserve">
          <source>This section is a quick start tutorial to get you started with Erlang. Everything in this section is true, but only part of the truth. For example, only the simplest form of the syntax is shown, not all esoteric forms. Also, parts that are greatly simplified are indicated with *manual*. This means that a lot more information on the subject is to be found in the Erlang book or in &lt;code&gt;Erlang Reference Manual&lt;/code&gt;.</source>
          <target state="translated">이 섹션은 Erlang을 시작하기위한 빠른 시작 자습서입니다. 이 섹션의 모든 내용은 사실이지만 사실의 일부일뿐입니다. 예를 들어, 모든 난해한 형식이 아니라 가장 간단한 구문 형식 만 표시됩니다. 또한 크게 단순화 된 부품은 * manual *로 표시됩니다. 이것은 주제에 대한 더 많은 정보가 Erlang 책이나 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 에 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="7681f5719ebc6c3947920d0c8b79f4d20d935db2" translate="yes" xml:space="preserve">
          <source>This section is about installing an embedded system. The following topics are considered:</source>
          <target state="translated">이 섹션은 임베디드 시스템 설치에 관한 것입니다. 다음과 같은 주제가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="e1226c380377fda419e20eb5188c02f21ab8efb4" translate="yes" xml:space="preserve">
          <source>This section is about list functions that &lt;strong&gt;construct&lt;/strong&gt; lists. A tail-recursive function that does not construct a list runs in constant space, while the corresponding body-recursive function uses stack space proportional to the length of the list.</source>
          <target state="translated">이 섹션은리스트를 &lt;strong&gt;구성&lt;/strong&gt; 하는리스트 함수에 관한 것 입니다. 리스트를 구성하지 않는 tail-recursive 함수는 일정한 공간에서 실행되는 반면, 해당 body-recursive 함수는리스트의 길이에 비례하는 스택 공간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68c719f00318cfafeb4885e7d19be04a0e723344" translate="yes" xml:space="preserve">
          <source>This section is the Erlang reference manual. It describes the Erlang programming language.</source>
          <target state="translated">이 섹션은 Erlang 참조 매뉴얼입니다. Erlang 프로그래밍 언어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ef1c8ac7b879ac21c4bbd932c5c5aba836b3ebe" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;app(4)&lt;/code&gt; and &lt;code&gt;application(3)&lt;/code&gt; manual pages in Kernel.</source>
          <target state="translated">이 섹션은 커널 의 &lt;code&gt;app(4)&lt;/code&gt; 및 &lt;code&gt;application(3)&lt;/code&gt; 매뉴얼 페이지 와 함께 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d050299e9360b73cf317b1cb6719eba05c8f8b67" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_event(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">이 절은 &lt;code&gt;gen_event(3)&lt;/code&gt; 의 gen_event (3) 매뉴얼 페이지에서 읽습니다. 여기서 모든 인터페이스 함수 및 콜백 함수에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b25498b71adedf6dc2be1b461a7355670bd9865a" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_server(3)&lt;/code&gt; manual page in &lt;code&gt;stdlib&lt;/code&gt;, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">이 섹션은 &lt;code&gt;stdlib&lt;/code&gt; 의 &lt;code&gt;gen_server(3)&lt;/code&gt; 매뉴얼 페이지에서 읽어야합니다 . 여기서 모든 인터페이스 함수 및 콜백 함수에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e425baa0c9a68eb141d0fd0ffe5193c115033f3e" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;gen_statem(3)&lt;/code&gt; manual page in STDLIB, where all interface functions and callback functions are described in detail.</source>
          <target state="translated">이 섹션은 &lt;code&gt;gen_statem(3)&lt;/code&gt; 의 gen_statem (3) 매뉴얼 페이지에서 읽어야합니다. 여기서 모든 인터페이스 함수 및 콜백 함수에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="834b2272d947ac4550fa4f7cf0a1b4b54d61e0d3" translate="yes" xml:space="preserve">
          <source>This section is to be read with the &lt;code&gt;rel(4)&lt;/code&gt;, &lt;code&gt;systools(3)&lt;/code&gt;, and &lt;code&gt;script(4)&lt;/code&gt; manual pages in SASL.</source>
          <target state="translated">이 섹션은 SASL 의 &lt;code&gt;rel(4)&lt;/code&gt; , &lt;code&gt;systools(3)&lt;/code&gt; 및 &lt;code&gt;script(4)&lt;/code&gt; 매뉴얼 페이지 와 함께 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d930e6096fb887dbfeb97cc96dedbb64de3c9031" translate="yes" xml:space="preserve">
          <source>This section lists a few modules and BIFs to watch out for, not only from a performance point of view.</source>
          <target state="translated">이 섹션에는 성능 관점뿐만 아니라주의해야 할 몇 가지 모듈과 BIF가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="302cba4ce6be32265c131b8fff3be15369bb97a8" translate="yes" xml:space="preserve">
          <source>This section lists all funs. The following fields exist for each fun:</source>
          <target state="translated">이 섹션에는 모든 재미가 있습니다. 각 재미에는 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc1c1a16c9fc6835aa747c430d5753502607fd3" translate="yes" xml:space="preserve">
          <source>This section lists the open ports, their owners, any linked processes, and the name of their driver or external process.</source>
          <target state="translated">이 섹션에는 열린 포트, 소유자, 연결된 프로세스 및 드라이버 또는 외부 프로세스 이름이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="251c858a6feb418633832df9c31b24c8b4f5a1b7" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using Native Implemented Functions (NIFs).</source>
          <target state="translated">이 절에서는 NIF (Native Implemented Functions)를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 의 예제 문제점을 해결하는 방법에 대한 예제를 간략하게 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="e7bc2bafdedf8fd30afa495c12130ded7ddd3fc5" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a C node. Notice that a C node is not typically used for solving simple problems like this, a port is sufficient.</source>
          <target state="translated">이 절에서는 C 노드를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 의 예제 문제점을 해결하는 방법에 대한 예제를 간략하게 설명 합니다. C 노드는 일반적으로 이와 같은 간단한 문제를 해결하는 데 사용되지 않으며 포트로 ​​충분합니다.</target>
        </trans-unit>
        <trans-unit id="d8b1fe16968a43f36d99fc7c39a89fadb4f26e24" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a linked-in port driver.</source>
          <target state="translated">이 절에서는 연결된 포트 드라이버를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 예제 문제를 해결하는 방법에 대한 예를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="6188e756764065c7ce79203e7dc5cecf3ee5f2b4" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; by using a port and Erl_Interface. It is necessary to read the port example in &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; before reading this section.</source>
          <target state="translated">이 절에서는 포트와 Erl_Interface를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;Problem Example&lt;/a&gt;&lt;/code&gt; 의 예제 문제점을 해결하는 방법에 대한 예제를 간략하게 설명합니다 . 에서 포트 예를 읽을 필요가 &lt;code&gt;&lt;a href=&quot;c_port&quot;&gt;Ports&lt;/a&gt;&lt;/code&gt; 이 절을 읽기 전에.</target>
        </trans-unit>
        <trans-unit id="37a17f96d0247a59a445c39970b3c2ce5aa258a2" translate="yes" xml:space="preserve">
          <source>This section outlines an example of how to solve the example problem in the &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; by using a port.</source>
          <target state="translated">이 섹션에서는 포트를 사용하여 &lt;code&gt;&lt;a href=&quot;example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; 의 예제 문제를 해결하는 방법의 예를 간략하게 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="909ed75e66d95b03604cc684f38a417f30c36fa4" translate="yes" xml:space="preserve">
          <source>This section outlines the current Unicode support and gives some recipes for working with Unicode data.</source>
          <target state="translated">이 섹션에서는 현재 유니 코드 지원에 대해 간략하게 설명하고 유니 코드 데이터 작업을위한 몇 가지 레시피를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4548220d710b00d84d1083e484e819816bc4647" translate="yes" xml:space="preserve">
          <source>This section presents all the atoms in the system. This is only of interest if one suspects that dynamic generation of atoms can be a problem, otherwise this section can be ignored.</source>
          <target state="translated">이 섹션은 시스템의 모든 원자를 나타냅니다. 이것은 원자의 동적 생성이 문제가 될 수 있다고 의심되는 경우에만 관심이 있으며, 그렇지 않으면이 섹션을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98a32dcb47ef919db3aef2c03013357cf7c9199" translate="yes" xml:space="preserve">
          <source>This section presents the generic protocol-independent model for use within an OTP-based NE. This model is used by all OAM components and can be used by the applications. The advantage of the model is that it clearly separates the resources from the management protocol. The resources do not need to be aware of which management protocol is used to manage the system. The same resources can therefore be managed with different protocols.</source>
          <target state="translated">이 섹션에서는 OTP 기반 NE 내에서 사용하기위한 프로토콜 독립적 인 모델을 제시합니다. 이 모델은 모든 OAM 구성 요소에서 사용되며 응용 프로그램에서 사용할 수 있습니다. 이 모델의 장점은 리소스가 관리 프로토콜과 명확하게 분리된다는 것입니다. 리소스는 시스템을 관리하는 데 사용되는 관리 프로토콜을 알 필요가 없습니다. 따라서 동일한 프로토콜을 다른 프로토콜로 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="16347e215e685cc8a7eb7375f07fbbb91f2c9603" translate="yes" xml:space="preserve">
          <source>This section provides a brief overview on how to write efficient drivers.</source>
          <target state="translated">이 섹션에서는 효율적인 드라이버 작성 방법에 대한 간략한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30913964bf9365a1caa81bfa4bb9ad170421d97f" translate="yes" xml:space="preserve">
          <source>This section provides a simplified demonstration of a &lt;code&gt;Mnesia&lt;/code&gt; system startup. The dialogue from the Erlang shell is as follows:</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 시작에 대한 간단한 데모를 제공합니다 . Erlang 쉘의 대화는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec0f201c25b61d89e7f6c76b13618afc0002a916" translate="yes" xml:space="preserve">
          <source>This section should be read with the &lt;code&gt;supervisor(3)&lt;/code&gt; manual page in STDLIB, where all details about the supervisor behaviour is given.</source>
          <target state="translated">이 섹션은 STDLIB 의 &lt;code&gt;supervisor(3)&lt;/code&gt; 매뉴얼 페이지에서 읽어야합니다. 여기서 감독자 동작에 대한 모든 세부 사항이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="859dc9ee797ee513900af80c0e4f3984de1a34df" translate="yes" xml:space="preserve">
          <source>This section shows a small example of how to set up client/server connections using the Erlang shell. The returned value of the &lt;code&gt;sslsocket&lt;/code&gt; is abbreviated with &lt;code&gt;[...]&lt;/code&gt; as it can be fairly large and is opaque.</source>
          <target state="translated">이 섹션에서는 Erlang 쉘을 사용하여 클라이언트 / 서버 연결을 설정하는 방법에 대한 작은 예를 보여줍니다. &lt;code&gt;sslsocket&lt;/code&gt; 의 리턴 값은 상당히 크고 불투명하기 때문에 &lt;code&gt;[...]&lt;/code&gt; 로 축약됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b3f3a6882bc6f1c999e3d6f053e34aa184902fb" translate="yes" xml:space="preserve">
          <source>This section starts with a simple example, showing a generator and a filter:</source>
          <target state="translated">이 섹션은 간단한 예제로 시작하여 생성기와 필터를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b10755987ebac7d338a7fd1a7c6bbec42a0583a6" translate="yes" xml:space="preserve">
          <source>This section tries to kill the old truths (or semi-truths) that have become myths.</source>
          <target state="translated">이 부분은 신화가 된 오래된 진실 (또는 반진)을 죽이려고합니다.</target>
        </trans-unit>
        <trans-unit id="4bc790cb1406d976325d74bbdbe32730d66b0176" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, as it explains important concepts, but this was written for an older driver interface so the examples do not work anymore. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">이 섹션은 오래 전에 작성되었습니다. 중요한 개념을 설명하기 때문에 대부분의 경우 여전히 유효하지만 이전 드라이버 인터페이스 용으로 작성되었으므로 더 이상 예제가 작동하지 않습니다. 독자는 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 문서도 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b93f78b17719c3a40516be4872cc22d2aa5ee759" translate="yes" xml:space="preserve">
          <source>This section was written a long time ago. Most of it is still valid, but some things have changed since then. Some updates have been made to the documentation of the driver presented here, but more can be done and is planned for the future. The reader is encouraged to read the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; documentation also.</source>
          <target state="translated">이 섹션은 오래 전에 작성되었습니다. 대부분은 여전히 ​​유효하지만 그 이후로 일부 사항이 변경되었습니다. 여기에 제시된 드라이버의 문서가 일부 업데이트되었지만 더 많은 작업을 수행하고 향후 계획을 세울 수 있습니다. 독자는 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 문서도 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3acfdfded91bac52b2d4f66deb3db7bcfef3bb64" translate="yes" xml:space="preserve">
          <source>This sends a request with a specified connection header:</source>
          <target state="translated">지정된 연결 헤더로 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a989f27ccbc0cd1a9d3190ceeec551d99b4ccfce" translate="yes" xml:space="preserve">
          <source>This sends an HTTP request over a unix domain socket (experimental):</source>
          <target state="translated">이것은 유닉스 도메인 소켓을 통해 HTTP 요청을 보냅니다 (실험적).</target>
        </trans-unit>
        <trans-unit id="0367f390c138c4cdab5de93d4dcd533741c91409" translate="yes" xml:space="preserve">
          <source>This server can be started with the Kernel configuration parameter &lt;code&gt;start_boot_server&lt;/code&gt;.</source>
          <target state="translated">이 서버는 커널 구성 매개 변수 &lt;code&gt;start_boot_server&lt;/code&gt; 로 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a01d31508a13cbee6fd61e7f30640416fa3e960" translate="yes" xml:space="preserve">
          <source>This server is used to assist diskless Erlang nodes that fetch all Erlang code from another machine.</source>
          <target state="translated">이 서버는 다른 시스템에서 모든 Erlang 코드를 가져 오는 디스크없는 Erlang 노드를 지원하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d1e9f0f9d29165296c1877ce900cce295357757" translate="yes" xml:space="preserve">
          <source>This server is used to fetch all code, including the start script, if an Erlang runtime system is started with command-line flag &lt;code&gt;-loader inet&lt;/code&gt;. All hosts specified with command-line flag &lt;code&gt;-hosts Host&lt;/code&gt; must have one instance of this server running.</source>
          <target state="translated">이 서버는 Erlang 런타임 시스템이 명령 행 플래그 &lt;code&gt;-loader inet&lt;/code&gt; 로 시작된 경우 시작 스크립트를 포함하여 모든 코드를 가져 오는 데 사용됩니다 . 명령 행 플래그 &lt;code&gt;-hosts Host&lt;/code&gt; 로 지정된 모든 호스트 에는이 서버의 인스턴스 하나가 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b854dfbf08852692209c2c9428fe6541ba04a2b8" translate="yes" xml:space="preserve">
          <source>This session sets the system_tracer to the same process as the ordinary tracer process (i. e. &amp;lt;0.31.0&amp;gt;) and sets the trace pattern for the function &lt;code&gt;dbg:get_tracer&lt;/code&gt; to one that has the action of setting a sequential token. When the function is called by a traced process (all processes are traced in this case), the process gets &quot;contaminated&quot; by the token and &lt;code&gt;seq_trace&lt;/code&gt; messages are sent both for the server request and the response. The &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; after the call clears the &lt;code&gt;seq_trace&lt;/code&gt; token, why no messages are sent when the answer propagates via the shell to the console port. The output would otherwise have been more noisy.</source>
          <target state="translated">이 세션은 system_tracer를 일반 추적 프로그램 프로세스와 동일한 프로세스 (예 : &amp;lt;0.31.0&amp;gt;)로 설정하고 &lt;code&gt;dbg:get_tracer&lt;/code&gt; 함수의 추적 패턴을 순차적 토큰 설정 조치가있는 패턴 으로 설정합니다. 추적 된 프로세스가 함수를 호출하면 (이 경우 모든 프로세스가 추적 됨) 프로세스가 토큰에 의해 &quot;오염&quot;되고 &lt;code&gt;seq_trace&lt;/code&gt; 메시지가 서버 요청과 응답 모두에 대해 전송됩니다. &lt;code&gt;seq_trace:set_token([])&lt;/code&gt; 호출 후 해제 &lt;code&gt;seq_trace&lt;/code&gt; 어떤 메시지가 전송되지 않는 이유 토큰을 때의 콘솔 포트에 쉘을 통해 응답 전파. 그렇지 않으면 출력이 더 시끄 럽습니다.</target>
        </trans-unit>
        <trans-unit id="cbd4292b15086fa99902265956cddedc9ff73138" translate="yes" xml:space="preserve">
          <source>This shared format is the heart of the EEP as it is what effectively allows cross-language collaboration.</source>
          <target state="translated">이 공유 형식은 언어 간 협업을 효과적으로 허용하므로 EEP의 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="7f6dee944ecab0b445c18e6ceefaac7d931ceec9" translate="yes" xml:space="preserve">
          <source>This should do the final touch to the environment and building should be easy after this. You could run &lt;code&gt;./otp_build env_win32&lt;/code&gt; without &lt;code&gt;eval&lt;/code&gt; just to see what it does, and to see that the environment it sets seems OK. The path is cleaned of spaces if possible (using DOS style short names instead), the variables &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt;, &lt;code&gt;CC&lt;/code&gt;, &lt;code&gt;CXX&lt;/code&gt;, &lt;code&gt;AR&lt;/code&gt; and &lt;code&gt;RANLIB&lt;/code&gt; are set to their respective wrappers and the directories &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; are added first in the PATH.</source>
          <target state="translated">이것은 환경에 대한 최종적인 손길이되어야하며, 그 후에는 건물이 쉬워야합니다. &lt;code&gt;./otp_build env_win32&lt;/code&gt; 를 &lt;code&gt;eval&lt;/code&gt; 없이 실행할 수 있으며 설정 한 환경이 정상인지 확인할 수 있습니다. 가능한 경우 경로는 공백으로 정리되고 (DOS 스타일의 짧은 이름을 대신 사용) 변수 &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt; , &lt;code&gt;CC&lt;/code&gt; , &lt;code&gt;CXX&lt;/code&gt; , &lt;code&gt;AR&lt;/code&gt; 및 &lt;code&gt;RANLIB&lt;/code&gt; 변수 는 각각의 래퍼 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tools/vc&lt;/code&gt; 디렉토리로 설정됩니다. &amp;gt; _tools / vc 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/&amp;lt;cygwin/msys&amp;gt;_tool&lt;/code&gt; 이 PATH에서 먼저 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="03f198b6590c34f01a64a75908db7163cea9b266" translate="yes" xml:space="preserve">
          <source>This should do the final touch to the environment and building should be easy after this. You could run &lt;code&gt;./otp_build env_win32&lt;/code&gt; without &lt;code&gt;eval&lt;/code&gt; just to see what it does, and to see that the environment it sets seems OK. The path is cleaned of spaces if possible (using DOS style short names instead), the variables &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt;, &lt;code&gt;CC&lt;/code&gt;, &lt;code&gt;CXX&lt;/code&gt;, &lt;code&gt;AR&lt;/code&gt; and &lt;code&gt;RANLIB&lt;/code&gt; are set to their respective wrappers and the directories &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt; are added first in the PATH.</source>
          <target state="translated">이것은 환경에 대한 최종적인 접촉을해야하고 그 후에는 건물이 쉬워야합니다. &lt;code&gt;eval&lt;/code&gt; 없이 &lt;code&gt;./otp_build env_win32&lt;/code&gt; 를 실행 하여 그 기능을 확인하고 설정 한 환경이 정상으로 보이는지 확인할 수 있습니다. 경로는 (대신 DOS 스타일의 짧은 이름을 사용) 가능한 변수가있는 경우 공간의 청소 &lt;code&gt;OVERRIDE_TARGET&lt;/code&gt; , &lt;code&gt;CC&lt;/code&gt; 는 , &lt;code&gt;CXX&lt;/code&gt; , &lt;code&gt;AR&lt;/code&gt; 및 &lt;code&gt;RANLIB&lt;/code&gt; 디렉토리 각각의 래퍼로 설정하고 &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; 및 &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt; 가 PATH에 먼저 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b5857195448594d0390d51817917a61df0959d" translate="yes" xml:space="preserve">
          <source>This should setup the additional environment variables.</source>
          <target state="translated">추가 환경 변수를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d785e08dd7a56c60e1bed8756d1974bdb847eb99" translate="yes" xml:space="preserve">
          <source>This shows another important non-obvious case: a clause guard, even if it's as simple as &lt;code&gt;Y &amp;gt; 0&lt;/code&gt;, always consists of a single disjunction of one or more conjunctions of tests, much like a tuple of tuples. Thus:</source>
          <target state="translated">이것은 명백한 또 다른 중요한 경우를 보여줍니다. 절 보호는 &lt;code&gt;Y &amp;gt; 0&lt;/code&gt; 과 같이 단순하더라도 항상 튜플의 튜플과 같이 하나 이상의 테스트 조합으로 단일 분리로 구성됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="d79fe51d70506d4d2574ce2f8d6c698753c2450c" translate="yes" xml:space="preserve">
          <source>This signal is sent as a reply to a process previously sending a &lt;code&gt;&lt;a href=&quot;#SPAWN_REQUEST&quot;&gt;SPAWN_REQUEST&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="translated">이 신호는 이전에 &lt;code&gt;&lt;a href=&quot;#SPAWN_REQUEST&quot;&gt;SPAWN_REQUEST&lt;/a&gt;&lt;/code&gt; 신호를 전송 한 프로세스에 대한 응답으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="640f93147afaa4bbce9c0970534b8a37095141af" translate="yes" xml:space="preserve">
          <source>This signal is sent by a call to the erlang:exit/2 bif</source>
          <target state="translated">이 신호는 erlang : exit / 2 bif에 대한 호출로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="7068d2c470c4b8af4e69cfc9fdf5935a4cd0cd8e" translate="yes" xml:space="preserve">
          <source>This signal is sent by the &lt;code&gt;&lt;a href=&quot;erlang#spawn_request-5&quot;&gt;spawn_request()&lt;/a&gt;&lt;/code&gt; BIF.</source>
          <target state="translated">이 신호는 &lt;code&gt;&lt;a href=&quot;erlang#spawn_request-5&quot;&gt;spawn_request()&lt;/a&gt;&lt;/code&gt; BIF에 의해 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bcd8c5c7a896221b7a365d42f6767bd737b00ce" translate="yes" xml:space="preserve">
          <source>This signal is sent when a link has been broken</source>
          <target state="translated">이 신호는 링크가 끊어졌을 때 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="1fa8ade625dd050384ebfe47137813125a13ed25" translate="yes" xml:space="preserve">
          <source>This signal will be ignored.</source>
          <target state="translated">이 신호는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="92abfd0b7a6c2f6f6e673410127b459c582c4efd" translate="yes" xml:space="preserve">
          <source>This signal will notify &lt;code&gt;erl_signal_server&lt;/code&gt; when it is received by the Erlang runtime system.</source>
          <target state="translated">이 신호는 Erlang 런타임 시스템에 의해 수신 될 때 &lt;code&gt;erl_signal_server&lt;/code&gt; 에 통지 합니다.</target>
        </trans-unit>
        <trans-unit id="edab6f17da92a0f0da17b2cdabee390180519ab6" translate="yes" xml:space="preserve">
          <source>This signal will use the default signal handler for the operating system.</source>
          <target state="translated">이 신호는 운영 체제의 기본 신호 처리기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="da98f38cbd3a5312fa20fb0710bd3343db7b6751" translate="yes" xml:space="preserve">
          <source>This simple definition was extended in Unicode to include more complicated kinds of composite character by giving each character a grapheme breaking property, and creating rules that use these properties to define the boundaries of extended grapheme clusters. In PCRE releases later than 8.31, \X matches one of these clusters.</source>
          <target state="translated">이 간단한 정의는 각 문자에 grapheme Breaking 속성을 부여하고 이러한 속성을 사용하여 확장 된 grapheme 클러스터의 경계를 정의하는 규칙을 작성하여 더 복잡한 종류의 복합 문자를 포함하도록 유니 코드로 확장되었습니다. 8.31 이후의 PCRE 릴리스에서 \ X는 이러한 클러스터 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e86121002d76857e44d3ab841a1269a83df96b05" translate="yes" xml:space="preserve">
          <source>This simple standard test, &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt;, a module which, using the &lt;code&gt;snmp_ex2_manager&lt;/code&gt; described in the previous section, implements a simple agent test utility.</source>
          <target state="translated">이 간단한 표준 테스트 인 &lt;code&gt;snmp_ex2_simple_standard_test&lt;/code&gt; 는 이전 섹션에서 설명한 &lt;code&gt;snmp_ex2_manager&lt;/code&gt; 를 사용하여 간단한 에이전트 테스트 유틸리티를 구현하는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="dd2b5053ac3688fc735f48df406e257a6da53d21" translate="yes" xml:space="preserve">
          <source>This sort of problem can be solved easier by use of the facilities in OTP, which also provide methods for updating code on the fly and so on (see &lt;code&gt; OTP Design Principles&lt;/code&gt;).</source>
          <target state="translated">이러한 종류의 문제는 OTP의 기능을 사용하여 쉽게 해결할 수 있으며, 이는 코드를 즉시 업데이트하는 방법도 제공합니다 ( &lt;code&gt; OTP Design Principles&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2d0034518115855077790a9986c987efa20b3785" translate="yes" xml:space="preserve">
          <source>This sort of problem can be solved easier by use of the facilities in OTP, which also provide methods for updating code on the fly and so on (see &lt;code&gt;OTP Design Principles&lt;/code&gt;).</source>
          <target state="translated">OTP의 기능을 사용하면 이러한 종류의 문제를 쉽게 해결할 수 있습니다.이 기능을 사용하면 코드를 즉시 업데이트하는 방법도 제공합니다 ( &lt;code&gt;OTP Design Principles&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e3b6d6c6628faa03b7c6f08bc646ad236cf4da32" translate="yes" xml:space="preserve">
          <source>This specialized decode decodes a subtype of a constructed value and is the fastest method to extract a subvalue. This decode is typically used when you want to inspect, for example, a version number, to be able to decide what to do with the entire value. The result is returned as &lt;code&gt;{ok,Value}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">이 특수화 된 디코드는 생성 된 값의 하위 유형을 디코딩하며 하위 값을 추출하는 가장 빠른 방법입니다. 이 디코드는 일반적으로 전체 값으로 수행 할 작업을 결정할 수 있도록 버전 번호와 같은 검사하려는 경우에 사용됩니다. 결과는 &lt;code&gt;{ok,Value}&lt;/code&gt; 또는 &lt;code&gt;{error,Reason}&lt;/code&gt; 으로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6e3b86cfeba9cfc10be5c29dcc96ff101065bf4" translate="yes" xml:space="preserve">
          <source>This specifies the file modes to use when opening the log file, see &lt;code&gt;&lt;a href=&quot;file#open-2&quot;&gt;file:open/2&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;modes&lt;/code&gt; are not specified, the default list used is &lt;code&gt;[raw,append,delayed_write]&lt;/code&gt;. If &lt;code&gt;modes&lt;/code&gt; are specified, the list replaces the default modes list with the following adjustments:</source>
          <target state="translated">이것은 로그 파일을 열 때 사용할 파일 모드를 지정합니다 . &lt;code&gt;&lt;a href=&quot;file#open-2&quot;&gt;file:open/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 경우 &lt;code&gt;modes&lt;/code&gt; 지정되지 않은, 사용되는 기본 목록입니다 &lt;code&gt;[raw,append,delayed_write]&lt;/code&gt; . &lt;code&gt;modes&lt;/code&gt; 가 지정된 경우 목록은 기본 모드 목록을 다음 조정으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="89922ee078d75b864b4466e994e9cf6b8e2ad24b" translate="yes" xml:space="preserve">
          <source>This specifies the name of the log file when the handler is of type &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">핸들러가 &lt;code&gt;file&lt;/code&gt; 유형일 때 로그 파일의 이름을 지정 합니다 .</target>
        </trans-unit>
        <trans-unit id="77e086b8dea4b8bfb5a0597b5900b1d75b0fef9f" translate="yes" xml:space="preserve">
          <source>This starts Erlang in its own window, with fully functioning command-line editing and scrollbars. All flags except &lt;code&gt;-oldshell&lt;/code&gt; work as they do for &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 완전한 기능을 갖춘 명령 줄 편집 및 스크롤 막대와 함께 자체 창에서 Erlang을 시작합니다. &lt;code&gt;-oldshell&lt;/code&gt; 을 제외한 모든 플래그 는 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a43faa1a1676e12b0177f046a812f0d8364ec82d" translate="yes" xml:space="preserve">
          <source>This starts the Erlang runtime system and evaluates the following functions:</source>
          <target state="translated">그러면 Erlang 런타임 시스템이 시작되고 다음 기능이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb8d3378772860a522d3a705d4cc5d40c409e79" translate="yes" xml:space="preserve">
          <source>This state data can be regarded as sensitive, and maybe not what you want in the error log because of some unpredictable event.</source>
          <target state="translated">이 상태 데이터는 민감한 것으로 간주 될 수 있으며 예측할 수없는 이벤트로 인해 오류 로그에 원하는 것이 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c14a1eab4a2d73f912f341632799fc7862da43" translate="yes" xml:space="preserve">
          <source>This state transition action can be invoked by returning it from the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;, from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or by giving it to &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 상태 전이 조치는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 로부터 리턴 하거나 &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; 에 제공하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57901b1493b88f1a72b634f92f65ad89d7517d70" translate="yes" xml:space="preserve">
          <source>This step also implies that the Erlang code in the interface and distribution modules is written in such a way that it can be run in the startup phase. In particular, there can be no calls to the &lt;code&gt;application&lt;/code&gt; module or to any modules not loaded at boot time. That is, only &lt;code&gt;Kernel&lt;/code&gt;, &lt;code&gt;STDLIB&lt;/code&gt;, and the application itself can be used.</source>
          <target state="translated">이 단계는 또한 인터페이스 및 분배 모듈의 Erlang 코드가 시작 단계에서 실행될 수있는 방식으로 작성되었음을 의미합니다. 특히, &lt;code&gt;application&lt;/code&gt; 모듈 또는 부팅시로드되지 않은 모듈에 대한 호출이 없을 수 있습니다 . 즉, &lt;code&gt;Kernel&lt;/code&gt; , &lt;code&gt;STDLIB&lt;/code&gt; 및 애플리케이션 자체 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33eaf1a1a2a532c70f7ffcd5caaf8b22d9ff8909" translate="yes" xml:space="preserve">
          <source>This structure is to be used if all clients are running the same type of Erlang machine. If there are clients running different types of Erlang machines, or on different operating systems, the &lt;code&gt;clients&lt;/code&gt; directory can be divided into one subdirectory per type of Erlang machine. Alternatively, one &lt;code&gt;$ROOT&lt;/code&gt; can be set up per type of machine. For each type, some of the directories specified for the &lt;code&gt;$ROOT&lt;/code&gt; directory are to be included:</source>
          <target state="translated">이 구조는 모든 클라이언트가 동일한 유형의 Erlang 시스템을 실행중인 경우에 사용됩니다. 다른 유형의 Erlang 시스템 또는 다른 운영 체제에서 실행중인 클라이언트가있는 경우 &lt;code&gt;clients&lt;/code&gt; 디렉토리를 Erlang 시스템 유형마다 하나의 서브 디렉토리로 나눌 수 있습니다. 또는 머신 유형마다 하나의 &lt;code&gt;$ROOT&lt;/code&gt; 를 설정할 수 있습니다. 각 유형에 대해 &lt;code&gt;$ROOT&lt;/code&gt; 디렉토리에 지정된 일부 디렉토리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ba107d8023d557fe4ebdc08a0485fead425f4a4c" translate="yes" xml:space="preserve">
          <source>This structure is used for all types of ports although some fields are useless for some types. The least memory consuming solution would be to arrange this structure as a union of structures. However, the multiple indirections in the code to access a field in such a structure would clutter the code too much for an example.</source>
          <target state="translated">이 구조는 모든 유형의 포트에 사용되지만 일부 필드는 일부 유형에는 쓸모가 없습니다. 가장 적은 메모리 소비 솔루션은이 구조를 구조의 결합으로 배열하는 것입니다. 그러나 코드에서 이러한 구조의 필드에 액세스하기위한 여러 간접 지시는 코드를 너무 복잡하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b9c807a7212c0db55e210d6237e55cf572102e59" translate="yes" xml:space="preserve">
          <source>This switches off logging for SSH and Telnet connections.</source>
          <target state="translated">SSH 및 Telnet 연결에 대한 로깅이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="3c8936eaae5713c5223ec21e20e0d36d26fc0092" translate="yes" xml:space="preserve">
          <source>This switches off logging for all connection types.</source>
          <target state="translated">모든 연결 유형에 대한 로깅이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f56bbb3abc53b0a624950444e1c66ce730f11613" translate="yes" xml:space="preserve">
          <source>This symbol should appear in the lhs of at least one grammar rule. This is the most general syntactic category which the parser ultimately will parse every input string into.</source>
          <target state="translated">이 기호는 적어도 하나의 문법 규칙에 나타납니다. 이것은 구문 분석기가 궁극적으로 모든 입력 문자열을 구문 분석하는 가장 일반적인 구문 범주입니다.</target>
        </trans-unit>
        <trans-unit id="f08fbd9f459967f29635f3f9f2adf9603031def1" translate="yes" xml:space="preserve">
          <source>This symmetric property is heavily used in our property test suite.</source>
          <target state="translated">이 대칭 속성은 속성 테스트 스위트에서 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f51a949c8210df35958e734e70df198be7b37d8" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to the syntax used in the trace patterns (see the &lt;code&gt; dbg(3)&lt;/code&gt;) module in Runtime_Tools.</source>
          <target state="translated">이 구문은 Runtime_Tools 의 추적 패턴 ( &lt;code&gt; dbg(3)&lt;/code&gt; ) 모듈에서 사용되는 구문과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a9ad3ed484ba9b2b41f2325fc27244234c66f278" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to the syntax used in the trace patterns (see the &lt;code&gt;dbg(3)&lt;/code&gt;) module in Runtime_Tools.</source>
          <target state="translated">이 구문은 Runtime_Tools 의 추적 패턴 ( &lt;code&gt;dbg(3)&lt;/code&gt; ) 모듈에 사용 된 구문과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="47928f153f260fce7ed8db1828b373dc61ec71dc" translate="yes" xml:space="preserve">
          <source>This table lists the retired cipher names in the first column and suggests names to replace them with in the second column.</source>
          <target state="translated">이 표는 첫 번째 열에 폐기 된 암호 이름을 나열하고 두 번째 열에서 대체 할 이름을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="ee2b2d8d451101694a58799b8409428a148a8058" translate="yes" xml:space="preserve">
          <source>This takes &lt;code&gt;H&lt;/code&gt; from &lt;code&gt;L&lt;/code&gt; in all possible ways. The result is the set of all lists &lt;code&gt;[H|T]&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the set of all possible permutations of &lt;code&gt;L&lt;/code&gt;, with &lt;code&gt;H&lt;/code&gt; removed:</source>
          <target state="translated">이것은 가능한 모든 방법으로 &lt;code&gt;L&lt;/code&gt; 에서 &lt;code&gt;H&lt;/code&gt; 를 가져옵니다 . 결과는 모든 목록의 집합이다 &lt;code&gt;[H|T]&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 는 모든 가능한 순열의 집합 인 &lt;code&gt;L&lt;/code&gt; 과, &lt;code&gt;H&lt;/code&gt; 제거 :</target>
        </trans-unit>
        <trans-unit id="618f3633ac8c2cadd4289f1c5621d970e601a5ca" translate="yes" xml:space="preserve">
          <source>This term is the encoding for external funs: &lt;code&gt;fun M:F/A&lt;/code&gt;.</source>
          <target state="translated">:이 용어는 외부 funs입니다에 대한 인코딩입니다 &lt;code&gt;fun M:F/A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beb3ae0ca905f496ce783ad12cff60bb9bb87bbd" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 0 of the external format; it has been superseded by &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 용어는 외부 형식의 부 버전 0에서 사용됩니다. &lt;code&gt;&lt;a href=&quot;#NEW_FLOAT_EXT&quot;&gt;NEW_FLOAT_EXT&lt;/a&gt;&lt;/code&gt; (으) 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b517e1702cae7ec8ee019fdb69c857aa5330cfd8" translate="yes" xml:space="preserve">
          <source>This term is used in minor version 1 of the external format.</source>
          <target state="translated">이 용어는 외부 형식의 부 버전 1에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0860084b170b958eacacb8679369f69a7b4a4046" translate="yes" xml:space="preserve">
          <source>This term represents a bitstring whose length in bits does not have to be a multiple of 8. The &lt;code&gt;Len&lt;/code&gt; field is an unsigned 4 byte integer (big-endian). The &lt;code&gt;Bits&lt;/code&gt; field is the number of bits (1-8) that are used in the last byte in the data field, counting from the most significant bit to the least significant.</source>
          <target state="translated">이 용어는 비트 단위의 길이가 8의 배수 일 필요가없는 비트 열을 나타냅니다. &lt;code&gt;Len&lt;/code&gt; 필드는 부호없는 4 바이트 정수 (빅 엔디안)입니다. &lt;code&gt;Bits&lt;/code&gt; 필드는 데이터 필드의 마지막 바이트에 사용되는 비트 (1-8)의 수이고, 최상위 비트에서 최하위로 계산.</target>
        </trans-unit>
        <trans-unit id="108bbd5cab7129c54f675f7643a23fb10026ce1d" translate="yes" xml:space="preserve">
          <source>This test specification declares that &lt;code&gt;node1@host1&lt;/code&gt; is to be started using the user callback function &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt;, and nodes &lt;code&gt;node1@host2&lt;/code&gt; and &lt;code&gt;node2@host2&lt;/code&gt; are to be started with the default callback module &lt;code&gt;ct_slave&lt;/code&gt;. The specified username and password are used to log on to remote host &lt;code&gt;host2&lt;/code&gt;. Also, function &lt;code&gt;module:function/0&lt;/code&gt; is evaluated on &lt;code&gt;node1@host3&lt;/code&gt;, and the result of this call is printed to the log.</source>
          <target state="translated">이 테스트 사양은 &lt;code&gt;node1@host1&lt;/code&gt; 이 사용자 콜백 함수 &lt;code&gt;callback_module:my_slave_callback/0&lt;/code&gt; 을 사용하여 시작 되고 &lt;code&gt;node1@host2&lt;/code&gt; 및 &lt;code&gt;node2@host2&lt;/code&gt; 노드 가 기본 콜백 모듈 &lt;code&gt;ct_slave&lt;/code&gt; 로 시작되도록 선언 합니다. 지정된 사용자 이름 및 비밀번호는 원격 호스트 &lt;code&gt;host2&lt;/code&gt; 에 로그온하는 데 사용됩니다 . 또한 function &lt;code&gt;module:function/0&lt;/code&gt; 은 &lt;code&gt;node1@host3&lt;/code&gt; 에서 평가 되며이 호출의 결과는 로그에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e29f7e984adbbfe8a53af166b10808cfa43c1c97" translate="yes" xml:space="preserve">
          <source>This tests all object files in the specified directory, as if they had been individually specified using &lt;code&gt;{file, FileName}&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;{file, FileName}&lt;/code&gt; 사용하여 개별적으로 지정된 것처럼 지정된 디렉토리의 모든 오브젝트 파일을 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="76191fd55833467474b9c8b3bbd30d057e2c02a5" translate="yes" xml:space="preserve">
          <source>This the formatter callback function to be called from handlers. The log event is processed as follows:</source>
          <target state="translated">핸들러에서 호출 할 포맷터 콜백 함수입니다. 로그 이벤트는 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a753a4a3983a27e7aa021fa6ea24ccc7d272be01" translate="yes" xml:space="preserve">
          <source>This time argument 2 is used, which is the second element in the tuple. If this returns the atom &lt;code&gt;false&lt;/code&gt;, fred is not logged on and the following message is sent:</source>
          <target state="translated">이번에는 인수 2가 사용되는데, 이는 튜플의 두 번째 요소입니다. 이 반환 원자의 경우 &lt;code&gt;false&lt;/code&gt; , 프레드에 기록되지 않고 다음과 같은 메시지가 전송됩니다</target>
        </trans-unit>
        <trans-unit id="15904ce64792364db6d7744d6d49fc6072f3ad19" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time in the general case. For more information, see the documentation of &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt; time warp modes&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">이 시간은 일반적인 경우에 단조롭게 증가하는 시간이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 자세한 내용 은 사용자 가이드 의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt; time warp modes&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e6fffaa6a8f0644a7ea4fa7c7c74c76ec90d774c" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time in the general case. For more information, see the documentation of &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">이 시간은 일반적인 경우 단조 증가하는 시간이 &lt;strong&gt;아닙니다&lt;/strong&gt; . 자세한 내용은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;time_correction#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49beb73df376b7dea84521a1c52301d5531a79e4" translate="yes" xml:space="preserve">
          <source>This time is &lt;strong&gt;not&lt;/strong&gt; a monotonically increasing time.</source>
          <target state="translated">이 시간은 단조 증가하는 시간이 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3748262d456a936f46c1ed22dababf257bb3fa6f" translate="yes" xml:space="preserve">
          <source>This time may or may not be an accurate view of POSIX time, and may or may not align with &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt;. The runtime system works towards aligning the two system times. Depending on the &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; used, this can be achieved by letting Erlang system time perform a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 시간은 POSIX 시간을 정확하게 볼 수도 있고 아닐 수도 있으며 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 과 일치 할 수도 있고 일치하지 않을 수도 있습니다 . 런타임 시스템은 두 시스템 시간을 맞추기 위해 노력합니다. 사용 된 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp mode&lt;/a&gt;&lt;/code&gt; 에 따라 , Erlang 시스템 시간이 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 수행하게함으로써이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83d87d01faae0b3a7fef0f76f0e3a3892ae23062" translate="yes" xml:space="preserve">
          <source>This time the first assertion looks at the preceding six characters, checks that the first three are digits, and then the second assertion checks that the preceding three characters are not &quot;999&quot;.</source>
          <target state="translated">이번에는 첫 번째 어설 션이 앞의 6 개 문자를보고 첫 번째 세 개가 숫자인지 확인한 다음 두 번째 어설 션이 앞의 세 개 문자가 &quot;999&quot;가 아닌지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="14391b08125b325189f3dcbd403d72965af6b345" translate="yes" xml:space="preserve">
          <source>This time, since the shell was not involved, no other work was done in the system during the profiling. If you retry the same example with a freshly started Erlang emulator, but omit the command &lt;code&gt;l(random)&lt;/code&gt;, the analysis will show a lot more function calls done by &lt;code&gt;code_server&lt;/code&gt; and others to automatically load the module &lt;code&gt;random&lt;/code&gt;.</source>
          <target state="translated">이번에는 쉘이 포함되지 않았으므로 프로파일 링 중에 시스템에서 다른 작업이 수행되지 않았습니다. 당신이 갓 시작 얼랑 에뮬레이터와 같은 예를 시도하지만, 명령 생략하는 경우 &lt;code&gt;l(random)&lt;/code&gt; , 분석은 수행 더 많은 함수 호출 표시됩니다 &lt;code&gt;code_server&lt;/code&gt; 자동으로 모듈로드와 다른 &lt;code&gt;random&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22a9f149405034822a960ba22d2e8646cd23a4b4" translate="yes" xml:space="preserve">
          <source>This time, the recursing alternative is tried first, and continues to recurse until it runs out of characters, at which point the recursion fails. But this time we have another alternative to try at the higher level. That is the significant difference: in the previous case the remaining alternative is at a deeper recursion level, which PCRE cannot use.</source>
          <target state="translated">이번에는 재귀 대안이 먼저 시도되고 문자가 부족할 때까지 재귀가 계속되어 재귀가 실패합니다. 그러나 이번에는 더 높은 수준에서 시도 할 다른 대안이 있습니다. 이는 중요한 차이점입니다. 이전의 경우 나머지 대안은 더 깊은 재귀 수준에 있으며 PCRE는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c60619daf599e1009f83ff3339a4a66e29dc068d" translate="yes" xml:space="preserve">
          <source>This timer is started when the &lt;strong&gt;first&lt;/strong&gt; reply to an asynchronous request (issued using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; function) arrives. As long as this timer is running, replies will be delivered via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function, with their &quot;arrival number&quot; (see &lt;code&gt;UserReply&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; callback function).</source>
          <target state="translated">이 타이머는 비동기 요청에 대한 &lt;strong&gt;첫 번째&lt;/strong&gt; 응답 ( &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast/3&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 발행 된 )에 도달하면 시작됩니다. 이 타이머가 실행되는 한, 답글을 통해 전달 될 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; - 그들의 &quot;도착 번호&quot;로 콜백 함수 (참조 &lt;code&gt;UserReply&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply/4,5&lt;/a&gt;&lt;/code&gt; - 콜백 함수).</target>
        </trans-unit>
        <trans-unit id="7f582a8bac4499f4041fc098c02442c6d51efa18" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; (e.g. the last of the segment which makes up the reply) is received, but all segments has not yet been received.</source>
          <target state="translated">이 타이머는 &lt;code&gt;segmentation complete token&lt;/code&gt; 표시된 세그먼트 (예 : 응답을 구성하는 세그먼트의 마지막)가 수신되었지만 모든 세그먼트가 아직 수신되지 않은 경우 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f2ade158232a7f92c6ed91597d402fd153194a" translate="yes" xml:space="preserve">
          <source>This timer is started when the segment indicated by the &lt;code&gt;segmentation complete token&lt;/code&gt; is received, but all segments has not yet been received.</source>
          <target state="translated">이 타이머는 &lt;code&gt;segmentation complete token&lt;/code&gt; 표시된 세그먼트 가 수신되었지만 모든 세그먼트가 아직 수신되지 않은 경우 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="706cbfbf9ab1807332ea2d94bd3ad6011d82aa07" translate="yes" xml:space="preserve">
          <source>This transaction can write the text &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 1000 times to the terminal. However, &lt;code&gt;Mnesia&lt;/code&gt; guarantees that each transaction will eventually run. As a result, &lt;code&gt;Mnesia&lt;/code&gt; is not only deadlock free, but also livelock free.</source>
          <target state="translated">이 트랜잭션은 터미널에 &lt;code&gt;&quot;Trying to write ... &quot;&lt;/code&gt; 텍스트를 1000 번 쓸 수 있습니다 . 그러나 &lt;code&gt;Mnesia&lt;/code&gt; 는 각 트랜잭션이 결국 실행되도록 보장합니다. 결과적으로 &lt;code&gt;Mnesia&lt;/code&gt; 는 교착 상태가 아니라 라이브 록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c15707ecd3d8e52159c361dec50a35ae8f4adf88" translate="yes" xml:space="preserve">
          <source>This transaction returns the list &lt;code&gt;[{foo,1,3}]&lt;/code&gt; if table &lt;code&gt;foo&lt;/code&gt; is of type &lt;code&gt;set&lt;/code&gt;. However, the list &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; is returned if the table is of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">이 트랜잭션은 테이블 &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;set&lt;/code&gt; 유형 인 경우 &lt;code&gt;[{foo,1,3}]&lt;/code&gt; 목록을 리턴합니다 . 그러나 테이블이 &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 &lt;code&gt;[{foo,1,2}, {foo,1,3}]&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="896c645fd7197a5da200f81b1127c1a22b3d1e2d" translate="yes" xml:space="preserve">
          <source>This transformation renames a &lt;code&gt;select_val/3&lt;/code&gt; instruction with a constant source operand to &lt;code&gt;i_const_select_val/3&lt;/code&gt;.</source>
          <target state="translated">이 변환은 바꾸고 &lt;code&gt;select_val/3&lt;/code&gt; 상수 소스 피연산자와 명령 &lt;code&gt;i_const_select_val/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3aa65821e6e6bbdfa16d2cf5e6359a478a61f30" translate="yes" xml:space="preserve">
          <source>This transformation rule matches a call to the BIF &lt;code&gt;element/2&lt;/code&gt;. The operands will be captured and the function &lt;code&gt;gen_element()&lt;/code&gt; will be called.</source>
          <target state="translated">이 변환 규칙은 BIF &lt;code&gt;element/2&lt;/code&gt; 에 대한 호출과 일치합니다 . 피연산자가 캡처되고 &lt;code&gt;gen_element()&lt;/code&gt; 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0fb13c45e90d79c73f06a24d887642b21d76da" translate="yes" xml:space="preserve">
          <source>This translates to &lt;code&gt;TCP_NOPUSH&lt;/code&gt; on BSD and to &lt;code&gt;TCP_CORK&lt;/code&gt; on Linux.</source>
          <target state="translated">이것은로 변환 &lt;code&gt;TCP_NOPUSH&lt;/code&gt; BSD와에 &lt;code&gt;TCP_CORK&lt;/code&gt; 리눅스에.</target>
        </trans-unit>
        <trans-unit id="bf13712351a4aa96ae94ff06cddb20f5ef75fe11" translate="yes" xml:space="preserve">
          <source>This tries to match &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; or &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; twice. If &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; appears, the function returns &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;ABC&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; 를 두 번 일치 시키려고합니다 . 만약 &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; 나타나면 함수 리턴 &lt;code&gt;HaltReason = {nnn,[&quot;NNN&quot;]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53c27958e7fca3ba05175a738c3a146371fd4e49" translate="yes" xml:space="preserve">
          <source>This tuple only exists if &lt;code&gt;Function&lt;/code&gt; can be used with different clocks. &lt;code&gt;ClockId&lt;/code&gt; corresponds to the clock identifier used when calling &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">이 튜플은 &lt;code&gt;Function&lt;/code&gt; 을 다른 시계와 함께 사용할 수있는 경우에만 존재합니다 . &lt;code&gt;ClockId&lt;/code&gt; 는 &lt;code&gt;Function&lt;/code&gt; 호출시 사용되는 시계 식별자에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="aa7524355b5ee56dd866d3d3779a64205a992024" translate="yes" xml:space="preserve">
          <source>This type defines all addresses (and flags) associated with the interface.</source>
          <target state="translated">이 유형은 인터페이스와 관련된 모든 주소 (및 플래그)를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ceff633d5c12b0ab1b989cd600fd3b0c1f9b57c7" translate="yes" xml:space="preserve">
          <source>This type is assigned in Erlang as follows:</source>
          <target state="translated">이 유형은 Erlang에서 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="34e89a0a89b0d1a14764e553fc94c9f4fbe45d6d" translate="yes" xml:space="preserve">
          <source>This type is further described in application &lt;code&gt;xmerl&lt;/code&gt;.</source>
          <target state="translated">이 유형은 &lt;code&gt;xmerl&lt;/code&gt; 응용 프로그램에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be71fbb0606c9b749f47ff7cbc7a8e0ca516ae1" translate="yes" xml:space="preserve">
          <source>This type of time-out is useful for example to act on inactivity. Let us restart the code sequence if no button is pressed for say 30 seconds:</source>
          <target state="translated">이 유형의 시간 초과는 예를 들어 비활성 상태에서 작동하는 데 유용합니다. 30 초 동안 아무 버튼도 누르지 않으면 코드 시퀀스를 다시 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0dd216aebaebb2374c204746cffeb0b8a3bfa66e" translate="yes" xml:space="preserve">
          <source>This utility function is used to create a formatted (pretty printable) string of the error reason received from either:</source>
          <target state="translated">이 유틸리티 함수는 다음 중 하나에서 수신 한 오류 이유의 형식화 된 (꽤 인쇄 가능한) 문자열을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e90f513c2d724696028de83a41a04ca02c00b03d" translate="yes" xml:space="preserve">
          <source>This utility is specific to Windows NT/2000/XP (and later versions of Windows). It allows Erlang emulators to run as services on the Windows system, allowing embedded systems to start without any user needing to log on. The emulator started in this way can be manipulated through the Windows services applet in a manner similar to other services.</source>
          <target state="translated">이 유틸리티는 Windows NT / 2000 / XP (및 이후 버전의 Windows)에만 해당됩니다. Erlang 에뮬레이터를 Windows 시스템에서 서비스로 실행할 수 있으므로 사용자가 로그온 할 필요없이 임베디드 시스템을 시작할 수 있습니다. 이러한 방식으로 시작된 에뮬레이터는 다른 서비스와 유사한 방식으로 Windows 서비스 애플릿을 통해 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b55cb392aed5fc4d4c203d5436538e3f6a69fde3" translate="yes" xml:space="preserve">
          <source>This validation callback will be executed before any heartbeat is sent to the port program. For the validation to succeed it needs to return with the value &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">이 유효성 검증 콜백은 하트 비트가 포트 프로그램으로 전송되기 전에 실행됩니다. 유효성 검증이 성공하려면 &lt;code&gt;ok&lt;/code&gt; 값으로 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b8b5c1eef6ea78b8a30fd3fe8ec2afd6d40564e" translate="yes" xml:space="preserve">
          <source>This value can also be set through (OS) environment variable &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt;.</source>
          <target state="translated">이 값은 (OS) 환경 변수 &lt;code&gt;ERL_FULLSWEEP_AFTER&lt;/code&gt; 를 통해 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b09f82dfd17c02b5cc9bb38621d7a9dc8cc490" translate="yes" xml:space="preserve">
          <source>This value can be set at startup by passing command-line argument &lt;code&gt;+SDio&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">이 값은 &lt;code&gt;erl(1)&lt;/code&gt; 에서 명령 행 인수 &lt;code&gt;+SDio&lt;/code&gt; 를 전달하여 시작할 때 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2f1511a226b28ee2f7a6351d90cc98e92a8e944" translate="yes" xml:space="preserve">
          <source>This value might wrap due to limitations in the underlying functionality provided by the operating system that is used.</source>
          <target state="translated">이 값은 사용되는 운영 체제에서 제공하는 기본 기능의 제한으로 인해 줄 바꿈 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae87da20fd16a3057a07a29b3ed216aa69d1b30e" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a disk_log sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">이 값 (밀리 초)은 핸들러가 disk_log 동기화 조작을 수행하여 버퍼링 된 데이터를 디스크에 쓰는 빈도를 지정합니다. 처리기는 작업을 반복적으로 시도하지만 실제로 기록 된 경우에만 새 동기화를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="562ee5839a71bc34778a37d5ff1caee77199d71c" translate="yes" xml:space="preserve">
          <source>This value, in milliseconds, specifies how often the handler does a file sync operation to write buffered data to disk. The handler attempts the operation repeatedly, but only performs a new sync if something has actually been logged.</source>
          <target state="translated">이 값 (밀리 초)은 핸들러가 파일 동기화 조작을 수행하여 버퍼링 된 데이터를 디스크에 쓰는 빈도를 지정합니다. 처리기는 작업을 반복적으로 시도하지만 실제로 기록 된 경우에만 새 동기화를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8a7dae834a17e1bfd7dcc5067b03add360f4e974" translate="yes" xml:space="preserve">
          <source>This variable sets the maximum size of a crash dump file in bytes. The crash dump will be truncated if this limit is exceeded. If the variable is not set, no size limit is enforced by default. If the variable is set to &lt;code&gt;0&lt;/code&gt;, the runtime system does not even attempt to write a crash dump file.</source>
          <target state="translated">이 변수는 크래시 덤프 파일의 최대 크기를 바이트 단위로 설정합니다. 이 한계를 초과하면 크래시 덤프가 잘립니다. 변수를 설정하지 않으면 기본적으로 크기 제한이 적용되지 않습니다. 변수가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 런타임 시스템은 크래시 덤프 파일을 쓰려고 시도조차하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8c996bd75b6c1e556e40ae90ed97ed437560b07" translate="yes" xml:space="preserve">
          <source>This variant is kept for compatibility.</source>
          <target state="translated">이 변형은 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f23ebd696e347931712dab86d1982b0ebcb811ea" translate="yes" xml:space="preserve">
          <source>This verb causes the match to end successfully, skipping the remainder of the pattern. However, when it is inside a subpattern that is called as a subroutine, only that subpattern is ended successfully. Matching then continues at the outer level. If (*ACCEPT) is triggered in a positive assertion, the assertion succeeds; in a negative assertion, the assertion fails.</source>
          <target state="translated">이 동사는 패턴의 나머지 부분을 건너 뛰고 일치를 성공적으로 종료시킵니다. 그러나 서브 루틴이라고하는 서브 패턴 안에 있으면 해당 서브 패턴 만 성공적으로 종료됩니다. 그런 다음 일치는 외부 수준에서 계속됩니다. (* ACCEPT)가 긍정 주장에서 트리거되면 주장이 성공합니다. 부정 어설 션에서는 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7d1a0e9b710171a3224e64c914a5b25f817e9dd9" translate="yes" xml:space="preserve">
          <source>This version (still) include three &lt;code&gt;pre version 3&lt;/code&gt; variants of the version 3 codec, beside the proper version 3. These versions, &lt;code&gt;prev3a | prev3b | prev3c&lt;/code&gt;, are &lt;strong&gt;deprecated&lt;/strong&gt;, and will be removed in OTP 24.</source>
          <target state="translated">이 버전 (여전히)에는 적절한 버전 3 &lt;code&gt;prev3a | prev3b | prev3c&lt;/code&gt; 버전 3 코덱의 세 가지 &lt;code&gt;pre version 3&lt;/code&gt; 변형이 포함되어 있습니다. 이러한 버전, prev3a | prev3b | prev3c 는 &lt;strong&gt;더 이상 사용되지 않으며&lt;/strong&gt; OTP 24에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d08ddef725078632007c7d27f955f2e16c27447f" translate="yes" xml:space="preserve">
          <source>This version encode atoms that can be represented by a latin1 string using latin1 encoding while only atoms that cannot be represented by latin1 are encoded using utf8.</source>
          <target state="translated">이 버전은 latin1 인코딩을 사용하여 latin1 문자열로 표시 될 수있는 원자를 인코딩하는 반면 latin1로 표현할 수없는 원자 만 utf8을 사용하여 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d758c1fa288ff4bea6ef5e3e118de5ef6067101b" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;wrap_log_reader&lt;/code&gt; does not detect if &lt;code&gt;disk_log&lt;/code&gt; wraps to a new index file between a call to &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; and the first call to &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt;. If this occurs, the call to &lt;code&gt;chunk()&lt;/code&gt; reads the last logged items in the log file, as the opened index file was truncated by &lt;code&gt;disk_log&lt;/code&gt;.</source>
          <target state="translated">이 버전의 &lt;code&gt;wrap_log_reader&lt;/code&gt; 이 경우 감지하지 못하는 &lt;code&gt;disk_log&lt;/code&gt; 에 대한 호출 사이에 새로운 인덱스 파일에 랩 &lt;code&gt;wrap_log_reader:open()&lt;/code&gt; 과의 최초의 호출 &lt;code&gt;wrap_log_reader:chunk()&lt;/code&gt; . 이 경우 &lt;code&gt;chunk()&lt;/code&gt; 호출 은 열린 색인 파일이 &lt;code&gt;disk_log&lt;/code&gt; 에 의해 잘린 것처럼 로그 파일에서 마지막으로 기록 된 항목을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="7892b8b3e220dc2d6df9f4226b75eda81b8a6c0a" translate="yes" xml:space="preserve">
          <source>This version of the stack is compliant with:</source>
          <target state="translated">이 버전의 스택은 다음을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="240472a34becd16e12bb3376c31742854774737c" translate="yes" xml:space="preserve">
          <source>This version of the stack supports version 1, 2 and 3 as defined by:</source>
          <target state="translated">이 버전의 스택은 다음에 의해 정의 된 버전 1, 2 및 3을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="12b130ec0f7a537e5f469d318f402ce06f564884" translate="yes" xml:space="preserve">
          <source>This way the decoder will detect which version is used and then use the proper decoder.</source>
          <target state="translated">이런 식으로 디코더는 사용되는 버전을 감지 한 다음 적절한 디코더를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1fab39fc6a9980decfad2e7adaa7dbca6690bf5b" translate="yes" xml:space="preserve">
          <source>This weighted scheduler utilization will reach &lt;code&gt;1.0&lt;/code&gt; when schedulers are active the same amount of time as maximum available CPU time. If more schedulers exist than available logical processors, this value may be greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">이 가중 스케줄러 사용률은 스케줄러가 사용 가능한 최대 CPU 시간과 동일한 시간 동안 활성화 될 때 &lt;code&gt;1.0&lt;/code&gt; 에 도달 합니다. 사용 가능한 논리 프로세서보다 많은 스케줄러가 존재하는 경우이 값은 &lt;code&gt;1.0&lt;/code&gt; 보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26f1c0ecf9835b048ce7fdf3cb11bce5cf430e0d" translate="yes" xml:space="preserve">
          <source>This will be transform into one call to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;my_table&lt;/code&gt; 에 대한 하나의 호출로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5959df48b0bcfac9f4ae84eabd6aeaab1c573506" translate="yes" xml:space="preserve">
          <source>This will be transform into two calls to &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;my_table&lt;/code&gt; 에 대한 두 가지 호출로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0938e7a4bcaf966d8f8e1648d8bf77602bdb131" translate="yes" xml:space="preserve">
          <source>This will create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">현재 디렉토리에 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8c674397ac895af2f7b4229947a7481b00df7c1" translate="yes" xml:space="preserve">
          <source>This will extract the string literal &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; into the variable &lt;code&gt;Foo&lt;/code&gt;. Note the use of the anonymous variable &lt;code&gt;9090&lt;/code&gt; to ignore the line number. To match and also bind a metavariable that must be an integer literal, we can use the convention of ending the integer with a 9, turning it into a Q-prefixed variable on the Erlang level (see the previous section).</source>
          <target state="translated">문자열 리터럴 &lt;code&gt;&quot;foo.erl&quot;&lt;/code&gt; 을 변수 &lt;code&gt;Foo&lt;/code&gt; 로 추출합니다 . 행 번호를 무시하기 위해 익명 변수 &lt;code&gt;9090&lt;/code&gt; 을 사용 하십시오 . 정수 리터럴이어야하는 메타 변수를 일치시키고 바인드하기 위해 정수를 9로 끝내는 규칙을 사용하여 Erlang 레벨에서 Q 접두사 변수로 바꿉니다 (이전 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="6844398e7182f73065c78df4a613dbb5c67fbf34" translate="yes" xml:space="preserve">
          <source>This will fail if the &lt;code&gt;copy_save&lt;/code&gt; option is enabled; see &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;copy_save&lt;/code&gt; 옵션이 활성화 되면 실패합니다 . &lt;code&gt;lcnt:rt_opt/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="161516cb1d32cdac4670da18a1c368a544091541" translate="yes" xml:space="preserve">
          <source>This will have the following effect:</source>
          <target state="translated">다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="00ecf511290805869defd2329acd31f4e4c2838e" translate="yes" xml:space="preserve">
          <source>This will print the following in the default log:</source>
          <target state="translated">그러면 기본 로그에 다음이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="876e81f13e31f8d2ed30e08e0458e7cd79ff32e8" translate="yes" xml:space="preserve">
          <source>This will print the following:</source>
          <target state="translated">그러면 다음이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="741ddd866b7f0cb141911125a2b18ae0245fffe3" translate="yes" xml:space="preserve">
          <source>This will produce a beam.smp.debug executable. The file are installed along side with the normal (opt) version &lt;code&gt;beam.smp&lt;/code&gt;.</source>
          <target state="translated">이것은 beam.smp.debug 실행 파일을 생성합니다. 파일은 일반 (opt) 버전 &lt;code&gt;beam.smp&lt;/code&gt; 와 함께 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a278059021fec133659ebfed89d918e76c5e908" translate="yes" xml:space="preserve">
          <source>This will start a &lt;code&gt;Collector&lt;/code&gt;, a &lt;code&gt;Viewer&lt;/code&gt; and also start the tracing of &lt;code&gt;et:trace_me/5&lt;/code&gt; function calls. The &lt;code&gt;Raw Trace Data&lt;/code&gt; is collected by the &lt;code&gt;Collector&lt;/code&gt; and a view of it is displayed on the screen by the &lt;code&gt;Viewer&lt;/code&gt;. You can define your own &quot;views&quot; of the data by implementing your own &lt;code&gt;Filter&lt;/code&gt; functions and register them in the &lt;code&gt;Viewer&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;Collector&lt;/code&gt; , &lt;code&gt;Viewer&lt;/code&gt; 가 시작되고 &lt;code&gt;et:trace_me/5&lt;/code&gt; 함수 호출 추적이 시작 됩니다. &lt;code&gt;Raw Trace Data&lt;/code&gt; 에 의해 수집 &lt;code&gt;Collector&lt;/code&gt; 과 이용의 전망은에 의해 화면에 표시됩니다 &lt;code&gt;Viewer&lt;/code&gt; . 자체 &lt;code&gt;Filter&lt;/code&gt; 기능 을 구현하여 데이터에 대한 &quot;보기&quot;를 정의 하고 &lt;code&gt;Viewer&lt;/code&gt; 에 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f434217aa97015d51cfaae19becfd875effa6d0a" translate="yes" xml:space="preserve">
          <source>This works even if &lt;code&gt;A&lt;/code&gt; is less than &lt;code&gt;-1.0&lt;/code&gt;, since in that case, &lt;code&gt;math:sqrt/1&lt;/code&gt; is never evaluated.</source>
          <target state="translated">이 경우 &lt;code&gt;math:sqrt/1&lt;/code&gt; 은 평가되지 않으므로 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;-1.0&lt;/code&gt; 보다 작은 경우에도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3252af803922384f63b13c1da6ba4644d77b472e" translate="yes" xml:space="preserve">
          <source>This works for those codecs that support partial decode of the version, currently &lt;strong&gt;text&lt;/strong&gt;, and ber_bin (&lt;code&gt;megaco_binary_encoder&lt;/code&gt; and &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt;).</source>
          <target state="translated">이것은 현재 &lt;strong&gt;text&lt;/strong&gt; 및 ber_bin ( &lt;code&gt;megaco_binary_encoder&lt;/code&gt; 및 &lt;code&gt;megaco_ber_bin_encoder&lt;/code&gt; ) 버전의 부분 디코딩을 지원하는 코덱에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="68fb3cd1bc230ff55ec815a8606d4b126de4061a" translate="yes" xml:space="preserve">
          <source>This would give the same result as the earlier examples, namely:</source>
          <target state="translated">이는 이전 예제와 동일한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f41ff74a32e2f2c5a120967bdd256a9d1fcf2924" translate="yes" xml:space="preserve">
          <source>This yields the following environment for &lt;code&gt;myapp&lt;/code&gt;:</source>
          <target state="translated">이렇게하면 &lt;code&gt;myapp&lt;/code&gt; 에 대한 다음 환경이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d50cfaeffc3214625910320412c7d6aae3538c57" translate="yes" xml:space="preserve">
          <source>Those option forms are kept only for compatibility and should not be used in new code.</source>
          <target state="translated">이러한 옵션 양식은 호환성을 위해서만 유지되며 새 코드에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2af7a09a50fb9a8406c64e603ab93839d0eeadbb" translate="yes" xml:space="preserve">
          <source>Those service could - and should - be disabled when they are not needed. The options &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are enabled per default but could be set to &lt;code&gt;disabled&lt;/code&gt; if not needed. The same options could also install handlers for the string(s) passed from the client to the server.</source>
          <target state="translated">이러한 서비스는 필요하지 않을 때 비활성화 될 수 있으며 비활성화되어야합니다. &lt;code&gt;&lt;a href=&quot;ssh#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ssh#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 옵션 은 기본적으로 활성화되어 있지만 필요하지 않은 경우 &lt;code&gt;disabled&lt;/code&gt; 로 설정할 수 있습니다 . 동일한 옵션으로 클라이언트에서 서버로 전달되는 문자열에 대한 핸들러를 설치할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cfb63a03667f91e2dddce0870e2cddb4d2428fc" translate="yes" xml:space="preserve">
          <source>Those that are not part of an identified script are lumped together as &quot;Common&quot;. The following is the current list of scripts:</source>
          <target state="translated">식별 된 스크립트의 일부가 아닌 스크립트는 &quot;공통&quot;으로 묶습니다. 다음은 현재 스크립트 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e0fb7ae92ade7541465dddf7bdde5e485e470cba" translate="yes" xml:space="preserve">
          <source>Those warnings cannot be disabled (except by disabling all warnings).</source>
          <target state="translated">이러한 경고는 비활성화 할 수 없습니다 (모든 경고를 비활성화 한 경우 제외).</target>
        </trans-unit>
        <trans-unit id="c351ee3b38329481117c9035b830002ad412235a" translate="yes" xml:space="preserve">
          <source>Thread identifier.</source>
          <target state="translated">스레드 식별자.</target>
        </trans-unit>
        <trans-unit id="4f9adbdf3e9b777ac0a0a507f193e4d00d4e660e" translate="yes" xml:space="preserve">
          <source>Thread options structure passed to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt; erl_drv_thread_create&lt;/a&gt;&lt;/code&gt;. The following field exists:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt; erl_drv_thread_create&lt;/a&gt;&lt;/code&gt; 에 전달 된 스레드 옵션 구조 . 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="472d223957fc2ad616dbfe0655959f460d590ae4" translate="yes" xml:space="preserve">
          <source>Thread options structure passed to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt;. The following field exists:</source>
          <target state="translated">스레드 옵션 구조가 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_create&quot;&gt;erl_drv_thread_create&lt;/a&gt;&lt;/code&gt; 로 전달되었습니다 . 다음 필드가 존재합니다 :</target>
        </trans-unit>
        <trans-unit id="2d38b72cd000a892fe63ed8ba79ccaabfe4c2e80" translate="yes" xml:space="preserve">
          <source>Three more escape sequences that match characters with specific properties are available. When in 8-bit non-UTF-8 mode, these sequences are limited to testing characters whose code points are &amp;lt; 256, but they do work in this mode. The following are the extra escape sequences:</source>
          <target state="translated">특정 특성을 가진 문자와 일치하는 세 개의 이스케이프 시퀀스를 사용할 수 있습니다. 8 비트 비 UTF-8 모드 인 경우이 시퀀스는 코드 포인트가 &amp;lt;256 인 문자 테스트로 제한되지만이 모드에서는 작동합니다. 추가 이스케이프 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48145c695e12f789bd065e16fe1bba615544dbc8" translate="yes" xml:space="preserve">
          <source>Three network messages to execute the two-phase commit protocol</source>
          <target state="translated">2 단계 커밋 프로토콜을 실행하기위한 3 개의 네트워크 메시지</target>
        </trans-unit>
        <trans-unit id="5b4d080b2f7b28c85cb580a4943bbfa952b77805" translate="yes" xml:space="preserve">
          <source>Three predefined resolve functions exist: &lt;code&gt;random_exit_name/3&lt;/code&gt;, &lt;code&gt;random_notify_name/3&lt;/code&gt;, and &lt;code&gt;notify_all_name/3&lt;/code&gt;. If no &lt;code&gt;Resolve&lt;/code&gt; function is defined, &lt;code&gt;random_exit_name&lt;/code&gt; is used. This means that one of the two registered processes is selected as correct while the other is killed.</source>
          <target state="translated">&lt;code&gt;random_exit_name/3&lt;/code&gt; , &lt;code&gt;random_notify_name/3&lt;/code&gt; 및 &lt;code&gt;notify_all_name/3&lt;/code&gt; 의 세 가지 사전 정의 된 해결 기능이 있습니다 . &lt;code&gt;Resolve&lt;/code&gt; 기능이 정의되어 있지 않으면 &lt;code&gt;random_exit_name&lt;/code&gt; 이 사용됩니다. 이는 등록 된 두 프로세스 중 하나가 올바른 것으로 선택되고 다른 프로세스는 종료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="789fe986bc68eef06a581bacefa09c9f316ad600" translate="yes" xml:space="preserve">
          <source>Three types of Dets tables exist:</source>
          <target state="translated">세 가지 유형의 Dets 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de17dda2df1b0a4a41a2a36ed513ae1a8fa82e62" translate="yes" xml:space="preserve">
          <source>Three types of logs are supported: transfer logs, security logs, and error logs. The de-facto standard Common Logfile Format is used for the transfer and security logging. There are numerous statistics programs available to analyze Common Logfile Format. The Common Logfile Format looks as follows:</source>
          <target state="translated">전송 로그, 보안 로그 및 오류 로그의 세 가지 유형의 로그가 지원됩니다. 사실상의 표준 공통 로그 파일 형식은 전송 및 보안 로깅에 사용됩니다. 공통 로그 파일 형식을 분석 할 수있는 수많은 통계 프로그램이 있습니다. 공통 로그 파일 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e9b97eab33817fa09e3b807cdad0cad941b514c" translate="yes" xml:space="preserve">
          <source>Three-per-em space</source>
          <target state="translated">3 인당 공간</target>
        </trans-unit>
        <trans-unit id="353307ebea91bdeb49e95a772ca9672b8b9ff1c9" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal filesize in bytes. The transfer is aborted if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">최대 파일 크기에 대한 임계 값은 바이트 단위입니다. 한도를 초과하면 전송이 중단됩니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81e689740a1ea2ba496a99261372d7eb5ff76c39" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of active connections. The daemon rejects the setup of new connections if the limit is exceeded. Default is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">최대 활성 연결 수에 대한 임계 값입니다. 한계가 초과되면 데몬은 새 연결 설정을 거부합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c5d2d9adf32dacfb55f57f6ed9d271632c69577" translate="yes" xml:space="preserve">
          <source>Threshold for the maximal number of retries. By default the server/client tries to resend a message up to five times when the time-out expires.</source>
          <target state="translated">최대 재시도 횟수에 대한 임계 값입니다. 기본적으로 서버 / 클라이언트는 시간 초과가 만료되면 최대 5 번까지 메시지를 다시 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="0ef311c86e366780b4c01dfd6e2377efaa407576" translate="yes" xml:space="preserve">
          <source>Through CTHs the results of tests and configuration functions can be manipulated. The main purpose to do this with CTHs is to allow common patterns to be abstracted out from test suites and applied to multiple test suites without duplicating any code. All the callback functions for a CTH follow a common interface described hereafter.</source>
          <target state="translated">CTH를 통해 테스트 결과 및 구성 기능을 조작 할 수 있습니다. CTH를 사용하여이 작업을 수행하는 주요 목적은 코드를 복제하지 않고도 공통 테스트 패턴을 테스트 스위트에서 추출하여 여러 테스트 스위트에 적용 할 수 있도록하는 것입니다. CTH에 대한 모든 콜백 함수는 이후에 설명 된 공통 인터페이스를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0aa7d917559b259354cb862e1c7d69350b345c76" translate="yes" xml:space="preserve">
          <source>Through a trigger function with a match specification created with &lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#seq_trigger_ms-0&quot;&gt;ttb:seq_trigger_ms/0,1&lt;/a&gt;&lt;/code&gt; 로 작성된 일치 스펙을 가진 트리거 함수를 통해 .</target>
        </trans-unit>
        <trans-unit id="dee8ee6675b19f7cc839a400403e3a6bdfc64698" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;Mnesia&lt;/code&gt; (on one node) can hang if a double fault occurs, that is, when two nodes crash simultaneously and one attempts to start when the other refuses to start, for example, because of a hardware error.</source>
          <target state="translated">따라서 이중 오류가 발생하는 경우, 즉 두 노드가 동시에 충돌하고 다른 노드가 시작을 거부 할 때 (예 : 하드웨어 오류로 인해) 하나의 노드 에서 &lt;code&gt;Mnesia&lt;/code&gt; 가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08620ab1394e488e40f6d760c0e43eb52ae9ae1e" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ch3&lt;/code&gt; must be loaded before &lt;code&gt;m1&lt;/code&gt;, in the upgrade case, and conversely in the downgrade case. &lt;code&gt;m1&lt;/code&gt; is said to be &lt;strong&gt;dependent on&lt;/strong&gt;&lt;code&gt;ch3&lt;/code&gt;. In a release handling instruction, this is expressed by the &lt;code&gt;DepMods&lt;/code&gt; element:</source>
          <target state="translated">따라서 &lt;code&gt;ch3&lt;/code&gt; 은 &lt;code&gt;m1&lt;/code&gt; 전에 , 업그레이드의 경우, 반대로 다운 그레이드의 경우 로드되어야합니다 . &lt;code&gt;m1&lt;/code&gt; 은 &lt;code&gt;ch3&lt;/code&gt; 에&lt;strong&gt;의존&lt;/strong&gt; 한다고합니다 . 릴리스 처리 명령에서 이는 &lt;code&gt;DepMods&lt;/code&gt; 요소로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4aac5229f9aff631f4112d990ef52e941da8602" translate="yes" xml:space="preserve">
          <source>Thus, Erlang pids contain information about where the process executes. So if you know the pid of a process, the &quot;!&quot; operator can be used to send it a message disregarding if the process is on the same node or on a different node.</source>
          <target state="translated">따라서 Erlang pid에는 프로세스 실행 위치에 대한 정보가 포함됩니다. 프로세스의 pid를 알고 있다면 &quot;!&quot; 연산자는 프로세스가 동일한 노드 또는 다른 노드에 있는지 여부를 무시하고 메시지를 보내는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cc9ac17e54e53ed54d89ecd362584a70502cce6" translate="yes" xml:space="preserve">
          <source>Thus, each table is made up of records, where the first element is a record name and the second element of the table is a key, which identifies the particular record in that table. The combination of the table name and a key is an arity two tuple &lt;code&gt;{Tab, Key}&lt;/code&gt; called the OID. For more information about the relationship beween the record name and the table name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">따라서 각 테이블은 레코드로 구성되며, 여기서 첫 번째 요소는 레코드 이름이고 두 번째 요소는 키이며 해당 테이블의 특정 레코드를 식별합니다. 테이블 이름과 키의 조합은 OID라고 하는 arity two tuple &lt;code&gt;{Tab, Key}&lt;/code&gt; 입니다. 레코드 이름과 테이블 이름 간의 관계에 대한 자세한 정보는 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names&lt;/a&gt;&lt;/code&gt; 테이블 이름을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98419cf3e6cb70f3d1ec7c30e6c6cd8e96f4569b" translate="yes" xml:space="preserve">
          <source>Thus, groups of users with identical cookie files get Erlang nodes that can communicate freely and without interference from the magic cookie system. Users who want to run nodes on separate file systems must make certain that their cookie files are identical on the different file systems.</source>
          <target state="translated">따라서 동일한 쿠키 파일을 가진 사용자 그룹은 매직 쿠키 시스템의 간섭없이 자유롭게 통신 할 수있는 Erlang 노드를 얻습니다. 별도의 파일 시스템에서 노드를 실행하려는 사용자는 쿠키 파일이 다른 파일 시스템에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8100fa7ba98e8e96e75fe52a1370cae3f3496b11" translate="yes" xml:space="preserve">
          <source>Thus, in Erlang the atoms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are used to encode a boolean value.</source>
          <target state="translated">따라서 Erlang에서 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 원자 는 부울 값을 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7ecce73f034bf35ecbb506fb930930ac4b3eff" translate="yes" xml:space="preserve">
          <source>Thus, it can be assumed that if an application wants to use tables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, the application must perform some action similar to following before it can use the tables:</source>
          <target state="translated">따라서 애플리케이션이 테이블 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 를 사용하려는 경우 애플리케이션이 테이블을 사용 하기 전에 다음과 유사한 조치를 수행해야 한다고 가정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e5bc2487ff82b85d2e3b10893d75ddc6f14f8fa" translate="yes" xml:space="preserve">
          <source>Thus, knowing the allowed structure it is easy to write a program that traverses the data structure and picks the information in the xmlElements records with name date.</source>
          <target state="translated">따라서 허용 된 구조를 알면 데이터 구조를 탐색하고 이름 날짜로 xmlElements 레코드의 정보를 선택하는 프로그램을 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2e92eacbda98564b7e1dba01abee128e6082f80" translate="yes" xml:space="preserve">
          <source>Thus, the call &lt;code&gt;ch3:alloc()&lt;/code&gt; returns the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the &lt;code&gt;gen_server&lt;/code&gt; then waits for new requests, now with an updated list of available channels.</source>
          <target state="translated">따라서 &lt;code&gt;ch3:alloc()&lt;/code&gt; 호출 은 할당 된 채널 &lt;code&gt;Ch&lt;/code&gt; 를 반환 하고 &lt;code&gt;gen_server&lt;/code&gt; 는 새로운 요청을 기다립니다. 이제는 사용 가능한 채널 목록이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9ebad642bddf4ab3db22dd4beeeeb7f4311403f9" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-COMMUNITY-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-COMMUNITY-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a7c61a5b14ab98813376fed50c0cd8d251b07679" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-FRAMEWORK-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-FRAMEWORK-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="612f9db5bba916759b754b605a4e539b1a5e5a7e" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-NOTIFICATION-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-NOTIFICATION-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9d1588ecea3ad2284ae9aa05caccc396d78985d5" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-STANDARD-MIB and SNMPv2-MIB, after this function has been called, is from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-STANDARD-MIB 및 SNMPv2-MIB의 데이터는 구성 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="43f6071a8cb0a08a947926938c79fe87f3b23556" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-TARGET-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-TARGET-MIB의 데이터는 구성 파일의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="698103ec7a5a24bef7840c9a9eb88301e5ac5c6b" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-USER-BASED-SM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-USER-BASED-SM-MIB의 데이터는 구성 파일의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="b154aa3e0b0b0cb0972c7b7c21e5fa2a7b63dbbc" translate="yes" xml:space="preserve">
          <source>Thus, the data in the SNMP-VIEW-BASED-ACM-MIB, after this function has been called, is the data from the configuration files.</source>
          <target state="translated">따라서이 기능이 호출 된 후 SNMP-VIEW-BASED-ACM-MIB의 데이터는 구성 파일의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="ece286b7b7e10c58b8006a0db1d818bda1598793" translate="yes" xml:space="preserve">
          <source>Thus, the defined callbacks are as follows:</source>
          <target state="translated">따라서 정의 된 콜백은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7283b7df46e07452f871697fbbb43dfaeb34c85" translate="yes" xml:space="preserve">
          <source>Thus, the following pattern matches all possible clauses:</source>
          <target state="translated">따라서 다음 패턴은 가능한 모든 절과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a6da41a12dddbe97c927f5b83e0ea21b128613a3" translate="yes" xml:space="preserve">
          <source>Thus, the main representation of test sets is &lt;strong&gt;deep lists&lt;/strong&gt;, and a simple test object can be viewed as a test set containing only a single test; there is no difference between &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">따라서 테스트 세트의 주요 표현은 &lt;strong&gt;딥리스트&lt;/strong&gt; 이며 간단한 테스트 개체는 단일 테스트 만 포함하는 테스트 세트로 볼 수 있습니다. &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;[T]&lt;/code&gt; 사이에는 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="72fc65dc129a4472605c016017814aa86198846c" translate="yes" xml:space="preserve">
          <source>Thus, the module is called &lt;strong&gt;tut&lt;/strong&gt;. Notice the full stop &quot;.&quot; at the end of the line. The files which are used to store the module must have the same name as the module but with the extension &quot;.erl&quot;. In this case the file name is &lt;code&gt;tut.erl&lt;/code&gt;. When using a function in another module, the syntax &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; is used. So the following means call function &lt;code&gt;double&lt;/code&gt; in module &lt;code&gt;tut&lt;/code&gt; with argument &quot;10&quot;.</source>
          <target state="translated">따라서이 모듈을 &lt;strong&gt;tut&lt;/strong&gt; 라고 합니다. 멈춤 표시 &quot;.&quot; 줄의 끝에서. 모듈을 저장하는 데 사용되는 파일은 모듈 이름과 동일하지만 확장자는 &quot;.erl&quot;이어야합니다. 이 경우 파일 이름은 &lt;code&gt;tut.erl&lt;/code&gt; 입니다. 다른 모듈에서 함수를 사용할 때는 구문 &lt;code&gt;module_name:function_name(arguments)&lt;/code&gt; 이 사용됩니다. 따라서 다음은 인수 &quot;10&quot;으로 모듈 &lt;code&gt;tut&lt;/code&gt; 에서 함수 &lt;code&gt;double&lt;/code&gt; 을 호출하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c34ce3a6ce18ac5cd93d950cae3e6a6b1eaefbd7" translate="yes" xml:space="preserve">
          <source>Thus, two instances of the application run simultaneously during the takeover, so that data can be transferred from the old to the new instance. If this is not an acceptable behavior, parts of the old instance can be shut down when the new instance is started. However, the application cannot be stopped entirely, at least the top supervisor must remain alive.</source>
          <target state="translated">따라서 인계 중에 두 개의 애플리케이션 인스턴스가 동시에 실행되므로 이전 인스턴스에서 새 인스턴스로 데이터를 전송할 수 있습니다. 이것이 허용 가능한 동작이 아닌 경우 새 인스턴스가 시작될 때 이전 인스턴스의 일부가 종료 될 수 있습니다. 그러나 응용 프로그램을 완전히 중지 할 수는 없으며 최소한 최고 감독자가 살아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b6a4f79c67e1c0cfc398c2295408f2eb4b88ca9" translate="yes" xml:space="preserve">
          <source>Tibetan</source>
          <target state="translated">Tibetan</target>
        </trans-unit>
        <trans-unit id="4be1e581820721963019e692dc1f7707fda4ff7f" translate="yes" xml:space="preserve">
          <source>Ticket shall be used within specified time window (freshness checks).</source>
          <target state="translated">티켓은 지정된 시간대 (신선도 확인) 내에서 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="495255dc624907e5a1daae0dcc0d862cd07a65e4" translate="yes" xml:space="preserve">
          <source>Tidies Erlang source files in a directory and its subdirectories.</source>
          <target state="translated">디렉토리와 서브 디렉토리에 Erlang 소스 파일을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="5ab18872f1a912f1810a74934cd2ae2c9eab483f" translate="yes" xml:space="preserve">
          <source>Tidies a syntax tree representation of a module definition. The given &lt;code&gt;Forms&lt;/code&gt; may be either a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. In either case, &lt;code&gt;Forms&lt;/code&gt; must represent a single complete module definition. The returned syntax tree has type &lt;code&gt;form_list&lt;/code&gt; and represents a tidied-up version of the same source code.</source>
          <target state="translated">모듈 정의의 구문 트리 표현을 정리합니다. 주어진 &lt;code&gt;Forms&lt;/code&gt; 는 &lt;code&gt;form_list&lt;/code&gt; 유형의 단일 구문 트리 이거나 &quot;프로그램 형식&quot;을 나타내는 구문 트리 목록 일 수 있습니다 . 두 경우 모두 &lt;code&gt;Forms&lt;/code&gt; 은 하나의 완전한 모듈 정의를 나타내야합니다. 반환 된 구문 트리는 &lt;code&gt;form_list&lt;/code&gt; 유형 이며 동일한 소스 코드의 정리 된 버전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f1ca9281bec4536e142232511847b2d622b54efd" translate="yes" xml:space="preserve">
          <source>Tidies an Erlang source code file.</source>
          <target state="translated">Erlang 소스 코드 파일을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="82f374f21b06bcdcda1afc18f61cb6cebcc8d024" translate="yes" xml:space="preserve">
          <source>Tidies and pretty-prints Erlang source code, removing unused functions, updating obsolete constructs and function calls, etc.</source>
          <target state="translated">Erlang 소스 코드 정리 및 예쁘게 인쇄, 사용하지 않는 함수 제거, 사용되지 않는 구문 및 함수 호출 업데이트 등</target>
        </trans-unit>
        <trans-unit id="cf46deb14abc3ae4a0180bd680085f5421becb62" translate="yes" xml:space="preserve">
          <source>Tifinagh</source>
          <target state="translated">Tifinagh</target>
        </trans-unit>
        <trans-unit id="06efc4d93bae79312067fccb5a91a687ea053f84" translate="yes" xml:space="preserve">
          <source>Time Accuracy</source>
          <target state="translated">시간 정확도</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
