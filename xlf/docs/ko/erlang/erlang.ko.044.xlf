<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="400e9b2c243f2f7c7d92b4dcf08486534cb1952f" translate="yes" xml:space="preserve">
          <source>Time Precision</source>
          <target state="translated">시간 정밀도</target>
        </trans-unit>
        <trans-unit id="cad164c081a78f266eeeb300b8131692f7bc1b2f" translate="yes" xml:space="preserve">
          <source>Time Resolution</source>
          <target state="translated">시간 해상도</target>
        </trans-unit>
        <trans-unit id="1b437206adf14eaf51046c0192d059cd605c7e97" translate="yes" xml:space="preserve">
          <source>Time Warp</source>
          <target state="translated">타임 워프</target>
        </trans-unit>
        <trans-unit id="a82ad5fd600ff000d4dd1a4b75dec09bd53099b8" translate="yes" xml:space="preserve">
          <source>Time in milli-seconds.</source>
          <target state="translated">밀리 초 단위의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="fb90c3d94bbbbb48a0690451d16d4a2746e6cf58" translate="yes" xml:space="preserve">
          <source>Time in milliseconds.</source>
          <target state="translated">밀리 초 단위의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="52f73c9f88768be27ae1df301f0781defb2c8b55" translate="yes" xml:space="preserve">
          <source>Time interval (in seconds) between each update of the display.</source>
          <target state="translated">각 디스플레이 업데이트 사이의 시간 간격 (초).</target>
        </trans-unit>
        <trans-unit id="aa2bb96c7dd2c54fd6b747929cbd2b7c505afa22" translate="yes" xml:space="preserve">
          <source>Time is in milliseconds.</source>
          <target state="translated">시간은 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="9335c98c7b128731a14ad90889a8a634ba7a0e3f" translate="yes" xml:space="preserve">
          <source>Time is local when it is adjusted in accordance with the current time zone and daylight saving. Time is universal when it reflects the time at longitude zero, without any adjustment for daylight saving. Universal Coordinated Time (UTC) time is also called Greenwich Mean Time (GMT).</source>
          <target state="translated">현재 시간대 및 일광 절약 시간제에 따라 조정하면 시간이 현지화됩니다. 일광 절약 시간을 조정하지 않고 경도 0의 시간을 반영 할 때 시간은 보편적입니다. UTC (협정 세계시) 시간을 그리니치 표준시 (GMT)라고도합니다.</target>
        </trans-unit>
        <trans-unit id="778cab80afb8fbb53cb2e3770f0d9802c84b4243" translate="yes" xml:space="preserve">
          <source>Time is shown as percentage of total time and as absolute time.</source>
          <target state="translated">시간은 총 시간의 백분율과 절대 시간으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfab7fde2f2bd1c95dae042160e5b78de938455d" translate="yes" xml:space="preserve">
          <source>Time is vital to an Erlang program and, more importantly, &lt;strong&gt;correct&lt;/strong&gt; time is vital to an Erlang program. As Erlang is a language with soft real-time properties and we can express time in our programs, the Virtual Machine and the language must be careful about what is considered a correct time and in how time functions behave.</source>
          <target state="translated">시간이 더 중요한 얼랑 프로그램에 중요합니다, &lt;strong&gt;정확한&lt;/strong&gt; 시간은 얼랑 프로그램에 중요합니다. Erlang은 소프트 실시간 속성이있는 언어이므로 프로그램에서 시간을 표현할 수 있으므로 가상 머신과 언어는 올바른 시간으로 간주되는 시간과 시간 기능이 작동하는 방식에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfb8ee1d3368aa29179a6d65ecd926cdeee8b67e" translate="yes" xml:space="preserve">
          <source>Time of failure.</source>
          <target state="translated">실패 시간.</target>
        </trans-unit>
        <trans-unit id="e5b5ff320546cded57bcdfd8e9154e88bfce347b" translate="yes" xml:space="preserve">
          <source>Time since &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt;. Epoch is defined to be 00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt;, 1970-01-01. &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; is defined to be exactly 86400 seconds long. Strangely enough, Epoch is defined to be a time in UTC, and UTC has another definition of how long a day is. Quoting the Open Group &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt;. The effect of this is that when an UTC leap second is inserted, POSIX time either stops for a second, or repeats the last second. If an UTC leap second would be deleted (which has not happened yet), POSIX time would make a one second leap forward.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17&quot;&gt; Epoch&lt;/a&gt;&lt;/code&gt; 이후의 시간 . Epoch는 00:00:00 &lt;code&gt;&lt;a href=&quot;#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; , 1970-01-01 로 정의됩니다 . &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14&quot;&gt; A day in POSIX time&lt;/a&gt;&lt;/code&gt; 정확히 86400 초로 정의됩니다. 이상하게도 Epoch는 UTC로 시간이 정의되고 UTC는 하루의 길이에 대한 다른 정의를 갖습니다. 오픈 그룹 인용 &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15&quot;&gt; &quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;&lt;/a&gt;&lt;/code&gt; . 그 결과 UTC 윤초가 삽입되면 POSIX 시간이 1 초 동안 멈추거나 마지막 초가 반복됩니다. UTC 도약 초가 삭제되면 (아직 발생하지 않은 경우) POSIX 시간이 1 초 도약합니다.</target>
        </trans-unit>
        <trans-unit id="c633e68c77dad8ff55d69828cca1fdead9120622" translate="yes" xml:space="preserve">
          <source>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt; statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the &lt;code&gt;scheduler_wall_time&lt;/code&gt; fraction. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">바쁘게 기다리는 시간. 이것은 또한 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt; statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 사용할 때 스케줄러가 더 이상 활성 상태라고보고하지 않는 상태 입니다. 따라서 this와 sleep을 제외한 다른 모든 상태를 추가 한 다음 스레드의 모든 시간으로 나누면 &lt;code&gt;scheduler_wall_time&lt;/code&gt; 분수 와 매우 유사한 것을 얻을 수 있습니다. 이번에는 추가 상태가 없으면 &lt;code&gt;other&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="daff1c5051fc31c193cbc0ef30cf4e11a8fa0acc" translate="yes" xml:space="preserve">
          <source>Time spent busy waiting. This is also the state where a scheduler no longer reports that it is active when using &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt;. So, if you add all other states but this and sleep, and then divide that by all time in the thread, you should get something very similar to the &lt;code&gt;scheduler_wall_time&lt;/code&gt; fraction. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">기다리는 데 시간이 많이 걸렸습니다. 또한 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time&quot;&gt;statistics(scheduler_wall_time)&lt;/a&gt;&lt;/code&gt; 사용할 때 스케줄러가 더 이상 활성 상태임을보고하지 않는 상태 입니다. 따라서이 상태를 제외한 다른 모든 상태를 추가하고 스레드에서 모든 시간으로 나누면 &lt;code&gt;scheduler_wall_time&lt;/code&gt; 분수 와 매우 비슷한 것을 얻을 수 있습니다. 추가 상태가 없으면 이번은 &lt;code&gt;other&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="4b70b59840bac36480b4ca278b19551bc7ff7ba0" translate="yes" xml:space="preserve">
          <source>Time spent checking for new I/O events.</source>
          <target state="translated">새로운 I / O 이벤트를 확인하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f8c4236fa95ff532dbcc0e2d31ef284b6605be9f" translate="yes" xml:space="preserve">
          <source>Time spent doing fullsweep garbage collection. Without extra states this time is part of the &lt;code&gt;gc&lt;/code&gt; state.</source>
          <target state="translated">풀 스윕 가비지 수집에 소요 된 시간입니다. 추가 상태가 없으면 이번은 &lt;code&gt;gc&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="804fe3e4c31d22ca440eb466bced64dac260645c" translate="yes" xml:space="preserve">
          <source>Time spent doing garbage collection. When extra states are enabled this is the time spent doing non-fullsweep garbage collections.</source>
          <target state="translated">가비지 수집에 소요 된 시간입니다. 추가 상태가 활성화되면 비 스위스 가비지 수집에 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f0d5415566936904747ef14c0c4e3fb853196c06" translate="yes" xml:space="preserve">
          <source>Time spent doing unaccounted things.</source>
          <target state="translated">설명되지 않은 일을하는 데 걸린 시간.</target>
        </trans-unit>
        <trans-unit id="4ba30f1fc2208657042880d6015e182708b6ae95" translate="yes" xml:space="preserve">
          <source>Time spent executing ETS BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">ETS BIF를 실행하는 데 소요 된 시간입니다. 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="6f0aba2d54a382bffda8610e637bf0f9265a1fa2" translate="yes" xml:space="preserve">
          <source>Time spent executing Erlang processes.</source>
          <target state="translated">Erlang 프로세스를 실행하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2140217ef427aad1b621513a3b193759d78a1510" translate="yes" xml:space="preserve">
          <source>Time spent executing ports.</source>
          <target state="translated">포트를 실행하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="1d9aa0e3f8d5f8534bd40659e4d0e67ab0101833" translate="yes" xml:space="preserve">
          <source>Time spent handling auxiliary jobs.</source>
          <target state="translated">보조 작업을 처리하는 데 소요 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="18b77c82a332110e23d9be0001f08986fee15519" translate="yes" xml:space="preserve">
          <source>Time spent in BIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">BIF에 소요 된 시간. 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="bcdc57b7f7275d059418c6711b15d167f486f63c" translate="yes" xml:space="preserve">
          <source>Time spent in NIFs. Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">NIF에서 보낸 시간. 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="4050018617b293ffdfb42ee633136a70a84f563a" translate="yes" xml:space="preserve">
          <source>Time spent managing memory. Without extra states this time is spread out over all other states.</source>
          <target state="translated">메모리 관리에 소요 된 시간입니다. 추가 상태가 없으면이 시간이 다른 모든 상태에 퍼집니다.</target>
        </trans-unit>
        <trans-unit id="9c01fc3b7f3c2c3c0d6942008a58943e7689d103" translate="yes" xml:space="preserve">
          <source>Time spent managing timers. Without extra states this time is part of the &lt;code&gt;other&lt;/code&gt; state.</source>
          <target state="translated">타이머 관리에 소요 된 시간입니다. 추가 상태가 없으면 이번은 &lt;code&gt;other&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="219f1ac61c024af183643b65bf00f27585517b49" translate="yes" xml:space="preserve">
          <source>Time spent sending messages (processes only). Without extra states this time is part of the &lt;code&gt;emulator&lt;/code&gt; state.</source>
          <target state="translated">메시지를 보내는 데 소요 된 시간 (프로세스 만) 추가 상태가 없으면이 시간은 &lt;code&gt;emulator&lt;/code&gt; 상태의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="cbdb8b8de682894a050f647f9b6f67984322b3e7" translate="yes" xml:space="preserve">
          <source>Time spent sleeping.</source>
          <target state="translated">잠자는 시간.</target>
        </trans-unit>
        <trans-unit id="5e12873ae797e4ba07d58c20986f4c5eb0d01fbc" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages consist of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt;.</source>
          <target state="translated">프로필 메시지의 타임 스탬프는 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 과 단조 증가 정수로 구성됩니다. 타임 스탬프 (Ts)는 &lt;code&gt;{erlang:monotonic_time(nanosecond), erlang:unique_integer([monotonic])}&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0a74926d30453b95a42997402e366f9dbba46f4a" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages include a time stamp (Ts) that has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;. This is also the default if no time stamp flag is specified. If &lt;code&gt;cpu_timestamp&lt;/code&gt; has been enabled through &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, this also effects the time stamp produced in profiling messages when flag &lt;code&gt;timestamp&lt;/code&gt; is enabled.</source>
          <target state="translated">프로필 메시지의 타임 스탬프에는 &lt;code&gt;erlang:now()&lt;/code&gt; 반환 한 것과 동일한 형식의 타임 스탬프 (Ts)가 포함됩니다 . 타임 스탬프 플래그가 지정되지 않은 경우에도 기본값입니다. 경우 &lt;code&gt;cpu_timestamp&lt;/code&gt; 을 통해 활성화 된 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; , 이것은 또한 플래그 때 메시지를 프로파일 링에서 생성 된 타임 스탬프에 영향을 미친다 &lt;code&gt;timestamp&lt;/code&gt; 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="22076e8ed9090afa79ae14afc1154da3fcea7d53" translate="yes" xml:space="preserve">
          <source>Time stamps in profile messages use &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt;. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt;.</source>
          <target state="translated">프로필 메시지의 타임 스탬프는 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;erlang:monotonic_time(nanosecond)&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="08ca334e927c4c6c13a180ed022f0e1809c6b0ea" translate="yes" xml:space="preserve">
          <source>Time unit expressed in parts per second. That is, the time unit equals &lt;code&gt;1/PartsPerSecond&lt;/code&gt; second.</source>
          <target state="translated">초당 단위로 표시되는 시간 단위. 즉, 시간 단위는 &lt;code&gt;1/PartsPerSecond&lt;/code&gt; 초입니다.</target>
        </trans-unit>
        <trans-unit id="56955f846ca14fda201279a48f5480070c862756" translate="yes" xml:space="preserve">
          <source>Time unit of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">의 시간 단위 &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf7ef9b043acd2fefcc767917bfb64bbe68691e" translate="yes" xml:space="preserve">
          <source>Time unit of returned value.</source>
          <target state="translated">반환 값의 시간 단위.</target>
        </trans-unit>
        <trans-unit id="c31fd1a438289cad94f807ff509ea2830cb0a280" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 에 대한 호출로 설정 타이머를 작성하는 데 사용되는 시간 입니다. 타이머는 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cba69c610e8e4d4cb1aafc070b3b00791654be26" translate="yes" xml:space="preserve">
          <source>Time used for creating a setup timer by a call to &lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt;. The timer should be passed along to &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:start_timer(SetupTime)&lt;/code&gt; 에 대한 호출로 설정 타이머를 작성하는 데 사용되는 시간 입니다. 타이머는 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ead486368f8803155ffc6453947e99e4019e5bc" translate="yes" xml:space="preserve">
          <source>Time warp safe code can handle a &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">타임 워프 안전 코드는 &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#Time_Warp&quot;&gt;time warp&lt;/a&gt;&lt;/code&gt; 를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="75c9ade9b7ea54157fc5ea15b058fcb35255e656" translate="yes" xml:space="preserve">
          <source>Time when the event record was created.</source>
          <target state="translated">이벤트 레코드가 작성된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="1078e1766373df8f70c0326e90a0881d10d2001d" translate="yes" xml:space="preserve">
          <source>Time when the trace was generated. Same as event_ts if omitted in trace data.</source>
          <target state="translated">추적이 생성 된 시간입니다. 추적 데이터에서 생략 된 경우 event_ts와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ea920146725e69689044ec910022adb3cb308cc6" translate="yes" xml:space="preserve">
          <source>Time-Constrained Tracing</source>
          <target state="translated">시간이 제한된 추적</target>
        </trans-unit>
        <trans-unit id="9b588b2f86ac72f24f2b525ef5518aac39862ff1" translate="yes" xml:space="preserve">
          <source>Time-Out Functions</source>
          <target state="translated">타임 아웃 기능</target>
        </trans-unit>
        <trans-unit id="7c54440dd4618f7bc17db7c59ce90a91687e0a3f" translate="yes" xml:space="preserve">
          <source>Time-constrained tracing</source>
          <target state="translated">시간이 제한된 추적</target>
        </trans-unit>
        <trans-unit id="dad879fd6c0ee22983f6de70e89c35317fb40e21" translate="yes" xml:space="preserve">
          <source>Time-out expired.</source>
          <target state="translated">시간이 만료되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e8c25c48b5132875c91d0c03a35c580928a7337" translate="yes" xml:space="preserve">
          <source>Time-out time for the request.</source>
          <target state="translated">요청 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="dbff00965ebcca637b30964828cca5002698389b" translate="yes" xml:space="preserve">
          <source>Time-out timers &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; are handled. Time-outs with zero time are guaranteed to be delivered to the state machine before any external not yet received event so if there is such a time-out requested, the corresponding time-out zero event is enqueued as the newest received event; that is after already queued events such as inserted and postponed events.</source>
          <target state="translated">타임 아웃 타이머 &lt;code&gt;&lt;a href=&quot;#type-event_timeout&quot;&gt;event_timeout()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt;generic_timeout()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#type-state_timeout&quot;&gt;state_timeout()&lt;/a&gt;&lt;/code&gt; 이 처리됩니다. 시간이 0 인 시간 초과는 아직 외부 수신되지 않은 이벤트가 발생하기 전에 상태 시스템에 전달되도록 보장되므로 해당 시간이 요청되면 해당 시간 초과 0 이벤트가 최신 수신 이벤트로 대기열에 추가됩니다. 즉, 삽입 및 연기 된 이벤트와 같은 이미 대기중인 이벤트 이후입니다.</target>
        </trans-unit>
        <trans-unit id="921bd14fe959f56d9bf6ef39fbc93c256e6bb1db" translate="yes" xml:space="preserve">
          <source>Time-out, in milliseconds, for establishing an association</source>
          <target state="translated">연결 설정을위한 시간 초과 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="321d15a7cc404b6bf384999b2f747b4923bb6c12" translate="yes" xml:space="preserve">
          <source>Time-outs in &lt;code&gt;gen_statem&lt;/code&gt; are started from a &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; during a state transition that is when exiting from the &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 시간 제한 은 &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 에서 종료 할 때 상태 전환 중 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 에서 시작됩니다 . &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9d894573097754c7b54a6191c10c2264d5de941" translate="yes" xml:space="preserve">
          <source>Timeout ::</source>
          <target state="translated">타임 아웃 ::</target>
        </trans-unit>
        <trans-unit id="9ba0fea57692bed3e35ebe6f8f6d8f58f2ad3a37" translate="yes" xml:space="preserve">
          <source>Timeout :: timeout()) -&amp;gt;</source>
          <target state="translated">타임 아웃 :: timeout ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fd55cd4f150e662912da414d712d8565cc5d6ef" translate="yes" xml:space="preserve">
          <source>Timeout = &lt;code&gt;non_neg_integer()&lt;/code&gt;</source>
          <target state="translated">시간 초과 = &lt;code&gt;non_neg_integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c83fda5023992a3a755c63b7feecf8cc4bb563b5" translate="yes" xml:space="preserve">
          <source>Timeout has expired.</source>
          <target state="translated">타임 아웃이 만료되었습니다.</target>
        </trans-unit>
        <trans-unit id="4de3dd3689e574562fe201d283c89d77aad9ff30" translate="yes" xml:space="preserve">
          <source>Timeout set the maximum time in milliseconds that each server request may take.</source>
          <target state="translated">시간 초과는 각 서버 요청에 걸리는 최대 시간 (밀리 초)을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0c72d1236b15e71c6081373a09d082eddd39e1e9" translate="yes" xml:space="preserve">
          <source>Timeout time for the call proxy.</source>
          <target state="translated">통화 프록시의 시간 초과 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b5240d69e014aa8db2761b61b654dac666884a70" translate="yes" xml:space="preserve">
          <source>Timeout) -&amp;gt;</source>
          <target state="translated">타임 아웃)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="cbe7ffd10c56674d0aeb143b8aef6a19536cbe9f" translate="yes" xml:space="preserve">
          <source>Timer functions.</source>
          <target state="translated">타이머 기능.</target>
        </trans-unit>
        <trans-unit id="5775c0fa857a175458a6f31fe323d1c61544a03a" translate="yes" xml:space="preserve">
          <source>Timers and re-send of messages will be handled on locally on one node, that is node(1), in order to avoid unnecessary transfer of data between the Erlang nodes.</source>
          <target state="translated">Erlang 노드간에 불필요한 데이터 전송을 피하기 위해 타이머 및 메시지 재전송은 하나의 노드, 즉 node (1)에서 로컬로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="345e4b38e568b767b30f56f4731767a882691f68" translate="yes" xml:space="preserve">
          <source>Timestamp = {MegaSecs, Secs, MicroSecs}</source>
          <target state="translated">타임 스탬프 = {MegaSecs, Secs, MicroSecs}</target>
        </trans-unit>
        <trans-unit id="15a044fe233b5f5d8f3f995d7e5a1a639fcad92c" translate="yes" xml:space="preserve">
          <source>Timestamps are formatted according to RFC3339, and the time designator is the character used as date and time separator.</source>
          <target state="translated">타임 스탬프는 RFC3339에 따라 형식이 지정되며 시간 지정자는 날짜 및 시간 구분 기호로 사용되는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="ec489097f09779c8f0337c7ffff14c271f605260" translate="yes" xml:space="preserve">
          <source>Timetrap values can be extended with a multiplier value specified at startup with option &lt;code&gt;multiply_timetraps&lt;/code&gt;. It is also possible to let the test server decide to scale up timetrap time-out values automatically. That is, if tools such as &lt;code&gt;cover&lt;/code&gt; or &lt;code&gt;trace&lt;/code&gt; are running during the test. This feature is disabled by default and can be enabled with start option &lt;code&gt;scale_timetraps&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;multiply_timetraps&lt;/code&gt; 를 사용 하여 시작시 지정된 승수 값으로 타임 트랩 값을 확장 할 수 있습니다 . 테스트 서버가 타임 랩 타임 아웃 값을 자동으로 확장하도록 결정할 수도 있습니다. 즉 , 테스트 중에 &lt;code&gt;cover&lt;/code&gt; 나 &lt;code&gt;trace&lt;/code&gt; 와 같은 도구 가 실행되고있는 경우입니다. 이 기능은 기본적으로 비활성화되어 있으며 시작 옵션 &lt;code&gt;scale_timetraps&lt;/code&gt; 로 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce4a7717f17e9b8af076c5d38d2f59e28a523086" translate="yes" xml:space="preserve">
          <source>Tirhuta</source>
          <target state="translated">Tirhuta</target>
        </trans-unit>
        <trans-unit id="b51456deb293c14e281cc125141b1ca93bd63d71" translate="yes" xml:space="preserve">
          <source>Title case letter</source>
          <target state="translated">타이틀 케이스 레터</target>
        </trans-unit>
        <trans-unit id="175f9c3cbfadc16808edf4696a9a651beef5a26c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - client side</source>
          <target state="translated">TLS / DTLS 옵션 설명-클라이언트 측</target>
        </trans-unit>
        <trans-unit id="ebe960548ac60cdb2adcef7ca8456b9e2d23126c" translate="yes" xml:space="preserve">
          <source>Tls/dtls option descriptions - server side</source>
          <target state="translated">TLS / DTLS 옵션 설명-서버 측</target>
        </trans-unit>
        <trans-unit id="bf91222de5df25eb68a0c8123513399e374daae1" translate="yes" xml:space="preserve">
          <source>To &quot;teach&quot; the function how to extract, you can give a fun which replaces the default extraction function. The &lt;code&gt;fqdn_fun&lt;/code&gt; takes one argument and returns either a &lt;code&gt;string()&lt;/code&gt; to be matched to each CN-name or the atom &lt;code&gt;default&lt;/code&gt; which will invoke the default fqdn extraction function. The return value &lt;code&gt;undefined&lt;/code&gt; removes the current URI from the fqdn extraction.</source>
          <target state="translated">함수를 추출하는 방법을 &quot;교육&quot;하기 위해 기본 추출 기능을 대체하는 재미를 줄 수 있습니다. &lt;code&gt;fqdn_fun&lt;/code&gt; 는 하나 개의 인수 및 반환 값 중 하나 얻어 &lt;code&gt;string()&lt;/code&gt; 각각 CN-이름 또는 원자에 매칭되는 &lt;code&gt;default&lt;/code&gt; 기본 FQDN 추출 함수를 호출한다. &lt;code&gt;undefined&lt;/code&gt; 반환 값 은 fqdn 추출에서 현재 URI를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2c5be475329fded4946b65a55d659b706b6fb900" translate="yes" xml:space="preserve">
          <source>To :: &lt;code&gt;&lt;a href=&quot;#type-storage_type&quot;&gt;storage_type()&lt;/a&gt;&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">받는 사람 :: &lt;code&gt;&lt;a href=&quot;#type-storage_type&quot;&gt;storage_type()&lt;/a&gt;&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c6ddde9755b765c3b046311bcbccd6ae209f1079" translate="yes" xml:space="preserve">
          <source>To access such tables, simplified access functions (as described earlier) cannot be used. For example, writing a subscriber record into a table requires the function &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; instead of the simplified functions &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이러한 테이블에 액세스하려면 앞에서 설명한 간단한 액세스 기능을 사용할 수 없습니다. 예를 들어, 구독자 레코드를 테이블에 &lt;code&gt;&lt;a href=&quot;mnesia#write-3&quot;&gt;mnesia:write/3&lt;/a&gt;&lt;/code&gt; 려면 단순화 된 &lt;code&gt;&lt;a href=&quot;mnesia#write-1&quot;&gt;mnesia:write/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#s_write-1&quot;&gt;mnesia:s_write/1&lt;/a&gt;&lt;/code&gt; 대신 mnesia : write / 3 함수가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="fff8dcb832da82946e10018f4faeadf19cfc862a" translate="yes" xml:space="preserve">
          <source>To acess the record in your callback-module use:</source>
          <target state="translated">콜백 모듈에서 레코드에 액세스하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e9f9ccb32571596628f903ebec0197042453a6d" translate="yes" xml:space="preserve">
          <source>To achieve authentication and privacy, the client and server perform a TLS/DTLS handshake procedure before transmitting or receiving any data. During the handshake, they agree on a protocol version and cryptographic algorithms, generate shared secrets using public key cryptographies, and optionally authenticate each other with digital certificates.</source>
          <target state="translated">인증 및 개인 정보 보호를 위해 클라이언트와 서버는 데이터를 전송하거나 수신하기 전에 TLS / DTLS 핸드 셰이크 절차를 수행합니다. 핸드 셰이크 중에 프로토콜 버전 및 암호화 알고리즘에 동의하고 공개 키 암호화를 사용하여 공유 비밀을 생성하며 선택적으로 디지털 인증서로 서로 인증합니다.</target>
        </trans-unit>
        <trans-unit id="0ec1db4ecbaf3ec0b305eae994234d479d4f46e8" translate="yes" xml:space="preserve">
          <source>To act as a timetrap. The time-out is triggered when the function returns.</source>
          <target state="translated">타임 트랩으로 작동합니다. 시간 초과는 함수가 반환 될 때 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="589688126179f4b6262587b2faac1c9d33d97234" translate="yes" xml:space="preserve">
          <source>To activate the code coverage support, specify the name of the cover specification file as you start &lt;code&gt;Common Test&lt;/code&gt;. Do this by using flag &lt;code&gt;-cover&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, for example:</source>
          <target state="translated">코드 적용 범위 지원을 활성화하려면 &lt;code&gt;Common Test&lt;/code&gt; 시작시 표지 스펙 파일의 이름을 지정하십시오 . 플래그를 사용하여이 작업을 수행 &lt;code&gt;-cover&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 예를 들어, :</target>
        </trans-unit>
        <trans-unit id="9cae8d843ee99890bf287306d3e1fa2ea6334285" translate="yes" xml:space="preserve">
          <source>To actor, such as receiver of message.</source>
          <target state="translated">메시지 수신자와 같은 행위자에게.</target>
        </trans-unit>
        <trans-unit id="c17cd393cb68cd745fb32bcdd513d6e91ea1d3f7" translate="yes" xml:space="preserve">
          <source>To add a new instance of the disk_log handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">disk_log 핸들러의 새 인스턴스를 추가하려면 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 핸들러 구성 인수는 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt; 설명 된 일반 구성 매개 변수 및 핸들러 특정 매개 변수를 포함 할 수있는 맵입니다 . 특정 데이터는 &lt;code&gt;config&lt;/code&gt; 키를 사용하여 하위 맵에 저장되며 다음 매개 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c67d81ad5962900cef3025ec2c90eb9d886e13" translate="yes" xml:space="preserve">
          <source>To add a new instance of the disk_log handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">disk_log 핸들러의 새 인스턴스를 추가하려면 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 핸들러 구성 인수는 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 설명 된 일반 구성 매개 변수 및 핸들러 특정 매개 변수를 포함 할 수있는 맵입니다 . 특정 데이터는 &lt;code&gt;config&lt;/code&gt; 키를 사용하여 서브맵에 저장되며 다음 매개 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a62dcd7f8a5f7512f140f3f638e7ecdf1954fe0c" translate="yes" xml:space="preserve">
          <source>To add a new instance of the standard handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">표준 핸들러의 새 인스턴스를 추가하려면 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3 &lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 핸들러 구성 인수는 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt; 설명 된 일반 구성 매개 변수 및 핸들러 특정 매개 변수를 포함 할 수있는 맵입니다 . 특정 데이터는 &lt;code&gt;config&lt;/code&gt; 키를 사용하여 하위 맵에 저장되며 다음 매개 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc71d9dc8116b79c66537800da31d34775d71f00" translate="yes" xml:space="preserve">
          <source>To add a new instance of the standard handler, use &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt;. The handler configuration argument is a map which can contain general configuration parameters, as documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;, and handler specific parameters. The specific data is stored in a sub map with the key &lt;code&gt;config&lt;/code&gt;, and can contain the following parameters:</source>
          <target state="translated">표준 핸들러의 새 인스턴스를 추가하려면 &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 핸들러 구성 인수는 &lt;code&gt;&lt;a href=&quot;logger_chapter#handler_configuration&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 설명 된 일반 구성 매개 변수 및 핸들러 특정 매개 변수를 포함 할 수있는 맵입니다 . 특정 데이터는 &lt;code&gt;config&lt;/code&gt; 키를 사용하여 서브맵에 저장되며 다음 매개 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25bba7220a4f7baf1911b739eb15c54b0c0b82c" translate="yes" xml:space="preserve">
          <source>To add hipe options, write like this from the Erlang shell:</source>
          <target state="translated">hipe 옵션을 추가하려면 Erlang 쉘에서 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="fce45144e65c70b074644a796eba73061cd36112" translate="yes" xml:space="preserve">
          <source>To add one file at the time into an opened tar file, use function &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;. When you are finished adding files, use function &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt; close/1&lt;/a&gt;&lt;/code&gt; to close the tar file.</source>
          <target state="translated">열린 tar 파일에 한 번에 하나의 파일을 추가하려면 함수 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 파일 추가가 끝나면 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt; close/1&lt;/a&gt;&lt;/code&gt; 기능을 사용 하여 tar 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="3baa48763297e23c94a7b912bd0879afc5570f44" translate="yes" xml:space="preserve">
          <source>To add one file at the time into an opened tar file, use function &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt;. When you are finished adding files, use function &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; to close the tar file.</source>
          <target state="translated">한 번에 하나의 파일을 열린 tar 파일에 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add/3,4&lt;/a&gt;&lt;/code&gt; 하려면 add / 3,4 함수를 사용 하십시오 . 파일 추가를 마치면 &lt;code&gt;&lt;a href=&quot;#close-1&quot;&gt;close/1&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 tar 파일을 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="a84e38b55e72c3e97104e0980726fd48cb3019f6" translate="yes" xml:space="preserve">
          <source>To add or remove functions to the set of traced functions, use &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;.</source>
          <target state="translated">추적 된 함수 세트에 함수를 추가하거나 제거하려면 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fda79af0ac4d5d28c0ded42a7d7b009f4b62fd23" translate="yes" xml:space="preserve">
          <source>To add or remove one or more processes to the set of traced processes, use &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추적 된 프로세스 세트에 하나 이상의 프로세스를 추가하거나 제거하려면 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="97e9dc37875751d49fa3a200c5e6307140fdca4a" translate="yes" xml:space="preserve">
          <source>To allow Emacs to auto-indent the code, each file starts with the following line:</source>
          <target state="translated">Emacs가 코드를 자동 들여 쓰기 할 수 있도록 각 파일은 다음 줄로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="dd9ff12ed931dadbc8c2436f103539b09520bf39" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; to &lt;strong&gt;request unloading&lt;/strong&gt; to wait for &lt;strong&gt;actual unloading&lt;/strong&gt;, &lt;code&gt;monitor&lt;/code&gt; triggers can be specified in much the same way as when loading. However, as &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this function seldom are interested in more than decrementing the reference counts, monitoring is seldom needed.</source>
          <target state="translated">허용하기 위해 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 에게 &lt;strong&gt;요청 언 로딩을&lt;/strong&gt; 기다릴 &lt;strong&gt;실제 하역&lt;/strong&gt; , &lt;code&gt;monitor&lt;/code&gt; 트리거는로드 할 때와 거의 같은 방법으로 지정할 수 있습니다. 그러나이 기능 을 사용하는 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 는 참조 횟수를 줄이는 데 관심이 거의 없으므로 모니터링이 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59bb251ccc89a2f6d964901c5abf9140c03fcff3" translate="yes" xml:space="preserve">
          <source>To avoid copying data when a large binary is sent or returned from the driver to an Erlang process, the driver must first allocate the binary and then send it to an Erlang process in some way.</source>
          <target state="translated">큰 바이너리가 드라이버에서 Erlang 프로세스로 전송되거나 리턴 될 때 데이터를 복사하지 않으려면 드라이버는 먼저 바이너리를 할당 한 다음 어떤 방식 으로든 Erlang 프로세스로 전송해야합니다.</target>
        </trans-unit>
        <trans-unit id="2865a7885b23338eb552d918abbacdfb214f7e88" translate="yes" xml:space="preserve">
          <source>To avoid copying the result in each iteration, build the list in reverse order and reverse the list when you are done:</source>
          <target state="translated">각 반복에서 결과를 복사하지 않으려면 목록을 역순으로 작성하고 완료되면 목록을 역순으로 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e09f8fda1e6fc4cf2056ba424646d85461e4106" translate="yes" xml:space="preserve">
          <source>To avoid duplication of upgrade instructions, it is allowed to use regular expressions to specify &lt;code&gt;UpFromVsn&lt;/code&gt; and &lt;code&gt;DownToVsn&lt;/code&gt;. To be considered a regular expression, the version identifier must be specified as a binary. For example, the following match all versions &lt;code&gt;2.1.x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is any number:</source>
          <target state="translated">업그레이드 지시 사항의 중복을 피하기 위해 정규식을 사용하여 &lt;code&gt;UpFromVsn&lt;/code&gt; 및 &lt;code&gt;DownToVsn&lt;/code&gt; 을 지정할 수 있습니다. 정규식으로 간주 되려면 버전 식별자를 이진으로 지정해야합니다. 예를 들어, 다음은 모든 버전 &lt;code&gt;2.1.x&lt;/code&gt; 와 일치합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 임의의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="f3e4e6304ab6854db5a3171fca0bb16d781ed384" translate="yes" xml:space="preserve">
          <source>To avoid hanging on open ports, use function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">열린 포트에 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 대신 try_load / 3 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31d3d102c2bccbc776e3cf95a6211839f76eac95" translate="yes" xml:space="preserve">
          <source>To avoid hard-coding data values related to the test and/or System Under Test (SUT) in the test suites, the data can instead be specified through configuration files or strings that &lt;code&gt;Common Test&lt;/code&gt; reads before the start of a test run. External configuration data makes it possible to change test properties without modifying the test suites using the data. Examples of configuration data follows:</source>
          <target state="translated">테스트 스위트의 테스트 및 / 또는 테스트 대상 시스템 (SUT)과 관련된 하드 코딩 데이터 값을 피하기 위해 테스트 실행을 시작하기 전에 &lt;code&gt;Common Test&lt;/code&gt; 가 읽는 구성 파일 또는 문자열을 통해 데이터를 지정할 수 있습니다. 외부 구성 데이터를 사용하면 데이터를 사용하여 테스트 스위트를 수정하지 않고도 테스트 특성을 변경할 수 있습니다. 구성 데이터의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dfbb5760a4f99858bb3dbeadd3c934b25eba7307" translate="yes" xml:space="preserve">
          <source>To avoid messing up the indentation, all comments are written as C++ style comments (&lt;code&gt;//&lt;/code&gt;) instead of &lt;code&gt;#&lt;/code&gt;. Note that a comment must start at the beginning of a line.</source>
          <target state="translated">들여 쓰기가 엉망이되지 않도록 모든 주석은 &lt;code&gt;#&lt;/code&gt; 대신 C ++ 스타일 주석 ( &lt;code&gt;//&lt;/code&gt; ) 으로 작성됩니다 . 주석은 줄의 시작 부분에서 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a0e028a0de585306a96650beddc8214b6be458a" translate="yes" xml:space="preserve">
          <source>To avoid the three copies of the code, we could use only one specific instruction:</source>
          <target state="translated">세 개의 코드 사본을 피하기 위해 하나의 특정 명령어 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff4064fdc26dd0f01d01190c1a8e9d791a3c3dfd" translate="yes" xml:space="preserve">
          <source>To avoid this, we can consider starting and stopping the server for every test. We can thus implement the start and stop action as common functions to be called from &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt;. (Remember to test the start and stop functionality separately.) The configuration can also be implemented as a common function, maybe grouped with the start function. Finally, the testing of connecting and disconnecting a client can be grouped into one test case. The resulting suite can look as follows:</source>
          <target state="translated">이를 피하기 위해 모든 테스트마다 서버 시작 및 중지를 고려할 수 있습니다. 따라서 시작 및 중지 조치를 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 에서 호출되는 공통 함수로 구현할 수 있습니다 . (시작 및 중지 기능은 별도로 테스트해야합니다.) 구성은 시작 기능과 함께 그룹화되어 공통 기능으로 구현 될 수도 있습니다. 마지막으로 클라이언트 연결 및 연결 해제 테스트를 하나의 테스트 사례로 그룹화 할 수 있습니다. 결과 제품군은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9201ec7b8336f2387fa27a7eefb8cd01282e065" translate="yes" xml:space="preserve">
          <source>To avoid this, we can consider starting and stopping the server for every test. We can thus implement the start and stop action as common functions to be called from &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt;. (Remember to test the start and stop functionality separately.) The configuration can also be implemented as a common function, maybe grouped with the start function. Finally, the testing of connecting and disconnecting a client can be grouped into one test case. The resulting suite can look as follows:</source>
          <target state="translated">이를 방지하기 위해 모든 테스트에서 서버를 시작하고 중지하는 것을 고려할 수 있습니다. 따라서 시작 및 중지 작업을 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase&lt;/a&gt;&lt;/code&gt; 에서 호출되는 공통 함수로 구현할 수 있습니다 . (시작 및 중지 기능을 별도로 테스트하는 것을 잊지 마십시오.) 구성은 또한 시작 기능과 그룹화 될 수있는 공통 기능으로 구현 될 수 있습니다. 마지막으로 클라이언트 연결 및 연결 해제 테스트를 하나의 테스트 케이스로 그룹화 할 수 있습니다. 결과 제품군은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da22d86c6d5a5e12ab72051b2e07972d39e8f4d0" translate="yes" xml:space="preserve">
          <source>To avoid this, you can format the internal state that gets in the error log and gets returned from &lt;code&gt;sys:get_status/1,2&lt;/code&gt; by implementing function &lt;code&gt;Module:format_status/2&lt;/code&gt;, for example like this:</source>
          <target state="translated">이를 방지하기 위해 &lt;code&gt;Module:format_status/2&lt;/code&gt; 함수를 구현 하여 오류 로그에 도착하고 &lt;code&gt;sys:get_status/1,2&lt;/code&gt; 에서 리턴되는 내부 상태를 형식화 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5df12af7ca1de496492c0fd73285a97d145fbb83" translate="yes" xml:space="preserve">
          <source>To be able to access a record in a fragmented table, &lt;code&gt;Mnesia&lt;/code&gt; must determine to which fragment the actual record belongs. This is done by module &lt;code&gt;mnesia_frag&lt;/code&gt;, which implements the &lt;code&gt;mnesia_access&lt;/code&gt; callback behavior. It is recommended to read the documentation about the function &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; to see how &lt;code&gt;mnesia_frag&lt;/code&gt; can be used as a &lt;code&gt;mnesia_access&lt;/code&gt; callback module.</source>
          <target state="translated">조각화 된 테이블의 레코드에 액세스하려면 &lt;code&gt;Mnesia&lt;/code&gt; 는 실제 레코드가 속하는 조각을 결정해야합니다. 이것은 모듈에 의해 수행 &lt;code&gt;mnesia_frag&lt;/code&gt; , 구현 &lt;code&gt;mnesia_access&lt;/code&gt; 의 콜백 동작. 함수에 대한 설명서를 읽을 것을 권장 &lt;code&gt;&lt;a href=&quot;mnesia#activity-4&quot;&gt;mnesia:activity/4&lt;/a&gt;&lt;/code&gt; 방식을 볼 수 &lt;code&gt;mnesia_frag&lt;/code&gt; 는 A와 사용할 수 있습니다 &lt;code&gt;mnesia_access&lt;/code&gt; 의 콜백 모듈을.</target>
        </trans-unit>
        <trans-unit id="23318e76150bd1f0abc3ba7a0d5c11d745ade1e5" translate="yes" xml:space="preserve">
          <source>To be able to access another source than &lt;code&gt;running&lt;/code&gt;, the server must advertise &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;running&lt;/code&gt; 이외의 다른 소스에 액세스하려면 서버가 &lt;code&gt;:candidate&lt;/code&gt; 및 / 또는 &lt;code&gt;:startup&lt;/code&gt; 을 보급해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b51f87825f77244a25cc2b4cb931c55829d08561" translate="yes" xml:space="preserve">
          <source>To be able to build the 64bit VM, you will also need the 64bit MinGW compiler from:</source>
          <target state="translated">64 비트 VM을 빌드하려면 다음의 64 비트 MinGW 컴파일러도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="26291c0ee8be34dfdaf3cc8ddf503e49e01d4215" translate="yes" xml:space="preserve">
          <source>To be able to handle that the peer has done a shutdown on the write side, option &lt;code&gt;{exit_on_close, false}&lt;/code&gt; is useful.</source>
          <target state="translated">피어가 쓰기 측에서 시스템 종료를 처리했음을 처리하려면 옵션 &lt;code&gt;{exit_on_close, false}&lt;/code&gt; 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e5203ca51ac51dc3846f4da1bcecefb73078a29b" translate="yes" xml:space="preserve">
          <source>To be able to match on events, the event handler module must include the header file &lt;code&gt;ct_event.hrl&lt;/code&gt;. An event is a record with the following definition:</source>
          <target state="translated">이벤트에서 일치 시키려면 이벤트 핸들러 모듈에 헤더 파일 &lt;code&gt;ct_event.hrl&lt;/code&gt; 이 포함되어야합니다 . 이벤트는 다음 정의를 가진 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="485420cfd5dcbb3ebc3984f14efff913d6cf6cf5" translate="yes" xml:space="preserve">
          <source>To be able to react to a change in Erlang system time, you must be able to detect that it happened. The change in Erlang system time occurs when the current time offset is changed. We have therefore introduced the possibility to monitor the time offset using &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt; erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt;. A process monitoring the time offset is sent a message on the following format when the time offset is changed:</source>
          <target state="translated">Erlang 시스템 시간의 변경에 대응하려면 해당 변경이 발생했음을 감지 할 수 있어야합니다. Erlang 시스템 시간의 변경은 현재 시간 오프셋이 변경 될 때 발생합니다. 따라서 &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt; erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt; 사용하여 시간 오프셋을 모니터링 할 수있는 가능성을 도입했습니다 . 시간 오프셋을 모니터링하는 프로세스는 시간 오프셋이 변경 될 때 다음 형식으로 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e3749ffc8118407236ba6c1778f7ad9201b5e31f" translate="yes" xml:space="preserve">
          <source>To be able to react to a change in Erlang system time, you must be able to detect that it happened. The change in Erlang system time occurs when the current time offset is changed. We have therefore introduced the possibility to monitor the time offset using &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt;. A process monitoring the time offset is sent a message on the following format when the time offset is changed:</source>
          <target state="translated">Erlang 시스템 시간의 변화에 ​​반응하려면, 발생한 시간을 감지 할 수 있어야합니다. Erlang 시스템 시간의 변경은 현재 시간 오프셋이 변경 될 때 발생합니다. 따라서 &lt;code&gt;&lt;a href=&quot;erlang#monitor-2&quot;&gt;erlang:monitor(time_offset, clock_service)&lt;/a&gt;&lt;/code&gt; 사용하여 시간 오프셋을 모니터링 할 수있는 가능성을 소개했습니다 . 시간 오프셋을 모니터링하는 프로세스는 시간 오프셋이 변경 될 때 다음 형식으로 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="247dec3e8d99aa407189a0694139d1d0d984205d" translate="yes" xml:space="preserve">
          <source>To be able to specify the different variants of version 3, the encoding config option &lt;code&gt;{version3, version3()}&lt;/code&gt;&lt;strong&gt;still&lt;/strong&gt; exists. This option, if present, has to be &lt;strong&gt;first&lt;/strong&gt; in the encoding config list. Version 1 and 2 codec's ignore this option, if found.</source>
          <target state="translated">버전 3의 다양한 변형을 지정할 수 있도록 인코딩 구성 옵션 &lt;code&gt;{version3, version3()}&lt;/code&gt; &lt;strong&gt;여전히&lt;/strong&gt; 존재합니다. 이 옵션이 있는 경우 인코딩 구성 목록에서 &lt;strong&gt;첫 번째&lt;/strong&gt; 여야 합니다. 버전 1 및 2 코덱은 발견 된 경우이 옵션을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="4db2f48a1319253c8231fa7c3d7cafe6f17c3bfc" translate="yes" xml:space="preserve">
          <source>To be backward compatible, &lt;code&gt;erlang:now/0&lt;/code&gt; remains &quot;as is&quot;, but &lt;strong&gt;you are strongly discouraged from using it&lt;/strong&gt;. Many use cases of &lt;code&gt;erlang:now/0&lt;/code&gt; prevents you from using the new &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, which is an important part of this new time functionality improvement.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;erlang:now/0&lt;/code&gt; 은 &quot;있는 그대로&quot;유지하지만 &lt;strong&gt;사용하지 않는 것이 좋습니다&lt;/strong&gt; . &lt;code&gt;erlang:now/0&lt;/code&gt; 의 많은 사용 사례는 새로운 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 를 사용하지 못하게 하므로이 새로운 시간 기능 개선의 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="329020006d74005fa227c858badad448a18d5417" translate="yes" xml:space="preserve">
          <source>To be explicit, this does not work:</source>
          <target state="translated">명시 적으로 말하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="921be93011160f60c5394e46977ec4ffed9f386b" translate="yes" xml:space="preserve">
          <source>To be exploited by documentation tools, such as EDoc, for generating program documentation of various forms</source>
          <target state="translated">다양한 형식의 프로그램 문서를 생성하기 위해 EDoc과 같은 문서 도구를 활용</target>
        </trans-unit>
        <trans-unit id="f48ee1f9c7b05fd181e829e8e9aa1a1a445ae544" translate="yes" xml:space="preserve">
          <source>To be made the default version, the newly installed release must be made &lt;strong&gt;permanent&lt;/strong&gt;, which means the previous version becomes &lt;strong&gt;old&lt;/strong&gt;:</source>
          <target state="translated">기본 버전, 새로 설치된 버전이 이루어져야 할하려면 &lt;strong&gt;영구&lt;/strong&gt; 이전 버전이되고 의미, &lt;strong&gt;오래된&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e74a300fec94193e2bb8d4e9a20ec23ef6d08170" translate="yes" xml:space="preserve">
          <source>To be passed along to &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f188872bc4af8764a7f9a37cf3e8af8d364819f6" translate="yes" xml:space="preserve">
          <source>To be used in &lt;code&gt;&lt;a href=&quot;crypto#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;related functions&lt;/code&gt;.</source>
          <target state="translated">에 사용되는 &lt;code&gt;&lt;a href=&quot;crypto#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;related functions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74a03c9a55622acfb1073ad485959792425762b4" translate="yes" xml:space="preserve">
          <source>To be used with:</source>
          <target state="translated">함께 사용 :</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="translated">쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478342ff97001f76e051ff05457f998d192f9c98" translate="yes" xml:space="preserve">
          <source>To bring up all functions of the module in the listbox, click the &lt;strong&gt;OK&lt;/strong&gt; button (or press the &lt;strong&gt;Return&lt;/strong&gt; or &lt;strong&gt;Tab&lt;/strong&gt; key) when a module name has been specified,.</source>
          <target state="translated">목록 상자에 모듈의 모든 기능을 불러 오려면 모듈 이름이 지정되었을 때 &lt;strong&gt;확인&lt;/strong&gt; 버튼을 클릭 하거나 &lt;strong&gt;Return&lt;/strong&gt; 또는 &lt;strong&gt;Tab&lt;/strong&gt; 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="eef5c50b74cfb025ae830e60721c49d26fd50ea9" translate="yes" xml:space="preserve">
          <source>To browse the file hierarchy and interpret the appropriate modules, either select a module name and click &lt;strong&gt;Choose&lt;/strong&gt; (or press carriage return), or double-click the module name. Interpreted modules have the type &lt;code&gt;erl src&lt;/code&gt;.</source>
          <target state="translated">파일 계층 구조를 찾아보고 적절한 모듈을 해석하려면 모듈 이름을 &lt;strong&gt;선택&lt;/strong&gt; 하고 &lt;strong&gt;선택을&lt;/strong&gt; 클릭 하거나 캐리지 리턴을 누르거나 모듈 이름을 두 번 클릭하십시오. 해석 된 모듈의 유형은 &lt;code&gt;erl src&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28e906186648188c00413e57f57d46fc8b55c323" translate="yes" xml:space="preserve">
          <source>To build the map &lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">&lt;code&gt;#{key1 =&amp;gt; 100, key2 =&amp;gt; {200, 300}}&lt;/code&gt; 맵을 빌드하려면 다음 호출을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf559a27d31b4ba64718074dda19ef0d468cf4ad" translate="yes" xml:space="preserve">
          <source>To build the tuple &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt;, the following call can be made.</source>
          <target state="translated">튜플 &lt;code&gt;{tcp, Port, [100 | Binary]}&lt;/code&gt; 으로 다음과 같은 호출을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94328137f8adf38a2d5782ddb946585047133b14" translate="yes" xml:space="preserve">
          <source>To call an arbitrary function from the release handler, the following instruction is used:</source>
          <target state="translated">릴리스 핸들러에서 임의의 함수를 호출하기 위해 다음 명령어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="648e7cf5c6adf0a3796e8cd7e102571a81de2b0f" translate="yes" xml:space="preserve">
          <source>To call the parser generator, use the following command:</source>
          <target state="translated">파서 생성기를 호출하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d0f9713393429e6796bf7c377bd68256251a30fd" translate="yes" xml:space="preserve">
          <source>To catch the exception, use for example:</source>
          <target state="translated">예외를 포착하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="754fcce3ba1a05a254eee986bb434f3d90945ecd" translate="yes" xml:space="preserve">
          <source>To change from old code to current code, a process must make a fully qualified function call.</source>
          <target state="translated">이전 코드에서 현재 코드로 변경하려면 프로세스가 완전한 함수 호출을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d43cb0d79f1f2a05084529861044cff6d89a0ac1" translate="yes" xml:space="preserve">
          <source>To change that we would need to insert action &lt;code&gt;hibernate&lt;/code&gt; in more places. For example, the state-independent &lt;code&gt;set_lock_button&lt;/code&gt; operation would have to use &lt;code&gt;hibernate&lt;/code&gt; but only in the &lt;code&gt;{open,_}&lt;/code&gt; state, which would clutter the code.</source>
          <target state="translated">이를 변경하려면 더 많은 위치에 &lt;code&gt;hibernate&lt;/code&gt; 동작을 삽입해야 합니다. 예를 들어, 상태 독립적 인 &lt;code&gt;set_lock_button&lt;/code&gt; 작업은 &lt;code&gt;hibernate&lt;/code&gt; 를 사용해야 하지만 &lt;code&gt;{open,_}&lt;/code&gt; 상태 에서만 코드가 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="8177a3463ef365dc1edec90cb008147223f97121" translate="yes" xml:space="preserve">
          <source>To change the SYSDIR, see the &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">SYSDIR을 변경하려면 &lt;code&gt;&lt;a href=&quot;#type-system_dir_daemon_option&quot;&gt;system_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e21c4ee2840bdc59e21153e6a7bd3fa7292bfdf0" translate="yes" xml:space="preserve">
          <source>To change the USERDIR, see the &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; option</source>
          <target state="translated">USERDIR을 변경하려면 &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d2291b5accb98f7fdfc37910802e511d2e8b381" translate="yes" xml:space="preserve">
          <source>To change the above program to one that works out the minimum value of the element in a list, you only need to write &amp;lt; instead of &amp;gt;. (But it would be wise to change the name of the function to &lt;code&gt;list_min&lt;/code&gt;.)</source>
          <target state="translated">위의 프로그램을 목록에서 요소의 최소값을 계산하는 프로그램으로 변경하려면&amp;gt; 대신 &amp;lt;만 쓰면됩니다. 그러나 함수 이름을 &lt;code&gt;list_min&lt;/code&gt; 으로 변경하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="df565b9f1ce8851c5511996238157f3f30542cab" translate="yes" xml:space="preserve">
          <source>To change the algorithm list, there are two options which can be used in &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt;. The options could of course be used in all other functions that initiates connections.</source>
          <target state="translated">알고리즘 목록을 변경하기 위해 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/2,3,4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 에서 사용할 수있는 두 가지 옵션이 있습니다 . 옵션은 물론 연결을 시작하는 다른 모든 기능에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20b354ae68e6f4458aeb56c8ff9e5b341166ae57" translate="yes" xml:space="preserve">
          <source>To change the log level for a handler, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config(HandlerId, level, Level) &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러의 로그 레벨을 변경하려면 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config(HandlerId, level, Level) &lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="645ec6265eaa80d65a779b7caa5860ddbfdebc42" translate="yes" xml:space="preserve">
          <source>To change the log level for a handler, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들러의 로그 레벨을 변경하려면 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt;set_handler_config(HandlerId, level, Level)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd786bf281877aa85271503f3c21215f44679fd5" translate="yes" xml:space="preserve">
          <source>To change the pattern so that it matches all palindromic strings, not only those with an odd number of characters, it is tempting to change the pattern to this:</source>
          <target state="translated">홀수 개의 문자가있는 문자열뿐만 아니라 모든 회문 문자열과 일치하도록 패턴을 변경하려면 패턴을 다음과 같이 변경하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a6051fffc9d710c7ebcc3e122883720f210d4ada" translate="yes" xml:space="preserve">
          <source>To change the primary log level for Logger, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt; set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Logger의 기본 로그 수준을 변경하려면 &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt; set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9656eb62d534763e64141fc6d3d1d35b0b442bc" translate="yes" xml:space="preserve">
          <source>To change the primary log level for Logger, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로거의 기본 로그 레벨을 변경하려면 &lt;code&gt;&lt;a href=&quot;#set_primary_config-2&quot;&gt;set_primary_config(level, Level)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="866ca5de7c21c0cf7da2438015592c26ee8d81d7" translate="yes" xml:space="preserve">
          <source>To change the rules that restrict the use of an asset, the user only needs write access to the directory where the asset is.</source>
          <target state="translated">자산 사용을 제한하는 규칙을 변경하려면 자산이있는 디렉토리에 대한 쓰기 권한 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="f5621caa72f0f06f014de0ebbc8d407830e5d0da" translate="yes" xml:space="preserve">
          <source>To check if your code is executed within a transaction, use the function &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt;. It returns &lt;code&gt;true&lt;/code&gt; when called inside a transaction context, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">트랜잭션 내에서 코드가 실행되는지 확인하려면 &lt;code&gt;&lt;a href=&quot;mnesia#is_transaction-0&quot;&gt;mnesia:is_transaction/0&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 트랜잭션 컨텍스트 내에서 호출되면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6b2516b6faafd214fb55f7400a6a5d85502f13d2" translate="yes" xml:space="preserve">
          <source>To check whether a term is a fun, use the test &lt;code&gt;is_function/1&lt;/code&gt; in a guard.</source>
          <target state="translated">용어가 재미 있는지 확인하려면 가드에서 &lt;code&gt;is_function/1&lt;/code&gt; 테스트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="61eaab6c693a13cade1df8955eec714a449d7d24" translate="yes" xml:space="preserve">
          <source>To choose the name for the generated module, for example, because you need to compile the same specs for different encoding rules.</source>
          <target state="translated">예를 들어 생성 된 모듈의 이름을 선택하려면 다른 인코딩 규칙에 대해 동일한 사양을 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="77676158a92effec6457676e808555ae1fd71986" translate="yes" xml:space="preserve">
          <source>To close the connection, call the function &lt;code&gt;&lt;a href=&quot;ssh#close-1&quot;&gt;ssh:close(ConnectionRef)&lt;/a&gt;&lt;/code&gt;. As an alternative, set the option &lt;code&gt;&lt;a href=&quot;ssh#type-max_idle_time_common_option&quot;&gt;{idle_time, 1}&lt;/a&gt;&lt;/code&gt; when opening the connection. This will cause the connection to be closed automaticaly when there are no channels open for the specified time period, in this case 1 ms.</source>
          <target state="translated">연결을 닫으려면 &lt;code&gt;&lt;a href=&quot;ssh#close-1&quot;&gt;ssh:close(ConnectionRef)&lt;/a&gt;&lt;/code&gt; 함수를 호출하십시오 . 또는 연결을 열 때 &lt;code&gt;&lt;a href=&quot;ssh#type-max_idle_time_common_option&quot;&gt;{idle_time, 1}&lt;/a&gt;&lt;/code&gt; 옵션을 설정하십시오 . 이렇게하면 지정된 시간 (이 경우 1ms) 동안 열린 채널이 없을 때 연결이 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="1427a1da5e3a256c344db44b11dc0bba14915bf8" translate="yes" xml:space="preserve">
          <source>To close the window, click &lt;strong&gt;Done&lt;/strong&gt;.</source>
          <target state="translated">창을 닫으려면 &lt;strong&gt;완료를&lt;/strong&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="8529722ba2eb984fe7acaf5239aaeee899afd795" translate="yes" xml:space="preserve">
          <source>To collect the channel messages in a program, use &lt;code&gt;receive...end&lt;/code&gt; instead of &lt;code&gt;flush/1&lt;/code&gt;:</source>
          <target state="translated">프로그램에서 채널 메시지를 수집하려면 &lt;code&gt;flush/1&lt;/code&gt; 대신 &lt;code&gt;receive...end&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b49e3e39a1c8fd0e9ebc5aae6e7cbc8ac29bcce" translate="yes" xml:space="preserve">
          <source>To communicate through Telnet to the host specified by &lt;code&gt;HostNameOrIpAddress&lt;/code&gt;, use the interface functions in &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for example, &lt;code&gt;open(Name)&lt;/code&gt; and &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt;.</source>
          <target state="translated">Telnet을 통해 &lt;code&gt;HostNameOrIpAddress&lt;/code&gt; 로 지정된 호스트와 통신하려면 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 의 인터페이스 함수 &lt;code&gt;open(Name)&lt;/code&gt; 예 : open (Name) 및 &lt;code&gt;cmd(Name,Cmd)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc63914adafb29982dfe6a5968660a48f49ce2e" translate="yes" xml:space="preserve">
          <source>To compare styles, here follows the same example using &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt;, or rather the code to replace after function &lt;code&gt;init/1&lt;/code&gt; of the &lt;code&gt;pushbutton.erl&lt;/code&gt; example file above:</source>
          <target state="translated">스타일을 비교하기 위해 다음은 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; 을 사용하는 동일한 예제 또는 위 의 &lt;code&gt;pushbutton.erl&lt;/code&gt; 예제 파일 의 함수 &lt;code&gt;init/1&lt;/code&gt; 이후에 대체 할 코드를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f9bdaaae36af33eb796c91b4364a72c96ddef2b5" translate="yes" xml:space="preserve">
          <source>To compare the importance of the printout to a specific verbosity level.</source>
          <target state="translated">인쇄물의 중요성을 특정 상세 레벨과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="ce902aa7e185b10f95db9c5e6db8ef30884a21be" translate="yes" xml:space="preserve">
          <source>To compile your code, ensure that your C compiler knows where to find &lt;code&gt;ei.h&lt;/code&gt; by specifying an appropriate &lt;code&gt;-I&lt;/code&gt; argument on the command line, or add it to the &lt;code&gt;CFLAGS&lt;/code&gt; definition in your &lt;code&gt;Makefile&lt;/code&gt;. The correct value for this path is &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt;, where:</source>
          <target state="translated">코드를 컴파일하려면 명령 줄에 적절한 &lt;code&gt;-I&lt;/code&gt; 인수를 지정 하여 C 컴파일러가 &lt;code&gt;ei.h&lt;/code&gt; 를 찾을 위치를 알고 있는지 확인 하거나 &lt;code&gt;Makefile&lt;/code&gt; 의 &lt;code&gt;CFLAGS&lt;/code&gt; 정의에 추가합니다 . 이 경로의 올바른 값은 &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt; . 여기서 :</target>
        </trans-unit>
        <trans-unit id="54ed5bb067e17e1fa5d9fb9384ef7e59e200b2f4" translate="yes" xml:space="preserve">
          <source>To compile your code, ensure that your C compiler knows where to find &lt;code&gt;erl_interface.h&lt;/code&gt; by specifying an appropriate &lt;code&gt;-I&lt;/code&gt; argument on the command line, or add it to the &lt;code&gt;CFLAGS&lt;/code&gt; definition in your &lt;code&gt;Makefile&lt;/code&gt;. The correct value for this path is &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt;, where:</source>
          <target state="translated">코드를 컴파일하려면 명령 행에 적절한 &lt;code&gt;-I&lt;/code&gt; 인수를 지정 하여 C 컴파일러가 &lt;code&gt;erl_interface.h&lt;/code&gt; 를 찾을 위치를 알고 있는지 확인 하거나 &lt;code&gt;Makefile&lt;/code&gt; 의 &lt;code&gt;CFLAGS&lt;/code&gt; 정의에 추가하십시오 . 이 경로의 올바른 값은 &lt;code&gt;$OTPROOT/lib/erl_interface-$EIVSN/include&lt;/code&gt; . 여기서,</target>
        </trans-unit>
        <trans-unit id="99dbaa9ef513face3ab175774b7916127ae86697" translate="yes" xml:space="preserve">
          <source>To complete the I/O server, we only need to read and write the table in an appropriate way:</source>
          <target state="translated">I / O 서버를 완성하려면 적절한 방법으로 테이블을 읽고 쓰면됩니다.</target>
        </trans-unit>
        <trans-unit id="ef56703b3c226b895e39bdf18576e702cab5ae0b" translate="yes" xml:space="preserve">
          <source>To configure the Logger backend, use &lt;code&gt;Kernel configuration parameters&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; in the Logger API.</source>
          <target state="translated">로거 백엔드를 구성하려면 로거 API에서 &lt;code&gt;Kernel configuration parameters&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#configuration_API&quot;&gt;configuration functions&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a8abc4316358324e879aa4fb86c41abefacbe121" translate="yes" xml:space="preserve">
          <source>To connect to a distributed Erlang node, you must first initialize the connection routine with &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt;, which stores information, such as the hostname, node name, and IP address for later use:</source>
          <target state="translated">분산 Erlang 노드에 연결하려면 먼저 &lt;code&gt;&lt;a href=&quot;erl_connect#erl_connect_init&quot;&gt;erl_connect:erl_connect_init&lt;/a&gt;&lt;/code&gt; 로 연결 루틴을 초기화해야합니다 . erl_connect : erl_connect_init 는 나중에 사용할 수 있도록 호스트 이름, 노드 이름 및 IP 주소와 같은 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="814ff103d76eb9252c18ebc95545cfae2963c042" translate="yes" xml:space="preserve">
          <source>To connect to a distributed Erlang node, you must first initialize the connection routine with one of the &lt;code&gt;&lt;a href=&quot;ei_connect#ei_connect_init&quot;&gt; ei_connect_init_*&lt;/a&gt;&lt;/code&gt; functions, which stores information, such as the hostname, and node name for later use:</source>
          <target state="translated">분산 된 Erlang 노드에 연결하려면 먼저 호스트 이름 및 노드 이름과 같은 정보를 저장 하는 &lt;code&gt;&lt;a href=&quot;ei_connect#ei_connect_init&quot;&gt; ei_connect_init_*&lt;/a&gt;&lt;/code&gt; 함수 중 하나로 연결 루틴을 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="da53f52f9b6e989d7d98084c289e93041ec03817" translate="yes" xml:space="preserve">
          <source>To constrain the match, it is needed to replace some of the &lt;code&gt;'_'&lt;/code&gt; elements. The code for matching out all female employees looks as follows:</source>
          <target state="translated">일치를 제한하려면 &lt;code&gt;'_'&lt;/code&gt; 요소 중 일부를 바꿔야 합니다. 모든 여성 직원을 매칭하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db8fca00f1d4d2a5725d8baaafde57fb1f7e09a3" translate="yes" xml:space="preserve">
          <source>To convert an error term returned from one of the functions above to a readable message, use function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위의 함수 중 하나에서 리턴 된 오류 용어를 읽을 수있는 메시지로 변환하려면 function_error &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="746ad6da742f525d196ec4f846fc54c5b8d6665f" translate="yes" xml:space="preserve">
          <source>To copy text to the clipboard, use &lt;code&gt;Ctrl-C&lt;/code&gt;.</source>
          <target state="translated">텍스트를 클립 보드에 복사하려면 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f0c639143cf961891408084facf2efc28d6f4b6" translate="yes" xml:space="preserve">
          <source>To copy the selected text to the clipboard, either use &lt;code&gt;Ctrl-C&lt;/code&gt;, use the menu, or press the copy button in the toolbar.</source>
          <target state="translated">선택한 텍스트를 클립 보드에 복사하려면 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 사용하거나 메뉴를 사용하거나 도구 모음에서 복사 단추를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="d0e2976d5ba6748c5f943edab22facd4c396be64" translate="yes" xml:space="preserve">
          <source>To counter the &quot;bad cluster&quot; problem and also ease the contention, the search will now always start by first looking at the allocators &lt;strong&gt;own&lt;/strong&gt; carriers. That is, carriers that were initially created by the allocator itself and later had been abandoned to the pool. If none of our own abandoned carrier would do, then the search continues into the pool, as before, to look for carriers created by other allocators. However, if we have at least one abandoned carrier of our own that could not satisfy the request, we can use that as entry point into the pool.</source>
          <target state="translated">&quot;불량 클러스터&quot;문제에 대응하고 경합을 완화하기 위해 이제 항상 할당 자 &lt;strong&gt;소유의&lt;/strong&gt; 캐리어를 먼저 살펴 보는 것으로 검색이 시작됩니다 . 즉, 처음에는 할당 자 자체에 의해 생성 된 캐리어가 나중에 풀에 버려졌습니다. 우리 자신이 포기한 캐리어가 없다면, 이전과 마찬가지로 다른 할당자가 만든 캐리어를 찾기 위해 검색이 풀로 계속됩니다. 그러나 요청을 충족 할 수없는 버려진 운송 업체가 하나 이상있는 경우이를 풀의 진입 점으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b54150ad2122f90546c148d80de8d120283f00f8" translate="yes" xml:space="preserve">
          <source>To create a list of binaries from an arbitrary iolist, use &lt;code&gt; erlang:iolist_to_iovec/1&lt;/code&gt;.</source>
          <target state="translated">임의의 iolist에서 바이너리 목록을 만들려면 &lt;code&gt; erlang:iolist_to_iovec/1&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f36469b72d764889b8bc2c05eb18e7c2e00c94" translate="yes" xml:space="preserve">
          <source>To create a list of binaries from an arbitrary iolist, use &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt;.</source>
          <target state="translated">임의의 iolist에서 바이너리 목록을 작성하려면 &lt;code&gt;erlang:iolist_to_iovec/1&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b64ef8fa41b5eb9b9fbad8912a240355ac0b560d" translate="yes" xml:space="preserve">
          <source>To create a port:</source>
          <target state="translated">포트를 만들려면</target>
        </trans-unit>
        <trans-unit id="c1b10e93b99ca718329a25a25398d8dc9f5d3821" translate="yes" xml:space="preserve">
          <source>To create the Mnesia tables, we use two records defined in &lt;code&gt;mod_auth.hrl&lt;/code&gt;, so that file must be included. &lt;code&gt;first_start/0&lt;/code&gt; creates a schema that specifies on which nodes the database is to reside. Then it starts Mnesia and creates the tables. The first argument is the name of the tables, the second argument is a list of options of how to create the table, see &lt;code&gt;mnesia(3)&lt;/code&gt;, documentation for more information. As the implementation of the &lt;code&gt;mod_auth_mnesia&lt;/code&gt; saves one row for each user, the type must be &lt;code&gt;bag&lt;/code&gt;. When the schema and the tables are created, function &lt;code&gt;mnesia:start/0&lt;/code&gt; is used to start Mnesia and waits for the tables to be loaded. Mnesia uses the directory specified as &lt;code&gt;mnesia_dir&lt;/code&gt; at startup if specified, otherwise Mnesia uses the current directory. For security reasons, ensure that the Mnesia tables are stored outside the document tree of the HTTP server. If they are placed in the directory which it protects, clients can download the tables. Only the Dets and Mnesia storage methods allow writing of dynamic user data to disk. &lt;code&gt;plain&lt;/code&gt; is a read only method.</source>
          <target state="translated">Mnesia 테이블을 작성하려면 &lt;code&gt;mod_auth.hrl&lt;/code&gt; 에 정의 된 두 개의 레코드를 사용 하므로 파일이 포함되어야합니다. &lt;code&gt;first_start/0&lt;/code&gt; 은 데이터베이스가 상주 할 노드를 지정하는 스키마를 작성합니다. 그런 다음 Mnesia를 시작하고 테이블을 만듭니다. 첫 번째 인수는 테이블의 이름이고 두 번째 인수는 테이블을 작성하는 방법에 대한 옵션 목록입니다 . 자세한 정보는 &lt;code&gt;mnesia(3)&lt;/code&gt; 문서를 참조하십시오. &lt;code&gt;mod_auth_mnesia&lt;/code&gt; 의 구현은 각 사용자에 대해 하나의 행을 저장하므로 유형은 &lt;code&gt;bag&lt;/code&gt; 이어야합니다 . 스키마와 테이블이 작성되면 &lt;code&gt;mnesia:start/0&lt;/code&gt; 함수가 Mnesia 를 시작하는 데 사용되며 테이블이로드되기를 기다립니다. Mnesia는 다음과 같이 지정된 디렉토리를 사용합니다. &lt;code&gt;mnesia_dir&lt;/code&gt; 지정된 경우 시작시 mnesia_dir , 그렇지 않으면 Mnesia는 현재 디렉토리를 사용합니다. 보안상의 이유로 Mnesia 테이블이 HTTP 서버의 문서 트리 외부에 저장되어 있는지 확인하십시오. 이들이 보호되는 디렉토리에 있으면, 클라이언트는 테이블을 다운로드 할 수 있습니다. Dets 및 Mnesia 스토리지 방법 만 사용하여 동적 사용자 데이터를 디스크에 쓸 수 있습니다. &lt;code&gt;plain&lt;/code&gt; 은 읽기 전용 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7026fff802f7dac35b82f566aac0d4c80c766528" translate="yes" xml:space="preserve">
          <source>To create zip archives, use function &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;create/2,3&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">zip 아카이브를 작성하려면 함수 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#zip-2&quot;&gt;zip/3&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 모듈 과 유사한 &lt;code&gt;create/2,3&lt;/code&gt; 으로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebc5fc7bc8bd769bb1bb61a99c206e8739bf277b" translate="yes" xml:space="preserve">
          <source>To decide the first state the &lt;code&gt; Module:init(Args) &lt;/code&gt; callback function is called before any &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is called. This function behaves like a &lt;strong&gt;state callback&lt;/strong&gt; function, but gets its only argument &lt;code&gt;Args&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt; start/3,4 &lt;/code&gt; or &lt;code&gt; start_link/3,4 &lt;/code&gt; function, and returns &lt;code&gt;{ok, State, Data}&lt;/code&gt; or &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt;. If you use the &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; action from this function, that action is ignored, since there is no event to postpone.</source>
          <target state="translated">첫 번째 상태에게 결정하기 위해 &lt;code&gt; Module:init(Args) &lt;/code&gt; 어떤 전에 콜백 함수가 호출됩니다 &lt;code&gt;&lt;a href=&quot;#State%20Callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 호출된다. 이 함수는 &lt;strong&gt;상태 콜백&lt;/strong&gt; 함수 처럼 작동 하지만 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt; start/3,4 &lt;/code&gt; 또는 start_link &lt;code&gt; start_link/3,4 &lt;/code&gt; 함수 에서 유일한 인수 &lt;code&gt;Args&lt;/code&gt; 를 가져와 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 또는 &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt; 반환합니다. . 이 함수에서 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; 작업 을 사용하면 연기 할 이벤트가 없으므로 해당 작업이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="96ba6751b435aa130ce8000c31fb7a59eb14a8a4" translate="yes" xml:space="preserve">
          <source>To decide the first state the &lt;code&gt;Module:init(Args)&lt;/code&gt; callback function is called before any &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; is called. This function behaves like an event handler function, but gets its only argument &lt;code&gt;Args&lt;/code&gt; from the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;start/3,4&lt;/code&gt; or &lt;code&gt;start_link/3,4&lt;/code&gt; function, and returns &lt;code&gt;{ok, State, Data}&lt;/code&gt; or &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt;. If you use the &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; action from this function, that action is ignored, since there is no event to postpone.</source>
          <target state="translated">첫 번째 상태를 결정하기 위해 &lt;code&gt;&lt;a href=&quot;#Event%20Handler&quot;&gt;Event Handler&lt;/a&gt;&lt;/code&gt; 가 호출 되기 전에 &lt;code&gt;Module:init(Args)&lt;/code&gt; 콜백 함수 가 호출됩니다. 이 함수는 이벤트 핸들러 함수처럼 작동하지만 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;start/3,4&lt;/code&gt; 또는 start_link &lt;code&gt;start_link/3,4&lt;/code&gt; 함수 에서 인수 &lt;code&gt;Args&lt;/code&gt; 만 가져 오고 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 또는 &lt;code&gt;{ok, State, Data, Actions}&lt;/code&gt; 리턴합니다. . 이 기능에서 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postpone&lt;/a&gt;&lt;/code&gt; 조치 를 사용하면 연기 할 이벤트가 없으므로 해당 조치가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="51c111740de9350080c7972bf37d34610910e708" translate="yes" xml:space="preserve">
          <source>To define a release, create a &lt;strong&gt;release resource file&lt;/strong&gt;, or in short a &lt;code&gt;.rel&lt;/code&gt; file. In the file, specify the name and version of the release, which ERTS version it is based on, and which applications it consists of:</source>
          <target state="translated">릴리스를 정의하려면 &lt;strong&gt;릴리스 자원 파일&lt;/strong&gt; 또는 간단히 &lt;code&gt;.rel&lt;/code&gt; 파일을 작성하십시오. 파일에서 릴리스의 이름과 버전, 기반이되는 ERTS 버전 및 구성되는 응용 프로그램을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7dcb9b11962f5e7cb3516154fef97049f24faad8" translate="yes" xml:space="preserve">
          <source>To define an application, an &lt;strong&gt;application specification&lt;/strong&gt; is created, which is put in an &lt;strong&gt;application resource file&lt;/strong&gt;, or in short an &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">응용 프로그램을 정의하기 위해 응용 &lt;strong&gt;프로그램 사양&lt;/strong&gt; 이 만들어지고 &lt;strong&gt;응용 프로그램 리소스 파일&lt;/strong&gt; 또는 짧은 &lt;code&gt;.app&lt;/code&gt; 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="54b3619697604e99e71233bb1079a1597fb1c5a2" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the current version and previous versions of an application, an &lt;strong&gt;application upgrade file&lt;/strong&gt;, or in short an &lt;code&gt;.appup&lt;/code&gt; file is created. The file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name:</source>
          <target state="translated">현재 버전과 이전 버전의 응용 프로그램간에 업그레이드 / 다운 그레이드하는 방법을 정의하기 위해 &lt;strong&gt;응용 프로그램 업그레이드 파일&lt;/strong&gt; 또는 간단히 &lt;code&gt;.appup&lt;/code&gt; 파일이 생성됩니다. 파일 이름은 &lt;code&gt;Application.appup&lt;/code&gt; 이며 여기서 &lt;code&gt;Application&lt;/code&gt; 은 응용 프로그램 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f1125003b8abae474fb015968f66692981cd19a0" translate="yes" xml:space="preserve">
          <source>To define how to upgrade/downgrade between the new version and previous versions of a release, a &lt;strong&gt;release upgrade file&lt;/strong&gt;, or in short &lt;code&gt;relup&lt;/code&gt; file, is to be created.</source>
          <target state="translated">새 버전과 이전 버전의 릴리스간에 업그레이드 / 다운 그레이드하는 방법을 정의하려면 &lt;strong&gt;릴리스 업그레이드 파일&lt;/strong&gt; 또는 짧은 &lt;code&gt;relup&lt;/code&gt; 파일을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e010624d4e818c00508b53d915d93db2cfd9d3a" translate="yes" xml:space="preserve">
          <source>To detect that the server is not the intended one, the client must additionaly perform a</source>
          <target state="translated">서버가 의도 한 것이 아니라는 것을 감지하려면 클라이언트가 추가로</target>
        </trans-unit>
        <trans-unit id="29f1578f8a4341b69585b80b12a72f76a9569382" translate="yes" xml:space="preserve">
          <source>To dig deeper into the general results, or the result of a specific test case, the operator can do so by following the links in the HTML presentation and read the major or minor log files. The &quot;all_runs.html&quot; page is a good starting point. It is located in &lt;code&gt;logdir&lt;/code&gt; and contains a link to each test run, including a quick overview (with date and time, node name, number of tests, test names, and test result totals).</source>
          <target state="translated">일반 결과 또는 특정 테스트 사례의 결과를보다 깊이 파고 들기 위해 HTML 프레젠테이션의 링크를 따라 주요 또는 부 로그 파일을 읽을 수 있습니다. &quot;all_runs.html&quot;페이지는 좋은 출발점입니다. 그것은에 위치하고 &lt;code&gt;logdir&lt;/code&gt; 및 (날짜와 시간, 노드 이름, 테스트의 수, 테스트 이름, 테스트 결과의 합계와) 빠른 개요를 포함하여 각 테스트 실행에 대한 링크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47ea787070856206ef8e8c44cdc817088453a80" translate="yes" xml:space="preserve">
          <source>To disable all electric commands set the variable &lt;code&gt;erlang-electric-commands&lt;/code&gt; to the empty list. In short, place the following line in your &lt;code&gt;.emacs&lt;/code&gt;-file:</source>
          <target state="translated">모든 전기 명령을 비활성화하려면 변수 &lt;code&gt;erlang-electric-commands&lt;/code&gt; 를 빈 목록으로 설정하십시오. 간단히 말해서 &lt;code&gt;.emacs&lt;/code&gt; -file 에 다음 줄을 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="2719f4e1a729a417c71b36c21728b88e49361422" translate="yes" xml:space="preserve">
          <source>To disable certain modes, do the following:</source>
          <target state="translated">특정 모드를 비활성화하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7d843b983a258077823d6e0bf23f5a51462fef79" translate="yes" xml:space="preserve">
          <source>To disable the automatic compilation feature, use flag &lt;code&gt;-no_auto_compile&lt;/code&gt; with &lt;code&gt;ct_run&lt;/code&gt;, or option &lt;code&gt;{auto_compile,false}&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. With automatic compilation disabled, the user is responsible for compiling the test suite modules (and any help modules) before the test run. If the modules cannot be loaded from the local file system during startup of &lt;code&gt;Common Test&lt;/code&gt;, the user must preload the modules before starting the test. &lt;code&gt;Common Test&lt;/code&gt; only verifies that the specified test suites exist (that is, that they are, or can be, loaded). This is useful, for example, if the test suites are transferred and loaded as binaries through RPC from a remote node.</source>
          <target state="translated">자동 편집 기능, 사용 플래그를 사용하지 않으려면 &lt;code&gt;-no_auto_compile&lt;/code&gt; 와 &lt;code&gt;ct_run&lt;/code&gt; , 또는 옵션 &lt;code&gt;{auto_compile,false}&lt;/code&gt; 와 &lt;code&gt;ct:run_test/1&lt;/code&gt; . 자동 컴파일을 사용하지 않으면 사용자는 테스트 실행 전에 테스트 스위트 모듈 (및 모든 도움말 모듈)을 컴파일해야합니다. &lt;code&gt;Common Test&lt;/code&gt; 시작 중에 로컬 파일 시스템에서 모듈을로드 할 수없는 경우 사용자는 테스트를 시작하기 전에 모듈을 사전로드해야합니다. &lt;code&gt;Common Test&lt;/code&gt; 는 지정된 테스트 스위트가 존재하는지 (즉,로드되거나로드 될 수 있는지) 만 검증합니다. 예를 들어 테스트 스위트가 원격 노드에서 RPC를 통해 바이너리로 전송되고로드되는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ceb4119cc35a0a33e9fed4f8110e9358a175961e" translate="yes" xml:space="preserve">
          <source>To disconnect from the shell without exiting the Erlang system, type &lt;code&gt;Ctrl-D&lt;/code&gt;.</source>
          <target state="translated">Erlang 시스템을 종료하지 않고 쉘에서 연결을 끊으려면 &lt;code&gt;Ctrl-D&lt;/code&gt; 를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="b548ad5d8837c627142ce75e81cde50b52ba7141" translate="yes" xml:space="preserve">
          <source>To distinguish trace logs produced with this tool from other logs, option &lt;code&gt;file&lt;/code&gt; is used in &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt;. The logs are therefore fetched to a directory named &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt;</source>
          <target state="translated">이 도구로 생성 된 추적 로그를 다른 로그와 구별하기 위해 옵션 &lt;code&gt;file&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;ttb#tracer-2&quot;&gt;tracer/2&lt;/a&gt;&lt;/code&gt; 에 사용됩니다 . 따라서 로그는 &lt;code&gt;ttb_upload_debug_log-YYYYMMDD-HHMMSS&lt;/code&gt; 라는 디렉토리로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="896795105dbda22e2604c15284900f9f7aafa1c2" translate="yes" xml:space="preserve">
          <source>To do the first search among own carriers, every allocator instance has a &lt;code&gt;pooled_tree&lt;/code&gt; of carriers. This tree is only accessed by the allocator itself and can only contain its own carriers. When a carrier is abandoned and put in the pool, it is also inserted into &lt;code&gt;pooled_tree&lt;/code&gt;. This is either done direct, if the carrier was already employed by its owner, or by first passing it back to the owner via the delayed dealloc queue.</source>
          <target state="translated">자신의 캐리어 중에서 첫 번째 검색을 수행하기 위해 모든 할당 자 인스턴스에는 캐리어 의 &lt;code&gt;pooled_tree&lt;/code&gt; 가 있습니다. 이 트리는 할당 자 자체에 의해서만 액세스되며 자체 캐리어 만 포함 할 수 있습니다. 캐리어가 버려지고 풀에 배치되면 &lt;code&gt;pooled_tree&lt;/code&gt; 에도 삽입됩니다 . 이는 캐리어가 이미 소유자에 의해 고용 된 경우 직접 수행되거나 지연된 Dealloc 대기열을 통해 먼저 소유자에게 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3e40468ed8befabe466118a08bf6fc28c0f6c6eb" translate="yes" xml:space="preserve">
          <source>To do this, create a &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; that defines which applications are included in the release.</source>
          <target state="translated">이렇게하려면 &lt;code&gt;&lt;a href=&quot;#res_file&quot;&gt;release resource file&lt;/a&gt;&lt;/code&gt; 에 포함 된 응용 프로그램을 정의 하는 릴리스 리소스 파일 을 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="71c169e0b7cdb28847a1d261315129b8416e6027" translate="yes" xml:space="preserve">
          <source>To do this, create an &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt;, and describe how the application is to be started and stopped.</source>
          <target state="translated">이를 수행하려면 &lt;code&gt;&lt;a href=&quot;#callback_module&quot;&gt;application callback module&lt;/a&gt;&lt;/code&gt; 작성하고 애플리케이션 을 시작하고 중지하는 방법을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="24f741a20f0106dade011b163f1322e4510ccc13" translate="yes" xml:space="preserve">
          <source>To document function interfaces</source>
          <target state="translated">함수 인터페이스를 문서화하려면</target>
        </trans-unit>
        <trans-unit id="4e2effe3d108d7692e70e0242432ef9323088c3f" translate="yes" xml:space="preserve">
          <source>To downgrade from &lt;code&gt;Vsn&lt;/code&gt; to &lt;code&gt;FromVsn&lt;/code&gt;, &lt;code&gt;install_release&lt;/code&gt; must be called again:</source>
          <target state="translated">에서 다운 그레이드 할 &lt;code&gt;Vsn&lt;/code&gt; 에 &lt;code&gt;FromVsn&lt;/code&gt; , &lt;code&gt;install_release&lt;/code&gt; 는 다시 호출해야합니다 :</target>
        </trans-unit>
        <trans-unit id="66dd305cb60ccb1d581b1532183a42d9550cf7c0" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name &lt;code&gt;cmac&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt;. Also check that the name in the</source>
          <target state="translated">가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 &lt;code&gt;cmac&lt;/code&gt; 이름이 있는지 확인합니다 . 또한 이름이</target>
        </trans-unit>
        <trans-unit id="b6aee92d122edd91f99a63916628811ec1c754e0" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name &lt;code&gt;hmac&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; and that the hash name is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(hashs)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 &lt;code&gt;hmac&lt;/code&gt; 이름이 있고 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(hashs)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 해시 이름이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="96b27582a0af681e39e67a0fb66383f1af501a73" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name &lt;code&gt;poly1305&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(macs)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 &lt;code&gt;poly1305&lt;/code&gt; 라는 이름이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="6bca713a31b268396f2f08d09009aa103834e0eb" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the name in the</source>
          <target state="translated">가용성을 동적으로 확인하려면</target>
        </trans-unit>
        <trans-unit id="8bd074941949eff62a2f10ace8d8745188c15d3a" translate="yes" xml:space="preserve">
          <source>To dynamically check availability, check that the wanted name in the</source>
          <target state="translated">가용성을 동적으로 확인하려면 원하는 이름이</target>
        </trans-unit>
        <trans-unit id="c857b1910cd745feb809b3e36bb979959ad34032" translate="yes" xml:space="preserve">
          <source>To each module using records, a pseudo function is added during compilation to obtain information about records:</source>
          <target state="translated">레코드를 사용하여 각 모듈에 의사 함수가 추가되어 레코드에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="aa7093d0b40db64d8d5dbb29fff9e15755ac8d7c" translate="yes" xml:space="preserve">
          <source>To effectively perform a batch of similar queries, you can use parameterized queries. This means that you in your SQL query string will mark the places that usually would contain values with question marks and then provide lists of values for each parameter. For instance you can use this to insert multiple rows into the &lt;code&gt;EMPLOYEE&lt;/code&gt; table while executing only a single SQL statement, for example code see &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; section in the &quot;Getting Started&quot; chapter.</source>
          <target state="translated">유사한 쿼리 일괄 처리를 효과적으로 수행하기 위해 매개 변수화 된 쿼리를 사용할 수 있습니다. 즉, SQL 쿼리 문자열에서 일반적으로 값이 물음표가 포함 된 위치를 표시 한 다음 각 매개 변수의 값 목록을 제공합니다. 예를 들어 , 단일 SQL 문만 실행하는 동안 &lt;code&gt;EMPLOYEE&lt;/code&gt; 테이블에 여러 행을 삽입하기 위해이를 사용할 수 있습니다. 예를 들어 코드 는 &quot;시작하기&quot;장의 &quot; &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b87466d719f55a7d0bc6167a3744c10376e2896" translate="yes" xml:space="preserve">
          <source>To enable inlining of list functions, use option &lt;code&gt;inline_list_funcs&lt;/code&gt;.</source>
          <target state="translated">목록 함수의 인라인을 활성화하려면 &lt;code&gt;inline_list_funcs&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="51f30cb208852b09d381f6f12d3f9662837e7b58" translate="yes" xml:space="preserve">
          <source>To enable inlining, either use the option &lt;code&gt;inline&lt;/code&gt; to let the compiler decide which functions to inline, or &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; to have the compiler inline all calls to the given functions. If the option is given inside a &lt;code&gt;compile&lt;/code&gt; directive in an Erlang module, &lt;code&gt;{Name,Arity}&lt;/code&gt; can be written as &lt;code&gt;Name/Arity&lt;/code&gt;.</source>
          <target state="translated">인라인 활성화 중 옵션 사용하려면 &lt;code&gt;inline&lt;/code&gt; 컴파일러가 인라인, 또는에있는 기능을 결정하도록 &lt;code&gt;{inline,[{Name,Arity},...]}&lt;/code&gt; 주어진 기능에 대한 모든 호출 인라인 컴파일러를합니다. 옵션이 Erlang 모듈 의 &lt;code&gt;compile&lt;/code&gt; 지시문 내에 제공되면 &lt;code&gt;{Name,Arity}&lt;/code&gt; 를 &lt;code&gt;Name/Arity&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85f19bd3dcfaf9ef3d9cd6caa0e986c9a4690183" translate="yes" xml:space="preserve">
          <source>To enable or disable &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt;. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#builtin_cths&quot;&gt;Built-in Common Test Hooks&lt;/a&gt;&lt;/code&gt; 를 활성화 또는 비활성화 합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="82cdfffdcb7bb12d82a554ed4fb4604dfb3bff2f" translate="yes" xml:space="preserve">
          <source>To enable or disable time correction, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시간 수정을 활성화 또는 비활성화하려면 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#+c&quot;&gt;+c [true|false]&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="708713ed825ecbbe1d0ddcd36ee2857e998c3c1b" translate="yes" xml:space="preserve">
          <source>To enable the full power of Merl, your module needs to include the Merl header file:</source>
          <target state="translated">Merl의 모든 기능을 사용하려면 모듈에 Merl 헤더 파일이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8d53019e25d31ae87446a8faff92ab534fbdf049" translate="yes" xml:space="preserve">
          <source>To encode a list, without knowing the arity in advance:</source>
          <target state="translated">미리 arity를 ​​모르고 목록을 인코딩하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6cd4ebf865b6fcb86e3b3c3d86118b3cbc2de974" translate="yes" xml:space="preserve">
          <source>To ensure that &lt;code&gt;Common Test&lt;/code&gt; does not start executing tests, or closes its log files and shuts down, before the external application is ready for it, &lt;code&gt;Common Test&lt;/code&gt; can be synchronized with the application. During startup and shutdown, &lt;code&gt;Common Test&lt;/code&gt; can be suspended, simply by having a CTH evaluate a &lt;code&gt;receive&lt;/code&gt; expression in the init- or terminate function. The macros &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; (the process executing the hook init function) and &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; (the process executing the hook terminate function) each specifies the name of the correct &lt;code&gt;Common Test&lt;/code&gt; process to send a message to. This is done to return from the &lt;code&gt;receive&lt;/code&gt;. These macros are defined in &lt;code&gt;ct.hrl&lt;/code&gt;.</source>
          <target state="translated">되도록하려면 &lt;code&gt;Common Test&lt;/code&gt; 시험을 수행하기 시작하거나, 외부 응용 프로그램이 준비되기 전에, 아래의 로그 파일과 닫힌다을 종료하지 않고, &lt;code&gt;Common Test&lt;/code&gt; 응용 프로그램과 동기화 할 수 있습니다. 시작 및 종료 중에 CTH 가 초기화 또는 종료 기능에서 &lt;code&gt;receive&lt;/code&gt; 표현식을 평가하도록함으로써 &lt;code&gt;Common Test&lt;/code&gt; 를 일시 중단 할 수 있습니다 . 매크로 &lt;code&gt;?CT_HOOK_INIT_PROCESS&lt;/code&gt; (후크 초기화 기능을 실행하는 프로세스) 및 &lt;code&gt;?CT_HOOK_TERMINATE_PROCESS&lt;/code&gt; (후크 종료 기능을 실행하는 프로세스)는 각각 메시지를 보낼 올바른 &lt;code&gt;Common Test&lt;/code&gt; 프로세스 의 이름을 지정합니다 . 이것은 &lt;code&gt;receive&lt;/code&gt; 에서 돌아 오기 위해 수행 됩니다.. 이 매크로는 &lt;code&gt;ct.hrl&lt;/code&gt; 에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6a3ca4567317dc34953b8a7c1cc3b757bbc4816" translate="yes" xml:space="preserve">
          <source>To ensure that a driver instance always uses the same thread, the following call can be used:</source>
          <target state="translated">드라이버 인스턴스가 항상 동일한 스레드를 사용하도록하기 위해 다음 호출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02dfbcc12d9a0c310d33ec7050492a8ba5fa268" translate="yes" xml:space="preserve">
          <source>To ensure that printouts to &lt;code&gt;stdout&lt;/code&gt; (or printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal,2,3&lt;/a&gt;&lt;/code&gt;) get written to the test case log file, and not to the &lt;code&gt;Common Test&lt;/code&gt; framework log, you can synchronize with the &lt;code&gt;Common Test&lt;/code&gt; server by matching on evvents &lt;code&gt;tc_start&lt;/code&gt; and &lt;code&gt;tc_done&lt;/code&gt;. In the period between these events, all I/O is directed to the test case log file. These events are sent synchronously to avoid potential timing problems (for example, that the test case log file is closed just before an I/O message from an external process gets through). Knowing this, you need to be careful that your &lt;code&gt;handle_event/2&lt;/code&gt; callback function does not stall the test execution, possibly causing unexpected behavior as a result.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 출력 (또는 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct#pal-2&quot;&gt;ct:pal,2,3&lt;/a&gt;&lt;/code&gt; 로 만든 출력)에 대한 출력 이 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 로그가 아닌 테스트 케이스 로그 파일에 기록되도록하려면 다음과 동기화 할 수 있습니다. evvents &lt;code&gt;tc_start&lt;/code&gt; 및 &lt;code&gt;tc_done&lt;/code&gt; 에서 일치하여 &lt;code&gt;Common Test&lt;/code&gt; 서버 . 이러한 이벤트 사이의 기간 동안 모든 I / O는 테스트 케이스 로그 파일로 보내집니다. 이러한 이벤트는 잠재적 인 타이밍 문제를 피하기 위해 동 기적으로 전송됩니다 (예 : 외부 프로세스의 I / O 메시지가 전달되기 직전에 테스트 케이스 로그 파일이 닫힘). 이것을 알면 &lt;code&gt;handle_event/2&lt;/code&gt; 에 주의해야합니다. 콜백 함수는 테스트 실행을 지연시키지 않으므로 결과적으로 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8b277a4b4779423015664e7a3f401ea54aeecd5" translate="yes" xml:space="preserve">
          <source>To ensure that printouts to &lt;code&gt;stdout&lt;/code&gt; (or printouts made with &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ct:pal,2,3&lt;/code&gt;) get written to the test case log file, and not to the &lt;code&gt;Common Test&lt;/code&gt; framework log, you can synchronize with the &lt;code&gt;Common Test&lt;/code&gt; server by matching on evvents &lt;code&gt;tc_start&lt;/code&gt; and &lt;code&gt;tc_done&lt;/code&gt;. In the period between these events, all I/O is directed to the test case log file. These events are sent synchronously to avoid potential timing problems (for example, that the test case log file is closed just before an I/O message from an external process gets through). Knowing this, you need to be careful that your &lt;code&gt;handle_event/2&lt;/code&gt; callback function does not stall the test execution, possibly causing unexpected behavior as a result.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 에 대한 출력물 (또는 &lt;code&gt;&lt;a href=&quot;ct#log-2&quot;&gt;ct:log/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;ct:pal,2,3&lt;/code&gt; 으로 작성된 출력물 )이 &lt;code&gt;Common Test&lt;/code&gt; 프레임 워크 로그가 아닌 테스트 케이스 로그 파일에 기록되도록하기 위해 &lt;code&gt;tc_start&lt;/code&gt; 및 &lt;code&gt;tc_done&lt;/code&gt; 에 일치시키는 &lt;code&gt;Common Test&lt;/code&gt; 서버 . 이러한 이벤트 사이의 기간 동안 모든 I / O는 테스트 케이스 로그 파일로 보내집니다. 이러한 이벤트는 잠재적 타이밍 문제를 피하기 위해 동기식으로 전송됩니다 (예 : 외부 프로세스의 I / O 메시지가 전달되기 직전에 테스트 케이스 로그 파일이 닫힘). 이것을 알면 &lt;code&gt;handle_event/2&lt;/code&gt; 를 조심해야합니다. 콜백 함수가 테스트 실행을 중단하지 않아 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a63e4ff906295f7807af4b654281729a99f4d599" translate="yes" xml:space="preserve">
          <source>To execute group &lt;code&gt;tests1&lt;/code&gt; twice with different properties for &lt;code&gt;tests2&lt;/code&gt; each time:</source>
          <target state="translated">매번 &lt;code&gt;tests2&lt;/code&gt; 에 대해 다른 속성으로 그룹 &lt;code&gt;tests1&lt;/code&gt; 을 두 번 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="7239843e8d90d77d86be2ae7b38276b2e33faca1" translate="yes" xml:space="preserve">
          <source>To execute the test cases in the recent test suite, type the following on the UNIX/Linux command line (assuming that the suite module is in the current working directory):</source>
          <target state="translated">최신 테스트 스위트에서 테스트 케이스를 실행하려면 스위트 모듈이 현재 작업 디렉토리에 있다고 가정하여 UNIX / Linux 명령 행에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="15b464ff8a64913edd497cc9c55da6f1268e3b00" translate="yes" xml:space="preserve">
          <source>To explain how it works, let us examine the following code line by line:</source>
          <target state="translated">작동 방식을 설명하기 위해 다음 코드를 한 줄씩 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6ace97c5b62d1ba123d6323684c350a22b583d3a" translate="yes" xml:space="preserve">
          <source>To extract all files from a tar file, use function &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt;. To extract only some files or to be able to specify some more options, use function &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">tar 파일에서 모든 파일을 추출하려면 extract &lt;code&gt;&lt;a href=&quot;#extract-1&quot;&gt;extract/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 일부 파일 만 추출하거나 추가 옵션을 지정하려면 &lt;code&gt;&lt;a href=&quot;#extract-2&quot;&gt;extract/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d79465290c25ae2d243af5890aece9f3a5c6794" translate="yes" xml:space="preserve">
          <source>To extract files from a zip archive, use function &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;extract/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">zip 아카이브에서 파일을 추출하려면 &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#unzip-2&quot;&gt;unzip/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 또한 &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 모듈 과 유사한 &lt;code&gt;extract/1,2&lt;/code&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49b523abf1ecfbea37ac71cc8ad901ada87596e3" translate="yes" xml:space="preserve">
          <source>To facilitate addition or removal of algorithms the option &lt;code&gt;modify_algorithms&lt;/code&gt; is available. See the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">알고리즘의 추가 또는 제거를 용이하게하기 위해 &lt;code&gt;modify_algorithms&lt;/code&gt; 옵션을 사용할 수 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;Reference Manual&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="318d261f2e9e44898ab106149f1818df3611a4d0" translate="yes" xml:space="preserve">
          <source>To facilitate for instance counting of failed tries, the &lt;code&gt;State&lt;/code&gt; variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the &lt;code&gt;State&lt;/code&gt; variable has the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">예를 들어 실패한 시도 횟수를 쉽게 계산하기 위해 &lt;code&gt;State&lt;/code&gt; 변수를 사용할 수 있습니다. 이 상태는 연결 당입니다. pwdfun이 연결을 위해 처음 호출 될 때 &lt;code&gt;State&lt;/code&gt; 변수의 값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb30040c24cb4398d4f306c6f75be49b3309b50e" translate="yes" xml:space="preserve">
          <source>To facilitate incremental MIB implementation, the tool can generate a prototype implementation for a whole MIB, or parts thereof. This allows different MIBs and management applications to be developed at the same time.</source>
          <target state="translated">증분 MIB 구현을 용이하게하기 위해, 툴은 전체 MIB 또는 그 일부에 대한 프로토 타입 구현을 생성 할 수있다. 이를 통해 서로 다른 MIB 및 관리 응용 프로그램을 동시에 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3b821acb43789b1950f11a1cb4212f690e5c52d" translate="yes" xml:space="preserve">
          <source>To fetch the EEP-48 documentation for a module you can use &lt;code&gt;&lt;a href=&quot;code#get_doc-1&quot;&gt;code:get_doc/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈에 대한 EEP-48 문서를 가져 오려면 &lt;code&gt;&lt;a href=&quot;code#get_doc-1&quot;&gt;code:get_doc/1&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2bbbdeeda7bd5404449757f8d9770ca2ef7aaa9" translate="yes" xml:space="preserve">
          <source>To filter only by dates, specify the empty list as the &lt;code&gt;Filters&lt;/code&gt; parameter.</source>
          <target state="translated">날짜별로 만 필터링하려면 빈 목록을 &lt;code&gt;Filters&lt;/code&gt; 매개 변수 로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="630e50a14a964d68d3d5576b2cd371a11e3b187e" translate="yes" xml:space="preserve">
          <source>To find &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; in all applications &lt;code&gt;src&lt;/code&gt; directories, use either of the following lines:</source>
          <target state="translated">모든 응용 프로그램 &lt;code&gt;src&lt;/code&gt; 디렉토리 에서 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.hrl&lt;/code&gt; 을 찾으려면 다음 행 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6396773c2bde8a4d52d39cd61a041b4f1f183b7" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.beam&lt;/code&gt; files in all applications, use the following line:</source>
          <target state="translated">모든 응용 프로그램에서 모든 &lt;code&gt;.beam&lt;/code&gt; 파일 을 찾으려면 다음 행을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20cf9c172afcf3da74dfc71cb0f3fcae5974105f" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in any subdirectory:</source>
          <target state="translated">하위 디렉토리에서 모든 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7ed6cec65dd2913192c7cb022d1a0950d0fa1dc6" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; files in either &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 또는 &lt;code&gt;include&lt;/code&gt; 디렉토리 에서 모든 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 찾으려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="fccdf7c91c9fff2872abc1dbafd75d06a060282b" translate="yes" xml:space="preserve">
          <source>To find all &lt;code&gt;.hrl&lt;/code&gt; files in &lt;code&gt;src&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; directories:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 에서 모든 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 찾 거나 디렉토리를 &lt;code&gt;include&lt;/code&gt; 시키려면 :</target>
        </trans-unit>
        <trans-unit id="8e72309f663e0cdb8ebe00ece9160cd743a20ac1" translate="yes" xml:space="preserve">
          <source>To find out which data types will be returned for the columns in a table use the function &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">테이블의 컬럼에 대해 리턴 될 데이터 유형을 찾으려면 &lt;code&gt;&lt;a href=&quot;odbc#describe_table&quot;&gt;describe_table/[2,3]&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="df081f6643e87b8a4d20937b6cf7036fe456bdf3" translate="yes" xml:space="preserve">
          <source>To find preceding keys in the table, use &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표에서 이전 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#prev-2&quot;&gt;prev/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bab05c393dca1da866e4258e15bc30ee1a82d0d1" translate="yes" xml:space="preserve">
          <source>To find subsequent keys in the table, use &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표에서 후속 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5305b16b9a4a45c3c66348bdacc0a4e5b3a4971f" translate="yes" xml:space="preserve">
          <source>To find the first key in the table, use &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표에서 첫 번째 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="42cc32e7cca81e536a322edfe74f1ef1ef453ef3" translate="yes" xml:space="preserve">
          <source>To find the last key in an &lt;code&gt;ordered_set&lt;/code&gt; table, use &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ordered_set&lt;/code&gt; 테이블 에서 마지막 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f84576968a9f5a5747d5c908246715868508fa22" translate="yes" xml:space="preserve">
          <source>To find the last key in the table, use &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테이블에서 마지막 키를 찾으려면 &lt;code&gt;&lt;a href=&quot;#last-1&quot;&gt;last/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1a928f27f842a3eeb3e94898ada404294f44440" translate="yes" xml:space="preserve">
          <source>To find the smallest free segment that will satisfy a carrier allocation (best fit), the free segments are organized in a tree sorted by size (&lt;code&gt;stree&lt;/code&gt;). We search in this tree at allocation. If no free segment of sufficient size was found, the area (&lt;code&gt;sa&lt;/code&gt; or &lt;code&gt;sua&lt;/code&gt;) is instead expanded. If two or more free segments with equal size exist, the one at lowest address is chosen for &lt;code&gt;sa&lt;/code&gt; and highest address for &lt;code&gt;sua&lt;/code&gt;.</source>
          <target state="translated">캐리어 할당 (최적 적합)을 충족 할 가장 작은 여유 세그먼트를 찾기 위해 여유 세그먼트가 크기 ( &lt;code&gt;stree&lt;/code&gt; ) 별로 정렬 된 트리로 구성됩니다 . 할당시이 트리에서 검색합니다. 충분한 크기의 여유 세그먼트가 없으면 대신 영역 ( &lt;code&gt;sa&lt;/code&gt; 또는 &lt;code&gt;sua&lt;/code&gt; )이 확장됩니다. 동일한 크기의 사용 가능한 세그먼트가 둘 이상있는 경우 가장 낮은 주소에있는 세그먼트가 &lt;code&gt;sa&lt;/code&gt; 에 대해 선택 되고 가장 높은 주소에 대해 &lt;code&gt;sua&lt;/code&gt; 에 대해 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="b08cebc24b1775a65769e106895c5039d3db4448" translate="yes" xml:space="preserve">
          <source>To fold a function over all files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">zip 아카이브의 모든 파일에 대해 함수를 접으려면 &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3107d752335f18f59b4878dac8c20e1cc44001a3" translate="yes" xml:space="preserve">
          <source>To force Unicode filename translation mode on systems where this is not the default was considered experimental in Erlang/OTP R14B01. This was because the initial implementation did not ignore wrongly encoded filenames, so that raw filenames could spread unexpectedly throughout the system. As from Erlang/OTP R16B, the wrongly encoded filenames are only retrieved by special functions (such as &lt;code&gt;file:list_dir_all/1&lt;/code&gt;). Since the impact on existing code is therefore much lower it is now supported. Unicode filename translation is expected to be default in future releases.</source>
          <target state="translated">이것이 기본값이 아닌 시스템에서 유니 코드 파일 이름 변환 모드를 강제 실행하는 것은 Erlang / OTP R14B01에서 실험적인 것으로 간주되었습니다. 초기 구현에서 잘못 인코딩 된 파일 이름을 무시하지 않았기 때문에 원시 파일 이름이 시스템 전체에 예기치 않게 퍼질 수있었습니다. Erlang / OTP R16B에서와 같이 잘못 인코딩 된 파일 이름은 특수 함수 (예 : &lt;code&gt;file:list_dir_all/1&lt;/code&gt; ) 로만 검색됩니다 . 따라서 기존 코드에 대한 영향이 훨씬 낮아 이제 지원됩니다. 향후 릴리스에서는 유니 코드 파일 이름 변환이 기본값이 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="286ba4fce2df7e992d24f0fa54be1d66081e5721" translate="yes" xml:space="preserve">
          <source>To format the printout according to a user-specific HTML Style Sheet (CSS).</source>
          <target state="translated">사용자 별 CSS (HTML Style Sheet)에 따라 출력물의 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d829ca082ad3db2ea55b112c3bcb9aa6980d21fb" translate="yes" xml:space="preserve">
          <source>To forsee the effect of an option there is an experimental function &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt;. It mangles the options &lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt; in the same way as &lt;code&gt;ssh:dameon&lt;/code&gt;, &lt;code&gt;ssh:connect&lt;/code&gt; and their friends does.</source>
          <target state="translated">옵션의 효과를 확인하기 위해 실험 기능 &lt;code&gt;ssh:chk_algos_opts(Opts)&lt;/code&gt; 있습니다. &lt;code&gt;ssh:dameon&lt;/code&gt; , &lt;code&gt;ssh:connect&lt;/code&gt; 와 같은 방식으로 &lt;code&gt;preferred_algorithms&lt;/code&gt; 및 &lt;code&gt;modify_algorithms&lt;/code&gt; 옵션을 엉망으로 만들며 친구와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6dec9bf90ad555856d14e7f8a0bcc0b6c2749f95" translate="yes" xml:space="preserve">
          <source>To fully understand how to configure the algorithms, it is essential to have a basic understanding of the SSH protocol and how OTP SSH app handles the corresponding items</source>
          <target state="translated">알고리즘 구성 방법을 완전히 이해하려면 SSH 프로토콜 및 OTP SSH 앱이 해당 항목을 처리하는 방법을 기본적으로 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="105f7930b5d0bd6dbe4b596f6e5e1aa3c7bab464" translate="yes" xml:space="preserve">
          <source>To gain performance by using the SMP emulator, your application &lt;strong&gt;must have more than one runnable Erlang process&lt;/strong&gt; most of the time. Otherwise, the Erlang emulator can still only run one Erlang process at the time, but you must still pay the overhead for locking. Although Erlang/OTP tries to reduce the locking overhead as much as possible, it will never become exactly zero.</source>
          <target state="translated">SMP 에뮬레이터를 사용하여 성능을 얻으려면 응용 프로그램에 대부분 &lt;strong&gt;실행 가능한 Erlang 프로세스가 두 개 이상 있어야합니다&lt;/strong&gt; . 그렇지 않으면, Erlang 에뮬레이터는 한 번에 하나의 Erlang 프로세스 만 실행할 수 있지만 잠금을 위해 여전히 오버 헤드를 지불해야합니다. Erlang / OTP는 잠금 오버 헤드를 최대한 줄이려고하지만 정확히 0이되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a634d1c3b542e6ded32efa3015b3577d54cdb1be" translate="yes" xml:space="preserve">
          <source>To get a long period the Xoroshiro928 generator from the &lt;code&gt;rand&lt;/code&gt; module is used as a counter (with period 2^928 - 1) and the generator states are scrambled through AES to create 58-bit pseudo random values.</source>
          <target state="translated">오랜 기간을 얻기 위해 &lt;code&gt;rand&lt;/code&gt; 모듈 의 Xoroshiro928 생성기 는 카운터로 사용되며 (기간 2 ^ 928-1 ) 생성기 상태는 AES를 통해 스크램블되어 58 비트 의사 난수 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2cbd28c322c2b7823640cb5d04b4000794237448" translate="yes" xml:space="preserve">
          <source>To get an overview of the concepts and operation of &lt;code&gt;gen_statem&lt;/code&gt;, do read the &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; in &lt;code&gt;OTP Design Principles&lt;/code&gt; which frequently links back to this reference manual to avoid containing detailed facts that may rot by age.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 의 개념과 작동에 대한 개요를 보려면 &lt;code&gt;OTP Design Principles&lt;/code&gt; 의 &lt;code&gt;gen_statem&amp;nbsp;Behaviour&lt;/code&gt; 을 읽고이 참조 매뉴얼에 자주 연결되어 연령별로 썩을 수있는 자세한 사실을 포함하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="01d79833ca3942345f121a64dcc3d55c1d0c6500" translate="yes" xml:space="preserve">
          <source>To get information about a PLT, use the following option:</source>
          <target state="translated">PLT에 대한 정보를 얻으려면 다음 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0e64c3c0e0f616c357b7610945241b260af495d" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템의 OS 단조로운 시간 소스에 대한 정보를 얻으려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1d5a6ae5a2a64c460f8242067e0ee912a4a4259" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템의 OS 모노 토닉 시간 소스에 대한 정보를 얻으려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d18259669e7618d7a319f9a564a8e6fb8e56985" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS system time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt; erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템의 OS 시스템 시간 소스에 대한 정보를 얻으려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt; erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1abf6bacf41753f2d4e4f3e187da0b6ca761589" translate="yes" xml:space="preserve">
          <source>To get information about the Erlang runtime system's source of OS system time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템의 OS 시스템 시간 소스에 대한 정보를 얻으려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_system_time_source&quot;&gt;erlang:system_info(os_system_time_source)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b209da3c80686caad1fbe93f4b143a75dbb826a1" translate="yes" xml:space="preserve">
          <source>To get log events on the same format as produced by &lt;code&gt;error_logger_tty_h&lt;/code&gt; and &lt;code&gt;error_logger_file_h&lt;/code&gt;, use the default formatter, &lt;code&gt;logger_formatter&lt;/code&gt;, with configuration parameter &lt;code&gt;legacy_header&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. This is the default configuration of the &lt;code&gt;default&lt;/code&gt; handler started by Kernel.</source>
          <target state="translated">&lt;code&gt;error_logger_tty_h&lt;/code&gt; 및 &lt;code&gt;error_logger_file_h&lt;/code&gt; 에 의해 생성 된 것과 동일한 형식으로 로그 이벤트를 얻으려면 구성 매개 변수 &lt;code&gt;legacy_header&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 기본 포맷터 &lt;code&gt;logger_formatter&lt;/code&gt; 를 사용하십시오 . 이것은 커널이 시작한 &lt;code&gt;default&lt;/code&gt; 핸들러 의 기본 구성입니다 .</target>
        </trans-unit>
        <trans-unit id="51cf577b00fc8216155e456c21c9c0183f56b93f" translate="yes" xml:space="preserve">
          <source>To get started, the least you need to do is to start a tracer with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;, and set the required trace flags on the processes you want to trace with &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시작하려면 최소한 &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; 로 추적 프로그램을 시작하고 &lt;code&gt;&lt;a href=&quot;ttb#p-2&quot;&gt;ttb:p/2&lt;/a&gt;&lt;/code&gt; 로 추적하려는 프로세스에서 필요한 추적 플래그를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc4b00be659493772c3eb90fac788afdac82d1da" translate="yes" xml:space="preserve">
          <source>To get started, you should read about the &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; data type; the main constructor functions: &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt;; and the main layout function &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시작하려면 &lt;code&gt;&lt;a href=&quot;#type-document&quot;&gt;document()&lt;/a&gt;&lt;/code&gt; 데이터 형식에 대해 읽어야 합니다. 주요 생성자 함수 : &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#above-2&quot;&gt;above/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#beside-2&quot;&gt;beside/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#nest-2&quot;&gt;nest/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#sep-1&quot;&gt;sep/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par/2&lt;/a&gt;&lt;/code&gt; ; 메인 레이아웃 기능 &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80a72b65fea86a98c851ba990e410aac5fd9f4fb" translate="yes" xml:space="preserve">
          <source>To get the consistent behavior of killing ports when the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; unloads, use driver option &lt;code&gt;kill_ports&lt;/code&gt; when loading the driver instead.</source>
          <target state="translated">마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 언로드 할 때 포트를 &lt;code&gt;kill_ports&lt;/code&gt; 하는 일관된 동작을 얻으려면 대신 드라이버를로드 할 때 드라이버 옵션 kill_ports를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="97de7a8dc23625a08e5a773780e14b0a5c65aae2" translate="yes" xml:space="preserve">
          <source>To get the output printed to a file, use option &lt;code&gt;--output_file&lt;/code&gt;.</source>
          <target state="translated">출력을 파일로 인쇄하려면 &lt;code&gt;--output_file&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f76cd184a6e7c8d866643b588a8bdefe5b9edef" translate="yes" xml:space="preserve">
          <source>To get trace messages containing return values from functions, use the &lt;code&gt;{return_trace}&lt;/code&gt; match specification action instead.</source>
          <target state="translated">함수의 리턴 값이 포함 된 추적 메시지를 얻으려면 대신 &lt;code&gt;{return_trace}&lt;/code&gt; 일치 스펙 조치를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1820d2a1d5bd22bcad0e15651513a749cd0ea7ac" translate="yes" xml:space="preserve">
          <source>To give an indication on the possible performance gain using the specialized decodes, some measures have been performed. The relative figures in the outcome between selective, exclusive, and complete decode (the normal case) depend on the structure of the type, the size of the message, and on what level the selective and exclusive decodes are specified.</source>
          <target state="translated">특수화 된 디코드를 사용하여 가능한 성능 이득을 표시하기 위해 일부 측정이 수행되었습니다. 선택적, 배타적 및 완전한 디코딩 (일반적인 경우) 사이의 결과에서 상대적인 수치는 유형의 구조, 메시지의 크기 및 선택적 및 독점적 디코드가 지정된 레벨에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dcc0da7706c1bd437120fd6114754c61c3ba2f69" translate="yes" xml:space="preserve">
          <source>To give some background to the rest of this document, here follows a quick overview of how instructions are loaded.</source>
          <target state="translated">이 문서의 나머지 부분에 대한 배경 지식을 제공하기 위해 다음은 지침이로드되는 방법에 대한 간략한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="a6bae83c7d1a2e1a895f2a1aac969ea5d6956ad8" translate="yes" xml:space="preserve">
          <source>To hack the erlang libraries, you simply do a &lt;code&gt;make opt&lt;/code&gt; in the specific &quot;applications&quot; directory, like:</source>
          <target state="translated">erlang 라이브러리를 해킹하려면 다음 과 같이 특정 &quot;applications&quot;디렉토리에서 간단히 &lt;code&gt;make opt&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="25afbf964210cbb860d968d22f8aec5dd76f1cff" translate="yes" xml:space="preserve">
          <source>To handle Unicode characters in Erlang, a common representation in both lists and binaries is needed. EEP (10) and the subsequent initial implementation in Erlang/OTP R13A settled a standard representation of Unicode characters in Erlang.</source>
          <target state="translated">Erlang에서 유니 코드 문자를 처리하려면 목록과 이진 모두에서 공통된 표현이 필요합니다. Erlang / OTP R13A의 EEP (10) 및 후속 초기 구현은 Erlang에서 유니 코드 문자의 표준 표현을 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="aff10dfbf070c41d255dec1932b739bd7e3bde90" translate="yes" xml:space="preserve">
          <source>To harbor real time characteristics, searching the pool is limited. We only inspect a limited number of carriers. If none of those carriers had a free block large enough to satisfy the allocation request, the search will fail. A carrier in the pool can also be BUSY if another thread is currently doing block deallocation work on the carrier. A BUSY carrier will also be skipped by the search as it cannot satisfy the request. The pool is lock-free and we do not want to block, waiting for the other thread to finish.</source>
          <target state="translated">실시간 특성을 유지하기 위해 수영장 검색이 제한됩니다. 제한된 수의 운송 업체 만 검사합니다. 이러한 캐리어 중 할당 요청을 충족 할만큼 큰 여유 블록이없는 경우 검색이 실패합니다. 다른 스레드가 현재 캐리어에서 블록 할당 해제 작업을 수행중인 경우 풀의 캐리어도 BUSY 일 수 있습니다. BUSY 반송파도 요청을 충족 할 수 없으므로 검색에서 건너 뜁니다. 풀은 잠금이 없으며 다른 스레드가 완료되기를 기다리면서 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="342c993bd4e7155816205341dd7a1c3953a4f6f8" translate="yes" xml:space="preserve">
          <source>To have &lt;code&gt;Common Test&lt;/code&gt; encrypt a specified file using function &lt;code&gt;DES3&lt;/code&gt; in application &lt;code&gt;Crypto&lt;/code&gt;, call &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; The encrypted file can then be used as a regular configuration file in combination with other encrypted files or normal text files. However, the key for decrypting the configuration file must be provided when running the test. This can be done with flag/option &lt;code&gt;decrypt_key&lt;/code&gt; or &lt;code&gt;decrypt_file&lt;/code&gt;, or a key file in a predefined location.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 가 &lt;code&gt;Crypto&lt;/code&gt; 애플리케이션에서 함수 &lt;code&gt;DES3&lt;/code&gt; 을 사용하여 지정된 파일을 암호화하도록 하려면 &lt;code&gt;&lt;a href=&quot;ct#encrypt_config_file-2&quot;&gt;ct:encrypt_config_file/2,3&lt;/a&gt;&lt;/code&gt; 을 호출하십시오 . 그런 다음 암호화 된 파일을 다른 암호화 된 파일 또는 일반 텍스트 파일과 함께 일반 구성 파일로 사용할 수 있습니다. 그러나 테스트를 실행할 때 구성 파일의 암호 해독 키가 제공되어야합니다. 이는 플래그 / 옵션 &lt;code&gt;decrypt_key&lt;/code&gt; 또는 &lt;code&gt;decrypt_file&lt;/code&gt; 또는 사전 정의 된 위치의 키 파일을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85cad9012ac3a0f7585ee9eb3d18653bcfe48b6e" translate="yes" xml:space="preserve">
          <source>To have an effect, a breakpoint must be set at an &lt;strong&gt;executable line&lt;/strong&gt;, which is a line of code containing an executable expression such as a matching or a function call. A blank line or a line containing a comment, function head, or pattern in a &lt;code&gt;case&lt;/code&gt; statement or &lt;code&gt;receive&lt;/code&gt; statement is not executable.</source>
          <target state="translated">효과를 얻으려면 &lt;strong&gt;실행 라인에&lt;/strong&gt; 중단 점을 설정해야합니다. &lt;strong&gt;실행 라인&lt;/strong&gt; 은 일치 또는 함수 호출과 같은 실행 가능 표현식을 포함하는 코드 라인입니다. &lt;code&gt;case&lt;/code&gt; 문이나 &lt;code&gt;receive&lt;/code&gt; 문에 주석, 함수 헤드 또는 패턴이 포함 된 빈 줄이나 줄 은 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3526ad99fb939a42fd2ac8a732fa13795a7fc7c2" translate="yes" xml:space="preserve">
          <source>To have effect, this function is to be called from &lt;code&gt;init_per_suite/1&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;) before any tests are performed.</source>
          <target state="translated">적용하려면 테스트를 수행하기 전에 &lt;code&gt;init_per_suite/1&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; 참조 ) 에서이 함수를 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="2708c75c960cc2ecf9c829562c09567eee5b452b" translate="yes" xml:space="preserve">
          <source>To help adapt configuration data to a test suite (or test case) and improve readability.</source>
          <target state="translated">구성 데이터를 테스트 스위트 (또는 테스트 케이스)에 적용하고 가독성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="030c50a15bdc06f6e3b51217f3e73b7d2d5a9ad8" translate="yes" xml:space="preserve">
          <source>To help setup the environment, there is a bat file, &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt;, that set's the appropriate environment for a Windows command prompt. This is not appropriate for bash, so you'll need to convert it to bash-style environments by editing your &lt;code&gt;.bash_profile&lt;/code&gt;. In my case, where the SDK is installed in the default directory and &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; is &lt;code&gt;C:\Program Files&lt;/code&gt;, the commands for setting up a 32bit build environment (on a 64bit or 32bit machine) look like this (in Cygwin):</source>
          <target state="translated">환경 설정을 돕기 위해 Windows 명령 프롬프트에 적합한 환경 인 bat 파일 &lt;code&gt;%PROGRAMFILES%\Mirosoft Visual Studio 12.0\VC\vcvarsall.bat&lt;/code&gt; 있습니다. 이것은 bash에 적합하지 않으므로 &lt;code&gt;.bash_profile&lt;/code&gt; 을 편집하여 bash 스타일 환경으로 변환해야합니다 . 필자의 경우 SDK가 기본 디렉토리에 설치되어 있고 &lt;code&gt;%PROGRAMFILES%&lt;/code&gt; 가 &lt;code&gt;C:\Program Files&lt;/code&gt; 인 경우 32 비트 빌드 환경 (64 비트 또는 32 비트 시스템에서)을 설정하는 명령은 다음과 같습니다 (Cygwin에서).</target>
        </trans-unit>
        <trans-unit id="8c68f332c622b4567e9853c18f5bd4711a371dc7" translate="yes" xml:space="preserve">
          <source>To help with debugging, EUnit defines several useful macros for printing messages directly to the console (rather than to the standard output). Furthermore, these macros all use the same basic format, which includes the file and line number where they occur, making it possible in some development environments (e.g., when running Erlang in an Emacs buffer) to simply click on the message and jump directly to the corresponding line in the code.</source>
          <target state="translated">디버깅을 돕기 위해 EUnit은 메시지를 표준 출력이 아닌 콘솔로 직접 인쇄하는 데 유용한 몇 가지 매크로를 정의합니다. 또한이 매크로는 모두 동일한 기본 형식을 사용합니다. 여기에는 파일과 줄 번호가 포함되어 있으며 일부 개발 환경 (예 : Emacs 버퍼에서 Erlang을 실행할 때)에서 간단히 메시지를 클릭하고 바로 이동할 수 있습니다. 코드에서 해당 라인.</target>
        </trans-unit>
        <trans-unit id="f2bf4f85026136c5e9d89c67190507dcee8f99df" translate="yes" xml:space="preserve">
          <source>To identify connections (described later).</source>
          <target state="translated">연결을 식별합니다 (나중에 설명).</target>
        </trans-unit>
        <trans-unit id="a3a37007760548419af74fbda4faaad4a58f472b" translate="yes" xml:space="preserve">
          <source>To illustrate the interoperability principles, C programs running in a UNIX environment have been used. It is assumed that you have enough knowledge to apply these principles to the relevant programming languages and platforms.</source>
          <target state="translated">상호 운용성 원칙을 설명하기 위해 UNIX 환경에서 실행되는 C 프로그램이 사용되었습니다. 이러한 원칙을 관련 프로그래밍 언어 및 플랫폼에 적용하기에 충분한 지식이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e25970fd2bf365203fb3a3002e19cdcdbb27a907" translate="yes" xml:space="preserve">
          <source>To illustrate this we make up an example where the buttons instead generate down and up (press and release) events, and the lock responds to an up event only after the corresponding down event.</source>
          <target state="translated">이를 설명하기 위해 버튼 대신 다운 및 업 (누르기 및 놓기) 이벤트를 생성하고 해당 다운 이벤트 이후에만 잠금이 업 이벤트에 응답하는 예를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="272786a4055a77679447504bd8a8b3f74b9c24f1" translate="yes" xml:space="preserve">
          <source>To illustrate this, do &lt;strong&gt;not&lt;/strong&gt; write as follows:</source>
          <target state="translated">이를 설명하기 위해 다음과 같이 쓰지 &lt;strong&gt;마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="968314d317898e187c56ec55b8af76cc4a65eba4" translate="yes" xml:space="preserve">
          <source>To illustrate this, suppose we extend our Mnesia &lt;code&gt;empTable&lt;/code&gt; with one internal column. We create it as before, but with an arity of 4, by adding another attribute.</source>
          <target state="translated">이를 설명하기 위해 Mnesia &lt;code&gt;empTable&lt;/code&gt; 을 하나의 내부 열로 확장한다고 가정하십시오 . 이전과 동일하지만 다른 속성을 추가하여 arity 4로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a162dc5a66ab8801f7f0ce0a26a9e8e3d6ef7a06" translate="yes" xml:space="preserve">
          <source>To illustrate this, the messenger example from the previous section is divided into the following five files:</source>
          <target state="translated">이를 설명하기 위해 이전 섹션의 메신저 예제는 다음 5 개의 파일로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="6bb28103d410bbb4345e8969c22657c7565cfc3a" translate="yes" xml:space="preserve">
          <source>To implement a new carrier for the Erlang distribution, the main steps are as follows.</source>
          <target state="translated">Erlang 배포를위한 새로운 이동 통신사를 구현하기위한 주요 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="279afddbfce41bfb8c90b18f6a7106e81cad960d" translate="yes" xml:space="preserve">
          <source>To implement a user-defined behaviour, write code similar to code for a special process, but call functions in a callback module for handling specific tasks.</source>
          <target state="translated">사용자 정의 동작을 구현하려면 특수 프로세스의 코드와 유사한 코드를 작성하지만 특정 작업을 처리하기 위해 콜백 모듈에서 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="bbcff46d509465f1d50c1bdbf6bb8561780d4955" translate="yes" xml:space="preserve">
          <source>To implement an agent, the programmer writes instrumentation functions for the variables and the tables in the MIBs that the agent is going to support. A running prototype which handles &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, and &lt;code&gt;get-next&lt;/code&gt; can be created without any programming.</source>
          <target state="translated">에이전트를 구현하기 위해 프로그래머는 에이전트가 지원할 MIB의 변수 및 테이블에 대한 계측 기능을 작성합니다. 프로그래밍없이 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;get-next&lt;/code&gt; 를 처리하는 실행중인 프로토 타입을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96a8f8e3de715f80a2e00a49b8a93d3352e72e52" translate="yes" xml:space="preserve">
          <source>To implement your own node discovery module you have to write your own EPMD module. The &lt;code&gt;EPMD module&lt;/code&gt; is responsible for providing the location of another node. The distribution modules (&lt;code&gt;inet_tcp_dist&lt;/code&gt;/&lt;code&gt;inet_tls_dist&lt;/code&gt;) call the EPMD module to get the IP address and port of the other node. The EPMD module that is part of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix process to get the port of another node. The EPMD unix process does this by connecting to the other node on a well-known port, port 4369.</source>
          <target state="translated">고유 한 노드 검색 모듈을 구현하려면 고유 한 EPMD 모듈을 작성해야합니다. &lt;code&gt;EPMD module&lt;/code&gt; 다른 노드의 위치를 제공 할 책임이있다. 배포 모듈 ( &lt;code&gt;inet_tcp_dist&lt;/code&gt; / &lt;code&gt;inet_tls_dist&lt;/code&gt; )은 EPMD 모듈을 호출하여 다른 노드의 IP 주소와 포트를 가져옵니다. Erlang / OTP의 일부인 EPMD 모듈은 DNS를 사용하여 호스트 이름을 확인하고 EPMD 유닉스 프로세스를 사용하여 다른 노드의 포트를 가져옵니다. EPMD 유닉스 프로세스는 잘 알려진 포트 4369의 다른 노드에 연결하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="330de1ad3973af593bbd7d81e03664889a42ea4e" translate="yes" xml:space="preserve">
          <source>To implement your own service discovery module you have to write your own EPMD module. The &lt;code&gt;EPMD module&lt;/code&gt; is responsible for providing the location of another node. The distribution modules (&lt;code&gt;inet_tcp_dist&lt;/code&gt;/&lt;code&gt;inet_tls_dist&lt;/code&gt;) call the EPMD module to get the IP address and port of the other node. The EPMD module that is part of Erlang/OTP will resolve the hostname using DNS and uses the EPMD unix process to get the port of another node. The EPMD unix process does this by connecting to the other node on a well-known port, port 4369.</source>
          <target state="translated">자체 서비스 검색 모듈을 구현하려면 자체 EPMD 모듈을 작성해야합니다. &lt;code&gt;EPMD module&lt;/code&gt; 다른 노드의 위치를 제공 할 책임이있다. 배포 모듈 ( &lt;code&gt;inet_tcp_dist&lt;/code&gt; / &lt;code&gt;inet_tls_dist&lt;/code&gt; )은 EPMD 모듈을 호출하여 다른 노드의 IP 주소와 포트를 가져옵니다. Erlang / OTP의 일부인 EPMD 모듈은 DNS를 사용하여 호스트 이름을 확인하고 EPMD unix 프로세스를 사용하여 다른 노드의 포트를 가져옵니다. EPMD unix 프로세스는 잘 알려진 포트 인 포트 4369의 다른 노드에 연결하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="79134b2c4e38df5717fe5011c4463fea24abb3c3" translate="yes" xml:space="preserve">
          <source>To improve performance when analysing cover results it is possible to do multiple calls to &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; at once. You can also use the &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; convenience function.</source>
          <target state="translated">표지 결과를 분석 할 때 성능을 향상시키기 위해 여러 번의 호출을 수행하여 &lt;code&gt;&lt;a href=&quot;cover#analyse-1&quot;&gt;analyse&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;cover#analyse_to_file-1&quot;&gt;analyse_to_file&lt;/a&gt;&lt;/code&gt; 을 한 번에 수행 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;cover#async_analyse_to_file-1&quot;&gt;async_analyse_to_file&lt;/a&gt;&lt;/code&gt; 편의 기능을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d70eada12ec2a8f92aa033daf56e896f20d26d8f" translate="yes" xml:space="preserve">
          <source>To include other nodes in the coverage analysis, use &lt;code&gt;start/1&lt;/code&gt;. All cover compiled modules will then be loaded on all nodes, and data from all nodes will be summed up when analysing. For simplicity this example only involves the current node.</source>
          <target state="translated">적용 범위 분석에 다른 노드를 포함 시키려면 &lt;code&gt;start/1&lt;/code&gt; 을 사용하십시오 . 그러면 모든 컴파일 된 모듈이 모든 노드에로드되고 분석시 모든 노드의 데이터가 요약됩니다. 간단히하기 위해이 예제에는 현재 노드 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a5478a26ee1ac879ac54fc75bcb8b9a9f083c3ec" translate="yes" xml:space="preserve">
          <source>To include private shell commands, define them in a module &lt;code&gt;user_default&lt;/code&gt; and add the following argument as the first line in the &lt;code&gt;.erlang&lt;/code&gt; file:</source>
          <target state="translated">개인 쉘 명령을 포함하려면 &lt;code&gt;user_default&lt;/code&gt; 모듈에서 명령을 정의하고 &lt;code&gt;.erlang&lt;/code&gt; 파일 의 첫 번째 행으로 다음 인수를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="203ccb7faa11c702e1202041c2be3ef44596552b" translate="yes" xml:space="preserve">
          <source>To initialize the database, execute the following code on one of the two nodes:</source>
          <target state="translated">데이터베이스를 초기화하려면 두 노드 중 하나에서 다음 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="026d2b6accddb0e61f3eda91aff0268e88788933" translate="yes" xml:space="preserve">
          <source>To insert an &amp;amp; or a \ in the result, precede it with a \. Notice that Erlang already gives a special meaning to \ in literal strings, so a single \ must be written as &lt;code&gt;&quot;\\&quot;&lt;/code&gt; and therefore a double \ as &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;.</source>
          <target state="translated">결과에 &amp;amp; 또는 \를 삽입하려면 앞에 \를 붙입니다. Erlang은 이미 리터럴 문자열에서 \에 특별한 의미를 부여하므로 단일 \는 &lt;code&gt;&quot;\\&quot;&lt;/code&gt; 로 작성되어야 하고 따라서 이중 \는 &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c018c38250aabfbb51e23ce90651060a950f1b96" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">시작 인수를 포함하여 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#installing&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 를 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="44e25aea36620d24d591fc0a361139dfb3c4b11c" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; including start arguments.</source>
          <target state="translated">시작 인수를 포함하여 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 를 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="c9c7864f1c5249a35705cc8dcabba48f995e8ae5" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;event_handler_chapter#event_handling&quot;&gt;event handlers&lt;/a&gt;&lt;/code&gt; 를 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="025cdabf9ad94f75800cda5f1e9747d7ccc0323d" translate="yes" xml:space="preserve">
          <source>To install the CSS file (&lt;code&gt;Common Test&lt;/code&gt; inlines the definition in the HTML code), the file name can be provided when executing &lt;code&gt;ct_run&lt;/code&gt;.</source>
          <target state="translated">CSS 파일을 설치하기 위해 ( &lt;code&gt;Common Test&lt;/code&gt; 는 HTML 코드에서 정의를 인라인합니다) &lt;code&gt;ct_run&lt;/code&gt; 을 실행할 때 파일 이름을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deb96dbc16afa611fcde38057919ecf9cc751bfa" translate="yes" xml:space="preserve">
          <source>To install the new version of the release in runtime, the &lt;strong&gt;release handler&lt;/strong&gt; is used. This is a process belonging to the SASL application, which handles unpacking, installation, and removal of release packages. It is communicated through the &lt;code&gt;release_handler&lt;/code&gt; module. For details, see the &lt;code&gt;release_handler(3)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">런타임에 새 버전의 릴리스를 설치하기 위해 &lt;strong&gt;릴리스 핸들러&lt;/strong&gt; 가 사용됩니다. 이는 릴리스 패키지의 포장 풀기, 설치 및 제거를 처리하는 SASL 응용 프로그램에 속하는 프로세스입니다. &lt;code&gt;release_handler&lt;/code&gt; 모듈을 통해 통신됩니다 . 자세한 내용 은 SASL 의 &lt;code&gt;release_handler(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73c1bf364dc283d1176ab1d289c500fd685a5dab" translate="yes" xml:space="preserve">
          <source>To interpret all displayed modules in the chosen directory, click &lt;strong&gt;All&lt;/strong&gt;.</source>
          <target state="translated">선택한 디렉토리에있는 모든 디스플레이 모듈을 해석하려면 클릭 &lt;strong&gt;모두&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3292879da2b34dcadcc9f9ce0648b935ba4e7f92" translate="yes" xml:space="preserve">
          <source>To interrupt the runtime system or the shell process (depending on what has been specified with system flag &lt;code&gt;+B&lt;/code&gt;), use &lt;code&gt;Ctrl-Break&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이나 쉘 프로세스를 중단하려면 (시스템 플래그로 지정 된 내용에 따라 &lt;code&gt;+B&lt;/code&gt; )를 사용 &lt;code&gt;Ctrl-Break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d9005b012d1045c52922820e7322a9dfa02e1f6" translate="yes" xml:space="preserve">
          <source>To investigate what Erlang thinks about the terminal, the call &lt;code&gt;io:getopts()&lt;/code&gt; can be used when the shell is started:</source>
          <target state="translated">Erlang이 터미널에 대해 어떻게 생각하는지 조사하기 위해 쉘이 시작될 때 &lt;code&gt;io:getopts()&lt;/code&gt; 호출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a6e867a167f9a4a740ad92d9902eefad28664c" translate="yes" xml:space="preserve">
          <source>To just run a shell on a remote machine, there are functions that bundles the needed three steps needed into one: &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt;. Similarily, to just open an sftp (file transfer) connection to a remote machine, the simplest way is to use &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원격 시스템에서 쉘을 실행하기 위해 필요한 세 단계를 하나로 묶는 기능이 있습니다 : &lt;code&gt;&lt;a href=&quot;#shell-1&quot;&gt;shell/1,2,3&lt;/a&gt;&lt;/code&gt; . 마찬가지로 원격 시스템에 대한 sftp (파일 전송) 연결을 여는 가장 간단한 방법은 &lt;code&gt;&lt;a href=&quot;ssh_sftp#start_channel-1&quot;&gt;ssh_sftp:start_channel/1,2,3&lt;/a&gt;&lt;/code&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9f2634ff9e5775d30c933d162e116bcf2daeb2ae" translate="yes" xml:space="preserve">
          <source>To learn what sequential tracing is and how it can be used, see the Reference Manual for &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">순차 추적이 무엇이고 어떻게 사용하는지 배우려면 &lt;code&gt;seq_trace&lt;/code&gt; 참조 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea8c91f9201e13f8a7af2544d0b6f79400981a45" translate="yes" xml:space="preserve">
          <source>To let the test suite continue on executing, return the configuration list that you want the test to use as the result.</source>
          <target state="translated">테스트 스위트가 계속 실행되도록하려면 테스트로 사용할 구성 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="d62397eee2357878fc975aeb84771b8bc2c06ea8" translate="yes" xml:space="preserve">
          <source>To limit the shutdown time, the time &lt;code&gt;init&lt;/code&gt; is allowed to spend taking down applications, command-line flag &lt;code&gt;-shutdown_time&lt;/code&gt; is to be used.</source>
          <target state="translated">종료 시간을 제한 하기 위해 &lt;code&gt;init&lt;/code&gt; 가 응용 프로그램을 종료하는 데 소요되는 시간 은 명령 행 플래그 &lt;code&gt;-shutdown_time&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31df00fd05b2b4e7d3ede7fd0ed32c7595a82e9c" translate="yes" xml:space="preserve">
          <source>To list the contents of a configuration file, use &lt;code&gt;list_config/1&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 내용을 나열하려면 &lt;code&gt;list_config/1&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5d893e9a4aaa1eb2af17414123d7e17dc6fd363" translate="yes" xml:space="preserve">
          <source>To listen on both SCTP and TCP, define one transport for each.</source>
          <target state="translated">SCTP와 TCP를 모두 청취하려면 각각에 대해 하나의 전송을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="11429257331a6c9848f977d465c2a19dfb56ed6e" translate="yes" xml:space="preserve">
          <source>To look for documentation for a module name example, a tool should:</source>
          <target state="translated">모듈 이름 예제에 대한 문서를 찾으려면 도구는 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="07a54ad0b2a1bb175cf95b725d86a06fc8b48cbd" translate="yes" xml:space="preserve">
          <source>To look up one of the names:</source>
          <target state="translated">이름 중 하나를 찾으려면</target>
        </trans-unit>
        <trans-unit id="8a56bbc15981f1188aa9ff7ef71388335fe7c6a6" translate="yes" xml:space="preserve">
          <source>To make a debug build of the emulator, you need to recompile both &lt;code&gt;beam.dll&lt;/code&gt; (the actual runtime system) and &lt;code&gt;erlexec.dll&lt;/code&gt;. Do like this</source>
          <target state="translated">에뮬레이터의 디버그 빌드를 만들려면 &lt;code&gt;beam.dll&lt;/code&gt; (실제 런타임 시스템)과 &lt;code&gt;erlexec.dll&lt;/code&gt; 을 모두 다시 컴파일해야합니다 . 이처럼</target>
        </trans-unit>
        <trans-unit id="038da331fd12e331816c4b78d58a10e2cc57ca86" translate="yes" xml:space="preserve">
          <source>To make it clearer exactly what code the warnings refer to, the warnings in the following examples are inserted as comments after the clause they refer to, for example:</source>
          <target state="translated">경고가 참조하는 코드를보다 명확하게하기 위해 다음 예의 경고는 예를 들어 참조 절 뒤에 주석으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3d3828bd3e752b691c02502aca9ad44d8387dc" translate="yes" xml:space="preserve">
          <source>To make it easier to manage breakpoints without single threaded mode a redesign of the breakpoint mechanism has been made. The old &quot;breakpoint wheel&quot; data structure was a circular double-linked list of breakpoints for each instrumented function. It was invented before the SMP emulator. To support it in the SMP emulator, is was essentially expanded to one breakpoint wheel per scheduler. As more breakpoint types have been added, the implementation have become messy and hard to understand and maintain.</source>
          <target state="translated">단일 스레드 모드없이 중단 점을 더 쉽게 관리 할 수 ​​있도록 중단 점 메커니즘을 다시 설계했습니다. 이전 &quot;중단 점 휠&quot;데이터 구조는 각 계측 기능에 대한 중단 점의 순환 이중 링크 목록이었습니다. SMP 에뮬레이터 이전에 발명되었습니다. SMP 에뮬레이터에서 지원하기 위해 기본적으로 스케줄러 당 하나의 중단 점 휠로 확장되었습니다. 중단 점 유형이 추가됨에 따라 구현이 지저분 해지고 이해 및 유지 관리가 어려워졌습니다.</target>
        </trans-unit>
        <trans-unit id="cd2982d9a90975bc47a9c7a7530d4f0cbaa3f7f2" translate="yes" xml:space="preserve">
          <source>To make it easier to understand this section, some terms are defined. This is a mix of our own terminology (Erlang/OS system time, Erlang/OS monotonic time, time warp) and globally accepted terminology.</source>
          <target state="translated">이 섹션을보다 쉽게 ​​이해할 수 있도록 일부 용어가 정의되어 있습니다. 이것은 자체 용어 (Erlang / OS 시스템 시간, Erlang / OS 단조 시간, 시간 왜곡) 및 전 세계적으로 사용되는 용어가 혼합 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="2921bab0b743bbb6198162ca9c596c8d4e059429" translate="yes" xml:space="preserve">
          <source>To make the descriptions simpler, we first list some definitions:</source>
          <target state="translated">설명을 단순화하기 위해 먼저 몇 가지 정의를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="9c4714caed05dab02e49dd183a4006e068e3199f" translate="yes" xml:space="preserve">
          <source>To make the example runnable, we start implementing the reading and writing of the data to/from the ETS table. First function &lt;code&gt;put_chars/3&lt;/code&gt;:</source>
          <target state="translated">예제를 실행 가능하게 만들기 위해 ETS 테이블에서 데이터를 읽고 쓰는 작업을 시작합니다. 첫 번째 함수 &lt;code&gt;put_chars/3&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="632f6f737e1f0ad548a43d9ad64573eca55f152d" translate="yes" xml:space="preserve">
          <source>To make the process change code, send the message &lt;code&gt;code_switch&lt;/code&gt; to it. The process then makes a fully qualified call to &lt;code&gt;m:loop()&lt;/code&gt; and changes to current code. Notice that &lt;code&gt;m:loop/0&lt;/code&gt; must be exported.</source>
          <target state="translated">프로세스 변경 코드를 작성하려면 &lt;code&gt;code_switch&lt;/code&gt; 메시지를 보내 십시오. 그런 다음 프로세스는 &lt;code&gt;m:loop()&lt;/code&gt; 를 완전히 호출 하고 현재 코드로 변경합니다. 알 &lt;code&gt;m:loop/0&lt;/code&gt; 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="e177c9389e3d182722e09e0544b0a24268ff84e3" translate="yes" xml:space="preserve">
          <source>To make the test fair, each new test run is to run in its own, newly created Erlang process. Otherwise, if all tests run in the same process, the later tests start out with larger heap sizes and therefore probably do fewer garbage collections. Also consider restarting the Erlang emulator between each test.</source>
          <target state="translated">테스트를 공정하게하기 위해 각각의 새로운 테스트 실행은 새로 생성 된 자체 Erlang 프로세스에서 실행됩니다. 그렇지 않으면 모든 테스트가 동일한 프로세스에서 실행되는 경우 이후 테스트는 더 큰 힙 크기로 시작되므로 가비지 콜렉션이 더 적을 수 있습니다. 또한 각 테스트간에 Erlang 에뮬레이터를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="120ecf4e057892d6019b012a82abcf83ac9ffd85" translate="yes" xml:space="preserve">
          <source>To make this happen the megaco stack has to be configured:</source>
          <target state="translated">이를 위해 megaco 스택을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="13169d7b871948e1e9a9c4457e119e83fe7939d4" translate="yes" xml:space="preserve">
          <source>To manipulate services, the logged on user is to have administrator privileges on the machine. The Erlang machine itself is (default) run as the local administrator. This can be changed with the Services applet in Windows.</source>
          <target state="translated">서비스를 조작하려면 로그온 한 사용자가 시스템에 대한 관리자 권한을 가지고 있어야합니다. Erlang 시스템 자체는 (기본) 로컬 관리자로 실행됩니다. 이것은 Windows의 서비스 애플릿으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="330fd48fdffeb44ebc089750d09d688535c7db34" translate="yes" xml:space="preserve">
          <source>To manipulate the Erlang services easily, put the &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; directory in the path instead of &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt;. The &lt;code&gt;erlsrv&lt;/code&gt; program can be found from inside Erlang by using the &lt;code&gt;os:find_executable/1&lt;/code&gt; Erlang function.</source>
          <target state="translated">Erlang 서비스를 쉽게 조작하려면 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\bin&lt;/code&gt; 대신 &lt;code&gt;&amp;lt;erlang_root&amp;gt;\erts-&amp;lt;version&amp;gt;\bin&lt;/code&gt; 디렉토리를 경로에 두십시오 . &lt;code&gt;erlsrv&lt;/code&gt; 의 프로그램은 이용 얼랑 내부에서 발견 될 수 &lt;code&gt;os:find_executable/1&lt;/code&gt; 얼랑 기능.</target>
        </trans-unit>
        <trans-unit id="7b0e537b9e6e88eafa3eeae7f7a02f18b4e1430f" translate="yes" xml:space="preserve">
          <source>To manipulate the table we implement the following utility functions:</source>
          <target state="translated">테이블을 조작하기 위해 다음 유틸리티 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ffb58770364e94bc236d60f5ec83adb55db02d32" translate="yes" xml:space="preserve">
          <source>To match a variable number of arguments we need to use the special operand type &lt;code&gt;*&lt;/code&gt; like this:</source>
          <target state="translated">가변 개수의 인수를 일치 시키려면 다음과 같은 특수 피연산자 유형 &lt;code&gt;*&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="af1c290996a023ca9ee9b2902b6c1dc2a988f5c7" translate="yes" xml:space="preserve">
          <source>To match out the rest of a binary, specify a binary field without size:</source>
          <target state="translated">나머지 이진을 일치 시키려면 크기가없는 이진 필드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="50f6c59cd17dfe4a6719c66fb938f13bf13c9cd5" translate="yes" xml:space="preserve">
          <source>To match out the rest of a bitstring, specify a field without size:</source>
          <target state="translated">나머지 비트 열을 일치 시키려면 크기가없는 필드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3c74e2148772d016b06b50e91a05f48c85c5db24" translate="yes" xml:space="preserve">
          <source>To merge all wrap logs from two nodes:</source>
          <target state="translated">두 노드의 모든 랩 로그를 병합하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9118cf58e561adea3d50918592e59eb25b8578d5" translate="yes" xml:space="preserve">
          <source>To modify the daemon start example above to reject one-time execution requests, we change &lt;code&gt;&lt;a href=&quot;#start-daemon-step3&quot;&gt;Step 3&lt;/a&gt;&lt;/code&gt; by adding the option &lt;code&gt;{exec, disabled}&lt;/code&gt; to:</source>
          <target state="translated">일회성 실행 요청을 거부하도록 위의 데몬 시작 예제를 수정하려면 &lt;code&gt;{exec, disabled}&lt;/code&gt; 옵션을 다음과 같이 추가하여 &lt;code&gt;&lt;a href=&quot;#start-daemon-step3&quot;&gt;Step 3&lt;/a&gt;&lt;/code&gt; 를 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="ca89d09befb2046f7583acd51b179a73eb3778d1" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt; update_handler_config/2&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1 &lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">기존 구성, 사용 수정하려면 &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt; update_handler_config/2&lt;/a&gt;&lt;/code&gt; , 또는, 더 복잡한 병합이 필요한 경우와 현재 구성 읽어 &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1 &lt;/a&gt;&lt;/code&gt; ,이 기능을 가진 새로운 구성 등을 쓰기 전에 병합을한다.</target>
        </trans-unit>
        <trans-unit id="6ec3ba5252c54ac879e329c670bb92c1a4f26979" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">기존 구성, 사용 수정하려면 &lt;code&gt;&lt;a href=&quot;#update_handler_config-2&quot;&gt;update_handler_config/2&lt;/a&gt;&lt;/code&gt; , 또는, 더 복잡한 병합이 필요한 경우와 현재 구성 읽어 &lt;code&gt;&lt;a href=&quot;#get_handler_config-1&quot;&gt;get_handler_config/1&lt;/a&gt;&lt;/code&gt; ,이 기능을 가진 새로운 구성 등을 쓰기 전에 병합을한다.</target>
        </trans-unit>
        <trans-unit id="d0497742c0aa1174886ab877594f8e6b707bfc8f" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt; update_primary_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0 &lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">기존 구성을 수정하려면 &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt; update_primary_config/1&lt;/a&gt;&lt;/code&gt; 을 사용 하거나 더 복잡한 병합이 필요한 경우 &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0 &lt;/a&gt;&lt;/code&gt; 으로 현재 구성을 읽은 다음이 함수를 사용하여 새 구성을 다시 쓰기 전에 병합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7cbe08d74968e08a72c3be83982bb750cd3d4357" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">기존 구성을 수정하려면 &lt;code&gt;&lt;a href=&quot;#update_primary_config-1&quot;&gt;update_primary_config/1&lt;/a&gt;&lt;/code&gt; 을 사용 하거나보다 복잡한 병합이 필요한 경우 &lt;code&gt;&lt;a href=&quot;#get_primary_config-0&quot;&gt;get_primary_config/0&lt;/a&gt;&lt;/code&gt; 으로 현재 구성을 읽은 다음이 기능으로 새 구성을 다시 작성하기 전에 병합을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="32727eea82b60880074a4863f6cda445f1b0e965" translate="yes" xml:space="preserve">
          <source>To modify the existing configuration, use &lt;code&gt;&lt;a href=&quot;#update_proxy_config-1&quot;&gt; update_proxy_config/1&lt;/a&gt;&lt;/code&gt;, or, if a more complex merge is needed, read the current configuration with &lt;code&gt;&lt;a href=&quot;#get_proxy_config-0&quot;&gt;get_proxy_config/0 &lt;/a&gt;&lt;/code&gt;, then do the merge before writing the new configuration back with this function.</source>
          <target state="translated">기존 구성을 수정하려면 &lt;code&gt;&lt;a href=&quot;#update_proxy_config-1&quot;&gt; update_proxy_config/1&lt;/a&gt;&lt;/code&gt; 을 사용 하거나 더 복잡한 병합이 필요한 경우 &lt;code&gt;&lt;a href=&quot;#get_proxy_config-0&quot;&gt;get_proxy_config/0 &lt;/a&gt;&lt;/code&gt; 으로 현재 구성을 읽은 다음이 함수로 새 구성을 다시 쓰기 전에 병합을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5232b103674f04a52f0f595b415d6da9c86b5634" translate="yes" xml:space="preserve">
          <source>To not lose the data that the failing node stored up to the point of crash, the control node tries to fetch it before restarting trace. This must occur within the allowed time frame, otherwise it is aborted (default is 10 seconds, but it can be changed with &lt;code&gt;{resume, MSec}&lt;/code&gt;). The data fetched this way is then merged with all other traces.</source>
          <target state="translated">장애가 발생한 노드가 충돌 지점까지 저장 한 데이터를 잃지 않기 위해 제어 노드는 추적을 다시 시작하기 전에 데이터를 가져 오려고 시도합니다. 허용 된 시간 내에 발생해야합니다. 그렇지 않으면 중단됩니다 (기본값은 10 초이지만 &lt;code&gt;{resume, MSec}&lt;/code&gt; 로 변경할 수 있음 ). 이 방법으로 가져온 데이터는 다른 모든 추적과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="eead728bbb8cc0046ae68985d45f67a85158d6b1" translate="yes" xml:space="preserve">
          <source>To not update a driver and only recompile, it probably works when building for a 32-bit machine creating a false sense of security. Hopefully that will generate many important warnings. But when recompiling the same driver later on for a 64-bit machine, there &lt;strong&gt;will&lt;/strong&gt; be warnings and almost certainly crashes. So it is a &lt;strong&gt;bad&lt;/strong&gt; idea to postpone updating the driver and not fixing the warnings.</source>
          <target state="translated">드라이버를 업데이트하지 않고 다시 컴파일하기 만하면 잘못된 보안 감각을 만드는 32 비트 시스템을 빌드 할 때 작동합니다. 많은 중요한 경고가 발생하기를 바랍니다. 동일한 드라이버 나중에 64 비트 머신에 재 컴파일 때,이 &lt;strong&gt;것&lt;/strong&gt; 경고하고 거의 확실하게 충돌합니다. 그래서 그것은이다 &lt;strong&gt;나쁜&lt;/strong&gt; 드라이버를 업데이트하고 경고를 고정하지 연기 할 생각은.</target>
        </trans-unit>
        <trans-unit id="25dd351d674ee351bc0d61f733e4bc4ab3924c98" translate="yes" xml:space="preserve">
          <source>To only collect data from remote nodes without stopping &lt;code&gt;cover&lt;/code&gt; on those nodes, use &lt;code&gt;cover:flush/1&lt;/code&gt;</source>
          <target state="translated">해당 노드에서 &lt;code&gt;cover&lt;/code&gt; 를 중지하지 않고 원격 노드에서만 데이터를 수집하려면 &lt;code&gt;cover:flush/1&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9228c30057d8d3d2590c6d0ceb056f1bc0cfdc8f" translate="yes" xml:space="preserve">
          <source>To only update an existing value, the following syntax is used:</source>
          <target state="translated">기존 값만 업데이트하기 위해 다음 구문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91ac146297375e57e22dd83d0532b37bf8d61261" translate="yes" xml:space="preserve">
          <source>To open a file for writing and place the BOM first is even simpler:</source>
          <target state="translated">쓰기 위해 파일을 열고 BOM을 먼저 배치하는 것이 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="58c7c0dd2c707e847605f73d2bf4f644bea3024e" translate="yes" xml:space="preserve">
          <source>To open a popup menu from which the appropriate module can be selected, right-click the &lt;strong&gt;Module&lt;/strong&gt; entry.</source>
          <target state="translated">적절한 모듈을 선택할 수있는 팝업 메뉴를 열려면 &lt;strong&gt;모듈&lt;/strong&gt; 항목을 마우스 오른쪽 버튼으로 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="14f5619a76f5c4433353480eb14374da920455d5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the module to which the fun belongs, right-click the row and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">재미가 속한 모듈에 대한 자세한 정보 페이지를 열려면 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;mod&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="707dccebf0704f68a732417b3f2c2e2a669bd41f" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of a timer, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">타이머의 소유자 프로세스에 대한 자세한 정보 페이지를 열려면 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;pid&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="67b5909ded381e129ca3cf333f0952bd76fc77a6" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the owner process of an ETS table, right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">ETS 테이블의 소유자 프로세스에 대한 자세한 정보 페이지를 열려면 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;pid&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="310178f41809534c7c90fe35f112b61d4b6677f5" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the scheduler, double-click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">스케줄러에 대한 자세한 정보 페이지를 열려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;'식별자'에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="571318d856ef4524500a9b751e49f54bd8327c0e" translate="yes" xml:space="preserve">
          <source>To open the detailed information page about the table, double- click, or right-click the row and select &lt;strong&gt;Properties for 'Identifier'&lt;/strong&gt;.</source>
          <target state="translated">테이블에 대한 자세한 정보 페이지를 열려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;'식별자'에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d9f96527be2bbc3f0e5c421b45a10f8abedace3" translate="yes" xml:space="preserve">
          <source>To optimize the copy operation in step 2, code access structures are reused. In current solution we have three sets of code access structures, identified by a code index of 0, 1 and 2. These indexes are used in a round robin fashion. Instead of having to initialize a completely new copy of all access structures for every load operation we just have to update with the changes that have happened since the last two code load operations. We could get by with only two code indexes (0 and 1), but that would require yet another round of waiting for thread progress before step 2 in the &lt;code&gt;finish_loading&lt;/code&gt; sequence. We cannot start reusing a code index as staging area until we know that no lingering scheduler thread is still using it as the active code index. With three generations of code indexes, the waiting for thread progress in step 4-6 will give this guarantee for us. Thread progress will wait for all running schedulers to reschedule at least one time. No ongoing execution reading code access structures reached from an old value of &lt;code&gt;the_active_code_index&lt;/code&gt; can exist after a second round of thread progress.</source>
          <target state="translated">2 단계에서 복사 작업을 최적화하기 위해 코드 액세스 구조가 재사용됩니다. 현재 솔루션에는 코드 인덱스 0, 1 및 2로 식별되는 세 세트의 코드 액세스 구조가 있습니다. 이러한 인덱스는 라운드 로빈 방식으로 사용됩니다. 모든로드 작업에 대해 모든 액세스 구조의 완전히 새로운 복사본을 초기화하는 대신 마지막 두 코드로드 작업 이후에 발생한 변경 사항으로 업데이트하면됩니다. 두 개의 코드 인덱스 (0 및 1)만으로 얻을 수 있지만 &lt;code&gt;finish_loading&lt;/code&gt; 의 2 단계 전에 스레드 진행을 기다리는 또 다른 라운드가 필요합니다 .순서. 느린 스케줄러 스레드가 여전히 활성 코드 인덱스로 사용하고 있음을 알 때까지 코드 인덱스를 스테이징 영역으로 재사용 할 수 없습니다. 3 세대 코드 인덱스를 사용하면 4-6 단계에서 스레드 진행을 기다리면 이러한 보장을받을 수 있습니다. 스레드 진행률은 실행중인 모든 스케줄러가 한 번 이상 다시 예약 할 때까지 기다립니다. 두 번째 스레드 진행 후 &lt;code&gt;the_active_code_index&lt;/code&gt; 의 이전 값에서 도달 한 코드 액세스 구조를 읽는 지속적인 실행 이 존재할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f882324ba7cf66c628fe99da4190c380235eb46" translate="yes" xml:space="preserve">
          <source>To output characters on an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">I / O 장치에서 문자를 출력하려면 다음과 같은 &lt;code&gt;Request&lt;/code&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="4460b3a67f9f027204de0ad12d5d1dec14e5f20d" translate="yes" xml:space="preserve">
          <source>To overcome this situation, try to restart the ongoing transactions that are accessing tables on the failing node, and write a &lt;code&gt;mnesia_down&lt;/code&gt; entry to a log file.</source>
          <target state="translated">이 상황을 극복하려면 실패한 노드의 테이블에 액세스하는 진행중인 트랜잭션을 다시 시작하고 &lt;code&gt;mnesia_down&lt;/code&gt; 항목을 로그 파일에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7f8360d8ea17a73622310335fec57f5f594e5a" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use</source>
          <target state="translated">병합없이 기존 구성을 덮어 쓰려면</target>
        </trans-unit>
        <trans-unit id="f7234cbfd68a0c262c592cc7d358092db950cccb" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">병합하지 않고 기존 구성을 덮어 &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2 &lt;/a&gt;&lt;/code&gt; 려면 set_handler_config / 2를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8eb9c41fc2b2f98f04f5d6d6242bc28f6713bd31" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">병합없이 기존 구성을 겹쳐 &lt;code&gt;&lt;a href=&quot;#set_handler_config-2&quot;&gt;set_handler_config/2&lt;/a&gt;&lt;/code&gt; 려면 set_handler_config / 2를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c898f6aa3f00a6669d0ce126d552a738c9ef72d7" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">병합하지 않고 기존 구성을 덮어 &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1 &lt;/a&gt;&lt;/code&gt; 려면 set_primary_config / 1을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="db040bf59efb80826409bf9f754e7a7431f35000" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">병합없이 기존 구성을 겹쳐 &lt;code&gt;&lt;a href=&quot;#set_primary_config-1&quot;&gt;set_primary_config/1&lt;/a&gt;&lt;/code&gt; 려면 set_primary_config / 1을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="49fbf2912e0f2c254843c85e6a31555d4db4ff43" translate="yes" xml:space="preserve">
          <source>To overwrite the existing configuration without any merge, use &lt;code&gt;&lt;a href=&quot;#set_proxy_config-1&quot;&gt;set_proxy_config/1 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">병합하지 않고 기존 구성을 덮어 &lt;code&gt;&lt;a href=&quot;#set_proxy_config-1&quot;&gt;set_proxy_config/1 &lt;/a&gt;&lt;/code&gt; 려면 set_proxy_config / 1을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ef5df41f2e14a8f5ccfe8eb5134454968930bd33" translate="yes" xml:space="preserve">
          <source>To pass data from one test suite to another, the same mechanism is used. The data is to be saved by finction &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; and read by function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; in the suite that follows. When passing data between suites, &lt;code&gt;Saver&lt;/code&gt; carries the name of the test suite.</source>
          <target state="translated">한 테스트 스위트에서 다른 테스트 스위트로 데이터를 전달하기 위해 동일한 메커니즘이 사용됩니다. 데이터는 종료 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 에 의해 저장되고 다음 제품군의 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 함수에 의해 읽혀 집니다. 제품군간에 데이터를 전달할 때 &lt;code&gt;Saver&lt;/code&gt; 는 테스트 제품군의 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7a2133d0447986ef047f45d46d57b0cba23ddd16" translate="yes" xml:space="preserve">
          <source>To pass data from one test suite to another, the same mechanism is used. The data is to be saved by finction &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; and read by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; in the suite that follows. When passing data between suites, &lt;code&gt;Saver&lt;/code&gt; carries the name of the test suite.</source>
          <target state="translated">한 테스트 스위트에서 다른 테스트 스위트로 데이터를 전달하기 위해 동일한 메커니즘이 사용됩니다. 데이터는 finction &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite&lt;/a&gt;&lt;/code&gt; 에 의해 저장되고 다음 제품군의 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite&lt;/a&gt;&lt;/code&gt; 함수가 읽습니다 . 스위트간에 데이터를 전달할 때 &lt;code&gt;Saver&lt;/code&gt; 는 테스트 스위트의 이름을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="de196dbd1fc4727b3381ea786892e523ea66df78" translate="yes" xml:space="preserve">
          <source>To pass start arguments to the event handler init function, use option &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; instead of &lt;code&gt;-event_handler&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러 init 함수에 시작 인수를 전달하려면 &lt;code&gt;ct_run -event_handler_init&lt;/code&gt; 대신 ct_run -event_handler_init 옵션을 사용 &lt;code&gt;-event_handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05760d82d1ff0699d6462cb51afbab4089fd15b2" translate="yes" xml:space="preserve">
          <source>To paste text, use &lt;code&gt;Ctrl-V&lt;/code&gt;.</source>
          <target state="translated">텍스트를 붙여 넣으려면 &lt;code&gt;Ctrl-V&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a0ab25b4dbcc22e8a0f55cfd17389d320947558" translate="yes" xml:space="preserve">
          <source>To perform a selective decode:</source>
          <target state="translated">선택적 디코딩을 수행하려면</target>
        </trans-unit>
        <trans-unit id="e34161a911d532a3fe5b96ed7a79392865f455a4" translate="yes" xml:space="preserve">
          <source>To perform an exclusive decode:</source>
          <target state="translated">단독 디코딩을 수행하려면</target>
        </trans-unit>
        <trans-unit id="3f8dad79e2d5118a556c41ca87119ccb799f35ee" translate="yes" xml:space="preserve">
          <source>To perform code coverage test (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">코드 범위 테스트를 수행하려면 ( &lt;code&gt;&lt;a href=&quot;cover_chapter#cover&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a431fccb77738e590c035501f73871c8ebfc0dd5" translate="yes" xml:space="preserve">
          <source>To plug in a handler to the &lt;code&gt;Common Test&lt;/code&gt; Master event manager, specify &lt;code&gt;master&lt;/code&gt; as the node in &lt;code&gt;NodeRefs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; Master 이벤트 관리자에 핸들러를 연결하려면 &lt;code&gt;NodeRefs&lt;/code&gt; 에서 &lt;code&gt;master&lt;/code&gt; 를 노드로 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9a49f1cec23382260ab3c7111ed66a3064f4b5e" translate="yes" xml:space="preserve">
          <source>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a &lt;strong&gt;maximum restart intensity&lt;/strong&gt; is defined using two integer values specified with keys &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; in the above map. Assuming the values &lt;code&gt;MaxR&lt;/code&gt; for &lt;code&gt;intensity&lt;/code&gt; and &lt;code&gt;MaxT&lt;/code&gt; for &lt;code&gt;period&lt;/code&gt;, then, if more than &lt;code&gt;MaxR&lt;/code&gt; restarts occur within &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;. &lt;code&gt;intensity&lt;/code&gt; defaults to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;period&lt;/code&gt; defaults to &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저가 자식 프로세스 종료 및 재시작의 무한 루프에 빠지지 않도록 위의 맵에서 키 &lt;code&gt;intensity&lt;/code&gt; 와 &lt;code&gt;period&lt;/code&gt; 지정된 두 정수 값을 사용하여 &lt;strong&gt;최대 재시작 강도&lt;/strong&gt; 를 정의합니다 . 값 가정 &lt;code&gt;MaxR&lt;/code&gt; 대한 &lt;code&gt;intensity&lt;/code&gt; 및 &lt;code&gt;MaxT&lt;/code&gt; 을 위한 &lt;code&gt;period&lt;/code&gt; 이상 '라면, &lt;code&gt;MaxR&lt;/code&gt; 의 재시작 내에 발생 &lt;code&gt;MaxT&lt;/code&gt; 의 초 감독자가 모든 하위 프로세스 자체를 종료한다. 이 경우 수퍼바이저 자체의 종료 이유는 &lt;code&gt;shutdown&lt;/code&gt; 입니다. &lt;code&gt;intensity&lt;/code&gt; 기본값은 &lt;code&gt;1&lt;/code&gt; 이며 &lt;code&gt;period&lt;/code&gt; 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b6bd58de0f6a9d2c9e5412e4769e5fc57c89331" translate="yes" xml:space="preserve">
          <source>To prevent accidentally reloading of modules affecting the Erlang runtime system, directories &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt;, and &lt;code&gt;compiler&lt;/code&gt; are considered &lt;strong&gt;sticky&lt;/strong&gt;. This means that the system issues a warning and rejects the request if a user tries to reload a module residing in any of them. The feature can be disabled by using command-line flag &lt;code&gt;-nostick&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템에 영향을 미치는 모듈을 실수로 다시로드하는 것을 막기 위해 &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; 및 &lt;code&gt;compiler&lt;/code&gt; 디렉토리 는 &lt;strong&gt;sticky&lt;/strong&gt; 로 간주됩니다 . 이는 시스템이 경고를 발행하고 사용자가 모듈에 상주하는 모듈을 다시로드하려고하면 요청을 거부 함을 의미합니다. 이 기능은 명령 행 플래그 &lt;code&gt;-nostick&lt;/code&gt; 을 사용하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dec616600e41a5b6ef771d942e395567b990586c" translate="yes" xml:space="preserve">
          <source>To prevent late answers (after the time-out) from polluting the message queue of the caller, a middleman process is used to do the calls. Late answers are then discarded when they arrive to a terminated process.</source>
          <target state="translated">늦은 응답 (시간 초과 후)이 호출자의 메시지 큐를 오염시키는 것을 방지하기 위해 중개자 프로세스가 호출을 수행하는 데 사용됩니다. 그런 다음 종료 된 프로세스에 도달하면 늦은 응답이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3c59c8bcb62921917057af6666d0e9bc306363f2" translate="yes" xml:space="preserve">
          <source>To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 쉘에 파일 목록을 인쇄하려면 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c96078a18d7d337d7863d89fe19020a3f6b4c5e0" translate="yes" xml:space="preserve">
          <source>To print some information in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page, return &lt;code&gt;{comment, Comment}&lt;/code&gt;.</source>
          <target state="translated">HTML 결과 페이지의 &lt;code&gt;Comment&lt;/code&gt; 필드에 일부 정보를 인쇄하려면 &lt;code&gt;{comment, Comment}&lt;/code&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e7f46b82ce549b77ba51c1629aef0ab23feab88" translate="yes" xml:space="preserve">
          <source>To print some information in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page, return &lt;code&gt;{comment,Comment}&lt;/code&gt;.</source>
          <target state="translated">HTML 결과 페이지의 &lt;code&gt;Comment&lt;/code&gt; 필드에 일부 정보를 인쇄하려면 &lt;code&gt;{comment,Comment}&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cc0874eca15de116c6433f2f6c8188ae52c6b95" translate="yes" xml:space="preserve">
          <source>To produce sensible results, &lt;code&gt;fprof&lt;/code&gt; tries not to charge any function more than once for ACC time. The instance highest up (with longest duration) in the call stack is chosen.</source>
          <target state="translated">합리적인 결과를 &lt;code&gt;fprof&lt;/code&gt; 위해 fprof 는 ACC 시간 동안 어떤 기능도 두 번 이상 충전하지 않습니다. 호출 스택에서 가장 높은 인스턴스 (길이가 가장 긴)가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fdb950e45ab67b6a47da12b4482a70174dcfdd0c" translate="yes" xml:space="preserve">
          <source>To provide customization and extensibility of the request handling of the HTTP servers, most of these steps are handled by one or more modules. These modules can be replaced or removed at runtime and new ones can be added. For each request, all modules are traversed in the order specified by the module directive in the server configuration file. Some parts, mainly the communication- related steps, are considered server core functionality and are not implemented using the Erlang web server API. A description of functionality implemented by the Erlang webserver API is described in &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">HTTP 서버의 요청 처리에 대한 사용자 정의 및 확장 성을 제공하기 위해 이러한 단계의 대부분은 하나 이상의 모듈에 의해 처리됩니다. 이러한 모듈은 런타임에 교체하거나 제거 할 수 있으며 새로운 모듈을 추가 할 수 있습니다. 각 요청에 대해 모든 모듈은 서버 구성 파일에서 모듈 지시문에 지정된 순서대로 순회합니다. 주로 통신 관련 단계 인 일부 부분은 서버 핵심 기능으로 간주되며 Erlang 웹 서버 API를 사용하여 구현되지 않습니다. Erlang 웹 서버 API로 구현 된 기능에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#Inets_Web_Server_Modules&quot;&gt;Section Inets Web Server Modules&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7caa6e3412703737187f18930265da85c613b9f8" translate="yes" xml:space="preserve">
          <source>To provide more information for bug detection tools, such as Dialyzer</source>
          <target state="translated">Dialyzer와 같은 버그 탐지 도구에 대한 자세한 정보를 제공하려면</target>
        </trans-unit>
        <trans-unit id="70140cd0cd31cb537fdab4b337a2d1d9434b3002" translate="yes" xml:space="preserve">
          <source>To provide robustness, a distributed Erlang node occasionally polls all its connected neighbors in an attempt to detect failed nodes or communication links. A node that receives such a message is expected to respond immediately with an &lt;code&gt;ERL_TICK&lt;/code&gt; message. This is done automatically by &lt;code&gt;ei_xreceive_msg()&lt;/code&gt;. However, when this has occurred, &lt;code&gt;ei_xreceive_msg&lt;/code&gt; returns &lt;code&gt;ERL_TICK&lt;/code&gt; to the caller without storing a message into the &lt;code&gt;erlang_msg&lt;/code&gt; structure.</source>
          <target state="translated">견고성을 제공하기 위해 분산 된 Erlang 노드는 실패한 노드 또는 통신 링크를 감지하기 위해 연결된 모든 이웃을 가끔 폴링합니다. 이러한 메시지를 수신 한 노드는 &lt;code&gt;ERL_TICK&lt;/code&gt; 메시지로 즉시 응답 할 것으로 예상됩니다 . 이것은 &lt;code&gt;ei_xreceive_msg()&lt;/code&gt; 의해 자동으로 수행됩니다 . 그러나, 이것은, 발생시 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 복귀 &lt;code&gt;ERL_TICK&lt;/code&gt; 을 에 메시지를 저장하지 않고 발신자 &lt;code&gt;erlang_msg&lt;/code&gt; 의 구조.</target>
        </trans-unit>
        <trans-unit id="5563a933e99748f8947b5b13de253c9bebd73132" translate="yes" xml:space="preserve">
          <source>To provide robustness, a distributed Erlang node occasionally polls all its connected neighbors in an attempt to detect failed nodes or communication links. A node that receives such a message is expected to respond immediately with an &lt;code&gt;ERL_TICK&lt;/code&gt; message. This is done automatically by &lt;code&gt;erl_receive()&lt;/code&gt;. However, when this has occurred, &lt;code&gt;erl_receive&lt;/code&gt; returns &lt;code&gt;ERL_TICK&lt;/code&gt; to the caller without storing a message into the &lt;code&gt;ErlMessage&lt;/code&gt; structure.</source>
          <target state="translated">견고성을 제공하기 위해 분산 Erlang 노드는 때때로 장애가 발생한 노드 또는 통신 링크를 감지하기 위해 연결된 모든 인접 노드를 폴링합니다. 이러한 메시지를받는 노드는 &lt;code&gt;ERL_TICK&lt;/code&gt; 메시지로 즉시 응답합니다 . 이것은 &lt;code&gt;erl_receive()&lt;/code&gt; 의해 자동으로 수행됩니다 . 그러나, 이것이 발생, &lt;code&gt;erl_receive&lt;/code&gt; 복귀 &lt;code&gt;ERL_TICK&lt;/code&gt; 을 에 메시지를 저장하지 않고 호출자 &lt;code&gt;ErlMessage&lt;/code&gt; 의 구조.</target>
        </trans-unit>
        <trans-unit id="c22d22ca8626a0d9ad4822b6abdf3304ff0e2ed1" translate="yes" xml:space="preserve">
          <source>To quickly get started on tracing function calls you can use the following code in the Erlang shell:</source>
          <target state="translated">추적 함수 호출을 빠르게 시작하려면 Erlang 쉘에서 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4216c6c1555a4ffc81851d786b4c47388d4033ab" translate="yes" xml:space="preserve">
          <source>To raise the salary to 10 for everyone with a salary less than 10 and return the sum of all raises:</source>
          <target state="translated">급여가 10 미만인 모든 사람의 급여를 10으로 올리고 모든 인상의 합계를 반환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="487f9ae77ed1f6bfc72656beab390cd3da83a3a4" translate="yes" xml:space="preserve">
          <source>To read characters from an I/O device, the following &lt;code&gt;Request&lt;/code&gt;s exist:</source>
          <target state="translated">I / O 장치에서 문자를 읽으려면 다음 &lt;code&gt;Request&lt;/code&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8ebc4e78936132f1c46d3f47b17ef930ad86f68e" translate="yes" xml:space="preserve">
          <source>To read data saved by a previous test case, use macro &lt;code&gt;config&lt;/code&gt; with a &lt;code&gt;saved_config&lt;/code&gt; key as follows:</source>
          <target state="translated">이전 테스트 사례에서 저장 한 데이터를 읽으려면 다음과 같이 &lt;code&gt;saved_config&lt;/code&gt; 키 와 함께 매크로 &lt;code&gt;config&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e65ac5f6db83037a2248f75d84c868aa8830d0a" translate="yes" xml:space="preserve">
          <source>To read test terms, use &lt;code&gt;Tag = tests&lt;/code&gt; (rather than &lt;code&gt;suites&lt;/code&gt;, &lt;code&gt;groups&lt;/code&gt;, or &lt;code&gt;cases&lt;/code&gt;). &lt;code&gt;Value&lt;/code&gt; is then the list of &lt;strong&gt;all&lt;/strong&gt; tests on the form &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt;, where &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt;.</source>
          <target state="translated">테스트 용어를 읽으려면 &lt;code&gt;suites&lt;/code&gt; , &lt;code&gt;groups&lt;/code&gt; 또는 &lt;code&gt;cases&lt;/code&gt; 대신 &lt;code&gt;Tag = tests&lt;/code&gt; 사용하십시오 . 그러면 &lt;code&gt;Value&lt;/code&gt; 는 &lt;code&gt;[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]&lt;/code&gt; 형식 의 &lt;strong&gt;모든&lt;/strong&gt; 테스트 목록입니다 . 여기서 &lt;code&gt;GroupsAndCases = [{Group,[Case]}] | [Case]&lt;/code&gt; [사례] .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7c528844ef8d79cae8d20604fa518c2950e82af" translate="yes" xml:space="preserve">
          <source>To read the counter value, use &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt; erlang:trace_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">카운터 값을 읽으려면 &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt; erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5502e1d91075568dbfad6a71c308a3359400e11e" translate="yes" xml:space="preserve">
          <source>To read the counter value, use &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">카운터 값을 읽으려면 &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf5d7d89573645295c9ea3ad3f20e180a97f562f" translate="yes" xml:space="preserve">
          <source>To read the value of a configuration variable, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구성 변수의 값을 읽으려면 &lt;code&gt;&lt;a href=&quot;ct#get_config-1&quot;&gt;get_config/1,2,3&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="85dbe7571965e09b1298a761ceeca08b4c2e5f97" translate="yes" xml:space="preserve">
          <source>To read the values from the table directly is not always possible. It can be needed to search one or more tables to get the wanted data, and this is done by writing database queries. Queries are always more expensive operations than direct lookups done with &lt;code&gt;mnesia:read&lt;/code&gt;. Therefore, avoid queries in performance-critical code.</source>
          <target state="translated">테이블에서 직접 값을 읽는 것이 항상 가능한 것은 아닙니다. 원하는 데이터를 얻기 위해 하나 이상의 테이블을 검색해야 할 수 있으며 이는 데이터베이스 쿼리를 작성하여 수행됩니다. 쿼리는 &lt;code&gt;mnesia:read&lt;/code&gt; 로 직접 조회하는 것보다 항상 더 비싼 작업 입니다. 따라서 성능이 중요한 코드에서는 쿼리를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="9ca82b142769fd54c89e1f8c4e76ea91942c4a3b" translate="yes" xml:space="preserve">
          <source>To reboot on Windows, &lt;code&gt;HEART_COMMAND&lt;/code&gt; can be set to &lt;code&gt;heart -shutdown&lt;/code&gt; (included in the Erlang delivery) or to any other suitable program that can activate a reboot.</source>
          <target state="translated">&lt;code&gt;HEART_COMMAND&lt;/code&gt; 는 Windows에서 재부팅 하기 위해 &lt;code&gt;heart -shutdown&lt;/code&gt; (Erlang 제공에 포함) 또는 재부팅을 활성화 할 수있는 다른 적절한 프로그램으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="193023780b4eaa20d8ea195a384aafb6f435f70c" translate="yes" xml:space="preserve">
          <source>To reclaim data from the old heap, both young and old heaps are included during the collection and copied to a common &lt;strong&gt;to space&lt;/strong&gt;. Both the &lt;strong&gt;from space&lt;/strong&gt; of the young and old heap are then deallocated and the procedure will start over from the beginning. This type of garbage collection is called a full sweep and is triggered when the size of the area under the high-watermark is larger than the size of the free area of the old heap. It can also be triggered by doing a manual call to &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#garbage_collect-0&quot;&gt;erlang:garbage_collect()&lt;/a&gt;&lt;/code&gt;, or by running into the young garbage collection limit set by &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;spawn_opt(fun(),[{fullsweep_after, N}])&lt;/a&gt;&lt;/code&gt; where N is the number of young garbage collections to do before forcing a garbage collection of both young and old heap.</source>
          <target state="translated">이전 힙에서 데이터를 재 확보하기 위해 수집 중에 젊은 힙과 이전 힙이 모두 포함되고 공통 &lt;strong&gt;공간에&lt;/strong&gt; 복사됩니다 . 모두 &lt;strong&gt;의 공간에서&lt;/strong&gt; 젊은이와 노인 힙은 해제되고, 절차는 처음부터 다시 시작됩니다. 이러한 유형의 가비지 수집을 전체 스윕이라고하며 하이 워터 마크 아래 영역의 크기가 이전 힙의 사용 가능한 영역 크기보다 클 때 트리거됩니다. &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#garbage_collect-0&quot;&gt;erlang:garbage_collect()&lt;/a&gt;&lt;/code&gt; 대한 수동 호출을 수행 하거나 &lt;code&gt;&lt;a href=&quot;http://erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;spawn_opt(fun(),[{fullsweep_after, N}])&lt;/a&gt;&lt;/code&gt; 의해 설정된 젊은 가비지 수집 제한에 도달하여 트리거 될 수도 있습니다 . 여기서 N은 젊은 가비지의 수입니다. 젊은 힙과 오래된 힙 모두의 가비지 콜렉션을 강제하기 전에 수행 할 콜렉션.</target>
        </trans-unit>
        <trans-unit id="904a52a917c4933054a167b0ca9069fffee62faa" translate="yes" xml:space="preserve">
          <source>To reduce fragmentation within the super carrier, it is good to keep SBCs and MBCs apart. MBCs with their uniform alignment and sizes can be packed very efficiently together. SBCs without demand for aligment can also be allocated quite efficiently together. But mixing them can lead to a lot of memory wasted when we need to create large holes of padding to the next alignment limit.</source>
          <target state="translated">슈퍼 캐리어 내에서 조각화를 줄이려면 SBC와 MBC를 분리하는 것이 좋습니다. 균일 한 정렬과 크기를 가진 MBC는 매우 효율적으로 함께 포장 할 수 있습니다. 결합에 대한 요구가없는 SBC는 매우 효율적으로 함께 할당 될 수 있습니다. 그러나 이들을 혼합하면 다음 정렬 한계까지 큰 패딩 구멍을 만들어야 할 때 많은 메모리가 낭비 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7356ba3e6c5278038b64fa42047a269f1c25742e" translate="yes" xml:space="preserve">
          <source>To reload a driver, the process must have loaded the driver before, that is, there must be an active &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver in the process.</source>
          <target state="translated">드라이버를 다시로드하려면 프로세스가 드라이버를로드하기 전에 프로세스에서 드라이버의 활성 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d5d80cf56917698c815ead9031a1b70952ad813b" translate="yes" xml:space="preserve">
          <source>To remove a breakpoint some more steps are needed. The idea is to first stage the breakpoint as disabled, do the switch, wait for thread progress and then remove the disabled breakpoint by restoring the original beam instruction.</source>
          <target state="translated">중단 점을 제거하려면 몇 가지 단계가 더 필요합니다. 아이디어는 먼저 중단 점을 비활성화 된 상태로 스테이징하고 전환을 수행하고 스레드 진행을 기다린 다음 원래 빔 명령을 복원하여 비활성화 된 중단 점을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa3cdbff1f4721e1fea3341a44c74cdfddea8582" translate="yes" xml:space="preserve">
          <source>To remove the special meaning from a sequence of characters, put them between \Q and \E. This is different from Perl in that $ and @ are handled as literals in \Q...\E sequences in PCRE, while $ and @ cause variable interpolation in Perl. Notice the following examples:</source>
          <target state="translated">일련의 문자에서 특별한 의미를 제거하려면 \ Q와 \ E 사이에 넣으십시오. $와 @는 PCRE의 \ Q ... \ E 시퀀스에서 리터럴로 처리되는 반면 $와 @는 Perl에서 변수 보간을 일으킨다는 점에서 이것은 Perl과 다릅니다. 다음 예를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="e4533b5e08e30a08269677e74e6167edc56c190c" translate="yes" xml:space="preserve">
          <source>To render the EEP-48 documentation for an Erlang module you can use &lt;code&gt;shell_docs:render/2&lt;/code&gt;.</source>
          <target state="translated">Erlang 모듈에 대한 EEP-48 문서를 &lt;code&gt;shell_docs:render/2&lt;/code&gt; 하려면 shell_docs : render / 2를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18463ee935cca0988ac023c8a2bb9233c9fed26c" translate="yes" xml:space="preserve">
          <source>To resolve BIF clashes, use explicit module names or the &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; compiler directive.</source>
          <target state="translated">BIF 충돌을 해결하려면 명시 적 모듈 이름 또는 &lt;code&gt;{no_auto_import,[F/A]}&lt;/code&gt; 컴파일러 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b836fc9905c583f17eeb633ad4676ccd91021746" translate="yes" xml:space="preserve">
          <source>To restrict access further, firewall software must be used.</source>
          <target state="translated">추가 액세스를 제한하려면 방화벽 소프트웨어를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8f49586e1a231ba1f54695cd73e9669c2fc73d3" translate="yes" xml:space="preserve">
          <source>To retain backwards compatibility, this module can also be used to start a standalone &lt;code&gt;nteventlog&lt;/code&gt; process which is not part of the OS_Mon supervision tree. When starting such a process, the user has to supply an identifier as well as a callback function to handle the messages.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해이 모듈을 사용 하여 OS_Mon 감독 트리의 일부가 아닌 독립형 &lt;code&gt;nteventlog&lt;/code&gt; 프로세스 를 시작할 수도 있습니다 . 이러한 프로세스를 시작할 때 사용자는 메시지를 처리하기 위해 콜백 함수뿐만 아니라 식별자를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a959b682cb9f11efcb53765708cc1ed01908dbd3" translate="yes" xml:space="preserve">
          <source>To retrieve information about which processes have fixed which tables, use &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt; info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt;. A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long.</source>
          <target state="translated">어떤 프로세스가 어떤 테이블을 수정했는지에 대한 정보를 검색하려면 &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt; info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt; . 테이블을 고정하는 프로세스가 많은 시스템에는 테이블이 너무 오랫동안 고정 된 경우 경보를 보내는 모니터가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df78eacbc0781784bde23219396762a59c5fc919" translate="yes" xml:space="preserve">
          <source>To retrieve information about which processes have fixed which tables, use &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt;. A system with many processes fixing tables can need a monitor that sends alarms when tables have been fixed for too long.</source>
          <target state="translated">어떤 프로세스가 어떤 테이블을 수정했는지에 대한 정보를 검색하려면 &lt;code&gt;&lt;a href=&quot;#info_2_safe_fixed_monotonic_time&quot;&gt;info(Tab, safe_fixed_monotonic_time)&lt;/a&gt;&lt;/code&gt; . 테이블을 수정하는 프로세스가 많은 시스템에는 테이블을 너무 오래 고정했을 때 경보를 보내는 모니터가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e2ab13997144de0b0946f9bce9ea8b713fdb68" translate="yes" xml:space="preserve">
          <source>To retrieve lock statistics information, use &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;. The collect operation will start a &lt;code&gt;lcnt&lt;/code&gt; server if it not already started. All collected data will be built into an Erlang term and uploaded to the server and a duration time will also be uploaded. This duration is the time between &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; and &lt;code&gt;lcnt:collect/0,1&lt;/code&gt;.</source>
          <target state="translated">잠금 통계 정보를 검색하려면 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 을 사용하십시오 . 수집 작업은 &lt;code&gt;lcnt&lt;/code&gt; 서버가 아직 시작되지 않은 경우 시작합니다. 수집 된 모든 데이터는 Erlang 용어로 작성되어 서버에 업로드되며 지속 시간도 업로드됩니다. 이 기간은 &lt;code&gt;lcnt:clear/0,1&lt;/code&gt; 과 &lt;code&gt;lcnt:collect/0,1&lt;/code&gt; 사이의 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="ed81e642c8e411bd6b5d4f1ff2f2a981ab28269a" translate="yes" xml:space="preserve">
          <source>To retrieve options, the following request is used:</source>
          <target state="translated">옵션을 검색하기 위해 다음 요청이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9ff785694d496350bf52e12cf31257901fe0f9a" translate="yes" xml:space="preserve">
          <source>To retrieve previous command lines, press the &lt;code&gt;Up arrow&lt;/code&gt; or use &lt;code&gt;Ctrl-P&lt;/code&gt;.</source>
          <target state="translated">이전 명령 행을 검색하려면 &lt;code&gt;Up arrow&lt;/code&gt; 누르 거나 &lt;code&gt;Ctrl-P&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fa4079733e0da1dfbe5a6ebd7c48cf9cb0263ef" translate="yes" xml:space="preserve">
          <source>To retrieve the current time offset, call &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 시간 오프셋을 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="559902e638ff39f33df6bbdca42175eae97e1371" translate="yes" xml:space="preserve">
          <source>To retrieve the current time offset, call &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 시간 오프셋을 검색하려면 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cbf41d37fbb9107d553f0edbf762bf1a41464d8" translate="yes" xml:space="preserve">
          <source>To retrieve the pathname of the script, call &lt;code&gt;&lt;a href=&quot;#script_name-0&quot;&gt; escript:script_name() &lt;/a&gt;&lt;/code&gt; from your script (the pathname is usually, but not always, absolute).</source>
          <target state="translated">스크립트의 경로 이름을 검색하려면 스크립트에서 &lt;code&gt;&lt;a href=&quot;#script_name-0&quot;&gt; escript:script_name() &lt;/a&gt;&lt;/code&gt; 을 호출 하십시오 (경로 이름은 일반적으로 절대적이지는 않지만 일반적 임).</target>
        </trans-unit>
        <trans-unit id="3766f9d946545324fc3caa134e7e2c3cc1ac0495" translate="yes" xml:space="preserve">
          <source>To retrieve the pathname of the script, call &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; from your script (the pathname is usually, but not always, absolute).</source>
          <target state="translated">스크립트의 경로 이름을 검색하려면 스크립트에서 &lt;code&gt;&lt;a href=&quot;#script_name_0&quot;&gt;escript:script_name()&lt;/a&gt;&lt;/code&gt; 을 호출 하십시오 (경로 이름은 대개는 아니지만 절대 경로 임).</target>
        </trans-unit>
        <trans-unit id="2fa3ffd8aedc2e1d61b1e455bb122f9f20bde0a5" translate="yes" xml:space="preserve">
          <source>To retrieve the size of a tuple, either use function &lt;code&gt;erl_size&lt;/code&gt; (which checks the type of the checked term and works for a binary as well as for a tuple) or &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; returns the arity of a tuple. &lt;code&gt;erl_size()&lt;/code&gt; does the same thing, but it checks that the argument is a tuple. &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; returns the element corresponding to a given position in the tuple.</source>
          <target state="translated">튜플의 크기를 검색하려면 함수 &lt;code&gt;erl_size&lt;/code&gt; (확인 된 용어의 유형을 확인하고 이진 및 튜플에 대해 작동 함)를 사용하거나 &lt;code&gt;ERL_TUPLE_SIZE(tuple)&lt;/code&gt; 는 튜플 의 arity를 ​​반환합니다. &lt;code&gt;erl_size()&lt;/code&gt; 는 동일한 작업을 수행하지만 인수가 튜플인지 확인합니다. &lt;code&gt;erl_element(index,tuple)&lt;/code&gt; 은 튜플 에서 주어진 위치에 해당하는 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e48e571028f75c8447b25387e9c4c4797341c527" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a tar file, use function &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;. To print a list of files to the Erlang shell, use function &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">tar 파일의 파일 목록을 리턴하려면 함수 &lt;code&gt;&lt;a href=&quot;#table-1&quot;&gt;table/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . Erlang 쉘에 파일 목록을 인쇄하려면 &lt;code&gt;&lt;a href=&quot;#t-1&quot;&gt;t/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#tt-1&quot;&gt;tt/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="340c1d928e96b2c334351d4a254c0683a554ee08" translate="yes" xml:space="preserve">
          <source>To return a list of the files in a zip archive, use function &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt;. They are also available as &lt;code&gt;table/1,2&lt;/code&gt;, to resemble the &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">zip 아카이브에있는 파일 목록을 리턴하려면 &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#list_dir-2&quot;&gt;list_dir/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;erl_tar&quot;&gt;erl_tar&lt;/a&gt;&lt;/code&gt; 모듈 과 유사한 &lt;code&gt;table/1,2&lt;/code&gt; 로도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="ede464349d4cd7d18cdfbdde4b663fdde07fb367" translate="yes" xml:space="preserve">
          <source>To return a timetrap time value (other than a function).</source>
          <target state="translated">함수 이외의 타임 트랩 시간 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b77285912aad5ab1ca119d023b421a0ece59988" translate="yes" xml:space="preserve">
          <source>To return only a few answers, cursors can be used. The following code returns no more than five answers using an ETS table for storing the unique answers:</source>
          <target state="translated">몇 가지 답변 만 반환하기 위해 커서를 사용할 수 있습니다. 다음 코드는 고유 답변을 저장하기 위해 ETS 테이블을 사용하여 5 개 이하의 답변을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f1313328915fb09221beb5318c9e4409d5bb780" translate="yes" xml:space="preserve">
          <source>To return your own non-zero exit code, call &lt;code&gt;halt(ExitCode)&lt;/code&gt;, for example:</source>
          <target state="translated">0이 아닌 종료 코드를 리턴하려면 &lt;code&gt;halt(ExitCode)&lt;/code&gt; 호출하십시오 ( 예 :</target>
        </trans-unit>
        <trans-unit id="1b79ecfdca80ef63664553eeb43bf5bf50699646" translate="yes" xml:space="preserve">
          <source>To revert to the old representation of the types, use option &lt;code&gt;legacy_erlang_types&lt;/code&gt;.</source>
          <target state="translated">유형의 이전 표현으로 되돌리려면 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="91cba5ad0a4514ff3580b9b3644134649e4008a3" translate="yes" xml:space="preserve">
          <source>To run DTLS add the option {protocol, dtls} to third argument.</source>
          <target state="translated">DTLS를 실행하려면 {protocol, dtls} 옵션을 세 번째 인수에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6379d836d463079cbc440c281ea46705465f1d9e" translate="yes" xml:space="preserve">
          <source>To run it manually do the following:</source>
          <target state="translated">수동으로 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="adfad10f00ccaf0e104d2a8e3a7d4d9ca3d7a1f4" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data from a test case that is to be skipped, return tuple &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt;.</source>
          <target state="translated">건너 뛸 테스트 케이스에서 &lt;code&gt;Config&lt;/code&gt; 데이터 를 저장하려면 tuple &lt;code&gt;{skip_and_save,Reason,ConfigList}&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="519bc4bce2b33dabd607dc6ed921c16f90d09ddb" translate="yes" xml:space="preserve">
          <source>To save &lt;code&gt;Config&lt;/code&gt; data, return tuple &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; from &lt;code&gt;end_per_testcase&lt;/code&gt; or from the main test case function.</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 데이터 를 저장하려면 &lt;code&gt;end_per_testcase&lt;/code&gt; 또는 기본 테스트 케이스 함수에서 튜플 &lt;code&gt;{save_config,ConfigList}&lt;/code&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="27c3f8d5138cdbd33fa95b3ba65e0753971bf624" translate="yes" xml:space="preserve">
          <source>To scale well, it is a good idea to ensure that the records are evenly distributed over all fragments, including the new one.</source>
          <target state="translated">확장 성을 높이려면 새 조각을 포함하여 모든 조각에 레코드가 고르게 분포되도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4c8083213bdb28df6c894a96e97a47fb6b900182" translate="yes" xml:space="preserve">
          <source>To schedule a dirty NIF for execution, the application has two options:</source>
          <target state="translated">더티 NIF 실행을 예약하기 위해 어플리케이션에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f67e6c0f7313593a134591d24c1deff4f24d43c9" translate="yes" xml:space="preserve">
          <source>To see all supported cipher suites, call &lt;code&gt;ssl:cipher_suites(all) &lt;/code&gt;. The available cipher suites for a connection depend on your certificate. Specific cipher suites that you want your connection to use can also be specified. Default is to use the strongest available.</source>
          <target state="translated">지원되는 모든 암호 그룹을 보려면 &lt;code&gt;ssl:cipher_suites(all) &lt;/code&gt; 호출하십시오 . 연결에 사용할 수있는 암호 그룹은 인증서에 따라 다릅니다. 연결에서 사용할 특정 암호 그룹도 지정할 수 있습니다. 기본값은 사용 가능한 가장 강력한 것을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2dcc54bfbac822c2d50a90e01df3c8520791a56a" translate="yes" xml:space="preserve">
          <source>To see all supported cipher suites, call &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt;. The available cipher suites for a connection depend on your certificate. Specific cipher suites that you want your connection to use can also be specified. Default is to use the strongest available.</source>
          <target state="translated">지원되는 모든 암호 제품군을 보려면 &lt;code&gt;ssl:cipher_suites(all)&lt;/code&gt; 호출하십시오 . 연결에 사용 가능한 암호 스위트는 인증서에 따라 다릅니다. 연결에 사용하려는 특정 암호 스위트도 지정할 수 있습니다. 기본값은 가장 강한 것을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="faa6a0098bcbb7837e8269c97adc5d1ee4575f3f" translate="yes" xml:space="preserve">
          <source>To see more detailed information about a node, double-click the row, or right-click the row and select &lt;strong&gt;Properties for node &amp;lt;node&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;, to open the detailed information window for the controlling port.</source>
          <target state="translated">노드에 대한 자세한 정보를 보려면 행을 두 번 클릭하거나 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;node&amp;gt; 노드의 특성을&lt;/strong&gt; 선택하십시오 . 마우스 오른쪽 버튼 메뉴에서 &lt;strong&gt;&amp;lt;port&amp;gt; 속성을&lt;/strong&gt; 선택 하여 제어 포트에 대한 자세한 정보 창을 열 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b51fe379feee1d788abaddbf99683f3e6711cc7" translate="yes" xml:space="preserve">
          <source>To see relevant version information for ssl, call &lt;code&gt;ssl:versions/0&lt;/code&gt; .</source>
          <target state="translated">ssl에 대한 관련 버전 정보를 보려면 &lt;code&gt;ssl:versions/0&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b01a4feb6bffa4cdaf907be61314c3a9080a6778" translate="yes" xml:space="preserve">
          <source>To see what &lt;code&gt;-no_prefetch&lt;/code&gt; does, let's first look at the default code generation. Here is the code generated for &lt;code&gt;move_cx&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;-no_prefetch&lt;/code&gt; 의 기능 을 확인하기 위해 먼저 기본 코드 생성을 살펴 보겠습니다. &lt;code&gt;move_cx&lt;/code&gt; 에 대해 생성 된 코드는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1a753c21aa1ee5d67b189d4fc20785c035d677" translate="yes" xml:space="preserve">
          <source>To see what names there are:</source>
          <target state="translated">어떤 이름이 있는지 보려면 :</target>
        </trans-unit>
        <trans-unit id="fac884f3e42129e5cef89147e288ea2b8ca2327a" translate="yes" xml:space="preserve">
          <source>To see which filters are currently installed in the system, use &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt; logger:get_config/0&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt; logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt; logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt;. Filters are listed in the order they are applied, that is, the first filter in the list is applied first, and so on.</source>
          <target state="translated">현재 시스템에 설치된 필터를 확인하려면 &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt; logger:get_config/0&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt; logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt; logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 . 필터는 적용된 순서대로 나열됩니다. 즉, 목록의 첫 번째 필터가 먼저 적용되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="1859a2e235479aee5e6ed677756b1cdde77dacdb" translate="yes" xml:space="preserve">
          <source>To see which filters are currently installed in the system, use &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt;. Filters are listed in the order they are applied, that is, the first filter in the list is applied first, and so on.</source>
          <target state="translated">현재 시스템에 설치된 필터를 보려면 &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt;logger:get_config/0&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;logger#get_primary_config-0&quot;&gt;logger:get_primary_config/0&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-1&quot;&gt;logger:get_handler_config/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 . 필터는 적용된 순서대로 나열됩니다. 즉, 목록의 첫 번째 필터가 먼저 적용되는 방식으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="45a5562edb75b6f3eb1acaabf3b28d155bb31931" translate="yes" xml:space="preserve">
          <source>To select more text than fits in the window, start by selecting a small part in the beginning of the text you want, then use the scrollbar to view the end of the desired selection, point to it, and press the &lt;strong&gt;right&lt;/strong&gt; mouse button. The whole area between your first selection and the point where you right-clicked is included in the selection.</source>
          <target state="translated">창에 맞는 것보다 많은 텍스트를 선택하려면 원하는 텍스트의 시작 부분에서 작은 부분을 선택한 다음 스크롤 막대를 사용하여 원하는 선택의 끝을보고 가리킨 다음 마우스 &lt;strong&gt;오른쪽&lt;/strong&gt; 버튼을 누릅니다. 첫 번째 선택과 마우스 오른쪽 버튼으로 클릭 한 지점 사이의 전체 영역이 선택에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="33c0c20ef88e8a421c1e58b4d073cd8cec174df4" translate="yes" xml:space="preserve">
          <source>To select text in the &lt;code&gt;werl&lt;/code&gt; window, press and hold the left mouse button and drag the mouse over the text you want to select. If the selection crosses line boundaries, the selected text consists of complete lines where applicable (just like in a word processor).</source>
          <target state="translated">&lt;code&gt;werl&lt;/code&gt; 창 에서 텍스트를 선택하려면 마우스 왼쪽 버튼을 누른 채 마우스를 선택하려는 텍스트 위로 드래그하십시오. 선택 영역이 선 경계를 넘는 경우 선택한 텍스트는 해당되는 경우 완전한 선으로 구성됩니다 (워드 프로세서에서와 ​​같이).</target>
        </trans-unit>
        <trans-unit id="baa709b93b3829a0df77188d6fd0ef0592956e57" translate="yes" xml:space="preserve">
          <source>To separate the first elements of the list from the rest of the list, &lt;code&gt;|&lt;/code&gt; is used. &lt;code&gt;First&lt;/code&gt; has got value 1 and &lt;code&gt;TheRest&lt;/code&gt; has got the value [2,3,4,5].</source>
          <target state="translated">목록의 첫 번째 요소를 나머지 목록과 분리하려면 &lt;code&gt;|&lt;/code&gt; 사용. &lt;code&gt;First&lt;/code&gt; 값은 1이고 &lt;code&gt;TheRest&lt;/code&gt; 는 [2,3,4,5]입니다.</target>
        </trans-unit>
        <trans-unit id="99399a80e908574c88a36cb976c633b07714e9f8" translate="yes" xml:space="preserve">
          <source>To set it, set the option &lt;code&gt;{key_cb, {ssh_file, [{optimize,TimeOrSpace}]}&lt;/code&gt; in the call of &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;&quot;ssh:connect/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2&lt;/a&gt;&lt;/code&gt; or similar function call that initiates an ssh connection.</source>
          <target state="translated">이를 설정하려면 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;&quot;ssh:connect/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2&lt;/a&gt;&lt;/code&gt; 또는 ssh 연결을 시작하는 유사한 함수 호출 에서 &lt;code&gt;{key_cb, {ssh_file, [{optimize,TimeOrSpace}]}&lt;/code&gt; 옵션을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c01449dac6b2c1e79ac6f7a80fed6fdc43f67423" translate="yes" xml:space="preserve">
          <source>To set the default handler, that starts initially with the Kernel application, to log to file instead of &lt;code&gt;standard_io&lt;/code&gt;, change the Kernel default logger configuration. Example:</source>
          <target state="translated">커널 응용 프로그램으로 처음 시작하는 기본 핸들러를 &lt;code&gt;standard_io&lt;/code&gt; 대신 파일에 로그하도록 설정하려면 커널 기본 로거 구성을 변경하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="f3ccaabc6c6c384fa4607146b378de54d2e651c3" translate="yes" xml:space="preserve">
          <source>To set the time warp mode, pass command-line argument &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시간 왜곡 모드를 설정하려면 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#+C_&quot;&gt;+C [no_time_warp|single_time_warp|multi_time_warp]&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0688ed50c18775a5b27e32c9d7ee33f891bdef" translate="yes" xml:space="preserve">
          <source>To set up Erlang distribution over TLS:</source>
          <target state="translated">TLS를 통한 Erlang 배포를 설정하려면</target>
        </trans-unit>
        <trans-unit id="d2cce9d630a9f1b9f9af96de1b5c45472cb5cc3c" translate="yes" xml:space="preserve">
          <source>To set up client/server connections:</source>
          <target state="translated">클라이언트 / 서버 연결을 설정하려면</target>
        </trans-unit>
        <trans-unit id="b43c85b2017cddcd0eeca4a7ee756681a2b5279f" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a UNIX systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt; in the your home directory.</source>
          <target state="translated">UNIX 시스템에서 Erlang Emacs 모드를 설정하려면 홈 디렉토리에서 &lt;code&gt;.emacs&lt;/code&gt; 파일을 편집 / 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="17525f3111c9dc221811cc59d7953bea94c55a6a" translate="yes" xml:space="preserve">
          <source>To set up the Erlang Emacs mode on a Windows systems, edit/create the file &lt;code&gt;.emacs&lt;/code&gt;, the location of the file depends on the configuration of the system. If the &lt;strong&gt;HOME&lt;/strong&gt; environment variable is set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in the directory indicated by the &lt;strong&gt;HOME&lt;/strong&gt; variable. If &lt;strong&gt;HOME&lt;/strong&gt; is not set, Emacs will look for the &lt;code&gt;.emacs&lt;/code&gt; file in &lt;code&gt;C:\&lt;/code&gt;.</source>
          <target state="translated">Windows 시스템에서 Erlang Emacs 모드를 설정하려면 파일 &lt;code&gt;.emacs&lt;/code&gt; 를 편집 / 작성하십시오. 파일 의 위치는 시스템 구성에 따라 다릅니다. 는 IF &lt;strong&gt;홈페이지&lt;/strong&gt; 환경 변수가 설정되어, 이맥스는 찾습니다 &lt;code&gt;.emacs&lt;/code&gt; 디렉토리에 의해 표시에 파일 &lt;strong&gt;홈페이지&lt;/strong&gt; 변수입니다. 경우 &lt;strong&gt;홈페이지가&lt;/strong&gt; 설정되어 있지 않은, 이맥스는 찾습니다 &lt;code&gt;.emacs&lt;/code&gt; 에서 파일을 &lt;code&gt;C:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3c1a4e5864dbab572e9a5afb37792b236ea4a2" translate="yes" xml:space="preserve">
          <source>To simplify driver replacement, avoid designing your system so that more than one &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; has the driver loaded.</source>
          <target state="translated">드라이버 교체를 단순화하려면 둘 이상의 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 드라이버를로드 하도록 시스템을 설계하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="6657bbbea9ee8b248ced80c3f983940e0a515151" translate="yes" xml:space="preserve">
          <source>To simulate a busy server, you can insert a delay between when &lt;code&gt;epmd&lt;/code&gt; gets notified that a new connection is requested and when the connection gets accepted.</source>
          <target state="translated">사용중인 서버를 시뮬레이트하기 위해 &lt;code&gt;epmd&lt;/code&gt; 에 새 연결이 요청되었다는 알림과 연결이 허용 되는 시점 사이에 지연을 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70ce8a79d8ffb4771e6a29808f1bcbc9c8b69320" translate="yes" xml:space="preserve">
          <source>To specify if the &lt;code&gt;cover&lt;/code&gt; tool is to be stopped after the test is completed (see &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">테스트가 완료된 후 &lt;code&gt;cover&lt;/code&gt; 도구를 중지 할지 여부를 지정하려면 ( &lt;code&gt;&lt;a href=&quot;cover_chapter#cover_stop&quot;&gt;Code Coverage Analysis&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f982d3b08151a090766a53c8ae58a0af1c7b2c36" translate="yes" xml:space="preserve">
          <source>To specify in which order groups are to be executed (also with respect to test cases that are not part of any group), add tuples on the form &lt;code&gt;{group,GroupName}&lt;/code&gt; to the &lt;code&gt;all/0&lt;/code&gt; list.</source>
          <target state="translated">차 단체 (또한 임의의 그룹의 일부가 아닌 테스트 케이스에 대해) 실행되어야하는 지정하려면 폼에 추가 튜플 &lt;code&gt;{group,GroupName}&lt;/code&gt; 받는 &lt;code&gt;all/0&lt;/code&gt; 목록.</target>
        </trans-unit>
        <trans-unit id="1db9eb6998e57480fd022b5b675c80cbbd9dce31" translate="yes" xml:space="preserve">
          <source>To specify starting line for scanning in document which contains fragments of XML.</source>
          <target state="translated">XML 조각이 포함 된 문서에서 스캔을위한 시작 줄을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f61119c7e1b2cdde6ff6d2fa7c86881726228a8c" translate="yes" xml:space="preserve">
          <source>To specify the modules to be included in the code coverage test, provide a cover specification file. With this file you can point out specific modules or specify directories containing modules to be included in the analysis. You can also specify modules to be excluded from the analysis.</source>
          <target state="translated">코드 커버리지 테스트에 포함될 모듈을 지정하려면 커버 스펙 파일을 제공하십시오. 이 파일을 사용하면 특정 모듈을 지정하거나 분석에 포함 할 모듈이 포함 된 디렉토리를 지정할 수 있습니다. 분석에서 제외 할 모듈을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7e24433e118f3675a94b0839832059d75700c72" translate="yes" xml:space="preserve">
          <source>To specify which PLT, use option &lt;code&gt;--plt&lt;/code&gt;.</source>
          <target state="translated">어떤 PLT를 지정하려면 &lt;code&gt;--plt&lt;/code&gt; 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="18d24b6fe052b97ca4a3faae65960b6ff118b488" translate="yes" xml:space="preserve">
          <source>To speed up the execution of &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt;, first call &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt;, using option &lt;code&gt;purge&lt;/code&gt;. This does the same check for old code. Then purges all modules that can be soft-purged. The purged modules do then no longer have any old code, and &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; does not need to do the checks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 의 실행 속도를 높이려면 먼저 &lt;code&gt;purge&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;&lt;a href=&quot;#check_install_release-1&quot;&gt;check_install_release&lt;/a&gt;&lt;/code&gt; 를 호출 하십시오 . 이전 코드와 동일한 검사를 수행합니다. 그런 다음 소프트 퍼지 할 수있는 모든 모듈을 제거합니다. 제거 된 모듈에는 더 이상 이전 코드 가 없으므로 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release&lt;/a&gt;&lt;/code&gt; 는 점검 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcb51d3d9e102b6569769ee6c7abeefeaf086476" translate="yes" xml:space="preserve">
          <source>To start a sequential trace, the user must explicitly set the trace token in the process that will send the first information in a sequence.</source>
          <target state="translated">순차 추적을 시작하려면 사용자가 시퀀스의 첫 번째 정보를 보낼 프로세스에서 추적 토큰을 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="881ed36f05e94ae0a21c8004b304eb3bc37646d6" translate="yes" xml:space="preserve">
          <source>To start a sequential trace, the user must explicitly set the trace token in the process that will send the first message in a sequence.</source>
          <target state="translated">순차적 추적을 시작하려면 첫 번째 메시지를 순서대로 보내는 프로세스에서 추적 토큰을 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="76f1852c3add5606a83bf5fb3f21588a546c38d4" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원격 노드에서 유사한 추적 프로그램을 시작하려면 &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="af5676be701d6ebffdcd18fcceb076e666de274b" translate="yes" xml:space="preserve">
          <source>To start a similar tracer on a remote node, use &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원격 노드에서 유사한 추적 프로그램을 시작하려면 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="069df5419adf0afb2c7538e01048c5b636cbd10a" translate="yes" xml:space="preserve">
          <source>To start all applications specified in the original &lt;code&gt;mysystem.rel&lt;/code&gt; file, use flag &lt;code&gt;-boot&lt;/code&gt; as follows:</source>
          <target state="translated">원래 &lt;code&gt;mysystem.rel&lt;/code&gt; 파일에 지정된 모든 응용 프로그램을 시작하려면 다음과 같이 플래그 &lt;code&gt;-boot&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6430f32849bacfbbbfdd73794b90f8a5cb5633c" translate="yes" xml:space="preserve">
          <source>To start an &lt;strong&gt;embedded target system&lt;/strong&gt;, the shell script &lt;code&gt;bin/start&lt;/code&gt; is used. The script calls &lt;code&gt;bin/run_erl&lt;/code&gt;, which in turn calls &lt;code&gt;bin/start_erl&lt;/code&gt; (roughly, &lt;code&gt;start_erl&lt;/code&gt; is an embedded variant of &lt;code&gt;erl&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;임베디드 대상 시스템&lt;/strong&gt; 을 시작하려면 쉘 스크립트 &lt;code&gt;bin/start&lt;/code&gt; 가 사용됩니다. 이 스크립트는 &lt;code&gt;bin/run_erl&lt;/code&gt; 을 호출하고 차례로 &lt;code&gt;bin/start_erl&lt;/code&gt; 을 호출합니다 (대개 &lt;code&gt;start_erl&lt;/code&gt; 은 &lt;code&gt;erl&lt;/code&gt; 의 내장 변형입니다 ).</target>
        </trans-unit>
        <trans-unit id="9d22fc7b6b61af9ef2d6145dba2c1c36bbe3774d" translate="yes" xml:space="preserve">
          <source>To start an event manager for handling errors, as described in the previous example, call the following function:</source>
          <target state="translated">이전 예에서 설명한대로 오류 처리를 위해 이벤트 관리자를 시작하려면 다음 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="65443b4fc91dab6b76dab71d1d80de342db77ebd" translate="yes" xml:space="preserve">
          <source>To start the &lt;code&gt;Company&lt;/code&gt; database and get it running on the two specified nodes, enter the following commands:</source>
          <target state="translated">&lt;code&gt;Company&lt;/code&gt; 데이터베이스 를 시작하고 지정된 두 노드에서 실행하려면 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="b812e0ece5117a4dc75569139c24b19927c8e4d0" translate="yes" xml:space="preserve">
          <source>To start the debug enabled runtime system execute:</source>
          <target state="translated">디버그 가능 런타임 시스템을 시작하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7fffc54b92267ef311f536c196ba13936bd59530" translate="yes" xml:space="preserve">
          <source>To start the interactive shell mode, start an Erlang shell manually and call &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; to install any configuration data you might need (use &lt;code&gt;[]&lt;/code&gt; as argument otherwise). Then call &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; to start &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">대화식 쉘 모드를 시작하려면 Erlang 쉘을 수동으로 시작하고 &lt;code&gt;&lt;a href=&quot;ct#install-1&quot;&gt;ct:install/1&lt;/a&gt;&lt;/code&gt; 을 호출 하여 필요한 구성 데이터를 설치하십시오 ( 그렇지 않으면 &lt;code&gt;[]&lt;/code&gt; 를 인수로 사용하십시오 ). 그런 다음 &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; 을 호출 하여 &lt;code&gt;Common Test&lt;/code&gt; 를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="2407e72a3ed0dce989e1ddb620f5b91d6fb2b5a8" translate="yes" xml:space="preserve">
          <source>To start, open a registry:</source>
          <target state="translated">시작하려면 레지스트리를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="37329084650848867e8284198738d0867fe2834a" translate="yes" xml:space="preserve">
          <source>To stop Erlang Top, use function &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang Top을 중지하려면 &lt;code&gt;&lt;a href=&quot;etop#stop-0&quot;&gt;etop:stop/0&lt;/a&gt;&lt;/code&gt; 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0a960f069bc98edbba1ff0928e02093c32ffad4" translate="yes" xml:space="preserve">
          <source>To stop a distributed application, &lt;code&gt;stop/1&lt;/code&gt; must be called on all nodes where it can execute (that is, on all nodes where it has been started). The call to &lt;code&gt;stop/1&lt;/code&gt; on the node where the application currently executes stops its execution. The application is not moved between nodes, as &lt;code&gt;stop/1&lt;/code&gt; is called on the node where the application currently executes before &lt;code&gt;stop/1&lt;/code&gt; is called on the other nodes.</source>
          <target state="translated">분산 응용 프로그램을 중지하려면 실행할 수있는 모든 노드 (즉, 시작된 모든 노드)에서 &lt;code&gt;stop/1&lt;/code&gt; 을 호출해야합니다. 애플리케이션이 현재 실행중인 노드에서 &lt;code&gt;stop/1&lt;/code&gt; 을 호출하면 실행이 중지됩니다. 다른 노드에서 &lt;code&gt;stop/1&lt;/code&gt; 이 호출 되기 전에 현재 응용 프로그램이 실행되는 노드에서 &lt;code&gt;stop/1&lt;/code&gt; 이 호출 되므로 응용 프로그램이 노드간에 이동되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5b81bcf2bbed22c8b9d584525dc2bbe3c5752e21" translate="yes" xml:space="preserve">
          <source>To stop one or more tests, use function &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; (to stop all) or &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 테스트를 중지하려면 함수 &lt;code&gt;&lt;a href=&quot;ct_master#abort-0&quot;&gt;ct_master:abort()&lt;/a&gt;&lt;/code&gt; (모두 중지) 또는 &lt;code&gt;&lt;a href=&quot;ct_master#abort-1&quot;&gt;ct_master:abort(Nodes)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b41c55a13290a9e7e9fdbffa7dec308f34e8baa6" translate="yes" xml:space="preserve">
          <source>To stop the Erlang emulator, close the &lt;code&gt;werl&lt;/code&gt; window.</source>
          <target state="translated">Erlang 에뮬레이터를 중지하려면 &lt;code&gt;werl&lt;/code&gt; 창을 닫으십시오 .</target>
        </trans-unit>
        <trans-unit id="805a085d9254eb5937e5f4dd565453dd8d6af7f9" translate="yes" xml:space="preserve">
          <source>To sum up this section: &lt;strong&gt;Do not use &lt;code&gt;erlang:now/0&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">이 섹션을 요약하면 : &lt;strong&gt; &lt;code&gt;erlang:now/0&lt;/code&gt; 을&lt;/strong&gt;&lt;strong&gt; 사용하지 마십시오 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4c3f23c8b7d11fd791f43a0f06c76ab501c60d6" translate="yes" xml:space="preserve">
          <source>To summarize, &lt;code&gt;my_binary_to_list/1&lt;/code&gt; only needs to create &lt;strong&gt;one&lt;/strong&gt; match context and no sub binaries.</source>
          <target state="translated">요약하면, &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 은 &lt;strong&gt;하나의&lt;/strong&gt; 일치 컨텍스트 만 작성 하고 하위 바이너리는 작성 하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="76f6d1c7fd98a557f9e7456fd478d01cb713b47b" translate="yes" xml:space="preserve">
          <source>To support Unicode in Erlang, problems in various areas have been addressed. This section describes each area briefly and more thoroughly later in this User's Guide.</source>
          <target state="translated">Erlang에서 유니 코드를 지원하기 위해 다양한 영역의 문제가 해결되었습니다. 이 섹션에서는이 사용 설명서 뒷부분에서 각 영역에 대해 간략하고 자세하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="490eb8f14b00a3993b65db4b76111ea78b82422f" translate="yes" xml:space="preserve">
          <source>To support the debug facilites in &lt;code&gt;sys&lt;/code&gt;, a &lt;strong&gt;debug structure&lt;/strong&gt; is needed. The &lt;code&gt;Deb&lt;/code&gt; term is initialized using &lt;code&gt;sys:debug_options/1&lt;/code&gt;:</source>
          <target state="translated">에서 디버그 부대 시설 지원하기 위해 &lt;code&gt;sys&lt;/code&gt; 하는 &lt;strong&gt;디버그 구조가&lt;/strong&gt; 필요하다. &lt;code&gt;Deb&lt;/code&gt; 용어는 사용하여 초기화 &lt;code&gt;sys:debug_options/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27cb03280676d8f91c2c5f4617f6dcad84db1918" translate="yes" xml:space="preserve">
          <source>To take Erlang down gracefully, see the &lt;code&gt;erl_call(1)&lt;/code&gt; manual page in &lt;code&gt;erl_interface&lt;/code&gt; for details on the use of &lt;code&gt;erl_call&lt;/code&gt;. However, that requires that Erlang runs as a distributed node, which is not always the case.</source>
          <target state="translated">우아하게 얼랑을 촬영하려면 참조 &lt;code&gt;erl_call(1)&lt;/code&gt; 의 매뉴얼 페이지 &lt;code&gt;erl_interface&lt;/code&gt; 의 사용에 대한 자세한 내용은 &lt;code&gt;erl_call&lt;/code&gt; 을 . 그러나 Erlang을 분산 노드로 실행해야하지만 항상 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="794cd63b456b29e5f25c1b3a3a1a7cadacb90ffd" translate="yes" xml:space="preserve">
          <source>To test the distribution, the &lt;code&gt;net_kernel:start/1&lt;/code&gt; function can be used. It is useful, as it starts the distribution on a running system, where tracing/debugging can be performed. The &lt;code&gt;net_kernel:start/1&lt;/code&gt; routine takes a list as its single argument. The list first element in the list is to be the node name (without the &quot;@hostname&quot;) as an atom. The second (and last) element is to be one of the atoms &lt;code&gt;shortnames&lt;/code&gt; or &lt;code&gt;longnames&lt;/code&gt;. In the example case, &lt;code&gt;shortnames&lt;/code&gt; is preferred.</source>
          <target state="translated">분배를 테스트하기 위해 &lt;code&gt;net_kernel:start/1&lt;/code&gt; 기능을 사용할 수 있습니다. 추적 / 디버깅을 수행 할 수있는 실행중인 시스템에서 배포를 시작하므로 유용합니다. &lt;code&gt;net_kernel:start/1&lt;/code&gt; 루틴은 단일 인수로 목록을합니다. 목록에서 목록의 첫 번째 요소는 &quot;@hostname&quot;없이 노드 이름이 아톰 인 것입니다. 두 번째 (및 마지막) 요소는 원자의 &lt;code&gt;shortnames&lt;/code&gt; 또는 &lt;code&gt;longnames&lt;/code&gt; 중 하나입니다 . 이 예에서는 &lt;code&gt;shortnames&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="1e25ada887f1b7f960ffeb09cb03b19c929e33ba" translate="yes" xml:space="preserve">
          <source>To the extent that it's practical, support SystemTap on Linux via DTrace provider compatibility.</source>
          <target state="translated">가능한 한 DTrace 제공자 호환성을 통해 Linux에서 SystemTap을 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="250e07e289185ee8c7406f121d27b06d85769339" translate="yes" xml:space="preserve">
          <source>To the left of the &lt;code&gt;:=&lt;/code&gt; is the name of the specific instruction that should be implemented by the fragments, in this case &lt;code&gt;i_increment&lt;/code&gt;. To the right of &lt;code&gt;:=&lt;/code&gt; is the name of the group with the fragments, followed by a &lt;code&gt;.&lt;/code&gt;. Then the name of the fragments in the group are listed in the order they should be executed. Note that the &lt;code&gt;head&lt;/code&gt; fragment is not listed.</source>
          <target state="translated">&lt;code&gt;:=&lt;/code&gt; 왼쪽 에는 조각에 의해 구현되어야하는 특정 명령어의 이름이 있습니다 (이 경우 &lt;code&gt;i_increment&lt;/code&gt; ) . &lt;code&gt;:=&lt;/code&gt; 의 오른쪽 에는 조각이있는 그룹의 이름과 &lt;code&gt;.&lt;/code&gt; . 그런 다음 그룹의 조각 이름이 실행되어야하는 순서대로 나열됩니다. 점을 유의 &lt;code&gt;head&lt;/code&gt; 조각이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fded3aabb510b1e1a75f760a53342f304a3c739e" translate="yes" xml:space="preserve">
          <source>To to start the application (agent and/or manager), the configuration files must be modified and there are two ways of doing this. Either edit the files manually, or run the configuration tool as follows.</source>
          <target state="translated">응용 프로그램 (에이전트 및 / 또는 관리자)을 시작하려면 구성 파일을 수정해야하며 두 가지 방법이 있습니다. 파일을 수동으로 편집하거나 다음과 같이 구성 도구를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="840859542432e2ae9a768d1a2567eb03227d2acc" translate="yes" xml:space="preserve">
          <source>To trace function calls, you also need to set up &lt;strong&gt;trace patterns&lt;/strong&gt;. Trace patterns select the function calls to be traced. The number of traced function calls can be further reduced with &lt;strong&gt;match specifications&lt;/strong&gt;. Match specifications can also be used to trigger more information in the trace messages.</source>
          <target state="translated">함수 호출을 추적하려면 추적 &lt;strong&gt;패턴도&lt;/strong&gt; 설정해야 &lt;strong&gt;합니다&lt;/strong&gt; . 추적 패턴은 추적 할 함수 호출을 선택합니다. &lt;strong&gt;일치 스펙&lt;/strong&gt; 으로 추적 된 함수 호출 수를 추가로 줄일 수 있습니다 . 일치 스펙을 사용하여 추적 메시지에서 추가 정보를 트리거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c07cb7f2e8d2563df9d5fc9199e90556dc33e70" translate="yes" xml:space="preserve">
          <source>To trigger file compression, its extension must match with the &lt;code&gt;compress&lt;/code&gt; condition and must not match the &lt;code&gt;uncompress&lt;/code&gt; condition. For example, if &lt;code&gt;compress&lt;/code&gt; is set to &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; is set to &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt;, only files with extension &lt;code&gt;&quot;gif&quot;&lt;/code&gt; are compressed.</source>
          <target state="translated">파일 압축을 트리거하려면 확장자가 &lt;code&gt;compress&lt;/code&gt; 조건과 일치해야하며 &lt;code&gt;uncompress&lt;/code&gt; 조건 과 일치하지 않아야합니다 . 예를 들어, &lt;code&gt;compress&lt;/code&gt; 가 &lt;code&gt;[&quot;gif&quot;, &quot;jpg&quot;]&lt;/code&gt; 로 설정 되고 &lt;code&gt;uncompress&lt;/code&gt; 가 &lt;code&gt;[&quot;jpg&quot;]&lt;/code&gt; 로 설정 되면 확장자가 &lt;code&gt;&quot;gif&quot;&lt;/code&gt; 인 파일 만 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcf647abab37b8b3f8542efaeba10430ea6f745" translate="yes" xml:space="preserve">
          <source>To turn off the Debugger stack trace facility, select option &lt;strong&gt;Stack Off&lt;/strong&gt;.</source>
          <target state="translated">디버거 스택 추적 기능을 끄려면 &lt;strong&gt;스택 끄기&lt;/strong&gt; 옵션을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="25889e4ee1555771488e4d2de1a7bf2d51b5a3ab" translate="yes" xml:space="preserve">
          <source>To turn off warnings for improper lists, add the following line to the source file:</source>
          <target state="translated">부적절한 목록에 대한 경고를 끄려면 소스 파일에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8ed98f94cb168a3368774c5de90ad9aac72676b6" translate="yes" xml:space="preserve">
          <source>To understand the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup, it is essential to understand how &lt;code&gt;Mnesia&lt;/code&gt; reacts when it loses contact with &lt;code&gt;Mnesia&lt;/code&gt; on another node. At this stage, &lt;code&gt;Mnesia&lt;/code&gt; cannot distinguish between a communication failure and a &quot;normal&quot; node-down. When this occurs, &lt;code&gt;Mnesia&lt;/code&gt; assumes that the other node is no longer running, whereas, in reality, the communication between the nodes has failed.</source>
          <target state="translated">시작시 &lt;code&gt;Mnesia&lt;/code&gt; 의 동작을 이해하려면 다른 노드 에서 &lt;code&gt;Mnesia&lt;/code&gt; 와의 연결이 끊어진 경우 &lt;code&gt;Mnesia&lt;/code&gt; 가 어떻게 반응 하는지 이해해야합니다 . 이 단계에서 &lt;code&gt;Mnesia&lt;/code&gt; 는 통신 장애와 &quot;정상&quot;노드 다운을 구별 할 수 없습니다. 이러한 상황이 발생하면 &lt;code&gt;Mnesia&lt;/code&gt; 는 다른 노드가 더 이상 실행되고 있지 않다고 가정하지만 실제로는 노드 간 통신이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="57ca1753f443dcffddf87cab0a01f1c5e59426d5" translate="yes" xml:space="preserve">
          <source>To understand this text, you also have to look at the &lt;code&gt;yacc&lt;/code&gt; documentation in the UNIX(TM) manual. This is most probably necessary in order to understand the idea of a parser generator, and the principle and problems of LALR parsing with finite look-ahead.</source>
          <target state="translated">이 텍스트를 이해하려면 UNIX (TM) 매뉴얼 의 &lt;code&gt;yacc&lt;/code&gt; 문서 를 봐야합니다 . 이것은 아마도 파서 생성기의 아이디어와 유한 미리보기로 LALR 파싱의 원리와 문제점을 이해하기 위해 필요할 것입니다.</target>
        </trans-unit>
        <trans-unit id="257c2b917b12b68949e96a87bad80aa179cede62" translate="yes" xml:space="preserve">
          <source>To understand what is discussed and examplified here, we recommended you to first read section &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 논의하고 시험 한 내용을 이해하려면 먼저 &lt;code&gt;&lt;a href=&quot;basics_chapter#basics&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; 섹션을 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c214f91d106ddf617278abe4918056162b083c9a" translate="yes" xml:space="preserve">
          <source>To unload it use crypto:ensure_engine_unloaded/1 which removes the ID from the internal list before unloading the engine.</source>
          <target state="translated">언로드하려면 엔진을 언로드하기 전에 내부 목록에서 ID를 제거하는 crypto : ensure_engine_unloaded / 1을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0d1537131067c43e7df0631cf8f01ef0dfa991f" translate="yes" xml:space="preserve">
          <source>To unregister a name:</source>
          <target state="translated">이름을 등록 취소하려면</target>
        </trans-unit>
        <trans-unit id="2d2a671d4b2f16d7f91c51ff47e2d4c92fb46607" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">게시 한 노드를 등록 해제하려면 &lt;code&gt;ei_publish()&lt;/code&gt; 에서 반환 한 설명자를 닫아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c7fc1b435a8defaf215479b11edd52150783be" translate="yes" xml:space="preserve">
          <source>To unregister a node you have published, you should instead close the descriptor that was returned by &lt;code&gt;ei_publish()&lt;/code&gt;.</source>
          <target state="translated">게시 한 노드를 등록 해제하려면 대신 &lt;code&gt;ei_publish()&lt;/code&gt; 에서 반환 한 설명자를 닫아야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b518c28463d854508111ea65fca22a57c4c2cf2" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor.</source>
          <target state="translated">EPMD에 등록을 취소하려면 반환 된 설명자를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="769d2fa177fb9e7db683f9606bab6d12279b1eda" translate="yes" xml:space="preserve">
          <source>To unregister with EPMD, simply close the returned descriptor. Do not use &lt;code&gt;ei_unpublish()&lt;/code&gt;, which is deprecated anyway.</source>
          <target state="translated">EPMD에 등록을 취소하려면 반환 된 설명자를 닫으십시오. 더 이상 사용되지 않는 &lt;code&gt;ei_unpublish()&lt;/code&gt; 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="84b4679c04fbfbaa9588413bb040c5640c41eacc" translate="yes" xml:space="preserve">
          <source>To upgrade &lt;code&gt;ch_app&lt;/code&gt; from &lt;code&gt;&quot;1&quot;&lt;/code&gt; to &lt;code&gt;&quot;2&quot;&lt;/code&gt; (and to downgrade from &lt;code&gt;&quot;2&quot;&lt;/code&gt; to &lt;code&gt;&quot;1&quot;&lt;/code&gt;), you only need to load the new (old) version of the &lt;code&gt;ch3&lt;/code&gt; callback module. Create the application upgrade file &lt;code&gt;ch_app.appup&lt;/code&gt; in the &lt;code&gt;ebin&lt;/code&gt; directory:</source>
          <target state="translated">업그레이드하려면 &lt;code&gt;ch_app&lt;/code&gt; 에서 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 을 &lt;code&gt;&quot;2&quot;&lt;/code&gt; (과에서의 다운 그레이드에 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ), 당신은 단지 새로운 (구) 버전로드 할 필요 &lt;code&gt;ch3&lt;/code&gt; 콜백 모듈을. &lt;code&gt;ebin&lt;/code&gt; 디렉토리 에 애플리케이션 업그레이드 파일 &lt;code&gt;ch_app.appup&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c873673fdbf39b186e8a04df81cc090fc729ac9" translate="yes" xml:space="preserve">
          <source>To upgrade a TCP/IP connection to a TLS connection, the client and server must agree to do so. The agreement can be accomplished by using a protocol, for example, the one used by HTTP specified in RFC 2817.</source>
          <target state="translated">TCP / IP 연결을 TLS 연결로 업그레이드하려면 클라이언트와 서버가 이에 동의해야합니다. 계약은 RFC 2817에 지정된 HTTP에서 사용되는 프로토콜과 같은 프로토콜을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f84bf7f2f7861b776ed5c35e1c7e32583ad5a627" translate="yes" xml:space="preserve">
          <source>To upgrade a TCP/IP connection to an SSL connection, the client and server must agree to do so. The agreement can be accomplished by using a protocol, for example, the one used by HTTP specified in RFC 2817.</source>
          <target state="translated">TCP / IP 연결을 SSL 연결로 업그레이드하려면 클라이언트와 서버가 동의해야합니다. 계약은 프로토콜 (예 : RFC 2817에 지정된 HTTP에서 사용 된 프로토콜)을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3aeb788d6c5ac30b033b2b969b7da351f17b7f" translate="yes" xml:space="preserve">
          <source>To upgrade to a TLS connection:</source>
          <target state="translated">TLS 연결로 업그레이드하려면 :</target>
        </trans-unit>
        <trans-unit id="3a48c54fe1c18b840875cc0d8882a5c73ce80e02" translate="yes" xml:space="preserve">
          <source>To upgrade to an SSL connection:</source>
          <target state="translated">SSL 연결로 업그레이드하려면</target>
        </trans-unit>
        <trans-unit id="ea7b425544bac4acf2d4b893b416d117aa7a59a1" translate="yes" xml:space="preserve">
          <source>To use Debugger, the basic steps are as follows:</source>
          <target state="translated">디버거를 사용하기위한 기본 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68fe3f1ab7b67db6b1b7b0c723fb8ab99d7ba09b" translate="yes" xml:space="preserve">
          <source>To use a literal &lt;code&gt;*&lt;/code&gt; character as &lt;code&gt;Pad&lt;/code&gt;, it must be passed as an argument:</source>
          <target state="translated">리터럴 &lt;code&gt;*&lt;/code&gt; 문자를 &lt;code&gt;Pad&lt;/code&gt; 로 사용하려면 인수로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="818b4f8cff2ed9c56e379af0203202630de033f4" translate="yes" xml:space="preserve">
          <source>To use any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions, include the following line in your code:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 함수 를 사용하려면 코드에 다음 줄을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bfffbe9810584067e7d160ff8bce5770cf34f906" translate="yes" xml:space="preserve">
          <source>To use any of the &lt;code&gt;Erl_Interface&lt;/code&gt; functions, include the following lines in your code:</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; 함수 를 사용하려면 코드에 다음 줄을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="e865188bf7a27ada82ac1699872c1f2decf0665c" translate="yes" xml:space="preserve">
          <source>To use encrypted debug information, a key must be provided to the compiler and &lt;code&gt;beam_lib&lt;/code&gt;. The key is specified as a string. It is recommended that the string contains at least 32 characters and that both upper and lower case letters as well as digits and special characters are used.</source>
          <target state="translated">암호화 된 디버그 정보를 사용하려면 컴파일러와 &lt;code&gt;beam_lib&lt;/code&gt; 에 키를 제공해야합니다 . 키는 문자열로 지정됩니다. 문자열은 32 자 이상이어야하며 숫자와 특수 문자뿐만 아니라 대문자와 소문자를 모두 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eb23e34638bd9093d10ee97bb3a0e372512e3fc8" translate="yes" xml:space="preserve">
          <source>To use event handlers written for &lt;code&gt;error_logger&lt;/code&gt;, just add your event handler with</source>
          <target state="translated">&lt;code&gt;error_logger&lt;/code&gt; 용으로 작성된 이벤트 핸들러를 사용하려면 다음 과 같이 이벤트 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0bdc7b110d3152a509f4766a597abefcfa1ed87d" translate="yes" xml:space="preserve">
          <source>To use the Erlang shell to run our test, you can evaluate the following call:</source>
          <target state="translated">Erlang 셸을 사용하여 테스트를 실행하려면 다음 호출을 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f4462aadd9025ab266be32a2032bf299d0b46f7" translate="yes" xml:space="preserve">
          <source>To use the disk_log handler instead of the default standard handler when starting an Erlang node, change the Kernel default logger to use &lt;code&gt;logger_disk_log_h&lt;/code&gt;. Example:</source>
          <target state="translated">얼랑 노드를 시작할 때 기본 표준 핸들러 대신 disk_log 핸들러를 사용하려면 사용에 대한 커널의 기본 로거 변경 &lt;code&gt;logger_disk_log_h&lt;/code&gt; 을 . 예:</target>
        </trans-unit>
        <trans-unit id="48d471ac0f461634b1a46f1744c359ab442ae3b1" translate="yes" xml:space="preserve">
          <source>To use the functions &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;release_shell&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기능을 사용하려면 &lt;code&gt;&lt;a href=&quot;ct#break-1&quot;&gt;ct:break/1,2&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ct#continue-0&quot;&gt;ct:continue/0,1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;release_shell&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 로 설정 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d698f2ffb5c429ffda0ac4557a52f1824b92cf1d" translate="yes" xml:space="preserve">
          <source>To use the pseudo functions triggering the translation, ensure to include the header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code. Failure to do so possibly results in runtime errors rather than compile time, as the expression can be valid as a plain Erlang program without translation.</source>
          <target state="translated">변환을 트리거하는 의사 함수를 사용하려면 소스 코드에 헤더 파일 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 을 포함시켜야합니다 . 그렇지 않으면 표현식이 변환없이 일반 Erlang 프로그램으로 유효 할 수 있으므로 컴파일 시간이 아닌 런타임 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f67b62fca597162026995f6815a18764fa1055" translate="yes" xml:space="preserve">
          <source>To use the real implementation, we must recompile the MIB and load it into the agent.</source>
          <target state="translated">실제 구현을 사용하려면 MIB를 다시 컴파일하여 에이전트에로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6519596ccb4c5e8b4c324416978687438404d59" translate="yes" xml:space="preserve">
          <source>To use this function for adding drivers residing in dynamically loaded code is dangerous. If the driver code for the added driver resides in the same dynamically loaded module (that is, &lt;code&gt;.so&lt;/code&gt; file) as a normal dynamically loaded driver (loaded with the &lt;code&gt;erl_ddll&lt;/code&gt; interface), the caller is to call &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt; driver_lock_driver&lt;/a&gt;&lt;/code&gt; before adding driver entries.</source>
          <target state="translated">동적으로로드 된 코드에있는 드라이버를 추가하는 데이 기능을 사용하는 것은 위험합니다. 추가 된 드라이버의 드라이버 코드 가 일반 동적로드 드라이버 ( &lt;code&gt;erl_ddll&lt;/code&gt; 인터페이스로 로드 됨)와 동일한 동적로드 모듈 (즉, &lt;code&gt;.so&lt;/code&gt; 파일)에있는 경우 호출자는 드라이버 항목을 추가하기 전에 &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt; driver_lock_driver&lt;/a&gt;&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="002952436d64ac58aa3de156b66387b85dc58e15" translate="yes" xml:space="preserve">
          <source>To use this function for adding drivers residing in dynamically loaded code is dangerous. If the driver code for the added driver resides in the same dynamically loaded module (that is, &lt;code&gt;.so&lt;/code&gt; file) as a normal dynamically loaded driver (loaded with the &lt;code&gt;erl_ddll&lt;/code&gt; interface), the caller is to call &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; before adding driver entries.</source>
          <target state="translated">동적으로로드 된 코드에있는 드라이버를 추가하기 위해이 기능을 사용하는 것은 위험합니다. 추가 된 드라이버의 드라이버 코드가 동적으로로드 된 일반 드라이버 ( &lt;code&gt;erl_ddll&lt;/code&gt; 인터페이스로 로드 됨)와 동일한 동적으로로드 된 모듈 (즉, &lt;code&gt;.so&lt;/code&gt; 파일)에있는 경우 호출자는 드라이버 항목을 추가하기 전에 &lt;code&gt;&lt;a href=&quot;#driver_lock_driver&quot;&gt;driver_lock_driver&lt;/a&gt;&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="06c29935ed139b37075ecc2db062cd1dfb073f59" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute in both phases is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모드를 사용하려면 두 단계에서 실행될 모든 Erlang 코드가 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="af48a71f55d5ffa8ab787fda3994e5f52dec889c" translate="yes" xml:space="preserve">
          <source>To use this mode, ensure that all Erlang code that will execute on the runtime system is &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모드를 사용하려면 런타임 시스템에서 실행될 모든 Erlang 코드가 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="847b164165eea8a7ac372dcfbedc4f6fbc9d1539" translate="yes" xml:space="preserve">
          <source>To use this program, you need to:</source>
          <target state="translated">이 프로그램을 사용하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6a7e1aba43c701aa62b9243d847578c39295abed" translate="yes" xml:space="preserve">
          <source>To use this with threads and asynchronous routines, create a pipe on Unix and an &lt;code&gt;Event&lt;/code&gt; on Windows. When the routine completes, write to the pipe (use &lt;code&gt;SetEvent&lt;/code&gt; on Windows), this makes the emulator call &lt;code&gt;ready_input&lt;/code&gt; or &lt;code&gt;ready_output&lt;/code&gt;.</source>
          <target state="translated">이것을 스레드 및 비동기 루틴과 함께 사용하려면 Unix에서 파이프를 작성하고 Windows 에서 &lt;code&gt;Event&lt;/code&gt; 를 작성하십시오. 루틴이 완료되면 파이프에 기록 ( Windows에서 &lt;code&gt;SetEvent&lt;/code&gt; 사용 )하면 에뮬레이터가 &lt;code&gt;ready_input&lt;/code&gt; 또는 &lt;code&gt;ready_output&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="01b8773f5a669a11ac026442b354c5f873c02791" translate="yes" xml:space="preserve">
          <source>To validate the configuration strings, the callback module is to have function &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; exported.</source>
          <target state="translated">구성 문자열의 유효성을 검사하기 위해 콜백 모듈은 &lt;code&gt;Callback:check_parameter/1&lt;/code&gt; 함수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="fe32e508b386431ed270d6f4036397947cfdf797" translate="yes" xml:space="preserve">
          <source>To verify that everything is ok you should open &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; in your web browser and make sure that there are zero failed test cases.</source>
          <target state="translated">모든 것이 &lt;code&gt;$ERL_TOP/release/tests/test_server/index.html&lt;/code&gt; 확인하려면 웹 브라우저에서 $ ERL_TOP / release / tests / test_server / index.html 을 열고 실패한 테스트 사례가 없는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="816f7f291832fe5da7fded15c95dc5548b14b744" translate="yes" xml:space="preserve">
          <source>To verify that lock counting is enabled check that &lt;code&gt;[lock-counting]&lt;/code&gt; appears in the status text when the VM is started.</source>
          <target state="translated">잠금 계산이 활성화되어 있는지 확인 하려면 VM이 시작될 때 상태 텍스트에 &lt;code&gt;[lock-counting]&lt;/code&gt; 이 나타나는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d79825059ed41d40f1eb38140584c29e49d43c05" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific module, double- click the row, or right-click it and select &lt;strong&gt;Properties for &amp;lt;mod&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">특정 모듈에 대한 자세한 정보를 보려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;mod&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3ee7cdc20eb34f07a508b3dffa9cad2da375fa2" translate="yes" xml:space="preserve">
          <source>To view detailed information about a specific process, double- click the row in the list, or right-click the row and select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">특정 프로세스에 대한 자세한 정보를 보려면 목록에서 행을 두 번 클릭하거나 행을 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;pid&amp;gt;에 대한 특성을&lt;/strong&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9a2be366e30f8af91ea3157c65f941baf52859b" translate="yes" xml:space="preserve">
          <source>To view more details about a specific port, double-click the row or right-click it and select &lt;strong&gt;Properties for &amp;lt;port&amp;gt;&lt;/strong&gt;. From the right-click menu, you can also select &lt;strong&gt;Properties for &amp;lt;pid&amp;gt;&lt;/strong&gt;, where &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; is the process connected to the port.</source>
          <target state="translated">특정 포트에 대한 자세한 내용을 보려면 행을 두 번 클릭하거나 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;&amp;lt;port&amp;gt;의 속성을&lt;/strong&gt; 선택하십시오 . 마우스 오른쪽 버튼 메뉴에서 &lt;strong&gt;&amp;lt;pid&amp;gt; 속성을&lt;/strong&gt; 선택할 수도 있습니다 . 여기서 &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt; 는 포트에 연결된 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="7c537dc716e918cf2d036be1a35d64af3e41081c" translate="yes" xml:space="preserve">
          <source>To view the result of a code coverage test, click the button labeled &quot;COVER LOG&quot; in the top-level index page for the test run.</source>
          <target state="translated">코드 적용 범위 테스트 결과를 보려면 테스트 실행을위한 최상위 인덱스 페이지에서 &quot;COVER LOG&quot;레이블이 지정된 단추를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="254465b8f25a6c97a3848f10e6162c3f124f7768" translate="yes" xml:space="preserve">
          <source>To view the result of macro expansion, a module can be compiled with the &lt;code&gt;'P'&lt;/code&gt; option. &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt;. This produces a listing of the parsed code after preprocessing and parse transforms, in the file &lt;code&gt;File.P&lt;/code&gt;.</source>
          <target state="translated">매크로 확장 결과를 보려면 &lt;code&gt;'P'&lt;/code&gt; 옵션을 사용하여 모듈을 컴파일 할 수 있습니다 . &lt;code&gt;compile:file(File, ['P'])&lt;/code&gt; . 이렇게하면 &lt;code&gt;File.P&lt;/code&gt; 파일에서 사전 처리 및 구문 분석 변환 후 구문 분석 된 코드 목록이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2863e2789d755b777cac4c624de8395bb36a4b90" translate="yes" xml:space="preserve">
          <source>To visualize the structure of a syntax tree, you can use the function &lt;code&gt;merl:show(T)&lt;/code&gt;, which prints a summary. For example, entering</source>
          <target state="translated">구문 트리의 구조를 시각화하기 위해 &lt;code&gt;merl:show(T)&lt;/code&gt; 함수를 사용하면 요약을 인쇄 할 수 있습니다 . 예를 들어,</target>
        </trans-unit>
        <trans-unit id="420f383fbb828ef9ba78290b1722db9b09af55f0" translate="yes" xml:space="preserve">
          <source>To work with binaries in ISO Latin-1 encoding, use the &lt;code&gt;file&lt;/code&gt; module instead.</source>
          <target state="translated">ISO Latin-1 인코딩에서 이진 파일로 작업하려면 &lt;code&gt;file&lt;/code&gt; 모듈을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9368499385b79811c6e242f08579ba92f510e423" translate="yes" xml:space="preserve">
          <source>To write a function that inserts an employee record into the database, there must be an &lt;code&gt;at_dep&lt;/code&gt; record and a set of &lt;code&gt;in_proj&lt;/code&gt; records inserted. Examine the following code used to complete this action:</source>
          <target state="translated">직원 레코드를 데이터베이스에 삽입하는 함수를 작성하려면 &lt;code&gt;at_dep&lt;/code&gt; 레코드와 일련의 &lt;code&gt;in_proj&lt;/code&gt; 레코드가 삽입 되어 있어야 합니다. 이 조치를 완료하는 데 사용 된 다음 코드를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="870bc92e8fb7bb157e38a72767baac7170c3e8c4" translate="yes" xml:space="preserve">
          <source>To write functions that manipulate this data, remember the following:</source>
          <target state="translated">이 데이터를 조작하는 함수를 작성하려면 다음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="49f4806c44f9e994d710db8f38c6399e247bca8a" translate="yes" xml:space="preserve">
          <source>To write your own client channel handler, use the behaviour &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt;. For server channel handlers use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; behaviour (replaces ssh_daemon_channel).</source>
          <target state="translated">고유 한 클라이언트 채널 핸들러를 작성하려면 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 동작을 사용하십시오 . 서버 채널 핸들러의 경우 &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;ssh_server_channel&lt;/a&gt;&lt;/code&gt; 동작을 사용하십시오 ( ssh_daemon_channel을 대체 함).</target>
        </trans-unit>
        <trans-unit id="f57b7cb4b41a526a6b5b1f9a162d27692ca9284c" translate="yes" xml:space="preserve">
          <source>Today there are no good ways of solving this problem and therefore the eval scheme can be removed in future release of &lt;code&gt;Inets&lt;/code&gt;.</source>
          <target state="translated">오늘날이 문제를 해결할 수있는 좋은 방법은 없으므로 향후 &lt;code&gt;Inets&lt;/code&gt; 릴리스에서 평가 체계를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7edb68e9d3675d0ca9b5133bc31d9005c2bc6f47" translate="yes" xml:space="preserve">
          <source>Too long external command.</source>
          <target state="translated">외부 명령이 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="306ef8d015fe20a0dcd8430c726d60b2b800ac4a" translate="yes" xml:space="preserve">
          <source>Tool Summary</source>
          <target state="translated">도구 요약</target>
        </trans-unit>
        <trans-unit id="b53132babe55797aa27d88cc20db666d7ee40a5b" translate="yes" xml:space="preserve">
          <source>Tools that need to know about optional callback functions can call &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; to get a list of all optional callback functions.</source>
          <target state="translated">선택적 콜백 함수에 대해 알아야하는 도구는 &lt;code&gt;Behaviour:behaviour_info(optional_callbacks)&lt;/code&gt; 를 호출하여 모든 선택적 콜백 함수 목록을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3a74b17c3a112fdfc9b4f6b58e1ba85a6ec96d" translate="yes" xml:space="preserve">
          <source>Top pad size (in kilobytes). This is the amount of extra memory that is allocated by &lt;code&gt;malloc&lt;/code&gt; when &lt;code&gt;sbrk&lt;/code&gt; is called to get more memory from the operating system. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">상단 패드 크기 (KB). 운영 체제에서 더 많은 메모리를 얻기 위해 &lt;code&gt;sbrk&lt;/code&gt; 가 호출 될 때 &lt;code&gt;malloc&lt;/code&gt; 에 의해 할당되는 추가 메모리의 양입니다 . 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8688b9f02fc264d86ffee1ffffdff34e5d5032b9" translate="yes" xml:space="preserve">
          <source>Total amount of data allocated by an Erlang node</source>
          <target state="translated">Erlang 노드가 할당 한 총 데이터 양</target>
        </trans-unit>
        <trans-unit id="15b379311d06275e570d3c8276f0c74ac315b01b" translate="yes" xml:space="preserve">
          <source>Total and own</source>
          <target state="translated">총 소유</target>
        </trans-unit>
        <trans-unit id="c2270f01832f95299124e422ec6e4ca5b86124d0" translate="yes" xml:space="preserve">
          <source>Total memory of all fragments</source>
          <target state="translated">모든 조각의 총 메모리</target>
        </trans-unit>
        <trans-unit id="7e54e8f9975c397f222301a7b10e36746a3fb103" translate="yes" xml:space="preserve">
          <source>Total scheduler utilization will equal &lt;code&gt;1.0&lt;/code&gt; when all schedulers have been active all the time between the two measurements.</source>
          <target state="translated">두 스케줄 사이에서 모든 스케줄러가 항상 활성화 된 경우 총 스케줄러 사용량은 &lt;code&gt;1.0&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="75f139724c9414120075277ba75a5a2d7bac69ee" translate="yes" xml:space="preserve">
          <source>Total size of all fragments</source>
          <target state="translated">모든 조각의 총 크기</target>
        </trans-unit>
        <trans-unit id="3d7796a77f0c2216ea352ac72490e4ec4449ab38" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers, weighted against maximum amount of available CPU time.</source>
          <target state="translated">사용 가능한 최대 CPU 시간에 가중치를 둔 모든 정상 및 더티 CPU 스케줄러의 총 이용률.</target>
        </trans-unit>
        <trans-unit id="6da5bac4a207bc853f48fee09219f38e35859ae6" translate="yes" xml:space="preserve">
          <source>Total utilization of all normal and dirty-cpu schedulers.</source>
          <target state="translated">모든 정상 및 더티 CPU 스케줄러의 전체 이용률.</target>
        </trans-unit>
        <trans-unit id="9bff8a7fc7360671cf907e56ce21842e96c20fad" translate="yes" xml:space="preserve">
          <source>TotalRunQueueLengths</source>
          <target state="translated">TotalRunQueueLengths</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="b977e923c4efbcbf64ad078300b599a2f20c534b" translate="yes" xml:space="preserve">
          <source>Trace Messages Sent to the System Tracer</source>
          <target state="translated">시스템 추적 프로그램에 보낸 추적 메시지</target>
        </trans-unit>
        <trans-unit id="0588c9e7ac9a2b21ded90cbcf26c439c837482b1" translate="yes" xml:space="preserve">
          <source>Trace Token</source>
          <target state="translated">추적 토큰</target>
        </trans-unit>
        <trans-unit id="80bb48f4677c815e975d8c45891c82e4681bcb89" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder</source>
          <target state="translated">트레이스 툴 빌더</target>
        </trans-unit>
        <trans-unit id="250a4f0c0db1541060f17b5d70ba72e38869d686" translate="yes" xml:space="preserve">
          <source>Trace Tool Builder is a base for building trace tools for single node or distributed Erlang systems. It requires the Runtime_Tools application to be available on the traced node.</source>
          <target state="translated">Trace Tool Builder는 단일 노드 또는 분산 Erlang 시스템을위한 추적 도구를 빌드하기위한 기반입니다. 추적 된 노드에서 Runtime_Tools 애플리케이션을 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e39bcc8d71bbaa0fa6b28e8699f8f1993f5c4d" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;arity&lt;/code&gt; can be used to change the contents of this message, so that &lt;code&gt;Arity&lt;/code&gt; is specified instead of &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Args&lt;/code&gt; 대신 &lt;code&gt;Arity&lt;/code&gt; 가 지정 되도록 추적 플래그 &lt;code&gt;arity&lt;/code&gt; 를 사용하여이 메시지의 내용을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2211485216352092a3c7b3ce77ba8fdb799ae23c" translate="yes" xml:space="preserve">
          <source>Trace flag &lt;code&gt;call&lt;/code&gt; is set on all processes. This means that any function activated with command &lt;code&gt;trc/1&lt;/code&gt; is traced on all existing and new processes.</source>
          <target state="translated">추적 플래그 &lt;code&gt;call&lt;/code&gt; 은 모든 프로세스에서 설정됩니다. 이는 &lt;code&gt;trc/1&lt;/code&gt; 명령으로 활성화 된 기능이 모든 기존 프로세스와 새 프로세스에서 추적 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0712efc6140a7fd34097a10dbcb83e8a2711b2c0" translate="yes" xml:space="preserve">
          <source>Trace garbage collection on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; that prints start, stop, and the time spent for each garbage collection.</source>
          <target state="translated">지정된 프로세스에서 가비지 콜렉션을 추적하십시오. 사용되는 형식 핸들러는 &lt;code&gt;multitrace:handle_gc/4&lt;/code&gt; 이며 시작, 중지 및 각 가비지 콜렉션에 소요 된 시간을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8ad201247194a3bc5c13be5040f0d1b1e662cf18" translate="yes" xml:space="preserve">
          <source>Trace in-scheduling and out-scheduling on the specified process(es). The format handler used is &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; that prints each in-scheduling and out-scheduling with process, time-stamp, and current function. It also prints the total time each traced process was scheduled in.</source>
          <target state="translated">지정된 프로세스에서 스케줄링 및 스케줄링을 추적합니다. 사용되는 형식 핸들러는 &lt;code&gt;multitrace:handle_schedule/4&lt;/code&gt; 이며 프로세스, 타임 스탬프 및 현재 기능을 사용하여 각 예약 및 예약을 인쇄합니다. 또한 추적 된 각 프로세스가 예약 된 총 시간을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ffc9984032978aa3b6449468569d3553d6cf5759" translate="yes" xml:space="preserve">
          <source>Trace messages:</source>
          <target state="translated">추적 메시지 :</target>
        </trans-unit>
        <trans-unit id="4d4722f0d0980b84f26e05618ea2d6105d2b13ac" translate="yes" xml:space="preserve">
          <source>Trace patterns can also be added for traced messages. Click button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt; and select &lt;strong&gt;Messages sent&lt;/strong&gt; or &lt;strong&gt;Messages received&lt;/strong&gt;, and a match specification.</source>
          <target state="translated">추적 된 메시지에 대한 추적 패턴을 추가 할 수도 있습니다. &lt;strong&gt;추적 패턴 추가&lt;/strong&gt; 단추를 클릭 하고 &lt;strong&gt;전송 된 &lt;/strong&gt;&lt;strong&gt;메시지&lt;/strong&gt; 또는 &lt;strong&gt;수신 된 메시지&lt;/strong&gt; 및 일치 스펙을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0940d3dfe2f33f718de044f09bc83c6282e8f2ee" translate="yes" xml:space="preserve">
          <source>Trace patterns only apply to the traced processes and ports.</source>
          <target state="translated">추적 패턴은 추적 된 프로세스 및 포트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9473289ba2f7fdb4aceac50e9847d3fb9343a9" translate="yes" xml:space="preserve">
          <source>Trace patterns specify how to trace a function or a message by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">추적 패턴은 일치 스펙을 사용하여 기능 또는 메시지를 추적하는 방법을 지정합니다. 일치 스펙은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02e22fba6caaac8c0531907ae75bbb4f037b1bf" translate="yes" xml:space="preserve">
          <source>Traces &lt;code&gt;Item&lt;/code&gt; in accordance to the value specified by &lt;code&gt;Flags&lt;/code&gt;. The variation of &lt;code&gt;Item&lt;/code&gt; is listed below:</source>
          <target state="translated">&lt;code&gt;Flags&lt;/code&gt; 로 지정된 값에 따라 &lt;code&gt;Item&lt;/code&gt; 을 추적 합니다 . &lt;code&gt;Item&lt;/code&gt; 의 변형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d4251419a7232d0215690c25726bd1d8598264d" translate="yes" xml:space="preserve">
          <source>Traces certain function calls. Specify which function calls to trace by calling &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특정 함수 호출을 추적합니다. &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 을 호출하여 추적 할 함수 호출을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d86b88eb80a4cb0c1e2e56d320a47a7c0a552ac" translate="yes" xml:space="preserve">
          <source>Traces certain function calls. Specify which function calls to trace by calling &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특정 함수 호출을 추적합니다. &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; 을 호출하여 추적 할 함수 호출을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6a38811b152556838705c34470f7050c3304700" translate="yes" xml:space="preserve">
          <source>Traces garbage collections of processes.</source>
          <target state="translated">가비지 프로세스 프로세스를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="0bfeea5f77e5e80144fb5c69582ff8a4c4aa0a8c" translate="yes" xml:space="preserve">
          <source>Traces global function calls for the process according to the trace patterns set in the system (see tp/2).</source>
          <target state="translated">시스템에 설정된 추적 패턴에 따라 프로세스에 대한 전역 함수 호출을 추적합니다 (tp / 2 참조).</target>
        </trans-unit>
        <trans-unit id="7b9365396596fa47926ca8347796645d68615fc5" translate="yes" xml:space="preserve">
          <source>Traces port related events to the port.</source>
          <target state="translated">포트 관련 이벤트를 포트로 추적합니다.</target>
        </trans-unit>
        <trans-unit id="9984d03ffd8c79d353ed1035134b4b78d308578d" translate="yes" xml:space="preserve">
          <source>Traces port-related events.</source>
          <target state="translated">포트 관련 이벤트를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="53c6e4ac66fc9e05350a56f9ce0407168d386402" translate="yes" xml:space="preserve">
          <source>Traces process related events to the process.</source>
          <target state="translated">프로세스 관련 이벤트를 프로세스로 추적합니다.</target>
        </trans-unit>
        <trans-unit id="29908912e6fff8dc5249509363a4412791547f21" translate="yes" xml:space="preserve">
          <source>Traces process-related events.</source>
          <target state="translated">프로세스 관련 이벤트를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="5fea32fcd1026ba95b7747cfa7687d7877ce29fa" translate="yes" xml:space="preserve">
          <source>Traces receiving of messages.</source>
          <target state="translated">메시지 수신을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="cc07cb20090b0accf4d5bc83ba241371cabc9b3a" translate="yes" xml:space="preserve">
          <source>Traces scheduling of exiting processes.</source>
          <target state="translated">종료 프로세스의 스케줄링을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="67d22b046457a4e977f4835a302c705d01e90b51" translate="yes" xml:space="preserve">
          <source>Traces scheduling of ports.</source>
          <target state="translated">포트 스케줄링을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="2f48a05431b99fc7b0ddcdfbdc7ffb069ba16117" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes just like &lt;code&gt;running&lt;/code&gt;. However, this option also includes schedule events when the process executes within the context of a port without being scheduled out itself.</source>
          <target state="translated">&lt;code&gt;running&lt;/code&gt; 과 같은 프로세스의 스케줄링을 추적 합니다 . 그러나이 옵션에는 프로세스가 자체적으로 스케줄되지 않고 포트 컨텍스트 내에서 실행될 때 스케줄 이벤트도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce958853f2f4b0ef08e9d0a61efd87ba237714e" translate="yes" xml:space="preserve">
          <source>Traces scheduling of processes.</source>
          <target state="translated">프로세스 스케줄링을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="c4c7172939e3bf7fce3abeb0aee363e0caeecf04" translate="yes" xml:space="preserve">
          <source>Traces sending of messages.</source>
          <target state="translated">메시지 전송을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="47adf62bbb5b7db2ff2d321ec8c4e3902e48036a" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives and sends.</source>
          <target state="translated">프로세스 또는 포트가 수신 및 전송하는 메시지를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="139350008a2a0843c976fc5033dee778dfce8767" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port receives.</source>
          <target state="translated">프로세스 또는 포트가 수신하는 메시지를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="bd14c1efd1ddeca64fe6450f80e57e6c1564eaab" translate="yes" xml:space="preserve">
          <source>Traces the messages the process or port sends.</source>
          <target state="translated">프로세스 또는 포트가 보내는 메시지를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="1253e547a3faeb02225fd239c7816e109cca29cf" translate="yes" xml:space="preserve">
          <source>Tracing Local Node from Erlang Shell</source>
          <target state="translated">Erlang Shell에서 로컬 노드 추적</target>
        </trans-unit>
        <trans-unit id="c82c46612470fc95ddd9cc9407e733f834757c70" translate="yes" xml:space="preserve">
          <source>Tracing. Trace flags can still be set for the process, but no trace messages of any kind are generated. (If flag &lt;code&gt;sensitive&lt;/code&gt; is turned off, trace messages are again generated if any trace flags are set.)</source>
          <target state="translated">트레이싱. 프로세스에 대해 추적 플래그를 계속 설정할 수 있지만 어떤 종류의 추적 메시지도 생성되지 않습니다. 플래그 &lt;code&gt;sensitive&lt;/code&gt; 이 해제되면 추적 플래그가 설정되면 추적 메시지가 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="47fc4ea1f09f1ee696b546f14553f696094e6dba" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph.</source>
          <target state="translated">트레이싱; 이전 단락에서 언급 한 바와 같이</target>
        </trans-unit>
        <trans-unit id="41e7b60cc9f2be5dd1ce4620f59c4b34f7bff5d2" translate="yes" xml:space="preserve">
          <source>Tracing; to file, as mentioned in the previous paragraph. The trace contains entries for function calls, returns to function, process scheduling, other process related (spawn, etc) events, and garbage collection. All trace entries are timestamped.</source>
          <target state="translated">트레이싱; 이전 단락에서 언급 한 바와 같이 추적에는 함수 호출, 함수 리턴, 프로세스 스케줄링, 기타 프로세스 관련 (스폰 등) 이벤트 및 가비지 콜렉션에 대한 항목이 포함됩니다. 모든 추적 항목이 타임 스탬프됩니다.</target>
        </trans-unit>
        <trans-unit id="8fe0486a60ee6a3c01827363742db14787a69569" translate="yes" xml:space="preserve">
          <source>Traditionally the Presented IDs were found in the &lt;code&gt;Subject&lt;/code&gt; certificate field as &lt;code&gt;CN&lt;/code&gt; names. This is still quite common. When printing a certificate they show up as:</source>
          <target state="translated">전통적으로 제시된 ID는 &lt;code&gt;Subject&lt;/code&gt; 인증서 필드에서 &lt;code&gt;CN&lt;/code&gt; 이름 으로 발견되었습니다 . 이것은 여전히 ​​흔합니다. 인증서를 인쇄 할 때 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd6a9e832dedaac8dfc95165be3ac0b240579c52" translate="yes" xml:space="preserve">
          <source>Transaction properties, which include atomicity, consistency, isolation, and durability</source>
          <target state="translated">원 자성, 일관성, 격리 및 내구성을 포함한 트랜잭션 속성</target>
        </trans-unit>
        <trans-unit id="0c055699e2752b762bcaa8253255fc14b9bef9a9" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; are both true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">트랜잭션 발신자 시간 초과 시간 두 가지 기능이 있습니다. 먼저, 값이 0이면 트랜잭션이 누적되지 않습니다 (예 : 트랜잭션 발신자 프로세스가 시작되지 않음). 둘째, 값이 0보다 크고 &lt;code&gt;auto_ack&lt;/code&gt; 및 &lt;code&gt;trans_ack&lt;/code&gt; 이 모두 true이거나 &lt;code&gt;trans_req&lt;/code&gt; 가 true 인 경우 트랜잭션 발신자가 시작되고 트랜잭션 ( &lt;code&gt;auto_ack&lt;/code&gt; , &lt;code&gt;trans_ack&lt;/code&gt; 및 &lt;code&gt;trans_req&lt;/code&gt; 값에 따라 다름 )이 나중에 누적됩니다. 배상.</target>
        </trans-unit>
        <trans-unit id="269959a97a6fb575e49d0eca74353214adfc6c11" translate="yes" xml:space="preserve">
          <source>Transaction sender timeout time. Has two functions. First, if the value is 0, then transactions will not be accumulated (e.g. the transaction sender process will not be started). Second, if the value is greater then 0 and &lt;code&gt;auto_ack&lt;/code&gt; and &lt;code&gt;trans_ack&lt;/code&gt; is true or if &lt;code&gt;trans_req&lt;/code&gt; is true, then transaction sender will be started and transactions (which is depending on the values of &lt;code&gt;auto_ack&lt;/code&gt;, &lt;code&gt;trans_ack&lt;/code&gt; and &lt;code&gt;trans_req&lt;/code&gt;) will be accumulated, for later sending.</source>
          <target state="translated">트랜잭션 발신자 시간 초과 시간 두 가지 기능이 있습니다. 먼저 값이 0이면 트랜잭션이 누적되지 않습니다 (예 : 트랜잭션 발신자 프로세스가 시작되지 않음). 둘째, 값이 0보다 크고 &lt;code&gt;auto_ack&lt;/code&gt; 및 &lt;code&gt;trans_ack&lt;/code&gt; 이 true이거나 &lt;code&gt;trans_req&lt;/code&gt; 가 true 인 경우 트랜잭션 발신자가 시작되고 트랜잭션 ( &lt;code&gt;auto_ack&lt;/code&gt; , &lt;code&gt;trans_ack&lt;/code&gt; 및 &lt;code&gt;trans_req&lt;/code&gt; 값에 따라 다름 )이 나중에 전송되도록 누적됩니다. .</target>
        </trans-unit>
        <trans-unit id="8663c67ab2c24806fdfac1e594f2b7c4880ae74b" translate="yes" xml:space="preserve">
          <source>Transaction-protected updates of counter records are not possible.</source>
          <target state="translated">카운터 레코드의 트랜잭션 보호 업데이트는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="92857e4acd00ac4a82a3a5846abb0210105c9b13" translate="yes" xml:space="preserve">
          <source>Transactions are important when designing fault-tolerant, distributed systems. A &lt;code&gt;Mnesia&lt;/code&gt; transaction is a mechanism by which a series of database operations can be executed as one functional block. The functional block that is run as a transaction is called a Functional Object (Fun), and this code can read, write, and delete &lt;code&gt;Mnesia&lt;/code&gt; records. The Fun is evaluated as a transaction that either commits or terminates. If a transaction succeeds in executing the Fun, it replicates the action on all nodes involved, or terminates if an error occurs.</source>
          <target state="translated">내결함성 분산 시스템을 설계 할 때는 트랜잭션이 중요합니다. &lt;code&gt;Mnesia&lt;/code&gt; 의 트랜잭션은 데이터베이스의 일련의 동작을 하나 개의 기능 블록으로 수행 할 수있는 메커니즘이다. 트랜잭션으로 실행되는 기능 블록을 기능 개체 (Fun)라고 &lt;code&gt;Mnesia&lt;/code&gt; 코드는 Mnesia 레코드를 읽고 쓰고 삭제할 수 있습니다. Fun은 커밋 또는 종료되는 트랜잭션으로 평가됩니다. 트랜잭션이 Fun 실행에 성공하면 관련된 모든 노드에서 조치를 복제하거나 오류가 발생하면 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb9104f2b09d1b5d4b87d82abb898d1890e970f" translate="yes" xml:space="preserve">
          <source>Transactions can be assigned the property of being executed on all nodes in the system, or on none. Transactions can also be bypassed in favor of running &quot;dirty operations&quot;, which reduce overheads and run fast.</source>
          <target state="translated">트랜잭션은 시스템의 모든 노드에서 실행되는 속성을 할당하거나 전혀 할당하지 않을 수 있습니다. 오버 헤드를 줄이고 빠르게 실행되는 &quot;더러운 작업&quot;을 실행하기 위해 트랜잭션을 무시할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a91a6387bdeb5a997e5106ce0eb7dbddb3fbc79e" translate="yes" xml:space="preserve">
          <source>Transactions can be nested in an arbitrary fashion. A child transaction must run in the same process as its parent. When a child transaction terminates, the caller of the child transaction gets return value &lt;code&gt;{aborted, Reason}&lt;/code&gt; and any work performed by the child is erased. If a child transaction commits, the records written by the child are propagated to the parent.</source>
          <target state="translated">트랜잭션은 임의의 방식으로 중첩 될 수 있습니다. 하위 트랜잭션은 상위 트랜잭션과 동일한 프로세스에서 실행해야합니다. 하위 트랜잭션이 종료되면 하위 트랜잭션의 호출자는 리턴 값 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 을 받고 하위에서 수행 한 모든 작업이 지워집니다. 자식 트랜잭션이 커밋되면 자식이 작성한 레코드가 부모에게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c5e2dea68a50fc96da311191d6565ac73e322c" translate="yes" xml:space="preserve">
          <source>Transactions that update the definition of a table requires that &lt;code&gt;Mnesia&lt;/code&gt; is started on all nodes where the storage type of the schema is &lt;code&gt;disc_copies&lt;/code&gt;. All replicas of the table on these nodes must also be loaded. There are a few exceptions to these availability rules:</source>
          <target state="translated">테이블 정의를 업데이트하는 트랜잭션 에서는 스키마의 스토리지 유형이 &lt;code&gt;disc_copies&lt;/code&gt; 인 모든 노드에서 &lt;code&gt;Mnesia&lt;/code&gt; 를 시작 해야합니다 . 이 노드에있는 테이블의 모든 복제본도로드해야합니다. 이러한 가용성 규칙에는 몇 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8042cfa4648048958e1595a0cff5bd3d748ab7d" translate="yes" xml:space="preserve">
          <source>Transcodes an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant &lt;code&gt;URIString&lt;/code&gt;, where &lt;code&gt;Options&lt;/code&gt; is a list of tagged tuples, specifying the inbound (&lt;code&gt;in_encoding&lt;/code&gt;) and outbound (&lt;code&gt;out_encoding&lt;/code&gt;) encodings. &lt;code&gt;in_encoding&lt;/code&gt; and &lt;code&gt;out_encoding&lt;/code&gt; specifies both binary encoding and percent-encoding for the input and output data. Mixed encoding, where binary encoding is not the same as percent-encoding, is not supported. If an argument is invalid, an error tuple is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 호환 &lt;code&gt;URIString&lt;/code&gt; 을 트랜스 코딩합니다 . 여기서 &lt;code&gt;Options&lt;/code&gt; 는 인바운드 ( &lt;code&gt;in_encoding&lt;/code&gt; ) 및 아웃 바운드 ( &lt;code&gt;out_encoding&lt;/code&gt; ) 인코딩을 지정하여 태그가 지정된 튜플의 목록입니다 . &lt;code&gt;in_encoding&lt;/code&gt; 및 &lt;code&gt;out_encoding&lt;/code&gt; 은 입력 및 출력 데이터에 대한 이진 인코딩 및 백분율 인코딩을 모두 지정합니다. 이진 인코딩이 퍼센트 인코딩과 동일하지 않은 혼합 인코딩은 지원되지 않습니다. 인수가 유효하지 않으면 오류 튜플이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5bcd602254f322e5e2715324aa9c41970279ec4f" translate="yes" xml:space="preserve">
          <source>Transcript</source>
          <target state="translated">Transcript</target>
        </trans-unit>
        <trans-unit id="0276c8258f3ca2236ded67dcb45cec51cdd4d087" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; into the file &lt;code&gt;RemoteFile&lt;/code&gt; at the remote server.</source>
          <target state="translated">전송 바이너리 &lt;code&gt;Bin&lt;/code&gt; 파일로 &lt;code&gt;RemoteFile&lt;/code&gt; 을 원격 서버에서.</target>
        </trans-unit>
        <trans-unit id="a31be82768a8a14fe4e45c8c31cc87a5a005d692" translate="yes" xml:space="preserve">
          <source>Transfers the binary &lt;code&gt;Bin&lt;/code&gt; to the remote server and appends it to the file &lt;code&gt;RemoteFile&lt;/code&gt;. If the file does not exist, it is created.</source>
          <target state="translated">전송 바이너리 &lt;code&gt;Bin&lt;/code&gt; 원격 서버와 파일에 추가합니다 &lt;code&gt;RemoteFile&lt;/code&gt; 을 . 파일이 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="96ecc5026b0a2d6e144a5dcc9d3d15bc2637fba5" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which appends it to the file specified in the call to &lt;code&gt;append_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">전송 청크 &lt;code&gt;Bin&lt;/code&gt; 에 대한 호출에 지정된 파일에 추가합니다 원격 서버에 &lt;code&gt;append_chunk_start/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d777ccd8cf743ce8e8b1db94238262ce12eba79" translate="yes" xml:space="preserve">
          <source>Transfers the chunk &lt;code&gt;Bin&lt;/code&gt; to the remote server, which writes it into the file specified in the call to &lt;code&gt;send_chunk_start/2&lt;/code&gt;.</source>
          <target state="translated">전송 청크 &lt;code&gt;Bin&lt;/code&gt; 에 대한 호출에 지정된 파일로 기록하는 원격 서버에 &lt;code&gt;send_chunk_start/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78ac497764b60c7c85e8349f223a68fe68089947" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LocalFile&lt;/code&gt; 파일 을 원격 서버로 전송 합니다. 경우 &lt;code&gt;RemoteFile&lt;/code&gt; 을가 지정되어, 원격 파일의 이름으로 설정되어 &lt;code&gt;RemoteFile&lt;/code&gt; 을 그렇지 않은 경우에, &lt;code&gt;LocalFile&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="aec29636456fbdaa72ac911c194e9cb134c0de35" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;LocalFile&lt;/code&gt; to the remote server. If &lt;code&gt;RemoteFile&lt;/code&gt; is specified, the name of the remote file that the file is appended to is set to &lt;code&gt;RemoteFile&lt;/code&gt;, otherwise to &lt;code&gt;LocalFile&lt;/code&gt;. If the file does not exists, it is created.</source>
          <target state="translated">&lt;code&gt;LocalFile&lt;/code&gt; 파일 을 원격 서버로 전송 합니다. 경우 &lt;code&gt;RemoteFile&lt;/code&gt; 을가 지정되어, 원격 파일의 이름 파일이 설정되어 추가되는 &lt;code&gt;RemoteFile&lt;/code&gt; 을 그렇지 않은 경우에, &lt;code&gt;LocalFile&lt;/code&gt; 에 . 파일이 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="90ba80cf80c63c0d2c8f02175aa1e10f13204467" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server and receives it as a binary.</source>
          <target state="translated">원격 서버에서 &lt;code&gt;RemoteFile&lt;/code&gt; 파일을 전송하고 이진 파일로 수신합니다.</target>
        </trans-unit>
        <trans-unit id="ef6a6bd4453d0b36a0f55436c56df830215430fd" translate="yes" xml:space="preserve">
          <source>Transfers the file &lt;code&gt;RemoteFile&lt;/code&gt; from the remote server to the file system of the local client. If &lt;code&gt;LocalFile&lt;/code&gt; is specified, the local file will be &lt;code&gt;LocalFile&lt;/code&gt;, otherwise &lt;code&gt;RemoteFile&lt;/code&gt;.</source>
          <target state="translated">원격 서버에서 로컬 클라이언트의 파일 시스템으로 &lt;code&gt;RemoteFile&lt;/code&gt; 파일을 전송합니다 . 경우 &lt;code&gt;LocalFile&lt;/code&gt; 에가 지정되어, 로컬 파일이있을 것입니다 &lt;code&gt;LocalFile&lt;/code&gt; 에 , 그렇지 않으면 &lt;code&gt;RemoteFile&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f0ad6ecb9ddaf64bd66989047cba27a4d5603ff1" translate="yes" xml:space="preserve">
          <source>Transform a alias-name to its oid.</source>
          <target state="translated">별명을 해당 이름으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="36c585abe302937d577b48572bd7c0e3655c0630" translate="yes" xml:space="preserve">
          <source>Transform a oid to its aliasname.</source>
          <target state="translated">OID를 별명으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="1d5829db0e03928c4e7cde6f753299a051ba3577" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, appending &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of the specified string.</source>
          <target state="translated">지정된 문자열의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 를 추가하여 컴파일하기 전에 입력 사전을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b3111884f3054cc372ba38df92c0a135c770202" translate="yes" xml:space="preserve">
          <source>Transform the input dictionary before compilation, setting &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; or &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; to the specified string.</source>
          <target state="translated">&lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#prefix&quot;&gt;@prefix&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 를 지정된 문자열로 설정하여 컴파일하기 전에 입력 사전을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="c21ae8bb9de07f6c449c2bda96f788a3baf2c6fe" translate="yes" xml:space="preserve">
          <source>Transformation rules are used to rewrite generic instructions to other generic instructions. The transformations rules are applied repeatedly until no rule match. At that point, the first instruction in the resulting instruction sequence will be converted to a specific instruction and added to the code for the module being loaded. Then the transformation rules for the remaining instructions are run in the same way.</source>
          <target state="translated">변환 규칙은 일반 명령어를 다른 일반 명령어로 다시 작성하는 데 사용됩니다. 변환 규칙은 일치하는 규칙이 없을 때까지 반복적으로 적용됩니다. 이 시점에서 결과 명령어 시퀀스의 첫 번째 명령어는 특정 명령어로 변환되고로드되는 모듈의 코드에 추가됩니다. 그런 다음 나머지 지침에 대한 변환 규칙이 동일한 방식으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="846b9581964cb477d07383c10e4204a0b7ad99e6" translate="yes" xml:space="preserve">
          <source>Transformations that are not possible to describe with the rule language as described here can be written as a C function in &lt;code&gt;beam_load.c&lt;/code&gt; and called from the right side of a transformation. The left side of the transformation will perform the match and bind operands to variables. The variables can then be passed to a generator function on the right side. For example:</source>
          <target state="translated">여기에 설명 된대로 규칙 언어로 설명 할 수 없는 변환 은 &lt;code&gt;beam_load.c&lt;/code&gt; 에서 C 함수로 작성되고 변환의 오른쪽에서 호출 될 수 있습니다 . 변환의 왼쪽은 일치를 수행하고 피연산자를 변수에 바인딩합니다. 그런 다음 변수를 오른쪽의 생성기 함수로 전달할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c4f1d57f141d31ace69a30793395cb3994e3e4b6" translate="yes" xml:space="preserve">
          <source>Transforming URIs into a normalized form</source>
          <target state="translated">URI를 정규화 된 형식으로 변환</target>
        </trans-unit>
        <trans-unit id="52a09e92d39be036799f55f3466102e3964c9981" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; into an internal representation that can be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt;. The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (that is, it cannot be sent to a process on another node and still remain a valid compiled match specification, nor can it be stored on disk). To check the validity of a compiled match specification, use &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 을 이후의 &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt; 호출에서 사용할 수있는 내부 표현으로 변환합니다 . 내부 표현은 불투명하며 외부 용어 형식으로 변환 한 다음 속성을 잃지 않고 다시 되돌릴 수 없습니다 (즉, 다른 노드의 프로세스로 전송 될 수없고 유효한 컴파일 된 일치 스펙으로 남아 있거나 저장 될 수 없음). 디스크). 컴파일 된 일치 스펙의 유효성을 확인하려면 &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="127c97ad73e2098d2302e04d73b62ee91a692d00" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; into an internal representation that can be used in subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt;. The internal representation is opaque. To check the validity of a compiled match specification, use &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_spec_run-2&quot;&gt;match_spec_run/2&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에서 사용할 수있는 내부 표현으로 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 을 변환합니다 . 내부 표현은 불투명합니다. 컴파일 된 일치 사양의 유효성을 확인하려면 &lt;code&gt;&lt;a href=&quot;#is_compiled_ms-1&quot;&gt;is_compiled_ms/1&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="29484fe337b3af71da5ca7a2dac4e696f5f79d47" translate="yes" xml:space="preserve">
          <source>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for &lt;code&gt;Node&lt;/code&gt;, as produced by the given &lt;code&gt;Printer&lt;/code&gt; function. Each line of the comment is prefixed by the string &lt;code&gt;Prefix&lt;/code&gt; (this does not include the initial &quot;&lt;code&gt;%&lt;/code&gt;&quot; character of the comment line).</source>
          <target state="translated">구문 트리를 추상 주석으로 변환합니다. 주석의 행 에는 주어진 &lt;code&gt;Printer&lt;/code&gt; 함수에 의해 생성 된 &lt;code&gt;Node&lt;/code&gt; 텍스트가 포함 됩니다. 주석의 각 줄은 문자열로 접두사 &lt;code&gt;Prefix&lt;/code&gt; (이 초기 &quot;에 포함되지 않습니다 &lt;code&gt;%&lt;/code&gt; 주석 라인의&quot;문자).</target>
        </trans-unit>
        <trans-unit id="0cbb6e0e6a14a90b777a9f90d55d975cb9b29ca2" translate="yes" xml:space="preserve">
          <source>Transforms addresses from internal MIB format to one more useful to &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부 MIB 형식의 주소를 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;Agent Net if&lt;/a&gt;&lt;/code&gt; 에 더 유용한 주소로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dec43f85ac93650f89af6686bc1b1b60f6b9599f" translate="yes" xml:space="preserve">
          <source>Transforms an &lt;code&gt;URI&lt;/code&gt; into a normalized form using Syntax-Based Normalization as defined by &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 에 의해 정의 된 구문 기반 정규화를 사용하여 &lt;code&gt;URI&lt;/code&gt; 를 정규화 된 양식으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d9a9fd8f3259ae9990008a8a6bec24b152a43a" translate="yes" xml:space="preserve">
          <source>Transforms an SNMP index to the corresponding Mnesia key. If the SNMP table has multiple keys, the key is a tuple of the key columns.</source>
          <target state="translated">SNMP 색인을 해당 Mnesia 키로 변환합니다. SNMP 테이블에 여러 키가있는 경우 키는 키 열의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="187ea5deff287a5504fddf1b7e36cd0f09e23500" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;person&lt;/code&gt; table from a RAM table into a disc-based table at &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; 테이블을 RAM 테이블에서 &lt;code&gt;Node&lt;/code&gt; 의 디스크 기반 테이블로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e599fefddd1839d024d114d1fae1e8b80cf9332c" translate="yes" xml:space="preserve">
          <source>Transforms trace data and makes an event record out of it.</source>
          <target state="translated">추적 데이터를 변환하고 그로부터 이벤트 레코드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="dae87e24dc1095e84bcbb6fcaaaa2c5136770260" translate="yes" xml:space="preserve">
          <source>Transient Failures</source>
          <target state="translated">일시적 실패</target>
        </trans-unit>
        <trans-unit id="635a90e0c9623c778cd92020a4761e58257d50d3" translate="yes" xml:space="preserve">
          <source>Transition options can be set by &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; and modify the &lt;strong&gt;state transition&lt;/strong&gt;. The &lt;strong&gt;state transition&lt;/strong&gt; takes place when the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; has processed an event and returns. Here are the sequence of steps for a &lt;strong&gt;state transition&lt;/strong&gt;:</source>
          <target state="translated">전환 옵션은 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 별로 설정 하고 &lt;strong&gt;상태 전환을&lt;/strong&gt; 수정할 수 있습니다 . &lt;strong&gt;상태 천이는&lt;/strong&gt; 장소 걸리는 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 이벤트 복귀 처리를했다. &lt;strong&gt;상태 전환을&lt;/strong&gt; 위한 일련의 단계는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="340b8d86a3623f3b21be6c18b845921955f1271a" translate="yes" xml:space="preserve">
          <source>Transition options can be set by &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; and modify the state transition. Here are the sequence of steps for a state transition:</source>
          <target state="translated">전환 옵션은 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; 으로 설정 하고 상태 전환을 수정할 수 있습니다 . 상태 전이 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c6cfa47dfcc18ddefe84ebeb0f5989ee0e3d8d7" translate="yes" xml:space="preserve">
          <source>Translates OID to Erlang digest type</source>
          <target state="translated">OID를 Erlang 다이제스트 유형으로 변환</target>
        </trans-unit>
        <trans-unit id="6f68e1d1cfad7a14a47ac7096b71655133e8d261" translate="yes" xml:space="preserve">
          <source>Translates an SCTP error number from, for example, &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; or &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; into an explanatory string, or one of the atoms &lt;code&gt;ok&lt;/code&gt; for no error or &lt;code&gt;undefined&lt;/code&gt; for an unrecognized error.</source>
          <target state="translated">, SCTP에서 에러 수를 변환 예 &lt;code&gt;#sctp_remote_error{}&lt;/code&gt; 또는 &lt;code&gt;#sctp_send_failed{}&lt;/code&gt; 설명 문자열 또는 원자 중 하나에 &lt;code&gt;ok&lt;/code&gt; 없음 에러 또는 &lt;code&gt;undefined&lt;/code&gt; 미정 에러.</target>
        </trans-unit>
        <trans-unit id="80c4059735d8cda62f939032264b405f285841d8" translate="yes" xml:space="preserve">
          <source>Translates an abstract syntax tree to a corresponding explicit record representation. The records are defined in the file &quot;&lt;code&gt;cerl.hrl&lt;/code&gt;&quot;.</source>
          <target state="translated">추상 구문 트리를 해당하는 명시 적 레코드 표현으로 변환합니다. 레코드는 &quot; &lt;code&gt;cerl.hrl&lt;/code&gt; &quot; 파일에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19487fcfdbdd7c9b9b7de31aef67e2f1e3c0f27" translate="yes" xml:space="preserve">
          <source>Translates an explicit record representation to a corresponding abstract syntax tree. The records are defined in the file &quot;&lt;code&gt;core_parse.hrl&lt;/code&gt;&quot;.</source>
          <target state="translated">명시 적 레코드 표현을 해당 추상 구문 트리로 변환합니다. 레코드는 &quot; &lt;code&gt;core_parse.hrl&lt;/code&gt; &quot; 파일에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fca7eec0c5c2c402ec9feaf20fb1cf586209144" translate="yes" xml:space="preserve">
          <source>Translates signature algorithm OID to Erlang digest and signature types.</source>
          <target state="translated">서명 알고리즘 OID를 Erlang 다이제스트 및 서명 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2dd26e871e1b0c6741054f66f2c8c6fd1ff461e9" translate="yes" xml:space="preserve">
          <source>Translates the binary trace logs into something readable. By default, &lt;code&gt;ttb&lt;/code&gt; presents each trace message as a line of text, but you can also write your own handler to make more complex interpretations of the trace information. A trace log can also be presented graphically with application Event Tracer (ET).</source>
          <target state="translated">이진 추적 로그를 읽을 수있는 것으로 변환합니다. 기본적으로 &lt;code&gt;ttb&lt;/code&gt; 는 각 추적 메시지를 한 줄의 텍스트로 표시하지만 추적 정보에 대한보다 복잡한 해석을 위해 자체 핸들러를 작성할 수도 있습니다. 응용 프로그램 이벤트 추적기 (ET)를 사용하여 추적 로그를 그래픽으로 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="247b327869ef6106bf80329969b8c8bd5956cb2a" translate="yes" xml:space="preserve">
          <source>Translation Agents</source>
          <target state="translated">번역 에이전트</target>
        </trans-unit>
        <trans-unit id="c10d76c9a4b81c39c13a3bbf7cdb7a157dfb1551" translate="yes" xml:space="preserve">
          <source>Transport</source>
          <target state="translated">Transport</target>
        </trans-unit>
        <trans-unit id="b374a75b21ba249e1509b4f849a514f5f64e23f6" translate="yes" xml:space="preserve">
          <source>Transport Failure Algorithm</source>
          <target state="translated">전송 실패 알고리즘</target>
        </trans-unit>
        <trans-unit id="67ca25bf09fe1a4bc0aa43dea06a3fcf06720b9d" translate="yes" xml:space="preserve">
          <source>Transport Failure Detection</source>
          <target state="translated">운송 실패 감지</target>
        </trans-unit>
        <trans-unit id="c24199b7fc627de79e3a1c89011039b836457577" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) and its predecessor, the Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. The protocols use X.509 certificates and hence public key (asymmetric) cryptography to authenticate the counterpart with whom they communicate, and to exchange a symmetric key for payload encryption. The protocol provides data/message confidentiality (encryption), integrity (through message authentication code checks) and host verification (through certificate path validation). DTLS (Datagram Transport Layer Security) that is based on TLS but datagram oriented instead of stream oriented.</source>
          <target state="translated">TLS (Transport Layer Security) 및 그 이전 버전 인 SSL (Secure Sockets Layer)은 컴퓨터 네트워크를 통한 통신 보안을 제공하도록 설계된 암호화 프로토콜입니다. 프로토콜은 X.509 인증서와 공개 키 (비대칭) 암호화를 사용하여 통신하는 상대방을 인증하고 페이로드 암호화를 위해 대칭 키를 교환합니다. 이 프로토콜은 데이터 / 메시지 기밀성 (암호화), 무결성 (메시지 인증 코드 검사를 통한) 및 호스트 확인 (인증서 경로 확인을 통한)을 제공합니다. TLS를 기반으로하지만 스트림 지향 대신 데이터 그램 지향 DTLS (Datagram Transport Layer Security).</target>
        </trans-unit>
        <trans-unit id="6d4ed04955b99e2e25f46f14a243ff2be9d1edb1" translate="yes" xml:space="preserve">
          <source>Transport Protocol</source>
          <target state="translated">전송 프로토콜</target>
        </trans-unit>
        <trans-unit id="784cd0f786d540e1df407cfe0bdede50bd4a091f" translate="yes" xml:space="preserve">
          <source>Transpose characters</source>
          <target state="translated">문자 조바꿈</target>
        </trans-unit>
        <trans-unit id="ad327557b2eecc894c5ce680d047ddb9ce864548" translate="yes" xml:space="preserve">
          <source>Trap Sending</source>
          <target state="translated">트랩 전송</target>
        </trans-unit>
        <trans-unit id="b87b3f0b12dc0cda40b5e7c065f4352f65c40f7f" translate="yes" xml:space="preserve">
          <source>Traversals using &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt; functions may not need to scan the entire table depending on how the key is specified. A match pattern with a &lt;strong&gt;fully bound key&lt;/strong&gt; (without any match variables) will optimize the operation to a single key lookup without any table traversal at all. For &lt;code&gt;ordered_set&lt;/code&gt; a &lt;strong&gt;partially bound key&lt;/strong&gt; will limit the traversal to only scan a subset of the table based on term order. A partially bound key is either a list or a tuple with a prefix that is fully bound. Example:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 및 &lt;code&gt;select&lt;/code&gt; 기능을 사용하는 순회 는 키 지정 방법에 따라 전체 테이블을 스캔 할 필요가 없습니다. &lt;strong&gt;완전히 바인딩 된 키&lt;/strong&gt; 가있는 일치 패턴 (일치 변수 없음)은 테이블 순회없이 단일 키 조회로 작업을 최적화합니다. 들어 &lt;code&gt;ordered_set&lt;/code&gt; &lt;strong&gt;부분적으로 결합 된 키&lt;/strong&gt; 만을 용어 순서에 따라 테이블의 일부를 스캔 할 수있는 탐색을 제한합니다. 부분적으로 바인딩 된 키는 완전히 바인딩 된 접두사가있는 목록 또는 튜플입니다. 예:</target>
        </trans-unit>
        <trans-unit id="6e192302cce69f9e090d601f54b7e73e6fdccdad" translate="yes" xml:space="preserve">
          <source>Traverses &lt;code&gt;Dirs&lt;/code&gt; and adds each &lt;code&gt;Dir&lt;/code&gt; to the beginning of the code path. This means that the order of &lt;code&gt;Dirs&lt;/code&gt; is reversed in the resulting code path. For example, if you add &lt;code&gt;[Dir1,Dir2]&lt;/code&gt;, the resulting path will be &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Dirs&lt;/code&gt; 를 트래버스 하고 각 &lt;code&gt;Dir&lt;/code&gt; 을 코드 경로의 시작 부분에 추가 합니다. 이것은 &lt;code&gt;Dirs&lt;/code&gt; 의 순서가 결과 코드 경로에서 역전 됨을 의미합니다 . 예를 들어 &lt;code&gt;[Dir1,Dir2]&lt;/code&gt; 를 추가 하면 결과 경로는 &lt;code&gt;[Dir2,Dir1|OldCodePath]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="137a357a519bf577c3a49eea20ac865057de4ba8" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise the function returns a key that can be used to read the actual record.</source>
          <target state="translated">테이블을 탐색하고 테이블의 모든 레코드에 대한 작업을 수행합니다. 테이블 끝에 도달하면 특수 키 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. 그렇지 않으면이 함수는 실제 레코드를 읽는 데 사용할 수있는 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d196f97744321413a11b3f30616c9f2f4eec01c6" translate="yes" xml:space="preserve">
          <source>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned. Otherwise, the function returns a key that can be used to read the actual record. The behavior is undefined if another Erlang process performs write operations on the table while it is being traversed with the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;.</source>
          <target state="translated">테이블을 탐색하고 테이블의 모든 레코드에 대한 작업을 수행합니다. 테이블 끝에 도달하면 특수 키 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다. 그렇지 않으면이 함수는 실제 레코드를 읽는 데 사용할 수있는 키를 반환합니다. 다른 Erlang 프로세스가 &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 함수로 트래버스되는 동안 테이블에서 쓰기 작업을 수행하는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8dc9f15de712d9d574738e5b2e0901706f6adc90" translate="yes" xml:space="preserve">
          <source>Traverses a table in a manner similar to the function &lt;code&gt;mnesia:dirty_next/2&lt;/code&gt;. A table has a number of slots that range from 0 (zero) to an unknown upper bound. The function &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; returns the special atom &lt;code&gt;'$end_of_table'&lt;/code&gt; when the end of the table is reached. The behavior of this function is undefined if a write operation is performed on the table while it is being traversed.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_next/2&lt;/code&gt; 함수와 유사한 방식으로 테이블을 탐색 합니다. 테이블에는 0에서 알 수없는 상한 범위의 슬롯이 있습니다. 함수 &lt;code&gt;mnesia:dirty_slot/2&lt;/code&gt; 반환 특별한 원자 &lt;code&gt;'$end_of_table'&lt;/code&gt; 테이블의 끝에 도달했을 때. 트래버스되는 동안 테이블에서 쓰기 작업이 수행되면이 함수의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5bce8436ec86270c2bccf19db4667aa0c4b7a23" translate="yes" xml:space="preserve">
          <source>Traversing the set of modules, it then recompiles every module for which at least one of the following conditions apply:</source>
          <target state="translated">그런 다음 모듈 세트를 순회하면 다음 조건 중 하나 이상이 적용되는 모든 모듈을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="7c6a05bfb91163574fcaf2b49273abce7fc5b093" translate="yes" xml:space="preserve">
          <source>Trees and iterators are built using opaque data structures that should not be pattern-matched from outside this module.</source>
          <target state="translated">트리와 반복기는이 모듈 외부에서 패턴 일치하지 않아야하는 불투명 한 데이터 구조를 사용하여 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c84ee4b222403ef3c2a2f6e4a34ab18cd985d5" translate="yes" xml:space="preserve">
          <source>Tries to create directory &lt;code&gt;Dir&lt;/code&gt;. Missing parent directories are &lt;strong&gt;not&lt;/strong&gt; created. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 디렉토리를 작성하려고합니다 . 누락 된 상위 디렉토리가 작성 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 반환 &lt;code&gt;ok&lt;/code&gt; 성공하는 경우.</target>
        </trans-unit>
        <trans-unit id="7539b9bc23bf1a63079b6009b66e55de1f511775" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the &lt;code&gt;NULL&lt;/code&gt;-terminated C-string &lt;code&gt;name&lt;/code&gt; with encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코딩 &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 로 &lt;code&gt;NULL&lt;/code&gt; 종료 C- 문자열 &lt;code&gt;name&lt;/code&gt; 에서 이미 존재하는 원자의 항을 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="d956aa4d45e626e33feccc52c2e668a01e46c2de" translate="yes" xml:space="preserve">
          <source>Tries to create the term of an already existing atom from the string &lt;code&gt;name&lt;/code&gt; with length &lt;code&gt;len&lt;/code&gt; and encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NULL&lt;/code&gt; characters are treated as any other characters.</source>
          <target state="translated">length &lt;code&gt;len&lt;/code&gt; 및 encoding &lt;code&gt;&lt;a href=&quot;#ErlNifCharEncoding&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열 &lt;code&gt;name&lt;/code&gt; 에서 이미 존재하는 원자의 용어를 작성하려고합니다 . &lt;code&gt;NULL&lt;/code&gt; 문자는 다른 문자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="c7380de8914d3d9d8e70fd1f6c74d924099655d6" translate="yes" xml:space="preserve">
          <source>Tries to delete directory &lt;code&gt;Dir&lt;/code&gt;. The directory must be empty before it can be deleted. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">디렉토리 &lt;code&gt;Dir&lt;/code&gt; 을 삭제하려고합니다 . 삭제하기 전에 디렉토리가 비어 있어야합니다. 반환 &lt;code&gt;ok&lt;/code&gt; 성공하는 경우.</target>
        </trans-unit>
        <trans-unit id="0694587d26aecfbb0a43b20ea81eab04225a2a67" translate="yes" xml:space="preserve">
          <source>Tries to delete file &lt;code&gt;Filename&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if successful.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 파일을 삭제하려고합니다 . 반환 &lt;code&gt;ok&lt;/code&gt; 성공하는 경우.</target>
        </trans-unit>
        <trans-unit id="917cb6bdcab3e4dcc84eba06ed763b346415331e" translate="yes" xml:space="preserve">
          <source>Tries to find a &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">digraph &lt;code&gt;G&lt;/code&gt; 의 정점 &lt;code&gt;V1&lt;/code&gt; 에서 정점 &lt;code&gt;V2&lt;/code&gt; 까지 의 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 를 찾으려고 시도합니다 . 경로를 꼭짓점 의 목록 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 로 반환 하거나, 길이 가 &lt;code&gt;V1&lt;/code&gt; 에서 &lt;code&gt;V2&lt;/code&gt; 이상인 간단한 경로가 없으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d6d56eefae6afa713ee58d8d532711a39f9d00e8" translate="yes" xml:space="preserve">
          <source>Tries to find an application downgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a previous version &lt;code&gt;OldVsn&lt;/code&gt; located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">현재 버전 에서 &lt;code&gt;Dir&lt;/code&gt; 에 있는 이전 버전의 &lt;code&gt;OldVsn&lt;/code&gt; 으로 &lt;code&gt;App&lt;/code&gt; 용 애플리케이션 다운 그레이드 스크립트를 찾으려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5b3cdb4b87509cbcdcf3943a3bdad2d3f9b6d987" translate="yes" xml:space="preserve">
          <source>Tries to find an application upgrade script for &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt;.</source>
          <target state="translated">현재 버전에서 &lt;code&gt;Dir&lt;/code&gt; 에있는 새 버전으로 &lt;code&gt;App&lt;/code&gt; 의 애플리케이션 업그레이드 스크립트를 찾으려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="63810144427574ddc18730d454daf02c43dd8338" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; through vertex &lt;code&gt;V&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the cycle as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple cycle through &lt;code&gt;V&lt;/code&gt; exists. Notice that a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; is returned as list &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt;.</source>
          <target state="translated">digraph &lt;code&gt;G&lt;/code&gt; 의 꼭짓점 &lt;code&gt;V&lt;/code&gt; 를 통해 가능한 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; 을 찾으려고 시도합니다 . 반환 목록으로주기 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 정점으로, 또는 &lt;code&gt;false&lt;/code&gt; 을 통해 간단한 사이클 경우 &lt;code&gt;V&lt;/code&gt; 는 존재하지 않는다. 알 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;V&lt;/code&gt; 가 리스트로서 반환한다 &lt;code&gt;[V,&amp;nbsp;V]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd32105e9ea9dba4a3239b99d2841486b3f987d" translate="yes" xml:space="preserve">
          <source>Tries to find an as short as possible &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; from vertex &lt;code&gt;V1&lt;/code&gt; to vertex &lt;code&gt;V2&lt;/code&gt; of digraph &lt;code&gt;G&lt;/code&gt;. Returns the path as a list &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; of vertices, or &lt;code&gt;false&lt;/code&gt; if no simple path from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; of length one or more exists.</source>
          <target state="translated">digraph &lt;code&gt;G&lt;/code&gt; 의 정점 &lt;code&gt;V1&lt;/code&gt; 에서 정점 &lt;code&gt;V2&lt;/code&gt; 까지 가능한 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; 를 찾으려고 시도합니다 . 경로를 꼭짓점 의 목록 &lt;code&gt;[V1,&amp;nbsp;...,&amp;nbsp;V2]&lt;/code&gt; 로 반환 하거나, 길이 가 &lt;code&gt;V1&lt;/code&gt; 에서 &lt;code&gt;V2&lt;/code&gt; 이상인 간단한 경로가 없으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f904e656f227e2a584648e9091f6b33093af20b3" translate="yes" xml:space="preserve">
          <source>Tries to load a module in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;, unless the module is already loaded. However, in embedded mode it does not load a module that is not already loaded, but returns &lt;code&gt;{error, embedded}&lt;/code&gt; instead. See &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; for a description of other possible error reasons.</source>
          <target state="translated">모듈이 이미로드되어 있지 않으면 &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 과 같은 방식으로 모듈을로드하려고 시도합니다 . 그러나 임베디드 모드에서는 아직로드되지 않은 모듈을로드하지 않고 대신 &lt;code&gt;{error, embedded}&lt;/code&gt; 를 리턴 합니다. 다른 가능한 오류 이유에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#error_reasons&quot;&gt;Error Reasons for Code-Loading Functions&lt;/a&gt;&lt;/code&gt; 대한 오류 이유를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec25834fa1b726007249264a0c7c78aaaf71538e" translate="yes" xml:space="preserve">
          <source>Tries to load all of the modules in the list &lt;code&gt;Modules&lt;/code&gt; atomically. That means that either all modules are loaded at the same time, or none of the modules are loaded if there is a problem with any of the modules.</source>
          <target state="translated">목록 &lt;code&gt;Modules&lt;/code&gt; 모든 모듈을 원자 적으로 로드하려고 시도합니다 . 즉, 모든 모듈이 동시에로드되거나 모듈에 문제가있는 경우 어떤 모듈도로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1aaf9b09924ea99accd919111039be58e3e4e9fc" translate="yes" xml:space="preserve">
          <source>Tries to load and restore Debugger settings from a file previously saved using &lt;strong&gt;Save Settings...&lt;/strong&gt; (see below). Any errors are silently ignored.</source>
          <target state="translated">&lt;strong&gt;Save Settings ...&lt;/strong&gt; (아래 참조)를 사용하여 이전에 저장된 파일에서 디버거 설정을로드하고 복원하려고합니다 . 모든 오류는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9bc1b21fc8af03b36192dd6ac14e4e4450744f7e" translate="yes" xml:space="preserve">
          <source>Tries to load any modules not already loaded in the list &lt;code&gt;Modules&lt;/code&gt; in the same way as &lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#load_file-1&quot;&gt;load_file/1&lt;/a&gt;&lt;/code&gt; 과 같은 방식으로 목록 &lt;code&gt;Modules&lt;/code&gt; 에 아직로드되지 않은 모듈을로드하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="b645a31575ab3155bc8f781878d4d3b627bae342" translate="yes" xml:space="preserve">
          <source>Tries to load code for all modules that have been previously prepared by &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt;. The loading occurs atomically, meaning that either all modules are loaded at the same time, or none of the modules are loaded.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 에 의해 준비된 모든 모듈에 대한 코드를로드하려고 시도합니다 . 로드는 원자 적으로 발생하므로 모든 모듈이 동시에로드되거나로드 된 모듈이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4b988df2289cf719529adabbdd5889a80ea66c6" translate="yes" xml:space="preserve">
          <source>Tries to load the Erlang module &lt;code&gt;Module&lt;/code&gt;, using the code path. It looks for the object code file with an extension corresponding to the Erlang machine used, for example, &lt;code&gt;Module.beam&lt;/code&gt;. The loading fails if the module name found in the object code differs from the name &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; must be used to load object code with a module name that is different from the file name.</source>
          <target state="translated">코드 경로를 사용하여 Erlang 모듈 &lt;code&gt;Module&lt;/code&gt; 을로드하려고합니다 . Erlang 시스템에 해당하는 확장자 (예 : &lt;code&gt;Module.beam&lt;/code&gt; ) 를 가진 오브젝트 코드 파일을 찾습니다 . 모듈 이름은 이름에서 오브젝트 코드 다릅니다에있는 경우로드가 실패 &lt;code&gt;Module&lt;/code&gt; . 파일 이름과 다른 모듈 이름으로 오브젝트 코드를로드하려면 &lt;code&gt;&lt;a href=&quot;#load_binary-3&quot;&gt;load_binary/3&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b49e8d37404b75156cbbeb1637eb4e0c68260be5" translate="yes" xml:space="preserve">
          <source>Tries to lock a mutex. A thread that has currently locked the mutex &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same mutex again.</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 현재 뮤텍스를 잠근 스레드 는 동일한 뮤텍스를 다시 잠그려고 시도 &lt;strong&gt;할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="369d095339d331183fd1de82b70ca1f958ce57f3" translate="yes" xml:space="preserve">
          <source>Tries to read &lt;code&gt;String&lt;/code&gt; in accordance with the control sequences in &lt;code&gt;Format&lt;/code&gt;. For a detailed description of the available formatting options, see &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt;. It is assumed that &lt;code&gt;String&lt;/code&gt; contains whole lines.</source>
          <target state="translated">&lt;code&gt;Format&lt;/code&gt; 의 제어 순서에 따라 &lt;code&gt;String&lt;/code&gt; 을 읽으려고 합니다. 사용 가능한 포맷 옵션에 대한 자세한 설명은 &lt;code&gt;&lt;a href=&quot;io#fread-3&quot;&gt;io:fread/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . &lt;code&gt;String&lt;/code&gt; 에 전체 줄이 포함되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="b5361d5cdb192bb80b006486e2deeb6e3a86a448" translate="yes" xml:space="preserve">
          <source>Tries to read lock an rwlock.</source>
          <target state="translated">rwlock을 읽기 위해 시도합니다.</target>
        </trans-unit>
        <trans-unit id="078c41228c821f4992dac3d604b1f36b0a4cc3ba" translate="yes" xml:space="preserve">
          <source>Tries to read/write lock an rwlock. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; try to lock the same rwlock again.</source>
          <target state="translated">rwlock을 읽고 쓰기 시도합니다. 현재 rwlock을 읽거나 읽거나 쓴 잠금 스레드 는 동일한 rwlock을 다시 잠그려고 시도 &lt;strong&gt;할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8fa12e3d041770e3cb72f5520664da24c9462a" translate="yes" xml:space="preserve">
          <source>Tries to reduce a guard expression to a single constant value, if possible. The returned value is &lt;code&gt;{value, Term}&lt;/code&gt; if the guard expression &lt;code&gt;Expr&lt;/code&gt; always yields the constant value &lt;code&gt;Term&lt;/code&gt;, and is otherwise &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">가능한 경우 가드 표현식을 단일 상수 값으로 줄이려고합니다. 가드 표현식 &lt;code&gt;Expr&lt;/code&gt; 이 항상 상수 값 &lt;code&gt;Term&lt;/code&gt; 을 산출하고 그렇지 않으면 &lt;code&gt;none&lt;/code&gt; 인 경우 반환 된 값은 &lt;code&gt;{value, Term}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="542b3a8d434cdeb35d54c993e320baf91923b244" translate="yes" xml:space="preserve">
          <source>Tries to rename the file &lt;code&gt;Source&lt;/code&gt; to &lt;code&gt;Destination&lt;/code&gt;. It can be used to move files (and directories) between directories, but it is not sufficient to specify the destination only. The destination filename must also be specified. For example, if &lt;code&gt;bar&lt;/code&gt; is a normal file and &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are directories, &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; returns an error, but &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; succeeds. Returns &lt;code&gt;ok&lt;/code&gt; if it is successful.</source>
          <target state="translated">시도는 파일 이름을 바꾸려면 &lt;code&gt;Source&lt;/code&gt; 에 &lt;code&gt;Destination&lt;/code&gt; . 디렉토리간에 파일 (및 디렉토리)을 이동하는 데 사용할 수 있지만 대상 만 지정하는 것만으로는 충분하지 않습니다. 대상 파일 이름도 지정해야합니다. 예를 들어, &lt;code&gt;bar&lt;/code&gt; 가 일반 파일이고 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;baz&lt;/code&gt; 가 디렉토리 인 경우 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz&quot;)&lt;/code&gt; 은 오류를 반환하지만 &lt;code&gt;rename(&quot;foo/bar&quot;, &quot;baz/bar&quot;)&lt;/code&gt; 는 성공합니다. 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b69799527904c5b0f81a27b2394603c188136973" translate="yes" xml:space="preserve">
          <source>Tries to set the scheduler bind type. The same as flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; except how some errors are handled. For more information, see &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러 바인드 유형을 설정하려고합니다. 일부 오류를 처리하는 방법을 제외하고 플래그 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3739b1427af771c5c5c521a0baa015d6c8471836" translate="yes" xml:space="preserve">
          <source>Tries to suspend all processes using a module &lt;code&gt;Mod&lt;/code&gt;. If a process does not respond, it is ignored. This can cause the process to die, either because it crashes when it spontaneously switches to new code, or as a result of a purge operation. If no &lt;code&gt;Timeout&lt;/code&gt; is specified or &lt;code&gt;default&lt;/code&gt; is specified, the default value for &lt;code&gt;sys:suspend&lt;/code&gt; is used.</source>
          <target state="translated">모듈 &lt;code&gt;Mod&lt;/code&gt; 를 사용하여 모든 프로세스를 일시 중지하려고합니다 . 프로세스가 응답하지 않으면 무시됩니다. 이로 인해 프로세스가 자발적으로 새 코드로 전환 될 때 충돌이 발생하거나 제거 작업의 결과로 프로세스가 종료 될 수 있습니다. &lt;code&gt;Timeout&lt;/code&gt; 을 지정 하지 않거나 &lt;code&gt;default&lt;/code&gt; 을 지정하면 &lt;code&gt;sys:suspend&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f07a25fbd2993e4438fecb34b5a2a265898a4510" translate="yes" xml:space="preserve">
          <source>Trigger the user-probe &lt;code&gt;user_trace_i4s4&lt;/code&gt; in the NIF library &lt;code&gt;dyntrace.so&lt;/code&gt; by calling &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt;.</source>
          <target state="translated">트리거 사용자 프로브 &lt;code&gt;user_trace_i4s4&lt;/code&gt; NIF 라이브러리에 &lt;code&gt;dyntrace.so&lt;/code&gt; 호출하여 &lt;code&gt;dyntrace:p/{1,2,3,4,5,6,7,8}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b4e339fc739fe569582f228faed311550ce6f3" translate="yes" xml:space="preserve">
          <source>Triggers garbage collection of requested type. Default value is &lt;code&gt;'major'&lt;/code&gt;, which would trigger a fullsweep GC. The option &lt;code&gt;'minor'&lt;/code&gt; is considered a hint and may lead to either minor or major GC run.</source>
          <target state="translated">요청 된 유형의 가비지 수집을 트리거합니다. 기본값은 &lt;code&gt;'major'&lt;/code&gt; 이며 풀 스윕 GC를 트리거합니다. 옵션 &lt;code&gt;'minor'&lt;/code&gt; 은 힌트로 간주되며 사소한 GC 실행으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bce7d4bc5bdcfee52b94b55561a6aeaf81f157f5" translate="yes" xml:space="preserve">
          <source>Triggers the next message to be streamed, that is, the same behavior as active ones for sockets.</source>
          <target state="translated">스트리밍 할 다음 메시지, 즉 소켓의 활성 메시지와 동일한 동작을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="a0f37655e58e53f4d21a5d5b772a98970d6a45b9" translate="yes" xml:space="preserve">
          <source>Trim threshold size (in kilobytes). This is the maximum amount of free memory at the top of the heap (allocated by &lt;code&gt;sbrk&lt;/code&gt;) that is kept by &lt;code&gt;malloc&lt;/code&gt; (not released to the operating system). When the amount of free memory at the top of the heap exceeds the trim threshold, &lt;code&gt;malloc&lt;/code&gt; releases it (by calling &lt;code&gt;sbrk&lt;/code&gt;). Trim threshold is specified in kilobytes. Defaults to &lt;code&gt;128&lt;/code&gt;.</source>
          <target state="translated">트림 임계 값 크기 (KB). 이것은 &lt;code&gt;malloc&lt;/code&gt; (운영 체제로 릴리스되지 않음)에 의해 유지되는 힙 맨 위의 사용 가능한 최대 메모리 양 ( &lt;code&gt;sbrk&lt;/code&gt; 에 의해 할당 됨 )입니다. 힙 상단의 사용 가능한 메모리 양이 트림 임계 값을 초과하면 &lt;code&gt;malloc&lt;/code&gt; 은이를 해제합니다 ( &lt;code&gt;sbrk&lt;/code&gt; 호출 ). 트림 임계 값은 킬로바이트로 지정됩니다. 기본값은 &lt;code&gt;128&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95ec715dc8ff6a5284221ec8f9868a8798be9478" translate="yes" xml:space="preserve">
          <source>Trivial FTP.</source>
          <target state="translated">사소한 FTP.</target>
        </trans-unit>
        <trans-unit id="4ba00956ec7cf24ae072a34b8ff599479668e012" translate="yes" xml:space="preserve">
          <source>Trivial example (beep on anything except empty line, which is expanded to &lt;code&gt;&quot;quit&quot;&lt;/code&gt;):</source>
          <target state="translated">간단한 예 ( &lt;code&gt;&quot;quit&quot;&lt;/code&gt; 로 확장 된 빈 줄 이외의 경고음 ) :</target>
        </trans-unit>
        <trans-unit id="c64384e3540118ebd85f8e8adda7b3a0d9d9d577" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a binary.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 이진수 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="2184451194ed3a9022be648eb665e2e8303c78bb" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a floating point number.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 부동 소수점 숫자 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="739f16017ed1c1b0d52375a346e88d29489f5f4c" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with at least one element.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 하나 이상의 요소가있는 목록 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="4dc6a0f22eecbe39d3b7bafca6d0ecf3f15fab72" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a list with zero or more elements.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 0 개 이상의 요소가있는 목록 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="7e4dec6465a412dda92c461f8f7e72cba72e9ec3" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a pid (process identifier).</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 pid (프로세스 식별자) 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="ca9f92d44502347305071d3028c3415ccc6539b0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a port.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 포트 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="63b81f24f20e74b9964fd68165f42bbd5f102696" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a reference.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 참조 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="369ae59368966778ddc2fa05ef42ca484213f640" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is a tuple.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 튜플 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="200e8169564499251662fa489120aa02ef56f5b7" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an atom.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 원자 이면 참 .</target>
        </trans-unit>
        <trans-unit id="d2096948a91663a352916722e0007725da8866ba" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an empty list.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 빈 목록 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="7cf519e4319be41a9707146ad88931f2320203e5" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;t&lt;/code&gt; is an integer.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 정수 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="58de67beda24834e524aecdc74c16cbb945cf7c3" translate="yes" xml:space="preserve">
          <source>Truncates the file referenced by &lt;code&gt;IoDevice&lt;/code&gt; at the current position. Returns &lt;code&gt;ok&lt;/code&gt; if successful, otherwise &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">현재 위치에서 &lt;code&gt;IoDevice&lt;/code&gt; 가 참조하는 파일을 자릅니다 . 성공하면 &lt;code&gt;ok&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="37023c65abd347268bb58c87d2fb0048749a483a" translate="yes" xml:space="preserve">
          <source>Try out the new function &lt;code&gt;mult&lt;/code&gt;:</source>
          <target state="translated">새로운 기능 &lt;code&gt;mult&lt;/code&gt; 를 사용해보십시오 :</target>
        </trans-unit>
        <trans-unit id="8ff47aa173fda0968a762374da8240dfe8b55c52" translate="yes" xml:space="preserve">
          <source>Trying to evaluate a &lt;code&gt;throw&lt;/code&gt;outside a &lt;code&gt;catch&lt;/code&gt;. &lt;code&gt;V&lt;/code&gt; is the thrown term.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 밖의 &lt;code&gt;throw&lt;/code&gt; 를 평가하려고합니다 . &lt;code&gt;V&lt;/code&gt; 는 던진 용어입니다.</target>
        </trans-unit>
        <trans-unit id="07a738ec4060694f8cccf2229438cc8e4149b664" translate="yes" xml:space="preserve">
          <source>Trying to link or monitor to a non-existing process or port.</source>
          <target state="translated">존재하지 않는 프로세스 또는 포트에 연결하거나 모니터링하려고합니다.</target>
        </trans-unit>
        <trans-unit id="cae5dd25bf19639aecf488ad3d7ba57e76736991" translate="yes" xml:space="preserve">
          <source>Trying to link to a non-existing process.</source>
          <target state="translated">존재하지 않는 프로세스에 연결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f4134e3f0fb2b5c47f2d5517769378391de080f4" translate="yes" xml:space="preserve">
          <source>Tunes the compression algorithm. Use the following values:</source>
          <target state="translated">압축 알고리즘을 조정합니다. 다음 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3e0a317e78b26f5945cf71664d252d582664be5" translate="yes" xml:space="preserve">
          <source>Tuning the intensity and period</source>
          <target state="translated">강도 및 기간 조정</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="83ed105f4df89ed36299f9fd59a044cb698807f7" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error, error_info()}&lt;/code&gt; and &lt;code&gt;{warning, error_info()}&lt;/code&gt;, denoting syntactically incorrect forms and warnings, and &lt;code&gt;{eof, line()}&lt;/code&gt;, denoting an end-of-stream encountered before a complete form had been parsed.</source>
          <target state="translated">문법적으로 잘못된 양식 및 경고를 나타내는 &lt;code&gt;{error, error_info()}&lt;/code&gt; 및 &lt;code&gt;{warning, error_info()}&lt;/code&gt; 튜플 은 완전한 양식이 구문 분석되기 전에 발생한 스트림 끝을 나타내는 &lt;code&gt;{eof, line()}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ffa679969428a6c8a5fbef9da583b1339b8f137" translate="yes" xml:space="preserve">
          <source>Tuples &lt;code&gt;{error,E}&lt;/code&gt; and &lt;code&gt;{warning,W}&lt;/code&gt;, denoting syntactically incorrect forms and warnings.</source>
          <target state="translated">문법적으로 잘못된 형식과 경고를 나타내는 튜플 &lt;code&gt;{error,E}&lt;/code&gt; 및 &lt;code&gt;{warning,W}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4a5e32a69d4a4da5b271ce1389ce7de27bf6be9" translate="yes" xml:space="preserve">
          <source>Tuples and string formats accepted by versions before ssl-8.2.4 will be converted for backwards compatibility</source>
          <target state="translated">ssl-8.2.4 이전 버전에서 허용되는 튜플 및 문자열 형식은 이전 버전과의 호환성을 위해 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f1ed151ede62f70799b920d57a42f17bd5fb2581" translate="yes" xml:space="preserve">
          <source>Tuples can have more than two parts, in fact as many parts as you want, and contain any valid Erlang &lt;strong&gt;term&lt;/strong&gt;. For example, to represent the temperature of various cities of the world:</source>
          <target state="translated">튜플은 실제로 원하는 수의 부품을 두 개 이상 가질 수 있으며 유효한 Erlang &lt;strong&gt;항을&lt;/strong&gt; 포함 할 수 있습니다 . 예를 들어 세계 여러 도시의 온도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef0f5b8ef4ff33f41dc26081793feb3c120d0be9" translate="yes" xml:space="preserve">
          <source>Tuples have a fixed number of items in them. Each item in a tuple is called an &lt;strong&gt;element&lt;/strong&gt;. In the tuple &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt;, element 1 is &lt;code&gt;moscow&lt;/code&gt; and element 2 is &lt;code&gt;{c,-10}&lt;/code&gt;. Here &lt;code&gt;c&lt;/code&gt; represents Celsius and &lt;code&gt;f&lt;/code&gt; Fahrenheit.</source>
          <target state="translated">튜플에는 고정 된 개수의 항목이 있습니다. 튜플의 각 항목을 &lt;strong&gt;요소&lt;/strong&gt; 라고합니다 . 튜플 &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; 에서 요소 1은 &lt;code&gt;moscow&lt;/code&gt; 이고 요소 2는 &lt;code&gt;{c,-10}&lt;/code&gt; 입니다. 여기서 &lt;code&gt;c&lt;/code&gt; 섭씨 나타내고 &lt;code&gt;f&lt;/code&gt; 를 화씨.</target>
        </trans-unit>
        <trans-unit id="6af244d55aef38e6c2274514e3d2ab60c94ed28b" translate="yes" xml:space="preserve">
          <source>Tuples in the template express if-exist tests for metadata keys. For example, the following tuple says that if &lt;code&gt;key1&lt;/code&gt; exists in the metadata map, print &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt;, where &lt;code&gt;Value&lt;/code&gt; is the value that &lt;code&gt;key1&lt;/code&gt; is associated with in the metadata map. If &lt;code&gt;key1&lt;/code&gt; does not exist, print nothing.</source>
          <target state="translated">템플릿의 튜플은 메타 데이터 키에 대한 기존 테스트를 나타냅니다. 예를 들어, 다음 튜플은 &lt;code&gt;key1&lt;/code&gt; 이 메타 데이터 맵에 존재 하는 경우 &lt;code&gt;&quot;key1=Value&quot;&lt;/code&gt; 를 인쇄합니다 . 여기서 &lt;code&gt;Value&lt;/code&gt; 는 &lt;code&gt;key1&lt;/code&gt; 이 메타 데이터 맵에서 연관된 값입니다 . 경우 &lt;code&gt;key1&lt;/code&gt; 존재하지 않는, 아무것도 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="243da839e833dcd6a7348ba4d1efa268f8e8a3ec" translate="yes" xml:space="preserve">
          <source>Tuples, maps, and lists (except strings, see below) are built in reverse polish notation, so that to build a tuple, the elements are specified first, and then the tuple term, with a count. Likewise for lists and maps.</source>
          <target state="translated">튜플, 맵 및 목록 (문자열 제외, 아래 참조)은 리버스 폴리쉬 표기법으로 빌드되므로 튜플을 빌드하기 위해 요소가 먼저 지정된 다음 튜플 용어가 개수와 함께 지정됩니다. 목록과지도도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8d71459c65d809aa4497f4a28bfc896fb1085c9c" translate="yes" xml:space="preserve">
          <source>Turn a syntax tree or list of trees into a template or templates. Templates can be instantiated or matched against, and reverted back to normal syntax trees using &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt;. If the input is already a template, it is not modified further.</source>
          <target state="translated">구문 트리 나 트리 목록을 템플릿으로 바꿉니다. &lt;code&gt;&lt;a href=&quot;#tree-1&quot;&gt;tree/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 템플릿을 인스턴스화하거나 일치시키고 일반 구문 트리로 되돌릴 수 있습니다 . 입력이 이미 템플릿 인 경우 더 이상 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8971cba7199bca87b23c2ec538c7121c59edc40" translate="yes" xml:space="preserve">
          <source>Turn a template into a syntax tree representing the template. Meta-variables in the template are turned into normal Erlang variables if their names (after the metavariable prefix characters) begin with an uppercase character. E.g., &lt;code&gt;_@Foo&lt;/code&gt; in the template becomes the variable &lt;code&gt;Foo&lt;/code&gt; in the meta-template. Furthermore, variables ending with &lt;code&gt;@&lt;/code&gt; are automatically wrapped in a call to merl:term/1, so e.g. &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; in the meta-template.</source>
          <target state="translated">템플릿을 템플릿을 나타내는 구문 트리로 바꿉니다. 템플릿의 메타 변수는 이름 (메타 변수 접두사 문자 뒤)이 대문자로 시작하면 일반 얼랭 변수로 바뀝니다. 예를 들어 템플릿의 &lt;code&gt;_@Foo&lt;/code&gt; 는 메타 템플릿 의 변수 &lt;code&gt;Foo&lt;/code&gt; 가됩니다 . 또한 &lt;code&gt;@&lt;/code&gt; 로 끝나는 변수 는 merl : term / 1을 호출 할 때 자동으로 래핑되므로 &lt;code&gt;_@Foo@ in the template becomes `merl:term(Foo)&lt;/code&gt; 는 메타 템플릿에서 `merl : term (Foo)가 됩니다.</target>
        </trans-unit>
        <trans-unit id="f11fdfc294615cd6feba1dc471497bd296595a74" translate="yes" xml:space="preserve">
          <source>Turn an error reason returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; into a readable string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 반환 한 오류 이유를 읽을 수있는 문자열로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="0a32475174f92b9fb2f8542dc37a90aaa235a8d8" translate="yes" xml:space="preserve">
          <source>Turn off monitoring of the SNMP manager.</source>
          <target state="translated">SNMP 관리자의 모니터링을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="1596e715102816d11edb68278af146f787525ee2" translate="yes" xml:space="preserve">
          <source>Turn on and pare down debugging</source>
          <target state="translated">디버깅 설정 및 해제</target>
        </trans-unit>
        <trans-unit id="8d0273b96fc2970b3bd22f825df50106f57a4d5f" translate="yes" xml:space="preserve">
          <source>Turn on distribution tracing on the Erlang node.</source>
          <target state="translated">Erlang 노드에서 분배 추적을 켜십시오.</target>
        </trans-unit>
        <trans-unit id="4b6673d76d88179b888141748a220ac4df22b7da" translate="yes" xml:space="preserve">
          <source>Turn on global tracing</source>
          <target state="translated">글로벌 추적 사용</target>
        </trans-unit>
        <trans-unit id="b5fd46c0414339fbc6a9a1e9bcad5db789cc32cf" translate="yes" xml:space="preserve">
          <source>Turning the scrollable_cursors option off is noted to make old odbc-drivers able to connect that will otherwhise fail.</source>
          <target state="translated">scrollable_cursors 옵션을 끄면 오래된 odbc 드라이버를 연결하여 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3754a20c309fb4bee5151fc9185df3eb19690cf" translate="yes" xml:space="preserve">
          <source>Turns &lt;code&gt;Expr&lt;/code&gt; into a &quot;test object&quot;, by wrapping it in a fun-expression and a source line number. Technically, this is the same as &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt;.</source>
          <target state="translated">켜 &lt;code&gt;Expr&lt;/code&gt; 재미있는 표현과 소스 줄 번호에 포장하여, &quot;테스트 개체&quot;로. 기술적으로 이것은 &lt;code&gt;{?LINE, fun () -&amp;gt; (Expr) end}&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f90beb2441a8b6db181aba2d7f261f9f114ad008" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node. For other nodes in the network, this is the same as the node going down. Only possible when the net kernel was started using &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt;, otherwise &lt;code&gt;{error, not_allowed}&lt;/code&gt; is returned. Returns &lt;code&gt;{error, not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">분산 노드를 비 분산 노드로 전환합니다. 네트워크의 다른 노드의 경우 이는 노드가 다운되는 것과 같습니다. net 커널이 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 시작된 경우에만 가능합니다 . 그렇지 않으면 &lt;code&gt;{error, not_allowed}&lt;/code&gt; 가 리턴됩니다. 로컬 노드가 &lt;code&gt;{error, not_found}&lt;/code&gt; 가 아닌 경우 {error, not_found}를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d9857baf63bd4ff78f8a1416e9cce2328191833c" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node by starting &lt;code&gt;net_kernel&lt;/code&gt; and other necessary processes.</source>
          <target state="translated">&lt;code&gt;net_kernel&lt;/code&gt; 및 기타 필요한 프로세스를 시작하여 비 분산 노드를 분산 노드로 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="3f5c74d445a6ff38a1d1a5a031b9bc86b2fedd78" translate="yes" xml:space="preserve">
          <source>Turns a parsed dictionary, as returned by &lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt;, back into the dictionary format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#codec-2&quot;&gt;codec/2&lt;/a&gt;&lt;/code&gt; 에서 반환 한 구문 분석 된 사전을 사전 형식으로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="e92b0eef302a90ddf93e3d3b8a0765906432d6ac" translate="yes" xml:space="preserve">
          <source>Turns an ordered list &lt;code&gt;List&lt;/code&gt; of key-value tuples into a tree. The list must not contain duplicate keys.</source>
          <target state="translated">정렬 된 목록 키-값 튜플 &lt;code&gt;List&lt;/code&gt; 을 트리로 바꿉니다. 이 목록에는 중복 키가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="8629e653fd2bdd0ad7cbe844c08311477772efcc" translate="yes" xml:space="preserve">
          <source>Turns an ordered-set list &lt;code&gt;List&lt;/code&gt; into a set. The list must not contain duplicates.</source>
          <target state="translated">정렬 된 세트리스트 켜 &lt;code&gt;List&lt;/code&gt; 세트로. 목록에는 중복 항목이 포함되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9373344ff9c8b8d02dd03592aeaf47c2fd0e64a6" translate="yes" xml:space="preserve">
          <source>Turns off all debugging for the process. This includes functions that are installed explicitly with function &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt;, for example, triggers.</source>
          <target state="translated">프로세스에 대한 모든 디버깅을 끕니다. 여기에는 &lt;code&gt;&lt;a href=&quot;#install-2&quot;&gt;install/2,3&lt;/a&gt;&lt;/code&gt; 기능으로 명시 적으로 설치된 기능 ( 예 : 트리거)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d36edf7582655f75400ba16943847aa4c6aa0271" translate="yes" xml:space="preserve">
          <source>Turns off warnings for &quot;fresh&quot; variables in functional objects or list comprehensions with the same name as some already defined variable. Default is to emit warnings for such variables.</source>
          <target state="translated">기능 객체의 &quot;새로 고침&quot;변수에 대한 경고를 끄거나 이미 정의 된 변수와 이름이 같은 목록 이해를 표시합니다. 이러한 변수에 대한 기본값은 경고입니다.</target>
        </trans-unit>
        <trans-unit id="c093c691688f1f921a86e4bb9a9da3d6975d7358" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions like &lt;code&gt;nowarn_deprecated_function&lt;/code&gt; does, but only for the mentioned functions. &lt;code&gt;MFAs&lt;/code&gt; is a tuple &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">&lt;code&gt;nowarn_deprecated_function&lt;/code&gt; 과 같이 더 이상 사용되지 않는 함수 호출에 대한 경고를 끄지 만 언급 된 함수에 대해서만 경고를 끕니다 . &lt;code&gt;MFAs&lt;/code&gt; 는 튜플 &lt;code&gt;{Module,Name,Arity}&lt;/code&gt; 또는 이러한 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="31c129b33c46ffb547299340b27a43f495c00d43" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to deprecated functions. Default is to emit warnings for every call to a function known by the compiler to be deprecated. Notice that the compiler does not know about attribute &lt;code&gt;-deprecated()&lt;/code&gt;, but uses an assembled list of deprecated functions in Erlang/OTP. To do a more general check, the Xref tool can be used. See also &lt;code&gt;xref(3)&lt;/code&gt; and the function &lt;code&gt;xref:m/1&lt;/code&gt;, also accessible through the function &lt;code&gt;c:xm/1&lt;/code&gt;.</source>
          <target state="translated">더 이상 사용되지 않는 함수 호출에 대한 경고를 끕니다. 기본값은 컴파일러가 사용하지 않는 것으로 알려진 함수를 호출 할 때마다 경고를 표시하는 것입니다. 컴파일러는 속성 &lt;code&gt;-deprecated()&lt;/code&gt; 에 대해 알지 못하지만 Erlang / OTP에서 더 이상 사용되지 않는 함수의 조합 된 목록을 사용합니다. 보다 일반적인 점검을 위해 외부 참조 도구를 사용할 수 있습니다. 참고 &lt;code&gt;xref(3)&lt;/code&gt; 와 기능 &lt;code&gt;xref:m/1&lt;/code&gt; , 기능을 통해 또한 액세스 &lt;code&gt;c:xm/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aee881859be77fa1680f379d9cb9a8b67406b5bf" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to functions that have been removed. Default is to emit warnings for every call to a function known by the compiler to have been recently removed from Erlang/OTP.</source>
          <target state="translated">제거 된 함수에 대한 호출에 대한 경고를 끕니다. 기본값은 컴파일러가 최근에 Erlang / OTP에서 제거 된 것으로 알려진 함수에 대한 모든 호출에 대해 경고를 내보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5a9e8c56d11bc3f831ac60e969adff2295cdb81" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to modules or functions that have been removed. Default is to emit warnings for every call to a function known by the compiler to have been recently removed from Erlang/OTP.</source>
          <target state="translated">제거 된 모듈 또는 함수에 대한 호출에 대한 경고를 끕니다. 기본값은 컴파일러가 최근에 Erlang / OTP에서 제거 된 것으로 알려진 함수에 대한 모든 호출에 대해 경고를 내보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8643ee4d5408ecde9d2dfad0ec79316bb062403" translate="yes" xml:space="preserve">
          <source>Turns off warnings for calls to old type testing BIFs, such as &lt;code&gt;pid/1&lt;/code&gt; and &lt;code&gt;list/1&lt;/code&gt;. See the &lt;code&gt;Erlang Reference Manual&lt;/code&gt; for a complete list of type testing BIFs and their old equivalents. Default is to emit warnings for calls to old type testing BIFs.</source>
          <target state="translated">&lt;code&gt;pid/1&lt;/code&gt; 및 &lt;code&gt;list/1&lt;/code&gt; 과 같은 이전 유형 테스트 BIF에 대한 호출에 대한 경고를 끕니다 . 형식 테스트 BIF 및 이전 버전의 전체 목록은 &lt;code&gt;Erlang Reference Manual&lt;/code&gt; 을 참조 하십시오 . 기본값은 이전 유형 테스트 BIF 호출에 대한 경고를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="858be8f3bcf091fa061e46059bd3158726b548e6" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions like &lt;code&gt;nowarn_unused_function&lt;/code&gt; does, but only for the mentioned local functions. &lt;code&gt;FAs&lt;/code&gt; is a tuple &lt;code&gt;{Name,Arity}&lt;/code&gt; or a list of such tuples.</source>
          <target state="translated">&lt;code&gt;nowarn_unused_function&lt;/code&gt; 과 같이 사용하지 않는 로컬 함수에 대한 경고를 끄고 언급 된 로컬 함수에 대해서만 경고를 끕니다 . &lt;code&gt;FAs&lt;/code&gt; 는 튜플 &lt;code&gt;{Name,Arity}&lt;/code&gt; 또는 이러한 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c5e54f68af28f7baa91e0a423d6d647a5b8f257e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused local functions. Default is to emit warnings for all local functions that are not called directly or indirectly by an exported function. The compiler does not include unused local functions in the generated beam file, but the warning is still useful to keep the source code cleaner.</source>
          <target state="translated">사용하지 않는 로컬 기능에 대한 경고를 끕니다. 기본값은 내 보낸 함수에 의해 직접 또는 간접적으로 호출되지 않은 모든 로컬 함수에 대해 경고를 발생시키는 것입니다. 컴파일러는 생성 된 빔 파일에 사용되지 않은 로컬 함수를 포함하지 않지만 소스 코드를 깨끗하게 유지하는 데 여전히 경고가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8756279a371f2c74c71bfe9ea11d8fce882bd7ef" translate="yes" xml:space="preserve">
          <source>Turns off warnings for unused record types. Default is to emit warnings for unused locally defined record types.</source>
          <target state="translated">사용하지 않는 레코드 유형에 대한 경고를 끕니다. 기본적으로 사용되지 않는 로컬로 정의 된 레코드 유형에 대한 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40e660b8f492c229e1e8f807933c1bba4d2abc6f" translate="yes" xml:space="preserve">
          <source>Turns off warnings for use of deprecated types. Default is to emit warnings for every use of a type known by the compiler to be deprecated.</source>
          <target state="translated">더 이상 사용되지 않는 유형 사용에 대한 경고를 끕니다. 기본값은 컴파일러가 사용하지 않는 것으로 알려진 유형을 사용할 때마다 경고를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="176262640a2c391f662fb5a4f78d832cbe27740e" translate="yes" xml:space="preserve">
          <source>Turns off warnings for uses of the &lt;code&gt;export_all&lt;/code&gt; option. Default is to emit a warning if option &lt;code&gt;export_all&lt;/code&gt; is also given.</source>
          <target state="translated">&lt;code&gt;export_all&lt;/code&gt; 옵션 사용에 대한 경고를 끕니다 . &lt;code&gt;export_all&lt;/code&gt; 옵션 도 제공된 경우 기본값은 경고를 표시하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="849c8f41403b31c687964c8f844bbdc3100c6d15" translate="yes" xml:space="preserve">
          <source>Turns on (if &lt;code&gt;How == true&lt;/code&gt;) or off (if &lt;code&gt;How == false&lt;/code&gt;) the trace flags in &lt;code&gt;FlagList&lt;/code&gt; for the process or processes represented by &lt;code&gt;PidPortSpec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PidPortSpec&lt;/code&gt; 로 표시되는 프로세스에 대해 &lt;code&gt;FlagList&lt;/code&gt; 의 추적 플래그를 켜거나 ( &lt;code&gt;How == true&lt;/code&gt; ) 끄십시오 ( &lt;code&gt;How == false&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="90d4fea9a9eccae1bb6537b80425ce163c0e0e56" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for all types of function calls. Trace messages are sent whenever any of the specified functions are called, regardless of how they are called. If flag &lt;code&gt;return_to&lt;/code&gt; is set for the process, a &lt;code&gt;return_to&lt;/code&gt; message is also sent when this function returns to its caller.</source>
          <target state="translated">모든 유형의 함수 호출에 대한 호출 추적을 켜거나 끕니다. 추적 메시지는 호출 방법에 관계없이 지정된 함수가 호출 될 때마다 전송됩니다. 플래그 경우 &lt;code&gt;return_to&lt;/code&gt; 이 과정을 위해 설정하는 &lt;code&gt;return_to&lt;/code&gt; 의 메시지는 호출자에 때이 함수가 반환 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9cdc9034760c5ba6cf5f548250769a126c6a5dc8" translate="yes" xml:space="preserve">
          <source>Turns on or off call tracing for global function calls (that is, calls specifying the module explicitly). Only exported functions match and only global calls generate trace messages. &lt;strong&gt;This is the default&lt;/strong&gt;.</source>
          <target state="translated">글로벌 함수 호출 (즉, 모듈을 명시 적으로 지정하는 호출)에 대한 호출 추적을 켜거나 끕니다. 내 보낸 함수 만 일치하고 전역 호출 만 추적 메시지를 생성합니다. &lt;strong&gt;이것이 기본값&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbac06dc38fd14ffc69474d6cefe052fcc1e6496" translate="yes" xml:space="preserve">
          <source>Turns on or off meta-tracing for all types of function calls. Trace messages are sent to the tracer whenever any of the specified functions are called. If no tracer is specified, &lt;code&gt;self()&lt;/code&gt; is used as a default tracer process.</source>
          <target state="translated">모든 유형의 함수 호출에 대한 메타 추적을 켜거나 끕니다. 지정된 함수가 호출 될 때마다 추적 메시지가 추적 프로그램으로 전송됩니다. 추적자를 지정하지 않으면 &lt;code&gt;self()&lt;/code&gt; 가 기본 추적 프로그램 프로세스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a9e6071c635a8a8f47c7128d5e27fbe6794aa8" translate="yes" xml:space="preserve">
          <source>Turns on or off scheduler wall time measurements.</source>
          <target state="translated">스케줄러 월 시간 측정을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="6491707b6fbdad098acea3fe30f8bc3c9caeff41" translate="yes" xml:space="preserve">
          <source>Turns on/off microstate accounting measurements. When passing reset, all counters are reset to 0.</source>
          <target state="translated">소액 회계 계산 측정을 켜거나 끕니다. 재설정을 통과하면 모든 카운터가 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="49209b989e6c3ee063b36215b5a4316a9a7be144" translate="yes" xml:space="preserve">
          <source>Turns on|off automatic mapping of IPv4 addresses into IPv6 ones (if the socket address family is &lt;code&gt;AF_INET6&lt;/code&gt;).</source>
          <target state="translated">IPv4 주소를 IPv6 주소로 자동 매핑을 해제합니다 (소켓 주소 패밀리가 &lt;code&gt;AF_INET6&lt;/code&gt; 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="f85ecd85cea1de6466fad134e2d2f8f716405e71" translate="yes" xml:space="preserve">
          <source>Turns on|off the Nagle algorithm for merging small packets into larger ones. This improves throughput at the expense of latency.</source>
          <target state="translated">작은 패킷을 큰 패킷으로 병합하기위한 Nagle 알고리즘을 켭니다. 이는 대기 시간을 희생하여 처리량을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="a1f9ac44326e752574b33a1f14907aa1c45d24f1" translate="yes" xml:space="preserve">
          <source>Turns the logging of system events on or off. If on, a maximum of &lt;code&gt;N&lt;/code&gt; events are kept in the debug structure (default is 10).</source>
          <target state="translated">시스템 이벤트 로깅을 켜거나 끕니다. 설정하면 최대 &lt;code&gt;N&lt;/code&gt; 개의 이벤트가 디버그 구조에 유지됩니다 (기본값은 10).</target>
        </trans-unit>
        <trans-unit id="23c458441c0867d8269280b70644bb94df142cbd" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are supported:</source>
          <target state="translated">두 가지 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback modes&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6e3d52e5b54fd0236c6fd5f3a13294fee0ddff15" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;code&gt;match&lt;/code&gt; if they are of the same type and have the same value, so that &lt;code&gt;1&lt;/code&gt; matches &lt;code&gt;1&lt;/code&gt;, but not &lt;code&gt;1.0&lt;/code&gt; (as &lt;code&gt;1.0&lt;/code&gt; is a &lt;code&gt;float()&lt;/code&gt; and not an &lt;code&gt;integer()&lt;/code&gt;).</source>
          <target state="translated">두 얼랑 용어 &lt;code&gt;match&lt;/code&gt; 가 동일한 유형이고 같은 값이 있다면, 그래서 &lt;code&gt;1&lt;/code&gt; 경기 &lt;code&gt;1&lt;/code&gt; 있지만 &lt;code&gt;1.0&lt;/code&gt; (AS &lt;code&gt;1.0&lt;/code&gt; A는 &lt;code&gt;float()&lt;/code&gt; 아닌 &lt;code&gt;integer()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d09b25abb2a2cc4ca463f856d47434d8b27efd72" translate="yes" xml:space="preserve">
          <source>Two Erlang terms &lt;strong&gt;compare equal&lt;/strong&gt; if they either are of the same type and value, or if both are numeric types and extend to the same value, so that &lt;code&gt;1&lt;/code&gt; compares equal to both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">두 얼랑 용어는 &lt;strong&gt;동일한 비교&lt;/strong&gt; 가하거나 동일한 유형 및 값 인 경우, 또는 모두가 수치 형이며 따라서, 동일한 값으로 확장하는 경우 있음 &lt;code&gt;1&lt;/code&gt; 모두 동일한 비교 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe9db2aa68d2fec9c04e8f17ebd9155b9b06ccb7" translate="yes" xml:space="preserve">
          <source>Two adjacent &lt;code&gt;*&lt;/code&gt; used as a single pattern match all files and zero or more directories and subdirectories.</source>
          <target state="translated">단일 패턴으로 사용되는 두 개의 인접한 &lt;code&gt;*&lt;/code&gt; 는 모든 파일과 0 개 이상의 디렉토리 및 하위 디렉토리와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b24fbae83d83ea5cfa4199071718c20f64dd2575" translate="yes" xml:space="preserve">
          <source>Two adjacent string literals are concatenated into one. This is done in the compilation, thus, does not incur any runtime overhead.</source>
          <target state="translated">두 개의 인접한 문자열 리터럴이 하나로 연결됩니다. 이는 컴파일에서 수행되므로 런타임 오버 헤드가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cec8b2ac60b473ad30ad5a9539e9b27a87fdf3d" translate="yes" xml:space="preserve">
          <source>Two are containers for binary data and are called:</source>
          <target state="translated">이진 데이터를위한 컨테이너는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00afe0b16fc4b5dc8fb5d2b5e5c18c2ad4f6f71e" translate="yes" xml:space="preserve">
          <source>Two are merely references to a part of a binary and are called:</source>
          <target state="translated">두 개는 이진의 일부에 대한 참조 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="98533a56936d4841968d6378e92444f0f102a983" translate="yes" xml:space="preserve">
          <source>Two cases can occur:</source>
          <target state="translated">두 가지 경우가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f177120050db74caa4e744ec6cff39212557e9" translate="yes" xml:space="preserve">
          <source>Two different methods for opening a connection using the support functions in, for example, &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; follows:</source>
          <target state="translated">지원 기능을 사용하여 연결을 여는 두 가지 방법 (예 : &lt;code&gt;&lt;a href=&quot;ct_ssh&quot;&gt;ct_ssh&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ct_ftp&quot;&gt;ct_ftp&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8398755c3e867c12fc5deb0d9e53ba2d8bf52d0" translate="yes" xml:space="preserve">
          <source>Two different names cannot define the same OBJECT IDENTIFIER.</source>
          <target state="translated">서로 다른 두 이름으로 동일한 개체 ID를 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e330ec8353880267f056d94838df302f660f82d1" translate="yes" xml:space="preserve">
          <source>Two formats of the log files are supported:</source>
          <target state="translated">두 가지 형식의 로그 파일이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a4eef9b92d56df50918b227071f569535a9d01e3" translate="yes" xml:space="preserve">
          <source>Two forms have special meaning:</source>
          <target state="translated">두 가지 형태는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd82c68ad98788490ce7310efdb097df7571def" translate="yes" xml:space="preserve">
          <source>Two forms of &lt;code&gt;--inherits&lt;/code&gt; have special meaning:</source>
          <target state="translated">두 가지 형태의 &lt;code&gt;--inherits&lt;/code&gt; 은 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7200659e5edf764a36bafabfdd35b2bc1867bbcb" translate="yes" xml:space="preserve">
          <source>Two functions (modules, applications, releases) belong to the same strongly connected component if they call each other (in)directly. The interpretation of the &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; operator is the set of strongly connected components of a set of calls. The &lt;code&gt;condensation&lt;/code&gt; of a set of calls is a new set of calls between the strongly connected components such that there is an edge between two components if there is some constant of the first component that calls some constant of the second component.</source>
          <target state="translated">두 개의 기능 (모듈, 응용 프로그램, 릴리스)은 서로 직접 호출하는 경우 동일한 강력하게 연결된 구성 요소에 속합니다. &lt;code id=&quot;graph_analyses&quot;&gt;components&lt;/code&gt; 연산자에 대한 해석은 일련의 통화 집합에 강력하게 연결된 구성 요소 집합입니다. 일련의 호출 의 &lt;code&gt;condensation&lt;/code&gt; 은 강력하게 연결된 구성 요소 사이의 새로운 호출 집합이므로 두 번째 구성 요소의 일부 상수를 호출하는 첫 번째 구성 요소의 상수가있는 경우 두 구성 요소 사이에 가장자리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8330baa5a8c7712027a0d478bca1ae0572b758a5" translate="yes" xml:space="preserve">
          <source>Two guard BIFs handle maps:</source>
          <target state="translated">두 개의 가드 BIF가 맵을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0b0d7874fec4ed30ad6e8758caa4fe777cac7d9b" translate="yes" xml:space="preserve">
          <source>Two interoperability mechanisms are built into the Erlang runtime system, &lt;strong&gt;distributed Erlang&lt;/strong&gt; and &lt;strong&gt;ports&lt;/strong&gt;. A variation of ports is &lt;strong&gt;linked-in drivers&lt;/strong&gt;.</source>
          <target state="translated">Erlang 런타임 시스템에는 두 가지 상호 운용성 메커니즘 인 &lt;strong&gt;분산 Erlang&lt;/strong&gt; 및 &lt;strong&gt;포트&lt;/strong&gt; 가 내장되어 &lt;strong&gt;있습니다&lt;/strong&gt; . 포트의 변형은 &lt;strong&gt;링크 된 드라이버&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5dedccf2b4c340ae3513b7f5da6ce218b6889bec" translate="yes" xml:space="preserve">
          <source>Two keys are considered equal if they match (&lt;code&gt;=:=&lt;/code&gt;). That is, numbers are compared literally rather than by value, so that, for example, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; are different keys.</source>
          <target state="translated">두 개의 키가 일치하면 ( &lt;code&gt;=:=&lt;/code&gt; ) 동일한 것으로 간주됩니다 . 즉, 숫자는 값이 아닌 문자 그대로 비교되므로 예를 들어 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;1.0&lt;/code&gt; 은 다른 키입니다.</target>
        </trans-unit>
        <trans-unit id="211827ea828fd59c26ecf8cc7423a3ab35588d32" translate="yes" xml:space="preserve">
          <source>Two methods are available for writing database queries:</source>
          <target state="translated">데이터베이스 쿼리 작성에 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad65263f8565f810c97115c267d8c4735088c82" translate="yes" xml:space="preserve">
          <source>Two more examples, both selecting Latin-1 as default encoding:</source>
          <target state="translated">기본 인코딩으로 Latin-1을 선택하는 두 가지 예 :</target>
        </trans-unit>
        <trans-unit id="310abdb2aa2e0aae49bd84e931c4347743cefcc7" translate="yes" xml:space="preserve">
          <source>Two old applications are of interest regarding interoperability. Both have been replaced by IC and are mentioned here for reference only:</source>
          <target state="translated">상호 운용성과 관련하여 두 가지 이전 응용 프로그램이 중요합니다. 둘 다 IC로 대체되었으며 참조 용으로 만 여기에 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ee15f30d25e865ebb91626574306b0a361ae12" translate="yes" xml:space="preserve">
          <source>Two processes can be &lt;strong&gt;linked&lt;/strong&gt; to each other. A link between two processes &lt;code&gt;Pid1&lt;/code&gt; and &lt;code&gt;Pid2&lt;/code&gt; is created by &lt;code&gt;Pid1&lt;/code&gt; calling the BIF &lt;code&gt;link(Pid2)&lt;/code&gt; (or conversely). There also exist a number of &lt;code&gt;spawn_link&lt;/code&gt; BIFs, which spawn and link to a process in one operation.</source>
          <target state="translated">두 프로세스가 서로 &lt;strong&gt;연결될&lt;/strong&gt; 수 있습니다 . 두 프로세스 간의 링크 &lt;code&gt;Pid1&lt;/code&gt; 및 &lt;code&gt;Pid2&lt;/code&gt; 에 의해 생성된다 &lt;code&gt;Pid1&lt;/code&gt; BIF의 전화 &lt;code&gt;link(Pid2)&lt;/code&gt; (또는 역으로). 또한 한 번의 작업으로 프로세스를 생성하고 연결 하는 많은 &lt;code&gt;spawn_link&lt;/code&gt; BIF가 있습니다.</target>
        </trans-unit>
        <trans-unit id="66233b52f4a68d187c85f03b1740a9c4ed076273" translate="yes" xml:space="preserve">
          <source>Two resource terms will compare equal if and only if they would yield the same resource object pointer when passed to &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 자원 용어는 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 에 전달 될 때 동일한 자원 객체 포인터를 생성하는 경우에만 동등하게 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="5608c70162089e189da4df1a1b5bf134008a262e" translate="yes" xml:space="preserve">
          <source>Two resource terms will compare equal iff they would yield the same resource object pointer when passed to &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 개의 자원 용어는 &lt;code&gt;&lt;a href=&quot;#enif_get_resource&quot;&gt;enif_get_resource&lt;/a&gt;&lt;/code&gt; 로 전달 될 때 동일한 자원 객체 포인터를 생성 할 경우 동일한 비교를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="af30a2501d3290d8d47d226b3a9dd6e2917631b1" translate="yes" xml:space="preserve">
          <source>Two sets are &lt;strong id=&quot;disjoint&quot;&gt;disjoint&lt;/strong&gt; if their intersection is the empty set.</source>
          <target state="translated">교차점이 빈 세트이면 두 세트가 &lt;strong id=&quot;disjoint&quot;&gt;분리&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7ebc9faf237e0b7af0081118908fcbec68ae6ca" translate="yes" xml:space="preserve">
          <source>Two sets of metacharacters exist: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized within square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">메타 문자의 두 세트가 존재합니다. 대괄호를 제외하고 패턴의 모든 위치에서 인식되는 문자와 대괄호 내에서 인식되는 메타 문자입니다. 대괄호 외부에서 메타 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca80cfab8caa7daafc007467d281bddd65b58bec" translate="yes" xml:space="preserve">
          <source>Two simple implementation(s) is provided with the toolkit; the modules &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; which is the default and &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">툴킷에는 두 가지 간단한 구현이 제공됩니다. &lt;code&gt;&lt;a href=&quot;snmpa_error_logger&quot;&gt;snmpa_error_logger&lt;/a&gt;&lt;/code&gt; 모듈 이며 기본값은 &lt;code&gt;&lt;a href=&quot;snmpa_error_io&quot;&gt;snmpa_error_io&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8aad91307995a202add0f48ff4e5e1745721276" translate="yes" xml:space="preserve">
          <source>Two subterms are supported, &lt;code&gt;node_start&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;node_start&lt;/code&gt; 및 &lt;code&gt;eval&lt;/code&gt; 의 두 가지 하위 용어가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a86bc9ecf16a74feace03ab8af025d243363cf6" translate="yes" xml:space="preserve">
          <source>Two terms &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; compare equal if &lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. They match if &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T1&amp;nbsp;==&amp;nbsp;T2&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 두 항 &lt;code&gt;T1&lt;/code&gt; 과 &lt;code&gt;T2&lt;/code&gt; 가 동일하게 비교됩니다 . &lt;code&gt;T1&amp;nbsp;=:=&amp;nbsp;T2&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="319ab96ab6a94c595bf510dc2b6df202a2c7e4fb" translate="yes" xml:space="preserve">
          <source>Two time types are defined within ASN.1: Generalized Time and Universal Time Coordinated (UTC). Both are assigned a value as an ordinary string within double quotes, for example, &quot;19820102070533.8&quot;.</source>
          <target state="translated">ASN.1에는 두 가지 시간 유형이 정의되어 있습니다 : 일반화 시간 및 표준시 (UTC). 둘 다 큰 따옴표 안에 일반 문자열로 값이 지정됩니다 (예 : &quot;19820102070533.8&quot;).</target>
        </trans-unit>
        <trans-unit id="5cbed6cd9f648062eb5c7c60f1a880bc94c83866" translate="yes" xml:space="preserve">
          <source>Two trace drivers are currently implemented, the &lt;code&gt;file&lt;/code&gt; and the &lt;code&gt;ip&lt;/code&gt; trace drivers. The file driver sends all trace messages into one or several binary files, from where they later can be fetched and processed with the &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; function. The ip driver opens a TCP/IP port where it listens for connections. When a client (preferably started by calling &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; on another Erlang node) connects, all trace messages are sent over the IP network for further processing by the remote client.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 과 &lt;code&gt;ip&lt;/code&gt; 추적 드라이버 라는 두 가지 추적 드라이버가 현재 구현되어 있습니다. 파일 드라이버는 모든 추적 메시지를 하나 또는 여러 개의 이진 파일로 전송합니다.이 파일은 나중에 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 함수 로 페치 및 처리 할 수 ​​있습니다 . ip 드라이버는 TCP / IP 포트를 열어 연결을 수신합니다. 클라이언트 ( 다른 Erlang 노드에서 &lt;code&gt;&lt;a href=&quot;#trace_client-2&quot;&gt;trace_client/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 시작하는 것이 바람직 함 )가 연결되면 원격 클라이언트가 추가 처리 할 수 ​​있도록 모든 추적 메시지가 IP 네트워크를 통해 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e5e6393335f1e611665a4a7a24f8bce5b9e0c892" translate="yes" xml:space="preserve">
          <source>Two types of counter arrays can be created with options &lt;code&gt;atomics&lt;/code&gt; or &lt;code&gt;write_concurrency&lt;/code&gt;. The &lt;code&gt;atomics&lt;/code&gt; counters have good allround performance with nice consistent semantics while &lt;code&gt;write_concurrency&lt;/code&gt; counters offers even better concurrent write performance at the expense of some potential read inconsistencies. See &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atomics&lt;/code&gt; 또는 &lt;code&gt;write_concurrency&lt;/code&gt; 옵션을 사용하여 두 가지 유형의 카운터 배열을 만들 수 있습니다 . &lt;code&gt;atomics&lt;/code&gt; 동안 카운터가 좋은 일관된 의미 좋은 ALLROUND의 성능을 &lt;code&gt;write_concurrency&lt;/code&gt; 의 몇 가지 가능성을 희생 카운터 제공 더 나은 동시 쓰기 성능이 불일치를 읽어 보시기 바랍니다. &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c70732f422ad9f7dd9ec37500b2c8c51a72ca7dd" translate="yes" xml:space="preserve">
          <source>Two types of funs have slightly different semantics:</source>
          <target state="translated">두 가지 유형의 재미에는 의미가 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c611be8ba1da86ea53fc2e7c1dde0be77787929a" translate="yes" xml:space="preserve">
          <source>Two types of logs are supported:</source>
          <target state="translated">두 가지 유형의 로그가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="95838f01360f14fad0ac2ded66819bb7c9468ffa" translate="yes" xml:space="preserve">
          <source>Two upgrade instructions restart the emulator:</source>
          <target state="translated">두 가지 업그레이드 지침이 에뮬레이터를 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4806b67c077ea8929e31609963501c8a6fe89444" translate="yes" xml:space="preserve">
          <source>Two values are supported for &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; 에는 두 가지 값이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="d651b987b0a7139ea05af6dee8d526234f2fc5bb" translate="yes" xml:space="preserve">
          <source>Type &quot;2 + 5.&quot; in the shell and then press Enter (carriage return). Notice that you tell the shell you are done entering code by finishing with a full stop &quot;.&quot; and a carriage return.</source>
          <target state="translated">&quot;2 + 5&quot;를 입력하십시오. 셸에서 Enter 키를 누릅니다 (캐리지 리턴). 쉼표 ( &quot;)&quot;로 마무리하면 코드 입력이 완료되었음을 쉘에 알 수 있습니다. 캐리지 리턴.</target>
        </trans-unit>
        <trans-unit id="58364f896fc728f993e560667ecfb60de4f30fa0" translate="yes" xml:space="preserve">
          <source>Type &quot;a&quot; to leave the Erlang system.</source>
          <target state="translated">Erlang 시스템을 종료하려면 &quot;a&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="bb5acf833432a1b10201899b4168eeb24706098c" translate="yes" xml:space="preserve">
          <source>Type ::= &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</source>
          <target state="translated">유형 :: = &lt;code&gt;Fun&lt;/code&gt; | &lt;code&gt;Mod&lt;/code&gt; | &lt;code&gt;App&lt;/code&gt; | &lt;code&gt;Rel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eca7274bab6669941602b10cce52d6006cb9d4c5" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt;, that is, the HTTP method.</source>
          <target state="translated">&lt;code&gt;&quot;GET&quot; | &quot;POST&quot; | &quot;HEAD&quot; | &quot;TRACE&quot;&lt;/code&gt; 유형 | &quot;POST&quot;| &quot;헤드&quot;| &quot;TRACE&quot; 즉, HTTP 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="7b17bb0639b15e0f667e2fd419629250d1fac8bc" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt;. &lt;code&gt;parsed_header&lt;/code&gt; contains all HTTP header fields from the HTTP request stored in a list as key-value tuples. See &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; for a listing of all header fields. For example, the date field is stored as &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt;. RFC 2616 defines that HTTP is a case-insensitive protocol and the header fields can be in lower case or upper case. &lt;code&gt;httpd&lt;/code&gt; ensures that all header field names are in lower case.</source>
          <target state="translated">유형 &lt;code&gt;[{HeaderKey,HeaderValue}]&lt;/code&gt; . &lt;code&gt;parsed_header&lt;/code&gt; 는 목록에 키-값 튜플로 저장된 HTTP 요청의 모든 HTTP 헤더 필드를 포함합니다. 모든 헤더 필드 목록은 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;RFC 2616&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 예를 들어, 날짜 필드는 &lt;code&gt;{&quot;date&quot;,&quot;Wed, 15 Oct 1997 14:35:17 GMT&quot;}&lt;/code&gt; 됩니다. RFC 2616은 HTTP가 대소 문자를 구분하지 않는 프로토콜이며 헤더 필드는 소문자 또는 대문자 일 수 있다고 정의합니다. &lt;code&gt;httpd&lt;/code&gt; 는 모든 헤더 필드 이름이 소문자인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="88ea934d5b010cb0dc7ac9b9cf16bdd13e544370" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; is used to propagate data between modules. Depicted &lt;code&gt;interaction_data()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">&lt;code&gt;[{InteractionKey,InteractionValue}]&lt;/code&gt; 유형 은 모듈간에 데이터를 전파하는 데 사용됩니다. 함수 타입 선언에서 &lt;code&gt;interaction_data()&lt;/code&gt; 를 묘사했습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c98d13e8efa980132b032f5c0f337a67821802" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;which makensis.exe&lt;/code&gt; in the bash prompt and you should get the path to the program.</source>
          <target state="translated">bash 프롬프트에 &lt;code&gt;which makensis.exe&lt;/code&gt; 를 입력 하면 프로그램의 경로를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="1a1f7e9e5b0f8e672e72370d1ca9a97b0c0c8e01" translate="yes" xml:space="preserve">
          <source>Type UTF8String is represented as a UTF-8 encoded binary in Erlang. Such binaries can be created directly using the binary syntax or by converting from a list of Unicode code points using function &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">UTF8String 유형은 Erlang에서 UTF-8로 인코딩 된 이진으로 표시됩니다. 이러한 이진은 이진 구문을 사용하거나 &lt;code&gt;unicode:characters_to_binary/1&lt;/code&gt; 함수를 사용하여 유니 코드 코드 포인트 목록에서 변환하여 직접 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e178121a16f6b2c746af40f7c8a4a42ab3a0ec2" translate="yes" xml:space="preserve">
          <source>Type constraints allowed in patterns</source>
          <target state="translated">패턴에 허용되는 유형 제약</target>
        </trans-unit>
        <trans-unit id="0b347ce4e1bb3f750a45e84a0eec8e47bcbc5d1c" translate="yes" xml:space="preserve">
          <source>Type declarations can also be parameterized by including type variables between the parentheses. The syntax of type variables is the same as Erlang variables, that is, starts with an upper-case letter. Naturally, these variables can - and is to - appear on the RHS of the definition. A concrete example follows:</source>
          <target state="translated">괄호 사이에 유형 변수를 포함시켜 유형 선언을 매개 변수화 할 수도 있습니다. 변수 유형의 구문은 Erlang 변수와 동일합니다. 즉 대문자로 시작합니다. 당연히 이러한 변수는 정의의 RHS에 나타날 수 있습니다. 구체적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6300b103de258ff822aa6629b9e4238dd2a5ce7d" translate="yes" xml:space="preserve">
          <source>Type definitions related to HTTP:</source>
          <target state="translated">HTTP 관련 유형 정의 :</target>
        </trans-unit>
        <trans-unit id="833b41c81d15ae09af14347e83ccba5147adbd10" translate="yes" xml:space="preserve">
          <source>Type definitions that are related to URI:</source>
          <target state="translated">URI와 관련된 유형 정의 :</target>
        </trans-unit>
        <trans-unit id="b644ccc50476a72e86f7c39296fad76704713706" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module, or abstractions to indicate the intended use of the data type, or both:</source>
          <target state="translated">이 모듈에서 두 번 이상 사용되는 유형 정의 또는 데이터 유형의 의도 된 사용을 나타내는 추상화 또는 둘 다 :</target>
        </trans-unit>
        <trans-unit id="d2cf34335496de985396b3065117c3a7c2a8fa2b" translate="yes" xml:space="preserve">
          <source>Type definitions that are used more than once in this module:</source>
          <target state="translated">이 모듈에서 두 번 이상 사용되는 유형 정의 :</target>
        </trans-unit>
        <trans-unit id="589fe68e6ecbba2c443f7f0f1e09900382145a63" translate="yes" xml:space="preserve">
          <source>Type descriptors can be compared for equality or order (in the Erlang term order), but remember that floating-point values should in general never be tested for equality.</source>
          <target state="translated">유형 설명자는 같음 또는 순서 (Erlang 용어 순서)를 비교할 수 있지만 일반적으로 부동 소수점 값은 같지 않은지 테스트해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="dfb0b5d119973a2ca756d65efb3094aa7a2749aa" translate="yes" xml:space="preserve">
          <source>Type information can be used for the following:</source>
          <target state="translated">유형 정보는 다음에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="455328c30f9e89d8dd33028cd24752b9087d170d" translate="yes" xml:space="preserve">
          <source>Type letters on the right side</source>
          <target state="translated">오른쪽에 글자 입력</target>
        </trans-unit>
        <trans-unit id="3ebeb58712dc090b9f1c0c555b88300efc0c9f1b" translate="yes" xml:space="preserve">
          <source>Type makensis at the bash prompt and you should get a list of options if everything is OK.</source>
          <target state="translated">bash 프롬프트에서 makensis를 입력하면 모든 것이 정상이면 옵션 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e5d444f8eae5fc410e04ffff9e480446db812725" translate="yes" xml:space="preserve">
          <source>Type of lock: &lt;code&gt;rw_mutex&lt;/code&gt;, &lt;code&gt;mutex&lt;/code&gt;, &lt;code&gt;spinlock&lt;/code&gt;, &lt;code&gt;rw_spinlock&lt;/code&gt; or &lt;code&gt;proclock&lt;/code&gt;.</source>
          <target state="translated">잠금의 종류 : &lt;code&gt;rw_mutex&lt;/code&gt; , &lt;code&gt;mutex&lt;/code&gt; , &lt;code&gt;spinlock&lt;/code&gt; , &lt;code&gt;rw_spinlock&lt;/code&gt; 또는 &lt;code&gt;proclock&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ab1c2b1113b129c21326cea282b309a413da68f9" translate="yes" xml:space="preserve">
          <source>Type tests: &lt;code&gt;is_atom&lt;/code&gt;, &lt;code&gt;is_float&lt;/code&gt;, &lt;code&gt;is_integer&lt;/code&gt;, &lt;code&gt;is_list&lt;/code&gt;, &lt;code&gt;is_number&lt;/code&gt;, &lt;code&gt;is_pid&lt;/code&gt;, &lt;code&gt;is_port&lt;/code&gt;, &lt;code&gt;is_reference&lt;/code&gt;, &lt;code&gt;is_tuple&lt;/code&gt;, &lt;code&gt;is_binary&lt;/code&gt;, &lt;code&gt;is_function&lt;/code&gt;, &lt;code&gt;is_record&lt;/code&gt;</source>
          <target state="translated">유형 테스트 : &lt;code&gt;is_atom&lt;/code&gt; , &lt;code&gt;is_float&lt;/code&gt; , &lt;code&gt;is_integer&lt;/code&gt; , &lt;code&gt;is_list&lt;/code&gt; , &lt;code&gt;is_number&lt;/code&gt; , &lt;code&gt;is_pid&lt;/code&gt; , &lt;code&gt;is_port&lt;/code&gt; , &lt;code&gt;is_reference&lt;/code&gt; , &lt;code&gt;is_tuple&lt;/code&gt; , &lt;code&gt;is_binary&lt;/code&gt; , &lt;code&gt;is_function&lt;/code&gt; , &lt;code&gt;is_record&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca8a72020b7154672a01a7e0906d7d4fb8f5305d" translate="yes" xml:space="preserve">
          <source>Type variables can be used in specifications to specify relations for the input and output arguments of a function. For example, the following specification defines the type of a polymorphic identity function:</source>
          <target state="translated">사양에서 유형 변수를 사용하여 함수의 입력 및 출력 인수에 대한 관계를 지정할 수 있습니다. 예를 들어 다음 사양은 다형성 항등 함수의 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="844d69ffa5852c018b86872fd3385643da1684b4" translate="yes" xml:space="preserve">
          <source>Types and function specifications</source>
          <target state="translated">유형 및 기능 사양</target>
        </trans-unit>
        <trans-unit id="d9cf88052e09b9cf4919f33ab2053b176aa31518" translate="yes" xml:space="preserve">
          <source>Types corresponding to RFC 6733 AVP Data Formats. Defined in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">RFC 6733 AVP 데이터 형식에 해당하는 유형입니다. &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="19b63cf79ea9c163682784b133c791343ee64d2c" translate="yes" xml:space="preserve">
          <source>Types declared as &lt;code&gt;opaque&lt;/code&gt; represent sets of terms whose structure is not supposed to be visible from outside of their defining module. That is, only the module defining them is allowed to depend on their term structure. Consequently, such types do not make much sense as module local - module local types are not accessible by other modules anyway - and is always to be exported.</source>
          <target state="translated">&lt;code&gt;opaque&lt;/code&gt; 선언 된 유형은 정의 모듈 외부에서 구조를 볼 수없는 용어 집합을 나타냅니다. 즉, 그것들을 정의하는 모듈 만이 용어 구조에 의존 할 수 있습니다. 결과적으로 이러한 유형은 모듈 로컬-모듈 로컬 유형은 다른 모듈에서 액세스 할 수 없으며 항상 내 보내야하므로 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="535782a993effddbcbcaf96e815b800bf2866b08" translate="yes" xml:space="preserve">
          <source>Types describe sets of Erlang terms. Types consist of, and are built from, a set of predefined types, for example, &lt;code&gt;integer()&lt;/code&gt;, &lt;code&gt;atom()&lt;/code&gt;, and &lt;code&gt;pid()&lt;/code&gt;. Predefined types represent a typically infinite set of Erlang terms that belong to this type. For example, the type &lt;code&gt;atom()&lt;/code&gt; denotes the set of all Erlang atoms.</source>
          <target state="translated">유형은 Erlang 용어 세트를 설명합니다. 유형은 사전 정의 된 유형 세트 &lt;code&gt;integer()&lt;/code&gt; 예 : integer () , &lt;code&gt;atom()&lt;/code&gt; 및 &lt;code&gt;pid()&lt;/code&gt; 유형에서 빌드됩니다 . 미리 정의 된 유형은이 유형에 속하는 일반적으로 무한한 Erlang 용어 집합을 나타냅니다. 예를 들어, &lt;code&gt;atom()&lt;/code&gt; 유형 은 모든 Erlang 원자 세트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16b7d8aee0365ea3f9bf161364bd57ac3691c6da" translate="yes" xml:space="preserve">
          <source>Types for Engines</source>
          <target state="translated">엔진 유형</target>
        </trans-unit>
        <trans-unit id="4826f9f1cd21548c629153b4f8bdd98bd55b49d6" translate="yes" xml:space="preserve">
          <source>Types that refer to themselves are called recursive types. Example:</source>
          <target state="translated">자신을 참조하는 유형을 재귀 유형이라고합니다. 예:</target>
        </trans-unit>
        <trans-unit id="024abbee89dd93c227a8c61717c55412558d1806" translate="yes" xml:space="preserve">
          <source>Types used in TLS/DTLS</source>
          <target state="translated">TLS / DTLS에서 사용되는 유형</target>
        </trans-unit>
        <trans-unit id="1c02047b4473ab1d57fc7225f4164216e6bcfaf2" translate="yes" xml:space="preserve">
          <source>Types:</source>
          <target state="translated">Types:</target>
        </trans-unit>
        <trans-unit id="2f711f90b7022e079d8d5f49cef08ad4c28d080c" translate="yes" xml:space="preserve">
          <source>Typical &lt;code&gt;Reasons&lt;/code&gt;s:</source>
          <target state="translated">일반적인 &lt;code&gt;Reasons&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="129bb568100797e751f2b2f98cd51094a6287657" translate="yes" xml:space="preserve">
          <source>Typical Error Reasons</source>
          <target state="translated">일반적인 오류 원인</target>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="translated">일반적인 오류 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="translated">일반적인 오류 이유 :</target>
        </trans-unit>
        <trans-unit id="a875996fe6fd67197a25c652eb601e185ed5cc23" translate="yes" xml:space="preserve">
          <source>Typical error reasons: as for &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; if a file had to be opened, and as for &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적인 오류 이유 : 파일 을 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 하는 경우 open / 2 및 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 와 같은 경우 .</target>
        </trans-unit>
        <trans-unit id="fc74151b7056fe15fd99a84d554133408c7c5852" translate="yes" xml:space="preserve">
          <source>Typical usage when writing to a file descriptor looks like this:</source>
          <target state="translated">파일 디스크립터에 쓸 때의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="987aa67db85afce4340f54b81c2c1c09452ae62a" translate="yes" xml:space="preserve">
          <source>Typical users of the dirty CPU schedulers are large garbage collections, json protocol encode/decoders written as nifs and matrix manipulation libraries.</source>
          <target state="translated">더티 CPU 스케줄러의 일반적인 사용자는 대용량 가비지 수집, nifs 및 매트릭스 조작 라이브러리로 작성된 json 프로토콜 인코딩 / 디코더입니다.</target>
        </trans-unit>
        <trans-unit id="866cbe1e9d381ba3cdbeb39e4730521fbfcc8133" translate="yes" xml:space="preserve">
          <source>Typical users of the dirty IO schedulers are reading and writing to files.</source>
          <target state="translated">더티 IO 스케줄러의 일반적인 사용자는 파일을 읽고 쓰고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0583dc7b5aaef5f34ea3fa51cd6e026a525fd0" translate="yes" xml:space="preserve">
          <source>Typically high &lt;code&gt;time&lt;/code&gt; values are bad and this is often the thing to look for. However, one should also look for high lock acquisition frequencies (#tries) since locks generate overhead and because high frequency could become problematic if they begin to have conflicts even if it is not shown in a particular test.</source>
          <target state="translated">일반적으로 높은 &lt;code&gt;time&lt;/code&gt; 값은 좋지 않으며 이는 종종 찾아야 할 사항입니다. 그러나 잠금은 오버 헤드를 생성하고 특정 테스트에 표시되지 않더라도 충돌이 발생하면 높은 주파수가 문제가 될 수 있으므로 높은 잠금 획득 주파수 (#tries)를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="2c47ac130c9d90117072288c85fcf5d65c5fe895" translate="yes" xml:space="preserve">
          <source>Typically the operator, possibly running hundreds or thousands of test cases, does not want to fill the console with details about, or printouts from, specific test cases. By default, the operator only sees the following:</source>
          <target state="translated">일반적으로 수백 또는 수천 개의 테스트 사례를 실행하는 운영자는 특정 테스트 사례에 대한 세부 정보 또는 출력물로 콘솔을 채우고 싶지 않습니다. 기본적으로 운영자에게는 다음 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97e9960729125226aaee305f3d87924465b5abf5" translate="yes" xml:space="preserve">
          <source>Typically you want to substitute negations first, then aliases, then perform one or more expansions (sometimes you want to pre-expand particular entries before doing the main expansion). You might want to substitute negations and/or aliases repeatedly, to allow such forms in the right-hand side of aliases and expansion lists.</source>
          <target state="translated">일반적으로 부정을 먼저 대체 한 다음 별칭을 사용한 다음 하나 이상의 확장을 수행합니다 (주 확장을 수행하기 전에 특정 항목을 미리 확장하려는 경우가 있음). 별칭 및 확장 목록의 오른쪽에 이러한 양식을 허용하기 위해 부정 및 / 또는 별칭을 반복해서 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4535970fd788996603de7fcae8b5b1132c50cf1f" translate="yes" xml:space="preserve">
          <source>Typically, OpenSSL engines provide a hardware implementation of specific cryptographic operations. The hardware implementation usually offers improved performance over its software-based counterpart, which is known as cryptographic acceleration.</source>
          <target state="translated">일반적으로 OpenSSL 엔진은 특정 암호화 작업의 하드웨어 구현을 제공합니다. 하드웨어 구현은 일반적으로 암호화 가속이라고하는 소프트웨어 기반 제품보다 향상된 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c81772f74c1a9d8da4ff099d810781ce160aacf0" translate="yes" xml:space="preserve">
          <source>Typographic conventions:</source>
          <target state="translated">활자체 규약 :</target>
        </trans-unit>
        <trans-unit id="0d3d0996d3543e832deef4b0344dd80b1d22ba4d" translate="yes" xml:space="preserve">
          <source>UDP packets from the network</source>
          <target state="translated">네트워크의 UDP 패킷</target>
        </trans-unit>
        <trans-unit id="50aa3ec0f92e35711e8ffb982901d2c7f9850924" translate="yes" xml:space="preserve">
          <source>UDP queries are used unless resolver option &lt;code&gt;usevc&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which forces TCP queries. If the query is too large for UDP, TCP is used instead. For regular DNS queries, 512 bytes is the size limit.</source>
          <target state="translated">리졸버 옵션 &lt;code&gt;usevc&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아닌 경우 UDP 쿼리가 사용 되어 TCP 쿼리를 강제합니다. 쿼리가 UDP에 비해 너무 큰 경우 TCP가 대신 사용됩니다. 일반 DNS 쿼리의 경우 크기 제한은 512 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="486c66a0286294375958525f91cdfdb3f82c9cb3" translate="yes" xml:space="preserve">
          <source>URI processing functions.</source>
          <target state="translated">URI 처리 기능</target>
        </trans-unit>
        <trans-unit id="1d057bddb70164b040386e82de4c64661e29e8f2" translate="yes" xml:space="preserve">
          <source>URI to filename translation.</source>
          <target state="translated">URI를 파일 이름으로 변환</target>
        </trans-unit>
        <trans-unit id="52c3521da24366089045fe93222bbbea327aa8ee" translate="yes" xml:space="preserve">
          <source>URI utility module</source>
          <target state="translated">URI 유틸리티 모듈</target>
        </trans-unit>
        <trans-unit id="2497da8c1e8f3017cb461e9ead3580ed94a9004a" translate="yes" xml:space="preserve">
          <source>URL Aliasing</source>
          <target state="translated">URL 별칭</target>
        </trans-unit>
        <trans-unit id="f09d741a3ad78a10aeac235b7eda60b472c1c7ea" translate="yes" xml:space="preserve">
          <source>URL aliasing.</source>
          <target state="translated">URL 별명</target>
        </trans-unit>
        <trans-unit id="284501aa026d810fca5e30ec3e6fbb8b907a7d92" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://java.sun.com&quot;&gt;http://java.sun.com&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2390079739ca194b6adba26faaa714759aa93368" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d52349cc271c6019348a86ea4c491c0478f8cdd3" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://openssl.org/community/binaries.html&quot;&gt;http://openssl.org/community/binaries.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0133be96d80a337735afdf94d4b6d5617e90e15" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&quot;&gt;http://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a52ac449904e56f2f8f4257d980b456503a1c2" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&quot;&gt;http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b683663e96daabab32de2bda24157392f5a1dc1c" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://www.cygwin.com&quot;&gt;http://www.cygwin.com&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46c81ae6362771f7cb6b8c4396678a5639bfb460" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;http://www.oracle.com/java/technologies/javase-downloads.html&quot;&gt;http://www.oracle.com/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL: &lt;code&gt;&lt;a href=&quot;http://www.oracle.com/java/technologies/javase-downloads.html&quot;&gt;http://www.oracle.com/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="276871ba1190025d3a896ad5f2648a68709c0037" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&quot;&gt;https://msdn.microsoft.com/en-us/windows/desktop/bg162891.aspx&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53f076fb21dd236ea02ee81db09d3c6d1a9c2d70" translate="yes" xml:space="preserve">
          <source>URL: &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;https://msys2.github.io/&quot;&gt;https://msys2.github.io/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c130e8186817488b08e47f250bc88b4918c57145" translate="yes" xml:space="preserve">
          <source>URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL:&lt;code&gt;&lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;http://code.google.com/p/msysgit/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba178104dbef5fc6beaedd696ad3c447ee9da6ac" translate="yes" xml:space="preserve">
          <source>UT1</source>
          <target state="translated">UT1</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="8c0cd56da21e982f4424f294a92af6cffab886e5" translate="yes" xml:space="preserve">
          <source>UTF-8 is designed so that ISO Latin-1 characters with numbers beyond the 7-bit ASCII range are seldom considered valid when decoded as UTF-8. Therefore one can usually use heuristics to determine if a file is in UTF-8 or if it is encoded in ISO Latin-1 (one byte per character). The &lt;code&gt;unicode&lt;/code&gt; module can be used to determine if data can be interpreted as UTF-8:</source>
          <target state="translated">UTF-8은 7 비트 ASCII 범위를 초과하는 숫자를 가진 ISO Latin-1 문자가 UTF-8로 디코딩 될 때 거의 유효한 것으로 간주되지 않도록 설계되었습니다. 따라서 일반적으로 휴리스틱을 사용하여 파일이 UTF-8인지 또는 ISO Latin-1 (문자 당 1 바이트)로 인코딩되었는지 확인할 수 있습니다. &lt;code&gt;unicode&lt;/code&gt; 데이터는 UTF-8로 해석 될 수 있는지 결정하는 모듈을 사용할 수있다 :</target>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="translated">Ugaritic</target>
        </trans-unit>
        <trans-unit id="7a2f970d37032e17cb13a44bc956fa4e60bba4ed" translate="yes" xml:space="preserve">
          <source>Unary +</source>
          <target state="translated">단항 +</target>
        </trans-unit>
        <trans-unit id="898ecd6a265af9abef6adb306b4c0c9c0e00c767" translate="yes" xml:space="preserve">
          <source>Unary + - bnot not</source>
          <target state="translated">단항 +-하지 않습니다</target>
        </trans-unit>
        <trans-unit id="684c6ddd5eb8c278f83bc5399212042f5f7e16e9" translate="yes" xml:space="preserve">
          <source>Unary -</source>
          <target state="translated">단항-</target>
        </trans-unit>
        <trans-unit id="637d4f607a8fd2105b314306ae4c76ef4925ad36" translate="yes" xml:space="preserve">
          <source>Unary bitwise NOT</source>
          <target state="translated">단항 비트 NOT</target>
        </trans-unit>
        <trans-unit id="c9d35054fa41b42db47e25b9d91e662cc93e9f89" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;FormatFun&lt;/code&gt; is used by &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; for displaying the call that created the query handle of the table. Defaults to &lt;code&gt;undefined&lt;/code&gt;, which means that &lt;code&gt;info/1,2&lt;/code&gt; displays a call to &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt;. It is up to &lt;code&gt;FormatFun&lt;/code&gt; to present the selected objects of the table in a suitable way. However, if a character list is chosen for presentation, it must be an Erlang expression that can be scanned and parsed (a trailing dot is added by &lt;code&gt;info/1,2&lt;/code&gt; though).</source>
          <target state="translated">단항 콜백 함수 &lt;code&gt;FormatFun&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1,2&lt;/a&gt;&lt;/code&gt; 에서 테이블의 쿼리 핸들을 작성한 호출을 표시하는 데 사용됩니다 . 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다. 즉, &lt;code&gt;info/1,2&lt;/code&gt; 는 &lt;code&gt;'$MOD':'$FUN'/0&lt;/code&gt; 대한 호출을 표시합니다 . 테이블의 선택된 개체를 적절한 방식으로 표시 하는 것은 &lt;code&gt;FormatFun&lt;/code&gt; 에 달려 있습니다. 그러나 프리젠 테이션을 위해 문자 목록을 선택한 경우 스캔하고 구문 분석 할 수있는 Erlang 표현식이어야합니다 (마지막 점은 &lt;code&gt;info/1,2&lt;/code&gt; 로 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="8a8cf6ea70815c5c8dc6febb5bc34ace0255c96a" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;InfoFun&lt;/code&gt; is to return information about the table. &lt;code&gt;undefined&lt;/code&gt; is to be returned if the value of some tag is unknown:</source>
          <target state="translated">단항 콜백 함수 &lt;code&gt;InfoFun&lt;/code&gt; 은 테이블에 대한 정보를 반환하는 것입니다. 일부 태그의 값을 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1442c4ded70572e00f428d9108e7ae55df7a65b5" translate="yes" xml:space="preserve">
          <source>Unary callback function &lt;code&gt;PreFun&lt;/code&gt; is called once before the table is read for the first time. If the call fails, the query evaluation fails.</source>
          <target state="translated">단항 콜백 함수 &lt;code&gt;PreFun&lt;/code&gt; 은 테이블을 처음 읽기 전에 한 번 호출됩니다. 호출이 실패하면 쿼리 평가가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5a92175579f60db68a9c361cc251147f8debf6b0" translate="yes" xml:space="preserve">
          <source>Unary logical NOT</source>
          <target state="translated">단항 논리 NOT</target>
        </trans-unit>
        <trans-unit id="27bb4c7fe8d37999952aa5b0af1c3595bd259bdb" translate="yes" xml:space="preserve">
          <source>UnaryGraphOp ::= &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</source>
          <target state="translated">UnaryGraphOp :: = &lt;code&gt;components&lt;/code&gt; | &lt;code&gt;condensation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01c0a17c153449bd9a04099f8971f3292a601fb" translate="yes" xml:space="preserve">
          <source>UnarySetOp ::= &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="translated">UnarySetOp :: = &lt;code&gt;domain&lt;/code&gt; | &lt;code&gt;range&lt;/code&gt; | &lt;code&gt;strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="translated">Unassigned</target>
        </trans-unit>
        <trans-unit id="8707e2ffeef5fa8b41de5e679969a877cb9db6f0" translate="yes" xml:space="preserve">
          <source>Unblocks a log. A log can only be unblocked by the blocking process.</source>
          <target state="translated">로그를 차단 해제합니다. 차단 프로세스를 통해서만 로그를 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe39591d424d43f7cc9d6d4ca1303c1c24c48eab" translate="yes" xml:space="preserve">
          <source>Unbound and unsafe variables</source>
          <target state="translated">언 바운드 및 안전하지 않은 변수</target>
        </trans-unit>
        <trans-unit id="b13fe86cfdf1fdbc7031b4349a4b6f2fc354ab38" translate="yes" xml:space="preserve">
          <source>Uncompressed Size</source>
          <target state="translated">압축되지 않은 크기</target>
        </trans-unit>
        <trans-unit id="0a4c7b6c3e87ff86f41e836e792f67b6c2bdf902" translate="yes" xml:space="preserve">
          <source>Uncompressed size (unsigned 32-bit integer in big-endian byte order) is the size of the data before it was compressed. The compressed data has the following format when it has been expanded:</source>
          <target state="translated">압축되지 않은 크기 (빅 엔디안 바이트 순서의 부호없는 32 비트 정수)는 압축되기 전의 데이터 크기입니다. 압축 된 데이터는 확장되었을 때 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="848b92d8de0252bd79df355552090abc0668ced9" translate="yes" xml:space="preserve">
          <source>Uncompresses data with gz headers and checksum.</source>
          <target state="translated">gz 헤더와 체크섬이있는 데이터를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="79897564d08477a4d49effa829f40061f9569280" translate="yes" xml:space="preserve">
          <source>Uncompresses data with zlib headers and checksum.</source>
          <target state="translated">zlib 헤더와 체크섬이있는 데이터를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="6ad0694c3152ef1643cde8ba2d996a0323a6b4d2" translate="yes" xml:space="preserve">
          <source>Uncompresses data without zlib headers and checksum.</source>
          <target state="translated">zlib 헤더 및 체크섬없이 데이터를 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="a1c0570481ff7f3e6ed039d51cc86442ea076a33" translate="yes" xml:space="preserve">
          <source>Undefined thread that is not a scheduler thread.</source>
          <target state="translated">스케줄러 스레드가 아닌 정의되지 않은 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="f7aa71224a65884ef564916a9d0da2f89835d7d4" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;$ROOT/releases&lt;/code&gt;, a new directory &lt;code&gt;B&lt;/code&gt; is created, containing &lt;code&gt;ch_rel-2.rel&lt;/code&gt;, &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;sys.config&lt;/code&gt;, and &lt;code&gt;relup&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$ROOT/releases&lt;/code&gt; 아래에 &lt;code&gt;ch_rel-2.rel&lt;/code&gt; , &lt;code&gt;start.boot&lt;/code&gt; , &lt;code&gt;sys.config&lt;/code&gt; 및 &lt;code&gt;relup&lt;/code&gt; 을 포함 하는 새 디렉토리 &lt;code&gt;B&lt;/code&gt; 가 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="9db2e4f4f838b5c44fe9cf387c90abe7108283e8" translate="yes" xml:space="preserve">
          <source>Under Windows, batch file &lt;code&gt;etop.bat&lt;/code&gt; can be used.</source>
          <target state="translated">Windows에서는 배치 파일 &lt;code&gt;etop.bat&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3264cd9d9eb75df44ac7458f032202c1c187eb3e" translate="yes" xml:space="preserve">
          <source>Under Windows, the batch file &lt;code&gt;cdv.bat&lt;/code&gt; can be used.</source>
          <target state="translated">Windows에서는 배치 파일 &lt;code&gt;cdv.bat&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c9e5a121880663dee4769e1af65faa7b494736" translate="yes" xml:space="preserve">
          <source>Under a key, any number of named values can be stored. They have names, types, and data.</source>
          <target state="translated">키 아래에 이름이 지정된 값을 얼마든지 저장할 수 있습니다. 이름, 유형 및 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd8f3b0e81b0f054de52ff314e53658c55941c1a" translate="yes" xml:space="preserve">
          <source>Under certain circumstances incompatible changes might be introduced even in parts of the system that should be compatible between releases. Things that might trigger incompatible changes like this are:</source>
          <target state="translated">특정 환경에서는 릴리스간에 호환되어야하는 시스템의 일부에서도 호환되지 않는 변경이 발생할 수 있습니다. 다음과 같이 호환되지 않는 변경을 유발할 수있는 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="572aa08aba747d5d8b7a4a50d789147e2afaec76" translate="yes" xml:space="preserve">
          <source>Under the &lt;strong&gt;Warnings&lt;/strong&gt; pull-down menu, there are buttons that control which discrepancies are reported to the user in the &lt;strong&gt;Warnings&lt;/strong&gt; window. By clicking these buttons, you can enable/disable a whole class of warnings. Information about the classes of warnings is found on the &quot;Warnings&quot; item under the &lt;strong&gt;Help&lt;/strong&gt; menu (in the rightmost top corner).</source>
          <target state="translated">언더 &lt;strong&gt;경고&lt;/strong&gt; 풀다운 메뉴, 불일치가있는 사용자에게보고 제어하는 것을 버튼이 있습니다 &lt;strong&gt;경고&lt;/strong&gt; 창. 이 버튼을 클릭하면 전체 경고 클래스를 활성화 / 비활성화 할 수 있습니다. 경고 클래스에 대한 정보는 &lt;strong&gt;도움말&lt;/strong&gt; 메뉴 (맨 위 오른쪽 모서리) 의 &quot;경고&quot;항목에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f2c37bc89cf9d5792256518a7724565bd0f1e9" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocated_areas&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt; erlang:system_info(allocated_areas)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;= allocated_areas&lt;/strong&gt; 태그 아래에는 &lt;code&gt; erlang:system_info(allocated_areas)&lt;/code&gt; 를 사용하여 살아있는 노드에서 얻을 수있는 것과 유사한 정보가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="ae6ad23ca12e3d31111c9342b18cb40e19aa690d" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocated_areas&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;= allocated_areas&lt;/strong&gt; 태그 아래에는 &lt;code&gt;erlang:system_info(allocated_areas)&lt;/code&gt; 를 사용하여 리빙 노드에서 얻을 수있는 것과 유사한 정보가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="b011cdf662fa95678104f28ffe7a2bd2b09e3ee6" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocator:&amp;lt;A&amp;gt;&lt;/strong&gt; is shown various information about allocator &amp;lt;A&amp;gt;. The information is similar to what can be obtained on a living node with &lt;code&gt; erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt;. For more information, see also &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;= allocator : &amp;lt;A&amp;gt;&lt;/strong&gt; 태그 아래에는 할당 자 &amp;lt;A&amp;gt;에 대한 다양한 정보가 표시됩니다. 정보는 &lt;code&gt; erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt; 를 사용하여 살아있는 노드에서 얻을 수있는 것과 유사합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4c5641fd04e324ff84f71ed58f45687d78170d8" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=allocator:&amp;lt;A&amp;gt;&lt;/strong&gt; is shown various information about allocator &amp;lt;A&amp;gt;. The information is similar to what can be obtained on a living node with &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt;. For more information, see also &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;= allocator : &amp;lt;A&amp;gt;&lt;/strong&gt; 태그 아래 에 할당 자 &amp;lt;A&amp;gt;에 대한 다양한 정보가 표시됩니다. 이 정보는 &lt;code&gt;erlang:system_info({allocator, &amp;lt;A&amp;gt;})&lt;/code&gt; 를 사용하여 리빙 노드에서 얻을 수있는 것과 유사합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d79bffcbce82c370cc6389413481bbd120a99622" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=memory&lt;/strong&gt; is shown information similar to what can be obtained on a living node with &lt;code&gt; erlang:memory()&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;= memory&lt;/strong&gt; 태그 아래에는 &lt;code&gt; erlang:memory()&lt;/code&gt; 를 사용하여 살아있는 노드에서 얻을 수있는 것과 유사한 정보가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="0d37cd225e87fcc610bec30b5a05911619436d89" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=memory&lt;/strong&gt; is shown information similar to what can be obtainted on a living node with &lt;code&gt;erlang:memory()&lt;/code&gt;.</source>
          <target state="translated">태그 아래에 &lt;strong&gt;= memory&lt;/strong&gt; 는 &lt;code&gt;erlang:memory()&lt;/code&gt; 를 사용하여 리빙 노드에서 얻을 수있는 것과 유사한 정보를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="63ce4685b2bc584945411c035f09d36043b054a2" translate="yes" xml:space="preserve">
          <source>Under the tag &lt;strong&gt;=scheduler&lt;/strong&gt; is shown information about the current state and statistics of the schedulers in the runtime system. On operating systems that allow suspension of other threads, the data within this section reflects what the runtime system looks like when a crash occurs.</source>
          <target state="translated">&lt;strong&gt;= scheduler&lt;/strong&gt; 태그 아래에는 런타임 시스템에서 스케줄러의 현재 상태 및 통계에 대한 정보가 표시됩니다. 다른 스레드를 일시 중단 할 수있는 운영 체제에서이 섹션의 데이터는 충돌 발생시 런타임 시스템의 모습을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="c4dc6bd20baf250db6e40693e866b1962ff4e8bc" translate="yes" xml:space="preserve">
          <source>Under the tags &lt;strong&gt;=hash_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; and &lt;strong&gt;=index_table:&amp;lt;table_name&amp;gt;&lt;/strong&gt; is shown internal tables. These are mostly of interest for runtime system developers.</source>
          <target state="translated">태그 아래에 &lt;strong&gt;= hash_table : &amp;lt;table_name&amp;gt;&lt;/strong&gt; 및 &lt;strong&gt;= index_table : &amp;lt;table_name&amp;gt;&lt;/strong&gt; 이 내부 테이블로 표시됩니다. 이들은 주로 런타임 시스템 개발자에게 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd488528eeec3369801c6ace7a039c15038c870d" translate="yes" xml:space="preserve">
          <source>Undo Operation</source>
          <target state="translated">실행 취소 작업</target>
        </trans-unit>
        <trans-unit id="2cc501eac2fcb3163225e3af20fdf997e537c7a6" translate="yes" xml:space="preserve">
          <source>Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before.</source>
          <target state="translated">문서화되지 않은 (구형) 알고리즘은 더 이상 사용되지 않지만 여전히 구현되어있어 이전 코드와 동일한 의사 난수 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="87e34279dd28e6f111c12cefa204d1bbe4761338" translate="yes" xml:space="preserve">
          <source>Undocumented functions in this module are not to be used.</source>
          <target state="translated">이 모듈의 문서화되지 않은 기능은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="196d8f0f66ad490a457b6fb5d6806ec3993a5c10" translate="yes" xml:space="preserve">
          <source>Unfolds all occurrences of atoms in &lt;code&gt;ListIn&lt;/code&gt; to tuples &lt;code&gt;{Atom, true}&lt;/code&gt;.</source>
          <target state="translated">ListIn에서 모든 원자를 &lt;code&gt;ListIn&lt;/code&gt; 하여 &lt;code&gt;{Atom, true}&lt;/code&gt; 튜플 합니다 .</target>
        </trans-unit>
        <trans-unit id="d44efc32ffe75b3dcb95ec9933fa94f5e6f5bc0b" translate="yes" xml:space="preserve">
          <source>Unfortunately not only threads managed by the thread progress functionality may insert memory blocks. Other threads also needs to be taken care of. Other threads will not be as frequent users of this functionality as managed threads, so using a less efficient scheme for them is not that big of a problem. In order to handle unmanaged threads we use two reference counters. When an unmanaged thread enters this implementation it increments the reference counter currently used, and when it leaves this implementation it decrements the same reference counter. When the consumer thread calls &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; in order to determine when it is safe to move &lt;code&gt;head.unref_end&lt;/code&gt;, it also swaps reference counters for unmanaged threads. The previous current represents outstanding references from the time up to this point. The new current represents future reference following this point. When the consumer thread detects that we have both reached the desired thread progress and when the previous current reference counter reach zero it is safe to move the &lt;code&gt;head.unref_end&lt;/code&gt;.</source>
          <target state="translated">불행히도 스레드 진행 기능에 의해 관리되는 스레드 만이 메모리 블록을 삽입 할 수 있습니다. 다른 스레드도 처리해야합니다. 다른 스레드는 관리되는 스레드만큼이 기능을 자주 사용하지 않으므로 덜 효율적인 스키마를 사용하는 것은 큰 문제가 아닙니다. 관리되지 않는 스레드를 처리하기 위해 두 개의 참조 카운터를 사용합니다. 관리되지 않는 스레드가이 구현에 들어가면 현재 사용되는 참조 카운터가 증가하고이 구현을 종료하면 동일한 참조 카운터가 감소합니다. 소비자 스레드가 호출하면 &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; 결정하는 순서대로 이동하는 것이 안전 할 때 &lt;code&gt;head.unref_end&lt;/code&gt; 을, 또한 관리되지 않는 스레드에 대한 참조 카운터를 교환합니다. 이전 전류는 지금까지의 뛰어난 참고 자료를 나타냅니다. 새로운 전류는이 시점 이후의 미래 참조를 나타냅니다. 소비자 스레드가 원하는 스레드 진행률에 도달했음을 감지하고 이전 현재 참조 카운터가 0에 도달하면 &lt;code&gt;head.unref_end&lt;/code&gt; 를 이동하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="3ab34ddc2bf3b987c39e2558abfd1de510704f88" translate="yes" xml:space="preserve">
          <source>Unicode binary encoded as UTF16 little endian.</source>
          <target state="translated">UTF16 리틀 엔디안으로 인코딩 된 유니 코드 이진.</target>
        </trans-unit>
        <trans-unit id="9476616408be8ddee79977abc7989cebfe910910" translate="yes" xml:space="preserve">
          <source>Unicode filename translation is turned on with switch &lt;code&gt;+fnu&lt;/code&gt;. On Linux, a VM started without explicitly stating the filename translation mode defaults to &lt;code&gt;latin1&lt;/code&gt; as the native filename encoding. On Windows and MacOS X, the default behavior is that of Unicode filename translation. Therefore &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; by default returns &lt;code&gt;utf8&lt;/code&gt; on those systems (Windows does not use UTF-8 on the file system level, but this can safely be ignored by the Erlang programmer). The default behavior can, as stated earlier, be changed using option &lt;code&gt;+fnu&lt;/code&gt; or &lt;code&gt;+fnl&lt;/code&gt; to the VM, see the &lt;code&gt;erl&lt;/code&gt; program. If the VM is started in Unicode filename translation mode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns atom &lt;code&gt;utf8&lt;/code&gt;. Switch &lt;code&gt;+fnu&lt;/code&gt; can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported.</source>
          <target state="translated">switch &lt;code&gt;+fnu&lt;/code&gt; 로 유니 코드 파일 이름 변환이 설정됩니다 . Linux에서 파일 이름 변환 모드를 명시 적으로 지정하지 않고 시작한 VM 은 기본 파일 이름 인코딩 으로 &lt;code&gt;latin1&lt;/code&gt; 이 기본값 입니다. Windows 및 MacOS X에서 기본 동작은 유니 코드 파일 이름 변환입니다. 따라서 기본적으로 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 은 해당 시스템에서 &lt;code&gt;utf8&lt;/code&gt; 을 리턴 합니다 (Windows는 파일 시스템 레벨에서 UTF-8을 사용하지 않지만 Erlang 프로그래머는 무시해도됩니다). 앞에서 언급했듯이 기본 동작은 &lt;code&gt;+fnu&lt;/code&gt; 또는 &lt;code&gt;+fnl&lt;/code&gt; 옵션을 사용 하여 VM 으로 변경할 수 있습니다 ( &lt;code&gt;erl&lt;/code&gt; 프로그램 참조) . VM이 유니 코드 파일 이름 변환 모드에서 시작된 경우 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 은 atom &lt;code&gt;utf8&lt;/code&gt; 을 반환합니다 . Switch &lt;code&gt;+fnu&lt;/code&gt; 다음에 &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 또는 &lt;code&gt;e&lt;/code&gt; 가 올 바르면 인코딩 된 파일 이름이 잘못보고되는 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae13754db32b01d8c677dc9a973140e8500d0a8" translate="yes" xml:space="preserve">
          <source>Unicode filename translation is turned on with switch &lt;code&gt;+fnu&lt;/code&gt;. On Linux, a VM started without explicitly stating the filename translation mode defaults to &lt;code&gt;latin1&lt;/code&gt; as the native filename encoding. On Windows, MacOS X and Android, the default behavior is that of Unicode filename translation. Therefore &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; by default returns &lt;code&gt;utf8&lt;/code&gt; on those systems (Windows does not use UTF-8 on the file system level, but this can safely be ignored by the Erlang programmer). The default behavior can, as stated earlier, be changed using option &lt;code&gt;+fnu&lt;/code&gt; or &lt;code&gt;+fnl&lt;/code&gt; to the VM, see the &lt;code&gt;erl&lt;/code&gt; program. If the VM is started in Unicode filename translation mode, &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns atom &lt;code&gt;utf8&lt;/code&gt;. Switch &lt;code&gt;+fnu&lt;/code&gt; can be followed by &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, or &lt;code&gt;e&lt;/code&gt; to control how wrongly encoded filenames are to be reported.</source>
          <target state="translated">유니 코드 파일 이름 변환은 &lt;code&gt;+fnu&lt;/code&gt; 스위치로 켜집니다 . Linux에서 파일 이름 변환 모드를 명시 적으로 지정하지 않고 시작된 VM 은 기본 파일 이름 인코딩 으로 &lt;code&gt;latin1&lt;/code&gt; 로 기본 설정됩니다. Windows, MacOS X 및 Android에서 기본 동작은 유니 코드 파일 이름 변환입니다. 따라서 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 은 기본적 으로 해당 시스템에서 &lt;code&gt;utf8&lt;/code&gt; 을 반환 합니다 (Windows는 파일 시스템 수준에서 UTF-8을 사용하지 않지만 Erlang 프로그래머가 무시할 수 있음). 앞에서 언급했듯이 기본 동작은 VM에 대해 &lt;code&gt;+fnu&lt;/code&gt; 또는 &lt;code&gt;+fnl&lt;/code&gt; 옵션을 사용하여 변경할 수 있습니다 . &lt;code&gt;erl&lt;/code&gt; 프로그램을 참조하십시오 . VM이 유니 코드 파일 이름 변환 모드로 시작되면 &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; 은 atom &lt;code&gt;utf8&lt;/code&gt; 을 반환합니다 . 스위치 &lt;code&gt;+fnu&lt;/code&gt; 뒤에 &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 또는 &lt;code&gt;e&lt;/code&gt; 를 사용하여 잘못 인코딩 된 파일 이름이보고되는 방식을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="988784de449d7b8cbc0704eff09bcd0c69371d5a" translate="yes" xml:space="preserve">
          <source>Unicode is a standard defining code points (numbers) for all known, living or dead, scripts. In principle, every symbol used in any language has a Unicode code point. Unicode code points are defined and published by the Unicode Consortium, which is a non-profit organization.</source>
          <target state="translated">유니 코드는 모든 알려진 스크립트, 살아있는 스크립트 또는 죽은 스크립트에 대한 표준 정의 코드 포인트 (숫자)입니다. 원칙적으로 모든 언어에서 사용되는 모든 기호에는 유니 코드 코드 포인트가 있습니다. 유니 코드 코드 포인트는 비영리 조직인 유니 코드 컨소시엄에서 정의하고 게시합니다.</target>
        </trans-unit>
        <trans-unit id="753a9fc18dc38abc9e40310e1511762a587d6d68" translate="yes" xml:space="preserve">
          <source>Unicode metadata stored in PAX headers is preserved</source>
          <target state="translated">PAX 헤더에 저장된 유니 코드 메타 데이터가 유지됩니다</target>
        </trans-unit>
        <trans-unit id="717d423333854e072ef433389e96fff5bd03e76d" translate="yes" xml:space="preserve">
          <source>Unicode support is basically UTF-8 based. To use Unicode characters, you either call &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; with option &lt;code&gt;unicode&lt;/code&gt;, or the pattern must start with one of these special sequences:</source>
          <target state="translated">유니 코드 지원은 기본적으로 UTF-8 기반입니다. 유니 코드 문자를 사용하려면 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 옵션을 &lt;code&gt;unicode&lt;/code&gt; 옵션으로 호출 하거나 패턴이 다음 특수 시퀀스 중 하나로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="9619f5cd0ede72c7dc62df2d3b5ff34d2c75b610" translate="yes" xml:space="preserve">
          <source>Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced.</source>
          <target state="translated">균일 한 플로트는 균일하지 않은 밀도를 가졌기 때문에 작은 값, 즉 0.5보다 작은 값은 생성 된 값이 0.0에 가까워 질수록 간격이 줄어든다. 새로운 알고리즘은 N * 2.0 ^ (-53) 형식으로 균일하게 분포 된 플로트를 생성하므로 간격이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4488ef1f56a2d01fb6e741f79e8378c71279a1d3" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator's precision the probability to produce a low number could be twice the probability for a high.</source>
          <target state="translated">균일 한 정수 범위는 확률 분포에서 작은 범위에서는 눈에 띄지 않지만 발생기의 정밀도보다 작은 넓은 범위에서는 비대칭으로 낮은 수를 생성 할 확률은 높은 확률의 두 배가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adabbdf2f0cec9c6d0d246d5a204f96b7e74b355" translate="yes" xml:space="preserve">
          <source>Uniform integer ranges larger than or equal to the generator's precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce.</source>
          <target state="translated">생성기의 정밀도보다 크거나 같은 균일 한 정수 범위는 요청 된 범위보다 작은 52 비트로 만 계산 된 부동 소수점 폴백을 사용하므로 요청 된 범위의 모든 숫자가 생성 할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="36e839dc7592fa37041cd55253f794215f4f6c06" translate="yes" xml:space="preserve">
          <source>Union of &lt;code&gt;rsa_digest_type()&lt;/code&gt;, &lt;code&gt;dss_digest_type()&lt;/code&gt;, and &lt;code&gt;ecdsa_digest_type()&lt;/code&gt;.</source>
          <target state="translated">연합 &lt;code&gt;rsa_digest_type()&lt;/code&gt; , &lt;code&gt;dss_digest_type()&lt;/code&gt; , 및 &lt;code&gt;ecdsa_digest_type()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a878275b775589505d998070ad22ad6d0081609" translate="yes" xml:space="preserve">
          <source>Unique Integers on a Runtime System Instance</source>
          <target state="translated">런타임 시스템 인스턴스의 고유 정수</target>
        </trans-unit>
        <trans-unit id="a2cc5144e25dba2fec68e539fbd788a730b7301a" translate="yes" xml:space="preserve">
          <source>Unique References on a Runtime System Instance</source>
          <target state="translated">런타임 시스템 인스턴스의 고유 참조</target>
        </trans-unit>
        <trans-unit id="1d658374db6cb2482782dbc55d76ade6be07a287" translate="yes" xml:space="preserve">
          <source>Unique Values</source>
          <target state="translated">고유 한 가치</target>
        </trans-unit>
        <trans-unit id="a306f316fd3f985303c362b8053185a26f2e0d45" translate="yes" xml:space="preserve">
          <source>Unique identifier for the application in the scope of the service. Defaults to the value of the &lt;code&gt;dictionary&lt;/code&gt; option.</source>
          <target state="translated">서비스 범위 내에서 응용 프로그램의 고유 식별자입니다. &lt;code&gt;dictionary&lt;/code&gt; 옵션 값이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="5724b00a081ae3e8a4cc6f50314a3e776bc6f0d2" translate="yes" xml:space="preserve">
          <source>Unit Testing is testing of individual program &quot;units&quot; in relative isolation. There is no particular size requirement: a unit can be a function, a module, a process, or even a whole application, but the most typical testing units are individual functions or modules. In order to test a unit, you specify a set of individual tests, set up the smallest necessary environment for being able to run those tests (often, you don't need to do any setup at all), you run the tests and collect the results, and finally you do any necessary cleanup so that the test can be run again later. A Unit Testing Framework tries to help you in each stage of this process, so that it is easy to write tests, easy to run them, and easy to see which tests failed (so you can fix the bugs).</source>
          <target state="translated">단위 테스트는 개별 프로그램 &quot;단위&quot;를 상대적으로 격리하여 테스트하는 것입니다. 특정 크기 요구 사항은 없습니다. 단위는 기능, 모듈, 프로세스 또는 전체 응용 프로그램 일 수 있지만 가장 일반적인 테스트 단위는 개별 기능 또는 모듈입니다. 단위를 테스트하려면 개별 테스트 세트를 지정하고 해당 테스트를 실행할 수있는 가장 작은 환경을 설정하고 (종종 전혀 설정을 수행 할 필요가 없음) 테스트를 실행하고 수집합니다. 결과는 마지막으로 테스트를 나중에 다시 실행할 수 있도록 필요한 정리를 수행합니다. 단위 테스팅 프레임 워크는이 프로세스의 각 단계에서 도움을주기 위해 테스트를 작성하고, 실행하기 쉽고, 실패한 테스트를 쉽게 확인할 수 있도록합니다 (버그를 수정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="9caddb3cd5b7265345df4fab350e48f214540b46" translate="yes" xml:space="preserve">
          <source>Universal Time. UT1 is based on the rotation of the earth and conceptually means solar time at 0&amp;deg; longitude.</source>
          <target state="translated">세계시. UT1은 지구의 회전을 기반으로하며 개념적으로 0 &amp;deg; 경도에서의 태양 시간을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="67fdab77a1c02655cb90e9076adda573749aee76" translate="yes" xml:space="preserve">
          <source>Universaltime</source>
          <target state="translated">Universaltime</target>
        </trans-unit>
        <trans-unit id="f0fd69818de3f9565ba68951c5c09c08312d1123" translate="yes" xml:space="preserve">
          <source>Unix 'tar' utility for reading and writing tar archives.</source>
          <target state="translated">tar 아카이브를 읽고 쓰는 유닉스 'tar'유틸리티.</target>
        </trans-unit>
        <trans-unit id="c497be34c3d12775e6c6e249a2bb96e5096e4688" translate="yes" xml:space="preserve">
          <source>Unix example: &lt;code&gt;/usr/local/bin&lt;/code&gt;</source>
          <target state="translated">유닉스 예제 : &lt;code&gt;/usr/local/bin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52db1f36f26e76a3a2c634008d80678e33f56bbd" translate="yes" xml:space="preserve">
          <source>Unknown Functions.</source>
          <target state="translated">알 수없는 기능.</target>
        </trans-unit>
        <trans-unit id="b20270332ab7fc1d7887105b864abda119f91200" translate="yes" xml:space="preserve">
          <source>Unknown Modules.</source>
          <target state="translated">알 수없는 모듈.</target>
        </trans-unit>
        <trans-unit id="c3ac576a2d7732a8c0c77a12f249926d64da2561" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is fixated using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a call to &lt;code&gt;next/2&lt;/code&gt; will fail if &lt;code&gt;Key1&lt;/code&gt; no longer exists in the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function always returns the next key after &lt;code&gt;Key1&lt;/code&gt; in term order, regardless whether &lt;code&gt;Key1&lt;/code&gt; ever existed in the table.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블이 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 고정 되지 않는 한, &lt;code&gt;Key1&lt;/code&gt; 이 테이블에 더 이상 존재하지 않으면 &lt;code&gt;next/2&lt;/code&gt; 에 대한 호출 이 실패 합니다. &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형의 경우 함수는 &lt;code&gt;Key1&lt;/code&gt; 이 테이블에 존재 하는지 여부에 관계없이 항상 &lt;code&gt;Key1&lt;/code&gt; 다음의 키 를 용어 순서로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="42c65364e9fb4489250a3ae7948a13788521c35e" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns a list containing object &lt;code&gt;I&lt;/code&gt; in Erlang term order.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블이 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 보호 되지 않으면 테이블을 동시에 업데이트하면 순회가 실패 할 수 있습니다. &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형의 경우 함수는 Erlang 용어 순서로 오브젝트 &lt;code&gt;I&lt;/code&gt; 를 포함하는 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="efdfb6336f1dc28fe44fc86849dcd9997db099f2" translate="yes" xml:space="preserve">
          <source>Unless a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; is protected using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, a traversal can fail if concurrent updates are made to the table. For table type &lt;code&gt;ordered_set&lt;/code&gt;, the function returns the next key in order, even if the object does no longer exist.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블이 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 보호 되지 않으면 테이블을 동시에 업데이트하면 순회가 실패 할 수 있습니다. &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형의 경우, 함수는 오브젝트가 더 이상 존재하지 않더라도 다음 키를 순서대로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="743984ff40a29e25f3a91777282531a480bea68e" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified by the options, all modules are assumed to be at least &quot;static&quot;, and all except the target module are assumed to be &quot;safe&quot;. See the &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;safe&lt;/code&gt; options for details.</source>
          <target state="translated">옵션으로 달리 지정하지 않는 한 모든 모듈은 &quot;정적&quot;인 것으로 가정하고 대상 모듈을 제외한 모든 모듈은 &quot;안전한&quot;것으로 간주됩니다. 자세한 내용은 &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;safe&lt;/code&gt; 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6fd12a82bf92d67e237725f9648f0226fb3bb44f" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type and encoding are the same as the input type and encoding. That is, binary input returns binary output, list input returns a list output but mixed input returns list output.</source>
          <target state="translated">달리 지정하지 않는 한 반환 값 유형 및 인코딩은 입력 유형 및 인코딩과 동일합니다. 즉, 이진 입력은 이진 출력을 반환하고 목록 입력은 목록 출력을 반환하지만 혼합 입력은 목록 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2452df07cb8ca79cfe0600811352c2e7e3686be8" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified the return value type is the same as the input type. That is, binary input returns binary output, list input returns a list output, and mixed input can return a mixed output.</source>
          <target state="translated">달리 지정하지 않는 한 반환 값 유형은 입력 유형과 동일합니다. 즉, 이진 입력은 이진 출력을 반환하고 목록 입력은 목록 출력을 반환하며 혼합 입력은 혼합 출력을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3df395f5cdf2fa36eee4743206fa60a6a1a66c2" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide.</source>
          <target state="translated">달리 지정하지 않으면 모든 제어 시퀀스에서 선행 공백이 무시됩니다. 입력 필드의 너비는 한 줄을 넘을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a1cc2b0ee63b4df93cb4cef8c16bee9110c56a5" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, the order of the registered filters will be the order in which they are registered.</source>
          <target state="translated">달리 지정하지 않는 한 등록 된 필터의 순서는 등록 된 순서입니다.</target>
        </trans-unit>
        <trans-unit id="336e16f5b15c1bb3924a2d4ee1f281da2f5d2f39" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions assume that position numbering starts at 1. That is, the first element of a list is at position 1.</source>
          <target state="translated">달리 명시되지 않는 한, 모든 기능은 위치 번호 매기기가 1에서 시작한다고 가정합니다. 즉, 목록의 첫 번째 요소는 위치 1에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5744f08804fbcbd546e4dfc2b0e6fcafee559f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_server&lt;/code&gt; process does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시되지 않는 한, 지정된 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 존재하지 않거나 잘못된 인수가 지정 되면이 모듈의 모든 기능이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="33f0b9bf676eb2bfd97e1ca14eb9192d3876198f" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified &lt;code&gt;gen_statem&lt;/code&gt; does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시되지 않는 한, 지정된 &lt;code&gt;gen_statem&lt;/code&gt; 이 존재하지 않거나 잘못된 인수가 지정 되면이 모듈의 모든 함수가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="2130ed65fd03b5efa6f9266bb204f3dc0f269a98" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시하지 않는 한, 지정된 이벤트 관리자가 없거나 잘못된 인수가 지정되면이 모듈의 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="94ecf2431ac506145df210d3f762df7ef9ac568e" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor bridge does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시되지 않는 한, 지정된 수퍼바이저 브리지가 없거나 잘못된 인수를 지정하면이 모듈의 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ce6e960d5712a50515c10d0e5588263e19e9ce6b" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified.</source>
          <target state="translated">달리 명시하지 않는 한 지정된 수퍼바이저가 없거나 잘못된 인수를 지정하면이 모듈의 모든 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5c7ee08644b98d18eca27766dd86d186eaca4f73" translate="yes" xml:space="preserve">
          <source>Unless specified by the user when the array is created, the default value is the atom &lt;code&gt;undefined&lt;/code&gt;. There is no difference between an unset entry and an entry that has been explicitly set to the same value as the default one (compare &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt;). If you need to differentiate between unset and set entries, ensure that the default value cannot be confused with the values of set entries.</source>
          <target state="translated">배열을 만들 때 사용자가 지정하지 않으면 기본값은 atom &lt;code&gt;undefined&lt;/code&gt; 입니다. 설정되지 않은 항목과 기본 항목과 동일한 값으로 명시 적으로 설정된 항목 ( &lt;code&gt;&lt;a href=&quot;#reset-2&quot;&gt;reset/2&lt;/a&gt;&lt;/code&gt; 비교)에는 차이가 없습니다 . 설정되지 않은 항목과 설정 한 항목을 구별해야하는 경우 기본값을 설정 한 항목의 값과 혼동 할 수 없도록하십시오.</target>
        </trans-unit>
        <trans-unit id="dd13caf6027b189cef2a36a20e0fd13e56485aad" translate="yes" xml:space="preserve">
          <source>Unless the file name is absolute, the file is first searched for relative to the current directory, and then using the normal search path (&lt;code&gt;code:get_path()&lt;/code&gt;). This means that the names of typical &quot;app&quot; files can be used directly, without a path, e.g., &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt;.</source>
          <target state="translated">파일 이름이 절대적인 경우가 아니면 먼저 현재 디렉토리를 기준으로 파일을 검색 한 다음 일반 검색 경로 ( &lt;code&gt;code:get_path()&lt;/code&gt; )를 사용합니다. 즉, &lt;code&gt;&quot;mnesia.app&quot;&lt;/code&gt; 와 같이 경로없이 일반적인 &quot;app&quot;파일의 이름을 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07a837b10265d2be2c9f800bf253594222b1cdf6" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, calls to &lt;code&gt;bchunk/2&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">테이블을 사용하여 보호하지 않는 한 &lt;code&gt;safe_fixtable/2&lt;/code&gt; 에 전화를 &lt;code&gt;bchunk/2&lt;/code&gt; 동시 업데이트가 테이블을 변경하면 예상대로 가능성이 일을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec243991d25d3f676894294544e13f5bc4cfeae2" translate="yes" xml:space="preserve">
          <source>Unless the table is protected using &lt;code&gt;safe_fixtable/2&lt;/code&gt;, subsequent calls to &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; do possibly not work as expected if concurrent updates are made to the table.</source>
          <target state="translated">&lt;code&gt;safe_fixtable/2&lt;/code&gt; 를 사용하여 테이블을 보호하지 않으면 테이블에 대한 동시 업데이트가 수행 되면 &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출이 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c55317241e5b2c59b25e3b0df5f88453b5f333" translate="yes" xml:space="preserve">
          <source>Unless the value is &lt;code&gt;none&lt;/code&gt;, the given function is called for each node whose list of annotations is not empty; see below for details. The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;none&lt;/code&gt; 이 아닌 한 주석 목록이 비어 있지 않은 각 노드에 대해 지정된 함수가 호출됩니다. 자세한 내용은 아래를 참조하십시오. 기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cdff867eb339963be03bd21021856778c904302c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt;, Ifname is encoded a binary. In the unlikely case that a system is using non-7-bit-ASCII characters in network device names, special care has to be taken when encoding this argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#getifaddrs-0&quot;&gt;getifaddrs/0&lt;/a&gt;&lt;/code&gt; 과 달리 Ifname은 이진으로 인코딩됩니다. 시스템이 네트워크 장치 이름에 7 비트가 아닌 ASCII 문자를 사용하는 경우에는이 인수를 인코딩 할 때 특별한주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ae5c0bd0a60e997d1705e91f30f45cde14782afc" translate="yes" xml:space="preserve">
          <source>Unlike data tables, information in schema tables can only be accessed and modified by using the schema-related functions described in this section.</source>
          <target state="translated">데이터 테이블과 달리 스키마 테이블의 정보는이 섹션에서 설명하는 스키마 관련 기능을 사용해야 만 액세스하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="315fbdc2014934db1db457f44c68e1cf848dbeb6" translate="yes" xml:space="preserve">
          <source>Unlike in &quot;plain Erlang&quot;, &lt;code&gt;proc_lib&lt;/code&gt; processes will not generate &lt;strong&gt;error reports&lt;/strong&gt;, which are written to the terminal by the emulator. All exceptions are converted to &lt;strong&gt;exits&lt;/strong&gt; which are ignored by the default &lt;code&gt;logger&lt;/code&gt; handler.</source>
          <target state="translated">&quot;plain Erlang&quot;과 달리 &lt;code&gt;proc_lib&lt;/code&gt; 프로세스는 에뮬레이터에 의해 터미널에 기록되는 &lt;strong&gt;오류 보고서를&lt;/strong&gt; 생성하지 않습니다 . 모든 예외는 기본 &lt;code&gt;logger&lt;/code&gt; 핸들러 에서 무시되는 &lt;strong&gt;엑시트&lt;/strong&gt; 로 변환 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8e53ff65d2dc51b350969a552119bea613d0b243" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send&lt;/a&gt;&lt;/code&gt; function, this one sends &lt;strong&gt;one message&lt;/strong&gt;. This means that if, for whatever reason, its not possible to send the message in one go, the function will instead return with the &lt;strong&gt;remaining&lt;/strong&gt; data (&lt;code&gt;{ok, Remaining}&lt;/code&gt;). Thereby leaving it up to the caller to decide what to do (retry with the remaining data of give up).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send&lt;/a&gt;&lt;/code&gt; 기능 과 달리 이것은 &lt;strong&gt;하나의 메시지를&lt;/strong&gt; 보냅니다 . 즉, 어떤 이유로 든 한 번에 메시지를 보낼 수없는 경우 함수가 &lt;strong&gt;나머지&lt;/strong&gt; 데이터 ( &lt;code&gt;{ok, Remaining}&lt;/code&gt; )를 대신 반환합니다 . 따라서 무엇을할지 결정하기 위해 발신자에게 맡기십시오 (포기의 나머지 데이터로 재 시도하십시오).</target>
        </trans-unit>
        <trans-unit id="4f0b46a073145149fc17e2f042255d68220cd4a4" translate="yes" xml:space="preserve">
          <source>Unload &lt;code&gt;Mibs&lt;/code&gt; from an agent. If it cannot unload all MIBs (the default value of the &lt;code&gt;Force&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;), it will indicate where unloading was aborted.</source>
          <target state="translated">에이전트에서 &lt;code&gt;Mibs&lt;/code&gt; 를 언로드 하십시오 . 모든 MIB를 언로드 할 수없는 경우 ( &lt;code&gt;Force&lt;/code&gt; 인수 의 기본값 은 &lt;code&gt;false&lt;/code&gt; ) 언로드가 중단 된 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01b2dca21a4f55d7d0fa16561ba72c0a5a938d9c" translate="yes" xml:space="preserve">
          <source>Unload a &lt;code&gt;Mib&lt;/code&gt; from the manager. The &lt;code&gt;MibName&lt;/code&gt; is the name of the Mib, including the path to where the compiled mib is found. For example,</source>
          <target state="translated">관리자에서 &lt;code&gt;Mib&lt;/code&gt; 를 언로드하십시오 . &lt;code&gt;MibName&lt;/code&gt; 는 컴파일 된 MIB가 발견 된 곳의 경로를 포함하여 MIB의 이름입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="318d9f4d5f03a67d10200c73fcad432663d2f29b" translate="yes" xml:space="preserve">
          <source>Unload a single &lt;code&gt;Mib&lt;/code&gt; from an agent.</source>
          <target state="translated">에이전트에서 단일 &lt;code&gt;Mib&lt;/code&gt; 를 언로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="769b903ce1d90a72efda3ccafb33dcd1f3d777a4" translate="yes" xml:space="preserve">
          <source>Unload the mib specified by the &lt;code&gt;Filename&lt;/code&gt; argument from the mib-server.</source>
          <target state="translated">mib-server에서 &lt;code&gt;Filename&lt;/code&gt; 인수로 지정된 mib를 언로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddd4c00f912e6ef2189a832da23d9650d2872c8c" translate="yes" xml:space="preserve">
          <source>Unloading can be described as the process of telling the emulator that this particular part of the code in this particular process (that is, this &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;) no longer needs the driver. That can, if there are no other users, trigger unloading of the driver, in which case the driver name disappears from the system and (if possible) the memory occupied by the driver executable code is reclaimed.</source>
          <target state="translated">언로드는이 특정 프로세스에서 코드의이 특정 부분 (즉,이 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; )이 더 이상 드라이버를 필요로하지 않는다고 에뮬레이터에 알리는 프로세스로 설명 할 수 있습니다 . 즉, 다른 사용자가 없으면 드라이버 언로드를 트리거 할 수 있습니다.이 경우 드라이버 이름이 시스템에서 사라지고 드라이버 실행 가능 코드가 차지하는 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="f01cfbd5c8a37883cb11fbfce549beccf62c0bdc" translate="yes" xml:space="preserve">
          <source>Unloads an engine loaded with the &lt;code&gt;ensure_engine_loaded&lt;/code&gt; function. It both removes the label from the OpenSSL internal engine list and unloads the engine. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">&lt;code&gt;ensure_engine_loaded&lt;/code&gt; 함수로 로드 된 엔진을 언로드합니다 . OpenSSL 내부 엔진 목록에서 레이블을 제거하고 엔진을 언로드합니다. 엔진을 언로드 할 수없는 경우 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="39ecc66fc726ebe5dc1f5680017eb9863277fd3d" translate="yes" xml:space="preserve">
          <source>Unloads an engine loaded with the &lt;code&gt;ensure_engine_loaded&lt;/code&gt; function. It both removes the label from the OpenSSL internal engine list and unloads the engine. This function is the same as calling &lt;code&gt;ensure_engine_unloaded/2&lt;/code&gt; with &lt;code&gt;EngineMethods&lt;/code&gt; set to a list of all the possible methods. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">&lt;code&gt;ensure_engine_loaded&lt;/code&gt; 함수로 로드 된 엔진을 언로드합니다 . OpenSSL 내부 엔진 목록에서 레이블을 제거하고 엔진을 언로드합니다. 이 함수는 가능한 모든 메소드 목록에 &lt;code&gt;EngineMethods&lt;/code&gt; 를 설정하여 &lt;code&gt;ensure_engine_unloaded/2&lt;/code&gt; 를 호출하는 것과 동일 합니다. 엔진을 언로드 할 수없는 경우 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7779518675ffce53110af3008d7744e065e1a5f3" translate="yes" xml:space="preserve">
          <source>Unloads the MIBs from agent &lt;code&gt;snmp_master_agent&lt;/code&gt;.</source>
          <target state="translated">에이전트 &lt;code&gt;snmp_master_agent&lt;/code&gt; 에서 MIB를 언로드합니다 .</target>
        </trans-unit>
        <trans-unit id="f4a3d6a062d2d5ee9eda88a5ecd1085fce084994" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-MIB.</source>
          <target state="translated">OTP-MIB를 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="c48f8e606621c6fa11b525d4c336815899ff648e" translate="yes" xml:space="preserve">
          <source>Unloads the OTP-OS-MON-MIB.</source>
          <target state="translated">OTP-OS-MON-MIB를 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="66f8e5114123bed6be608b90ce2bc660face1031" translate="yes" xml:space="preserve">
          <source>Unloads the OpenSSL engine given by &lt;code&gt;Engine&lt;/code&gt;. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">&lt;code&gt;Engine&lt;/code&gt; 에서 제공하는 OpenSSL 엔진을 언로드합니다 . 엔진을 언로드 할 수없는 경우 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="38ed8242b3b1b71902fb9d376310f5c95786abfe" translate="yes" xml:space="preserve">
          <source>Unloads the OpenSSL engine given by &lt;code&gt;EngineId&lt;/code&gt;. An error tuple is returned if the engine can't be unloaded.</source>
          <target state="translated">&lt;code&gt;EngineId&lt;/code&gt; 가 제공 한 OpenSSL 엔진을 언로드합니다 . 엔진을 언로드 할 수 없으면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5cff9e0ced01393a829b38eaa7e0451df21ea9d5" translate="yes" xml:space="preserve">
          <source>Unloads the application specification for &lt;code&gt;Application&lt;/code&gt; from the application controller. It also unloads the application specifications for any included applications. Notice that the function does not purge the Erlang object code.</source>
          <target state="translated">언로드에 대한 응용 프로그램 사양 &lt;code&gt;Application&lt;/code&gt; 응용 프로그램 컨트롤러에서. 또한 포함 된 모든 응용 프로그램의 응용 프로그램 사양을 언로드합니다. 이 함수는 Erlang 오브젝트 코드를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="351a6f889a5ded537e77bca6799737838e6f4f76" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, all remaining open ports using the driver are killed with reason &lt;code&gt;driver_unloaded&lt;/code&gt; and the driver eventually gets unloaded.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이라는 드라이버를 언로드하거나 최소한 역 참조합니다 . 호출자가 드라이버 의 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 인 경우 &lt;code&gt;driver_unloaded&lt;/code&gt; 이유로 드라이버를 사용하여 남아있는 모든 열린 포트가 종료 되고 결국 드라이버가 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="2061febf2aa265ba0d12f05d42293814e13d57b8" translate="yes" xml:space="preserve">
          <source>Unloads, or at least dereferences the driver named &lt;code&gt;Name&lt;/code&gt;. If the caller is the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver, and no more open ports use the driver, the driver gets unloaded. Otherwise, unloading is delayed until all ports are closed and no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; remain.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 이라는 드라이버를 언로드하거나 최소한 역 참조합니다 . 호출자가 드라이버 의 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 이고 열려있는 포트가 더 이상 드라이버를 사용하지 않으면 드라이버가 언로드됩니다. 그렇지 않으면 모든 포트가 닫히고 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 남아 있지 않을 때까지 언로드가 지연 됩니다.</target>
        </trans-unit>
        <trans-unit id="38ad66e7caef87bb85f8df32ab5caabf7bf35995" translate="yes" xml:space="preserve">
          <source>Unlocks a mutex. The mutex currently must be locked by the calling thread.</source>
          <target state="translated">뮤텍스를 잠금 해제합니다. 뮤텍스는 현재 호출 스레드에 의해 잠겨 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b9b1fba9416c1278f7484dce6e469b9ce20199f" translate="yes" xml:space="preserve">
          <source>Unlocks the configuration target.</source>
          <target state="translated">구성 대상을 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="19786a83cc46632e0d13d564e393de3e1de085fe" translate="yes" xml:space="preserve">
          <source>Unlocks the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">인수 ( &lt;code&gt;pdl&lt;/code&gt; ) 로 전달 된 포트 데이터 잠금을 잠금 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="c1621249e0ef6ecc8c1156b8b07b094cf1d8ea3a" translate="yes" xml:space="preserve">
          <source>Unmanaged threads can delay thread progress being made:</source>
          <target state="translated">관리되지 않는 스레드는 스레드 진행을 지연시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e529736ebba8b22ec528fcbede64fa669b39cc8" translate="yes" xml:space="preserve">
          <source>Unordered sending is configurable in &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt;. There is no special handling of DPR/DPA: since a user that cares about pending answers should wait for them before initiating DPR.</source>
          <target state="translated">정렬되지 않은 전송은 &lt;code&gt;&lt;a href=&quot;diameter_sctp&quot;&gt;diameter_sctp(3)&lt;/a&gt;&lt;/code&gt; 에서 구성 할 수 있습니다 . 보류중인 응답에 관심이있는 사용자는 DPR을 시작하기 전에 기다려야하므로 DPR / DPA에 대한 특별한 처리는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cdfeac47c5892b6d5954da0f63cd683192cebcee" translate="yes" xml:space="preserve">
          <source>Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal to any ordered set.</source>
          <target state="translated">정렬되지 않은 세트와 정렬 된 세트는이 모듈에서 다시 직교합니다. 정렬되지 않은 세트는 정렬 된 세트와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0315bcb1361b2c68fa29fded47a0e3b15d0b5028" translate="yes" xml:space="preserve">
          <source>Unpacking and Installation of Release Packages</source>
          <target state="translated">릴리스 패키지 포장 풀기 및 설치</target>
        </trans-unit>
        <trans-unit id="3b45b03b4626e1a53bac859dec0524861ec0a57e" translate="yes" xml:space="preserve">
          <source>Unpacks a release package &lt;code&gt;Name.tar.gz&lt;/code&gt; located in the &lt;code&gt;releases&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;releases&lt;/code&gt; 디렉토리 에 있는 릴리스 패키지 &lt;code&gt;Name.tar.gz&lt;/code&gt; 를 압축 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="1a99a056cf6ecaf575d784978bf9746e5f0db64d" translate="yes" xml:space="preserve">
          <source>Unrecognized options are ignored.</source>
          <target state="translated">인식 할 수없는 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c3e8f759a055d6a9097dc478f2320ca3772d6837" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored but are returned unmodified by &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; and can be referred to in predicate functions passed to &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인식 할 수없는 옵션은 자동으로 무시되지만 &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; 에 의해 수정되지 않은 상태로 리턴 되며 &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; 에 전달 된 술어 함수에서 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcf136da00ab173645906b6446844bfeeb401e42" translate="yes" xml:space="preserve">
          <source>Unrecognized options are silently ignored.</source>
          <target state="translated">인식 할 수없는 옵션은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54d58ee32687d0ed22df44187d707090c9f1ee63" translate="yes" xml:space="preserve">
          <source>Unregister a Node from EPMD</source>
          <target state="translated">EPMD에서 노드 등록 취소</target>
        </trans-unit>
        <trans-unit id="db0b20da3e0471bc484aaa9c62ebfd991d58e416" translate="yes" xml:space="preserve">
          <source>Unregister a notification filter.</source>
          <target state="translated">알림 필터를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="4e280e10a8485894674391e4d6645db6545aff52" translate="yes" xml:space="preserve">
          <source>Unregister a sub-agent. If the second argument is a pid, then that sub-agent will be unregistered from all trees in &lt;code&gt;Agent&lt;/code&gt;.</source>
          <target state="translated">하위 에이전트를 등록 취소하십시오. 두 번째 인수가 pid 인 경우 해당 하위 에이전트는 &lt;code&gt;Agent&lt;/code&gt; 의 모든 트리에서 등록 취소됩니다 .</target>
        </trans-unit>
        <trans-unit id="f03ca80c8e4fbe50cea94aadfa5356b1cefa6ea2" translate="yes" xml:space="preserve">
          <source>Unregister the agent.</source>
          <target state="translated">에이전트를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f3dba02392fc14b01a49c5237fb9ba133abd12" translate="yes" xml:space="preserve">
          <source>Unregister the subagent, handling part of the mib-tree, as specified by the &lt;code&gt;oid()&lt;/code&gt; or &lt;code&gt;pid()&lt;/code&gt; (&lt;code&gt;PidOrOid&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;oid()&lt;/code&gt; 또는 &lt;code&gt;pid()&lt;/code&gt; ( &lt;code&gt;PidOrOid&lt;/code&gt; )에 지정된대로 mib-tree의 일부를 처리하는 서브 에이전트를 등록 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f8277a7a1c1b3585ee2c7d6442d480190db4efc" translate="yes" xml:space="preserve">
          <source>Unregister the user.</source>
          <target state="translated">사용자를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a27c51fcd7b00626a6adb2154cd8c213ef4ec1" translate="yes" xml:space="preserve">
          <source>Unregister this USM user.</source>
          <target state="translated">이 USM 사용자를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d7b4bee0a41ee99a7b5f42eb631d46c2797262" translate="yes" xml:space="preserve">
          <source>Unregisters a name from &lt;code&gt;global&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 에서 이름을 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="778ebac023e85b1f0510378d21c9e5c1fcf345ea" translate="yes" xml:space="preserve">
          <source>Unregisters all USM users.</source>
          <target state="translated">모든 USM 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="3c58e843a4c38141952ae3478058bdba2218974e" translate="yes" xml:space="preserve">
          <source>Unregisters all managed agents.</source>
          <target state="translated">모든 관리 에이전트를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="246367dd21663f20ce31444da8332f55bea35d97" translate="yes" xml:space="preserve">
          <source>Unregisters all users.</source>
          <target state="translated">모든 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="32c40ce96fa1e83b3bd9616363397a86b832aa70" translate="yes" xml:space="preserve">
          <source>Unregisters the crypto key fun and terminates the process holding it, started by &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; 로 시작하여 암호화 키 기능을 등록 취소하고이를 보유하는 프로세스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="7c5ba8d70542c76fd25b8d56f14442cbc2255390" translate="yes" xml:space="preserve">
          <source>Unregisters the specified USM users.</source>
          <target state="translated">지정된 USM 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="01d1e628f578a9203fd5dd6ce46d237fc06cee37" translate="yes" xml:space="preserve">
          <source>Unregisters the specified managed agents.</source>
          <target state="translated">지정된 관리 에이전트를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="b35f5d367e4318dedf6e9eecba89fb487eb5ab44" translate="yes" xml:space="preserve">
          <source>Unregisters the specified users.</source>
          <target state="translated">지정된 사용자를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="39827e01c383c5bfbd3766c32b34efde1bf35451" translate="yes" xml:space="preserve">
          <source>Unresolved Calls. Empty in &lt;code&gt;modules&lt;/code&gt; mode.</source>
          <target state="translated">해결되지 않은 통화. &lt;code&gt;modules&lt;/code&gt; 모드 에서 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f30d44760477c48d3263ea185339929d64ed8c" translate="yes" xml:space="preserve">
          <source>Unresolved calls make module data incomplete, which implies that the results of analyses may be invalid.</source>
          <target state="translated">확인되지 않은 호출은 모듈 데이터를 불완전하게 만들어 분석 결과가 유효하지 않을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fb40d6160cba8c7f57aa914e409db0d952645ffe" translate="yes" xml:space="preserve">
          <source>Unset the log level for all the modules of the specified application.</source>
          <target state="translated">지정된 응용 프로그램의 모든 모듈에 대한 로그 수준을 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="6d813c57ac643b33b15704ddfaac2f69f436d7ab" translate="yes" xml:space="preserve">
          <source>Unsigned 8-bit integer.</source>
          <target state="translated">부호없는 8 비트 정수</target>
        </trans-unit>
        <trans-unit id="c196c4cb59b173e8333c1a8a5df703d2addbca5b" translate="yes" xml:space="preserve">
          <source>Unspecified connection shutdown.</source>
          <target state="translated">지정되지 않은 연결 종료</target>
        </trans-unit>
        <trans-unit id="23ba21b928bd868bd499fdc4e16f1fbae6b293bf" translate="yes" xml:space="preserve">
          <source>Unsticks a directory that is marked as sticky.</source>
          <target state="translated">고정으로 표시된 디렉토리를 고정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2277446510c2f9009fdeac95bbe80a1168ba956b" translate="yes" xml:space="preserve">
          <source>Unsubscribe to event messages from a service.</source>
          <target state="translated">서비스의 이벤트 메시지를 수신 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf5dcc3da0cf64b87e972ea01a22a51c15d8495" translate="yes" xml:space="preserve">
          <source>Unused Functions (*). All local and exported functions of analyzed modules that have not been used.</source>
          <target state="translated">사용하지 않은 기능 (*). 사용되지 않은 분석 된 모듈의 모든 로컬 및 내 보낸 기능.</target>
        </trans-unit>
        <trans-unit id="ef54ae19c4ebc6695e02cbec5080af83b195b393" translate="yes" xml:space="preserve">
          <source>Unused Variables</source>
          <target state="translated">사용하지 않는 변수</target>
        </trans-unit>
        <trans-unit id="48532263f2300b60babe28fff5fbbc91ed7d708c" translate="yes" xml:space="preserve">
          <source>Unused functions and imports</source>
          <target state="translated">사용하지 않은 함수 및 가져 오기</target>
        </trans-unit>
        <trans-unit id="e9b3d935e2fe5c05c6efefdff41786dcbb306041" translate="yes" xml:space="preserve">
          <source>Unused variables</source>
          <target state="translated">사용하지 않은 변수</target>
        </trans-unit>
        <trans-unit id="b7745c954ca016fa895b408f407a03e565617f6b" translate="yes" xml:space="preserve">
          <source>Up to five log files at maximum 100 KB each with the content of the standard streams from and to the command. (Both the number of logs and sizes can be changed by environment variables, see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; below.)</source>
          <target state="translated">표준 스트림의 내용과 함께 최대 100KB의 로그 파일 최대 5 개 (로그 및 크기의 수는 환경 변수에 의해 변경 될 수 있습니다 . 아래의 &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9dd274c7d6098a1a4d8932d92e9e158a8e9dd4b8" translate="yes" xml:space="preserve">
          <source>Up to now, examples of a number of functions that can be used inside a transaction have been shown. The following list shows the &lt;strong&gt;simplest&lt;/strong&gt;&lt;code&gt;Mnesia&lt;/code&gt; functions that work with transactions. Notice that these functions must be embedded in a transaction. If no enclosing transaction (or other enclosing &lt;code&gt;Mnesia&lt;/code&gt; activity) exists, they all fail.</source>
          <target state="translated">지금까지 트랜잭션 내부에서 사용할 수있는 여러 함수의 예가 나와 있습니다. 다음 목록은 트랜잭션과 함께 작동 하는 &lt;strong&gt;가장 간단한 &lt;/strong&gt; &lt;code&gt;Mnesia&lt;/code&gt; 함수를 보여줍니다 . 이러한 기능은 트랜잭션에 포함되어야합니다. 엔 클로징 트랜잭션 (또는 기타 엔 클로징 &lt;code&gt;Mnesia&lt;/code&gt; 활동)이 없으면 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="01b4c751d26980e5035738b359c986debcfcf4b4" translate="yes" xml:space="preserve">
          <source>Up until ERTS version 8.*, the check process code operation checks for all types of references to the old code. That is, direct references (e.g. return addresses on the process stack), indirect references (&lt;code&gt;fun&lt;/code&gt;s in process context), and references to literals in the code.</source>
          <target state="translated">ERTS 버전 8. *까지 점검 프로세스 코드 조작은 이전 코드에 대한 모든 유형의 참조를 점검합니다. , 직접 참조 (프로세스 스택에 예를 들어, 반환 주소), 간접 참조 (즉 &lt;code&gt;fun&lt;/code&gt; 코드에서 리터럴에 대한 프로세스 컨텍스트에서 S), 및 참조.</target>
        </trans-unit>
        <trans-unit id="8debd6fa2cf5bff1fb2fae483fef9fdfafa670e1" translate="yes" xml:space="preserve">
          <source>Up until OTP 17 there used to exist an experimental &lt;code&gt;pg&lt;/code&gt; module in &lt;code&gt;stdlib&lt;/code&gt;. This &lt;code&gt;pg&lt;/code&gt; module is not the same module as that experimental &lt;code&gt;pg&lt;/code&gt; module, and only share the same module name.</source>
          <target state="translated">OTP 17까지는 &lt;code&gt;stdlib&lt;/code&gt; 에 실험적인 &lt;code&gt;pg&lt;/code&gt; 모듈 이 존재했습니다 . 이 &lt;code&gt;pg&lt;/code&gt; 모듈은 실험적인 &lt;code&gt;pg&lt;/code&gt; 모듈과 동일한 모듈이 아니며 동일한 모듈 이름 만 공유합니다.</target>
        </trans-unit>
        <trans-unit id="4c2624bab6b3cfd68919c56a6d5e5cfd349d334b" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. An exception &lt;code&gt;{badkey,Key}&lt;/code&gt; is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the map.</source>
          <target state="translated">새 값을 얻으려면 이전 값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 &lt;code&gt;Key&lt;/code&gt; 와 연관된 &lt;code&gt;Map1&lt;/code&gt; 의 값을 업데이트하십시오 . &lt;code&gt;Key&lt;/code&gt; 가 맵에 없으면 &lt;code&gt;{badkey,Key}&lt;/code&gt; 예외 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="1c9b1268f0c338627a3b15658c74da637dde057f" translate="yes" xml:space="preserve">
          <source>Update a value in a &lt;code&gt;Map1&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt; by calling &lt;code&gt;Fun&lt;/code&gt; on the old value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in &lt;code&gt;Map1&lt;/code&gt; then &lt;code&gt;Init&lt;/code&gt; will be associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">새 값을 얻으려면 이전 값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 &lt;code&gt;Key&lt;/code&gt; 와 연관된 &lt;code&gt;Map1&lt;/code&gt; 의 값을 업데이트하십시오 . 경우 &lt;code&gt;Key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;Map1&lt;/code&gt; 다음 &lt;code&gt;Init&lt;/code&gt; 연결됩니다 &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2fca097e563aa25bfd5fb033663686a751ded2" translate="yes" xml:space="preserve">
          <source>Update agent config. The function &lt;code&gt;update_agent_info/3&lt;/code&gt; should be used when several values needs to be updated atomically.</source>
          <target state="translated">에이전트 구성을 업데이트하십시오. 여러 값을 원자 적으로 업데이트해야하는 경우 &lt;code&gt;update_agent_info/3&lt;/code&gt; 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7afc903ad53b7f5b82a666a44760f2b71394b08f" translate="yes" xml:space="preserve">
          <source>Update all access structures in the staging area to include the newly prepared module.</source>
          <target state="translated">새로 준비된 모듈을 포함하도록 준비 영역의 모든 액세스 구조를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e65320d77653af5410845622a9ee939279e72f69" translate="yes" xml:space="preserve">
          <source>Update an MD5 &lt;code&gt;Context&lt;/code&gt; with &lt;code&gt;Data&lt;/code&gt; and returns a &lt;code&gt;NewContext&lt;/code&gt;.</source>
          <target state="translated">MD5 &lt;code&gt;Context&lt;/code&gt; 를 &lt;code&gt;Data&lt;/code&gt; 로 업데이트 하고 &lt;code&gt;NewContext&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2d392faf5b221ec067551948fb64c66dc210a1b9" translate="yes" xml:space="preserve">
          <source>Update configuration data for the Logger proxy. This function behaves as if it was implemented as follows:</source>
          <target state="translated">Logger 프록시에 대한 구성 데이터를 업데이트합니다. 이 함수는 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="15c23ed960405748d119e2cf48c12e3dfbd628b3" translate="yes" xml:space="preserve">
          <source>Update configuration data for the specified handler. This function behaves as if it was implemented as follows:</source>
          <target state="translated">지정된 핸들러의 구성 데이터를 업데이트하십시오. 이 함수는 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fe58a4200c84c77e18dad55e69d7d322faa4c745" translate="yes" xml:space="preserve">
          <source>Update information about a user</source>
          <target state="translated">사용자 정보 업데이트</target>
        </trans-unit>
        <trans-unit id="312c6091d8eac0e5b07d6cd16487ac2bd404f20a" translate="yes" xml:space="preserve">
          <source>Update information about an active connection</source>
          <target state="translated">활성 연결에 대한 정보 업데이트</target>
        </trans-unit>
        <trans-unit id="1fe0611d972ddd201356bf6556896ed52b2f48ec" translate="yes" xml:space="preserve">
          <source>Update primary configuration data for Logger. This function behaves as if it was implemented as follows:</source>
          <target state="translated">로거의 기본 구성 데이터를 업데이트하십시오. 이 함수는 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="764a554dd6a058f4ee8b2a49aff080d148edb108" translate="yes" xml:space="preserve">
          <source>Update the application version number in the &lt;code&gt;.app&lt;/code&gt; file and write an &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 파일 에서 애플리케이션 버전 번호를 업데이트하고 &lt;code&gt;.appup&lt;/code&gt; 파일을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="df2e0eab67dde01477b9adecadae6f860b5f68c2" translate="yes" xml:space="preserve">
          <source>Update the connection info protocol_version.</source>
          <target state="translated">연결 정보 protocol_version을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="1ae0552d56ac843dfab3a0e0e90394739c437be4" translate="yes" xml:space="preserve">
          <source>Update the formatter configuration for the specified handler.</source>
          <target state="translated">지정된 핸들러의 포맷터 구성을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="e12a74739554e4908ca08a51e98ff68b92ec211d" translate="yes" xml:space="preserve">
          <source>Update the receive handle of the control process (e.g. after having changed protocol version).</source>
          <target state="translated">제어 프로세스의 수신 핸들을 업데이트하십시오 (예 : 프로토콜 버전을 변경 한 후).</target>
        </trans-unit>
        <trans-unit id="4ff8cf55883e7040256c251d18a9776b47973fa6" translate="yes" xml:space="preserve">
          <source>Update the receive handle with the encoding-config (the &lt;code&gt;encoding_config&lt;/code&gt; field).</source>
          <target state="translated">encoding-config ( &lt;code&gt;encoding_config&lt;/code&gt; 필드)로 수신 핸들을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fc874196868b2850c4d27972aa555825f4c8abc" translate="yes" xml:space="preserve">
          <source>Update the staging part of all affected breakpoints. Disable breakpoints that are to be removed.</source>
          <target state="translated">영향을받는 모든 중단 점의 스테이징 부분을 업데이트하십시오. 제거 할 중단 점을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b4e75d0ad461333a3e5a1fa13055100c26a0e7bc" translate="yes" xml:space="preserve">
          <source>Update usm user config.</source>
          <target state="translated">usm 사용자 구성을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="5ff39bab1bf1708cca0909e3396800e9779cd838" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is present in the tree.</source>
          <target state="translated">&lt;code&gt;Tree1&lt;/code&gt; 의 &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; 를 업데이트 하고 새 트리를 반환합니다. 키가 트리에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ce52fdc3093dff8fef11813ce4ce3d448b0c6f2e" translate="yes" xml:space="preserve">
          <source>Updates a running Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the checksum.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 에 대해 실행중인 Adler-32 체크섬을 업데이트합니다 . 경우 &lt;code&gt;Data&lt;/code&gt; 빈 바이너리 또는 빈 iolist이며,이 기능은 검사에 필요한 초기 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39a616ffbea893cd0d7caf81f5c475e558b40da3" translate="yes" xml:space="preserve">
          <source>Updates a running CRC checksum for &lt;code&gt;Data&lt;/code&gt;. If &lt;code&gt;Data&lt;/code&gt; is the empty binary or the empty iolist, this function returns the required initial value for the CRC.</source>
          <target state="translated">에 대한 실행 CRC 체크섬 업데이트 &lt;code&gt;Data&lt;/code&gt; . 경우 &lt;code&gt;Data&lt;/code&gt; 빈 바이너리 또는 빈 iolist이며,이 기능은 CRC에 필요한 초기 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78c9911ea54430b2ec4c2464fea0fba3c01b13cb" translate="yes" xml:space="preserve">
          <source>Updates a time-out with a new &lt;code&gt;EventContent&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt; timeout_action() &lt;/a&gt;&lt;/code&gt; for how to start a time-out.</source>
          <target state="translated">새로운 &lt;code&gt;EventContent&lt;/code&gt; 로 시간 제한을 업데이트합니다 . 시간 제한을 시작하는 방법 은 &lt;code&gt;&lt;a href=&quot;#type-timeout_action&quot;&gt; timeout_action() &lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d39f7d480179f5db485862d26b6c6e7aed7b81" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. An exception is generated if &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary.</source>
          <target state="translated">값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 새 값을 가져 와서 사전의 값을 업데이트 합니다. &lt;code&gt;Key&lt;/code&gt; 가 사전에 없으면 예외가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab59d74f46080461c39369f0019171f2f23af955" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as follows:</source>
          <target state="translated">값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 새 값을 가져 와서 사전의 값을 업데이트 합니다. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Initial&lt;/code&gt; 처음 값으로 저장된다. 예를 들어, &lt;code&gt;append/3&lt;/code&gt; 는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6a761f1dc7fcd9496ff0fc00ba409b036ce20c" translate="yes" xml:space="preserve">
          <source>Updates a value in a dictionary by calling &lt;code&gt;Fun&lt;/code&gt; on the value to get a new value. If &lt;code&gt;Key&lt;/code&gt; is not present in the dictionary, &lt;code&gt;Initial&lt;/code&gt; is stored as the first value. For example, &lt;code&gt;append/3&lt;/code&gt; can be defined as:</source>
          <target state="translated">값에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 새 값을 가져 와서 사전의 값을 업데이트 합니다. 경우 &lt;code&gt;Key&lt;/code&gt; 사전에 존재하지 않는, &lt;code&gt;Initial&lt;/code&gt; 처음 값으로 저장된다. 예를 들어, &lt;code&gt;append/3&lt;/code&gt; 는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c90a4670b3f9486158db598e8de0114e5577be" translate="yes" xml:space="preserve">
          <source>Updates an accumulator by applying &lt;code&gt;Fun&lt;/code&gt; on each collection of annotations of the &lt;code&gt;erl_parse&lt;/code&gt; tree &lt;code&gt;Abstr&lt;/code&gt;. The first call to &lt;code&gt;Fun&lt;/code&gt; has &lt;code&gt;AccIn&lt;/code&gt; as argument, the returned accumulator &lt;code&gt;AccOut&lt;/code&gt; is passed to the next call, and so on. The final value of the accumulator is returned. The &lt;code&gt;erl_parse&lt;/code&gt; tree is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">&lt;code&gt;erl_parse&lt;/code&gt; 트리 &lt;code&gt;Abstr&lt;/code&gt; 의 각 주석 콜렉션에 &lt;code&gt;Fun&lt;/code&gt; 을 적용하여 누산기를 업데이트합니다 . &lt;code&gt;Fun&lt;/code&gt; 에 대한 첫 번째 호출 은 인수로 &lt;code&gt;AccIn&lt;/code&gt; 을 가지며 반환 된 누산기 &lt;code&gt;AccOut&lt;/code&gt; 은 다음 호출로 전달됩니다. 누산기의 최종 값이 반환됩니다. &lt;code&gt;erl_parse&lt;/code&gt; 의 나무는 깊이 우선, 왼쪽에서 오른쪽 방식으로 이송됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ebcf826afc7224f3463dd215eb5352561a6434" translate="yes" xml:space="preserve">
          <source>Updates information about debugged processes. Information about all terminated processes are removed from the window. All Attach Process windows for terminated processes are closed.</source>
          <target state="translated">디버깅 된 프로세스에 대한 정보를 업데이트합니다. 종료 된 모든 프로세스에 대한 정보가 창에서 제거됩니다. 종료 된 프로세스에 대한 모든 프로세스 첨부 창이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="a4db32f627e995a84c52631b1bbbde821d611764" translate="yes" xml:space="preserve">
          <source>Updates the HMAC represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using an HMAC init function (such as &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hmac_update&lt;/code&gt; or to one of the functions &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">지정된 &lt;code&gt;Data&lt;/code&gt; 를 사용해 &lt;code&gt;Context&lt;/code&gt; 로 나타내지는 HMAC를 갱신합니다 . &lt;code&gt;Context&lt;/code&gt; 는 HMAC init 함수 (예 : &lt;code&gt;&lt;a href=&quot;#hmac_init-2&quot;&gt;hmac_init&lt;/a&gt;&lt;/code&gt; )를 사용하여 생성되어야합니다 . &lt;code&gt;Data&lt;/code&gt; 는 임의의 길이 일 수 있습니다. &lt;code&gt;NewContext&lt;/code&gt; 에 다음 호출에 전달해야 &lt;code&gt;hmac_update&lt;/code&gt; 또는 기능 중 하나가 &lt;code&gt;&lt;a href=&quot;#hmac_final-1&quot;&gt;hmac_final&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#hmac_final_n-2&quot;&gt;hmac_final_n&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1728dfd48279b9b9b36c71be367adee8270c7c05" translate="yes" xml:space="preserve">
          <source>Updates the MAC represented by &lt;code&gt;State0&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt; which could be of any length.</source>
          <target state="translated">임의의 길이가 될 수있는 주어진 &lt;code&gt;Data&lt;/code&gt; 를 사용하여 &lt;code&gt;State0&lt;/code&gt; 이 나타내는 MAC을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="0cc7f14f3a3fed19f2f8c9a020605209d8a12c68" translate="yes" xml:space="preserve">
          <source>Updates the digest represented by &lt;code&gt;Context&lt;/code&gt; using the given &lt;code&gt;Data&lt;/code&gt;. &lt;code&gt;Context&lt;/code&gt; must have been generated using &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; or a previous call to this function. &lt;code&gt;Data&lt;/code&gt; can be any length. &lt;code&gt;NewContext&lt;/code&gt; must be passed into the next call to &lt;code&gt;hash_update&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;Data&lt;/code&gt; 를 사용해 &lt;code&gt;Context&lt;/code&gt; 로 나타내지는 다이제스트를 갱신합니다 . &lt;code&gt;Context&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#hash_init-1&quot;&gt;hash_init&lt;/a&gt;&lt;/code&gt; 또는이 함수에 대한 이전 호출을 사용하여 생성되어야합니다 . &lt;code&gt;Data&lt;/code&gt; 는 임의의 길이 일 수 있습니다. &lt;code&gt;NewContext&lt;/code&gt; 는 다음 번 &lt;code&gt;hash_update&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#hash_final-1&quot;&gt;hash_final&lt;/a&gt;&lt;/code&gt; 호출로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a37f581698786fafdf7275742d9f7c793868104" translate="yes" xml:space="preserve">
          <source>Updates the hook function field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 후크 기능 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c2e71d06680882c2ec32b2dc6bea400636a79824" translate="yes" xml:space="preserve">
          <source>Updates the line widh field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 line widh 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="06a0436ed02af4ad242287fe8c27e31aafc0067b" translate="yes" xml:space="preserve">
          <source>Updates the object with key &lt;code&gt;Key&lt;/code&gt; stored in table &lt;code&gt;Name&lt;/code&gt; of type &lt;code&gt;set&lt;/code&gt; by adding &lt;code&gt;Incr&lt;/code&gt; to the element at the &lt;code&gt;Pos&lt;/code&gt;:th position. The new counter value is returned. If no position is specified, the element directly following the key is updated.</source>
          <target state="translated">&lt;code&gt;Pos&lt;/code&gt; : th 위치 의 요소에 &lt;code&gt;Incr&lt;/code&gt; 을 추가하여 &lt;code&gt;set&lt;/code&gt; 유형 &lt;code&gt;Name&lt;/code&gt; 테이블에 키 &lt;code&gt;Key&lt;/code&gt; 로 오브젝트를 업데이트합니다 . 새로운 카운터 값이 반환됩니다. 위치를 지정하지 않으면 키 바로 다음의 요소가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="74b81e579810979a583fac3a15071ea6d7e0648e" translate="yes" xml:space="preserve">
          <source>Updates the operator precedence field of the prettyprinter context. See the &lt;code&gt;erl_parse(3)&lt;/code&gt; module for operator precedences.</source>
          <target state="translated">prettyprinter 컨텍스트의 연산자 우선 순위 필드를 업데이트합니다. 연산자 우선 순위 는 &lt;code&gt;erl_parse(3)&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63d2d102522483d5460d1744c9d5282ecfc3df2b" translate="yes" xml:space="preserve">
          <source>Updates the paper widh field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 paper widh 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1f9326e8e858c536ca9e794bc54c6e439dd4f44b" translate="yes" xml:space="preserve">
          <source>Updates the user data field of the prettyprinter context.</source>
          <target state="translated">prettyprinter 컨텍스트의 사용자 데이터 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d4648225b60a7bf7a7074d97ae9b8282d0ba6646" translate="yes" xml:space="preserve">
          <source>Updating Maps</source>
          <target state="translated">지도 업데이트</target>
        </trans-unit>
        <trans-unit id="eb57e471df554364292c825fe5e79967d1cd792b" translate="yes" xml:space="preserve">
          <source>Updating a map has a similar syntax as constructing it.</source>
          <target state="translated">지도를 업데이트하는 것은지도를 만드는 것과 비슷한 구문을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="20eed44fc68b8b204aedfb0f91c533a64f205785" translate="yes" xml:space="preserve">
          <source>Updating a persistent term with the same value as it already has is specially optimized to do nothing quickly; thus, there is no need compare the old and new values and avoid calling &lt;code&gt;&lt;a href=&quot;#put-2&quot;&gt;put/2&lt;/a&gt;&lt;/code&gt; if the values are equal.</source>
          <target state="translated">이미 가지고있는 것과 동일한 값으로 지속적 용어를 업데이트하는 것은 특별히 빠르게 아무것도하지 않도록 최적화되어 있습니다. 따라서 이전 값과 새 값을 비교할 필요가 없으며 값이 같으면 &lt;code&gt;&lt;a href=&quot;#put-2&quot;&gt;put/2&lt;/a&gt;&lt;/code&gt; 를 호출하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="02d141042860aca10991eb65163181406dcf7137" translate="yes" xml:space="preserve">
          <source>Updating or deleting a persistent term will trigger a global GC if the term does not fit in one machine word. Processes will be scheduled as usual, but all processes will be made runnable at once, which will make the system less responsive until all process have run and scanned their heaps for the deleted terms. One way to minimize the effects on responsiveness could be to minimize the number of processes on the node before updating or deleting a persistent term. It would also be wise to avoid updating terms when the system is at peak load.</source>
          <target state="translated">영구 용어를 업데이트하거나 삭제하면 용어가 하나의 기계어에 맞지 않는 경우 전역 GC가 트리거됩니다. 프로세스는 평소와 같이 예약되지만 모든 프로세스가 한 번에 실행 가능하게되어 모든 프로세스가 실행되고 힙에서 삭제 된 용어를 검색 할 때까지 시스템의 응답 성이 떨어집니다. 응답성에 미치는 영향을 최소화하는 한 가지 방법은 지속적 기간을 업데이트하거나 삭제하기 전에 노드의 프로세스 수를 최소화하는 것입니다. 또한 시스템이 최대 부하에있을 때 용어 업데이트를 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="52b5471f4080ddbb8029246652a7263fae21041d" translate="yes" xml:space="preserve">
          <source>Upgrade Example - TLS only</source>
          <target state="translated">업그레이드 예-TLS 만</target>
        </trans-unit>
        <trans-unit id="a4ccacf954181a7d1504665a82641050052eb900" translate="yes" xml:space="preserve">
          <source>Upgrade the connection associated with &lt;code&gt;Handle&lt;/code&gt; to a tls connection if possible.</source>
          <target state="translated">가능한 경우 &lt;code&gt;Handle&lt;/code&gt; 과 연관된 연결 을 tls 연결로 업그레이드하십시오 .</target>
        </trans-unit>
        <trans-unit id="db0184af500cc1d274a7e5600d1d6a2de2501102" translate="yes" xml:space="preserve">
          <source>Upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, connected socket to a TLS socket, that is, performs the client-side TLS handshake.</source>
          <target state="translated">&lt;code&gt;gen_tcp&lt;/code&gt; 또는 이와 동등한 연결된 소켓을 TLS 소켓으로 업그레이드합니다. 즉 , 클라이언트 측 TLS 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ca4651bcfd7cc66e9b643622e9b6fa5cf9be97fb" translate="yes" xml:space="preserve">
          <source>Upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, connected socket to an TLS socket, that is, performs the client-side TLS handshake.</source>
          <target state="translated">&lt;code&gt;gen_tcp&lt;/code&gt; 또는 이와 동등한 연결 소켓을 TLS 소켓으로 업그레이드합니다. 즉 , 클라이언트 측 TLS 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0885a1400bd730b033aa9a97c94e31cdcc2976c9" translate="yes" xml:space="preserve">
          <source>Upgrades an application &lt;code&gt;App&lt;/code&gt; from the current version to a new version located in &lt;code&gt;Dir&lt;/code&gt; according to the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; 파일 에 따라 응용 프로그램 &lt;code&gt;App&lt;/code&gt; 을 현재 버전에서 &lt;code&gt;Dir&lt;/code&gt; 에 있는 새 버전으로 업그레이드 합니다.</target>
        </trans-unit>
        <trans-unit id="fe465284017475712d39dd7e9e97f804a2375abf" translate="yes" xml:space="preserve">
          <source>Upon failure to reopen the log, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">로그를 다시 열지 못하면 EXIT 메시지 &lt;code&gt;{{failed,Error},[{disk_log,Fun,Arity}]}&lt;/code&gt; 와 함께 디스크 로그 프로세스가 종료됩니다 . 요청이 대기중인 다른 프로세스는 &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; 메시지를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="313cdf1a747cf13f7fb3ba0b75e218a96c2914cd" translate="yes" xml:space="preserve">
          <source>Uppercase letter</source>
          <target state="translated">대문자</target>
        </trans-unit>
        <trans-unit id="655dc371ef84593d2a9260f8648168e35e59595a" translate="yes" xml:space="preserve">
          <source>Uppercase letters</source>
          <target state="translated">대문자</target>
        </trans-unit>
        <trans-unit id="42df97f2f6a736b6736486799c452f7ab2ae5c74" translate="yes" xml:space="preserve">
          <source>Uppercase letters signify real identifiers and lowercase letters signify fake identifiers only used for description of the topology. Identifiers passed as real identifiers can be used by the runtime system when trying to access specific hardware; if they are incorrect the behavior is undefined. Faked logical CPU identifiers are not accepted, as there is no point in defining the CPU topology without real logical CPU identifiers. Thread, core, processor, and node identifiers can be omitted. If omitted, the thread ID defaults to &lt;code&gt;t0&lt;/code&gt;, the core ID defaults to &lt;code&gt;c0&lt;/code&gt;, the processor ID defaults to &lt;code&gt;p0&lt;/code&gt;, and the node ID is left undefined. Either each logical processor must belong to only one NUMA node, or no logical processors must belong to any NUMA nodes.</source>
          <target state="translated">대문자는 실제 식별자를 나타내며 소문자는 토폴로지 설명에 사용 된 가짜 식별자를 나타냅니다. 실제 식별자로 전달 된 식별자는 특정 하드웨어에 액세스하려고 할 때 런타임 시스템에서 사용할 수 있습니다. 이들이 올바르지 않으면 동작이 정의되지 않습니다. 실제 논리적 CPU 식별자없이 CPU 토폴로지를 정의 할 필요가 없으므로 결함이있는 논리적 CPU 식별자는 허용되지 않습니다. 스레드, 코어, 프로세서 및 노드 식별자는 생략 할 수 있습니다. 생략하면 스레드 ID의 기본값은 &lt;code&gt;t0&lt;/code&gt; 이고 코어 ID의 기본값은 &lt;code&gt;c0&lt;/code&gt; 이고 프로세서 ID의 기본값은 &lt;code&gt;p0&lt;/code&gt; 이며 노드 ID는 정의되지 않은 상태로 남아 있습니다. 각 논리 프로세서는 하나의 NUMA 노드에만 속하거나 논리 프로세서는 NUMA 노드에 속하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="19370c86dcca239b2f891f36eb2a0c4f475f930f" translate="yes" xml:space="preserve">
          <source>Uri data types</source>
          <target state="translated">Uri 데이터 유형</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="2c9af3bf645c9bf6cb6b56eedb88807aad3f66ae" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; with an absolute path after &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 후 절대 경로로 &lt;code&gt;&lt;a href=&quot;#change_key-2&quot;&gt;change_key/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c47962432a46afd10354bf7faf78b77ebd176482" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; together with &lt;code&gt;enif_select&lt;/code&gt; to detect failing Erlang processes and prevent them from causing permanent leakage of resources and their contained OS event objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_monitor_process&quot;&gt;enif_monitor_process&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;enif_select&lt;/code&gt; 를 enif_select 와 함께 사용 하여 실패한 Erlang 프로세스를 감지하고 자원 및 포함 된 OS 이벤트 오브젝트의 영구 누출을 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="44e7e015a8657a665a01a0520fdb99490efbc8b2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; to guarantee &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; for subsequent calls to &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에 대해 &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; 를 보장 하려면 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7da24533e796ccef89e6be1ffa753ac897a16df3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; to guarantee &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; for subsequent calls to &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에 대해 &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; 를 보장 하려면 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fc01bc65b8bccb967f709eb00a1f11cb2c754fc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; to guarantee &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; for subsequent calls to &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 에 대한 후속 호출에 대해 &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt;safe traversal&lt;/a&gt;&lt;/code&gt; 를 보장 하려면 &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac19f9c55f3cb262bc1bcb3f39438151f391e8ca" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt; gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; to signal that no more data is to be sent and wait for the read side of the socket to be closed.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt; gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; 더 이상 데이터가 전송 될 소켓의 읽기 측에 대한 대기가 폐쇄 될 수 없다는 것을 알리기 위해.</target>
        </trans-unit>
        <trans-unit id="f81221a29d13782207a78cbfa816c0cbf3c464d7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; to signal that no more data is to be sent and wait for the read side of the socket to be closed.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;gen_tcp:shutdown(Sock, write)&lt;/a&gt;&lt;/code&gt; 더 이상 데이터가 전송 될 소켓의 읽기 측에 대한 대기가 폐쇄 될 수 없다는 것을 알리기 위해.</target>
        </trans-unit>
        <trans-unit id="7ead82a2bde7adf5d2bb9488a1ed038033681dd8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erl_ext_dist#fragments&quot;&gt;fragmented&lt;/a&gt;&lt;/code&gt; distribution messages to send large messages.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#fragments&quot;&gt;fragmented&lt;/a&gt;&lt;/code&gt; 큰 메시지를 보낼 유통 메시지를.</target>
        </trans-unit>
        <trans-unit id="88a6e8689fc8004e74f39f7b9aff0d955c4830e5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt; erlang:system_time/1&lt;/a&gt;&lt;/code&gt; to retrieve the current Erlang system time on the &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; of your choice.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt; erlang:system_time/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 선택한 &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 로 현재 Erlang 시스템 시간을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="71bd29e8e106825432b11d0f4aa2b931f6f8bf79" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; to retrieve the current Erlang system time on the &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; of your choice.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#system_time-1&quot;&gt;erlang:system_time/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 선택한 &lt;code&gt;&lt;a href=&quot;erlang#type_time_unit&quot;&gt;time unit&lt;/a&gt;&lt;/code&gt; 로 현재 Erlang 시스템 시간을 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c6d38128136d372de87b2cca11fa0fc14d3b6dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;net_adm#ping-1&quot;&gt;net_adm:ping(Node)&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="611de99bd7fd476bf937c72c0e0fd5671d5f5338" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; to see the content of the history buffer and &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; to re-execute one of the entries.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ttb#list_history-0&quot;&gt;ttb:list_history/0&lt;/a&gt;&lt;/code&gt; 을 사용 하여 히스토리 버퍼의 내용을보고 &lt;code&gt;&lt;a href=&quot;ttb#run_history-1&quot;&gt;ttb:run_history/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 항목 중 하나를 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a08416b12ce433a16c45d0b1b7b6dcc6f100d529" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; as &lt;code&gt;mode&lt;/code&gt; in order to safely close an event object that has been passed to &lt;code&gt;enif_select&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback of the resource &lt;code&gt;obj&lt;/code&gt; will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received (or cancelled) and no further calls to &lt;code&gt;enif_select&lt;/code&gt; have been made. &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; will first cancel any selected events before it calls or schedules the &lt;code&gt;stop&lt;/code&gt; callback. Arguments &lt;code&gt;pid&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; are ignored when &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; is specified.</source>
          <target state="translated">사용 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 같은 &lt;code&gt;mode&lt;/code&gt; 로 전달되어 안전하게 가까운 이벤트 객체 위해 &lt;code&gt;enif_select&lt;/code&gt; . 자원 &lt;code&gt;obj&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 콜백은 이벤트 객체를 닫아도 안전 할 때 호출됩니다. 이벤트 객체를 닫는이 안전한 방법은 모든 알림이 수신 (또는 취소)되고 &lt;code&gt;enif_select&lt;/code&gt; 에 대한 추가 호출이 수행 되지 않은 경우에도 사용해야합니다 . &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 은 &lt;code&gt;stop&lt;/code&gt; 콜백을 호출하거나 예약하기 전에 선택한 이벤트를 먼저 취소합니다 . &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 이 지정 되면 인수 &lt;code&gt;pid&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt; 가 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="03a0a6dcdb4bb774d1d742179139e2e450523f30" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; as &lt;code&gt;mode&lt;/code&gt; in order to safely close an event object that has been passed to &lt;code&gt;enif_select&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback of the resource &lt;code&gt;obj&lt;/code&gt; will be called when it is safe to close the event object. This safe way of closing event objects must be used even if all notifications have been received and no further calls to &lt;code&gt;enif_select&lt;/code&gt; have been made.</source>
          <target state="translated">사용 &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; 같은 &lt;code&gt;mode&lt;/code&gt; 로 전달되어 안전하게 가까운 이벤트 객체 위해 &lt;code&gt;enif_select&lt;/code&gt; . 이벤트 객체를 닫는 것이 안전 할 때 리소스 &lt;code&gt;obj&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 콜백이 호출됩니다. 모든 알림이 수신되고 &lt;code&gt;enif_select&lt;/code&gt; 에 대한 추가 호출이없는 경우에도 이벤트 객체를 안전하게 닫는이 방법을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4dbf19e8e181869d7824e230cc259b4296e049dd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;M-x compile&lt;/code&gt; to compile an MIB from inside Emacs, and enter:</source>
          <target state="translated">사용 &lt;code&gt;M-x compile&lt;/code&gt; 이맥스 내부에서 MIB를 컴파일하고 입력합니다 :</target>
        </trans-unit>
        <trans-unit id="43487582b9c31bb61fd048104c15adf5df0fcbcf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:is_compiled/1&lt;/code&gt; or &lt;code&gt;code:which/1&lt;/code&gt; to see if a module is Cover compiled (and still loaded) or not.</source>
          <target state="translated">사용 &lt;code&gt;cover:is_compiled/1&lt;/code&gt; 또는 &lt;code&gt;code:which/1&lt;/code&gt; 모듈이 커버 컴파일 (여전히로드) 가능 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7f85d8a08505e2b0a869a54c5dd45740db5b3406" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;cover:start/1&lt;/code&gt; and &lt;code&gt;cover:stop/1&lt;/code&gt; to add or remove nodes. The same Cover compiled code will be loaded on each node, and analysis will collect and sum up coverage data results from all nodes.</source>
          <target state="translated">사용 &lt;code&gt;cover:start/1&lt;/code&gt; 및 &lt;code&gt;cover:stop/1&lt;/code&gt; 추가하거나 제거 할 노드합니다. 동일한 Cover 컴파일 코드가 각 노드에로드되고 분석은 모든 노드에서 Coverage 데이터 결과를 수집하고 요약합니다.</target>
        </trans-unit>
        <trans-unit id="5b51e4203eb742f5eb4fc26e38e7eb765f543077" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;driver_alloc_binary()&lt;/code&gt; to allocate a binary.</source>
          <target state="translated">바이너리를 할당 하려면 &lt;code&gt;driver_alloc_binary()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c95131c00c47173f141a21936f6eef73f82cca9f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:get_cookie()&lt;/code&gt; in ERTS instead.</source>
          <target state="translated">대신 ERTS에서 &lt;code&gt;erlang:get_cookie()&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c041275bff1db161bb6bcf06b8c664a175f0746" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:now/0&lt;/code&gt; to retrieve the current Erlang system time.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 을 사용 하여 현재 Erlang 시스템 시간을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="70734f79b3e2d0baca01b45e43fb19b230f1b8af" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:set_cookie(node(), Cookie) in ERTS&lt;/code&gt; instead.</source>
          <target state="translated">사용 &lt;code&gt;erlang:set_cookie(node(), Cookie) in ERTS&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="de069253a09bf6a9eebbd010c198840f5e87a703" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; instead.</source>
          <target state="translated">사용 &lt;code&gt;erlang:set_cookie(node(),Cookie)in ERTS&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="4290f2a7a214d1f9ba5e3a266d300f53024ef971" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;hipe:help_options/0&lt;/code&gt; to print out the available options.</source>
          <target state="translated">사용 가능한 옵션을 인쇄 하려면 &lt;code&gt;hipe:help_options/0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae0a3e8fb6ea6a46c1431393956ad0cdb131d016" translate="yes" xml:space="preserve">
          <source>Use Compiler option &lt;code&gt;{debug_info_key,Key}&lt;/code&gt;, see &lt;code&gt;compile(3)&lt;/code&gt; and function &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; to register a fun that returns the key whenever &lt;code&gt;beam_lib&lt;/code&gt; must decrypt the debug information.</source>
          <target state="translated">컴파일러 옵션 &lt;code&gt;{debug_info_key,Key}&lt;/code&gt; 를 사용하고 , &lt;code&gt;compile(3)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#crypto_key_fun-1&quot;&gt;crypto_key_fun/1&lt;/a&gt;&lt;/code&gt; 함수를 참조 하여 &lt;code&gt;beam_lib&lt;/code&gt; 가 디버그 정보를 해독해야 할 때마다 키를 리턴하는 재미를 등록 하십시오.</target>
        </trans-unit>
        <trans-unit id="cf76996b770b568aba2d669a4a4c375802561542" translate="yes" xml:space="preserve">
          <source>Use Dialyzer from the command line to detect defects in the specified files or directories containing &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.beam&lt;/code&gt; files, depending on the type of the analysis.</source>
          <target state="translated">명령 유형에서 Dialyzer를 사용 하여 분석 유형에 따라 &lt;code&gt;.erl&lt;/code&gt; 또는 &lt;code&gt;.beam&lt;/code&gt; 파일을 포함하는 지정된 파일 또는 디렉토리의 결함을 감지 하십시오.</target>
        </trans-unit>
        <trans-unit id="52ecd59359aa11823ae3489c4b92ca323d2f8686" translate="yes" xml:space="preserve">
          <source>Use Mnesia with the following types of applications:</source>
          <target state="translated">다음과 같은 유형의 응용 프로그램에서 Mnesia를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd0851048c67fb91d296c17c79d984235168aa8a" translate="yes" xml:space="preserve">
          <source>Use STDLIB application variable &lt;code&gt;restricted_shell&lt;/code&gt; and specify, as its value, the name of the callback module. Example (with callback functions implemented in &lt;code&gt;callback_mod.erl&lt;/code&gt;): &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt;.</source>
          <target state="translated">사용 STDLIB 응용 프로그램 변수는 &lt;code&gt;restricted_shell&lt;/code&gt; 값, 콜백 모듈의 이름으로, 그리고 지정합니다. 예 (구현 콜백 기능 &lt;code&gt;callback_mod.erl&lt;/code&gt; ) : &lt;code&gt;$ erl -stdlib restricted_shell callback_mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9de9466c5fd84c1497ee031330a8bf3182295b3" translate="yes" xml:space="preserve">
          <source>Use a parameterized query to insert many rows in one go.</source>
          <target state="translated">한 번에 많은 행을 삽입하려면 매개 변수화 된 쿼리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4246bdbd0514a46c24c66d6a824bf38823f49b83" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm with a constant seed:</source>
          <target state="translated">상수 시드와 함께 지정된 알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="98d7bed7136a80ee2a1f391e37af7b4e25791949" translate="yes" xml:space="preserve">
          <source>Use a specified algorithm:</source>
          <target state="translated">지정된 알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ef43eef2287dfb39d5045b73777b94383dd1809" translate="yes" xml:space="preserve">
          <source>Use active mode only if your high-level protocol provides its own flow control (for example, acknowledging received messages) or the amount of data exchanged is small. &lt;code&gt;{active, false}&lt;/code&gt; mode, use of the &lt;code&gt;{active, once}&lt;/code&gt; mode, or &lt;code&gt;{active, N}&lt;/code&gt; mode with values of &lt;code&gt;N&lt;/code&gt; appropriate for the application provides flow control. The other side cannot send faster than the receiver can read.</source>
          <target state="translated">고급 프로토콜이 자체 흐름 제어 (예 : 수신 된 메시지 확인)를 제공하거나 교환되는 데이터 양이 적은 경우에만 활성 모드를 사용하십시오. &lt;code&gt;{active, false}&lt;/code&gt; 모드, 응용 프로그램에 적합한 &lt;code&gt;N&lt;/code&gt; 값을 가진 &lt;code&gt;{active, once}&lt;/code&gt; 모드 또는 &lt;code&gt;{active, N}&lt;/code&gt; 모드 사용 은 흐름 제어를 제공합니다. 상대방이 읽을 수있는 것보다 빨리 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0cb9f5afdf0431967f44f8bc5907c7bc9106a55e" translate="yes" xml:space="preserve">
          <source>Use batch file &lt;code&gt;etop.bat&lt;/code&gt;, for example, &lt;code&gt;etop -node tiger@durin&lt;/code&gt;.</source>
          <target state="translated">배치 파일 &lt;code&gt;etop.bat&lt;/code&gt; 를 사용하십시오 ( 예 : &lt;code&gt;etop -node tiger@durin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804cbb37615425c1f58bef26b23df4ccbb998e2d" translate="yes" xml:space="preserve">
          <source>Use bitwise AND to test for specific bits in the return value. New significant bits may be added in future releases to give more detailed information for both failed and successful calls. Do NOT use equality tests like &lt;code&gt;==&lt;/code&gt;, as that may cause your application to stop working.</source>
          <target state="translated">비트 AND를 사용하여 반환 값에서 특정 비트를 테스트합니다. 실패한 통화와 성공적인 통화 모두에 대한 자세한 정보를 제공하기 위해 향후 릴리스에 새로운 중요 비트가 추가 될 수 있습니다. &lt;code&gt;==&lt;/code&gt; 와 같은 동등성 테스트를 사용하지 마십시오 . 응용 프로그램 작동이 중지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28d05d6e3c0c6496475b27e170aa3c9890b934a6" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; to obtain a basic pattern, which matches all records in a table, or use the default value in record creation. Do not make the pattern hard-coded, as this makes the code more vulnerable to future changes of the record definition.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#table_info-2&quot;&gt;mnesia:table_info(Tab, wild_pattern)&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 테이블의 모든 레코드와 일치하는 기본 패턴을 얻거나 레코드 작성시 기본값을 사용하십시오. 패턴을 하드 코딩하지 마십시오. 레코드 정의의 향후 변경에 코드가 더 취약 해집니다.</target>
        </trans-unit>
        <trans-unit id="36fef5f536ab55188b5441adeba6150367c3ff02" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; to list all loaded reports:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rb#list-0&quot;&gt;rb:list()&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여로드 된 모든 보고서를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b28b25ff39058f6138bbe1ff3ebce8f3b6ccb94a" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; to show details of a specific report:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rb#show-1&quot;&gt;rb:show(Number)&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 특정 보고서의 세부 사항을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="a0eac0e99e0695efffadbf6a76c731707faeeeea" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; to stop the &lt;code&gt;rb_server&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rb#stop-0&quot;&gt;rb:stop()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;rb_server&lt;/code&gt; (stop) 함수를 사용 하여 rb_server 를 중지하십시오 .</target>
        </trans-unit>
        <trans-unit id="012887c588a915c59771e087bcd639512c6a8489" translate="yes" xml:space="preserve">
          <source>Use function &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; to get all flags for features that require strict order delivery.</source>
          <target state="translated">&lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 함수를 사용 하여 엄격한 주문 전달이 필요한 기능에 대한 모든 플래그를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="7f83ae95c5e5857514f24ca4885f3294c1f168dd" translate="yes" xml:space="preserve">
          <source>Use its graphical interface to investigate the state of the current test case.</source>
          <target state="translated">그래픽 인터페이스를 사용하여 현재 테스트 사례의 상태를 조사하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
