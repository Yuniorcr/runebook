<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="946db1924667eb983a11ec1edab5fe1131a72877" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;obj&lt;/code&gt; is pointer to the resource to hold the monitor and &lt;code&gt;*target_pid&lt;/code&gt; identifies the local process to be monitored.</source>
          <target state="translated">인수 &lt;code&gt;obj&lt;/code&gt; 는 모니터를 보유 할 자원에 대한 포인터이며 &lt;code&gt;*target_pid&lt;/code&gt; 는 모니터 할 로컬 프로세스를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="759c092e66e225d8bfb0ee95cc9263fb1d2744cd" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;percent&lt;/code&gt; must be an integer between 1 and 100. This function must only be called from a NIF-calling thread, and argument &lt;code&gt;env&lt;/code&gt; must be the environment of the calling process.</source>
          <target state="translated">인수 &lt;code&gt;percent&lt;/code&gt; 은 1과 100 사이의 정수 여야합니다.이 함수는 NIF 호출 스레드에서만 호출 해야하며 인수 &lt;code&gt;env&lt;/code&gt; 는 호출 프로세스의 환경이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f2c2f60e2d8ae32461ae1eadddd46c13583f534f" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;pid&lt;/code&gt; may be &lt;code&gt;NULL&lt;/code&gt; to indicate the calling process.</source>
          <target state="translated">호출 프로세스를 표시하기 위해 인수 &lt;code&gt;pid&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="302f9a8d5949d2f9e3d699e1fadbaaf1fd2728b5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;ref&lt;/code&gt; must be either a reference obtained from &lt;code&gt;&lt;a href=&quot;erlang#make_ref-0&quot;&gt;erlang:make_ref/0&lt;/a&gt;&lt;/code&gt; or the atom &lt;code&gt;undefined&lt;/code&gt;. It will be passed as &lt;code&gt;Ref&lt;/code&gt; in the notifications. If a selective &lt;code&gt;receive&lt;/code&gt; statement is used to wait for the notification then a reference created just before the &lt;code&gt;receive&lt;/code&gt; will exploit a runtime optimization that bypasses all earlier received messages in the queue.</source>
          <target state="translated">인수 &lt;code&gt;ref&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;erlang#make_ref-0&quot;&gt;erlang:make_ref/0&lt;/a&gt;&lt;/code&gt; 에서 얻은 참조 이거나 원자 &lt;code&gt;undefined&lt;/code&gt; 여야 합니다. 알림에서 &lt;code&gt;Ref&lt;/code&gt; 로 전달됩니다 . 선택적 &lt;code&gt;receive&lt;/code&gt; 명령문을 사용하여 알림을 기다리는 경우 &lt;code&gt;receive&lt;/code&gt; 직전에 작성된 참조 는 큐에서 이전에 수신 된 모든 메시지를 무시하는 런타임 최적화를 이용합니다.</target>
        </trans-unit>
        <trans-unit id="7193c5fbe44de78fcb734160bf05a4992363162d" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;reserved&lt;/code&gt; is intended for future use and is to be ignored.</source>
          <target state="translated">&lt;code&gt;reserved&lt;/code&gt; 인수 는 나중에 사용하기위한 것이며 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="47a1b242d8b4376bd70073509fcf4806ebd02558" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;to_enc&lt;/code&gt; is ignored. As from Erlang/OTP 20 the encoding is always done in UTF-8 which is readable by nodes as old as Erlang/OTP R16.</source>
          <target state="translated">인수 &lt;code&gt;to_enc&lt;/code&gt; 는 무시됩니다. Erlang / OTP 20에서와 같이 인코딩은 항상 UTF-8로 수행되며 Erlang / OTP R16만큼 오래된 노드에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="765075133d0be0aa3a9dbc9bcb841e96fb89d790" translate="yes" xml:space="preserve">
          <source>Argument list for the &lt;code&gt;init&lt;/code&gt; function in the callback module.</source>
          <target state="translated">콜백 모듈 의 &lt;code&gt;init&lt;/code&gt; 함수에 대한 인수 목록</target>
        </trans-unit>
        <trans-unit id="13185c544644b7f2a243ef918a03957be326a36d" translate="yes" xml:space="preserve">
          <source>Argument:</source>
          <target state="translated">Argument:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="565865945dd4be2b94783c9b5e4f90518f12be80" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Args&lt;/code&gt; are used in a call to &lt;code&gt;io_lib:format/2&lt;/code&gt; to create the comment string. The behavior of &lt;code&gt;comment/2&lt;/code&gt; is otherwise the same as function &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Format&lt;/code&gt; 및 &lt;code&gt;Args&lt;/code&gt; 는 주석 문자열을 만들기 위해 &lt;code&gt;io_lib:format/2&lt;/code&gt; 를 호출 할 때 사용됩니다 . &lt;code&gt;comment/2&lt;/code&gt; 의 동작은 &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt; 함수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="a853cd0dac3624d36b7ac915686a7bf9b68613c0" translate="yes" xml:space="preserve">
          <source>Arithmetic bitshift left</source>
          <target state="translated">산술 비트 시프트 왼쪽</target>
        </trans-unit>
        <trans-unit id="09257e94fa407278a59602ea81c51ef19d845892" translate="yes" xml:space="preserve">
          <source>Arithmetic bitwise XOR</source>
          <target state="translated">산술 비트 XOR</target>
        </trans-unit>
        <trans-unit id="206db889fe395b01fcd9ea9b88e2747a6dbb4f32" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions</source>
          <target state="translated">산술 식</target>
        </trans-unit>
        <trans-unit id="296f27747464dfd4585fc68aca14b6147fb87a9b" translate="yes" xml:space="preserve">
          <source>Arithmetics: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;rem&lt;/code&gt;</source>
          <target state="translated">산술 : &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;div&lt;/code&gt; , &lt;code&gt;rem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdadcc41e499fbe0cbed3e778cd50052fc53c2be" translate="yes" xml:space="preserve">
          <source>Arity ::= Number | &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">Arity :: = 숫자 | &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="6c4709af989db804327c6ea436d6589b124f8253" translate="yes" xml:space="preserve">
          <source>Arranges documents horizontally or vertically, separated by whitespace. Returns a document representing two alternative layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents, such that either all elements in &lt;code&gt;Docs&lt;/code&gt; are concatenated horizontally, and separated by a space character, or all elements are concatenated vertically (without extra separation).</source>
          <target state="translated">공백으로 구분하여 문서를 가로 또는 세로로 정렬합니다. 반환 (비어 있지 않은) 두 대체 레이아웃을 나타내는 문서 시퀀스 &lt;code&gt;Docs&lt;/code&gt; 문서의를에 어느 모든 요소되도록 &lt;code&gt;Docs&lt;/code&gt; 가로로 연접하고, 공백 문자에 의해 분리 또는 모든 요소 (추가 분리없이) 수직으로 연접되어있다.</target>
        </trans-unit>
        <trans-unit id="cb6e8bc43bfadc15174aa7c7533ec25e49f627de" translate="yes" xml:space="preserve">
          <source>Arranges documents in a paragraph-like layout. Returns a document representing all possible left-aligned paragraph-like layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents. Elements in &lt;code&gt;Docs&lt;/code&gt; are separated horizontally by a single space character and vertically with a single line break. All lines following the first (if any) are indented to the same left column, whose indentation is specified by the optional &lt;code&gt;Offset&lt;/code&gt; parameter relative to the position of the first element in &lt;code&gt;Docs&lt;/code&gt;. For example, with an offset of -4, the following layout can be produced, for a list of documents representing the numbers 0 to 15:</source>
          <target state="translated">단락과 같은 레이아웃으로 문서를 정렬합니다. 비어 있지 않은 순서의 &lt;code&gt;Docs&lt;/code&gt; 에서 가능한 왼쪽 정렬 된 단락과 유사한 레이아웃을 나타내는 문서를 반환합니다 . &lt;code&gt;Docs&lt;/code&gt; 요소 는 단일 공백 ​​문자로 가로로 구분되고 단일 줄 바꿈으로 세로로 구분됩니다. 첫 번째 (있는 경우) 뒤의 모든 행은 동일한 왼쪽 열에 들여 쓰기되며, 들여 쓰기는 &lt;code&gt;Docs&lt;/code&gt; 의 첫 번째 요소 위치와 관련된 선택적 &lt;code&gt;Offset&lt;/code&gt; 매개 변수에 의해 지정됩니다 . 예를 들어, 오프셋이 -4 인 경우 0에서 15까지의 숫자를 나타내는 문서 목록에 대해 다음 레이아웃을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0401c5dcd8acaf55fb3e4a1e292be99ca524e1" translate="yes" xml:space="preserve">
          <source>Arrays uses &lt;strong&gt;zero&lt;/strong&gt;-based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples.</source>
          <target state="translated">배열은 &lt;strong&gt;0부터 시작하는&lt;/strong&gt; 인덱싱을 사용 합니다. 이것은 의도적 인 디자인 선택이며 다른 Erlang 데이터 구조 (예 : 튜플)와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8daa60e38c87072a49c49928224bef6c12c7e054" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; 하지만 더러운 CPU 스케줄러에 영향을 미칩니다. 기본값은 &lt;code&gt;short&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="309dd2054ffb824320663f138850770c829b8b4e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; 하지만 더러운 IO 스케줄러에 영향을 미칩니다. 기본값은 &lt;code&gt;short&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b3946f390b5828658a54092e42e5c1aeb3b35f2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; 하지만 더러운 CPU 스케줄러에 영향을 미칩니다. 기본값은 &lt;code&gt;medium&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e2e5d1e1ed3c38e858012a446291d2ee5eda343" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; 하지만 더러운 IO 스케줄러에 영향을 미칩니다. 기본값은 &lt;code&gt;medium&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc32ea3f593b79a1f69eaba316d39f23e652807c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt;, but the atom must exist.</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt; 만 원자가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="434cd7266c5993b7f305995750735748f31955d2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;Subject&lt;/code&gt; is searched until exhausted and a list of all non-overlapping parts matching &lt;code&gt;Pattern&lt;/code&gt; is returned (in order).</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; 만 &lt;code&gt;Subject&lt;/code&gt; 소진과 일치하는 모든 중첩되지 않는 부품의 목록까지 검색되는 &lt;code&gt;Pattern&lt;/code&gt; (순서대로) 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="62392802bcfff15af67682cfdf06f0083a7bb98e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; ,하지만 보내지 않습니다 &lt;code&gt;hello&lt;/code&gt; 메시지를.</target>
        </trans-unit>
        <trans-unit id="cb9ffdb93aadccde648214772c8fec53159cd3ed" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; ,하지만 보내지 않습니다 &lt;code&gt;hello&lt;/code&gt; 메시지를.</target>
        </trans-unit>
        <trans-unit id="4fa21b36059529486327fb112773587da1a9d73d" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;S'&lt;/code&gt; depend only on &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, the kind of state machine described here is a Mealy machine (see, for example, the Wikipedia article &quot;Mealy machine&quot;).</source>
          <target state="translated">마찬가지로 및 &lt;code&gt;S'&lt;/code&gt; 만에 의존 &lt;code&gt;S&lt;/code&gt; 및 &lt;code&gt;E&lt;/code&gt; , 상태 머신의 종류는 여기에 설명 된 반점 기계이다 (참조, 예를 들어 상기 Wikipedia 기사 &quot;반점 시스템&quot;). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7f0ebcdeb2935048365b1b7688d80f3aa697b38" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Common Test&lt;/code&gt; always finishes at least the current test case, the time specified with &lt;code&gt;duration&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; is never definitive.</source>
          <target state="translated">으로 &lt;code&gt;Common Test&lt;/code&gt; 항상 적어도 현재의 테스트 케이스를 완료, 시간이 지정된 &lt;code&gt;duration&lt;/code&gt; 이나 &lt;code&gt;until&lt;/code&gt; 확실한 결코 없다.</target>
        </trans-unit>
        <trans-unit id="36e279355dc9b13486eb359a6a271e352bb9ca92" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_list/1&lt;/code&gt;, but returns a list of integers corresponding to the bytes from position &lt;code&gt;Start&lt;/code&gt; to position &lt;code&gt;Stop&lt;/code&gt; in &lt;code&gt;Binary&lt;/code&gt;. The positions in the binary are numbered starting from 1.</source>
          <target state="translated">로 &lt;code&gt;binary_to_list/1&lt;/code&gt; 만 반환 위치에서 바이트에 해당하는 정수의 목록 &lt;code&gt;Start&lt;/code&gt; 위치에 &lt;code&gt;Stop&lt;/code&gt; 에 &lt;code&gt;Binary&lt;/code&gt; . 이진의 위치는 1부터 시작하여 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="356a2faa4b1e013f3d85b59d1af52dcdb569daaf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_term/1&lt;/code&gt;, but takes these options:</source>
          <target state="translated">으로 &lt;code&gt;binary_to_term/1&lt;/code&gt; 만 이러한 옵션을합니다 :</target>
        </trans-unit>
        <trans-unit id="4a20cd1597bfd4ebe1b9bc83959a610632302a2c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt; execute on the same Erlang process as the test case, printouts from these configuration functions are included in the test case log file.</source>
          <target state="translated">마찬가지로 &lt;code&gt;init_per_testcase&lt;/code&gt; 및 &lt;code&gt;end_per_testcase&lt;/code&gt; 테스트 케이스 같은 얼랑 프로세스 실행,이 구성에서 기능 출력물은 테스트 케이스 로그 파일에 포함된다.</target>
        </trans-unit>
        <trans-unit id="077937866e1c72c70b5a0b14cb6e8cc697f67ab6" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;reload/2&lt;/code&gt; waits for the reloading to occur, a misbehaving process keeping open ports to the driver (or keeping the driver loaded) can cause infinite waiting for reload. Time-outs must be provided outside of the process demanding the reload or by using the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; in combination with driver monitors.</source>
          <target state="translated">마찬가지로 &lt;code&gt;reload/2&lt;/code&gt; 장전 대한 발생 리로딩, 운전자에게 열린 포트를 유지 (또는 드라이버가로드 유지)가 오작동 프로세스가 발생할 수있는 무한 대기 기다린다. 재로드를 요구하는 프로세스 외부에서 또는 드라이버 모니터와 함께 하위 레벨 인터페이스 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 를 사용하여 제한 시간을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35dd6ddae6107d33b10d598d29bb9b8cf8efce75" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;{Unused,Binary}&lt;/code&gt; where &lt;code&gt;Unused&lt;/code&gt; denotes how many trailing zero-bits 0-7 that are unused in the least significant byte in &lt;code&gt;Binary&lt;/code&gt;. This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if &lt;code&gt;compact_bit_string&lt;/code&gt; has been given.</source>
          <target state="translated">마찬가지로 &lt;code&gt;{Unused,Binary}&lt;/code&gt; 여기서 &lt;code&gt;Unused&lt;/code&gt; 이고 얼마나 후미 제로 비트 최하위 바이트의 미사용 0-7 &lt;code&gt;Binary&lt;/code&gt; . 이 형식은 인코딩 함수에 대한 입력으로 허용되며, &lt;code&gt;compact_bit_string&lt;/code&gt; 이 제공된 경우 &lt;code&gt;BIT STRING&lt;/code&gt; 이이 형식으로 디코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="40263cdf47a643660bd823252e4e54341b4e8e99" translate="yes" xml:space="preserve">
          <source>As Erl_Interface operates on the Erlang external term format, the port must be set to use binaries.</source>
          <target state="translated">Erl_Interface는 Erlang 외부 용어 형식으로 작동하므로 포트는 바이너리를 사용하도록 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf5866c25e866f9c6f9b119f63b598360bcc9ad6" translate="yes" xml:space="preserve">
          <source>As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific.</source>
          <target state="translated">Erlang에는 고정 된 유형의 유형이 있으므로 프로그래머가 일부 응용 프로그램에서 사용되는 외부 형식의 사양을 정의 할 필요가 없습니다. 모든 Erlang 용어는 외부 표현을 가지며 다른 용어의 해석은 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c7e5143ee8610dc021b9a09e083dc533d485e207" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">A와 &lt;code&gt;simple_one_for_one&lt;/code&gt; 의 관리자가 여러 아이를 가질 수 있습니다, 그것은 비동기 모두 종료합니다. 즉, 어린이가 정리를 동시에 수행하므로 중지 순서가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2fd4a4764c6e535778fe8db9cbb1523710b87e3" translate="yes" xml:space="preserve">
          <source>As a NIF library is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang (alongside port drivers). Calling NIFs requires no context switches. But it is also the least safe, because a crash in a NIF brings the emulator down too.</source>
          <target state="translated">NIF 라이브러리가 에뮬레이터 프로세스에 동적으로 링크되어 있으므로 Erlang (포트 드라이버와 함께)에서 C 코드를 호출하는 가장 빠른 방법입니다. NIF 호출에는 컨텍스트 전환이 필요하지 않습니다. 그러나 NIF 충돌로 인해 에뮬레이터도 다운되기 때문에 가장 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58e7b3f109198992ba59bec647e67726857b68a0" translate="yes" xml:space="preserve">
          <source>As a complement to the &lt;code&gt;set&lt;/code&gt; operation, it is possible to specify a test function. This function has the same syntax as the set operation above, except that the first argument is &lt;code&gt;is_set_ok&lt;/code&gt; instead of &lt;code&gt;set&lt;/code&gt;. This function is called before the variable is set. Its purpose is to ensure that it is permissible to set the variable to the new value.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 작업 의 보완으로 테스트 기능을 지정할 수 있습니다. 이 함수는 첫 번째 인자 인 것을 제외하고는, 설정 동작시 상기와 같은 구문 &lt;code&gt;is_set_ok&lt;/code&gt; 대신 &lt;code&gt;set&lt;/code&gt; . 이 함수는 변수가 설정되기 전에 호출됩니다. 이 변수의 목적은 변수를 새 값으로 설정할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2948bceb43ecea497f0a445923a501687c512364" translate="yes" xml:space="preserve">
          <source>As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;. Thus, the following two patterns match the same set of strings:</source>
          <target state="translated">편리한 속기로서 캡처하지 않은 하위 패턴의 시작 부분에 옵션 설정이 필요한 경우 &quot;?&quot;사이에 옵션 문자가 나타날 수 있습니다. &quot;:&quot;. 따라서 다음 두 패턴은 동일한 문자열 세트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f6848c0bdaadb93a4b8d51c18e19a86434987f9a" translate="yes" xml:space="preserve">
          <source>As a convention, all I/O servers handle both &lt;code&gt;{setopts, [binary]}&lt;/code&gt;, &lt;code&gt;{setopts, [list]}&lt;/code&gt;, and &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt;, hence the trick with &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; and &lt;code&gt;proplists:unfold/1&lt;/code&gt;. If invalid options are sent to us, we send &lt;code&gt;{error, enotsup}&lt;/code&gt; back to the client.</source>
          <target state="translated">일반적으로 모든 I / O 서버는 &lt;code&gt;{setopts, [binary]}&lt;/code&gt; , &lt;code&gt;{setopts, [list]}&lt;/code&gt; 및 &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt; 을 처리하므로 &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; 및 &lt;code&gt;proplists:unfold/1&lt;/code&gt; . 잘못된 옵션이 Google에 전송되면 고객에게 &lt;code&gt;{error, enotsup}&lt;/code&gt; 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="493adbb575cc27e47dde3943edacdea5778a9cf8" translate="yes" xml:space="preserve">
          <source>As a final example we demonstrate the use of &lt;code&gt;driver_async&lt;/code&gt;. We also use the driver term interface. The driver is written in C++. This enables us to use an algorithm from STL. We use the &lt;code&gt;next_permutation&lt;/code&gt; algorithm to get the next permutation of a list of integers. For large lists (&amp;gt; 100,000 elements), this takes some time, so we perform this as an asynchronous task.</source>
          <target state="translated">마지막 예제로 &lt;code&gt;driver_async&lt;/code&gt; 사용을 보여줍니다 . 드라이버 용어 인터페이스도 사용합니다. 드라이버는 C ++로 작성되었습니다. 이를 통해 STL의 알고리즘을 사용할 수 있습니다. &lt;code&gt;next_permutation&lt;/code&gt; 알고리즘을 사용하여 정수 목록의 다음 순열을 가져옵니다. 큰 목록 (&amp;gt; 100,000 개 요소)의 경우 시간이 걸리므로 비동기 작업으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a1f3df7ed28f00795df09b73036126e4e8c30a4d" translate="yes" xml:space="preserve">
          <source>As a hexadecimal number (or an integer). Avoid this as it is easy to misinterpret a &lt;code&gt;BIT STRING&lt;/code&gt; value in this format.</source>
          <target state="translated">16 진수 (또는 정수). 이 형식으로 &lt;code&gt;BIT STRING&lt;/code&gt; 값 을 잘못 해석하기 쉽기 때문에 이것을 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="7085268ee258ef21d5f659dd9a334d1661d8596c" translate="yes" xml:space="preserve">
          <source>As a last resort, the implementation solely based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__sync_*&lt;/code&gt; builtins. This will however cause lots of expensive and unnecessary memory barrier instructions to be issued. That is, performance will suffer. The &lt;code&gt;configure&lt;/code&gt; script will warn at the end of its execution if it cannot find any other alternative than this.</source>
          <target state="translated">최후의 수단으로, 구현은 전적으로 &lt;code&gt;gcc&lt;/code&gt; &lt;code&gt;__sync_*&lt;/code&gt; 내장을 기반으로합니다 . 그러나 이로 인해 많은 비싸고 불필요한 메모리 배리어 명령이 발행됩니다. 즉, 성능이 저하됩니다. &lt;code&gt;configure&lt;/code&gt; 은 이것보다 다른 대안을 찾을 수없는 경우 스크립트의 실행의 끝에서 경고합니다.</target>
        </trans-unit>
        <trans-unit id="ebe4b26b3285c31b7e66a15f34435eba521d186d" translate="yes" xml:space="preserve">
          <source>As a match specification can turn on sequential tracing, the combination of &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;seq_trace&lt;/code&gt; can be quite powerful. This brief example shows a session where sequential tracing is used:</source>
          <target state="translated">일치 스펙이 순차 추적을 &lt;code&gt;seq_trace&lt;/code&gt; 수 있으므로 &lt;code&gt;dbg&lt;/code&gt; 와 seq_trace 의 조합 이 매우 강력 할 수 있습니다. 이 간단한 예는 순차 추적이 사용되는 세션을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="57ca2c648144ecb05c83959a4bb6906fc7dba92e" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;add_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">&lt;code&gt;add_frag&lt;/code&gt; 프로 시저 의 일부로 Mnesia 는 &lt;code&gt;IterFrags&lt;/code&gt; 숫자에 해당하는 모든 조각을 반복하고 각 레코드에 대해 &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; 를 시작합니다 . 새 조각이 이전 조각과 다른 경우 레코드가 새 조각으로 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="afa5aac0272b889e29ab3d3e2445e190b23afd3b" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;del_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">&lt;code&gt;del_frag&lt;/code&gt; 프로 시저 의 일부로 Mnesia 는 &lt;code&gt;IterFrags&lt;/code&gt; 숫자에 해당하는 모든 조각을 반복하고 각 레코드에 대해 &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; 를 시작합니다 . 새 조각이 이전 조각과 다른 경우 레코드가 새 조각으로 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="e1a32b7616ffad81dc2a3990b12ee743d67d1150" translate="yes" xml:space="preserve">
          <source>As a port driver is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang. Calling functions in the port driver requires no context switches. But it is also the least safe way, because a crash in the port driver brings the emulator down too.</source>
          <target state="translated">포트 드라이버는 에뮬레이터 프로세스에 동적으로 연결되므로 Erlang에서 C 코드를 가장 빠르게 호출 할 수 있습니다. 포트 드라이버에서 함수를 호출하면 컨텍스트 전환이 필요하지 않습니다. 그러나 포트 드라이버의 충돌로 인해 에뮬레이터도 다운되기 때문에 가장 안전한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="67c16b741f04ea5b7b054409fb35ff1c48cb01da" translate="yes" xml:space="preserve">
          <source>As a side effect, the function prints the name of each module it tries to compile. If compilation fails for a module, the make procedure stops and &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">부작용으로, 함수는 컴파일하려는 각 모듈의 이름을 인쇄합니다. 모듈에 대한 컴파일이 실패하면 make 프로 시저가 중지되고 &lt;code&gt;error&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bef2be0aff2e7e47dd8199f96ca616049e6fbecf" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;{message, false}&lt;/code&gt; disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the &lt;code&gt;MatchBody&lt;/code&gt; part are desired.</source>
          <target state="translated">특별한 경우, &lt;code&gt;{message, false}&lt;/code&gt; 는 일치 스펙이 일치하지 않는 것처럼이 함수 호출에 대한 추적 메시지 ( 'call'및 'return_to') 전송을 사용하지 않습니다. &lt;code&gt;MatchBody&lt;/code&gt; 부분의 부작용 만 필요한 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="dc75067c89eb230d3aeaa930304e48d7ffc6b8ce" translate="yes" xml:space="preserve">
          <source>As a special case, drivers can be unloaded from processes that have done no corresponding call to &lt;code&gt;try_load/3&lt;/code&gt; if, and only if, there are &lt;strong&gt;no users of the driver at all&lt;/strong&gt;, which can occur if the process containing the last user dies.</source>
          <target state="translated">특별한 경우로, 드라이버 &lt;strong&gt;사용자&lt;/strong&gt; 가 &lt;strong&gt;전혀없는&lt;/strong&gt; 경우에만 &lt;code&gt;try_load/3&lt;/code&gt; 에 대한 해당 호출을 수행하지 않은 프로세스에서 드라이버를 언로드 할 수 있습니다. 이는 마지막 사용자를 포함하는 프로세스가 종료 된 경우 발생할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5a63aa06a92181b3a5ed95aec64c64b4bdd7c17" translate="yes" xml:space="preserve">
          <source>As a special case, the following apply in the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts:</source>
          <target state="translated">특별한 경우 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 부품 에 다음이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="03b85735e71929e52331dbf92e7f4188f735f3c7" translate="yes" xml:space="preserve">
          <source>As a test suite runs, all information (including output to &lt;code&gt;stdout&lt;/code&gt;) is recorded in many different log files. A minimum of information is displayed in the user console (only start and stop information, plus a note for each failed test case).</source>
          <target state="translated">테스트 스위트가 실행되면 모든 정보 ( &lt;code&gt;stdout&lt;/code&gt; 출력 포함 )가 여러 다른 로그 파일에 기록됩니다. 최소한의 정보가 사용자 콘솔에 표시됩니다 (시작 및 중지 정보와 실패한 각 테스트 사례에 대한 메모 만).</target>
        </trans-unit>
        <trans-unit id="af27c23232c9332dfe458eed56f4e4ca1c250964" translate="yes" xml:space="preserve">
          <source>As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; functions, although Dets exports a similar interface.</source>
          <target state="translated">Dets가 수행하는 모든 작업은 디스크 작업이므로 단일 조회 작업에는 일련의 디스크 찾기 및 읽기 작업이 포함된다는 것을 인식해야합니다. Dets 가 비슷한 인터페이스를 내보내지만 Dets 함수 는 해당 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; 함수 보다 훨씬 느립니다 .</target>
        </trans-unit>
        <trans-unit id="eb95848bc99a15bbb0e15871e436bb30c7e336fc" translate="yes" xml:space="preserve">
          <source>As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and &quot;Saturday&quot;.</source>
          <target state="translated">대체 분기가 왼쪽에서 오른쪽으로 시도되고 하위 패턴의 끝에 도달 할 때까지 옵션이 재설정되지 않으므로 한 분기의 옵션 설정이 후속 분기에 영향을 미치므로 위 패턴이 &quot;SUNDAY&quot;및 &quot;Saturday&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3c01043c234b4ec0c86a33f6ba721a734f751f6e" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;-pa&lt;/code&gt;, if several directories are to be prepended to the code path and the directories have a common parent directory, that parent directory can be specified in environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-pa&lt;/code&gt; 에 대한 대안으로 여러 디렉토리를 코드 경로 앞에 추가하고 디렉토리에 공통 상위 디렉토리가있는 경우 해당 상위 디렉토리를 환경 변수 &lt;code&gt;ERL_LIBS&lt;/code&gt; 에 지정할 수 있습니다 . &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88dc064e87e4d93064611ba4390a686486fbcb39" translate="yes" xml:space="preserve">
          <source>As an alternative to building a bootscript, you can explicitly add the path to the SSL &lt;code&gt;ebin&lt;/code&gt; directory on the command line. This is done with command-line option &lt;code&gt;-pa&lt;/code&gt;. This works as the SSL application does not need to be started for the distribution to come up, as a clone of the SSL application is hooked into the Kernel application. So, as long as the SSL application code can be reached, the distribution starts. The &lt;code&gt;-pa&lt;/code&gt; method is only recommended for testing purposes.</source>
          <target state="translated">부트 스크립트를 작성하는 대신 명령 행 에서 SSL &lt;code&gt;ebin&lt;/code&gt; 디렉토리 의 경로를 명시 적으로 추가 할 수 있습니다 . 이것은 명령 행 옵션 &lt;code&gt;-pa&lt;/code&gt; 로 수행 됩니다. SSL 응용 프로그램의 복제본이 커널 응용 프로그램에 연결되어 있으므로 배포를 시작하기 위해 SSL 응용 프로그램을 시작할 필요가 없으므로 작동합니다. 따라서 SSL 애플리케이션 코드에 도달 할 수있는 한 분배가 시작됩니다. &lt;code&gt;-pa&lt;/code&gt; 의 메소드는 테스트 목적으로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="99c43706bedf3f37ba2bc1f77eaef7f141bffa35" translate="yes" xml:space="preserve">
          <source>As an alternative to sorting files, a function of one argument can be specified as input. When called with argument &lt;code&gt;read&lt;/code&gt;, the function is assumed to return either of the following:</source>
          <target state="translated">파일 정렬에 대한 대안으로 하나의 인수 함수를 입력으로 지정할 수 있습니다. 인수 &lt;code&gt;read&lt;/code&gt; 로 호출 하면 함수는 다음 중 하나를 리턴한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="aa2f69a7cd9917454bfd5b22b175f310f6d2bfae" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-callback&lt;/code&gt; and &lt;code&gt;-optional_callbacks&lt;/code&gt; attributes you may directly implement and export &lt;code&gt;behaviour_info()&lt;/code&gt;:</source>
          <target state="translated">받는 대안으로 &lt;code&gt;-callback&lt;/code&gt; 및 &lt;code&gt;-optional_callbacks&lt;/code&gt; 속성을 직접 구현하고 수출 할 수있다 &lt;code&gt;behaviour_info()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c35ac71302602496215802d2ceb07a268d8ab46b" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on the host at the other end of the TCP socket.</source>
          <target state="translated">대안으로, 이미 열린 TCP 소켓이 &lt;code&gt;TcpSocket&lt;/code&gt; 의 함수로 전달 될 수 있습니다 . SSH 시작 및 협상이 시작되고 마지막으로 TCP 소켓의 다른 쪽 끝에있는 호스트에서 쉘이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="310627ae72667d56b80e90bfe9262f70c174ac28" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one when an SSH starts at the other end of the TCP socket.</source>
          <target state="translated">대안으로, 이미 열린 TCP 소켓이 &lt;code&gt;TcpSocket&lt;/code&gt; 의 함수로 전달 될 수 있습니다 . SSH 시작 및 협상은 SSH가 TCP 소켓의 다른 쪽 끝에서 시작될 때 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="273b6d8022e0a14e661c5ebb9acfcaf89acecfbc" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one with the SSH that should be at the other end.</source>
          <target state="translated">대안으로, 이미 열린 TCP 소켓이 &lt;code&gt;TcpSocket&lt;/code&gt; 의 함수로 전달 될 수 있습니다 . SSH 시작 및 협상은 다른 쪽 끝에 있어야하는 SSH를 사용하여 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d2d299871acdd7ed8b13c9605799bbdca8d746" translate="yes" xml:space="preserve">
          <source>As an example let's add the Diffie-Hellman Group1 first in the kex list. It is supported according to &lt;code&gt;Supported algoritms&lt;/code&gt;.</source>
          <target state="translated">예를 들어 kex 목록에서 Diffie-Hellman Group1을 먼저 추가하겠습니다. &lt;code&gt;Supported algoritms&lt;/code&gt; 에 따라 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fed952b378ed463bdf14ff665fe8061e73af37b" translate="yes" xml:space="preserve">
          <source>As an example of analyzing indirect calls, the following Erlang function tries to answer the question: if we want to know which modules are used indirectly by some module(s), is it worth while using the &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; rather than the module graph? Recall that a module M1 is said to call a module M2 if there is some function in M1 that calls some function in M2. It would be nice if we could use the much smaller module graph, since it is available also in the light weight &lt;code&gt;modules&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of Xref servers.</source>
          <target state="translated">간접 호출을 분석하는 예로 다음과 같은 Erlang 함수가 질문에 답하려고합니다. 어떤 모듈이 어떤 모듈을 간접적으로 사용하는지 알고 싶다면 모듈 &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; 아닌 함수 그래프 를 사용하는 동안 가치가 있습니까? M1에 M2에서 일부 함수를 호출하는 함수가 있으면 모듈 M1이 모듈 M2를 호출한다고합니다. Xref 서버의 경량 &lt;code&gt;modules&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 에서도 사용 가능하므로 훨씬 작은 모듈 그래프를 사용할 수 있다면 좋을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c9dcf4f61625ae0867c30f6f2ec1a54ebcaa12ae" translate="yes" xml:space="preserve">
          <source>As an example of how the function can be used, we create an interpreted escript that uses &lt;code&gt;emu_args&lt;/code&gt; to set some emulator flag. In this case, it happens to disable the &lt;code&gt;smp_support&lt;/code&gt;. We also extract the different sections from the newly created script:</source>
          <target state="translated">함수를 사용하는 방법의 예를 들어, 우리는 사용 된 것으로 해석 escript 만들 &lt;code&gt;emu_args&lt;/code&gt; 는 일부 에뮬레이터 플래그를 설정합니다. 이 경우 &lt;code&gt;smp_support&lt;/code&gt; 가 비활성화 됩니다 . 또한 새로 만든 스크립트에서 다른 섹션을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="93e8253d4bef52c01714100b16613baca9f2eb65" translate="yes" xml:space="preserve">
          <source>As an example of how to use function &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;, the implementation of a QLC table for the &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; module is given:</source>
          <target state="translated">function &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; 를 사용하는 방법에 대한 예제로 &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; 모듈에 대한 QLC 테이블 구현 이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d7686e8d3cae0d8b83f082414847869122b1c718" translate="yes" xml:space="preserve">
          <source>As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair &lt;code&gt;{3,4}&lt;/code&gt;, where character positions are zero-based, just as in offsets:</source>
          <target state="translated">기본 동작의 예로, 다음 호출은 주제의 일치하는 부분 (가운데 &quot;abcd&quot;)을 색인 쌍 &lt;code&gt;{3,4}&lt;/code&gt; 로 첫 번째 및 캡처 된 문자열로 리턴합니다 . 여기서 문자 위치는 0입니다. 오프셋과 마찬가지로</target>
        </trans-unit>
        <trans-unit id="1363c4916ced9b1c12e495d959e392b062a979b7" translate="yes" xml:space="preserve">
          <source>As an example of these rules, suppose you want to write the function &lt;code&gt;select&lt;/code&gt;, which selects certain elements from a list of tuples. Suppose you write &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; with the intention of extracting all tuples from &lt;code&gt;L&lt;/code&gt;, where the first item is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">이러한 규칙의 예로 튜플 목록에서 특정 요소를 선택하는 &lt;code&gt;select&lt;/code&gt; 함수를 작성한다고 가정 하십시오 . 가정 당신은 쓰기 &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; &lt;code&gt;L&lt;/code&gt; 에서 모든 튜플을 추출하기 위해 첫 번째 항목은 &lt;code&gt;X&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d77fac41d8f6ac13e4c80ca8e1c35a37d97d30a" translate="yes" xml:space="preserve">
          <source>As an example, assume that the old maximum number of files is 10 and that the new maximum number of files is 6. If the current file number is not greater than the new maximum number of files, files 7-10 are removed when file 6 is full and the log starts to write to file number 1 again. Otherwise, the files greater than the current file are removed when the current file is full (for example, if the current file is 8, files 9 and 10 are removed). The files between the new maximum number of files and the current file (that is, files 7 and 8) are removed the next time file 6 is full.</source>
          <target state="translated">예를 들어, 이전 최대 파일 수는 10이고 새 최대 파일 수는 6이라고 가정하십시오. 현재 파일 수가 새 최대 파일 수보다 크지 않으면 파일 6에서 파일 7-10이 제거됩니다. 이 가득 차서 로그가 파일 번호 1에 다시 쓰기 시작합니다. 그렇지 않으면 현재 파일이 가득 찼을 때 현재 파일보다 큰 파일이 제거됩니다 (예 : 현재 파일이 8 인 경우 파일 9 및 10이 제거됨). 새로운 최대 파일 수와 현재 파일 (즉, 파일 7 및 8) 사이의 파일은 다음에 파일 6이 가득 찰 때 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6df1dd563dff5d559d5237ab7b1799899d2a4427" translate="yes" xml:space="preserve">
          <source>As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms.</source>
          <target state="translated">예를 들어, 디스크 로그 파일에서 용어를 정렬하십시오. 디스크 로그에서 청크를 읽고 이진 목록을 반환하는 함수가 입력으로 사용됩니다. 결과는 용어 목록으로 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="9ef05760a87925d5316892398ba7e6735c0cc668" translate="yes" xml:space="preserve">
          <source>As an example, consider the following record definition:</source>
          <target state="translated">예를 들어, 다음 레코드 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0bace29d40d7981ee102e27dfe23de3fe372b080" translate="yes" xml:space="preserve">
          <source>As an example, contemplate the issue of converting between upper and lower case letters. Reading the standard makes you realize that there is not a simple one to one mapping in all scripts, for example:</source>
          <target state="translated">예를 들어, 대문자와 소문자 사이의 변환 문제를 고려하십시오. 표준을 읽으면 모든 스크립트에 간단한 일대일 매핑이 없다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e81b4992cba2b699d381459f734b8216213b6b3" translate="yes" xml:space="preserve">
          <source>As an example, list comprehensions can be used to simplify some of the functions in &lt;code&gt;lists.erl&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 목록 이해는 &lt;code&gt;lists.erl&lt;/code&gt; 일부 기능을 단순화하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1e3067854a4c9b6a2c74afda818dcdb334e651b" translate="yes" xml:space="preserve">
          <source>As an example, one can insert an object with &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; as a key in an &lt;code&gt;ordered_set&lt;/code&gt; and get the object returned as a result of doing a &lt;code&gt;lookup/2&lt;/code&gt; with &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; as the key to search for.</source>
          <target state="translated">예를 들어, &lt;code&gt;ordered_set&lt;/code&gt; 에 &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; 을 키로 사용 하는 객체를 삽입하고 검색 키로 &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; 을 사용하여 &lt;code&gt;lookup/2&lt;/code&gt; 를 수행 한 결과로 객체를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66fc66c449548ea231626daea7c93210ea8cbc49" translate="yes" xml:space="preserve">
          <source>As an example, one can let trace messages be sent over the network to another Erlang node (preferably &lt;strong&gt;not&lt;/strong&gt; distributed), where the formatting occurs:</source>
          <target state="translated">예를 들어, 추적 메시지가 네트워크를 통해 다른 Erlang 노드 (바람직하게 &lt;strong&gt;는&lt;/strong&gt; 분배 &lt;strong&gt;되지 않음&lt;/strong&gt; ) 로 전송되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7c1111ab56bf671a69f40fa390abccb417d88d6" translate="yes" xml:space="preserve">
          <source>As an example, suppose that you want to start a slave node at host &lt;code&gt;H&lt;/code&gt; with node name &lt;code&gt;Name@H&lt;/code&gt; and want the slave node to have the following properties:</source>
          <target state="translated">예를 들어, 노드 이름이 &lt;code&gt;Name@H&lt;/code&gt; 호스트 &lt;code&gt;H&lt;/code&gt; 에서 슬레이브 노드를 시작하고 슬레이브 노드에 다음과 같은 속성이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8f6e43ba50d78085627070b9be2ee7833e58261c" translate="yes" xml:space="preserve">
          <source>As an example, the I/O server for the interactive shell (in &lt;code&gt;group.erl&lt;/code&gt;) understands the following options:</source>
          <target state="translated">예를 들어, 대화식 쉘의 I / O 서버 ( &lt;code&gt;group.erl&lt;/code&gt; )는 다음 옵션을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="d726847c4d6dbe66ba80230721adc5bfacc18e04" translate="yes" xml:space="preserve">
          <source>As an example, we will use the following function, that you may recognise as a slightly modified benchmark function from the manpage file(3):</source>
          <target state="translated">예를 들어, 맨 페이지 파일 (3)에서 약간 수정 된 벤치 마크 함수로 인식 할 수 있도록 다음 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="67171017e640943dfb29d4cbec09fb767fa51114" translate="yes" xml:space="preserve">
          <source>As an snmp adaption usually keeps the index for the whole of the systems lifetime, this is rarely a problem.</source>
          <target state="translated">snmp 적응은 일반적으로 전체 시스템 수명 동안 인덱스를 유지하기 때문에 거의 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="319bb3abd29884b1375ba09774a3c06c1a190a13" translate="yes" xml:space="preserve">
          <source>As another example, consider concatenating the answers to two queries &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; while removing all duplicates. This is accomplished by using option &lt;code&gt;unique&lt;/code&gt;:</source>
          <target state="translated">다른 예로, 모든 중복을 제거하면서 두 쿼리 &lt;code&gt;QH1&lt;/code&gt; 및 &lt;code&gt;QH2&lt;/code&gt; 에 대한 답변을 연결하는 것을 고려하십시오 . 이것은 &lt;code&gt;unique&lt;/code&gt; 옵션을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="002e4414e669ace8432711f4ee7463efc45a9f68" translate="yes" xml:space="preserve">
          <source>As any other type of scripts, Erlang scripts do not work on Unix platforms if the execution bit for the script file is not set. (To turn on the execution bit, use &lt;code&gt;chmod +x script-name&lt;/code&gt;.)</source>
          <target state="translated">다른 유형의 스크립트와 마찬가지로 Erlang 스크립트는 스크립트 파일의 실행 비트가 설정되지 않은 경우 Unix 플랫폼에서 작동하지 않습니다. 실행 비트를 켜려면 &lt;code&gt;chmod +x script-name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66b2e146ed4ec9e49f678bedfee3350f88534599" translate="yes" xml:space="preserve">
          <source>As any variable that occurs in the head of a fun is considered a new variable, it is equally valid to write as follows:</source>
          <target state="translated">재미의 머리에서 발생하는 모든 변수는 새로운 변수로 간주되므로 다음과 같이 쓰는 것도 똑같이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="90f853228a72190e3c182428d8aa021055665aa1" translate="yes" xml:space="preserve">
          <source>As can be noted above, the parameter list can be matched against a single &lt;code&gt;MatchVariable&lt;/code&gt; or an &lt;code&gt;'_'&lt;/code&gt;. To replace the whole parameter list with a single variable is a special case. In all other cases the &lt;code&gt;MatchHead&lt;/code&gt; must be a &lt;strong&gt;proper&lt;/strong&gt; list.</source>
          <target state="translated">위에서 알 수 있듯이 매개 변수 목록은 단일 &lt;code&gt;MatchVariable&lt;/code&gt; 또는 &lt;code&gt;'_'&lt;/code&gt; 과 일치시킬 수 있습니다 . 전체 매개 변수 목록을 단일 변수로 바꾸는 것은 특별한 경우입니다. 다른 모든 경우에는 &lt;code&gt;MatchHead&lt;/code&gt; 가 &lt;strong&gt;올바른&lt;/strong&gt; 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f45447aff436963dfcba66b79f762faf452d90b1" translate="yes" xml:space="preserve">
          <source>As can be seen from the figures above there is no real difference between a non-reentrant and an reentrant flex scanner when it comes to the decode times of an individual message.</source>
          <target state="translated">위의 그림에서 볼 수 있듯이 개별 메시지의 디코딩 시간과 관련하여 재진입과 비 진입 플렉스 스캐너 사이에는 실질적인 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f43e75c9b3fbee4477b49b641a7fb630b3c13f5" translate="yes" xml:space="preserve">
          <source>As can be seen, the fun used with &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; takes a single list as parameter instead of a single tuple. The list matches a list of the parameters to the traced function. A single variable can also be used. The body of the fun expresses, in a more imperative way, actions to be taken if the fun head (and the guards) matches. &lt;code&gt;true&lt;/code&gt; is returned here, only because the body of a fun cannot be empty. The return value is discarded.</source>
          <target state="translated">알 수 있듯이 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 과 함께 사용되는 재미 는 단일 튜플 대신 단일 목록을 매개 변수로 사용합니다. 이 목록은 매개 변수 목록을 추적 된 기능과 일치시킵니다. 단일 변수를 사용할 수도 있습니다. 재미의 몸은 재미 머리 (및 경비원)가 일치하는 경우 취해야 할 조치를보다 필수적으로 표현합니다. 재미의 본문은 비워 둘 수 없으므로 &lt;code&gt;true&lt;/code&gt; 가 여기에 리턴됩니다. 반환 값은 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="606f60b3cba3318c2eecb57b2a49a6b6b1a39eb6" translate="yes" xml:space="preserve">
          <source>As can be seen, the functions above are just the type of functions that are to be provided in &lt;code&gt;get_until&lt;/code&gt; requests.</source>
          <target state="translated">알 수 있듯이 위의 함수는 &lt;code&gt;get_until&lt;/code&gt; 요청에 제공되는 함수 유형 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="191e8e1e5a9e73a6798b23edb476be7abc2c9de8" translate="yes" xml:space="preserve">
          <source>As default result sets are returned as a lists of tuples. The &lt;code&gt;TupleMode&lt;/code&gt; option still exists to keep some degree of backwards compatibility. If the option is set to off, result sets will be returned as a lists of lists instead of a lists of tuples.</source>
          <target state="translated">기본 결과 집합으로 튜플 목록으로 반환됩니다. &lt;code&gt;TupleMode&lt;/code&gt; 의 옵션은 여전히 이전 버전과의 호환성을 어느 정도 유지하기 위해 존재한다. 옵션이 off로 설정된 경우 결과 세트는 튜플 목록 대신 목록 목록으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="17700b7b2c5191dc7a064a620902163dd840f68f" translate="yes" xml:space="preserve">
          <source>As described in Robert's paper, I/O servers and clients communicate using &lt;code&gt;io_request&lt;/code&gt;/&lt;code&gt;io_reply&lt;/code&gt; tuples as follows:</source>
          <target state="translated">Robert의 백서에 설명 된대로 I / O 서버 및 클라이언트 는 다음과 같이 &lt;code&gt;io_request&lt;/code&gt; / &lt;code&gt;io_reply&lt;/code&gt; 튜플을 사용하여 통신 합니다.</target>
        </trans-unit>
        <trans-unit id="d5e4f17183134fe62fa988455bb38a208a7f52d2" translate="yes" xml:space="preserve">
          <source>As documented, the election assumes knowledge of a peer's DiameterIdentity when initiating a connection, which diameter doesn't require. Connections will be accepted if configuration allows multiple connections per peer to be established or there is no existing connection. Note that the election process is only applicable when multiple connections per peer is disallowed.</source>
          <target state="translated">기록 된 바와 같이, 선거는 직경을 필요로하지 않는 연결을 시작할 때 동료의 DiameterIdentity에 대한 지식을 가정합니다. 구성에서 피어 당 여러 연결을 설정할 수 있거나 기존 연결이없는 경우 연결이 허용됩니다. 선택 프로세스는 피어 당 여러 연결이 허용되지 않는 경우에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5435f11ff35ae6054509834ff9cbbd3dacb50a82" translate="yes" xml:space="preserve">
          <source>As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. &lt;code&gt;gen_event&lt;/code&gt; is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with &lt;code&gt;Reason&lt;/code&gt;, or returns a bad value &lt;code&gt;Term&lt;/code&gt;, the event manager does not fail. It deletes the event handler by calling callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt;, giving as argument &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. No other event handler is affected.</source>
          <target state="translated">각 이벤트 핸들러는 하나의 콜백 모듈이므로 이벤트 관리자에는 동적으로 추가 및 삭제되는 많은 콜백 모듈이 있습니다. 따라서 &lt;code&gt;gen_event&lt;/code&gt; 는 다른 동작보다 콜백 모듈 오류에 더 관대합니다. 설치된 이벤트 핸들러의 콜백 함수가 &lt;code&gt;Reason&lt;/code&gt; 과 함께 실패 하거나 잘못된 값 &lt;code&gt;Term&lt;/code&gt; 을 리턴 하면 이벤트 관리자가 실패하지 않습니다. 콜백 함수 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 각각 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 또는 &lt;code&gt;{error,Term}&lt;/code&gt; 인수로 이벤트 핸들러를 삭제합니다 . 다른 이벤트 핸들러는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf9e38f9c03cb4cfe6ebeed4a9cd9c1754bcff3e" translate="yes" xml:space="preserve">
          <source>As evaluating this function causes the process to terminate, it has no return value unless the arguments are invalid, in which case the function &lt;strong&gt;returns the error reason&lt;/strong&gt;&lt;code&gt;badarg&lt;/code&gt;. If you want to be sure not to return, you can call &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; and hope to distinguish exceptions later.</source>
          <target state="translated">이 함수를 평가하면 프로세스가 종료되므로 인수가 유효하지 않으면 리턴 값이 없습니다.이 경우 함수 &lt;strong&gt;는 오류 이유 &lt;/strong&gt; &lt;code&gt;badarg&lt;/code&gt; 를&lt;strong&gt;리턴합니다&lt;/strong&gt; . 반환하지 않으려면 &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; 호출 하고 나중에 예외를 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2842aa39be48bf38b0c0560d59180375acac20be" translate="yes" xml:space="preserve">
          <source>As everyone trying to use &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;dbg&lt;/code&gt; seems to end up reading this manual page, this description is an introduction to the concept of match specifications.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;dbg&lt;/code&gt; 를 사용하려는 모든 사람 이이 매뉴얼 페이지를 읽은 것으로 보이므로이 설명은 일치 스펙 개념에 대한 소개입니다.</target>
        </trans-unit>
        <trans-unit id="91ed2cd090a035beba9495ca5c354901e71094c0" translate="yes" xml:space="preserve">
          <source>As expected, double of 10 is 20.</source>
          <target state="translated">예상대로 10의 두 배는 20입니다.</target>
        </trans-unit>
        <trans-unit id="4e58a012dddf03e3db23dd481662a4b03cf78027" translate="yes" xml:space="preserve">
          <source>As far as we know by the time of writing, it is infeasible to break &lt;code&gt;des3_cbc&lt;/code&gt; encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information &lt;strong&gt;should&lt;/strong&gt; be safe from intruders.</source>
          <target state="translated">글을 쓰는 시점까지 아는 한 키에 대한 지식없이 &lt;code&gt;des3_cbc&lt;/code&gt; 암호화 를 깨는 것은 불가능합니다 . 따라서 키를 안전하게 유지하고 추측 할 수없는 한 암호화 된 디버그 정보 &lt;strong&gt;는&lt;/strong&gt; 침입자로부터 안전 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9f24794a82149383ffae0568581aa4a52378ab67" translate="yes" xml:space="preserve">
          <source>As file times are stored in POSIX time on most OS, it is faster to query file information with option &lt;code&gt;posix&lt;/code&gt;.</source>
          <target state="translated">대부분의 OS에서 파일 시간이 POSIX 시간으로 저장되므로 &lt;code&gt;posix&lt;/code&gt; 옵션을 사용하여 파일 정보를 쿼리하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="61df7f84fe1d4826c5be72f8b4bc768821e8d381" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;i/1&lt;/code&gt; and &lt;code&gt;ni/1&lt;/code&gt;, a module can be specified by its module name or filename.</source>
          <target state="translated">관해서 &lt;code&gt;i/1&lt;/code&gt; 및 &lt;code&gt;ni/1&lt;/code&gt; , 모듈은 그 모듈 명이나 파일명에 의해 지정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="3a8f23a48e1867cb7be6b7e031f9615ed3dd2a0d" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;select&lt;/code&gt;, the table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</source>
          <target state="translated">관해서 &lt;code&gt;select&lt;/code&gt; 테이블을 호출하여 이송되는 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; . 차이점은 일치 스펙이 명시 적으로 지정된다는 것입니다. QLC에서 제공하는 구문 내에서 쉽게 표현할 수없는 일치 스펙을 명시하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f0387e8c16bce6477d55e9ca9b7e7cb6c002c7dd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</source>
          <target state="translated">ERTS 5.10부터 프로세스에서 포트로의 모든 신호는 실제로 비동기 적으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e9113f3079af7b202922889fc7baf1985e8c3b0f" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.5 (Erlang / OTP R11B)에서와 같이이 값에는 현재 예약 된 프로세스의 현재 시간 조각에서 수행 된 감소가 포함되지 않습니다. 정확한 값을 원하면 &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9466fb03b2f8f448def70765eb14302f05b1d4a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</source>
          <target state="translated">ERTS 5.5.2에서와 같이 출구 신호는 공정에 따라 비동기 적으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0d8b23980173959043ec4b6b8e4640034ae1c36c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="translated">ERTS 5.5.3부터 드라이버 인터페이스가 확장되었습니다 ( &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt; 참조 ). 확장 인터페이스는 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; , 드라이버 초기화시 기능 플래그 ( &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt; 참조 )를 런타임 시스템에 전달할 수있는 가능성 및 일부 새로운 드라이버 API 기능을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="19ca09aeee3e5a4978501284aa2a30557b389ea8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">ERTS 5.5.3에서 버전 인터페이스 및 기능 정보를 전달할 수있는 가능성으로 드라이버 인터페이스가 확장되었습니다. 기능 플래그는 48 행에 존재합니다. ERTS 5.7.4에서와 같이 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 플래그 는 배포에 사용되는 드라이버에 필요합니다. soft busy 플래그는 드라이버가 사용중으로 표시되었지만 &lt;code&gt;output&lt;/code&gt; 및 &lt;code&gt;outputv&lt;/code&gt; 콜백 에 대한 호출을 처리 할 수 ​​있음을 의미합니다 . 이는 배포판에서 사용하는 드라이버에 대한 요구 사항 이었지만 이전에는 이에 대한 기능 정보가 없었습니다. 자세한 내용은. &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a78fa09b1376522e4bce196c1fb535907b82e7d" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.4.3 the default stack size for threads in the async-thread pool is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the amount of async-threads can be quite large. The default stack size is enough for drivers delivered with Erlang/OTP, but is possibly not sufficiently large for other dynamically linked-in drivers that use the &lt;code&gt;driver_async&lt;/code&gt; functionality. A suggested stack size for threads in the async-thread pool can be configured through command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.5.4.3에서 비동기 스레드 풀의 스레드에 대한 기본 스택 크기는 16 킬로 워드, 즉 32 비트 아키텍처에서 64 킬로바이트입니다. 비동기 스레드의 양이 상당히 클 수 있으므로이 작은 기본 크기가 선택되었습니다. 기본 스택 크기는 Erlang / OTP와 함께 제공되는 드라이버에는 충분하지만 &lt;code&gt;driver_async&lt;/code&gt; 기능 을 사용하는 다른 동적으로 링크 된 드라이버에는 충분하지 않을 수 있습니다. 비동기 스레드 풀의 스레드에 제안 된 스택 크기 는 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; 를 통해 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6e9cd2bd7de01214fb3ff560ba3219fdc3a33fd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than &lt;code&gt;temp_alloc&lt;/code&gt;. This because it only causes problems for other allocators.</source>
          <target state="translated">ERTS 5.6.1부터 에뮬레이터는 &lt;code&gt;temp_alloc&lt;/code&gt; 이외의 다른 할당 자에서이 전략을 사용하지 않습니다 . 다른 할당 자에게만 문제가되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c9cdb7d3c60a1b802e1be9fa56092fa96daa0110" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; requires that all &lt;code&gt;erts_alloc(3)&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">ERTS 5.6.4에서와 같이 &lt;code&gt;erlang:memory/0&lt;/code&gt; 에서는 모든 &lt;code&gt;erts_alloc(3)&lt;/code&gt; 할당자가 사용 가능해야합니다 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="0648017001664f8866e87e3887eab6500d7d8d5c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; requires that all &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">ERTS 5.6.4에서와 같이 &lt;code&gt;erlang:memory/1&lt;/code&gt; 에서는 모든 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 할당자가 사용 가능해야합니다 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="03c3044d6f35884274a0ea9ce93bcb4a6dd2e7b8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This protocol introduced the distribution header. Nodes with an ERTS version earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache are used.</source>
          <target state="translated">ERTS 5.7.2에서와 같이 기존 아톰 캐시 프로토콜이 삭제되고 새로운 프로토콜이 도입되었습니다. 이 프로토콜은 배포 헤더를 도입했습니다. ERTS 5.7.2 이전 버전의 노드는 여전히 새 노드와 통신 할 수 있지만 분배 헤더 및 아톰 캐시는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0bf3fb747dbb4638699932cce5b52da0fd8c732" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the runtime system passes a distribution flag in the handshake stage that enables the use of a &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; on all messages passed. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">ERTS 5.7.2에서와 같이 런타임 시스템은 전달 된 모든 메시지 에서 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있도록 핸드 셰이크 단계에서 분배 플래그를 전달합니다. 이 경우 노드간에 전달 된 메시지는 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="32ca42b8d63db763c29dc94fc4d01b222bd06006" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9 (Erlang / OTP R15B)에서와 같이 드라이버 인터페이스는 콜백 &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 대해 더 큰 유형으로 변경되었습니다 . &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; 의 드라이버 &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed0ea6cc1d812d63e5d244adc339b28e36e76666" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors. For more information, see system flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9 (Erlang / OTP R15B)에서와 같이 런타임 시스템은 기본적으로 스케줄러를 논리 프로세서에 바인드 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 자세한 정보는 시스템 플래그 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90a69eabde7b774111db809b2a3f8cd2e6d93bb9" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9에서와 같이 이전 드라이버는 다시 컴파일하고 확장 인터페이스를 사용해야합니다. 또한 &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt; 로 조정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d18bc1c72ccf3f56d64803c503d7a9ae14a8c4e0" translate="yes" xml:space="preserve">
          <source>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes that still execute the old code is killed by this function. In earlier versions, such incorrect use could cause much more fatal failures, like emulator crash.</source>
          <target state="translated">ERTS 8.0 (Erlang / OTP 19)과 마찬가지로 이전 코드를 계속 실행하는 느린 프로세스는이 기능으로 인해 종료됩니다. 이전 버전에서는 이러한 잘못된 사용으로 인해 에뮬레이터 충돌과 같은 훨씬 더 치명적인 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa0884ce96d8d06eafbfe246ea264efc463f164" translate="yes" xml:space="preserve">
          <source>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode characters and are always encoded using the UTF-8 external formats &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;. The old Latin-1 formats &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; are deprecated and are only kept for backward compatibility when decoding terms encoded by older nodes.</source>
          <target state="translated">ERTS 9.0 (OTP 20)부터 원자는 임의의 유니 코드 문자를 포함 할 수 있으며 항상 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; UTF-8 외부 형식을 사용하여 인코딩됩니다 . 이전 라틴 -1 형식 &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; 는 더 이상 사용되지 않으며 이전 노드로 인코딩 된 용어를 디코딩 할 때 이전 버전과의 호환성을 위해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="432b2e5b8c0948df031dfa90355327eda74cb917" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt;System principles&lt;/code&gt; in System Documentation.</source>
          <target state="translated">Erlang / OTP 17에서와 같이 OTP 릴리스 번호는 주요 OTP 버전 번호에 해당합니다. &lt;code&gt;erlang:system_info()&lt;/code&gt; 인수는 정확한 OTP 버전을 제공 하지 않습니다 . 일반적인 경우 정확한 OTP 버전을 결정하기가 어렵 기 때문입니다. 자세한 내용 은 시스템 설명서 에서 &lt;code&gt;System principles&lt;/code&gt; 의 버전 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a73c626964af738d0bf5772ed44b01c65f1937d2" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 18 (ERTS 7.0) the time functionality has been extended. This includes a &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; for time and &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; that change the system behavior when system time changes.</source>
          <target state="translated">Erlang / OTP 18 (ERTS 7.0)부터 시간 기능이 확장되었습니다. 여기에는 시스템 시간이 변경 될 때 시스템 동작을 변경하는 시간 및 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; 를 위한 &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ecb4c90c54fe542574fe5a3d1dc6ac0bee28192e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;String&lt;/code&gt; may contain any Unicode character. Earlier versions allowed only ISO-latin-1 characters as the implementation did not allow Unicode characters above 255. For more information on Unicode support in atoms, see &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">Erlang / OTP 20에서와 같이, &lt;code&gt;String&lt;/code&gt; 은 임의의 유니 코드 문자를 포함 할 수 있습니다. 구현에서 255보다 큰 유니 코드 문자를 허용하지 않기 때문에 이전 버전에서는 ISO-latin-1 문자 만 허용했습니다. 원자에서의 유니 코드 지원에 대한 자세한 내용 은 사용자 안내서의 &quot;외부 용어 형식&quot;섹션 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; 에 대한 참고 사항을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a96169a26804822b5af1efdb6e68b574110fb9b3" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; is capable of encoding any Unicode character. Earlier versions would fail if the binary contained Unicode characters &amp;gt; 255. For more information about Unicode support in atoms, see the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">Erlang / OTP 20에서와 같이 &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; 은 모든 유니 코드 문자를 인코딩 할 수 있습니다. 바이너리에 유니 코드 문자&amp;gt; 255가 포함 된 경우 이전 버전이 실패합니다. 원자에서의 유니 코드 지원에 대한 자세한 내용은 사용자 안내서의 &quot;외부 용어 형식&quot;섹션 &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; 에 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="880a395a4cc835daf564a6c2cb8b779237ad447e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, atoms can contain any Unicode character and &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; may fail if the text representation for &lt;code&gt;Atom&lt;/code&gt; contains a Unicode character &amp;gt; 255.</source>
          <target state="translated">얼랑 / OTP 20으로 원자 유니 코드 문자가 포함될 수 &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; 에 대한 텍스트 표현이 실패 할 경우 &lt;code&gt;Atom&lt;/code&gt; 유니 코드 문자&amp;gt; (255)를 포함한다.</target>
        </trans-unit>
        <trans-unit id="05e99f10299c611eb38d2e60ef290380c488aab4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 21.0, a field width of value &lt;code&gt;0&lt;/code&gt; can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example:</source>
          <target state="translated">Erlang / OTP 21.0에서와 같이, 값이 &lt;code&gt;0&lt;/code&gt; 인 필드 너비를 사용하여 줄이 무한히 길어 지도록 지정할 수 있습니다. 즉, 줄 바꿈이 삽입되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="201cedcfe08f8b8dd67e3f18b939fb9656e57837" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="translated">Erlang / OTP R13A에서와 같이 &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; 함수에 제공된 데이터 는 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 형식 이어야 합니다. 즉,이 기능에 바이너리를 제공하는 프로그램은 I / O 장치에서 데이터를 출력하기 전에 UTF-8로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d33e90079df692505b294a1290c3639aac4d952d" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_close/1&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Erlang / OTP R16에서와 같이 &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; 는 실제로 비동기입니다. 이 작업은 항상 비동기 작업으로 문서화되었지만 기본 구현은 동기식입니다. 그러나 &lt;code&gt;port_close/1&lt;/code&gt; 은 오류 동작으로 인해 여전히 완전히 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="847e19f07a1da0af86460018529c6ed10c09d277" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_command/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Erlang / OTP R16에서와 같이 &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; 는 실제로 비동기입니다. 이 작업은 항상 비동기 작업으로 문서화되었지만 기본 구현은 동기식입니다. 그러나 &lt;code&gt;port_command/2&lt;/code&gt; 는 오류 동작으로 인해 여전히 완전히 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca95bf5c29d60d3f435edb308337e14ca27dfa7" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_connect/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Erlang / OTP R16에서와 같이 &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; 는 실제로 비동기입니다. 이 작업은 항상 비동기 작업으로 문서화되었지만 기본 구현은 동기식입니다. 그러나 &lt;code&gt;port_connect/2&lt;/code&gt; 는 오류 동작으로 인해 여전히 완전히 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="72f6bdc7a49b76220d72f254a24c40ac2103b81f" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, Erlang source files can be written in UTF-8 or bytewise (&lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt;) encoding. For information about how to state the encoding of an Erlang source file, see the &lt;code&gt;epp(3)&lt;/code&gt; module. As from Erlang/OTP R16, strings and comments can be written using Unicode. As from Erlang/OTP 20, also atoms and functions can be written using Unicode. Modules, applications, and nodes must still be named using characters from the ISO Latin-1 character set. (These restrictions in the language are independent of the encoding of the source file.)</source>
          <target state="translated">Erlang / OTP R16에서와 같이 Erlang 소스 파일은 UTF-8 또는 바이트 단위 ( &lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt; ) 인코딩 으로 작성할 수 있습니다 . Erlang 소스 파일의 인코딩 상태에 대한 정보는 &lt;code&gt;epp(3)&lt;/code&gt; 모듈을 참조하십시오 . Erlang / OTP R16에서와 같이 문자열과 주석은 유니 코드를 사용하여 작성할 수 있습니다. Erlang / OTP 20에서와 같이 원자와 함수도 유니 코드를 사용하여 작성할 수 있습니다. 모듈, 응용 프로그램 및 노드는 여전히 ISO Latin-1 문자 세트의 문자를 사용하여 이름을 지정해야합니다. 언어의 이러한 제한은 소스 파일의 인코딩과 무관합니다.</target>
        </trans-unit>
        <trans-unit id="7886b46a773db0e50442aecaebbaf32b222b9fd4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the whole Unicode range by supplying startup flag &lt;code&gt;+pc latin1&lt;/code&gt; or &lt;code&gt;+pc unicode&lt;/code&gt;, respectively. For backward compatibility, &lt;code&gt;latin1&lt;/code&gt; is default. This only controls how heuristic string detection is done. More ranges are expected to be added in the future, enabling tailoring of the heuristics to the language and region relevant to the user.</source>
          <target state="translated">Erlang / OTP R16B에서와 같이 시작 플래그 &lt;code&gt;+pc latin1&lt;/code&gt; 또는 &lt;code&gt;+pc unicode&lt;/code&gt; 를 각각 제공하여 ISO Latin-1 범위 또는 전체 유니 코드 범위를 선택할 수 있습니다 . 이전 버전과의 호환성을 위해 &lt;code&gt;latin1&lt;/code&gt; 이 기본값입니다. 이 방법은 휴리스틱 문자열 감지 방법을 제어합니다. 추후 더 많은 범위가 추가되어 휴리스틱을 사용자와 관련된 언어 및 지역에 맞게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="716bfb66439cef7ad7bad31829606da528f05b26" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R9C, the &lt;code&gt;abstract_code&lt;/code&gt; chunk contains &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt;, where &lt;code&gt;AbstractCode&lt;/code&gt; is the abstract code as described in this section.</source>
          <target state="translated">Erlang / OTP R9C에서와 같이 &lt;code&gt;abstract_code&lt;/code&gt; 청크에는 &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt; 가 포함되어 있습니다 . 여기서 &lt;code&gt;AbstractCode&lt;/code&gt; 는이 섹션에서 설명 된 추상 코드입니다.</target>
        </trans-unit>
        <trans-unit id="79439af412211da1e82f500e663913d9e02afa8d" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, and ERTS version 5.5.4, the following is guaranteed:</source>
          <target state="translated">커널 버전 2.11.4 및 ERTS 버전 5.5.4에서 다음이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="e6086f606b9a19f3992ba56f0349c22f46bc841b" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, subscriptions can also be made before the &lt;code&gt;net_kernel&lt;/code&gt; server is started, that is, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; does not return &lt;code&gt;ignored&lt;/code&gt;.</source>
          <target state="translated">전과 커널 버전 2.11.4에서 다른 이름으로, 구독도 할 수 &lt;code&gt;net_kernel&lt;/code&gt; 서버가 시작이라고, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; 반환하지 않습니다 &lt;code&gt;ignored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12edcd68388680c33d418efadc851c1c0e7b367" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.13, and ERTS version 5.7, the following is guaranteed:</source>
          <target state="translated">커널 버전 2.13 및 ERTS 버전 5.7에서 다음이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="2c683a693696d1ac1e9f3a076bd2cf07e0602bc8" translate="yes" xml:space="preserve">
          <source>As from R14A and forward, the compiler resolves calls without module prefix to local or imported functions before trying with auto-imported BIFs. If the BIF is to be called, use the &lt;code&gt;erlang&lt;/code&gt; module prefix in the call, not &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt;.</source>
          <target state="translated">R14A 이상에서와 같이 컴파일러는 자동으로 가져온 BIF를 사용하기 전에 모듈 접두어가없는 호출을 로컬 또는 가져온 함수로 해결합니다. BIF를 호출하려면 &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt; 아니라 호출에서 &lt;code&gt;erlang&lt;/code&gt; 모듈 접 두부를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="23bc1a56d40682c98cebd327d476b5499f2bfa45" translate="yes" xml:space="preserve">
          <source>As from beginning with R14A, the compiler no longer calls the auto-imported BIF if the name clashes with a local or explicitly imported function, and a call without explicit module name is issued. Instead, the local or imported function is called. Still accepting &lt;code&gt;nowarn_bif_clash&lt;/code&gt; would make a module calling functions clashing with auto-imported BIFs compile with both the old and new compilers, but with completely different semantics. This is why the option is removed.</source>
          <target state="translated">R14A부터 시작하여 이름이 로컬 또는 명시 적으로 가져온 함수와 충돌하고 명시적인 모듈 이름이없는 호출이 발행되면 컴파일러는 더 이상 자동으로 가져온 BIF를 호출하지 않습니다. 대신 로컬 또는 가져온 함수가 호출됩니다. &lt;code&gt;nowarn_bif_clash&lt;/code&gt; 를 여전히 수용 하면 자동으로 가져온 BIF와 충돌하는 함수를 호출하는 모듈이 이전 컴파일러와 새 컴파일러로 컴파일되지만 완전히 다른 의미로 컴파일됩니다. 이것이 옵션이 제거 된 이유입니다.</target>
        </trans-unit>
        <trans-unit id="8624ad0f786ca708e353d31a82300424a2da173c" translate="yes" xml:space="preserve">
          <source>As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well.</source>
          <target state="translated">함수는 관계이므로 마지막 항목 (도메인, 범위 등)의 정의는 함수에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="07695f74f1c383a64bbc45b6016faa64c5986911" translate="yes" xml:space="preserve">
          <source>As illustrated, properties can be combined. If, for example, &lt;code&gt;shuffle&lt;/code&gt;, &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, and &lt;code&gt;sequence&lt;/code&gt; are all specified, the test cases in the group are executed repeatedly, and in random order, until a test case fails. Then execution is immediately stopped and the remaining cases are skipped.</source>
          <target state="translated">도시 된 바와 같이, 특성들이 결합 될 수있다. 예를 들어, &lt;code&gt;shuffle&lt;/code&gt; , &lt;code&gt;repeat_until_any_fail&lt;/code&gt; 및 &lt;code&gt;sequence&lt;/code&gt; 가 모두 지정된 경우 그룹의 테스트 케이스는 테스트 케이스가 실패 할 때까지 임의 순서로 반복 실행됩니다. 그런 다음 실행이 즉시 중지되고 나머지 사례는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="68fe7148f0f6ccc13bf1a24fdc690584b0a600f5" translate="yes" xml:space="preserve">
          <source>As illustrated, the two directories reside on different nodes, because &lt;code&gt;/ldisc/scratch&lt;/code&gt; (the &quot;local&quot; disc) exists on the two different nodes.</source>
          <target state="translated">그림과 같이 &lt;code&gt;/ldisc/scratch&lt;/code&gt; ( &quot;로컬&quot;디스크)가 두 개의 다른 노드에 있기 때문에 두 개의 디렉토리 는 다른 노드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2998e8a048230bd280f5294610d17bc1bd53ffb" translate="yes" xml:space="preserve">
          <source>As in &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to be specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">에서와 같이 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;mp()&lt;/code&gt; 옵션으로 컴파일 &lt;code&gt;unicode&lt;/code&gt; 필요 &lt;code&gt;Subject&lt;/code&gt; 유니 코드로 &lt;code&gt;charlist()&lt;/code&gt; . 컴파일이 내재적으로 수행되고 &lt;code&gt;unicode&lt;/code&gt; 컴파일 옵션이이 함수에 지정된 경우 정규식과 &lt;code&gt;Subject&lt;/code&gt; 모두 유효한 유니 코드 &lt;code&gt;charlist()&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="466e0ad8d0c7cbd5f38b33d59e9622626664550d" translate="yes" xml:space="preserve">
          <source>As in Erlang, messages can be sent to a pid or to a registered name. It is easier to send a message to a registered name, as it avoids the problem of finding a suitable pid.</source>
          <target state="translated">Erlang과 마찬가지로 메시지를 pid 또는 등록 된 이름으로 보낼 수 있습니다. 적합한 pid를 찾는 데 문제가 없으므로 등록 된 이름으로 메시지를 보내는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a4d88e181201a03cc3fb7ded4e3d176b1c280bd5" translate="yes" xml:space="preserve">
          <source>As in construction, the order in which the key and value expressions are evaluated is not defined. The syntactic order of the key-value pairs in the update is of no relevance, except in the case where two keys match. In that case, the latter value is used.</source>
          <target state="translated">구성에서와 같이 키 및 값 표현식이 평가되는 순서는 정의되지 않습니다. 업데이트에서 키-값 쌍의 구문 순서는 두 키가 일치하는 경우를 제외하고는 관련이 없습니다. 이 경우 후자의 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc2ecf4ab7dc9e0eae158ae04299a70b115b03c8" translate="yes" xml:space="preserve">
          <source>As in function &lt;code&gt;run/3&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">함수에서와 마찬가지로 &lt;code&gt;run/3&lt;/code&gt; , &lt;code&gt;mp()&lt;/code&gt; 옵션으로 컴파일 &lt;code&gt;unicode&lt;/code&gt; 필요 &lt;code&gt;Subject&lt;/code&gt; 유니 코드로 &lt;code&gt;charlist()&lt;/code&gt; . 컴파일이 내재적으로 수행되고 &lt;code&gt;unicode&lt;/code&gt; 컴파일 옵션이이 함수에 지정된 경우 정규식과 &lt;code&gt;Subject&lt;/code&gt; 모두 유효한 유니 코드 &lt;code&gt;charlist()&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3af4e7ec9b32aca75bcf09376c862c57bf6062d9" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적인 Erlang 일치와 마찬가지로 &quot;일치 내부 일치&quot;, 즉 a &lt;code&gt;=&lt;/code&gt; 를 사용하여 변수를 전체 일치 오브젝트에 바인딩 할 수 있습니다 . 불행히도 사양과 일치하도록 번역 된 펀에서는 &quot;최상위 수준&quot;에서만 허용됩니다. 즉, 도착 하는 &lt;strong&gt;전체&lt;/strong&gt; 객체가 개별 변수와 일치하도록 일치합니다. 직접 일치 스펙을 작성하는 데 익숙한 경우 변수 A는 단순히 '$ _'로 변환됩니다. 또는 의사 함수 &lt;code&gt;object/0&lt;/code&gt; 도 일치하는 전체 객체를 반환합니다 ( &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="c43013c670a4d6155374f58258fab04f5fbbc072" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;erl_free_compound()&lt;/code&gt; ensures that the complete term pointed to by &lt;code&gt;ep&lt;/code&gt; is released. This is necessary because the pointer from the second call to &lt;code&gt;erl_format&lt;/code&gt; is lost.</source>
          <target state="translated">이전 예에서와 같이 Erlang 용어에 할당 된 메모리를 해제하는 것은 귀하의 책임입니다. 이 예에서 &lt;code&gt;erl_free_compound()&lt;/code&gt; 는 &lt;code&gt;ep&lt;/code&gt; 가 가리키는 완전한 용어 가 해제되도록합니다. &lt;code&gt;erl_format&lt;/code&gt; 에 대한 두 번째 호출의 포인터 가 유실 되므로이 작업 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d26ac3436bd27f40dd7ea34e33f65a20575923b6" translate="yes" xml:space="preserve">
          <source>As in the previous section the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="translated">이전 섹션에서와 같이 PEM 파일 &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; 에는 서버 인증서와 개인 키가 모두 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="debb8560047fb0b42a46cc59f3c825a91b4209ba" translate="yes" xml:space="preserve">
          <source>As indicated by the name, emulator flags control the behavior of the emulator.</source>
          <target state="translated">이름으로 표시된대로 에뮬레이터 플래그는 에뮬레이터의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="6f49bed7fb11b494819d4e36cc0258b2b542e095" translate="yes" xml:space="preserve">
          <source>As long as all character sets were limited to 256 characters, each character could be stored in one single byte, so there was more or less only one practical encoding for the characters. Encoding each character in one byte was so common that the encoding was not even named. With the Unicode system there are much more than 256 characters, so a common way is needed to represent these. The common ways of representing the code points are the encodings. This means a whole new concept to the programmer, the concept of character representation, which was a non-issue earlier.</source>
          <target state="translated">모든 문자 세트가 256 자로 제한되는 한, 각 문자는 하나의 단일 바이트에 저장 될 수 있으므로 문자에 대한 실제 인코딩은 하나만 존재합니다. 각 문자를 1 바이트로 인코딩하는 것은 너무 일반적이어서 인코딩의 이름도 지정되지 않았습니다. 유니 코드 시스템에는 256자를 넘는 문자가 있으므로이를 나타내는 일반적인 방법이 필요합니다. 코드 포인트를 나타내는 일반적인 방법은 인코딩입니다. 이것은 프로그래머에게 전혀 새로운 개념, 즉 문자 표현의 개념을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9b7153107281cf1e02599d91bf8553499b75800f" translate="yes" xml:space="preserve">
          <source>As long as real identifiers are correct, it is OK to pass a CPU topology that is not a correct description of the CPU topology. When used with care this can be very useful. This to trick the emulator to bind its schedulers as you want. For example, if you want to run multiple Erlang runtime systems on the same machine, you want to reduce the number of schedulers used and manipulate the CPU topology so that they bind to different logical CPUs. An example, with two Erlang runtime systems on a quad core machine:</source>
          <target state="translated">실제 식별자가 올바른 한 CPU 토폴로지에 대한 올바른 설명이 아닌 CPU 토폴로지를 전달하는 것이 좋습니다. 주의해서 사용하면 매우 유용 할 수 있습니다. 이것은 에뮬레이터가 원하는대로 스케줄러를 바인딩하도록 속입니다. 예를 들어, 동일한 시스템에서 여러 Erlang 런타임 시스템을 실행하려는 경우 사용 된 스케줄러 수를 줄이고 CPU 토폴로지가 다른 논리 CPU에 바인드되도록 조작합니다. 쿼드 코어 머신에 두 개의 Erlang 런타임 시스템이있는 예 :</target>
        </trans-unit>
        <trans-unit id="3a4531be2cf765e3ef8b54b63b05d246b380ee1c" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;ftp&lt;/code&gt; application is operational, the FTP sessions are supervised and can be soft code upgraded.</source>
          <target state="translated">로 오랫동안로 &lt;code&gt;ftp&lt;/code&gt; 응용 프로그램이 작동의 FTP 세션이 감독하고 부드러운 코드를 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b05ddb8fa8f81edfa35269196a6d393612d35a2a" translate="yes" xml:space="preserve">
          <source>As long as the data is always lists, modifier &lt;code&gt;t&lt;/code&gt; can be used for any string, but when binary data is involved, care must be taken to make the correct choice of formatting characters. A bytewise-encoded binary is also interpreted as a string, and printed even when using &lt;code&gt;~ts&lt;/code&gt;, but it can be mistaken for a valid UTF-8 string. Avoid therefore using the &lt;code&gt;~ts&lt;/code&gt; control if the binary contains bytewise-encoded characters and not UTF-8.</source>
          <target state="translated">데이터가 항상리스트 인 한 모디파이어 &lt;code&gt;t&lt;/code&gt; 는 모든 문자열에 사용될 수 있지만, 이진 데이터가 관련된 경우 올바른 형식의 문자를 선택하도록주의를 기울여야합니다. 바이트 단위로 인코딩 된 이진은 문자열로 해석되어 &lt;code&gt;~ts&lt;/code&gt; 사용할 때도 인쇄 되지만 유효한 UTF-8 문자열로 오인 될 수 있습니다. 따라서 바이너리에 UTF-8이 아닌 바이트 단위 인코딩 문자가 포함 된 경우 &lt;code&gt;~ts&lt;/code&gt; 컨트롤을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="38beb3decd97936c9d002a776141659553006a04" translate="yes" xml:space="preserve">
          <source>As long as the length of the message queue is lower than this value, all log events are handled asynchronously. This means that the client process sending the log event, by calling a log function in the &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt;, does not wait for a response from the handler but continues executing immediately after the event is sent. It is not affected by the time it takes the handler to print the event to the log device. If the message queue grows larger than this value, the handler starts handling log events synchronously instead, meaning that the client process sending the event must wait for a response. When the handler reduces the message queue to a level below the &lt;code&gt;sync_mode_qlen&lt;/code&gt; threshold, asynchronous operation is resumed. The switch from asynchronous to synchronous mode can slow down the logging tempo of one, or a few, busy senders, but cannot protect the handler sufficiently in a situation of many busy concurrent senders.</source>
          <target state="translated">메시지 큐의 길이가이 값보다 작 으면 모든 로그 이벤트가 비동기 적으로 처리됩니다. 즉, &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; 에서 로그 함수를 호출하여 클라이언트가 로그 이벤트를 전송 하면 처리기의 응답을 기다리지 않고 이벤트가 전송 된 직후에 계속 실행됩니다. 핸들러가 이벤트를 로그 장치에 인쇄하는 데 걸리는 시간의 영향을받지 않습니다. 메시지 큐가이 값보다 커지면 핸들러는 대신 로그 이벤트 처리를 동 기적으로 시작합니다. 즉, 이벤트를 보내는 클라이언트 프로세스가 응답을 기다려야합니다. 핸들러가 메시지 큐를 &lt;code&gt;sync_mode_qlen&lt;/code&gt; 아래 레벨로 줄인 경우임계 값, 비동기 작업이 재개됩니다. 비동기 모드에서 동기 모드로 전환하면 한 명 또는 몇 명의 통화중인 발신자의 로깅 템포가 느려질 수 있지만 많은 통화중인 동시 발신자의 상황에서는 처리기를 충분히 보호 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb54073b5c596b75c4d1032a2bc0e471288f7302" translate="yes" xml:space="preserve">
          <source>As long as there are no more than 16 schedulers, there will never be any lock contention on the port lock for the driver.</source>
          <target state="translated">스케줄러가 16 개를 넘지 않는 한 드라이버의 포트 잠금에는 잠금 경합이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4b29322baa56d4c7a0700a6dec611b4da2d64c8" translate="yes" xml:space="preserve">
          <source>As many options are silently discarded by the stack if they are specified out of range; it can be a good idea to check that a raw option is accepted. The following code places the value in variable &lt;code&gt;TcpLinger2:&lt;/code&gt;</source>
          <target state="translated">범위를 벗어난 경우 많은 옵션이 스택에서 자동으로 삭제됩니다. 원시 옵션이 허용되는지 확인하는 것이 좋습니다. 다음 코드는 변수 &lt;code&gt;TcpLinger2:&lt;/code&gt; 값을 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="cde1dbb415595f7822eb3d191139162bdd23a109" translate="yes" xml:space="preserve">
          <source>As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as</source>
          <target state="translated">일치가 왼쪽에서 오른쪽으로 진행됨에 따라 PCRE는 주제에서 각 &quot;a&quot;를 찾은 후 다음 패턴이 나머지 패턴과 일치하는지 확인합니다. 패턴이 다음과 같이 지정된 경우</target>
        </trans-unit>
        <trans-unit id="6ca1c79babb9a0075f407b28d68680d2a199070e" translate="yes" xml:space="preserve">
          <source>As md5 is not available in FIPS mode it is only possible to use certificates that were signed using sha hashing. When validating an entire certificate chain all certificates (including the root CA's) must comply with this rule.</source>
          <target state="translated">md5는 FIPS 모드에서 사용할 수 없으므로 sha 해싱을 사용하여 서명 된 인증서 만 사용할 수 있습니다. 전체 인증서 체인의 유효성을 검사 할 때는 모든 인증서 (루트 CA 포함)가이 규칙을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7c08fa4650f0a0fe94395e21e9822cf60a9f2f7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a script can contains precompiled &lt;code&gt;beam&lt;/code&gt; code. In a precompiled script, the interpretation of the script header is the same as in a script containing source code. This means that you can make a &lt;code&gt;beam&lt;/code&gt; file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In a precompiled script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported.</source>
          <target state="translated">앞에서 언급했듯이 스크립트는 사전 컴파일 된 &lt;code&gt;beam&lt;/code&gt; 코드를 포함 할 수 있습니다 . 사전 컴파일 된 스크립트에서 스크립트 헤더의 해석은 소스 코드를 포함하는 스크립트에서와 동일합니다. 이것은 파일에 &lt;code&gt;#!&lt;/code&gt; 으로 시작하는 줄을 붙여서 &lt;code&gt;beam&lt;/code&gt; 파일을 실행 가능 하게 만들 수 있음을 의미합니다 . 그리고 &lt;code&gt;%%!&lt;/code&gt; 위에 언급했듯이. 사전 컴파일 된 스크립트에서 &lt;code&gt;main/1&lt;/code&gt; 함수를 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="64feb9f4a1acc565bd79ae07225ce3ec20e86066" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt;List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="translated">앞에서 언급했듯이 쿼리는 Erlang Reference Manual의 &lt;code&gt;Expressions&lt;/code&gt; 섹션에 설명 된대로 목록 이해 구문으로 표현 됩니다. 다음에서는 목록 이해에 대해 어느 정도 친숙하다고 가정합니다. 프로그래밍 예제의 &lt;code&gt;List Comprehensions&lt;/code&gt; 섹션에 있는 예제를 통해 시작할 수 있습니다. 리스트 이해는 언어에 계산 능력을 추가하지 않습니다. 목록 이해를 통해 수행 할 수있는 모든 작업도 수행 할 수 있습니다. 그러나 간단한 검색 문제를 표현하기위한 구문을 추가하는데, 일단 익숙해지면 간단하고 명확합니다.</target>
        </trans-unit>
        <trans-unit id="dcc63d308b096795c5804a0be71fa661e287ba90" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, segments have the following general syntax:</source>
          <target state="translated">앞에서 언급했듯이 세그먼트에는 다음과 같은 일반적인 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d171b0ef9d17830114bdb2e45fbb538d0990d4" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="translated">이 섹션의 시작 부분 에있는 &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; 텍스트에서 언급했듯이 드라이버 콜백이 상대적으로 빠르게 반환되는 것이 매우 중요합니다. 드라이버 콜백이 작동 할 수있는 정확한 최대 시간을 제공하는 것은 어렵지만 일반적으로 올바르게 작동하는 드라이버 콜백은 1 밀리 초 이내에 반환됩니다. 이것은 다른 접근법을 사용하여 달성 할 수 있습니다. 드라이버 콜백에서 실행할 코드를 완전히 제어 할 수있는 가장 좋은 방법은 작업을 여러 작업 덩어리로 나누고 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; 0으로 시간 초과 콜백 에 대한 여러 호출을 트리거하는 것 입니다. &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; 함수이러한 시간 제한 콜백 호출을 트리거 할시기를 결정하는 데 유용 할 수 있습니다. 그러나 때로는 타사 라이브러리를 호출 할 때와 같이이 방법으로 구현할 수 없습니다. 이 경우 일반적으로 작업을 다른 스레드로 발송하려고합니다. 스레드 기본 요소에 대한 정보는 아래에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="870908039e217eddb9cd9dd34c7a2a0d9565d41f" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this manual page, it is of &lt;strong&gt;vital importance&lt;/strong&gt; that a native function returns relatively fast. It is difficult to give an exact maximum amount of time that a native function is allowed to work, but usually a well-behaving native function is to return to its caller within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times. This is, however, not always possible, for example when calling third-party libraries.</source>
          <target state="translated">이 매뉴얼 페이지의 시작 부분 에있는 &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; 텍스트에서 언급했듯이 기본 기능이 상대적으로 빠르게 반환되는 &lt;strong&gt;것이 매우 중요&lt;/strong&gt; 합니다. 기본 함수가 작동 할 수있는 정확한 최대 시간을 제공하는 것은 어렵지만 일반적으로 올바르게 작동하는 기본 함수는 1 밀리 초 내에 호출자에게 리턴하는 것입니다. 이것은 다른 접근법을 사용하여 달성 할 수 있습니다. 기본 함수에서 실행할 코드를 완전히 제어 할 수있는 경우 가장 좋은 방법은 작업을 여러 작업 덩어리로 나누고 기본 함수를 여러 번 호출하는 것입니다. 그러나 타사 라이브러리를 호출 할 때 항상 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0d72cf22161ff39dc24cc56c84b763eb1ee94488" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are exists other erlang open source alternatives.</source>
          <target state="translated">현재 &lt;code&gt;Inets&lt;/code&gt; 5.0 HTTP 서버를 시작하기 쉽습니다 / 정지 및 가장 기본적인 웹 서버 기능을 제공하는 사용자 정의 웹 서버. Inets는 임베디드 시스템 용으로 설계되었으며 본격적인 웹 서버를 원한다면 다른 erlang 오픈 소스 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0209ca89965504887d9fa6f1d52589a2103d8bad" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retranspissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="translated">ERTS 버전 10.0부터 배포 컨트롤러 프로세스에 대한 지원이 도입되었습니다. 즉, 배포 채널을 통한 트래픽은 포트가 아닌 프로세스로 관리 할 수 ​​있습니다. 이를 통해 Erlang 코드에서 로직의 많은 부분을 구현할 수 있으며 프로토콜에 대해 새로운 드라이버가 필요하지 않을 수도 있습니다. 예를 들어 &lt;code&gt;gen_udp&lt;/code&gt; 를 사용하여 UDP를 통한 Erlang 배포가 있습니다 (Erlang 코드는 물론이 예에서 재 변환 등을 처리해야합니다). 즉, 원하는 작업에 따라 드라이버를 전혀 구현할 필요가 없으며 아래의 드라이버 관련 섹션을 건너 뛸 수 있습니다. &lt;code&gt;gen_tcp_dist&lt;/code&gt; 예에서 설명한 &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; 섹션은 배포 컨트롤러 프로세스를 활용하며 배포 컨트롤러 프로세스를 사용 하려는지 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c85a6ebe0161eb5757b5cd028db5ba4081c57741" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of &lt;code&gt;erlang:check_process_code/3&lt;/code&gt;, which is used in order to determine this.</source>
          <target state="translated">ERTS 버전 9.0부터 프로세스는 코드에 대한 직접 참조가있는 경우에만 코드에 남아있는 것으로 간주됩니다. 자세한 정보 는이를 판별하기 위해 사용되는 &lt;code&gt;erlang:check_process_code/3&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="990b2f43003907f6ffa2fd600f8b8c5f6d4c0c81" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">ERTS 버전 9.0부터 더티 CPU 스케줄러도 결과에 포함됩니다. 즉, CPU 바운드 작업을 처리 할 것으로 예상되는 모든 스케줄러 스레드입니다. 더티 I / O 스케줄러에 대한 정보도 원하는 경우 &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="924b8134638ed9edf16b9abf6ee2f7cc8660dc0a" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the Erlang runtime system will as default have more schedulers than logical processors. This due to the dirty schedulers.</source>
          <target state="translated">ERTS 버전 9.0부터 Erlang 런타임 시스템에는 기본적으로 논리 프로세서보다 많은 스케줄러가 있습니다. 이것은 더러운 스케줄러 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cf90680c064454d2c96d45dd08744df7108b0b29" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the check process code operation only checks for direct references to the code. Indirect references via &lt;code&gt;fun&lt;/code&gt;s will be ignored. If such &lt;code&gt;fun&lt;/code&gt;s exist and are used after a purge of the old code, an exception will be raised upon usage (same as the case when the &lt;code&gt;fun&lt;/code&gt; is received by the process after the purge). Literals will be taken care of (copied) at a later stage. This behavior can as of ERTS version 8.1 be enabled when &lt;code&gt;building OTP&lt;/code&gt;, and will automatically be enabled if dirty scheduler support is enabled.</source>
          <target state="translated">ERTS 버전 9.0부터 검사 프로세스 코드 조작은 코드에 대한 직접 참조 만 검사합니다. &lt;code&gt;fun&lt;/code&gt; 을 통한 간접 참조 는 무시됩니다. 이러한 &lt;code&gt;fun&lt;/code&gt; 가 존재하고 이전 코드를 제거한 후에 사용되는 경우 사용시 예외가 발생합니다 ( 퍼지 후 프로세스 에서 &lt;code&gt;fun&lt;/code&gt; 를받는 경우와 동일 ). 리터럴은 이후 단계에서 처리 (복사)됩니다. 이 동작은 &lt;code&gt;building OTP&lt;/code&gt; 시 ERTS 버전 8.1부터 활성화 될 수 있으며 더티 스케줄러 지원이 활성화되면 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f4e1d3eb137cab5087aa6346ca40170ec41e8ce0" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 17, most applications deliver a valid application upgrade file (&lt;code&gt;appup&lt;/code&gt;). In earlier releases, a majority of the applications in Erlang/OTP did not support upgrade. Many of the applications use the &lt;code&gt;restart_application&lt;/code&gt; instruction. These are applications for which it is not crucial to support real soft upgrade, for example, tools and library applications. The &lt;code&gt;restart_application&lt;/code&gt; instruction ensures that all modules in the application are reloaded and thereby running the new code.</source>
          <target state="translated">Erlang / OTP 17부터 대부분의 응용 프로그램은 유효한 응용 프로그램 업그레이드 파일 ( &lt;code&gt;appup&lt;/code&gt; )을 제공합니다. 이전 릴리스에서는 Erlang / OTP의 대부분의 응용 프로그램에서 업그레이드를 지원하지 않았습니다. 많은 응용 프로그램이 &lt;code&gt;restart_application&lt;/code&gt; 명령을 사용합니다 . 도구 및 라이브러리 응용 프로그램과 같이 실제 소프트 업그레이드를 지원하는 것이 중요하지 않은 응용 프로그램입니다. &lt;code&gt;restart_application&lt;/code&gt; 의 명령은 응용 프로그램의 모든 모듈을 다시로드하여 새 코드를 실행하는 것을 보장한다.</target>
        </trans-unit>
        <trans-unit id="3896e9860076cb6efc826bd1af4282cf215a66b2" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 21.0, the concept of SASL reports is removed, meaning that the default behaviour is as follows:</source>
          <target state="translated">Erlang / OTP 21.0부터 SASL 보고서 개념이 제거되어 기본 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5156993619ca489fb8cfd9ed4a3335d7b4428f29" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP R16, messages sent to ports are delivered truly asynchronously. The underlying implementation previously delivered messages to ports synchronously. Message passing has however always been documented as an asynchronous operation. Hence, this is not to be an issue for an Erlang program communicating with ports, unless false assumptions about ports have been made.</source>
          <target state="translated">Erlang / OTP R16부터 포트로 전송 된 메시지는 진정으로 비동기 적으로 전달됩니다. 기본 구현은 이전에 메시지를 포트에 동 기적으로 전달했습니다. 그러나 메시지 전달은 항상 비동기 작업으로 문서화되었습니다. 따라서 포트에 대한 잘못된 가정이 없으면 Erlang 프로그램이 포트와 통신하는 데는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db7deccbe166e540f0b707dd76ed8fd8300520de" translate="yes" xml:space="preserve">
          <source>As of OTP 17.0 application versions use the same &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; as the OTP version. Application versions part of a release candidate will however not have an &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; suffix as the OTP version. Also note that a major increment in an application version does not necessarily imply a major increment of the OTP version. This depends on whether the major change in the application is considered as a major change for OTP as a whole or not.</source>
          <target state="translated">OTP 17.0부터 애플리케이션 버전 은 OTP 버전과 동일한 &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; 를 사용합니다 . 그러나 릴리스 후보의 응용 프로그램 버전 부분 에는 OTP 버전으로 &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; 접미사 가 없습니다 . 또한 응용 프로그램 버전에서 큰 증가가 반드시 OTP 버전의 큰 증가를 의미하지는 않습니다. 이는 응용 프로그램의 주요 변경 사항이 OTP의 전체 변경 사항으로 간주되는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e6a68f9772c180bbf4b9650571adc55b4582fbcd" translate="yes" xml:space="preserve">
          <source>As of OTP release 17, the OTP release number corresponds to the major part of the OTP version. The OTP version as a concept was introduced in OTP 17. The version scheme used is described in detail in &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTP 릴리스 17부터 OTP 릴리스 번호는 OTP 버전의 주요 부분에 해당합니다. 개념으로 OTP 버전은 OTP (17)에 자세히 설명되어 사용되는 버전 방식에 도입 된 &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2be4113be53a8f180a26c5c4f8137c8f0b13cc" translate="yes" xml:space="preserve">
          <source>As of R15B01, the dynamic trace code is included in the OTP source distribution, although it's considered experimental. The main development of the dtrace code still happens outside of Ericsson, but there is no need to fetch a patched version of the OTP source to get the basic functionality.</source>
          <target state="translated">R15B01부터는 동적 추적 코드가 실험적인 것으로 간주되지만 OTP 소스 배포에 포함됩니다. dtrace 코드의 주요 개발은 여전히 ​​Ericsson 외부에서 발생하지만 기본 기능을 얻기 위해 패치 된 버전의 OTP 소스를 가져올 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3175e151baddb9462eaca8a3103721b845c4be90" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. This function is used to convert to the old (pre-4.4) info format.</source>
          <target state="translated">버전 4.4부터 정보 형식이 변경되었습니다. 이 기능은 이전 (4.4 이전) 정보 형식으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc18a1e131252e89f07716dc1f6c84f4f113e552" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. To convert the info to the old format, call the &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">버전 4.4부터 정보 형식이 변경되었습니다. 정보를 이전 형식으로 변환하려면 &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0806b3a57271c3368eb538cbf78e42f66a7befe" translate="yes" xml:space="preserve">
          <source>As operators are not terms in their own right, when operators are mentioned below, the representation of an operator is to be taken to be the atom with a printname consisting of the same characters as the operator.</source>
          <target state="translated">연산자는 그 자체로 용어가 아니므로 아래에서 연산자를 언급 할 때 연산자의 표현은 연산자와 동일한 문자로 구성된 인쇄 이름을 가진 원자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="27aa2715207bd314b837c8f9f949d9e43e3fe153" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-M&lt;/code&gt;, except that the Makefile is written to &lt;code&gt;Makefile&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">옵션으로 &lt;code&gt;-M&lt;/code&gt; , 메이크가 기록 된 것을 제외하고 &lt;code&gt;Makefile&lt;/code&gt; . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d10554b44799b09a5d688a7590a7e6f973d1129" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-MT&lt;/code&gt;, except that characters special to &lt;code&gt;make/1&lt;/code&gt; are quoted.</source>
          <target state="translated">&lt;code&gt;make/1&lt;/code&gt; 에 특수 문자 가 인용 되는 것을 제외하고 옵션 &lt;code&gt;-MT&lt;/code&gt; 로 .</target>
        </trans-unit>
        <trans-unit id="b8f789d4c76adaa6e3ad489f09dfb73a7ef05683" translate="yes" xml:space="preserve">
          <source>As parameter &lt;code&gt;Config&lt;/code&gt; is a list of key-value tuples, that is, a data type called a property list, it can be handled by the &lt;code&gt;proplists&lt;/code&gt; module. A value can, for example, be searched for and returned with function &lt;code&gt;proplists:get_value/2&lt;/code&gt;. Also, or alternatively, the general &lt;code&gt;lists&lt;/code&gt; module contains useful functions. Normally, the only operations performed on &lt;code&gt;Config&lt;/code&gt; is insert (adding a tuple to the head of the list) and lookup. &lt;code&gt;Common Test&lt;/code&gt; provides a simple macro named &lt;code&gt;?config&lt;/code&gt;, which returns a value of an item in &lt;code&gt;Config&lt;/code&gt; given the key (exactly like &lt;code&gt;proplists:get_value&lt;/code&gt;). Example: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;Config&lt;/code&gt; 는 키-값 튜플의 목록, 즉 속성 목록이라고하는 데이터 유형이므로 &lt;code&gt;proplists&lt;/code&gt; 모듈에서 처리 할 수 ​​있습니다 . 예를 들어, &lt;code&gt;proplists:get_value/2&lt;/code&gt; 함수를 사용하여 값을 검색하고 리턴 할 수 있습니다 . 또한, 또는 대안 적으로, 일반 &lt;code&gt;lists&lt;/code&gt; 모듈은 유용한 기능을 포함한다. 일반적으로 &lt;code&gt;Config&lt;/code&gt; 에서 수행되는 유일한 작업 은 삽입 (목록의 헤드에 튜플 추가) 및 조회입니다. &lt;code&gt;Common Test&lt;/code&gt; 라는 간단한 매크로를 제공 &lt;code&gt;?config&lt;/code&gt; 에서 항목의 값을 반환 &lt;code&gt;Config&lt;/code&gt; (정확히 같은 키 제공 &lt;code&gt;proplists:get_value&lt;/code&gt; ). 예: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e768910eb46b5bf1b56cc0b04701d6e5fb8dd7f" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">앞에서 설명한 것처럼 여기에 나열된 테이블 액세스 작업을 수행하는 FUN (Functional Object)은 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt; 함수에 인수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="697d56b55fb0573091be8112b03dc468b6978a3a" translate="yes" xml:space="preserve">
          <source>As previously explained, this specification can also be provided by an entry like the following in a configuration file:</source>
          <target state="translated">앞에서 설명한 것처럼이 스펙은 구성 파일에 다음과 같은 항목으로 제공 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4c831da626efb451c44f834caf79dfb78dcdf6" translate="yes" xml:space="preserve">
          <source>As previously stated, the locking strategy used by &lt;code&gt;Mnesia&lt;/code&gt; is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use &lt;code&gt;Mnesia&lt;/code&gt; mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</source>
          <target state="translated">앞서 언급 한 것처럼 &lt;code&gt;Mnesia&lt;/code&gt; 에서 사용하는 잠금 전략 은 레코드를 읽을 때 하나의 레코드를 잠그고 레코드를 쓸 때 레코드의 모든 복제본을 잠그는 것입니다. 그러나 일부 응용 프로그램은 내결함성 품질을 위해 &lt;code&gt;Mnesia&lt;/code&gt; 를 주로 사용 합니다. 이러한 응용 프로그램은 모든 과중한 작업을 수행하는 하나의 노드와 기본 노드가 실패 할 경우 인수 할 준비가 된 대기 노드로 구성 할 수 있습니다. 이러한 응용 프로그램은 일반적인 잠금 구성표 대신 고정 잠금을 사용하면 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d595490ab4714d8a9871d8a09a973dfea9d0d3d" translate="yes" xml:space="preserve">
          <source>As received in the &lt;code&gt;stream_start message&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;stream_start message&lt;/code&gt; 에서 수신 한대로</target>
        </trans-unit>
        <trans-unit id="fd5870133105312565312c6b2ab7ff3fd841d30a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 의해 반환 &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b46cebaae7c70180ee044bb55a1784247c2f3b67" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; 에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="6563f22087e6266633a8cc2568e501f807ea6a94" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt; 에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="613b92ac4a60557f480687125ac1a95cb659b564" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; 에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5ba5543136150606738a5ee102fcd04508cc21b" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 에서 반환 한대로 .</target>
        </trans-unit>
        <trans-unit id="863aff4e4c6e39a97f1c4df4bc54ef46a778c1ae" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;pid()&lt;/code&gt; is a process handling I/O-protocols.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된대로 ; &lt;code&gt;pid()&lt;/code&gt; 는 I / O 프로토콜을 처리하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="b4c95d43e70076905f6c54f0f92a6860693a2f6a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt; 에서 반환 한대로</target>
        </trans-unit>
        <trans-unit id="90363fa78582864ae9fe09932744a0fa77aa02f7" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt; 에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a102b38b674404b91761c097130f2c6e8ca2119" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; parse_erl_exprs / 2에서 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d84d9f434fd43a7bcd5371be1f74578362aa6337" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로 돌려 &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; 로 돌려 &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66acc65c2b1802196c6e3511e7c37cac12a600c6" translate="yes" xml:space="preserve">
          <source>As seen in the help text -- unless you have not upgraded your Emacs yet (well, what are you waiting around here for? Off you go and upgrade!) -- &lt;code&gt;etags&lt;/code&gt; associate the file extensions &lt;code&gt;.erl&lt;/code&gt; and &lt;code&gt;.hrl&lt;/code&gt; with Erlang.</source>
          <target state="translated">도움말 텍스트에서 볼 수 있듯이 Emacs를 아직 업그레이드하지 않은 경우를 제외하고 (잘, 여기에서 무엇을 기다리고 있습니까? Off and go and upgrade!)- &lt;code&gt;etags&lt;/code&gt; 는 파일 확장자 &lt;code&gt;.erl&lt;/code&gt; 및 &lt;code&gt;.hrl&lt;/code&gt; 을 Erlang 과 연관시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5f01e0b8a20288a5e48191d860785e7700a74b5b" translate="yes" xml:space="preserve">
          <source>As seen, the basic syntax of a type is an atom followed by closed parentheses. New types are declared using &lt;code&gt;-type&lt;/code&gt; and &lt;code&gt;-opaque&lt;/code&gt; attributes as in the following:</source>
          <target state="translated">보시다시피, 유형의 기본 구문은 원자 다음에 닫힌 괄호입니다. 새로운 유형은 다음과 같이 &lt;code&gt;-type&lt;/code&gt; 및 &lt;code&gt;-opaque&lt;/code&gt; 속성을 사용하여 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3fd03dc2b283a58adbff3d43946bbc1c68e036d" translate="yes" xml:space="preserve">
          <source>As shown above, some files have extension &lt;code&gt;.hrl&lt;/code&gt;. These are header files that are included in the &lt;code&gt;.erl&lt;/code&gt; files by:</source>
          <target state="translated">위에 표시된 것처럼 일부 파일의 확장자는 &lt;code&gt;.hrl&lt;/code&gt; 입니다. 이들은 &lt;code&gt;.erl&lt;/code&gt; 파일에 포함 된 헤더 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="644b5188f948ac22e42edad7ffd5f78d4eae0359" translate="yes" xml:space="preserve">
          <source>As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well.</source>
          <target state="translated">예제에서 볼 수 있듯이 셸에서 함수를 호출 할 수도 있습니다. 쉘에서 사용될 때 재미는 문자 그대로 전화에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="81045d7eeb4cf703574814aab4af0c68ba1e701f" translate="yes" xml:space="preserve">
          <source>As shown in section &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;, the test suite module implements &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (mandatory or optional) for various purposes, for example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; 섹션에 표시된대로 테스트 스위트 모듈 은 다음과 같은 다양한 목적으로 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (필수 또는 선택적)를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="030eefb3aa3439bedecb7d423ba21572f508483d" translate="yes" xml:space="preserve">
          <source>As shown, first it is checked if a year is leap. If a year is divisible by 400, it is a leap year. To determine this, first divide the year by 400 and use the BIF &lt;code&gt;trunc&lt;/code&gt; (more about this later) to cut off any decimals. Then multiply by 400 again and see if the same value is returned again. For example, year 2004:</source>
          <target state="translated">도시 된 바와 같이, 우선 1 년이 도약하는지 확인한다. 연도를 400으로 나눌 수 있으면 윤년입니다. 이를 결정하려면 먼저 연도를 400으로 나누고 BIF &lt;code&gt;trunc&lt;/code&gt; (나중에 자세히 설명)를 사용하여 소수를 자릅니다. 그런 다음 다시 400을 곱하고 같은 값이 다시 반환되는지 확인하십시오. 예를 들어, 2004 년 :</target>
        </trans-unit>
        <trans-unit id="732c6e940059e650b01cb8f7c64bf6533a984dc1" translate="yes" xml:space="preserve">
          <source>As shown, the Erlang shell numbers the lines that can be entered, (as 1&amp;gt; 2&amp;gt;) and that it correctly says that 2 + 5 is 7. If you make writing mistakes in the shell, you can delete with the backspace key, as in most shells. There are many more editing commands in the shell (see &lt;code&gt;tty - A command line interface&lt;/code&gt; in ERTS User's Guide).</source>
          <target state="translated">그림과 같이 Erlang 셸은 입력 할 수있는 행에 번호를 매기고 (1&amp;gt; 2&amp;gt;로) 2 + 5는 7이라고 올바르게 표시합니다. 셸에서 실수를 쓴 경우 백 스페이스 키를 사용하여 삭제할 수 있습니다. 대부분의 껍질 에서처럼. 쉘에는 더 많은 편집 명령이 있습니다 ( ERTS 사용자 안내서의 tty- &lt;code&gt;tty - A command line interface&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="e71ec6804a29b4599e20b3e464961470ccc68635" translate="yes" xml:space="preserve">
          <source>As shown, the function &lt;code&gt;say_something&lt;/code&gt; writes its first argument the number of times specified by second argument. The function &lt;code&gt;start&lt;/code&gt; starts two Erlang processes, one that writes &quot;hello&quot; three times and one that writes &quot;goodbye&quot; three times. Both processes use the function &lt;code&gt;say_something&lt;/code&gt;. Notice that a function used in this way by &lt;code&gt;spawn&lt;/code&gt;, to start a process, must be exported from the module (that is, in the &lt;code&gt;-export&lt;/code&gt; at the start of the module).</source>
          <target state="translated">표시된 것처럼 &lt;code&gt;say_something&lt;/code&gt; 함수 는 첫 번째 인수를 두 번째 인수로 지정된 횟수만큼 씁니다. 기능 &lt;code&gt;start&lt;/code&gt; 은 두 개의 Erlang 프로세스를 시작 합니다. 하나는 &quot;hello&quot;를 세 번 쓰고 다른 하나는 &quot;byeby&quot;를 세 번 씁니다. 두 프로세스 모두 &lt;code&gt;say_something&lt;/code&gt; 함수를 사용합니다 . 프로세스를 시작하기 위해 &lt;code&gt;spawn&lt;/code&gt; 이 이런 방식으로 사용 된 함수 는 모듈에서 내 보내야합니다 (즉 , 모듈 시작시 &lt;code&gt;-export&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8dddde7bbb47337791588e9c259e08ddee9bc47" translate="yes" xml:space="preserve">
          <source>As shown, the ping pong program has run. On the &quot;pong&quot; side:</source>
          <target state="translated">그림과 같이 탁구 프로그램이 실행되었습니다. &quot;퐁&quot;쪽에서 :</target>
        </trans-unit>
        <trans-unit id="ad4c171e5c21c103c918431cb469ba42140798d7" translate="yes" xml:space="preserve">
          <source>As stated earlier, changing child specifications does not affect existing child processes. New child specifications are automatically added, but not deleted. Child processes are not automatically started or terminated, this must be done using &lt;code&gt;apply&lt;/code&gt; instructions.</source>
          <target state="translated">앞서 언급했듯이 자식 사양 변경은 기존 자식 프로세스에 영향을 미치지 않습니다. 새로운 하위 스펙이 자동으로 추가되지만 삭제되지는 않습니다. 하위 프로세스는 자동으로 시작 또는 종료되지 않으며 &lt;code&gt;apply&lt;/code&gt; 지시 사항을 사용하여 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bab58f9f01e2ec9b0aff4a10808faf716038fb5e" translate="yes" xml:space="preserve">
          <source>As stated earlier, instruction &lt;code&gt;restart_new_emulator&lt;/code&gt; causes the emulator to be restarted with new versions of ERTS&amp;gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">앞에서 언급 한 것처럼 &lt;code&gt;restart_new_emulator&lt;/code&gt; 명령어 는 새 버전의 ERTS&amp;gt;, Kernel, STDLIB 및 SASL을 사용하여 에뮬레이터를 다시 시작합니다. 그러나 다른 모든 응용 프로그램은 시작할 때이 새 에뮬레이터에서 이전 버전을 실행합니다. 이는 일반적으로 문제가되지 않지만 지금은 핵심 응용 프로그램에 호환되지 않는 변경이 발생하여이 설정에 문제가 발생할 수 있습니다. 이러한 호환되지 않는 변경 (기능이 제거 될 때)은 일반적으로 두 개의 주요 릴리스에서 더 이상 사용되지 않습니다. 호환되지 않는 변경으로 인해 응용 프로그램이 중단되지 않도록하려면 가능한 빨리 사용되지 않는 기능에 대한 호출을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d2f8b1ba1c67fb67671d7cb5d1f4c6ff846076c9" translate="yes" xml:space="preserve">
          <source>As stated earlier, the order of the instructions is important. When upgrading, &lt;code&gt;m1&lt;/code&gt; must be loaded, and the supervisor child specification changed, before the new child process can be started. When downgrading, the child process must be terminated before the child specification is changed and the module is deleted.</source>
          <target state="translated">앞에서 언급했듯이 지침의 순서가 중요합니다. 업그레이드 할 때 새 하위 프로세스를 시작하기 전에 &lt;code&gt;m1&lt;/code&gt; 을로드하고 수퍼바이저 하위 스펙을 변경해야합니다. 다운 그레이드 할 때 하위 스펙을 변경하고 모듈을 삭제하기 전에 하위 프로세스를 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7ff2d94dd69653efaa6f0e2b153be55d281f264" translate="yes" xml:space="preserve">
          <source>As such a client cannot read a new &lt;code&gt;start_erl.data&lt;/code&gt; file (the file cannot be changed dynamically). The boot and config files are always fetched from the same place (but with new contents if a new release has been installed).</source>
          <target state="translated">이러한 클라이언트는 새 &lt;code&gt;start_erl.data&lt;/code&gt; 파일을 읽을 수 없으므로 파일을 동적으로 변경할 수 없습니다. 부팅 및 구성 파일은 항상 동일한 위치에서 가져옵니다 (그러나 새 릴리스가 설치된 경우 새 내용 포함).</target>
        </trans-unit>
        <trans-unit id="1714bc6ebf672752fb654342a2c562571522eab2" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;++&lt;/code&gt; operator copies its left operand, the result is copied repeatedly, leading to quadratic complexity.</source>
          <target state="translated">애즈 &lt;code&gt;++&lt;/code&gt; 연산자 복사 왼쪽 피연산자 결과는 차 복잡도를 초래 반복 복사된다.</target>
        </trans-unit>
        <trans-unit id="2e226d4cd051311bceb315b8997b69c3409b32fc" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;add_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">는 AS &lt;code&gt;add_frag&lt;/code&gt; 의 절차는 스키마 트랜잭션의 일부, Mnesia는 영향을받는 테이블에 쓰기 잠금을 획득합니다. 즉, &lt;code&gt;IterFrags&lt;/code&gt; 에 해당하는 프래그먼트 와 &lt;code&gt;AdditionalLockFrags&lt;/code&gt; 에 해당하는 프래그먼트 모두 입니다.</target>
        </trans-unit>
        <trans-unit id="f8afd221610cfbc0c004b3e80d9cc06e7451e3b4" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;address&lt;/code&gt; field was omitted, its default value is used.</source>
          <target state="translated">는 AS &lt;code&gt;address&lt;/code&gt; 필드가 생략 된, 기본 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13444681318a2f85bf718682f9be9c04d867f14f" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;del_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">는 AS &lt;code&gt;del_frag&lt;/code&gt; 의 절차는 스키마 트랜잭션의 일부, Mnesia는 영향을받는 테이블에 쓰기 잠금을 획득합니다. 즉, &lt;code&gt;IterFrags&lt;/code&gt; 에 해당하는 프래그먼트 와 &lt;code&gt;AdditionalLockFrags&lt;/code&gt; 에 해당하는 프래그먼트 모두 입니다.</target>
        </trans-unit>
        <trans-unit id="996b8c87675fcbf684c10ebd80b9cfdfdf3cae34" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;total&lt;/code&gt; value is the sum of &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;, the error in &lt;code&gt;system&lt;/code&gt; propagates to the &lt;code&gt;total&lt;/code&gt; value.</source>
          <target state="translated">애즈 &lt;code&gt;total&lt;/code&gt; 값의 합 &lt;code&gt;processes&lt;/code&gt; 및 &lt;code&gt;system&lt;/code&gt; 에서 오류 &lt;code&gt;system&lt;/code&gt; 받는 전파 &lt;code&gt;total&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="4195fa76015f84a5df8be91ff120efd14a713307" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application is dependent on third party products there are a few administrative things that needs to be done before you can get things up and running.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 써드 파티 제품에 의존하므로 작업을 시작하고 실행하기 전에 수행해야 할 몇 가지 관리 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c8404a5de3c59614d50e29989cfead97f57ced" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application relies on third party products and communicates with a database that probably runs on another computer in the network there are plenty of things that might go wrong. To fully understand the things that might happen it facilitate to know the design of the Erlang ODBC application, hence here follows a short description of the current design.</source>
          <target state="translated">Erlang ODBC 응용 프로그램은 써드 파티 제품에 의존하고 네트워크의 다른 컴퓨터에서 실행되는 데이터베이스와 통신 할 때 잘못 될 수있는 많은 것이 있습니다. 발생할 수있는 상황을 완전히 이해하려면 Erlang ODBC 응용 프로그램의 설계를 쉽게 알 수 있으므로 여기에서는 현재 설계에 대한 간단한 설명을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3558041c42459c9de0de1dcf3a8814d6434e5a6c" translate="yes" xml:space="preserve">
          <source>As the UTF-8 encoding is widely spread and provides some backward compatibility in the 7-bit ASCII range, it is selected as the standard encoding for Unicode characters in binaries for Erlang.</source>
          <target state="translated">UTF-8 인코딩은 광범위하게 확산되고 7 비트 ASCII 범위에서 일부 이전 버전과의 호환성을 제공하므로 Erlang 바이너리에서 유니 코드 문자의 표준 인코딩으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="bdb9f25861a28ac570dd99575f72b2d8ad54d3fa" translate="yes" xml:space="preserve">
          <source>As the driver is a shared module, not a program, no main function is present. All function pointers are not used in this example, and the corresponding fields in the &lt;code&gt;driver_entry&lt;/code&gt; structure are set to NULL.</source>
          <target state="translated">드라이버는 프로그램이 아니라 공유 모듈이므로 주요 기능이 없습니다. 이 예제에서는 모든 함수 포인터가 사용되지 않으며 &lt;code&gt;driver_entry&lt;/code&gt; 구조 의 해당 필드는 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8406821028c9ff87cf4b1f089c352e4449600154" translate="yes" xml:space="preserve">
          <source>As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms.</source>
          <target state="translated">일치 사양의 실행 및 구조는 재미와 비슷하므로 친숙한 재미 구문을 사용하여 작성하고 일치 사양으로 자동 변환하는 것이 더 간단합니다. 실제 재미는 일치 사양이 허용하는 것보다 훨씬 강력하지만 일치 사양을 염두에두고 수행 할 수있는 작업을 모두 재미있게 작성하는 것이 더 편리합니다. 이 모듈에는 fun 구문을 일치 스펙 용어로 변환하는 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="500258296a887dd562c74c1baf7dab1768136ec5" translate="yes" xml:space="preserve">
          <source>As the execution of the test suites proceed, events are logged in the following four different ways:</source>
          <target state="translated">테스트 스위트의 실행이 진행되면 이벤트는 다음 네 가지 방식으로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2b99f096c11009199607e528c1ab4fde76715836" translate="yes" xml:space="preserve">
          <source>As the message is an &lt;code&gt;ETERM&lt;/code&gt; struct, Erl_Interface functions can be used to manipulate it. In this case, the message becomes a 3-tuple, because that is how the Erlang code is written. The second element will be the pid of the caller and the third element will be the tuple &lt;code&gt;{Function,Arg}&lt;/code&gt; determining which function to call, and with which argument. The result of calling the function is made into an &lt;code&gt;ETERM&lt;/code&gt; struct as well and sent back to Erlang using &lt;code&gt;erl_send()&lt;/code&gt;, which takes the open file descriptor, a pid, and a term as arguments:</source>
          <target state="translated">메시지가 &lt;code&gt;ETERM&lt;/code&gt; 구조체이므로 Erl_Interface 함수를 사용 하여 메시지 를 조작 할 수 있습니다. 이 경우 Erlang 코드가 작성되는 방식이므로 메시지가 3 개의 튜플이됩니다. 두 번째 요소는 호출자의 pid이고 세 번째 요소는 호출 할 함수와 인수를 결정하는 튜플 &lt;code&gt;{Function,Arg}&lt;/code&gt; 입니다. 함수를 호출 한 결과도 &lt;code&gt;ETERM&lt;/code&gt; 구조체로 만들어 지고 열린 파일 디스크립터, pid 및 용어를 인수로 사용하는 &lt;code&gt;erl_send()&lt;/code&gt; 사용하여 Erlang으로 다시 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="7146c7ac731941ac40a19a992206ba27e74fa230" translate="yes" xml:space="preserve">
          <source>As the position is specified as a byte-offset, take special caution when working with files where &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, as not every byte position is a valid character boundary on such a file.</source>
          <target state="translated">위치가 바이트 오프셋으로 지정되므로 모든 바이트 위치가 해당 파일에서 유효한 문자 경계가 아니기 때문에 &lt;code&gt;encoding&lt;/code&gt; 이 &lt;code&gt;latin1&lt;/code&gt; 이외의 것으로 설정된 파일로 작업 할 때 특히주의 하십시오.</target>
        </trans-unit>
        <trans-unit id="f76a9267a5d5f392fb58b458fb3bf07880270ba9" translate="yes" xml:space="preserve">
          <source>As the runtime system handles the optimization (instead of the compiler), there are very few circumstances in which the optimization does not work.</source>
          <target state="translated">런타임 시스템이 컴파일러 대신 최적화를 처리하므로 최적화가 작동하지 않는 환경은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b697dde1f8ec4fdc0c53e1bd6391f4323555d01f" translate="yes" xml:space="preserve">
          <source>As the source code is distributed, it can easily be modified to accept other options. The program must still accept option &lt;code&gt;-data&lt;/code&gt; with the semantics described above for the release handler to work correctly.</source>
          <target state="translated">소스 코드가 배포되면 다른 옵션을 수용하도록 쉽게 수정할 수 있습니다. 릴리스 핸들러가 올바르게 작동 하려면 프로그램은 여전히 위에서 설명한 의미와 함께 옵션 &lt;code&gt;-data&lt;/code&gt; 를 승인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8795a3307568900a68fbd017733b56af3116954b" translate="yes" xml:space="preserve">
          <source>As the time offset is not allowed to change, time correction must adjust the frequency of the Erlang monotonic clock to align Erlang system time with OS system time smoothly. A significant downside of this approach is that we on purpose will use a faulty frequency on the Erlang monotonic clock if adjustments are needed. This error can be as large as 1%. This error will show up in all time measurements in the runtime system.</source>
          <target state="translated">시간 오프셋을 변경할 수 없으므로 시간 수정은 Erlang 시스템 시간을 OS 시스템 시간과 부드럽게 맞추기 위해 Erlang 모노 토닉 클록의 주파수를 조정해야합니다. 이 접근 방식의 중요한 단점은 조정이 필요한 경우 의도적으로 Erlang 모노 토닉 클록에서 잘못된 주파수를 사용한다는 것입니다. 이 오류는 최대 1 % 일 수 있습니다. 이 오류는 런타임 시스템의 모든 시간 측정에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c394e9d8956e53ffa12dda34b51f038d61fe77cf" translate="yes" xml:space="preserve">
          <source>As the two alternatives are inside a &lt;code&gt;(?|&lt;/code&gt; group, both sets of capturing parentheses are numbered one. Thus, when the pattern matches, you can look at captured substring number one, whichever alternative matched. This construct is useful when you want to capture a part, but not all, of one of many alternatives. Inside a &lt;code&gt;(?|&lt;/code&gt; group, parentheses are numbered as usual, but the number is reset at the start of each branch. The numbers of any capturing parentheses that follow the subpattern start after the highest number used in any branch. The following example is from the Perl documentation; the numbers underneath show in which buffer the captured content is stored:</source>
          <target state="translated">두 개의 대안이 &lt;code&gt;(?|&lt;/code&gt; 그룹 안에 있기 때문에, 두 개의 캡처 괄호 세트는 하나의 번호가 매겨집니다. 따라서 패턴이 일치하면 캡처 된 서브 스트링 1 번 중 어느 것이라도 일치하는 것을 볼 수 있습니다.이 구성은 캡처하려는 경우에 유용합니다 일부, 전부는 아니지만하는 많은 대안 중 하나의 내부. &lt;code&gt;(?|&lt;/code&gt; 그룹은 괄호 평소대로 번호,하지만 숫자는 각 지점의 시작 재설정 된 서브 패턴 시작 후 뒤에 오는 캡처 괄호의 숫자. 다음 예제는 Perl 문서에서 가져온 것이며 아래 숫자는 캡처 된 내용이 저장된 버퍼를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6b1ff2bd85ad93af178cdc629f19b070b543117b" translate="yes" xml:space="preserve">
          <source>As there can be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If option &lt;code&gt;extended&lt;/code&gt; is set, this can be whitespace. Otherwise an empty comment (see section &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt;) can be used.</source>
          <target state="translated">패턴에 많은 캡처 괄호가있을 수 있으므로 백 슬래시 뒤의 모든 숫자는 잠재적 인 역 참조 번호의 일부로 사용됩니다. 패턴이 숫자 문자로 계속되면 일부 분리 문자를 사용하여 역 참조를 종료해야합니다. &lt;code&gt;extended&lt;/code&gt; 옵션을 설정하면 공백이 될 수 있습니다. 그렇지 않으면 빈 코멘트 (섹션 참조 &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a74c4cf2304eafd1772e4800b2c34ab0218b1011" translate="yes" xml:space="preserve">
          <source>As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option &lt;code&gt;group&lt;/code&gt;, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</source>
          <target state="translated">예제의 마지막 부분 ( &quot;g&quot;)에 일치하는 하위 표현식이 없으므로 그 뒤에 아무것도 삽입되지 않습니다. 문자열 그룹과 하위 표현식과 일치하는 부분을보다 명확하게하기 위해 문자열을 분할 할 때 주제 문자열의 일부를 하위 표현식과 일치하는 부분으로 &lt;code&gt;group&lt;/code&gt; 하는 옵션 group을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e2c8ed56878a9d0ce4d6f8c64f1107a4ec68580" translate="yes" xml:space="preserve">
          <source>As these are the C library, the same limitations apply.</source>
          <target state="translated">이것이 C 라이브러리이므로 동일한 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c163dd9740f51616c09627b0819df111304b0a64" translate="yes" xml:space="preserve">
          <source>As this interface implies that ports are killed when the last user disappears, the function does not hang waiting for ports to get closed.</source>
          <target state="translated">이 인터페이스는 마지막 사용자가 사라질 때 포트가 종료됨을 의미하므로 포트가 닫힐 때까지 함수가 정지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="269a4f9e2c4144f24e95fc48fbc36000ea30889f" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 컴파일러 관리자에게만 관심이 있고 두 곳에서 동일한 설명을 피하기 위해 경고를 제어하는 &lt;code&gt;Options&lt;/code&gt; 요소 는 &lt;code&gt;compile(3)&lt;/code&gt; 모듈 에만 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4808daf64c94ffd2d15ac09bfa7bb9ffab8a8096" translate="yes" xml:space="preserve">
          <source>As was mentioned before, the graph analyses operate on the &lt;code&gt;digraph&lt;/code&gt; representation of graphs. By default, the &lt;code&gt;digraph&lt;/code&gt; representation is created when needed (and deleted when no longer used), but it can also be created explicitly by use of the &lt;code&gt;closure&lt;/code&gt; operator:</source>
          <target state="translated">앞에서 언급했듯이 그래프 분석은 그래프의 &lt;code&gt;digraph&lt;/code&gt; 표현에서 작동 합니다. 기본적으로 &lt;code&gt;digraph&lt;/code&gt; 표현은 필요할 때 작성되고 더 이상 사용되지 않으면 삭제되지만 &lt;code&gt;closure&lt;/code&gt; 연산자를 사용하여 명시 적으로 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08da2b535fd9c3da81a12df0eca527a12e4f65fc" translate="yes" xml:space="preserve">
          <source>As was mentioned in the previous section, &lt;code&gt;start_erl&lt;/code&gt; requires a &lt;code&gt;sys.config&lt;/code&gt; in the release version directory (&lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt;). If there is no such file, the system start fails. Such a file must therefore also be added.</source>
          <target state="translated">이전 섹션에서 언급 한 것처럼, &lt;code&gt;start_erl&lt;/code&gt; 는 필요 &lt;code&gt;sys.config&lt;/code&gt; 릴리스 버전 디렉토리 ( &lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt; ). 그러한 파일이 없으면 시스템 시작이 실패합니다. 따라서 이러한 파일도 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f5cac0dfe306d70277c63b5386d001ed67533ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 소유권 이전이 수행되지 않습니다. 자원은 여전히 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; 로 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="86dd8791c9b5f5dca561254006fe497e2d3994c7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt;: use with extreme care.</source>
          <target state="translated">&lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt; 과 같이 : 매우주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="efe69f566993703e5412e0783db54d43802e91bd" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;run/3&lt;/code&gt;, compilation errors raise the &lt;code&gt;badarg&lt;/code&gt; exception. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; can be used to get more information about the error.</source>
          <target state="translated">&lt;code&gt;run/3&lt;/code&gt; 과 마찬가지로 컴파일 오류로 인해 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 오류에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ddbc78ec2288effbfbc27dc2887832b0da7683" translate="yes" xml:space="preserve">
          <source>As with all other functions starting with &lt;code&gt;ei_&lt;/code&gt;, you are &lt;strong&gt;not&lt;/strong&gt; expected to put the socket in non-blocking mode yourself in the program. Every use of non-blocking mode is embedded inside the time-out functions. The socket will always be back in blocking mode after the operations are completed (regardless of the result). To avoid problems, leave the socket options alone. &lt;code&gt;ei&lt;/code&gt; handles any socket options that need modification.</source>
          <target state="translated">모든 다른 기능으로 시작과 마찬가지로 &lt;code&gt;ei_&lt;/code&gt; , 당신은되어 &lt;strong&gt;있지&lt;/strong&gt; 자신이 프로그램에서 비 블로킹 모드에서 소켓을 넣어 것으로 예상. 비 차단 모드의 모든 사용은 타임 아웃 기능에 포함됩니다. 작업이 완료된 후 (결과에 상관없이) 소켓은 항상 차단 모드로 돌아갑니다. 문제를 피하려면 소켓 옵션을 그대로 두십시오. &lt;code&gt;ei&lt;/code&gt; 는 수정이 필요한 모든 소켓 옵션을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c3c8339b0d633ff7f739e39a8bb36a1648a7db29" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process is lost if the supervisor itself restarts.</source>
          <target state="translated">동적으로 추가 된 자식 프로세스와 마찬가지로 관리자 자체가 다시 시작되면 정적 자식 프로세스 삭제 효과가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="ec50db8f3e13bb5768f12bc8a6a3b1ddcd9124a9" translate="yes" xml:space="preserve">
          <source>As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity.</source>
          <target state="translated">일반적인 트리 구조와 마찬가지로 조회 (멤버십 테스트), 삽입 및 삭제에는 로그가 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="96a345435dd16a7fc2f73434205466252ddf7e39" translate="yes" xml:space="preserve">
          <source>As with process monitors, each driver monitor set only generates &lt;strong&gt;one single message&lt;/strong&gt;. The monitor is &quot;destroyed&quot; after the message is sent, so it is then not needed to call &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스 모니터와 마찬가지로 각 드라이버 모니터 세트는 &lt;strong&gt;하나의 단일 메시지&lt;/strong&gt; 만 생성 &lt;strong&gt;합니다&lt;/strong&gt; . 메시지가 전송 된 후 모니터가 &quot;파기&quot;되므로 &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; 을 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b2467dbec656f95127f4a0e7d30ecc8a6ad6234f" translate="yes" xml:space="preserve">
          <source>As you can see by the example, the function can be called from the shell too. The &lt;code&gt;fun()&lt;/code&gt; needs to be literally in the call when used from the shell as well. Other means than the parse_transform are used in the shell case, but more or less the same restrictions apply (the exception being records, as they are not handled by the shell).</source>
          <target state="translated">예제에서 볼 수 있듯이 함수는 셸에서도 호출 할 수 있습니다. &lt;code&gt;fun()&lt;/code&gt; 뿐만 아니라 쉘에서 사용할 때 호출에 그대로 있어야합니다. parse_transform 이외의 다른 방법이 쉘의 경우에 사용되지만 거의 동일한 제한이 적용됩니다 (쉘에서 처리하지 않으므로 레코드는 예외입니다).</target>
        </trans-unit>
        <trans-unit id="2b8232bbed24ef8f629ce1816536b7c03bfad7c6" translate="yes" xml:space="preserve">
          <source>As you can understand from the illustration, &lt;code&gt;Common Test&lt;/code&gt; requires a test case to generate a runtime error to indicate failure (for example, by causing a bad match error or by calling &lt;code&gt;exit/1&lt;/code&gt;, preferably through the help function &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt;). A successful execution is indicated by a normal return from the test case function.</source>
          <target state="translated">그림에서 알 수 있듯이 &lt;code&gt;Common Test&lt;/code&gt; 에는 실패를 표시하기 위해 런타임 오류를 생성하기위한 테스트 케이스가 필요합니다 (예를 들어, 일치 오류가 발생하거나 &lt;code&gt;exit/1&lt;/code&gt; 기능 호출 , 바람직하게는 도움말 기능 &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; ). 성공적인 실행은 테스트 케이스 함수에서 정상 리턴으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9b635d527fabae96e027fa225db3c0e9bac328ef" translate="yes" xml:space="preserve">
          <source>As you have seen, it is possible to use the &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; functions explicitly. By using those functions you can write your own trace client that reads trace data from any source stored in any format and just feed the &lt;code&gt;Collector&lt;/code&gt; with it. You may replace the default &lt;code&gt;Collector Filter&lt;/code&gt; with a filter that converts new exciting trace data formats to &lt;code&gt;Event Records&lt;/code&gt; or you may convert it to an &lt;code&gt;Event Record&lt;/code&gt; before you invoke &lt;code&gt;et_collector:report/2&lt;/code&gt; and then rely on the default &lt;code&gt;Collector Filter&lt;/code&gt; to handle the new format.</source>
          <target state="translated">앞에서 본 것처럼 &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; 함수를 명시 적으로 사용할 수 있습니다. 이러한 기능을 사용하면 모든 형식으로 저장된 소스에서 추적 데이터를 읽고 &lt;code&gt;Collector&lt;/code&gt; 에이를 제공하는 고유 한 추적 클라이언트를 작성할 수 있습니다 . 기본 &lt;code&gt;Collector Filter&lt;/code&gt; 를 새로운 흥미로운 추적 데이터 형식을 &lt;code&gt;Event Records&lt;/code&gt; 로 변환하는 필터로 바꾸 거나 &lt;code&gt;et_collector:report/2&lt;/code&gt; 를 호출 한 다음 기본 &lt;code&gt;Collector Filter&lt;/code&gt; 를 사용하여 새 형식을 처리 하기 전에 이를 &lt;code&gt;Event Record&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d261c2679b68d55f3f5768006262a218d859a604" translate="yes" xml:space="preserve">
          <source>Ask them to transform the internal state format and switch to the new version of the module.</source>
          <target state="translated">내부 상태 형식을 변환하고 새 버전의 모듈로 전환하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="7ccd30300261a4eca3d0f1af0fcf77d29e731e3c" translate="yes" xml:space="preserve">
          <source>Asking for and inspecting raw socket options require low-level information about the current operating system and TCP stack.</source>
          <target state="translated">원시 소켓 옵션을 요청하고 검사하려면 현재 운영 체제 및 TCP 스택에 대한 저수준 정보가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0599d793007329beb80221bb5065e2bf255ef6e5" translate="yes" xml:space="preserve">
          <source>Assert end of string (or line, in multiline mode)</source>
          <target state="translated">문자열 끝 (또는 여러 줄 모드에서 줄)</target>
        </trans-unit>
        <trans-unit id="cf59339e55d5c656acd77a3516f63cf3ff15de3e" translate="yes" xml:space="preserve">
          <source>Assert start of string (or line, in multiline mode)</source>
          <target state="translated">문자열 시작 (또는 여러 줄 모드에서 줄 시작)</target>
        </trans-unit>
        <trans-unit id="18d329141ee34e40c36d7b169bb7a159eb5aeb08" translate="yes" xml:space="preserve">
          <source>Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.)</source>
          <target state="translated">어설 션 하위 패턴은 하위 패턴을 캡처하지 않습니다. 이러한 어설 션에 캡처 하위 패턴이 포함되어 있으면 전체 패턴에서 캡처 하위 패턴의 번호를 매기기 위해 계산됩니다. 그러나 부분 문자열 캡처는 긍정적 인 주장에 대해서만 수행됩니다. (Perl은 항상 그런 것은 아니지만 항상 부정적인 어설 션으로 캡처를 수행합니다.)</target>
        </trans-unit>
        <trans-unit id="dc3e91b0be656a68c41466178566755f49840e06" translate="yes" xml:space="preserve">
          <source>Assertions can be nested in any combination. For example, the following matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded by &quot;foo&quot;:</source>
          <target state="translated">어설 션은 어떤 조합으로도 중첩 될 수 있습니다. 예를 들어, 다음은 &quot;bar&quot;가 앞에 오는 &quot;baz&quot;와 일치하며 &quot;foo&quot;가 앞에 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8383a156cd04a5d92aafffd1ec55eeaa8e37c727" translate="yes" xml:space="preserve">
          <source>Assigning a value to type &lt;code&gt;Operational&lt;/code&gt; in Erlang is possible by using the following Erlang code:</source>
          <target state="translated">Erlang에서 &lt;code&gt;Operational&lt;/code&gt; 유형에 값을 지정하는 것은 다음 Erlang 코드를 사용하여 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4ad8afb43e64d75a730687d995308551590810c9" translate="yes" xml:space="preserve">
          <source>Assignment ::= Variable &lt;code&gt;:=&lt;/code&gt; Expression | Variable &lt;code&gt;=&lt;/code&gt; Expression</source>
          <target state="translated">할당 :: = 변수 &lt;code&gt;:=&lt;/code&gt; 식 | 변수 &lt;code&gt;=&lt;/code&gt; 표현식</target>
        </trans-unit>
        <trans-unit id="31732955b5b879b8595ccb4012494c26bfc62323" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt;.</source>
          <target state="translated">새로운 제어 프로세스 &lt;code&gt;Pid&lt;/code&gt; 를 &lt;code&gt;Socket&lt;/code&gt; 에 할당합니다 . &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt; 와 동일한 구현 입니다.</target>
        </trans-unit>
        <trans-unit id="750263088fcf3a705a426666d4ba4253060235cc" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. The controlling process is the process that receives messages from the socket. If called by any other process than the current controlling process, &lt;code&gt;{error, not_owner}&lt;/code&gt; is returned. If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local pid, &lt;code&gt;{error, badarg}&lt;/code&gt; is returned. &lt;code&gt;{error, badarg}&lt;/code&gt; may also be returned in some cases when &lt;code&gt;Socket&lt;/code&gt; is closed during the execution of this function.</source>
          <target state="translated">새로운 제어 프로세스 &lt;code&gt;Pid&lt;/code&gt; 를 &lt;code&gt;Socket&lt;/code&gt; 에 할당합니다 . 제어 프로세스는 소켓에서 메시지를받는 프로세스입니다. 현재 제어 프로세스가 아닌 다른 프로세스에서 호출하면 &lt;code&gt;{error, not_owner}&lt;/code&gt; 가 리턴됩니다. &lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스 가 기존 로컬 pid가 아닌 경우 &lt;code&gt;{error, badarg}&lt;/code&gt; 가 리턴됩니다. 이 함수를 실행하는 동안 &lt;code&gt;Socket&lt;/code&gt; 이 닫히면 경우에 따라 &lt;code&gt;{error, badarg}&lt;/code&gt; 가 반환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83e6ee60d090046ec0df21d8f20b308779b0123e" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process to the SSL socket. A controlling process is the owner of an SSL socket, and receives all messages from the socket.</source>
          <target state="translated">새로운 제어 프로세스를 SSL 소켓에 지정합니다. 제어 프로세스는 SSL 소켓의 소유자이며 소켓에서 모든 메시지를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="e2015efa67c45a84e357363963f8ef7cc19116af" translate="yes" xml:space="preserve">
          <source>Associate a result set containing the whole table &lt;code&gt;EMPLOYEE&lt;/code&gt; to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">전체 테이블 &lt;code&gt;EMPLOYEE&lt;/code&gt; 를 포함하는 결과 세트를 연결에 연관 시키십시오. 결과 집합의 행 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c01c817bd8220a9e426732586a19782a2ec8dae2" translate="yes" xml:space="preserve">
          <source>Associate a result set that contains the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">모든 여성 직원의 &lt;code&gt;FIRSTNAME&lt;/code&gt; 및 &lt;code&gt;NR&lt;/code&gt; 필드가 포함 된 결과 집합을 연결에 연결하십시오. 결과 집합의 행 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e682a3847cd3fad46ea3e5c2bf3acec87c695369" translate="yes" xml:space="preserve">
          <source>Associates &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; and inserts the association into map &lt;code&gt;Map2&lt;/code&gt;. If key &lt;code&gt;Key&lt;/code&gt; already exists in map &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new association and the old associations in &lt;code&gt;Map1&lt;/code&gt;.</source>
          <target state="translated">Associates의 &lt;code&gt;Key&lt;/code&gt; 값을 &lt;code&gt;Value&lt;/code&gt; 과 삽입지도에 연결 &lt;code&gt;Map2&lt;/code&gt; 에 . 키 경우 &lt;code&gt;Key&lt;/code&gt; 이미 맵에 존재 &lt;code&gt;Map1&lt;/code&gt; 이전 관련 값은 값으로 대체됩니다 &lt;code&gt;Value&lt;/code&gt; . 이 함수는 &lt;code&gt;Map1&lt;/code&gt; 의 새 연관 및 이전 연관을 포함 하는 새 맵 &lt;code&gt;Map2&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fe25fda4b17970a0ef529403d3f726c24aae538c" translate="yes" xml:space="preserve">
          <source>Associates a UDP port number (&lt;code&gt;Port&lt;/code&gt;) with the calling process.</source>
          <target state="translated">UDP 포트 번호 ( &lt;code&gt;Port&lt;/code&gt; )를 호출 프로세스와 연관 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f1f8648a03de87c0a9794d9b8e650c32fee361c7" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;Name&lt;/code&gt;, an atom, with the process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">이름 &lt;code&gt;Name&lt;/code&gt; , 원자를 프로세스 &lt;code&gt;Pid&lt;/code&gt; 와 연관시킵니다 .</target>
        </trans-unit>
        <trans-unit id="adba476945469569c82884884c1c62b87ee5beca" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;RegName&lt;/code&gt; with a process identifier (pid) or a port identifier. &lt;code&gt;RegName&lt;/code&gt;, which must be an atom, can be used instead of the pid or port identifier in send operator (&lt;code&gt;RegName ! Message&lt;/code&gt;). Example:</source>
          <target state="translated">이름 &lt;code&gt;RegName&lt;/code&gt; 을 프로세스 식별자 (pid) 또는 포트 식별자와 연결합니다. 송신 연산자 ( &lt;code&gt;RegName ! Message&lt;/code&gt; ) 에서 pid 또는 포트 식별자 대신 원자 여야하는 &lt;code&gt;RegName&lt;/code&gt; 을 사용할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="41bb0af24396833201992ca15a0ccfba7ee7f093" translate="yes" xml:space="preserve">
          <source>Associates the test run with a name that gets printed in the overview HTML log files.</source>
          <target state="translated">테스트 실행을 개요 HTML 로그 파일에 인쇄되는 이름과 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="a929bb502012d59c211ba29e792fdfc1bcec65b6" translate="yes" xml:space="preserve">
          <source>Association is successfully established. This indicates a successful completion of &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">협회가 성공적으로 설립되었습니다. &lt;code&gt;connect&lt;/code&gt; 이 성공적으로 완료되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cd321e5d28d57fcf199c5a0fe6ae644a0f00e982" translate="yes" xml:space="preserve">
          <source>Assume that a module is extended by adding an interface function, as in the example in &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;, where a function &lt;code&gt;available/0&lt;/code&gt; is added to &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 의 예제에서와 같이 인터페이스 함수를 추가하여 모듈이 확장되었다고 가정하십시오 . 여기서 &lt;code&gt;available/0&lt;/code&gt; 함수 가 &lt;code&gt;ch3&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="81e67a14a83897861024d39ef25a7c52fdc905a0" translate="yes" xml:space="preserve">
          <source>Assume that a test case for the following program should be verified:</source>
          <target state="translated">다음 프로그램의 테스트 케이스를 확인해야한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="71a8953ab141a80996cc4c7f627c6481c2d38dca" translate="yes" xml:space="preserve">
          <source>Assume that a user does not want Erlang to use the native lookup method, but wants Erlang to read all information necessary from start and use that for resolving names and addresses. If lookup fails, Erlang is to request the data from a nameserver (using the Erlang DNS client, set to use EDNS allowing larger responses). The resolver configuration is updated when its configuration file changes. Also, DNS records are never to be cached. The user configuration file (in this example named &lt;code&gt;erl_inetrc&lt;/code&gt;, stored in directory &lt;code&gt;./cfg_files&lt;/code&gt;) can then look as follows (Unix):</source>
          <target state="translated">사용자가 Erlang이 기본 조회 방법을 사용하지 않고 Erlang이 시작에서 필요한 모든 정보를 읽고 이름과 주소를 확인하는 데 필요한 정보를 사용한다고 가정합니다. 조회가 실패하면 Erlang은 네임 서버에서 데이터를 요청해야합니다 (Erlang DNS 클라이언트를 사용하여 더 큰 응답을 허용하는 EDNS를 사용하도록 설정). 구성 파일이 변경되면 리졸버 구성이 업데이트됩니다. 또한 DNS 레코드는 캐시되지 않습니다. (이름이 예에서 사용자 구성 파일 &lt;code&gt;erl_inetrc&lt;/code&gt; 디렉토리에 저장 &lt;code&gt;./cfg_files&lt;/code&gt; (유닉스)를 다음과 같이 볼 수) :</target>
        </trans-unit>
        <trans-unit id="2d48df2f1a8f0fd07793d2b425e8df418ef5bfad" translate="yes" xml:space="preserve">
          <source>Assume that nothing happens when tracing in this way. The function is never called with these parameters. We conclude that someone else (some other module) is doing it and realize that we must trace on &lt;code&gt;ets:insert/2&lt;/code&gt; and want to see the calling function. The calling function can be retrieved using the match specification function &lt;code&gt;caller&lt;/code&gt;. To get it into the trace message, the match specification function &lt;code&gt;message&lt;/code&gt; must be used. The filter call looks like this (looking for calls to &lt;code&gt;ets:insert/2&lt;/code&gt;):</source>
          <target state="translated">이 방법으로 추적 할 때 아무 일도 일어나지 않는다고 가정하십시오. 이 매개 변수로 함수가 호출되지 않습니다. 우리는 다른 누군가 (일부 다른 모듈)가 그것을하고 있다고 결론 내리고 &lt;code&gt;ets:insert/2&lt;/code&gt; 를 추적 하고 호출 함수를보고 싶다는 것을 알고 있습니다. 일치 스펙 함수 &lt;code&gt;caller&lt;/code&gt; 사용하여 호출 함수를 검색 할 수 있습니다 . 추적 메시지로 가져 오려면 일치 스펙 기능 &lt;code&gt;message&lt;/code&gt; 사용해야합니다. 필터 호출은 다음과 같습니다 ( &lt;code&gt;ets:insert/2&lt;/code&gt; 호출 참조).</target>
        </trans-unit>
        <trans-unit id="997882ed021f898e3c4711038cfd690fedaa8231" translate="yes" xml:space="preserve">
          <source>Assume that the module now passes all testing and goes into the system. After a while, it is found that table &lt;code&gt;toy_table&lt;/code&gt; grows while the system is running and that there are many elements with atoms as keys. We expected only integer keys and so does the rest of the system, but clearly not the entire system. We turn on call tracing and try to see calls to the module with an atom as the key:</source>
          <target state="translated">모듈이 이제 모든 테스트를 통과하고 시스템으로 이동한다고 가정하십시오. 잠시 후 , 시스템이 실행되는 동안 테이블 &lt;code&gt;toy_table&lt;/code&gt; 이 커지고 원자를 키로 갖는 많은 요소가 있음을 알 수 있습니다. 우리는 정수 키만을 기대했고 나머지 시스템은 물론 전체 시스템은 아닙니다. 콜 추적을 켜고 원자를 키로하여 모듈에 대한 호출을 보려고합니다.</target>
        </trans-unit>
        <trans-unit id="f89a940266dfec94c78b06cb601b527f92f04417" translate="yes" xml:space="preserve">
          <source>Assume that the suite contains the test case &lt;code&gt;get_resource_status&lt;/code&gt; that is independent of the other two cases, then function &lt;code&gt;all&lt;/code&gt; can look as follows:</source>
          <target state="translated">스위트가 다른 두 경우와 독립적 인 테스트 케이스 &lt;code&gt;get_resource_status&lt;/code&gt; 를 포함한다고 가정하면 함수는 &lt;code&gt;all&lt;/code&gt; 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d831964edca879d5d90599f59a999703ad024ad1" translate="yes" xml:space="preserve">
          <source>Assume that there are two systems, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, that are tested in separate test runs. System &lt;code&gt;s1&lt;/code&gt; contains a library module &lt;code&gt;m1&lt;/code&gt; tested by test run &lt;code&gt;s1&lt;/code&gt; and is included in the cover specification of &lt;code&gt;s1&lt;/code&gt; as follows:</source>
          <target state="translated">별도의 테스트 실행에서 테스트되는 두 개의 시스템 &lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 가 있다고 가정하십시오 . 시스템 &lt;code&gt;s1&lt;/code&gt; 에는 테스트 실행 &lt;code&gt;s1&lt;/code&gt; 에서 테스트 한 라이브러리 모듈 &lt;code&gt;m1&lt;/code&gt; 이 포함 되며 다음과 같이 &lt;code&gt;s1&lt;/code&gt; 의 커버 사양에 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a42279cd9be030fbaa5a2fcc34c767220fae2bb" translate="yes" xml:space="preserve">
          <source>Assume that there is a network application that receives instances of the ASN.1 defined type &lt;code&gt;Person&lt;/code&gt;, modifies, and sends them back again:</source>
          <target state="translated">ASN.1 정의 유형 &lt;code&gt;Person&lt;/code&gt; 의 인스턴스를 수신 하고 수정 한 후 다시 전송 하는 네트워크 애플리케이션이 있다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="33069b991dada2eb5da77ef53b4f64ef6b97abaa" translate="yes" xml:space="preserve">
          <source>Assume that there is an index on position &lt;code&gt;Pos&lt;/code&gt; for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table &lt;code&gt;person&lt;/code&gt;, the call &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; returns a list of all persons with age 36. &lt;code&gt;Pos&lt;/code&gt; can also be an attribute name (atom), but if the notation &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; is used, the field position is searched for in runtime, for each call.</source>
          <target state="translated">특정 레코드 유형에 대해 위치 &lt;code&gt;Pos&lt;/code&gt; 에 색인이 있다고 가정하십시오 . 이 기능을 사용하면 레코드의 실제 키를 몰라도 레코드를 읽을 수 있습니다. 예를 들어, 테이블 &lt;code&gt;person&lt;/code&gt; 의 위치 1에 인덱스가 있으면 &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; 호출 은 36 세인 모든 사람의 목록을 리턴합니다. &lt;code&gt;Pos&lt;/code&gt; 는 속성 이름 (아톰) 일 수도 있습니다. &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; 표기법을 사용하는 경우 각 호출에 대해 런타임에서 필드 위치를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="829ce164f6e9881978858a93ac53473e3de7a2fe" translate="yes" xml:space="preserve">
          <source>Assume that we have not found the problem yet, and want to see what &lt;code&gt;ets:new/2&lt;/code&gt; returns. We use a slightly different trace pattern:</source>
          <target state="translated">아직 문제를 발견하지 못했고 &lt;code&gt;ets:new/2&lt;/code&gt; 가 무엇을 반환 하는지 알고 싶다고 가정 합니다. 약간 다른 추적 패턴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="58d7492d43f93e533d2fc8b2893194dfb95c91d5" translate="yes" xml:space="preserve">
          <source>Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier:</source>
          <target state="translated">하나의 요소 대신 전체 개체 일치를 원한다고 가정하십시오. 한 가지 대안은 레코드의 모든 부분에 변수를 할당하고 재미의 본문에서 다시 한 번 빌드하는 것이지만 다음이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d1bf62160b9303fd32fdad0cd34b9da4d1aef481" translate="yes" xml:space="preserve">
          <source>Assume that we want to get all the employee numbers of employees hired before year 2000. Using &lt;code&gt;ets:match/2&lt;/code&gt; is not an alternative here, as relational operators cannot be expressed there. Once again, &lt;code&gt;ets:foldr/3&lt;/code&gt; can do it (slowly, but correct):</source>
          <target state="translated">2000 년 이전에 고용 된 직원의 모든 직원 수를 얻으려고한다고 가정하십시오. &lt;code&gt;ets:match/2&lt;/code&gt; 를 사용 하는 것은 관계 연산자를 표현할 수 없으므로 여기서 대안이 아닙니다. 다시 한 번, &lt;code&gt;ets:foldr/3&lt;/code&gt; 가 할 수 있습니다 (느리지 만 맞습니다).</target>
        </trans-unit>
        <trans-unit id="1ba39d9d328d97a989e24d8ac3124b4d21b0636f" translate="yes" xml:space="preserve">
          <source>Assume that you have an initiating process with &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="translated">다음과 같이 &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; 인 시작 프로세스가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="59beb2deb0d2bf3ac19ece9f2db7b475398662e6" translate="yes" xml:space="preserve">
          <source>Assume that you want to calculate the factorial for 1:</source>
          <target state="translated">1에 대한 계승을 계산한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="81e6855c42a523802dad6f1c6e5e336c4662d743" translate="yes" xml:space="preserve">
          <source>Assume that you want to transform the &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; document to HTML. If you want the same structure and tags of the resulting HTML document as of the XML document then you can use the &lt;code&gt;xmerl:export/2&lt;/code&gt; function. The following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; 문서를 HTML 로 변환한다고 가정하십시오 . XML 문서와 동일한 결과 HTML 문서의 구조와 태그를 원하는 경우 &lt;code&gt;xmerl:export/2&lt;/code&gt; 함수를 사용할 수 있습니다 . 다음과 같은:</target>
        </trans-unit>
        <trans-unit id="42a5d8a52feabf03d2cc601350c97037810f3131" translate="yes" xml:space="preserve">
          <source>Assume the following:</source>
          <target state="translated">다음을 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="b4dd172e924a451d443d3ebe731fdc5eb7eae97d" translate="yes" xml:space="preserve">
          <source>Assume we want to check the following module:</source>
          <target state="translated">다음 모듈을 확인한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a1917e9bb4b3ba3244f0149508301240f3ef84a5" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each location &lt;code&gt;L&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">&lt;code&gt;Term&lt;/code&gt; 가 &lt;code&gt;erl_parse&lt;/code&gt; 트리 와 동일한 구조를 가지지 만 &lt;code&gt;erl_parse&lt;/code&gt; 트리에 주석 콜렉션이 있는 &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; 가있는 용어 라고 가정합니다 . 각 위치 &lt;code&gt;L&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt; 반환 된 값으로 대체되는 &lt;code&gt;erl_parse&lt;/code&gt; 트리를 반환합니다 . 용어 &lt;code&gt;Term&lt;/code&gt; 는 깊이 우선, 왼쪽에서 오른쪽으로 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="b7cafb7be7f1db85e6934ccfbc9df1141dff9353" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">&lt;code&gt;Term&lt;/code&gt; 은 &lt;code&gt;erl_parse&lt;/code&gt; 트리 와 동일한 구조를 &lt;code&gt;erl_parse&lt;/code&gt; 트리에는 주석 콜렉션이 있는 &lt;code&gt;T&lt;/code&gt; 와 같은 용어 가 있다고 가정합니다 . 각 용어 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt; 의해 리턴 된 값으로 대체되는 &lt;code&gt;erl_parse&lt;/code&gt; 트리를 리턴합니다 . 용어 &lt;code&gt;Term&lt;/code&gt; 는 깊이 우선, 왼쪽에서 오른쪽으로 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="0867c9c6c98bb1857eef83b5370df89b6931896a" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;Forms&lt;/code&gt; represents a program (or any sequence of &quot;program forms&quot;), any comments whose first lines are not directly associated with a specific program form will become standalone comments inserted between the neighbouring program forms. Furthermore, comments whose column position is less than or equal to one will not be attached to a program form that begins at a conflicting line number (this can happen with preprocessor-generated &lt;code&gt;line&lt;/code&gt;-attributes).</source>
          <target state="translated">&lt;code&gt;Forms&lt;/code&gt; 이 프로그램 (또는 일련의 &quot;프로그램 양식&quot;)을 나타내는 것으로 가정하면 , 첫 줄이 특정 프로그램 양식과 직접 연관되지 않은 주석은 인접 프로그램 양식 사이에 삽입 된 독립형 주석이됩니다. 또한 열 위치가 1보다 작거나 같은 주석은 충돌하는 행 번호로 시작하는 프로그램 양식에 첨부되지 않습니다 (이는 전 처리기 생성 &lt;code&gt;line&lt;/code&gt; 속성에서 발생할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="85756eb2ccf84d68d4412ebf0e79850cfd5d276b" translate="yes" xml:space="preserve">
          <source>Assuming an Erlang system called ping (but not the &quot;ping&quot; process) has already been started on kosken, then on gollum this is done:</source>
          <target state="translated">ping ( &quot;ping&quot;프로세스가 아님)이라는 Erlang 시스템이 이미 kosken에서 시작되었다고 가정하면 골룸에서이 작업이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="10a82aabb0e61cdb059228faa6975a490d22e3b9" translate="yes" xml:space="preserve">
          <source>Assuming an Ets table that uses &lt;code&gt;idno&lt;/code&gt; as key and contains the following:</source>
          <target state="translated">&lt;code&gt;idno&lt;/code&gt; 를 키로 사용 하고 다음을 포함 하는 Ets 테이블을 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="18d8e312811328614a25350d0eb0a85b61ed61f9" translate="yes" xml:space="preserve">
          <source>Assuming that both the arguments and the results from the C functions are less than 256, a simple encoding/decoding scheme is employed. In this scheme, &lt;code&gt;foo&lt;/code&gt; is represented by byte 1, &lt;code&gt;bar&lt;/code&gt; is represented by 2, and the argument/result is represented by a single byte as well:</source>
          <target state="translated">C 함수의 인수와 결과가 모두 256보다 작다고 가정하면 간단한 인코딩 / 디코딩 체계가 사용됩니다. 이 체계에서 &lt;code&gt;foo&lt;/code&gt; 는 바이트 1로 &lt;code&gt;bar&lt;/code&gt; 되고 bar 는 2로 표시되며 인수 / 결과는 단일 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a66845ce6e93230866ff8e0772d20b4798a32003" translate="yes" xml:space="preserve">
          <source>Assuming that environment variables has been correctly set, a strings containing valid characters on the specific OS for environment variable names and values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. The first &lt;code&gt;$=&lt;/code&gt; characters appearing in the string separates environment variable name (on the left) from environment variable value (on the right).</source>
          <target state="translated">환경 변수가 올바르게 설정되었다고 가정하면 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하여 환경 변수 이름 및 값에 대해 특정 OS에서 유효한 문자를 포함하는 문자열 입니다. 문자열에 나타나는 첫 번째 &lt;code&gt;$=&lt;/code&gt; 문자는 환경 변수 이름 (왼쪽)과 환경 변수 값 (오른쪽)을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="0a6f58980048155b748b7c9405f322e65c5a9184" translate="yes" xml:space="preserve">
          <source>Assuming that the call to &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; does not find any schema to read on the disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; 에 대한 호출 이 디스크에서 읽을 스키마를 찾지 못하면 &lt;code&gt;Mnesia&lt;/code&gt; 는 디스크가없는 노드로 시작한 다음 디스크를 사용하여 스키마를 로컬로 저장하는 노드로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d6872420cefd05df68dce4eed3bc63d15db4f598" translate="yes" xml:space="preserve">
          <source>Assuming that the node has been started as follows:</source>
          <target state="translated">노드가 다음과 같이 시작되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="8499608ce735317421447e4bbbb5e480084db254" translate="yes" xml:space="preserve">
          <source>Assuming that these requirements are fulfilled, time correction is enabled, and OS system time is adjusted using a time adjustment protocol such as NTP, only small adjustments of Erlang monotonic time are needed to keep system times aligned after finalization. As long as the system is not suspended, the largest adjustments needed are for inserted (or deleted) leap seconds.</source>
          <target state="translated">이러한 요구 사항이 충족되고 시간 수정이 활성화되고 OS 시스템 시간이 NTP와 같은 시간 조정 프로토콜을 사용하여 조정된다고 가정하면, 마무리 후 시스템 시간을 정렬하려면 Erlang 모노 토닉 시간을 약간만 조정하면됩니다. 시스템이 일시 중단되지 않는 한 필요한 최대 조정은 삽입 (또는 삭제) 윤초를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="03367feb887591c7e80f18fd1145673d7dcffe3e" translate="yes" xml:space="preserve">
          <source>Assuming that these types are exported from module &lt;code&gt;'mod'&lt;/code&gt;, you can refer to them from other modules using remote type expressions like the following:</source>
          <target state="translated">이러한 유형이 &lt;code&gt;'mod'&lt;/code&gt; 모듈에서 내보내 졌다고 가정하면 다음과 같은 원격 유형 표현식을 사용하여 다른 모듈에서 해당 유형을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26267ff052ff06ed2dce21d69453c5f440474929" translate="yes" xml:space="preserve">
          <source>Assuming that we want the employee numbers of everyone in the sales department, there are several ways.</source>
          <target state="translated">영업 부서의 모든 직원 수를 원한다고 가정하면 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="266f66badd0d0b518b2e5df463ab8847e52c02bb" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;.rel file&lt;/code&gt; is stored in a file &lt;code&gt;start_ssl.rel&lt;/code&gt; in the current directory, a boot script can be built as follows:</source>
          <target state="translated">&lt;code&gt;.rel file&lt;/code&gt; 이 현재 디렉토리의 &lt;code&gt;start_ssl.rel&lt;/code&gt; 파일 에 저장되어 있다고 가정하면 다음과 같이 부트 스크립트를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fce84ccb66529fc8ed6e1c0f38776816b583ca0" translate="yes" xml:space="preserve">
          <source>Assuming the same &lt;code&gt;CLIENTDIR&lt;/code&gt; as above, the last line is to look like:</source>
          <target state="translated">위와 동일한 &lt;code&gt;CLIENTDIR&lt;/code&gt; 을 가정하면 마지막 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a0c79afff9d3483a1ae5e8cbc8205664dba4b83" translate="yes" xml:space="preserve">
          <source>Assuming there is an operational target system with installation root directory &lt;code&gt;$ROOT&lt;/code&gt;, the release package with the new version of the release is to be copied to &lt;code&gt;$ROOT/releases&lt;/code&gt;.</source>
          <target state="translated">설치 루트 디렉토리가 &lt;code&gt;$ROOT&lt;/code&gt; 인 운영 대상 시스템이 있다고 가정하면 새 버전의 릴리스가있는 릴리스 패키지가 &lt;code&gt;$ROOT/releases&lt;/code&gt; 복사 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7c30a0e4666f7264a0489fe55f811dceafac52d" translate="yes" xml:space="preserve">
          <source>Assuming these definitions:</source>
          <target state="translated">이러한 정의를 가정하면 :</target>
        </trans-unit>
        <trans-unit id="f4b10ac30756395c83923e7cf3c7d80acae92175" translate="yes" xml:space="preserve">
          <source>Async queue length is not defined for &lt;code&gt;put&lt;/code&gt; operations.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 작업에 비동기 대기열 길이가 정의되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3988dd15a01716f5457aa8c6239f3feeb9605755" translate="yes" xml:space="preserve">
          <source>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See &lt;code&gt;erl +A&lt;/code&gt; for more details.</source>
          <target state="translated">비동기 스레드는 다양한 링크 된 드라이버 (주로 파일 드라이버)가 CPU를 많이 사용하지 않는 작업을 오프로드하는 데 사용됩니다. 자세한 내용은 &lt;code&gt;erl +A&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1f2ff86b0c85c68964cf97af02073f12b82e6dee" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="translated">비동기 &lt;code&gt;get-bulk-request&lt;/code&gt; (RFC1905 참조).</target>
        </trans-unit>
        <trans-unit id="3284d2626e5dc0e20ecd8465f9256541f56870e5" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="translated">비동기 &lt;code&gt;get-next-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce12675017eba1aad96dc4af8158e8ade8a6e141" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="translated">비동기 &lt;code&gt;get-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07690d2c187b7cfafc60389b63d0ee62b7cd3c1c" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="translated">비동기식 &lt;code&gt;set-request&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c4f45c7554c3415b2762a3d8f5669acc6525702" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">비동기 요청 정리 시간 모든 요청에 ​​대해 일부 정보는 내부에 저장되어 응답이 도착할 때 적절한 목적지로 전달할 수 있습니다. 회신이 도착하면이 정보가 삭제됩니다. 그러나 응답이 없으면 (시간 내에) 시간이 지나기 &lt;strong&gt;전에 가장 좋은&lt;/strong&gt; 정보를 삭제해야합니다 . 이 정리는 &lt;code&gt;server_timeout()&lt;/code&gt; 시간으로 정의 된 일정한 간격으로 수행됩니다 . 요청 함수를 호출 할 때 지정된 &lt;code&gt;Expire&lt;/code&gt; 시간으로 정의 된 &lt;strong&gt;최상의&lt;/strong&gt; 정보를 갖습니다 ( &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f4ef40b42e8c28e77390dcc6fa14ba97907a734" translate="yes" xml:space="preserve">
          <source>Asynchronous request for cancellation. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the cancellation to be performed synchronously. When &lt;code&gt;Async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the cancel operation is performed asynchronously. That is, &lt;code&gt;cancel_timer()&lt;/code&gt; sends an asynchronous request for cancellation to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">취소를위한 비동기 요청. &lt;code&gt;Async&lt;/code&gt; 기본값은 &lt;code&gt;false&lt;/code&gt; 로 , 취소가 동 기적으로 수행됩니다. &lt;code&gt;Async&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 취소 작업이 비동기 적으로 수행됩니다. 즉, &lt;code&gt;cancel_timer()&lt;/code&gt; 는 타이머를 관리하는 타이머 서비스에 취소에 대한 비동기 요청을 보낸 다음 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="95fd03b1444c479be3c52aee359cb2dfca32c856" translate="yes" xml:space="preserve">
          <source>Asynchronous request for state information. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the operation to be performed synchronously. In this case, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:read_timer&lt;/code&gt;. When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;erlang:read_timer&lt;/code&gt; sends an asynchronous request for the state information to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;. A message on the format &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:read_timer&lt;/code&gt; when the operation has been processed.</source>
          <target state="translated">상태 정보에 대한 비동기 요청. &lt;code&gt;Async&lt;/code&gt; 기본값은 &lt;code&gt;false&lt;/code&gt; 이며, 이로 인해 작업이 동 기적으로 수행됩니다. 이 경우 &lt;code&gt;Result&lt;/code&gt; 는 &lt;code&gt;erlang:read_timer&lt;/code&gt; 에 의해 리턴됩니다 . 때 &lt;code&gt;Async&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;erlang:read_timer&lt;/code&gt; , 타이머를 관리하는 타이머 서비스에 대한 상태 정보에 대한 비동기 요청을 전송 한 후 반환 &lt;code&gt;ok&lt;/code&gt; . 작업이 처리되면 &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; 형식의 메시지 가 &lt;code&gt;erlang:read_timer&lt;/code&gt; 의 호출자에게 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ca776a5d287d8b2a7dc6071e248dbb73c2d391b" translate="yes" xml:space="preserve">
          <source>Asynchronously append a list of items to a disk log. &lt;code&gt;alog_terms/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog_terms/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog_terms/2&lt;/code&gt; can also be used for internally formatted logs if the binaries are constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">디스크 로그에 항목 목록을 비동기 적으로 추가합니다. &lt;code&gt;alog_terms/2&lt;/code&gt; 는 내부 형식의 로그에 &lt;code&gt;balog_terms/2&lt;/code&gt; 는 외부 형식의 로그에 사용됩니다. 바이너리가 &lt;code&gt;term_to_binary/1&lt;/code&gt; 호출로 구성된 경우 &lt;code&gt;balog_terms/2&lt;/code&gt; 는 내부 형식화 된 로그에도 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb5375e7ef1ea5eaaf79230eafedb013e5c6183e" translate="yes" xml:space="preserve">
          <source>Asynchronously append an item to a disk log. &lt;code&gt;alog/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog/2&lt;/code&gt; can also be used for internally formatted logs if the binary is constructed with a call to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">디스크 로그에 항목을 비동기 적으로 추가합니다. &lt;code&gt;alog/2&lt;/code&gt; 는 내부 형식의 로그에 &lt;code&gt;balog/2&lt;/code&gt; 는 외부 형식의 로그에 사용됩니다. 바이너리가 &lt;code&gt;term_to_binary/1&lt;/code&gt; 에 대한 호출로 구성된 경우 &lt;code&gt;balog/2&lt;/code&gt; 는 내부 형식화 된 로그에도 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4919029fc256c29ef79f5f904616a2c8e94c3f2" translate="yes" xml:space="preserve">
          <source>At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for recursive patterns is described below.</source>
          <target state="translated">&quot;최상위 수준&quot;에서는 이러한 모든 재귀 테스트 조건이 거짓입니다. 재귀 패턴의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f43d3dd154d77c634c392d671f75757f296a087e" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; contains a list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">에 &lt;code&gt;success()&lt;/code&gt; 의 &lt;code&gt;UserReply&lt;/code&gt; 는 아마도 오류 표시를 포함하는 'ActionReply'기록의 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d45243ad2c3b8770cad6640db0cb04483b46411" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; either contains:</source>
          <target state="translated">에 &lt;code&gt;success()&lt;/code&gt; 의 &lt;code&gt;UserReply&lt;/code&gt; 이 하나 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="a23e179a407d51751e1caa4f70ab6a111682bb8b" translate="yes" xml:space="preserve">
          <source>At any time, the current Erlang Top display can be dumped to a text file with function &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">언제든지 현재 Erlang Top 디스플레이를 &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 텍스트 파일로 덤프 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1d3d95e4cd84ec49bb6d5fe0b90a58ea62ba48" translate="yes" xml:space="preserve">
          <source>At any time, to get the current status of the test nodes, call function &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">언제든지 테스트 노드의 현재 상태를 얻으려면 함수 &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd91a4b48e4394db081304cf8a7e752960166fb5" translate="yes" xml:space="preserve">
          <source>At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</source>
          <target state="translated">서브 패턴의 각 반복에서 역 참조는 이전 반복에 해당하는 문자열과 일치합니다. 이것이 작동하기 위해서는 첫 번째 반복이 역 참조와 일치 할 필요가없는 패턴이어야합니다. 이것은 위의 예에서와 같이 교대를 사용하거나 최소 0의 정량 자로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b373a9f8122a8a2b8c68bd7132b1ca7c2848e49f" translate="yes" xml:space="preserve">
          <source>At each record access, &lt;code&gt;mnesia_frag&lt;/code&gt; first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</source>
          <target state="translated">각 레코드 액세스에서 &lt;code&gt;mnesia_frag&lt;/code&gt; 는 먼저 레코드 키에서 해시 값을 계산합니다. 둘째, 테이블 조각의 이름은 해시 값에서 결정됩니다. 마지막으로 실제 테이블 액세스는 조각화되지 않은 테이블과 동일한 기능으로 수행됩니다. 키를 미리 알 수없는 경우 모든 조각에서 일치하는 레코드를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e791bb91b86137f009adcbd36f18e163d6c841d5" translate="yes" xml:space="preserve">
          <source>At least one other identifier type besides &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; must also have a list of identifiers.</source>
          <target state="translated">&lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; 이외의 다른 식별자 유형 에는 식별자 목록이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6e34fe0dc564614befa189e8748c8b5b71f49e4" translate="yes" xml:space="preserve">
          <source>At present only the default module is provided with the agent, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt;.</source>
          <target state="translated">현재 기본 모듈 만 에이전트 &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; 과 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="52b6928d79b0ae8a32944a5857ee7a65e4d13aa4" translate="yes" xml:space="preserve">
          <source>At start-up, a node has a random atom assigned as its magic cookie and the cookie of other nodes is assumed to be &lt;code&gt;nocookie&lt;/code&gt;. The first action of the Erlang network authentication server (&lt;code&gt;auth&lt;/code&gt;) is then to read a file named &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt;. If the file does not exist, it is created. The UNIX permissions mode of the file is set to octal 400 (read-only by user) and its contents are a random string. An atom &lt;code&gt;Cookie&lt;/code&gt; is created from the contents of the file and the cookie of the local node is set to this using &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt;. This also makes the local node assume that all other nodes have the same cookie &lt;code&gt;Cookie&lt;/code&gt;.</source>
          <target state="translated">시작할 때 노드는 매직 쿠키로 지정된 임의의 원자를 가지며 다른 노드의 쿠키는 &lt;code&gt;nocookie&lt;/code&gt; 로 간주됩니다 . Erlang 네트워크 인증 서버 ( &lt;code&gt;auth&lt;/code&gt; ) 의 첫 번째 조치는 &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt; 파일을 읽는 것 입니다. 파일이 없으면 작성됩니다. 파일의 UNIX 권한 모드는 8 진 400 (사용자가 읽기 전용)으로 설정하고 내용은 임의의 문자열입니다. 아톰 &lt;code&gt;Cookie&lt;/code&gt; 는 파일의 컨텐츠에서 작성되며 로컬 노드의 쿠키는 &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt; 사용하여 쿠키로 설정됩니다 . 또한 로컬 노드는 다른 모든 노드에 동일한 쿠키 &lt;code&gt;Cookie&lt;/code&gt; 가 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="518744e98c40235fc6bb7d9cc4f9e7b8cd708382" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; assumes that its local replica is the most recent version and loads the table from disc if either of the following situations is detected:</source>
          <target state="translated">시작시 &lt;code&gt;Mnesia&lt;/code&gt; 는 로컬 복제본이 최신 버전 인 것으로 가정하고 다음 상황 중 하나가 감지되면 디스크에서 테이블을로드합니다.</target>
        </trans-unit>
        <trans-unit id="e5838a6fe5958edaad5f512813e7c830bd8af3cc" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, &lt;code&gt;Mnesia&lt;/code&gt; performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise &lt;code&gt;Mnesia&lt;/code&gt; shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</source>
          <target state="translated">시작시 &lt;code&gt;Mnesia&lt;/code&gt; 는 서로 다른 노드를 서로 연결 한 다음 테이블 정의를 서로 교환하며 테이블 정의가 병합됩니다. 병합 절차 중 &lt;code&gt;Mnesia&lt;/code&gt; 는 테이블 정의가 서로 호환되는지 확인하기 위해 무결성 테스트를 수행합니다. 테이블이 여러 노드에 존재하는 경우 쿠키는 동일해야하며, 그렇지 않으면 &lt;code&gt;Mnesia&lt;/code&gt; 는 노드 중 하나를 종료합니다. 이 불행한 상황은 연결이 끊어진 동안 두 노드에서 서로 독립적으로 테이블이 작성된 경우에 발생합니다. 이를 해결하려면 테이블 중 하나를 삭제해야합니다 (쿠키가 다르기 때문에 이름이 같은 경우에도 두 개의 다른 테이블로 간주 됨).</target>
        </trans-unit>
        <trans-unit id="a627688b56cf27035c1a223f76b7c1a970186939" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; loads tables to make them accessible for its applications. Sometimes &lt;code&gt;Mnesia&lt;/code&gt; decides to load all tables that reside locally, and sometimes the tables are not accessible until &lt;code&gt;Mnesia&lt;/code&gt; brings a copy of the table from another node.</source>
          <target state="translated">시작시 &lt;code&gt;Mnesia&lt;/code&gt; 는 테이블을로드하여 해당 응용 프로그램에 액세스 할 수 있도록합니다. 때로는 &lt;code&gt;Mnesia&lt;/code&gt; 는 로컬에있는 모든 테이블을로드하기로 결정 때까지 때로는 테이블에 액세스 할 수 없습니다 &lt;code&gt;Mnesia&lt;/code&gt; 가 다른 노드에서 테이블의 사본을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d42e266b7e766640fca49bd15e785ddd09a12678" translate="yes" xml:space="preserve">
          <source>At startup, Mnesia always loads &lt;code&gt;read_only&lt;/code&gt; table locally regardless of when and if Mnesia is terminated on other nodes. This argument returns the access mode of the table. The access mode can be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="translated">시작시, Mnesia 항상로드 &lt;code&gt;read_only&lt;/code&gt; 로컬에 관계없이 때의 테이블과 Mnesia 다른 노드에서 종료합니다. 이 인수는 테이블의 액세스 모드를 리턴합니다. 액세스 모드는 &lt;code&gt;read_only&lt;/code&gt; 또는 &lt;code&gt;read_write&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd3b6f4ef0dfb0e46121f11afdceab8754106c9b" translate="yes" xml:space="preserve">
          <source>At startup, notice that all tables residing on nodes without a &lt;code&gt;mnesia_down&lt;/code&gt; entry can have fresher replicas. Their replicas can have been updated after the termination of &lt;code&gt;Mnesia&lt;/code&gt; on the current node. To catch up with the latest updates, transfer a copy of the table from one of these other &quot;fresh&quot; nodes. If you are unlucky, other nodes can be down and you must wait for the table to be loaded on one of these nodes before receiving a fresh copy of the table.</source>
          <target state="translated">시작시, &lt;code&gt;mnesia_down&lt;/code&gt; 항목이 없는 노드에있는 모든 테이블 은 더 새로운 복제본을 가질 수 있습니다. 현재 노드 에서 &lt;code&gt;Mnesia&lt;/code&gt; 가 종료 된 후에 복제본을 업데이트 할 수 있습니다 . 최신 업데이트를 확인하려면 이러한 다른 &quot;신선한&quot;노드 중 하나에서 테이블 사본을 전송하십시오. 운이 좋지 않으면 다른 노드가 작동 중지 될 수 있으며 테이블의 새로운 사본을 수신하기 전에 이러한 노드 중 하나에 테이블이로드 될 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="cebd2da32e4452b268c6c9625fdcaae6da724209" translate="yes" xml:space="preserve">
          <source>At startup, the &lt;code&gt;Mnesia&lt;/code&gt; normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of potential &lt;code&gt;mnesia_down&lt;/code&gt; entries in the log. &lt;code&gt;Nodes&lt;/code&gt; can only contain nodes where the table has a replica. If &lt;code&gt;Nodes&lt;/code&gt; is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">시작시 &lt;code&gt;Mnesia&lt;/code&gt; 일반 테이블로드 알고리즘이 무시되고 로그 의 잠재적 &lt;code&gt;mnesia_down&lt;/code&gt; 항목에 관계없이 테이블에 대해 정의 된 마스터 노드 중 하나에서 테이블이로드됩니다 . &lt;code&gt;Nodes&lt;/code&gt; 는 테이블에 복제본이있는 노드 만 포함 할 수 있습니다. &lt;code&gt;Nodes&lt;/code&gt; 가 비어 있으면 특정 테이블의 마스터 노드 복구 메커니즘이 재설정되고 다음에 다시 시작할 때 일반로드 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6322370642204a58e29b000b086020c58026493" translate="yes" xml:space="preserve">
          <source>At system start, Logger is configured through Kernel configuration parameters. The parameters that apply to Logger are described in section &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt;. Examples are found in section &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시스템 시작시 로거는 커널 구성 매개 변수를 통해 구성됩니다. 로거에 적용되는 매개 변수는 &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있습니다. 예는 &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d12c0011c249bb23aab720fbf3331a64e7f920" translate="yes" xml:space="preserve">
          <source>At the Media Gateway Controller (MGC) side it is possible to reject a connection request (and send a message error reply to the gateway) by returning &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; or simply &lt;code&gt;error&lt;/code&gt; which generates an error descriptor with code 402 (unauthorized) and reason &quot;Connection refused by user&quot; (this is also the case for all unknown results, such as exit signals or throw).</source>
          <target state="translated">미디어 게이트웨이 제어기 (MGC)쪽에는 연결 요청을 거부 (게이트웨이에 메시지 에러 응답을 전송하는) 복귀가 가능하다 &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; 또는 단순히 &lt;code&gt;error&lt;/code&gt; 코드 (402) (무단)에 오류 디스크립터를 생성하고, 이유 &quot;사용자가 연결을 거부했습니다&quot;(종료 신호 또는 던지기와 같은 알 수없는 결과가 모두있는 경우).</target>
        </trans-unit>
        <trans-unit id="082190436d06dd5d49208af168f795454a1d2c3e" translate="yes" xml:space="preserve">
          <source>At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against</source>
          <target state="translated">경기가 끝나면 캡처 괄호의 값은 가장 바깥 쪽 레벨의 값입니다. 위의 패턴이</target>
        </trans-unit>
        <trans-unit id="a0bd3386c01848e616038cd3be0a42aca1ff92e4" translate="yes" xml:space="preserve">
          <source>At the end of phase one, the user defined &lt;code&gt;is_set_ok&lt;/code&gt; functions are called for each scalar variable, and for each group of table operations.</source>
          <target state="translated">1 단계가 끝나면 사용자 정의 &lt;code&gt;is_set_ok&lt;/code&gt; 함수가 각 스칼라 변수 및 각 테이블 조작 그룹에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7141009a47e03284bdfb55bb6f57dbdb2f6af74" translate="yes" xml:space="preserve">
          <source>At the end of the file the following call is made to indicate the end of the transfer:</source>
          <target state="translated">파일의 끝에서 전송의 끝을 표시하기 위해 다음 호출이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f5e152a75003f4c0eecbf24783ff86692b5ac63" translate="yes" xml:space="preserve">
          <source>At the moment this is always an empty list as policies are not currently supported.</source>
          <target state="translated">현재 정책이 지원되지 않으므로 현재 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ffb7455412e52bcc56b05d38e6e5253be2bc9d2d" translate="yes" xml:space="preserve">
          <source>At the other end, a server is listening on port 5678, accepts the connection, and receives the binary:</source>
          <target state="translated">다른 쪽에서 서버는 포트 5678에서 수신 대기하고 연결을 수락하며 바이너리를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a2ee7dea7134049488781051edab25bd2f008623" translate="yes" xml:space="preserve">
          <source>At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are not part of the recursion.)</source>
          <target state="translated">최상위 레벨에서 첫 번째 문자는 일치하지만 문자열의 끝에 있지 않으므로 첫 번째 대체는 실패하고 두 번째 대체는 취해지고 재귀는 시작됩니다. 하위 패턴 1에 대한 재귀 호출은 다음과 일치합니다. 문자 ( &quot;b&quot;). (라인 시작과 끝 테스트는 재귀의 일부가 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="ed2220b4de1fb3635d6a43309a72686050501dc1" translate="yes" xml:space="preserve">
          <source>At this point it would make sense to create a &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt;, but in this particular example the compiler sees that there will soon be a call to a function (in this case, to &lt;code&gt;my_binary_to_list/1&lt;/code&gt; itself) that immediately will create a new match context and discard the sub binary.</source>
          <target state="translated">이 시점에서 &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt; 를 생성하는 것이 이치에 맞지만,이 특정 예제에서 컴파일러는 곧 새로운 매치 컨텍스트를 생성하는 함수 (이 경우에는 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 자체)가 호출 될 것임을 알게 됩니다. 하위 바이너리를 버립니다.</target>
        </trans-unit>
        <trans-unit id="2a5d6ede3e3967bfd759ea91b6f59bd9213c0242" translate="yes" xml:space="preserve">
          <source>At this stage when we have a couple of &lt;code&gt;Events&lt;/code&gt;, it is time to show how it looks like in the graphical interface of &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="translated">이 단계에서 몇 개의 &lt;code&gt;Events&lt;/code&gt; 가있을 때 &lt;code&gt;et_viewer&lt;/code&gt; 의 그래픽 인터페이스에서 어떻게 보이는지 보여줄 차례입니다 .</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="c3c309f16bf4b6076b8eb93fd32be986ed93ed91" translate="yes" xml:space="preserve">
          <source>Atom ::= - same as Erlang atoms -</source>
          <target state="translated">원자 :: =-Erlang 원자와 동일-</target>
        </trans-unit>
        <trans-unit id="51343a15868219ae0470e742ba631bc7eec26597" translate="yes" xml:space="preserve">
          <source>Atom is another data type in Erlang. Atoms start with a small letter (see &lt;code&gt;Atom&lt;/code&gt;), for example, &lt;code&gt;charles&lt;/code&gt;, &lt;code&gt;centimeter&lt;/code&gt;, and &lt;code&gt;inch&lt;/code&gt;. Atoms are simply names, nothing else. They are not like variables, which can have a value.</source>
          <target state="translated">원자는 Erlang의 또 다른 데이터 유형입니다. 원자는 작은 편지 (참조로 시작 &lt;code&gt;Atom&lt;/code&gt; 예를 들어, 용), &lt;code&gt;charles&lt;/code&gt; , &lt;code&gt;centimeter&lt;/code&gt; 와 &lt;code&gt;inch&lt;/code&gt; . 원자는 단순한 이름 일뿐입니다. 그것들은 값을 가질 수있는 변수와는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7195f879141a5a8ba030248689c692d5148b0ee2" translate="yes" xml:space="preserve">
          <source>AtomConst ::= Application | Module | Release</source>
          <target state="translated">AtomConst :: = 응용 프로그램 | 모듈 | 해제</target>
        </trans-unit>
        <trans-unit id="1c66839560fb43e9f121274907f35e59ef182189" translate="yes" xml:space="preserve">
          <source>Atomic Memory Operations and the VM</source>
          <target state="translated">원자 메모리 작업 및 VM</target>
        </trans-unit>
        <trans-unit id="285aeb96eeef706de92b804eae05d172e8e0a60b" translate="yes" xml:space="preserve">
          <source>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both \d+ and \d+? are prepared to adjust the number of digits they match to make the remaining pattern match, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; can only match an entire sequence of digits.</source>
          <target state="translated">원자 그룹화 하위 패턴은 하위 패턴을 캡처하지 않습니다. 위의 예와 같은 간단한 사례는 가능한 모든 것을 삼켜야하는 최대 반복으로 생각할 수 있습니다. 그래서 \ d +와 \ d +는? 나머지 패턴이 일치하도록 일치하는 자릿수를 조정할 준비가되어 있으며 &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; 는 전체 자릿수 만 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70263cc27057f40aecb08445d5e4246aa30c686a" translate="yes" xml:space="preserve">
          <source>Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &quot;possessive quantifier&quot; can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as</source>
          <target state="translated">일반적으로 원자 그룹은 복잡한 하위 패턴을 포함 할 수 있으며 중첩 될 수 있습니다. 그러나, 원자 그룹에 대한 서브 패턴이 단지 하나의 반복 된 항목 일 때, 위의 예에서와 같이, &quot;포스 퍼시 티브 정량화 기&quot;라 불리는보다 간단한 표기법이 사용될 수있다. 이것은 수량 자 다음에 + 문자로 구성됩니다. 이 표기법을 사용하여 이전 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d74d1749d4da9ae8e4ba38276cc8935928009a4" translate="yes" xml:space="preserve">
          <source>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction.</source>
          <target state="translated">원자 거래. 일련의 테이블 조작 작업을 단일 원자 트랜잭션으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24ad40d30afa103adc1e00c3958d38ebb6700ca" translate="yes" xml:space="preserve">
          <source>Atomically changes the registered name &lt;code&gt;Name&lt;/code&gt; on all nodes to refer to &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 를 참조하기 위해 모든 노드 에서 등록 된 이름 &lt;code&gt;Name&lt;/code&gt; 을 원자 적으로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="ee048f7e55224c5c36ed6495f528ec9c74109599" translate="yes" xml:space="preserve">
          <source>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function &lt;code&gt;raise/2&lt;/code&gt;, shown in the previous example, writes one record only. The function &lt;code&gt;insert_emp/3&lt;/code&gt;, shown in the program listing in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, writes the record &lt;code&gt;employee&lt;/code&gt; as well as employee relations, such as &lt;code&gt;at_dep&lt;/code&gt; and &lt;code&gt;in_proj&lt;/code&gt;, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</source>
          <target state="translated">원자 성은 동일한 트랜잭션에서 원자 적으로 두 개 이상의 레코드를 작성해야 할 때 중요합니다. 앞의 예제에 표시된 &lt;code&gt;raise/2&lt;/code&gt; 함수 는 하나의 레코드 만 씁니다. &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; 의 프로그램 목록에 표시된 &lt;code&gt;insert_emp/3&lt;/code&gt; 함수 는 레코드 &lt;code&gt;employee&lt;/code&gt; 뿐만 아니라 &lt;code&gt;at_dep&lt;/code&gt; 및 &lt;code&gt;in_proj&lt;/code&gt; 와 같은 직원 관계를 데이터베이스에 기록합니다. 후자의 코드가 트랜잭션 내에서 실행되면 트랜잭션 핸들러는 트랜잭션이 완전히 성공하거나 전혀 성공하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="9e7bf26b3574db121c0f9c2d5135066a290bba9b" translate="yes" xml:space="preserve">
          <source>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</source>
          <target state="translated">원 자성이란 트랜잭션에 의해 실행되는 데이터베이스 변경이 관련된 모든 노드에 적용되거나 노드에 영향을 미치지 않음을 의미합니다. 즉, 트랜잭션이 완전히 성공하거나 완전히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="8b4ce0020874da6c44e911622f2debe1461e0f0d" translate="yes" xml:space="preserve">
          <source>Atoms and variables can use all Latin-1 letters.</source>
          <target state="translated">원자와 변수는 모든 Latin-1 문자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e89bc7b897d5b27ce2d498db94d099bf846c461" translate="yes" xml:space="preserve">
          <source>Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached.</source>
          <target state="translated">원자는 가비지 수집되지 않습니다. 원자가 생성되면 절대 제거되지 않습니다. 원자 수의 한계 (기본적으로 1,048,576)에 도달하면 에뮬레이터가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="53953ef0095a671ea4007a14634a7ef6dcdd0975" translate="yes" xml:space="preserve">
          <source>Atoms starting with &lt;code&gt;@&lt;/code&gt;, for example &lt;code&gt;'@foo'&lt;/code&gt; or &lt;code&gt;'@Foo'&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 으로 시작하는 원자 ( 예 : &lt;code&gt;'@foo'&lt;/code&gt; 또는 &lt;code&gt;'@Foo'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1f2e1b1dd67aa033d9dce573a905b7f9461d62" translate="yes" xml:space="preserve">
          <source>Attaches comments to a syntax tree. The result is a pair &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; where &lt;code&gt;NewTree&lt;/code&gt; is the given &lt;code&gt;Tree&lt;/code&gt; where comments from the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places. &lt;code&gt;Remainder&lt;/code&gt; is the list of entries in &lt;code&gt;Comments&lt;/code&gt; which have not been inserted, because their line numbers are greater than those of any node in the tree. The entries in &lt;code&gt;Comments&lt;/code&gt; are inserted in order; if two comments become attached to the same node, they will appear in the same order in the program text.</source>
          <target state="translated">구문 트리에 주석을 첨부합니다. 결과는 &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; 쌍입니다. 여기서 &lt;code&gt;NewTree&lt;/code&gt; 는 목록의 &lt;code&gt;Comments&lt;/code&gt; 이 올바른 위치에 첨부 ​​된 지정된 &lt;code&gt;Tree&lt;/code&gt; 입니다. &lt;code&gt;Remainder&lt;/code&gt; 는 줄의 번호가 트리에있는 노드의 번호보다 커서 &lt;code&gt;Comments&lt;/code&gt; 에 삽입되지 않은 항목의 목록입니다 . &lt;code&gt;Comments&lt;/code&gt; 의 항목은 순서대로 삽입됩니다. 두 개의 주석이 동일한 노드에 첨부되면 프로그램 텍스트에서 동일한 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d2ceee4cae7cbba986c24f620add3c4dd9b79139" translate="yes" xml:space="preserve">
          <source>Attaches comments to the syntax tree/trees representing a program. The given &lt;code&gt;Forms&lt;/code&gt; should be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. The syntax trees must contain valid position information (for details, see &lt;code&gt;recomment_tree/2&lt;/code&gt;). The result is a corresponding syntax tree of type &lt;code&gt;form_list&lt;/code&gt; in which all comments in the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places.</source>
          <target state="translated">프로그램을 나타내는 구문 트리 / 트리에 주석을 첨부합니다. 주어진 &lt;code&gt;Forms&lt;/code&gt; 는 &lt;code&gt;form_list&lt;/code&gt; 유형의 단일 구문 트리 이거나 &quot;프로그램 형식&quot;을 나타내는 구문 트리 목록 이어야 합니다. 구문 트리는 유효한 위치 정보를 포함해야합니다 (자세한 내용은 &lt;code&gt;recomment_tree/2&lt;/code&gt; 참조 ). 결과는 목록 &lt;code&gt;Comments&lt;/code&gt; 모든 주석 이 적절한 위치에 첨부 ​​된 &lt;code&gt;form_list&lt;/code&gt; 유형의 해당 구문 트리입니다 .</target>
        </trans-unit>
        <trans-unit id="08f3c18f1ef82b85d187f359be8053ba60fcff3a" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. An Attach Process window is opened for the process.</source>
          <target state="translated">디버깅 된 프로세스 &lt;code&gt;Pid&lt;/code&gt; 에 연결합니다 . 프로세스에 대한 프로세스 첨부 창이 열립니다.</target>
        </trans-unit>
        <trans-unit id="e858ba60db5ffa465fde04178472518163ea425c" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. The interpreter calls &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (and ignores the result).</source>
          <target state="translated">디버깅 된 프로세스 &lt;code&gt;Pid&lt;/code&gt; 에 연결합니다 . 인터프리터는 &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; 호출 합니다 ( 결과는 무시합니다).</target>
        </trans-unit>
        <trans-unit id="dc33862cfcafa306527c136f22aeb55fbb46ae26" translate="yes" xml:space="preserve">
          <source>Attaches to the process and open an &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스에 연결하고 프로세스 &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="a27b2860df5ad784c2a072eec792bd3ddbfbbcf2" translate="yes" xml:space="preserve">
          <source>Attempt to delete the current directory. On some platforms, &lt;code&gt;eacces&lt;/code&gt; is returned instead.</source>
          <target state="translated">현재 디렉토리를 삭제하십시오. 일부 플랫폼에서는 &lt;code&gt;eacces&lt;/code&gt; 가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4dd873defa6a2d59737d4e84f136645c52891193" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can also be used for turning on warnings. For example, if a module has been fixed regarding unmatched returns, adding the following line can help in assuring that no new unmatched return warnings are introduced:</source>
          <target state="translated">&lt;code&gt;-dialyzer()&lt;/code&gt; 속성을 사용하여 경고를 켤 수도 있습니다. 예를 들어, 일치하지 않는 반품과 관련하여 모듈이 수정 된 경우 다음 행을 추가하면 일치하지 않는 새로운 반품 경고가 발생하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94a2d033077fb7d4c11be4d28e975e8f7fa67d5d" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can be used for turning off warnings in a module by specifying functions or warning options. For example, to turn off all warnings for the function &lt;code&gt;f/0&lt;/code&gt;, include the following line:</source>
          <target state="translated">&lt;code&gt;-dialyzer()&lt;/code&gt; 속성 은 함수 또는 경고 옵션을 지정하여 모듈에서 경고를 끄는 데 사용할 수 있습니다. 예를 들어, &lt;code&gt;f/0&lt;/code&gt; 기능에 대한 모든 경고를 끄 려면 다음 행을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="3bb46baccc6ddbcfec9893a911a5598494b5fa7f" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; is allowed after function declarations. Lists of warning options or functions are allowed:</source>
          <target state="translated">&lt;code&gt;-dialyzer()&lt;/code&gt; 속성 은 함수 선언 후에 허용됩니다. 경고 옵션 또는 기능 목록이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="20497f389e60747b76a9f4c282fe115ff9e65b81" translate="yes" xml:space="preserve">
          <source>Attribute = {atom(), term()}</source>
          <target state="translated">속성 = {atom (), term ()}</target>
        </trans-unit>
        <trans-unit id="56cec620065c043a2c53d113a84f30cf04a24bfc" translate="yes" xml:space="preserve">
          <source>Attributes = [{Name, Value}| #xmlAttribute{}]</source>
          <target state="translated">속성 = [{이름, 값} | #xmlAttribute {}]</target>
        </trans-unit>
        <trans-unit id="8196898f60a411611bff755ce53bcb927eed9bf5" translate="yes" xml:space="preserve">
          <source>Audit Trail Logging</source>
          <target state="translated">감사 추적 로깅</target>
        </trans-unit>
        <trans-unit id="e7a0dac799c2ac1aee5c36d21a89de6463f1070c" translate="yes" xml:space="preserve">
          <source>Auth-Application-Id AVP</source>
          <target state="translated">인증 애플리케이션 ID AVP</target>
        </trans-unit>
        <trans-unit id="6f57677bc7cc52df8c3d26defd5359054852e0c9" translate="yes" xml:space="preserve">
          <source>Auth-Grace-Period AVP</source>
          <target state="translated">정통 기간 AVP</target>
        </trans-unit>
        <trans-unit id="ffad30279d0dbdebdba0995b72cf095104751ce5" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP</source>
          <target state="translated">인증 요청 유형 AVP</target>
        </trans-unit>
        <trans-unit id="bab9dd08fa19bdf6f1b4cf6e9f78668ae505c80e" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP Values</source>
          <target state="translated">인증 요청 유형 AVP 값</target>
        </trans-unit>
        <trans-unit id="d8ff104e64da7ae152dbd68cb8bb5ac85c8606c8" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP</source>
          <target state="translated">인증 세션 상태 AVP</target>
        </trans-unit>
        <trans-unit id="52aa2478028e9ddcf53894d8996729bb4145d0b1" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP Values</source>
          <target state="translated">인증 세션 상태 AVP 값</target>
        </trans-unit>
        <trans-unit id="b01542a7f0aa1f0864e6a230526030dbd833afdd" translate="yes" xml:space="preserve">
          <source>Authenticate the connection using simple authentication.</source>
          <target state="translated">간단한 인증을 사용하여 연결을 인증하십시오.</target>
        </trans-unit>
        <trans-unit id="efdb86330764c8fbe68da0d4b6819ef23c162680" translate="yes" xml:space="preserve">
          <source>Authenticating the integrity of the handshake messages.</source>
          <target state="translated">핸드 셰이크 메시지의 무결성을 인증합니다.</target>
        </trans-unit>
        <trans-unit id="7a30fd25c7a3f93a7b30740a0a98229a0638bb08" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt;net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="translated">인증 ( &lt;code&gt;net_kernel(3)&lt;/code&gt; ) (3)</target>
        </trans-unit>
        <trans-unit id="dc6b01190c75db5a643cf18f6685ef326b9bb4bb" translate="yes" xml:space="preserve">
          <source>Authentication determines which nodes are allowed to communicate with each other. In a network of different Erlang nodes, it is built into the system at the lowest possible level. Each node has its own &lt;strong&gt;magic cookie&lt;/strong&gt;, which is an Erlang atom.</source>
          <target state="translated">인증은 서로 통신 할 수있는 노드를 결정합니다. 다른 Erlang 노드의 네트워크에서는 가능한 가장 낮은 레벨의 시스템에 내장되어 있습니다. 각 노드에는 Erlang 원자 인 자체 &lt;strong&gt;매직 쿠키&lt;/strong&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b69c9c9364edcba7a03ffefeefa382cf82287356" translate="yes" xml:space="preserve">
          <source>Authentication of the peer is done by public key path validation as defined in RFC 3280. This means basically the following:</source>
          <target state="translated">피어 인증은 RFC 3280에 정의 된 공개 키 경로 유효성 검사에 의해 수행됩니다. 이는 기본적으로 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="65b45c1a860b3348b9833c0a96364a1acd14c2b7" translate="yes" xml:space="preserve">
          <source>Authentication/access checks.</source>
          <target state="translated">인증 / 액세스 확인</target>
        </trans-unit>
        <trans-unit id="1ba9c0e85dda9702580d19335be06fa7a8c504cb" translate="yes" xml:space="preserve">
          <source>Authorization Session State Machine</source>
          <target state="translated">권한 부여 세션 상태 머신</target>
        </trans-unit>
        <trans-unit id="cd708bd6499f399dc5b86474d073a1c2f25376ad" translate="yes" xml:space="preserve">
          <source>Authorization and accounting AVPs are defined in provided dictionaries. Their proper use is the responsibility of the user.</source>
          <target state="translated">권한 부여 및 회계 AVP는 제공된 사전에 정의되어 있습니다. 올바른 사용은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="f163341ede12f9adebdea0335c91c64ca9f864cb" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user.</source>
          <target state="translated">승인은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="50b27cabe4dbb1d4ad17bfe9e56741a4affc2eea" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">권한은 사용자의 책임입니다. 직경은이 상태 머신을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30ed2a3e728e1f003c2a2c8e103841be8b0ec854" translate="yes" xml:space="preserve">
          <source>Authorization-Lifetime AVP</source>
          <target state="translated">승인 평생 AVP</target>
        </trans-unit>
        <trans-unit id="edd7b5046b035f96ef22223b25da57cd6e60a20a" translate="yes" xml:space="preserve">
          <source>Authorized keys - OpenSSH format looks as follows:</source>
          <target state="translated">인증 된 키-OpenSSH 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a574cde3f8131fcb2c5ef5b3ac87763f839e4628" translate="yes" xml:space="preserve">
          <source>Auto-imported BIFs are listed without module prefix. BIFs listed with module prefix are not auto-imported.</source>
          <target state="translated">자동 가져온 BIF는 모듈 접두사없이 나열됩니다. 모듈 접두사와 함께 나열된 BIF는 자동으로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5883a7e0cca29e11fe6124ccc75bacf71f8b9f1" translate="yes" xml:space="preserve">
          <source>Automated execution of test suites (sets of test cases)</source>
          <target state="translated">테스트 스위트의 자동 실행 (테스트 케이스 세트)</target>
        </trans-unit>
        <trans-unit id="d436c113d37a4bf9ab8a69c9c589f736a5417312" translate="yes" xml:space="preserve">
          <source>Automatic compilation of test suites (and help modules)</source>
          <target state="translated">테스트 스위트 (및 도움말 모듈) 자동 컴파일</target>
        </trans-unit>
        <trans-unit id="fccc42c97a2ffc422d0e26337a4e4d5dff20a9b3" translate="yes" xml:space="preserve">
          <source>Automatic send transaction ack when the transaction reply has been received (see &lt;code&gt;trans_ack&lt;/code&gt; below).</source>
          <target state="translated">트랜잭션 응답이 수신 될 때 자동 전송 트랜잭션 확인 (아래 &lt;code&gt;trans_ack&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="ca478c0ab639849e3541da90cb17a860b5490d08" translate="yes" xml:space="preserve">
          <source>Automatic send transaction pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">트랜잭션 응답이 전송되기 전에 타이머가 만료되면 자동 전송 트랜잭션 보류 중입니다. 이 타이머는 임시 응답 타이머라고도합니다.</target>
        </trans-unit>
        <trans-unit id="93da85ea44d26c2624d1e105b7f890bc46bd09ba" translate="yes" xml:space="preserve">
          <source>Automatic state enter calls</source>
          <target state="translated">자동 상태 입력 통화</target>
        </trans-unit>
        <trans-unit id="2a89768431c505706353574d66358c32a869dccc" translate="yes" xml:space="preserve">
          <source>Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">자동 유형 캐스팅은 크기가 32 비트보다 큰 드라이버에만 이러한 변경이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef94894ba2f4eb73cf0fd7bdecec218163555bf" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;HandlerId&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">로거에 의해 자동으로 삽입됩니다. 값은 핸들러를 추가 할 때 지정된 &lt;code&gt;HandlerId&lt;/code&gt; 와 동일 하며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="77c6bd373dea25df6392c697b76ebb783fd68b3e" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;Module&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">로거에 의해 자동으로 삽입됩니다. 값은 핸들러를 추가 할 때 지정된 &lt;code&gt;Module&lt;/code&gt; 과 동일 하며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="32d8c661feaa1a96e94bb053c82356a83532060b" translate="yes" xml:space="preserve">
          <source>Automatically send pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">트랜잭션 응답이 전송되기 전에 타이머가 만료되면 자동으로 보류 중입니다. 이 타이머는 임시 응답 타이머라고도합니다.</target>
        </trans-unit>
        <trans-unit id="18da0ae80b2a3d06e9335371a77bc11e953c941d" translate="yes" xml:space="preserve">
          <source>Autoresume</source>
          <target state="translated">Autoresume</target>
        </trans-unit>
        <trans-unit id="440311567fa2e46e6495460ee5e7f6ca1160021b" translate="yes" xml:space="preserve">
          <source>Available only in some POSIX systems, this call results in a call to &lt;code&gt;fsync()&lt;/code&gt;, or has no effect in systems not providing the &lt;code&gt;fdatasync()&lt;/code&gt; syscall.</source>
          <target state="translated">일부 POSIX 시스템에서만 사용 가능한이 호출은 &lt;code&gt;fsync()&lt;/code&gt; 호출 하거나 &lt;code&gt;fdatasync()&lt;/code&gt; syscall을 제공하지 않는 시스템에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a5325c58f3190f03981f3d4b6e263a0fcae8b5bc" translate="yes" xml:space="preserve">
          <source>Available options are:</source>
          <target state="translated">사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="057b4b33c8569c09b413019743ff85bf2e11c330" translate="yes" xml:space="preserve">
          <source>Available options:</source>
          <target state="translated">사용 가능한 옵션 :</target>
        </trans-unit>
        <trans-unit id="4e9d1b7f151f31fb76e5b9ef9857c7c1cae6dcf2" translate="yes" xml:space="preserve">
          <source>Available properties are the same as the start options of the server, but the properties &lt;code&gt;bind_address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; cannot be changed.</source>
          <target state="translated">사용 가능한 속성은 서버의 시작 옵션과 동일하지만 &lt;code&gt;bind_address&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 속성 은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef104ec434506c3596f5487f13a01379d4ba6bd2" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;'receive'&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">추적 플래그 &lt;code&gt;'receive'&lt;/code&gt; 및 추적 프로그램 모듈로 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 가있는 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="27f7db47a04206f9b18980fb6fca2934f7e7d231" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">추적 플래그 &lt;code&gt;call&lt;/code&gt; 및 추적 프로그램 모듈로 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 와 함께 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="ec9c72570d3ed2f9817e1e27636799b0c17600b7" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;return_to&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">추적 플래그 &lt;code&gt;call&lt;/code&gt; 또는 &lt;code&gt;return_to&lt;/code&gt; 및 추적 프로그램 모듈로 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 와 함께 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="19369e2b69d2d29bcf7d2b110bd632c0497eadc1" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;garbage_collection&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">추적 플래그가 &lt;code&gt;garbage_collection&lt;/code&gt; 이고 추적 프로그램 모듈로 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 가있는 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="0b14892085d0235611acf16621043bf554272c4b" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">추적 플래그 &lt;code&gt;ports&lt;/code&gt; 및 추적 프로그램 모듈로 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 가있는 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="98fc651851a4575e9edd1b04d22bca4d2ff1533e" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;procs&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">관통 가능한 &lt;code&gt;erlang:trace/3&lt;/code&gt; 추적 플래그와 &lt;code&gt;procs&lt;/code&gt; 및 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 추적 모듈로.</target>
        </trans-unit>
        <trans-unit id="3f46a50dcc99ab759ab69e8cdf416560bd6713f8" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">추적 플래그가 &lt;code&gt;running&lt;/code&gt; 되고 추적 프로그램 모듈로 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 가있는 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="04747a5c4337891e1a74cc42657f396a199e1343" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">추적 플래그 &lt;code&gt;send&lt;/code&gt; 및 추적 프로그램 모듈로 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; 와 함께 &lt;code&gt;erlang:trace/3&lt;/code&gt; 를 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="0979e25ae12ecf75e6954405c51afc218144f433" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, received by the socket.</source>
          <target state="translated">소켓이 수신 한 평균 패킷 크기 편차 (바이트).</target>
        </trans-unit>
        <trans-unit id="24a6380cb9d560f221f5bab0ac3ac216888c3989" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, sent from the socket.</source>
          <target state="translated">소켓에서 전송 된 평균 패킷 크기 편차 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="ba5da32502768a08b71f47f54787f1a18d984da2" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, received by the socket.</source>
          <target state="translated">소켓이 수신 한 평균 패킷 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="a548c980c935b270267b69573bc6d8a367a0ccd7" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, sent from the socket.</source>
          <target state="translated">소켓에서 보낸 패킷의 평균 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="7666ec90c7fb3e6a7737d1ce78d04e16a63f834f" translate="yes" xml:space="preserve">
          <source>Avoid calling this on the root keys, as it can be slow.</source>
          <target state="translated">느릴 수 있으므로 루트 키에서 이것을 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8eebcbcc17ab43565fe594806f1d03745ee4ec86" translate="yes" xml:space="preserve">
          <source>Avoid mixing multiple &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; with driver reload requests.</source>
          <target state="translated">여러 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 를 드라이버 재로드 요청과 혼합하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="98289f5c4b0096f8495ef524df96672c88d3f383" translate="yes" xml:space="preserve">
          <source>Avoid the following values of &lt;code&gt;ResourceId&lt;/code&gt;, otherwise Erlang/OTP does not work properly:</source>
          <target state="translated">다음 &lt;code&gt;ResourceId&lt;/code&gt; 값을 피하십시오. 그렇지 않으면 Erlang / OTP가 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ebd07d23bcd301e7132f885cb8e225fce4de1c1" translate="yes" xml:space="preserve">
          <source>Avoiding common mistakes:</source>
          <target state="translated">일반적인 실수를 피하십시오 :</target>
        </trans-unit>
        <trans-unit id="8677c671e8bfb9480004f697032e107bf2d89ade" translate="yes" xml:space="preserve">
          <source>B/SFR</source>
          <target state="translated">B/SFR</target>
        </trans-unit>
        <trans-unit id="d6a2b7b76ae3b1331d97630c6fbdfda1e2e20faf" translate="yes" xml:space="preserve">
          <source>BEAM is a register-based virtual machine. It has 1024 virtual registers that are used for holding temporary values and for passing arguments when calling functions. Variables that need to survive a function call are saved to the stack.</source>
          <target state="translated">BEAM은 레지스터 기반 가상 머신입니다. 임시 값을 유지하고 함수를 호출 할 때 인수를 전달하는 데 사용되는 1024 개의 가상 레지스터가 있습니다. 함수 호출에서 살아남 아야하는 변수는 스택에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4e374de82335c7a8d86c8e4d74077c948da138e0" translate="yes" xml:space="preserve">
          <source>BEAM is a threaded-code interpreter. Each instruction is word pointing directly to executable C-code, making instruction dispatching very fast.</source>
          <target state="translated">BEAM은 스레드 코드 인터프리터입니다. 각 명령어는 실행 가능한 C 코드를 직접 가리키는 단어이므로 명령어 디스패치가 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="7efce4656362191b2f6893e9594afff40994fed8" translate="yes" xml:space="preserve">
          <source>BIFs are functions that for some reason are built-in to the Erlang virtual machine. BIFs often implement functionality that is impossible or is too inefficient to implement in Erlang. Some BIFs can be called using the function name only but they are by default belonging to the &lt;code&gt;erlang&lt;/code&gt; module. For example, the call to the BIF &lt;code&gt;trunc&lt;/code&gt; below is equivalent to a call to &lt;code&gt;erlang:trunc&lt;/code&gt;.</source>
          <target state="translated">BIF는 어떤 이유로 Erlang 가상 머신에 내장 된 기능입니다. BIF는 종종 Erlang에서 구현하기에 불가능하거나 너무 비효율적 인 기능을 구현합니다. 일부 BIF는 함수 이름 만 사용하여 호출 할 수 있지만 기본적으로 &lt;code&gt;erlang&lt;/code&gt; 모듈 에 속합니다 . 예를 들어, 아래 의 BIF &lt;code&gt;trunc&lt;/code&gt; 호출은 &lt;code&gt;erlang:trunc&lt;/code&gt; 호출과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="890c2ec47feac80bf8654b893be74f130c02facf" translate="yes" xml:space="preserve">
          <source>BIFs are implemented in C code in the runtime system. BIFs do things that are difficult or impossible to implement in Erlang. Most of the BIFs belong to the module &lt;code&gt;erlang&lt;/code&gt; but there are also BIFs belonging to a few other modules, for example &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;ets&lt;/code&gt;.</source>
          <target state="translated">BIF는 런타임 시스템에서 C 코드로 구현됩니다. BIF는 Erlang에서 구현하기 어렵거나 불가능한 일을합니다. 대부분의 BIF는 모듈 &lt;code&gt;erlang&lt;/code&gt; 에 속 하지만 &lt;code&gt;lists&lt;/code&gt; 및 &lt;code&gt;ets&lt;/code&gt; 와 같은 다른 모듈에 속하는 BIF도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42278b69b892fd26dcff3099719503a85d2ed515" translate="yes" xml:space="preserve">
          <source>BIFs can fail for various reasons. All BIFs fail with reason &lt;code&gt;badarg&lt;/code&gt; if they are called with arguments of an incorrect type. The other reasons are described in the description of each individual BIF.</source>
          <target state="translated">BIF는 여러 가지 이유로 실패 할 수 있습니다. 모든 BIF 가 잘못된 유형의 인수로 호출되면 이유 &lt;code&gt;badarg&lt;/code&gt; 로 실패 합니다. 다른 이유는 각 개별 BIF의 설명에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0971b2037c9ec621fb794e414dbe4e3e6e9ea234" translate="yes" xml:space="preserve">
          <source>Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern 2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different:</source>
          <target state="translated">최상위 레벨로 돌아가서 다음 문자 ( &quot;c&quot;)는 하위 패턴 2와 일치하는 항목 ( &quot;a&quot;)과 비교됩니다. 실패합니다. 재귀가 원자 그룹으로 취급되므로 역 추적 지점이 없으므로 전체 일치가 실패합니다. Perl은 이제 재귀를 다시 입력하고 두 번째 대안을 시도 할 수 있습니다. 그러나 패턴이 다른 순서로 대안으로 작성된 경우 상황이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="48a05ca6fa60802ff208e26ea9e34464ac28a529" translate="yes" xml:space="preserve">
          <source>Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group.</source>
          <target state="translated">이 유형의 역 참조는 참조하는 그룹이 원자 그룹으로 취급되도록합니다. 전체 그룹이 일치하면 후속 일치 실패로 인해 그룹 중간으로 역 추적 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab429c0e231fa759e013662e3a14521ce2c5b79b" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt;.</source>
          <target state="translated">에서 사용하는 백엔드 기능 &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4aa3add341382a466d659f858fca56aef2ce0f58" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt;.</source>
          <target state="translated">사용하여 백엔드 기능 &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="84e3bb9dd16cb2ba0f02d7245545feda5e3cabcb" translate="yes" xml:space="preserve">
          <source>Backspace.</source>
          <target state="translated">Backspace.</target>
        </trans-unit>
        <trans-unit id="7fc5d71b3eae328beb908064e6dec5ed2151041f" translate="yes" xml:space="preserve">
          <source>Backup and restore of C node state to and from &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 와의 C 노드 상태 백업 및 복원</target>
        </trans-unit>
        <trans-unit id="643aeb5ad5e07a8a0aedfaec9f291b8b2d8eb1e8" translate="yes" xml:space="preserve">
          <source>Backup operation are performed with the following functions:</source>
          <target state="translated">백업 기능은 다음 기능으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a1b1261f879477741073cc5643737c50cece295a" translate="yes" xml:space="preserve">
          <source>Backup persistent data handled by the manager.</source>
          <target state="translated">관리자가 처리 한 백업 영구 데이터.</target>
        </trans-unit>
        <trans-unit id="48159fb2ea43e7a90492b5cc62df25d733040b1d" translate="yes" xml:space="preserve">
          <source>Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).</source>
          <target state="translated">에이전트가 처리하는 백업 영구 / 영구 데이터 (예 : local-db, mib-data 및 vacm).</target>
        </trans-unit>
        <trans-unit id="76b2ca97753e81a47e64d73e23600b3684a357e4" translate="yes" xml:space="preserve">
          <source>Backup, restore, fallback, and disaster recovery</source>
          <target state="translated">백업, 복원, 폴백 및 재해 복구</target>
        </trans-unit>
        <trans-unit id="8afb5bf327667dc553b8e9a32ac34a080d815b3b" translate="yes" xml:space="preserve">
          <source>BackupDir cannot be identical to DbDir.</source>
          <target state="translated">BackupDir은 DbDir과 같을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f132fe31e8d713406288c3f7dcb9dbc8378cfdf5" translate="yes" xml:space="preserve">
          <source>Backward character</source>
          <target state="translated">뒤로 캐릭터</target>
        </trans-unit>
        <trans-unit id="82c36d6a4f52a2dc6589f184f22fdf4b95e97b1c" translate="yes" xml:space="preserve">
          <source>Backward kill line</source>
          <target state="translated">뒤로 킬 라인</target>
        </trans-unit>
        <trans-unit id="5be769b9776675c14c24d6f30ed3fba3e401a997" translate="yes" xml:space="preserve">
          <source>Backward kill word</source>
          <target state="translated">뒤로 킬 단어</target>
        </trans-unit>
        <trans-unit id="c0b7a7d6f9015db486c407e9f3cba9dc8dea0ff8" translate="yes" xml:space="preserve">
          <source>Backward word</source>
          <target state="translated">거꾸로 단어</target>
        </trans-unit>
        <trans-unit id="1161e058ccd842cdd5e5fe2efd102fbd9ed43bbd" translate="yes" xml:space="preserve">
          <source>Bad argument in an arithmetic expression.</source>
          <target state="translated">산술 표현식에서 잘못된 인수입니다.</target>
        </trans-unit>
        <trans-unit id="af4ade1fd757cc8bcb7e76a2f6d37f1ec5bbb7b5" translate="yes" xml:space="preserve">
          <source>Bad argument.</source>
          <target state="translated">잘못된 주장.</target>
        </trans-unit>
        <trans-unit id="c4cf9343231b13c7b7056a157910cd49cc8ff14e" translate="yes" xml:space="preserve">
          <source>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</source>
          <target state="translated">잘못된 주장. 인수가 잘못된 데이터 유형이거나 잘못 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="3401e9b8481ac17e3759a0b06770cb6fc7bbc79c" translate="yes" xml:space="preserve">
          <source>Bad input arguments to &lt;code&gt;open_port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open_port&lt;/code&gt; 에 잘못된 입력 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="26e5990472188146a21fbe9216d5e35fd4688af2" translate="yes" xml:space="preserve">
          <source>Base Protocol Command AVP Table</source>
          <target state="translated">기본 프로토콜 명령 AVP 테이블</target>
        </trans-unit>
        <trans-unit id="d9e2287d49a0defabf83f04683cfd099fe9d2461" translate="yes" xml:space="preserve">
          <source>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called &lt;strong&gt;release handling&lt;/strong&gt;.</source>
          <target state="translated">이 기능을 기반으로 OTP 애플리케이션 SASL은 런타임시 전체 릴리스의 다른 버전간에 업그레이드 및 다운 그레이드 할 수있는 프레임 워크를 제공합니다. 이것을 &lt;strong&gt;릴리스 처리&lt;/strong&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="37e7613ad8170257c16610a53d06cfb1a6379742" translate="yes" xml:space="preserve">
          <source>Basic AVP Data Formats</source>
          <target state="translated">기본 AVP 데이터 형식</target>
        </trans-unit>
        <trans-unit id="6b9ebfc825400dcd8efd5ccd3ed7166c57bc3280" translate="yes" xml:space="preserve">
          <source>Basic Encoding Rules (BER)</source>
          <target state="translated">기본 인코딩 규칙 (BER)</target>
        </trans-unit>
        <trans-unit id="60289c0d7f3cdae9e1d8eee79fef52de4c163a03" translate="yes" xml:space="preserve">
          <source>Basic knowledge of Emacs and Erlang/OTP.</source>
          <target state="translated">Emacs 및 Erlang / OTP에 대한 기본 지식.</target>
        </trans-unit>
        <trans-unit id="9dd9d44759000b74a8ffb28eb7a9b5d4bda605bf" translate="yes" xml:space="preserve">
          <source>Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;, adding transport capability using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; and sending Diameter requests and receiving Diameter answers with &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;. Incoming Diameter requests are communicated as callbacks to a &lt;code&gt;diameter_app(3)&lt;/code&gt; callback modules as specified in the service configuration.</source>
          <target state="translated">기본 사용법은 로컬로 구현 된 Diameter 노드와 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 로 해당 기능을 작성하고 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 전송 기능을 추가 하고 Diameter 요청을 보내고 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 Diameter 응답을받는 것으로 구성 됩니다. 수신 직경 요청은 서비스 구성에 지정된대로 &lt;code&gt;diameter_app(3)&lt;/code&gt; 콜백 모듈에 대한 콜백으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d03e3070f8930ea991974fa59117d8692bbcffdd" translate="yes" xml:space="preserve">
          <source>Basically the same as UTF-32, but without some Unicode semantics, defined by IEEE, and has little use as a separate encoding standard. For all normal (and possibly abnormal) use, UTF-32 and UCS-4 are interchangeable.</source>
          <target state="translated">기본적으로 UTF-32와 동일하지만 IEEE로 정의 된 일부 유니 코드 시맨틱은 없으며 별도의 인코딩 표준으로 거의 사용되지 않습니다. 모든 정상적인 (및 비정상적인) 사용의 경우 UTF-32와 UCS-4는 서로 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="7299a57060c9f81f94931f5581972334cd31d5c2" translate="yes" xml:space="preserve">
          <source>Basically, the &lt;code&gt;etags&lt;/code&gt; utility is ran using the following form:</source>
          <target state="translated">기본적으로 &lt;code&gt;etags&lt;/code&gt; 유틸리티는 다음 양식을 사용하여 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="38c83af4610a697d6724ff3bf3f45adb4124041d" translate="yes" xml:space="preserve">
          <source>Basically, the procedure is as follows:</source>
          <target state="translated">기본적으로 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c6f5bb2c23fc72e02ed4fe91c08eb86ab7eb097" translate="yes" xml:space="preserve">
          <source>Basics on how computers are programmed</source>
          <target state="translated">컴퓨터 프로그래밍 방법에 대한 기본 사항</target>
        </trans-unit>
        <trans-unit id="075b61c3bd00c5372d9b40a37e76d0e216819b8e" translate="yes" xml:space="preserve">
          <source>Bassa_Vah</source>
          <target state="translated">Bassa_Vah</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="58c655b2cd5d86487b8917d2d93a7efbac26efff" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;enif_schedule_nif&lt;/code&gt;, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return. This means that the calling NIF cannot expect to receive the scheduled NIF return value and use it for further operations.</source>
          <target state="translated">주의 그 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 미래의 실행을위한 그 이름에서 알 수 있듯이, 단지 스케줄 NIF는. 호출 NIF는 스케줄 된 NIF의 실행 및 리턴 대기를 차단하지 않습니다. 이는 호출 NIF가 스케줄 된 NIF 리턴 값을 수신하여 추가 조작에 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1bb1d4b8960f0882b546a0b46a0612e449641efb" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">하위 프로세스가 작업자 인 경우 종료 시간을 &lt;code&gt;infinity&lt;/code&gt; 설정할 때주의하십시오 . 이 상황에서 감독 트리 종료는 하위 프로세스에 따라 다르므로 안전한 방식으로 구현해야하며 정리 절차는 항상 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ffb65a64fc348102ef56127a672718177ad2a7ab" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process; it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">하위 프로세스가 작업자 인 경우 종료 시간을 &lt;code&gt;infinity&lt;/code&gt; 설정할 때주의하십시오 . 이 상황에서 감독 트리의 종료는 하위 프로세스에 따라 다릅니다. 안전한 방법으로 구현되어야하며 정리 절차는 항상 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2fd62499ab8def7b8b69fee274c4b8917538a4e1" translate="yes" xml:space="preserve">
          <source>Be careful with the version header, use &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; when appropriate.</source>
          <target state="translated">버전 헤더에주의하여 적절한 경우 &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7301ce2a6e0b85e60f35ab88d520e5d9725285df" translate="yes" xml:space="preserve">
          <source>Be started in a way that makes the process fit into a supervision tree</source>
          <target state="translated">프로세스를 감독 트리에 맞게 만드는 방식으로 시작</target>
        </trans-unit>
        <trans-unit id="105320a56b534ace4c0d31c6412a7c5d4168a815" translate="yes" xml:space="preserve">
          <source>Be sure &lt;strong&gt;not&lt;/strong&gt; no name the directory containing the measurement binaries starting with 'megaco-', e.g. megaco-meas. This will confuse the erlang application loader (erlang applications are named, e.g. megaco-1.0.2).</source>
          <target state="translated">확인 &lt;strong&gt;되지&lt;/strong&gt; 아니 'megaco-', 예를 들어, MEGACO - 신체의 체중 측정 후의 측정 바이너리를 포함하는 디렉토리의 이름을 지정합니다. 이것은 erlang 응용 프로그램 로더를 혼동합니다 (erlang 응용 프로그램은 megaco-1.0.2와 같이 이름이 지정됩니다).</target>
        </trans-unit>
        <trans-unit id="00d0130a026229dfaa52123c4c578740ea2d109c" translate="yes" xml:space="preserve">
          <source>Be sure to read about &lt;code&gt;Long-running NIFs&lt;/code&gt; before writing a NIF.</source>
          <target state="translated">NIF를 작성하기 전에 &lt;code&gt;Long-running NIFs&lt;/code&gt; NIF 에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="d2edff3a35b65adb5039205d11c2d7f121323a42" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children will do their cleanup in parallel and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">때문에 &lt;code&gt;simple_one_for_one&lt;/code&gt; 의 관리자가 여러 아이를 가질 수 있습니다, 그것은 비동기 모두 종료합니다. 즉, 어린이가 정리를 동시에 수행하므로 중지 순서가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abef4f4009e13039f29fcccf0a57474c315686c1" translate="yes" xml:space="preserve">
          <source>Because lists are commonly used, they have shorthand type notations. The types &lt;code&gt;list(T)&lt;/code&gt; and &lt;code&gt;nonempty_list(T)&lt;/code&gt; have the shorthands &lt;code&gt;[T]&lt;/code&gt; and &lt;code&gt;[T,...]&lt;/code&gt;, respectively. The only difference between the two shorthands is that &lt;code&gt;[T]&lt;/code&gt; can be an empty list but &lt;code&gt;[T,...]&lt;/code&gt; cannot.</source>
          <target state="translated">목록이 일반적으로 사용되므로 축약 형 표기법이 있습니다. 유형 &lt;code&gt;list(T)&lt;/code&gt; 및 &lt;code&gt;nonempty_list(T)&lt;/code&gt; 는 각각 약식 &lt;code&gt;[T]&lt;/code&gt; 및 &lt;code&gt;[T,...]&lt;/code&gt; 를 갖습니다 . 두 속기의 유일한 차이점은 &lt;code&gt;[T]&lt;/code&gt; 는 빈 목록이 될 수 있지만 &lt;code&gt;[T,...]&lt;/code&gt; 는 불가능 하다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5b3a7dd1ee18a1a87ef5bd7ed89f7551e8ad10ce" translate="yes" xml:space="preserve">
          <source>Because of network and processing delays, the period of tracing is approximate.</source>
          <target state="translated">네트워크 및 처리 지연으로 인해 추적 기간은 대략적인 것입니다.</target>
        </trans-unit>
        <trans-unit id="d37fd4abb225a06f4a6768bb951238ff22bfe669" translate="yes" xml:space="preserve">
          <source>Because of peculiarities in the dynamic loading interfaces on different platforms, the returned string is only guaranteed to describe the correct error &lt;strong&gt;if format_error/1 is called in the same instance of the Erlang virtual machine as the error appeared in&lt;/strong&gt; (meaning the same operating system process).</source>
          <target state="translated">다른 플랫폼의 동적 로딩 인터페이스의 특성으로 인해 리턴 된 문자열은 오류 &lt;strong&gt;가 나타난 것과 동일한 Erlang 가상 머신 인스턴스에서 format_error / 1이 호출 된 경우에만 동일한&lt;/strong&gt; 오류를 설명합니다 (동일한 운영 체제 프로세스를 의미 함). ).</target>
        </trans-unit>
        <trans-unit id="2937aec3114f354420a4dc65f7919f8480931c3a" translate="yes" xml:space="preserve">
          <source>Because of subtype relations that exist between types, types form a lattice where the top-most element, &lt;code&gt;any()&lt;/code&gt;, denotes the set of all Erlang terms and the bottom-most element, &lt;code&gt;none()&lt;/code&gt;, denotes the empty set of terms.</source>
          <target state="translated">유형 사이에 존재하는 하위 유형 관계로 인해 유형은 최상위 요소 인 &lt;code&gt;any()&lt;/code&gt; 가 모든 Erlang 항의 세트를 나타내고 최하부 요소 인 &lt;code&gt;none()&lt;/code&gt; 은 빈 항을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="022a498b7c46fc56b49452af050953c22bfbf306" translate="yes" xml:space="preserve">
          <source>Because of the limited length of atoms, it is recommended to use &lt;code&gt;-run&lt;/code&gt; instead.</source>
          <target state="translated">원자의 길이가 제한되어 있으므로 대신 &lt;code&gt;-run&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1384b995beb9b21c8a759c386f9768bb6e9bf48f" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ h&lt;/strong&gt; 가된다&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="299f84debe52036e59ae03120fd4f1dabe601f72" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Ll}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ p {Ll}&lt;/strong&gt; 이 됨&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d91b3caacd37fdde510b95d27795a9af6bf8136" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Lu}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ p {Lu}&lt;/strong&gt; 가 됨&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c0abdb743817968c55df2e58d08673027964564" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{L}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ p {L}&lt;/strong&gt; 가 됨&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="730c516db3536d87659465b8430f3c06b9b28d02" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Nd}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ p {Nd}&lt;/strong&gt; 가 됨&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af6446ff6bb33935f80c0e27353d8c85c94660f6" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xan}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ p {Xan}&lt;/strong&gt; 가 됨&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d22b3bf8b56b82387696e9e8f32390beb8e0c" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xps}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ p {Xps}&lt;/strong&gt; 가 됨&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89fc848e28a9b477f8a3b6e31d45687e11d42e23" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xwd}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ p {Xwd}&lt;/strong&gt; 가 됨&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ebae434cd88ef2302f9bbb202778d21d2e46d19" translate="yes" xml:space="preserve">
          <source>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with &lt;code&gt;badarg&lt;/code&gt; if the monitored process resided on a primitive node (such as erl_interface or jinterface), where remote process monitoring is not implemented.</source>
          <target state="translated">ERTS 10.0 (OTP 21.0) 이전에 모니터링 된 프로세스가 원격 프로세스 모니터링이 구현되지 않은 기본 노드 (예 : erl_interface 또는 jinterface)에있는 경우 &lt;code&gt;badarg&lt;/code&gt; 로 프로세스 모니터링이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2170fbb9997cb7343b013f87d0b07f06679bee2" translate="yes" xml:space="preserve">
          <source>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</source>
          <target state="translated">ERTS 5.9 이전에는 스케줄러보다 적은 수의 스레드 특정 인스턴스를 구성 할 수있었습니다. 그러나 이것은 더 이상 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60f2fe367a59604d77c1ee7cdc5c0f81f65eda6e" translate="yes" xml:space="preserve">
          <source>Before ERTS 7.0 (Erlang/OTP 18), the return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if &lt;code&gt;enif_make_badarg&lt;/code&gt; has been invoked.</source>
          <target state="translated">ERTS 7.0 (Erlang / OTP 18) &lt;code&gt;enif_make_badarg&lt;/code&gt; 에는 enif_make_badarg 의 리턴 값 이 NIF에서 리턴되어야했습니다. &lt;code&gt;enif_make_badarg&lt;/code&gt; 가 호출 된 경우 NIF의 리턴 값이 무시 되므로이 요구 사항이 해제 되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8ec3341c03352c2dcbc8cc1ae6efea67d454637" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other and to empty binaries (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;). If serialized, they would be recreated as plain empty binaries.</source>
          <target state="translated">ERTS 9.0 (OTP-20.0) 이전에는 모든 자원 용어가 서로 같고 비어있는 이진 ( &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ) 과 비교되었습니다 . 직렬화되면 일반 빈 바이너리로 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f16cc2c8df0cf217a1b01164cd474f9be586865b" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255 was accepted in the string. Now any unicode string is valid.</source>
          <target state="translated">ERTS 9.1 (OTP-20.1) 이전에는 0-255 범위의 코드 포인트 만 문자열에 허용되었습니다. 이제 모든 유니 코드 문자열이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b8815a40e2ba0160069e9df632d708ff9fef831a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 17.1, if your test run consisted of multiple tests, cover would be started and stopped for each test within the test run. Separate logs would be available through the &quot;Coverage log&quot; link on the test suite result pages. These links are still available, but now they all point to the same page as the button on the top-level index page. The log contains the accumulated results for the complete test run. For details about this change, see the release notes.</source>
          <target state="translated">Erlang / OTP 17.1 이전에 테스트 실행이 여러 테스트로 구성된 경우 테스트 실행 내의 각 테스트에 대해 커버가 시작되고 중지되었습니다. 테스트 스위트 결과 페이지의 &quot;Coverage log&quot;링크를 통해 별도의 로그를 사용할 수 있습니다. 이러한 링크는 계속 사용할 수 있지만 이제는 최상위 색인 페이지의 버튼과 동일한 페이지를 가리 킵니다. 로그에는 전체 테스트 실행에 대한 누적 결과가 포함됩니다. 이 변경 사항에 대한 자세한 내용은 릴리스 정보를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="173b9788d3472306f8bca6acb906380d15ebb018" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 19, for fields without initial values, the singleton type &lt;code&gt;'undefined'&lt;/code&gt; was added to all declared types. In other words, the following two record declarations had identical effects:</source>
          <target state="translated">Erlang / OTP 19 이전에는 초기 값이없는 필드의 경우 단일 유형 &lt;code&gt;'undefined'&lt;/code&gt; 이 선언 된 모든 유형에 추가되었습니다. 즉, 다음 두 레코드 선언은 동일한 효과를가집니다.</target>
        </trans-unit>
        <trans-unit id="1ebd17eea52effdc10d3b387a5f97c65de3d711a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; behaved completely asynchronously, that is, the monitor was active until the &quot;demonitor signal&quot; reached the monitored entity. This had one undesirable effect. You could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to receive a &lt;code&gt;DOWN&lt;/code&gt; message because of the monitor.</source>
          <target state="translated">Erlang / OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; 이 완전히 비동기식으로 작동 하기 전에 , 즉, &quot;모니터링 해제 신호&quot;가 모니터링 된 엔티티에 도달 할 때까지 모니터가 활성화되었습니다. 이것은 바람직하지 않은 영향을 미쳤다. 모니터로 인해 &lt;code&gt;DOWN&lt;/code&gt; 메시지 가 수신 &lt;strong&gt;되지 않을&lt;/strong&gt; 때를 알 수 없었습니다 .</target>
        </trans-unit>
        <trans-unit id="c04cf745a3c4adfcd300b132adf03ceaef66e4c6" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; behaved completely asynchronously, that is, the link was active until the &quot;unlink signal&quot; reached the linked entity. This had an undesirable effect, as you could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to be effected by the link.</source>
          <target state="translated">Erlang / OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; 이 완전히 비동기식으로 작동 하기 전에 , 즉 &quot;링크 해제 신호&quot;가 연결된 엔티티에 도달 할 때까지 링크가 활성화되었습니다. 링크에 의해 영향을 &lt;strong&gt;받지&lt;/strong&gt; 않는 것을 언제 알지 알 수 없었기 때문에 이것은 바람직하지 않은 영향 을 미쳤습니다.</target>
        </trans-unit>
        <trans-unit id="14149394b7877b033496395cfd6e420c1de55bda" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R16, the port ID could be used as a key with proper casting, but after the rewrite of the port subsystem, this is no longer the case. With this function, you can achieve the same distribution based on port IDs as before Erlang/OTP R16.</source>
          <target state="translated">Erlang / OTP R16 이전에는 포트 ID를 적절한 캐스팅의 키로 사용할 수 있었지만 포트 하위 시스템을 다시 쓴 후에는 더 이상 문제가되지 않습니다. 이 기능을 사용하면 Erlang / OTP R16 이전과 동일한 포트 ID를 기반으로 동일한 분배를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="055828a24a30444b0c0047933c2db837ba4b5188" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but could not retrieved with &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;. Since Linux 3.8, it is readable.</source>
          <target state="translated">Linux 3.8 이전에는이 ​​소켓 옵션을 설정할 수 있었지만 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 로 검색 할 수 없었습니다 . Linux 3.8부터는 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de814773d3f4ef3f2f57f8421829e0616b1e21de" translate="yes" xml:space="preserve">
          <source>Before OTP 19, if the &lt;code&gt;on_load&lt;/code&gt; function failed, any previously current code would become old, essentially leaving the system without any working and reachable instance of the module. That problem has been eliminated in OTP 19.</source>
          <target state="translated">OTP 19 이전 에는 &lt;code&gt;on_load&lt;/code&gt; 함수가 실패하면 이전에 현재 코드가 오래되어 기본적으로 작동하고 도달 가능한 모듈 인스턴스없이 시스템을 떠나게됩니다. 이 문제는 OTP 19에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="0463b80fdbddc48ab1e8bca76239196573ee534f" translate="yes" xml:space="preserve">
          <source>Before OTP R14A (ERTS version 5.8), an implicitly qualified function call to a function having the same name as an auto-imported BIF always resulted in the BIF being called. In newer versions of the compiler, the local function is called instead. This is to avoid that future additions to the set of auto-imported BIFs do not silently change the behavior of old code.</source>
          <target state="translated">OTP R14A (ERTS 버전 5.8) 이전에는 자동 반입 된 BIF와 동일한 이름을 가진 함수에 대한 내재적으로 규정 된 함수 호출로 인해 BIF가 항상 호출되었습니다. 최신 버전의 컴파일러에서는 로컬 함수가 대신 호출됩니다. 이는 나중에 자동으로 가져온 BIF 세트에 추가 한 내용이 이전 코드의 동작을 자동으로 변경하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b947a51569cc1cfaeef7b7ff4bf48e678a02c245" translate="yes" xml:space="preserve">
          <source>Before R14, parentheses were needed as follows:</source>
          <target state="translated">R14 이전에는 다음과 같이 괄호가 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="777f496c9fcf95c8a759b97ce9f5b072f83c3c75" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successfull, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="translated">Erlang에서 드라이버를 호출하기 전에로드하여 열어야합니다. 로드는 &lt;code&gt;erl_ddll&lt;/code&gt; 모듈 ( 동적 드라이버를로드 하는 &lt;code&gt;erl_ddll&lt;/code&gt; 드라이버는 실제로 드라이버 자체)을 사용하여 수행됩니다 . 로드에 성공하면 &lt;code&gt;open_port/2&lt;/code&gt; 로 포트를 열 수 있습니다 . 포트 이름은 공유 라이브러리 이름 및 드라이버 항목 구조의 이름과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="20019fdf1abe6fd7869945f2f7dac92f9f72ebdc" translate="yes" xml:space="preserve">
          <source>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the &lt;code&gt;UserProgressTerm&lt;/code&gt; that will be used as input the next time the callback function is called.</source>
          <target state="translated">파일이 전송되기 전에 파일 전송 시작 ​​및 파일 크기를 나타 내기 위해 다음 호출이 수행됩니다. 콜백 함수의 반환 값은 다음에 콜백 함수가 호출 될 때 입력으로 사용되는 &lt;code&gt;UserProgressTerm&lt;/code&gt; 의 새 값입니다 .</target>
        </trans-unit>
        <trans-unit id="159e2277de857354c36db29ad08f2c463be464e2" translate="yes" xml:space="preserve">
          <source>Before an application can be started, it must be &lt;strong&gt;loaded&lt;/strong&gt;. The application controller reads and stores the information from the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">응용 프로그램을 시작하기 전에 응용 프로그램을 &lt;strong&gt;로드&lt;/strong&gt; 해야합니다 . 애플리케이션 컨트롤러는 &lt;code&gt;.app&lt;/code&gt; 파일 에서 정보를 읽고 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="afd284c8bc9adc5dd4975944173af35c38112da6" translate="yes" xml:space="preserve">
          <source>Before an application makes its first access to a table, &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; is to be executed to ensure that the table is accessible from the local node. If the function times out, the application can choose to force a load of the local replica with &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; and deliberately lose all updates that can have been performed on the other nodes while the local node was down. If &lt;code&gt;Mnesia&lt;/code&gt; has loaded the table on another node already, or intends to do so, copy the table from that node to avoid unnecessary inconsistency.</source>
          <target state="translated">애플리케이션이 테이블에 처음 액세스하기 전에 로컬 노드에서 테이블에 액세스 할 수 있도록 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; 를 실행해야합니다. 기능이 시간 초과되면 응용 프로그램은 &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; 을 사용하여 로컬 복제본을 강제로로드하도록 선택 하고 로컬 노드가 다운 된 동안 다른 노드에서 수행 할 수있는 모든 업데이트를 의도적으로 잃게됩니다. &lt;code&gt;Mnesia&lt;/code&gt; 가 이미 다른 노드에 테이블을로드 했거나 로드하려는 경우 불필요한 불일치를 피하기 위해 해당 노드에서 테이블을 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="75a2137a0d589f3ac4ee86651537916f812a4998" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, module data must be &lt;strong&gt;set up&lt;/strong&gt;. For instance, the cross reference and the unknown functions are computed when all module data are known. The functions that need complete data (&lt;code&gt;analyze&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;variables&lt;/code&gt;) take care of setting up data automatically. Module data need to be set up (again) after calls to any of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set_library_path&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions.</source>
          <target state="translated">분석을 수행하기 전에 모듈 데이터를 &lt;strong&gt;설정&lt;/strong&gt; 해야 &lt;strong&gt;합니다&lt;/strong&gt; . 예를 들어, 상호 참조 및 알 수없는 기능은 모든 모듈 데이터를 알고있을 때 계산됩니다. 완전한 데이터 ( &lt;code&gt;analyze&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; , &lt;code&gt;variables&lt;/code&gt; ) 가 필요한 기능은 자동으로 데이터 설정을 처리합니다. &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;set_library_path&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt; 함수를 호출 한 후 모듈 데이터를 다시 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ca67bda82873ef4332d857192e18635d990609ed" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt;. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">분석을 수행하기 전에 관련 모듈을 &lt;strong&gt;커버 컴파일&lt;/strong&gt; 해야합니다 . 이것은 모듈에 바이너리로 컴파일되기 전에 모듈에 추가 정보가 추가되어 &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt; 된다는 것을 의미합니다 . 모듈의 소스 파일은 영향을받지 않으며 &lt;code&gt;.beam&lt;/code&gt; 파일이 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="258fe4cd782832c98fba1da0a69f9a8b68aa3908" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is loaded. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">분석을 수행하기 전에 관련 모듈을 &lt;strong&gt;커버 컴파일&lt;/strong&gt; 해야합니다 . 즉, 바이너리로 컴파일되기 전에 모듈에 추가 정보가 추가되어로드됩니다. 모듈의 소스 파일은 영향을받지 않으며 &lt;code&gt;.beam&lt;/code&gt; 파일이 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="451eac2b19829254921c8ba2920439b2b92145f5" translate="yes" xml:space="preserve">
          <source>Before applying a patch you need to do a &lt;strong&gt;full&lt;/strong&gt; build of OTP in the source directory.</source>
          <target state="translated">패치를 적용하기 전에 소스 디렉토리에서 &lt;strong&gt;전체&lt;/strong&gt; OTP 빌드 를 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0af32825676162dfe9c05e6f703b3efa51985180" translate="yes" xml:space="preserve">
          <source>Before asking a question you can browse the &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt; mailing list archive&lt;/a&gt; and read the &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Frequently Asked Questions&lt;/a&gt;.</source>
          <target state="translated">질문을하기 전에 &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt;메일 링리스트 아카이브를&lt;/a&gt; 탐색 하고 &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;자주 묻는 질문을&lt;/a&gt; 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cda5c6edb9898f9347103f74f622c57ddde1c654" translate="yes" xml:space="preserve">
          <source>Before calling any of the other &lt;code&gt;Erl_Interface&lt;/code&gt; functions, call &lt;code&gt;erl_init()&lt;/code&gt; exactly once to initialize the library. &lt;code&gt;erl_init()&lt;/code&gt; takes two arguments. However, the arguments are no longer used by &lt;code&gt;Erl_Interface&lt;/code&gt; and are therefore to be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;Erl_Interface&lt;/code&gt; 함수를 호출 하기 전에 &lt;code&gt;erl_init()&lt;/code&gt; 정확히 한 번 호출 하여 라이브러리를 초기화하십시오. &lt;code&gt;erl_init()&lt;/code&gt; 는 두 개의 인수를 취합니다. 그러나 인수는 더 이상 &lt;code&gt;Erl_Interface&lt;/code&gt; 에서 사용되지 않으므로 &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; 으로 지정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5913933d73f661127a755638c745adee88554860" translate="yes" xml:space="preserve">
          <source>Before calling any other function in Erl_Interface, the memory handling must be initiated:</source>
          <target state="translated">Erl_Interface에서 다른 함수를 호출하기 전에 메모리 처리를 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c91078fc982ffe0902391841ac4ff114e2a4c572" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">그룹의 실행이 시작되기 전에 구성 함수 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 이 함수에서 반환 된 튜플 목록은 &lt;code&gt;Config&lt;/code&gt; 인수에 의해 일반적인 방식으로 테스트 사례에 전달됩니다 . &lt;code&gt;init_per_group/2&lt;/code&gt; 는 그룹의 테스트 사례에 공통적 인 초기화에 사용됩니다. 그룹의 실행이 끝나면 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; 함수 가 호출됩니다. 이 함수는 &lt;code&gt;init_per_group/2&lt;/code&gt; 이후 정리에 사용됩니다 . init 함수가 정의 된 경우 end 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dfe638852bde7e76a1e9584d5c09fb0ca66d3651" translate="yes" xml:space="preserve">
          <source>Before execution of the timetrap function (which is performed on a parallel, dedicated timetrap process), &lt;code&gt;Common Test&lt;/code&gt; cancels any previously set timer for the test case or configuration function. When the timetrap function returns, the time-out is triggered, &lt;strong&gt;unless&lt;/strong&gt; the return value is a valid timetrap time, such as an integer, or a &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; tuple (for details, see module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;). If a time value is returned, a new timetrap is started to generate a time-out after the specified time.</source>
          <target state="translated">병렬 전용 타임 트랩 프로세스에서 수행되는 타임 트랩 기능을 실행하기 전에 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 케이스 또는 구성 기능에 대해 이전에 설정된 타이머를 취소합니다. 타임 트랩 함수가 반환되면 반환 값이 정수 또는 &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; 튜플 과 같은 유효한 타임 트랩 시간이 &lt;strong&gt;아닌 한&lt;/strong&gt; 시간 초과가 트리거 됩니다 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; 모듈 참조 ). 시간 값이 리턴되면 지정된 시간 이후에 시간 종료를 생성하기 위해 새 시간 트랩이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="08b1254c8bec1bc486b54b5a55646cb74814353f" translate="yes" xml:space="preserve">
          <source>Before going into details of the supervision and error handling in an Erlang system, let us see how Erlang processes terminate, or in Erlang terminology, &lt;strong&gt;exit&lt;/strong&gt;.</source>
          <target state="translated">Erlang 시스템의 감독 및 오류 처리에 대한 자세한 내용을 살펴보기 전에 Erlang 프로세스가 종료되는 방법 또는 Erlang 용어로 &lt;strong&gt;exit를&lt;/strong&gt; 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="158d175d6b77bf980038361a2e334b0ed9a4b8fc" translate="yes" xml:space="preserve">
          <source>Before improving the messenger program, let us look at some general principles, using the ping pong program as an example. Recall that when &quot;ping&quot; finishes, it tells &quot;pong&quot; that it has done so by sending the atom &lt;code&gt;finished&lt;/code&gt; as a message to &quot;pong&quot; so that &quot;pong&quot; can also finish. Another way to let &quot;pong&quot; finish is to make &quot;pong&quot; exit if it does not receive a message from ping within a certain time. This can be done by adding a &lt;strong&gt;time-out&lt;/strong&gt; to &lt;code&gt;pong&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">메신저 프로그램을 개선하기 전에 탁구 프로그램을 예로 들어 일반적인 원칙을 살펴 보겠습니다. &quot;ping&quot;이 끝나면 &quot;pong&quot;에게 &quot;pong&quot; 에게 메시지로 &lt;code&gt;finished&lt;/code&gt; 된 원자 를 &quot;pong&quot;에게 보내서 &quot;pong&quot;도 끝낼 수 있도록함으로써 그렇게했음을 알려줍니다 . &quot;퐁&quot;을 끝내는 또 다른 방법은 특정 시간 내에 핑에서 메시지를받지 못하면 &quot;퐁&quot;을 종료하는 것입니다. 다음 예제와 같이 &lt;code&gt;pong&lt;/code&gt; &lt;strong&gt;시간 초과&lt;/strong&gt; 를 추가하면 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0240a960734bd032bfb25f877be3ed95c27ca3" translate="yes" xml:space="preserve">
          <source>Before installation you should test whether your build is working properly by running our smoke test. The smoke test is a subset of the complete Erlang/OTP test suites. First you will need to build and release the test suites.</source>
          <target state="translated">설치하기 전에 연기 테스트를 실행하여 빌드가 제대로 작동하는지 테스트해야합니다. 연기 테스트는 완전한 Erlang / OTP 테스트 스위트의 하위 세트입니다. 먼저 테스트 스위트를 빌드하고 릴리스해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9b6bb02452d70c4cea213f1df9be77d0db03bc1" translate="yes" xml:space="preserve">
          <source>Before looking at how this program works, notice that a few comments are added to the code. A comment starts with a %-character and goes on to the end of the line. Notice also that the &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; line only includes the function &lt;code&gt;format_temps/1&lt;/code&gt;. The other functions are &lt;strong&gt;local&lt;/strong&gt; functions, that is, they are not visible from outside the module &lt;code&gt;tut5&lt;/code&gt;.</source>
          <target state="translated">이 프로그램의 작동 방식을 살펴보기 전에 코드에 몇 가지 주석이 추가되어 있는지 확인하십시오. 주석은 % 문자로 시작하여 줄 끝으로 이동합니다. 또한 &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; line은 &lt;code&gt;format_temps/1&lt;/code&gt; 함수 만 포함합니다 . 다른 함수는 &lt;strong&gt;로컬&lt;/strong&gt; 함수입니다. 즉, 모듈 &lt;code&gt;tut5&lt;/code&gt; 외부에서는 보이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="12bcc79844186de606633bdd333ae924acec0daf" translate="yes" xml:space="preserve">
          <source>Before registering a name, you should already have registered your port number with &lt;code&gt;epmd&lt;/code&gt;. This is not strictly necessary, but if you neglect to do so, then other nodes wishing to communicate with your service cannot find or connect to your process.</source>
          <target state="translated">이름을 등록하기 전에 이미 포트 번호를 &lt;code&gt;epmd&lt;/code&gt; 로 등록해야합니다 . 꼭 필요한 것은 아니지만 그렇게하지 않으면 서비스와 통신하려는 다른 노드가 프로세스를 찾거나 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="26cb26b93d1388560e328aa535c6bbe4b5f0b51c" translate="yes" xml:space="preserve">
          <source>Before registering with &lt;code&gt;epmd&lt;/code&gt;, you must first create a listen socket and bind it to a port. Then:</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; 에 등록하기 전에 먼저 청취 소켓을 만들어 포트에 바인딩해야합니다. 그때:</target>
        </trans-unit>
        <trans-unit id="9c7e0e1b9fcac24580ab6b3d03b6e4b55f4c8972" translate="yes" xml:space="preserve">
          <source>Before starting &lt;code&gt;Mnesia&lt;/code&gt;, the following must be done:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 를 시작하기 전에 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a519a0020d8de31b673de93ded06a0618f853d2" translate="yes" xml:space="preserve">
          <source>Before starting, notice the following:</source>
          <target state="translated">시작하기 전에 다음을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7011eaabfad589a3868b28c469ad42e5d05beb89" translate="yes" xml:space="preserve">
          <source>Before the call of &lt;code&gt;deflateParams&lt;/code&gt;, the stream state must be set as for a call of &lt;code&gt;deflate/3&lt;/code&gt;, as the currently available input may have to be compressed and flushed.</source>
          <target state="translated">&lt;code&gt;deflateParams&lt;/code&gt; 를 호출하기 전에 현재 사용 가능한 입력을 압축하고 플러시 해야 할 수 있으므로 스트림 상태는 &lt;code&gt;deflate/3&lt;/code&gt; 를 호출하도록 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78fa7e00043ebdf38881948abf63f1275524f7cf" translate="yes" xml:space="preserve">
          <source>Before the first call to &lt;code&gt;allow/1&lt;/code&gt;, any node with the correct cookie can be connected. When &lt;code&gt;allow/1&lt;/code&gt; is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not in that list will be rejected.</source>
          <target state="translated">&lt;code&gt;allow/1&lt;/code&gt; 을 처음 호출하기 전에 올바른 쿠키를 가진 모든 노드를 연결할 수 있습니다. 시 &lt;code&gt;allow/1&lt;/code&gt; 이라고, 허용 노드 목록이 설정됩니다. 해당 목록에없는 (또는) 노드에서 액세스 시도는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="dc3113c94757b2848bc9b3cfac6670102a406895" translate="yes" xml:space="preserve">
          <source>Before the log is dumped, the file &lt;code&gt;LATEST.LOG&lt;/code&gt; is renamed to &lt;code&gt;PREVIOUS.LOG&lt;/code&gt;, and a new &lt;code&gt;LATEST.LOG&lt;/code&gt; file is created. Once the log has been successfully dumped, the file &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; is deleted.</source>
          <target state="translated">로그가 덤프되기 전에 &lt;code&gt;LATEST.LOG&lt;/code&gt; 파일의 이름이 &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; 로 바뀌고 새 &lt;code&gt;LATEST.LOG&lt;/code&gt; 파일이 작성됩니다. 로그가 성공적으로 덤프되면 &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; 파일 이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="db255d80fd5fbd19169beeb79eff7051fb467716" translate="yes" xml:space="preserve">
          <source>Before the port is created, the driver must be loaded. This is done with the function &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt;, with the name of the shared library as argument.</source>
          <target state="translated">포트를 작성하기 전에 드라이버를로드해야합니다. &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt; 함수 를 사용하여 공유 라이브러리의 이름을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="46a334a8ddbc15c984030c1582dd4508b5f21665" translate="yes" xml:space="preserve">
          <source>Before the traversal starts, the source backup media is opened with &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt;, and the target backup media is opened with &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt;. The arguments are as follows:</source>
          <target state="translated">순회가 시작되기 전에 소스 백업 매체는 &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt; 로 열리고 대상 백업 매체는 &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt; 열립니다 . 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1da9ec4f3c9fc4eb1c3cfeb7777f44d15e8f2fe" translate="yes" xml:space="preserve">
          <source>Before this instruction occurs, &lt;code&gt;Mod&lt;/code&gt; must have been loaded using &lt;code&gt;load_object_code&lt;/code&gt;. This instruction loads the module. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">이 명령어가 발생하기 전에 &lt;code&gt;load_object_code&lt;/code&gt; 를 사용하여 &lt;code&gt;Mod&lt;/code&gt; 를로드해야합니다 . 이 명령어는 모듈을로드합니다. &lt;code&gt;PrePurge&lt;/code&gt; 가 무시됩니다. &lt;code&gt;PostPurge&lt;/code&gt; 에 대한 설명은 앞서 고급 명령 &lt;code&gt;update&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="352876a2381c0951748f4964cadc93f74da158b5" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding startElement event, and all endPrefixMapping events will occur immediately after the corresponding endElement event, but their order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable.</source>
          <target state="translated">접두사 URI 네임 스페이스 매핑의 범위를 시작합니다. start / endPrefixMapping 이벤트는 서로에 대해 올바르게 중첩되지 않을 수 있습니다. 모든 startPrefixMapping 이벤트는 해당 startElement 이벤트 직전에 발생하고 모든 endPrefixMapping 이벤트는 해당 endElement 이벤트 직후에 발생하지만 순서는 달리 보장되지 않습니다. . &quot;xml&quot;접두사에 대한 start / endPrefixMapping 이벤트는 미리 선언되어 있고 변경할 수 없기 때문에 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef3ba8079ba496eafefddd167fd69849d3349c1c" translate="yes" xml:space="preserve">
          <source>Beginning of line</source>
          <target state="translated">선의 시작</target>
        </trans-unit>
        <trans-unit id="a0541a24650d9da6d38c74c8da4b43cac73179f4" translate="yes" xml:space="preserve">
          <source>Beginning with Erlang/OTP R14, parentheses when accessing or updating nested records can be omitted. Assume the following record definitions:</source>
          <target state="translated">Erlang / OTP R14부터는 중첩 레코드에 액세스하거나 업데이트 할 때 괄호를 생략 할 수 있습니다. 다음 레코드 정의를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="dbe51e0d3cf7fe095d04d74ded17ede0a93150c5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt; 로 작동 하지만 유니 코드 목록 대신 이진을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="89ade40ae04b2b1a7cb87dcb6495bdb4cd27f4c3" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; except that it allows an extra option to be specified, namely &lt;code&gt;allow_passive_connect&lt;/code&gt;. This option allows the BIF to wait the normal network connection time-out for the &lt;strong&gt;monitored node&lt;/strong&gt; to connect itself, even if it cannot be actively connected from this node (that is, it is blocked). The state where this can be useful can only be achieved by using the Kernel option &lt;code&gt;dist_auto_connect once&lt;/code&gt;. If that option is not used, option &lt;code&gt;allow_passive_connect&lt;/code&gt; has no effect.</source>
          <target state="translated">추가 옵션을 지정할 수 있다는 것을 제외하고 &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; 로 작동 합니다 (예 : &lt;code&gt;allow_passive_connect&lt;/code&gt; ) . 이 옵션을 사용하면 &lt;strong&gt;모니터링되는 노드&lt;/strong&gt; 가이 노드에서 능동적으로 연결할 수없는 경우에도 (즉, 차단 된 경우에도) BIF가 정상적인 네트워크 연결 시간 종료를 대기합니다 . 이 옵션이 유용한 상태는 커널 옵션 &lt;code&gt;dist_auto_connect once&lt;/code&gt; 만 얻을 수 있습니다 . 해당 옵션을 사용하지 않으면 &lt;code&gt;allow_passive_connect&lt;/code&gt; 옵션이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="64aaa639db43c0fb66ead8ebf5d3670fe4ea4ff0" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">SSH 클라이언트의 공개 키 처리를위한 API를 설명하는 동작입니다. 이 동작에 정의 된 콜백을 구현하면 SSH 클라이언트의 공개 키 처리를 사용자 정의 할 수 있습니다. 기본적으로 &lt;code&gt;ssh&lt;/code&gt; 응용 프로그램은 표준 OpenSSH 파일을 사용하여이 동작을 구현합니다. &lt;code&gt;ssh(6)&lt;/code&gt; 응용 프로그램 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f16faae4208d9a96f7fb1bb23ef9cd7087ccfdeb" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">SSH 서버의 공개 키 처리를위한 API를 설명하는 동작입니다. 이 동작에 정의 된 콜백을 구현하여 SSH 서버의 공개 키 처리를 사용자 정의 할 수 있습니다. 기본적으로 SSH 응용 프로그램은 표준 OpenSSH 파일을 사용하여이 동작을 구현합니다. &lt;code&gt;ssh(6)&lt;/code&gt; 응용 프로그램 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0d4ec155f7430eef8a27415e38c4ad6595b98c0" translate="yes" xml:space="preserve">
          <source>Behaviour module for reporting SNMP agent errors</source>
          <target state="translated">SNMP 에이전트 오류보고를위한 동작 모듈</target>
        </trans-unit>
        <trans-unit id="2d41c7e7235b92d9c78165f5ea1a1214538b7ae8" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent discovery handler.</source>
          <target state="translated">SNMP 에이전트 감지 핸들러의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="4d88eee718b5f101a30d4bf7abe96e2a4af445a2" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib storage.</source>
          <target state="translated">SNMP 에이전트 mib 스토리지의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="213836ecbce5c62ee5c70a707ff8f6efbfddb7e0" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib-server data module.</source>
          <target state="translated">SNMP 에이전트 mib-server 데이터 모듈의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="9b9ea5bbfad06ea1fc316484f53361a36304e0df" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network interface.</source>
          <target state="translated">SNMP 에이전트 네트워크 인터페이스의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="b7490591e615b37731085e0dc791786738305c7b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network-interface filter.</source>
          <target state="translated">SNMP 에이전트 네트워크 인터페이스 필터의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="2d2c6aaaa587ce80e3a95c5e764e760aa91d874b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification delivery information receiver.</source>
          <target state="translated">SNMP 에이전트 알림 전달 정보 수신자의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="625c1c9de2b712103668af5814be0412885b49e5" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification filters.</source>
          <target state="translated">SNMP 에이전트 알림 필터의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="de9d0d8b19209222093743579cc0da909bbbb028" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network interface.</source>
          <target state="translated">SNMP 관리자 네트워크 인터페이스의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="2f41f4d43078504e98d5de4dc916e14eb8a85ba6" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network-interface filter.</source>
          <target state="translated">SNMP 관리자 네트워크 인터페이스 필터의 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="eb1e7ed7fa32a13f652cc9e9bf36d2ab93e52c2b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager user.</source>
          <target state="translated">SNMP 관리자 사용자를위한 동작 모듈.</target>
        </trans-unit>
        <trans-unit id="77b3fcb503c107fdcf78ea27b16f4310e4bd176a" translate="yes" xml:space="preserve">
          <source>Behaviour with optional callbacks to customize the inets HTTP server.</source>
          <target state="translated">선택적 콜백이있는 동작으로 inets HTTP 서버를 사용자 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e0f283a40056570ec143d350395380c52fd1c5b2" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;/usr/local/otp&lt;/code&gt;:</source>
          <target state="translated">다음은 OTP가 &lt;code&gt;/usr/local/otp&lt;/code&gt; 디렉토리에 설치되어있는 경우 사용자의 &lt;code&gt;.emacs&lt;/code&gt; 에 추가해야 할 사항의 전체 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1fad7bb629bd2e9041c6abf5bc0a920316f854b0" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">다음은 OTP가 &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt; 디렉토리에 설치되어있는 경우 사용자의 &lt;code&gt;.emacs&lt;/code&gt; 에 추가해야하는 전체 예입니다 .</target>
        </trans-unit>
        <trans-unit id="40217191ef85c64b525b787ccb400689f06f21a9" translate="yes" xml:space="preserve">
          <source>Below is an example of the grammar above with structure building code added:</source>
          <target state="translated">다음은 구조 작성 코드가 추가 된 위의 문법 예입니다.</target>
        </trans-unit>
        <trans-unit id="5d5970fcf1e0337426fd2a5c1de2fd3082f3b1fe" translate="yes" xml:space="preserve">
          <source>Benchmarks can measure wall-clock time or CPU time.</source>
          <target state="translated">벤치 마크는 벽시계 시간 또는 CPU 시간을 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb8b17cc74805621ef756d36abfea020e22ec89" translate="yes" xml:space="preserve">
          <source>Benchmarks that appear to be concurrent are often sequential. The estone benchmark, for example, is entirely sequential. So is the most common implementation of the &quot;ring benchmark&quot;; usually one process is active, while the others wait in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="translated">동시적인 것으로 보이는 벤치 마크는 종종 순차적입니다. 예를 들어, estone 벤치 마크는 완전히 순차적입니다. &quot;링 벤치 마크&quot;의 가장 일반적인 구현도 마찬가지입니다. 일반적으로 하나의 프로세스가 활성화되고 다른 프로세스는 &lt;code&gt;receive&lt;/code&gt; 문을 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="c274af2a723078651a0cf0e2bdc4b8cb3f48d70d" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;qlc:table/2&lt;/code&gt;, other functions return query handles. They are used more seldom than tables, but are sometimes useful. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; traverses objects from many tables or lists after each other. If, for example, you want to traverse all answers to a query &lt;code&gt;QH&lt;/code&gt; and then finish off by a term &lt;code&gt;{finished}&lt;/code&gt;, you can do that by calling &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt;. &lt;code&gt;append/2&lt;/code&gt; first returns all objects of &lt;code&gt;QH&lt;/code&gt;, then &lt;code&gt;{finished}&lt;/code&gt;. If a tuple &lt;code&gt;{finished}&lt;/code&gt; exists among the answers to &lt;code&gt;QH&lt;/code&gt;, it is returned twice from &lt;code&gt;append/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;qlc:table/2&lt;/code&gt; 외에도 다른 함수는 쿼리 핸들을 반환합니다. 그것들은 테이블보다 거의 사용되지 않지만 때로는 유용합니다. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; 는 많은 테이블이나 목록의 객체를 차례로 순회합니다. 예를 들어 쿼리 &lt;code&gt;QH&lt;/code&gt; 에 대한 모든 답변을 탐색 한 다음 &lt;code&gt;{finished}&lt;/code&gt; 용어로 마무리 하려면 &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt; 를 호출하여이를 수행 할 수 있습니다 . &lt;code&gt;append/2&lt;/code&gt; 는 먼저 &lt;code&gt;QH&lt;/code&gt; 의 모든 객체를 반환 한 다음 &lt;code&gt;{finished}&lt;/code&gt; 를 반환합니다 . &lt;code&gt;QH&lt;/code&gt; 에 대한 응답 중에 튜플 &lt;code&gt;{finished}&lt;/code&gt; 가 있으면 &lt;code&gt;append/2&lt;/code&gt; 에서 두 번 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6260580b5bc11052e617d5d44b018db15e9a982" translate="yes" xml:space="preserve">
          <source>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</source>
          <target state="translated">pid를 사용하여 프로세스를 처리하는 것 외에도 프로세스를 이름으로 등록하기위한 BIF도 있습니다. 이름은 원자 여야하며 프로세스가 종료되면 자동으로 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="b15bc3f2eceb04129fd4516b3b370516eb00424d" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">보고 시간 외에도 &lt;code&gt;erlang:now/0&lt;/code&gt; 은 고유하고 엄격하게 단조 증가하는 값을 생성합니다. 이 기능을 시간 측정에서 분리하기 위해 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt; 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="9a52810e66627e5a80808e690811322ee8adf786" translate="yes" xml:space="preserve">
          <source>Besides test cases and groups, the test suite can also contain configuration functions. These functions are meant to be used for setting up (and verifying) environment and state in the SUT (and/or the &lt;code&gt;Common Test&lt;/code&gt; host node), required for the tests to execute correctly. Examples of operations are: Opening a connection to the SUT, initializing a database, running an installation script, and so on. Configuration can be performed per suite, per test case group, and per individual test case.</source>
          <target state="translated">테스트 사례 및 그룹 외에도 테스트 스위트에는 구성 기능이 포함될 수 있습니다. 이 기능은 테스트가 올바르게 실행 되려면 SUT (및 / 또는 &lt;code&gt;Common Test&lt;/code&gt; 호스트 노드) 에서 환경 및 상태를 설정 (및 확인)하는 데 사용 됩니다. 조작 예는 다음과 같습니다. SUT에 대한 연결 열기, 데이터베이스 초기화, 설치 스크립트 실행 등. 제품군, 테스트 사례 그룹 및 개별 테스트 사례별로 구성을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="007ac80b876d6b31b51d4c189993df4c58d1fc5a" translate="yes" xml:space="preserve">
          <source>Besides the already mentioned source parameters &lt;code&gt;root_dir&lt;/code&gt; and &lt;code&gt;lib_dirs&lt;/code&gt;, the following system (&lt;code&gt;sys&lt;/code&gt;) level options are supported:</source>
          <target state="translated">이미 언급 된 소스 매개 변수 &lt;code&gt;root_dir&lt;/code&gt; 및 &lt;code&gt;lib_dirs&lt;/code&gt; 외에도 다음 시스템 ( &lt;code&gt;sys&lt;/code&gt; ) 레벨 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d77fc5043db349a36fcc2530a0223317a9d51ded" translate="yes" xml:space="preserve">
          <source>Between modules</source>
          <target state="translated">모듈 간</target>
        </trans-unit>
        <trans-unit id="7e04d97ca7154dfa6468b97d3b9c42d0c616a358" translate="yes" xml:space="preserve">
          <source>Between nodes</source>
          <target state="translated">노드 사이</target>
        </trans-unit>
        <trans-unit id="3430043cce88789d3bd382a0b2a1bc3c39a24538" translate="yes" xml:space="preserve">
          <source>Between processes</source>
          <target state="translated">프로세스 간</target>
        </trans-unit>
        <trans-unit id="f647ae7d5e7143915c4692eef6551f34333f508c" translate="yes" xml:space="preserve">
          <source>Beware of confusing mandatory in the sense of the M-bit with mandatory in the sense of the command grammar. The former is a semantic requirement: that the receiver understand the semantics of the AVP in the context in question. The latter is a syntactic requirement: whether or not the AVP must occur in the message in question.</source>
          <target state="translated">M- 비트의 의미에서 의무적 인 혼동과 명령 문법의 의미에서 의무적 인 혼동을 조심하십시오. 전자는 의미 론적 요구 사항이다 : 수신자는 문제의 맥락에서 AVP의 의미론을 이해해야한다. 후자는 구문상의 요구 사항입니다. 해당 메시지에서 AVP가 발생해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5a3b08c5bdc112934a46e49f93c6566926eb949f" translate="yes" xml:space="preserve">
          <source>Beware of trailing space in &lt;code&gt;Replacement&lt;/code&gt; to be used. If you must have a space in &lt;code&gt;Re&lt;/code&gt;, use, for example, the character encoding &lt;code&gt;\040&lt;/code&gt;, see &lt;code&gt;re(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Replacement&lt;/code&gt; 사용할 후행 공간에주의하십시오 . &lt;code&gt;Re&lt;/code&gt; 에 공백이 있어야하는 경우, 예를 들어 문자 인코딩 &lt;code&gt;\040&lt;/code&gt; 을 사용하십시오. &lt;code&gt;re(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99e106abb61082912f0a96161c0ad22a4eea32f3" translate="yes" xml:space="preserve">
          <source>Beware of using fun expressions of the form &lt;code&gt;fun Name/Arity&lt;/code&gt; in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">재미가 &lt;code&gt;fun Name/Arity&lt;/code&gt; 되지 않고 런타임에 코드를 업그레이드 해야하는 상황에서 fun 재미있는 Name / Arity 형식의 재미있는 표현 사용에주의하십시오. 이러한 재미를 유지하는 프로세스는 이전 코드를 참조하기 때문입니다. 특히, 이러한 값은 일반적으로 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 로 전달 된 구성에 적합하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9f04d9d4432e8383e468152a41bfa09dcf4f742e" translate="yes" xml:space="preserve">
          <source>Beware that RFC 6733 changed the DiameterURI transport/port defaults specified in RFC3588. Relying on the defaults can result in interoperability problems.</source>
          <target state="translated">RFC 6733이 RFC3588에 지정된 DiameterURI 전송 / 포트 기본값을 변경했음을주의하십시오. 기본값을 사용하면 상호 운용성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37789191d916ab6f4adfabdff7e05307d5bbf9ba" translate="yes" xml:space="preserve">
          <source>Beware the difference between &lt;strong&gt;diameter&lt;/strong&gt; (not capitalized) and &lt;strong&gt;Diameter&lt;/strong&gt; (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733.</source>
          <target state="translated">차이주의 &lt;strong&gt;직경&lt;/strong&gt; (되지 대문자) 및 &lt;strong&gt;직경&lt;/strong&gt; (대문자)를. 전자는 여기서 주요 api가 여기에 정의 된 Diameter라는 Erlang 애플리케이션을 참조하고, 후자는 RFC 6733의 의미에서 Diameter 프로토콜을 말합니다.</target>
        </trans-unit>
        <trans-unit id="5b68a0f135268fc97357fa1f2e8bec70aa5933a7" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the binum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="translated">Bignum은 &lt;code&gt;Sign&lt;/code&gt; 바이트 와 함께 단항 형식으로 저장됩니다. 즉, 이항이 양수이면 0이고 음수이면 1입니다. 숫자는 최하위 바이트가 먼저 저장된 상태로 저장됩니다. 정수를 계산하기 위해 다음 공식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c51379d746d689abb0d4163480ae980cc1ea4f" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="translated">이진은 비트 구문 표현 또는 &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; , &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt; 또는 이진 포트의 입력으로 생성됩니다. &lt;code&gt;Len&lt;/code&gt; 길이 필드는 4 바이트의 부호없는 정수 (빅 엔디안)이다.</target>
        </trans-unit>
        <trans-unit id="afb16785a033cecba113ba879f8a7ad266f9f880" translate="yes" xml:space="preserve">
          <source>Binaries are more troublesome. For performance reasons, programs often store textual data in binaries instead of lists, mainly because they are more compact (one byte per character instead of two words per character, as is the case with lists). Using &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, an ISO Latin-1 Erlang string can be converted into a binary, effectively using bytewise encoding: one byte per character. This was convenient for those limited Erlang strings, but cannot be done for arbitrary Unicode lists.</source>
          <target state="translated">바이너리는 더 귀찮습니다. 성능상의 이유로 프로그램은 종종 텍스트 데이터를 목록 대신 이진 파일로 저장합니다. 주로 텍스트가 더 작기 때문입니다 (목록의 경우와 같이 문자 당 두 단어 대신 문자 당 1 바이트). 사용 &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; 는 ISO 라틴어 1 얼랑 문자열 인코딩의 바이트 효율적으로 사용하여 바이너리로 변환 할 수 있습니다 : 문자 당 한 바이트. 이는 제한된 Erlang 문자열에는 편리하지만 임의의 유니 코드 목록에는 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9777da829501809520a535ef9e6d08ff6a5dcba9" translate="yes" xml:space="preserve">
          <source>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</source>
          <target state="translated">이진은 전체 바이트의 시퀀스입니다. 임의의 비트 길이를 가진 비트 스트링은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddb0d785eee554ca3ad9cce85a18ca8630f56b8c" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently built in the following way:</source>
          <target state="translated">바이너리는 다음과 같은 방식으로 효율적으로 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0d3b67132c6fcaa92c679366fed8db13d485e2" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently matched like this:</source>
          <target state="translated">바이너리는 다음과 같이 효율적으로 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="892dde55806e241693a0b3bdfdd1efae250f381f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;Bin&lt;/code&gt; contains the same information as the output from &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt;. Use &lt;code&gt;binary_to_list/1&lt;/code&gt; to obtain the string of characters from the binary.</source>
          <target state="translated">이진 &lt;code&gt;Bin&lt;/code&gt; 에는 &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt; 의 출력과 동일한 정보가 포함 됩니다. 바이너리에서 문자열을 얻으려면 &lt;code&gt;binary_to_list/1&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebbd4d9948de9c87d6e53af4cc41250b5709a590" translate="yes" xml:space="preserve">
          <source>Binary boot script</source>
          <target state="translated">이진 부팅 스크립트</target>
        </trans-unit>
        <trans-unit id="6ca5ef63e7a423ed4f0c902eb2201ec5aa53e26f" translate="yes" xml:space="preserve">
          <source>Binary callback function &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; is used for looking up objects in the table. The first argument &lt;code&gt;Position&lt;/code&gt; is the key position or an indexed position and the second argument &lt;code&gt;Keys&lt;/code&gt; is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at &lt;code&gt;Position&lt;/code&gt; is a member of &lt;code&gt;Keys&lt;/code&gt;. Any other return value is immediately returned as value of the query evaluation. &lt;code&gt;LookupFun&lt;/code&gt; is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at &lt;code&gt;Position&lt;/code&gt; in such a way that only &lt;code&gt;Keys&lt;/code&gt; need to be looked up to find all potential answers.</source>
          <target state="translated">이진 콜백 함수 &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; 은 테이블에서 객체를 찾는 데 사용됩니다. 첫 번째 인수 &lt;code&gt;Position&lt;/code&gt; 은 키 위치 또는 인덱스 위치이고 두 번째 인수 &lt;code&gt;Keys&lt;/code&gt; 는 고유 값의 정렬 된 목록입니다. 반환 값은 &lt;code&gt;Position&lt;/code&gt; 의 요소 가 &lt;code&gt;Keys&lt;/code&gt; 의 멤버가 되도록 모든 객체 (튜플)의리스트입니다 . 다른 반환 값은 즉시 쿼리 평가 값으로 반환됩니다. &lt;code&gt;LookupFun&lt;/code&gt; 는 구문 분석에 필터가 일치하는지 확인하고있는 요소를 비교할 수 있습니다 컴파일시에 변환 경우 대신 테이블을 가로 지르는의 호출 &lt;code&gt;Position&lt;/code&gt; 하는 방법으로 만 &lt;code&gt;Keys&lt;/code&gt; 모든 잠재적 인 답변을 찾으려면 찾아봐야합니다.</target>
        </trans-unit>
        <trans-unit id="91649b24f930abce26bedbe83f0148ebb05baa18" translate="yes" xml:space="preserve">
          <source>Binary codecs</source>
          <target state="translated">이진 코덱</target>
        </trans-unit>
        <trans-unit id="bfbd337015a6a1e9c7fe45e7f4ee5d33b7a0cc06" translate="yes" xml:space="preserve">
          <source>Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.</source>
          <target state="translated">이진 데이터는 프로세스간에 공유됩니다. 다른 프로세스가 여전히 더 큰 바이너리를 참조하는 경우이 프로세스가 사용하는 부분을 복사하면 더 많은 메모리 만 소비되고 가비지 수집을 위해 더 큰 바이너리를 해제하지 않습니다. 이러한 종류의 침입 기능은 극도의주의를 기울여 실제 문제가 감지 된 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e0b461eb903baadd26c515cd4ef53be30f07dc47" translate="yes" xml:space="preserve">
          <source>Binary handling was significantly improved in R12B. Because code that was efficient in R11B might not be efficient in R12B, and vice versa, earlier revisions of this Efficiency Guide contained some information about binary handling in R11B.</source>
          <target state="translated">이진 처리는 R12B에서 크게 개선되었습니다. R11B에서 효율적인 코드는 R12B에서 효율적이지 않거나 그 반대 일 수 있으므로이 효율 안내서의 이전 버전에는 R11B의 이진 처리에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3435ca67f0f051a1fea228cdb0770bf8e8bb3d65" translate="yes" xml:space="preserve">
          <source>Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with &lt;code&gt;copy/1&lt;/code&gt; can be useful when optimizing for memory use.</source>
          <target state="translated">이진 공유는 이진이 분리 될 때마다 발생합니다. 이것이 바이너리가 빠르며 근본적으로 O (1) 복잡성으로 분해를 수행 할 수있는 근본적인 이유입니다. 드문 경우이지만이 데이터 공유는 바람직하지 않습니다. 왜이 기능이 &lt;code&gt;copy/1&lt;/code&gt; 과 함께 메모리 사용을 최적화 할 때 유용 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="444f4f33b9d5b0002c23fd9ec1a4edab1ded0af6" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in UTF-8 or UTF-16.</source>
          <target state="translated">UTF-8 또는 UTF-16으로 인코딩 된 문자가있는 이진입니다.</target>
        </trans-unit>
        <trans-unit id="c065024f1e88a0e634a5d724af341ce692e22147" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in iso-latin-1.</source>
          <target state="translated">이소-라틴 -1로 인코딩 된 문자를 가진 이진.</target>
        </trans-unit>
        <trans-unit id="89f902f1a369dce968f46c3953a9e68e0d99f72f" translate="yes" xml:space="preserve">
          <source>BinaryGraphOp ::= &lt;code&gt;of&lt;/code&gt;</source>
          <target state="translated">BinaryGraphOp :: = &lt;code&gt;of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7513e46be3c5ca02f1cd91f8479bcae815aa2cca" translate="yes" xml:space="preserve">
          <source>BinarySetOp ::= &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">BinarySetOp :: = &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8264338650782cc58de94b15794c38a796b18c92" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is not supported on the specific platform.</source>
          <target state="translated">특정 플랫폼에서는 스케줄러 바인딩이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65e949b92a71c14d4ea442682069d67c76442e70" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is only supported on newer Linux, Solaris, FreeBSD, and Windows systems.</source>
          <target state="translated">스케줄러 바인딩은 최신 Linux, Solaris, FreeBSD 및 Windows 시스템에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1e29acb46257f51cfc0f132df9d70d5a8cf45608" translate="yes" xml:space="preserve">
          <source>Bindings,</source>
          <target state="translated">Bindings,</target>
        </trans-unit>
        <trans-unit id="a255a9d3a4009bbdfcc5e9d159b353b687a30da6" translate="yes" xml:space="preserve">
          <source>Binds a socket to a specific network interface. This option must be used in a function call that creates a socket, that is, &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">소켓을 특정 네트워크 인터페이스에 바인딩합니다. 이 옵션은 소켓을 작성하는 함수 호출, 즉 &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt; 에서 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="360cda316649dfca67f2603c94b136a74b6c648a" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are analogous to List Comprehensions. They are used to generate bit strings efficiently and succinctly.</source>
          <target state="translated">비트 열 이해는리스트 이해와 유사합니다. 비트 문자열을 효율적이고 간결하게 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ef7ef37c0e6417fc396a660a24f1538c5ef671" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are written with the following syntax:</source>
          <target state="translated">비트 문자열 이해는 다음 구문으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="fe2441919ecc33eba0d15c91c6774d8e118b27fa" translate="yes" xml:space="preserve">
          <source>Bit strings are expressed using the &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비트 문자열은 &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt; 사용하여 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef4786f28896f4e7ec27947fbbc93a25189b57f1" translate="yes" xml:space="preserve">
          <source>Bit strings that consist of a number of bits that are evenly divisible by eight, are called &lt;strong&gt;binaries&lt;/strong&gt;</source>
          <target state="translated">8로 나눌 수있는 여러 비트로 구성된 비트 문자열을 &lt;strong&gt;이진&lt;/strong&gt; 이라고 &lt;strong&gt;합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71ef7d1974a07fcaa17eb97f44c3fb4fcef331ed" translate="yes" xml:space="preserve">
          <source>Bitshift right</source>
          <target state="translated">비트 시프트</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="567f521d0a70021d35df0a7429cd3579c200a9d3" translate="yes" xml:space="preserve">
          <source>Bitwise operators: &lt;code&gt;band&lt;/code&gt;, &lt;code&gt;bor&lt;/code&gt;, &lt;code&gt;bxor&lt;/code&gt;, &lt;code&gt;bnot&lt;/code&gt;, &lt;code&gt;bsl&lt;/code&gt;, &lt;code&gt;bsr&lt;/code&gt;</source>
          <target state="translated">비트 연산자 : &lt;code&gt;band&lt;/code&gt; , &lt;code&gt;bor&lt;/code&gt; , &lt;code&gt;bxor&lt;/code&gt; , &lt;code&gt;bnot&lt;/code&gt; , &lt;code&gt;bsl&lt;/code&gt; , &lt;code&gt;bsr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae104d5e9f670270b20927f74417d76623f8773a" translate="yes" xml:space="preserve">
          <source>Black-box testing of target systems of any type (that is, not necessarily implemented in Erlang). This is performed through standard O&amp;amp;M interfaces (such as SNMP, HTTP, CORBA, and Telnet) and, if necessary, through user-specific interfaces (often called test ports).</source>
          <target state="translated">모든 유형의 대상 시스템에 대한 블랙 박스 테스트 (즉, 반드시 Erlang으로 구현되지는 않음). 이는 표준 O &amp;amp; M 인터페이스 (예 : SNMP, HTTP, CORBA 및 Telnet)를 통해 수행되며 필요한 경우 사용자 별 인터페이스 (종종 테스트 포트)를 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9a8a1cf314b7d5a93ed2c3c8500ce8e82ea060d8" translate="yes" xml:space="preserve">
          <source>Block ciphers -  DES and AES in Block Cipher Modes - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">블록 암호-블록 암호 모드의 DES 및 AES- &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc11d63974d38781fdb2ea32c8ba8e895421285c" translate="yes" xml:space="preserve">
          <source>Block expressions provide a way to group a sequence of expressions, similar to a clause body. The return value is the value of the last expression &lt;code&gt;ExprN&lt;/code&gt;.</source>
          <target state="translated">블록 표현식은 절 본문과 유사한 일련의 표현식을 그룹화하는 방법을 제공합니다. 리턴 값은 마지막 표현식 &lt;code&gt;ExprN&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a11c7845b57dd764a4e0b6dfeac45510d039cbd4" translate="yes" xml:space="preserve">
          <source>Blocking of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that you need to use these features, consider it a few more times again. Blocking multi-scheduling is only to be used as a last resort, as it is most likely a &lt;strong&gt;very inefficient&lt;/strong&gt; way to solve the problem.</source>
          <target state="translated">다중 예약 및 일반 다중 예약 차단은 일반적으로 필요하지 않습니다. 이러한 기능을 사용해야한다고 생각되면 다시 몇 번 더 고려하십시오. 다중 예약 차단 은 문제를 해결하는 데 &lt;strong&gt;매우 비효율적 인&lt;/strong&gt; 방법 일 수 있으므로 최후의 수단으로 만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f88bcddd0731f8535aab4cf6c4aea9771da5b592" translate="yes" xml:space="preserve">
          <source>Blocks that are larger than the value of the singleblock carrier threshold (&lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt;) parameter are placed in singleblock carriers.</source>
          <target state="translated">단일 블록 캐리어 임계 값 ( &lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt; ) 파라미터 의 값보다 큰 블록은 단일 블록 캐리어 에 배치된다.</target>
        </trans-unit>
        <trans-unit id="19edd385ea6503e1211246f52fb3bd015a6b72b6" translate="yes" xml:space="preserve">
          <source>Blocks that are smaller than the value of parameter &lt;code&gt;sbct&lt;/code&gt; are placed in multiblock carriers.</source>
          <target state="translated">파라미터 &lt;code&gt;sbct&lt;/code&gt; 의 값보다 작은 블록은 멀티 블록 캐리어에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="4206776cd5ab32e70519cb42f90bc1cb4373333a" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3cde099dd0c2860dfd30f6b0378f3f056b13cc7" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="60192723d1692fc0b5f8fc179416c38b9c58ae23" translate="yes" xml:space="preserve">
          <source>Boolean expressions</source>
          <target state="translated">부울 식</target>
        </trans-unit>
        <trans-unit id="66182d005e228ccf7ad8ca7af48f43e62e8288b3" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;andalso&lt;/code&gt;, &lt;code&gt;orelse&lt;/code&gt;</source>
          <target state="translated">부울 연산자 : &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;andalso&lt;/code&gt; , &lt;code&gt;orelse&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff2372b936c678678613bf8145deb94c379766ad" translate="yes" xml:space="preserve">
          <source>Booleans in ASN.1 express values that can be either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;. The meanings assigned to &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are outside the scope of this text.</source>
          <target state="translated">ASN.1의 부울 값은 &lt;code&gt;TRUE&lt;/code&gt; 또는 &lt;code&gt;FALSE&lt;/code&gt; 일 수있는 값을 나타 냅니다. &lt;code&gt;TRUE&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 에 지정된 의미 는이 텍스트의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="57f87135d0b5c7204e5e725d7f6d51c65d0e1da6" translate="yes" xml:space="preserve">
          <source>Boot script</source>
          <target state="translated">부팅 스크립트</target>
        </trans-unit>
        <trans-unit id="55cc3a7f7d6ae5f5575682107980e3293f644b52" translate="yes" xml:space="preserve">
          <source>Boot scripts are built using the &lt;code&gt;systools&lt;/code&gt; utility in the SASL application. For more information on &lt;code&gt;systools&lt;/code&gt;, see the SASL documentation. This is only an example of what can be done.</source>
          <target state="translated">부팅 스크립트는 SASL 응용 프로그램 의 &lt;code&gt;systools&lt;/code&gt; 유틸리티를 사용하여 작성 됩니다. &lt;code&gt;systools&lt;/code&gt; 에 대한 자세한 내용 은 SASL 설명서를 참조하십시오. 이것은 할 수있는 일의 예일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="a3d4144d275cc7e2f7cb03eca0c38a1d2569fa5e" translate="yes" xml:space="preserve">
          <source>Boot server for other Erlang machines.</source>
          <target state="translated">다른 Erlang 머신의 부트 서버.</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="aeca55061b1a7fcf42d399adecf44466466ea1f5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;GetInfo&lt;/code&gt; and &lt;code&gt;GetBin&lt;/code&gt; must be called within the &lt;code&gt;Fun&lt;/code&gt;. Their behavior is undefined if they are called outside the context of &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">두 &lt;code&gt;GetInfo&lt;/code&gt; 를 하고 &lt;code&gt;GetBin&lt;/code&gt; 는 내에서 호출해야 &lt;code&gt;Fun&lt;/code&gt; . &lt;code&gt;Fun&lt;/code&gt; 컨텍스트 외부에서 호출되는 경우 해당 동작은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="088b2c8092f1e119c8753dea210acbd5446d7101" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;WarningList&lt;/code&gt; and &lt;code&gt;ErrorList&lt;/code&gt; have the following format:</source>
          <target state="translated">&lt;code&gt;WarningList&lt;/code&gt; 및 &lt;code&gt;ErrorList&lt;/code&gt; 는 모두 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="17f701bc8b6f6001358219750664486c85b21b5d" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; have &lt;strong&gt;return values&lt;/strong&gt;, that is, in the above example &lt;code&gt;case&lt;/code&gt; returned either &lt;code&gt;{inch,X/2.54}&lt;/code&gt; or &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt;. The behaviour of &lt;code&gt;case&lt;/code&gt; can also be modified by using guards. The following example clarifies this. It tells us the length of a month, given the year. The year must be known, since February has 29 days in a leap year.</source>
          <target state="translated">두 &lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;if&lt;/code&gt; 가 &lt;strong&gt;리턴 값&lt;/strong&gt; , 즉, 상기 예에서 &lt;code&gt;case&lt;/code&gt; 중 리턴 &lt;code&gt;{inch,X/2.54}&lt;/code&gt; 또는 &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt; . 가드를 사용하여 &lt;code&gt;case&lt;/code&gt; 의 동작을 수정할 수도 있습니다. 다음 예제는이를 명확하게합니다. 주어진 연도의 길이를 알려줍니다. 2 월은 윤년에 29 일이 있기 때문에 연도를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="28509f91486de7be6923a1aa53ee47118e6db5bf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; belong to the STDLIB application.</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 및 &lt;code&gt;proc_lib&lt;/code&gt; 는 모두 STDLIB 응용 프로그램에 속합니다.</target>
        </trans-unit>
        <trans-unit id="da40d11cd13d54f5078c0119cec66e0ccfe5dfdd" translate="yes" xml:space="preserve">
          <source>Both building with dynamic trace probes and using them is experimental and unsupported by Erlang/OTP. It is included as an option for the developer to trace and debug performance issues in their systems.</source>
          <target state="translated">Erlang / OTP는 다이나믹 트레이스 프로브를 사용하여 빌드하고 사용하는 것이 실험적이고 지원되지 않습니다. 개발자가 시스템의 성능 문제를 추적하고 디버그 할 수있는 옵션으로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="272b41459c2a4ad1e5b3d0281a8c236f1fbb8ef5" translate="yes" xml:space="preserve">
          <source>Both clients and daemons accepts options that controls the exact behaviour. Some options are common to both. The three sets are called &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">클라이언트와 데몬은 모두 정확한 동작을 제어하는 ​​옵션을 허용합니다. 일부 옵션은 둘 다 공통입니다. 세 가지 세트를 &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="43500df87c9d667061a043ba9cd51b43abef2516" translate="yes" xml:space="preserve">
          <source>Both functions are described in the following.</source>
          <target state="translated">두 기능 모두 다음에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8393123b8c640d62b0cc06dc60be2e57645d7426" translate="yes" xml:space="preserve">
          <source>Both increasing and decreasing &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt;s are allowed.</source>
          <target state="translated">&lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt; 를 늘리거나 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84d91e83adcd109e53d7f1d1718f4d0e6a80ae0d" translate="yes" xml:space="preserve">
          <source>Both mechanisms have the same theoretical time and memory complexity, while the selective receive language construct has smaller constant factors.</source>
          <target state="translated">두 가지 메커니즘 모두 이론적 시간 및 메모리 복잡성이 동일하지만 선택적 수신 언어 구성은 더 작은 상수 요소를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c1196a55702bdb5abaf2deea06cedc05c7a896fe" translate="yes" xml:space="preserve">
          <source>Both of them can be empty, but not at the same time. If &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; is empty, no changes have been made that change the build result of any application. This could, for example, be a pure bug fix of the build system. The order of lines is undefined. All white-space characters in this file are either space (character 32) or line-break (character 10).</source>
          <target state="translated">둘 다 비워 둘 수 있지만 동시에 할 수는 없습니다. 경우 &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; 비어, 변경은 그 변화 모든 응용 프로그램의 빌드 결과를 만들어되지 않았습니다. 예를 들어, 이것은 빌드 시스템의 순수한 버그 수정일 수 있습니다. 줄의 순서는 정의되어 있지 않습니다. 이 파일의 모든 공백 문자는 공백 (문자 32) 또는 줄 바꿈 (문자 10)입니다.</target>
        </trans-unit>
        <trans-unit id="3442514fe2989d64511fbe704d87cbeac484a561" translate="yes" xml:space="preserve">
          <source>Both old and current code for a module are valid, and can even be evaluated concurrently. The difference is that exported functions in old code are unavailable. Hence, a global call cannot be made to an exported function in old code, but old code can still be evaluated because of processes lingering in it.</source>
          <target state="translated">모듈의 이전 코드와 현재 코드는 모두 유효하며 동시에 평가할 수도 있습니다. 차이점은 이전 코드에서 내 보낸 함수를 사용할 수 없다는 것입니다. 따라서 이전 코드에서 내 보낸 함수에 대한 전역 호출을 수행 할 수 없지만 프로세스가 남아있는 이전 코드는 여전히 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a81666107cfaaf40864441b74f9792a8cc7fb8a" translate="yes" xml:space="preserve">
          <source>Both old and current code is valid, and can be evaluated concurrently. Fully qualified function calls always refer to current code. Old code can still be evaluated because of processes lingering in the old code.</source>
          <target state="translated">이전 코드와 현재 코드는 모두 유효하며 동시에 평가할 수 있습니다. 완전한 함수 호출은 항상 현재 코드를 참조합니다. 이전 코드에는 프로세스가 남아 있기 때문에 이전 코드는 여전히 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19893bb20867dad51e674f2c8283aa35e37963b9" translate="yes" xml:space="preserve">
          <source>Both options give the same effect, the input string is interpreted as UTF-8. Notice that with these instructions, the automatic conversion of lists to UTF-8 is not performed by the &lt;code&gt;re&lt;/code&gt; functions. Therefore, using these sequences is not recommended. Add option &lt;code&gt;unicode&lt;/code&gt; when running &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">두 옵션 모두 동일한 효과를 제공하며 입력 문자열은 UTF-8로 해석됩니다. 이 명령어를 사용하면 &lt;code&gt;re&lt;/code&gt; 함수 에서 목록을 UTF-8로 자동 변환하지 않습니다 . 따라서 이러한 시퀀스를 사용하지 않는 것이 좋습니다. 대신 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 를 실행할 때 옵션 &lt;code&gt;unicode&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f750b6f7ecf467d03fd155880c2c08a8e8637a" translate="yes" xml:space="preserve">
          <source>Both server and event manager are registered processes which can be expected to be always accessible. Thus they are specified to be &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">서버와 이벤트 관리자는 모두 항상 액세스 할 수있는 등록 된 프로세스입니다. 따라서 그것들은 &lt;code&gt;permanent&lt;/code&gt; 지정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57dd8748ee1441894d656dd738cdc13c745b3ff2" translate="yes" xml:space="preserve">
          <source>Both source code and object code for the module is found.</source>
          <target state="translated">모듈의 소스 코드와 객체 코드가 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ebc6ec0ff8694d627315dcce4507da48f45e45" translate="yes" xml:space="preserve">
          <source>Both the agent and the manager can be configured to log incoming and outgoing messages. It uses the Erlang standard log mechanism &lt;code&gt;disk_log&lt;/code&gt; for logging. The size and location of the log files are configurable. A wrap log is used, which means that when the log has grown to a maximum size, it starts from the beginning of the log, overwriting existing log records.</source>
          <target state="translated">에이전트와 관리자 모두 수신 및 발신 메시지를 기록하도록 구성 할 수 있습니다. Erlang 표준 로그 메커니즘 &lt;code&gt;disk_log&lt;/code&gt; 를 사용하여 로깅합니다. 로그 파일의 크기와 위치를 구성 할 수 있습니다. 랩 로그가 사용됩니다. 즉, 로그가 최대 크기로 커지면 로그 시작 부분부터 시작하여 기존 로그 레코드를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="31ef6ae37976246cbbb8302e6168cf2ddacebc06" translate="yes" xml:space="preserve">
          <source>Both the module declaration and the export declaration of the &lt;code&gt;main/1&lt;/code&gt; function are optional.</source>
          <target state="translated">&lt;code&gt;main/1&lt;/code&gt; 함수 의 모듈 선언과 내보내기 선언은 모두 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="19b296fa85d6e817ce8e73a30a0d4e4ab33ce24a" translate="yes" xml:space="preserve">
          <source>Both the old and new versions of the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.rel&lt;/code&gt; files must be in the code path, as well as the &lt;code&gt;.appup&lt;/code&gt; and (new) &lt;code&gt;.beam&lt;/code&gt; files. The code path can be extended by using the option &lt;code&gt;path&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 및 &lt;code&gt;.rel&lt;/code&gt; 파일 의 이전 및 새 버전은 모두 &lt;code&gt;.appup&lt;/code&gt; 및 (new) &lt;code&gt;.beam&lt;/code&gt; 파일 과 함께 코드 경로에 있어야 합니다. 옵션 &lt;code&gt;path&lt;/code&gt; 를 사용하여 코드 경로를 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2a0efd65a8f4b932941a27e1ed06208576cd1ee" translate="yes" xml:space="preserve">
          <source>Both the registration and lock services are atomic. All nodes involved in these actions have the same view of the information.</source>
          <target state="translated">등록 및 잠금 서비스는 모두 원자 적입니다. 이러한 조치와 관련된 모든 노드는 동일한 정보보기를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a1ccfade4aa63d420f2f18a1184490432f9a36ed" translate="yes" xml:space="preserve">
          <source>Both these tools use the message package (time_test.msgs) provided with the tool(s), although it can run on any message package as long as it has the same structure.</source>
          <target state="translated">이 두 도구는 도구와 함께 제공된 메시지 패키지 (time_test.msgs)를 사용하지만 구조가 동일한 한 모든 메시지 패키지에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ccbfe9c0e689e8b9dc53b4b4ec4a1a3a8c73326" translate="yes" xml:space="preserve">
          <source>Both transport security at connection establishment and negotiated via an Inband-Security AVP are supported.</source>
          <target state="translated">연결 설정시 전송 보안과 인 밴드 보안 AVP를 통해 협상 된 전송 보안이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0c0eaabc27903558b46afc5c85515d4a1d0fc689" translate="yes" xml:space="preserve">
          <source>Bound on the expected size of incoming Diameter messages. Messages larger than the specified number of bytes are discarded.</source>
          <target state="translated">들어오는 직경 메시지의 예상 크기에 바인딩됩니다. 지정된 바이트 수보다 큰 메시지는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="0021328dee4879f40d348f1597841de3b466cc17" translate="yes" xml:space="preserve">
          <source>Bound parts (Erlang terms)</source>
          <target state="translated">바운드 부품 (Erlang 용어)</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="acd5609c99b4261f4b2a9f0f2cd2cd2a63fc35c8" translate="yes" xml:space="preserve">
          <source>Branches off an existing association &lt;code&gt;Assoc&lt;/code&gt; in a socket &lt;code&gt;Socket&lt;/code&gt; of type &lt;code&gt;seqpacket&lt;/code&gt; (one-to-many style) into a new socket &lt;code&gt;NewSocket&lt;/code&gt; of type &lt;code&gt;stream&lt;/code&gt; (one-to-one style).</source>
          <target state="translated">&lt;code&gt;seqpacket&lt;/code&gt; 유형 의 소켓 &lt;code&gt;Socket&lt;/code&gt; (일대 다 스타일) 에서 기존 연관 &lt;code&gt;Assoc&lt;/code&gt; 을 분기하여 &lt;code&gt;stream&lt;/code&gt; 유형 (일대일 스타일)의 새 소켓 &lt;code&gt;NewSocket&lt;/code&gt; 으로 분기 합니다.</target>
        </trans-unit>
        <trans-unit id="7fb13ed24388f546ddc4203cc04ff019ad463378" translate="yes" xml:space="preserve">
          <source>Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths:</source>
          <target state="translated">다른 길이의 문자열과 일치하는 분기는 lookbehind 어설 션의 최상위 수준에서만 허용됩니다. 이것은 모든 분기가 동일한 길이의 문자열과 일치 해야하는 Perl과 비교되는 확장입니다. 단일 최상위 분기가 두 개의 다른 길이와 일치 할 수 있으므로 다음과 같은 어설 션은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5a0f50acb3dd75574af8408fef3b88b8ceb46b5" translate="yes" xml:space="preserve">
          <source>Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs.</source>
          <target state="translated">이러한 방식으로 장기 실행 기능을 분리하면 VM이 NIF 호출 간 제어권을 다시 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bdcc7199154fffd9f8d9a9848283a3809fc361e" translate="yes" xml:space="preserve">
          <source>Breakpoints are created and deleted using the &lt;strong&gt;Break&lt;/strong&gt; menu of either the Monitor window, View Module window, or Attach Process window.</source>
          <target state="translated">중단 점은 모니터 창, 모듈보기 창 또는 프로세스 연결 창의 &lt;strong&gt;중단&lt;/strong&gt; 메뉴를 사용하여 작성 및 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a8d8f460f3a399bfb04e89862d06e9b316c1004" translate="yes" xml:space="preserve">
          <source>Breakpoints are marked with a stop symbol.</source>
          <target state="translated">중단 점에는 정지 기호가 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fac70209382c8083fb51c23797738064b31d35" translate="yes" xml:space="preserve">
          <source>Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches a breakpoint, it stops. This means that a breakpoint must be set at an executable line, that is, a code line containing an executable expression.</source>
          <target state="translated">중단 점은 라인 단위로 지정됩니다. 해석 된 모듈에서 코드를 실행하는 프로세스가 중단 점에 도달하면 중지됩니다. 즉, 실행 가능 행, 즉 실행 가능 표현식을 포함하는 코드 행에 중단 점이 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fbbe2bd05741e651732db1439c4df7101add2a7e" translate="yes" xml:space="preserve">
          <source>Briefly on Solaris 10</source>
          <target state="translated">Solaris 10에 대한 간략한 설명</target>
        </trans-unit>
        <trans-unit id="2c54c32cef81a294e27f0b55c17e9d3989656be7" translate="yes" xml:space="preserve">
          <source>Broadcasts on a condition variable. That is, if other threads are waiting on the condition variable being broadcast on, &lt;strong&gt;all&lt;/strong&gt; of them are woken.</source>
          <target state="translated">조건 변수로 브로드 캐스트합니다. 다른 스레드에 조건 변수의 존재 방송에서 대기하는 경우 즉, &lt;strong&gt;모든&lt;/strong&gt; 이들의이 깨어있다.</target>
        </trans-unit>
        <trans-unit id="298841afbb7ef24f7711e916938def078c174299" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; asynchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">지정된 노드 의 등록 된 프로세스 &lt;code&gt;Name&lt;/code&gt; 으로 메시지 &lt;code&gt;Msg&lt;/code&gt; 를 비동기 적으로 브로드 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="0e9067bfac6a20153ac4defbe476694c9b168a4a" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; synchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">메시지 &lt;code&gt;Msg&lt;/code&gt; 를 지정된 노드 의 등록 된 프로세스 &lt;code&gt;Name&lt;/code&gt; 으로 동 기적으로 브로드 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="e87af70cba1f1e451d37824609594b2a73b9bafc" translate="yes" xml:space="preserve">
          <source>Browse the application configuration file (do &lt;strong&gt;not&lt;/strong&gt; edit it). The full name of the application configuration file is derived from the position of the &lt;code&gt;os_mon&lt;/code&gt; application in the file system by adding &lt;code&gt;/ebin/os_mon.app&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 구성 파일을 찾아보십시오 ( 편집 하지 &lt;strong&gt;마십시오&lt;/strong&gt; ). 애플리케이션 구성 파일의 이름이 위치에서 파생 &lt;code&gt;os_mon&lt;/code&gt; 에 추가하여 파일 시스템의 어플리케이션 &lt;code&gt;/ebin/os_mon.app&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8d698cd7b5307da0633f70f00f726e5dbe00ea1a" translate="yes" xml:space="preserve">
          <source>Browses table &lt;code&gt;Tab&lt;/code&gt; on a terminal.</source>
          <target state="translated">터미널에서 테이블 &lt;code&gt;Tab&lt;/code&gt; 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="f47b617427a681f5cc68845744e7adc91ae07ed8" translate="yes" xml:space="preserve">
          <source>Browsing the html pages by loading the page &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; or &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; if the prefix option has been used.</source>
          <target state="translated">접두어 옵션이 사용 된 경우 &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; 페이지를로드하여 html 페이지 찾아보기</target>
        </trans-unit>
        <trans-unit id="792fdd1cd5fd403216843c6560d9bf75c37a3a2e" translate="yes" xml:space="preserve">
          <source>Buf is initialized to contain object attributes.</source>
          <target state="translated">Buf는 객체 속성을 포함하도록 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="3caca7ca1e839168f274364c9d0c4a80119c3d3a" translate="yes" xml:space="preserve">
          <source>Buffer is too small.</source>
          <target state="translated">버퍼가 너무 작습니다.</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="5e39e7697b21824bcc7130368908ca3db3109308" translate="yes" xml:space="preserve">
          <source>Build Erlang/OTP</source>
          <target state="translated">Erlang / OTP 구축</target>
        </trans-unit>
        <trans-unit id="da71556c2060cac2828b51ce118c10a5f1cb07b2" translate="yes" xml:space="preserve">
          <source>Build Issues</source>
          <target state="translated">빌드 문제</target>
        </trans-unit>
        <trans-unit id="82de423db4cc623ec5f04ba52bfec4b055f722a1" translate="yes" xml:space="preserve">
          <source>Build or install the FIPS Object Module and a FIPS enabled OpenSSL library.</source>
          <target state="translated">FIPS 오브젝트 모듈 및 FIPS 사용 OpenSSL 라이브러리를 빌드하거나 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="0ca44d234eb0f2b9b591c5ee4decd555e8ce199c" translate="yes" xml:space="preserve">
          <source>Build the Erlang/OTP release.</source>
          <target state="translated">Erlang / OTP 릴리스를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="07f491f3b5c090f34f2ee3e97cafbb3c5f5f8099" translate="yes" xml:space="preserve">
          <source>Build the boot script.</source>
          <target state="translated">부팅 스크립트를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="77d5d2f2a5f4a3ffbde6ae0d3e363ac721059f26" translate="yes" xml:space="preserve">
          <source>Build the documentation.</source>
          <target state="translated">설명서를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="55d9080383317c03f360d21bbd25b0561e946784" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. Note that &lt;code&gt;otp_build configure&lt;/code&gt; will produce a default configuration that differs from what &lt;code&gt;configure&lt;/code&gt; will produce by default. For example, currently &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; is added to the &lt;code&gt;configure&lt;/code&gt; command line arguments unless &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; has been explicitly passed. The binary releases that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;. The defaults used by &lt;code&gt;otp_build configure&lt;/code&gt; may change at any time without prior notice.</source>
          <target state="translated">건물 얼랑 / OTP는 사용하여 중 하나를 수행 할 수 있습니다 &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; , 스크립트 또는 호출하여 &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; 하고 &lt;code&gt;make&lt;/code&gt; 직접. &lt;code&gt;otp_build&lt;/code&gt; 를 사용 하면 보다 적은 단계를 수행 할 수 있으므로 구축 이 쉬워 지지만 &lt;code&gt;otp_build&lt;/code&gt; 구축 절차는 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 구축 절차 만큼 유연하지 않습니다 . 참고 것을 &lt;code&gt;otp_build configure&lt;/code&gt; 기본 구성을 생성 할 것이다 것과 다릅니다 &lt;code&gt;configure&lt;/code&gt; 기본적으로 생성합니다. 예를 들어, 현재 &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; 가 &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; 가 아니면 &lt;code&gt;configure&lt;/code&gt; 명령 줄 인수에 추가됩니다.명시 적으로 전달되었습니다. 우리가 제공하는 바이너리 릴리스는 &lt;code&gt;otp_build&lt;/code&gt; 를 사용하여 빌드 됩니다. &lt;code&gt;otp_build configure&lt;/code&gt; 사용되는 기본값 은 사전 통지없이 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0288be29544ae6b8e621446c1d716ba731ebd705" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. The binary releases for Windows that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;.</source>
          <target state="translated">건물 얼랑 / OTP는 사용하여 중 하나를 수행 할 수 있습니다 &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; , 스크립트 또는 호출하여 &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; 하고 &lt;code&gt;make&lt;/code&gt; 직접. &lt;code&gt;otp_build&lt;/code&gt; 를 사용 하면 보다 적은 단계를 수행 할 수 있으므로 구축 이 쉬워 지지만 &lt;code&gt;otp_build&lt;/code&gt; 구축 절차는 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 구축 절차 만큼 유연하지 않습니다 . 우리가 제공하는 Windows 용 바이너리 릴리스는 &lt;code&gt;otp_build&lt;/code&gt; 를 사용하여 빌드 됩니다.</target>
        </trans-unit>
        <trans-unit id="f9a1d72262f0ba28560224e8b5f84f82d3a37931" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP on a relatively fast computer takes approximately 5 minutes. To speed it up, you can utilize parallel make with the &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">비교적 빠른 컴퓨터에서 Erlang / OTP를 구축하는 데 약 5 분이 걸립니다. 속도를 높이려면 &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; 옵션 과 함께 병렬 make를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ef5793998a525a29078ba78dcc6651a8e69241f" translate="yes" xml:space="preserve">
          <source>Building a Bootstrap System</source>
          <target state="translated">부트 스트랩 시스템 구축</target>
        </trans-unit>
        <trans-unit id="6fcd9e84832d8fc06ff9412088752b9ac40d1d27" translate="yes" xml:space="preserve">
          <source>Building in Git</source>
          <target state="translated">힘내 건물</target>
        </trans-unit>
        <trans-unit id="6e610827003738b99e768b26958b3f36694ff33c" translate="yes" xml:space="preserve">
          <source>Building is easiest using the &lt;code&gt;otp_build&lt;/code&gt; script:</source>
          <target state="translated">&lt;code&gt;otp_build&lt;/code&gt; 스크립트를 사용하면 빌드가 가장 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="840f8d32dc79d0e6d7906ca187022ffdcd65d433" translate="yes" xml:space="preserve">
          <source>Building on OS X</source>
          <target state="translated">OS X 기반</target>
        </trans-unit>
        <trans-unit id="0919d6c99c47efcb70329ed0ebdeb92cd58e964c" translate="yes" xml:space="preserve">
          <source>Building terms and patterns</source>
          <target state="translated">건물 용어 및 패턴</target>
        </trans-unit>
        <trans-unit id="d7b4eea65f50794546e0a9cd2e50530baa9d4e3f" translate="yes" xml:space="preserve">
          <source>Building with wxErlang</source>
          <target state="translated">wxErlang으로 빌드</target>
        </trans-unit>
        <trans-unit id="03d9659d4e51ca391a6e1291a5a6e5195ec7e16f" translate="yes" xml:space="preserve">
          <source>Building with wxWidgets. Download wxWidgets-3.0.3 or higher.</source>
          <target state="translated">wxWidgets로 빌드 wxWidgets-3.0.3 이상을 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="5a48efe1163ff4f604b0e75b0f8069e848d42294" translate="yes" xml:space="preserve">
          <source>Builds a BEAM module (as a binary) from a list of chunks.</source>
          <target state="translated">청크 목록에서 BEAM 모듈 (2 진)을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="04266b7610bbe7204641a5a18f1b641cc5a4ad92" translate="yes" xml:space="preserve">
          <source>Builds an internal structure representing a compilation of a search pattern, later to be used in functions &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;cp()&lt;/code&gt; returned is guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">검색 패턴의 컴파일을 나타내는 내부 구조를 빌드하고 나중에 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt; 함수에 사용됩니다 . 리턴 된 &lt;code&gt;cp()&lt;/code&gt; 는 프로그램이 사전 컴파일되지 않은 검색 패턴과 구별 할 수 있도록 하는 &lt;code&gt;tuple()&lt;/code&gt; 임을 보증합니다 .</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="3685c8c87d2a5725cbc54a94228a1a89d1d88a57" translate="yes" xml:space="preserve">
          <source>Built-in term storage.</source>
          <target state="translated">내장 용어 저장</target>
        </trans-unit>
        <trans-unit id="5849712291c78b1a99987a87b4b4819b9538fc4d" translate="yes" xml:space="preserve">
          <source>But if a constant is sent to another process (or stored in an Ets table), it is &lt;strong&gt;copied&lt;/strong&gt;. The reason is that the runtime system must be able to keep track of all references to constants to unload code containing constants properly. (When the code is unloaded, the constants are copied to the heap of the processes that refer to them.) The copying of constants might be eliminated in a future Erlang/OTP release.</source>
          <target state="translated">그러나 상수가 다른 프로세스로 전송되거나 Ets 테이블에 저장되면 &lt;strong&gt;복사&lt;/strong&gt; 됩니다. 그 이유는 런타임 시스템이 상수를 포함하는 코드를 올바르게 언로드하기 위해 상수에 대한 모든 참조를 추적 할 수 있어야하기 때문입니다. (코드가 언로드되면 상수는이를 참조하는 프로세스의 힙에 복사됩니다.) 상수 복사는 향후 Erlang / OTP 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12383ec381d6eef21e12692f3a3beac567f979cb" translate="yes" xml:space="preserve">
          <source>But in more complicated code, how can one know whether the optimization is applied or not?</source>
          <target state="translated">그러나 더 복잡한 코드에서 최적화 적용 여부를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="13e80088d58b6e2e78ae703a190df34ce17a3ab1" translate="yes" xml:space="preserve">
          <source>But it will generate code that builds a sub binary in the first clause:</source>
          <target state="translated">그러나 첫 번째 절에서 하위 바이너리를 작성하는 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a0a27a5b2ec989d8d33e3ef99ff2c029f3ccadb0" translate="yes" xml:space="preserve">
          <source>But that is history. Funs was given its own data type in R6B and was further optimized in R7B. Now the cost for a fun call falls roughly between the cost for a call to a local function and &lt;code&gt;apply/3&lt;/code&gt;.</source>
          <target state="translated">그러나 그것은 역사입니다. R6B에서는 Funs에 자체 데이터 유형이 주어졌으며 R7B에서 더욱 최적화되었습니다. 이제 재미있는 통화 비용은 대략 지역 함수 호출 비용과 &lt;code&gt;apply/3&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9edeffd1c02cedcbcf042627c2b5c0c907cde008" translate="yes" xml:space="preserve">
          <source>But this fails as Fred has already logged off.</source>
          <target state="translated">그러나 Fred가 이미 로그 오프 했으므로 이는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3c55fef2a765c8d16ab4eacfbd4c2a04ae1406db" translate="yes" xml:space="preserve">
          <source>But this fails:</source>
          <target state="translated">그러나 이것은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae29bf624e4dd4338883041af300ffb73e4829e9" translate="yes" xml:space="preserve">
          <source>But this is not enough. There is also a set of &lt;strong&gt;mandatory&lt;/strong&gt; messages which the network interface entity must be able to receive and be able to send. This is described in chapter &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 이것으로는 충분하지 않습니다. 네트워크 인터페이스 엔티티가 수신하고 보낼 수 있어야하는 &lt;strong&gt;필수&lt;/strong&gt; 메시지 세트도 있습니다. 이것은 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt; 장에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45778b54cb8ef168c982efffe69e2d8b502fce93" translate="yes" xml:space="preserve">
          <source>But using &lt;code&gt;++&lt;/code&gt; as follows is not bad:</source>
          <target state="translated">그러나 다음과 같이 &lt;code&gt;++&lt;/code&gt; 를 사용하는 것은 나쁘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="521274df22007097293748284fe185141e772a3c" translate="yes" xml:space="preserve">
          <source>But you realize that it is unnecessary to have the Erlang compiler in this one:</source>
          <target state="translated">그러나 당신은 이것에 Erlang 컴파일러를 가질 필요가 없다는 것을 알고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="94852e93461c3ce16031709d1ba53f77338d1422" translate="yes" xml:space="preserve">
          <source>But, if we nevertheless &lt;strong&gt;do&lt;/strong&gt; dig down we find the call to the linked in driver that does the file operations towards the host operating system:</source>
          <target state="translated">그러나, 우리는 그럼에도 불구하고 있다면 &lt;strong&gt;어떻게&lt;/strong&gt; 우리가 호출을 찾을 수 아래로 발굴 호스트 운영 시스템으로 파일 작업을 수행 드라이버에 연결 :</target>
        </trans-unit>
        <trans-unit id="aaa9717eecd88e22102280721e33d90c4f0a390a" translate="yes" xml:space="preserve">
          <source>By &lt;strong&gt;attaching to&lt;/strong&gt; a process executing interpreted code, it is possible to examine variable bindings and order stepwise execution. This is done by sending and receiving information to/from the process through a third process, called the meta process. You can implement your own attached process. See &lt;code&gt;int.erl&lt;/code&gt; for available functions and &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; for possible messages.</source>
          <target state="translated">해석 된 코드를 실행하는 프로세스에 &lt;strong&gt;연결&lt;/strong&gt; 함으로써 변수 바인딩을 검사하고 단계별 실행을 수행 할 수 있습니다. 이는 메타 프로세스라고하는 세 번째 프로세스를 통해 프로세스와 정보를주고 받음으로써 수행됩니다. 자체 첨부 프로세스를 구현할 수 있습니다. 참조 &lt;code&gt;int.erl&lt;/code&gt; 가능한 기능에 대한 &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; 가능한 메시지.</target>
        </trans-unit>
        <trans-unit id="5e25689214717ab6f387eff1ce87fefe79882799" translate="yes" xml:space="preserve">
          <source>By SASL reports we mean supervisor reports, crash reports and progress reports.</source>
          <target state="translated">SASL 보고서는 감독자 보고서, 충돌 보고서 및 진행률 보고서를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61329f5b77a1e8f4de56300ae6baa6480eff0a5f" translate="yes" xml:space="preserve">
          <source>By calling &lt;code&gt;blend/2&lt;/code&gt; on any color term created by &lt;code&gt;new/4&lt;/code&gt;, the resulting color can be calculated as determined by the two map terms.</source>
          <target state="translated">&lt;code&gt;new/4&lt;/code&gt; 로 만든 모든 색상 용어에 대해 &lt;code&gt;blend/2&lt;/code&gt; 를 호출 하면 두 가지지도 용어에 따라 결정된 색상이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="6e21b8bafe38feea973da163115371fd334e57e8" translate="yes" xml:space="preserve">
          <source>By calling function &lt;code&gt;info/0&lt;/code&gt; in a generated module, you get information about which compiler options were used.</source>
          <target state="translated">생성 된 모듈에서 &lt;code&gt;info/0&lt;/code&gt; 함수를 호출 하면 사용 된 컴파일러 옵션에 대한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="817528d15c927d91ed8c4901f6bd96f0b70a6a47" translate="yes" xml:space="preserve">
          <source>By clicking the name in the column header of any table (for example, &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;, and so on), the table rows are sorted in whatever order makes sense for the type of value (for example, numerical for &quot;Ok&quot; or &quot;Time&quot;, and alphabetical for &quot;Case&quot;). The sorting is performed through JavaScript code, automatically inserted into the HTML log files. &lt;code&gt;Common Test&lt;/code&gt; uses the &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; library and the &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; plugin, with customized sorting functions, for this implementation.</source>
          <target state="translated">테이블의 열 머리글에서 이름을 클릭하면 (예 : &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;등) 테이블 행은 값 유형에 맞는 순서대로 정렬됩니다 (예 : , &quot;Ok&quot;또는 &quot;Time&quot;은 숫자이고 &quot;Case&quot;는 알파벳순으로 표시됩니다. 정렬은 JavaScript 코드를 통해 수행되며 HTML 로그 파일에 자동으로 삽입됩니다. &lt;code&gt;Common Test&lt;/code&gt; 는 이 구현을 위해 &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; 라이브러리 및 &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; 플러그인을 사용자 정의 정렬 기능과 함께 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3e3f09bd43c71064511228990649461289b5c148" translate="yes" xml:space="preserve">
          <source>By configuration, you can also modify or disable the default handler, replace it by a custom handler, and install additional handlers.</source>
          <target state="translated">구성에 따라 기본 핸들러를 수정하거나 사용하지 않고 사용자 정의 핸들러로 바꾸고 추가 핸들러를 설치할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="65dc91babe6148c48d235004a31fddc4c1120398" translate="yes" xml:space="preserve">
          <source>By convention, most Built-In Functions (BIFs) are included in this module. Some of the BIFs are viewed more or less as part of the Erlang programming language and are &lt;strong&gt;auto-imported&lt;/strong&gt;. Thus, it is not necessary to specify the module name. For example, the calls &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; and &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; are identical.</source>
          <target state="translated">일반적으로 대부분의 내장 함수 (BIF)가이 모듈에 포함되어 있습니다. 일부 BIF는 Erlang 프로그래밍 언어의 일부로 보이거나 적게 보이며 &lt;strong&gt;자동으로 가져&lt;/strong&gt; 옵니다 . 따라서 모듈 이름을 지정할 필요가 없습니다. 예를 들어, &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; 및 &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; 호출 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="082c66d79fe52cb570696433b4792152063b55b2" translate="yes" xml:space="preserve">
          <source>By convention, the name of a tar file is to end in &quot;&lt;code&gt;.tar&lt;/code&gt;&quot;. To abide to the convention, add &quot;&lt;code&gt;.tar&lt;/code&gt;&quot; to the name.</source>
          <target state="translated">일반적으로 tar 파일의 이름은 &quot; &lt;code&gt;.tar&lt;/code&gt; &quot; 로 끝나야 합니다. 컨벤션을 준수하려면 이름에 &quot; &lt;code&gt;.tar&lt;/code&gt; &quot;를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e51e93220df3f4bd5dc8a32795232ab13e7f0c15" translate="yes" xml:space="preserve">
          <source>By convention, the name of a zip file is to end with &lt;code&gt;.zip&lt;/code&gt;. To abide to the convention, add &lt;code&gt;.zip&lt;/code&gt; to the filename.</source>
          <target state="translated">일반적으로 zip 파일의 이름은 &lt;code&gt;.zip&lt;/code&gt; 으로 끝나야 합니다. 규칙을 준수하려면 파일 이름 에 &lt;code&gt;.zip&lt;/code&gt; 을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="458ef8621b4f7c4ee2bf42d5b9e1f263171a21fb" translate="yes" xml:space="preserve">
          <source>By default 16 files are merged at a time. This option is rarely needed.</source>
          <target state="translated">기본적으로 한 번에 16 개의 파일이 병합됩니다. 이 옵션은 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f916c5ec73659e63b033b011cdae7b63d48ef9e3" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 100 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;Mnesia&lt;/code&gt; 는 100 개의 레코드가 로그에 작성되거나 3 분이 지날 때마다 로그를 덤프합니다. 이것은 두 개의 애플리케이션 매개 변수 &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; 및 &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt; 에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="e33f74e5fe8c2a189ae75982a8ae0619e585aa16" translate="yes" xml:space="preserve">
          <source>By default SSL/TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="translated">기본적으로 SSL / TLS는 커널 의 &lt;code&gt;gen_tcp&lt;/code&gt; 모듈 과 동일한 API (Application Programming Interface)를 사용하여 신뢰할 수있는 다른 전송 프로토콜을 연결할 수 있지만 TCP / IP 프로토콜을 통해 실행 됩니다. DTLS는 기본적으로 UDP / IP를 통해 실행되므로 응용 프로그램 데이터에 전달 보증이 없습니다. SCTP와 같은 다른 전송은 향후 릴리스에서 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b91f316a10114e643a738ef56cbce119a92d15" translate="yes" xml:space="preserve">
          <source>By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed.</source>
          <target state="translated">기본적으로 파일에서 읽은 약 512 * 1024 바이트는 내부적으로 정렬됩니다. 이 옵션은 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e8fa96214b81833eb829752ba3cb11f2aac75f4" translate="yes" xml:space="preserve">
          <source>By default in OTP 17, the representation of the &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; types as Erlang terms were changed. &lt;code&gt;BIT STRING&lt;/code&gt; values are now Erlang bit strings and &lt;code&gt;OCTET STRING&lt;/code&gt; values are binaries. Also, an undecoded open type is now wrapped in an &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; tuple. For details, see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">OTP 17에서는 기본적 으로 Erlang 용어로 &lt;code&gt;BIT STRING&lt;/code&gt; 및 &lt;code&gt;OCTET STRING&lt;/code&gt; 유형의 표현이 변경되었습니다. &lt;code&gt;BIT STRING&lt;/code&gt; 값은 이제 Erlang 비트 문자열이고 &lt;code&gt;OCTET STRING&lt;/code&gt; 값은 이진입니다. 또한, 디코딩되지 않은 개방형은 이제 &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; 튜플에 싸여 있습니다. 자세한 내용은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9dc86d1dada42ddb164640d0be1c9cd268646f6a" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be.</source>
          <target state="translated">기본적으로이 옵션은 포함되어 있지 않지만이 옵션이 있으면 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c97804b0eee285b037a2d076e7ba516d0e16e389" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be. The reference text will be placed in the allocList field of the mib-entry record (#me{}) for the table.</source>
          <target state="translated">기본적으로이 옵션은 포함되어 있지 않지만이 옵션이 있으면 포함됩니다. 참조 텍스트는 테이블에 대한 mib-entry 레코드 (#me {})의 allocList 필드에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="a4cb7bdb00bc5f4f34ca644e957ab5ac212ab81d" translate="yes" xml:space="preserve">
          <source>By default on such systems, Erlang starts in &lt;code&gt;utf8&lt;/code&gt; filename mode if the terminal supports UTF-8, otherwise in &lt;code&gt;latin1&lt;/code&gt; mode.</source>
          <target state="translated">이러한 시스템에서 기본적으로 Erlang은 터미널이 UTF-8을 지원하는 경우 &lt;code&gt;utf8&lt;/code&gt; 파일 이름 모드 에서 시작하고 , 그렇지 않으면 &lt;code&gt;latin1&lt;/code&gt; 모드 에서 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="66001038963df69c701cdea04de30818e23ced2f" translate="yes" xml:space="preserve">
          <source>By default only the running target is available, unless the server includes &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; in its list of capabilities.</source>
          <target state="translated">서버 가 기능 목록에 &lt;code&gt;:candidate&lt;/code&gt; 또는 &lt;code&gt;:startup&lt;/code&gt; 을 포함하지 않는 한 기본적으로 실행중인 대상 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f41b809750734c802dac0f55be66baad734531" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Application inclusion policy&lt;/code&gt; on system level is used for all applications. Set the value to &lt;code&gt;include&lt;/code&gt; if you want to explicitly include one particular application. Set it to &lt;code&gt;exclude&lt;/code&gt; if you want to exclude the application despite that it is used by another (explicitly or implicitly) included application. &lt;code&gt;derived&lt;/code&gt; means that the application automatically will be included if some other (explicitly or implicitly) included application uses it.</source>
          <target state="translated">기본적 으로 시스템 수준 의 &lt;code&gt;Application inclusion policy&lt;/code&gt; 은 모든 응용 프로그램에 사용됩니다. 하나의 특정 애플리케이션을 명시 적으로 포함 하려면 &lt;code&gt;include&lt;/code&gt; 할 값을 설정하십시오 . 포함 된 다른 응용 프로그램 (명시 적 또는 암시 적)에 의해 사용됨에도 불구하고 응용 프로그램을 제외 시키려면 &lt;code&gt;exclude&lt;/code&gt; 설정하십시오 . &lt;code&gt;derived&lt;/code&gt; 은 포함 된 일부 다른 응용 프로그램에서 응용 프로그램을 사용하는 경우 응용 프로그램이 자동으로 포함됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3bb33b9d4c2d5314003279505372f2bd591c4469" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Module inclusion policy&lt;/code&gt; on system level is used for all applications. Set it to &lt;code&gt;derived&lt;/code&gt; if you only want actually used modules to be included. Set it to &lt;code&gt;app&lt;/code&gt; if you, besides derived modules, also want the modules listed in the app file to be included. Set it to &lt;code&gt;ebin&lt;/code&gt; if you, besides derived modules, also want the modules that exist as beam files in the ebin directory to be included. Set it to &lt;code&gt;all&lt;/code&gt; if you want all modules to be included, that is the union of modules found in the ebin directory and listed in the app file.</source>
          <target state="translated">기본적 으로 시스템 수준 의 &lt;code&gt;Module inclusion policy&lt;/code&gt; 은 모든 응용 프로그램에 사용됩니다. 실제로 사용한 모듈 만 포함 하려면 &lt;code&gt;derived&lt;/code&gt; 설정하십시오 . 로 설정하여 &lt;code&gt;app&lt;/code&gt; 이, 파생 모듈 외에, 또한 응용 프로그램 파일에 나열된 모듈이 포함되어야합니다. 파생 된 모듈 외에 ebin 디렉토리에 빔 파일로 존재하는 모듈도 포함 시키려면이 를 &lt;code&gt;ebin&lt;/code&gt; 으로 설정하십시오 . 모든 모듈을 포함하려면 ebin 디렉토리에 있고 앱 파일에 나열된 모듈의 조합 인 모듈 을 &lt;code&gt;all&lt;/code&gt; 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="81c493b42c1c2d3836dadd1b1f65d1b4066bbbb2" translate="yes" xml:space="preserve">
          <source>By default the EPMD listens on port 4369.</source>
          <target state="translated">기본적으로 EPMD는 포트 4369에서 수신 대기합니다.</target>
        </trans-unit>
        <trans-unit id="60c9fed0b81fb4b980269d86433bdb1dec183e3e" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it.</source>
          <target state="translated">기본적으로 TLS / DTLS 클라이언트는 사용 가능한 세션을 재사용하려고 시도하고 기본적으로 TLS / DTLS 서버는 클라이언트가 요청할 때 세션을 재사용하기로 동의합니다.</target>
        </trans-unit>
        <trans-unit id="40a1d269c0b2f20066064de554ea4fe767edbe1b" translate="yes" xml:space="preserve">
          <source>By default the currently stored events (existing) are written to a brand new file (write) and the events are kept (keep) after they have been written to the file.</source>
          <target state="translated">기본적으로 현재 저장된 이벤트 (기존)는 새 파일에 기록되고 (쓰기) 이벤트는 파일에 기록 된 후에 유지됩니다 (유지).</target>
        </trans-unit>
        <trans-unit id="b301155fe91b7f29a76df23651c02320368fef48" translate="yes" xml:space="preserve">
          <source>By default the flex scanner reports line-number of an error. But it can be built without line-number reporting. Instead token number is used. This will speed up the scanning some 5-10%. Use &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; when configuring the application.</source>
          <target state="translated">기본적으로 플렉스 스캐너는 오류의 줄 번호를보고합니다. 그러나 행 번호보고없이 구축 할 수 있습니다. 대신 토큰 번호가 사용됩니다. 스캔 속도가 5-10 % 정도 빨라집니다. 사용 &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; 응용 프로그램을 구성 할 때.</target>
        </trans-unit>
        <trans-unit id="c20eaae0e3f3676678ff09602bb8cee954cea155" translate="yes" xml:space="preserve">
          <source>By default the socket options set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; are used when establishing a connection.</source>
          <target state="translated">기본적으로 &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; 기능으로 설정 한 소켓 옵션 이 연결을 설정할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec72fa4eac79a3cc871f1f0e43828e92af1bb91b" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특정 플랫폼에서 지원되는 경우 시간 수정이 기본적으로 사용됩니다. 여기에는 OS가 제공하는 OS 단조 시간과 OS 단조 시간을 사용하는 Erlang 런타임 시스템의 구현이 모두 포함됩니다. 시스템이 OS 단조 시간을 지원하는지 확인하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; 호출하십시오 . 시스템에서 시간 수정이 활성화되어 있는지 확인하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ceb9ebe7b981aea32343aa2ebada87a65d18c16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; fetches trace logs and trace information files from all nodes. The logs are stored in a new directory named &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; under the working directory of the trace control node. Fetching can be disabled by providing option &lt;code&gt;nofetch&lt;/code&gt; to &lt;code&gt;ttb:stop/1&lt;/code&gt;. The user can specify a fetch directory by passing option &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; 은 모든 노드에서 추적 로그 및 추적 정보 파일을 가져옵니다. 로그는 추적 제어 노드의 작업 디렉토리 아래에 &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; 라는 새 디렉토리에 저장됩니다 . &lt;code&gt;ttb:stop/1&lt;/code&gt; 에 nofetch 옵션을 제공하여 &lt;code&gt;nofetch&lt;/code&gt; 를 비활성화 할 수 있습니다 . 사용자는 &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt; 옵션을 전달하여 페치 디렉토리를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e28d91aead7c4c840b960191290c3223a7f6126a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Char&lt;/code&gt; is &lt;code&gt;$\s&lt;/code&gt; and &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;trailing&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;Char&lt;/code&gt; 는 &lt;code&gt;$\s&lt;/code&gt; 이고 &lt;code&gt;Dir&lt;/code&gt; 은 &lt;code&gt;trailing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="071766231ebcbb0e6dd0a89742db95d7cd2d08e3" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Common Test&lt;/code&gt; creates one central private directory per test run, shared by all test cases. This is not always suitable. Especially if the same test cases are executed multiple times during a test run (that is, if they belong to a test case group with property &lt;code&gt;repeat&lt;/code&gt;) and there is a risk that files in the private directory get overwritten. Under these circumstances, &lt;code&gt;Common Test&lt;/code&gt; can be configured to create one dedicated private directory per test case and execution instead. This is accomplished with the flag/option &lt;code&gt;create_priv_dir&lt;/code&gt; (to be used with the &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program, the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; function, or as test specification term). There are three possible values for this option as follows:</source>
          <target state="translated">기본적으로 &lt;code&gt;Common Test&lt;/code&gt; 는 모든 테스트 케이스가 공유하는 테스트 실행 당 하나의 중앙 개인 디렉토리를 작성합니다. 항상 적합한 것은 아닙니다. 특히 테스트 실행 중 동일한 테스트 케이스가 여러 번 실행되는 경우 (즉, 속성이 &lt;code&gt;repeat&lt;/code&gt; 인 테스트 케이스 그룹에 속하는 경우 ) 개인 디렉토리의 파일을 겹쳐 쓸 위험이 있습니다. 이러한 상황에서 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 케이스 당 하나의 전용 개인 디렉토리를 작성하고 대신 실행하도록 구성 할 수 있습니다. 이는 플래그 / 옵션 &lt;code&gt;create_priv_dir&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; 프로그램, &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 과 함께 사용)을 사용하여 수행됩니다 .기능 또는 테스트 사양 용어). 이 옵션에는 다음과 같은 세 가지 가능한 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc3169458b9c52d0cd7a98448830679fb2a8731a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;leading&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;Dir&lt;/code&gt; 이 &lt;code&gt;leading&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="28f74729db7b0c3b278863ef6db06bd5bab6afe7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ERTS&lt;/code&gt; is only guaranteed to be compatible with other Erlang/OTP components from the same release as &lt;code&gt;ERTS&lt;/code&gt; itself.</source>
          <target state="translated">기본적으로 &lt;code&gt;ERTS&lt;/code&gt; 는 &lt;code&gt;ERTS&lt;/code&gt; 자체 와 동일한 릴리스의 다른 Erlang / OTP 구성 요소와 만 호환되도록 보장 됩니다.</target>
        </trans-unit>
        <trans-unit id="4d10644009649e0b88125d8c14d6cdb3379fe167" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Norm&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;IgnoreCase&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 이고 &lt;code&gt;Norm&lt;/code&gt; 은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9d6341953fcce030f785b04ed13be99fb6431b5" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;Length&lt;/code&gt; 는 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="737dbf79ae1fa944f9b53b6e9f296655a6f7aa71" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;relup&lt;/code&gt; file is located in the current working directory. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, the &lt;code&gt;relup&lt;/code&gt; file is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">기본적으로 &lt;code&gt;relup&lt;/code&gt; 파일은 현재 작업 디렉토리에 있습니다. &lt;code&gt;{outdir,Dir}&lt;/code&gt; 옵션 이 지정되면 &lt;code&gt;relup&lt;/code&gt; 파일은 대신 &lt;code&gt;Dir&lt;/code&gt; 에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e5740833bc9a00277b2eef37e4a06e9efa51635" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the &lt;code&gt;proc_lib&lt;/code&gt; module.</source>
          <target state="translated">초기 호출에 대한 정보를 찾을 수 없으면 기본적으로 &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; 가 리턴됩니다. 호출자가 프로세스가 &lt;code&gt;proc_lib&lt;/code&gt; 모듈 로 생성되었음을 알고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1a09da640fbd6b16e4c97f30cbf385b23a15ab05" translate="yes" xml:space="preserve">
          <source>By default, Debugger only saves information about recursive function calls, that is, function calls that have not yet returned a value (option &lt;strong&gt;Stack On, No Tail&lt;/strong&gt;).</source>
          <target state="translated">기본적으로 디버거는 재귀 함수 호출, 즉 아직 값을 반환하지 않은 함수 호출 (옵션 &lt;strong&gt;스택 켜기, 꼬리 없음&lt;/strong&gt; )에 대한 정보 만 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="cb83760fc1df1215ce919183bfc30967f2391d71" translate="yes" xml:space="preserve">
          <source>By default, Dialyzer caches the results of native compilation in directory &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt;. &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; defaults to &lt;code&gt;$HOME/.cache&lt;/code&gt;. Use this option to disable caching.</source>
          <target state="translated">기본적으로 Dialyzer는 &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt; 디렉토리에 기본 컴파일 결과를 캐시합니다 . &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 의 기본값은 &lt;code&gt;$HOME/.cache&lt;/code&gt; .cache 입니다. 캐싱을 비활성화하려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ca501566661fba6186a204103ba54062fe33920b" translate="yes" xml:space="preserve">
          <source>By default, Erlang is started so that only the &lt;code&gt;latin1&lt;/code&gt; range of characters indicate that a list of integers is a string.</source>
          <target state="translated">기본적으로 Erlang은 시작하여 &lt;code&gt;latin1&lt;/code&gt; 문자 범위 만 정수 목록이 문자열임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8a82754162a45a0d73de414ecadee9a7ddca8c1b" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="translated">기본적으로 Erlang은 라틴 -1 범위의 문자 목록 만 문자열로 감지하지만 &lt;code&gt;+pc unicode&lt;/code&gt; 플래그를 사용하여이를 변경할 수 있습니다 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; 참조). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddfb5846cc6e75b4d26cdc33d2870cc55885837f" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 Erlang / OTP 릴리스는 &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; 에 설치 됩니다. 예를 들어 표준 위치에 설치할 수있는 권한이없는 경우 다른 위치에 Erlang / OTP를 설치할 수 있습니다. 예를 들어,에 설치 &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt; , 사용 &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="449ac9961843b5846b7c02a09a67a56c7a856de8" translate="yes" xml:space="preserve">
          <source>By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (&lt;code&gt;^&lt;/code&gt;) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (&lt;code&gt;$&lt;/code&gt;) matches only at the end of the string, or before a terminating newline (unless option &lt;code&gt;dollar_endonly&lt;/code&gt; is specified). This is the same as in Perl.</source>
          <target state="translated">기본적으로 PCRE는 제목 문자열을 한 줄의 문자 (줄 바꿈이 포함되어 있더라도)로 구성된 것으로 취급합니다. &quot;행의 시작&quot;메타 문자 ( &lt;code&gt;^&lt;/code&gt; )는 문자열의 시작에서만 일치하는 반면 &quot;행의 끝&quot;메타 문자 ( &lt;code&gt;$&lt;/code&gt; )는 문자열의 끝에서만 또는 종료 줄 바꾸기 전에 만 일치합니다 ( &lt;code&gt;dollar_endonly&lt;/code&gt; 옵션 이 지정 되지 않은 경우) ). 이것은 Perl과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c5979203f447d5bf52653ed357687aa3ce1b0b5f" translate="yes" xml:space="preserve">
          <source>By default, a breakpoint is active, has trigger action &lt;code&gt;enable&lt;/code&gt;, and has no associated condition. For details about breakpoints, see the User's Guide.</source>
          <target state="translated">기본적으로 중단 점은 활성 상태이며 트리거 조치 &lt;code&gt;enable&lt;/code&gt; 이 있으며 연관된 조건이 없습니다. 중단 점에 대한 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce5b679d831561af8a791cf34b427a861410973" translate="yes" xml:space="preserve">
          <source>By default, a name must be unique within a pattern, but this constraint can be relaxed by setting option &lt;code&gt;dupnames&lt;/code&gt; at compile time. (Duplicate names are also always permitted for subpatterns with the same number, set up as described in the previous section.) Duplicate names can be useful for patterns where only one instance of the named parentheses can match. Suppose that you want to match the name of a weekday, either as a 3-letter abbreviation or as the full name, and in both cases you want to extract the abbreviation. The following pattern (ignoring the line breaks) does the job:</source>
          <target state="translated">기본적으로 이름은 패턴 내에서 고유해야하지만 컴파일시 옵션 &lt;code&gt;dupnames&lt;/code&gt; 를 설정하여이 제한 조건을 완화 할 수 있습니다 . (이전 섹션에서 설명한대로 설정 한 동일한 번호의 하위 패턴에는 중복 이름도 항상 허용됩니다.) 중복 이름은 명명 된 괄호의 한 인스턴스 만 일치 할 수있는 패턴에 유용 할 수 있습니다. 요일 이름을 3 자 약어로 또는 전체 이름으로 일치시키고 두 경우 모두 약어를 추출한다고 가정합니다. 다음 패턴 (줄 바꿈 무시)이 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c874b6a01a35c20ad7535dd46729e15bd7a18206" translate="yes" xml:space="preserve">
          <source>By default, after \x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \x{ and }. If a character other than a hexadecimal digit appears between \x{ and }, or if there is no terminating }, an error occurs.</source>
          <target state="translated">기본적으로 \ x 다음에 {가 나오지 않으면 0에서 2 개의 16 진 숫자를 읽습니다 (문자는 대문자 또는 소문자 일 수 있음). \ x {와} 사이에는 16 진수가 제한없이 나타날 수 있습니다. \ x {와} 사이에 16 진수 이외의 문자가 나타나거나 종료}가 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1911d23f55521707a73b458b73f12a15fc75306a" translate="yes" xml:space="preserve">
          <source>By default, all I/O devices in OTP are set in &lt;code&gt;list&lt;/code&gt; mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers.</source>
          <target state="translated">기본적으로 OTP의 모든 I / O 장치는 &lt;code&gt;list&lt;/code&gt; 모드 로 설정 됩니다. 그러나 I / O 기능은 이러한 모드 중 하나를 처리 할 수 ​​있으므로 I / O 서버에 대한 클라이언트 역할을하는 다른 사용자 작성 모듈도 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b2f7942ad86f7d74769554cdd60a7505d483c06" translate="yes" xml:space="preserve">
          <source>By default, all NETCONF traffic is logged in one single log file. However, different connections can be logged in separate files. To do this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work, that is, they must be opened with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본적으로 모든 NETCONF 트래픽은 하나의 단일 로그 파일에 기록됩니다. 그러나 다른 연결은 별도의 파일에 기록 될 수 있습니다. 이렇게하려면 후크 옵션 &lt;code&gt;hosts&lt;/code&gt; 를 사용하고 제품군에 사용될 서버 / 연결 이름을 나열하십시오. 이것이 작동하려면 연결 이름을 지정해야합니다. 즉, &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 로 열어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="d82598d7e978ba992edaa523f47e7a8ba20e371c" translate="yes" xml:space="preserve">
          <source>By default, all applications are loaded with permission &lt;code&gt;true&lt;/code&gt; on all nodes. The permission can be configured using the Kernel configuration parameter &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">기본적으로 모든 응용 프로그램은 모든 노드에서 &lt;code&gt;true&lt;/code&gt; 권한으로로드 됩니다. 커널 구성 매개 변수 &lt;code&gt;permissions&lt;/code&gt; 를 사용하여 권한을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97ad4d1175f0f089a0071483175aa615b421ee54" translate="yes" xml:space="preserve">
          <source>By default, all existing files with the same name as files in the tar file are overwritten. With this option, existing files are not overwriten.</source>
          <target state="translated">기본적으로 tar 파일의 파일과 이름이 같은 모든 기존 파일을 덮어 씁니다. 이 옵션을 사용하면 기존 파일을 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e40750937dae4fae3bc5f70b97a3f2528fbb80b" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the tar file. With this option, only those files are extracted whose names are included in &lt;code&gt;FileList&lt;/code&gt;.</source>
          <target state="translated">기본적으로 모든 파일은 tar 파일에서 추출됩니다. 이 옵션을 사용하면 이름이 &lt;code&gt;FileList&lt;/code&gt; 에 포함 된 파일 만 추출 됩니다.</target>
        </trans-unit>
        <trans-unit id="88e8684fe917ca09c774ce03048bec7c20dc7976" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the zip archive. With option &lt;code&gt;{file_list, FileList}&lt;/code&gt;, function &lt;code&gt;unzip/2&lt;/code&gt; only extracts the files whose names are included in &lt;code&gt;FileList&lt;/code&gt;. The full paths, including the names of all subdirectories within the zip archive, must be specified.</source>
          <target state="translated">기본적으로 모든 파일은 zip 아카이브에서 추출됩니다. &lt;code&gt;{file_list, FileList}&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;unzip/2&lt;/code&gt; 함수 는 이름이 &lt;code&gt;FileList&lt;/code&gt; 에 포함 된 파일 만 추출합니다 . zip 아카이브 내의 모든 서브 디렉토리 이름을 포함한 전체 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8373c854a1dcafc057dbfa5df0f447eef64bc1ef" translate="yes" xml:space="preserve">
          <source>By default, all files with the same name as files in the zip archive are overwritten. With option &lt;code&gt;keep_old_files&lt;/code&gt; set, function &lt;code&gt;unzip/2&lt;/code&gt; does not overwrite existing files. Notice that even with option &lt;code&gt;memory&lt;/code&gt; specified, which means that no files are overwritten, existing files are excluded from the result.</source>
          <target state="translated">기본적으로 zip 아카이브의 파일과 이름이 같은 모든 파일을 덮어 씁니다. &lt;code&gt;keep_old_files&lt;/code&gt; 옵션을 설정하면 &lt;code&gt;unzip/2&lt;/code&gt; 함수 는 기존 파일을 겹쳐 쓰지 않습니다. 옵션 &lt;code&gt;memory&lt;/code&gt; 지정된 경우에도 파일을 덮어 쓰지 않음을 의미하므로 기존 파일은 결과에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="6de29fd7730a88164d057863c9dcf72fa1cb3f6c" translate="yes" xml:space="preserve">
          <source>By default, all log events originating from within OTP, except the former so called &quot;SASL reports&quot;, look the same as before.</source>
          <target state="translated">기본적으로 이른바 &quot;SASL 보고서&quot;를 제외한 OTP 내에서 시작된 모든 로그 이벤트는 이전과 동일하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="2882c6abbebff5ea0f043573bc5ce53ddfde39c3" translate="yes" xml:space="preserve">
          <source>By default, all parts of the string, including the empty strings, are returned from the function, for example:</source>
          <target state="translated">기본적으로 빈 문자열을 포함하여 문자열의 모든 부분이 함수에서 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74b4b269097f50b433c9602d13038dfa07527232" translate="yes" xml:space="preserve">
          <source>By default, an &lt;code&gt;OCTET STRING&lt;/code&gt; is always represented as an Erlang binary. If the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;, the encode functions accept both lists and binaries, and the decode functions decode an &lt;code&gt;OCTET STRING&lt;/code&gt; to a list.</source>
          <target state="translated">기본적으로 &lt;code&gt;OCTET STRING&lt;/code&gt; 은 항상 Erlang 바이너리로 표시됩니다. 사양이 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 옵션으로 컴파일 된 경우 인코딩 함수는 목록과 이진을 모두 허용하며 디코딩 함수는 &lt;code&gt;OCTET STRING&lt;/code&gt; 을 목록으로 디코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="0bac80eb92816a5a88bf3b52b9fd2aacd857eeb1" translate="yes" xml:space="preserve">
          <source>By default, autostart information is stored in a file named &lt;code&gt;ttb_autostart.bin&lt;/code&gt; on each node. If this is not desired (for example, on diskless nodes), a custom module handling autostart information storage and retrieval can be provided by specifying environment variable &lt;code&gt;ttb_autostart_module&lt;/code&gt; for the application Runtime_Tools. The module must respond to the following API:</source>
          <target state="translated">기본적으로 자동 시작 정보는 각 노드의 &lt;code&gt;ttb_autostart.bin&lt;/code&gt; 파일에 저장됩니다 . 이것이 필요하지 않은 경우 (예를 들어, 디스크가없는 노드에서) 응용 프로그램 Runtime_Tools에 환경 변수 &lt;code&gt;ttb_autostart_module&lt;/code&gt; 을 지정하여 자동 시작 정보 저장 및 검색을 처리하는 사용자 정의 모듈을 제공 할 수 있습니다 . 모듈은 다음 API에 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad25aa21de1694492059b0bfb35caab2d579e0fb" translate="yes" xml:space="preserve">
          <source>By default, characters with values &amp;gt; 255 do not match any of the Posix character classes. However, if option &lt;code&gt;PCRE_UCP&lt;/code&gt; is passed to &lt;code&gt;pcre_compile()&lt;/code&gt;, some of the classes are changed so that Unicode character properties are used. This is achieved by replacing certain Posix classes by other sequences, as follows:</source>
          <target state="translated">기본적으로 값이 255보다 큰 문자는 Posix 문자 클래스와 일치하지 않습니다. 그러나 &lt;code&gt;PCRE_UCP&lt;/code&gt; 옵션 이 &lt;code&gt;pcre_compile()&lt;/code&gt; 전달 되면 유니 코드 문자 속성이 사용되도록 일부 클래스가 변경됩니다. 이것은 다음과 같이 특정 Posix 클래스를 다른 시퀀스로 대체하여 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="053346f97801947e69ed842b8b3fec738287fe79" translate="yes" xml:space="preserve">
          <source>By default, data for all Telnet connections is logged in one common file (named &lt;code&gt;default&lt;/code&gt;), which can get messy, for example, if multiple Telnet sessions are running in parallel. Therefore a separate log file can be created for each connection. To configure this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work (see &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">기본적으로 모든 Telnet 연결의 데이터는 하나의 공통 파일 ( &lt;code&gt;default&lt;/code&gt; )에 기록되며 , 예를 들어 여러 Telnet 세션이 병렬로 실행되는 경우 혼란 스러울 수 있습니다. 따라서 각 연결마다 별도의 로그 파일을 작성할 수 있습니다. 이를 구성하려면 후크 옵션 &lt;code&gt;hosts&lt;/code&gt; 를 사용하고 제품군에 사용될 서버 / 연결 이름을 나열하십시오. 이것이 작동하려면 연결 이름을 지정해야합니다 ( &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="776bbd51980a39359333108981da5fd37cece1a7" translate="yes" xml:space="preserve">
          <source>By default, each CTH installed is executed in the order that they are installed for init calls, and then reversed for end calls. This is not always desired, so &lt;code&gt;Common Test&lt;/code&gt; allows the user to specify a priority for each hook. The priority can either be specified in the CTH function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; or when installing the hook. The priority specified at installation overrides the priority returned by the CTH.</source>
          <target state="translated">기본적으로 설치된 각 CTH는 초기화 호출에 대해 설치된 순서대로 실행 된 다음 종료 호출에 대해 반대 순서로 실행됩니다. 이것이 항상 바람직한 것은 아니므로 &lt;code&gt;Common Test&lt;/code&gt; 통해 사용자는 각 후크의 우선 순위를 지정할 수 있습니다. 우선 순위는 CTH 기능 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 에서 또는 후크를 설치할 때 지정할 수 있습니다 . 설치시 지정된 우선 순위는 CTH가 리턴 한 우선 순위를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="462e7da9c97e5f027114d96a2306c993c035da8a" translate="yes" xml:space="preserve">
          <source>By default, each installation of a CTH causes a new instance of it to be activated. This can cause problems if you want to override CTHs in test specifications while still having them in the suite information function. The &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; callback exists to address this problem. By returning the same &lt;code&gt;id&lt;/code&gt; in both places, &lt;code&gt;Common Test&lt;/code&gt; knows that this CTH is already installed and does not try to install it again.</source>
          <target state="translated">기본적으로 CTH를 설치할 때마다 CTH의 새 인스턴스가 활성화됩니다. 스위트 정보 기능에 CTH가있는 동안 테스트 스펙에서 CTH를 대체하려는 경우 문제점이 발생할 수 있습니다. &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; 콜백이 문제를 해결하기 위해 존재한다. &lt;code&gt;Common Test&lt;/code&gt; 는 두 위치에서 동일한 &lt;code&gt;id&lt;/code&gt; 를 리턴 하여이 CTH가 이미 설치되어 있음을 알고 다시 설치하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46480571329f9b5765128d1e4d2b38b49550c0a0" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead either returns &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt;, where &lt;code&gt;Relup&lt;/code&gt; is the release upgrade file, or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">기본적으로 오류 및 경고는 tty로 인쇄되며이 함수는 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 를 반환합니다 . 옵션 &lt;code&gt;silent&lt;/code&gt; 가 지정되면 함수는 대신 &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Relup&lt;/code&gt; 은 릴리스 업그레이드 파일이거나 &lt;code&gt;{error,Module,Error}&lt;/code&gt; 입니다. &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; 또는 &lt;code&gt;Module:format_error(Error)&lt;/code&gt; 를 호출하여 경고 및 오류를 문자열로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="294052fb58119cdee244d014d8cb85f8f3d4b24a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">기본적으로 오류 및 경고는 tty로 인쇄되며이 함수는 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 를 반환합니다 . 옵션 &lt;code&gt;silent&lt;/code&gt; 가 지정되면 함수는 대신 &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; 또는 &lt;code&gt;{error,Module,Error}&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; 또는 &lt;code&gt;Module:format_error(Error)&lt;/code&gt; 를 호출하여 경고 및 오류를 문자열로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee3c67a77746a67e2bb8398f5d758b0ceca821c3" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; function opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">기본적으로, 기능 &lt;code&gt;open/2&lt;/code&gt; 기능은 tar 파일을 &lt;code&gt;raw&lt;/code&gt; 모드로 여는 데 빠르지 만 원격 (Erlang) 파일 서버를 사용할 수는 없습니다. &lt;code&gt;cooked&lt;/code&gt; 를 모드 목록에 추가 하면 기본값이 무시되고 &lt;code&gt;raw&lt;/code&gt; 옵션없이 tar 파일이 열립니다 .</target>
        </trans-unit>
        <trans-unit id="c31b08201db8e452376ac550216866c4f0213c87" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">기본적으로, &lt;code&gt;open/2&lt;/code&gt; function 함수 는 tar 파일을 &lt;code&gt;raw&lt;/code&gt; 모드로 여는 데 빠르지 만 원격 (Erlang) 파일 서버를 사용할 수는 없습니다. &lt;code&gt;cooked&lt;/code&gt; 를 모드 목록에 추가 하면 기본값이 무시되고 &lt;code&gt;raw&lt;/code&gt; 옵션없이 tar 파일이 열립니다 .</target>
        </trans-unit>
        <trans-unit id="4c4fa6e3241b3f16b2494ba76c92a8e6751097f9" translate="yes" xml:space="preserve">
          <source>By default, if any requested chunk is missing in &lt;code&gt;Beam&lt;/code&gt;, an &lt;code&gt;error&lt;/code&gt; tuple is returned. However, if option &lt;code&gt;allow_missing_chunks&lt;/code&gt; is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt;. Notice however that if chunk &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; is missing, that is considered a fatal error and the return value is an &lt;code&gt;error&lt;/code&gt; tuple.</source>
          <target state="translated">요청 된 덩어리가에없는 경우 기본적으로, &lt;code&gt;Beam&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; 튜플이 반환됩니다. 그러나 &lt;code&gt;allow_missing_chunks&lt;/code&gt; 옵션을 지정하면 청크가 없어도 결과가 반환됩니다. 결과 목록에서 누락 된 청크는 &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt; 로 표시됩니다 . 그러나 &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; 청크 가 없으면 치명적인 오류로 간주되며 반환 값은 &lt;code&gt;error&lt;/code&gt; 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="6f53b57e48d13ba35bc616bbd211c0e3f61e0177" translate="yes" xml:space="preserve">
          <source>By default, in &lt;code&gt;unicode&lt;/code&gt; mode, characters with values &amp;gt; 255, that is, all characters outside the ISO Latin-1 character set, never match \d, \s, or \w, and always match \D, \S, and \W. These sequences retain their original meanings from before UTF support was available, mainly for efficiency reasons. However, if option &lt;code&gt;ucp&lt;/code&gt; is set, the behavior is changed so that Unicode properties are used to determine character types, as follows:</source>
          <target state="translated">기본적으로 &lt;code&gt;unicode&lt;/code&gt; 모드에서 값이 255보다 큰 문자, 즉 ISO Latin-1 문자 세트를 벗어난 모든 문자는 \ d, \ s 또는 \ w와 일치하지 않으며 항상 \ D, \ S 및 \와 일치합니다. W. 이러한 시퀀스는 주로 효율성상의 이유로 UTF 지원이 제공되기 전의 원래 의미를 유지합니다. 그러나 옵션 &lt;code&gt;ucp&lt;/code&gt; 가 설정되면 다음과 같이 유니 코드 특성이 문자 유형을 판별하는 데 사용되도록 동작이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8dce2b9977241b689bc8a7cc79ba1876582a372f" translate="yes" xml:space="preserve">
          <source>By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option &lt;code&gt;dereference&lt;/code&gt;.</source>
          <target state="translated">기본적으로 기호 링크는 tar 파일에 기호 링크로 저장됩니다. 기본값을 대체하고 기호 링크가 가리키는 파일을 tar 파일로 저장하려면 &lt;code&gt;dereference&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="307631df678df3363024a8553c6845aa25ac4dbc" translate="yes" xml:space="preserve">
          <source>By default, that lock is at the driver level, that is, if several ports have been opened to the same driver, only code for one port at the same time can be running.</source>
          <target state="translated">기본적으로이 잠금은 드라이버 레벨에 있습니다. 즉, 여러 개의 포트가 동일한 드라이버에 열린 경우 한 포트에 대한 코드 만 동시에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59ef4e65d1c06e09a6d712a392cd376d76f7e30c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; libraries are only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리는 라이브러리 자체와 동일한 릴리스의 다른 Erlang / OTP 구성 요소와 만 호환되도록 보장됩니다. 이전 릴리스에서 Erlang / OTP 구성 요소와 통신하는 방법에 대한 정보는 함수 &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de70cb5ed283df211d9a60f565e19a6787b411b0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;Erl_Interface&lt;/code&gt; library itself. For example, &lt;code&gt;Erl_Interface&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">기본적으로 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리는 &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리 자체 와 동일한 릴리스의 다른 Erlang / OTP 구성 요소와 만 호환되도록 보장 됩니다. 예를 들어, Erlang / OTP R10의 &lt;code&gt;Erl_Interface&lt;/code&gt; 는 기본적으로 Erlang / OTP R9의 Erlang 에뮬레이터와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5408a0e73229b9b5e967fe902da2634b16e6868a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;ei&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;ei&lt;/code&gt; library itself. For example, &lt;code&gt;ei&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">기본적으로 &lt;code&gt;ei&lt;/code&gt; 라이브러리는 &lt;code&gt;ei&lt;/code&gt; 라이브러리 자체 와 동일한 릴리스의 다른 Erlang / OTP 구성 요소와 만 호환되도록 보장 됩니다. 예를 들어, Erlang / OTP R10의 &lt;code&gt;ei&lt;/code&gt; 는 기본적으로 Erlang / OTP R9의 Erlang 에뮬레이터와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc7855f5354d795a3773624d2090708d90c447ea" translate="yes" xml:space="preserve">
          <source>By default, the &lt;strong&gt;default user&lt;/strong&gt; is set to the &lt;code&gt;snmpm_user_default&lt;/code&gt; module, which simply sends an info message to the error_logger. It is however highly recommended that this module be replaced by another that does something useful (see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; for more info).</source>
          <target state="translated">기본적으로 &lt;strong&gt;기본 사용자&lt;/strong&gt; 는 &lt;code&gt;snmpm_user_default&lt;/code&gt; 모듈로 설정되어 있으며 단순히 error_logger에 정보 메시지를 보냅니다. 그러나이 모듈을 유용한 다른 모듈로 교체하는 것이 좋습니다 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8754a9737ab7ee6fe2f3b847124e99177bf4ce53" translate="yes" xml:space="preserve">
          <source>By default, the Cover tool is automatically stopped when the tests are completed. This causes the original (non-cover compiled) modules to be loaded back into the test node. If a process at this point still runs old code of any of the modules that are cover compiled, meaning that it has not done any fully qualified function call after the cover compilation, the process is killed. To avoid this, set the value of option &lt;code&gt;cover_stop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. This means that the modules stay cover compiled. Therefore, this is only recommended if the Erlang nodes under test are terminated after the test is completed, or if cover can be manually stopped.</source>
          <target state="translated">기본적으로 테스트가 완료되면 표지 도구가 자동으로 중지됩니다. 이렇게하면 원래 (비 커버 컴파일 된) 모듈이 테스트 노드로 다시로드됩니다. 이 시점에서 프로세스가 여전히 커버 컴파일 된 모듈의 이전 코드를 실행하는 경우 (커버 컴파일 후 완전한 함수 호출을 수행하지 않은 경우) 프로세스가 종료됩니다. 이를 피하려면 &lt;code&gt;cover_stop&lt;/code&gt; 옵션 값 을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 이는 모듈이 계속 컴파일 된 상태임을 의미합니다. 따라서 테스트가 완료된 후 테스트중인 Erlang 노드가 종료되거나 커버를 수동으로 중지 할 수있는 경우에만 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="9bc1af126fb19b5493bbbaf63937647ea51683fa" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default printed to the terminal.</source>
          <target state="translated">기본적으로 커널 응용 프로그램은 시스템 시작시 하나의 로그 핸들러를 설치합니다. 이 핸들러의 이름은 &lt;code&gt;default&lt;/code&gt; 입니다. Erlang 런타임 시스템, 표준 동작 및 다른 Erlang / OTP 애플리케이션에서 생성 된 표준 로그 이벤트를 수신하고 처리합니다. 로그 이벤트는 기본적으로 터미널에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="44204f5230679d2fef96d8949b078f4f3e6c9083" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default written to the terminal.</source>
          <target state="translated">기본적으로 커널 응용 프로그램은 시스템 시작시 하나의 로그 핸들러를 설치합니다. 이 핸들러의 이름은 &lt;code&gt;default&lt;/code&gt; 입니다. Erlang 런타임 시스템, 표준 동작 및 다른 Erlang / OTP 애플리케이션에서 생성 된 표준 로그 이벤트를 수신하고 처리합니다. 로그 이벤트는 기본적으로 터미널에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="05263651b062c95772f413d54c47f0b67ec3f917" translate="yes" xml:space="preserve">
          <source>By default, the actual access to the backup media is performed through module &lt;code&gt;mnesia_backup&lt;/code&gt; for both read and write. Currently &lt;code&gt;mnesia_backup&lt;/code&gt; is implemented with the standard library module &lt;code&gt;disc_log&lt;/code&gt;. However, you can write your own module with the same interface as &lt;code&gt;mnesia_backup&lt;/code&gt; and configure &lt;code&gt;Mnesia&lt;/code&gt; so that the alternative module performs the actual accesses to the backup media. The user can therefore put the backup on a media that &lt;code&gt;Mnesia&lt;/code&gt; does not know about, possibly on hosts where Erlang is not running. Use configuration parameter &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">기본적으로 백업 미디어에 대한 실제 액세스 는 읽기 및 쓰기 모듈 &lt;code&gt;mnesia_backup&lt;/code&gt; 을 통해 수행됩니다 . 현재 &lt;code&gt;mnesia_backup&lt;/code&gt; 표준 라이브러리 모듈로 구현된다 &lt;code&gt;disc_log&lt;/code&gt; . 그러나 &lt;code&gt;mnesia_backup&lt;/code&gt; 과 동일한 인터페이스로 자체 모듈을 작성 하고 대체 모듈이 백업 미디어에 대한 실제 액세스를 수행 하도록 &lt;code&gt;Mnesia&lt;/code&gt; 를 구성 할 수 있습니다. 따라서 사용자는 &lt;code&gt;Mnesia&lt;/code&gt; 가 알지 못하는 미디어 , 아마도 Erlang이 실행되고 있지 않은 호스트에 백업을 넣을 수 있습니다 . 이를 위해 구성 매개 변수 &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1afaf0fcbb8ede75fea0c65c21d25a0925f3450" translate="yes" xml:space="preserve">
          <source>By default, the agent has no knowledge of any other contexts than the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;. If it is to support more contexts, these must be explicitly added, by using an appropriate configuration file &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본적으로 에이전트는 기본 컨텍스트 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이외의 다른 컨텍스트에 대한 지식이 없습니다 . 더 많은 컨텍스트를 지원하려면 적절한 구성 파일 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt; 을 사용하여 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="90e34246dd8429aefe6c7b588f2a3b0f064042d2" translate="yes" xml:space="preserve">
          <source>By default, the boot script and boot file are located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, they are located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">기본적으로 부팅 스크립트와 부팅 파일은 &lt;code&gt;Name.rel&lt;/code&gt; 과 동일한 디렉토리에 있습니다 . 즉, &lt;code&gt;Name&lt;/code&gt; 에 경로가 없는 경우 현재 작업 디렉토리에서 . &lt;code&gt;{outdir,Dir}&lt;/code&gt; 옵션 이 지정되면 대신 &lt;code&gt;Dir&lt;/code&gt; 에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d3804b66310d736d0a24d21cca9ed0959844c03" translate="yes" xml:space="preserve">
          <source>By default, the generated code for operation &lt;code&gt;Record#record_tag.field&lt;/code&gt; verifies that the tuple &lt;code&gt;Record&lt;/code&gt; has the correct size for the record, and that the first element is the tag &lt;code&gt;record_tag&lt;/code&gt;. Use this option to omit the verification code.</source>
          <target state="translated">기본적으로 &lt;code&gt;Record#record_tag.field&lt;/code&gt; 조작에 대해 생성 된 코드 는 튜플 &lt;code&gt;Record&lt;/code&gt; 의 레코드 크기가 올바른지, 첫 번째 요소가 &lt;code&gt;record_tag&lt;/code&gt; 태그인지 검증합니다 . 인증 코드를 생략하려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="92ed03811630a1034411365747a68f1b027d08b7" translate="yes" xml:space="preserve">
          <source>By default, the maximum number of atoms is 1,048,576. This limit can be raised or lowered using the &lt;code&gt;+t&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 최대 원자 수는 1,048,576입니다. 이 한계는 &lt;code&gt;+t&lt;/code&gt; 옵션을 사용하여 늘리거나 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c86aae6b772372c0ae40b88282e56c074aa7a5f1" translate="yes" xml:space="preserve">
          <source>By default, the parser that was generated will not print out error messages to the screen. The user will have to do this either by printing the returned error messages, or by inserting tests and print instructions in the Erlang code associated with the syntax rules of the grammar file.</source>
          <target state="translated">기본적으로 생성 된 구문 분석기는 화면에 오류 메시지를 인쇄하지 않습니다. 사용자는 리턴 된 오류 메시지를 인쇄하거나 문법 파일의 구문 규칙과 연관된 Erlang 코드에 테스트 및 인쇄 지시 사항을 삽입하여이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e241a1115343866b033984b2e0f3224cbedbb8d1" translate="yes" xml:space="preserve">
          <source>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern</source>
          <target state="translated">기본적으로 수량자는 &quot;욕심&quot;입니다. 즉, 나머지 패턴이 실패하지 않고 가능한 한 (최대 허용 시간까지) 일치합니다. 이것이 문제를 일으키는 전형적인 예는 C 프로그램에서 주석을 일치시키는 것입니다. 이들은 / *와 * / 사이에 나타납니다. 주석 내에서 개별 * 및 / 문자가 나타날 수 있습니다. 패턴을 적용하여 C 주석과 일치시키려는 시도</target>
        </trans-unit>
        <trans-unit id="3c85bc6c43eb52272e65af88f8cd9d253d828366" translate="yes" xml:space="preserve">
          <source>By default, the release package contains the directories &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; and &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; for each included application. If more directories are to be included, option &lt;code&gt;dirs&lt;/code&gt; is specified, for example, &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt;.</source>
          <target state="translated">기본적으로 릴리스 패키지에는 포함 된 각 응용 프로그램에 대한 &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; 및 &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; 디렉토리가 포함되어 있습니다. 더 많은 디렉토리를 포함 시키려면 옵션 &lt;code&gt;dirs&lt;/code&gt; 가 지정됩니다 (예 : &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="f48b56c162fe6bc8e83c9024713b2063795276f9" translate="yes" xml:space="preserve">
          <source>By default, the release package file is located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, it is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">기본적으로 릴리스 패키지 파일은 &lt;code&gt;Name.rel&lt;/code&gt; 과 동일한 디렉토리에 있습니다 . 즉, &lt;code&gt;Name&lt;/code&gt; 에 경로가 없는 경우 현재 작업 디렉토리에서 . &lt;code&gt;{outdir,Dir}&lt;/code&gt; 옵션 이 지정되면 대신 &lt;code&gt;Dir&lt;/code&gt; 에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd67be193ef985280c7869e02ad1eaa76d02cee6" translate="yes" xml:space="preserve">
          <source>By default, the script will be interpreted. You can force it to be compiled by including the following line somewhere in the script file:</source>
          <target state="translated">기본적으로 스크립트가 해석됩니다. 스크립트 파일 어딘가에 다음 줄을 포함시켜 강제로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2a64b819e1641df3c5bc639a09bb56418f80b28" translate="yes" xml:space="preserve">
          <source>By default, the tar file is opened in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">기본적으로 tar 파일은 &lt;code&gt;raw&lt;/code&gt; 모드 로 열리 므로 더 빠르지 만 원격 (Erlang) 파일 서버를 사용할 수 없습니다. &lt;code&gt;cooked&lt;/code&gt; 를 모드 목록에 추가 하면 기본값이 무시되고 &lt;code&gt;raw&lt;/code&gt; 옵션없이 tar 파일이 열립니다 .</target>
        </trans-unit>
        <trans-unit id="968238200f11724a49fdbda317cbe260c831d025" translate="yes" xml:space="preserve">
          <source>By default, the value is as before, that is, &lt;code&gt;minimal&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 값은 이전과 같습니다 (즉, &lt;code&gt;minimal&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="e69fa5b82743edee630d33a79817b045aafc5d81" translate="yes" xml:space="preserve">
          <source>By default, this function adds a new line to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">기본적으로이 함수는 지정된 명령의 끝에 새 줄을 추가합니다. 이것이 바람직하지 않은 경우, &lt;code&gt;{newline,false}&lt;/code&gt; 옵션을 사용하십시오 . 예를 들어, IAC (Interprete As Command) 접두어가 붙은 Telnet 명령 시퀀스를 전송할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d49eba4b9253b8356ed12159ecfe231995c2f898" translate="yes" xml:space="preserve">
          <source>By default, this function adds a newline to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">기본적으로이 함수는 지정된 명령 끝에 줄 바꿈을 추가합니다. 이것이 바람직하지 않은 경우, &lt;code&gt;{newline,false}&lt;/code&gt; 옵션을 사용할 수 있습니다. 예를 들어, IAC (Interprete As Command) 접두어가 붙은 Telnet 명령 시퀀스를 전송할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a9e7714f2d506552215115a4ebf113d003a0acf0" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 기능은 zip 파일을 &lt;code&gt;raw&lt;/code&gt; 모드로 열리지 만 더 빠르지 만 원격 (Erlang) 파일 서버를 사용할 수는 없습니다. &lt;code&gt;cooked&lt;/code&gt; 를 모드 목록에 추가 하면 기본값이 무시되고 &lt;code&gt;raw&lt;/code&gt; 옵션없이 zip 파일이 열립니다 .</target>
        </trans-unit>
        <trans-unit id="d14a17c6143d2f118a5dcf4b9f9f2f606d6beef7" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;. The same applies for the files extracted.</source>
          <target state="translated">기본적으로이 기능은 zip 파일을 &lt;code&gt;raw&lt;/code&gt; 모드로 열리지 만 더 빠르지 만 원격 (Erlang) 파일 서버를 사용할 수는 없습니다. &lt;code&gt;cooked&lt;/code&gt; 를 모드 목록에 추가 하면 기본값이 무시되고 &lt;code&gt;raw&lt;/code&gt; 옵션없이 zip 파일이 열립니다 . 추출 된 파일에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a8f2bce9d4e28310f04f71c37d623d77632500e" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in mode &lt;code&gt;raw&lt;/code&gt;, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without the &lt;code&gt;raw&lt;/code&gt; option. The same applies for the files added.</source>
          <target state="translated">기본적으로이 기능은 zip 파일을 &lt;code&gt;raw&lt;/code&gt; 모드로 열어서 더 빠르지 만 원격 (Erlang) 파일 서버를 사용할 수 없습니다. 모드 목록에 &lt;code&gt;cooked&lt;/code&gt; 를 추가 하면 기본값이 무시되고 &lt;code&gt;raw&lt;/code&gt; 옵션 없이 zip 파일이 열립니다 . 추가 된 파일에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="679e4d02c8183bf697056897c283fb7c9fe1a240" translate="yes" xml:space="preserve">
          <source>By default, this option is not set. This means that the number is not limited.</source>
          <target state="translated">기본적으로이 옵션은 설정되어 있지 않습니다. 이것은 그 수가 제한되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6486abd515b1ceb341dd61657f6cfe722ef188e0" translate="yes" xml:space="preserve">
          <source>By default, this rule is written to &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt;. However, if option &lt;code&gt;binary&lt;/code&gt; is set, nothing is written and the rule is returned in &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 규칙은 &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt; 에 작성됩니다 . 그러나 &lt;code&gt;binary&lt;/code&gt; 옵션 이 설정되어 있으면 아무것도 기록되지 않으며 &lt;code&gt;Binary&lt;/code&gt; 규칙이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3dc5c5c502173feaca81300d649a4642ade965d9" translate="yes" xml:space="preserve">
          <source>By default, this will &lt;strong&gt;not&lt;/strong&gt; be used.</source>
          <target state="translated">기본적으로이 기능은 사용 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9e77c5d7a27dc1e5cf909f3bf8e3e3ad53b629c2" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted for unused variables, except for variables beginning with an underscore (&quot;Prolog style warnings&quot;). Use this option to turn off this kind of warnings.</source>
          <target state="translated">밑줄로 시작하는 변수 ( &quot;프롤로그 스타일 경고&quot;)를 제외하고 기본적으로 사용하지 않는 변수에 대해 경고가 생성됩니다. 이 종류의 경고를 끄려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20ba07e398dad932a7a5314c1ee7e53c53da657a" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;[]&lt;/code&gt; is passed as &lt;code&gt;ModifierList&lt;/code&gt;, both negative and positive integers can be returned. This to use the range of integers that do not need heap memory allocation as much as possible. By default the returned integers are also only guaranteed to be unique, that is, any returned integer can be smaller or larger than previously returned integers.</source>
          <target state="translated">기본적으로 &lt;code&gt;[]&lt;/code&gt; 가 &lt;code&gt;ModifierList&lt;/code&gt; 로 전달되면 음수 및 양수를 모두 반환 할 수 있습니다. 힙 메모리 할당이 필요없는 정수 범위를 사용합니다. 기본적으로 반환 된 정수는 고유 한 것만 보장됩니다. 즉, 반환 된 정수는 이전에 반환 된 정수보다 작거나 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11b69da7024ea541c3dc95c3ee7904796b05dd49" translate="yes" xml:space="preserve">
          <source>By definition, it is not possible to send objects with ACCESS &lt;code&gt;not-accessible&lt;/code&gt; in notifications. However, historically this is often done and for this reason we allow it in notification sending. If a variable has ACCESS &lt;code&gt;not-accessible&lt;/code&gt;, the user must provide a value for the variable in the &lt;code&gt;Varbinds&lt;/code&gt; list. It is not possible for the agent to perform a get-operation to retrieve this value.</source>
          <target state="translated">정의에 따라 통지에서 &lt;code&gt;not-accessible&lt;/code&gt; ACCESS를 가진 오브젝트를 보낼 수 없습니다 . 그러나 역사적으로이 작업은 종종 수행되므로 이러한 이유로 인해 알림 전송이 가능합니다. 변수가 ACCESS가있는 경우 &lt;code&gt;not-accessible&lt;/code&gt; , 사용자가에서 변수의 값 제공해야 &lt;code&gt;Varbinds&lt;/code&gt; 의 목록을. 에이전트가 get-operation을 수행하여이 값을 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fe4bf7551fb0bca40b8408258d2d9b38f061a30" translate="yes" xml:space="preserve">
          <source>By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea.</source>
          <target state="translated">더 큰 이진을 참조하지 않기 위해 의도적으로 단일 이진을 복사하면 나중에 가비지 수집을 위해 더 큰 이진을 비우는 대신 필요한 것보다 훨씬 많은 이진 데이터를 만들 수 있습니다. 이진 데이터를 공유하는 것이 좋습니다. 작은 부품이 큰 이진을 참조하고 큰 이진이 더 이상 어떤 프로세스에서도 사용되지 않는 특별한 경우에만 의도적 인 복사가 좋은 생각이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a1bde088e58ddc2e236cd1237348e4ca2d354a9" translate="yes" xml:space="preserve">
          <source>By executing these commands, two Erlang nodes are configured to run the &lt;code&gt;Company&lt;/code&gt; database, and therefore, initialize the database. This is required only once when setting up. The next time the system is started, &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes, to initialize the system from disc.</source>
          <target state="translated">이 명령을 실행하면 두 개의 Erlang 노드가 &lt;code&gt;Company&lt;/code&gt; 데이터베이스 를 실행하도록 구성되어 데이터베이스를 초기화합니다. 설정시 한 번만 필요합니다. 다음에 시스템을 시작할 때 디스크에서 시스템을 초기화하기 위해 두 노드에서 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cbb518f731cd8bac9f82803da816e494e6c084" translate="yes" xml:space="preserve">
          <source>By far the most common situation where this occurs, is when you get lists of UTF-8 instead of proper Unicode strings, and then convert them to UTF-8 in a binary or on a file:</source>
          <target state="translated">가장 일반적인 상황은 적절한 유니 코드 문자열 대신 UTF-8 목록을 가져온 다음 바이너리 또는 파일에서 UTF-8로 변환하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e536308fb486e25402a1208f98bf1f7153e3c15e" translate="yes" xml:space="preserve">
          <source>By focusing on getting the code to pass the tests, the programmer can become more productive, not overspecify or get lost in premature optimizations, and create code that is correct from the very beginning (so-called &lt;strong&gt;test-driven development&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">코드를 테스트에 통과시키는 데 집중함으로써 프로그래머는 생산성을 높이고, 과도하게 지정하거나 조기 최적화에서 잃지 않고, 처음부터 올바른 코드를 만들 수 있습니다 (소위 &lt;strong&gt;테스트 중심 개발&lt;/strong&gt; ; &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1be6092d2f04d5672bbcc552b76ea03252377f9a" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application (see section &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">형식 핸들러 &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; 제공 하면 ET 애플리케이션에서 &lt;code&gt;et_viewer&lt;/code&gt; 를 사용하여 추적 로그를 그래픽으로 표시 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt; 프로그램으로 추적 로그 표시 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="4d1f348639ff071f4f3a637874209a8d2a2be427" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application. &lt;code&gt;ttb&lt;/code&gt; provides filters that can be selected from the menu &lt;strong&gt;Filter&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt; window. The filters are names according to the type of actors they present (that is, what each vertical line in the sequence diagram represents). Interaction between actors is shown as red arrows between two vertical lines, and activities within an actor are shown as blue text to the right of the actors line.</source>
          <target state="translated">형식 핸들러 &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; 제공 하면 ET 애플리케이션에서 &lt;code&gt;et_viewer&lt;/code&gt; 를 사용하여 추적 로그를 그래픽으로 표시 할 수 있습니다 . &lt;code&gt;ttb&lt;/code&gt; 메뉴에서 선택할 수있는 필터 제공 &lt;strong&gt;필터&lt;/strong&gt; 에서 &lt;code&gt;et_viewer&lt;/code&gt; 의 창을. 필터는 존재하는 액터의 유형 (즉, 시퀀스 다이어그램의 각 수직선이 나타내는 것)에 따른 이름입니다. 액터 간 상호 작용은 두 개의 수직선 사이에 빨간색 화살표로 표시되고 액터 내의 액티비티는 액터 선 오른쪽에 파란색 텍스트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1c38dcce4fbbcbaa49db2c494d622ac31a93af9e" translate="yes" xml:space="preserve">
          <source>By inspecting the headers or writing a small C program, it is found that &lt;code&gt;IPPROTO_TCP&lt;/code&gt; is 6, &lt;code&gt;TCP_INFO&lt;/code&gt; is 11, the structure size is 92 (bytes), the offset of &lt;code&gt;tcpi_sacked&lt;/code&gt; is 28 bytes, and the value is a 32-bit integer. The following code can be used to retrieve the value:</source>
          <target state="translated">헤더를 검사하거나 작은 C 프로그램을 작성하면 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 는 6이고 &lt;code&gt;TCP_INFO&lt;/code&gt; 는 11이며 구조 크기는 92 (바이트)이며 &lt;code&gt;tcpi_sacked&lt;/code&gt; 의 오프셋 은 28 바이트이며 값은 32 비트 정수입니다. 다음 코드를 사용하여 값을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018fc7c90872dc5bcc3ecc8ce71bc58db7e38b60" translate="yes" xml:space="preserve">
          <source>By inspecting the implementation, you might notice that some specific signal gives a stricter guarantee than described above. It is of vital importance that such knowledge about the implementation is &lt;strong&gt;not&lt;/strong&gt; used by Erlang code, as the implementation can change at any time without prior notice.</source>
          <target state="translated">구현을 검사하면 일부 특정 신호가 위에서 설명한 것보다 더 엄격한 보증을 제공함을 알 수 있습니다. 구현에 대한 이러한 지식은 Erlang 코드에서 사용 &lt;strong&gt;되지 않는&lt;/strong&gt; 것이 중요합니다. 구현은 사전 통지없이 언제든지 변경 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e8b879e7731e558078b8cea840f1fb4c1f690b4a" translate="yes" xml:space="preserve">
          <source>By looking at the results from the analyses, it can be deducted that the test case does not cover the case when all channels are allocated and &lt;code&gt;test.erl&lt;/code&gt; should be extended accordingly.</source>
          <target state="translated">분석 결과를 살펴보면 모든 채널이 할당되고 &lt;code&gt;test.erl&lt;/code&gt; 이 그에 따라 확장되어야 하는 경우 테스트 사례가 해당 사례를 다루지 않는다는 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0adc0a428da4933a5c912fbd894ed220b7168db5" translate="yes" xml:space="preserve">
          <source>By parsing an XML document you will get a record, displaying the structure of the document, as return value. The record also holds the data of the document. xmerl is convenient to use in for instance the following scenarios:</source>
          <target state="translated">XML 문서를 구문 분석하면 문서 구조를 리턴 값으로 표시하는 레코드를 얻게됩니다. 레코드는 문서의 데이터도 보유합니다. xmerl은 예를 들어 다음 시나리오에서 사용하기 편리합니다.</target>
        </trans-unit>
        <trans-unit id="805a7a9a8ddfb1ba7400cf31f92187edc3ff9a77" translate="yes" xml:space="preserve">
          <source>By passing a pointer to an integer variable containing the value &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt;, the currently used limit is read and written back to the integer variable. A new limit can be set by passing a pointer to an integer variable containing a valid limit. The passed value is written to the internal limit. The internal limit is then adjusted. After this the adjusted limit is written back to the integer variable from which the new value was read. Values are in bytes.</source>
          <target state="translated">&lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt; 값을 포함하는 정수 변수에 포인터를 전달 하면 현재 사용 된 한계를 읽고 정수 변수에 다시 씁니다 . 유효한 한계를 포함하는 정수 변수에 포인터를 전달하여 새로운 한계를 설정할 수 있습니다. 전달 된 값은 내부 한계에 기록됩니다. 그런 다음 내부 한계가 조정됩니다. 이 후 조정 된 한계는 새 값을 읽은 정수 변수에 다시 쓰여집니다. 값은 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="75da6c1f2ebad0633762bf86ba622c3a4f5ba6cd" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; 함수에 인수와 동일한 &quot;fun&quot;을 전달하면 &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt; 함수와 거의 동일한 컨텍스트에서 수행됩니다 . 차이점은 작업이 동 기적으로 수행된다는 것입니다. 호출자는 모든 활성 복제본에서 업데이트가 수행되기를 기다립니다. &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; 를 사용 하면 다음과 같은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="808cd51c3638fb04adece47349170a09569ccf1c" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; 함수에 인수와 동일한 &quot;fun&quot;을 전달하면 더티 컨텍스트에서 수행됩니다. 함수 호출은 해당 더티 함수에 매핑됩니다. 여기에는 여전히 로깅, 복제 및 구독이 포함되지만 잠금, 로컬 트랜잭션 스토리지 또는 커밋 프로토콜은 포함되지 않습니다. 체크 포인트 리테이너는 업데이트되었지만 &quot;더티&quot;로 업데이트되었습니다. 따라서 비동기 적으로 업데이트됩니다. 기능은 한 노드에서 작업이 수행되기를 기다리지 만 다른 노드에서는 수행되지 않습니다. 테이블이 로컬에 있으면 대기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fe18782111712f87288c23d1c8fb50a83e580df" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; 함수에 인수와 동일한 &quot;fun&quot;을 전달하면 동기화 된 트랜잭션 컨텍스트에서 수행됩니다. 동기화 된 트랜잭션은 모든 활성 복제본이 트랜잭션을 디스크로 커밋 할 때까지 기다린 후 &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; 호출 에서 돌아옵니다 . &lt;code&gt;sync_transaction&lt;/code&gt; 을 사용 하면 다음과 같은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8d8e68091d4403f0e83bd114c70649e6a566d00b" translate="yes" xml:space="preserve">
          <source>By preference, these functions can be included in module &lt;code&gt;shell_default&lt;/code&gt;. By default, they are included in that module.</source>
          <target state="translated">&lt;code&gt;shell_default&lt;/code&gt; 으로 이러한 기능은 shell_default 모듈에 포함될 수 있습니다 . 기본적으로 해당 모듈에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f254d4f66995179ccfd6ad20889ce3083eb5612" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;SourceMod&lt;/code&gt; and &lt;code&gt;TargetMod&lt;/code&gt; to different modules, a backup can be copied from one backup media to another.</source>
          <target state="translated">&lt;code&gt;SourceMod&lt;/code&gt; 와 &lt;code&gt;TargetMod&lt;/code&gt; 를 다른 모듈 로 설정 하면 한 백업 미디어에서 다른 백업 미디어로 백업을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d49dba3e2b5c5cceb098125c642fa912b7e82445" translate="yes" xml:space="preserve">
          <source>By testing in a bottom-up fashion, beginning with the smallest program units and creating a confidence in that they work as they should, it becomes easier to test that a higher-level component, consisting of several such units, also behaves according to specification (known as &lt;strong&gt;integration testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">가장 작은 프로그램 단위부터 시작하여 원하는대로 작동한다는 확신을 가지면서 상향식으로 테스트하면 여러 단위로 구성된 상위 레벨 구성 요소가 스펙에 따라 작동하는지 테스트하기가 더 쉬워집니다. ( &lt;strong&gt;통합 테스트&lt;/strong&gt; 라고도 합니다. &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ff05bbe6b9df494deffc0d26f620950719c544d4" translate="yes" xml:space="preserve">
          <source>By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:</source>
          <target state="translated">이것에 의해, 패턴의 다른 부분에서 다른 설정을 갖도록 옵션을 만들 수 있습니다. 하나의 대안에서 이루어진 모든 변경 사항은 동일한 하위 패턴 내에서 후속 분기로 이어집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35ec349917181f956c0a4c9c0f4a81caa7003c00" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt;, you can specify if Debugger is to be started in local or global mode:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 디버거 를 로컬 또는 글로벌 모드에서 시작할지 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da8978f9ea68a7c6f48f6d3c9e527498ef08964" translate="yes" xml:space="preserve">
          <source>By using option &lt;code&gt;handler&lt;/code&gt; when starting the tracer, the information about how to format the file is stored in the trace information file (&lt;code&gt;.ti&lt;/code&gt;). This is not necessary, as it can be specified when formatting instead. However, It can be useful if you, for example, want to format trace logs automatically using option &lt;code&gt;format&lt;/code&gt; in &lt;code&gt;ttb:stop/1&lt;/code&gt;. Also, you do not need any knowledge of the content of a binary log to format it the way it is intended. If option &lt;code&gt;handler&lt;/code&gt; is specified both when starting the tracer and when formatting, the one specified when formatting is used.</source>
          <target state="translated">추적 프로그램을 시작할 때 옵션 &lt;code&gt;handler&lt;/code&gt; 를 사용 하면 파일 형식화 방법에 대한 정보가 추적 정보 파일 ( &lt;code&gt;.ti&lt;/code&gt; )에 저장됩니다 . 대신 포맷 할 때 지정할 수 있으므로 필요하지 않습니다. 그러나 예를 들어 &lt;code&gt;ttb:stop/1&lt;/code&gt; 의 옵션 &lt;code&gt;format&lt;/code&gt; 을 사용하여 추적 로그를 자동으로 형식화하려는 경우 유용 할 수 있습니다 . 또한 바이너리 로그의 내용에 대한 지식이 없어도 원하는 방식으로 형식을 지정할 수 있습니다. 추적 프로그램을 시작할 때와 형식화 할 때 옵션 &lt;code&gt;handler&lt;/code&gt; 를 지정하면 형식화 할 때 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="02d1325592a3ef565e5e7f405f91fc17bcd0d42f" translate="yes" xml:space="preserve">
          <source>By using ordinary UNIX tools like &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; one can easily find answers to various questions like:</source>
          <target state="translated">&lt;code&gt;sed&lt;/code&gt; 및 &lt;code&gt;grep&lt;/code&gt; 과 같은 일반적인 UNIX 도구를 사용 하면 다음과 같은 다양한 질문에 대한 답변을 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2d275dd09349865f8c3284b6c4fd5293841ad62" translate="yes" xml:space="preserve">
          <source>By using the new API, you automatically get scalability and performance improvements. This also enables you to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; that improves accuracy and precision of time measurements.</source>
          <target state="translated">새로운 API를 사용하면 확장 성과 성능이 자동으로 향상됩니다. 또한 시간 측정의 정확성과 정밀도를 향상시키는 &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77c257b7be9bfb86770597be303f8b67e4aa586a" translate="yes" xml:space="preserve">
          <source>By wrapping the API with functions that fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable, and using these wrappers instead of using the API directly, the problem is solved. These wrappers can, for example, be implemented as in &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt;.</source>
          <target state="translated">새 API를 사용할 수 없을 때 &lt;code&gt;erlang:now/0&lt;/code&gt; 으로 대체 되는 함수로 API를 랩핑하고 API를 직접 사용하는 대신 이러한 래퍼를 사용하면 문제가 해결됩니다. 이러한 래퍼는 예를 들어 &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt; 과 같이 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00bf079d821f3a0145d168bfcf76ce42b727b9c4" translate="yes" xml:space="preserve">
          <source>Bypass all messages to the receiving process.</source>
          <target state="translated">모든 메시지를 수신 프로세스로 우회하십시오.</target>
        </trans-unit>
        <trans-unit id="0cfa66375624ff2bee2fec17b2715898b2615b30" translate="yes" xml:space="preserve">
          <source>Bypass the native code compilation of some key files that Dialyzer heuristically performs when dialyzing many files. This avoids the compilation time, but can result in (much) longer analysis time.</source>
          <target state="translated">많은 파일을 투석 할 때 Dialyzer가 경험적으로 수행하는 일부 주요 파일의 원시 코드 컴파일을 무시하십시오. 이렇게하면 컴파일 시간이 단축되지만 분석 시간이 훨씬 길어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eed4df1a2c0521e891f717551aca2cc2df95a04a" translate="yes" xml:space="preserve">
          <source>Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte).</source>
          <target state="translated">0x2A, 0x2D, ​​0x2E, 0x30 ~ 0x39, 0x41 ~ 0x5A, 0x5F, 0x61 ~ 0x7A 범위를 벗어난 바이트는 퍼센트 인코딩 (U + 0025 PERCENT SIGN 문자 (%) 뒤에 16 진수를 나타내는 대문자 ASCII 16 진수)입니다. 바이트 값).</target>
        </trans-unit>
        <trans-unit id="0ca15868aa5caba5cda8401a4c79d41061a3d6a4" translate="yes" xml:space="preserve">
          <source>Bytes written to the file by any means are translated to UTF-8 encoding before being stored on the disk file.</source>
          <target state="translated">어떤 방법 으로든 파일에 기록 된 바이트는 디스크 파일에 저장되기 전에 UTF-8 인코딩으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="e48d8a1314ac59090c047f1cace030d6174ffe04" translate="yes" xml:space="preserve">
          <source>C nodes can also register themselves with &lt;code&gt;epmd&lt;/code&gt; if they want other nodes in the system to be able to find and connect to them.</source>
          <target state="translated">C 노드는 시스템의 다른 노드가 찾아서 연결할 수있게하려면 &lt;code&gt;epmd&lt;/code&gt; 에 자신을 등록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aaca542e8937ae72090fdd955fe659422678461" translate="yes" xml:space="preserve">
          <source>C-Left</source>
          <target state="translated">C-Left</target>
        </trans-unit>
        <trans-unit id="e2bb854461c349ecc3ae2bfb00ac6727ba113ad8" translate="yes" xml:space="preserve">
          <source>C-Right</source>
          <target state="translated">C-Right</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="1d8e75405de8be939b05db3eef9ab4daa516674d" translate="yes" xml:space="preserve">
          <source>C-d</source>
          <target state="translated">C-d</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="68b4cf03a08cd7bf7acc0d39d68cca6ef0f409f3" translate="yes" xml:space="preserve">
          <source>C-t</source>
          <target state="translated">C-t</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="8e0be97e2cc76979d93e15014888863a6e79a7af" translate="yes" xml:space="preserve">
          <source>C-w</source>
          <target state="translated">C-w</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="27ae2e5d9b51df18972eb310bdefaba625476830" translate="yes" xml:space="preserve">
          <source>CEA is sent and received by diameter.</source>
          <target state="translated">CEA는 직경별로 송수신됩니다.</target>
        </trans-unit>
        <trans-unit id="ff534b0e9ae18ae782f79e9fe262a000f3c6ff49" translate="yes" xml:space="preserve">
          <source>CER is sent and received by diameter.</source>
          <target state="translated">CER은 직경별로 송수신됩니다.</target>
        </trans-unit>
        <trans-unit id="112d72d949c9bbe40789456cde8492d907b63e28" translate="yes" xml:space="preserve">
          <source>CHARACTER (size), CHAR (size)</source>
          <target state="translated">문자 (크기), 문자 (크기)</target>
        </trans-unit>
        <trans-unit id="24ecce9e5657a884a70aea047867075f09d39ad6" translate="yes" xml:space="preserve">
          <source>CHARACTER VARYING(size), CHAR VARYING(size)</source>
          <target state="translated">문자 가변 (크기), 문자 가변 (크기)</target>
        </trans-unit>
        <trans-unit id="4a4f0e1b5b9cde6b772cb89e0e6bdb0a6ab6de56" translate="yes" xml:space="preserve">
          <source>CR, LF, or CRLF only</source>
          <target state="translated">CR, LF 또는 CRLF 만</target>
        </trans-unit>
        <trans-unit id="d5ab3cb5603f8a4df9b9b5741bc8bf57061a02e7" translate="yes" xml:space="preserve">
          <source>CRL cache</source>
          <target state="translated">CRL 캐시</target>
        </trans-unit>
        <trans-unit id="ff86d60418e1cef1253cf01c43b18051224fcb54" translate="yes" xml:space="preserve">
          <source>CTHs are run with the same process scoping as normal test suites, that is, a different process executes the &lt;code&gt;init_per_suite&lt;/code&gt; hooks then the &lt;code&gt;init_per_group&lt;/code&gt; or &lt;code&gt;per_testcase&lt;/code&gt; hooks. So if you want to spawn a process in the CTH, you cannot link with the CTH process, as it exits after the post hook ends. Also, if you for some reason need an ETS table with your CTH, you must spawn a process that handles it.</source>
          <target state="translated">CTH는 일반 테스트 스위트와 동일한 프로세스 범위로 실행됩니다. 즉, 다른 프로세스가 &lt;code&gt;init_per_suite&lt;/code&gt; 후크를 실행 한 다음 &lt;code&gt;init_per_group&lt;/code&gt; 또는 &lt;code&gt;per_testcase&lt;/code&gt; 후크 를 실행합니다 . 따라서 CTH에서 프로세스를 생성하려면 포스트 후크가 종료 된 후 종료되므로 CTH 프로세스와 연결할 수 없습니다. 또한 어떤 이유로 CTH와 함께 ETS 테이블이 필요한 경우이를 처리하는 프로세스를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e6e1792db904ba826af372ccec45b6e25fb5024" translate="yes" xml:space="preserve">
          <source>CTHs can also be added within a test suite. This is done by returning &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; in the configuration list from &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 스위트 내에 CTH를 추가 할 수도 있습니다. 구성 목록에서 &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; 를 리턴하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="cebcaf761552337b6a6de3a9db00451f69633f4b" translate="yes" xml:space="preserve">
          <source>CTHs can be used to synchronize test runs with external user applications. The init function can, for example, start and/or communicate with an application that has the purpose of preparing the SUT for an upcoming test run, or initialize a database for saving test data to during the test run. The terminate function can similarly order such an application to reset the SUT after the test run, and/or tell the application to finish active sessions and terminate. Any system error- or progress reports generated during the init- or termination stage are saved in the &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt;. (This is also true for any printouts made with &lt;code&gt;ct:log/2&lt;/code&gt; and &lt;code&gt;ct:pal/2&lt;/code&gt;).</source>
          <target state="translated">CTH를 사용하여 테스트 실행을 외부 사용자 응용 프로그램과 동기화 할 수 있습니다. 예를 들어, 초기화 기능은 다음 테스트 실행을 위해 SUT를 준비하거나 테스트 실행 중 테스트 데이터를 저장하기 위해 데이터베이스를 초기화 할 목적으로 응용 프로그램을 시작 및 / 또는 통신 할 수 있습니다. 종료 기능은 테스트 실행 후 SUT를 재설정하도록 응용 프로그램을 유사하게 주문하거나 응용 프로그램에 활성 세션을 마치고 종료하도록 지시 할 수 있습니다. 초기화 또는 종료 단계에서 생성 된 모든 시스템 오류 또는 진행률 보고서는 &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt; 됩니다. ( &lt;code&gt;ct:log/2&lt;/code&gt; 및 &lt;code&gt;ct:pal/2&lt;/code&gt; 로 작성된 모든 출력물의 경우에도 마찬가지입니다 ).</target>
        </trans-unit>
        <trans-unit id="1413152f77878171b8b1aa5bd33bfea4b91b1e35" translate="yes" xml:space="preserve">
          <source>CTHs cannot be added here right now. That feature may be added in a later release, but it would right now break backwards compatibility.</source>
          <target state="translated">현재 CTH를 추가 할 수 없습니다. 이 기능은 이후 릴리스에서 추가 될 수 있지만 지금은 이전 버전과의 호환성을 손상시킵니다.</target>
        </trans-unit>
        <trans-unit id="27930480546a406089acbe7e97d210e59cf3f0a5" translate="yes" xml:space="preserve">
          <source>Caches a new session or updates an already cached one. Is only called from the cache handling process.</source>
          <target state="translated">새 세션을 캐시하거나 이미 캐시 된 세션을 업데이트합니다. 캐시 처리 프로세스에서만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a61c27140fecb8e4a22ce80c81760b45147855bd" translate="yes" xml:space="preserve">
          <source>Calculate scheduler utilizations for the time interval from when &lt;code&gt;Sample&lt;/code&gt; was taken and &quot;now&quot;. The same as calling &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sample&lt;/code&gt; 채취 시점부터 &quot;지금&quot; 까지의 시간 간격에 대한 스케줄러 활용도를 계산하십시오 . &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3159ceb44a5156030b65aa273f276c3747dcacc9" translate="yes" xml:space="preserve">
          <source>Calculates a key for later use in &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt;. The keys are evenly distributed so that a fair mapping between port IDs and async thread IDs is achieved.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; 에서 나중에 사용하기 위해 키를 계산합니다 . 키는 균등하게 분배되어 포트 ID와 비동기 스레드 ID 사이의 공평한 맵핑이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="97a16654177af632fa24a3c60a60a85917da19f0" translate="yes" xml:space="preserve">
          <source>Calculates a ssh fingerprint from a public host key as openssh does.</source>
          <target state="translated">openssh와 같이 공개 호스트 키에서 ssh 지문을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="96b67c5752326af1f998bcfc9d0641aa609cb938" translate="yes" xml:space="preserve">
          <source>Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included).</source>
          <target state="translated">모듈 코드에 대한 MD5 중복 검사를 계산합니다 (컴파일 날짜 및 기타 속성은 포함되지 않음).</target>
        </trans-unit>
        <trans-unit id="49556b91adcf0245cb3d710749c75861fa022a4f" translate="yes" xml:space="preserve">
          <source>Calculates and returns the length of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">큐 &lt;code&gt;Q&lt;/code&gt; 의 길이를 계산하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2e81ece084c83acdfbcc583fdce8e53ba5b901b1" translate="yes" xml:space="preserve">
          <source>Calculates scheduler utilizations for the time interval between the two samples obtained from calling &lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt; 호출에서 얻은 두 샘플 사이의 시간 간격에 대한 스케줄러 활용도를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="227b790ced77d840153cd69f4b9d2467f87af6d9" translate="yes" xml:space="preserve">
          <source>Calculates the Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 에 대한 Adler-32 체크섬을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f486ba07e5a51271bcf5c7397d6baef999b087f1" translate="yes" xml:space="preserve">
          <source>Calculates the CRC checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; 의 CRC 체크섬을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7a8a87c52d80ef29c6c7f4e720f1eb69b8f5e769" translate="yes" xml:space="preserve">
          <source>Calculates the time difference &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; in &lt;strong&gt;microseconds&lt;/strong&gt;, where &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are time-stamp tuples on the same format as returned from &lt;code&gt;erlang:timestamp/0&lt;/code&gt; or &lt;code&gt;os:timestamp/0&lt;/code&gt;.</source>
          <target state="translated">시간 차이 &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; 을 &lt;strong&gt;마이크로 초 단위로&lt;/strong&gt; 계산합니다 . 여기서 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 는 &lt;code&gt;erlang:timestamp/0&lt;/code&gt; 또는 &lt;code&gt;os:timestamp/0&lt;/code&gt; 에서 반환 된 형식과 동일한 형식의 타임 스탬프 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="31e631ed71da6b22331e1ba2c1ab40350acc8c94" translate="yes" xml:space="preserve">
          <source>Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format. The following condition applies always:</source>
          <target state="translated">Erlang 외부 용어 형식으로 인코딩 된 용어의 최대 바이트 크기를 인코딩하지 않고 계산합니다. 다음 조건이 항상 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9a2b0161d342ba687bae1cf3bd6fc16726fc85e" translate="yes" xml:space="preserve">
          <source>Call ::= FunSpec &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt;MFA&lt;code&gt;,&lt;/code&gt; MFA&lt;code&gt;}&lt;/code&gt; | AtomConst &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt;AtomConst&lt;code&gt;,&lt;/code&gt; AtomConst&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">전화 :: = FunSpec- &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt; MFA &lt;code&gt;,&lt;/code&gt; MFA &lt;code&gt;}&lt;/code&gt; | AtomConst- &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt; AtomConst &lt;code&gt;,&lt;/code&gt; AtomConst &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87defee9508517c6c10659d4e0fee5236449ad6" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, pass to it a pointer to the dirty NIF to be executed, and indicate with argument &lt;code&gt;flags&lt;/code&gt; whether it expects the operation to be CPU-bound or I/O-bound.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; 를 호출 하고 실행할 더티 NIF에 대한 포인터를 전달 하고 조작이 CPU 바운드인지 I / O 바운드인지 여부 를 인수 &lt;code&gt;flags&lt;/code&gt; 표시 하십시오.</target>
        </trans-unit>
        <trans-unit id="69bfcf4495124cb65edd6183c66a7288de41dd51" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;analyze&lt;/code&gt; with &lt;code&gt;total&lt;/code&gt; option when profiling has been stopped to display the results per function call, that is in which function calls the time has been spent.</source>
          <target state="translated">전화 &lt;code&gt;analyze&lt;/code&gt; 과 &lt;code&gt;total&lt;/code&gt; 기능은 시간이 소비되어 호출하는 것입니다 함수 호출, 당 결과를 표시 중지 된 프로파일 링 할 때 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="166bcff3bd03bad3b22be129a767e953b92bb7c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">전화 &lt;code&gt;info&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b32de2da67e0b479c6558da688c298d2c8d61df" translate="yes" xml:space="preserve">
          <source>Call Graph Edges (*).</source>
          <target state="translated">호출 그래프 모서리 (*).</target>
        </trans-unit>
        <trans-unit id="ee61800f5d1b4760400245c96aa2f8c30730dd00" translate="yes" xml:space="preserve">
          <source>Call Graph Vertices (*).</source>
          <target state="translated">호출 그래프 정점 (*).</target>
        </trans-unit>
        <trans-unit id="4517bf0f809aaf1e241952932bd6d071e97a1670" translate="yes" xml:space="preserve">
          <source>Call a NIF that first performs a chunk of the work, then invokes the &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result.</source>
          <target state="translated">먼저 작업 덩어리를 수행하는 NIF를 호출 한 후 &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 다음 덩어리를 수행하도록 다른 NIF 호출을 스케줄하십시오. 이러한 방식으로 예약 된 최종 통화는 전체 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e64aca1cbd78581418480040f30e164b840d03b" translate="yes" xml:space="preserve">
          <source>Call back function to accumulate contents of entity.</source>
          <target state="translated">엔티티의 내용을 축적하는 함수를 콜백하십시오.</target>
        </trans-unit>
        <trans-unit id="25cbcf90fa280c9778e7621dfdd70289b3357c4e" translate="yes" xml:space="preserve">
          <source>Call back function to decide what to do if the scanner runs into EOF before the document is complete.</source>
          <target state="translated">문서가 완성되기 전에 스캐너가 EOF에 도달 할 경우 수행 할 작업을 결정하는 기능을 콜백합니다.</target>
        </trans-unit>
        <trans-unit id="305e72ce9d0178fb37627379b7066e3998f1aaff" translate="yes" xml:space="preserve">
          <source>Call back function to fetch an external resource.</source>
          <target state="translated">외부 리소스를 가져 오려면 함수를 콜백하십시오.</target>
        </trans-unit>
        <trans-unit id="f1d17c05f561817d9262782ed4703874ffa16a47" translate="yes" xml:space="preserve">
          <source>Call back function to handle scanner events.</source>
          <target state="translated">스캐너 이벤트를 처리하기위한 콜백 기능.</target>
        </trans-unit>
        <trans-unit id="967a892c17aad400146f3cd8a0b41cd0e008b98d" translate="yes" xml:space="preserve">
          <source>Call back function to process the document entities once identified.</source>
          <target state="translated">식별 된 문서 엔티티를 처리하는 함수를 콜백하십시오.</target>
        </trans-unit>
        <trans-unit id="e43990d9029a1b5faffe47cfb2a73c40d38948b7" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradation in the vicinity of 10 percent.</source>
          <target state="translated">추적 메시지를 생성 할 필요가 없기 때문에 통화 수 추적은 다른 형식의 추적에 비해 매우 가볍습니다. 일부 측정 결과는 10 % 부근에서 성능 저하를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d9d8ff2abc216537369a4f6c51252cf41bb671a" translate="yes" xml:space="preserve">
          <source>Call count tracing is very lightweight compared to other forms of tracing since no trace message has to be generated. Some measurements indicates performance degradations in the vicinity of 10 percent.</source>
          <target state="translated">추적 메시지를 생성 할 필요가 없기 때문에 통화 수 추적은 다른 형식의 추적에 비해 매우 가볍습니다. 일부 측정 결과는 10 % 부근에서 성능 저하를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ed8c88acf1e0b8225e507d6c8cef5617c61d6b6" translate="yes" xml:space="preserve">
          <source>Call these iteration functions on nodes that contain a replica of the table. Each call to the function &lt;code&gt;Fun&lt;/code&gt; access the table and if the table resides on another node it generates much unnecessary network traffic.</source>
          <target state="translated">테이블의 복제본이 포함 된 노드에서 이러한 반복 함수를 호출하십시오. &lt;code&gt;Fun&lt;/code&gt; 함수를 호출 할 때마다 테이블에 액세스하고 테이블이 다른 노드에 있으면 불필요한 네트워크 트래픽이 많이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92a83b9ff602a28ae97d4ee0c90eb3fa1240e7fa" translate="yes" xml:space="preserve">
          <source>Call this function to stop cover test on nodes previously added with &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt;. Results on the remote node are transferred to the &lt;code&gt;Common Test&lt;/code&gt; node.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;#add_nodes-1&quot;&gt;ct_cover:add_nodes/1&lt;/a&gt;&lt;/code&gt; 로 추가 된 노드에서 커버 테스트를 중지하려면이 함수를 호출하십시오 . 원격 노드의 결과는 &lt;code&gt;Common Test&lt;/code&gt; 노드 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="37045b168b3bc333ac8bca52ef56747d12a1101f" translate="yes" xml:space="preserve">
          <source>Call this function when profiling has been stopped to display the results per process, that is:</source>
          <target state="translated">프로세스 당 결과를 표시하기 위해 프로파일 링이 중지 된 경우이 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="eea8e2a2479f703038c465d2c2ffcd082e88cb6f" translate="yes" xml:space="preserve">
          <source>Callback = atom()</source>
          <target state="translated">콜백 = atom ()</target>
        </trans-unit>
        <trans-unit id="61dfb922d9f46c947d009d0fb95ea292779f3dc7" translate="yes" xml:space="preserve">
          <source>Callback for &lt;code&gt;ct_telnet.erl&lt;/code&gt;.</source>
          <target state="translated">대한 콜백 &lt;code&gt;ct_telnet.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e45c8484398e4aeac5267b27d0e1fb6f862e303" translate="yes" xml:space="preserve">
          <source>Callback function &lt;code&gt;TraverseFun&lt;/code&gt; is used for traversing the table. It is to return a list of objects terminated by either &lt;code&gt;[]&lt;/code&gt; or a nullary fun to be used for traversing the not yet traversed objects of the table. Any other return value is immediately returned as value of the query evaluation. Unary &lt;code&gt;TraverseFun&lt;/code&gt;s are to accept a match specification as argument. The match specification is created by the parse transform by analyzing the pattern of the generator calling &lt;code&gt;qlc:table/2&lt;/code&gt; and filters using variables introduced in the pattern. If the parse transform cannot find a match specification equivalent to the pattern and filters, &lt;code&gt;TraverseFun&lt;/code&gt; is called with a match specification returning every object.</source>
          <target state="translated">콜백 함수 &lt;code&gt;TraverseFun&lt;/code&gt; 은 테이블을 순회하는 데 사용됩니다. 아직 트래버스되지 않은 테이블의 개체를 순회하는 데 사용하기 위해 &lt;code&gt;[]&lt;/code&gt; 또는 널 (null) 재미로 종료 된 개체 목록을 반환 합니다. 다른 반환 값은 즉시 쿼리 평가 값으로 반환됩니다. 단항 &lt;code&gt;TraverseFun&lt;/code&gt; 은 일치 스펙을 인수로 승인해야합니다. 일치 스펙은 &lt;code&gt;qlc:table/2&lt;/code&gt; 를 호출하는 생성기의 패턴을 분석하고 패턴에 도입 된 변수를 사용하여 필터를 분석하여 구문 분석 변환에 의해 작성됩니다 . 구문 분석 변환이 패턴 및 필터와 동등한 일치 스펙을 찾을 수없는 경우 &lt;code&gt;TraverseFun&lt;/code&gt; 은 모든 오브젝트를 리턴하는 일치 스펙으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="04f9a377a5245adf1c0c727ef509b19ea04d764a" translate="yes" xml:space="preserve">
          <source>Callback functions</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="37556ac19058ca5c17bab63cd838a12f2880d206" translate="yes" xml:space="preserve">
          <source>Callback functions that are optional for the user of the behaviour to implement are specified by use of the &lt;code&gt;-optional_callbacks&lt;/code&gt; attribute:</source>
          <target state="translated">구현할 동작 사용자에게 선택적인 콜백 함수는 &lt;code&gt;-optional_callbacks&lt;/code&gt; 속성 을 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a04bb6692677302b06dcc4155d24ffed7a1d8b90" translate="yes" xml:space="preserve">
          <source>Callback invoked prior to terminating the transport process of a transport connection having watchdog state &lt;code&gt;OKAY&lt;/code&gt;. Applied to &lt;code&gt;application|service|transport&lt;/code&gt; and the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; in question: &lt;code&gt;application&lt;/code&gt; indicates that the diameter application is being stopped, &lt;code&gt;service&lt;/code&gt; that the service in question is being stopped by &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;transport&lt;/code&gt; that the transport in question is being removed by &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">워치 독 상태가 &lt;code&gt;OKAY&lt;/code&gt; 인 전송 연결의 전송 프로세스를 종료하기 전에 콜백이 호출되었습니다 . 에 적용 &lt;code&gt;application|service|transport&lt;/code&gt; 과 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;code&gt;diameter_app:peer()&lt;/code&gt;&lt;/code&gt; 문제 : &lt;code&gt;application&lt;/code&gt; , 직경 응용 프로그램이 중지되고 있음을 나타냅니다 &lt;code&gt;service&lt;/code&gt; 해당 서비스가 중지되고 있음을 &lt;code&gt;&lt;a href=&quot;#stop_service-1&quot;&gt;stop_service/1&lt;/a&gt;&lt;/code&gt; , 및 &lt;code&gt;transport&lt;/code&gt; 수송가 문제는 &lt;code&gt;&lt;a href=&quot;#remove_transport-2&quot;&gt;remove_transport/2&lt;/a&gt;&lt;/code&gt; 에 의해 제거되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="66eade566a1aabb00b9616d9f85c98561a92d0e8" translate="yes" xml:space="preserve">
          <source>Callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether or not the connection should be accepted. Applied to the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;#diameter_caps{}&lt;/code&gt; record of the connection.</source>
          <target state="translated">연결 허용 여부를 묻기 위해 기능 교환 중 CER / CEA 수신시 콜백이 호출되었습니다. 연결의 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 및 &lt;code&gt;#diameter_caps{}&lt;/code&gt; 레코드에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8170a9b43176c43c83ab38fea10e4e72c195d1f2" translate="yes" xml:space="preserve">
          <source>Callback module for &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">UNIX 호스트의 Telnet 서버에 연결하기 위한 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 의 콜백 모듈 .</target>
        </trans-unit>
        <trans-unit id="723d576b61f4090ef99d45ef635768456422a654" translate="yes" xml:space="preserve">
          <source>Callback module for ct_telnet, for connecting to a Telnet server on a UNIX host.</source>
          <target state="translated">UNIX 호스트의 Telnet 서버에 연결하기위한 ct_telnet의 콜백 모듈.</target>
        </trans-unit>
        <trans-unit id="c6227e8f008e1e3653b7695696953858c51a783a" translate="yes" xml:space="preserve">
          <source>Callback module for customized logging of errors, warnings, and info messages. The callback module must implement the &lt;code&gt;tftp_logger&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt;. The default module is &lt;code&gt;tftp_logger&lt;/code&gt;.</source>
          <target state="translated">오류, 경고 및 정보 메시지의 사용자 정의 로깅을위한 콜백 모듈. 콜백 모듈은 &lt;code&gt;tftp_logger&lt;/code&gt; 동작을 구현해야합니다 ( &lt;code&gt;&lt;a href=&quot;#tftp_logger&quot;&gt;LOGGER FUNCTIONS&lt;/a&gt;&lt;/code&gt; 참조) . 기본 모듈은 &lt;code&gt;tftp_logger&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac834d27797dbad127ce8fd6d8a2319b5f46c402" translate="yes" xml:space="preserve">
          <source>Callback module for users of the Megaco application</source>
          <target state="translated">Megaco 애플리케이션 사용자를위한 콜백 모듈</target>
        </trans-unit>
        <trans-unit id="55798c61abfa41a7a5297d6740d1e64b1d565485" translate="yes" xml:space="preserve">
          <source>Callback module in which messages of the Diameter application are handled. See &lt;code&gt;diameter_app(3)&lt;/code&gt; for the required interface and semantics.</source>
          <target state="translated">직경 응용 프로그램의 메시지가 처리되는 콜백 모듈. 필요한 인터페이스 및 시맨틱에 대해서는 &lt;code&gt;diameter_app(3)&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63edefe6aafdd040e89d039ff830e8a61ffa1b95" translate="yes" xml:space="preserve">
          <source>Callback modules for &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;gen_event&lt;/code&gt; can also change the value of &lt;code&gt;Misc&lt;/code&gt; by exporting a function &lt;code&gt;format_status/2&lt;/code&gt;, which contributes module-specific information. For details, see &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; 및 &lt;code&gt;gen_event&lt;/code&gt; 에 대한 콜백 모듈은 모듈 별 정보를 제공하는 &lt;code&gt;format_status/2&lt;/code&gt; 함수를 내보내 &lt;code&gt;Misc&lt;/code&gt; 의 값을 변경할 수도 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;gen_server#Module:format_status-2&quot;&gt;gen_server:format_status/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_statem#Module:format_status-2&quot;&gt;gen_statem:format_status/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;gen_event#Module:format_status-2&quot;&gt;gen_event:format_status/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a42e9b08e0786b523d53e7aaa69806b6b4c7c7b" translate="yes" xml:space="preserve">
          <source>Callback timeouts</source>
          <target state="translated">콜백 시간 초과</target>
        </trans-unit>
        <trans-unit id="1424d68bc26afe36f6e438d92e2344fe5359e183" translate="yes" xml:space="preserve">
          <source>Called after an asynchronous call has completed. The asynchronous call is started with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt;. This function is called from the Erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multi-threading is enabled).</source>
          <target state="translated">비동기 호출이 완료된 후 호출됩니다. 비동기 호출은 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_async&quot;&gt;erl_driver:driver_async&lt;/a&gt;&lt;/code&gt; 로 시작됩니다 . 이 함수는 일부 스레드에서 호출되는 비동기 함수와 달리 Erlang 에뮬레이터 스레드에서 호출됩니다 (멀티 스레딩이 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="308f76c161337017286f205aef3ab09cb6ea041d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the master-agent for primary processing.</source>
          <target state="translated">기본 메시지 처리 (MPD)가 완료된 후, 그러나 pdu가 1 차 처리를 위해 마스터 에이전트로 전달되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a313d3073d9eea56873be11a826fd840a7e0d86d" translate="yes" xml:space="preserve">
          <source>Called after the basic message processing (MPD) has been done, but before the pdu is handed over to the server for primary processing.</source>
          <target state="translated">MPD (Basic Message Processing)가 완료된 후, pdu가 1 차 처리를 위해 서버로 전달되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e5fe3aacb675f5586e55ac426e9e29a0553867e0" translate="yes" xml:space="preserve">
          <source>Called any time after the driver's timer reaches &lt;code&gt;0&lt;/code&gt;. The timer is activated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt;. No priorities or ordering exist among drivers, so if several drivers time out at the same time, anyone of them is called first.</source>
          <target state="translated">운전자 타이머가 &lt;code&gt;0&lt;/code&gt; 에 도달 한 후 언제든지 호출 됩니다. 타이머는 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_set_timer&quot;&gt;erl_driver:driver_set_timer&lt;/a&gt;&lt;/code&gt; 로 활성화됩니다 . 드라이버간에 우선 순위 나 순서가 없으므로 여러 드라이버가 동시에 시간 초과되면 해당 드라이버를 먼저 호출합니다.</target>
        </trans-unit>
        <trans-unit id="81eabbdc5601ceaa0bccb714043c53b451726d6f" translate="yes" xml:space="preserve">
          <source>Called at the reception of a message (before &lt;strong&gt;any&lt;/strong&gt; processing has been done).</source>
          <target state="translated">메시지의 수신시 호출 (이전에 &lt;strong&gt;어떤&lt;/strong&gt; 처리를 수행하고있다).</target>
        </trans-unit>
        <trans-unit id="bf59df7706e69db3cc159c1ee57e97f02070c14b" translate="yes" xml:space="preserve">
          <source>Called before the basic message processing (MPD) is done, when a pdu has been received from the master-agent.</source>
          <target state="translated">마스터 에이전트로부터 pdu를 수신하면 MPD (기본 메시지 처리)가 완료되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="67cc06ab5c5cdaf22f4e18059ff7135bed75b26e" translate="yes" xml:space="preserve">
          <source>Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; as part of its return value.</source>
          <target state="translated">재미가 등록 해제되기 전에 호출됩니다. 여기에서 모든 정리를 수행 할 수 있습니다. 반환 값은 중요하지 않지만 반환 값의 일부로 &lt;code&gt;clear_crypto_key_fun/0&lt;/code&gt; 호출자에게 다시 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="60cc53ceda191e4c7c43073a2ca95d2429376ca7" translate="yes" xml:space="preserve">
          <source>Called before the sending of a message (after &lt;strong&gt;all&lt;/strong&gt; processing has been done).</source>
          <target state="translated">메시지를 보내기 전에 호출합니다 ( &lt;strong&gt;모든&lt;/strong&gt; 처리가 완료된 후 ).</target>
        </trans-unit>
        <trans-unit id="411e859542f736dac045f8721e0a466752068640" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;Host&lt;/code&gt; defaults to the localhost. Returns the names and associated port numbers of the Erlang nodes that &lt;code&gt;epmd&lt;/code&gt; registered at the specified host. Returns &lt;code&gt;{error, address}&lt;/code&gt; if &lt;code&gt;epmd&lt;/code&gt; is not operational.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;net_adm&quot;&gt;net_adm:names/0&lt;/a&gt;&lt;/code&gt; 에 의해 호출됩니다 . &lt;code&gt;Host&lt;/code&gt; 기본적으로 localhost입니다. 지정된 호스트에 &lt;code&gt;epmd&lt;/code&gt; 가 등록한 Erlang 노드의 이름과 관련 포트 번호를 반환합니다 . 반환 &lt;code&gt;{error, address}&lt;/code&gt; 경우 &lt;code&gt;epmd&lt;/code&gt; 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="754186ab8b7082c0674d04f3bdaf7fcddc1ab3a3" translate="yes" xml:space="preserve">
          <source>Called by the &lt;code&gt;erl_ddll&lt;/code&gt; driver when the driver is unloaded. (It is only called in dynamic drivers.)</source>
          <target state="translated">드라이버가 언로드 될 때 &lt;code&gt;erl_ddll&lt;/code&gt; 드라이버에 의해 호출됩니다 . (동적 드라이버에서만 호출됩니다.)</target>
        </trans-unit>
        <trans-unit id="650a5975977f531507f62d29a2ce95a7a1cfb83f" translate="yes" xml:space="preserve">
          <source>Called by the distribution module. Resolves the &lt;code&gt;Host&lt;/code&gt; to an IP address.</source>
          <target state="translated">배포 모듈에서 호출합니다. 해결 &lt;code&gt;Host&lt;/code&gt; 의 IP 주소를.</target>
        </trans-unit>
        <trans-unit id="e6e67ee5139f5c3d24c6add77615125e4e640a01" translate="yes" xml:space="preserve">
          <source>Called directly after the driver has been loaded by &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; (actually when the driver is added to the driver list). The driver is to return &lt;code&gt;0&lt;/code&gt;, or, if the driver cannot initialize, &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; 에 의해 드라이버가로드 된 직후에 호출됩니다 (실제로 드라이버가 드라이버 목록에 추가 될 때). 드라이버는 &lt;code&gt;0&lt;/code&gt; 을 반환 하거나 드라이버를 초기화 할 수없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="262d7b78c6487d8a39946866f1d11a39d5496a09" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to continue its execution (for example, after it has been suspended). This function never returns.</source>
          <target state="translated">프로세스가 실행을 계속할 때 (예 : 일시 중단 된 후) &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . 이 함수는 절대 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73172cc1a7cb2d69c85f4a96da6765b4101ba755" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to perform a code change. The code change is used when the internal data structure has changed. This function converts argument &lt;code&gt;Misc&lt;/code&gt; to the new data structure. &lt;code&gt;OldVsn&lt;/code&gt; is attribute &lt;strong&gt;vsn&lt;/strong&gt; of the old version of the &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the atom &lt;code&gt;undefined&lt;/code&gt; is sent.</source>
          <target state="translated">프로세스가 코드 변경을 수행 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . 내부 데이터 구조가 변경되면 코드 변경이 사용됩니다. 이 함수는 &lt;code&gt;Misc&lt;/code&gt; 인수 를 새로운 데이터 구조 로 변환 합니다. &lt;code&gt;OldVsn&lt;/code&gt; 은 이전 버전의 &lt;code&gt;Module&lt;/code&gt; 에 대한 속성 &lt;strong&gt;vsn&lt;/strong&gt; 입니다 . 그러한 속성이 정의되어 있지 않으면 정의 &lt;code&gt;undefined&lt;/code&gt; 아톰 이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="594143f9a65ae1c6fe10c4f338068b8a9f905601" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to replace its current state. &lt;code&gt;NState&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 현재 상태를 교체 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . &lt;code&gt;NState&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#replace_state-3&quot;&gt;replace_state/3&lt;/a&gt;&lt;/code&gt; 가 반환 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="d9b3e834b715a254168526e411e95a8a48713b20" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to return a term that reflects its current state. &lt;code&gt;State&lt;/code&gt; is the value returned by &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스가 현재 상태를 반영하는 용어를 리턴 할 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출됩니다 . &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#get_state-2&quot;&gt;get_state/2&lt;/a&gt;&lt;/code&gt; 가 반환 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="e4c98925793456e56a2d33122eb6a311fa293f3d" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; when the process is to terminate. For example, this function is called when the process is suspended and its parent orders shutdown. It gives the process a chance to do a cleanup. This function never returns.</source>
          <target state="translated">프로세스가 종료 될 때 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 에서 호출 됩니다. 예를 들어,이 기능은 프로세스가 일시 중단되고 상위 주문이 종료 될 때 호출됩니다. 프로세스가 정리를 수행 할 수있는 기회를 제공합니다. 이 함수는 절대 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee779128abb96dcaaa77c4845eb5b58fcbdf4ab2" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt;. It works a lot like the &lt;code&gt;control&lt;/code&gt; callback, but uses the external term format for input and output.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#port_call-3&quot;&gt;erlang:port_call/3&lt;/a&gt;&lt;/code&gt; 에서 호출합니다 . &lt;code&gt;control&lt;/code&gt; 콜백 과 매우 유사 하지만 입력 및 출력에 외부 용어 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eda5333bad3b8e6536c6e400a545bf0c68561f86" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:open_port/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:open_port/2&lt;/code&gt; 에서 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="52c95806576ffd5c6e9bda3738995849c83e6d48" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_call/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:port_call/3&lt;/code&gt; 에서 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="37967ef10d51ab9623c55cce347e8ac82ffaa69f" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:port_control/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:port_control/3&lt;/code&gt; 에서 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="76a9c293f08a9964ffe8949415ea15fcd479022c" translate="yes" xml:space="preserve">
          <source>Called from &lt;code&gt;erlang:send/2&lt;/code&gt; and &lt;code&gt;erlang:port_command/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:send/2&lt;/code&gt; 및 &lt;code&gt;erlang:port_command/2&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b7712d2af65521477e16f6013575117d34b96c0" translate="yes" xml:space="preserve">
          <source>Called in order to close the &lt;code&gt;Listen&lt;/code&gt; handle that originally was passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback.</source>
          <target state="translated">원래 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 콜백 에서 전달 된 &lt;code&gt;Listen&lt;/code&gt; 핸들 을 닫기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="470a1c0ce98f90a6c63285d61ce7082f47f6706f" translate="yes" xml:space="preserve">
          <source>Called on behalf of &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; when it is safe to close an event object.</source>
          <target state="translated">이벤트 객체를 닫는 것이 안전 할 때 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_select&quot;&gt;erl_driver:driver_select&lt;/a&gt;&lt;/code&gt; 를 대신하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="23ff0ae2399ea44f77132823a27ee56494ae7347" translate="yes" xml:space="preserve">
          <source>Called to instruct the manager that this agent shall be handled. This function is used when the user knows in advance which agents the manager shall handle. Note that there is an alternate way to do the same thing: Add the agent to the manager config files (see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 에이전트를 처리하도록 관리자에게 지시하기 위해 호출됩니다. 이 기능은 사용자가 관리자가 처리 할 에이전트를 미리 알고있을 때 사용됩니다. 동일한 작업을 수행하는 다른 방법이 있습니다. 에이전트를 관리자 구성 파일에 추가하십시오 ( &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#agents&quot;&gt;agents.conf&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2c4e12b2b87e916464a480eeba6c90e011990c07" translate="yes" xml:space="preserve">
          <source>Called when a driver event (specified in parameter &lt;code&gt;event&lt;/code&gt;) is signaled. This is used to help asynchronous drivers &quot;wake up&quot; when something occurs.</source>
          <target state="translated">드라이버 이벤트 (매개 변수 &lt;code&gt;event&lt;/code&gt; 에 지정 )가 신호를 받으면 호출됩니다 . 이것은 무언가 발생했을 때 비동기 드라이버가 &quot;일어나도록&quot;돕는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f6a024fd8f77a2ea9867d6adcf09937e5b321e" translate="yes" xml:space="preserve">
          <source>Called when a monitored process exits. The &lt;code&gt;drv_data&lt;/code&gt; is the data associated with the port for which the process is monitored (using &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt;) and the &lt;code&gt;monitor&lt;/code&gt; corresponds to the &lt;code&gt;ErlDrvMonitor&lt;/code&gt; structure filled in when creating the monitor. The driver interface function &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; can be used to retrieve the process ID of the exiting process as an &lt;code&gt;ErlDrvTermData&lt;/code&gt;.</source>
          <target state="translated">모니터링 된 프로세스가 종료 될 때 호출됩니다. &lt;code&gt;drv_data&lt;/code&gt; 는 (사용하는 프로세스 모니터링하는 포트와 연관된 데이터이다 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_monitor_process&quot;&gt;erl_driver:driver_monitor_process&lt;/a&gt;&lt;/code&gt; )와 &lt;code&gt;monitor&lt;/code&gt; 에 해당합니다 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 의 모니터를 만들 때 충전 구조. 함수 인터페이스 드라이버 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_get_monitored_process&quot;&gt;erl_driver:driver_get_monitored_process&lt;/a&gt;&lt;/code&gt; 는 AS를 유출되는 프로세스의 프로세스 ID 검색하는 데 사용할 수 &lt;code&gt;ErlDrvTermData&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="d67e2aa0c472d7e1f331918d874d82a46a103385" translate="yes" xml:space="preserve">
          <source>Called when a port is closed.</source>
          <target state="translated">포트가 닫힐 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9f79f35f10e231c1c5d46754dcc831f0124571c5" translate="yes" xml:space="preserve">
          <source>Called when an Erlang process has sent data to the port. The data is pointed to by &lt;code&gt;buf&lt;/code&gt;, and is &lt;code&gt;len&lt;/code&gt; bytes. Data is sent to the port with &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; or with &lt;code&gt;erlang:port_command/2&lt;/code&gt;. Depending on how the port was opened, it is to be either a list of integers &lt;code&gt;0...255&lt;/code&gt; or a binary. See &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 프로세스가 포트로 데이터를 보냈을 때 호출됩니다. 데이터는이 가리키는 &lt;code&gt;buf&lt;/code&gt; , 및 &lt;code&gt;len&lt;/code&gt; 바이트. 데이터는 &lt;code&gt;Port ! {self(), {command, Data}}&lt;/code&gt; 를 사용하여 포트로 전송됩니다 . {자기 () {명령, 데이터}} 이상에서 &lt;code&gt;erlang:port_command/2&lt;/code&gt; . 포트가 열린 방법에 따라, 정수 &lt;code&gt;0...255&lt;/code&gt; 또는 이진 목록이 됩니다. &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;erlang#port_command-2&quot;&gt;erlang:port_command/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fefd076009119dd92492aabc22699c37cd1acfde" translate="yes" xml:space="preserve">
          <source>Called when document has been completely parsed.</source>
          <target state="translated">문서가 완전히 파싱되었을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d5c990ed44bfe60f747ede5eb6362b963aa6ee" translate="yes" xml:space="preserve">
          <source>Called when it is possible to write to a socket.</source>
          <target state="translated">소켓에 쓸 수있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ea08619d53f9130eaa9e346bb5fa5aec56010fde" translate="yes" xml:space="preserve">
          <source>Called when the driver is instantiated, when &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; is called. The driver is to return a number &amp;gt;= 0 or a pointer, or, if the driver cannot be started, one of three error codes:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 가 호출 될 때 드라이버가 인스턴스화 될 때 호출됩니다 . 드라이버는 숫자&amp;gt; = 0 또는 포인터를 반환하거나 드라이버를 시작할 수없는 경우 다음 세 가지 오류 코드 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c7878482ce6f10c4027034352ce73f5aaa4ce9cf" translate="yes" xml:space="preserve">
          <source>Called when the driver is unloaded. A distribution driver will never be unloaded, but we include this for completeness. To be able to clean up after oneself is always a good thing.</source>
          <target state="translated">드라이버가 언로드 될 때 호출됩니다. 배포 드라이버는 언로드되지 않지만 완전성을 위해 이것을 포함합니다. 자신을 정리 한 후에는 항상 좋은 일입니다.</target>
        </trans-unit>
        <trans-unit id="e9777a1b7d37a6943bc53bf03a6d0e91d50d751f" translate="yes" xml:space="preserve">
          <source>Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; is returned, &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; is registered instead of &lt;code&gt;CryptoKeyFun&lt;/code&gt;. If &lt;code&gt;{error, Term}&lt;/code&gt; is returned, the registration is aborted and &lt;code&gt;crypto_key_fun/1&lt;/code&gt; also returns &lt;code&gt;{error, Term}&lt;/code&gt;.</source>
          <target state="translated">재미가있는 프로세스에서 재미가 등록 될 때 호출됩니다. 여기서 암호 키 재미는 필요한 초기화를 수행 할 수 있습니다. 경우 &lt;code&gt;{ok, NewCryptoKeyFun}&lt;/code&gt; 반환되고, &lt;code&gt;NewCryptoKeyFun&lt;/code&gt; 는 대신 등록 &lt;code&gt;CryptoKeyFun&lt;/code&gt; . 경우 &lt;code&gt;{error, Term}&lt;/code&gt; 반환, 등록이 중단되고 &lt;code&gt;crypto_key_fun/1&lt;/code&gt; 도 반환 &lt;code&gt;{error, Term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ad7a8527ae38bbbd2d4e06002457415af632b3" translate="yes" xml:space="preserve">
          <source>Called when the key is needed for module &lt;code&gt;Module&lt;/code&gt; in the file named &lt;code&gt;Filename&lt;/code&gt;. &lt;code&gt;Mode&lt;/code&gt; is the type of crypto algorithm; currently, the only possible value is &lt;code&gt;des3_cbc&lt;/code&gt;. The call is to fail (raise an exception) if no key is available.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 이라는 파일 에서 모듈 &lt;code&gt;Module&lt;/code&gt; 에 키가 필요할 때 호출됩니다 . &lt;code&gt;Mode&lt;/code&gt; 는 암호화 알고리즘의 유형입니다. 현재 가능한 유일한 값은 &lt;code&gt;des3_cbc&lt;/code&gt; 입니다. 사용 가능한 키가 없으면 호출이 실패합니다 (예외 발생).</target>
        </trans-unit>
        <trans-unit id="0dcbf03fb42831c6723cb1715f47765453867f67" translate="yes" xml:space="preserve">
          <source>Called when the port is about to be closed, and there is data in the driver queue that must be flushed before 'stop' can be called.</source>
          <target state="translated">포트를 닫으려고 할 때 호출되며 '중지'를 호출하기 전에 플러시해야하는 데이터가 드라이버 큐에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8919d79f584bde48131fa0a13624f5f0b5dd1e5e" translate="yes" xml:space="preserve">
          <source>Called when the port is closed, with &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;Port ! {self(), close}&lt;/code&gt;. Notice that terminating the port owner process also closes the port. If &lt;code&gt;drv_data&lt;/code&gt; is a pointer to memory allocated in &lt;code&gt;start&lt;/code&gt;, then &lt;code&gt;stop&lt;/code&gt; is the place to deallocate that memory.</source>
          <target state="translated">포트가 닫히면 &lt;code&gt;&lt;a href=&quot;erlang#port_close-1&quot;&gt;erlang:port_close/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;Port ! {self(), close}&lt;/code&gt; 입니다. 포트 소유자 프로세스를 종료하면 포트가 닫힙니다. 경우 &lt;code&gt;drv_data&lt;/code&gt; 가 에 할당 된 메모리에 대한 포인터로 &lt;code&gt;start&lt;/code&gt; , 다음 &lt;code&gt;stop&lt;/code&gt; 이 메모리 할당을 해제 할 수있는 장소입니다.</target>
        </trans-unit>
        <trans-unit id="bce5d5b2decf756f58e8642c565207befb9d1e4c" translate="yes" xml:space="preserve">
          <source>Called when there is something to read from a socket.</source>
          <target state="translated">소켓에서 읽을 것이있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cb06eda8927a232da24c20e732e3e2949f2b101f" translate="yes" xml:space="preserve">
          <source>Called whenever the port is written to. If it is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;output&lt;/code&gt; function is called instead. This function is faster than &lt;code&gt;output&lt;/code&gt;, as it takes an &lt;code&gt;ErlIOVec&lt;/code&gt; directly, which requires no copying of the data. The port is to be in binary mode, see &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트가 쓰여질 때마다 호출됩니다. &lt;code&gt;NULL&lt;/code&gt; 인 경우 대신 &lt;code&gt;output&lt;/code&gt; 함수가 호출됩니다. 이 함수는 &lt;code&gt;ErlIOVec&lt;/code&gt; 을 직접 가져 오기 때문에 &lt;code&gt;output&lt;/code&gt; 보다 빠르 므로 데이터를 복사 할 필요가 없습니다. 포트는 이진 모드에 있습니다 ( &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="8c4da0ebceae11eff6b7919b2ddd46f27587b04d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; with a string argument still produces a crash dump. On Unix systems, sending an emulator process a &lt;code&gt;SIGUSR1&lt;/code&gt; signal also forces a crash dump.</source>
          <target state="translated">문자열 인수로 &lt;code&gt;&lt;a href=&quot;erlang#halt-1&quot;&gt;erlang:halt/1&lt;/a&gt;&lt;/code&gt; 을 호출 하면 여전히 크래시 덤프가 생성됩니다. Unix 시스템에서 &lt;code&gt;SIGUSR1&lt;/code&gt; 신호를 에뮬레이터 프로세스로 보내면 크래시 덤프가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="655a22092d77d88145d5c50ca50e242cddc91b3d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; is equivalent to the following, but more efficient:</source>
          <target state="translated">&lt;code&gt;demonitor(MonitorRef, [flush])&lt;/code&gt; 호출 은 다음과 같지만보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="8abf86e315d47dada23e450fdd1a6d2f9ae320c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time()&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time()&lt;/code&gt; 호출 은 &lt;code&gt;&lt;a href=&quot;#monotonic_time-0&quot;&gt;erlang:monotonic_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b083a75a2460c0a8048c36cd9fefa43e466519e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:system_time(Unit)&lt;/code&gt; 호출 은 &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt;erlang:convert_time_unit&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;erlang:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac8161866033e5fba00c9f967a358dd87e252b77" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;merl:print(Call)&lt;/code&gt; will then print the following code:</source>
          <target state="translated">호출 &lt;code&gt;merl:print(Call)&lt;/code&gt; 다음 코드를 인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="2cedca3701bb5e353b3d951a1078a1fe4f284c28" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;os:system_time(Unit)&lt;/code&gt; is equivalent to &lt;code&gt;erlang:convert_time_unit&lt;/code&gt;(&lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;, native, Unit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os:system_time(Unit)&lt;/code&gt; 호출 은 &lt;code&gt;erlang:convert_time_unit&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;os:system_time()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;, native, Unit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afeabfe36eaf236b85f9317a022e3a32b2c67b0d" translate="yes" xml:space="preserve">
          <source>Calling and applying a fun does not involve any hash-table lookup. A fun contains an (indirect) pointer to the function that implements the fun.</source>
          <target state="translated">재미를 부르고 적용하는 것은 해시 테이블 조회를 포함하지 않습니다. 재미는 재미를 구현하는 함수에 대한 (간접) 포인터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="90124b2b5c5e8b577f502d3a36088e606891a366" translate="yes" xml:space="preserve">
          <source>Calling or applying a fun (&lt;code&gt;Fun()&lt;/code&gt;, &lt;code&gt;apply(Fun, [])&lt;/code&gt;) is about &lt;strong&gt;three times&lt;/strong&gt; as expensive as calling a local function.</source>
          <target state="translated">&lt;code&gt;Fun()&lt;/code&gt; , &lt;code&gt;apply(Fun, [])&lt;/code&gt; 호출하거나 적용하는 것은 로컬 함수를 호출하는 것 &lt;strong&gt;보다&lt;/strong&gt; 약 &lt;strong&gt;3 배&lt;/strong&gt; 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="4977f905b190f9bbe202e2e85576e00836e9734e" translate="yes" xml:space="preserve">
          <source>Calling the function with &lt;code&gt;{MonitorPid, Options}&lt;/code&gt; as argument is the same as calling &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{MonitorPid, Options}&lt;/code&gt; 를 인수로 사용하여 함수를 호출하는 것은 &lt;code&gt;&lt;a href=&quot;#system_monitor-2&quot;&gt;erlang:system_monitor(MonitorPid,Options)&lt;/a&gt;&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4b42cc7ad99418c1a03de8a69add23747a547065" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing all the integer()'s and string()'s provided, as well as any user tag set in the current process.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되어 제공된 모든 integer () 및 string () 및 현재 프로세스에 설정된 모든 사용자 태그를 포함하는 추적 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="444f79602e491b38e25cb8c13003f56f8345ff63" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer or string parameter in the first integer/string field.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되어 첫 번째 정수 / 문자열 필드에 사용자 태그와 정수 또는 문자열 매개 변수가 포함 된 추적 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ca84bd13b57ed20dc137036dea97bc867dd9acff" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters, as in &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되고 각 유형의 첫 번째 필드로 user 태그 및 integer () 또는 string () 매개 변수를 포함하는 추적 메시지가 전송됩니다. &lt;code&gt;&lt;a href=&quot;#p-2&quot;&gt;p/2&lt;/a&gt;&lt;/code&gt; 와 같이 integer () 매개 변수는 string () 매개 변수 앞에 놓아야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d6504b8ed29fe9b52bfa13411a0abbd154f8e3e" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message containing the user tag and the integer() or string() parameters as the first fields of respective type. integer() parameters should be put before any string() parameters. I.e. &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; is ok, as is &lt;code&gt;p(1,1)&lt;/code&gt; and &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt;, but not &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되고 각 유형의 첫 번째 필드로 user 태그 및 integer () 또는 string () 매개 변수를 포함하는 추적 메시지가 전송됩니다. integer () 매개 변수는 string () 매개 변수 앞에 놓아야합니다. 즉 &lt;code&gt;p(1,&quot;Hello&quot;)&lt;/code&gt; 는 &lt;code&gt;p(1,1)&lt;/code&gt; 및 &lt;code&gt;p(&quot;Hello&quot;,&quot;Again&quot;)&lt;/code&gt; 과 같이 괜찮지 만 &lt;code&gt;p(&quot;Hello&quot;,1)&lt;/code&gt; 는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ba80ef3622f6d7266790c78fbbdd6b4544d6f3ea" translate="yes" xml:space="preserve">
          <source>Calling this function will trigger the &quot;user&quot; trace probe user_trace_i4s4 in the dyntrace NIF module, sending a trace message only containing the user tag and zeroes/empty strings in all other fields.</source>
          <target state="translated">이 함수를 호출하면 dyntrace NIF 모듈에서 &quot;user&quot;추적 프로브 user_trace_i4s4가 트리거되어 다른 모든 필드의 사용자 태그와 0 / 빈 문자열 만 포함하는 추적 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fc31c095d153129fc853cf06c728a75bf3b46c60" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; with the same arguments and filters the result, so &lt;code&gt;Opts&lt;/code&gt; is described for those functions.</source>
          <target state="translated">동일한 인수로 &lt;code&gt;&lt;a href=&quot;#resolve-3&quot;&gt;resolve/*&lt;/a&gt;&lt;/code&gt; 를 호출 하고 결과를 필터링하므로 해당 기능에 대해 &lt;code&gt;Opts&lt;/code&gt; 가 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="64e4f69ad9125f63ba8df8f7d7d250f3cecda4ae" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; for every &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/3&lt;/code&gt; must return a new accumulator, which is passed to the next successive call. This function returns the final value of the accumulator. The initial accumulator value &lt;code&gt;Init&lt;/code&gt; is returned if the map is empty.</source>
          <target state="translated">매 순서대로 &lt;code&gt;MapOrIter&lt;/code&gt; 에서 &lt;code&gt;V&lt;/code&gt; 연관을 평가 하기 위해 모든 &lt;code&gt;K&lt;/code&gt; 에 대해 &lt;code&gt;F(K, V, AccIn)&lt;/code&gt; 를 호출 합니다. 기능 &lt;code&gt;fun F/3&lt;/code&gt; 는 다음 누적 호출로 전달되는 새 누산기를 반환해야합니다. 이 함수는 누산기의 최종 값을 반환합니다. 맵이 비어 있으면 초기 누산기 값 &lt;code&gt;Init&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4295c8a20ece7cf06d43d6ebf25e275c406c6e5f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; for each element &lt;code&gt;Elem&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt;. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; 의 각 요소 &lt;code&gt;Elem&lt;/code&gt; 에 대해 &lt;code&gt;Fun(Elem)&lt;/code&gt; 을 호출 합니다. 이 기능은 부작용에 사용되며 평가 순서는 목록의 요소 순서와 동일하도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="63f2bd2bc7b570ff8e3f588bc3a35e7f39bb021c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem)&lt;/code&gt; on successive elements &lt;code&gt;Elem&lt;/code&gt; of &lt;code&gt;List1&lt;/code&gt;. &lt;code&gt;Fun/1&lt;/code&gt; must return either a Boolean or a tuple &lt;code&gt;{true, Value}&lt;/code&gt;. The function returns the list of elements for which &lt;code&gt;Fun&lt;/code&gt; returns a new value, where a value of &lt;code&gt;true&lt;/code&gt; is synonymous with &lt;code&gt;{true, Elem}&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;Fun(Elem)&lt;/code&gt; 연속적인 요소에 &lt;code&gt;Elem&lt;/code&gt; 모델 의 &lt;code&gt;List1&lt;/code&gt; 입니다 . &lt;code&gt;Fun/1&lt;/code&gt; 은 부울 또는 튜플 &lt;code&gt;{true, Value}&lt;/code&gt; 반환해야합니다 . 이 함수는 &lt;code&gt;Fun&lt;/code&gt; 이 새 값을 리턴하는 요소 목록을 리턴합니다. 여기서 &lt;code&gt;true&lt;/code&gt; 값은 &lt;code&gt;{true, Elem}&lt;/code&gt; 과 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="50d89c32ea4d0c6ee1b26f9c66ad9e11c8879726" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements &lt;code&gt;A&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">통화 &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; 가 연속 한 요소에 의 &lt;code&gt;List&lt;/code&gt; 을 시작으로 &lt;code&gt;AccIn == Acc0&lt;/code&gt; . &lt;code&gt;Fun/2&lt;/code&gt; 는 새 어큐뮬레이터를 반환해야하며, 다음 어큐뮬레이터로 전달됩니다. 이 함수는 누산기의 최종 값을 반환합니다. 목록이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d14f785e84c0e45ac023a87056c299dcc94c604" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; on successive elements of the cache, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;. &lt;code&gt;Fun/2&lt;/code&gt; must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. &lt;code&gt;Acc0&lt;/code&gt; is returned if the cache is empty.</source>
          <target state="translated">호출 &lt;code&gt;Fun(Elem, AccIn)&lt;/code&gt; 로 시작하는 캐시의 연속적인 요소에 &lt;code&gt;AccIn == Acc0&lt;/code&gt; . &lt;code&gt;Fun/2&lt;/code&gt; 는 새 어큐뮬레이터를 반환해야하며, 다음 어큐뮬레이터로 전달됩니다. 이 함수는 누산기의 최종 값을 반환합니다. 캐시가 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d85b7bf8f7b8acf4c9a5d164bbe2b412bc74ce98" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; on successive files in the &lt;code&gt;Archive&lt;/code&gt;, starting with &lt;code&gt;AccIn == Acc0&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;Fun(FileInArchive, GetInfo, GetBin, AccIn)&lt;/code&gt; 의 연속 파일에 &lt;code&gt;Archive&lt;/code&gt; 를 시작으로 &lt;code&gt;AccIn == Acc0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb1b12376680c06a8dcd6a14c87f88b97c0f362" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict1&lt;/code&gt; tvo return a new value for each key.</source>
          <target state="translated">연속 키에 대한 &lt;code&gt;Fun&lt;/code&gt; 호출 및 &lt;code&gt;Orddict1&lt;/code&gt; tvo의 값은 각 키에 대해 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41cc957320ee93c3d6a8d2c0cf887c390c051f0c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of &lt;code&gt;Orddict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the list is empty.</source>
          <target state="translated">추가 인수 &lt;code&gt;Acc&lt;/code&gt; 와 함께 &lt;code&gt;Orddict&lt;/code&gt; 의 연속 키 및 값에 대해 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 (누산기의 약어). &lt;code&gt;Fun&lt;/code&gt; 는 다음 호출로 전달되는 새 누산기를 반환해야합니다. 목록이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db2c15c0e80df0b70d2a4c08c9328f07d292a334" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict1&lt;/code&gt; to return a new value for each key. The evaluation order is undefined.</source>
          <target state="translated">연속되는 키와 사전 &lt;code&gt;Dict1&lt;/code&gt; 의 값에 대해 &lt;code&gt;Fun&lt;/code&gt; 을 호출 하여 각 키에 대한 새 값을 반환합니다. 평가 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51e98c878f8461c82b19b807000534c1ee895d35" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Fun&lt;/code&gt; on successive keys and values of dictionary &lt;code&gt;Dict&lt;/code&gt; together with an extra argument &lt;code&gt;Acc&lt;/code&gt; (short for accumulator). &lt;code&gt;Fun&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the dictionary is empty. The evaluation order is undefined.</source>
          <target state="translated">추가 인수 &lt;code&gt;Acc&lt;/code&gt; 와 함께 사전 &lt;code&gt;Dict&lt;/code&gt; 의 연속 키와 값에 대해 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 (누산기의 약어). &lt;code&gt;Fun&lt;/code&gt; 는 다음 호출로 전달되는 새 누산기를 반환해야합니다. 사전이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다. 평가 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e38b9bc9aa02fa070ce4650030edfd32a81b7dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive answers to the query handle together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The query handle and the function are evaluated in the calling process. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator, which is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if there are no answers to the query handle.</source>
          <target state="translated">추가 인수 &lt;code&gt;AccIn&lt;/code&gt; 과 함께 쿼리 핸들에 대한 연속적인 응답에 대해 &lt;code&gt;Function&lt;/code&gt; 를 호출 합니다. 쿼리 핸들과 함수는 호출 프로세스에서 평가됩니다. &lt;code&gt;Function&lt;/code&gt; 는 다음 누산으로 전달되는 새 누산기를 반환해야합니다. 쿼리 핸들에 대한 답변이 없으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="411261c708a55893631cad145cf652a3f25bc6dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Function&lt;/code&gt; on successive elements of table &lt;code&gt;Name&lt;/code&gt; together with an extra argument &lt;code&gt;AccIn&lt;/code&gt;. The table elements are traversed in unspecified order. &lt;code&gt;Function&lt;/code&gt; must return a new accumulator that is passed to the next call. &lt;code&gt;Acc0&lt;/code&gt; is returned if the table is empty.</source>
          <target state="translated">추가 인수 &lt;code&gt;AccIn&lt;/code&gt; 과 함께 테이블 &lt;code&gt;Name&lt;/code&gt; 의 연속 요소에 대한 &lt;code&gt;Function&lt;/code&gt; 를 호출 합니다. 테이블 요소는 지정되지 않은 순서로 순회됩니다. &lt;code&gt;Function&lt;/code&gt; 는 다음 호출로 전달되는 새 누산기를 반환해야합니다. 테이블이 비어 있으면 &lt;code&gt;Acc0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e4d0f89deb9513a8ea8d66e61b19ec50cb6a197f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; surrounded by &lt;code&gt;trace([start, ...])&lt;/code&gt; and &lt;code&gt;trace(stop)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace([start, ...])&lt;/code&gt; 및 &lt;code&gt;trace(stop)&lt;/code&gt; 둘러싸인 &lt;code&gt;erlang:apply(Func, Args)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c8e905cfa5d08f37d1d656135714c1381b168281" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt;, where &lt;code&gt;AccessMod&lt;/code&gt; is the default access callback module obtained by &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt;. &lt;code&gt;Args&lt;/code&gt; defaults to &lt;code&gt;[]&lt;/code&gt; (empty list).</source>
          <target state="translated">통화 &lt;code&gt;mnesia:activity(AccessContext, Fun, Args, AccessMod)&lt;/code&gt; , &lt;code&gt;AccessMod&lt;/code&gt; 이 얻을 기본 액세스 콜백 모듈입니다 &lt;code&gt;mnesia:system_info(access_module)&lt;/code&gt; . &lt;code&gt;Args&lt;/code&gt; 의 기본값은 &lt;code&gt;[]&lt;/code&gt; (빈 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="7ba5ad987837e04f29a6e17ab4165c3bf8a13ef5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:async_dirty(Fun, Args)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ffcbed2136c4dbb9cb540ca3e3bb945d48a84489" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete(Tab, Key, write)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6cd2ad960a91e2c7b84aad8b8cab2b4af89af1d4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete_object(Tab, Record, write)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b1619836284281d3b4ace7f8138860d37a317d20" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_delete(Tab, Key)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f7eff8e0d0f21895a3712d8b82ab68aad9ff93c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_delete_object(Tab, Record)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b968f64643fdd3ef4196ca7f2353074d34a25592" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_match_object(Tab, Pattern)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Pattern)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc9bba8191f80d74baf71dc1c6ce5482c73891a5" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_read(Tab, Key)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="672698b739738396e1aaa279f1425416fa4ed4d3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_update_counter(Tab, Key, Incr)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f15de5c4989490ba445d84120b63ae4fef3a10da" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:dirty_write(Tab, Record)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a49f85d237c7a52c5025bd7a45bcefecee838aed" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:ets(Fun, Args)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d1e1b27f2b3d32c30f1a9af2546f7ff28be30d84" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Args&lt;/code&gt; 는 &lt;code&gt;[{scope, global}, {module, BackupMod}]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="adefbd4d29b6f99f9c5284fcea99a93af40e2354" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is &lt;code&gt;[{scope, global}]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:install_fallback(Opaque, Args)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Args&lt;/code&gt; 는 &lt;code&gt;[{scope, global}]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6371048f46424da76665133d09722d29e17eb95d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Pattern)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:match_object(Tab, Pattern, read)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Pattern)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="506bd136b0f38c6b5c4e9aba7994479cbf8607c2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:sync_dirty(Fun, Args)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4768e4194eaa19668e98e8297432714da38f80fe" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">&lt;code&gt;mnesia:sync_transaction(Fun, Args, Retries)&lt;/code&gt; 호출 합니다. 트랜잭션이 성공하면 (원자) &lt;code&gt;Fun&lt;/code&gt; 의 결과 가 리턴되고 그렇지 않으면 중단 이유로 함수가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f4238a5e661c7a2d85c9a77b9854e4b9f7ca29a9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt;. Notice that the result from &lt;code&gt;Fun&lt;/code&gt; is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</source>
          <target state="translated">&lt;code&gt;mnesia:transaction(Fun, Args, Retries)&lt;/code&gt; 호출 합니다. 트랜잭션이 성공하면 (원자) &lt;code&gt;Fun&lt;/code&gt; 의 결과 가 리턴되고 그렇지 않으면 중단 이유로 함수가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4bef8126b535186f1c6f440c4f89eb4f6b6acd97" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt;, where &lt;code&gt;RecName&lt;/code&gt; is &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)&lt;/code&gt; 호출 합니다. 여기서 &lt;code&gt;RecName&lt;/code&gt; 은 &lt;code&gt;mnesia:table_info(Tab, record_name)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f8dac520c4ed465440262ceedf36f6b5ee392b4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;names(Host)&lt;/code&gt; for all hosts that are specified in the Erlang host file &lt;code&gt;.hosts.erlang&lt;/code&gt;, collects the replies, and then evaluates &lt;code&gt;ping(Node)&lt;/code&gt; on all those nodes. Returns the list of all nodes that are successfully pinged.</source>
          <target state="translated">Erlang 호스트 파일 &lt;code&gt;.hosts.erlang&lt;/code&gt; 에 지정된 모든 호스트에 대해 &lt;code&gt;names(Host)&lt;/code&gt; 를 호출 하고 응답을 수집 한 다음 모든 해당 노드에서 &lt;code&gt;ping(Node)&lt;/code&gt; 을 평가 합니다. 성공적으로 핑된 모든 노드의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f89caf1a58d70de4bc1545d4d2c63f722e1134d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt;. If you want to start a node from the command line and set up a number of pseudo servers, an Erlang runtime system can be started as follows:</source>
          <target state="translated">&lt;code&gt;pseudo(Master, ServerList)&lt;/code&gt; 호출합니다 . 명령 행에서 노드를 시작하고 여러 의사 서버를 설정하려는 경우 다음과 같이 Erlang 런타임 시스템을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fd282143317f0c95d38258aa5488afaefacb19b" translate="yes" xml:space="preserve">
          <source>Calls a fun, passing the elements in &lt;code&gt;Args&lt;/code&gt; as arguments.</source>
          <target state="translated">&lt;code&gt;Args&lt;/code&gt; 의 요소를 인수 로 전달하여 재미를 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="bc1df90caee2a0f744537886d1a4a5d884e3a1f0" translate="yes" xml:space="preserve">
          <source>Calls between functions are either  &lt;strong id=&quot;local_call&quot;&gt;local calls&lt;/strong&gt; like &lt;code&gt;f()&lt;/code&gt;, or  &lt;strong id=&quot;external_call&quot;&gt;external calls&lt;/strong&gt; like &lt;code&gt;m:f()&lt;/code&gt;.  &lt;strong id=&quot;module_data&quot;&gt;Module data&lt;/strong&gt;, which are extracted from BEAM files, include local functions, exported functions, local calls and external calls. By default, calls to built-in functions (BIF) are ignored, but if the option &lt;code&gt;builtins&lt;/code&gt;, accepted by some of this module's functions, is set to &lt;code&gt;true&lt;/code&gt;, calls to BIFs are included as well. It is the analyzing OTP version that decides what functions are BIFs. Functional objects are assumed to be called where they are created (and nowhere else).  &lt;strong id=&quot;unresolved_call&quot;&gt;Unresolved calls&lt;/strong&gt; are calls to &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;spawn&lt;/code&gt; with variable module, variable function, or variable arguments. Examples are &lt;code&gt;M:F(a)&lt;/code&gt;, &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt;, and &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt;. Unresolved calls are represented by calls where variable modules have been replaced with the atom &lt;code&gt;'$M_EXPR'&lt;/code&gt;, variable functions have been replaced with the atom &lt;code&gt;'$F_EXPR'&lt;/code&gt;, and variable number of arguments have been replaced with the number &lt;code&gt;-1&lt;/code&gt;. The above mentioned examples are represented by calls to &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt;, &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt;, and &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt;. The unresolved calls are a subset of the external calls.</source>
          <target state="translated">함수 간의 &lt;strong id=&quot;local_call&quot;&gt;호출&lt;/strong&gt; 은 &lt;code&gt;f()&lt;/code&gt; 와 같은 &lt;strong id=&quot;local_call&quot;&gt;로컬 호출&lt;/strong&gt; 이거나 &lt;code&gt;m:f()&lt;/code&gt; 와 같은 &lt;strong id=&quot;external_call&quot;&gt;외부 호출&lt;/strong&gt; 입니다. BEAM 파일에서 추출 된 &lt;strong id=&quot;module_data&quot;&gt;모듈 데이터&lt;/strong&gt; 에는 로컬 기능, 내 보낸 기능, 로컬 호출 및 외부 호출이 포함됩니다. 기본적으로 내장 함수 (BIF)에 대한 호출은 무시되지만 이 모듈의 일부 기능에 의해 승인 된 &lt;code&gt;builtins&lt;/code&gt; 옵션 이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 BIF에 대한 호출도 포함됩니다. 어떤 기능이 BIF인지를 결정하는 것은 분석 OTP 버전입니다. 기능적 객체는 생성 된 곳 (및 다른 곳)에 있다고 가정합니다. &lt;strong id=&quot;unresolved_call&quot;&gt;해결되지 않은 호출&lt;/strong&gt; 하는 전화입니다 &lt;code&gt;apply&lt;/code&gt; 또는&lt;strong id=&quot;module_data&quot;&gt;&lt;/strong&gt;&lt;strong id=&quot;unresolved_call&quot;&gt;&lt;/strong&gt; &lt;code&gt;spawn&lt;/code&gt; 변수 모듈, 변수 함수 또는 변수 인수로 스폰 됩니다. 예는 &lt;code&gt;M:F(a)&lt;/code&gt; , &lt;code&gt;apply(M,&amp;nbsp;f,&amp;nbsp;[a])&lt;/code&gt; 및 &lt;code&gt;spawn(m,&amp;nbsp;f(),&amp;nbsp;Args)&lt;/code&gt; 입니다. &lt;code&gt;'$M_EXPR'&lt;/code&gt; 되지 않은 호출은 변수 모듈이 원자 '$ M_EXPR' 로 대체되고 변수 함수가 원자 &lt;code&gt;'$F_EXPR'&lt;/code&gt; 로 대체되었으며 변수의 인수 수가 숫자 &lt;code&gt;-1&lt;/code&gt; 로 대체 된 호출로 표시됩니다 . 위에서 언급 한 예는 &lt;code&gt;'$M_EXPR':'$F_EXPR'/1&lt;/code&gt; , &lt;code&gt;'$M_EXPR':f/1&lt;/code&gt; 및 &lt;code&gt;m:'$F_EXPR'/-1&lt;/code&gt; 됩니다. 해결되지 않은 통화는 외부 통화의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="e175a0645ad31688c1ad90ebe51d1f98332790c8" translate="yes" xml:space="preserve">
          <source>Calls between modules, applications and releases are also directed graphs. The  &lt;strong id=&quot;type&quot;&gt;types&lt;/strong&gt; of the vertices and edges of these graphs are (ranging from the most special to the most general): &lt;code&gt;Fun&lt;/code&gt; for functions; &lt;code&gt;Mod&lt;/code&gt; for modules; &lt;code&gt;App&lt;/code&gt; for applications; and &lt;code&gt;Rel&lt;/code&gt; for releases. The following paragraphs will describe the different constructs of the language used for selecting and analyzing parts of the graphs, beginning with the  &lt;strong id=&quot;constants&quot;&gt;constants&lt;/strong&gt;:</source>
          <target state="translated">모듈, 응용 프로그램 및 릴리스 간 호출도 직접 그래프입니다. &lt;strong id=&quot;type&quot;&gt;종류의&lt;/strong&gt; 정점와이 그래프의 가장자리는 (가장 특별한 가장 일반에 이르기까지)되어 &lt;code&gt;Fun&lt;/code&gt; 기능; 모듈 &lt;code&gt;Mod&lt;/code&gt; ; &lt;code&gt;App&lt;/code&gt; 위한 앱 ; 및 &lt;code&gt;Rel&lt;/code&gt; 릴리스. 다음 단락에서는 &lt;strong id=&quot;constants&quot;&gt;상수로&lt;/strong&gt; 시작하여 그래프의 일부를 선택하고 분석하는 데 사용되는 언어의 다양한 구성에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="be43177e95bbd471940bc32f6f4691d58dabae5d" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:read(Tab, Key, read)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e1ab266a520f0fa15f418f121757a95a2f87b8a3" translate="yes" xml:space="preserve">
          <source>Calls quickcheck and returns the result in a form suitable for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">빠른 검사를 호출하고 &lt;code&gt;Common Test&lt;/code&gt; 적합한 형식으로 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8c7c891f9853016ddc130d88be49b034108f4922" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. It is performed in almost the same context as &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the &lt;code&gt;Fun&lt;/code&gt; returns. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">트랜잭션으로 보호되지 않는 컨텍스트 에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 . &lt;code&gt;Fun&lt;/code&gt; 에서 수행 된 Mnesia 함수 호출 은 해당 더티 함수에 매핑됩니다. &lt;code&gt;mnesia:async_dirty/1,2&lt;/code&gt; 와 거의 동일한 컨텍스트에서 수행됩니다 . 차이점은 작업이 동 기적으로 수행된다는 것입니다. 발신자는 &lt;code&gt;Fun&lt;/code&gt; 이 복귀 하기 전에 모든 활성 복제본에서 업데이트가 수행되기를 기다립니다 . 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 및 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f3ec8be69b09a2c810b010167a3f606775918ce" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a context that is not protected by a transaction. The Mnesia function calls performed in the &lt;code&gt;Fun&lt;/code&gt; are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indexes are updated, but they are updated dirty. As for normal &lt;code&gt;mnesia:dirty_*&lt;/code&gt; operations, the operations are performed semi-asynchronously. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">트랜잭션으로 보호되지 않는 컨텍스트 에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 . &lt;code&gt;Fun&lt;/code&gt; 에서 수행 된 Mnesia 함수 호출 은 해당 더티 함수에 매핑됩니다. 여기에는 여전히 로깅, 복제 및 구독이 포함되지만 잠금, 로컬 트랜잭션 스토리지 또는 커밋 프로토콜은 없습니다. 체크 포인트 보유자와 색인은 업데이트되지만 더티 업데이트됩니다. 일반적인 &lt;code&gt;mnesia:dirty_*&lt;/code&gt; 작업의 경우 작업이 반 비동기식으로 수행됩니다. 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 및 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d819d67bdd8cdeb2caeeb18f61988b23312e64a2" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;Fun&lt;/code&gt; in a raw context that is not protected by a transaction. The Mnesia function call is performed in the &lt;code&gt;Fun&lt;/code&gt; and performed directly on the local ETS tables on the assumption that the local storage type is &lt;code&gt;ram_copies&lt;/code&gt; and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to &lt;code&gt;disc_copies&lt;/code&gt; tables if all operations are read only. For details, see &lt;code&gt;mnesia:activity/4&lt;/code&gt; and the User's Guide.</source>
          <target state="translated">트랜잭션으로 보호되지 않은 원시 컨텍스트에서 &lt;code&gt;Fun&lt;/code&gt; 을 호출합니다 . Mnesia 함수 호출은 &lt;code&gt;Fun&lt;/code&gt; 에서 수행되고 로컬 스토리지 유형이 &lt;code&gt;ram_copies&lt;/code&gt; 이고 테이블이 다른 노드에 복제되지 않는다는 가정하에 로컬 ETS 테이블에서 직접 수행 됩니다. 구독이 트리거되지 않고 체크 포인트가 업데이트되지 않지만 매우 빠릅니다. 모든 작업이 읽기 전용 인 경우이 함수는 &lt;code&gt;disc_copies&lt;/code&gt; 테이블 에도 적용 할 수 있습니다 . 자세한 내용은 &lt;code&gt;mnesia:activity/4&lt;/code&gt; 및 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a784dd04ba58d02965f17a28a416dac496f4c6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mnesia:delete(Tab, Key, sticky_write)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ecca9949a5635aaf8c27410eea7636e30e459fb0" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete_object(Tab, Record, sticky_write)&lt;/code&gt; 함수를 호출합니다 . 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="949e11ed9c4c541b273d5f803d7f14e93decf845" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:lock({table, Tab}, read)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7a8c4bc10158fea84b8bc4d0f51afdb0e35c5827" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:lock({table, Tab}, write)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cddc0b283837cd9cf6bfc5ffbfc0d1ab69ceebc5" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:read(Tab, Key, write)&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="55f266ac7f0a7fd8339f6a382397f015c2d00cb9" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:uninstall_fallback([{scope, global}])&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a04316f127b21a90e451cb0328b531e879c5c8a6" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:write(Tab, Record, sticky_write)&lt;/code&gt; 함수를 호출합니다 . 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6619bcc0446814c6bc36959f774872812e839577" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt;, where &lt;code&gt;Tab&lt;/code&gt; is &lt;code&gt;element(1, Record)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:write(Tab, Record, write)&lt;/code&gt; 함수를 호출합니다 . 여기서 &lt;code&gt;Tab&lt;/code&gt; 은 &lt;code&gt;element(1, Record)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b9dce33ce75c3e0cd20ec5b024a2864ee93e989" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;free()&lt;/code&gt; function.</source>
          <target state="translated">표준 &lt;code&gt;free()&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b90d8d44b261c3e05c2a69f75c7d0d01e3b518f9" translate="yes" xml:space="preserve">
          <source>Calls the standard &lt;code&gt;malloc()&lt;/code&gt; function.</source>
          <target state="translated">표준 &lt;code&gt;malloc()&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3f325b7e41b1fdb81e7bc7cb001482dfdf57640d" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt;, and corresponding functions for warning and info messages, are all forwarded to Logger as calls to &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">를 호출 &lt;code&gt;&lt;a href=&quot;error_logger#error_report-1&quot;&gt;error_logger:error_report/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;error_logger#error_msg-1&quot;&gt;error_logger:error_msg/1,2&lt;/a&gt;&lt;/code&gt; , 경고 및 정보 메시지에 대한 기능을 해당하는 모든 호출로 로거로 전달됩니다 &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log(Level,Report,Metadata)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="681ce3661a9a40c6caccc2250ea6929229c7aac3" translate="yes" xml:space="preserve">
          <source>Calls to functions defined by evaluating fun expressions &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; are also hidden from non-local function handlers.</source>
          <target state="translated">fun 표현식 &lt;code&gt;&quot;fun ... end&quot;&lt;/code&gt; 를 평가하여 정의 된 함수에 대한 호출 도 로컬이 아닌 함수 핸들러에서 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="a78c70fc8985fb6668305436210f739782826d6b" translate="yes" xml:space="preserve">
          <source>Calls to local or external functions (&lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;m:foo()&lt;/code&gt;) are the fastest calls.</source>
          <target state="translated">로컬 또는 외부 함수 ( &lt;code&gt;foo()&lt;/code&gt; , &lt;code&gt;m:foo()&lt;/code&gt; )에 대한 호출이 가장 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="c1368b924e595a7f64353a1c8704cd02aa9b58af" translate="yes" xml:space="preserve">
          <source>Calls to the BIFs specified in table &lt;code&gt;Type Test BIFs&lt;/code&gt;</source>
          <target state="translated">테이블 &lt;code&gt;Type Test BIFs&lt;/code&gt; 지정된 BIF 호출</target>
        </trans-unit>
        <trans-unit id="c5e2dbf1a74a301e38682ebfa666c1939e25bd23" translate="yes" xml:space="preserve">
          <source>Can another internal data representation be used to make things more efficient?</source>
          <target state="translated">보다 효율적인 내부 작업을 위해 다른 내부 데이터 표현을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ce2b0460aad57730836f17162000a27e6d1988d5" translate="yes" xml:space="preserve">
          <source>Can any redundant tests be removed?</source>
          <target state="translated">중복 테스트를 제거 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="14d70599293b8e413ef952c38a0440843056f84c" translate="yes" xml:space="preserve">
          <source>Can any test be run less often if the order of tests is changed?</source>
          <target state="translated">테스트 순서가 변경되면 테스트를 덜 자주 실행할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1dbbd23b5878e1a733c169db6ec8393bc170cde2" translate="yes" xml:space="preserve">
          <source>Can be a back reference, or another way of writing a tab</source>
          <target state="translated">역 참조 또는 다른 탭 작성 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ff3af864aead7cd729fa897ed19cd40dd3bea5a" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise the character with octal code 113</source>
          <target state="translated">역 참조 일 수 있으며, 그렇지 않으면 8 진 코드 113의 문자</target>
        </trans-unit>
        <trans-unit id="ca748588186d1a7e973cd887d71235755974030e" translate="yes" xml:space="preserve">
          <source>Can be a back reference, otherwise value 255 (decimal)</source>
          <target state="translated">역 참조 일 수 있음, 그렇지 않은 경우 값 255 (10 진수)</target>
        </trans-unit>
        <trans-unit id="7d7475380f4be07d179c7231bb2dd90fbd5279b2" translate="yes" xml:space="preserve">
          <source>Can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag &lt;code&gt;-relaxed_command_check&lt;/code&gt;, which it normally is not.</source>
          <target state="translated">프로세스가 로컬 호스트의 EPMD에서 지정된 노드를 등록 해제하기 위해 호출 할 수 있습니다. 그러나 EPMD가 플래그 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 로 시작되지 않는 한 일반적으로 허용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f44b4080b46d42a3270b0b18ff48ce34cd9d5ec2" translate="yes" xml:space="preserve">
          <source>Can be implemented as:</source>
          <target state="translated">다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="435b9419e03f7e525befa539fe46b7b2779ce303" translate="yes" xml:space="preserve">
          <source>Can be one of the following:</source>
          <target state="translated">다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18e0b766363b36ea716659f6503b3ddde9e7ec85" translate="yes" xml:space="preserve">
          <source>Can be removed in a future release of the halfword emulator.</source>
          <target state="translated">하프 워드 에뮬레이터의 다음 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a329dd98b578890314d90cd00ae46894da7e6ba8" translate="yes" xml:space="preserve">
          <source>Can be set to &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;relaxed&lt;/code&gt;. It controls how each directory in the code path is to be interpreted:</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; 하거나 &lt;code&gt;relaxed&lt;/code&gt; 설정할 수 있습니다 . 코드 경로의 각 디렉토리를 해석하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="61d2fdff92dff8eebb470df37755eb8b633955c3" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; daemon listens only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified).</source>
          <target state="translated">쉼표로 구분 된 IP 주소 목록으로 설정할 수 있습니다.이 경우 &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 데몬은 지정된 주소와 루프백 주소 (지정되지 않은 경우 목록에 암시 적으로 추가됨)에서만 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1d6e47517b6960079a15e323f8e14b95671cfd59" translate="yes" xml:space="preserve">
          <source>Can be set to a comma-separated list of IP addresses, in which case the &lt;code&gt;epmd&lt;/code&gt; daemon will listen only on the specified address(es) and on the loopback address (which is implicitly added to the list if it has not been specified). The default behavior is to listen on all available IP addresses.</source>
          <target state="translated">쉼표로 구분 된 IP 주소 목록으로 설정할 수 있습니다.이 경우 &lt;code&gt;epmd&lt;/code&gt; 데몬은 지정된 주소와 루프백 주소 (지정되지 않은 경우 목록에 암시 적으로 추가됨)에서만 수신합니다. 기본 동작은 사용 가능한 모든 IP 주소를 수신하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32027351ef478fb666878cfb7ea809e9ec8104be" translate="yes" xml:space="preserve">
          <source>Can be used as a name resolving function for &lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#register_name-3&quot;&gt;register_name/3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#re_register_name-3&quot;&gt;re_register_name/3&lt;/a&gt;&lt;/code&gt; 의 이름 해석 기능으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a41238ba1ffe4cd44c8669bf5362c16badbd6e66" translate="yes" xml:space="preserve">
          <source>Can be used by a process that initiates a debug structure from a list of options. The values of argument &lt;code&gt;Opt&lt;/code&gt; are the same as for the corresponding functions.</source>
          <target state="translated">옵션 목록에서 디버그 구조를 시작하는 프로세스에서 사용할 수 있습니다. 인수 &lt;code&gt;Opt&lt;/code&gt; 의 값은 해당 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e44e4550227750d3133233de3b9ab784df8d5876" translate="yes" xml:space="preserve">
          <source>Can be used if interactive performance is not to be affected by the emulator process.</source>
          <target state="translated">대화식 성능이 에뮬레이터 프로세스의 영향을받지 않는 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4554428a28a365553523e827200f0a4801491275" translate="yes" xml:space="preserve">
          <source>Can be used if the size of the trace logs must be limited. Default values are &lt;code&gt;Size=128*1024&lt;/code&gt; and &lt;code&gt;Count=8&lt;/code&gt;.</source>
          <target state="translated">추적 로그의 크기를 제한해야하는 경우 사용할 수 있습니다. 기본값은 &lt;code&gt;Size=128*1024&lt;/code&gt; 및 &lt;code&gt;Count=8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52514699bbc5fce906ba4874a907b457ea6b2ad1" translate="yes" xml:space="preserve">
          <source>Can be used if two Erlang nodes are to reside on one dedicated system and one is to have precedence over the other.</source>
          <target state="translated">두 개의 Erlang 노드가 하나의 전용 시스템에 상주하고 다른 하나보다 우선하는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cfd6096580c6f0fc105f7dae283a846f824ac79" translate="yes" xml:space="preserve">
          <source>Can be used to determine which crypto algorithms that are supported by the underlying OpenSSL library</source>
          <target state="translated">기본 OpenSSL 라이브러리가 지원하는 암호화 알고리즘을 결정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac2e838e28c4e79b7b0173c19b32b3299e09f77" translate="yes" xml:space="preserve">
          <source>Can be used to determine which named elliptic curves are supported.</source>
          <target state="translated">지원되는 명명 된 타원 곡선을 결정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0139eb1de3d0a9614c9b210a184d4b0320912f6e" translate="yes" xml:space="preserve">
          <source>Can be used to make the client act as an &lt;code&gt;HTTP/1.0&lt;/code&gt; or &lt;code&gt;HTTP/0.9&lt;/code&gt; client. By default this is an &lt;code&gt;HTTP/1.1&lt;/code&gt; client. When using &lt;code&gt;HTTP/1.0&lt;/code&gt; persistent connections are not used.</source>
          <target state="translated">클라이언트를 &lt;code&gt;HTTP/1.0&lt;/code&gt; 또는 &lt;code&gt;HTTP/0.9&lt;/code&gt; 클라이언트 로 작동시키는 데 사용할 수 있습니다 . 기본적으로 이것은 &lt;code&gt;HTTP/1.1&lt;/code&gt; 클라이언트입니다. 사용하는 경우 &lt;code&gt;HTTP/1.0&lt;/code&gt; 영구 연결은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9de6dfb4b293a374f8bbe2fd001451aff895674" translate="yes" xml:space="preserve">
          <source>Can be used to retrieve information about the C-node. These values are initially set with &lt;code&gt;ei_connect_init()&lt;/code&gt; or &lt;code&gt;ei_connect_xinit()&lt;/code&gt;.</source>
          <target state="translated">C 노드에 대한 정보를 검색하는 데 사용할 수 있습니다. 이 값은 처음에 &lt;code&gt;ei_connect_init()&lt;/code&gt; 또는 &lt;code&gt;ei_connect_xinit()&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6b6b3b3a5a2150a389c6b25e1e84aa23960992c" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with a server called &lt;code&gt;Name&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;. It is assumed that the server receives messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and replies using &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt;. This function makes such a server call and ensures that the entire call is packed into an atomic transaction, which either succeeds or fails. It never hangs, unless the server itself hangs.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;Name&lt;/code&gt; 이라는 서버와 상호 작용할 때 사용할 수 있습니다 . 서버가 &lt;code&gt;{From, Msg}&lt;/code&gt; 형식의 메시지를 수신 하고 &lt;code&gt;From ! {ReplyWrapper, Node, Reply}&lt;/code&gt; 사용하여 응답 한다고 가정합니다 . {ReplyWrapper는, 노드, 회신} . 이 기능은 이러한 서버 호출을 수행하고 전체 호출이 원자 트랜잭션으로 묶여 성공 또는 실패를 보장합니다. 서버 자체가 멈추지 않는 한 절대 멈추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb8693797500f3627529857787e0f8552cc7d7b2" translate="yes" xml:space="preserve">
          <source>Can be used when interacting with servers called &lt;code&gt;Name&lt;/code&gt; on the specified nodes. It is assumed that the servers receive messages in the format &lt;code&gt;{From, Msg}&lt;/code&gt; and reply using &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt;, where &lt;code&gt;Node&lt;/code&gt; is the name of the node where the server is located. The function returns &lt;code&gt;{Replies, BadNodes}&lt;/code&gt;, where &lt;code&gt;Replies&lt;/code&gt; is a list of all &lt;code&gt;Reply&lt;/code&gt; values, and &lt;code&gt;BadNodes&lt;/code&gt; is one of the following:</source>
          <target state="translated">지정된 노드에서 &lt;code&gt;Name&lt;/code&gt; 이라는 서버와 상호 작용할 때 사용할 수 있습니다 . 서버는 &lt;code&gt;{From, Msg}&lt;/code&gt; 형식의 메시지를 수신 하고 &lt;code&gt;From ! {Name, Node, Reply}&lt;/code&gt; 사용하여 응답 한다고 가정합니다 . {Name, Node, Reply} (여기서 &lt;code&gt;Node&lt;/code&gt; 는 서버가있는 노드의 이름입니다. 이 함수는 &lt;code&gt;{Replies, BadNodes}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;Replies&lt;/code&gt; 는 모든 &lt;code&gt;Reply&lt;/code&gt; 값 의 목록 이며 &lt;code&gt;BadNodes&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="413a11e06a5cc3367aeaca579508da6cce5c360b" translate="yes" xml:space="preserve">
          <source>Can be used with &lt;code&gt;chunk/2,3&lt;/code&gt; and &lt;code&gt;bchunk/2,3&lt;/code&gt; to search through an internally formatted wrap log. It takes as argument a continuation as returned by &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, or &lt;code&gt;chunk_step/3&lt;/code&gt;, and steps forward (or backward) &lt;code&gt;Step&lt;/code&gt; files in the wrap log. The continuation returned, points to the first log item in the new current file.</source>
          <target state="translated">&lt;code&gt;chunk/2,3&lt;/code&gt; 및 &lt;code&gt;bchunk/2,3&lt;/code&gt; / 2,3 과 함께 사용 하여 내부 형식화 된 랩 로그를 검색 할 수 있습니다 . &lt;code&gt;chunk/2,3&lt;/code&gt; , &lt;code&gt;bchunk/2,3&lt;/code&gt; 또는 &lt;code&gt;chunk_step/3&lt;/code&gt; 에서 리턴 한대로 연속을 인수 로 사용하고 랩 로그에서 &lt;code&gt;Step&lt;/code&gt; 파일을 앞으로 (또는 뒤로) 단계 화 합니다. 리턴 된 연속은 새 현재 파일의 첫 번째 로그 항목을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="54b689659783bb6b4ac1454db70e48394a638a38" translate="yes" xml:space="preserve">
          <source>Can contain the port number &lt;code&gt;epmd&lt;/code&gt; will use. The default port will work fine in most cases. A different port can be specified to allow several instances of &lt;code&gt;epmd&lt;/code&gt;, representing independent clusters of nodes, to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; 가 사용할 포트 번호를 포함 할 수 있습니다 . 대부분의 경우 기본 포트가 제대로 작동합니다. 독립적 인 노드 클러스터를 나타내는 &lt;code&gt;epmd&lt;/code&gt; 의 여러 인스턴스가 동일한 호스트에 공존 할 수 있도록 다른 포트를 지정할 수 있습니다 . 클러스터의 모든 노드는 동일한 &lt;code&gt;epmd&lt;/code&gt; 포트 번호를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d4e8ff3c787597c2cdf851d9445ac7a46d3eec" translate="yes" xml:space="preserve">
          <source>Can contain the port number to use when communicating with &lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt;. The default port works fine in most cases. A different port can be specified to allow nodes of independent clusters to co-exist on the same host. All nodes in a cluster must use the same &lt;code&gt;epmd&lt;/code&gt; port number.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;epmd&quot;&gt;epmd&lt;/a&gt;&lt;/code&gt; 와 통신 할 때 사용할 포트 번호를 포함 할 수 있습니다 . 대부분의 경우 기본 포트가 제대로 작동합니다. 독립 클러스터의 노드가 동일한 호스트에 공존 할 수 있도록 다른 포트를 지정할 수 있습니다. 클러스터의 모든 노드는 동일한 &lt;code&gt;epmd&lt;/code&gt; 포트 번호를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="763e2024cfbffcaa35312ea836b3ce5e41e09735" translate="yes" xml:space="preserve">
          <source>Can either be the originals passed into the calling NIF, or can be values created by the calling NIF.</source>
          <target state="translated">호출하는 NIF로 전달 된 원본이거나 호출하는 NIF에 의해 작성된 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1762b945a07d7a0928b055cdfb86c61f5e180a18" translate="yes" xml:space="preserve">
          <source>Can enable trace on all functions or only exported functions on chosen modules.</source>
          <target state="translated">모든 기능에서 추적을 사용하거나 선택한 모듈에서 내 보낸 기능 만 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d98498dcb02bc77d5362ec71948bf4dcb80403" translate="yes" xml:space="preserve">
          <source>Can only be used to check the local time of day if the time-zone information of the underlying OS is properly configured.</source>
          <target state="translated">기본 OS의 시간대 정보가 올바르게 구성된 경우에만 현지 시간을 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b665cc5f87b4b96a8b89bb4858d5c6ded666e00" translate="yes" xml:space="preserve">
          <source>Can only be used with TLS/DTLS connections; &lt;code&gt;{error, undefined}&lt;/code&gt; is returned for SSLv3 connections.</source>
          <target state="translated">TLS / DTLS 연결에만 사용할 수 있습니다. SSLv3 연결에 대해 &lt;code&gt;{error, undefined}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="0ce7f9b48109071ca45af63e2c7f4cded74fe895" translate="yes" xml:space="preserve">
          <source>Cancel a previous asynchronous request.</source>
          <target state="translated">이전 비동기 요청을 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="8c0d517ae93b9275421781af37452eec4bb2fa47" translate="yes" xml:space="preserve">
          <source>Cancel a previous request to be notified of SNMP manager start.</source>
          <target state="translated">SNMP 관리자 시작을 알리는 이전 요청을 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="a9a0f30cfff3cf2f7919e74d440e32f436d7292c" translate="yes" xml:space="preserve">
          <source>Cancel all outstanding messages for this connection</source>
          <target state="translated">이 연결에 대한 모든 미해결 메시지 취소</target>
        </trans-unit>
        <trans-unit id="2e83179d769a2b44650615f9d44ca78b37a04604" translate="yes" xml:space="preserve">
          <source>Cancel the handshake with a fatal &lt;code&gt;USER_CANCELED&lt;/code&gt; alert.</source>
          <target state="translated">치명적인 &lt;code&gt;USER_CANCELED&lt;/code&gt; 경고로 악수를 취소하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
