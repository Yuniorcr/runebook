<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="fc2106dbbf5f859efe242b4f2863fc622702b3ed" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session as a channel on the given SSH connection, and exchanges hello messages with the server.</source>
          <target state="translated">주어진 SSH 연결에서 NETCONF 세션을 채널로 열고 서버와 hello 메시지를 교환합니다.</target>
        </trans-unit>
        <trans-unit id="01cccde2b149248e69a585d60c61c3d13087127c" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session, but does not send &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">NETCONF 세션을 열지 만 &lt;code&gt;hello&lt;/code&gt; 를 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="45f71db9541f82e0ef4dd81a5e3160d6a9c42345" translate="yes" xml:space="preserve">
          <source>Opens a TLS/DTLS connection to &lt;code&gt;Host&lt;/code&gt;, &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; , &lt;code&gt;Port&lt;/code&gt; 에 대한 TLS / DTLS 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="e0e8afe49dad7508484506ff701e53d0d8fc26e0" translate="yes" xml:space="preserve">
          <source>Opens a Telnet connection to the specified target host.</source>
          <target state="translated">지정된 대상 호스트에 대한 Telnet 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="863e973e6a31c9261a3ac1a5ee27b4c5d6dfcd10" translate="yes" xml:space="preserve">
          <source>Opens a channel for an SSH session.</source>
          <target state="translated">SSH 세션을위한 채널을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f4b954e8567f661fe6c4ddf769bdcc65e25fa9df" translate="yes" xml:space="preserve">
          <source>Opens a channel for an SSH session. The channel id returned from this function is the id used as input to the other functions in this module.</source>
          <target state="translated">SSH 세션을위한 채널을 엽니 다. 이 기능에서 반환 된 채널 ID는이 모듈의 다른 기능에 대한 입력으로 사용되는 ID입니다.</target>
        </trans-unit>
        <trans-unit id="84e8a4380a15d0e1019641a8397c044a4caf2ec5" translate="yes" xml:space="preserve">
          <source>Opens a connection to the database. The connection is associated with the process that created it and can only be accessed through it. This function may spawn new processes to handle the connection. These processes will terminate if the process that created the connection dies or if you call disconnect/1.</source>
          <target state="translated">데이터베이스에 대한 연결을 엽니 다. 연결은 연결을 만든 프로세스와 연결되며 연결을 통해서만 액세스 할 수 있습니다. 이 함수는 연결을 처리하기 위해 새로운 프로세스를 생성 할 수 있습니다. 연결을 만든 프로세스가 종료되거나 disconnect / 1을 호출하면 이러한 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8a2ca3ab2e6a54c904b5fe348aa46db48f2f0c68" translate="yes" xml:space="preserve">
          <source>Opens a detailed information window on the selected process, including the following:</source>
          <target state="translated">다음을 포함하여 선택한 프로세스에 대한 자세한 정보 창을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f750e93585a93a3a78ed2d040624e4bedee5783b" translate="yes" xml:space="preserve">
          <source>Opens a file for preprocessing.</source>
          <target state="translated">전처리를 위해 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="0dae8080316d196c81e5e5bd698fc2b46c3bd578" translate="yes" xml:space="preserve">
          <source>Opens a file for read or write access.</source>
          <target state="translated">읽기 또는 쓰기 액세스를 위해 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="05853d805e8d0a64be6bd32197c1efe7fc8affff" translate="yes" xml:space="preserve">
          <source>Opens a file on the server and returns a handle, which can be used for reading or writing.</source>
          <target state="translated">서버에서 파일을 열고 읽기 또는 쓰기에 사용할 수있는 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8cba523b51510605036808e563faed86bad7a34" translate="yes" xml:space="preserve">
          <source>Opens a handle to a directory on the server. The handle can be used for reading directory contents.</source>
          <target state="translated">서버의 디렉토리에 대한 핸들을 엽니 다. 핸들은 디렉토리 내용을 읽는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582c61865473eb0cf103ce22b094eb7d48793963" translate="yes" xml:space="preserve">
          <source>Opens a handle to a tar file on the server, associated with &lt;code&gt;ChannelPid&lt;/code&gt;. The handle can be used for remote tar creation and extraction, as defined by the &lt;code&gt;erl_tar:init/3&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;ChannelPid&lt;/code&gt; 와 연관된 서버의 tar 파일에 대한 핸들을 엽니 다 . 핸들은 &lt;code&gt;erl_tar:init/3&lt;/code&gt; 함수에 정의 된대로 원격 tar 작성 및 추출에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2c2e2f345cf2c0d7bffb15b36f80da084528f09" translate="yes" xml:space="preserve">
          <source>Opens a handle to a tar file on the server, associated with &lt;code&gt;ChannelPid&lt;/code&gt;. The handle can be used for remote tar creation and extraction. The actual writing and reading is performed by calls to &lt;code&gt;erl_tar:add/3,4&lt;/code&gt; and &lt;code&gt;erl_tar:extract/2&lt;/code&gt;. Note: The &lt;code&gt;erl_tar:init/3&lt;/code&gt; function should not be called, that one is called by this open_tar function.</source>
          <target state="translated">&lt;code&gt;ChannelPid&lt;/code&gt; 와 연결된 서버의 tar 파일에 대한 핸들을 엽니 다 . 핸들은 원격 tar 생성 및 추출에 사용할 수 있습니다. 실제 쓰기 및 읽기는 &lt;code&gt;erl_tar:add/3,4&lt;/code&gt; 및 &lt;code&gt;erl_tar:extract/2&lt;/code&gt; 호출에 의해 수행됩니다 . 참고 : &lt;code&gt;erl_tar:init/3&lt;/code&gt; 함수는 호출하지 않아야합니다.이 함수는이 open_tar 함수에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="38a016da939f8a64a311d0439e65d9ca62d7e550" translate="yes" xml:space="preserve">
          <source>Opens a named NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">명명 된 NETCONF 세션을 열고 &lt;code&gt;hello&lt;/code&gt; 메시지를 교환 합니다.</target>
        </trans-unit>
        <trans-unit id="6c86f8db1e9c8781949e8303c056c061130288be" translate="yes" xml:space="preserve">
          <source>Opens a named NETCONF session, but does not send &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">명명 된 NETCONF 세션을 열지 만 &lt;code&gt;hello&lt;/code&gt; 를 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ae78d453fdc1ed67800d13633ccdbf6892076735" translate="yes" xml:space="preserve">
          <source>Opens a table. An empty Dets table is created if no file exists.</source>
          <target state="translated">테이블을 엽니 다. 파일이 없으면 비어있는 Dets 테이블이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5b10027bd172d07f8eae36a418eb12d0559fcafd" translate="yes" xml:space="preserve">
          <source>Opens a trace port on each node to be traced. By default, trace messages are written to binary files on remote nodes (the binary trace log).</source>
          <target state="translated">추적 할 각 노드에서 추적 포트를 엽니 다. 기본적으로 추적 메시지는 원격 노드의 이진 파일 (이진 추적 로그)에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6a5ff76be69758b5b422a1d897ebb9c5f931b8de" translate="yes" xml:space="preserve">
          <source>Opens a zip archive, and reads and saves its directory. This means that later reading files from the archive is faster than unzipping files one at a time with &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Zip 아카이브를 열고 디렉토리를 읽고 저장합니다. 이는 나중에 압축 파일을 읽는 것이 &lt;code&gt;&lt;a href=&quot;#unzip-1&quot;&gt;unzip/1,2&lt;/a&gt;&lt;/code&gt; 로 한 번에 하나씩 파일을 압축 해제 하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="cfb9d8cc25812a80fcde10dfb14baff5e93d3d89" translate="yes" xml:space="preserve">
          <source>Opens a zlib stream.</source>
          <target state="translated">zlib 스트림을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="cf71532877f9185120e6ff70251b83955022ad68" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection and fetches a file from the remote host.</source>
          <target state="translated">FTP 연결을 열고 원격 호스트에서 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0edbf2d8cf836a0928dd1ee04359d15b3360a7a1" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection and sends a file to the remote host.</source>
          <target state="translated">FTP 연결을 열고 파일을 원격 호스트로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="34a1d5c3e19d27c4c884a326dd68b7ad28a75ae7" translate="yes" xml:space="preserve">
          <source>Opens an FTP connection to the specified node.</source>
          <target state="translated">지정된 노드에 대한 FTP 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="375e952b3e4358b9086c82fb4e035f4c2d220eed" translate="yes" xml:space="preserve">
          <source>Opens an SSH connection to a NETCONF server.</source>
          <target state="translated">NETCONF 서버에 대한 SSH 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a16d2119745f4d905dfff9790116b88f38df60dd" translate="yes" xml:space="preserve">
          <source>Opens an SSH or SFTP connection using the information associated with &lt;code&gt;KeyOrName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;KeyOrName&lt;/code&gt; 과 관련된 정보를 사용하여 SSH 또는 SFTP 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="39bf3429a9eb17df337807274369a2a1485631e4" translate="yes" xml:space="preserve">
          <source>Opens an TLS/DTLS connection to &lt;code&gt;Host&lt;/code&gt;, &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; , &lt;code&gt;Port&lt;/code&gt; 에 대한 TLS / DTLS 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="62effb5551d902e97d0967400f135108af21c88b" translate="yes" xml:space="preserve">
          <source>Opens an existing resource type and takes over ownership of all its instances. The supplied destructor &lt;code&gt;dtor&lt;/code&gt; is called both for existing instances and new instances not yet created by the calling NIF library.</source>
          <target state="translated">기존 자원 유형을 열고 모든 인스턴스의 소유권을 인수합니다. 제공된 소멸자 &lt;code&gt;dtor&lt;/code&gt; 는 기존 인스턴스와 호출 NIF 라이브러리에 의해 아직 작성되지 않은 새 인스턴스 모두에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9f30c59ec922ffa7f6658907dc759edc40afdb39" translate="yes" xml:space="preserve">
          <source>Opens an existing table. If the table is not properly closed, it is repaired. The returned reference is to be used as the table name. This function is most useful for debugging purposes.</source>
          <target state="translated">기존 테이블을 엽니 다. 테이블이 제대로 닫히지 않으면 복구됩니다. 리턴 된 참조는 테이블 이름으로 사용됩니다. 이 기능은 디버깅 목적으로 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6191fa62fa9a2d5758147014b1cebb180f7936ed" translate="yes" xml:space="preserve">
          <source>Opens an interactive Windows console window for the Erlang shell of the service. Automatically disables the &lt;code&gt;StopAction&lt;/code&gt;. A service started with an interactive console window does not survive logouts. &lt;code&gt;OnFail&lt;/code&gt; actions do not work with debug consoles either.</source>
          <target state="translated">서비스의 Erlang 쉘에 대한 대화식 Windows 콘솔 창을 엽니 다. &lt;code&gt;StopAction&lt;/code&gt; 을 자동으로 비활성화합니다 . 대화식 콘솔 창으로 시작한 서비스는 로그 아웃 후에도 지속되지 않습니다. &lt;code&gt;OnFail&lt;/code&gt; 작업은 디버그 콘솔에서도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b42e9b24605e4d337c32c2f54025481d238a9f0" translate="yes" xml:space="preserve">
          <source>Opens file &lt;code&gt;File&lt;/code&gt; in the mode determined by &lt;code&gt;Modes&lt;/code&gt;, which can contain one or more of the following options:</source>
          <target state="translated">다음 옵션 중 하나 이상을 포함 할 수있는 &lt;code&gt;Modes&lt;/code&gt; 에 의해 결정된 모드에서 파일 &lt;code&gt;File&lt;/code&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="f1f250fc2e30dcf740ba52a6778d1bf170664542" translate="yes" xml:space="preserve">
          <source>Opens log file &lt;code&gt;Filename&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if successful, or &lt;code&gt;{error, allready_have_logfile}&lt;/code&gt; if logging to file is already enabled, or an error tuple if another error occurred (for example, if &lt;code&gt;Filename&lt;/code&gt; cannot be opened). The file is opened with encoding UTF-8.</source>
          <target state="translated">로그 파일 &lt;code&gt;Filename&lt;/code&gt; 을 엽니 다 . 성공한 경우 &lt;code&gt;ok&lt;/code&gt; 를 반환 하거나 &lt;code&gt;{error, allready_have_logfile}&lt;/code&gt; 파일에 로깅이 이미 활성화 된 경우 {error, allready_have_logfile} 또는 다른 오류가 발생한 경우 (예 : &lt;code&gt;Filename&lt;/code&gt; 을 열 수없는 경우) 오류 튜플을 반환 합니다. 파일은 UTF-8 인코딩으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="515b021c218ccf64dc87cfd2e6aafb2c71875e7c" translate="yes" xml:space="preserve">
          <source>Opens the &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt;, where new modules to be interpreted can be specified.</source>
          <target state="translated">해석 할 새 모듈을 지정할 수있는 모듈 &lt;code&gt;&lt;a href=&quot;#interpret&quot;&gt;Interpret Modules window&lt;/a&gt;&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="9b4d52c05a1dfa015184d5b6d02092d14d75b8e3" translate="yes" xml:space="preserve">
          <source>Opens the registry for reading or writing. The current key is the root (&lt;code&gt;HKEY_CLASSES_ROOT&lt;/code&gt;). Flag &lt;code&gt;read&lt;/code&gt; in the mode list can be omitted.</source>
          <target state="translated">읽거나 쓸 레지스트리를 엽니 다. 현재 키는 루트 ( &lt;code&gt;HKEY_CLASSES_ROOT&lt;/code&gt; )입니다. 모드리스트에서 &lt;code&gt;read&lt;/code&gt; 플래그 는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3844a6955eb1488c222cb350aad910d634debf0b" translate="yes" xml:space="preserve">
          <source>Operating system interface</source>
          <target state="translated">운영 체제 인터페이스</target>
        </trans-unit>
        <trans-unit id="6ba10933377bd765bd39421a74f86a9f5033cd62" translate="yes" xml:space="preserve">
          <source>Operating system-specific functions.</source>
          <target state="translated">운영 체제 별 기능.</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="3c9639c2c52d47e5befdf848b84975f48bd5f879" translate="yes" xml:space="preserve">
          <source>Operation &lt;code&gt;&lt;a href=&quot;#kill_session-2&quot;&gt;kill_session/2,3&lt;/a&gt;&lt;/code&gt; can be used to force the release of a lock owned by another NETCONF session. How this is achieved by the server side is implementation-specific.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#kill_session-2&quot;&gt;kill_session/2,3&lt;/a&gt;&lt;/code&gt; 조작을 사용하여 다른 NETCONF 세션이 소유 한 잠금을 강제로 해제 할 수 있습니다. 서버 측에서이를 달성하는 방법은 구현별로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2fd85be02fe70099570593767a6ed02c554cee82" translate="yes" xml:space="preserve">
          <source>Operations on finite sets and relations represented as sets</source>
          <target state="translated">유한 집합 및 집합으로 표현 된 관계에 대한 작업</target>
        </trans-unit>
        <trans-unit id="d721e6bae341c96a244ef5325ee7783da8aa05da" translate="yes" xml:space="preserve">
          <source>Operator precedence in falling priority:</source>
          <target state="translated">우선 순위가 떨어지는 운영자 우선 순위 :</target>
        </trans-unit>
        <trans-unit id="9ac3210fbaf7aa51089439b718a4799d5b27c2af" translate="yes" xml:space="preserve">
          <source>Option (&lt;code&gt;option()&lt;/code&gt;) details:</source>
          <target state="translated">옵션 ( &lt;code&gt;option()&lt;/code&gt; ) 세부 사항 :</target>
        </trans-unit>
        <trans-unit id="7bc4e2bf65691f392e0c6aef8849b96e3503d3f9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;+d&lt;/code&gt; instructs the emulator to produce only a core dump and no crash dump if an internal error is detected.</source>
          <target state="translated">Option &lt;code&gt;+d&lt;/code&gt; 는 내부 오류가 감지되면 에뮬레이터에 코어 덤프 만 생성하고 크래시 덤프는 생성하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9cc73ba20b77152d175148d97de55bb048d9c415" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Encoding&lt;/code&gt; is used for selecting which integer lists to be considered as strings. The default is to use the encoding returned by function &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt; epp:default_encoding/0&lt;/a&gt;&lt;/code&gt;. Value &lt;code&gt;none&lt;/code&gt; means that no integer lists are considered as strings. &lt;code&gt;encoding_func()&lt;/code&gt; is called with one integer of a list at a time; if it returns &lt;code&gt;true&lt;/code&gt; for every integer, the list is considered a string.</source>
          <target state="translated">옵션 &lt;code&gt;Encoding&lt;/code&gt; 은 문자열로 간주 할 정수 목록을 선택하는 데 사용됩니다. 기본값은 &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt; epp:default_encoding/0&lt;/a&gt;&lt;/code&gt; 함수에서 반환 된 인코딩을 사용하는 것 입니다. 값 &lt;code&gt;none&lt;/code&gt; 은 정수 목록이 문자열로 간주되지 않음을 의미합니다. &lt;code&gt;encoding_func()&lt;/code&gt; 는 한 번에 하나의 정수 목록으로 호출됩니다. 모든 정수에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 목록은 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="617924dbd7f61aaccfafefec23e2e5c27276a861" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Encoding&lt;/code&gt; is used for selecting which integer lists to be considered as strings. The default is to use the encoding returned by function &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt;epp:default_encoding/0&lt;/a&gt;&lt;/code&gt;. Value &lt;code&gt;none&lt;/code&gt; means that no integer lists are considered as strings. &lt;code&gt;encoding_func()&lt;/code&gt; is called with one integer of a list at a time; if it returns &lt;code&gt;true&lt;/code&gt; for every integer, the list is considered a string.</source>
          <target state="translated">옵션 &lt;code&gt;Encoding&lt;/code&gt; 은 문자열로 간주 할 정수 목록을 선택하는 데 사용됩니다. 디폴트는 &lt;code&gt;&lt;a href=&quot;epp#default_encoding-0&quot;&gt;epp:default_encoding/0&lt;/a&gt;&lt;/code&gt; 함수가 리턴 한 인코딩을 사용하는 것 입니다. 값 &lt;code&gt;none&lt;/code&gt; 은 정수 목록이 문자열로 간주되지 않음을 의미합니다. &lt;code&gt;encoding_func()&lt;/code&gt; 는 한 번에 하나의 정수 목록으로 호출됩니다. 모든 정수에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 목록이 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="03b58ec642c1d6975a7cca9e9e0680f47eecc590" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Format&lt;/code&gt; determines the function that is applied to binaries to create the terms to be sorted. Defaults to &lt;code&gt;binary_term&lt;/code&gt;, which is equivalent to &lt;code&gt;fun&amp;nbsp;binary_to_term/1&lt;/code&gt;. Value &lt;code&gt;binary&lt;/code&gt; is equivalent to &lt;code&gt;fun(X) -&amp;gt; X end&lt;/code&gt;, which means that the binaries are sorted as they are. This is the fastest format. If &lt;code&gt;Format&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt;, &lt;code&gt;io:read/2&lt;/code&gt; is called to read terms. In that case, only the default value of option &lt;code&gt;header&lt;/code&gt; is allowed.</source>
          <target state="translated">옵션 &lt;code&gt;Format&lt;/code&gt; 은 정렬 할 용어를 만들기 위해 이진에 적용되는 기능을 결정합니다. 기본적으로 &lt;code&gt;binary_term&lt;/code&gt; 이며 &lt;code&gt;fun&amp;nbsp;binary_to_term/1&lt;/code&gt; 과 같습니다 . &lt;code&gt;binary&lt;/code&gt; 값 은 &lt;code&gt;fun(X) -&amp;gt; X end&lt;/code&gt; 와 같습니다. 즉, 이진은 그대로 정렬됩니다. 가장 빠른 형식입니다. 경우 &lt;code&gt;Format&lt;/code&gt; 인 &lt;code&gt;term&lt;/code&gt; , &lt;code&gt;io:read/2&lt;/code&gt; 약관을 읽어하기 위해 호출됩니다. 이 경우 옵션 &lt;code&gt;header&lt;/code&gt; 의 기본값 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="515640376a1e84c5e88279e98275326333b1e883" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;Line&lt;/code&gt; is the line to be assigned to each node of &lt;code&gt;AbsTerm&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;Line&lt;/code&gt; 은 &lt;code&gt;AbsTerm&lt;/code&gt; 의 각 노드에 할당 될 라인 입니다.</target>
        </trans-unit>
        <trans-unit id="ba8fe57baa6137f1e318cb3833968d8989a57f43" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;accept&lt;/code&gt; specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the association to be aborted. Multiple &lt;code&gt;accept&lt;/code&gt; options can be specified. A string-valued &lt;code&gt;Match&lt;/code&gt; that does not parse as an address is interpreted as a regular expression.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 옵션 은 수신 전송에 대한 원격 주소를 지정하며 연결 ​​전송에 유효하지 않습니다. 지정된 경우 지정된 주소 중 하나와 일치하지 않는 원격 주소로 인해 연결이 중단됩니다. 여러 &lt;code&gt;accept&lt;/code&gt; 옵션을 지정할 수 있습니다. 주소로 구문 분석하지 않는 문자열 값 &lt;code&gt;Match&lt;/code&gt; 는 정규식으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="37bd8dc1b650be1a6635cb23b4502d2226d11576" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;accept&lt;/code&gt; specifies remote addresses for a listening transport and is not valid for a connecting transport. If specified, a remote address that does not match one of the specified addresses causes the connection to be aborted. Multiple &lt;code&gt;accept&lt;/code&gt; options can be specified. A string-valued &lt;code&gt;Match&lt;/code&gt; that does not parse as an address is interpreted as a regular expression.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 옵션 은 수신 전송에 대한 원격 주소를 지정하며 연결 ​​전송에 유효하지 않습니다. 지정된 경우 지정된 주소 중 하나와 일치하지 않는 원격 주소로 인해 연결이 중단됩니다. 여러 &lt;code&gt;accept&lt;/code&gt; 옵션을 지정할 수 있습니다. 주소로 구문 분석하지 않는 문자열 값 &lt;code&gt;Match&lt;/code&gt; 는 정규식으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1f55894395584bb9a3e02eafbec27ef2e407d6b9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;allow_passive_connect&lt;/code&gt; is used internally and is seldom needed in applications where the network topology and the Kernel options in effect are known in advance.</source>
          <target state="translated">&lt;code&gt;allow_passive_connect&lt;/code&gt; 옵션 은 내부적으로 사용되며 네트워크 토폴로지와 커널 옵션이 미리 알려진 응용 프로그램에는 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a76c912018b3dd2b854bd85ee5b0c4b94ebb022" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;c&lt;/code&gt; makes &lt;code&gt;Ctrl-C&lt;/code&gt; interrupt the current shell instead of invoking the emulator break handler. Option &lt;code&gt;d&lt;/code&gt; (same as specifying &lt;code&gt;+B&lt;/code&gt; without an extra option) disables the break handler. Option &lt;code&gt;i&lt;/code&gt; makes the emulator ignore any break signal.</source>
          <target state="translated">옵션 &lt;code&gt;c&lt;/code&gt; 는 에뮬레이터 브레이크 핸들러를 호출하는 대신 &lt;code&gt;Ctrl-C&lt;/code&gt; 가 현재 쉘을 인터럽트하도록합니다. 옵션 &lt;code&gt;d&lt;/code&gt; ( 추가 옵션없이 &lt;code&gt;+B&lt;/code&gt; 를 지정하는 것과 동일 )는 중단 처리기를 비활성화합니다. 옵션 &lt;code&gt;i&lt;/code&gt; 는 에뮬레이터가 브레이크 신호를 무시하게합니다.</target>
        </trans-unit>
        <trans-unit id="326d67c6dd06e800f8ccc7205a53b4bad41af409" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;cache&lt;/code&gt; has no effect if it is known that the QLC is to be evaluated at most once. This is always true for the top-most QLC and also for the list expression of the first generator in a list of qualifiers. Notice that in the presence of side effects in filters or callback functions, the answers to QLCs can be affected by option &lt;code&gt;cache&lt;/code&gt;.</source>
          <target state="translated">QLC가 최대 한 번 평가되는 것으로 알려진 경우 옵션 &lt;code&gt;cache&lt;/code&gt; 는 적용되지 않습니다. 이는 최상위 QLC와 규정 자 목록에서 첫 번째 생성기의 목록 표현식에도 항상 해당됩니다. 필터 또는 콜백 함수에 부작용이있는 경우 QLC에 대한 응답은 옵션 &lt;code&gt;cache&lt;/code&gt; 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7d8de2a211bf879bd6b340617eed0c81c43b5ad" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;cache_all&lt;/code&gt; can be set to &lt;code&gt;ets&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt; when evaluating a query. It adds a &lt;code&gt;cache&lt;/code&gt; or &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; option to every list expression except QLC tables and lists on all levels of the query. This can be used for testing if caching would improve efficiency at all. If the answer is yes, further testing is needed to pinpoint the generators that are to be cached.</source>
          <target state="translated">쿼리를 평가할 때 &lt;code&gt;cache_all&lt;/code&gt; 옵션 을 &lt;code&gt;ets&lt;/code&gt; 또는 &lt;code&gt;list&lt;/code&gt; 로 설정할 수 있습니다 . 그것은 추가 &lt;code&gt;cache&lt;/code&gt; 또는 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 쿼리의 모든 수준에 QLC 테이블 및 목록을 제외한 모든 목록 발현에 옵션을 선택합니다. 캐싱이 효율성을 향상시키는 지 여부를 테스트하는 데 사용할 수 있습니다. 대답이 예인 경우, 캐시 할 생성기를 정확히 찾아 내기 위해 추가 테스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7a829489a7a9e56e844e391961dfa203573e6326" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;capability&lt;/code&gt; specifies the content of a corresponding element in an outgoing hello message, each option specifying the content of a single element. If no base NETCONF capability is configured then the RFC 4741 1.0 capability, &quot;urn:ietf:params:netconf:base:1.0&quot;, is added, otherwise not. In particular, the RFC 6241 1.1 capability must be explicitly configured. NETCONF capabilities can be specified using the shorthand notation defined in RFC 6241, any capability string starting with a colon being prefixed by either &quot;urn:ietf:params:netconf&quot; or &quot;urn:ietf:params:netconf:capability&quot;, as appropriate.</source>
          <target state="translated">옵션 &lt;code&gt;capability&lt;/code&gt; 은 보내는 hello 메시지에서 해당 요소의 콘텐츠를 지정하며 각 옵션은 단일 요소의 콘텐츠를 지정합니다. 기본 NETCONF 기능이 구성되지 않은 경우 RFC 4741 1.0 기능인 &quot;urn : ietf : params : netconf : base : 1.0&quot;이 추가되고 그렇지 않으면 추가되지 않습니다. 특히 RFC 6241 1.1 기능을 명시 적으로 구성해야합니다. NETCONF 기능은 RFC 6241에 정의 된 약식 표기법을 사용하여 지정할 수 있습니다. 콜론으로 시작하는 모든 기능 문자열에는 &quot;urn : ietf : params : netconf&quot;또는 &quot;urn : ietf : params : netconf : capability&quot;가 접두사로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="8f4c8cddaf80a90f873230e5b6a5e7a3ad8af338" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;compile_source&lt;/code&gt; only affects the result if the escript contains &lt;code&gt;source&lt;/code&gt; code. In this case the Erlang code is automatically compiled and &lt;code&gt;{source, BeamCode}&lt;/code&gt; is returned instead of &lt;code&gt;{source, SourceCode}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compile_source&lt;/code&gt; 옵션 은 escript에 &lt;code&gt;source&lt;/code&gt; 코드 가 포함 된 경우에만 결과에 영향을줍니다 . 이 경우 Erlang 코드가 자동으로 컴파일되고 &lt;code&gt;{source, SourceCode}&lt;/code&gt; 대신 &lt;code&gt;{source, BeamCode}&lt;/code&gt; 가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ac2c8d2a46b7ed6d2b62afd37f0558c267adb74" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the Compiler (see &lt;code&gt;compile(3)&lt;/code&gt;) to have debug information, such as &lt;code&gt;Erlang Abstract Format&lt;/code&gt;, stored in the &lt;code&gt;debug_info&lt;/code&gt; chunk. Tools such as Debugger and Xref require the debug information to be included.</source>
          <target state="translated">&lt;code&gt;Erlang Abstract Format&lt;/code&gt; 과 같은 디버그 정보 가 &lt;code&gt;debug_info&lt;/code&gt; 청크에 저장 되도록 &lt;code&gt;debug_info&lt;/code&gt; 옵션을 컴파일러에 지정할 수 있습니다 ( &lt;code&gt;compile(3)&lt;/code&gt; 참조 ) . 디버거 및 외부 참조와 같은 도구에는 디버그 정보가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bceef863ec9665aec5cef62d9d27d0ce6ab12ecb" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;debug_info&lt;/code&gt; causes &lt;strong&gt;debug information&lt;/strong&gt; or &lt;strong&gt;abstract code&lt;/strong&gt; to be added to the &lt;code&gt;.beam&lt;/code&gt; file. This increases the file size and makes it possible to reconstruct the source code. It is therefore recommended not to include debug information in code aimed for target systems.</source>
          <target state="translated">&lt;code&gt;debug_info&lt;/code&gt; 옵션을 사용 하면 &lt;strong&gt;디버그 정보&lt;/strong&gt; 또는 &lt;strong&gt;추상 코드&lt;/strong&gt; 가 &lt;code&gt;.beam&lt;/code&gt; 파일에 추가 됩니다. 파일 크기가 커지고 소스 코드를 재구성 할 수 있습니다. 따라서 대상 시스템을 대상으로하는 코드에 디버그 정보를 포함하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="769f8dc6e95ee290900e92345b3ad7fa81275ab3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;extended_info&lt;/code&gt; specifies what extra information is written to the table dump:</source>
          <target state="translated">&lt;code&gt;extended_info&lt;/code&gt; 옵션 은 테이블 덤프에 기록되는 추가 정보를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7392a715b1ab5247b835edd88a64118c85b3ed71" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;format&lt;/code&gt; also determines what is written to the sorted output file: if &lt;code&gt;Format&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt;, then &lt;code&gt;io:format/3&lt;/code&gt; is called to write each term, otherwise the binary prefixed by a header is written. Notice that the binary written is the same binary that was read; the results of applying function &lt;code&gt;Format&lt;/code&gt; are thrown away when the terms have been sorted. Reading and writing terms using the &lt;code&gt;io&lt;/code&gt; module is much slower than reading and writing binaries.</source>
          <target state="translated">옵션 &lt;code&gt;format&lt;/code&gt; 은 정렬 된 출력 파일에 기록되는 내용도 결정합니다. &lt;code&gt;Format&lt;/code&gt; 이 &lt;code&gt;term&lt;/code&gt; 인 경우 &lt;code&gt;io:format/3&lt;/code&gt; 이 호출되어 각 용어를 쓰며, 그렇지 않으면 머리글이 앞에 붙은 이진이 쓰여집니다. 작성된 바이너리는 읽은 바이너리와 동일합니다. 용어가 정렬되면 함수 &lt;code&gt;Format&lt;/code&gt; 적용 결과가 삭제 됩니다. &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 단어를 읽고 쓰는 것이 바이너리를 읽고 쓰는 것보다 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="c6b86819a94a42b6a35f9a5c83dd920e56cafa28" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;fragment_timer&lt;/code&gt; specifies the timeout, in milliseconds, of a timer used to flush messages from the incoming byte stream even if the number of bytes indicated in the Message Length field of its Diameter Header have not yet been accumulated: such a message is received over the transport interface after two successive timeouts without the reception of additional bytes. Defaults to 1000.</source>
          <target state="translated">&lt;code&gt;fragment_timer&lt;/code&gt; 옵션 은 지름 헤더의 메시지 길이 필드에 표시된 바이트 수가 아직 누적되지 않은 경우에도 수신 바이트 스트림에서 메시지를 플러시하는 데 사용되는 타이머의 시간 초과 (밀리 초)를 지정합니다. 이러한 메시지는 추가 바이트를 수신하지 않고 두 번의 연속 시간 초과 후 전송 인터페이스. 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="ed047187b33ff5a36de976c2d7f174208794b18a" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;fullsweep_after&lt;/code&gt; makes it possible to specify the maximum number of generational collections before forcing a fullsweep, even if there is room on the old heap. Setting the number to zero disables the general collection algorithm, that is, all live data is copied at every garbage collection.</source>
          <target state="translated">&lt;code&gt;fullsweep_after&lt;/code&gt; 옵션 을 사용하면 이전 힙에 공간이 있어도 전체 스위프를 수행하기 전에 최대 세대 콜렉션 수를 지정할 수 있습니다. 숫자를 0으로 설정하면 일반 수집 알고리즘이 비활성화됩니다. 즉, 모든 라이브 데이터가 모든 가비지 수집에서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="ecaf25cf5459dfb31ebf85a2facfaa8a1ab4324e" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;hosts&lt;/code&gt; has no effect if &lt;code&gt;log_type&lt;/code&gt; is set to &lt;code&gt;html&lt;/code&gt; or &lt;code&gt;silent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;log_type&lt;/code&gt; 이 &lt;code&gt;html&lt;/code&gt; 또는 &lt;code&gt;silent&lt;/code&gt; 로 설정된 경우 옵션 &lt;code&gt;hosts&lt;/code&gt; 는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="64143a1b2e482aa0e161fd7b97567d3f14883e09" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;in_comment_only&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; by default, which is correct for Erlang source files. If set to &lt;code&gt;false&lt;/code&gt;, the encoding string does not necessarily have to occur in a comment.</source>
          <target state="translated">&lt;code&gt;in_comment_only&lt;/code&gt; 옵션 은 기본적으로 &lt;code&gt;true&lt;/code&gt; 이며 Erlang 소스 파일에 적합합니다. &lt;code&gt;false&lt;/code&gt; 로 설정 되면 인코딩 문자열이 주석에서 반드시 발생할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebc5aecdab80e23de01ab20e75171559f54d5713" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;inet6&lt;/code&gt; has no effect on this function. You probably want to use &lt;code&gt;Type = a | aaaa&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;inet6&lt;/code&gt; 옵션 은이 기능에 영향을 미치지 않습니다. 아마도 &lt;code&gt;Type = a | aaaa&lt;/code&gt; 대신에.</target>
        </trans-unit>
        <trans-unit id="8ca5f10fb139927f4989778fe340ba3f7bdbce64" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;ipv6_host_with_bracket&lt;/code&gt; deals with how to parse IPv6 addresses. For details, see argument &lt;code&gt;Options&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#request-4&quot;&gt;request/[4,5]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;ipv6_host_with_bracket&lt;/code&gt; 은 IPv6 주소를 구문 분석하는 방법을 다룹니다. 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;#request-4&quot;&gt;request/[4,5]&lt;/a&gt;&lt;/code&gt; 인수 &lt;code&gt;Options&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29e3299985763e8c1fce58b82fc31709b15fd60b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;join&lt;/code&gt; can be used to force the &lt;code&gt;qlc&lt;/code&gt; module to use a certain join method. For the rest of this section it is assumed that the excessively slow join method called &quot;nested loop&quot; has been chosen:</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈이 특정 결합 방법을 사용 하도록 옵션 &lt;code&gt;join&lt;/code&gt; 사용할 수 있습니다 . 이 섹션의 나머지 부분에서는 &quot;중첩 루프&quot;라는 과도하게 느린 조인 방법이 선택되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="895c90440d351c3b981bbc05eca735daa09f36b0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;join&lt;/code&gt; does not imply that the test terms are merged, only that all tests are executed in one single test run.</source>
          <target state="translated">옵션 &lt;code&gt;join&lt;/code&gt; 은 테스트 용어가 병합됨을 의미하지 않으며 모든 테스트가 단일 테스트 실행으로 실행된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="176adb220c5fcd1ac1d87552301af2b1ded87f73" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;line_length&lt;/code&gt; also applies to &lt;code&gt;http*&lt;/code&gt; packet types as an alias for option &lt;code&gt;packet_size&lt;/code&gt; if &lt;code&gt;packet_size&lt;/code&gt; itself is not set. This use is only intended for backward compatibility.</source>
          <target state="translated">옵션 &lt;code&gt;line_length&lt;/code&gt; 는 또한 적용 &lt;code&gt;http*&lt;/code&gt; 옵션에 대한 별칭으로 패킷 유형 &lt;code&gt;packet_size&lt;/code&gt; 경우 &lt;code&gt;packet_size&lt;/code&gt; 자체가 설정되어 있지 않습니다. 이 사용은 이전 버전과의 호환성을 위해서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab41e9f6eb5eab4065b30a808546e5a4a2b51e9" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;message_cb&lt;/code&gt; specifies a callback that is invoked on incoming and outgoing messages, that can be used to implement flow control. It is applied to two arguments: an atom indicating the reason for the callback (&lt;code&gt;send&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt;, or &lt;code&gt;ack&lt;/code&gt; after a completed send), and the message in question (binary() on &lt;code&gt;recv&lt;/code&gt;, binary() or diameter_packet record on &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;ack&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt; on &lt;code&gt;ack&lt;/code&gt; when an incoming request has been discarded). It should return a list of actions and a new callback as tail; eg. &lt;code&gt;[fun cb/3, State]&lt;/code&gt;. Valid actions are the atoms &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;recv&lt;/code&gt;, to cause a following message-valued action to be sent/received, a message to send/receive (binary() or diameter_packet record), or a boolean() to enable/disable reading on the socket. More than one &lt;code&gt;send&lt;/code&gt;/&lt;code&gt;recv&lt;/code&gt;/message sequence can be returned from the same callback, and an initial &lt;code&gt;send&lt;/code&gt;/&lt;code&gt;recv&lt;/code&gt; can be omitted if the same as the value passed as the callback's first argument. Reading is initially enabled, and returning &lt;code&gt;false&lt;/code&gt; does not imply there cannot be subsequent &lt;code&gt;recv&lt;/code&gt; callbacks since messages may already have been read. An empty tail is equivalent to the prevailing callback. Defaults to a callback equivalent to &lt;code&gt;fun(ack, _) -&amp;gt; []; (_, Msg) -&amp;gt; [Msg] end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message_cb&lt;/code&gt; 옵션 은 플로우 제어를 구현하는 데 사용할 수있는 수신 및 발신 메시지에서 호출되는 콜백을 지정합니다. 콜백의 이유를 나타내는 아톰 ( &lt;code&gt;send&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; 또는 send 완료 후 &lt;code&gt;ack&lt;/code&gt; )과 해당 메시지 ( &lt;code&gt;recv&lt;/code&gt; , binary ()의 binary (), &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;ack&lt;/code&gt; 의 diameter_packet 레코드)에 적용됩니다. 또는 &lt;code&gt;false&lt;/code&gt; 에 &lt;code&gt;ack&lt;/code&gt; 수신 요청)가 폐기되었을 때. 액션 목록과 새로운 콜백을 테일로 반환해야합니다. 예. &lt;code&gt;[fun cb/3, State]&lt;/code&gt; . 유효한 조치는 원자 &lt;code&gt;send&lt;/code&gt; 또는 &lt;code&gt;recv&lt;/code&gt; 다음의 메시지 값 동작을 보내거나 받으려면, 소켓에서 읽기를 활성화 / 비활성화하는 보내기 / 받기 (binary () 또는 diameter_packet 레코드) 또는 boolean () 메시지를 보내십시오. 동일한 콜백에서 둘 이상의 &lt;code&gt;send&lt;/code&gt; / &lt;code&gt;recv&lt;/code&gt; / message 시퀀스를 리턴 할 수 있으며 콜백의 첫 번째 인수로 전달 된 값과 동일한 경우 초기 &lt;code&gt;send&lt;/code&gt; / &lt;code&gt;recv&lt;/code&gt; 를 생략 할 수 있습니다. 읽기는 처음에 활성화되어 있으며 &lt;code&gt;false&lt;/code&gt; 를 반환 한다고해서 메시지를 이미 읽었을 수 있으므로 이후의 &lt;code&gt;recv&lt;/code&gt; 콜백 이있을 수 없습니다 . 빈 꼬리는 일반적인 콜백과 같습니다. 기본적으로 &lt;code&gt;fun(ack, _) -&amp;gt; []; (_, Msg) -&amp;gt; [Msg] end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8d5b9882df46cf953f258565ab460a21016ddc5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;monitor&lt;/code&gt; is not supported by &lt;code&gt;spawn_opt/5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spawn_opt/5&lt;/code&gt; 는 옵션 &lt;code&gt;monitor&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="058fcf7970e7469cb0bc642aad1ff0a1a179cc45" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;multicast_ttl&lt;/code&gt; changes the time-to-live (TTL) for outgoing multicast datagrams to control the scope of the multicasts.</source>
          <target state="translated">&lt;code&gt;multicast_ttl&lt;/code&gt; 옵션 은 발신 멀티 캐스트 데이터 그램에 대한 TTL (Time-to-Live)을 변경하여 멀티 캐스트 범위를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="369ac162beffd61017f1f26b4498fc999c7935c0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;packet&lt;/code&gt; determines how/if an incoming message is packaged into a diameter_packet record. If &lt;code&gt;false&lt;/code&gt; then messages are received as binary(). If &lt;code&gt;true&lt;/code&gt; then as a record with the binary() message in the &lt;code&gt;bin&lt;/code&gt; field and a &lt;code&gt;{stream, Id}&lt;/code&gt; tuple in the &lt;code&gt;transport_data&lt;/code&gt; field, where &lt;code&gt;Id&lt;/code&gt; is the identifier of the inbound stream the message was received on. If &lt;code&gt;raw&lt;/code&gt; then as a record with the received ancillary sctp_sndrcvinfo record in the &lt;code&gt;transport_data&lt;/code&gt; field. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;packet&lt;/code&gt; 은 들어오는 메시지가 diameter_packet 레코드로 패키지되는 방법 / 경우를 결정합니다. 경우 &lt;code&gt;false&lt;/code&gt; 다음 메시지를 바이너리로 수신 (). &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;bin&lt;/code&gt; 필드 의 binary () 메시지 와 &lt;code&gt;transport_data&lt;/code&gt; 필드 의 &lt;code&gt;{stream, Id}&lt;/code&gt; 튜플이 있는 레코드로 , 여기서 &lt;code&gt;Id&lt;/code&gt; 는 메시지가 수신 된 인바운드 스트림의 ID입니다. 만약 &lt;code&gt;raw&lt;/code&gt; 에서 수신 보조 sctp_sndrcvinfo 레코드와 같이 레코드 다음 &lt;code&gt;transport_data&lt;/code&gt; 의 필드. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0baa94c523937f7abe156cc0676d6a21aa0601f3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;pending_driver&lt;/code&gt; is of little use, but is present for completeness, as it is well defined which reload options that can give rise to which delays. However, it can be a good idea to use the same &lt;code&gt;MonitorOption&lt;/code&gt; as the &lt;code&gt;ReloadOption&lt;/code&gt;, if present.</source>
          <target state="translated">&lt;code&gt;pending_driver&lt;/code&gt; 옵션 은 거의 사용되지 않지만 어느 지연을 야기 할 수있는 재로드 옵션이 잘 정의되어 있으므로 완전성을 나타냅니다. 그러나 같은 사용하는 좋은 아이디어가 될 수 &lt;code&gt;MonitorOption&lt;/code&gt; 을 은 AS &lt;code&gt;ReloadOption&lt;/code&gt; (있는 경우).</target>
        </trans-unit>
        <trans-unit id="b9556e70d4bac7e47023b3e6de8358a32c614234" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;persistent&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt; to guarantee that parameters set with &lt;code&gt;set_env/2&lt;/code&gt; are not overridden by those defined in the application resource file on load. This means that persistent values will stick after the application is loaded and also on application reload.</source>
          <target state="translated">&lt;code&gt;set_env/2&lt;/code&gt; 로 설정된 매개 변수 가로드시 애플리케이션 자원 파일에 정의 된 매개 변수로 대체되지 않도록 하기 위해 &lt;code&gt;persistent&lt;/code&gt; 옵션 을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 즉, 영구 값은 응용 프로그램이로드 된 후 응용 프로그램을 다시로드 할 때도 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f5cff995931880f38d32793bedddc8696fd39abc" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;persistent&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt; to guarantee that parameters set with &lt;code&gt;set_env/4&lt;/code&gt; are not overridden by those defined in the application resource file on load. This means that persistent values will stick after the application is loaded and also on application reload.</source>
          <target state="translated">&lt;code&gt;set_env/4&lt;/code&gt; 로 설정된 매개 변수 가로드시 응용 프로그램 자원 파일에 정의 된 매개 변수로 대체되지 않도록 옵션 &lt;code&gt;persistent&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 이는 애플리케이션이로드 된 후 및 애플리케이션을 다시로드 할 때 지속적 값이 유지됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9c0c34736e937a0d6bddb3baef2d644165d26b6e" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;progress&lt;/code&gt; is intended to be used by applications that want to create some type of progress report, such as a progress bar in a GUI. Default for the progress option is &lt;code&gt;ignore&lt;/code&gt;, that is, the option is not used. When the progress option is specified, the following happens when &lt;code&gt;ftp:send/[3,4]&lt;/code&gt; or &lt;code&gt;ftp:recv/[3,4]&lt;/code&gt; are called:</source>
          <target state="translated">옵션 &lt;code&gt;progress&lt;/code&gt; 은 GUI의 진행률 표시 줄과 같은 일부 유형의 진행률 보고서를 생성하려는 응용 프로그램에서 사용하기위한 것입니다. progress 옵션의 기본값은 &lt;code&gt;ignore&lt;/code&gt; 입니다 . 즉, 옵션이 사용되지 않습니다. progress 옵션이 지정되면 &lt;code&gt;ftp:send/[3,4]&lt;/code&gt; 또는 &lt;code&gt;ftp:recv/[3,4]&lt;/code&gt; 가 호출 될 때 다음이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="dbc0c804ab6c1e7a5b640a84e147efe8c10f9c09" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;read_concurrency&lt;/code&gt; can be combined with option &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt; write_concurrency&lt;/a&gt;&lt;/code&gt;. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common.</source>
          <target state="translated">옵션 &lt;code&gt;read_concurrency&lt;/code&gt; 는 옵션과 결합 될 수 &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt; write_concurrency&lt;/a&gt;&lt;/code&gt; . 일반적으로 대규모 동시 읽기 버스트와 대규모 동시 쓰기 버스트가 일반적 일 때 이러한 요소를 결합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="121fc2ac086a7c8d8d3e29d994b8f84bb924c24b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;read_concurrency&lt;/code&gt; can be combined with option &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt;. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common.</source>
          <target state="translated">옵션 &lt;code&gt;read_concurrency&lt;/code&gt; 는 옵션과 결합 될 수 &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt; . 일반적으로 큰 동시 읽기 버스트와 큰 동시 쓰기 버스트가 공통 인 경우 이들을 결합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ce25f3241dc3da9e62005bbb6632271b6187acc5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;repair&lt;/code&gt; is ignored if the table is already open.</source>
          <target state="translated">테이블이 이미 열려 있으면 옵션 &lt;code&gt;repair&lt;/code&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="cebc9a26a2692e09f8edba6efb06adb14bf3202b" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;report_errors&lt;/code&gt; adds the possibility that an error tuple is returned. The tuple either indicates a matching error (&lt;code&gt;match_limit&lt;/code&gt; or &lt;code&gt;match_limit_recursion&lt;/code&gt;), or a compilation error, where the error tuple has the format &lt;code&gt;{error, {compile, CompileErr}}&lt;/code&gt;. Notice that if option &lt;code&gt;report_errors&lt;/code&gt; is not specified, the function never returns error tuples, but reports compilation errors as a &lt;code&gt;badarg&lt;/code&gt; exception and failed matches because of exceeded match limits simply as &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;report_errors&lt;/code&gt; 옵션 은 오류 튜플이 반환 될 가능성을 추가합니다. 튜플은 일치하는 오류 ( &lt;code&gt;match_limit&lt;/code&gt; 또는 &lt;code&gt;match_limit_recursion&lt;/code&gt; ) 또는 오류 튜플의 형식이 &lt;code&gt;{error, {compile, CompileErr}}&lt;/code&gt; . &lt;code&gt;report_errors&lt;/code&gt; 옵션을 지정 하지 않으면 이 함수는 오류 튜플을 반환하지 않지만 컴파일 오류를 &lt;code&gt;badarg&lt;/code&gt; 예외 로보고 하고 일치 한계를 단순히 &lt;code&gt;nomatch&lt;/code&gt; 로 초과했기 때문에 일치하지 않은 것으로 보고 합니다.</target>
        </trans-unit>
        <trans-unit id="4fc492ec1e8bbd2f982156bf23c1f5fcad8e8282" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;sender&lt;/code&gt; specifies whether or not to use a dedicated process for sending outgoing messages, which avoids the possibility of send blocking reception. Defaults to &lt;code&gt;false&lt;/code&gt;. If set to &lt;code&gt;true&lt;/code&gt; then a &lt;code&gt;message_cb&lt;/code&gt; that avoids the possibility of messages being queued in the sender process without bound should be configured.</source>
          <target state="translated">&lt;code&gt;sender&lt;/code&gt; 옵션은 발신 메시지 전송을위한 전용 프로세스를 사용할지 여부를 지정하여 송신 차단 수신 가능성을 방지합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;code&gt;true&lt;/code&gt; 로 설정 되면 송신자 프로세스에서 메시지가 바인드되지 않고 대기 할 가능성을 피하는 &lt;code&gt;message_cb&lt;/code&gt; 를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="50b59aee750b8ace41d580c775edcd5cf8326a92" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;ssl_options&lt;/code&gt; must be specified for a transport that should support TLS: a value of &lt;code&gt;true&lt;/code&gt; results in a TLS handshake immediately upon connection establishment while &lt;code&gt;list()&lt;/code&gt; specifies options to be passed to &lt;code&gt;ssl:connect/2&lt;/code&gt; or &lt;code&gt;ssl:ssl_accept/2&lt;/code&gt; after capabilities exchange if TLS is negotiated.</source>
          <target state="translated">TLS를 지원해야하는 전송에 옵션 &lt;code&gt;ssl_options&lt;/code&gt; 를 지정해야합니다. &lt;code&gt;true&lt;/code&gt; 값은 연결 설정 즉시 TLS 핸드 셰이크를 발생시키는 반면 &lt;code&gt;list()&lt;/code&gt; 기능 교환 후 &lt;code&gt;ssl:connect/2&lt;/code&gt; 또는 &lt;code&gt;ssl:ssl_accept/2&lt;/code&gt; 에 전달 될 옵션을 지정 합니다. TLS가 협상 된 경우</target>
        </trans-unit>
        <trans-unit id="eb0b2c00845747ebfd6a57dac944c8489e34fe1d" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; (milliseconds) is used when setting up the SSH connection and when waiting for the &lt;code&gt;hello&lt;/code&gt; message from the server. It is not used for any other purposes during the lifetime of the connection.</source>
          <target state="translated">SSH 연결을 설정 하고 서버에서 &lt;code&gt;hello&lt;/code&gt; 메시지를 기다릴 때 옵션 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)가 사용됩니다 . 연결 수명 동안 다른 용도로는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afc7cede7fbac62c14c694ddc0b6eec6bf4a0ae3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; (milliseconds) is used when setting up the SSH connection. It is not used for any other purposes during the lifetime of the connection.</source>
          <target state="translated">SSH 연결을 설정할 때 옵션 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)가 사용됩니다. 연결 수명 동안 다른 용도로는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33648c8e4866da798d09c425a4d8d5d74a5e0058" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; specifies how long the client must wait for prompt. If the time expires, the function returns &lt;code&gt;{error,timeout}&lt;/code&gt;. For information about the default value for the command timeout, see the &lt;code&gt;&lt;a href=&quot;#Default_values&quot;&gt;list of default values&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">옵션 &lt;code&gt;timeout&lt;/code&gt; 는 클라이언트가 프롬프트를 기다려야하는 시간을 지정합니다. 시간이 만료되면 함수는 &lt;code&gt;{error,timeout}&lt;/code&gt; 을 반환합니다 . 명령 시간 종료 기본값에 대한 정보 는이 모듈의 시작 부분에있는 &lt;code&gt;&lt;a href=&quot;#Default_values&quot;&gt;list of default values&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3322b8eb2ac3b0d6c5921c1fd7368fb6163c677f" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;timeout&lt;/code&gt; specifies the number of milliseconds to allow for connection establishment and, if the function in question results in an outgoing hello message, reception of the server hello. The timeout applies to connection and hello independently; one timeout for connection establishment, another for hello reception.</source>
          <target state="translated">옵션 &lt;code&gt;timeout&lt;/code&gt; 은 연결 설정을 허용하는 밀리 초 수를 지정하고 문제의 기능이 나가는 hello 메시지를 생성하는 경우 서버 hello의 수신을 허용합니다. 제한 시간은 connection 및 hello에 독립적으로 적용됩니다. 하나는 연결 설정을위한 것이고 다른 하나는 hello 수신을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c0719ab2fd2367d9658fdeb70a32aaa618f2e49" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;unicode&lt;/code&gt; is an alias for &lt;code&gt;utf8&lt;/code&gt;, as this is the preferred encoding for Unicode characters in binaries. &lt;code&gt;utf16&lt;/code&gt; is an alias for &lt;code&gt;{utf16,big}&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; is an alias for &lt;code&gt;{utf32,big}&lt;/code&gt;. The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; 옵션 은 바이너리의 유니 코드 문자에 대해 선호되는 인코딩이므로 &lt;code&gt;utf8&lt;/code&gt; 의 별명입니다 . &lt;code&gt;utf16&lt;/code&gt; 은 &lt;code&gt;{utf16,big}&lt;/code&gt; 의 별명 이고 &lt;code&gt;utf32&lt;/code&gt; 는 &lt;code&gt;{utf32,big}&lt;/code&gt; 의 별명입니다 . 원자 &lt;code&gt;big&lt;/code&gt; 및 &lt;code&gt;little&lt;/code&gt; 나타낸다 BIG-또는 리틀 엔디안 인코딩.</target>
        </trans-unit>
        <trans-unit id="dd54ba2652e6caa2fdc53e186c7711e64ef49755" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;unordered&lt;/code&gt; specifies whether or not to use unordered delivery, integer &lt;code&gt;N&lt;/code&gt; being equivalent to &lt;code&gt;N =&amp;lt; OS&lt;/code&gt;, where &lt;code&gt;OS&lt;/code&gt; is the number of outbound streams negotiated on the association in question. Regardless of configuration, sending is ordered on stream 0 until reception of a second incoming message, to ensure that a peer receives capabilities exchange messages before any other. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unordered&lt;/code&gt; 옵션은 비 순차 전달을 사용할지 여부를 지정합니다. 정수 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;N =&amp;lt; OS&lt;/code&gt; 와 같습니다. 여기서 &lt;code&gt;OS&lt;/code&gt; 는 해당 연관에 대해 협상 된 아웃 바운드 스트림의 수입니다. 구성에 관계없이, 피어는 두 번째 수신 메시지를 수신 할 때까지 스트림 0에서 순서가 정해져 피어가 다른 것보다 먼저 메시지를 교환 할 수있는 기능을 수신 할 수 있습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9437b2aaf317ba6723d7637ccb49bca377c204e5" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;variables&lt;/code&gt; can be used to specify an installation directory other than &lt;code&gt;$ROOT/lib&lt;/code&gt; for some of the applications. If a variable &lt;code&gt;{VarName,Prefix}&lt;/code&gt; is specified and an application is found in a directory &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt;, this application gets the path &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; in the boot script. If an application is found in a directory &lt;code&gt;Prefix/Rest&lt;/code&gt;, the path is &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt;. When starting Erlang, all variables &lt;code&gt;VarName&lt;/code&gt; are given values using command-line flag &lt;code&gt;boot_var&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;variables&lt;/code&gt; 는 일부 응용 프로그램에 대해 &lt;code&gt;$ROOT/lib&lt;/code&gt; 이외의 설치 디렉토리를 지정하는 데 사용될 수 있습니다 . 변수 &lt;code&gt;{VarName,Prefix}&lt;/code&gt; 가 지정되고 응용 프로그램이 &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt; ,이 응용 프로그램은 부트 스크립트에서 &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; 경로를 가져옵니다 . 응용 프로그램이 &lt;code&gt;Prefix/Rest&lt;/code&gt; 디렉토리에있는 경우 경로는 &lt;code&gt;VarName/Rest/App-Vsn/ebin&lt;/code&gt; 입니다. Erlang을 시작할 때 모든 변수 &lt;code&gt;VarName&lt;/code&gt; 에는 명령 행 플래그 &lt;code&gt;boot_var&lt;/code&gt; 를 사용하여 값이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fe4cb46f323a7c472497777738ff73ebf76a2c2" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;variables&lt;/code&gt; can be used to specify an installation directory other than &lt;code&gt;lib&lt;/code&gt; for some of the applications. If variable &lt;code&gt;{VarName,Prefix}&lt;/code&gt; is specified and an application is found in directory &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt;, this application is packed into a separate &lt;code&gt;VarName.tar.gz&lt;/code&gt; file as &lt;code&gt;Rest/App-Vsn/ebin&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;variables&lt;/code&gt; 를 사용하여 일부 응용 프로그램에 대해 &lt;code&gt;lib&lt;/code&gt; 이외의 설치 디렉토리를 지정할 수 있습니다 . 변수 &lt;code&gt;{VarName,Prefix}&lt;/code&gt; 가 지정되고 애플리케이션이 &lt;code&gt;Prefix/Rest/App[-Vsn]/ebin&lt;/code&gt; 에있는 경우이 애플리케이션은 별도의 &lt;code&gt;VarName.tar.gz&lt;/code&gt; 파일에 &lt;code&gt;Rest/App-Vsn/ebin&lt;/code&gt; 으로 압축 됩니다.</target>
        </trans-unit>
        <trans-unit id="a5d38b5eca75c6ce7a8a86d89951c54beea09b28" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;verbose&lt;/code&gt; (or rather &lt;code&gt;{verbose,true}&lt;/code&gt;) causes diagnostics printout through &lt;code&gt;io:format/2&lt;/code&gt; of queries, replies retransmissions, and so on, similar to from utilities, such as &lt;code&gt;dig&lt;/code&gt; and &lt;code&gt;nslookup&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;verbose&lt;/code&gt; (또는 오히려 &lt;code&gt;{verbose,true}&lt;/code&gt; )는 &lt;code&gt;io:format/2&lt;/code&gt; 쿼리를 통해 진단 결과를 출력하고 , 재발송 등에 응답하며, &lt;code&gt;dig&lt;/code&gt; 및 &lt;code&gt;nslookup&lt;/code&gt; 과 같은 유틸리티에서와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="3a9444c4853f083de328fc1ee9ccc9ae214b7bd7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;verbose&lt;/code&gt; can be added to get information about the generated files:</source>
          <target state="translated">생성 된 파일에 대한 정보를 얻기 위해 옵션 &lt;code&gt;verbose&lt;/code&gt; 를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72dc8b34cd621366e301671b30bbc40e7b1100a0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;write_concurrency&lt;/code&gt; can be combined with option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt;. You typically want to combine these when large concurrent read bursts and large concurrent write bursts are common; for more information, see option &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;write_concurrency&lt;/code&gt; 는 옵션과 결합 될 수 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt; . 일반적으로 큰 동시 읽기 버스트와 큰 동시 쓰기 버스트가 공통 인 경우 이들을 결합하려고합니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;#new_2_read_concurrency&quot;&gt;read_concurrency&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9faea62aad9078a0a76ca4af9ddb6c33c84d32" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; can be used to cache the answers to a QLC. The answers are stored in one ETS table for each cached QLC. When a cached QLC is evaluated again, answers are fetched from the table without any further computations. Therefore, when all answers to a cached QLC have been found, the ETS tables used for caching answers to the qualifiers of the QLC can be emptied. Option &lt;code&gt;cache&lt;/code&gt; is equivalent to &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 를 사용하여 QLC에 대한 답변을 캐시 할 수 있습니다. 답변은 캐시 된 각 QLC에 대해 하나의 ETS 테이블에 저장됩니다. 캐시 된 QLC가 다시 평가되면 추가 계산없이 테이블에서 답변을 가져옵니다. 따라서 캐시 된 QLC에 대한 모든 응답을 찾으면 QLC의 규정 자에 대한 응답을 캐싱하는 데 사용되는 ETS 테이블을 비울 수 있습니다. 옵션 &lt;code&gt;cache&lt;/code&gt; 는 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f0b3ecf3fceaf01bc2ca34bef8c3c517c967e629" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; can be used to cache the answers to a QLC like &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;. The difference is that the answers are kept in a list (on the process heap). If the answers would occupy more than a certain amount of RAM memory, a temporary file is used for storing the answers. Option &lt;code&gt;max_list_size&lt;/code&gt; sets the limit in bytes and the temporary file is put on the directory set by option &lt;code&gt;tmpdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; 와 같은 QLC에 대한 답변을 캐시 할 수 있습니다 . 차이점은 답변이 프로세스 힙의 목록에 유지된다는 것입니다. 응답이 특정 양의 RAM 메모리보다 많은 공간을 차지하는 경우 임시 파일을 사용하여 응답을 저장합니다. &lt;code&gt;max_list_size&lt;/code&gt; 옵션 은 바이트 단위로 한계를 설정하고 임시 파일은 &lt;code&gt;tmpdir&lt;/code&gt; 옵션으로 설정된 디렉토리에 놓 입니다.</target>
        </trans-unit>
        <trans-unit id="c363b0b99cf0b9f17d626eea478292453b3a04e0" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; offers the possibility to store the answers in a list on the process heap. This has the potential of being faster than ETS tables, as there is no need to copy answers from the table. However, it can often result in slower evaluation because of more garbage collections of the process heap and increased RAM memory consumption because of larger heaps. Another drawback with cache lists is that if the list size exceeds a limit, a temporary file is used. Reading the answers from a file is much slower than copying them from an ETS table. But if the available RAM memory is scarce, setting the &lt;code&gt;&lt;a href=&quot;#max_list_size&quot;&gt;limit&lt;/a&gt;&lt;/code&gt; to some low value is an alternative.</source>
          <target state="translated">옵션 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; 는 프로세스 힙의 목록에 답변을 저장할 수있는 가능성을 제공합니다. 테이블에서 응답을 복사 할 필요가 없으므로 ETS 테이블보다 빠를 가능성이 있습니다. 그러나 프로세스 힙의 가비지 콜렉션이 많고 힙이 클수록 RAM 메모리 소비가 증가하여 평가 속도가 느려질 수 있습니다. 캐시 목록의 또 다른 단점은 목록 크기가 제한을 초과하면 임시 파일이 사용된다는 것입니다. 파일에서 답을 읽는 것이 ETS 테이블에서 복사하는 것보다 훨씬 느립니다. 그러나 사용 가능한 RAM 메모리가 부족한 경우 &lt;code&gt;&lt;a href=&quot;#max_list_size&quot;&gt;limit&lt;/a&gt;&lt;/code&gt; 을 일부 낮은 값으로 설정하는 것이 대안입니다.</target>
        </trans-unit>
        <trans-unit id="78277a7753947f4b67c1f00cd1efea245ef61134" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{exit_on_close, false}&lt;/code&gt; is useful if the peer has done a shutdown on the write side.</source>
          <target state="translated">피어가 쓰기 측에서 종료를 수행 한 경우 옵션 &lt;code&gt;{exit_on_close, false}&lt;/code&gt; 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="06b017310b210415f4e3f5ffc5d41bfadc6c3b12" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{join,&amp;nbsp;Join}&lt;/code&gt; can be used to ensure that a certain join method is used:</source>
          <target state="translated">&lt;code&gt;{join,&amp;nbsp;Join}&lt;/code&gt; 옵션을 사용하여 특정 결합 방법이 사용되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30fedae2cf205df5ff8623315cf8962b5f1bff95" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{lookup,&amp;nbsp;true}&lt;/code&gt; can be used to ensure that the &lt;code&gt;qlc&lt;/code&gt; module looks up constants in some QLC table. If there are more than one QLC table among the list expressions of the generators, constants must be looked up in at least one of the tables. The evaluation of the query fails if there are no constants to look up. This option is useful when it would be unacceptable to traverse all objects in some table. Setting option &lt;code&gt;lookup&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; ensures that no constants are looked up (&lt;code&gt;{max_lookup,&amp;nbsp;0}&lt;/code&gt; has the same effect). Defaults to &lt;code&gt;any&lt;/code&gt;, which means that constants are looked up whenever possible.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈이 일부 QLC 테이블에서 상수를 &lt;code&gt;{lookup,&amp;nbsp;true}&lt;/code&gt; 옵션을 사용할 수 있습니다 . 생성기의 목록 표현식 중에 둘 이상의 QLC 테이블이있는 경우, 하나 이상의 테이블에서 상수를 찾아야합니다. 조회 할 상수가 없으면 조회 평가에 실패합니다. 이 옵션은 일부 테이블의 모든 객체를 통과 할 수없는 경우에 유용합니다. 옵션 &lt;code&gt;lookup&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 상수가 조회 되지 않습니다 ( &lt;code&gt;{max_lookup,&amp;nbsp;0}&lt;/code&gt; 의 효과는 동일 함). 기본값은 &lt;code&gt;any&lt;/code&gt; 로 , 가능할 때마다 상수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e9c6fcc69606cfd5e227d68821d1d1d7a8fea3e4" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{minor_version, Version}&lt;/code&gt; can be used to control some encoding details. This option was introduced in Erlang/OTP R11B-4. The valid values for &lt;code&gt;Version&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;{minor_version, Version}&lt;/code&gt; 옵션을 사용하여 일부 인코딩 세부 사항을 제어 할 수 있습니다. 이 옵션은 Erlang / OTP R11B-4에서 도입되었습니다. &lt;code&gt;Version&lt;/code&gt; 의 유효한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9c3856b6828cbaadee3b68b65792a41e0088ebf" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{minor_version, Version}&lt;/code&gt; specifies how floats are encoded. For a detailed description, see &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt; term_to_binary/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;{minor_version, Version}&lt;/code&gt; 은 부동 소수점 인코딩 방법을 지정합니다. 자세한 설명은 &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt; term_to_binary/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe3131626c8fb97f4a37a0360d9d266a8a597be3" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{minor_version, Version}&lt;/code&gt; specifies how floats are encoded. For a detailed description, see &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{minor_version, Version}&lt;/code&gt; 옵션 은 부동 소수점을 인코딩하는 방법을 지정합니다. 자세한 설명은 &lt;code&gt;&lt;a href=&quot;#term_to_binary-2&quot;&gt;term_to_binary/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="524c17823f60e5f4fb7f4313f11efaa80a725ce7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{shell, ShellType}&lt;/code&gt; allows making &lt;code&gt;ttb&lt;/code&gt; operation similar to &lt;code&gt;dbg&lt;/code&gt;. Using &lt;code&gt;{shell, true}&lt;/code&gt; displays all trace messages in the shell before storing them. &lt;code&gt;{shell, only}&lt;/code&gt; additionally disables message storage (making the tool to behave exactly like &lt;code&gt;dbg&lt;/code&gt;). This is allowed only with IP trace ports (&lt;code&gt;{trace, {local, File}}&lt;/code&gt;).</source>
          <target state="translated">옵션 &lt;code&gt;{shell, ShellType}&lt;/code&gt; 사용하면 &lt;code&gt;dbg&lt;/code&gt; 와 비슷한 &lt;code&gt;ttb&lt;/code&gt; 작업을 수행 할 수 있습니다 . &lt;code&gt;{shell, true}&lt;/code&gt; 사용하면 저장하기 전에 모든 추적 메시지가 쉘에 표시됩니다. &lt;code&gt;{shell, only}&lt;/code&gt; 메시지 저장 기능을 추가로 비활성화합니다 (도구가 &lt;code&gt;dbg&lt;/code&gt; 와 똑같이 동작하게 함 ). 이는 IP 추적 포트 ( &lt;code&gt;{trace, {local, File}}&lt;/code&gt; ) 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef42e9a1232f5a9ba117da4d9479739de508ecd1" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; can be used to remove duplicate answers to a QLC. The unique answers are stored in one ETS table for each QLC. The table is emptied every time it is known that there are no more answers to the QLC. Option &lt;code&gt;unique&lt;/code&gt; is equivalent to &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;. If option &lt;code&gt;unique&lt;/code&gt; is combined with option &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt;, two ETS tables are used, but the full answers are stored in one table only. If option &lt;code&gt;unique&lt;/code&gt; is combined with option &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt;, the answers are sorted twice using &lt;code&gt;&lt;a href=&quot;#keysort-3&quot;&gt;keysort/3&lt;/a&gt;&lt;/code&gt;; once to remove duplicates and once to restore the order.</source>
          <target state="translated">옵션 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 를 사용하여 QLC에 대한 중복 답변을 제거 할 수 있습니다. 고유 한 답변은 각 QLC에 대해 하나의 ETS 테이블에 저장됩니다. QLC에 대한 응답이 더 이상 없음을 알 때마다 테이블이 비워집니다. 옵션 &lt;code&gt;unique&lt;/code&gt; 는 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 와 같습니다 . 옵션 경우 &lt;code&gt;unique&lt;/code&gt; 옵션과 결합 &lt;code&gt;{cache,&amp;nbsp;ets}&lt;/code&gt; , 두 ETS 테이블이 사용되지만, 전체 응답은 단 하나 개의 테이블에 저장됩니다. 옵션 경우 &lt;code&gt;unique&lt;/code&gt; 옵션과 결합 &lt;code&gt;{cache,&amp;nbsp;list}&lt;/code&gt; , 답변을 사용하여 두 번 분류되어 &lt;code&gt;&lt;a href=&quot;#keysort-3&quot;&gt;keysort/3&lt;/a&gt;&lt;/code&gt; ; 한 번은 중복을 제거하고 한 번은 주문을 복원합니다.</target>
        </trans-unit>
        <trans-unit id="d03fe843ff69bab217c2db04a4de76a5997a0834" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;{var_tar,VarTar}&lt;/code&gt; can be used to specify if and where a separate package is to be stored. In this option &lt;code&gt;VarTar&lt;/code&gt; is one of the following:</source>
          <target state="translated">&lt;code&gt;{var_tar,VarTar}&lt;/code&gt; 옵션을 사용하여 별도의 패키지를 저장할 위치와 위치를 지정할 수 있습니다. 이 옵션에서 &lt;code&gt;VarTar&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="035817bcba72e336831559d60aeb6facccf9b64f" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Close&lt;/strong&gt; executes &lt;code&gt;erlang:port_close/1&lt;/code&gt; on the port under the mouse pointer.</source>
          <target state="translated">옵션 &lt;strong&gt;닫기&lt;/strong&gt; 는 마우스 포인터 아래의 포트에서 &lt;code&gt;erlang:port_close/1&lt;/code&gt; 을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="35e926c6fbc3d99b909d12d014b384bd4c783eb2" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Kill process&lt;/strong&gt; brutally kills the processes under the mouse pointer by sending an exit signal with reason &lt;code&gt;kill&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;strong&gt;Kill process&lt;/strong&gt; 는 reason &lt;code&gt;kill&lt;/code&gt; 과 함께 종료 신호를 보내 마우스 포인터 아래의 &lt;strong&gt;프로세스를&lt;/strong&gt; 잔인하게 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="70321865963caf3c8ea1efe0081cc07fb0b639e6" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Port info&lt;/strong&gt; opens a detailed information window for the port under the mouse pointer. In addition to the information above, it also shows links and monitors.</source>
          <target state="translated">옵션 &lt;strong&gt;포트 정보&lt;/strong&gt; 는 마우스 포인터 아래에 포트에 대한 자세한 정보 창을 엽니 다. 위의 정보 외에도 링크 및 모니터도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d65b0f04dbfd40d29f90c9cb3594f974e725b28" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Process info&lt;/strong&gt; opens a detailed information window on the process under the mouse pointer, including the following:</source>
          <target state="translated">옵션 &lt;strong&gt;프로세스 정보&lt;/strong&gt; 는 다음을 포함하여 마우스 포인터 아래의 프로세스에 대한 자세한 정보 창을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="99160977b4d7a39a2a6e97003b66bdad996bc6ed" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected ports by name&lt;/strong&gt; adds the registered name of the port to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;. This can be useful when tracing is done on many nodes, as ports with that name are then traced on all traced nodes.</source>
          <target state="translated">옵션 &lt;strong&gt;이름으로 선택한 포트 추적은 포트&lt;/strong&gt; 의 등록 된 이름을 탭 &lt;strong&gt;개요에 추가&lt;/strong&gt; 합니다. 이 이름을 가진 포트가 모든 추적 노드에서 추적되므로 많은 노드에서 추적을 수행 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b6c236e8cdc6b5cda5c55b97f093a7e3cd6785f" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected ports&lt;/strong&gt; adds the selected port identifiers, and the nodes that the ports reside on, to tab &lt;strong&gt;Trace Overview&lt;/strong&gt;.</source>
          <target state="translated">옵션 &lt;strong&gt;선택된 포트 추적&lt;/strong&gt; 은 선택된 포트 식별자와 포트가있는 노드를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ac9ff1921b3900c17896467fd0d99ce466117b8b" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected processes by name&lt;/strong&gt; adds the registered name of the processes. This can be useful when tracing is done on many nodes, as processes with that name are then traced on all traced nodes.</source>
          <target state="translated">옵션 &lt;strong&gt;이름으로 선택한 프로세스 추적&lt;/strong&gt; 은 등록 된 &lt;strong&gt;프로세스 이름을&lt;/strong&gt; 추가합니다. 이 이름을 가진 프로세스가 모든 추적 노드에서 추적되므로 많은 노드에서 추적을 수행 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f5a98945509d3374dcec511a2237bb11d72c5e8" translate="yes" xml:space="preserve">
          <source>Option &lt;strong&gt;Trace selected processes&lt;/strong&gt; adds the selected process identifiers to tab &lt;strong&gt;Trace Overview&lt;/strong&gt; plus the node that the processes reside on.</source>
          <target state="translated">&lt;strong&gt;선택된 프로세스 추적&lt;/strong&gt; 옵션 은 선택된 프로세스 식별자를 &lt;strong&gt;추적 개요&lt;/strong&gt; 탭 과 프로세스가있는 노드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bbcdc0d51603836feb28f7c0f6ebeff6083e909a" translate="yes" xml:space="preserve">
          <source>Option can be an empty list. Otherwise, see possible &lt;strong&gt;POSIX&lt;/strong&gt; names in Section 8 in &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt; RFC 4254&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션은 빈 목록 일 수 있습니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4254.txt&quot;&gt; RFC 4254&lt;/a&gt;&lt;/code&gt; 의 섹션 8에서 가능한 &lt;strong&gt;POSIX&lt;/strong&gt; 이름을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed343dc73ff17a12eae43c4c8abcaf085a15af89" translate="yes" xml:space="preserve">
          <source>Option description:</source>
          <target state="translated">옵션 설명 :</target>
        </trans-unit>
        <trans-unit id="842a1436ee68919d09edec512df7b86300e0f790" translate="yes" xml:space="preserve">
          <source>Option for the request to be synchronous or asynchronous.</source>
          <target state="translated">요청이 동기식이거나 비동기식 인 옵션.</target>
        </trans-unit>
        <trans-unit id="1293048f15d31bf84b0b730a9b1782f9b01e778a" translate="yes" xml:space="preserve">
          <source>Option list, required but not used.</source>
          <target state="translated">필수이지만 사용되지 않은 옵션 목록.</target>
        </trans-unit>
        <trans-unit id="462548ed78075584c1554197ff33d7cd930b932f" translate="yes" xml:space="preserve">
          <source>Option passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. Has one of the following types.</source>
          <target state="translated">옵션이 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; 로 전달되었습니다 . 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="23707ebafb992d8dfae9b58a9ba61d8c8fd2c70a" translate="yes" xml:space="preserve">
          <source>Option passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;. Can be any &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; as well as the following.</source>
          <target state="translated">옵션이 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; 로 전달되었습니다 . 다음과 같은 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c6c4102d4dfec3b1aa41117e0e344046c58a151" translate="yes" xml:space="preserve">
          <source>Optional</source>
          <target state="translated">Optional</target>
        </trans-unit>
        <trans-unit id="4d4b2106cdcb3604717e69731f6481a51f9daa36" translate="yes" xml:space="preserve">
          <source>Optional Header Elements</source>
          <target state="translated">선택적 헤더 요소</target>
        </trans-unit>
        <trans-unit id="dfbb34787505eab01012f74ede55769d7b2752c8" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code id=&quot;hook_function&quot;&gt;HookFunction&lt;/code&gt;, shown in the functions described in this module, defines a function that is called when an unknown form occurs where there is to be a valid expression. If &lt;code&gt;HookFunction&lt;/code&gt; is equal to &lt;code&gt;none&lt;/code&gt;, there is no hook function.</source>
          <target state="translated">이 모듈에 설명 된 함수에 표시된 선택적 인수 &lt;code id=&quot;hook_function&quot;&gt;HookFunction&lt;/code&gt; 은 유효한 표현식이있는 곳에서 알 수없는 양식이 발생할 때 호출되는 함수를 정의합니다. 경우 &lt;code&gt;HookFunction&lt;/code&gt; 가 같은지 &lt;code&gt;none&lt;/code&gt; 어떠한 후크 함수가 없다.</target>
        </trans-unit>
        <trans-unit id="276de84647d247405111dca217abe17bdd0364d3" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code&gt;NumberOfAnswers&lt;/code&gt; determines the maximum number of answers returned. Defaults to &lt;code&gt;10&lt;/code&gt;. If less than the requested number of answers is returned, subsequent calls to &lt;code&gt;next_answers&lt;/code&gt; return &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;code&gt;NumberOfAnswers&lt;/code&gt; 는 반환되는 최대 답변 수를 결정합니다. 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다. 요청 된 수보다 적은 수의 응답이 반환되면 &lt;code&gt;next_answers&lt;/code&gt; 에 대한 후속 호출이 &lt;code&gt;[]&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8e155301399a6f11bab8a0f03e661dc264bf4113" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;code&gt;Timeout&lt;/code&gt; specifies a time-out in milliseconds. The default value is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;code&gt;Timeout&lt;/code&gt; 은 시간 초과를 밀리 초로 지정합니다. 기본값은 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc160da129ae196cb0bc016f6e6b2dc9018a93f1" translate="yes" xml:space="preserve">
          <source>Optional disc. The schema can reside on disc or in RAM. If the schema is found on disc, Mnesia starts as a disc-based node and the storage type of the schema table is &lt;code&gt;disc_copies&lt;/code&gt;. If no schema is found on disc, Mnesia starts as a disc-less node and the storage type of the schema table is &lt;code&gt;ram_copies&lt;/code&gt;. Default value for the application parameter is &lt;code&gt;opt_disc&lt;/code&gt;.</source>
          <target state="translated">옵션 디스크. 스키마는 디스크 나 RAM에있을 수 있습니다. 디스크에 스키마가있는 경우 Mnesia는 디스크 기반 노드로 시작하며 스키마 테이블의 스토리지 유형은 &lt;code&gt;disc_copies&lt;/code&gt; 입니다. 디스크에 스키마가 없으면 Mnesia는 디스크없는 노드로 시작하며 스키마 테이블의 스토리지 유형은 &lt;code&gt;ram_copies&lt;/code&gt; 입니다. 애플리케이션 매개 변수의 기본값은 &lt;code&gt;opt_disc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08766916e383f04d3e4dd8436f435e4ff78d676e" translate="yes" xml:space="preserve">
          <source>Optional disc. The schema can reside on either disc or RAM. If the schema is found on disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-full node (the storage type of the schema table is disc_copies). If no schema is found on disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node (the storage type of the schema table is &lt;code&gt;ram_copies&lt;/code&gt;). The default for the application parameter is &lt;code&gt;opt_disc&lt;/code&gt;.</source>
          <target state="translated">옵션 디스크. 스키마는 디스크 또는 RAM에있을 수 있습니다. 디스크에서 스키마가 발견되면 &lt;code&gt;Mnesia&lt;/code&gt; 는 디스크가 가득 찬 노드로 시작합니다 (스키마 테이블의 스토리지 유형은 disc_copies입니다). 디스크에 스키마가 없으면 &lt;code&gt;Mnesia&lt;/code&gt; 는 디스크가없는 노드로 시작합니다 (스키마 테이블의 스토리지 유형은 &lt;code&gt;ram_copies&lt;/code&gt; 입니다 ). 애플리케이션 매개 변수의 기본값은 &lt;code&gt;opt_disc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="85dd2f62ecb3fc58781f23223662bb5750bb8b07" translate="yes" xml:space="preserve">
          <source>Optional fields are to be omitted from the map if they have no value:</source>
          <target state="translated">선택적 필드는 값이없는 경우 맵에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f7ff2e1b639664116012253b69978817d7cb9d18" translate="yes" xml:space="preserve">
          <source>Optional parameter that indicates which stream of event is of interest. If not present, events in the default NETCONF stream are sent.</source>
          <target state="translated">관심있는 이벤트 스트림을 나타내는 선택적 매개 변수입니다. 존재하지 않으면 기본 NETCONF 스트림의 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9f20bc591a797de16d0e389435598756b6d01a90" translate="yes" xml:space="preserve">
          <source>Optional parameter that indicates which subset of all possible events is of interest. The parameter format is the same as that of the filter parameter in the NETCONF protocol operations. If not present, all events not precluded by other parameters are sent.</source>
          <target state="translated">관심있는 모든 가능한 이벤트의 서브 세트를 나타내는 선택적 매개 변수입니다. 매개 변수 형식은 NETCONF 프로토콜 조작에서 필터 매개 변수의 형식과 동일합니다. 존재하지 않으면 다른 매개 변수에 의해 제외되지 않은 모든 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="91c8bbcc154e216bf161a4cea2cf2921f55e3375" translate="yes" xml:space="preserve">
          <source>Optional parameter used to trigger the replay feature and indicate that the replay is to start at the time specified. If &lt;code&gt;StartTime&lt;/code&gt; is not present, this is not a replay subscription.</source>
          <target state="translated">재생 기능을 트리거하고 지정된 시간에 재생이 시작됨을 나타내는 데 사용되는 선택적 매개 변수입니다. 경우 &lt;code&gt;StartTime&lt;/code&gt; 존재하지 않는, 이것은 재생 가입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b62c08c67213d147aac035093ce60b242c49707" translate="yes" xml:space="preserve">
          <source>Optional parameter used with the optional replay feature to indicate the newest notifications of interest. If &lt;code&gt;StopTime&lt;/code&gt; is not present, the notifications continues until the subscription is terminated.</source>
          <target state="translated">선택적 재생 기능과 함께 사용되는 선택적 매개 변수는 최신 관심 알림을 나타냅니다. 경우 &lt;code&gt;StopTime&lt;/code&gt; 이 존재하지 않는 가입이 종료 될 때까지 알림이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="a4149a55fc8e55fc8490190fca6fd327f9a538b3" translate="yes" xml:space="preserve">
          <source>Optional.</source>
          <target state="translated">Optional.</target>
        </trans-unit>
        <trans-unit id="e8af255ca8f0d30288a7d242bda54e97c39eddd8" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3e770d9ae3be1592b6bb4e71a2a0b4d02b632c8" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;agentEngine&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;agentEngine&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f444f3a32fb5864a64535a82d40b191fe3d8f92a" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;ct_test&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;ct_test&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d86ff1cf1753eeb2712d25027e36b3bfeeb878b3" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;&quot;mgrEngine&quot;&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;&quot;mgrEngine&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a5be38a4ec672fa5fc505b1d3938e2c4805690c" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;4000&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;4000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d818395035fabb022c90708c6cc84ee8b4b5af1" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;484&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;484&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb016daeda5d1c2dc4395fae5d7f67d4983388a1" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;5000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a91274ea47ca456c7c73bd65eabdba098688b45e" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;[v2]&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;[v2]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9145bb534991daf57f7701301bbf91899e9dd502" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1862eeb7c8ff53d3ad48a0810e5755cdc2bd4c3" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;localhost&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56e30788f63a5934b2591e0b2064ad81f73c70ba" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50d0a6ed5f07cbf3535d40a94c01a427fc76812c" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;trap&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;trap&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81e97dcaaa41ca3300b210af9cb347aabd6782bc" translate="yes" xml:space="preserve">
          <source>Optional. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">선택 과목. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7a5e868b1b2f32a86b5bd642dcb3afd6a406ab2" translate="yes" xml:space="preserve">
          <source>Optional. SNMPv3 only.</source>
          <target state="translated">선택 과목. SNMPv3에만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e29d2e9b1f6270c8f759be9d98bdcc632686ece6" translate="yes" xml:space="preserve">
          <source>Optional. Specifies a file name relative to the release directory (that is, the subdirectory of &amp;lt;release root&amp;gt; where the &lt;code&gt;.boot&lt;/code&gt; file and others are located). The contents of this file is appended to the command line when Erlang is started. This makes it easy to start the emulator with different options for different releases.</source>
          <target state="translated">선택 과목. 릴리스 디렉토리를 기준으로 파일 이름을 지정합니다 (즉, &lt;code&gt;.boot&lt;/code&gt; 파일 및 기타 파일이 있는 &amp;lt;release root&amp;gt;의 하위 디렉토리 ). 이 파일의 내용은 Erlang이 시작될 때 명령 행에 추가됩니다. 따라서 릴리스마다 다른 옵션으로 에뮬레이터를 쉽게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0c96e71650acccc82db9e27a628d2721580904" translate="yes" xml:space="preserve">
          <source>Optional. Specifies another data file than &lt;code&gt;start_erl.data&lt;/code&gt; in the &amp;lt;release root&amp;gt;. It is specified relative to the &amp;lt;release root&amp;gt; or absolute (including drive letter, and so on). This option is used by the release handler during upgrade and is not to be used during normal operation. Normally the release data file is not to be named differently.</source>
          <target state="translated">선택 과목. &amp;lt;release root&amp;gt;에서 &lt;code&gt;start_erl.data&lt;/code&gt; 이외의 다른 데이터 파일을 지정합니다 . &amp;lt;릴리즈 루트&amp;gt; 또는 절대 값 (드라이브 문자 등 포함)에 대해 지정됩니다. 이 옵션은 업그레이드 중에 릴리스 핸들러에서 사용되며 정상 작동 중에는 사용되지 않습니다. 일반적으로 릴리스 데이터 파일의 이름은 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="6e896a68b07b1ca3cf93595378b5e6e78183b5ae" translate="yes" xml:space="preserve">
          <source>Optional. Specifies what &lt;code&gt;start_erl.data&lt;/code&gt; file to use.</source>
          <target state="translated">선택 과목. 사용할 &lt;code&gt;start_erl.data&lt;/code&gt; 파일을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="8dfb648c156e19ccfde0a8a75080225f82a66290" translate="yes" xml:space="preserve">
          <source>Optional: a list of</source>
          <target state="translated">선택 사항 :</target>
        </trans-unit>
        <trans-unit id="40298ed5ccf236464308dd175b962b82475a2522" translate="yes" xml:space="preserve">
          <source>Optional: one or more</source>
          <target state="translated">선택 사항 : 하나 이상</target>
        </trans-unit>
        <trans-unit id="c38ca1d794e5db4040d672952825698f938f1b2b" translate="yes" xml:space="preserve">
          <source>Optionally an associated condition. A condition is a tuple &lt;code&gt;{Module,Name}&lt;/code&gt;. When the breakpoint is reached, &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; is called. If it evaluates to &lt;code&gt;true&lt;/code&gt;, execution stops. If it evaluates to &lt;code&gt;false&lt;/code&gt;, the breakpoint is ignored. &lt;code&gt;Bindings&lt;/code&gt; contains the current variable bindings. To retrieve the value for a specified variable, use &lt;code&gt;get_binding&lt;/code&gt;.</source>
          <target state="translated">선택적으로 관련 조건. 조건은 튜플 &lt;code&gt;{Module,Name}&lt;/code&gt; 입니다. 중단 점에 도달하면 &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; 이 호출됩니다. &lt;code&gt;true&lt;/code&gt; 로 평가 되면 실행이 중지됩니다. &lt;code&gt;false&lt;/code&gt; 로 평가 되면 중단 점이 무시됩니다. &lt;code&gt;Bindings&lt;/code&gt; 은 현재 변수 바인딩을 포함합니다. 지정된 변수의 값을 검색하려면 &lt;code&gt;get_binding&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a4282aaa4b303055b863e5204685bc1397a847f" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a time consuming transaction request</source>
          <target state="translated">시간 소모적 인 트랜잭션 요청에 대해 선택적으로 호출</target>
        </trans-unit>
        <trans-unit id="c6c8e1e5181e25bac7195f77b91e7ea903739f23" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a transaction acknowledgement</source>
          <target state="translated">트랜잭션 승인을 위해 선택적으로 호출</target>
        </trans-unit>
        <trans-unit id="a5f2278c7ee5f9556ced2e826a1b917355402ad3" translate="yes" xml:space="preserve">
          <source>Optionally invoked for a transaction reply</source>
          <target state="translated">트랜잭션 응답을 위해 선택적으로 호출</target>
        </trans-unit>
        <trans-unit id="da6a3730bb2085f8ebf92b6273cda1787e65e75e" translate="yes" xml:space="preserve">
          <source>Optionally specifies how captured substrings are to be returned. If omitted, the default of &lt;code&gt;index&lt;/code&gt; is used.</source>
          <target state="translated">선택적으로 캡처 된 하위 문자열이 리턴되는 방법을 지정합니다. 생략하면 &lt;code&gt;index&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9a37fc27a14f568c026b4fd05c32a49102ca20f" translate="yes" xml:space="preserve">
          <source>Optionaly, in case of &lt;code&gt;publickey&lt;/code&gt; authorization, one or more of the remote user's public keys in the &lt;code&gt;&lt;a href=&quot;#USERDIR&quot;&gt;USERDIR&lt;/a&gt;&lt;/code&gt; directory are used. See the files &lt;code&gt;&lt;a href=&quot;#FILE-authorized_keys&quot;&gt;USERDIR/authorized_keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#FILE-authorized_keys2&quot;&gt;USERDIR/authorized_keys2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Optionaly의 경우 &lt;code&gt;publickey&lt;/code&gt; 인증, 하나 또는에서 원격 사용자의 공개 키의 더 &lt;code&gt;&lt;a href=&quot;#USERDIR&quot;&gt;USERDIR&lt;/a&gt;&lt;/code&gt; 디렉토리 사용된다. &lt;code&gt;&lt;a href=&quot;#FILE-authorized_keys&quot;&gt;USERDIR/authorized_keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#FILE-authorized_keys2&quot;&gt;USERDIR/authorized_keys2&lt;/a&gt;&lt;/code&gt; 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="9749013cefa7f03d17b664b15412b1588b737407" translate="yes" xml:space="preserve">
          <source>Options (&lt;code&gt;Opt&lt;/code&gt;s):</source>
          <target state="translated">옵션 ( &lt;code&gt;Opt&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="1cc6e01afd8e684ce4b8791ec94b07a2736be0c2" translate="yes" xml:space="preserve">
          <source>Options :: [create_opt()]) -&amp;gt;</source>
          <target state="translated">옵션 :: [create_opt ()])-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a71724fb98cff6a19705fe029e03eebb720115b" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;-P&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, and &lt;code&gt;-S&lt;/code&gt; are equivalent to &lt;code&gt;+'P'&lt;/code&gt;, &lt;code&gt;+'E'&lt;/code&gt;, and &lt;code&gt;+'S'&lt;/code&gt;, except that it is not necessary to include the single quotes to protect them from the shell.</source>
          <target state="translated">옵션 &lt;code&gt;-P&lt;/code&gt; , &lt;code&gt;-E&lt;/code&gt; 및 &lt;code&gt;-S&lt;/code&gt; 는 &lt;code&gt;+'P'&lt;/code&gt; , &lt;code&gt;+'E'&lt;/code&gt; 및 &lt;code&gt;+'S'&lt;/code&gt; 와 동일합니다. 단, 따옴표를 포함하여 쉘에서 보호 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0366a9ebac5c17541c6d26640b461361c80a4a4" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt; are used to log on to the remote host &lt;code&gt;Host&lt;/code&gt;. &lt;code&gt;Username&lt;/code&gt;, if omitted, defaults to the current username. &lt;code&gt;Password&lt;/code&gt; is empty by default.</source>
          <target state="translated">옵션 &lt;code&gt;Username&lt;/code&gt; 및 &lt;code&gt;Password&lt;/code&gt; 는 원격 호스트 &lt;code&gt;Host&lt;/code&gt; 에 로그온하는 데 사용됩니다 . &lt;code&gt;Username&lt;/code&gt; 이 생략되면 기본값은 현재 사용자 이름입니다. &lt;code&gt;Password&lt;/code&gt; 는 기본적으로 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dcd58b0792b2c9e9c3b6819e8f16b982914d604" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;encoding&lt;/code&gt; are common for all I/O servers in OTP, while &lt;code&gt;echo&lt;/code&gt; and &lt;code&gt;expand&lt;/code&gt; are valid only for this I/O server. Option &lt;code&gt;unicode&lt;/code&gt; notifies how characters are put on the physical I/O device, that is, if the terminal itself is Unicode-aware. It does not affect how characters are sent in the I/O protocol, where each request contains encoding information for the provided or returned data.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 및 &lt;code&gt;encoding&lt;/code&gt; 옵션 은 OTP의 모든 I / O 서버에 공통이며 &lt;code&gt;echo&lt;/code&gt; 및 &lt;code&gt;expand&lt;/code&gt; 은이 I / O 서버에만 유효합니다. 옵션 &lt;code&gt;unicode&lt;/code&gt; 는 문자가 물리적 I / O 장치에 배치되는 방법, 즉 터미널 자체가 유니 코드를 인식하는 경우를 알려줍니다. I / O 프로토콜에서 문자를 보내는 방법에는 영향을 미치지 않으며, 각 요청에는 제공된 또는 반환 된 데이터에 대한 인코딩 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8ff02c5f14ce17a7d5799eee0ac8c1ea2bf12c76" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;cache&lt;/code&gt; and &lt;code&gt;unique&lt;/code&gt; apply not only to the QLC itself but also to the results of looking up constants, running match specifications, and joining handles.</source>
          <target state="translated">옵션 &lt;code&gt;cache&lt;/code&gt; 및 &lt;code&gt;unique&lt;/code&gt; 는 QLC 자체뿐만 아니라 상수 조회, 일치 스펙 실행 및 핸들 결합의 결과에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9580f262070eeecb51ff008fdc6585d927dbc1f8" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;{scope, part()}&lt;/code&gt; work as for &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;. The return type is always a &lt;code&gt;binary()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 및 &lt;code&gt;{scope, part()}&lt;/code&gt; 옵션 은 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 과 동일하게 작동 합니다. 반환 유형은 항상 &lt;code&gt;binary()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75961960aaa5db134dc677d4d398db1f86aa02d2" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; specify the server endpoint to which to connect, and are passed directly to &lt;code&gt;ssh:connect/4&lt;/code&gt;, as are arbitrary ssh options. Common options are &lt;code&gt;user&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;user_dir&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 는 연결할 서버 엔드 포인트를 지정하고 임의의 ssh 옵션과 마찬가지로 &lt;code&gt;ssh:connect/4&lt;/code&gt; 로 직접 전달됩니다 . 일반적인 옵션은 &lt;code&gt;user&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; 및 &lt;code&gt;user_dir&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="51c09aef080d57e48a07185acafc8ce6ebec94f6" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;message_cb&lt;/code&gt; and &lt;code&gt;sender&lt;/code&gt; have semantics identical to those documented in &lt;code&gt;&lt;a href=&quot;diameter_tcp#sender&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt;, but with the message argument to a &lt;code&gt;recv&lt;/code&gt; callback being as directed by the &lt;code&gt;packet&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;message_cb&lt;/code&gt; 및 &lt;code&gt;sender&lt;/code&gt; 옵션 은 &lt;code&gt;&lt;a href=&quot;diameter_tcp#sender&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; 설명 된 것과 동일한 의미를 갖지만 &lt;code&gt;recv&lt;/code&gt; 콜백에 대한 메시지 인수 는 &lt;code&gt;packet&lt;/code&gt; 옵션에 의해 지시됩니다 .</target>
        </trans-unit>
        <trans-unit id="668ebce6eb26637e08574b22c150f48b118e610d" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;monitor&lt;/code&gt; and &lt;code&gt;link&lt;/code&gt; are ignored in the list-valued case. An MFA is applied with an additional term prepended to its argument list, and should return either the pid of the handler process that invokes &lt;code&gt;diameter_traffic:request/1&lt;/code&gt; on the argument in order to process the request, or the atom &lt;code&gt;discard&lt;/code&gt;. The handler process need not be local, and diameter need not be started on the remote node, but diameter and relevant application callbacks must be on the code path.</source>
          <target state="translated">옵션 &lt;code&gt;monitor&lt;/code&gt; 및 &lt;code&gt;link&lt;/code&gt; 는 목록 값 케이스에서 무시됩니다. MFA는 인수 목록 앞에 추가 용어가 추가 된 상태로 적용되며 &lt;code&gt;diameter_traffic:request/1&lt;/code&gt; 을 처리하기 위해 인수에 diameter_traffic : request / 1 을 호출하는 핸들러 프로세스의 pid를 반환하거나 atom을 &lt;code&gt;discard&lt;/code&gt; 합니다. 핸들러 프로세스는 로컬 일 필요는 없으며 diameter는 원격 노드에서 시작될 필요가 없지만 diameter 및 관련 애플리케이션 콜백은 코드 경로에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e61d32b3cca20de20d192710649075d0fa3c950e" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;raddr&lt;/code&gt; and &lt;code&gt;rport&lt;/code&gt; specify the remote address and port for a connecting transport and are not valid for a listening transport.</source>
          <target state="translated">&lt;code&gt;raddr&lt;/code&gt; 및 &lt;code&gt;rport&lt;/code&gt; 옵션 은 연결 전송의 원격 주소와 포트를 지정하며 수신 전송에는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9f19d6b068a72ffa150ad3783e561ce5a572f10" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;raddr&lt;/code&gt; and &lt;code&gt;rport&lt;/code&gt; specify the remote address and port for a connecting transport and not valid for a listening transport: the former is required while latter defaults to 3868 if unspecified. Multiple &lt;code&gt;raddr&lt;/code&gt; options can be specified, in which case the connecting transport in question attempts each in sequence until an association is established.</source>
          <target state="translated">&lt;code&gt;raddr&lt;/code&gt; 및 &lt;code&gt;rport&lt;/code&gt; 옵션 은 연결 전송에 대한 원격 주소와 포트를 지정하며 수신 전송에는 유효하지 않습니다. 전자는 필수이며 후자는 지정되지 않은 경우 기본값은 3868입니다. 여러 &lt;code&gt;raddr&lt;/code&gt; 옵션을 지정할 수 있으며,이 경우 해당 연결 전송은 연결이 설정 될 때까지 각각 순서대로 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ffb596bacd291beb9c0f85faa25b79b4527311a4" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt; can be combined to match a sequence multiple times.</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; 옵션 과 &lt;code&gt;sequence&lt;/code&gt; 옵션을 조합하여 시퀀스를 여러 번 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a156299ace864a0d2165f732e3884af6ab552b9" translate="yes" xml:space="preserve">
          <source>Options Accepted By escript</source>
          <target state="translated">escript에서 허용되는 옵션</target>
        </trans-unit>
        <trans-unit id="3253e08c4676ac3d9e5c7ba947d4ff7346f3e690" translate="yes" xml:space="preserve">
          <source>Options Menu</source>
          <target state="translated">옵션 메뉴</target>
        </trans-unit>
        <trans-unit id="e81a184b61cbd5436906125ea2fd1369abbf5985" translate="yes" xml:space="preserve">
          <source>Options allow to customize the behaviour of the scanner. See also &lt;code&gt;tutorial&lt;/code&gt; on customization functions.</source>
          <target state="translated">옵션을 통해 스캐너의 동작을 사용자 정의 할 수 있습니다. 사용자 정의 기능에 대한 &lt;code&gt;tutorial&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1df937b910b748dfde76ee563a39943f8c8982a" translate="yes" xml:space="preserve">
          <source>Options allow to customize the behaviour of the validation.</source>
          <target state="translated">옵션을 통해 유효성 검사 동작을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d2339a2a5eabae774a416fb2e29a52c85a83319" translate="yes" xml:space="preserve">
          <source>Options allows to customize the behaviour of the XPath scanner.</source>
          <target state="translated">옵션을 사용하면 XPath 스캐너의 동작을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ffa2c48bad8b2b21cb7fd3c0cdc61a21bc9b14c" translate="yes" xml:space="preserve">
          <source>Options are processed in the order they occur in the list, that is, later options have higher precedence.</source>
          <target state="translated">옵션은 목록에서 발생하는 순서대로 처리됩니다. 즉, 나중에 옵션이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="5257320eb8c67ae70e398e048755a4a432e71e80" translate="yes" xml:space="preserve">
          <source>Options available to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; when sending an outgoing Diameter request. Has one of the following types.</source>
          <target state="translated">나가는 지름 요청을 보낼 때 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 할 수있는 옵션 . 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="43baa3cfdab8fbfb50fe057ed27dea4648766c66" translate="yes" xml:space="preserve">
          <source>Options can be set to make the release package include source code and the ERTS binary as well.</source>
          <target state="translated">릴리스 패키지에 소스 코드와 ERTS 바이너리도 포함되도록 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5ad669703dff008e4b32951b24529560fa2ff0" translate="yes" xml:space="preserve">
          <source>Options common to clients and daemons</source>
          <target state="translated">클라이언트 및 데몬에 공통적 인 옵션</target>
        </trans-unit>
        <trans-unit id="19f6806cc859d20b910b98cdb91856f7d205c282" translate="yes" xml:space="preserve">
          <source>Options defining a Diameter application. Has one of the following types.</source>
          <target state="translated">직경 응용 프로그램을 정의하는 옵션. 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="85fa7bc47c34fb7d169b6cba28b8680c98650d6d" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cmd-2&quot;&gt;os:cmd/2&lt;/a&gt;&lt;/code&gt; 에 대한 옵션</target>
        </trans-unit>
        <trans-unit id="c747f7830167fa762f894dbecb9703a094daa7ee" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;clients&lt;/a&gt;&lt;/code&gt;. The individual options are further explained below or by following the hyperlinks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;clients&lt;/a&gt;&lt;/code&gt; 위한 옵션 . 개별 옵션에 대해서는 아래 또는 하이퍼 링크를 통해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7a1ffff775190d7efc280e2ad290e1f4ea5665b9" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#daemon-1&quot;&gt;daemons&lt;/a&gt;&lt;/code&gt;. The individual options are further explained below or by following the hyperlinks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#daemon-1&quot;&gt;daemons&lt;/a&gt;&lt;/code&gt; 옵션 . 개별 옵션에 대해서는 아래 또는 하이퍼 링크를 통해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b1da4f4ded338618658f16678eab34365d8af2b8" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;&lt;a href=&quot;#spawn_opt-4&quot;&gt;spawn_opt()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#spawn_opt-4&quot;&gt;spawn_opt()&lt;/a&gt;&lt;/code&gt; 옵션 .</target>
        </trans-unit>
        <trans-unit id="eb4d9d68b8a4bdc7b530015f01b070a24bbaaaae" translate="yes" xml:space="preserve">
          <source>Options for ROOT, Intermediate and Peer certs</source>
          <target state="translated">루트, 중급 및 피어 인증서에 대한 옵션</target>
        </trans-unit>
        <trans-unit id="9042d93fd9440ddea881c97ce0150fe0b79baee4" translate="yes" xml:space="preserve">
          <source>Options for hardening are described in the &lt;code&gt;&lt;a href=&quot;hardening&quot;&gt;Hardening SSH&lt;/a&gt;&lt;/code&gt; chapter. How the options for algorithm configuration interact are described in the &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; chapter.</source>
          <target state="translated">강화 옵션은 &lt;code&gt;&lt;a href=&quot;hardening&quot;&gt;Hardening SSH&lt;/a&gt;&lt;/code&gt; 장에 설명되어 있습니다. 알고리즘 구성 옵션이 상호 작용하는 &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; 장 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="566dbd8ceb4282768aef5cb41d2fb475cfe4f53a" translate="yes" xml:space="preserve">
          <source>Options for level &lt;code&gt;ip&lt;/code&gt;:</source>
          <target state="translated">레벨 &lt;code&gt;ip&lt;/code&gt; 대한 옵션 :</target>
        </trans-unit>
        <trans-unit id="b6254ef355357f5050a678c222e0253528618965" translate="yes" xml:space="preserve">
          <source>Options for level &lt;code&gt;ipv6&lt;/code&gt;:</source>
          <target state="translated">레벨 &lt;code&gt;ipv6&lt;/code&gt; 에 대한 옵션 :</target>
        </trans-unit>
        <trans-unit id="282d3bbec47472c7487917ac2473620e7adb1b32" translate="yes" xml:space="preserve">
          <source>Options for level &lt;code&gt;otp&lt;/code&gt;:</source>
          <target state="translated">레벨 &lt;code&gt;otp&lt;/code&gt; 에 대한 옵션 :</target>
        </trans-unit>
        <trans-unit id="fea2e1f6451d5a765df0b487e0d49558cf7a79e9" translate="yes" xml:space="preserve">
          <source>Options for level &lt;code&gt;sctp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sctp&lt;/code&gt; 레벨 옵션 :</target>
        </trans-unit>
        <trans-unit id="29a1be83b21515714e747f576513d1ff3041b0c9" translate="yes" xml:space="preserve">
          <source>Options for level &lt;code&gt;socket&lt;/code&gt;:</source>
          <target state="translated">레벨 &lt;code&gt;socket&lt;/code&gt; 옵션 :</target>
        </trans-unit>
        <trans-unit id="26fc97cb1ab2be800ebf0710071f234e21a67fc7" translate="yes" xml:space="preserve">
          <source>Options for level &lt;code&gt;tcp&lt;/code&gt;:</source>
          <target state="translated">레벨 &lt;code&gt;tcp&lt;/code&gt; 에 대한 옵션 :</target>
        </trans-unit>
        <trans-unit id="357a3218944002f2aa86ac8760669dc098099654" translate="yes" xml:space="preserve">
          <source>Options for level &lt;code&gt;udp&lt;/code&gt;:</source>
          <target state="translated">레벨 &lt;code&gt;udp&lt;/code&gt; 에 대한 옵션 :</target>
        </trans-unit>
        <trans-unit id="1ff564237d1265e1d9e5c013163df9ff0e749c0f" translate="yes" xml:space="preserve">
          <source>Options for public key encrypt/decrypt. Only RSA is supported.</source>
          <target state="translated">공개 키 암호화 / 복호화 옵션. RSA 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="90b13cdea6bce419cba673b7f212cd4d1f015a67" translate="yes" xml:space="preserve">
          <source>Options for sign and verify.</source>
          <target state="translated">서명 및 확인 옵션.</target>
        </trans-unit>
        <trans-unit id="de2af7cb9d8a73a31380a359d67d255134013079" translate="yes" xml:space="preserve">
          <source>Options for the default ssh_file callback module</source>
          <target state="translated">기본 ssh_file 콜백 모듈에 대한 옵션</target>
        </trans-unit>
        <trans-unit id="bc2f2c736a746d27a97fe210a5df470704203acf" translate="yes" xml:space="preserve">
          <source>Options for the ssh_agent callback module</source>
          <target state="translated">ssh_agent 콜백 모듈에 대한 옵션</target>
        </trans-unit>
        <trans-unit id="271cee05e17a96561b06a7392bd67ac3d4ab26c5" translate="yes" xml:space="preserve">
          <source>Options in the environment variable EUNIT are also included last in the option list, i.e., have lower precedence than those in &lt;code&gt;Options&lt;/code&gt;.</source>
          <target state="translated">환경 변수 EUNIT의 옵션도 옵션 목록의 마지막에 포함됩니다 (즉, &lt;code&gt;Options&lt;/code&gt; 의 옵션 보다 우선 순위가 낮음) .</target>
        </trans-unit>
        <trans-unit id="2d595c0adb932691342148a1f5ccb473e844d862" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; when spawning a process for an incoming Diameter request. Options &lt;code&gt;monitor&lt;/code&gt; and &lt;code&gt;link&lt;/code&gt; are ignored.</source>
          <target state="translated">들어오는 직경 요청에 대한 프로세스를 생성 할 때 옵션이 &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; 로 전달되었습니다 . 옵션 &lt;code&gt;monitor&lt;/code&gt; 및 &lt;code&gt;link&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6adb442fc6700a7d845b5b6f08d580352873cb" translate="yes" xml:space="preserve">
          <source>Options preceding &lt;code&gt;-erl_args&lt;/code&gt; that &lt;code&gt;Common Test&lt;/code&gt; does not recognize are also passed on to the emulator untouched. By &lt;code&gt;-erl_args&lt;/code&gt; the user can specify flags with the same name, but with different destinations, on the &lt;code&gt;ct_run&lt;/code&gt; command line.</source>
          <target state="translated">위의 옵션 &lt;code&gt;-erl_args&lt;/code&gt; 것이 &lt;code&gt;Common Test&lt;/code&gt; 도 그대로 에뮬레이터에 전달되어 인식하지 않습니다. 에 의해 &lt;code&gt;-erl_args&lt;/code&gt; 사용자는하지만, 서로 다른 목적지로, 같은 이름의 플래그를 지정할 수 있습니다 &lt;code&gt;ct_run&lt;/code&gt; 의 명령 행.</target>
        </trans-unit>
        <trans-unit id="ff1becd31ec7dd72ea26d9a9fd1b56a0ae87b96b" translate="yes" xml:space="preserve">
          <source>Options provided to &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/[3,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/[3,4]&lt;/a&gt;&lt;/code&gt; 에 제공되는 옵션 .</target>
        </trans-unit>
        <trans-unit id="be2f1fd15114f1dab339629da4d391e98859a026" translate="yes" xml:space="preserve">
          <source>Options provided to &lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh#daemon-2&quot;&gt;ssh:daemon/2,3&lt;/a&gt;&lt;/code&gt; 에 제공되는 옵션 .</target>
        </trans-unit>
        <trans-unit id="34209f6f492a2966caf548e5cb61a33749ede09a" translate="yes" xml:space="preserve">
          <source>Options that can be given to the &lt;code&gt;cth_conn_log&lt;/code&gt; hook, which is used for logging of NETCONF and Telnet connections. See &lt;code&gt;&lt;a href=&quot;ct_netconfc#Logging&quot;&gt;ct_netconfc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_telnet#Logging&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; for description and examples of how to use this hook.</source>
          <target state="translated">NETCONF 및 Telnet 연결 로깅에 사용되는 &lt;code&gt;cth_conn_log&lt;/code&gt; 후크에 제공 될 수있는 옵션 . 이 후크를 사용하는 방법에 대한 설명과 예는 &lt;code&gt;&lt;a href=&quot;ct_netconfc#Logging&quot;&gt;ct_netconfc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct_telnet#Logging&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9ee1ea2881fd5e5e1f4f2dcf607eb50c3389b53" translate="yes" xml:space="preserve">
          <source>Options that can be used when starting a &lt;code&gt;gen_statem&lt;/code&gt; server through, &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 서버를 시작할 때 사용할 수있는 옵션 &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="228dffd69b4e3c0e126c643a9f0b0e320c2b02c8" translate="yes" xml:space="preserve">
          <source>Options that can be used when starting a &lt;code&gt;gen_statem&lt;/code&gt; server through, for example, &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3&lt;/a&gt;&lt;/code&gt; 를 통해 gen_statem 서버를 시작할 때 사용할 수있는 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="d6e5101586b632aaf8a368594dc5123cd9322755" translate="yes" xml:space="preserve">
          <source>Options to configure a &lt;code&gt;ErlNifIOQueue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlNifIOQueue&lt;/code&gt; 를 구성하는 옵션 .</target>
        </trans-unit>
        <trans-unit id="23d20f728be4aacef3be89090ba5883ef7e28da2" translate="yes" xml:space="preserve">
          <source>Options used for setting up an SSH connection to a NETCONF server.</source>
          <target state="translated">NETCONF 서버에 대한 SSH 연결을 설정하는 데 사용되는 옵션.</target>
        </trans-unit>
        <trans-unit id="910207f354e542f3e522ad9da85b70501659257e" translate="yes" xml:space="preserve">
          <source>Options used to customize the behaviour of the parser. Possible options are:</source>
          <target state="translated">파서의 동작을 사용자 정의하는 데 사용되는 옵션. 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42d00fed5d36db33cd37d8b52271d2720789f5a2" translate="yes" xml:space="preserve">
          <source>Options) -&amp;gt;</source>
          <target state="translated">옵션)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="6d118f8e941d56db78406a33fb3a53aed05d43fb" translate="yes" xml:space="preserve">
          <source>Options: see &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt;. Note however that for &lt;code&gt;quick_parse_file/2&lt;/code&gt;, the option &lt;code&gt;no_fail&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">옵션은 다음을 참조하십시오 &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file/2&lt;/a&gt;&lt;/code&gt; 를 . 그러나 &lt;code&gt;quick_parse_file/2&lt;/code&gt; 의 경우 &lt;code&gt;no_fail&lt;/code&gt; 옵션 은 기본적으로 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b12501090de711d45f4f134407e2f3085fb7dedb" translate="yes" xml:space="preserve">
          <source>Opts :: [&lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;debug_opt()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;hibernate_after_opt()&lt;/a&gt;&lt;/code&gt;],</source>
          <target state="translated">옵션 :: [ &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;debug_opt()&lt;/a&gt;&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;hibernate_after_opt()&lt;/a&gt;&lt;/code&gt; ],</target>
        </trans-unit>
        <trans-unit id="755886f8ab2742679da1bf59039bff5251443996" translate="yes" xml:space="preserve">
          <source>Opts :: [&lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt;enter_loop_opt()&lt;/a&gt;&lt;/code&gt;],</source>
          <target state="translated">옵션 :: [ &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt;enter_loop_opt()&lt;/a&gt;&lt;/code&gt; ],</target>
        </trans-unit>
        <trans-unit id="9ef1aeb0b64bab0b8696b0aebb6c7bffc58deff9" translate="yes" xml:space="preserve">
          <source>Opts :: [&lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt;start_opt()&lt;/a&gt;&lt;/code&gt;]) -&amp;gt;</source>
          <target state="translated">옵션 :: [ &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt;start_opt()&lt;/a&gt;&lt;/code&gt; ])-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="afce6d0b0f239ad1ab536fe15749163d8cbfb224" translate="yes" xml:space="preserve">
          <source>Opts :: [compressed | verbose | cooked]) -&amp;gt;</source>
          <target state="translated">옵션 :: [압축 | 장황한 | 요리])-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ddc3f14766efb56c4d34a9542fe728065e02b6b" translate="yes" xml:space="preserve">
          <source>Or - if building a 64bit version:</source>
          <target state="translated">또는 64 비트 버전을 빌드하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5326c62b422be5d15a751d74a2dc4fcf60deb938" translate="yes" xml:space="preserve">
          <source>Or calls the following if the process is to terminate:</source>
          <target state="translated">또는 프로세스가 종료 될 경우 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ba69cd0427a638368d97eab4ad9466aab5343d29" translate="yes" xml:space="preserve">
          <source>Or perhaps in combination with constants:</source>
          <target state="translated">또는 상수와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="01433e00bc9b318bce7a3cc505bdb311b1e7b75c" translate="yes" xml:space="preserve">
          <source>Or resulting in the next clause being tested in function heads and case expressions.</source>
          <target state="translated">또는 함수 절과 대소 문자 표현에서 다음 절을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0045ed6a97a1146a04c393e163018af002e6d4f9" translate="yes" xml:space="preserve">
          <source>Or what happens if the server goes down in the middle of sending a message, leaving the sending client hanging forever in the &lt;code&gt;await_result&lt;/code&gt; function?</source>
          <target state="translated">또는 메시지를 보내는 도중에 서버가 다운되어 보내는 클라이언트가 &lt;code&gt;await_result&lt;/code&gt; 함수에 영원히 매달려 있으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="66e4dcf09aeb43d320a42f1b4be9f68e9c1bc539" translate="yes" xml:space="preserve">
          <source>Oracle Java SE JDK -- The Java Development Kit (Standard Edition). Required for building the application &lt;code&gt;jinterface&lt;/code&gt;. At least version 1.6.0 of the JDK is required.</source>
          <target state="translated">Oracle Java SE JDK-Java 개발 키트 (Standard Edition). 응용 프로그램 &lt;code&gt;jinterface&lt;/code&gt; 를 빌드하는 데 필요합니다 . JDK 버전 1.6.0 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="46e91eb4640ec2930b03548b549f832b4d7231f2" translate="yes" xml:space="preserve">
          <source>Order of Versions</source>
          <target state="translated">버전 순서</target>
        </trans-unit>
        <trans-unit id="0bf474cf8ba0ba095b74a741f3d8323580f1cc75" translate="yes" xml:space="preserve">
          <source>Ordered_set Tables</source>
          <target state="translated">Ordered_set 테이블</target>
        </trans-unit>
        <trans-unit id="7d70c02187561212366cd733179443acd95da909" translate="yes" xml:space="preserve">
          <source>Orders &lt;code&gt;Common Test&lt;/code&gt; to repeat execution of all the cases in the group a given number of times, or until any, or all, cases fail or succeed.</source>
          <target state="translated">주어진 횟수만큼 또는 일부 또는 모든 케이스가 실패하거나 성공할 때까지 그룹의 모든 케이스 실행을 반복하도록 &lt;code&gt;Common Test&lt;/code&gt; 를 명령 합니다.</target>
        </trans-unit>
        <trans-unit id="d2f0ae466f7c5d340f95e5db43c368a9a3b0bc8a" translate="yes" xml:space="preserve">
          <source>Orders &lt;code&gt;Common Test&lt;/code&gt; to repeat execution of the cases in the group a given number of times, or until any, or all, cases fail or succeed.</source>
          <target state="translated">주어진 횟수만큼, 또는 일부 또는 전부가 실패하거나 성공할 때까지 그룹에서 사례 실행을 반복하도록 &lt;code&gt;Common Test&lt;/code&gt; 를 주문 합니다.</target>
        </trans-unit>
        <trans-unit id="636580cb18b2a3d3ee70fe45f93fcb8012a1efb3" translate="yes" xml:space="preserve">
          <source>Orders a generic server to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate/2&lt;/a&gt;&lt;/code&gt; before exiting.</source>
          <target state="translated">일반 서버가 지정된 &lt;code&gt;Reason&lt;/code&gt; 와 함께 종료하도록 명령하고 종료 될 때까지 기다립니다. &lt;code&gt;gen_server&lt;/code&gt; 의 과정은 호출 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate/2&lt;/a&gt;&lt;/code&gt; 종료하기 전에.</target>
        </trans-unit>
        <trans-unit id="5112607d3f38b5535b071c81b4e3ced527521a31" translate="yes" xml:space="preserve">
          <source>Orders a generic server to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. The &lt;code&gt;gen_server&lt;/code&gt; process calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; before exiting.</source>
          <target state="translated">지정된 &lt;code&gt;Reason&lt;/code&gt; 를 사용하여 일반 서버를 종료하도록 명령하고 종료 될 때까지 기다립니다. &lt;code&gt;gen_server&lt;/code&gt; 의 과정은 호출 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 종료하기 전에.</target>
        </trans-unit>
        <trans-unit id="addadfcd76036a3c6afad7bab40aa94a4dc339ad" translate="yes" xml:space="preserve">
          <source>Orders event manager &lt;code&gt;EventMgrRef&lt;/code&gt; to exit with the specifies &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. Before terminating, &lt;code&gt;gen_event&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; for each installed event handler.</source>
          <target state="translated">이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 가 지정된 &lt;code&gt;Reason&lt;/code&gt; 와 함께 종료하도록 명령 하고 종료 될 때까지 기다립니다. 종료하기 전에 &lt;code&gt;gen_event&lt;/code&gt; 는 설치된 각 이벤트 핸들러에 대해 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="54d7ea1c4f89a8a332559591ee4debf050cee229" translate="yes" xml:space="preserve">
          <source>Orders event manager &lt;code&gt;EventMgrRef&lt;/code&gt; to exit with the specifies &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. Before terminating, &lt;code&gt;gen_event&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; for each installed event handler.</source>
          <target state="translated">이벤트 관리자 &lt;code&gt;EventMgrRef&lt;/code&gt; 가 지정된 &lt;code&gt;Reason&lt;/code&gt; 를 사용하여 종료하도록 명령 하고 종료를 기다립니다. 종료하기 전에 &lt;code&gt;gen_event&lt;/code&gt; 는 설치된 각 이벤트 핸들러에 대해 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate(stop,...)&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a3f48e6002fbd3799add791dc0a450399f2f90c2" translate="yes" xml:space="preserve">
          <source>Orders the &lt;code&gt;gen_statem&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate. The &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; before exiting.</source>
          <target state="translated">순서 붙이고 &lt;code&gt;gen_statem&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;#type-server_ref&quot;&gt;ServerRef&lt;/a&gt;&lt;/code&gt; 지정된와 출구 &lt;code&gt;Reason&lt;/code&gt; 와이 종료 할 때까지 기다립니다. &lt;code&gt;gen_statem&lt;/code&gt; 는 호출 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 종료하기 전에.</target>
        </trans-unit>
        <trans-unit id="21b34b1ca6772cefd2286c0a8bd7c2c47fffae8f" translate="yes" xml:space="preserve">
          <source>Orders the process to exit with the specified &lt;code&gt;Reason&lt;/code&gt; and waits for it to terminate.</source>
          <target state="translated">주문 지정된와 출구 공정 &lt;code&gt;Reason&lt;/code&gt; 와이 종료 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="a61c180dee133a0d4fb6e99797fd60387a9fa2b3" translate="yes" xml:space="preserve">
          <source>Orders the process to terminate with the specified &lt;code&gt;Reason&lt;/code&gt;. The termination is done asynchronously, so it is not guaranteed that the process is terminated when the function returns.</source>
          <target state="translated">프로세스를 지정된 &lt;code&gt;Reason&lt;/code&gt; 종료하도록 명령합니다 . 종료는 비동기 적으로 수행되므로 함수가 리턴 될 때 프로세스가 종료되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccb8dd4b62075b726550209fcb7d0f2adb744793" translate="yes" xml:space="preserve">
          <source>Ordinary characters that must match the next input character.</source>
          <target state="translated">다음 입력 문자와 일치해야하는 일반 문자</target>
        </trans-unit>
        <trans-unit id="e33058c8aca144db86ea897b7f2317a8d1c1af9d" translate="yes" xml:space="preserve">
          <source>Origin-Host AVP</source>
          <target state="translated">오리진 호스트 AVP</target>
        </trans-unit>
        <trans-unit id="66ca57643d2d91ab73b0b3763337e2fec53749fc" translate="yes" xml:space="preserve">
          <source>Origin-Realm AVP</source>
          <target state="translated">원산지 AVP</target>
        </trans-unit>
        <trans-unit id="236ee85d9ea34d47b8bad24ef64b77e613147f6c" translate="yes" xml:space="preserve">
          <source>Origin-State-Id AVP</source>
          <target state="translated">원산지 상태 ID AVP</target>
        </trans-unit>
        <trans-unit id="8a2b322ac24d0d94010349833607bcb6c362fc2e" translate="yes" xml:space="preserve">
          <source>Origin-State-Id is optional but, if configured, will be included in outgoing CER/CEA and DWR/DWA messages. Setting a value of &lt;code&gt;0&lt;/code&gt; (zero) is equivalent to not setting a value, as documented in RFC 6733. The function &lt;code&gt;&lt;a href=&quot;#origin_state_id-0&quot;&gt;origin_state_id/0&lt;/a&gt;&lt;/code&gt; can be used as to retrieve a value that is computed when the diameter application is started.</source>
          <target state="translated">Origin-State-Id는 선택 사항이지만 구성된 경우 발신 CER / CEA 및 DWR / DWA 메시지에 포함됩니다. RFC 6733에 설명 된대로 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하는 것은 값을 설정하지 않는 것과 같습니다. &lt;code&gt;&lt;a href=&quot;#origin_state_id-0&quot;&gt;origin_state_id/0&lt;/a&gt;&lt;/code&gt; 함수 는 직경 응용 프로그램이 시작될 때 계산되는 값을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a110457753a54db4b2f584279c17319e7442c3ff" translate="yes" xml:space="preserve">
          <source>Original API</source>
          <target state="translated">원본 API</target>
        </trans-unit>
        <trans-unit id="e2f0776017330240cb474fc09a019aea6a403d19" translate="yes" xml:space="preserve">
          <source>Originating a Request</source>
          <target state="translated">요청 시작</target>
        </trans-unit>
        <trans-unit id="c10643b85fbfbd4fbb63e61c52588993e2ffbfa5" translate="yes" xml:space="preserve">
          <source>Oriya</source>
          <target state="translated">Oriya</target>
        </trans-unit>
        <trans-unit id="42cb2600c161bf7bf85310fb50b63266488059bf" translate="yes" xml:space="preserve">
          <source>Osmanya</source>
          <target state="translated">Osmanya</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="e5f5f875b3d15fa11fe3de5896a4e66d7c090218" translate="yes" xml:space="preserve">
          <source>Other (rare) error condition, such as &lt;code&gt;{error, estale}&lt;/code&gt; if reading from an NFS file system.</source>
          <target state="translated">NFS 파일 시스템에서 읽을 경우 &lt;code&gt;{error, estale}&lt;/code&gt; 와 같은 기타 (드문) 오류 조건 .</target>
        </trans-unit>
        <trans-unit id="03965c1e12674420b58d4f32742d1467e2298c0b" translate="yes" xml:space="preserve">
          <source>Other ASN.1 types and values can differ much from these figures. It is therefore important that you, in every case where you intend to use either of these decodes, perform some tests that show if you will benefit your purpose.</source>
          <target state="translated">다른 ASN.1 유형과 값은이 수치와 크게 다를 수 있습니다. 따라서이 디코드 중 하나를 사용하려는 모든 경우에 목적에 도움이 될지 보여주는 몇 가지 테스트를 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c1385ef92fd62e1027c2fed35303a7d7f5d9ee0f" translate="yes" xml:space="preserve">
          <source>Other Flags</source>
          <target state="translated">다른 깃발</target>
        </trans-unit>
        <trans-unit id="dec81ea1827d7684fb9060cf49585a878d5be333" translate="yes" xml:space="preserve">
          <source>Other PCRE-specific options can be set by the application when the compiling or matching functions are called. Sometimes the pattern can contain special leading sequences, such as (*CRLF), to override what the application has set or what has been defaulted. Details are provided in section &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt; Newline Sequences&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">다른 PCRE 관련 옵션은 컴파일 또는 일치 함수가 호출 될 때 응용 프로그램에서 설정할 수 있습니다. 때때로 패턴은 (* CRLF)와 같은 특수 선행 시퀀스를 포함하여 애플리케이션이 설정 한 항목이나 기본값을 대체 할 수 있습니다. 자세한 내용은 이전의 &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt; Newline Sequences&lt;/a&gt;&lt;/code&gt; 섹션에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="db5a9e63db2cdafd4d9a58a4d1e203908f440948" translate="yes" xml:space="preserve">
          <source>Other PCRE-specific options can be set by the application when the compiling or matching functions are called. Sometimes the pattern can contain special leading sequences, such as (*CRLF), to override what the application has set or what has been defaulted. Details are provided in section &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; earlier.</source>
          <target state="translated">컴파일 또는 일치 함수가 호출 될 때 응용 프로그램에서 다른 PCRE 특정 옵션을 설정할 수 있습니다. 경우에 따라 패턴에는 (* CRLF)와 같은 특수 선행 시퀀스가 ​​포함되어 응용 프로그램에서 설정 한 내용이나 기본값을 무시할 수 있습니다. 자세한 내용은 이전 &lt;code&gt;&lt;a href=&quot;#newline_sequences&quot;&gt;Newline Sequences&lt;/a&gt;&lt;/code&gt; 섹션에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f49cb27bb45f84c3f80150dae558a48052d7977" translate="yes" xml:space="preserve">
          <source>Other Storage Media</source>
          <target state="translated">기타 저장 매체</target>
        </trans-unit>
        <trans-unit id="d244aac16bfbb22cf74ea0c33f98a68a4cf6d192" translate="yes" xml:space="preserve">
          <source>Other Tools</source>
          <target state="translated">다른 도구들</target>
        </trans-unit>
        <trans-unit id="302303d7df48684e7df86411d56b9659af7d97fb" translate="yes" xml:space="preserve">
          <source>Other Unicode encodings than integers representing code points or UTF-8 in binaries are referred to as &quot;external encodings&quot;. The ISO Latin-1 encoding is in binaries and lists referred to as latin1-encoding.</source>
          <target state="translated">바이너리에서 코드 포인트 또는 UTF-8을 나타내는 정수 이외의 다른 유니 코드 인코딩을 &quot;외부 인코딩&quot;이라고합니다. ISO Latin-1 인코딩은 바이너리로되어 있으며 latin1-encoding이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ed0cea3720246c22c3a30bbc4492b0bc7ca1703c" translate="yes" xml:space="preserve">
          <source>Other addresses are possible, for example Linux implements &quot;Abstract Addresses&quot;. See the documentation for Unix Domain Sockets on your system, normally &lt;code&gt;unix&lt;/code&gt; in manual section 7.</source>
          <target state="translated">다른 주소들도 가능하다. 예를 들어 리눅스는 &quot;Abstract Addresses&quot;를 구현한다. 시스템의 Unix Domain Sockets 설명서 , 일반적으로 매뉴얼 섹션 7에서 &lt;code&gt;unix&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd29435e6c5d5cb295da7f257e1e953a855af66c" translate="yes" xml:space="preserve">
          <source>Other applications like ssl/tls or https might have options that are passed down to the &lt;code&gt;public_key:pkix_verify_hostname&lt;/code&gt;. You will probably not have to call it directly</source>
          <target state="translated">ssl / tls 또는 https와 같은 다른 애플리케이션에는 &lt;code&gt;public_key:pkix_verify_hostname&lt;/code&gt; 으로 전달되는 옵션이있을 수 있습니다 . 당신은 아마 그것을 직접 호출 할 필요가 없습니다</target>
        </trans-unit>
        <trans-unit id="88b1b43caa29bc1ae4d1876c05734a9c8181e624" translate="yes" xml:space="preserve">
          <source>Other characters represent themselves. Only filenames that have exactly the same character in the same position match. Matching is case-sensitive, for example, &quot;a&quot; does not match &quot;A&quot;.</source>
          <target state="translated">다른 문자는 자신을 나타냅니다. 동일한 위치에서 문자가 정확히 동일한 파일 이름 만 일치합니다. 일치는 대소 문자를 구분합니다. 예를 들어 &quot;a&quot;는 &quot;A&quot;와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14464638b9e33ce4c0d8ac32a7485fa9028da73b" translate="yes" xml:space="preserve">
          <source>Other combinations, such as &lt;code&gt;{Module,'_',Arity}&lt;/code&gt;, are not allowed. Local functions match wildcards only if option &lt;code&gt;local&lt;/code&gt; is in &lt;code&gt;FlagList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{Module,'_',Arity}&lt;/code&gt; 와 같은 다른 조합 은 허용되지 않습니다. local 함수 는 &lt;code&gt;local&lt;/code&gt; 옵션 이 &lt;code&gt;FlagList&lt;/code&gt; 에있는 경우에만 와일드 카드와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="ad1281a2fabb7670b330f0b63f7a590c6d68515e" translate="yes" xml:space="preserve">
          <source>Other configuration parameters exist, to be used for customizing the overload protection behaviour. The same parameters are used both in the standard handler and the disk_log handler, and are documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">과부하 보호 동작을 사용자 정의하는 데 사용할 다른 구성 매개 변수가 있습니다. 동일한 매개 변수가 표준 핸들러와 disk_log 핸들러 모두에서 사용되며 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide &lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="885f57e5d13595e0ee4f423a6b4d92f55b55a565" translate="yes" xml:space="preserve">
          <source>Other configuration parameters exist, to be used for customizing the overload protection behaviour. The same parameters are used both in the standard handler and the disk_log handler, and are documented in the &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">과부하 보호 동작을 사용자 정의하는 데 사용되는 다른 구성 매개 변수가 있습니다. 표준 핸들러와 disk_log 핸들러 모두에서 동일한 매개 변수가 사용되며 &lt;code&gt;&lt;a href=&quot;logger_chapter#overload_protection&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd2063ac325b87a9381eab00b4e9d208668c9217" translate="yes" xml:space="preserve">
          <source>Other constants (terms and bound variables), all regarded as false</source>
          <target state="translated">다른 상수 (용어 및 바운드 변수) (모두 거짓으로 간주 됨)</target>
        </trans-unit>
        <trans-unit id="5785009adfe7a26f06e17419436f0bb3a5dc5365" translate="yes" xml:space="preserve">
          <source>Other data types</source>
          <target state="translated">기타 데이터 유형</target>
        </trans-unit>
        <trans-unit id="c3ac4deb2089a1f649e5fdba0cc491bef7b16555" translate="yes" xml:space="preserve">
          <source>Other directories in the development environment may be needed. If source code from languages other than Erlang is used, for instance C-code for NIFs, that code should be placed in a separate directory. By convention it is recommended to prefix such directories with the language name, for example &lt;code&gt;c_src&lt;/code&gt; for C, &lt;code&gt;java_src&lt;/code&gt; for Java or &lt;code&gt;go_src&lt;/code&gt; for Go. Directories with &lt;code&gt;_src&lt;/code&gt; suffix indicates that it is a part of the application and the compilation step. The final build artifacts should target the &lt;code&gt;priv/lib&lt;/code&gt; or &lt;code&gt;priv/bin&lt;/code&gt; directories.</source>
          <target state="translated">개발 환경의 다른 디렉토리가 필요할 수 있습니다. Erlang 이외의 언어로 작성된 소스 코드 (예 : NIF의 C 코드)를 사용하는 경우 해당 코드는 별도의 디렉토리에 배치해야합니다. 관례는 예를 들어, 언어 이름과 같은 디렉토리를 접두사하는 것이 좋습니다 &lt;code&gt;c_src&lt;/code&gt; C를 들어, &lt;code&gt;java_src&lt;/code&gt; 자바 또는 &lt;code&gt;go_src&lt;/code&gt; 이동합니다. &lt;code&gt;_src&lt;/code&gt; 접미사가있는 디렉토리는 이것이 응용 프로그램 및 컴파일 단계의 일부임을 나타냅니다. 최종 빌드 아티팩트는 &lt;code&gt;priv/lib&lt;/code&gt; 또는 &lt;code&gt;priv/bin&lt;/code&gt; 디렉토리를 대상으로해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae9077b452914a72240410cfd78d06125441adc8" translate="yes" xml:space="preserve">
          <source>Other errors than these can occur, as the &lt;code&gt;erlang:halt/1&lt;/code&gt; BIF can generate any message. If the message is not generated by the BIF and does not occur in the list above, it can be because of an error in the emulator. There can however be unusual messages, not mentioned here, which are still connected to an application failure. There is much more information available, so a thorough reading of the crash dump can reveal the crash reason. The size of processes, the number of ETS tables, and the Erlang data on each process stack can be useful to find the problem.</source>
          <target state="translated">&lt;code&gt;erlang:halt/1&lt;/code&gt; BIF가 모든 메시지를 생성 할 수 있으므로 이들 이외의 다른 오류가 발생할 수 있습니다 . 메시지가 BIF에 의해 생성되지 않고 위 목록에 나타나지 않으면 에뮬레이터의 오류 때문일 수 있습니다. 그러나 여기에 언급되지 않은 비정상적인 메시지가 여전히있을 수 있으며 여전히 응용 프로그램 오류와 연결되어 있습니다. 사용 가능한 정보가 훨씬 많으므로 크래시 덤프를 자세히 읽으면 크래시 원인을 알 수 있습니다. 각 프로세스 스택의 프로세스 크기, ETS 테이블 수 및 Erlang 데이터는 문제를 찾는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60efd3d69d9ecb24af68e74d348360a07b5ed6b" translate="yes" xml:space="preserve">
          <source>Other features:</source>
          <target state="translated">다른 기능들:</target>
        </trans-unit>
        <trans-unit id="a58b6dc215a18ea443d12708103eda9efd5d5635" translate="yes" xml:space="preserve">
          <source>Other fields are rarely used. For complete information, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 필드는 거의 사용되지 않습니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extensions for SCTP&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbd6de3d10f2fc66f49e8c1b345f9c0059ed9ba5" translate="yes" xml:space="preserve">
          <source>Other functions that create sets are &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#from_sets-1&quot;&gt;from_sets/1&lt;/a&gt;&lt;/code&gt;. Special cases of &lt;code&gt;from_term/2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#a_function-1&quot;&gt;a_function/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#empty_set-0&quot;&gt;empty_set/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#family-1&quot;&gt;family/1,2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#relation-1&quot;&gt;relation/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#set-1&quot;&gt;set/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">세트를 작성하는 다른 함수는 &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#from_sets-1&quot;&gt;from_sets/1&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;from_term/2&lt;/code&gt; 의 특수한 경우 는 &lt;code&gt;&lt;a href=&quot;#a_function-1&quot;&gt;a_function/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#empty_set-0&quot;&gt;empty_set/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#family-1&quot;&gt;family/1,2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#relation-1&quot;&gt;relation/1,2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#set-1&quot;&gt;set/1,2&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d8b80772e0f8b1d872444ba18ad7b48f4cc4cfe" translate="yes" xml:space="preserve">
          <source>Other letter</source>
          <target state="translated">다른 편지</target>
        </trans-unit>
        <trans-unit id="1e25df6c3ebdcf4ee11a121bc16f17e603a8b7df" translate="yes" xml:space="preserve">
          <source>Other match specs activates tracing of calls to &lt;code&gt;et:trace_me/4,5&lt;/code&gt; accordingly with &lt;code&gt;erlang:trace_pattern/2&lt;/code&gt;.</source>
          <target state="translated">다른 일치 스펙 은 &lt;code&gt;erlang:trace_pattern/2&lt;/code&gt; 에 따라 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 에 대한 호출 추적을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="51ca0c2d75fe6310043838d9fb791594049c226f" translate="yes" xml:space="preserve">
          <source>Other modules can provide a nullary &lt;code&gt;TraverseFun&lt;/code&gt;. An example is &lt;code&gt;gb_table:table/1&lt;/code&gt; in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 모듈은 null &lt;code&gt;TraverseFun&lt;/code&gt; 을 제공 할 수 있습니다 . 예제는 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 섹션의 &lt;code&gt;gb_table:table/1&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="17c16931cb7557980e4b6e326788381e28a97c59" translate="yes" xml:space="preserve">
          <source>Other notable features:</source>
          <target state="translated">기타 주목할만한 기능 :</target>
        </trans-unit>
        <trans-unit id="3022c490a2bd62676beabc0c1b504084140a7de5" translate="yes" xml:space="preserve">
          <source>Other number</source>
          <target state="translated">다른 번호</target>
        </trans-unit>
        <trans-unit id="97bd01729246532af9de85d0c3ab1ddb360d5a4e" translate="yes" xml:space="preserve">
          <source>Other options are:</source>
          <target state="translated">다른 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">다른 옵션:</target>
        </trans-unit>
        <trans-unit id="997739492917d646490ffd1fec1419fa6e98b907" translate="yes" xml:space="preserve">
          <source>Other priorities than &lt;code&gt;normal&lt;/code&gt; are normally not needed. When other priorities are used, use them with care, &lt;strong&gt;especially&lt;/strong&gt; priority &lt;code&gt;high&lt;/code&gt;. A process on priority &lt;code&gt;high&lt;/code&gt; is only to perform work for short periods. Busy looping for long periods in a &lt;code&gt;high&lt;/code&gt; priority process causes most likely problems, as important OTP servers run on priority &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">이외의 우선 순위 &lt;code&gt;normal&lt;/code&gt; 일반적으로 필요하지 않습니다. 다른 우선 순위를 사용할 때는 &lt;strong&gt;특히&lt;/strong&gt; 우선 순위가 &lt;code&gt;high&lt;/code&gt; 주의해서 사용하십시오 . 우선 순위가 &lt;code&gt;high&lt;/code&gt; 프로세스 는 단기간 동안 작업을 수행하는 것입니다. 중요한 OTP 서버가 우선 순위가 &lt;code&gt;normal&lt;/code&gt; 실행되기 &lt;code&gt;high&lt;/code&gt; 우선 순위 가 높은 프로세스 에서 장시간의 바쁜 루핑은 문제가 발생할 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="cd7bd73139a7f3678d7510386d6ecf37b58dbf90" translate="yes" xml:space="preserve">
          <source>Other problems were different experienced limitations of the OS implementation of mmap:</source>
          <target state="translated">다른 문제는 mmap의 OS 구현에 대해 경험 한 여러 제한 사항이었습니다.</target>
        </trans-unit>
        <trans-unit id="8dea56314c50bfb058a315994e322b37ac05f071" translate="yes" xml:space="preserve">
          <source>Other processes can read the digraph (default).</source>
          <target state="translated">다른 프로세스는이 그래프를 읽을 수 있습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="20bc18ec4477d52890b4d5aac0d2cbc92eb389a4" translate="yes" xml:space="preserve">
          <source>Other punctuation</source>
          <target state="translated">다른 구두점</target>
        </trans-unit>
        <trans-unit id="ec9bcce7656bc224a64ce97ba2b5bd792aeb6391" translate="yes" xml:space="preserve">
          <source>Other requirements:</source>
          <target state="translated">다른 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="e28544fd56893780941b6044efc20d476e8af135" translate="yes" xml:space="preserve">
          <source>Other states do not normally occur in the output from &lt;code&gt;connect/*&lt;/code&gt;. Rather, they can occur in &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; events received instead of data in &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; calls. All of them indicate losing the association because of various error conditions, and are listed here for the sake of completeness:</source>
          <target state="translated">다른 상태는 일반적으로 &lt;code&gt;connect/*&lt;/code&gt; 의 출력에서 ​​발생하지 않습니다 . 오히려 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 호출 의 데이터 대신 수신 된 &lt;code&gt;#sctp_assoc_change{}&lt;/code&gt; 이벤트 에서 발생할 수 있습니다 . 그들 모두는 다양한 오류 조건으로 인해 연결이 끊어 졌음을 나타내며 완전성을 위해 여기에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a8ec65432412d24f9c042216a5db6173548a99" translate="yes" xml:space="preserve">
          <source>Other symbol</source>
          <target state="translated">다른 상징</target>
        </trans-unit>
        <trans-unit id="577365eaf2b9f85de95baced848e1cc288b22cd3" translate="yes" xml:space="preserve">
          <source>Other table access than reading, such as calling &lt;code&gt;InfoFun&lt;/code&gt;, is assumed to be OK at any time.</source>
          <target state="translated">&lt;code&gt;InfoFun&lt;/code&gt; 호출과 같은 읽기 이외의 다른 테이블 액세스는 언제든지 정상인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="24654f0b470cc0982d088fd0b8978733097cbe87" translate="yes" xml:space="preserve">
          <source>Other tuples than the ones defined are ignored.</source>
          <target state="translated">정의 된 것 이외의 다른 튜플은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="15363bfb92322f3fe6ad2718148dd35e33fdb154" translate="yes" xml:space="preserve">
          <source>Other types can be read, and are returned as binaries.</source>
          <target state="translated">다른 유형을 읽을 수 있으며 이진으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cdedf43490cc2ff1da81cd679f5229c3c1cc0879" translate="yes" xml:space="preserve">
          <source>Other types cannot be added or changed.</source>
          <target state="translated">다른 유형은 추가하거나 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70e28792612da22154d851b53e24c945311f74a0" translate="yes" xml:space="preserve">
          <source>Other useful function(s) for debugging the agent are:</source>
          <target state="translated">에이전트 디버깅에 유용한 다른 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ebc4c4dd4036621515140929b889184c451a256" translate="yes" xml:space="preserve">
          <source>Other useful information can be found at our GitHub wiki:</source>
          <target state="translated">다른 유용한 정보는 GitHub 위키에서 찾을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0531b334dc961f9344129177c8d2945332656c08" translate="yes" xml:space="preserve">
          <source>Other valid options depends on what options are supported by the node identified by &lt;code&gt;Node&lt;/code&gt;. A description of other valid &lt;code&gt;Option&lt;/code&gt;s for the local node of current OTP version can be found in the documentation of &lt;code&gt;&lt;a href=&quot;#spawn_opt-4&quot;&gt;spawn_opt/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 유효한 옵션은 &lt;code&gt;Node&lt;/code&gt; 로 식별되는 노드 에서 지원하는 옵션에 따라 다릅니다 . 현재 OTP 버전의 로컬 노드에 대한 다른 유효한 &lt;code&gt;Option&lt;/code&gt; 에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#spawn_opt-4&quot;&gt;spawn_opt/4&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="198dd873fca5b5131fb3a9224056b4006b7b1428" translate="yes" xml:space="preserve">
          <source>Otherwise all options valid for function &lt;code&gt;compile/2&lt;/code&gt; are also allowed. Options allowed both for compilation and execution of a match, namely &lt;code&gt;anchored&lt;/code&gt; and &lt;code&gt;{newline, NLSpec}&lt;/code&gt;, affect both the compilation and execution if present together with a non-precompiled regular expression.</source>
          <target state="translated">그렇지 않으면 함수 &lt;code&gt;compile/2&lt;/code&gt; 에 유효한 모든 옵션 도 허용됩니다. &lt;code&gt;anchored&lt;/code&gt; 및 &lt;code&gt;{newline, NLSpec}&lt;/code&gt; 과 같이 일치 컴파일 및 실행에 허용되는 옵션은 사전 컴파일되지 않은 정규식과 함께있는 경우 컴파일 및 실행에 모두 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="e30cc24dff4a8e4fd3505b91e8729e2519c09a8a" translate="yes" xml:space="preserve">
          <source>Otherwise an &lt;code&gt;undef&lt;/code&gt; exception is raised.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="397a19a3210257e034ddbc5987f1f58dde936b81" translate="yes" xml:space="preserve">
          <source>Otherwise recreates the exported seed and returns the state. See also &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt; export_seed/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 내 보낸 시드를 다시 만들고 상태를 반환합니다. &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt; export_seed/0&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75ef1eb055dcb5b6ca421038e624721c946bf1b2" translate="yes" xml:space="preserve">
          <source>Otherwise recreates the exported seed and returns the state. See also &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 내 보낸 시드를 다시 작성하고 상태를 리턴합니다. &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b75f15a942afae834871232ccf0ba77e7558f01c" translate="yes" xml:space="preserve">
          <source>Otherwise recreates the exported seed in the process dictionary, and returns the state. See also &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 프로세스 사전에서 내 보낸 시드를 다시 작성하고 상태를 리턴합니다. &lt;code&gt;&lt;a href=&quot;#export_seed-0&quot;&gt;export_seed/0&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4516a5a0c8fab848ec459b0a78f55d03b3d5d1ac" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;gen_statem&lt;/code&gt; goes into &lt;code&gt;receive&lt;/code&gt; or hibernation (if &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;) to wait for the next message. In hibernation the next non-system event awakens the &lt;code&gt;gen_statem&lt;/code&gt;, or rather the next incoming message awakens the &lt;code&gt;gen_statem&lt;/code&gt;, but if it is a system event it goes right back into hibernation. When a new message arrives the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is called with the corresponding event, and we start again from the top of this sequence.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;gen_statem&lt;/code&gt; 이 &lt;code&gt;receive&lt;/code&gt; 또는 최대 절전 모드 ( &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 )로 들어가 다음 메시지를 기다립니다. 최대 절전 모드에서는 다음 비 시스템 이벤트가 &lt;code&gt;gen_statem&lt;/code&gt; 을 깨우 거나 다음 수신 메시지가 &lt;code&gt;gen_statem&lt;/code&gt; 을 깨우지 만 시스템 이벤트 인 경우 바로 최대 절전 모드로 돌아갑니다. 새 메시지가 도착하면 해당 이벤트와 함께 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 이 호출 &lt;strong&gt;되고이&lt;/strong&gt; 시퀀스의 맨 위에서 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d87b5659173c759cef0ab46aa4a7fb80d00cb3c5" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;gen_statem&lt;/code&gt; goes into &lt;code&gt;receive&lt;/code&gt; or hibernation (if &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;) to wait for the next message. In hibernation the next non-system event awakens the &lt;code&gt;gen_statem&lt;/code&gt;, or rather the next incoming message awakens the &lt;code&gt;gen_statem&lt;/code&gt;, but if it is a system event it goes right back into hibernation. When a new message arrives the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; is called with the corresponding event, and we start again from the top of this sequence.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;gen_statem&lt;/code&gt; 은 다음 메시지를 기다리기 위해 &lt;code&gt;receive&lt;/code&gt; 또는 최대 절전 모드 ( &lt;code&gt;&lt;a href=&quot;#type-hibernate&quot;&gt;hibernate()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 )로 들어갑니다. 최대 절전 모드에서는 다음 비 시스템 이벤트가 &lt;code&gt;gen_statem&lt;/code&gt; 을 깨우 거나 다음 수신 메시지가 &lt;code&gt;gen_statem&lt;/code&gt; 깨우지 만 시스템 이벤트 인 경우 다시 최대 절전 모드로 돌아갑니다. 새로운 메시지가 도착하면 해당 이벤트와 함께 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 이 호출 되고이 시퀀스의 맨 처음부터 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ca5bba34991dc2c836a13ba5d708caac9b079155" translate="yes" xml:space="preserve">
          <source>Otherwise the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Server = Server_or_Actions&lt;/code&gt; and &lt;code&gt;Actions = []&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;Server = Server_or_Actions&lt;/code&gt; 및 &lt;code&gt;Actions = []&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7a3e409482e92d7312335dbbdf06b6be17b9baa1" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;Name&lt;/code&gt; is to be a filename.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;Name&lt;/code&gt; 은 파일 이름 이됩니다.</target>
        </trans-unit>
        <trans-unit id="00aeea6c12722cc94d58e2f90a9872f32740085b" translate="yes" xml:space="preserve">
          <source>Otherwise, end the cluster.</source>
          <target state="translated">그렇지 않으면 클러스터를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="721932d781d83d618f6a74c5ad3eea7a7cd92826" translate="yes" xml:space="preserve">
          <source>Otherwise, if function &lt;code&gt;'$handle_undefined_function'/2&lt;/code&gt; is exported, it is called as &lt;code&gt;'$handle_undefined_function'(&lt;/code&gt;Function, Args).</source>
          <target state="translated">그렇지 않으면, 함수 &lt;code&gt;'$handle_undefined_function'/2&lt;/code&gt; 가 내보내 &lt;code&gt;'$handle_undefined_function'(&lt;/code&gt; Function, Args)이라고합니다.</target>
        </trans-unit>
        <trans-unit id="bd45978f4d37112b76326ff6ee1522682525ecd5" translate="yes" xml:space="preserve">
          <source>Otherwise, if the calling process is trapping exits, and/or &lt;code&gt;PidOrPort&lt;/code&gt; is remote, &lt;code&gt;link/1&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but an exit signal with reason &lt;code&gt;noproc&lt;/code&gt; is sent to the calling process.</source>
          <target state="translated">그렇지 않으면, 호출 프로세스가 종료를 트래핑하고 /하거나 &lt;code&gt;PidOrPort&lt;/code&gt; 가 원격 인 경우, &lt;code&gt;link/1&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 리턴 하지만, &lt;code&gt;noproc&lt;/code&gt; 이 있는 종료 신호가 호출 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="da43d3db522f1f4c7c74271266d895bb136efa89" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns, if possible, the value of &lt;code&gt;apply(Fun, Args)&lt;/code&gt; after an attempt is made to autoload &lt;code&gt;Module&lt;/code&gt;. If this is not possible, the call fails with exit reason &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 가능하면 &lt;code&gt;Module&lt;/code&gt; 자동로드 시도 후 &lt;code&gt;apply(Fun, Args)&lt;/code&gt; 값을 리턴합니다 . 이것이 가능하지 않은 경우 종료 이유 &lt;code&gt;undef&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="cacbdaf48917ea52fc8e545a2f82b0aa7f975a90" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;gen_server&lt;/code&gt; process terminates immediately.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="94d92e282ea81d3ea91c85388ba278cc5356a549" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;gen_statem&lt;/code&gt; is immediately terminated.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;gen_statem&lt;/code&gt; 이 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4310db4b8648fe0dc2ce19712dff695071b2d572" translate="yes" xml:space="preserve">
          <source>Otherwise, this option (&lt;code&gt;timeout&lt;/code&gt;) is used as the negotiation timeout only and there is no connection timeout set</source>
          <target state="translated">그렇지 않으면이 옵션 ( &lt;code&gt;timeout&lt;/code&gt; )이 협상 제한 시간으로 만 사용되며 연결 제한 시간이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b3f7c8e4e4677a9df71f0dfa15c3c32d290db0d1" translate="yes" xml:space="preserve">
          <source>Our Java code (jinterface, ic) is tested on windows with JDK 8. Get it for Windows and install it, the JRE is not enough.</source>
          <target state="translated">Java 코드 (jinterface, ic)는 JDK 8이 설치된 Windows에서 테스트되었습니다. Windows 용으로 가져 와서 설치하세요. JRE로는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fc1fe0597f841fdd158f43b025edbb7cffcfe68" translate="yes" xml:space="preserve">
          <source>Our driver data is also extended, we keep track of the socket used for communication with postgres, and also the port, which is needed when we send data to the port with &lt;code&gt;driver_output&lt;/code&gt;. We have a flag &lt;code&gt;connecting&lt;/code&gt; to tell whether the driver is waiting for a connection or waiting for the result of a query. (This is needed, as the entry &lt;code&gt;ready_io&lt;/code&gt; is called both when connecting and when there is a query result.)</source>
          <target state="translated">드라이버 데이터도 확장되어 postgres와 통신하는 데 사용되는 소켓과 &lt;code&gt;driver_output&lt;/code&gt; 을 사용하여 포트로 데이터를 보낼 때 필요한 포트를 추적 합니다. 드라이버가 &lt;code&gt;connecting&lt;/code&gt; 을 기다리고 있는지 또는 쿼리 결과를 기다리고 있는지 알려주기 위해 연결 하는 플래그 가 있습니다. ( 연결할 때와 쿼리 결과가있을 때 &lt;code&gt;ready_io&lt;/code&gt; 항목 이 모두 호출 되므로 이는 필수 입니다.)</target>
        </trans-unit>
        <trans-unit id="f0056bc8aeb56d2dc843d5e275d5c6af5ac8105e" translate="yes" xml:space="preserve">
          <source>Our example test could for example be a simple test of an ftp server, where we perform get, put and delete requests, some of them in parallel. Per default, the result has three sections:</source>
          <target state="translated">예를 들어 우리의 예제 테스트는 ftp 서버에 대한 간단한 테스트가 될 수 있습니다. 여기서 get, put 및 delete 요청을 수행하며 그중 일부는 병렬로 수행합니다. 기본적으로 결과에는 세 개의 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6438f58ef6f89d7bd274993ab31926c276b0cdc6" translate="yes" xml:space="preserve">
          <source>Our new release, &quot;SECOND&quot;, is now the current release, but we can also see that our &quot;FIRST&quot; release is still permanent. This means that if the node would be restarted now, it would come up running the &quot;FIRST&quot; release again.</source>
          <target state="translated">새 릴리스 인 &quot;SECOND&quot;가 현재 릴리스이지만 &quot;FIRST&quot;릴리스가 여전히 영구적임을 알 수 있습니다. 즉, 노드가 지금 다시 시작되면 &quot;FIRST&quot;릴리스를 다시 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="867b0a717a764649cafbff4174c1ab32b19f1745" translate="yes" xml:space="preserve">
          <source>Outbound binary encoding in binaries</source>
          <target state="translated">바이너리의 아웃 바운드 바이너리 인코딩</target>
        </trans-unit>
        <trans-unit id="59cc61305ef8bc0545ffbb32a894c83964c825a0" translate="yes" xml:space="preserve">
          <source>Outbound percent-encoding in lists and binaries</source>
          <target state="translated">목록 및 이진의 아웃 바운드 백분율 인코딩</target>
        </trans-unit>
        <trans-unit id="f6e7d5a9598d3a265926a82b01d7b1deec941696" translate="yes" xml:space="preserve">
          <source>Outgoing reply messages will be segmented as needed (see &lt;code&gt;max_pdu_size&lt;/code&gt; below). Segment messages are sent all at once (i.e. no acknowledgement awaited before sending the next segment).</source>
          <target state="translated">발신 응답 메시지는 필요에 따라 분류됩니다 (아래 &lt;code&gt;max_pdu_size&lt;/code&gt; 참조). 세그먼트 메시지는 한 번에 모두 전송됩니다 (즉, 다음 세그먼트를 보내기 전에 승인이 대기하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="db1552aa4fc51b4e7d46fa43321f568f6c953efb" translate="yes" xml:space="preserve">
          <source>Outgoing reply messages will be segmented as needed (see &lt;code&gt;max_pdu_size&lt;/code&gt; below). This value, K, indicate the outstanding window, i.e. how many segments can be outstanding (not acknowledged) at any given time.</source>
          <target state="translated">발신 응답 메시지는 필요에 따라 분류됩니다 (아래 &lt;code&gt;max_pdu_size&lt;/code&gt; 참조). 이 값 K는 미해결 기간, 즉 주어진 시간에 미해결 될 수있는 세그먼트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="685ad21255174c3fd01ff63b9cc3a546c7bc9ee3" translate="yes" xml:space="preserve">
          <source>Output messages are sent without packet lengths. A user-defined protocol must be used between the Erlang process and the external object.</source>
          <target state="translated">출력 메시지는 패킷 길이없이 전송됩니다. Erlang 프로세스와 외부 개체간에 사용자 정의 프로토콜을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f7c458df3a3815d9db3a23cdf615c8f0139aaad" translate="yes" xml:space="preserve">
          <source>Output to stdout on the server side is also displayed as well as the resulting term from the function call:</source>
          <target state="translated">서버 측의 stdout에 대한 출력과 함수 호출의 결과 용어도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1940195f61826f0bf71c04e3e654bd8f616a6a5b" translate="yes" xml:space="preserve">
          <source>Outputs information from parsing the input file and generating the internal tables.</source>
          <target state="translated">입력 파일을 구문 분석하고 내부 테이블을 생성하여 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="73c0f26b2a7bd194530650de5672dbbf0d19179d" translate="yes" xml:space="preserve">
          <source>Outputs the message &lt;code&gt;Text&lt;/code&gt; (which can be a plain string, an IO-list, or just an atom). The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">메시지 &lt;code&gt;Text&lt;/code&gt; (일반 문자열, IO- 목록 또는 원자 일 수 있음)를 출력합니다. 결과는 항상 &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47cdda9f06afdf9eb8f93de49e9252c88f5dc624" translate="yes" xml:space="preserve">
          <source>Outside a character class, a backslash followed by a digit &amp;gt; 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (that is, to its left) in the pattern, provided there have been that many previous capturing left parentheses.</source>
          <target state="translated">문자 클래스 외부에서 백 슬래시 다음에 숫자&amp;gt; 0 (및 추가 숫자)이 오는 경우 패턴에서 이전의 캡처 하위 패턴 (즉, 왼쪽)에 대한 역 참조입니다. .</target>
        </trans-unit>
        <trans-unit id="cd6a3b6581f40f67d6587389bf34b0d7ce3534cd" translate="yes" xml:space="preserve">
          <source>Outside a character class, a dot in the pattern matches any character in the subject string except (by default) a character that signifies the end of a line.</source>
          <target state="translated">문자 클래스 외부에서 패턴의 점은 기본적으로 줄의 끝을 나타내는 문자를 제외하고 제목 문자열의 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="81930bbe14ad5ca39d3f1c5a979f1ece61d2de2e" translate="yes" xml:space="preserve">
          <source>Outside a character class, by default, the escape sequence \R matches any Unicode newline sequence. In non-UTF-8 mode, \R is equivalent to the following:</source>
          <target state="translated">문자 클래스 외부에서 기본적으로 이스케이프 시퀀스 \ R은 모든 유니 코드 개행 시퀀스와 일치합니다. 비 UTF-8 모드에서 \ R은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85b61b9dbc2dcc77797a3d987698e978f37365fe" translate="yes" xml:space="preserve">
          <source>Outside a character class, in the default matching mode, the circumflex character is an assertion that is true only if the current matching point is at the start of the subject string. If argument &lt;code&gt;startoffset&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; is non-zero, circumflex can never match if option &lt;code&gt;multiline&lt;/code&gt; is unset. Inside a character class, circumflex has an entirely different meaning (see below).</source>
          <target state="translated">문자 클래스 외부의 기본 일치 모드에서 곡절 문자는 현재 일치 지점이 제목 문자열의 시작 부분에있는 경우에만 적용되는 어설 션입니다. &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 인수 &lt;code&gt;startoffset&lt;/code&gt; 이 0이 아니면 옵션 &lt;code&gt;multiline&lt;/code&gt; 이 설정되지 않은 경우 circumflex는 절대 일치하지 않습니다 . 캐릭터 클래스 내에서 곡절 반경은 완전히 다른 의미를 갖습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="96066ed4fc24874155ae3f2d4ec23afe749bc90e" translate="yes" xml:space="preserve">
          <source>Outside a character class, the escape sequence \C matches any data unit, regardless if a UTF mode is set. One data unit is one byte. Unlike a dot, \C always matches line-ending characters. The feature is provided in Perl to match individual bytes in UTF-8 mode, but it is unclear how it can usefully be used. As \C breaks up characters into individual data units, matching one unit with \C in a UTF mode means that the remaining string can start with a malformed UTF character. This has undefined results, as PCRE assumes that it deals with valid UTF strings.</source>
          <target state="translated">문자 클래스 외부에서 이스케이프 시퀀스 \ C는 UTF 모드가 설정되어 있는지 여부에 관계없이 모든 데이터 단위와 일치합니다. 하나의 데이터 단위는 1 바이트입니다. 점과 달리 \ C는 항상 줄 끝 문자와 일치합니다. 이 기능은 UTF-8 모드에서 개별 바이트와 일치하도록 Perl에 제공되지만 유용하게 사용할 수있는 방법은 확실하지 않습니다. \ C는 문자를 개별 데이터 단위로 나누므로 UTF 모드에서 하나의 단위를 \ C와 일치 시키면 나머지 문자열이 잘못된 UTF 문자로 시작할 수 있습니다. PCRE가 유효한 UTF 문자열을 처리한다고 가정하므로 정의되지 않은 결과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d06e3f0473ed837ae5eabca58e86d752a67b3e6e" translate="yes" xml:space="preserve">
          <source>Over time, as the Framework has evolved from SNMPv1 , through SNMPv2, to SNMPv3 the definitions of each of these architectural components have become richer and more clearly defined, but the fundamental architecture has remained consistent.</source>
          <target state="translated">프레임 워크가 SNMPv1에서 SNMPv2를 통해 SNMPv3으로 발전함에 따라 시간이 지남에 따라 이러한 각 아키텍처 구성 요소의 정의가 더욱 풍부하고 명확하게 정의되었지만 기본 아키텍처는 일관되게 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="afffe81c6dad8cc96b3ce448af31b5dc40135548" translate="yes" xml:space="preserve">
          <source>Overhead</source>
          <target state="translated">Overhead</target>
        </trans-unit>
        <trans-unit id="edc8f798d5c08e478ccf078886e412565dd84cb0" translate="yes" xml:space="preserve">
          <source>Overload Protection</source>
          <target state="translated">과부하 보호</target>
        </trans-unit>
        <trans-unit id="cef9305d1dcaaa55a42c6722272e0c832cae51ee" translate="yes" xml:space="preserve">
          <source>Overload protection</source>
          <target state="translated">과부하 보호</target>
        </trans-unit>
        <trans-unit id="1024473923480d46de1a6ce534031a4fb8bf2fe9" translate="yes" xml:space="preserve">
          <source>Overload protection activated on one node does not affect other nodes, where the tracing continues as normal. &lt;code&gt;ttb:stop/0,1&lt;/code&gt; fetches data from all clients, including everything collected before the activation of overload protection.</source>
          <target state="translated">한 노드에서 활성화 된 과부하 보호는 추적이 정상적으로 계속되는 다른 노드에는 영향을 미치지 않습니다. &lt;code&gt;ttb:stop/0,1&lt;/code&gt; 은 과부하 보호를 활성화하기 전에 수집 된 모든 것을 포함하여 모든 클라이언트에서 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9872bf40547ca2f3f14680ffa0287ececed0c74a" translate="yes" xml:space="preserve">
          <source>Override protocol version when sending a message by adding the item &lt;code&gt;{protocol_version, integer()}&lt;/code&gt; to the Options. See &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{protocol_version, integer()}&lt;/code&gt; 을 옵션 에 추가하여 메시지를 보낼 때 프로토콜 버전을 대체 하십시오. &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;cast&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07d3d194fae83d351901e71d428409c25c0a3d51" translate="yes" xml:space="preserve">
          <source>Override the default, which is to analyze BEAM files, and analyze starting from Erlang source code instead.</source>
          <target state="translated">BEAM 파일을 분석하는 기본 설정을 대체하고 대신 Erlang 소스 코드에서 시작하여 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="15565d57245d3503a665b06bb1ebc90f34652149" translate="yes" xml:space="preserve">
          <source>Overrides any value set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options&lt;/a&gt;&lt;/code&gt; 함수로 설정된 값을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="e903860e59ffb2ebea40577767dba45a92e0e0e5" translate="yes" xml:space="preserve">
          <source>Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</source>
          <target state="translated">제목 문자열에서 줄 바꿈의 기본 정의 인 Erlang의 LF (ASCII 10)를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="70f5e663bdd85b0cbb11a197a25022368effaefb" translate="yes" xml:space="preserve">
          <source>Overrides the source file name as presented in &lt;code&gt;module_info(compile)&lt;/code&gt; and stack traces.</source>
          <target state="translated">&lt;code&gt;module_info(compile)&lt;/code&gt; 및 스택 추적에 표시된 소스 파일 이름을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="2178a71f4d4796adf7ebfc54ce9d2c304cda5e26" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_sctp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_sctp&lt;/code&gt; for IPv6.</source>
          <target state="translated">사용되는 콜백 모듈을 재정의합니다. IPv4의 경우 기본값은 &lt;code&gt;inet_sctp&lt;/code&gt; 이고 IPv6의 경우 &lt;code&gt;inet6_sctp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9febcfe22539c2d72353741f4a91ee3eee5e5d0a" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_tcp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_tcp&lt;/code&gt; for IPv6.</source>
          <target state="translated">사용되는 콜백 모듈을 재정의합니다. IPv4의 경우 기본값은 &lt;code&gt;inet_tcp&lt;/code&gt; 이고 IPv6의 경우 &lt;code&gt;inet6_tcp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb4575b7495ce7d57228d043087de6f17605a208" translate="yes" xml:space="preserve">
          <source>Overrides which callback module is used. Defaults to &lt;code&gt;inet_udp&lt;/code&gt; for IPv4 and &lt;code&gt;inet6_udp&lt;/code&gt; for IPv6.</source>
          <target state="translated">사용되는 콜백 모듈을 재정의합니다. IPv4의 경우 기본값은 &lt;code&gt;inet_udp&lt;/code&gt; 이고 IPv6의 경우 &lt;code&gt;inet6_udp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2f619cd71b1d0660f0efea7cc2e66087681e7c2" translate="yes" xml:space="preserve">
          <source>Overriding CTHs</source>
          <target state="translated">CTH 재정의</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="d263dc838fe87831b80976b412672c3d8e02db11" translate="yes" xml:space="preserve">
          <source>Owners can subscribe to &lt;strong&gt;notifications&lt;/strong&gt;, messages of the form &lt;code&gt;{disk_log, Node, Log, Info}&lt;/code&gt;, which are sent from the disk log process when certain events occur, see the functions and in particular the &lt;code&gt;open/1&lt;/code&gt; option &lt;code&gt;&lt;a href=&quot;#notify&quot;&gt;notify&lt;/a&gt;&lt;/code&gt;. A log can have many owners, but a process cannot own a log more than once. However, the same process can open the log as a user more than once.</source>
          <target state="translated">소유자는 특정 이벤트가 발생할 때 디스크 로그 프로세스에서 전송되는 &lt;code&gt;{disk_log, Node, Log, Info}&lt;/code&gt; 형식의 메시지 인 &lt;strong&gt;알림에&lt;/strong&gt; 가입 할 수 있습니다 . 기능 및 특히 &lt;code&gt;open/1&lt;/code&gt; 옵션 &lt;code&gt;&lt;a href=&quot;#notify&quot;&gt;notify&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 로그에는 많은 소유자가있을 수 있지만 프로세스는 로그를 두 번 이상 소유 할 수 없습니다. 그러나 동일한 프로세스에서 사용자로 로그를 두 번 이상 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf7d16b62f8d7d4458289a41b07f8e9ce785647" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications are notified of an error with an &lt;code&gt;error_status&lt;/code&gt; message if the error reason tag is &lt;code&gt;invalid_header&lt;/code&gt; or &lt;code&gt;file_error&lt;/code&gt;.</source>
          <target state="translated">오류 이유 태그가 &lt;code&gt;invalid_header&lt;/code&gt; 또는 &lt;code&gt;file_error&lt;/code&gt; 인 경우 알림을 구독하는 소유자에게 &lt;code&gt;error_status&lt;/code&gt; 메시지 와 함께 오류가 통지 됩니다.</target>
        </trans-unit>
        <trans-unit id="47ddeec7968a11b2b2f13154dd59f134a92d672e" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications normally receive a &lt;code&gt;wrap&lt;/code&gt; message, but if an error occurs with a reason tag of &lt;code&gt;invalid_header&lt;/code&gt; or &lt;code&gt;file_error&lt;/code&gt;, an &lt;code&gt;error_status&lt;/code&gt; message is sent.</source>
          <target state="translated">알림을 구독하는 소유자는 일반적으로 &lt;code&gt;wrap&lt;/code&gt; 메시지를 수신 하지만 &lt;code&gt;invalid_header&lt;/code&gt; 또는 &lt;code&gt;file_error&lt;/code&gt; 이유 태그로 오류가 발생 하면 &lt;code&gt;error_status&lt;/code&gt; 메시지가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ea5a85a9a6040f17a47f7ba2c861df0d45af862d" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive a &lt;code&gt;truncate&lt;/code&gt; message.</source>
          <target state="translated">알림을 구독하는 소유자는 &lt;code&gt;truncate&lt;/code&gt; 메시지를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="69f83710cbb8ab650339dad71d8d01aeb1346e48" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive message &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;blocked_log&lt;/code&gt;, or &lt;code&gt;format_external&lt;/code&gt; if the item cannot be written on the log, and possibly one of the messages &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, or &lt;code&gt;error_status&lt;/code&gt; if an item is written on the log. Message &lt;code&gt;error_status&lt;/code&gt; is sent if something is wrong with the header function or if a file error occurs.</source>
          <target state="translated">알림을 구독하는 소유자 는 항목을 로그에 쓸 수없는 경우 &lt;code&gt;read_only&lt;/code&gt; , &lt;code&gt;blocked_log&lt;/code&gt; 또는 &lt;code&gt;format_external&lt;/code&gt; 메시지 를 받고 , 항목이 로그에 기록되면 &lt;code&gt;wrap&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; 또는 &lt;code&gt;error_status&lt;/code&gt; 메시지 중 하나를 받을 수 있습니다. 헤더 기능에 문제가 있거나 파일 오류가 발생하면 &lt;code&gt;error_status&lt;/code&gt; 메시지 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fc53f78ca51a5c5588dc259bf4af7ddf544cabda" translate="yes" xml:space="preserve">
          <source>Owners subscribing to notifications receive message &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;blocked_log&lt;/code&gt;, or &lt;code&gt;format_external&lt;/code&gt; if the items cannot be written on the log, and possibly one or more of the messages &lt;code&gt;wrap&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, and &lt;code&gt;error_status&lt;/code&gt; if items are written on the log. Message &lt;code&gt;error_status&lt;/code&gt; is sent if something is wrong with the header function or if a file error occurs.</source>
          <target state="translated">알림을 구독하는 소유자 는 항목을 로그에 쓸 수없는 경우 &lt;code&gt;read_only&lt;/code&gt; , &lt;code&gt;blocked_log&lt;/code&gt; 또는 &lt;code&gt;format_external&lt;/code&gt; 메시지 를 받고 , 항목이 로그에 기록되면 하나 이상의 메시지 &lt;code&gt;wrap&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; 및 &lt;code&gt;error_status&lt;/code&gt; 를 받습니다. 헤더 기능에 문제가 있거나 파일 오류가 발생하면 &lt;code&gt;error_status&lt;/code&gt; 메시지 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="36f780fdbda5b2b2ce85c9ebb57086d1880ae757" translate="yes" xml:space="preserve">
          <source>PC</source>
          <target state="translated">PC</target>
        </trans-unit>
        <trans-unit id="d561f41a3e664cc0a8835732d97f931d41f72800" translate="yes" xml:space="preserve">
          <source>PCRE (and Perl) also recognize the Posix syntax [.ch.] and [=ch=] where &quot;ch&quot; is a &quot;collating element&quot;, but these are not supported, and an error is given if they are encountered.</source>
          <target state="translated">PCRE (및 Perl)도 Posix 구문 [.ch.] 및 [= ch =]를 인식합니다. 여기서 &quot;ch&quot;는 &quot;collating element&quot;이지만 지원되지 않으며 오류가 발생하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c7e1a3a2c06dd5d35852b8fd7f58b67f48a9a787" translate="yes" xml:space="preserve">
          <source>PCRE contains some optimizations that are used to speed up matching by running some checks at the start of each match attempt. For example, it can know the minimum length of matching subject, or that a particular character must be present. When one of these optimizations bypasses the running of a match, any included backtracking verbs are not processed. processed. You can suppress the start-of-match optimizations by setting option &lt;code&gt;no_start_optimize&lt;/code&gt; when calling &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, or by starting the pattern with (*NO_START_OPT).</source>
          <target state="translated">PCRE에는 각 일치 시도가 시작될 때 일부 검사를 실행하여 일치 속도를 높이는 데 사용되는 일부 최적화가 포함되어 있습니다. 예를 들어, 일치하는 주제의 최소 길이를 알거나 특정 문자가 있어야 함을 알 수 있습니다. 이러한 최적화 중 하나가 일치하는 실행을 무시하면 포함 된 모든 역 추적 동사가 처리되지 않습니다. 가공. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 &lt;code&gt;no_start_optimize&lt;/code&gt; 옵션을 설정 하거나 (* NO_START_OPT)로 패턴을 시작하여 일치 시작 최적화를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b299ec8de52cb755bee6ddf20ed30414c507680c" translate="yes" xml:space="preserve">
          <source>PCRE differs from Perl in its handling of backtracking verbs in repeated groups. For example, consider:</source>
          <target state="translated">PCRE는 반복 그룹에서 역 추적 동사를 처리한다는 점에서 Perl과 다릅니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3cc508b88f2a03ca5b89b7762b1f20cd8e196650" translate="yes" xml:space="preserve">
          <source>PCRE does not allow \C to appear in lookbehind assertions (described below) in a UTF mode, as this would make it impossible to calculate the length of the lookbehind.</source>
          <target state="translated">PCRE는 \ C가 UTF 모드에서 lookbehind 어설 션 (아래 설명 참조)에 표시되지 않도록하여 lookbehind의 길이를 계산할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="1cbd2b65949cf73edf1658ac5a4fd6ddc42bd83c" translate="yes" xml:space="preserve">
          <source>PCRE has an optimization that automatically &quot;possessifies&quot; certain simple pattern constructs. For example, the sequence A+B is treated as A++B, as there is no point in backtracking into a sequence of A:s when B must follow.</source>
          <target state="translated">PCRE에는 특정 간단한 패턴 구성을 자동으로 &quot;포지션&quot;하는 최적화 기능이 있습니다. 예를 들어, 시퀀스 A + B는 B가 따라야 할 때 A : s 시퀀스로 역 추적 할 지점이 없으므로 A ++ B로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f0fc58f08622bddb7678d55039d7a59b7bc48042" translate="yes" xml:space="preserve">
          <source>PCRE supports an extension to Oniguruma: if a number is preceded by a plus or minus sign, it is taken as a relative reference, for example:</source>
          <target state="translated">PCRE는 Oniguruma에 대한 확장을 지원합니다. 숫자 앞에 더하기 또는 빼기 부호가 오는 경우 상대 참조로 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dec962e9c5b1c207185027f300491448a37e5072" translate="yes" xml:space="preserve">
          <source>PCRE supports five conventions for indicating line breaks in strings: a single CR (carriage return) character, a single LF (line feed) character, the two-character sequence CRLF, any of the three preceding, and any Unicode newline sequence.</source>
          <target state="translated">PCRE는 문자열에서 줄 바꿈을 표시하기위한 단일 CR (캐리지 리턴) 문자, 단일 LF (줄 바꿈) 문자, 두 문자 시퀀스 CRLF, 앞의 세 가지 문자 및 유니 코드 줄 바꿈 시퀀스의 다섯 가지 규칙을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fa87f3aabeb31ade442c9f5f35c180a263350233" translate="yes" xml:space="preserve">
          <source>PEM files, used by ssl API-functions, are cached. The cache is regularly checked to see if any cache entries should be invalidated, however this function provides a way to unconditionally clear the whole cache.</source>
          <target state="translated">ssl API 기능에서 사용되는 PEM 파일이 캐시됩니다. 캐시 항목을 무효화해야하는지 확인하기 위해 캐시를 정기적으로 점검하지만이 기능을 사용하면 전체 캐시를 무조건 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5042994dc29e0b7745ace489955579f5e16456d2" translate="yes" xml:space="preserve">
          <source>POLY1305</source>
          <target state="translated">POLY1305</target>
        </trans-unit>
        <trans-unit id="d0568d1c1f87f3ca3e6965698849e46435e09220" translate="yes" xml:space="preserve">
          <source>POLY1305 is available with OpenSSL 1.1.1 or later if not disabled by configuration.</source>
          <target state="translated">POLY1305는 구성에 의해 비활성화되지 않은 경우 OpenSSL 1.1.1 이상에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8aa6cc7fa4d908912776c2db48294fafe7237e" translate="yes" xml:space="preserve">
          <source>POSIX Error Codes</source>
          <target state="translated">POSIX 오류 코드</target>
        </trans-unit>
        <trans-unit id="135bec020b8c2fed18e800ec919b567b281c8a13" translate="yes" xml:space="preserve">
          <source>POSIX Time</source>
          <target state="translated">POSIX 시간</target>
        </trans-unit>
        <trans-unit id="c890d6f6c5e3b641d450986635fca5239474a886" translate="yes" xml:space="preserve">
          <source>PRE TLS-1.3 these names differ for RFC names</source>
          <target state="translated">PRE TLS-1.3이 이름은 RFC 이름에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2eac7604dbdefe54932409a6ebb9a50abd2e8624" translate="yes" xml:space="preserve">
          <source>PSK and session resumption is supported (stateful and stateless tickets)</source>
          <target state="translated">PSK 및 세션 재개가 지원됩니다 (상태 저장 및 상태 비 저장 티켓).</target>
        </trans-unit>
        <trans-unit id="1ba8df77889f1181a72d5c498af3180cd0487517" translate="yes" xml:space="preserve">
          <source>PSK with (EC)DHE</source>
          <target state="translated">(EC) DHE를 사용한 PSK</target>
        </trans-unit>
        <trans-unit id="046d25012c0b58d806710b7947f458d18f6711f8" translate="yes" xml:space="preserve">
          <source>PSK-only</source>
          <target state="translated">PSK-only</target>
        </trans-unit>
        <trans-unit id="1cd905f009accd2df9f1ab5f8a17d5b5c38872a6" translate="yes" xml:space="preserve">
          <source>Package the installation in &lt;code&gt;&amp;lt;RELEASE_DIR&amp;gt;&lt;/code&gt;, place it wherever you want on your target machine, and run the &lt;code&gt;Install&lt;/code&gt; script on your target machine:</source>
          <target state="translated">&lt;code&gt;&amp;lt;RELEASE_DIR&amp;gt;&lt;/code&gt; 에 설치를 패키지하고 대상 시스템에서 원하는 위치에 배치 한 후 대상 시스템에서 &lt;code&gt;Install&lt;/code&gt; 스크립트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2b5d604d7f06e3d1f95fc5dc804a3221b871852" translate="yes" xml:space="preserve">
          <source>Packed Encoding Rules (PER), both the aligned and unaligned variant</source>
          <target state="translated">정렬 된 변형과 정렬되지 않은 변형 모두 팩형 인코딩 규칙 (PER)</target>
        </trans-unit>
        <trans-unit id="e71a71de422305a16e28853d413eeb1fe6adaa8c" translate="yes" xml:space="preserve">
          <source>Packets can be sent to the returned socket &lt;code&gt;Socket&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;. Packets sent from the peer are delivered as messages (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the listening socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 반환 된 소켓 &lt;code&gt;Socket&lt;/code&gt; 에 패킷을 보낼 수 있습니다 . 피어에서 보낸 패킷은 메시지로 전달됩니다 ( 리스닝 소켓의 옵션 목록에 &lt;code&gt;{active, false}&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 패킷을 검색하는 경우 ).</target>
        </trans-unit>
        <trans-unit id="999e0ae2fd1b7fad6eb65fd1659da2a1e9675393" translate="yes" xml:space="preserve">
          <source>Packets can be sent to the returned socket &lt;code&gt;Socket&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;. Packets sent from the peer are delivered as messages:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 반환 된 소켓 &lt;code&gt;Socket&lt;/code&gt; 에 패킷을 보낼 수 있습니다 . 피어에서 보낸 패킷은 메시지로 배달됩니다.</target>
        </trans-unit>
        <trans-unit id="a9cbdaa25497050f647df52257a52127df4c6dcd" translate="yes" xml:space="preserve">
          <source>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The header length can be one, two, or four bytes, and containing an unsigned integer in big-endian byte order. Each send operation generates the header, and the header is stripped off on each receive operation.</source>
          <target state="translated">패킷은 패킷의 바이트 수를 지정하는 헤더와 그 바이트 수로 구성됩니다. 헤더 길이는 1, 2 또는 4 바이트 일 수 있으며 빅 엔디안 바이트 순서로 부호없는 정수를 포함합니다. 각 전송 작업은 헤더를 생성하고 각 수신 작업에서 헤더가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d592f83333abf860b4699c427f31bf34be37ff" translate="yes" xml:space="preserve">
          <source>Packets consist of a header specifying the number of bytes in the packet, followed by that number of bytes. The length of the header can be one, two, or four bytes; the order of the bytes is big-endian. The header is stripped off when the packet is returned.</source>
          <target state="translated">패킷은 패킷의 바이트 수를 지정하는 헤더와 그 바이트 수로 구성됩니다. 헤더의 길이는 1, 2 또는 4 바이트 일 수 있습니다. 바이트의 순서는 빅 엔디안입니다. 패킷이 반환되면 헤더가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f8676c898cfd0dc16d652496de7c51b83121c16e" translate="yes" xml:space="preserve">
          <source>Padding could be enabled with the option &lt;code&gt;&lt;a href=&quot;#type-padding&quot;&gt;{padding,Padding}&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; enables &lt;code&gt;pkcs_padding&lt;/code&gt; or no padding (&lt;code&gt;none&lt;/code&gt;). The paddings &lt;code&gt;zero&lt;/code&gt; or &lt;code&gt;random&lt;/code&gt; fills the last part of the last block with zeroes or random bytes. If the last block is already full, nothing is added.</source>
          <target state="translated">패딩은 &lt;code&gt;&lt;a href=&quot;#type-padding&quot;&gt;{padding,Padding}&lt;/a&gt;&lt;/code&gt; 옵션으로 활성화 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; 이 가능 &lt;code&gt;pkcs_padding&lt;/code&gt; 또는 패딩 ( &lt;code&gt;none&lt;/code&gt; ). &lt;code&gt;zero&lt;/code&gt; 또는 &lt;code&gt;random&lt;/code&gt; 의 패딩 은 마지막 블록의 마지막 부분을 0 또는 임의의 바이트로 채 웁니다. 마지막 블록이 이미 가득 차면 아무것도 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9b4528e2d3cf117ea52177114c90e71d60519dc" translate="yes" xml:space="preserve">
          <source>Pads &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;Length&lt;/code&gt; with grapheme cluster &lt;code&gt;Char&lt;/code&gt;. &lt;code&gt;Dir&lt;/code&gt;, which can be &lt;code&gt;leading&lt;/code&gt;, &lt;code&gt;trailing&lt;/code&gt;, or &lt;code&gt;both&lt;/code&gt;, indicates where the padding should be added.</source>
          <target state="translated">패드 &lt;code&gt;String&lt;/code&gt; 에 &lt;code&gt;Length&lt;/code&gt; 그래 핀 클러스터 &lt;code&gt;Char&lt;/code&gt; . &lt;code&gt;leading&lt;/code&gt; , &lt;code&gt;trailing&lt;/code&gt; 또는 &lt;code&gt;both&lt;/code&gt; 수있는 &lt;code&gt;Dir&lt;/code&gt; 은 패딩을 추가 할 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="62bfbd510157d2b2d32934302b71a771f9fb8488" translate="yes" xml:space="preserve">
          <source>Pahawh_Hmong</source>
          <target state="translated">Pahawh_Hmong</target>
        </trans-unit>
        <trans-unit id="ea98d285a450c2d86578176798a994d47e81c69f" translate="yes" xml:space="preserve">
          <source>Palmyrene</source>
          <target state="translated">Palmyrene</target>
        </trans-unit>
        <trans-unit id="eb7595283333290680efe8f59bad4f5efb16ee78" translate="yes" xml:space="preserve">
          <source>Paragraph separator</source>
          <target state="translated">단락 구분자</target>
        </trans-unit>
        <trans-unit id="ea1f90af11a63290665889dc8c71bcb46ef20ff7" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;ArgL&lt;/code&gt; is a list of the following options:</source>
          <target state="translated">매개 변수 &lt;code&gt;ArgL&lt;/code&gt; 은 다음 옵션의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="481ff685beef8edc87c1c25cefdedd5dd3072163" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;FlagList&lt;/code&gt; is a list of options. The following are the valid options:</source>
          <target state="translated">Parameter &lt;code&gt;FlagList&lt;/code&gt; 는 옵션 목록입니다. 유효한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb58c9f9f7662428e1102cf73d06277b9a9f8408" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;Item&lt;/code&gt; specifies which driver to monitor (the driver name) and which state change to monitor. The parameter is a tuple of arity two whose first element is the driver name and second element is one of the following:</source>
          <target state="translated">매개 변수 &lt;code&gt;Item&lt;/code&gt; 은 모니터링 할 드라이버 (드라이버 이름) 및 모니터링 할 상태 변경을 지정합니다. 이 매개 변수는 첫 번째 요소가 드라이버 이름이고 두 번째 요소가 다음 중 하나 인 arity 2의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="ffc2bcb064cabdbae071c079e72742a961a53078" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;MgrAgentConfName&lt;/code&gt; in the functions is to be a name you allocate in your test suite using a &lt;code&gt;require&lt;/code&gt; statement. Example (where &lt;code&gt;MgrAgentConfName = snmp_mgr_agent&lt;/code&gt;):</source>
          <target state="translated">함수의 &lt;code&gt;MgrAgentConfName&lt;/code&gt; 매개 변수 는 &lt;code&gt;require&lt;/code&gt; 문을 사용하여 테스트 스위트에 할당 한 이름 입니다. 예 (여기서 &lt;code&gt;MgrAgentConfName = snmp_mgr_agent&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="67a9b163fdabde30f306efc624573ddbed00e72a" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;Options&lt;/code&gt; is a list of atoms that specifies table type, access rights, key position, and whether the table is named. Default values are used for omitted options. This means that not specifying any options (&lt;code&gt;[]&lt;/code&gt;) is the same as specifying &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;Options&lt;/code&gt; 은 테이블 유형, 액세스 권한, 키 위치 및 테이블 이름 지정 여부를 지정하는 원자 목록입니다. 생략 된 옵션에는 기본값이 사용됩니다. 이는 옵션 ( &lt;code&gt;[]&lt;/code&gt; )을 지정하지 않으면 &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a2266f7f7cc282a30cd7a8c0468383b6f19dbee" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;Options&lt;/code&gt; is a list of options that specifies table type, access rights, key position, and whether the table is named. Default values are used for omitted options. This means that not specifying any options (&lt;code&gt;[]&lt;/code&gt;) is the same as specifying &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}, {decentralized_counters,false}]&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;Options&lt;/code&gt; 은 테이블 유형, 액세스 권한, 키 위치 및 테이블 이름 지정 여부를 지정하는 옵션 목록입니다. 생략 된 옵션에는 기본값이 사용됩니다. 즉, 옵션 ( &lt;code&gt;[]&lt;/code&gt; )을 지정하지 않는 것은 &lt;code&gt;[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}, {decentralized_counters,false}]&lt;/code&gt; 를 지정하는 것과 같습니다. ] .</target>
        </trans-unit>
        <trans-unit id="a0265f8de4f4646ca005773d4ffc9856ff9b487f" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;UserData&lt;/code&gt; is typically the result of opening a low-level structure like a file descriptor or an SFTP channel id. The different &lt;code&gt;Fun&lt;/code&gt; clauses operate on that very term.</source>
          <target state="translated">매개 변수 &lt;code&gt;UserData&lt;/code&gt; 는 일반적으로 파일 설명자 또는 SFTP 채널 ID와 같은 저수준 구조를 연 결과입니다. 다른 &lt;code&gt;Fun&lt;/code&gt; 절이 바로 그 용어로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9d795107fbe2f795cba5a352dc3d9eb7ed96b4b2" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;UserPrivate&lt;/code&gt; is typically the result of opening a low-level structure like a file descriptor or an SFTP channel id. The different &lt;code&gt;Fun&lt;/code&gt; clauses operate on that very term.</source>
          <target state="translated">매개 변수 &lt;code&gt;UserPrivate&lt;/code&gt; 는 일반적으로 파일 디스크립터 또는 SFTP 채널 ID와 같은 저수준 구조를 연 결과입니다. 다른 &lt;code&gt;Fun&lt;/code&gt; 절은 바로 그 용어에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="178879c4f36263f5398b5fe0c1d2b17ffe37778c" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;buf&lt;/code&gt; points to the data to send, and &lt;code&gt;len&lt;/code&gt; is the number of bytes.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 매개 변수 는 전송할 데이터를 가리키며 &lt;code&gt;len&lt;/code&gt; 은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="8c3b0a66603387ab483d713b83c217fa59d3b555" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;event&lt;/code&gt; identifies an OS-specific event object. On Unix systems, the functions &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; are used. The event object must be a socket or pipe (or other object that &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; can use). On Windows, the Win32 API function &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; is used. This places other restrictions on the event object; see the Win32 SDK documentation.</source>
          <target state="translated">매개 변수 &lt;code&gt;event&lt;/code&gt; 는 OS 특정 이벤트 객체를 식별합니다. 유닉스 시스템에서는 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 기능 이 사용됩니다. 이벤트 오브젝트는 소켓 또는 파이프 여야합니다 (또는 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; 할 수있는 다른 오브젝트 ). Windows에서는 Win32 API 함수 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; 가 사용됩니다. 이로 인해 이벤트 객체에 다른 제한이 적용됩니다. Win32 SDK 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="164ddca5ff1565ca4f9e0ee9934496e78da5103a" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;extra_db_nodes&lt;/code&gt; can also be used on disc based nodes.</source>
          <target state="translated">디스크 기반 노드에서 &lt;code&gt;extra_db_nodes&lt;/code&gt; 매개 변수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19911242e8e159e23d1389d3ca9b289be8023784" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;group_names_or_paths&lt;/code&gt; specifies one or more group names and/or one or more group paths. At startup, &lt;code&gt;Common Test&lt;/code&gt; searches for matching groups in the group definitions tree (that is, the list returned from &lt;code&gt;Suite:groups/0&lt;/code&gt;; for details, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;group_names_or_paths&lt;/code&gt; 는 하나 이상의 그룹 이름 및 / 또는 하나 이상의 그룹 경로를 지정합니다. &lt;code&gt;Common Test&lt;/code&gt; 는 시작시 그룹 정의 트리에서 일치하는 그룹 (즉, &lt;code&gt;Suite:groups/0&lt;/code&gt; 에서 리턴 된 목록)을 검색합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83d4a946c14610cd207ac0d8f60cb89155f38f46" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;mode&lt;/code&gt; is a bitwise OR combination of &lt;code&gt;ERL_DRV_READ&lt;/code&gt;, &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt;, and &lt;code&gt;ERL_DRV_USE&lt;/code&gt;. The first two specify whether to wait for read events and/or write events. A fired read event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt; ready_input&lt;/a&gt;&lt;/code&gt; and a fired write event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt; ready_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;ERL_DRV_READ&lt;/code&gt; , &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt; 및 &lt;code&gt;ERL_DRV_USE&lt;/code&gt; 의 비트 단위 OR 조합입니다 . 처음 두 개는 읽기 이벤트 및 / 또는 쓰기 이벤트를 대기할지 여부를 지정합니다. &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt; ready_input&lt;/a&gt;&lt;/code&gt; 읽기 이벤트는 ready_input을 호출하고 시작된 쓰기 이벤트는 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt; ready_output&lt;/a&gt;&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="1db4151b626c494895a3303e3e9dc15c541574a3" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;mode&lt;/code&gt; is a bitwise OR combination of &lt;code&gt;ERL_DRV_READ&lt;/code&gt;, &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt;, and &lt;code&gt;ERL_DRV_USE&lt;/code&gt;. The first two specify whether to wait for read events and/or write events. A fired read event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt;ready_input&lt;/a&gt;&lt;/code&gt; and a fired write event calls &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt;ready_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;ERL_DRV_READ&lt;/code&gt; , &lt;code&gt;ERL_DRV_WRITE&lt;/code&gt; 및 &lt;code&gt;ERL_DRV_USE&lt;/code&gt; 의 비트 단위 OR 조합입니다 . 처음 두 개는 이벤트 읽기 및 / 또는 쓰기 이벤트 대기 여부를 지정합니다. 발생 된 읽기 이벤트는 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_input&quot;&gt;ready_input&lt;/a&gt;&lt;/code&gt; 을 호출 하고 발생 된 쓰기 이벤트는 &lt;code&gt;&lt;a href=&quot;driver_entry#ready_output&quot;&gt;ready_output&lt;/a&gt;&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="24b7e614b3fb7661e3c4bfa669cf966c8e65b191" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;offset&lt;/code&gt; is an offset into the binary and &lt;code&gt;len&lt;/code&gt; is the number of bytes to send.</source>
          <target state="translated">매개 변수 &lt;code&gt;offset&lt;/code&gt; 은 이진에 대한 오프셋이며 &lt;code&gt;len&lt;/code&gt; 은 보낼 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2c09fe112bbeb4630f395aac2bcdfe148aca5521" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;on&lt;/code&gt; is to be &lt;code&gt;1&lt;/code&gt; for setting events and &lt;code&gt;0&lt;/code&gt; for clearing them.</source>
          <target state="translated">이벤트 설정의 경우 매개 변수 &lt;code&gt;on&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 이고 , 지우 려면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c6329fafab17889c996d466aa0b5a818fe1c76a" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;port&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; an ordinary port handle, but a port handle converted using &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt; driver_mk_port&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;port&lt;/code&gt; 입니다 &lt;strong&gt;하지&lt;/strong&gt; 일반 포트 핸들,하지만 포트 핸들을 사용하여 변환 &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt; driver_mk_port&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f74566537c8d9ce233e9f86c48184e78edfc96b6" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;port&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; an ordinary port handle, but a port handle converted using &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt;driver_mk_port&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;port&lt;/code&gt; 입니다 &lt;strong&gt;하지&lt;/strong&gt; 일반 포트 핸들,하지만 포트 핸들을 사용하여 변환 &lt;code&gt;&lt;a href=&quot;#driver_mk_port&quot;&gt;driver_mk_port&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b389bdc5e8c68c9bf486330a4dfc6e8f07dac5d9" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;process&lt;/code&gt; is to be the return value of an earlier call to &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt; driver_caller&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">매개 변수 &lt;code&gt;process&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt; driver_caller&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; 호출 에 대한 이전 호출의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="31842056db03aa395dd407bca74bccb68a5a26bb" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;process&lt;/code&gt; is to be the return value of an earlier call to &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt;driver_caller&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">매개 변수 &lt;code&gt;process&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#driver_caller&quot;&gt;driver_caller&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#driver_connected&quot;&gt;driver_connected&lt;/a&gt;&lt;/code&gt; 호출 에 대한 이전 호출의 리턴 값입니다 .</target>
        </trans-unit>
        <trans-unit id="66a261af649e0d1c255cd39045bb5e13b9ca6186" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;skip&lt;/code&gt; is a number of bytes to skip of the &lt;code&gt;ev&lt;/code&gt; vector from the head.</source>
          <target state="translated">매개 변수 &lt;code&gt;skip&lt;/code&gt; 은 헤드에서 &lt;code&gt;ev&lt;/code&gt; 벡터 를 건너 뛸 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="64e4fb00a7835e330447d940e7db2ce15d43c569" translate="yes" xml:space="preserve">
          <source>Parameter &lt;code&gt;term&lt;/code&gt; points to an array of &lt;code&gt;ErlDrvTermData&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; elements. This array contains terms described in the driver term format. Every term consists of 1-4 elements in the array. The first term has a term type and then arguments. Parameter &lt;code&gt;port&lt;/code&gt; specifies the sending port.</source>
          <target state="translated">매개 변수 &lt;code&gt;term&lt;/code&gt; 는 &lt;code&gt;n&lt;/code&gt; 개의 요소 가있는 &lt;code&gt;ErlDrvTermData&lt;/code&gt; 의 배열을 가리 킵니다 . 이 배열은 드라이버 용어 형식으로 설명 된 용어를 포함합니다. 모든 용어는 배열에서 1-4 개의 요소로 구성됩니다. 첫 번째 용어에는 용어 유형과 인수가 있습니다. 파라미터 &lt;code&gt;port&lt;/code&gt; 는 송신 포트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="619a12371bd91db45106e0947981ba34d3c2bd49" translate="yes" xml:space="preserve">
          <source>Parameterization, which is defined in X.683, can be used when defining types, values, value sets, classes, objects, or object sets. A part of a definition can be supplied as a parameter. For example, if a &lt;code&gt;Type&lt;/code&gt; is used in a definition with a certain purpose, you want the type name to express the intention. This can be done with parameterization.</source>
          <target state="translated">X.683에 정의 된 매개 변수화는 유형, 값, 값 세트, 클래스, 오브젝트 또는 오브젝트 세트를 정의 할 때 사용할 수 있습니다. 정의의 일부를 매개 변수로 제공 할 수 있습니다. 예를 들어, 특정 목적으로 정의에 &lt;code&gt;Type&lt;/code&gt; 을 사용하는 경우 유형 이름에 의도를 표시하려고합니다. 이것은 매개 변수화로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f2f731b6fa47d9e1cb589072277ce145e0fd44" translate="yes" xml:space="preserve">
          <source>Parameterized queries</source>
          <target state="translated">매개 변수화 된 쿼리</target>
        </trans-unit>
        <trans-unit id="e37afe9cf72f8741ca2e835677dabb056b3df604" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;port&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;port&lt;/code&gt; , &lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 에서 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3001577f3d424b071c234b5e5a77e2c797ba8919" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;port&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; , &lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 에서 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5222f53305ea881b58cbd6fc24ce56b2532be794" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;term&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt; erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 에서 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="aa047ce05d4bbf51547604b5fd791b6e5ce4e1a0" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;term&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; work as in &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;#erl_drv_output_term&quot;&gt;erl_drv_output_term&lt;/a&gt;&lt;/code&gt; 에서 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="52408a3808b8f3d07d1e351897f44c8601912f48" translate="yes" xml:space="preserve">
          <source>Parameters to be used to call public_key:generate_key/1, to generate a key, or an existing key. Defaults to generating an ECDSA key. Note this could fail if Erlang/OTP is compiled with a very old cryptolib.</source>
          <target state="translated">키 또는 기존 키를 생성하기 위해 public_key : generate_key / 1을 호출하는 데 사용되는 매개 변수입니다. ECDSA 키 생성이 기본값입니다. Erlang / OTP가 매우 오래된 암호로 컴파일 된 경우 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="603b6d7d88b76cdf28420d118d75c73cf2f74970" translate="yes" xml:space="preserve">
          <source>Parametric curve definition.</source>
          <target state="translated">파라 메트릭 곡선 정의.</target>
        </trans-unit>
        <trans-unit id="f544c8871ad84d3b8d3ea9af03500476893103ea" translate="yes" xml:space="preserve">
          <source>Parentheses are used for grouping, either to make an expression more readable or to override the default precedence of operators:</source>
          <target state="translated">괄호는 표현식을보다 읽기 쉽게 만들거나 연산자의 기본 우선 순위를 재정의하기 위해 그룹화에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a38e57cb166c131b67e7c17a52a16571f7e59fb9" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions are useful to override &lt;code&gt;&lt;a href=&quot;#prec&quot;&gt;operator precedences&lt;/a&gt;&lt;/code&gt;, for example, in arithmetic expressions:</source>
          <target state="translated">괄호로 묶은 표현식은 &lt;code&gt;&lt;a href=&quot;#prec&quot;&gt;operator precedences&lt;/a&gt;&lt;/code&gt; 를 재정의하는 데 유용합니다 ( 예 : 산술 표현식).</target>
        </trans-unit>
        <trans-unit id="1eeecad7580d2da2f17c99a50bfedd315bdbe5ca" translate="yes" xml:space="preserve">
          <source>Parse Transformations</source>
          <target state="translated">구문 분석 변환</target>
        </trans-unit>
        <trans-unit id="1ec3038821c8e34cb4ca25c92efd7b368a0d8e5a" translate="yes" xml:space="preserve">
          <source>Parse a stream containing an XML document.</source>
          <target state="translated">XML 문서를 포함하는 스트림을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="8217aea2b6b930a773bd2a30eafc88abe67c2fba" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document</source>
          <target state="translated">XML 문서를 포함하는 파싱 파일</target>
        </trans-unit>
        <trans-unit id="5a6136b4aa579fcfcffcc46e0f8f8eb6d5603d86" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document as a stream, DOM style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;continuation_fun&lt;/code&gt; for handling streams of XML data. Note that the &lt;code&gt;continuation_fun&lt;/code&gt;, &lt;code&gt;acc_fun&lt;/code&gt;, &lt;code&gt;fetch_fun&lt;/code&gt;, &lt;code&gt;rules&lt;/code&gt; and &lt;code&gt;close_fun&lt;/code&gt; options cannot be user defined using this parser.</source>
          <target state="translated">XML 문서를 스트림, DOM 스타일로 포함하는 파일을 구문 분석하십시오. XML 데이터 스트림을 처리하기위한 &lt;code&gt;continuation_fun&lt;/code&gt; 을 사용하여 XML 구문 분석기 &lt;code&gt;xmerl_scan&lt;/code&gt; 을 호출하기위한 랩퍼 . 있습니다 &lt;code&gt;continuation_fun&lt;/code&gt; , &lt;code&gt;acc_fun&lt;/code&gt; , &lt;code&gt;fetch_fun&lt;/code&gt; , &lt;code&gt;rules&lt;/code&gt; 및 &lt;code&gt;close_fun&lt;/code&gt; 의 옵션이 파서를 사용하여 사용자 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="674e40f858960e6e4df14fbdc24544779fa454b2" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document as a stream, SAX style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;continuation_fun&lt;/code&gt; for handling streams of XML data. Note that the &lt;code&gt;continuation_fun&lt;/code&gt;, &lt;code&gt;acc_fun&lt;/code&gt;, &lt;code&gt;fetch_fun&lt;/code&gt;, &lt;code&gt;rules&lt;/code&gt;, &lt;code&gt;hook_fun&lt;/code&gt;, &lt;code&gt;close_fun&lt;/code&gt; and &lt;code&gt;user_state&lt;/code&gt; options cannot be user defined using this parser.</source>
          <target state="translated">XML 문서를 스트림, SAX 스타일로 포함하는 파일을 구문 분석하십시오. XML 데이터 스트림을 처리하기위한 &lt;code&gt;continuation_fun&lt;/code&gt; 을 사용하여 XML 구문 분석기 &lt;code&gt;xmerl_scan&lt;/code&gt; 을 호출하기위한 랩퍼 . 있습니다 &lt;code&gt;continuation_fun&lt;/code&gt; , &lt;code&gt;acc_fun&lt;/code&gt; , &lt;code&gt;fetch_fun&lt;/code&gt; , &lt;code&gt;rules&lt;/code&gt; , &lt;code&gt;hook_fun&lt;/code&gt; , &lt;code&gt;close_fun&lt;/code&gt; 및 &lt;code&gt;user_state&lt;/code&gt; 옵션이 파서를 사용하여 사용자 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc9ee985dfae362f5f4036d5f83dc0f5fe590d74" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document, SAX style. Wrapper for a call to the XML parser &lt;code&gt;xmerl_scan&lt;/code&gt; with a &lt;code&gt;hook_fun&lt;/code&gt; for using xmerl export functionality directly after an entity is parsed.</source>
          <target state="translated">XML 문서, SAX 스타일을 포함하는 파일을 구문 분석하십시오. 엔티티를 구문 분석 한 후 직접 xmerl 내보내기 기능을 사용하기 위해 &lt;code&gt;hook_fun&lt;/code&gt; 을 사용하여 XML 구문 분석기 &lt;code&gt;xmerl_scan&lt;/code&gt; 을 호출하기위한 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="a7e66c978a3bc50b34f2f8f441cb5d45be8ce70b" translate="yes" xml:space="preserve">
          <source>Parse file containing an XML document. This functions uses a default continuation function to read the file in blocks.</source>
          <target state="translated">XML 문서를 포함하는 파일을 구문 분석하십시오. 이 기능은 기본 연속 기능을 사용하여 파일을 블록 단위로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c11cdcc0a2531ae96dc218c56c12636fa75bf6fe" translate="yes" xml:space="preserve">
          <source>Parse string containing an XML document</source>
          <target state="translated">XML 문서를 포함하는 구문 분석 문자열</target>
        </trans-unit>
        <trans-unit id="6b19e7fcfb29d25095c7a452b5d973ecb668a8f0" translate="yes" xml:space="preserve">
          <source>Parse text and substitute meta-variables.</source>
          <target state="translated">텍스트를 구문 분석하고 메타 변수를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="f3059059775d564c176b513311505460d999325b" translate="yes" xml:space="preserve">
          <source>Parse text and substitute meta-variables. Takes an initial scanner starting position as first argument.</source>
          <target state="translated">텍스트를 구문 분석하고 메타 변수를 대체하십시오. 최초 스캐너 시작 위치를 첫 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="995f08395199c28811d1c157ebeb410cdf5f6a52" translate="yes" xml:space="preserve">
          <source>Parse text.</source>
          <target state="translated">텍스트를 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="6f88d437ec32b29a09b77bb3c60dda1a500d3d76" translate="yes" xml:space="preserve">
          <source>Parse text. Takes an initial scanner starting position as first argument.</source>
          <target state="translated">텍스트를 구문 분석하십시오. 최초 스캐너 시작 위치를 첫 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2db8f8fef89f426d3dbefc3cc3581aafe79f6ce1" translate="yes" xml:space="preserve">
          <source>Parse the given test specification files and return the tests to run and skip.</source>
          <target state="translated">제공된 테스트 스펙 파일을 구문 분석하고 테스트를 실행하여 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="2163966b8b6a50fd1cf0cca656abeddf8dd5cc71" translate="yes" xml:space="preserve">
          <source>Parse transform for merl.</source>
          <target state="translated">merl에 대한 구문 분석 변환</target>
        </trans-unit>
        <trans-unit id="16b406d744c815ddcee583e6e5df09f0720355fa" translate="yes" xml:space="preserve">
          <source>Parse transform for merl. Enables the use of automatic metavariables and using quasi-quotes in matches and case switches. Also optimizes calls to functions in &lt;code&gt;merl&lt;/code&gt; by partially evaluating them, turning strings to templates, etc., at compile-time.</source>
          <target state="translated">merl에 대한 구문 분석 변환 자동 메타 변수를 사용하고 일치 및 대소 문자 전환에 준 따옴표를 사용할 수 있습니다. 또한 컴파일 타임에 부분적으로 평가하고 문자열을 템플릿으로 바꾸는 등의 방법으로 &lt;code&gt;merl&lt;/code&gt; 함수 호출을 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="1a936ecbdaa0108bef18e5866e06c3f267270543" translate="yes" xml:space="preserve">
          <source>Parse transformations are used if a programmer wants to use Erlang syntax, but with different semantics. The original Erlang code is then transformed into other Erlang code.</source>
          <target state="translated">프로그래머가 Erlang 구문을 사용하려고하지만 의미가 다른 경우 구문 분석 변환이 사용됩니다. 그런 다음 원래 Erlang 코드는 다른 Erlang 코드로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2baf70db7b7c168b6c27755c6350a0d8b3a3116" translate="yes" xml:space="preserve">
          <source>Parse transformations are used when a programmer wants to use Erlang syntax but with different semantics. The original Erlang code is then transformed into other Erlang code.</source>
          <target state="translated">프로그래머가 Erlang 구문을 사용하고 싶지만 의미가 다른 경우 구문 분석 변환이 사용됩니다. 그런 다음 원래 Erlang 코드는 다른 Erlang 코드로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b27625b152a11d3756ff7a956cb8d71acc5d561c" translate="yes" xml:space="preserve">
          <source>Parse trees for Erlang expression, see section &lt;code&gt;The Abstract Format&lt;/code&gt; in the ERTS User's Guide.</source>
          <target state="translated">Erlang 표현식의 구문 분석 트리는 ERTS 사용 설명서의 &lt;code&gt;The Abstract Format&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b485e40955067baa97180fef7a23873d2bbfac9" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a form. Returns one of the following:</source>
          <target state="translated">&lt;code&gt;Tokens&lt;/code&gt; 을 양식 인 것처럼 구문 분석 합니다. 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40605f235bf487ac5cc36c28815be60cb52740c7" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a list of expressions. Returns one of the following:</source>
          <target state="translated">표현식 목록 인 것처럼 &lt;code&gt;Tokens&lt;/code&gt; 을 구문 분석 합니다. 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5e90d2f7ca99ca3b5931aed84bb2db57dbbc833" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Tokens&lt;/code&gt; as if it was a term. Returns one of the following:</source>
          <target state="translated">용어 인 것처럼 &lt;code&gt;Tokens&lt;/code&gt; 을 구문 분석합니다 . 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="86ede94d84471001f5bfaece799d5f9fa59c6b81" translate="yes" xml:space="preserve">
          <source>Parses a URI. If no scheme defaults are provided, the value of the &lt;code&gt;&lt;a href=&quot;#scheme_defaults&quot;&gt;scheme_defaults&lt;/a&gt;&lt;/code&gt; function is used.</source>
          <target state="translated">URI를 구문 분석합니다. 구성표 기본값을 제공하지 않으면 &lt;code&gt;&lt;a href=&quot;#scheme_defaults&quot;&gt;scheme_defaults&lt;/a&gt;&lt;/code&gt; 함수 의 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22aeb59a17ed90dfcd4e4d9f7b96872d034caad8" translate="yes" xml:space="preserve">
          <source>Parses a digit map body</source>
          <target state="translated">숫자 맵 본문을 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="dd0ff0f3941a66c29a5874954a99087c88f42111" translate="yes" xml:space="preserve">
          <source>Parses a digit map body, represented as a list of characters, into a list of state transitions suited to be evaluated by megaco:eval_digit_map/1,2.</source>
          <target state="translated">문자 목록으로 표시되는 숫자 맵 본문을 megaco : eval_digit_map / 1,2에서 평가하기에 적합한 상태 전이 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="f9c79f9646018440e3ebc591b18276096ccfad27" translate="yes" xml:space="preserve">
          <source>Parses an &lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; and returns an IPv4 or IPv6 address string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-ip_address&quot;&gt;ip_address()&lt;/a&gt;&lt;/code&gt; 구문 분석하고 IPv4 또는 IPv6 주소 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b6c5f3cfcbd29b09ebd5d2c45e4555d696f66e8a" translate="yes" xml:space="preserve">
          <source>Parses an &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; compliant &lt;code&gt;uri_string()&lt;/code&gt; into a &lt;code&gt;uri_map()&lt;/code&gt;, that holds the parsed components of the &lt;code&gt;URI&lt;/code&gt;. If parsing fails, an error tuple is returned.</source>
          <target state="translated">구문 분석 &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; 을 준수 &lt;code&gt;uri_string()&lt;/code&gt; 에 &lt;code&gt;uri_map()&lt;/code&gt; 의 구문 분석 된 구성 요소를 보유하고, &lt;code&gt;URI&lt;/code&gt; 를 . 구문 분석에 실패하면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e34be64e7e0d26bd52b330f13bd6dd5de7306b80" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt;. Accepts a shortened IPv4 address string.</source>
          <target state="translated">IPv4 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 반환합니다 . 단축 된 IPv4 주소 문자열을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="18cc80d670fa4d4c9b9ad5cf24a3ddc556aaf953" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 address string containing four fields, that is, &lt;strong&gt;not&lt;/strong&gt; shortened, and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">단축 &lt;strong&gt;되지 않은&lt;/strong&gt; 네 개의 필드를 포함하는 IPv4 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c579f7b626178d3c420a2e9643120d9f2832584e" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 or IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Accepts a shortened IPv4 address string.</source>
          <target state="translated">IPv4 또는 IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 리턴합니다 . 단축 된 IPv4 주소 문자열을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="5aa7dda9589a835953ec88f83cdf4c9c4edfbf77" translate="yes" xml:space="preserve">
          <source>Parses an IPv4 or IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Does &lt;strong&gt;not&lt;/strong&gt; accept a shortened IPv4 address string.</source>
          <target state="translated">IPv4 또는 IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip4_address&quot;&gt;ip4_address()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 리턴합니다 . 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 단축 IPv4 주소 문자열을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="4b1a2097f959aec277e56d7b2f09d960c163d98b" translate="yes" xml:space="preserve">
          <source>Parses an IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. Does &lt;strong&gt;not&lt;/strong&gt; accept IPv4 addresses.</source>
          <target state="translated">IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 반환합니다 . 않습니다 &lt;strong&gt;하지&lt;/strong&gt; IPv4 주소를 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="eac51ea7e0934384fa0112eeeaf88c4ebab04633" translate="yes" xml:space="preserve">
          <source>Parses an IPv6 address string and returns an &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt;. If an IPv4 address string is specified, an IPv4-mapped IPv6 address is returned.</source>
          <target state="translated">IPv6 주소 문자열을 구문 분석하고 &lt;code&gt;&lt;a href=&quot;#type-ip6_address&quot;&gt;ip6_address()&lt;/a&gt;&lt;/code&gt; 반환합니다 . IPv4 주소 문자열을 지정하면 IPv4 매핑 된 IPv6 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bf75044e156126d255e07b08533855db07ce584c" translate="yes" xml:space="preserve">
          <source>Parses an escript and extracts its sections. This is the reverse of &lt;code id=&quot;extract_2&quot;&gt;&lt;a href=&quot;#create_2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">escript를 구문 분석하고 해당 섹션을 추출합니다. 이것은 &lt;code id=&quot;extract_2&quot;&gt;&lt;a href=&quot;#create_2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="86b0f38abf52f234a7baaf70256d4015ecabaa26" translate="yes" xml:space="preserve">
          <source>Parses an escript and extracts its sections. This is the reverse of &lt;code&gt;&lt;a href=&quot;#create-2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">escript를 구문 분석하고 해당 섹션을 추출합니다. 이것은 &lt;code&gt;&lt;a href=&quot;#create-2&quot;&gt;create/2&lt;/a&gt;&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="bdec3f2af87f1d33ee6b97ffa74db142958cd9e8" translate="yes" xml:space="preserve">
          <source>Parses the printout from an SQL table and returns a list of tuples.</source>
          <target state="translated">SQL 테이블에서 출력물을 구문 분석하고 튜플 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="f5365bc5f3e468cf2148385f40bff58f883061be" translate="yes" xml:space="preserve">
          <source>Parsing URIs into its components and returing a map</source>
          <target state="translated">URI를 구성 요소로 구문 분석하고 맵을 다시 작성</target>
        </trans-unit>
        <trans-unit id="c8eb7f630b2224852a36c9237667bd9e0484c53a" translate="yes" xml:space="preserve">
          <source>Parsing and serializing non-UTF-8 form-urlencoded query strings are also supported (&lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">비 UTF-8 형식으로 인코딩 된 쿼리 문자열 구문 분석 및 직렬화도 지원됩니다 ( &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="394ec0942f3b3fee9fe7ee73fb59ad007a74829f" translate="yes" xml:space="preserve">
          <source>Parsing of test specifications for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">에 대한 시험 사양의 구문 분석 &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546554c2840e61b82ab7aeb7ea63ff6baaa80832" translate="yes" xml:space="preserve">
          <source>Parsing of test specifications for Common Test.</source>
          <target state="translated">공통 테스트에 대한 테스트 사양 구문 분석</target>
        </trans-unit>
        <trans-unit id="9769719e65a84af80528eb749196580978ee6445" translate="yes" xml:space="preserve">
          <source>Part of a match specification list cannot be changed directly. If a function has a match specification, it can be replaced with a new one. To change an existing match specification, use the BIF &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; to retrieve the existing match specification.</source>
          <target state="translated">일치 사양 목록의 일부는 직접 변경할 수 없습니다. 기능이 일치 스펙을 갖는 경우 새 기능으로 대체 할 수 있습니다. 기존 일치 스펙을 변경하려면 BIF &lt;code&gt;&lt;a href=&quot;#trace_info-2&quot;&gt;erlang:trace_info/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 기존 일치 스펙을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="bf0d342d4ce21f38adfd95210e15a51046211865" translate="yes" xml:space="preserve">
          <source>Part of a pattern within square brackets is called a &quot;character class&quot;. The following are the only metacharacters in a character class:</source>
          <target state="translated">대괄호 안에있는 패턴의 일부를 &quot;문자 클래스&quot;라고합니다. 다음은 문자 클래스에서 유일한 메타 문자입니다.</target>
        </trans-unit>
        <trans-unit id="18b2611fc7db391596d869af43d014cbb4c1feec" translate="yes" xml:space="preserve">
          <source>Part of the &lt;code&gt;new API&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new API&lt;/code&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="36ce5203ba89b037d3f45fb0ea5c0d88605494d9" translate="yes" xml:space="preserve">
          <source>Part of the &lt;code&gt;new API&lt;/code&gt;. Do a complete encrypt or decrypt of the full text in the argument &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new API&lt;/code&gt; 일부입니다 . &lt;code&gt;Data&lt;/code&gt; 인수의 전체 텍스트를 완전히 암호화하거나 해독합니다 .</target>
        </trans-unit>
        <trans-unit id="6d2353d027c421b57617139eec211d5a253dad9b" translate="yes" xml:space="preserve">
          <source>Part of the &lt;code&gt;new API&lt;/code&gt;. Do a complete encrypt or decrypt with an AEAD cipher of the full text.</source>
          <target state="translated">&lt;code&gt;new API&lt;/code&gt; 일부입니다 . 전체 텍스트의 AEAD 암호로 완전한 암호화 또는 복호화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ad7926d1e37321235fe2bb0990ccec6758b82f69" translate="yes" xml:space="preserve">
          <source>Part of the &lt;code&gt;new API&lt;/code&gt;. Do an actual crypto operation on a part of the full text and the IV is supplied for each part. The &lt;code&gt;State&lt;/code&gt; should be created with &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new API&lt;/code&gt; 일부입니다 . 전체 텍스트의 일부에서 실제 암호화 작업을 수행하고 각 부분에 IV가 제공됩니다. &lt;code&gt;State&lt;/code&gt; 로 만들어야합니다 &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1b71960d803159cc937f7519730574a3e8c0cf0" translate="yes" xml:space="preserve">
          <source>Part of the &lt;code&gt;new API&lt;/code&gt;. Initializes a series of encryptions or decryptions and creates an internal state with a reference that is returned.</source>
          <target state="translated">&lt;code&gt;new API&lt;/code&gt; 일부입니다 . 일련의 암호화 또는 암호 해독을 초기화하고 반환 된 참조를 사용하여 내부 상태를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3c3a7ef9d414fd26a4f258e7fd770312d08a2e59" translate="yes" xml:space="preserve">
          <source>Part of the &lt;code&gt;new API&lt;/code&gt;. It does an actual crypto operation on a part of the full text. If the part is less than a number of full blocks, only the full blocks (possibly none) are encrypted or decrypted and the remaining bytes are saved to the next &lt;code&gt;crypto_update&lt;/code&gt; operation. The &lt;code&gt;State&lt;/code&gt; should be created with &lt;code&gt;&lt;a href=&quot;crypto#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;crypto#crypto_init-4&quot;&gt;crypto_init/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new API&lt;/code&gt; 일부입니다 . 전체 텍스트의 일부에서 실제 암호화 작업을 수행합니다. 부분이 전체 블록 수보다 적 으면 전체 블록 (아마도 없음) 만 암호화되거나 해독되고 나머지 바이트는 다음 &lt;code&gt;crypto_update&lt;/code&gt; 작업에 저장됩니다 . &lt;code&gt;State&lt;/code&gt; 로 만들어야합니다 &lt;code&gt;&lt;a href=&quot;crypto#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;crypto#crypto_init-4&quot;&gt;crypto_init/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bcb9ea04e25a8921a95bf6ab1089af46b847ca3" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;List&lt;/code&gt; into a list of sublists and a remainder. &lt;code&gt;Lists&lt;/code&gt; contains one sublist for each key in &lt;code&gt;Keys&lt;/code&gt;, in the corresponding order. The relative order of the elements in each sublist is preserved from the original &lt;code&gt;List&lt;/code&gt;. &lt;code&gt;Rest&lt;/code&gt; contains the elements in &lt;code&gt;List&lt;/code&gt; that are not associated with any of the specified keys, also with their original relative order preserved.</source>
          <target state="translated">파티션 &lt;code&gt;List&lt;/code&gt; 을 하위 목록과 나머지 목록 으로 나눕니다. &lt;code&gt;Lists&lt;/code&gt; 는 &lt;code&gt;Keys&lt;/code&gt; 의 각 키에 대해 하나의 하위 목록을 해당 순서대로 포함합니다. 각 하위 &lt;code&gt;List&lt;/code&gt; 에있는 요소의 상대적 순서는 원래 List 에서 유지됩니다 . &lt;code&gt;Rest&lt;/code&gt; 는 지정된 키와 연관되지 않은 원래 요소 순서와 함께 &lt;code&gt;List&lt;/code&gt; 의 요소를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="1d1e8ed0c63bea5501f0e18a8588004e6a97f424" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;List&lt;/code&gt; into two lists according to &lt;code&gt;Pred&lt;/code&gt;. &lt;code&gt;splitwith/2&lt;/code&gt; behaves as if it is defined as follows:</source>
          <target state="translated">&lt;code&gt;Pred&lt;/code&gt; 에 따라 파티션 &lt;code&gt;List&lt;/code&gt; 을 두 목록 으로 나눕니다 . &lt;code&gt;splitwith/2&lt;/code&gt; 는 다음과 같이 정의 된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="7a0f34af55f62b96f8e7863f5d8947f87bbe0f4d" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;List&lt;/code&gt; into two lists, where the first list contains all elements for which &lt;code&gt;Pred(Elem)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, and the second list contains all elements for which &lt;code&gt;Pred(Elem)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">파티션 &lt;code&gt;List&lt;/code&gt; 을 두 목록 으로 분할 합니다. 첫 번째 목록에는 &lt;code&gt;Pred(Elem)&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모든 요소가 포함되고 두 번째 목록에는 &lt;code&gt;Pred(Elem)&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 를 반환 하는 모든 요소가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="be77f796fd8548373af529ca7332cc6d13c15156" translate="yes" xml:space="preserve">
          <source>Parts of certificates can be decoded with &lt;code&gt;public_key:der_decode/2&lt;/code&gt;, using the ASN.1 type of that part. However, an application-specific certificate extension requires application-specific ASN.1 decode/encode-functions. In the recent example, the first value of &lt;code&gt;rdnSequence&lt;/code&gt; is of ASN.1 type &lt;code&gt;'X520CommonName'. ({2,5,4,3} = ?id-at-commonName)&lt;/code&gt;:</source>
          <target state="translated">인증서 부분은 해당 부분의 ASN.1 유형을 사용하여 &lt;code&gt;public_key:der_decode/2&lt;/code&gt; 로 디코딩 할 수 있습니다 . 그러나 응용 프로그램 별 인증서 확장에는 응용 프로그램 별 ASN.1 디코딩 / 인코딩 기능이 필요합니다. 최근 예에서 &lt;code&gt;rdnSequence&lt;/code&gt; 의 첫 번째 값 은 ASN.1 유형 &lt;code&gt;'X520CommonName'. ({2,5,4,3} = ?id-at-commonName)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39f1ccafc930086a1e2f26b171bee188745affe2" translate="yes" xml:space="preserve">
          <source>Pass extra chunks to be stored in the &lt;code&gt;.beam&lt;/code&gt; file. The extra chunks must be a list of tuples with a four byte binary as chunk name followed by a binary with the chunk contents. See &lt;code&gt;beam_lib&lt;/code&gt; for more information.</source>
          <target state="translated">추가 청크를 전달하여 &lt;code&gt;.beam&lt;/code&gt; 파일에 저장 하십시오. 추가 청크는 청크 이름으로 4 바이트 2 진이 있고 청크 내용이있는 2 진이있는 튜플 목록이어야합니다. 자세한 내용은 &lt;code&gt;beam_lib&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0d014bb56599fcece5464b8d5372d0e641b8c1b" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;+Mea config&lt;/code&gt; command-line flag to the Erlang runtime system you are going to use for creation of the allocator configuration. It will disable features that prevent &lt;code&gt;erts_alloc_config&lt;/code&gt; from doing its job. Note, you should &lt;strong&gt;not&lt;/strong&gt; use this flag when using the created configuration. Also note that it is important that you use the same &lt;code&gt;amount of schedulers&lt;/code&gt; when creating the configuration as you are going the use on the system using the configuration.</source>
          <target state="translated">패스 &lt;code&gt;+Mea config&lt;/code&gt; 하면 할당 구성의 생성을 위해 사용하려고하는 얼랑 런타임 시스템에 명령 줄 플래그. &lt;code&gt;erts_alloc_config&lt;/code&gt; 가 작업을 수행 하지 못하게하는 기능을 비활성화합니다 . 작성된 구성을 사용할 때이 플래그를 사용 &lt;strong&gt;하지&lt;/strong&gt; 않아야 합니다. 또한 구성을 사용하여 시스템에서 사용할 때 구성을 작성할 때 동일한 &lt;code&gt;amount of schedulers&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="52a8e49b5b4f355426b2d1b0e4d23c4d22798cb7" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;megaco_receive_handle&lt;/code&gt; to the transport module.</source>
          <target state="translated">패스 &lt;code&gt;megaco_receive_handle&lt;/code&gt; 전송 모듈을.</target>
        </trans-unit>
        <trans-unit id="a12c368fddb9450ed1c838dd29236b5bedef5580" translate="yes" xml:space="preserve">
          <source>Pass the cross compilation variables as command line arguments to &lt;code&gt;configure&lt;/code&gt; using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax.</source>
          <target state="translated">크로스 컴파일 변수를 명령 행 인수로 전달 하여 &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 구문을 사용하여 &lt;code&gt;configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15b216add241be5dbff40c5c961c72de3bf72091" translate="yes" xml:space="preserve">
          <source>Passed &quot;as-is&quot; from the &lt;code&gt;{advanced,Extra}&lt;/code&gt; part of the update instruction.</source>
          <target state="translated">업데이트 명령 의 &lt;code&gt;{advanced,Extra}&lt;/code&gt; 부분 에서 &quot;있는 그대로&quot;전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="48905dff7e74ddb13af1cf1fa9519a564cdab569" translate="yes" xml:space="preserve">
          <source>Passed as the first argument to all NIFs. All function arguments passed to a NIF belong to that environment. The return value from a NIF must also be a term belonging to the same environment.</source>
          <target state="translated">모든 NIF에 대한 첫 번째 인수로 전달되었습니다. NIF에 전달 된 모든 함수 인수는 해당 환경에 속합니다. NIF의 리턴 값도 동일한 환경에 속하는 용어 여야합니다.</target>
        </trans-unit>
        <trans-unit id="fe19796ea8ae4e0d9e314bad1316720d47fe5a55" translate="yes" xml:space="preserve">
          <source>Passed as the first argument to all the non-NIF callback functions (&lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#ErlNifResourceDtor&quot;&gt;dtor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#ErlNifResourceDown&quot;&gt;down&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt;). Works like a process bound environment but with a temporary pseudo process that &quot;terminates&quot; when the callback has returned. Terms may be created in this environment but they will only be accessible during the callback.</source>
          <target state="translated">NIF가 아닌 모든 콜백 함수 ( &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#ErlNifResourceDtor&quot;&gt;dtor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#ErlNifResourceDown&quot;&gt;down&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#ErlNifResourceStop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; )에 첫 번째 인수로 전달됩니다 . 프로세스 바운드 환경처럼 작동하지만 콜백이 반환되면 &quot;종료&quot;되는 임시 의사 프로세스를 사용합니다. 이 환경에서 약관을 만들 수 있지만 콜백 중에 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c3be2c46cb777ea99e77e7f907baf818750d4a3" translate="yes" xml:space="preserve">
          <source>Passes &lt;code&gt;ListIn&lt;/code&gt; through a sequence of substitution/expansion stages. For an &lt;code&gt;aliases&lt;/code&gt; operation, function &lt;code&gt;&lt;a href=&quot;#substitute_aliases-2&quot;&gt; substitute_aliases/2&lt;/a&gt;&lt;/code&gt; is applied using the specified list of aliases:</source>
          <target state="translated">패스 &lt;code&gt;ListIn&lt;/code&gt; 를 교체 / 신장 단계의 시퀀스를 통해. 들어 &lt;code&gt;aliases&lt;/code&gt; 동작 기능 &lt;code&gt;&lt;a href=&quot;#substitute_aliases-2&quot;&gt; substitute_aliases/2&lt;/a&gt;&lt;/code&gt; 는 별칭 지정된 목록을 사용하여 적용된다 :</target>
        </trans-unit>
        <trans-unit id="2a480eadd0d94fe624912e0c9231b5b28630f2a3" translate="yes" xml:space="preserve">
          <source>Passes &lt;code&gt;ListIn&lt;/code&gt; through a sequence of substitution/expansion stages. For an &lt;code&gt;aliases&lt;/code&gt; operation, function &lt;code&gt;&lt;a href=&quot;#substitute_aliases-2&quot;&gt;substitute_aliases/2&lt;/a&gt;&lt;/code&gt; is applied using the specified list of aliases:</source>
          <target state="translated">패스 &lt;code&gt;ListIn&lt;/code&gt; 를 교체 / 신장 단계의 시퀀스를 통해. 들어 &lt;code&gt;aliases&lt;/code&gt; 동작 기능 &lt;code&gt;&lt;a href=&quot;#substitute_aliases-2&quot;&gt;substitute_aliases/2&lt;/a&gt;&lt;/code&gt; 는 별칭 지정된 목록을 사용하여 적용된다 :</target>
        </trans-unit>
        <trans-unit id="e5bad30c3f82a8b6ce3c2d80f62cb2189d29b412" translate="yes" xml:space="preserve">
          <source>Passes extra arguments to the emulator startup program &lt;code&gt;erl.exe&lt;/code&gt; (or &lt;code&gt;start_erl.exe&lt;/code&gt;). Arguments that cannot be specified here are &lt;code&gt;-noinput&lt;/code&gt; (&lt;code&gt;StopActions&lt;/code&gt; would not work), &lt;code&gt;-name&lt;/code&gt;, and &lt;code&gt;-sname&lt;/code&gt; (they are specified in any way). The most common use is for specifying cookies and flags to be passed to &lt;code&gt;init:boot()&lt;/code&gt; (&lt;code&gt;-s&lt;/code&gt;).</source>
          <target state="translated">에뮬레이터 시작 프로그램 &lt;code&gt;erl.exe&lt;/code&gt; (또는 &lt;code&gt;start_erl.exe&lt;/code&gt; )에 추가 인수를 전달합니다 . 여기에 지정할 수없는 인수는 &lt;code&gt;-noinput&lt;/code&gt; ( &lt;code&gt;StopActions&lt;/code&gt; 가 작동하지 않음), &lt;code&gt;-name&lt;/code&gt; 및 &lt;code&gt;-sname&lt;/code&gt; 입니다 ( 어쨌든 지정됨 ). 가장 일반적인 용도는 쿠키와 플래그를 &lt;code&gt;init:boot()&lt;/code&gt; ( &lt;code&gt;-s&lt;/code&gt; ) 로 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="17423ed9634ebf487daeddd08024ea098b0dfac8" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;msg_env&lt;/code&gt; as &lt;code&gt;NULL&lt;/code&gt; is only supported as from ERTS 8.0 (Erlang/OTP 19).</source>
          <target state="translated">&lt;code&gt;msg_env&lt;/code&gt; 를 &lt;code&gt;NULL&lt;/code&gt; 로 전달하는 것은 ERTS 8.0 (Erlang / OTP 19)에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="05b52936612a6b19fd4936a6190ec91e1270fc3f" translate="yes" xml:space="preserve">
          <source>Passing the others on to an enclosing &lt;code&gt;try&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt;, or to default error handling.</source>
          <target state="translated">다른 것들을 둘러싼 &lt;code&gt;try&lt;/code&gt; 또는 &lt;code&gt;catch&lt;/code&gt; 또는 기본 오류 처리로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="7c5751b4937e362acbdf37fef68aa0c840a5f43f" translate="yes" xml:space="preserve">
          <source>Password authentication in Erlang SSH</source>
          <target state="translated">Erlang SSH의 비밀번호 인증</target>
        </trans-unit>
        <trans-unit id="c3441c01856bc44f16f44713579f9eb0b9cab8a3" translate="yes" xml:space="preserve">
          <source>Password-protected and encrypted archives are not supported.</source>
          <target state="translated">비밀번호로 보호되고 암호화 된 아카이브는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c3606fd7f334a9c3d48f5825a16e88b15b8c73b" translate="yes" xml:space="preserve">
          <source>Pasted text is inserted at the current prompt position and is interpreted by Erlang as usual keyboard input.</source>
          <target state="translated">붙여 넣은 텍스트는 현재 프롬프트 위치에 삽입되며 Erlang은 일반적인 키보드 입력으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="bae50870edf6016cbfd2f917e452b9a16dcd7599" translate="yes" xml:space="preserve">
          <source>Patches are either released as maintenance patch packages or emergency patch packages. The only difference is that maintenance patch packages are planned and usually contain more changes than emergency patch packages. Emergency patch packages are released to solve one or more specific issues when such are discovered.</source>
          <target state="translated">패치는 유지 보수 패치 패키지 또는 응급 패치 패키지로 릴리스됩니다. 유일한 차이점은 유지 관리 패치 패키지가 계획되어 있으며 일반적으로 응급 패치 패키지보다 더 많은 변경 사항이 포함되어 있다는 것입니다. 응급 패치 패키지는 발견 될 때 하나 이상의 특정 문제를 해결하기 위해 릴리스됩니다.</target>
        </trans-unit>
        <trans-unit id="8160b1ab2039239aefde8cb0e11cb5ebe2e0ad8b" translate="yes" xml:space="preserve">
          <source>Patching applications is a one-way process. Create a backup of your OTP installation directory before proceeding.</source>
          <target state="translated">패치 응용 프로그램은 단방향 프로세스입니다. 계속하기 전에 OTP 설치 디렉토리의 백업을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="55c14b77f9d8f42c4e27a07e774f4f8fb65cbb79" translate="yes" xml:space="preserve">
          <source>Path P is &lt;strong id=&quot;simple_path&quot;&gt;simple&lt;/strong&gt; if all vertices are distinct, except that the first and the last vertices can be the same.</source>
          <target state="translated">첫 번째와 마지막 정점이 동일 할 수 있다는 점을 제외하고 모든 정점이 구별되는 경우 경로 P는 &lt;strong id=&quot;simple_path&quot;&gt;간단&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e97f14f2f6a2a22960aaaf716fd64dd488ed83" translate="yes" xml:space="preserve">
          <source>Path P is a &lt;strong id=&quot;cycle&quot;&gt;cycle&lt;/strong&gt; if the length of P is not zero and v[1] = v[k].</source>
          <target state="translated">P 의 길이가 0이 아니고 v [1] = v [k] 인 경우 경로 P는 &lt;strong id=&quot;cycle&quot;&gt;주기&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ec4b3c7aff6a8f5ca4aa618fd7283506da7262b5" translate="yes" xml:space="preserve">
          <source>Path to a file containing PEM-encoded CA certificates. The CA certificates are used during server authentication and when building the client certificate chain.</source>
          <target state="translated">PEM으로 인코딩 된 CA 인증서가 포함 된 파일의 경로입니다. CA 인증서는 서버 인증 및 클라이언트 인증서 체인을 구축 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e90e566c06157343897915883777d52efdf4c086" translate="yes" xml:space="preserve">
          <source>Path to a file containing PEM-encoded CA certificates. The CA certificates are used to build the server certificate chain and for client authentication. The CAs are also used in the list of acceptable client CAs passed to the client when a certificate is requested. Can be omitted if there is no need to verify the client and if there are no intermediate CAs for the server certificate.</source>
          <target state="translated">PEM으로 인코딩 된 CA 인증서가 포함 된 파일의 경로입니다. CA 인증서는 서버 인증서 체인을 구축하고 클라이언트 인증을 위해 사용됩니다. CA는 인증서가 요청 될 때 클라이언트에 전달 된 허용 가능한 클라이언트 CA 목록에도 사용됩니다. 클라이언트를 확인할 필요가없고 서버 인증서에 대한 중간 CA가없는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a605e96cddb300d711887a44f810e2c399109734" translate="yes" xml:space="preserve">
          <source>Path to a file containing PEM-encoded Diffie Hellman parameters to be used by the server if a cipher suite using Diffie Hellman key exchange is negotiated. If not specified, default parameters are used.</source>
          <target state="translated">Diffie Hellman 키 교환을 사용하는 암호 스위트가 협상 된 경우 서버에서 사용할 PEM 인코딩 Diffie Hellman 매개 변수가 포함 된 파일의 경로입니다. 지정하지 않으면 기본 매개 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4652f6d89f276e4fe49b02c8985562829b98b7ad" translate="yes" xml:space="preserve">
          <source>Path to a file containing the user certificate on PEM format or possible several certificates where the first one is the users certificate and the rest of the certificates constitutes the certificate chain. For more details see &lt;code&gt;&lt;a href=&quot;#type-cert&quot;&gt;cert()&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">PEM 형식의 사용자 인증서를 포함하는 파일의 경로 또는 첫 번째 인증서가 사용자 인증서이고 나머지 인증서가 인증서 체인을 구성하는 가능한 여러 인증서. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#type-cert&quot;&gt;cert()&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eac8a20a2d9480ebb53700b4e9bedee92d37f637" translate="yes" xml:space="preserve">
          <source>Path to a file containing the user certificate.</source>
          <target state="translated">사용자 인증서가 포함 된 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="1e962d8338f96f1e74e511aa7a15c1b3d987bd58" translate="yes" xml:space="preserve">
          <source>Path to the file containing the user's private PEM-encoded key. As PEM-files can contain several entries, this option defaults to the same file as given by option &lt;code&gt;certfile&lt;/code&gt;.</source>
          <target state="translated">사용자의 개인 PEM 인코딩 키가 포함 된 파일의 경로입니다. PEM 파일에는 여러 항목이 포함될 수 &lt;code&gt;certfile&lt;/code&gt; 옵션의 기본값은 certfile 옵션에서 제공 한 것과 동일한 파일 입니다.</target>
        </trans-unit>
        <trans-unit id="8fcabcda1f4e1160624d33fb2f5784f5c63030cc" translate="yes" xml:space="preserve">
          <source>PathList is a list of directories to search when fetching files. If the file in question is not in the fetch_path, the URI will be used as a file name.</source>
          <target state="translated">PathList는 파일을 가져올 때 검색 할 디렉토리 목록입니다. 문제의 파일이 fetch_path에 없으면 URI가 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47482e00ecdde046c872e760861acd107da31305" translate="yes" xml:space="preserve">
          <source>Paths to keys are left to right, with subkeys to the right and backslash between keys. (Remember that backslashes must be doubled in Erlang strings.) Case is preserved but not significant.</source>
          <target state="translated">키에 대한 경로는 왼쪽에서 오른쪽으로, 하위 키는 오른쪽으로, 키 사이에는 백 슬래시가 있습니다. Erlang 문자열에서는 백 슬래시를 두 배로 늘려야합니다. 대소 문자는 유지되지만 중요하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a4ff6f40515d80959eb2891b1a4f521722adb61" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
          <target state="translated">패턴 매칭</target>
        </trans-unit>
        <trans-unit id="07df831a704cd0fc47532246baa7f29146388369" translate="yes" xml:space="preserve">
          <source>Pattern matching in function head as well as in &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt; clauses are optimized by the compiler. With a few exceptions, there is nothing to gain by rearranging clauses.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;receive&lt;/code&gt; 절 뿐만 아니라 함수 헤드에서도 패턴 일치가 컴파일러에 의해 최적화됩니다. 몇 가지 예외가 있지만 조항을 재정렬하여 얻을 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e33f96bb1810cf2a758f0574bbb8ca910eec1915" translate="yes" xml:space="preserve">
          <source>Pattern matching with records is very similar to creating records. For example, inside a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;receive&lt;/code&gt;:</source>
          <target state="translated">레코드와 패턴 일치는 레코드 작성과 매우 유사합니다. 예를 들어, &lt;code&gt;case&lt;/code&gt; 내부 또는 &lt;code&gt;receive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b4cf89b5b26547550456e5e4f643ae53f5d29be" translate="yes" xml:space="preserve">
          <source>Pattern variables &lt;code&gt;'$N'&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt;=0,1,...</source>
          <target state="translated">패턴 변수 &lt;code&gt;'$N'&lt;/code&gt; , 여기서 &lt;code&gt;N&lt;/code&gt; = 0,1, ...</target>
        </trans-unit>
        <trans-unit id="98d00def036dd2fd6e93404dff53fcc8b8b39938" translate="yes" xml:space="preserve">
          <source>Patterns are allowed in clause heads, &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt; expressions, and match expressions.</source>
          <target state="translated">절 머리글, &lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;receive&lt;/code&gt; 표현식 에서 패턴을 사용할 수 있으며 표현식을 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6af09a32bdb3adae271bf8a9bea0cb4b9c66dda2" translate="yes" xml:space="preserve">
          <source>Pau_Cin_Hau</source>
          <target state="translated">Pau_Cin_Hau</target>
        </trans-unit>
        <trans-unit id="49ed482e870cd614e256519cffa6b9161630c632" translate="yes" xml:space="preserve">
          <source>Pause call count tracing for all functions in all modules and stop it for all functions in modules to be loaded. This is the same as &lt;code&gt;(pause({'_','_','_'})+stop({on_load}))&lt;/code&gt;.</source>
          <target state="translated">모든 모듈의 모든 기능에 대해 호출 수 추적을 일시 중지하고 모듈의 모든 기능이로드되도록 중지하십시오. 이것은 &lt;code&gt;(pause({'_','_','_'})+stop({on_load}))&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2db0d11168e0cf244f7875ac1346e7b6c97f62cc" translate="yes" xml:space="preserve">
          <source>Pause call counters for matching functions in matching modules. The &lt;code&gt;FS&lt;/code&gt; argument can be used to specify the first argument to &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;. See erlang(3).</source>
          <target state="translated">일치하는 모듈에서 일치하는 기능을 위해 콜 카운터를 일시 중지합니다. &lt;code&gt;FS&lt;/code&gt; 의 인수에 대한 첫 번째 인수를 지정하는 데 사용할 수 있습니다 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; . erlang (3)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="391d516918ec3156c32ea3be943e04f2e2a433a7" translate="yes" xml:space="preserve">
          <source>Pauses the call counters for specified functions. This minimises the impact of code running in the background or in the shell that disturbs the profiling. Call counters are automatically paused when they &quot;hit the ceiling&quot; of the host machine word size. For a 32 bit host the maximum counter value is 2147483647.</source>
          <target state="translated">지정된 기능에 대한 콜 카운터를 일시 중지합니다. 이것은 프로파일 링을 방해하는 백그라운드 또는 쉘에서 실행되는 코드의 영향을 최소화합니다. 콜 카운터는 호스트 기계 단어 크기의 &quot;최고 한도&quot;에 도달하면 자동으로 일시 중지됩니다. 32 비트 호스트의 경우 최대 카운터 값은 2147483647입니다.</target>
        </trans-unit>
        <trans-unit id="cf9afa37f2e5869dc6ad902115a35d4f0c5f630f" translate="yes" xml:space="preserve">
          <source>Peer Connections</source>
          <target state="translated">피어 연결</target>
        </trans-unit>
        <trans-unit id="59488fa72b53c2103f34565feb175db9fb2c4131" translate="yes" xml:space="preserve">
          <source>Peer State Machine</source>
          <target state="translated">피어 스테이트 머신</target>
        </trans-unit>
        <trans-unit id="98ae8b5da563501389aa05d3f2695db094619a3c" translate="yes" xml:space="preserve">
          <source>Peer Table</source>
          <target state="translated">피어 테이블</target>
        </trans-unit>
        <trans-unit id="1bee610f8ffa13f60ce754210a4e3cbf3ffbe983" translate="yes" xml:space="preserve">
          <source>Peer to which the request in question can be sent, preempting the selection of peers having advertised support for the Diameter application in question. Multiple options can be specified, and their order is respected in the candidate lists passed to a subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback.</source>
          <target state="translated">해당 요청을 전송할 수있는 피어로서, 해당 직경 애플리케이션에 대한 광고를 지원하는 피어를 선점합니다. 여러 옵션을 지정할 수 있으며 순서는 후속 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백에 전달 된 후보 목록에서 고려 됩니다.</target>
        </trans-unit>
        <trans-unit id="84b84620029f6985cb04948713a4f88534fba4df" translate="yes" xml:space="preserve">
          <source>Peer-to-Peer Considerations</source>
          <target state="translated">피어 투 피어 고려 사항</target>
        </trans-unit>
        <trans-unit id="fcd5fc2500f0a1816c7d774f52e29f9431495a7a" translate="yes" xml:space="preserve">
          <source>Peers are only shared with services of the same name for the purpose of sending outgoing requests. Since the value of the &lt;code&gt;&lt;a href=&quot;#application_opt&quot;&gt;application_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;alias&lt;/code&gt;, passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;, is the handle for identifying a peer as a suitable candidate, services that share peers must use the same aliases to identify their supported applications. They should typically also configure identical &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt;, since by sharing peer connections they are distributing the implementation of a single Diameter node across multiple Erlang nodes.</source>
          <target state="translated">동료는 발신 요청을 보내기 위해 동일한 이름의 서비스와 만 공유됩니다. &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 에 전달 된 &lt;code&gt;&lt;a href=&quot;#application_opt&quot;&gt;application_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;alias&lt;/code&gt; 값은 피어를 적합한 후보로 식별하는 핸들이므로 피어를 공유하는 서비스는 지원되는 애플리케이션을 식별하기 위해 동일한 별명을 사용해야합니다. 피어 연결을 공유함으로써 여러 Erlang 노드에 단일 직경 노드 구현을 분배하기 때문에 일반적으로 동일한 &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="83040eadd1e47ac6af77c8ee2d41f0ec18c15f6e" translate="yes" xml:space="preserve">
          <source>Per module to caller</source>
          <target state="translated">발신자에게 모듈 당</target>
        </trans-unit>
        <trans-unit id="2cad7f79a8783eead4b37e0cf84881231114b250" translate="yes" xml:space="preserve">
          <source>Per process to screen/file</source>
          <target state="translated">화면 / 파일로 프로세스 당</target>
        </trans-unit>
        <trans-unit id="15141e26e03178e5d1d620e527c846aa1c625c2d" translate="yes" xml:space="preserve">
          <source>Per process/function to screen/file</source>
          <target state="translated">화면 / 파일에 대한 프로세스 / 기능별</target>
        </trans-unit>
        <trans-unit id="21a672c25cb6115c561386f5282f6c411185f4cd" translate="yes" xml:space="preserve">
          <source>Percent-encoding is implemented in &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; and it happens when converting a &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt;. There is no equivalent to a raw percent-encoding function as percent-encoding shall be applied on the component level using different sets of allowed characters. Applying percent-encoding directly on an input URI would not be safe just as in the case of &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt;, the output could be an invalid URI.</source>
          <target state="translated">백분율 인코딩은 &lt;code&gt;&lt;a href=&quot;uri_string#recompose-1&quot;&gt;uri_string:recompose/1&lt;/a&gt;&lt;/code&gt; 에서 구현되며 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_map&quot;&gt;uri_map()&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;uri_string#type-uri_string&quot;&gt;uri_string()&lt;/a&gt;&lt;/code&gt; 으로 변환 할 때 발생합니다 . 퍼센트 인코딩은 서로 다른 허용 문자 집합을 사용하여 구성 요소 수준에 적용되므로 원시 퍼센트 인코딩 기능에 해당하는 것은 없습니다. 입력 URI에 직접 백분율 인코딩을 적용하는 것은 &lt;code&gt;&lt;a href=&quot;uri_string#percent_decode-1&quot;&gt;uri_string:percent_decode/1&lt;/a&gt;&lt;/code&gt; 의 경우처럼 안전하지 않으며 출력이 잘못된 URI 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6128679797da16a04d84c728a524e6710fc16bbe" translate="yes" xml:space="preserve">
          <source>Percentage of accumulated waiting time of wall clock time. This percentage can be higher than 100% since accumulated time is from all threads.</source>
          <target state="translated">벽시계 시간의 누적 대기 시간 백분율. 누적 시간이 모든 스레드에서 오기 때문에이 백분율은 100 %보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb78b6579cb64af21372225b9a2c062736452a4" translate="yes" xml:space="preserve">
          <source>Perform CRL (Certificate Revocation List) verification &lt;code&gt; (public_key:pkix_crls_validate/3)&lt;/code&gt; on all the certificates during the path validation &lt;code&gt;(public_key:pkix_path_validation/3) &lt;/code&gt; of the certificate chain. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">인증서 체인 의 경로 유효성 검사 &lt;code&gt;(public_key:pkix_path_validation/3) &lt;/code&gt; 중에 모든 인증서에 대해 CRL (인증서 해지 목록) 확인 &lt;code&gt; (public_key:pkix_crls_validate/3)&lt;/code&gt; 을 수행합니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="900a5b77b467253970a850573dc79a89db1e52f1" translate="yes" xml:space="preserve">
          <source>Perform CRL (Certificate Revocation List) verification &lt;code&gt;(public_key:pkix_crls_validate/3)&lt;/code&gt; on all the certificates during the path validation &lt;code&gt;(public_key:pkix_path_validation/3)&lt;/code&gt; of the certificate chain. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">인증서 체인 의 경로 유효성 검사 &lt;code&gt;(public_key:pkix_path_validation/3)&lt;/code&gt; 중에 모든 인증서에 대해 CRL (인증서 해지 목록) 확인 &lt;code&gt;(public_key:pkix_crls_validate/3)&lt;/code&gt; 을 수행하십시오 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7dfd0566897f67f4a88a10a9ccab4a835f714346" translate="yes" xml:space="preserve">
          <source>Perform a backup of the mib-server data.</source>
          <target state="translated">mib 서버 데이터의 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f5297ab6e77bd5a8f87b119bc54aebb086ae8bf2" translate="yes" xml:space="preserve">
          <source>Perform a backup of the mib-storage table.</source>
          <target state="translated">mib-storage 테이블의 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3df0035ca80e21666d0fd6cd422cbcccdf7b1a" translate="yes" xml:space="preserve">
          <source>Perform a code-change (upgrade or downgrade).</source>
          <target state="translated">코드 변경 (업그레이드 또는 다운 그레이드)을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="dcafc54e1058ab12e1726559ee25482e972eb9fa" translate="yes" xml:space="preserve">
          <source>Perform a minimal decode of a megaco message.</source>
          <target state="translated">megaco 메시지의 최소 디코딩을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="794622c63bd34b165ba99166f899c7db08151e43" translate="yes" xml:space="preserve">
          <source>Perform mib server cache gc.</source>
          <target state="translated">mib 서버 캐시 gc를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="3130994b43da1d8950109e1c6564a8348e9d6104" translate="yes" xml:space="preserve">
          <source>Performance Considerations</source>
          <target state="translated">성능 고려 사항</target>
        </trans-unit>
        <trans-unit id="ffce32cc050ae65e8a2071012a2914617cc171d0" translate="yes" xml:space="preserve">
          <source>Performance suffers when modified timing is enabled. This flag is &lt;strong&gt;only&lt;/strong&gt; intended for testing and debugging.</source>
          <target state="translated">수정 된 타이밍이 활성화되면 성능이 저하됩니다. 이 플래그는 테스트 및 디버깅 &lt;strong&gt;전용&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d4cef1e85e0d8796653ef41a51578e4b550d221" translate="yes" xml:space="preserve">
          <source>Performance tuning. Defaults to &lt;code&gt;false&lt;/code&gt;, in which case an operation that mutates (writes to) the table obtains exclusive access, blocking any concurrent access of the same table until finished. If set to &lt;code&gt;true&lt;/code&gt;, the table is optimized to concurrent write access. Different objects of the same table can be mutated (and read) by concurrent processes. This is achieved to some degree at the expense of memory consumption and the performance of sequential access and concurrent reading.</source>
          <target state="translated">성능 조정 기본값은 &lt;code&gt;false&lt;/code&gt; 이며,이 경우 테이블을 변경 (쓰기)하는 작업은 단독 액세스를 가져 와서 완료 될 때까지 동일한 테이블의 동시 액세스를 차단합니다. &lt;code&gt;true&lt;/code&gt; 로 설정 하면 테이블이 동시 쓰기 액세스에 최적화됩니다. 동일한 테이블의 다른 개체는 동시 프로세스에 의해 변경 (및 읽기) 될 수 있습니다. 이는 메모리 소비와 순차적 액세스 및 동시 읽기 성능을 희생하여 어느 정도 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="4ab94c7cedeb2cfec74773af353f3d78c22eb541" translate="yes" xml:space="preserve">
          <source>Performance tuning. Defaults to &lt;code&gt;false&lt;/code&gt;. When set to &lt;code&gt;true&lt;/code&gt;, the table is optimized for concurrent read operations. When this option is enabled on a runtime system with SMP support, read operations become much cheaper; especially on systems with multiple physical processors. However, switching between read and write operations becomes more expensive.</source>
          <target state="translated">성능 조정 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;code&gt;true&lt;/code&gt; 로 설정 하면 테이블이 동시 읽기 작업에 최적화됩니다. SMP를 지원하는 런타임 시스템에서이 옵션을 사용하면 읽기 작업이 훨씬 저렴 해집니다. 특히 여러 개의 물리적 프로세서가있는 시스템에서. 그러나 읽기와 쓰기 작업 간 전환이 더 비싸집니다.</target>
        </trans-unit>
        <trans-unit id="91515440c402b608cc59dbc5bbe6e2a35b330acc" translate="yes" xml:space="preserve">
          <source>Performance tuning. Defaults to &lt;code&gt;true&lt;/code&gt; for tables of type &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt; write_concurrency&lt;/a&gt;&lt;/code&gt; option enabled, and defaults to false for all other table types. This option has no effect if the &lt;code&gt;write_concurrency&lt;/code&gt; option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">성능 조정. 기본값은 &lt;code&gt;true&lt;/code&gt; 타입의 테이블에 대한 &lt;code&gt;ordered_set&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt; write_concurrency&lt;/a&gt;&lt;/code&gt; 의 다른 모든 테이블 유형에 대한 false로 옵션이 설정 및 기본 설정됩니다. &lt;code&gt;write_concurrency&lt;/code&gt; 옵션이 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우이 옵션은 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="24461109bfb38c1846415956b344d29b6573204f" translate="yes" xml:space="preserve">
          <source>Performing the handshakes/cookie verification</source>
          <target state="translated">핸드 셰이크 / 쿠키 확인 수행</target>
        </trans-unit>
        <trans-unit id="748a52904d3e179112746e46060bb4e26004cda9" translate="yes" xml:space="preserve">
          <source>Performs CRL validation. It is intended to be called from the verify fun of &lt;code&gt;&lt;a href=&quot;#pkix_path_validation-3&quot;&gt; pkix_path_validation/3 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CRL 유효성 검사를 수행합니다. &lt;code&gt;&lt;a href=&quot;#pkix_path_validation-3&quot;&gt; pkix_path_validation/3 &lt;/a&gt;&lt;/code&gt; 의 검증 재미에서 호출되도록 의도되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4f5f75852079a024445eb45615d781f09840d582" translate="yes" xml:space="preserve">
          <source>Performs CRL validation. It is intended to be called from the verify fun of &lt;code&gt;&lt;a href=&quot;#pkix_path_validation-3&quot;&gt;pkix_path_validation/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CRL 유효성 검사를 수행합니다. &lt;code&gt;&lt;a href=&quot;#pkix_path_validation-3&quot;&gt;pkix_path_validation/3&lt;/a&gt;&lt;/code&gt; 의 검증 기능에서 호출하도록되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55946f4b90e3f6fd8ef1498f50ddd3c5f07b68a6" translate="yes" xml:space="preserve">
          <source>Performs a GET operation on the agent. All loaded MIB objects are visible in this operation. The agent calls the corresponding instrumentation functions just as if it was a GET request coming from a manager.</source>
          <target state="translated">에이전트에서 GET 조작을 수행합니다. 이 작업에서는로드 된 모든 MIB 객체를 볼 수 있습니다. 에이전트는 마치 관리자로부터 오는 GET 요청 인 것처럼 해당 계측 기능을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="98e445605a9fc3e5f98515d8ffa3a57e6ffd8436" translate="yes" xml:space="preserve">
          <source>Performs a GET-NEXT operation on the agent. All loaded MIB objects are visible in this operation. The agent calls the corresponding instrumentation functions just as if it was a GET request coming from a manager.</source>
          <target state="translated">에이전트에서 GET-NEXT 작업을 수행합니다. 이 작업에서는로드 된 모든 MIB 객체를 볼 수 있습니다. 에이전트는 마치 관리자로부터 오는 GET 요청 인 것처럼 해당 계측 기능을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="74811a8e4cadcf197c65d7d83047edc0c17164a0" translate="yes" xml:space="preserve">
          <source>Performs a basic path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280.&lt;/a&gt;&lt;/code&gt; However, CRL validation is done separately by &lt;code&gt;&lt;a href=&quot;#pkix_crls_validate-3&quot;&gt;pkix_crls_validate/3 &lt;/a&gt;&lt;/code&gt; and is to be called from the supplied &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280.&lt;/a&gt;&lt;/code&gt; 에 따라 기본 경로 유효성 검사를 수행합니다. 그러나 CRL 유효성 검사는 &lt;code&gt;&lt;a href=&quot;#pkix_crls_validate-3&quot;&gt;pkix_crls_validate/3 &lt;/a&gt;&lt;/code&gt; 에 의해 별도로 수행되며 제공된 &lt;code&gt;verify_fun&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="fbfe9d2053799030c3effc383609b21073247735" translate="yes" xml:space="preserve">
          <source>Performs a basic path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280.&lt;/a&gt;&lt;/code&gt; However, CRL validation is done separately by &lt;code&gt;&lt;a href=&quot;#pkix_crls_validate-3&quot;&gt;pkix_crls_validate/3&lt;/a&gt;&lt;/code&gt; and is to be called from the supplied &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280.&lt;/a&gt;&lt;/code&gt; 에 따라 기본 경로 유효성 검증을 수행합니다. 그러나 CRL 유효성 검증은 &lt;code&gt;&lt;a href=&quot;#pkix_crls_validate-3&quot;&gt;pkix_crls_validate/3&lt;/a&gt;&lt;/code&gt; 에 의해 별도로 수행되며 제공된 &lt;code&gt;verify_fun&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9816bd4572d4da2d5254081f508d19359bc0475d" translate="yes" xml:space="preserve">
          <source>Performs a sanity check on the system. If no issues were found, &lt;code&gt;ok&lt;/code&gt; is returned. If issues were found, &lt;code&gt;{failed, Failures}&lt;/code&gt; is returned. All failures found will be part of the &lt;code&gt;Failures&lt;/code&gt; list. Currently defined &lt;code&gt;Failure&lt;/code&gt; elements in the &lt;code&gt;Failures&lt;/code&gt; list:</source>
          <target state="translated">시스템에서 상태 점검을 수행합니다. 문제가 발견되지 않으면 &lt;code&gt;ok&lt;/code&gt; 가 반환됩니다. 문제가 발견되면 &lt;code&gt;{failed, Failures}&lt;/code&gt; 가 반환됩니다. 발견 된 모든 실패는 &lt;code&gt;Failures&lt;/code&gt; 목록의 일부입니다 . &lt;code&gt;Failures&lt;/code&gt; 목록 에서 현재 정의 된 &lt;code&gt;Failure&lt;/code&gt; 요소 :</target>
        </trans-unit>
        <trans-unit id="1be49612d446742e1eb3514b871f56b8a3ce8433" translate="yes" xml:space="preserve">
          <source>Performs a sequence of &lt;code&gt;pread/3&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. Returns &lt;code&gt;{ok, [Data, ...]}&lt;/code&gt; or &lt;code&gt;{error, Reason}&lt;/code&gt;, where each &lt;code&gt;Data&lt;/code&gt;, the result of the corresponding &lt;code&gt;pread&lt;/code&gt;, is either a list or a binary depending on the mode of the file, or &lt;code&gt;eof&lt;/code&gt; if the requested position is beyond end of file.</source>
          <target state="translated">한 번에 하나씩 호출하는 것보다 효율적인 &lt;code&gt;pread/3&lt;/code&gt; 시퀀스를 한 번의 작업으로 수행합니다 . &lt;code&gt;{ok, [Data, ...]}&lt;/code&gt; 또는 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환합니다 . 여기서 해당 &lt;code&gt;pread&lt;/code&gt; 의 결과 인 각 &lt;code&gt;Data&lt;/code&gt; 는 파일 모드에 따라 목록 또는 이진이거나 요청 된 경우 &lt;code&gt;eof&lt;/code&gt; 입니다 위치가 파일 끝을 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="22bb771fd651389aaadce513456ba74d3fd0ed89" translate="yes" xml:space="preserve">
          <source>Performs a sequence of &lt;code&gt;pwrite/3&lt;/code&gt; in one operation, which is more efficient than calling them one at a time. Returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, {N, Reason}}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of successful writes done before the failure.</source>
          <target state="translated">한 번에 하나씩 호출하는 것보다 효율적인 &lt;code&gt;pwrite/3&lt;/code&gt; 시퀀스를 한 번의 작업으로 수행합니다 . &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error, {N, Reason}}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 실패 전에 완료된 쓰기 수입니다.</target>
        </trans-unit>
        <trans-unit id="280190b61c0c88706d5eded9a13af6f093ee900b" translate="yes" xml:space="preserve">
          <source>Performs a synchronous call to a port. The meaning of &lt;code&gt;Operation&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; depends on the port, that is, on the port driver. Not all port drivers support this feature.</source>
          <target state="translated">포트에 대한 동기 호출을 수행합니다. &lt;code&gt;Operation&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 의 의미는 포트, 즉 포트 드라이버에 따라 다릅니다. 모든 포트 드라이버가이 기능을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="40fc6748b5fbb2d35ce953467a85ef32b1d82a24" translate="yes" xml:space="preserve">
          <source>Performs a synchronous control operation on a port. The meaning of &lt;code&gt;Operation&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; depends on the port, that is, on the port driver. Not all port drivers support this control feature.</source>
          <target state="translated">포트에서 동기 제어 작업을 수행합니다. &lt;code&gt;Operation&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 의 의미는 포트, 즉 포트 드라이버에 따라 다릅니다. 모든 포트 드라이버가이 제어 기능을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="13d765f074145e069c27186fead40fb3ae13c752" translate="yes" xml:space="preserve">
          <source>Performs a syntactic and semantic check of the script file. Warnings and errors (if any) are written to the standard output, but the script will not be run. The exit status is &lt;code&gt;0&lt;/code&gt; if any errors are found, otherwise &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">스크립트 파일의 구문 및 의미 검사를 수행합니다. 경고 및 오류 (있는 경우)는 표준 출력에 기록되지만 스크립트는 실행되지 않습니다. 오류가 발견되면 종료 상태는 &lt;code&gt;0&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;127&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="51b00069a7d5cb93226f893911ac7caf2f55b4b0" translate="yes" xml:space="preserve">
          <source>Performs a test of encode and decode of types in &lt;code&gt;Module&lt;/code&gt;. The generated functions are called by this function. This function is useful during test to secure that the generated encode and decode functions as well as the general runtime support work as expected.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 에서 형식의 인코딩 및 디코딩 테스트를 수행합니다 . 생성 된 함수는이 함수에 의해 호출됩니다. 이 기능은 테스트 중에 생성 된 인코딩 및 디코딩 기능과 일반 런타임 지원이 예상대로 작동하는지 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d3b4972ee35b6d2ed6932472f96493c8c99e99ae" translate="yes" xml:space="preserve">
          <source>Performs a user-initiated dump of the local log file. This is usually not necessary, as Mnesia by default manages this automatically. See configuration parameters &lt;code&gt;&lt;a href=&quot;#dump_log_time_threshold&quot;&gt;dump_log_time_threshold&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#dump_log_write_threshold&quot;&gt;dump_log_write_threshold&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬 로그 파일의 사용자 시작 덤프를 수행합니다. Mnesia는 기본적으로 이것을 자동으로 관리하므로 일반적으로 필요하지 않습니다. 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#dump_log_time_threshold&quot;&gt;dump_log_time_threshold&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#dump_log_write_threshold&quot;&gt;dump_log_write_threshold&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbce4fd8e8c273fb3d0d070a4bf63febe024097d" translate="yes" xml:space="preserve">
          <source>Performs an asynchronous call. The function &lt;code&gt;async_invoke&lt;/code&gt; is invoked in a thread separate from the emulator thread. This enables the driver to perform time-consuming, blocking operations without blocking the emulator.</source>
          <target state="translated">비동기 호출을 수행합니다. &lt;code&gt;async_invoke&lt;/code&gt; 함수 는 에뮬레이터 스레드와 별도의 스레드에서 호출됩니다. 이를 통해 드라이버는 에뮬레이터를 차단하지 않고 시간이 많이 걸리는 차단 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8e1e45db305e4c65eb358872501f86f5ca41b3" translate="yes" xml:space="preserve">
          <source>Performs an ets/dets matching on the table. See Stdlib documentation, module ets, for a description of &lt;code&gt;Pattern&lt;/code&gt; and the return values.</source>
          <target state="translated">테이블에서 일치하는 ets / dets를 수행합니다. &lt;code&gt;Pattern&lt;/code&gt; 및 리턴 값 에 대한 설명은 Stdlib 문서, 모듈 세트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80ddf1ab4c5a4ace67d0fceb7152a9233f49eec4" translate="yes" xml:space="preserve">
          <source>Performs an identity transformation on Erlang forms, as an example.</source>
          <target state="translated">예를 들어 Erlang 양식에서 ID 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e96ceee5ca669b69ceed3f28a9e634eb2729259c" translate="yes" xml:space="preserve">
          <source>Performs analysis of one or more Cover compiled modules, as specified by &lt;code&gt;Analysis&lt;/code&gt; and &lt;code&gt;Level&lt;/code&gt; (see above), by examining the contents of the internal database.</source>
          <target state="translated">내부 데이터베이스의 내용을 검사하여 &lt;code&gt;Analysis&lt;/code&gt; 및 &lt;code&gt;Level&lt;/code&gt; (위 참조)에 지정된대로 하나 이상의 Cover 컴파일 된 모듈을 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="ef62ac9b7159f229d46fa80ce221a721a030144b" translate="yes" xml:space="preserve">
          <source>Performs bit-wise XOR (exclusive or) on the data supplied.</source>
          <target state="translated">제공된 데이터에 대해 비트 단위 XOR (독점 또는)을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1e4270aba1ba7205d6177c0c6c52d4aee26d94d9" translate="yes" xml:space="preserve">
          <source>Performs command &lt;code&gt;listenv&lt;/code&gt; on the specified Telnet connection and returns the result as a list of key-value pairs.</source>
          <target state="translated">지정된 Telnet 연결에서 명령 &lt;code&gt;listenv&lt;/code&gt; 를 수행 하고 결과를 키-값 쌍의 목록으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1e742f72d48ea0d869f73c425bd3bb42130fb756" translate="yes" xml:space="preserve">
          <source>Performs login of &lt;code&gt;User&lt;/code&gt; with &lt;code&gt;Password&lt;/code&gt; to the account specified by &lt;code&gt;Account&lt;/code&gt;.</source>
          <target state="translated">수행이의 로그인 &lt;code&gt;User&lt;/code&gt; 와 &lt;code&gt;Password&lt;/code&gt; 에 의해 지정된 계정에 &lt;code&gt;Account&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61aff80f20917a90cadf86008c298098cf718490" translate="yes" xml:space="preserve">
          <source>Performs login of &lt;code&gt;User&lt;/code&gt; with &lt;code&gt;Password&lt;/code&gt;.</source>
          <target state="translated">수행이의 로그인 &lt;code&gt;User&lt;/code&gt; 와 &lt;code&gt;Password&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="769228d92551ca190343e485d3132a7289d3b538" translate="yes" xml:space="preserve">
          <source>Performs multiple &lt;code&gt;call&lt;/code&gt; operations in parallel on multiple nodes. That is, evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the nodes &lt;code&gt;Nodes&lt;/code&gt; in parallel. &lt;code&gt;Timeout&lt;/code&gt; is an integer representing the timeout in milliseconds or the atom &lt;code&gt;infinity&lt;/code&gt; which prevents the operation from ever timing out. The result is returned as a list where the result from each node is placed at the same position as the node name is placed in &lt;code&gt;Nodes&lt;/code&gt;. Each item in the resulting list is formatted as either:</source>
          <target state="translated">여러 노드에서 병렬로 여러 &lt;code&gt;call&lt;/code&gt; 작업을 수행합니다 . 즉, 노드 &lt;code&gt;Nodes&lt;/code&gt; 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 병렬로 평가합니다. &lt;code&gt;Timeout&lt;/code&gt; 는 시간 초과를 밀리 초 단위로 나타내는 정수 또는 작업 시간 초과 를 방지하는 원자 &lt;code&gt;infinity&lt;/code&gt; 입니다. 결과는 각 노드의 결과가 &lt;code&gt;Nodes&lt;/code&gt; 에 있는 노드 이름과 동일한 위치에있는 목록으로 반환됩니다 . 결과 목록의 각 항목은 다음 중 하나로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a3c66dde8a5c3d5e1d69b450f3fb1194e697017" translate="yes" xml:space="preserve">
          <source>Performs possible initializations of the cache and returns a reference to it that is used as parameter to the other API functions. Is called by the cache handling processes &lt;code&gt;init&lt;/code&gt; function, hence putting the same requirements on it as a normal process &lt;code&gt;init&lt;/code&gt; function. This function is called twice when starting the SSL application, once with the role client and once with the role server, as the SSL application must be prepared to take on both roles.</source>
          <target state="translated">캐시의 가능한 초기화를 수행하고 다른 API 함수에 매개 변수로 사용되는 참조를 리턴합니다. 캐시 처리 프로세스 &lt;code&gt;init&lt;/code&gt; 함수에 의해 호출 되므로 일반 프로세스 &lt;code&gt;init&lt;/code&gt; 함수 와 동일한 요구 사항이 적용됩니다 . SSL 응용 프로그램이 두 역할을 모두 수행 할 수 있도록 준비되어야하므로이 기능은 SSL 응용 프로그램을 시작할 때 역할 클라이언트에서 한 번, 역할 서버에서 한 번 두 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e21c5aaeabe015b0a346ede9fe7603c40e3285" translate="yes" xml:space="preserve">
          <source>Performs some checks on the package, for example, checks that all mandatory files are present, and extracts its contents.</source>
          <target state="translated">예를 들어, 모든 필수 파일이 있는지 확인하고 내용을 추출하는 등 패키지에 대한 일부 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d7e17286dfe95065d8a22e3569662aef2ec0170e" translate="yes" xml:space="preserve">
          <source>Performs the SSL/TLS/DTLS server-side handshake.</source>
          <target state="translated">SSL / TLS / DTLS 서버 측 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2464610ee2491632e223d2a2d09c63b72ea7ebff" translate="yes" xml:space="preserve">
          <source>Performs the TLS/DTLS server-side handshake.</source>
          <target state="translated">TLS / DTLS 서버 측 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="de30caaee38c0ba213430dd42690a090335a596f" translate="yes" xml:space="preserve">
          <source>Perhaps you want to do something more arranged for human reading. Suppose that you want to list all different brands in the beginning with links to each group of motorcycles. You also want all motorcycles sorted by brand, then some flashy colors on top of it. Thus you rearrange the order of the elements and put in arbitrary HTML tags. This is possible to do by means of the &lt;code&gt;&lt;a href=&quot;http://www.w3.org/Style/XSL/&quot;&gt;XSL Transformation (XSLT)&lt;/a&gt;&lt;/code&gt; like functionality in xmerl.</source>
          <target state="translated">아마도 당신은 인간의 독서를 위해 더 마련된 것을하고 싶을 것입니다. 처음에 각기 다른 오토바이 그룹에 대한 링크와 함께 모든 다른 브랜드를 나열한다고 가정하십시오. 또한 모든 오토바이를 브랜드별로 정렬 한 다음 화려한 색상을 원합니다. 따라서 요소의 순서를 재정렬하고 임의의 HTML 태그를 넣습니다. 이는 xmerl의 기능과 같은 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/Style/XSL/&quot;&gt;XSL Transformation (XSLT)&lt;/a&gt;&lt;/code&gt; 를 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc72f276fa3f20586692a9e869fb89bcfcd032e0" translate="yes" xml:space="preserve">
          <source>Periodically checks the disks. For each disk or partition which uses more than a certain amount of the available space, the alarm &lt;code&gt;{{disk_almost_full, MountedOn}, []}&lt;/code&gt; is set.</source>
          <target state="translated">정기적으로 디스크를 점검하십시오. 사용 가능한 공간을 일정량 이상 사용하는 각 디스크 또는 파티션에 대해 &lt;code&gt;{{disk_almost_full, MountedOn}, []}&lt;/code&gt; 알람 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc7dbf4febfa0c8bb5d477417b519dab3eca2415" translate="yes" xml:space="preserve">
          <source>Periodically flushes all file trace port clients (see &lt;code&gt; dbg:flush_trace_port/1&lt;/code&gt;). When enabled, the buffers are freed each &lt;code&gt;MSec&lt;/code&gt; millisecond. This option is not allowed with &lt;code&gt;{file, {local, File}}&lt;/code&gt; tracing.</source>
          <target state="translated">모든 파일 추적 포트 클라이언트를 주기적으로 플러시합니다 ( &lt;code&gt; dbg:flush_trace_port/1&lt;/code&gt; 참조 ). 활성화되면 버퍼는 &lt;code&gt;MSec&lt;/code&gt; 밀리 초 마다 해제됩니다 . 이 옵션은 &lt;code&gt;{file, {local, File}}&lt;/code&gt; 추적에 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ae86c831bcfb2749ff7edc7ec83510fdd2c53cda" translate="yes" xml:space="preserve">
          <source>Periodically flushes all file trace port clients (see &lt;code&gt;dbg:flush_trace_port/1&lt;/code&gt;). When enabled, the buffers are freed each &lt;code&gt;MSec&lt;/code&gt; millisecond. This option is not allowed with &lt;code&gt;{file, {local, File}}&lt;/code&gt; tracing.</source>
          <target state="translated">모든 파일 추적 포트 클라이언트를 주기적으로 플러시합니다 ( &lt;code&gt;dbg:flush_trace_port/1&lt;/code&gt; 참조 ). 활성화되면 버퍼는 매 &lt;code&gt;MSec&lt;/code&gt; 밀리 초 마다 해제됩니다 . &lt;code&gt;{file, {local, File}}&lt;/code&gt; 추적 에서는 이 옵션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c59c25186e0bd17e60b87557f8d70871e9a6d4de" translate="yes" xml:space="preserve">
          <source>Periodically performs a memory check:</source>
          <target state="translated">주기적으로 메모리 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ec9bd9a3791c02544b4da2b4e584f9e54f09f137" translate="yes" xml:space="preserve">
          <source>Peripheral, trace, and debug functionality is at greater risk of being changed in an incompatible way than functionality in the language itself and core libraries used during operation.</source>
          <target state="translated">주변 장치, 추적 및 디버그 기능은 언어 자체의 기능 및 운영 중에 사용되는 핵심 라이브러리보다 호환되지 않는 방식으로 변경 될 위험이 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="7d00286c1df2e01196a79a4eb5cbf70766e74af5" translate="yes" xml:space="preserve">
          <source>Peripheral, trace, and debug functionality is at greater risk of removal than functionality in the language itself and core libraries used during operation.</source>
          <target state="translated">주변 장치, 추적 및 디버그 기능은 언어 자체의 기능 및 작동 중에 사용되는 핵심 라이브러리보다 제거 위험이 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="4cdcf1198efb4c7cd76975e49ce37ac8c50b1461" translate="yes" xml:space="preserve">
          <source>Perl 5</source>
          <target state="translated">펄 5</target>
        </trans-unit>
        <trans-unit id="f883526d06ac7dbd60d3aeb0d4a51ea2f54f7ccb" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a feature where each alternative in a subpattern uses the same numbers for its capturing parentheses. Such a subpattern starts with &lt;code&gt;(?|&lt;/code&gt; and is itself a non-capturing subpattern. For example, consider the following pattern:</source>
          <target state="translated">Perl 5.10에서는 하위 패턴의 각 대안이 캡처 괄호에 동일한 숫자를 사용하는 기능을 도입했습니다. 이러한 하위 패턴은 &lt;code&gt;(?|&lt;/code&gt; 시작하며 자체가 캡처되지 않는 하위 패턴입니다. 예를 들어 다음 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b82c2b36892e4b847da5ec02ae07fa7e941783f0" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced some &quot;Special Backtracking Control Verbs&quot;, which are still described in the Perl documentation as &quot;experimental and subject to change or removal in a future version of Perl&quot;. It goes on to say: &quot;Their usage in production code should be noted to avoid problems during upgrades.&quot; The same remarks apply to the PCRE features described in this section.</source>
          <target state="translated">Perl 5.10은 &quot;Special Backtracking Control Verbs&quot;를 도입했으며, Perl 문서에는 여전히 &quot;Perl의 향후 버전에서 실험적이며 변경 또는 제거 될 수 있습니다&quot;라고 설명되어 있습니다. &quot;업그레이드 중 문제를 피하기 위해 프로덕션 코드에서의 사용법에 주목해야합니다.&quot; 이 섹션에 설명 된 PCRE 기능에도 동일한 설명이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e78f523b81d69e2ce697283a6d30d972833c9add" translate="yes" xml:space="preserve">
          <source>Perl and POSIX space are now the same. Perl added VT to its space character set at release 5.18 and PCRE changed at release 8.34.</source>
          <target state="translated">펄과 POSIX 공간은 이제 동일합니다. Perl은 릴리스 5.18에서 공백 문자 세트에 VT를 추가하고 릴리스 8.34에서 PCRE가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="2de73d4e781601af4c1bbb6f2148001448b0732c" translate="yes" xml:space="preserve">
          <source>Perl documents that the use of \K within assertions is &quot;not well defined&quot;. In PCRE, \K is acted upon when it occurs inside positive assertions, but is ignored in negative assertions. Note that when a pattern such as (?=ab\K) matches, the reported start of the match can be greater than the end of the match.</source>
          <target state="translated">펄은 어설 션 내에서 \ K의 사용이 &quot;잘 정의되어 있지 않다&quot;고 문서화했다. PCRE에서 \ K는 포지티브 어설 션 내부에서 발생할 때 작동하지만 네거티브 어설 션에서는 무시됩니다. (? = ab \ K)와 같은 패턴이 일치하면보고 된 일치 시작이 일치 끝보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f68ced8ff5ff018b572b360c5b59d5cb10a9ec8" translate="yes" xml:space="preserve">
          <source>Perl has no direct equivalent of &lt;code&gt;notempty&lt;/code&gt; or &lt;code&gt;notempty_atstart&lt;/code&gt;, but it does make a special case of a pattern match of the empty string within its split() function, and when using modifier &lt;code&gt;/g&lt;/code&gt;. The Perl behavior can be emulated after matching a null string by first trying the match again at the same offset with &lt;code&gt;notempty_atstart&lt;/code&gt; and &lt;code&gt;anchored&lt;/code&gt;, and then, if that fails, by advancing the starting offset (see below) and trying an ordinary match again.</source>
          <target state="translated">Perl은 &lt;code&gt;notempty&lt;/code&gt; 또는 &lt;code&gt;notempty_atstart&lt;/code&gt; 와 직접적으로 동일 하지는 않지만 split () 함수 내에서 및 modifier &lt;code&gt;/g&lt;/code&gt; 를 사용할 때 빈 문자열의 패턴 일치에 대한 특별한 경우를 만듭니다 . &lt;code&gt;notempty_atstart&lt;/code&gt; 및 &lt;code&gt;anchored&lt;/code&gt; 와 동일한 오프셋에서 일치를 다시 시도한 다음 시작 오프셋을 높이고 (아래 참조) 일반 일치를 다시 시도하여 null 문자열을 일치시킨 후 Perl 동작을 에뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe8e00e55de2ba8dd6ec7b50c079a9f787696c02" translate="yes" xml:space="preserve">
          <source>Perl supports the Posix notation for character classes. This uses names enclosed by [: and :] within the enclosing square brackets. PCRE also supports this notation. For example, the following matches &quot;0&quot;, &quot;1&quot;, any alphabetic character, or &quot;%&quot;:</source>
          <target state="translated">Perl은 문자 클래스에 대한 Posix 표기법을 지원합니다. 이것은 대괄호 안에 [:와 :]로 묶인 이름을 사용합니다. PCRE는이 표기법도 지원합니다. 예를 들어, 다음은 &quot;0&quot;, &quot;1&quot;, 알파벳 문자 또는 &quot;%&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="765fb2057a7d0f34aecd0daea653b99ec1e8d5fd" translate="yes" xml:space="preserve">
          <source>Perl uses the syntax (?(&amp;lt;name&amp;gt;)...) or (?('name')...) to test for a used subpattern by name. For compatibility with earlier versions of PCRE, which had this facility before Perl, the syntax (?(name)...) is also recognized.</source>
          <target state="translated">Perl은 구문 (? (&amp;lt;name&amp;gt;) ...) 또는 (? ( 'name') ...)을 사용하여 이름으로 사용 된 하위 패턴을 테스트합니다. Perl 이전에이 기능을 가진 이전 버전의 PCRE와의 호환성을 위해 구문 (? (name) ...)도 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae8f7a8fad341ccb38028f9d0cbbf740e954e88" translate="yes" xml:space="preserve">
          <source>Perl-like regular expressions for Erlang.</source>
          <target state="translated">Erlang에 대한 Perl과 같은 정규식.</target>
        </trans-unit>
        <trans-unit id="863d66a8ea986e9d2766a9fb1020b6a98f7a40ae" translate="yes" xml:space="preserve">
          <source>Permanent Failures</source>
          <target state="translated">영구적 인 실패</target>
        </trans-unit>
        <trans-unit id="5e842f59f65d2bb9be9ae185301ffb374b609927" translate="yes" xml:space="preserve">
          <source>Permanently deletes all replicas of table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;Tab&lt;/code&gt; 의 모든 복제본을 영구적으로 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="9d10bab6320387e35667d7efc31ca008974ef6de" translate="yes" xml:space="preserve">
          <source>Permits access to the specified set of nodes.</source>
          <target state="translated">지정된 노드 세트에 대한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cbcc14cf66794a811615925669093ae6f0483b21" translate="yes" xml:space="preserve">
          <source>Persistence. Tables can be coherently kept on disc and in the main memory.</source>
          <target state="translated">고집. 테이블은 디스크와 주 메모리에 일관성있게 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f92e7deab74e37ba55baaec014f2b2842033b9fb" translate="yes" xml:space="preserve">
          <source>Persistent connections are not supported when setting the &lt;code&gt;socket_opts&lt;/code&gt; option. When &lt;code&gt;socket_opts&lt;/code&gt; is not set the current implementation assumes the requests to the same host, port combination will use the same socket options.</source>
          <target state="translated">&lt;code&gt;socket_opts&lt;/code&gt; 옵션을 설정할 때 지속적인 연결이 지원되지 않습니다 . 때 &lt;code&gt;socket_opts&lt;/code&gt; 는 현재 구현은 동일한 호스트에 요청을 가정 설정되지 않은 포트 조합은 동일한 소켓 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6a685aab78a1ff039ade99a9798da21ecfe76ab6" translate="yes" xml:space="preserve">
          <source>Persistent terms is an advanced feature and is not a general replacement for ETS tables. Before using persistent terms, make sure to fully understand the consequence to system performance when updating or deleting persistent terms.</source>
          <target state="translated">영구 용어는 고급 기능이며 ETS 테이블의 일반적인 대체가 아닙니다. 영구 용어를 사용하기 전에 영구 용어를 업데이트하거나 삭제할 때 시스템 성능에 미치는 결과를 완전히 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="49d7a033f1e6bc84489abbcac9eae834fe583a72" translate="yes" xml:space="preserve">
          <source>Persistent terms.</source>
          <target state="translated">지속적인 용어.</target>
        </trans-unit>
        <trans-unit id="2bee04fabd8ac0fac36ed62f88c0b1f7fc8cfa48" translate="yes" xml:space="preserve">
          <source>Peter's client receives the message in the &lt;code&gt;await_result&lt;/code&gt; function.</source>
          <target state="translated">Peter의 클라이언트는 &lt;code&gt;await_result&lt;/code&gt; 함수 에서 메시지를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="a1fbe41a1fd16bc593d390402b8a1d609687aad4" translate="yes" xml:space="preserve">
          <source>Phags_Pa</source>
          <target state="translated">Phags_Pa</target>
        </trans-unit>
        <trans-unit id="6908ab9bda0e225ecfd064a3d987f42cfc69e74c" translate="yes" xml:space="preserve">
          <source>Phoenician</source>
          <target state="translated">Phoenician</target>
        </trans-unit>
        <trans-unit id="816184994301f53e2f7c60336684c53229d3fc02" translate="yes" xml:space="preserve">
          <source>Pick just a few suites</source>
          <target state="translated">스위트 몇 개 선택</target>
        </trans-unit>
        <trans-unit id="f298de9cea75ea5230dda5d9d28b4989aaf746f4" translate="yes" xml:space="preserve">
          <source>Pid</source>
          <target state="translated">Pid</target>
        </trans-unit>
        <trans-unit id="39e4ade84d7c390c8d53a5ae6be8e034ac54f0ea" translate="yes" xml:space="preserve">
          <source>Pid is the pid returned from &lt;code&gt;inets:start/[2,3]&lt;/code&gt;. Can also be retrieved form &lt;code&gt;inets:services/0&lt;/code&gt; and &lt;code&gt;inets:services_info/0&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Pid는 &lt;code&gt;inets:start/[2,3]&lt;/code&gt; 에서 반환 된 pid 입니다. &lt;code&gt;inets:services/0&lt;/code&gt; 및 &lt;code&gt;inets:services_info/0&lt;/code&gt; 에서 검색 할 수도 있습니다 &lt;code&gt;&lt;a href=&quot;inets&quot;&gt;inets(3)&lt;/a&gt;&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="e01f641077fee77726a119c7fdcdd0d01e6ca152" translate="yes" xml:space="preserve">
          <source>PidOrPids :: pid() | [pid()]) -&amp;gt;</source>
          <target state="translated">PidOrPids :: pid() | [pid()]) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5a12aecdd3b6ac3a81192c0d891abe00ae128dc" translate="yes" xml:space="preserve">
          <source>Pipelining is only used if the pipeline time-out is set, otherwise persistent connections without pipelining are used. That is, the client always waits for the previous response before sending the next request.</source>
          <target state="translated">파이프 라인 시간 초과가 설정된 경우에만 파이프 라이닝이 사용되며 그렇지 않으면 파이프 라이닝이없는 영구 연결이 사용됩니다. 즉, 클라이언트는 다음 요청을 보내기 전에 항상 이전 응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="299afcf56421dc47a2f48e2448670fa6fa1de131" translate="yes" xml:space="preserve">
          <source>Plain arguments are not interpreted in any way. They are also stored by the &lt;code&gt;init&lt;/code&gt; process and can be retrieved by calling &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt;. Plain arguments can occur before the first flag, or after a &lt;code&gt;--&lt;/code&gt; flag. Also, the &lt;code&gt;-extra&lt;/code&gt; flag causes everything that follows to become plain arguments.</source>
          <target state="translated">일반적인 주장은 어떤 식으로도 해석되지 않습니다. 또한 &lt;code&gt;init&lt;/code&gt; 프로세스 에 의해 저장되며 &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt; 을 호출하여 검색 할 수 있습니다 . 일반 인수는 첫 번째 플래그 앞이나 &lt;code&gt;--&lt;/code&gt; 플래그 뒤에 발생할 수 있습니다 . 또한 &lt;code&gt;-extra&lt;/code&gt; 플래그는 뒤에 오는 모든 항목이 일반 인수가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="11b1d9af09ba599e8f15b95865824e691f3b401f" translate="yes" xml:space="preserve">
          <source>Plain system messages. These are received as &lt;code&gt;{system, From, Msg}&lt;/code&gt;. The content and meaning of this message are not interpreted by the receiving process module. When a system message is received, function &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; is called to handle the request.</source>
          <target state="translated">일반 시스템 메시지. &lt;code&gt;{system, From, Msg}&lt;/code&gt; 로 수신됩니다 . 이 메시지의 내용과 의미는 수신 프로세스 모듈에서 해석되지 않습니다. 시스템 메시지가 수신되면 요청을 처리하기 위해 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt; handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="021e228d28e31a2dac01ca348b598716a2be960a" translate="yes" xml:space="preserve">
          <source>Plain system messages. These are received as &lt;code&gt;{system, From, Msg}&lt;/code&gt;. The content and meaning of this message are not interpreted by the receiving process module. When a system message is received, function &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; is called to handle the request.</source>
          <target state="translated">일반 시스템 메시지. 이들은 &lt;code&gt;{system, From, Msg}&lt;/code&gt; 로 수신됩니다 . 이 메시지의 내용과 의미는 수신 프로세스 모듈에 의해 해석되지 않습니다. 시스템 메시지가 수신되면 &lt;code&gt;&lt;a href=&quot;#handle_system_msg-6&quot;&gt;handle_system_msg/6&lt;/a&gt;&lt;/code&gt; 함수 가 호출되어 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="32e02713e0dda686ae47235808f8c5c0c7010f65" translate="yes" xml:space="preserve">
          <source>PlainText</source>
          <target state="translated">PlainText</target>
        </trans-unit>
        <trans-unit id="6c4dde4d34ff165124f9124a75a7cc5be39f9952" translate="yes" xml:space="preserve">
          <source>PlainText :: iodata()) -&amp;gt;</source>
          <target state="translated">PlainText :: iodata()) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="38a2100e6697f9c988273348c65437beba4c1a2f" translate="yes" xml:space="preserve">
          <source>Please note that by historical reasons both the &lt;code&gt;HostAddress&lt;/code&gt; argument and the &lt;code&gt;gen_tcp connect_option() {ip,Address}&lt;/code&gt; set the listening address. This is a source of possible inconsistent settings.</source>
          <target state="translated">역사적인 이유로 &lt;code&gt;HostAddress&lt;/code&gt; 인수와 &lt;code&gt;gen_tcp connect_option() {ip,Address}&lt;/code&gt; 모두 수신 주소를 설정합니다. 이것은 일관되지 않은 설정의 원인입니다.</target>
        </trans-unit>
        <trans-unit id="67b04c48713ae02b17574be1c7c9e6c47d938551" translate="yes" xml:space="preserve">
          <source>Please note that by historical reasons both the &lt;code&gt;HostAddress&lt;/code&gt; argument and the &lt;code&gt;gen_tcp connect_option(){ip,Address}&lt;/code&gt; set the listening address. This is a source of possible inconsistent settings.</source>
          <target state="translated">역사적으로 &lt;code&gt;HostAddress&lt;/code&gt; 인수와 &lt;code&gt;gen_tcp connect_option(){ip,Address}&lt;/code&gt; 는 모두 수신 주소를 설정합니다. 이는 일관되지 않은 설정의 원인입니다.</target>
        </trans-unit>
        <trans-unit id="32abe057fa82c9bf0495c06f768e39e26b9f11f2" translate="yes" xml:space="preserve">
          <source>Please note that design is something, that not necessarily will, but might change in future releases. While the semantics of the API will not change as it is independent of the implementation.</source>
          <target state="translated">디자인은 반드시 필요한 것은 아니지만 향후 릴리스에서 변경 될 수 있습니다. API의 의미는 구현과 무관하므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa1d93d97f3230b4f87fac4d80b8e20f34958a43" translate="yes" xml:space="preserve">
          <source>Please note that httpc normalizes input URIs before internal processing and special care shall be taken when the URI has percent (&quot;%&quot;) characters. A percent serves as the indicator for percent-encoded octets and it must be percent-encoded as &quot;%25&quot; for that octet to be used as data within the URI.</source>
          <target state="translated">httpc는 내부 처리 전에 입력 URI를 정규화하므로 URI에 퍼센트 ( &quot;%&quot;) 문자가있는 경우 특별한주의가 필요합니다. 백분율은 백분율로 인코딩 된 옥텟의 표시기 역할을하며 해당 옥텟이 URI 내에서 데이터로 사용 되려면 &quot;% 25&quot;로 백분율 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="597358d6204ed2d5f3fed145f855762b0d748a69" translate="yes" xml:space="preserve">
          <source>Please see the GNU Emacs Manual and the etags man page for more info.</source>
          <target state="translated">자세한 내용은 GNU Emacs 매뉴얼 및 etags 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c436ed1231dc5771eef264b43827bd13f0e6d7b" translate="yes" xml:space="preserve">
          <source>Please submit any patches for cross compiling in a way consistent with this system. All input is welcome as we have a very limited set of cross compiling environments to test with. If a new configuration variable is needed, add it to &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt;, and use it in &lt;code&gt;configure.in&lt;/code&gt;. Other files that might need to be updated are:</source>
          <target state="translated">이 시스템과 일관된 방식으로 크로스 컴파일을위한 패치를 제출하십시오. 테스트 할 크로스 컴파일 환경이 매우 제한되어 있으므로 모든 입력을 환영합니다. 새 구성 변수가 필요한 경우 &lt;code&gt;$ERL_TOP/xcomp/erl-xcomp.conf.template&lt;/code&gt; 에 추가하고 &lt;code&gt;configure.in&lt;/code&gt; 에서 사용하십시오 . 업데이트해야 할 다른 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4140a0c59f9aa45b8631c3e0f8a874473a22c621" translate="yes" xml:space="preserve">
          <source>Please take a look at the reference of &lt;code&gt;sanity_check()&lt;/code&gt; for more information.</source>
          <target state="translated">자세한 내용 은 &lt;code&gt;sanity_check()&lt;/code&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de27f66a37035340860ce9e599a1a2f161cf94be" translate="yes" xml:space="preserve">
          <source>Please, observe that these performance figures are related to our implementation in Erlang/OTP. Measurements of other implementations using other tools and techniques may of course result in other figures.</source>
          <target state="translated">이러한 성능 수치는 Erlang / OTP에서의 구현과 관련이 있습니다. 다른 툴 및 기술을 사용한 다른 구현의 측정은 물론 다른 도면을 초래할 수있다.</target>
        </trans-unit>
        <trans-unit id="d9963c2e5095bb9cc0241cd748d7939bdbfdd2d6" translate="yes" xml:space="preserve">
          <source>Pointer to next structure in a linked list of all port structures. This list is used when accepting connections and when the driver is unloaded.</source>
          <target state="translated">모든 포트 구조의 링크 된 목록에서 다음 구조를 가리키는 포인터. 이 목록은 연결을 수락 할 때와 드라이버를 언로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f19f028244073bea25c8d31a9519278211c9e77e" translate="yes" xml:space="preserve">
          <source>Pointer to the array of reference numbers in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; 의 참조 번호 배열을 가리키는 포인터 .</target>
        </trans-unit>
        <trans-unit id="90279912bde8fc7a98584b2f5586d2486ad5964a" translate="yes" xml:space="preserve">
          <source>Pointer to the dynamically allocated buffer.</source>
          <target state="translated">동적으로 할당 된 버퍼를 가리키는 포인터.</target>
        </trans-unit>
        <trans-unit id="1604bd8010fd538d08c7b5045fd397612cd1e659" translate="yes" xml:space="preserve">
          <source>Points out a file containing a decryption key for &lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt; 의 암호 해독 키가 포함 된 파일을 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="7afa60ee7ef4769f7cc3c7f050d9db637653fed0" translate="yes" xml:space="preserve">
          <source>Points out a user HTML style sheet (described later).</source>
          <target state="translated">사용자 HTML 스타일 시트를 가리 킵니다 (나중에 설명 함).</target>
        </trans-unit>
        <trans-unit id="c3267371bb927c874f21bde6afeb9450a04b23f0" translate="yes" xml:space="preserve">
          <source>Policy certificate extensions are not supported.</source>
          <target state="translated">정책 인증서 확장은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a35981ceab91897e91ab04e8e2d42162dbd7728" translate="yes" xml:space="preserve">
          <source>Policy for the selection of the temporary port that is used by the server/client during the file transfer. Default is &lt;code&gt;random&lt;/code&gt;, which is the standardized policy. With this policy a randomized free port is used. A single port or a range of ports can be useful if the protocol passes through a firewall.</source>
          <target state="translated">파일 전송 중 서버 / 클라이언트가 사용하는 임시 포트 선택 정책. 기본값은 &lt;code&gt;random&lt;/code&gt; 이며 이는 표준화 된 정책입니다. 이 정책에서는 무작위로 사용 가능한 포트가 사용됩니다. 프로토콜이 방화벽을 통과하는 경우 단일 포트 또는 포트 범위가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="465d89dc629419a077edf90091affa9697b2e338" translate="yes" xml:space="preserve">
          <source>Polling interval (sleep time between polls) = 1 second</source>
          <target state="translated">폴링 간격 (폴링 사이의 휴면 시간) = 1 초</target>
        </trans-unit>
        <trans-unit id="f8b9e6faf5ca12ec30a6ab11e637a8f904a10ff8" translate="yes" xml:space="preserve">
          <source>Polling limit (max number of times to poll to get a remaining string terminated) = 0</source>
          <target state="translated">폴링 제한 (남은 문자열을 종료하기 위해 폴링 할 최대 횟수) = 0</target>
        </trans-unit>
        <trans-unit id="dc3e5751626ffc8947f9f0b3a17d71ba3b06ae9b" translate="yes" xml:space="preserve">
          <source>Pooled carriers are always &lt;strong&gt;employed&lt;/strong&gt; by their &lt;strong&gt;owner&lt;/strong&gt;.</source>
          <target state="translated">풀링 된 캐리어는 항상 &lt;strong&gt;소유자가 &lt;/strong&gt;&lt;strong&gt;고용&lt;/strong&gt; 합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f674f7342afffc2f1fe6b84a078cfaa6e0d124f7" translate="yes" xml:space="preserve">
          <source>Pooled carriers are not allocated from.</source>
          <target state="translated">풀링 된 캐리어는 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85ac5ed2edbd75fdc5be499e6afb737ffdefac14" translate="yes" xml:space="preserve">
          <source>Pop the top module from the internal stack of callback modules and set it to be the new &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; for the running server. If the stack is empty the server fails. Otherwise like &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; above.</source>
          <target state="translated">콜백 모듈의 내부 스택에서 최상위 모듈을 &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 실행중인 서버 의 새 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 로 설정 합니다. 스택이 비어 있으면 서버가 실패합니다. 그렇지 않으면 위의 &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; 과 같습니다 . &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="991780bf544d0a8fc475baa289ae5667bb4579b0" translate="yes" xml:space="preserve">
          <source>Pops the top module from the internal stack of callback modules and changes the callback module to be the popped module. If the stack is empty the server fails. Otherwise like &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; above.</source>
          <target state="translated">콜백 모듈의 내부 스택에서 최상위 모듈을 꺼내고 콜백 모듈을 팝된 모듈로 변경합니다. 스택이 비어 있으면 서버가 실패합니다. 그렇지 않으면 위의 &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="799fa570fa6f42daa22b2994cc3725a643fc7be8" translate="yes" xml:space="preserve">
          <source>Port :: &lt;code&gt;inet:port_number()&lt;/code&gt;) -&amp;gt;</source>
          <target state="translated">포트 :: &lt;code&gt;inet:port_number()&lt;/code&gt; )-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ea62c46246b1ea7a1efd0181063c1442570f3e77" translate="yes" xml:space="preserve">
          <source>Port :: &lt;code&gt;inet:port_number()&lt;/code&gt;,</source>
          <target state="translated">포트 :: &lt;code&gt;inet:port_number()&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3db9bac190e277a6139a6817df535ad965dd6629" translate="yes" xml:space="preserve">
          <source>Port = &lt;code&gt;integer() &amp;gt; 0&lt;/code&gt;</source>
          <target state="translated">포트 = &lt;code&gt;integer() &amp;gt; 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c4923d568bc203f2611ee342cb7f5146785d157" translate="yes" xml:space="preserve">
          <source>Port Example</source>
          <target state="translated">포트 예</target>
        </trans-unit>
        <trans-unit id="9658d0e5f890f70c212b44e605a327442f5f0483" translate="yes" xml:space="preserve">
          <source>Port Programs</source>
          <target state="translated">항구 프로그램</target>
        </trans-unit>
        <trans-unit id="59426fd42c4bd1ecdac5914a8115399d46411358" translate="yes" xml:space="preserve">
          <source>Port handle of the executing port.</source>
          <target state="translated">실행 포트의 포트 핸들</target>
        </trans-unit>
        <trans-unit id="bda81d4c1d517232b2d8149167cc3dc467ef84ea" translate="yes" xml:space="preserve">
          <source>Port queries, that is, on which port the node with a specified name listens</source>
          <target state="translated">포트 쿼리, 즉 지정된 이름의 노드가 수신하는 포트</target>
        </trans-unit>
        <trans-unit id="909ce0bd80b59fe5319fb9028cc0d212219399d1" translate="yes" xml:space="preserve">
          <source>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 4.9.1.1). The function returns a hash value for &lt;code&gt;Term&lt;/code&gt; within the range &lt;code&gt;1..Range&lt;/code&gt;. The maximum value for &lt;code&gt;Range&lt;/code&gt; is 2^32.</source>
          <target state="translated">기계 구조 및 ERTS 버전에 관계없이 동일한 Erlang 용어에 대해 동일한 해시를 제공하는 휴대용 해시 함수 (BIF는 ERTS 4.9.1.1에서 도입 됨). 이 함수는 &lt;code&gt;1..Range&lt;/code&gt; 범위 내의 &lt;code&gt;Term&lt;/code&gt; 해시 값을 반환합니다 . &lt;code&gt;Range&lt;/code&gt; 의 최대 값 은 2 ^ 32입니다.</target>
        </trans-unit>
        <trans-unit id="054b8319dfcb3d23d08071f8f07f5156fb5d7c54" translate="yes" xml:space="preserve">
          <source>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version (the BIF was introduced in ERTS 5.2). The function returns a hash value for &lt;code&gt;Term&lt;/code&gt; within the range &lt;code&gt;0..Range-1&lt;/code&gt;. The maximum value for &lt;code&gt;Range&lt;/code&gt; is 2^32. When without argument &lt;code&gt;Range&lt;/code&gt;, a value in the range 0..2^27-1 is returned.</source>
          <target state="translated">기계 구조 및 ERTS 버전에 관계없이 동일한 Erlang 용어에 대해 동일한 해시를 제공하는 휴대용 해시 함수 (BIF는 ERTS 5.2에서 도입 됨). 이 함수는 &lt;code&gt;0..Range-1&lt;/code&gt; 범위 내의 &lt;code&gt;Term&lt;/code&gt; 해시 값을 반환합니다 . &lt;code&gt;Range&lt;/code&gt; 의 최대 값 은 2 ^ 32입니다. 인수 &lt;code&gt;Range&lt;/code&gt; 가 없으면 0..2 ^ 27-1 범위의 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1154c86e0447265172bd06d0ffc96a0fbd31265c" translate="yes" xml:space="preserve">
          <source>Portable hash function that gives the same hash for the same Erlang term regardless of machine architecture and ERTS version.</source>
          <target state="translated">기계 구조 및 ERTS 버전에 관계없이 동일한 Erlang 용어에 대해 동일한 해시를 제공하는 휴대용 해시 기능</target>
        </trans-unit>
        <trans-unit id="16c2eb4dbbcdafb15c712951d6aee1bf0a101658" translate="yes" xml:space="preserve">
          <source>Ports</source>
          <target state="translated">Ports</target>
        </trans-unit>
        <trans-unit id="6631722b28d8fb75219e7fe0927592627111d1a6" translate="yes" xml:space="preserve">
          <source>Ports and Linked-In Drivers</source>
          <target state="translated">포트 및 연결된 드라이버</target>
        </trans-unit>
        <trans-unit id="c97a4b3879c8d95d45f28ff453955a6b9bfa5cfb" translate="yes" xml:space="preserve">
          <source>Ports are always byte-oriented, so before sending data that you are not sure is bytewise-encoded to a port, ensure to encode it in a proper Unicode encoding. Sometimes this means that only part of the data must be encoded as, for example, UTF-8. Some parts can be binary data (like a length indicator) or something else that must not undergo character encoding, so no automatic translation is present.</source>
          <target state="translated">포트는 항상 바이트 지향이므로 확실하지 않은 데이터를 포트로 바이트 단위로 인코딩하기 전에 적절한 유니 코드 인코딩으로 인코딩해야합니다. 때때로 이것은 데이터의 일부만 예를 들어 UTF-8로 인코딩되어야 함을 의미합니다. 일부 부분은 길이 표시기와 같은 이진 데이터이거나 문자 인코딩을 수행해서는 안되는 다른 부분 일 수 있으므로 자동 변환이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4193cfa2c1ff713d813bfaa0d36b429c920defb" translate="yes" xml:space="preserve">
          <source>Ports are configured by the user: diameter places no restrictions.</source>
          <target state="translated">포트는 사용자가 구성합니다. 직경은 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb46560c81a3989fb4e829762625b62e66c95636" translate="yes" xml:space="preserve">
          <source>Ports provide the basic mechanism for communication with the external world, from Erlang's point of view. The ports provide a byte-oriented interface to an external program. When a port is created, Erlang can communicate with it by sending and receiving lists of bytes (not Erlang terms). This means that the programmer might have to invent a suitable encoding and decoding scheme.</source>
          <target state="translated">포트는 Erlang의 관점에서 외부 세계와의 통신을위한 기본 메커니즘을 제공합니다. 포트는 외부 프로그램에 바이트 지향 인터페이스를 제공합니다. 포트가 작성되면 Erlang은 바이트 목록 (Erlang 용어가 아님)을 송수신하여 통신 할 수 있습니다. 이것은 프로그래머가 적절한 인코딩 및 디코딩 체계를 발명해야 할 수도 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e5dca5bbd887da11b920c85a6859b7dc5d6446ce" translate="yes" xml:space="preserve">
          <source>Posix character class (only if followed by Posix syntax)</source>
          <target state="translated">Posix 문자 클래스 (Posix 구문이 뒤에 오는 경우에만)</target>
        </trans-unit>
        <trans-unit id="cf44c2ab63d2bfdbd90509d6ab05ee59689772ed" translate="yes" xml:space="preserve">
          <source>Possessive quantifiers are always greedy; the setting of option &lt;code&gt;ungreedy&lt;/code&gt; is ignored. They are a convenient notation for the simpler forms of an atomic group. However, there is no difference in the meaning of a possessive quantifier and the equivalent atomic group, but there can be a performance difference; possessive quantifiers are probably slightly faster.</source>
          <target state="translated">소유 수량자는 항상 탐욕스러워합니다. 옵션 &lt;code&gt;ungreedy&lt;/code&gt; 설정 은 무시됩니다. 원자 그룹의 단순한 형태에 대한 편리한 표기법입니다. 그러나 소유 수량 화기와 동등한 원자 그룹의 의미에는 차이가 없지만 성능 차이가있을 수 있습니다. 소유 수량자는 아마도 약간 빠를 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b6f1087ff5e67d140eb09f11b3dad81741a1747" translate="yes" xml:space="preserve">
          <source>Possessive quantifiers can be used with lookbehind assertions to specify efficient matching of fixed-length strings at the end of subject strings. Consider the following simple pattern when applied to a long string that does not match:</source>
          <target state="translated">Posessive 한정자는 lookbehind 어설 션과 함께 사용되어 주제 문자열의 끝에 고정 길이 문자열의 효율적인 일치를 지정합니다. 일치하지 않는 긴 문자열에 적용될 때는 다음과 같은 간단한 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1dfe8268667e0c66e3daa6ac9b57143d77624130" translate="yes" xml:space="preserve">
          <source>Possible Erlang 'EXIT' messages is to be handled by this function and all channels are to handle the following message.</source>
          <target state="translated">가능한 Erlang 'EXIT'메시지는이 기능으로 처리되며 모든 채널은 다음 메시지를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="149bf3ac15f9f4fc58f0fe306b8c56c8c16051d0" translate="yes" xml:space="preserve">
          <source>Possible SCTP events:</source>
          <target state="translated">가능한 SCTP 이벤트 :</target>
        </trans-unit>
        <trans-unit id="b91d93860e0e7dc1f57e9b3c4cd2dfcbc0c4795b" translate="yes" xml:space="preserve">
          <source>Possible actions: ignore as in drop the event (maybe log it) or deal with the event in some other state as in postpone it.</source>
          <target state="translated">가능한 조치 : 이벤트를 제거 할 때 무시하거나 (로그 기록 가능) 연기 된 것처럼 다른 상태에서 이벤트를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="986d4a1466fd9cd5e38ecaec22d116bf1c515c81" translate="yes" xml:space="preserve">
          <source>Possible configuration variables include:</source>
          <target state="translated">가능한 구성 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34001dfcb817c4c0ae5c87f2102d6fe4615ff7e1" translate="yes" xml:space="preserve">
          <source>Possible options and values vary depending on the I/O device. For a list of supported options and their current values on a specific I/O device, use function &lt;code&gt;&lt;a href=&quot;#getopts-1&quot;&gt;getopts/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가능한 옵션과 값은 I / O 장치에 따라 다릅니다. 특정 I / O 장치에서 지원되는 옵션 및 현재 값 목록을 보려면 &lt;code&gt;&lt;a href=&quot;#getopts-1&quot;&gt;getopts/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="878f3530033a9b08ada15887a53634015460882c" translate="yes" xml:space="preserve">
          <source>Possible options are :</source>
          <target state="translated">가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60e11e810786d4e1c3e27a2df214cc536e9941c7" translate="yes" xml:space="preserve">
          <source>Possible options are:</source>
          <target state="translated">가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2005d62e46c5a3d6f217477137da0006cd82c5a1" translate="yes" xml:space="preserve">
          <source>Possible reasons for a bad certificate:</source>
          <target state="translated">잘못된 인증서의 가능한 이유 :</target>
        </trans-unit>
        <trans-unit id="1473fc3a07d611c813c39a776d207edb467c5e8f" translate="yes" xml:space="preserve">
          <source>Possibly the most important feature of an editor designed for programmers is the ability to indent a line of code in accordance with the structure of the programming language. The Erlang mode does, of course, provide this feature. The layout used is based on the common use of the language. The mode also provides things as syntax highlighting, electric commands, module name verification, comment support including paragraph filling, skeletons, tags support etc.</source>
          <target state="translated">프로그래머를 위해 설계된 편집기의 가장 중요한 기능은 프로그래밍 언어의 구조에 따라 코드 줄을 들여 쓰는 기능 일 것입니다. Erlang 모드는 물론이 기능을 제공합니다. 사용 된 레이아웃은 일반적인 언어 사용을 기반으로합니다. 이 모드는 구문 강조, 전기 명령, 모듈 이름 확인, 단락 채우기를 포함한 주석 지원, 골격, 태그 지원 등을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d22147626ea096d748e45c8057c724e89829172f" translate="yes" xml:space="preserve">
          <source>Postponing is ordered by the &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt;.</source>
          <target state="translated">연기는 &lt;code&gt;&lt;a href=&quot;#Transition%20Actions&quot;&gt; &lt;strong&gt;transition action&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 의해 지정됩니다 . &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c84b501894f8e4082c349aaca37c8c128c099d19" translate="yes" xml:space="preserve">
          <source>Postponing is ordered by the state transition &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;postpone&lt;/code&gt;.</source>
          <target state="translated">연기는 상태 전이 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;postpone&lt;/code&gt; 의해 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e2fa43d974da83b84f8b7a0198aa7c4a5f02ff1" translate="yes" xml:space="preserve">
          <source>PowerPC: All 32-bit 6xx/7xx(G3)/74xx(G4) processors should work. 32-bit mode on 970 (G5) and POWER5 processors should work.</source>
          <target state="translated">PowerPC : 모든 32 비트 6xx / 7xx (G3) / 74xx (G4) 프로세서가 작동해야합니다. 970 (G5) 및 POWER5 프로세서의 32 비트 모드가 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="cfd617494e5919519b64ca7cf73d988ce7314f09" translate="yes" xml:space="preserve">
          <source>PowerPC: Linux, Mac OSX</source>
          <target state="translated">PowerPC : Linux, Mac OSX</target>
        </trans-unit>
        <trans-unit id="bb533d9ed60c4c4366192eaf66aa35d663c4e5ef" translate="yes" xml:space="preserve">
          <source>Pre and Post commands for &lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3 and /4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#engine_load-3&quot;&gt;engine_load/3 and /4&lt;/a&gt;&lt;/code&gt; 대한 사전 및 사후 명령 .</target>
        </trans-unit>
        <trans-unit id="0e662ed0ab305723c6508be67f9b43c339486ad4" translate="yes" xml:space="preserve">
          <source>Pre-Defined Module Attributes</source>
          <target state="translated">사전 정의 된 모듈 속성</target>
        </trans-unit>
        <trans-unit id="0a9ed395dc4a0c7112396cf0cd653ab947e17244" translate="yes" xml:space="preserve">
          <source>Pre-Processing</source>
          <target state="translated">Pre-Processing</target>
        </trans-unit>
        <trans-unit id="8756ea35ca147cf4eb388864ebf89dce85216cce" translate="yes" xml:space="preserve">
          <source>Pre-built Source Release</source>
          <target state="translated">사전 빌드 소스 릴리스</target>
        </trans-unit>
        <trans-unit id="87851276bfe81c98a7198277088c96a9d033b5dc" translate="yes" xml:space="preserve">
          <source>Pre-defined macro functions</source>
          <target state="translated">사전 정의 된 매크로 함수</target>
        </trans-unit>
        <trans-unit id="e2d753c3372e1527a96177f0cb9217ccadf215de" translate="yes" xml:space="preserve">
          <source>Pre-defined macros and variables</source>
          <target state="translated">사전 정의 된 매크로 및 변수</target>
        </trans-unit>
        <trans-unit id="e9533f120fc37f02251d4dcf3459051b82c4e403" translate="yes" xml:space="preserve">
          <source>Pre-defined module attributes is to be placed before any function declaration.</source>
          <target state="translated">사전 정의 된 모듈 속성은 함수 선언 전에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="926f83f2a7c83bde06ce094d99185e3842a8a8f9" translate="yes" xml:space="preserve">
          <source>Pre-formatted &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_html_21.0.tar.gz&quot;&gt;html documentation&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_man_21.0.tar.gz&quot;&gt;man pages&lt;/a&gt;&lt;/code&gt; can be downloaded from</source>
          <target state="translated">사전 형식화 된 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_html_21.0.tar.gz&quot;&gt;html documentation&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_man_21.0.tar.gz&quot;&gt;man pages&lt;/a&gt;&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="bcf0b40568c417d952629596d718f9e8e4b093be" translate="yes" xml:space="preserve">
          <source>Pre-formatted &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_html_23.2.tar.gz&quot;&gt;html documentation&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_man_23.2.tar.gz&quot;&gt;man pages&lt;/a&gt;&lt;/code&gt; can be downloaded from</source>
          <target state="translated">사전 형식화 된 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_html_23.2.tar.gz&quot;&gt;html documentation&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/download/otp_doc_man_23.2.tar.gz&quot;&gt;man pages&lt;/a&gt;&lt;/code&gt; 는 다음 사이트에서 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff56d95f5ae87da89cf746ab41ce4e6a479c1f0d" translate="yes" xml:space="preserve">
          <source>Predictive Loop Avoidance</source>
          <target state="translated">예측 루프 회피</target>
        </trans-unit>
        <trans-unit id="5377ce70ede93e38d6f770b9c04d7953c8a34e30" translate="yes" xml:space="preserve">
          <source>Prefer creating a few large persistent terms to creating many small persistent terms. The execution time for storing a persistent term is proportional to the number of already existing terms.</source>
          <target state="translated">여러 개의 작은 지속적 용어를 작성하는 것보다 몇 개의 큰 지속적 용어를 작성하는 것이 좋습니다. 영구 기간을 저장하기위한 실행 시간은 이미 존재하는 기간의 수에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="1fa566d2725a0b203f5437a8f646bcbb04681b10" translate="yes" xml:space="preserve">
          <source>Preferably, you would check the machine type, the operating system, and the Kernel version before executing anything similar to this code.</source>
          <target state="translated">이 코드와 비슷한 것을 실행하기 전에 머신 유형, 운영 체제 및 커널 버전을 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="84c0062ba00a989bbfa87f065cc839159da1421f" translate="yes" xml:space="preserve">
          <source>Preliminary version 3, based on TD-33</source>
          <target state="translated">TD-33 기반 예비 버전 3</target>
        </trans-unit>
        <trans-unit id="da668ceef4aad0b079d2fa1313967654991563d7" translate="yes" xml:space="preserve">
          <source>Preliminary version 3, based on TD-33, but text encoding updated with the final solution for priority in &lt;code&gt;contextProperty&lt;/code&gt; (which is backward compatible with v2).</source>
          <target state="translated">TD-33을 기반으로하는 예비 버전 3이지만 텍스트 인코딩은 &lt;code&gt;contextProperty&lt;/code&gt; 의 우선 순위에 대한 최종 솔루션으로 업데이트되었습니다 (v2와 역 호환 가능).</target>
        </trans-unit>
        <trans-unit id="8ce9d534fd06e5e0f995497a19bceaa290fe794b" translate="yes" xml:space="preserve">
          <source>Preliminary version 3, based on the final version of the v3-standard, but &lt;strong&gt;excluding&lt;/strong&gt; segments!</source>
          <target state="translated">v3 표준의 최종 버전을 기반으로하는 예비 버전 3 ( 세그먼트 &lt;strong&gt;제외)&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="635a0b9ab635f6550fdf7e8b53c541a528049aa3" translate="yes" xml:space="preserve">
          <source>Preloaded modules are always reported as &lt;code&gt;loaded&lt;/code&gt;, without inspecting the contents on disk. Cover compiled modules will always be reported as &lt;code&gt;modified&lt;/code&gt; if an object file exists, or as &lt;code&gt;removed&lt;/code&gt; otherwise. Modules whose load path is an empty string (which is the convention for auto-generated code) will only be reported as &lt;code&gt;loaded&lt;/code&gt; or &lt;code&gt;not_loaded&lt;/code&gt;.</source>
          <target state="translated">사전 &lt;code&gt;loaded&lt;/code&gt; 모듈은 디스크의 내용을 검사하지 않고 항상 loaded 로보고됩니다 . Cover 컴파일 된 모듈은 항상 오브젝트 파일이 존재하는 경우 &lt;code&gt;modified&lt;/code&gt; 것으로보고 되거나 그렇지 않으면 &lt;code&gt;removed&lt;/code&gt; 된 것으로보고됩니다 . 로드 경로가 빈 문자열 (자동 생성 코드의 규칙) 인 모듈은 &lt;code&gt;loaded&lt;/code&gt; 또는 &lt;code&gt;not_loaded&lt;/code&gt; 로만보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8bc382020aaaa716a496826f97b0c9d436c31a9" translate="yes" xml:space="preserve">
          <source>Preparation</source>
          <target state="translated">Preparation</target>
        </trans-unit>
        <trans-unit id="f39a18f1762094e5cc4c63111fe2c5cee36d0231" translate="yes" xml:space="preserve">
          <source>Prepare for next call to &lt;code&gt;trace_pattern&lt;/code&gt; by updating the new staging area (the old active) for all enabled breakpoints.</source>
          <target state="translated">활성화 된 모든 중단 점에 대해 새 스테이징 영역 (이전 활성)을 업데이트하여 &lt;code&gt;trace_pattern&lt;/code&gt; 에 대한 다음 호출을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="7400972dd44b6d7ca793bcda89fa90523fd49cc6" translate="yes" xml:space="preserve">
          <source>Prepare for next call to &lt;code&gt;trace_pattern&lt;/code&gt; by updating the new staging part (the old active) of the breakpoint to be identic to the the new active part.</source>
          <target state="translated">중단 점의 새 스테이징 파트 (이전 활성)를 새 활성 파트와 동일하게 업데이트하여 &lt;code&gt;trace_pattern&lt;/code&gt; 에 대한 다음 호출을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="0ccb4a6b47e69ccdef1feeb0cb6c0bbd699daa33" translate="yes" xml:space="preserve">
          <source>Prepares to load the modules in the list &lt;code&gt;Modules&lt;/code&gt;. Finish the loading by calling &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading(Prepared)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모듈 목록에 &lt;code&gt;Modules&lt;/code&gt; 을로드 할 준비를합니다 . &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading(Prepared)&lt;/a&gt;&lt;/code&gt; 을 호출하여로드를 완료하십시오 .</target>
        </trans-unit>
        <trans-unit id="9af0e9a7676ad5c34d0982329c5f5caab38b02df" translate="yes" xml:space="preserve">
          <source>Prepares to open a file on the client side.</source>
          <target state="translated">클라이언트 측에서 파일을 열 준비를합니다.</target>
        </trans-unit>
        <trans-unit id="1af579a4819f628301944085e091406a4beaf50a" translate="yes" xml:space="preserve">
          <source>Prepend the specified directory to the code path. Use to point at beam files compiled from inherited dictionaries, &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; in a dictionary file creating a beam dependency, not an erl/hrl dependency.</source>
          <target state="translated">지정된 디렉토리를 코드 경로 앞에 추가하십시오. 빔 상속 사전에서 컴파일 된 파일에서 포인트 사용 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#inherits&quot;&gt;@inherits&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 빔 의존성을 만드는 사전 파일이 아닌 ERL / HRL 의존성.</target>
        </trans-unit>
        <trans-unit id="a20fa72c3402e6bde9460d87001f7ae629c23c73" translate="yes" xml:space="preserve">
          <source>Preprocesses and parses an Erlang source file. Notice that tuple &lt;code&gt;{eof, Line}&lt;/code&gt; returned at the end of the file is included as a &quot;form&quot;.</source>
          <target state="translated">Erlang 소스 파일을 사전 처리하고 구문 분석합니다. 파일 끝에서 반환 된 튜플 &lt;code&gt;{eof, Line}&lt;/code&gt; 은 &quot;양식&quot;으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="690b8706d3e1f79bde61f6dc644048c260a4aafe" translate="yes" xml:space="preserve">
          <source>Preprocessor</source>
          <target state="translated">Preprocessor</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="2691f43bd7041517e5cd137cba084147892ae0d0" translate="yes" xml:space="preserve">
          <source>Presented IDs</source>
          <target state="translated">제시된 ID</target>
        </trans-unit>
        <trans-unit id="0c6c64c4381af2076f81188f61e3735af23c9c67" translate="yes" xml:space="preserve">
          <source>Presented Identifier</source>
          <target state="translated">제시된 식별자</target>
        </trans-unit>
        <trans-unit id="1d8162ec721e521c8cbbcf0236344390db358601" translate="yes" xml:space="preserve">
          <source>Presents the error returned by an SSL function as a printable string.</source>
          <target state="translated">SSL 함수가 리턴 할 수있는 오류를 인쇄 가능한 문자열로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="834be78dfc277babb3a97beb35d93868f34537ec" translate="yes" xml:space="preserve">
          <source>Presents the result of</source>
          <target state="translated">결과 제시</target>
        </trans-unit>
        <trans-unit id="04f8808cdf1dcc1ebc30cfb13086e1464c6e225f" translate="yes" xml:space="preserve">
          <source>Press Control-C to shut down the Erlang system and the Erlang shell.</source>
          <target state="translated">Control-C를 눌러 Erlang 시스템과 Erlang 쉘을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="2711f010ee53e2db82bf69468b5b4f03b6d1cfe4" translate="yes" xml:space="preserve">
          <source>Pretty print the Logger configuration.</source>
          <target state="translated">Logger 구성을 예쁘게 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="f85da72e94aea2381a2f0b0888b6cb0b938cff09" translate="yes" xml:space="preserve">
          <source>Pretty printing of abstract Erlang syntax trees.</source>
          <target state="translated">추상 Erlang 구문 트리의 예쁜 인쇄.</target>
        </trans-unit>
        <trans-unit id="be15d452e14cc6357729870688727ace6920738d" translate="yes" xml:space="preserve">
          <source>Pretty prints a &lt;code&gt;Form&lt;/code&gt;, which is an abstract form of a type that is returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_form-1&quot;&gt; erl_parse:parse_form/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Pretty는 &lt;code&gt;&lt;a href=&quot;erl_parse#parse_form-1&quot;&gt; erl_parse:parse_form/1&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 유형의 추상적 인 형태 인 &lt;code&gt;Form&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="dc508f11298d514f277642f83dadf29968dd9d46" translate="yes" xml:space="preserve">
          <source>Pretty prints a &lt;code&gt;Form&lt;/code&gt;, which is an abstract form of a type that is returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_form-1&quot;&gt;erl_parse:parse_form/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Pretty는 &lt;code&gt;&lt;a href=&quot;erl_parse#parse_form-1&quot;&gt;erl_parse:parse_form/1&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 형식의 추상 형식 인 &lt;code&gt;Form&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d63df205ad942f1c830ebd4e4bc701ca8b9e816f" translate="yes" xml:space="preserve">
          <source>Pretty-print a syntax tree or template to the standard output. This is a utility function for development and debugging.</source>
          <target state="translated">구문 트리 또는 템플릿을 표준 출력으로 출력하십시오. 개발 및 디버깅을위한 유틸리티 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ac772a8e8177c0183620391b61e4e90f72e8fe2f" translate="yes" xml:space="preserve">
          <source>Prettyprint-formats an abstract Erlang syntax tree as text. For example, if you have a &lt;code&gt;.beam&lt;/code&gt; file that has been compiled with &lt;code&gt;debug_info&lt;/code&gt;, the following should print the source code for the module (as it looks in the debug info representation):</source>
          <target state="translated">Pretty Erlang 구문 트리를 텍스트로 Prettyprint 형식으로 지정합니다. 당신이있는 경우 예를 들어, &lt;code&gt;.beam&lt;/code&gt; 의 컴파일 된 파일 &lt;code&gt;debug_info&lt;/code&gt; 을 (가 디버그 정보 표현에 보이는대로), 다음은 모듈의 소스 코드를 인쇄해야합니다 :</target>
        </trans-unit>
        <trans-unit id="bf3e85268675b1375b86ffb5b4b5e86258ba6284" translate="yes" xml:space="preserve">
          <source>Prevents loading information about source filenames and line numbers. This saves some memory, but exceptions do not contain information about the filenames and line numbers.</source>
          <target state="translated">소스 파일 이름 및 줄 번호에 대한 정보를로드하지 못하게합니다. 이렇게하면 일부 메모리가 절약되지만 파일 이름 및 줄 번호에 대한 정보는 예외에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d09eeaa3bc8ced4fe796ecbcf1dd05c62de1e4cd" translate="yes" xml:space="preserve">
          <source>Prevents the Server Name Indication extension from being sent and disables the hostname verification check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;</source>
          <target state="translated">서버 이름 표시 확장이 전송되지 않도록하고 호스트 이름 확인 검사 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="13c464652aa4866a035cb6021e96dd21a453187f" translate="yes" xml:space="preserve">
          <source>Previous implementation used to allow all characters as long as they were integer values greater than or equal to zero. This sometimes lead to unwanted results since null characters (integer value zero) often are interpreted as string termination. The current implementation rejects these.</source>
          <target state="translated">이전 구현에서는 모든 문자가 0 이상의 정수 값인 한 모든 문자를 허용했습니다. 널 문자 (정수 값 0)가 종종 문자열 종료로 해석되기 때문에 원하지 않는 결과가 발생할 수 있습니다. 현재 구현에서는이를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="7569c52a61d993390fecf54a831ac17622da8694" translate="yes" xml:space="preserve">
          <source>Previously &lt;code&gt;erlang:now/0&lt;/code&gt; was the only option for doing many things. This section deals with some things that &lt;code&gt;erlang:now/0&lt;/code&gt; can be used for, and how you use the new API.</source>
          <target state="translated">이전에는 &lt;code&gt;erlang:now/0&lt;/code&gt; 이 많은 작업을 수행하는 유일한 옵션이었습니다. 이 섹션에서는 &lt;code&gt;erlang:now/0&lt;/code&gt; 을 사용할 수있는 몇 가지 사항 과 새로운 API를 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c7564efe264c3b6c0a1caef06afe212ed23e0f2a" translate="yes" xml:space="preserve">
          <source>Previously all operations sending signals to ports began by acquiring the port lock, then performed preparations for sending the signal, and then finally sent the signal. The preparations typically included inspecting the state of the port, and preparing the data to pass along with the signal. The preparation of data is frequently quite time consuming, and did not really depend on the port. That is we would like to do this without having the port lock locked.</source>
          <target state="translated">이전에는 포트로 신호를 보내는 모든 작업이 포트 잠금을 획득 한 다음 신호 전송 준비를 수행 한 다음 마지막으로 신호를 전송했습니다. 준비에는 일반적으로 포트의 상태를 검사하고 신호와 함께 전달할 데이터를 준비하는 작업이 포함됩니다. 데이터 준비는 종종 시간이 많이 걸리며 포트에 실제로 의존하지 않았습니다. 즉, 포트 잠금을 잠그지 않고이 작업을 수행하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="e16667c6d147892f06ecec60287d99fb172844a5" translate="yes" xml:space="preserve">
          <source>Previously when a process that was in a run queue got suspended, we removed it from the queue straight away. This involved locking the process, locking the run queue, and then unlinking it from the double linked list implementing the queue. Removing a process from a lock free queue gets really complicated. Instead, of removing it from the queue, we just leave it in the queue and mark it as suspended. When later selected for execution we check if the process is suspended, if so just dropped it. During its time in the queue, it might also get resumed again, if so execute it when it get selected for execution.</source>
          <target state="translated">이전에는 실행 큐에 있던 프로세스가 일시 중단되었을 때 즉시 큐에서 제거했습니다. 여기에는 프로세스 잠금, 실행 큐 잠금, 큐를 구현하는 이중 연결 목록에서 링크 해제가 포함됩니다. 잠금 해제 대기열에서 프로세스를 제거하는 것은 정말 복잡합니다. 대신 큐에서 제거하는 대신 큐에 그대로두고 일시 중단 된 것으로 표시합니다. 나중에 실행하도록 선택 될 때 프로세스가 일시 중단되었는지 확인합니다. 대기열에있는 동안 다시 재개 될 수도 있습니다. 그러면 실행을 위해 선택 될 때 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e0ceee1e4ba51d6772fb4907373f07ae18936fe7" translate="yes" xml:space="preserve">
          <source>Previously, in the runtime system without SMP support, specific driver callbacks were always called from the same thread. This is &lt;strong&gt;not&lt;/strong&gt; the case in the runtime system with SMP support. Regardless of locking scheme used, calls to driver callbacks can be made from different threads. For example, two consecutive calls to exactly the same callback for exactly the same port can be made from two different threads. This is for &lt;strong&gt;most&lt;/strong&gt; drivers not a problem, but it can be. Drivers that depend on all callbacks that are called in the same thread, &lt;strong&gt;must&lt;/strong&gt; be rewritten before they are used in the runtime system with SMP support.</source>
          <target state="translated">이전에는 SMP를 지원하지 않는 런타임 시스템에서 특정 드라이버 콜백이 항상 동일한 스레드에서 호출되었습니다. 입니다 &lt;strong&gt;하지&lt;/strong&gt; SMP를 지원하는 런타임 시스템의 경우. 사용 된 잠금 체계에 관계없이 드라이버 콜백에 대한 호출은 다른 스레드에서 수행 될 수 있습니다. 예를 들어, 정확히 동일한 포트에 대해 정확히 동일한 콜백에 대한 두 번의 연속 호출은 두 개의 다른 스레드에서 이루어질 수 있습니다. 이것은 &lt;strong&gt;대부분의&lt;/strong&gt; 드라이버에게 문제가되지 않지만 문제가 될 수 있습니다. 동일한 스레드에서 호출 된 모든 콜백에 의존하는 드라이버는 SMP를 지원하는 런타임 시스템에서 사용되기 전에 다시 작성 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5f579d9ae867a89d0d67a62b8e2faa9a8ddf24b1" translate="yes" xml:space="preserve">
          <source>Primary Logger Configuration</source>
          <target state="translated">기본 로거 구성</target>
        </trans-unit>
        <trans-unit id="41e95726528ea52023e106b0ac0c22d8fda4f9a9" translate="yes" xml:space="preserve">
          <source>Primary configuration data for Logger. The following default values apply:</source>
          <target state="translated">로거의 기본 구성 데이터. 다음과 같은 기본값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="42d555687785b7ddf41e200674b7e8d72cd8d523" translate="yes" xml:space="preserve">
          <source>Primary filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt; logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt;. They can also be added at system start via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 필터는 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt; logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 로 추가 되고 &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt; logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 로 제거됩니다 . 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 를 통해 시스템 시작시 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4247f20e948bccce17d13768ac3cbeade11f898" translate="yes" xml:space="preserve">
          <source>Primary filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt;. They can also be added at system start via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 필터는 &lt;code&gt;&lt;a href=&quot;logger#add_primary_filter-2&quot;&gt;logger:add_primary_filter/2&lt;/a&gt;&lt;/code&gt; 로 추가 되고 &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 로 제거됩니다 . 시스템 시작시 커널 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; 를 통해 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c017c83ba101ed388ebd807c4962577b9c15b383" translate="yes" xml:space="preserve">
          <source>Print information about the progress of execution (analysis phases, time spent in each, and size of the relative input).</source>
          <target state="translated">실행 진행 상황 (분석 단계, 각각에 소요 된 시간 및 상대 입력 크기)에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d875fa0682eb986753b79ff11bb8426e9a0c7e07" translate="yes" xml:space="preserve">
          <source>Print logs to a file</source>
          <target state="translated">로그를 파일로 인쇄</target>
        </trans-unit>
        <trans-unit id="840da8e13285304b6387e89b722d638fe4321fb7" translate="yes" xml:space="preserve">
          <source>Print percentage of time spent in each state out of system time as well as thread time. Default: false.</source>
          <target state="translated">스레드 시간뿐만 아니라 시스템 시간이 아닌 각 상태에서 소요 된 시간의 백분율을 인쇄합니다. 기본값 : false</target>
        </trans-unit>
        <trans-unit id="07be91632e8eb7326b61e92e0be9119ccf72f9d9" translate="yes" xml:space="preserve">
          <source>Print the Dialyzer version and some more information and exit.</source>
          <target state="translated">투석기 버전 및 추가 정보를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="92dfebd42b16e35a5fd17a2305e434920bbb3835" translate="yes" xml:space="preserve">
          <source>Print the configuration of all handlers.</source>
          <target state="translated">모든 핸들러의 구성을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="465f1109a54007c3651daa6d3f5648d85d0c94ae" translate="yes" xml:space="preserve">
          <source>Print the documentation for &lt;code&gt;Module:Function/Arity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module:Function/Arity&lt;/code&gt; 에 대한 문서를 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c54f23b1168b2002879e4bf41359b131882a9c7" translate="yes" xml:space="preserve">
          <source>Print the documentation for &lt;code&gt;Module&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 대한 문서 인쇄</target>
        </trans-unit>
        <trans-unit id="ec4c7fdc49fc657235f735e67b103083d086d3a9" translate="yes" xml:space="preserve">
          <source>Print the documentation for all &lt;code&gt;Module:Function&lt;/code&gt;s (regardless of arity).</source>
          <target state="translated">모든 &lt;code&gt;Module:Function&lt;/code&gt; 에 대한 문서를 인쇄합니다 (arity에 관계없이).</target>
        </trans-unit>
        <trans-unit id="4ad3462bebc7bf990bf0f02e7785a28379a6206b" translate="yes" xml:space="preserve">
          <source>Print the given microstate statistics values to standard out. With many states this can be quite verbose. See the top of this reference manual for a brief description of what the fields mean.</source>
          <target state="translated">주어진 마이크로 스테이트 통계 값을 표준 출력으로 인쇄합니다. 많은 주에서 이것은 매우 장황 할 수 있습니다. 필드의 의미에 대한 간략한 설명은이 참조 매뉴얼 상단을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4970bf3b0689c3bc33384763bf346be0cfadd6f5" translate="yes" xml:space="preserve">
          <source>Print the given microstate statistics values to stdout. Same as &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt; msacc:print(DataOrStats,#{}). &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">주어진 microstate 통계 값을 stdout에 인쇄합니다. &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt; msacc:print(DataOrStats,#{}). &lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c29cb731638369d14c3a95c6a29333f3020a9db2" translate="yes" xml:space="preserve">
          <source>Print the given microstate statistics values to stdout. Same as &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(DataOrStats,#{}).&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">주어진 마이크로 스테이트 통계 값을 stdout에 인쇄하십시오. &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(DataOrStats,#{}).&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d7eaf72064647bad389abb4f1d3dfdc027f8b39d" translate="yes" xml:space="preserve">
          <source>Print the given microstate statistics values to the given file or device. The other arguments behave the same way as for &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 마이크로 스테이트 통계 값을 주어진 파일 또는 장치에 인쇄하십시오. 다른 인수는 &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt; 와 같은 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ba5de3ef9125e2ec267d01741dd2ed47712b2cfb" translate="yes" xml:space="preserve">
          <source>Print the primary Logger configurations.</source>
          <target state="translated">기본 로거 구성을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="34634055c6f69316398bf0d40b7161096698a0c0" translate="yes" xml:space="preserve">
          <source>Print the statistics by source file and line numbers.</source>
          <target state="translated">소스 파일 및 행 번호별로 통계를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="6346a375113351396db6189bbd3e28045635ee9a" translate="yes" xml:space="preserve">
          <source>Print the structure of a syntax tree or template to the standard output. This is a utility function for development and debugging.</source>
          <target state="translated">구문 트리 또는 템플릿의 구조를 표준 출력으로 인쇄하십시오. 개발 및 디버깅을위한 유틸리티 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e10fd3ed853bc375bf83189519dd5d93564c2fbe" translate="yes" xml:space="preserve">
          <source>Print the type documentation for &lt;code&gt;Module&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 대한 유형 문서 인쇄</target>
        </trans-unit>
        <trans-unit id="f1efdeed5130231a6e5fabdee2f6a141a2950036" translate="yes" xml:space="preserve">
          <source>Print the type documentation for &lt;code&gt;Type/Arity&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type/Arity&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; 에 대한 유형 문서를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="631758cd60c7a5de270b74862175133314a58a36" translate="yes" xml:space="preserve">
          <source>Print the type documentation for &lt;code&gt;Type&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; regardless of arity.</source>
          <target state="translated">Arity에 관계없이 &lt;code&gt;Type&lt;/code&gt; in &lt;code&gt;Module&lt;/code&gt; 에 대한 유형 문서를 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0de2ead24e5961c777ca83b34e36a96963308e8" translate="yes" xml:space="preserve">
          <source>Print this message and exit.</source>
          <target state="translated">이 메시지를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="67d04a8c259ba2c520817ac42065457527ed5559" translate="yes" xml:space="preserve">
          <source>Printing characters, excluding letters, digits, and space</source>
          <target state="translated">문자, 숫자 및 공백을 제외한 문자 인쇄</target>
        </trans-unit>
        <trans-unit id="dd479d5b24caa5cc7f6fcec5ba84f65bfd052c0e" translate="yes" xml:space="preserve">
          <source>Printing characters, excluding space</source>
          <target state="translated">공백을 제외한 문자 인쇄</target>
        </trans-unit>
        <trans-unit id="1ceeb223cd6849a3604ba83fadcbca0256451f47" translate="yes" xml:space="preserve">
          <source>Printing characters, including space</source>
          <target state="translated">공백을 포함한 문자 인쇄</target>
        </trans-unit>
        <trans-unit id="5d921c48d9c8fb8f05637fa271ea8672b6ca0cee" translate="yes" xml:space="preserve">
          <source>Printing options:</source>
          <target state="translated">인쇄 옵션 :</target>
        </trans-unit>
        <trans-unit id="d6045c26dcc40b8b0b1a862cc5369f2a960dd880" translate="yes" xml:space="preserve">
          <source>Prints &lt;code&gt;Text&lt;/code&gt; and the wall clock time for evaluation of &lt;code&gt;Expr&lt;/code&gt;. The result is always the value of &lt;code&gt;Expr&lt;/code&gt;, so this macro can be wrapped around any expression to show its run time when the code is compiled with debugging enabled. For example, &lt;code&gt;List1 = ?debugTime(&quot;sorting&quot;, lists:sort(List))&lt;/code&gt; might show as &quot;&lt;code&gt;sorting: 0.015 s&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 평가를 위해 &lt;code&gt;Text&lt;/code&gt; 및 벽시계 시간을 인쇄 합니다. 결과는 항상 &lt;code&gt;Expr&lt;/code&gt; 의 값 이므로,이 매크로는 코드가 디버깅이 활성화 된 상태에서 컴파일 될 때 런타임을 보여주기 위해 모든 표현식을 감쌀 수 있습니다. 예를 들어 &lt;code&gt;List1 = ?debugTime(&quot;sorting&quot;, lists:sort(List))&lt;/code&gt; 는 &quot; &lt;code&gt;sorting: 0.015 s&lt;/code&gt; &quot; 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="249624d6cefc4a2b88e5bd0c9d8e84ed3f1f76d0" translate="yes" xml:space="preserve">
          <source>Prints a list of internal lock counters by source code locations.</source>
          <target state="translated">소스 코드 위치별로 내부 잠금 카운터 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5b46759cd364af5f12c0d8bc8dd37e3821f4b179" translate="yes" xml:space="preserve">
          <source>Prints a list of internal lock counters for a specific lock.</source>
          <target state="translated">특정 잠금에 대한 내부 잠금 카운터 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f780c7159f6f13c37c7d77cfd6cc4335b5ecf7a3" translate="yes" xml:space="preserve">
          <source>Prints a list of internal locks and its statistics.</source>
          <target state="translated">내부 잠금 목록 및 해당 통계를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="34938f37f4431fc15190b179d6c88b3314bbc2c3" translate="yes" xml:space="preserve">
          <source>Prints a term using the record definitions known to the shell. All of &lt;code&gt;Term&lt;/code&gt; is printed; the depth is not limited as is the case when a return value is printed.</source>
          <target state="translated">쉘에 알려진 레코드 정의를 사용하여 용어를 인쇄합니다. 모든 &lt;code&gt;Term&lt;/code&gt; 가 인쇄됩니다. 반환 값이 인쇄 될 때와 같이 깊이는 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af0bf4827e6f6c31d2c88fd072f546d7d79231d8" translate="yes" xml:space="preserve">
          <source>Prints a term, in clear text, to the file specified by &lt;code&gt;fp&lt;/code&gt;, or the buffer pointed to by &lt;code&gt;s&lt;/code&gt;. It tries to resemble the term printing in the Erlang shell.</source>
          <target state="translated">&lt;code&gt;fp&lt;/code&gt; 로 지정된 파일 또는 &lt;code&gt;s&lt;/code&gt; 로 지정된 버퍼 에 일반 텍스트로 용어를 인쇄합니다 . Erlang 쉘의 인쇄 용어와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="dbb3d816fd9f97adbc552b5513c5a135cb6248eb" translate="yes" xml:space="preserve">
          <source>Prints a text representation of &lt;code&gt;Term&lt;/code&gt; on the standard output.</source>
          <target state="translated">표준 출력 에 &lt;code&gt;Term&lt;/code&gt; 의 텍스트 표현을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="f131bd4ae3bf99f6a37fd4eaaff33b16a3ddd00d" translate="yes" xml:space="preserve">
          <source>Prints all existing breakpoints in &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 모든 기존 중단 점을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="5a8350e6665f2a056f33d55252db1621c39e138f" translate="yes" xml:space="preserve">
          <source>Prints all existing breakpoints.</source>
          <target state="translated">기존의 모든 중단 점을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a09e12adb74f08869231e9cda96a7ab997d865d7" translate="yes" xml:space="preserve">
          <source>Prints all filenames in the zip archive &lt;code&gt;Archive&lt;/code&gt; to the Erlang shell. (Similar to &lt;code&gt;tar&amp;nbsp;t&lt;/code&gt;.)</source>
          <target state="translated">Zip 아카이브 &lt;code&gt;Archive&lt;/code&gt; 의 모든 파일 이름을 Erlang 쉘 에 인쇄합니다 . &lt;code&gt;tar&amp;nbsp;t&lt;/code&gt; 와 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="18e7b8e58c0e38665fb68377f1d2376f33278d8b" translate="yes" xml:space="preserve">
          <source>Prints all record definitions.</source>
          <target state="translated">모든 레코드 정의를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="66a41d50c3e8acabd70db40b3336aae5ee4b67bb" translate="yes" xml:space="preserve">
          <source>Prints all system events on &lt;code&gt;standard_io&lt;/code&gt;. The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;standard_io&lt;/code&gt; 의 모든 시스템 이벤트를 인쇄합니다 . 이벤트는 이벤트를 생성 한 프로세스에 의해 정의 된 함수 ( &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt; 에 대한 호출)로 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a70ee13c7e68963279aefe5da5f06258c94682e" translate="yes" xml:space="preserve">
          <source>Prints an informational message about each added file.</source>
          <target state="translated">추가 된 각 파일에 대한 정보 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b783bcbadb2cc653a08641efe74f849f29f9e618" translate="yes" xml:space="preserve">
          <source>Prints an informational message about the added file.</source>
          <target state="translated">추가 된 파일에 대한 정보 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="789b189bdffe8e48a506f0e50b3eae0173a1b17d" translate="yes" xml:space="preserve">
          <source>Prints an informational message for each extracted file.</source>
          <target state="translated">추출 된 각 파일에 대한 정보 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b42f15b17183c3dbb48cf5820eb8a855896d590a" translate="yes" xml:space="preserve">
          <source>Prints and logs from a test case.</source>
          <target state="translated">테스트 사례에서 인쇄 및 기록합니다.</target>
        </trans-unit>
        <trans-unit id="0cf9dc25b9f3af6da971b72a11d06f3ed2521439" translate="yes" xml:space="preserve">
          <source>Prints both the source code for &lt;code&gt;Expr&lt;/code&gt; and its current value. E.g., &lt;code&gt;?debugVal(f(X))&lt;/code&gt; might be displayed as &quot;&lt;code&gt;f(X) = 42&lt;/code&gt;&quot;. (Large terms are truncated to the depth given by the macro &lt;code&gt;EUNIT_DEBUG_VAL_DEPTH&lt;/code&gt;, which defaults to 15 but can be overridden by the user.) The result is always the value of &lt;code&gt;Expr&lt;/code&gt;, so this macro can be wrapped around any expression to display its value when the code is compiled with debugging enabled.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 의 소스 코드 와 현재 값 을 모두 인쇄합니다 . 예를 들어, &lt;code&gt;?debugVal(f(X))&lt;/code&gt; 는 &quot; &lt;code&gt;f(X) = 42&lt;/code&gt; &quot; 로 표시 될 수 있습니다 . (큰 용어는 &lt;code&gt;EUNIT_DEBUG_VAL_DEPTH&lt;/code&gt; 매크로가 제공하는 깊이로 잘 리며 기본값은 15이지만 사용자가 재정의 할 수 있습니다.) 결과는 항상 &lt;code&gt;Expr&lt;/code&gt; 값 이므로이 매크로는 모든 표현식을 감싸서 값을 표시 할 수 있습니다. 코드는 디버깅이 활성화 된 상태로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="cba2a56bd54f58298d76b707819499e391db4251" translate="yes" xml:space="preserve">
          <source>Prints call statistics for each process in the analysis. This is the default.</source>
          <target state="translated">분석의 각 프로세스에 대한 통화 통계를 인쇄합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e1be7a76157fe86cb7376f259794a335da8ea625" translate="yes" xml:space="preserve">
          <source>Prints callers and called information in the analysis. This is the default.</source>
          <target state="translated">분석에서 발신자와 호출 된 정보를 인쇄합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c909f68d3cdf1b4678031168fcbd218d91fd2a8e" translate="yes" xml:space="preserve">
          <source>Prints filenames and information about all files in the zip archive &lt;code&gt;Archive&lt;/code&gt; to the Erlang shell. (Similar to &lt;code&gt;tar tv&lt;/code&gt;.)</source>
          <target state="translated">Zip 아카이브 &lt;code&gt;Archive&lt;/code&gt; 의 모든 파일에 대한 파일 이름 및 정보를 Erlang 쉘에 인쇄합니다. ( &lt;code&gt;tar tv&lt;/code&gt; 와 유사합니다 .)</target>
        </trans-unit>
        <trans-unit id="3d37aa2c01035d21e560d11bd3a6a17de70550c3" translate="yes" xml:space="preserve">
          <source>Prints from a test case to the console.</source>
          <target state="translated">테스트 케이스에서 콘솔로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f28c890f7ca27b31a21a647f349c289e1195b699" translate="yes" xml:space="preserve">
          <source>Prints from a test case to the log file.</source>
          <target state="translated">테스트 케이스에서 로그 파일로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="367bedb7c3ebf6d1df93886702fa7c7177182d00" translate="yes" xml:space="preserve">
          <source>Prints help text.</source>
          <target state="translated">도움말 텍스트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4842182b0113366c688f6ed8532b18cf4974ced6" translate="yes" xml:space="preserve">
          <source>Prints information about all table definitions on the terminal.</source>
          <target state="translated">터미널의 모든 테이블 정의에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c9b99b5c7266c995bbf989e773efe1fa4d05005d" translate="yes" xml:space="preserve">
          <source>Prints information about one table definition on the terminal.</source>
          <target state="translated">터미널에서 하나의 테이블 정의에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9a832165573cfbb962be90caea9e1e9a84652de7" translate="yes" xml:space="preserve">
          <source>Prints lcnt server state and generic information about collected lock statistics.</source>
          <target state="translated">수집 된 잠금 통계에 대한 lcnt 서버 상태 및 일반 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="96fd634328bfac39da0d4ad325d6f383ea04727b" translate="yes" xml:space="preserve">
          <source>Prints names and information about all files in the tar file &lt;code&gt;Name&lt;/code&gt; to the Erlang shell (similar to &quot;&lt;code&gt;tar&amp;nbsp;tv&lt;/code&gt;&quot;).</source>
          <target state="translated">인쇄 이름과 타르 파일에있는 모든 파일에 대한 정보는 &lt;code&gt;Name&lt;/code&gt; ( &quot;비슷한 얼랑 쉘 &lt;code&gt;tar&amp;nbsp;tv&lt;/code&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="0b7c144db0f81aaecb54453231a97d3656fc6209" translate="yes" xml:space="preserve">
          <source>Prints one expression. It is useful for implementing hooks (see section &lt;code&gt;&lt;a href=&quot;#knownlimitations&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">하나의 표현식을 인쇄합니다. 후크 구현에 유용합니다 (섹션 &lt;code&gt;&lt;a href=&quot;#knownlimitations&quot;&gt;Known Limitations&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0d811790ffe033d437439353029d5c5f60196585" translate="yes" xml:space="preserve">
          <source>Prints selected record definitions. &lt;code&gt;RecordNames&lt;/code&gt; is a record name or a list of record names.</source>
          <target state="translated">선택된 레코드 정의를 인쇄합니다. &lt;code&gt;RecordNames&lt;/code&gt; 는 레코드 이름 또는 레코드 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3337334a9f65d4805b4e67126869967487e4a45a" translate="yes" xml:space="preserve">
          <source>Prints system information on the terminal. This function can be used even if Mnesia is not started. However, more information is displayed if Mnesia is started.</source>
          <target state="translated">터미널에 시스템 정보를 인쇄합니다. Mnesia가 시작되지 않은 경우에도이 기능을 사용할 수 있습니다. 그러나 Mnesia가 시작되면 자세한 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7fe00a6e4282e0ab0f331a54683530177db63d" translate="yes" xml:space="preserve">
          <source>Prints the argument with the string syntax. The argument is, if no Unicode translation modifier is present, an &lt;code&gt;iolist()&lt;/code&gt;, a &lt;code&gt;binary()&lt;/code&gt;, or an &lt;code&gt;atom()&lt;/code&gt;. If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is in effect, the argument is &lt;code&gt;unicode:chardata()&lt;/code&gt;, meaning that binaries are in UTF-8. The characters are printed without quotes. The string is first truncated by the specified precision and then padded and justified to the specified field width. The default precision is the field width.</source>
          <target state="translated">문자열 구문으로 인수를 인쇄합니다. 유니 코드 변환 수정자가없는 경우 &lt;code&gt;iolist()&lt;/code&gt; , &lt;code&gt;binary()&lt;/code&gt; 또는 &lt;code&gt;atom()&lt;/code&gt; 입니다. 유니 코드 변환 수정 자 ( &lt;code&gt;t&lt;/code&gt; )가 유효한 경우 인수는 &lt;code&gt;unicode:chardata()&lt;/code&gt; 이며 이진은 UTF-8로되어 있습니다. 문자는 따옴표없이 인쇄됩니다. 문자열은 먼저 지정된 정밀도로 잘린 다음 지정된 필드 너비에 맞게 채워지고 정렬됩니다. 기본 정밀도는 필드 너비입니다.</target>
        </trans-unit>
        <trans-unit id="bd5cd1b05b1d6e3d16e8bf612aeeaa8d48e96e04" translate="yes" xml:space="preserve">
          <source>Prints the content of all the (snmp) tables and variables for all mibs handled by the snmp agent.</source>
          <target state="translated">snmp 에이전트가 처리하는 모든 mib에 대한 모든 (snmp) 테이블 및 변수의 내용을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="90637c82b5d5250fe221618f94be01dea7995ed8" translate="yes" xml:space="preserve">
          <source>Prints the content of all the (snmp) tables for all mibs handled by the snmp agent.</source>
          <target state="translated">snmp 에이전트가 처리하는 모든 mib에 대한 모든 (snmp) 테이블의 내용을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4bf87b55c70954b59410622021acfda18b4d862a" translate="yes" xml:space="preserve">
          <source>Prints the content of all the (snmp) variables for all mibs handled by the snmp agent.</source>
          <target state="translated">snmp 에이전트가 처리하는 모든 mib에 대한 모든 (snmp) 변수의 내용을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5b79c2bcb86c7797ba5fa06effcf5832d223d36a" translate="yes" xml:space="preserve">
          <source>Prints the contents of the database on screen. This is useful for debugging since the &lt;code&gt;STANDARD-MIB&lt;/code&gt; and &lt;code&gt;OTP-SNMPEA-MIB&lt;/code&gt; (and maybe your own MIBs) are stored in &lt;code&gt;snmpa_local_db&lt;/code&gt;.</source>
          <target state="translated">데이터베이스의 내용을 화면에 인쇄합니다. 이것은 이후 디버깅에 유용 &lt;code&gt;STANDARD-MIB&lt;/code&gt; 및 &lt;code&gt;OTP-SNMPEA-MIB&lt;/code&gt; 에 저장됩니다 (어쩌면 자신의 MIB를하고) &lt;code&gt;snmpa_local_db&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf9bf607d302af3ec16b8915f5fde9c68b05ce6e" translate="yes" xml:space="preserve">
          <source>Prints the current microstate accounting to standard out. Same as &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt; msacc:print(msacc:stats(),#{}). &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">현재 미시 상태 계정을 표준 출력으로 인쇄합니다. 동일 &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt; msacc:print(msacc:stats(),#{}). &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d48e71ba53b9a774ace4b3048a7d6147bac49e2" translate="yes" xml:space="preserve">
          <source>Prints the current microstate accounting to standard out. Same as &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(msacc:stats(),#{}).&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">현재 마이크로 스테이트 회계를 표준 출력으로 인쇄합니다. 동일 &lt;code&gt;&lt;a href=&quot;#print-1&quot;&gt;msacc:print(msacc:stats(),#{}).&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f573f7b3b8befc12d22fd5e016d5affba5ec7e7" translate="yes" xml:space="preserve">
          <source>Prints the current status of all interpreted processes.</source>
          <target state="translated">해석 된 모든 프로세스의 현재 상태를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b7de039db4515d2480ed1087648907d99e3cce17" translate="yes" xml:space="preserve">
          <source>Prints the current variable bindings.</source>
          <target state="translated">현재 변수 바인딩을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="38356e23d298a145e0dd7db9a9c3d8f5137f87bd" translate="yes" xml:space="preserve">
          <source>Prints the formatted string in the comment field in the table on the test suite result page.</source>
          <target state="translated">테스트 스위트 결과 페이지의 테이블에있는 주석 필드에 형식화 된 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9a338446495bbc76dc9e6e72c05e03dc5573b368" translate="yes" xml:space="preserve">
          <source>Prints the history list.</source>
          <target state="translated">히스토리 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1587f809009dffca5babc79d912a7baf0c2c4678" translate="yes" xml:space="preserve">
          <source>Prints the logged system events in the debug structure, using &lt;code&gt;FormFunc&lt;/code&gt; as defined when the event was generated by a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt; 호출로 이벤트가 생성 될 때 정의 된대로 &lt;code&gt;FormFunc&lt;/code&gt; 를 사용하여 디버그 구조에서 로그 된 시스템 이벤트를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="c697f405132de684f29b1c85650f6166f19d3f38" translate="yes" xml:space="preserve">
          <source>Prints the name of the working directory.</source>
          <target state="translated">작업 디렉토리의 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2b0a0e8caa63b361ad3055b9a938bd9ee0847140" translate="yes" xml:space="preserve">
          <source>Prints the names of all files in the tar file &lt;code&gt;Name&lt;/code&gt; to the Erlang shell (similar to &quot;&lt;code&gt;tar&amp;nbsp;t&lt;/code&gt;&quot;).</source>
          <target state="translated">tar 파일에있는 모든 파일의 &lt;code&gt;Name&lt;/code&gt; 을 Erlang 쉘에 인쇄합니다 ( &quot; &lt;code&gt;tar&amp;nbsp;t&lt;/code&gt; &quot; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="df056a5b36536b5f6f05efef7d94a9025dcb4881" translate="yes" xml:space="preserve">
          <source>Prints the node uptime (as specified by &lt;code&gt;erlang:statistics(wall_clock)&lt;/code&gt;) in human-readable form.</source>
          <target state="translated">&lt;code&gt;erlang:statistics(wall_clock)&lt;/code&gt; 지정된 노드 가동 시간 을 사람이 읽을 수있는 형식으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="236e4648c9dfa6dccb2557b594716eafdf865791" translate="yes" xml:space="preserve">
          <source>Prints the specified &lt;code&gt;Comment&lt;/code&gt; in the comment field in the table on the test suite result page.</source>
          <target state="translated">테스트 스위트 결과 페이지의 테이블에있는 주석 필드에 지정된 &lt;code&gt;Comment&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="86341a0cf794500a0ef3c32c1e84cb1e5b1a1ea2" translate="yes" xml:space="preserve">
          <source>Prints the specified Erlang term to the specified output stream.</source>
          <target state="translated">지정된 Erlang 용어를 지정된 출력 스트림으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="325bdac9b9003ed5a24e798d3e0a5f4333783830" translate="yes" xml:space="preserve">
          <source>Prior to Erlang/OTP 21.0, supervisor, crash, and progress reports were only logged when the SASL application was running. This behaviour can, for backwards compatibility, be enabled by setting the Kernel configuration parameter &lt;code&gt; logger_sasl_compatible&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="translated">Erlang / OTP 21.0 이전에는 감독자, 충돌 및 진행 보고서가 SASL 응용 프로그램이 실행 중일 때만 기록되었습니다. 이 동작은 이전 버전과의 호환성을 위해 커널 구성 매개 변수 &lt;code&gt; logger_sasl_compatible&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 . 자세한 내용 은 SASL 사용 설명서의 &lt;code&gt;SASL Error Logging&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01d810dcc882a2671bb99ec2a3f4b52034e71105" translate="yes" xml:space="preserve">
          <source>Prior to Erlang/OTP 21.0, supervisor, crash, and progress reports were only logged when the SASL application was running. This behaviour can, for backwards compatibility, be enabled by setting the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="translated">Erlang / OTP 21.0 이전에는 수퍼바이저, 충돌 및 진행 보고서가 SASL 응용 프로그램이 실행 중일 때만 기록되었습니다. 커널 구성 매개 변수 &lt;code&gt;logger_sasl_compatible&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 이전 버전과의 호환성을 위해이 동작을 사용할 수 있습니다 . 자세한 내용 은 SASL 사용 설명서의 &lt;code&gt;SASL Error Logging&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c5c3d6724263056f8e5809f4ae6b20baea9b0f8" translate="yes" xml:space="preserve">
          <source>Prior to Erlang/OTP 21.0, these reports were only logged when the SASL application was running, and they were printed trough SASL's own event handlers &lt;code&gt;sasl_report_tty_h&lt;/code&gt; and &lt;code&gt;sasl_report_file_h&lt;/code&gt;.</source>
          <target state="translated">Erlang / OTP 21.0 이전에는 이러한 보고서가 SASL 응용 프로그램이 실행 중일 때만 기록되었으며 SASL 자체 이벤트 핸들러 &lt;code&gt;sasl_report_tty_h&lt;/code&gt; 및 &lt;code&gt;sasl_report_file_h&lt;/code&gt; 를 통해 인쇄 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a9517dd9993b228427ab1498ed0cfff24f45932f" translate="yes" xml:space="preserve">
          <source>Prior to OTP 22.1, this function was documented as having 15 variants in 6 arities. These are still exported for backwards compatibility, but no longer documented. The map-based variants documented above provide the same functionality with simpler arguments.</source>
          <target state="translated">OTP 22.1 이전에는이 ​​기능이 6 개 배열에 15 개의 변형이있는 것으로 문서화되었습니다. 이전 버전과의 호환성을 위해 여전히 내보내 지지만 더 이상 문서화되지 않습니다. 위에 설명 된지도 기반 변형은 더 간단한 인수로 동일한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="53132db818aa78ab7620a49cbf8f5a24e49b420c" translate="yes" xml:space="preserve">
          <source>Prior to each test execution, Common Test does a simulated test run in order to count test suites, groups and cases for logging purposes. This causes the &lt;code&gt;post_all/3&lt;/code&gt; hook function to always be called twice. For this reason, side effects are best avoided in this callback.</source>
          <target state="translated">각 테스트 실행 전에 Common Test는 로깅 목적으로 테스트 스위트, 그룹 및 케이스를 계산하기 위해 시뮬레이션 된 테스트 실행을 수행합니다. 이로 인해 &lt;code&gt;post_all/3&lt;/code&gt; 후크 함수가 항상 두 번 호출됩니다. 이러한 이유로이 콜백에서는 부작용을 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d9fa9488e8079c2ed6ee6f3914be0fef3b123eb1" translate="yes" xml:space="preserve">
          <source>Prior to each test execution, Common Test does a simulated test run in order to count test suites, groups and cases for logging purposes. This causes the &lt;code&gt;post_groups/2&lt;/code&gt; hook function to always be called twice. For this reason, side effects are best avoided in this callback.</source>
          <target state="translated">각 테스트 실행 전에 Common Test는 로깅 목적으로 테스트 스위트, 그룹 및 케이스를 계산하기 위해 시뮬레이션 된 테스트 실행을 수행합니다. 이로 인해 &lt;code&gt;post_groups/2&lt;/code&gt; 후크 함수가 항상 두 번 호출됩니다. 이러한 이유로이 콜백에서는 부작용을 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cfc234fd653a76336820a16651d9ce91647ca6e8" translate="yes" xml:space="preserve">
          <source>Prior to stdlib-3.7 (OTP-22.0) &lt;code&gt;write_concurrency&lt;/code&gt; had no effect on &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">stdlib-3.7 (OTP-22.0) &lt;code&gt;write_concurrency&lt;/code&gt; 에는 write_concurrency 가 &lt;code&gt;ordered_set&lt;/code&gt; 에 영향을 미치지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="06bdb66fe24b1bd0f13724edf2132df5e7b44cc6" translate="yes" xml:space="preserve">
          <source>Priority level &lt;code&gt;max&lt;/code&gt; is reserved for internal use in the Erlang runtime system, and is &lt;strong&gt;not&lt;/strong&gt; to be used by others.</source>
          <target state="translated">우선 순위 레벨 &lt;code&gt;max&lt;/code&gt; 는 Erlang 런타임 시스템에서 내부 용으로 예약 되어 있으며 다른 사람이 사용 &lt;strong&gt;해서는 안됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="891a5ba970623a36963c697cb5e2983045ef4bf5" translate="yes" xml:space="preserve">
          <source>Private directory for a test suite. This directory is to be used when the test suite needs to write to files.</source>
          <target state="translated">테스트 스위트의 개인 디렉토리. 이 디렉토리는 테스트 스위트가 파일에 써야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1560d5e03a4510a6c6ad469d0a62cd63315c3854" translate="yes" xml:space="preserve">
          <source>Private key of the host matching the &lt;code&gt;Algorithm&lt;/code&gt;. It may be a reference to a 'ssh-rsa', rsa-sha2-* or 'ssh-dss' (NOT ecdsa) key stored in a loaded Engine.</source>
          <target state="translated">&lt;code&gt;Algorithm&lt;/code&gt; 과 일치하는 호스트의 개인 키 . 로드 된 엔진에 저장된 'ssh-rsa', rsa-sha2- * 또는 'ssh-dss'(NOT ecdsa) 키에 대한 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="603f6c7b83b91ba3b66637cb17d80977c31db448" translate="yes" xml:space="preserve">
          <source>Private key of the user matching the &lt;code&gt;Algorithm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Algorithm&lt;/code&gt; 과 일치하는 사용자의 개인 키 .</target>
        </trans-unit>
        <trans-unit id="74ad72304fcac0b5a69a08a6f5ec35c07a46f71f" translate="yes" xml:space="preserve">
          <source>Private use</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="b79a8e30c6fdcdcf9dd5d5409cd8498f3ab57c1c" translate="yes" xml:space="preserve">
          <source>Probe specifications can be found in &lt;code&gt;erts/emulator/beam/erlang_dtrace.d&lt;/code&gt;, and a few example scripts can be found under &lt;code&gt;lib/runtime_tools/examples/&lt;/code&gt;.</source>
          <target state="translated">프로브 사양은 &lt;code&gt;erts/emulator/beam/erlang_dtrace.d&lt;/code&gt; 에서 찾을 수 있으며 &lt;code&gt;lib/runtime_tools/examples/&lt;/code&gt; 에서 몇 가지 예제 스크립트를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f85f3223fd42f20ff0f4013198f3a0482c317dc6" translate="yes" xml:space="preserve">
          <source>Probes in the dtrace.so NIF library like this:</source>
          <target state="translated">dtrace.so NIF 라이브러리의 프로브는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4180fe17ea663764396b9e7a7c467588a0d635b1" translate="yes" xml:space="preserve">
          <source>Problems were found during the analysis.</source>
          <target state="translated">분석 중에 문제가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="dcd7a97391d07066e93a31ea99c263af50266780" translate="yes" xml:space="preserve">
          <source>Problems when extracting from a tar file, &lt;code&gt;erl_tar:extract/2&lt;/code&gt; returned &lt;code&gt;{error, {Name, Reason}}&lt;/code&gt;.</source>
          <target state="translated">tar 파일에서 추출 할 때 &lt;code&gt;erl_tar:extract/2&lt;/code&gt; 에서 &lt;code&gt;{error, {Name, Reason}}&lt;/code&gt; 리턴되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a4ea781ed99930cb2040f2b3d1f7277fa799d5c7" translate="yes" xml:space="preserve">
          <source>Procedure</source>
          <target state="translated">Procedure</target>
        </trans-unit>
        <trans-unit id="d682fc9dab69c1d2daf94fe72d9c9c2027249415" translate="yes" xml:space="preserve">
          <source>Procedures</source>
          <target state="translated">Procedures</target>
        </trans-unit>
        <trans-unit id="5c506e1119ce934c20944a9840c90c01b739012d" translate="yes" xml:space="preserve">
          <source>Process Communication</source>
          <target state="translated">프로세스 커뮤니케이션</target>
        </trans-unit>
        <trans-unit id="81f4402b2340732e32048f86bdd935e046c914b7" translate="yes" xml:space="preserve">
          <source>Process Grid</source>
          <target state="translated">프로세스 그리드</target>
        </trans-unit>
        <trans-unit id="1b5406f64cf5c66ba3e1f6f68c84ed91019d67d3" translate="yes" xml:space="preserve">
          <source>Process Groups implement strong eventual consistency. Unlike &lt;code&gt;&lt;a href=&quot;pg2&quot;&gt;pg2&lt;/a&gt;&lt;/code&gt;, that provides strong ordering guarantees, Process Groups membership view may temporarily diverge. For example, when processes on &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt; join concurrently, &lt;code&gt;node3&lt;/code&gt; and &lt;code&gt;node4&lt;/code&gt; may receive updates in a different order.</source>
          <target state="translated">프로세스 그룹은 강력한 최종 일관성을 구현합니다. 강력한 순서 보장을 제공하는 &lt;code&gt;&lt;a href=&quot;pg2&quot;&gt;pg2&lt;/a&gt;&lt;/code&gt; 와 달리 프로세스 그룹 구성원보기는 일시적으로 다를 수 있습니다. 예를 들어, &lt;code&gt;node1&lt;/code&gt; 과 &lt;code&gt;node2&lt;/code&gt; 의 프로세스가 동시에 결합하면 &lt;code&gt;node3&lt;/code&gt; 과 &lt;code&gt;node4&lt;/code&gt; 가 다른 순서로 업데이트를받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e976a26adbbfd7012fe545033a0a8839af4e4c58" translate="yes" xml:space="preserve">
          <source>Process IDs of processes linked to this one. Can also contain ports. If process monitoring is used, this field also tells in which direction the monitoring is in effect. That is, a link &quot;to&quot; a process tells you that the &quot;current&quot; process was monitoring the other, and a link &quot;from&quot; a process tells you that the other process was monitoring the current one.</source>
          <target state="translated">이 프로세스에 연결된 프로세스의 프로세스 ID 포트를 포함 할 수도 있습니다. 프로세스 모니터링이 사용되는 경우이 필드는 모니터링이 적용되는 방향을 알려줍니다. 즉, 프로세스에 대한 &quot;연결&quot;링크는 &quot;현재&quot;프로세스가 다른 프로세스를 모니터링하고 있음을 나타내며 프로세스 &quot;연결&quot;은 프로세스가 다른 프로세스가 현재 프로세스를 모니터링하고 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="5c2a6df2a2c67e8993bc6d87fb8bd6f06f3a923e" translate="yes" xml:space="preserve">
          <source>Process Implementation Functions</source>
          <target state="translated">프로세스 구현 기능</target>
        </trans-unit>
        <trans-unit id="e4e4bc359a8d952b99a64e9bb76a5b77309cbdfc" translate="yes" xml:space="preserve">
          <source>Process Menu</source>
          <target state="translated">프로세스 메뉴</target>
        </trans-unit>
        <trans-unit id="d7a28bb3334285a1e0ac0387ca14af38afa1bb3b" translate="yes" xml:space="preserve">
          <source>Process a received message</source>
          <target state="translated">수신 된 메시지 처리</target>
        </trans-unit>
        <trans-unit id="8bb6fc6f7e7a2280b8063de0d5700d2bb0cb9663" translate="yes" xml:space="preserve">
          <source>Process filters</source>
          <target state="translated">공정 필터</target>
        </trans-unit>
        <trans-unit id="bbbfe7098744c6470df556a76ad34523d9620833" translate="yes" xml:space="preserve">
          <source>Process groups can be organised into multiple scopes. Scopes are completely independent of each other. A process may join any number of groups in any number of scopes. Scopes are designed to decouple single mesh into a set of overlay networks, reducing amount of traffic required to propagate group membership information. Default scope &lt;code&gt;pg&lt;/code&gt; is started automatically when &lt;code&gt;kernel(6)&lt;/code&gt; is configured to do so.</source>
          <target state="translated">프로세스 그룹은 여러 범위로 구성 될 수 있습니다. 범위는 서로 완전히 독립적입니다. 프로세스는 여러 범위에서 원하는 수의 그룹에 가입 할 수 있습니다. 범위는 단일 메시를 오버레이 네트워크 세트로 분리하도록 설계되어 그룹 멤버십 정보를 전파하는 데 필요한 트래픽 양을 줄입니다. 기본 범위 &lt;code&gt;pg&lt;/code&gt; 는 &lt;code&gt;kernel(6)&lt;/code&gt; 이 이렇게 구성 될 때 자동으로 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ed08f16461a6d037cb208e9913ab037737a77bd" translate="yes" xml:space="preserve">
          <source>Process identifier of the &lt;code&gt;Kernel&lt;/code&gt; process. That is, the process that called either &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Kernel&lt;/code&gt; 프로세스 의 프로세스 식별자 . 즉, &lt;code&gt;&lt;a href=&quot;#setup&quot;&gt;setup/5&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; 를 호출 한 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="b2a5dd3b972f257d7fbc08cb7fd3527f448acb92" translate="yes" xml:space="preserve">
          <source>Process identifier of the group leader of the newly created process.</source>
          <target state="translated">새로 생성 된 프로세스 그룹 리더의 프로세스 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="5350a81bb4d7a6e885720414c324c78fdac18460" translate="yes" xml:space="preserve">
          <source>Process identifier of the process created by the &lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#accept&quot;&gt;accept/1&lt;/a&gt;&lt;/code&gt; 콜백에 의해 생성 된 프로세스의 프로세스 식별자 .</target>
        </trans-unit>
        <trans-unit id="423e976c638ce3015784a0556ff5f2c502e53ea5" translate="yes" xml:space="preserve">
          <source>Process identifier of the process making the request. That is, the parent process to be.</source>
          <target state="translated">요청하는 프로세스의 프로세스 식별자입니다. 즉, 부모 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="04402a10f6411016e19cf84d1d0c3b48a617b2c7" translate="yes" xml:space="preserve">
          <source>Process identifier of the process making the spawn request.</source>
          <target state="translated">생성 요청을 만드는 프로세스의 프로세스 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="ec8568d5958f46e915bd83080ff98e0e79a75222" translate="yes" xml:space="preserve">
          <source>Process is monitored by pid.</source>
          <target state="translated">프로세스는 pid에 의해 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="d75f836c4b41dbd50f08ee91d634c102832d9687" translate="yes" xml:space="preserve">
          <source>Process max heap size configuration. For more info see &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;process_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">최대 힙 크기 구성을 처리합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;process_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; 참조하세요.</target>
        </trans-unit>
        <trans-unit id="2ea03c83c0bea6d342541a89cb5e2488edbcde72" translate="yes" xml:space="preserve">
          <source>Process message queue data configuration. For more info see &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt;process_flag(message_queue_data, MQD)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">메시지 큐 데이터 구성을 처리합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#process_flag_message_queue_data&quot;&gt;process_flag(message_queue_data, MQD)&lt;/a&gt;&lt;/code&gt; 참조하세요.</target>
        </trans-unit>
        <trans-unit id="6f880ba7aefb600d7833f0168b36c50728469e28" translate="yes" xml:space="preserve">
          <source>Process metadata is set and updated with &lt;code&gt;&lt;a href=&quot;logger#set_process_metadata-1&quot;&gt; logger:set_process_metadata/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#update_process_metadata-1&quot;&gt; logger:update_process_metadata/1&lt;/a&gt;&lt;/code&gt;, respectively. This metadata applies to the process on which these calls are made, and Logger adds the metadata to all log events issued on that process.</source>
          <target state="translated">프로세스 메타 데이터는 각각 &lt;code&gt;&lt;a href=&quot;logger#set_process_metadata-1&quot;&gt; logger:set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#update_process_metadata-1&quot;&gt; logger:update_process_metadata/1&lt;/a&gt;&lt;/code&gt; 로 설정되고 업데이트됩니다 . 이 메타 데이터는 이러한 호출이 수행되는 프로세스에 적용되며 Logger는 해당 프로세스에서 발행 된 모든 로그 이벤트에 메타 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="beca56c90caa14898b2c241f5874170cc90c2a9c" translate="yes" xml:space="preserve">
          <source>Process metadata is set and updated with &lt;code&gt;&lt;a href=&quot;logger#set_process_metadata-1&quot;&gt;logger:set_process_metadata/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#update_process_metadata-1&quot;&gt;logger:update_process metadata/1&lt;/a&gt;&lt;/code&gt;, respectively. This metadata applies to the process on which these calls are made, and Logger adds the metadata to all log events issued on that process.</source>
          <target state="translated">프로세스 메타 데이터는 각각 &lt;code&gt;&lt;a href=&quot;logger#set_process_metadata-1&quot;&gt;logger:set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#update_process_metadata-1&quot;&gt;logger:update_process metadata/1&lt;/a&gt;&lt;/code&gt; 로 설정 및 업데이트됩니다 . 이 메타 데이터는 이러한 호출이 수행되는 프로세스에 적용되며 로거는 해당 프로세스에서 발행 된 모든 로그 이벤트에 메타 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="540946d7cea619b7ce232c97b46a1860d2e4a41b" translate="yes" xml:space="preserve">
          <source>Process priority level. For more info see &lt;code&gt;&lt;a href=&quot;#process_flag_priority&quot;&gt;process_flag(priority, Level)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">프로세스 우선 순위 수준. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#process_flag_priority&quot;&gt;process_flag(priority, Level)&lt;/a&gt;&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67e5f2d87d665dc7e3929e88907eef304eb59bc0" translate="yes" xml:space="preserve">
          <source>Process the action requests and either return an error_descr() indicating some fatal error or a list of action replies (wildcarded or not).</source>
          <target state="translated">조치 요청을 처리하고 일부 치명적 오류를 나타내는 error_descr () 또는 조치 응답 목록 (와일드 카드 표시 여부)을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="6055fe67fe73591ecd6add960eb22a68e35be849" translate="yes" xml:space="preserve">
          <source>Processes an incoming message. Performs authentication and decryption as necessary. The return values should be passed the manager server.</source>
          <target state="translated">수신 메시지를 처리합니다. 필요에 따라 인증 및 암호 해독을 수행합니다. 리턴 값은 관리자 서버로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="288b10741351f050abd56115edaeab3cbc0b134b" translate="yes" xml:space="preserve">
          <source>Processes an incoming packet. Performs authentication and decryption as necessary. The return values should be passed to the agent.</source>
          <target state="translated">들어오는 패킷을 처리합니다. 필요에 따라 인증 및 암호 해독을 수행합니다. 리턴 값은 에이전트에 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed98243f088a1f790e5261686fb35da9e9e2e36b" translate="yes" xml:space="preserve">
          <source>Processes and ports added by process/port identifiers add the nodes these processes/ports reside on in the node list. More nodes can be added by clicking button &lt;strong&gt;Add Nodes&lt;/strong&gt;, or by right-clicking in the &lt;strong&gt;Nodes&lt;/strong&gt; list and select &lt;strong&gt;Add Nodes&lt;/strong&gt;. To remove nodes, select them, then right-click and choose &lt;strong&gt;Remove nodes&lt;/strong&gt;.</source>
          <target state="translated">프로세스 / 포트 식별자로 추가 된 프로세스 및 포트는 이러한 프로세스 / 포트가있는 노드를 노드 목록에 추가합니다. &lt;strong&gt;Add Nodes&lt;/strong&gt; 버튼을 클릭 하거나 &lt;strong&gt;Nodes&lt;/strong&gt; 목록 에서 마우스 오른쪽 버튼을 클릭하고 &lt;strong&gt;Add Nodes를&lt;/strong&gt; 선택 하여 더 많은 노드를 추가 할 수 있습니다 . 노드를 제거하려면 해당 노드를 선택한 다음 마우스 오른쪽 단추를 클릭하고 &lt;strong&gt;노드 제거를&lt;/strong&gt; 선택 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bf438e45a34ce6e54b5666dee9827f7d9908c9aa" translate="yes" xml:space="preserve">
          <source>Processes are added from the &lt;strong&gt;Applications&lt;/strong&gt; or &lt;strong&gt;Processes&lt;/strong&gt; tabs. Ports are added from the &lt;strong&gt;Ports&lt;/strong&gt; tab. A special &lt;strong&gt;new&lt;/strong&gt; identifier, meaning all processes, or ports, started after trace start, can be added with buttons &lt;strong&gt;Add 'new' Processes&lt;/strong&gt; and &lt;strong&gt;Add 'new' Ports&lt;/strong&gt;, respecively.</source>
          <target state="translated">프로세스는 &lt;strong&gt;응용 프로그램&lt;/strong&gt; 또는 &lt;strong&gt;프로세스&lt;/strong&gt; 탭 에서 추가됩니다 . 포트는 &lt;strong&gt;포트&lt;/strong&gt; 탭 에서 추가됩니다 . 추적 시작 후 시작된 모든 프로세스 또는 포트를 의미 하는 특수한 &lt;strong&gt;새&lt;/strong&gt; 식별자는 &lt;strong&gt;'새'프로세스 &lt;/strong&gt;&lt;strong&gt;추가&lt;/strong&gt; 및 &lt;strong&gt;'새'포트 추가&lt;/strong&gt; 단추로 각각 &lt;strong&gt;추가&lt;/strong&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be549e5919a2d84debbcdab9c71aa73639ddafc7" translate="yes" xml:space="preserve">
          <source>Processes can be specified as registered names, globally registered names, or process identifiers. Ports can be specified as registered names or port identifiers. If a registered name is specified, the flags are set on processes/ports with this name on all active nodes.</source>
          <target state="translated">프로세스는 등록 된 이름, 전체적으로 등록 된 이름 또는 프로세스 식별자로 지정할 수 있습니다. 포트는 등록 된 이름 또는 포트 식별자로 지정할 수 있습니다. 등록 된 이름이 지정되면 플래그는 모든 활성 노드에서이 이름으로 프로세스 / 포트에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c93cc0cb1c7c1cf0a914f4b84e40d8422afe1f41" translate="yes" xml:space="preserve">
          <source>Processes can monitor other processes and detect process terminations, see &lt;code&gt;&lt;a href=&quot;processes#errors&quot;&gt;Processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 프로세스를 모니터링하고 프로세스 종단을 검출 할 수있는 프로세스는, 참조 &lt;code&gt;&lt;a href=&quot;processes#errors&quot;&gt;Processes&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="630a26a9de10b21d483dfee70c4d12d378a250c0" translate="yes" xml:space="preserve">
          <source>Processes communicate by sending and receiving messages. Messages are sent by using the &lt;code&gt;&lt;a href=&quot;expressions#send&quot;&gt;send operator !&lt;/a&gt;&lt;/code&gt; and received by calling &lt;code&gt;&lt;a href=&quot;expressions#receive&quot;&gt;receive&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스는 메시지를 송수신하여 통신합니다. &lt;code&gt;&lt;a href=&quot;expressions#send&quot;&gt;send operator !&lt;/a&gt;&lt;/code&gt; 를 사용하여 메시지를 보냅니다 ! &lt;code&gt;&lt;a href=&quot;expressions#receive&quot;&gt;receive&lt;/a&gt;&lt;/code&gt; 를 호출하여 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="d178bde37cb4db43efd1bc3bc63a9067eff3bf67" translate="yes" xml:space="preserve">
          <source>Processes in &lt;code&gt;ch_app&lt;/code&gt; for which code have not been updated, for example, the supervisor, are still evaluating code from &lt;code&gt;ch_app-1&lt;/code&gt;.</source>
          <target state="translated">코드가 업데이트되지 않은 &lt;code&gt;ch_app&lt;/code&gt; 의 프로세스 ( 예 : 감독자)는 여전히 &lt;code&gt;ch_app-1&lt;/code&gt; 의 코드를 평가하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="033f59a44cf3d7e0ad2fb2a6c9d6d37906dc4f55" translate="yes" xml:space="preserve">
          <source>Processes sending command data to the port are suspended if either the port is busy or if the port message queue is busy. Suspended processes are resumed when neither the port or the port message queue is busy.</source>
          <target state="translated">포트가 사용 중이거나 포트 메시지 큐가 사용 중이면 명령 데이터를 포트로 전송하는 프로세스가 일시 중단됩니다. 포트 또는 포트 메시지 큐가 사용 중이 아니면 일시 중단 된 프로세스가 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="7813ce8e07b59a64bbf71e0e1c1f12985cd75cf4" translate="yes" xml:space="preserve">
          <source>Processes sending command data to the port are suspended if either the port or the port message queue is busy. Suspended processes are resumed when neither the port or the port message queue is busy. Command data is in this context data passed to the port using either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;.</source>
          <target state="translated">포트 또는 포트 메시지 큐가 사용 중이면 명령 데이터를 포트로 보내는 프로세스가 일시 중단됩니다. 포트 또는 포트 메시지 큐가 사용 중이 아니면 일시 중단 된 프로세스가 재개됩니다. 명령 데이터는이 컨텍스트에서 &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; 또는 &lt;code&gt;port_command/[2,3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a29be095a2ff95859b3cad24b61604a71c86c0b" translate="yes" xml:space="preserve">
          <source>Processes started with functions &lt;code&gt;proc_lib:spawn&lt;/code&gt; or &lt;code&gt;proc_lib:spawn_link&lt;/code&gt; are wrapped within a &lt;code&gt;catch&lt;/code&gt;. A crash report is issued when such a process terminates with an unexpected reason, which is any reason other than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;. Processes using behaviors &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt; or &lt;code&gt;gen_statem&lt;/code&gt; are examples of such processes. A crash report contains the following items:</source>
          <target state="translated">&lt;code&gt;proc_lib:spawn&lt;/code&gt; 또는 &lt;code&gt;proc_lib:spawn_link&lt;/code&gt; 함수로 시작된 프로세스 는 &lt;code&gt;catch&lt;/code&gt; 내에 래핑됩니다 . 이러한 프로세스가 예기치 않은 이유로 종료 될 경우 충돌 보고서가 발행되는데, 이는 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; 또는 &lt;code&gt;{shutdown,Term}&lt;/code&gt; 이외의 다른 이유 입니다. &lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_fsm&lt;/code&gt; 또는 &lt;code&gt;gen_statem&lt;/code&gt; 동작을 사용하는 프로세스 가 이러한 프로세스의 예입니다. 충돌 보고서에는 다음 항목이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a39a6bcdcfd7777bfaedcdb0b7cb9d27d3872a4" translate="yes" xml:space="preserve">
          <source>Processes that are not implemented as one of the standard behaviors must still understand system messages. The following three messages must be understood:</source>
          <target state="translated">표준 동작 중 하나로 구현되지 않은 프로세스는 여전히 시스템 메시지를 이해해야합니다. 다음 세 가지 메시지를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="258d2694c3db94bd2e39f0eb743d67f6aa439cd6" translate="yes" xml:space="preserve">
          <source>Processes, ports and ets tables can then be inspecting using their respective info functions, i.e. &lt;code&gt;erlang:process_info/2 &lt;/code&gt;, &lt;code&gt;erlang:port_info/2 &lt;/code&gt; and &lt;code&gt;ets:info/1&lt;/code&gt;.</source>
          <target state="translated">프로세스, 포트 및 ets 테이블은 각각의 정보 함수 (예 : &lt;code&gt;erlang:process_info/2 &lt;/code&gt; , &lt;code&gt;erlang:port_info/2 &lt;/code&gt; 및 &lt;code&gt;ets:info/1&lt;/code&gt; )를 사용하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58c7efb2fc2ee91313efcb0b51ba3d6222f1b4e4" translate="yes" xml:space="preserve">
          <source>Processes, ports and ets tables can then be inspecting using their respective info functions, i.e. &lt;code&gt;erlang:process_info/2&lt;/code&gt;, &lt;code&gt;erlang:port_info/2&lt;/code&gt; and &lt;code&gt;ets:info/1&lt;/code&gt;.</source>
          <target state="translated">그런 다음 프로세스, 포트 및 ets 테이블은 각각의 정보 기능 (예 : &lt;code&gt;erlang:process_info/2&lt;/code&gt; , &lt;code&gt;erlang:port_info/2&lt;/code&gt; 및 &lt;code&gt;ets:info/1&lt;/code&gt; )을 사용하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6017176610426ad0695826f94e970fac5ae785f" translate="yes" xml:space="preserve">
          <source>Processing Local Requests</source>
          <target state="translated">로컬 요청 처리</target>
        </trans-unit>
        <trans-unit id="2f93aa73375c48e5ac1052bbdea13b31c4c62dea" translate="yes" xml:space="preserve">
          <source>Processing Received Answers</source>
          <target state="translated">받은 답변 처리</target>
        </trans-unit>
        <trans-unit id="47c0c8f7f7c694d8170efc2ece7ee9a4d20e521e" translate="yes" xml:space="preserve">
          <source>Processing options such as case-independence are fixed when a subpattern is defined, so if it is used as a subroutine, such options cannot be changed for different calls. For example, the following pattern matches &quot;abcabc&quot; but not &quot;abcABC&quot;, as the change of processing option does not affect the called subpattern:</source>
          <target state="translated">서브 패턴이 정의되면 대소 문자 독립성과 같은 처리 옵션이 고정되므로 서브 루틴으로 사용되는 경우 다른 호출에 대해 이러한 옵션을 변경할 수 없습니다. 예를 들어, 처리 옵션 변경이 호출 된 서브 패턴에 영향을주지 않으므로 다음 패턴은 &quot;abcabc&quot;와 일치하지만 &quot;abcABC&quot;와는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8cd404c23dee55e608769bb45175244d3e786e5" translate="yes" xml:space="preserve">
          <source>Produces &lt;code&gt;logger events&lt;/code&gt; on logger &lt;code&gt;level error&lt;/code&gt; under the hierarchical logger &lt;code&gt;domain:&lt;/code&gt;&lt;code&gt;[otp, inets, httpd, ServerID, error]&lt;/code&gt; The built in logger formatting function produces log entries from the error reports:</source>
          <target state="translated">생산 &lt;code&gt;logger events&lt;/code&gt; 로거에 &lt;code&gt;level error&lt;/code&gt; 계층 적 로거에서 &lt;code&gt;domain:&lt;/code&gt; &lt;code&gt;[otp, inets, httpd, ServerID, error]&lt;/code&gt; 로거 기능을 포맷에 내장 된 오류 보고서에서 로그 항목을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="0eab01ffe9a07f631f008bdf0c75bf332d75ff92" translate="yes" xml:space="preserve">
          <source>Produces a Makefile rule to track header dependencies. The rule is sent to &lt;code&gt;stdout&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">헤더 종속성을 추적하는 Makefile 규칙을 생성합니다. 규칙은 &lt;code&gt;stdout&lt;/code&gt; 으로 전송됩니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b0b65fd07934b92a1f3f3b16fdae0415377d8f3" translate="yes" xml:space="preserve">
          <source>Produces a Makefile rule to track headers dependencies. No object file is produced.</source>
          <target state="translated">헤더 종속성을 추적하는 Makefile 규칙을 생성합니다. 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="522655e258c4e569c30e0510cdca6d0699bc8809" translate="yes" xml:space="preserve">
          <source>Produces a list of miscellaneous information. Intended for debugging. If no profile is specified, the default profile is used.</source>
          <target state="translated">기타 정보 목록을 생성합니다. 디버깅을위한 것입니다. 프로파일을 지정하지 않으면 기본 프로파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17b15b2832a09a04ae3469c8eba4b0f7717aeed3" translate="yes" xml:space="preserve">
          <source>Produces a list of the entire cookie database. Intended for debugging/testing purposes. If no profile is specified, the default profile is used.</source>
          <target state="translated">전체 쿠키 데이터베이스의 목록을 생성합니다. 디버깅 / 테스트 목적으로 사용됩니다. 프로파일을 지정하지 않으면 기본 프로파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4a70cdd8befb25aae49184a69129ba10dc3026" translate="yes" xml:space="preserve">
          <source>Produces a listing of the assembler code in the file &lt;code&gt;&amp;lt;File&amp;gt;.S&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">&lt;code&gt;&amp;lt;File&amp;gt;.S&lt;/code&gt; 파일에 어셈블러 코드 목록을 생성합니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14a6e3657dbd240095b72afb45cd733b01f3e525" translate="yes" xml:space="preserve">
          <source>Produces a listing of the code, after all source code transformations have been performed, in the file &lt;code&gt;&amp;lt;File&amp;gt;.E&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">&lt;code&gt;&amp;lt;File&amp;gt;.E&lt;/code&gt; 파일에서 모든 소스 코드 변환이 수행 된 후 코드 목록을 생성합니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e05890546d0a6ddd75cdab592794da9dd67dbc" translate="yes" xml:space="preserve">
          <source>Produces a listing of the parsed code, after preprocessing and parse transforms, in the file &lt;code&gt;&amp;lt;File&amp;gt;.P&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">사전 처리 및 구문 분석 변환 후 &lt;code&gt;&amp;lt;File&amp;gt;.P&lt;/code&gt; 파일에서 구문 분석 된 코드의 목록을 생성합니다 . 오브젝트 파일이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b42942b44b3250eb3b2271073a1658bcb5331121" translate="yes" xml:space="preserve">
          <source>Produces a new map &lt;code&gt;Map&lt;/code&gt; by calling function &lt;code&gt;fun F(K, V1)&lt;/code&gt; for every &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V1&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun F/2&lt;/code&gt; must return value &lt;code&gt;V2&lt;/code&gt; to be associated with key &lt;code&gt;K&lt;/code&gt; for the new map &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">매 &lt;code&gt;K&lt;/code&gt; 마다 함수 &lt;code&gt;fun F(K, V1)&lt;/code&gt; 를 호출 하여 &lt;code&gt;MapOrIter&lt;/code&gt; 의 &lt;code&gt;V1&lt;/code&gt; 연관 을 어떤 순서 로든 호출 하여 새 맵 &lt;code&gt;Map&lt;/code&gt; 을 생성합니다 . 함수 &lt;code&gt;fun F/2&lt;/code&gt; 는 새 맵 &lt;code&gt;Map&lt;/code&gt; 의 키 &lt;code&gt;K&lt;/code&gt; 와 연관되도록 값 &lt;code&gt;V2&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b65baebfeee97894cc99c3e97f532ea2844c3dd7" translate="yes" xml:space="preserve">
          <source>Produces a new map &lt;code&gt;Map&lt;/code&gt; by calling function &lt;code&gt;fun F(Key, Value1)&lt;/code&gt; for every &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value1&lt;/code&gt; association in &lt;code&gt;MapOrIter&lt;/code&gt; in any order. Function &lt;code&gt;fun Fun/2&lt;/code&gt; must return value &lt;code&gt;Value2&lt;/code&gt; to be associated with key &lt;code&gt;Key&lt;/code&gt; for the new map &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">임의의 순서 로 &lt;code&gt;MapOrIter&lt;/code&gt; 의 모든 &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value1&lt;/code&gt; 연관에 대해 &lt;code&gt;fun F(Key, Value1)&lt;/code&gt; 함수를 호출 하여 새 맵 &lt;code&gt;Map&lt;/code&gt; 을 생성합니다 . Function &lt;code&gt;fun Fun/2&lt;/code&gt; 는 새 맵 &lt;code&gt;Map&lt;/code&gt; 에 대한 키 &lt;code&gt;Key&lt;/code&gt; 와 연관되도록 &lt;code&gt;Value2&lt;/code&gt; 값 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="734f2970d4a5791f19c5ec99de733cebe7c5db24" translate="yes" xml:space="preserve">
          <source>Produces a slightly processed dump of the session database. It is intended for debugging. If no profile is specified, the default profile is used.</source>
          <target state="translated">약간 처리 된 세션 데이터베이스 덤프를 생성합니다. 디버깅을위한 것입니다. 프로파일을 지정하지 않으면 기본 프로파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e2b5bef8d3aea29dc3d87dc03c8bd706ff3c63" translate="yes" xml:space="preserve">
          <source>Produces an Erlang binary object from a buffer containing a sequence of bytes.</source>
          <target state="translated">바이트 시퀀스를 포함하는 버퍼에서 Erlang 이진 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="28dc5d49200b0d0db7991c1bd65981ee7a79b5b9" translate="yes" xml:space="preserve">
          <source>Product identification, or similar.</source>
          <target state="translated">제품 식별 또는 유사</target>
        </trans-unit>
        <trans-unit id="47c4b8b7bf496f53b2cc4542ca4954138de2040e" translate="yes" xml:space="preserve">
          <source>Product-Name AVP</source>
          <target state="translated">제품 이름 AVP</target>
        </trans-unit>
        <trans-unit id="17df105acacb67dbb629858e9cd9d8d447c45b58" translate="yes" xml:space="preserve">
          <source>Profile :: atom()) -&amp;gt;</source>
          <target state="translated">프로필 :: atom ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0026a969a9cb473a3dd25bc732d4ff9709ac80a8" translate="yes" xml:space="preserve">
          <source>Profile :: term()) -&amp;gt;</source>
          <target state="translated">프로필 :: term ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="57c6e422edb8ce7e828dbfdc0ca3e7e40b6fc1e1" translate="yes" xml:space="preserve">
          <source>Profile process locks, equal to adding &lt;code&gt;process&lt;/code&gt; to the lock category mask; see &lt;code&gt;lcnt:rt_mask/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; 를 잠금 카테고리 마스크 에 추가하는 것과 동일한 프로세스 잠금 ; 참조 &lt;code&gt;lcnt:rt_mask/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f72795f752c26fa8b5758727320096204ecec91e" translate="yes" xml:space="preserve">
          <source>Profiling is done in the following steps:</source>
          <target state="translated">프로파일 링은 다음 단계에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="630e9fa5225f76b674631196640d8884476f77f0" translate="yes" xml:space="preserve">
          <source>Profiling is essentially done in 3 steps:</source>
          <target state="translated">프로파일 링은 기본적으로 3 단계로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="129873d7917621f62579cca8da507adfd58f5037" translate="yes" xml:space="preserve">
          <source>Profiling; the trace file is read and raw profile data is collected into an internal RAM storage on the node. During this step the trace data may be dumped in text format to file or console.</source>
          <target state="translated">프로파일 링; 추적 파일을 읽고 원시 프로파일 데이터가 노드의 내부 RAM 스토리지에 수집됩니다. 이 단계에서 추적 데이터는 텍스트 형식으로 파일 또는 콘솔에 덤프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="864662422fc6799b55caf37fed8419aea855ecf3" translate="yes" xml:space="preserve">
          <source>Profiling; the trace file is read, the execution call stack is simulated, and raw profile data is calculated from the simulated call stack and the trace timestamps. The profile data is stored in the &lt;code&gt;fprof&lt;/code&gt; server state. During this step the trace data may be dumped in text format to file or console.</source>
          <target state="translated">프로파일 링; 추적 파일을 읽고, 실행 호출 스택을 시뮬레이션하고, 원시 프로파일 데이터가 시뮬레이션 된 호출 스택 및 추적 타임 스탬프에서 계산됩니다. 프로필 데이터는 &lt;code&gt;fprof&lt;/code&gt; 서버 상태로 저장됩니다 . 이 단계에서 추적 데이터는 텍스트 형식으로 파일 또는 콘솔에 덤프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="2866921ef7dbac7fe5d0f0f9c3f43ccc11ffda6a" translate="yes" xml:space="preserve">
          <source>Program Explained</source>
          <target state="translated">프로그램 설명</target>
        </trans-unit>
        <trans-unit id="be14140f572829d13e013899b88b1a29c94a894b" translate="yes" xml:space="preserve">
          <source>Program used for starting Common Test from the OS command line.</source>
          <target state="translated">OS 명령 행에서 공통 테스트를 시작하는 데 사용되는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="04fc4ca4a8116882232b1856689a04eb18a1fd86" translate="yes" xml:space="preserve">
          <source>Programmers are strongly advised not to engage in parse transformations. No support is offered for problems encountered.</source>
          <target state="translated">프로그래머는 구문 분석 변환에 관여하지 않는 것이 좋습니다. 발생한 문제에 대한 지원은 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd20cc773cac79796c578e4d9775b5144b70f227" translate="yes" xml:space="preserve">
          <source>Programming Erlang: Software for a Concurrent World (2007), Pragmatic Bookshelf, ISBN13: 9781934356005.</source>
          <target state="translated">Erlang 프로그래밍 : 동시 세계를위한 소프트웨어 (2007), Pragmatic Bookshelf, ISBN13 : 9781934356005.</target>
        </trans-unit>
        <trans-unit id="04bef1b7e7ac277d38fb7b2086faa2a0ce21e478" translate="yes" xml:space="preserve">
          <source>Programming Erlang: Software for a Concurrent World by Joe Armstrong; ISBN: 978-1-93435-600-5</source>
          <target state="translated">프로그래밍 Erlang : Joe Armstrong의 동시 세계 용 소프트웨어; ISBN : 978-1-93435-600-5</target>
        </trans-unit>
        <trans-unit id="4fff5c0832402c080338f74960f55c82c6dba845" translate="yes" xml:space="preserve">
          <source>Programming concurrent Erlang systems is the subject of a separate book. However, it is worthwhile to draw attention to the following features, which permit concurrent processes to exist in a &lt;code&gt;Mnesia&lt;/code&gt; system:</source>
          <target state="translated">동시 Erlang 시스템 프로그래밍은 별도의 책의 주제입니다. 그러나 &lt;code&gt;Mnesia&lt;/code&gt; 시스템 에 동시 프로세스가 존재할 수 있도록 다음 기능에주의를 기울여야 합니다.</target>
        </trans-unit>
        <trans-unit id="a7ee4483c6941542c37358b60ce74e365d1f78dd" translate="yes" xml:space="preserve">
          <source>Programs should always operate on a normalized form and compare canonical-equivalent Unicode characters as equal. All characters should thus be normalized to one form once on the system borders. One of the following functions can convert characters to their normalized forms &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt; characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt; characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_list-1&quot;&gt; characters_to_nfd_list/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_binary-1&quot;&gt; characters_to_nfd_binary/1&lt;/a&gt;&lt;/code&gt;. For general text &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt; characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt; characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; is preferred, and for identifiers one of the compatibility normalization functions, such as &lt;code&gt;&lt;a href=&quot;#characters_to_nfkc_list-1&quot;&gt; characters_to_nfkc_list/1&lt;/a&gt;&lt;/code&gt;, is preferred for security reasons. The normalization functions where introduced in OTP 20. Additional information on normalization can be found in the &lt;code&gt;&lt;a href=&quot;http://unicode.org/faq/normalization.html&quot;&gt;Unicode FAQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로그램은 항상 정규화 된 형식으로 작동해야하며 표준에 해당하는 유니 코드 문자를 동일한 것으로 비교해야합니다. 따라서 모든 문자는 시스템 경계에서 한 번 하나의 형식으로 정규화되어야합니다. 다음 함수 중 하나는 문자를 정규화 된 형식 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt; characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt; characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_list-1&quot;&gt; characters_to_nfd_list/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_binary-1&quot;&gt; characters_to_nfd_binary/1&lt;/a&gt;&lt;/code&gt; 으로 변환 할 수 있습니다 . 일반 텍스트의 경우 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt; characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt; characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; 이 선호되고 식별자의 경우 &lt;code&gt;&lt;a href=&quot;#characters_to_nfkc_list-1&quot;&gt; characters_to_nfkc_list/1&lt;/a&gt;&lt;/code&gt; 과 같은 호환성 정규화 함수 중 하나가 선호됩니다., 보안상의 이유로 선호됩니다. OTP 20에 도입 된 정규화 기능. 정규화에 대한 추가 정보는 &lt;code&gt;&lt;a href=&quot;http://unicode.org/faq/normalization.html&quot;&gt;Unicode FAQ&lt;/a&gt;&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f766991f1e78a66d69e7e9b58e7feee18bce8c08" translate="yes" xml:space="preserve">
          <source>Programs should always operate on a normalized form and compare canonical-equivalent Unicode characters as equal. All characters should thus be normalized to one form once on the system borders. One of the following functions can convert characters to their normalized forms &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_list-1&quot;&gt;characters_to_nfd_list/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_binary-1&quot;&gt;characters_to_nfd_binary/1&lt;/a&gt;&lt;/code&gt;. For general text &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; is preferred, and for identifiers one of the compatibility normalization functions, such as &lt;code&gt;&lt;a href=&quot;#characters_to_nfkc_list-1&quot;&gt;characters_to_nfkc_list/1&lt;/a&gt;&lt;/code&gt;, is preferred for security reasons. The normalization functions where introduced in OTP 20. Additional information on normalization can be found in the &lt;code&gt;&lt;a href=&quot;http://unicode.org/faq/normalization.html&quot;&gt;Unicode FAQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로그램은 항상 정규화 된 형식으로 작동해야하며 동등한 동등한 유니 코드 문자를 비교해야합니다. 따라서 모든 문자는 시스템 경계에서 한 형태로 한 번만 정규화되어야합니다. 다음 함수 중 하나는 문자를 정규화 된 양식 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_list-1&quot;&gt;characters_to_nfd_list/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#characters_to_nfd_binary-1&quot;&gt;characters_to_nfd_binary/1&lt;/a&gt;&lt;/code&gt; 로 변환 할 수 있습니다 . 일반 텍스트 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_list-1&quot;&gt;characters_to_nfc_list/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#characters_to_nfc_binary-1&quot;&gt;characters_to_nfc_binary/1&lt;/a&gt;&lt;/code&gt; 이 선호되며 식별자의 경우 &lt;code&gt;&lt;a href=&quot;#characters_to_nfkc_list-1&quot;&gt;characters_to_nfkc_list/1&lt;/a&gt;&lt;/code&gt; 과 같은 호환성 정규화 함수 중 하나입니다.보안상의 이유로 선호됩니다. 정규화 기능은 OTP 20에 도입 된 기능입니다. 정규화에 대한 추가 정보는 &lt;code&gt;&lt;a href=&quot;http://unicode.org/faq/normalization.html&quot;&gt;Unicode FAQ&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc562a9bcac4fb874aa74077af2a891fe251b3ed" translate="yes" xml:space="preserve">
          <source>Programs that process plain text or binary data files.</source>
          <target state="translated">일반 텍스트 또는 이진 데이터 파일을 처리하는 프로그램.</target>
        </trans-unit>
        <trans-unit id="7c71281f9dbe691f92bb15faa53cb0c49a91d43a" translate="yes" xml:space="preserve">
          <source>Progress = &lt;code&gt;ignore | {CBModule, CBFunction, InitProgress}&lt;/code&gt;</source>
          <target state="translated">진행 = &lt;code&gt;ignore | {CBModule, CBFunction, InitProgress}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="519ffd1265424ff9151c74fa5631e9848160fa7a" translate="yes" xml:space="preserve">
          <source>Progress report</source>
          <target state="translated">진행 보고서</target>
        </trans-unit>
        <trans-unit id="a3f10a152d854770b6ab1de6f50d8a4da946dbb4" translate="yes" xml:space="preserve">
          <source>Progress reports are issued as &lt;code&gt;info&lt;/code&gt; level log events, and since the default primary log level is &lt;code&gt;notice&lt;/code&gt;, these are not logged by default. To enable printing of progress reports, set the &lt;code&gt;&lt;a href=&quot;#primary_level&quot;&gt;primary log level&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;info&lt;/code&gt;.</source>
          <target state="translated">진행률 보고서는 &lt;code&gt;info&lt;/code&gt; 레벨 로그 이벤트 로 발행되며 기본 1 차 로그 레벨이 &lt;code&gt;notice&lt;/code&gt; 이므로 기본적으로 로그 되지 않습니다. 진행률 보고서를 인쇄하려면 &lt;code&gt;&lt;a href=&quot;#primary_level&quot;&gt;primary log level&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;info&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d970e24b22fc0f6e277e6e1b9c10241b2293ff1" translate="yes" xml:space="preserve">
          <source>Prompting</source>
          <target state="translated">Prompting</target>
        </trans-unit>
        <trans-unit id="2feeef99e0f2d9657de9874ba0e75f9b066346ff" translate="yes" xml:space="preserve">
          <source>Propagate the same error signal to the links of the killed process.</source>
          <target state="translated">종료 된 프로세스의 링크에 동일한 오류 신호를 전파하십시오.</target>
        </trans-unit>
        <trans-unit id="5eb34826139e0a6c504423934bde097d38a8e5ac" translate="yes" xml:space="preserve">
          <source>Properties are not inherited from top-level groups to nested subgroups. For instance, in the previous example, the test cases in &lt;code&gt;group2&lt;/code&gt; are not executed in random order (which is the property of &lt;code&gt;group1&lt;/code&gt;).</source>
          <target state="translated">최상위 그룹에서 중첩 하위 그룹으로 속성이 상속되지 않습니다. 예를 들어, 이전 예제에서 &lt;code&gt;group2&lt;/code&gt; 의 테스트 케이스 는 무작위 순서 ( &lt;code&gt;group1&lt;/code&gt; 의 특성)로 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cf72435a6a8dfe264c2d8cbb64919ecfbaeba5bb" translate="yes" xml:space="preserve">
          <source>Property lists are ordinary lists containing entries in the form of either tuples, whose first elements are keys used for lookup and insertion, or atoms, which work as shorthand for tuples &lt;code&gt;{Atom, true}&lt;/code&gt;. (Other terms are allowed in the lists, but are ignored by this module.) If there is more than one entry in a list for a certain key, the first occurrence normally overrides any later (irrespective of the arity of the tuples).</source>
          <target state="translated">속성 목록은 첫 번째 요소가 조회 및 삽입에 사용되는 키인 튜플 또는 튜플 &lt;code&gt;{Atom, true}&lt;/code&gt; 속기 역할을하는 원자 형식의 항목을 포함하는 일반 목록 입니다. (다른 용어는 목록에서 허용되지만이 모듈에서는 무시됩니다.) 특정 키에 대한 목록에 둘 이상의 항목이있는 경우 첫 번째 항목은 일반적으로 이후에 우선합니다 (튜플의 특성에 관계없이).</target>
        </trans-unit>
        <trans-unit id="8f3a63f6f6853f3776df6fd40f512c3bc2423c62" translate="yes" xml:space="preserve">
          <source>Property lists are useful for representing inherited properties, such as options passed to a function where a user can specify options overriding the default settings, object properties, annotations, and so on.</source>
          <target state="translated">속성 목록은 사용자가 기본 설정, 객체 속성, 주석 등을 재정의하는 옵션을 지정할 수있는 함수에 전달 된 옵션과 같은 상속 된 속성을 나타내는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="69ef40d1cd2975594eba3c5b03a443daf8151c13" translate="yes" xml:space="preserve">
          <source>Protocol Errors</source>
          <target state="translated">프로토콜 오류</target>
        </trans-unit>
        <trans-unit id="1b0a81e8f360216134418545602ccf414662dde9" translate="yes" xml:space="preserve">
          <source>Protocol Messages</source>
          <target state="translated">프로토콜 메시지</target>
        </trans-unit>
        <trans-unit id="2e1b345b4778495a0a85f0806404f2ef32e5c47c" translate="yes" xml:space="preserve">
          <source>Protocol Overview</source>
          <target state="translated">프로토콜 개요</target>
        </trans-unit>
        <trans-unit id="a1a8787c51e4736d24c8977bdbdc2c59f887b0e9" translate="yes" xml:space="preserve">
          <source>Protocol operations in the NETCONF protocol are realized as remote procedure calls (RPCs) from client to server and a corresponding reply from server to client. RPCs are sent using like-named functions (eg. &lt;code&gt;&lt;a href=&quot;#edit_config-3&quot;&gt;edit_config/3-5&lt;/a&gt;&lt;/code&gt; to send an edit-config RPC), with the server reply as return value. There are functions for each RPC defined in RFC 6241 and the create-subscription RPC from RFC 5277, all of which are wrappers on &lt;code&gt;&lt;a href=&quot;#send_rpc-2&quot;&gt;send_rpc/2,3&lt;/a&gt;&lt;/code&gt;, that can be used to send an arbitrary RPC not defined in RFC 6241 or RFC 5277.</source>
          <target state="translated">NETCONF 프로토콜의 프로토콜 작업은 클라이언트에서 서버로의 원격 프로 시저 호출 (RPC)과 서버에서 클라이언트로의 해당 응답으로 실현됩니다. RPC는 같은 이름의 함수 (예 : edit-config RPC를 보내는 &lt;code&gt;&lt;a href=&quot;#edit_config-3&quot;&gt;edit_config/3-5&lt;/a&gt;&lt;/code&gt; ) 를 사용하여 전송되며, 서버 응답은 반환 값입니다. RFC 6241에 정의 된 각 RPC 및 RFC 5277의 구독 생성 RPC에 대한 함수가 있으며, 모두 &lt;code&gt;&lt;a href=&quot;#send_rpc-2&quot;&gt;send_rpc/2,3&lt;/a&gt;&lt;/code&gt; 의 래퍼 이며 RFC 6241 또는 RFC 5277에 정의되지 않은 임의의 RPC를 전송하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c07efc54af15e46ede9045b5a09cbf868ae19105" translate="yes" xml:space="preserve">
          <source>Prototypes for the driver callback routines can be found in the &lt;code&gt;erl_driver.h&lt;/code&gt; header file.</source>
          <target state="translated">드라이버 콜백 루틴의 프로토 타입은 &lt;code&gt;erl_driver.h&lt;/code&gt; 헤더 파일 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f653b51c616d14c355967d6de899534adb195231" translate="yes" xml:space="preserve">
          <source>Prototyping</source>
          <target state="translated">Prototyping</target>
        </trans-unit>
        <trans-unit id="1f374df4d309c019bc6178248783e9390656a10a" translate="yes" xml:space="preserve">
          <source>Provide a fun to implement your own logging of the SSH message SSH_MSG_DEBUG. The last three parameters are from the message, see &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4253#section-11.3&quot;&gt;RFC 4253, section 11.3&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;#type-connection_ref&quot;&gt;connection_ref()&lt;/a&gt;&lt;/code&gt; is the reference to the connection on which the message arrived. The return value from the fun is not checked.</source>
          <target state="translated">SSH 메시지 SSH_MSG_DEBUG에 대한 자체 로깅을 구현하는 재미를 제공하십시오. 마지막 3 개의 매개 변수는 메시지에서 온 것입니다 ( &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4253#section-11.3&quot;&gt;RFC 4253, section 11.3&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;#type-connection_ref&quot;&gt;connection_ref()&lt;/a&gt;&lt;/code&gt; 메시지가 도착한 연결에 대한 참조이다. 재미의 반환 값은 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08a2504f6114a9c36ec403b96c7c302a482e126f" translate="yes" xml:space="preserve">
          <source>Provide default headers for the HTTP servers responses. Note that this option may override built-in defaults.</source>
          <target state="translated">HTTP 서버 응답에 대한 기본 헤더를 제공하십시오. 이 옵션은 내장 기본값을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bca3403285a45fca5f582216c20e2b31fefe923" translate="yes" xml:space="preserve">
          <source>Provide some simple support for sequential tracing.</source>
          <target state="translated">순차 추적에 대한 간단한 지원을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="410239829c19fb6bb8f95e6437ab94a49a5db9bc" translate="yes" xml:space="preserve">
          <source>Provides a decryption key for &lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;config_file_chapter#encrypted_config_files&quot;&gt;encrypted configuration files&lt;/a&gt;&lt;/code&gt; 대한 암호 해독 키를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="903b44886dfe622745223d5547c0cc9c2859f2f6" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging or other action when an unexpected message arrives. If the fun returns &lt;code&gt;report&lt;/code&gt; the usual info report is issued but if &lt;code&gt;skip&lt;/code&gt; is returned no report is generated.</source>
          <target state="translated">예기치 않은 메시지가 도착했을 때 자신의 로깅 또는 기타 작업을 구현할 수있는 재미를 제공합니다. 재미가 &lt;code&gt;report&lt;/code&gt; 반환 하면 일반적인 정보 보고서가 발행되지만 &lt;code&gt;skip&lt;/code&gt; 가 반환 되면 보고서가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ffbd3b6dc47604871d65b5a79796a1a2da426e0" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging or other handling at disconnects.</source>
          <target state="translated">연결이 끊길 때 자신의 로깅 또는 기타 처리를 구현하는 재미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8122202de6a4acb088d775f3973da908d4fecce" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging when a user authenticates to the server.</source>
          <target state="translated">사용자가 서버에 인증 할 때 고유 한 로깅을 구현할 수있는 재미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6ae014fb7ce0d00946111ea1f6afbd515ba680d3" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging when a user fails to authenticate.</source>
          <target state="translated">사용자가 인증에 실패하면 자신의 로깅을 구현할 수있는 재미있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="693b50c9238225aebe1905f9a4bbeddbe802666a" translate="yes" xml:space="preserve">
          <source>Provides a fun to implement your own logging when the peer disconnects.</source>
          <target state="translated">피어 연결이 끊어졌을 때 사용자 고유의 로깅을 구현하는 재미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2622540d75e1ce825909c4c27dcf1a5e81b022b9" translate="yes" xml:space="preserve">
          <source>Provides a function for password validation. This could used for calling an external system or handeling passwords stored as hash values.</source>
          <target state="translated">비밀번호 유효성 검사 기능을 제공합니다. 이것은 외부 시스템을 호출하거나 해시 값으로 저장된 암호를 처리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b02519300dbb28165f9b31d399e480b06aff4a3e" translate="yes" xml:space="preserve">
          <source>Provides a function for password validation. This function is called with user and password as strings, and returns:</source>
          <target state="translated">비밀번호 유효성 검사 기능을 제공합니다. 이 함수는 사용자 및 비밀번호를 문자열로 사용하여 호출되며 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6aa5ff7905134531fc9760a2816fc0228545f5bd" translate="yes" xml:space="preserve">
          <source>Provides a function for tab-completion (expansion) like the Erlang shell. This function is called when the user presses the &lt;strong&gt;Tab&lt;/strong&gt; key. The expansion is active when calling line-reading functions, such as &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 쉘과 같은 탭 완성 (확장) 기능을 제공합니다. 이 기능은 사용자가 &lt;strong&gt;Tab&lt;/strong&gt; 키를 누를 때 호출됩니다 . &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 와 같은 행 읽기 기능을 호출 할 때 확장이 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="0126483ea757d9c456fac59884fa78b1895b0c1d" translate="yes" xml:space="preserve">
          <source>Provides a global password that authenticates any user.</source>
          <target state="translated">모든 사용자를 인증하는 글로벌 비밀번호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bcf2a440040f1adc832c9af437538a1274c09fbb" translate="yes" xml:space="preserve">
          <source>Provides a list of the scheme and their default port numbers supported (by default) by this utility.</source>
          <target state="translated">이 유틸리티가 지원하는 체계 및 기본 포트 번호 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e41ea94fc42949509a5e1ad43ddb8e3777a04f48" translate="yes" xml:space="preserve">
          <source>Provides a map with information about block_size, key_length, iv_length and possibly other properties of the cipher algorithm in question.</source>
          <target state="translated">block_size, key_length, iv_length 및 해당 암호 알고리즘의 기타 속성에 대한 정보가 포함 된 맵을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c4d6929e2e0f81130f02865c5e36545d49049a55" translate="yes" xml:space="preserve">
          <source>Provides a map with information about block_size, size and possibly other properties of the hash algorithm in question.</source>
          <target state="translated">문제의 해시 알고리즘의 block_size, 크기 및 기타 속성에 대한 정보가있는 맵을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="882538ba1337b4bc7c8a6a34a8a92a54495af42b" translate="yes" xml:space="preserve">
          <source>Provides a name for the NIF that is scheduled for execution. If it cannot be converted to an atom, &lt;code&gt;enif_schedule_nif&lt;/code&gt; returns a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">실행이 예정된 NIF의 이름을 제공합니다. 원자로 변환 할 수 없으면 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 는 &lt;code&gt;badarg&lt;/code&gt; 예외를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9a7fa191207bdbdcf1355b3abd90f2d61475ca15" translate="yes" xml:space="preserve">
          <source>Provides a password for password authentication. If this option is not given, the user is asked for a password, if the password authentication method is attempted.</source>
          <target state="translated">비밀번호 인증을위한 비밀번호를 제공합니다. 이 옵션을 지정하지 않으면 비밀번호 인증 방법을 시도 할 경우 사용자에게 비밀번호를 묻습니다.</target>
        </trans-unit>
        <trans-unit id="2e6245a80cc81adaed06ea9939826c09d6c8984a" translate="yes" xml:space="preserve">
          <source>Provides a way of filtering log events based on a &lt;code&gt;domain&lt;/code&gt; field in &lt;code&gt;Metadata&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Metadata&lt;/code&gt; 의 &lt;code&gt;domain&lt;/code&gt; 필드를 기반으로 로그 이벤트를 필터링하는 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="955f63ea342c9ccdf55e0b9ef1640dd09419b809" translate="yes" xml:space="preserve">
          <source>Provides a way of filtering log events based on the log level.</source>
          <target state="translated">로그 수준을 기반으로 로그 이벤트를 필터링하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="917a3a6ad732d2f5671eafaeed7176e9ef18f549" translate="yes" xml:space="preserve">
          <source>Provides access to the registry on Windows.</source>
          <target state="translated">Windows에서 레지스트리에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05ac5290f4045fe43f63e391afe9724d565253dd" translate="yes" xml:space="preserve">
          <source>Provides an Erlang interface to communicate with relational SQL-databases. It is built on top of Microsofts ODBC interface and therefore requires that you have an ODBC driver to the database that you want to connect to. The Erlang ODBC application is designed using the version 3.0 of the ODBC-standard, however using the option &lt;code&gt;{scrollable_cursors, off}&lt;/code&gt; for a connection has been known to make it work for at least some 2.X drivers.</source>
          <target state="translated">관계형 SQL 데이터베이스와 통신하기위한 Erlang 인터페이스를 제공합니다. Microsoft의 ODBC 인터페이스 위에 구축되므로 연결할 데이터베이스에 대한 ODBC 드라이버가 있어야합니다. Erlang ODBC 응용 프로그램은 ODBC 표준 버전 3.0을 사용하여 설계되었지만 연결에 대해 &lt;code&gt;{scrollable_cursors, off}&lt;/code&gt; 옵션을 사용하면 최소한 2.X 드라이버에서 작동하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="f79e1bbf3ee82741dfe60b12a6243392fa5cd563" translate="yes" xml:space="preserve">
          <source>Provides base64 encode and decode, see &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base64 인코딩 및 디코딩을 제공합니다 ( &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4e9af3af74f64719e08406feffc5d04267f3391b" translate="yes" xml:space="preserve">
          <source>Provides base64 encode and decode, see RFC 2045.</source>
          <target state="translated">base64 인코딩 및 디코딩을 제공합니다 (RFC 2045 참조).</target>
        </trans-unit>
        <trans-unit id="0767fcb9cf2d27bebf009a5c390e3880f87527f9" translate="yes" xml:space="preserve">
          <source>Provides extended diagnostics, use &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">확장 된 진단 기능을 제공합니다 &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1.&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e583caf4df904713adcce17bae909ffac9b6bbf8" translate="yes" xml:space="preserve">
          <source>Provides functions to handle public-key infrastructure, for details see &lt;code&gt;public_key(6)&lt;/code&gt;.</source>
          <target state="translated">공개 키 인프라를 처리하는 기능을 제공합니다. 자세한 내용은 &lt;code&gt;public_key(6)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b490ba126a125b5dbe6b1345ee3fd68b833fe2f" translate="yes" xml:space="preserve">
          <source>Provides information about the FIPS operating status of crypto and the underlying OpenSSL library. If crypto was built with FIPS support this can be either &lt;code&gt;enabled&lt;/code&gt; (when running in FIPS mode) or &lt;code&gt;not_enabled&lt;/code&gt;. For other builds this value is always &lt;code&gt;not_supported&lt;/code&gt;.</source>
          <target state="translated">암호화 및 기본 OpenSSL 라이브러리의 FIPS 작동 상태에 대한 정보를 제공합니다. 암호화가 FIPS 지원으로 빌드 된 경우이를 &lt;code&gt;enabled&lt;/code&gt; (FIPS 모드에서 실행할 때)하거나 &lt;code&gt;not_enabled&lt;/code&gt; 할 수 있습니다 . 다른 빌드의 경우이 값은 항상 &lt;code&gt;not_supported&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30dbaaafbb7e052ae711783e3f47a1722fb23cbb" translate="yes" xml:space="preserve">
          <source>Provides information about the FIPS operating status of crypto and the underlying libcrypto library. If crypto was built with FIPS support this can be either &lt;code&gt;enabled&lt;/code&gt; (when running in FIPS mode) or &lt;code&gt;not_enabled&lt;/code&gt;. For other builds this value is always &lt;code&gt;not_supported&lt;/code&gt;.</source>
          <target state="translated">crypto 및 기본 libcrypto 라이브러리의 FIPS 작동 상태에 대한 정보를 제공합니다. 암호화가 FIPS 지원으로 빌드 된 경우 &lt;code&gt;enabled&lt;/code&gt; (FIPS 모드에서 실행 중일 때) 또는 &lt;code&gt;not_enabled&lt;/code&gt; 를 사용할 수 있습니다 . 다른 빌드의 경우이 값은 항상 &lt;code&gt;not_supported&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e528ef223145dad4b73216f63054349090dcd33" translate="yes" xml:space="preserve">
          <source>Provides more control than the &lt;code&gt;load/2&lt;/code&gt;/&lt;code&gt;reload/2&lt;/code&gt; and &lt;code&gt;load_driver/2&lt;/code&gt;/&lt;code&gt;reload_driver/2&lt;/code&gt; interfaces. It never waits for completion of other operations related to the driver, but immediately returns the status of the driver as one of the following:</source>
          <target state="translated">&lt;code&gt;load/2&lt;/code&gt; / &lt;code&gt;reload/2&lt;/code&gt; 및 &lt;code&gt;load_driver/2&lt;/code&gt; / &lt;code&gt;reload_driver/2&lt;/code&gt; 인터페이스 보다 더 많은 제어 기능을 제공합니다 . 드라이버와 관련된 다른 작업이 완료 될 때까지 기다리지 않지만 다음 중 하나로 드라이버의 상태를 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15c9038fc5b1524a7c052b7a20860ee70d660228" translate="yes" xml:space="preserve">
          <source>Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords.</source>
          <target state="translated">비밀번호 인증을위한 비밀번호를 제공합니다. 암호는 누군가 서버에 연결하려고 시도하고 공개 키 사용자 인증에 실패한 경우에 사용됩니다. 이 옵션은 유효한 사용자 이름 및 해당 비밀번호 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b074a4910398fb49d04cfd408836de827bf0e394" translate="yes" xml:space="preserve">
          <source>Provides the flag &lt;code&gt;-boot&lt;/code&gt; specifying the boot file of the release version found (&lt;code&gt;&quot;releases/FIRST/start.boot&quot;&lt;/code&gt;).</source>
          <target state="translated">찾은 릴리스 버전의 부팅 파일 ( &lt;code&gt;&quot;releases/FIRST/start.boot&quot;&lt;/code&gt; )을 지정 하여 플래그 &lt;code&gt;-boot&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a72441e1164e80082373bf66638549573dc043ff" translate="yes" xml:space="preserve">
          <source>Provides the name and version of the libraries used by crypto.</source>
          <target state="translated">암호화에 사용되는 라이브러리의 이름과 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="77276a6c8bb030519317824295c69e75a13fdde9" translate="yes" xml:space="preserve">
          <source>Provides the username. If this option is not given, &lt;code&gt;ssh&lt;/code&gt; reads from the environment (&lt;code&gt;LOGNAME&lt;/code&gt; or &lt;code&gt;USER&lt;/code&gt; on UNIX, &lt;code&gt;USERNAME&lt;/code&gt; on Windows).</source>
          <target state="translated">사용자 이름을 제공합니다. 이 옵션을 지정하지 않으면 &lt;code&gt;ssh&lt;/code&gt; 가 환경에서 읽습니다 ( UNIX의 경우 &lt;code&gt;LOGNAME&lt;/code&gt; 또는 &lt;code&gt;USER&lt;/code&gt; , Windows의 경우 &lt;code&gt;USERNAME&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b09826e2df02ed043b8710bf898e2179004a2680" translate="yes" xml:space="preserve">
          <source>Provides your own CLI implementation in a daemon.</source>
          <target state="translated">데몬에서 고유 한 CLI 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6337706f6e77732d06ad836d88d60b82dd945341" translate="yes" xml:space="preserve">
          <source>Proxy Agents</source>
          <target state="translated">프록시 에이전트</target>
        </trans-unit>
        <trans-unit id="a7d3fe08253cdc3ad07d2f5dabfe674d1aa52bd9" translate="yes" xml:space="preserve">
          <source>Proxy-Host AVP</source>
          <target state="translated">프록시 호스트 AVP</target>
        </trans-unit>
        <trans-unit id="aaa9a1afcf35a6a510bb9543bf0d6f52952fb297" translate="yes" xml:space="preserve">
          <source>Proxy-Info AVP</source>
          <target state="translated">프록시 정보 AVP</target>
        </trans-unit>
        <trans-unit id="64812682c3ee84678a9b41d9cc2b26f19b76cc5c" translate="yes" xml:space="preserve">
          <source>Proxy-State AVP</source>
          <target state="translated">프록시 상태 AVP</target>
        </trans-unit>
        <trans-unit id="40db0b3883f06edc9792ae47fe2fd8fc1148af25" translate="yes" xml:space="preserve">
          <source>Psalter_Pahlavi</source>
          <target state="translated">Psalter_Pahlavi</target>
        </trans-unit>
        <trans-unit id="d0fdfc27d15a90f7600623009abb8fe006b3ef96" translate="yes" xml:space="preserve">
          <source>Pseudo function that by a &lt;code&gt;parse_transform&lt;/code&gt; translates &lt;code&gt;LiteralFun&lt;/code&gt; typed as parameter in the function call to a &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt;. With &quot;literal&quot; is meant that the fun must textually be written as the parameter of the function, it cannot be held in a variable that in turn is passed to the function.</source>
          <target state="translated">a로한다는 의사 기능 &lt;code&gt;parse_transform&lt;/code&gt; 가 번역 &lt;code&gt;LiteralFun&lt;/code&gt; 는 A와 함수 호출에서 매개 변수로 입력 한 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; . &quot;리터럴&quot;이란 재미는 문자 적으로 함수의 매개 변수로 텍스트로 작성되어야 함을 의미하며, 함수에 전달되는 변수에 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b76821618a6e81543a9111bbe440dd93c8037696" translate="yes" xml:space="preserve">
          <source>Pseudo function that by means of a &lt;code&gt;parse_transform&lt;/code&gt; translates the &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;fun()&lt;/code&gt; typed as parameter in the function call to a match specification as described in the &lt;code&gt;match_spec&lt;/code&gt; manual of ERTS users guide. (with literal I mean that the &lt;code&gt;fun()&lt;/code&gt; needs to textually be written as the parameter of the function, it cannot be held in a variable which in turn is passed to the function).</source>
          <target state="translated">&lt;code&gt;parse_transform&lt;/code&gt; 을 통해 함수 호출에서 매개 변수로 입력 된 &lt;strong&gt;리터럴 &lt;/strong&gt; &lt;code&gt;fun()&lt;/code&gt; 을 ERTS 사용자 안내서 의 &lt;code&gt;match_spec&lt;/code&gt; 매뉴얼에 설명 된대로 일치 스펙으로 변환하는 의사 함수 . (리터럴을 사용하면 &lt;code&gt;fun()&lt;/code&gt; 이 텍스트로 함수의 매개 변수로 텍스트로 작성되어야하며 함수에 전달되는 변수에 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad66a675910e9dc1b80a46c98524572b8db0801a" translate="yes" xml:space="preserve">
          <source>Pseudo random number generation.</source>
          <target state="translated">의사 난수 생성.</target>
        </trans-unit>
        <trans-unit id="3d62ca4c64f68f59f57794d1a577fae252d0de3d" translate="yes" xml:space="preserve">
          <source>Pseudo-random number generation.</source>
          <target state="translated">의사 난수 생성.</target>
        </trans-unit>
        <trans-unit id="c20825441684d87fd2029a194a2fa7c884903fe5" translate="yes" xml:space="preserve">
          <source>Public Key Ciphers</source>
          <target state="translated">공개 키 암호</target>
        </trans-unit>
        <trans-unit id="336ac16c89226b0af6be05bedd8e39d0d89d2481" translate="yes" xml:space="preserve">
          <source>Public Key Sign and Verify</source>
          <target state="translated">공개 키 서명 및 확인</target>
        </trans-unit>
        <trans-unit id="a70714540366d8fae2fe06e39149c6abe313d018" translate="yes" xml:space="preserve">
          <source>Public key authentication in Erlang SSH</source>
          <target state="translated">Erlang SSH의 공개 키 인증</target>
        </trans-unit>
        <trans-unit id="c98572a8cdc44f29acd6d9bafcc787680c0311e9" translate="yes" xml:space="preserve">
          <source>Public-key data (keys, certificates, and so on) can be stored in Privacy Enhanced Mail (PEM) format. The PEM files have the following structure:</source>
          <target state="translated">공개 키 데이터 (키, 인증서 등)는 PEM (Privacy Enhanced Mail) 형식으로 저장할 수 있습니다. PEM 파일의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af9d874c62240cf5f3756c1a09f53a1acbbe30fb" translate="yes" xml:space="preserve">
          <source>Public-key decryption using the private key. See also &lt;code&gt;crypto:private_decrypt/4&lt;/code&gt;</source>
          <target state="translated">개인 키를 사용한 공개 키 암호 해독 &lt;code&gt;crypto:private_decrypt/4&lt;/code&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="0d0b4eff2289312e196864ad9ede672c54ac16fd" translate="yes" xml:space="preserve">
          <source>Public-key decryption using the public key. See also &lt;code&gt;crypto:public_decrypt/4&lt;/code&gt;</source>
          <target state="translated">공개 키를 사용한 공개 키 암호 해독 &lt;code&gt;crypto:public_decrypt/4&lt;/code&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="1c9a6fa031fc4d41c5bb997e94e3205b5bde379c" translate="yes" xml:space="preserve">
          <source>Public-key encryption using the private key. See also &lt;code&gt;crypto:private_encrypt/4&lt;/code&gt;.</source>
          <target state="translated">개인 키를 사용하는 공개 키 암호화 &lt;code&gt;crypto:private_encrypt/4&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b474ab2cacf9c0bf60c2569f1a89c4cf597b125c" translate="yes" xml:space="preserve">
          <source>Public-key encryption using the public key. See also &lt;code&gt;crypto:public_encrypt/4&lt;/code&gt;.</source>
          <target state="translated">공개 키를 사용한 공개 키 암호화 &lt;code&gt;crypto:public_encrypt/4&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2af20711419a0ca72d8212bc8c208e78e4545388" translate="yes" xml:space="preserve">
          <source>Public/Private Keys</source>
          <target state="translated">공개 / 개인 키</target>
        </trans-unit>
        <trans-unit id="7681fa099c677c9c3bef9e3f7267e6ecaf959e64" translate="yes" xml:space="preserve">
          <source>PublicKey :: &lt;code&gt;public_key:public_key()&lt;/code&gt;,</source>
          <target state="translated">PublicKey :: &lt;code&gt;public_key:public_key()&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="68fc7bd4bc44e3818645b5f17ee1089ffb95b680" translate="yes" xml:space="preserve">
          <source>Punctuation</source>
          <target state="translated">Punctuation</target>
        </trans-unit>
        <trans-unit id="9a2f2d19b27f34b47025e9233d9cd866b4bd3b4e" translate="yes" xml:space="preserve">
          <source>Punctuation character</source>
          <target state="translated">문장 부호 문자</target>
        </trans-unit>
        <trans-unit id="82792519d207c87b83fb05059a79c1df3520b2eb" translate="yes" xml:space="preserve">
          <source>Punctuation characters</source>
          <target state="translated">문장 부호 문자</target>
        </trans-unit>
        <trans-unit id="0438651b1551394f1e2bbfd8ad53fbbf577875d4" translate="yes" xml:space="preserve">
          <source>Punctuation space</source>
          <target state="translated">문장 부호 공간</target>
        </trans-unit>
        <trans-unit id="f4845e6e07d3e7c50eaf916600cc5ee92c07d965" translate="yes" xml:space="preserve">
          <source>Purges and loads, or reloads, a module by calling &lt;code&gt;code:purge(Module)&lt;/code&gt; followed by &lt;code&gt;code:load_file(Module)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;code:purge(Module)&lt;/code&gt; 다음에 &lt;code&gt;code:load_file(Module)&lt;/code&gt; 을 호출하여 모듈을 제거 및로드하거나 다시로드 합니다.</target>
        </trans-unit>
        <trans-unit id="2a530eeffee5c0860d74ab29d23d89f4632d5774" translate="yes" xml:space="preserve">
          <source>Purges each module &lt;code&gt;Mod&lt;/code&gt;, that is, removes the old code. Notice that any process executing purged code is killed.</source>
          <target state="translated">각 모듈 &lt;code&gt;Mod&lt;/code&gt; 를 제거합니다. 즉, 이전 코드를 제거합니다. 제거 된 코드를 실행하는 모든 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="3fdb75c711668c4160644fd3a6e8e5aebaaf8245" translate="yes" xml:space="preserve">
          <source>Purges the code for &lt;code&gt;Module&lt;/code&gt;, that is, removes code marked as old, but only if no processes linger in it.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 코드를 제거합니다 . 즉, 이전으로 표시된 코드를 제거하지만 프로세스가 남아 있지 않은 경우에만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3d8198c900f27b7b2a03e448756c517424e92bed" translate="yes" xml:space="preserve">
          <source>Purges the code for &lt;code&gt;Module&lt;/code&gt;, that is, removes code marked as old. If some processes still linger in the old code, these processes are killed before the code is removed.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 코드를 제거합니다 . 즉, 이전으로 표시된 코드를 제거합니다. 일부 프로세스가 여전히 이전 코드에 남아 있으면 코드를 제거하기 전에 이러한 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdaf8c1d6cdda09ba5cdf41daf294b6c9ed7786" translate="yes" xml:space="preserve">
          <source>Purists may argue that this should be modelled with a separate state machine that sends pre-processed events to the main state machine, but to decrease overhead the small pre-processing state machine can be implemented in the common state event handling of the main state machine using a few state data variables that then sends the pre-processed events as internal events to the main state machine. Using internal events also can make it easier to synchronize the state machines.</source>
          <target state="translated">순수 주의자들은 이것이 전처리 된 이벤트를 주 상태 머신으로 보내는 별도의 상태 머신으로 모델링되어야한다고 주장 할 수 있지만, 오버 헤드를 줄이기 위해 소형 전처리 상태 머신은 메인 상태 머신의 공통 상태 이벤트 처리에서 구현 될 수 있습니다 몇 가지 상태 데이터 변수를 사용하여 사전 처리 된 이벤트를 내부 이벤트로 기본 상태 머신에 보냅니다. 내부 이벤트를 사용하면 상태 시스템을보다 쉽게 ​​동기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89ea6fdb33fc3dacfafa57a13cd28cd1e7ef36c9" translate="yes" xml:space="preserve">
          <source>Push the current &lt;strong&gt;callback module&lt;/strong&gt; to the top of an internal stack of callback modules and set the new &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; for the running server. Otherwise like &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; above.</source>
          <target state="translated">현재 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 을 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 의 내부 스택 맨 위로 푸시하고 실행중인 서버에 대한 새 &lt;code&gt;&lt;a href=&quot;#Callback%20Module&quot;&gt; &lt;strong&gt;callback module&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; 을 설정 합니다. 그렇지 않으면 위의 &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; 과 같습니다 . &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21d0557e3f9ecb76a229545c8585bdf38a2980a1" translate="yes" xml:space="preserve">
          <source>Pushes the current callback module to the top of an internal stack of callback modules and changes the callback module to &lt;code&gt;NewModule&lt;/code&gt;. Otherwise like &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; above.</source>
          <target state="translated">현재 콜백 모듈을 콜백 모듈의 내부 스택 맨 위로 푸시하고 콜백 모듈을 &lt;code&gt;NewModule&lt;/code&gt; 로 변경합니다 . 그렇지 않으면 위의 &lt;code&gt;{change_callback_module, NewModule}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="10c01ec6868afc102597a3ed42373e9470221d26" translate="yes" xml:space="preserve">
          <source>Pushing back characters gives you unexpected possibilities to cause the scanner to loop!</source>
          <target state="translated">문자를 뒤로 밀면 스캐너가 루프 될 수있는 예상치 못한 가능성이 있습니다!</target>
        </trans-unit>
        <trans-unit id="4fe937319833d21c895af7373098e512f06998b1" translate="yes" xml:space="preserve">
          <source>Put the marker on a function name and double click to go to the definition of the function. If the function is defined in another module, that module will be loaded and added to the page list.</source>
          <target state="translated">함수 이름에 마커를 놓고 두 번 클릭하여 함수 정의로 이동하십시오. 함수가 다른 모듈에 정의되어 있으면 해당 모듈이로드되어 페이지 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5c334594f2e0d971a5e8ed41a49b4ac58e9cff76" translate="yes" xml:space="preserve">
          <source>Put their names in the association file.</source>
          <target state="translated">이름을 연관 파일에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="267984807457cef8b61168f668ee488edeae227f" translate="yes" xml:space="preserve">
          <source>Puts data at the head of the driver queue. The data in &lt;code&gt;buf&lt;/code&gt; is copied (&lt;code&gt;len&lt;/code&gt; bytes) and placed at the beginning of the queue.</source>
          <target state="translated">드라이버 큐의 헤드에 데이터를 넣습니다. &lt;code&gt;buf&lt;/code&gt; 의 데이터 가 복사되고 ( &lt;code&gt;len&lt;/code&gt; 바이트) 큐의 시작 부분에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="9e27e158ac5c5a01e234c267f7eda9d6f033aceb" translate="yes" xml:space="preserve">
          <source>Puts data in the binary &lt;code&gt;bin&lt;/code&gt;, at &lt;code&gt;offset&lt;/code&gt; with length &lt;code&gt;len&lt;/code&gt; at the head of the driver queue. It is most often faster than &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt;, because no data must be copied.</source>
          <target state="translated">이진 데이터에두고 &lt;code&gt;bin&lt;/code&gt; 에서 &lt;code&gt;offset&lt;/code&gt; 길이 &lt;code&gt;len&lt;/code&gt; 드라이버 큐의 헤드. 데이터를 복사 할 필요가 없으므로 &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="35a65ec39446238a0a0eac9475e71d6cef8cf751" translate="yes" xml:space="preserve">
          <source>Puts the Erlang term &lt;code&gt;TraceInfo&lt;/code&gt; into the sequential trace output if the calling process currently is executing within a sequential trace and the &lt;code&gt;print&lt;/code&gt; flag of the trace token is set.</source>
          <target state="translated">호출 프로세스가 현재 순차 추적 내에서 실행 중이고 추적 토큰 의 &lt;code&gt;print&lt;/code&gt; 플래그가 설정된 경우 Erlang 용어 &lt;code&gt;TraceInfo&lt;/code&gt; 를 순차 추적 출력에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="042a67e13942247a8e41ae9098af6d0aa9580018" translate="yes" xml:space="preserve">
          <source>Puts the calling process into a wait state where its memory allocation has been reduced as much as possible. This is useful if the process does not expect to receive any messages soon.</source>
          <target state="translated">호출 프로세스를 메모리 할당이 가능한 한 감소 된 대기 상태로 만듭니다. 프로세스가 메시지를 곧받을 것으로 예상되지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d013f0295b6c01c558d00c5ba53aca86377c9dd9" translate="yes" xml:space="preserve">
          <source>Puts the data in &lt;code&gt;ev&lt;/code&gt;, skipping the first &lt;code&gt;skip&lt;/code&gt; bytes of it, at the head of the driver queue. It is faster than &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt;, because no data must be copied.</source>
          <target state="translated">드라이버 큐의 헤드에서 데이터 의 첫 번째 &lt;code&gt;skip&lt;/code&gt; 바이트를 건너 뛰고 &lt;code&gt;ev&lt;/code&gt; 에 데이터 를 넣습니다. 데이터를 복사 할 필요가 없으므로 &lt;code&gt;&lt;a href=&quot;#driver_pushq&quot;&gt;driver_pushq&lt;/a&gt;&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="0e3da342d32b71066e0ff7598d5155af43136f49" translate="yes" xml:space="preserve">
          <source>Pythagorean triplets are sets of integers &lt;code&gt;{A,B,C}&lt;/code&gt; such that &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt;.</source>
          <target state="translated">피타고라스 수는 정수의 집합 인 &lt;code&gt;{A,B,C}&lt;/code&gt; 되도록 &lt;code&gt;A**2 + B**2 = C**2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbdad7e832388f477b308e785e461d43f185fd4b" translate="yes" xml:space="preserve">
          <source>Q: Can I build something that looks exactly as the commercial release?</source>
          <target state="translated">Q : 상용 릴리스와 똑같이 보이는 것을 만들 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9c33e934c4ed63e98eb95622daa029fee8f2aee2" translate="yes" xml:space="preserve">
          <source>Q: Can you help me setup X in Cygwin/MSYS/MSYS2?</source>
          <target state="translated">Q : Cygwin / MSYS / MSYS2에서 X 설정을 도와 줄 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2a92f9f3084b89244941d6f295251370a4ed363a" translate="yes" xml:space="preserve">
          <source>Q: Can/will I build a Cygwin binary with the procedure you describe?</source>
          <target state="translated">Q : 설명하는 절차에 따라 Cygwin 바이너리를 구축 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8fdbaf479bc8188c169196a96796d9e462c3fb1f" translate="yes" xml:space="preserve">
          <source>Q: Hah, I saw you, you used GCC even though you said you didn't!</source>
          <target state="translated">Q : Hah, 나는 당신을 보았습니다, 당신은 당신이하지 않았다고 말했지만 GCC를 사용했습니다!</target>
        </trans-unit>
        <trans-unit id="4d33d2562fd29f6e1c9fc76d264215b3d5aeeca3" translate="yes" xml:space="preserve">
          <source>Q: OK, you need VC++, but now you've started to demand a quite recent (and expensive) version of Visual Studio. Why?</source>
          <target state="translated">Q : 좋습니다. VC ++가 필요하지만 이제는 최신 (그리고 비싼) 버전의 Visual Studio를 요구하기 시작했습니다. 왜?</target>
        </trans-unit>
        <trans-unit id="5fa7db24f83822063f97229323a06aa3a0877f5d" translate="yes" xml:space="preserve">
          <source>Q: So how does it all work then?</source>
          <target state="translated">Q : 그렇다면 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="4848dd0945c44e751b1591373d20f6801c1998a4" translate="yes" xml:space="preserve">
          <source>Q: So now there's a MS VC++ project file somewhere and I can build OTP using the nifty VC++ GUI?</source>
          <target state="translated">Q : 이제 어딘가에 MS VC ++ 프로젝트 파일이 있는데 멋진 VC ++ GUI를 사용하여 OTP를 빌드 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="7beb25dc53e0563d452b76025a13d007739f049b" translate="yes" xml:space="preserve">
          <source>Q: So, now I can build Erlang using GCC on Windows?</source>
          <target state="translated">Q : 이제 Windows에서 GCC를 사용하여 Erlang을 빌드 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1f93ee200a556071dcfd3098474bd38969c35084" translate="yes" xml:space="preserve">
          <source>Q: Which version of Cygwin/MSYS/MSYS2 and other tools do you use then?</source>
          <target state="translated">Q : 어떤 버전의 Cygwin / MSYS / MSYS2 및 기타 도구를 사용하십니까?</target>
        </trans-unit>
        <trans-unit id="8891a2f89f4aba3906b6429931ac38fc100643aa" translate="yes" xml:space="preserve">
          <source>Q: Which version of WSL and other tools do you use then?</source>
          <target state="translated">Q : 그렇다면 어떤 버전의 WSL 및 기타 도구를 사용하십니까?</target>
        </trans-unit>
        <trans-unit id="3824ecc6208efe4bfe24a674a751c9d0ca079f07" translate="yes" xml:space="preserve">
          <source>Q: Why haven't you got rid of VC++ then, you ******?</source>
          <target state="translated">Q : 왜 VC ++를 없애지 않았습니까, ******?</target>
        </trans-unit>
        <trans-unit id="cb20cfbdc096ea44ab338185d58c6e58b37996ba" translate="yes" xml:space="preserve">
          <source>Q: You use and need Cygwin, but then you haven't taken the time to port Erlang to the Cygwin environment but instead focus on your commercial release, is that really ethical?</source>
          <target state="translated">Q : Cygwin을 사용하고 필요하지만 Erlang을 Cygwin 환경으로 포팅하는 데 시간이 걸리지 않고 대신 상용 릴리스에 집중하는 것이 정말 윤리적인가?</target>
        </trans-unit>
        <trans-unit id="ab248038951d6f5bbf2e6b69cbcd23902b8c49b9" translate="yes" xml:space="preserve">
          <source>QLC</source>
          <target state="translated">QLC</target>
        </trans-unit>
        <trans-unit id="44b991a394914f0303f96d96a457d83497af8f65" translate="yes" xml:space="preserve">
          <source>QLC can be used as a database programming language for Mnesia. It includes a notation called &quot;list comprehensions&quot; and can be used to make complex database queries over a set of tables.</source>
          <target state="translated">QLC는 Mnesia의 데이터베이스 프로그래밍 언어로 사용될 수 있습니다. 여기에는 &quot;목록 이해&quot;라는 표기법이 포함되며 일련의 테이블에 대해 복잡한 데이터베이스 쿼리를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b344639b609596306bc487c87eb37bfda190216" translate="yes" xml:space="preserve">
          <source>QLC can optimize the query compiler for the Mnesia DBMS, essentially making the DBMS more efficient.</source>
          <target state="translated">QLC는 Mnesia DBMS에 대한 쿼리 컴파일러를 최적화하여 기본적으로 DBMS를보다 효율적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5d2d92876611f40bde581d69101f8fddd8c14363" translate="yes" xml:space="preserve">
          <source>QLC queries can also be used to search &lt;code&gt;Mnesia&lt;/code&gt; tables. By using the function &lt;code&gt;&lt;a href=&quot;mnesia#table-1&quot;&gt;mnesia:table/[1|2]&lt;/a&gt;&lt;/code&gt; as the generator inside a QLC query, you let the query operate on a &lt;code&gt;Mnesia&lt;/code&gt; table. &lt;code&gt;Mnesia&lt;/code&gt;-specific options to &lt;code&gt;mnesia:table/2&lt;/code&gt; are &lt;code&gt;{lock, Lock}&lt;/code&gt;, &lt;code&gt;{n_objects,Integer}&lt;/code&gt;, and &lt;code&gt;{traverse, SelMethod}&lt;/code&gt;:</source>
          <target state="translated">QLC 쿼리를 사용하여 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 을 검색 할 수도 있습니다 . &lt;code&gt;&lt;a href=&quot;mnesia#table-1&quot;&gt;mnesia:table/[1|2]&lt;/a&gt;&lt;/code&gt; 함수를 QLC 쿼리 내부의 생성기로 사용하면 쿼리가 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에서 작동하게 할 수 있습니다 . &lt;code&gt;Mnesia&lt;/code&gt; &lt;code&gt;mnesia:table/2&lt;/code&gt; 대한 Mnesia 관련 옵션 은 &lt;code&gt;{lock, Lock}&lt;/code&gt; , &lt;code&gt;{n_objects,Integer}&lt;/code&gt; 및 &lt;code&gt;{traverse, SelMethod}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2442c21b812ded9c8602b0eb848411eef6d3f41" translate="yes" xml:space="preserve">
          <source>QLC queries can be performed in all these activity contexts (&lt;code&gt;transaction&lt;/code&gt;, &lt;code&gt;sync_transaction&lt;/code&gt;, &lt;code&gt;async_dirty&lt;/code&gt;, &lt;code&gt;sync_dirty&lt;/code&gt;, and &lt;code&gt;ets&lt;/code&gt;). The &lt;code&gt;ets&lt;/code&gt; activity only works if the table has no indexes.</source>
          <target state="translated">QLC 쿼리는 이러한 모든 활동 컨텍스트 ( &lt;code&gt;transaction&lt;/code&gt; , &lt;code&gt;sync_transaction&lt;/code&gt; , &lt;code&gt;async_dirty&lt;/code&gt; , &lt;code&gt;sync_dirty&lt;/code&gt; 및 &lt;code&gt;ets&lt;/code&gt; ) 에서 수행 될 수 있습니다 . &lt;code&gt;ets&lt;/code&gt; 테이블에는 인덱스가없는 경우 활동에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6fdde551c1ae8e6fe45e078d55ddb3f31ce7e09a" translate="yes" xml:space="preserve">
          <source>QLCs are convenient for stating constraints on data from two or more tables. The following example does a natural join on two query handles on position 2:</source>
          <target state="translated">QLC는 둘 이상의 테이블의 데이터에 대한 제한 조건을 설명하는 데 편리합니다. 다음 예제는 위치 2의 두 쿼리 핸들에서 자연 결합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2fb1858154779be9095d34bc86481decea9864b5" translate="yes" xml:space="preserve">
          <source>Qualifiers</source>
          <target state="translated">Qualifiers</target>
        </trans-unit>
        <trans-unit id="28177dc15b26c0a74159857924b18e3df0638648" translate="yes" xml:space="preserve">
          <source>Queries can be sent to the master to determine which node will have the least load.</source>
          <target state="translated">쿼리를 마스터로 보내서로드가 가장 적은 노드를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594265df0f504d11dc7e03fde007c6624ca2cfba" translate="yes" xml:space="preserve">
          <source>Queries the database to find out the ODBC data types of the columns of the table &lt;code&gt;Table&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 테이블을 조회하여 &lt;code&gt;Table&lt;/code&gt; 테이블 열의 ODBC 데이터 유형을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="2412c764d41ab6b9791a2250b7102a18362506f7" translate="yes" xml:space="preserve">
          <source>Query ::= Statement&lt;code&gt;,&lt;/code&gt; ...</source>
          <target state="translated">쿼리 :: = 문 &lt;code&gt;,&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="c162938e377e38115dc3cedfcf24cb92df1d737c" translate="yes" xml:space="preserve">
          <source>Query List Comprehension (QLC) can be used with Mnesia to produce specialized functions that enhance the operational ability of Mnesia. QLC has its own documentation as part of the OTP documentation set. The main features of QLC when used with Mnesia are as follows:</source>
          <target state="translated">QLC (Query List Comprehension)는 Mnesia와 함께 사용하여 Mnesia의 작동 능력을 향상시키는 특수 기능을 생성 할 수 있습니다. QLC에는 OTP 문서 세트의 일부로 자체 문서가 있습니다. Mnesia와 함께 사용되는 QLC의 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d6e12fb5478de8f3fa8e6c09b0ca1974dd2631e" translate="yes" xml:space="preserve">
          <source>Query interface</source>
          <target state="translated">쿼리 인터페이스</target>
        </trans-unit>
        <trans-unit id="c1792a32d0b77c434cdc1e30d03076a0c0097b22" translate="yes" xml:space="preserve">
          <source>Query interface to Mnesia, ETS, Dets, and so on.</source>
          <target state="translated">Mnesia, ETS, Dets 등에 대한 쿼리 인터페이스.</target>
        </trans-unit>
        <trans-unit id="966933c9d4fe3603343d28156ae1dd639fce4546" translate="yes" xml:space="preserve">
          <source>Queues are double-ended. The mental picture of a queue is a line of people (items) waiting for their turn. The queue front is the end with the item that has waited the longest. The queue rear is the end an item enters when it starts to wait. If instead using the mental picture of a list, the front is called head and the rear is called tail.</source>
          <target state="translated">대기열이 두 번 끝났습니다. 줄의 정신 그림은 사람들의 차례를 기다리는 사람들 (항목)입니다. 대기열 앞쪽은 가장 오래 기다린 항목의 끝입니다. 대기열 뒷면은 항목이 대기하기 시작할 때 입력되는 끝입니다. 대신 목록의 정신 그림을 사용하는 경우 앞면을 머리라고하고 뒷면을 꼬리라고합니다.</target>
        </trans-unit>
        <trans-unit id="a20596c790f832b98307345d7e29739a19f1b37f" translate="yes" xml:space="preserve">
          <source>Quits Erlang. Notice that this option is disabled if Erlang is started with the ignore break, &lt;code&gt;+Bi&lt;/code&gt;, system flag (which can be useful, for example when running a restricted shell, see the next section).</source>
          <target state="translated">Erlang을 종료합니다. Erlang이 시스템 브레이크 플래그 인 ignore break &lt;code&gt;+Bi&lt;/code&gt; 로 시작되면이 옵션이 비활성화됩니다 (예 : 제한된 쉘을 실행할 때 유용 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="9e0e35667c233db47de30256c67c29187c2127da" translate="yes" xml:space="preserve">
          <source>RAM memory of 96 MB is recommended to run OTP on Windows NT. A system with less than 64 MB of RAM is not recommended.</source>
          <target state="translated">Windows NT에서 OTP를 실행하려면 96MB의 RAM 메모리가 권장됩니다. RAM이 64MB 미만인 시스템은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="e243ff0db6962f2860f9daeb7b76706585f6a228" translate="yes" xml:space="preserve">
          <source>RFC 1350, The TFTP Protocol (revision 2)</source>
          <target state="translated">RFC 1350, TFTP 프로토콜 (개정 2)</target>
        </trans-unit>
        <trans-unit id="1dce0d83a131f276794188635a3dd2c84e8c7eb2" translate="yes" xml:space="preserve">
          <source>RFC 2347, TFTP Option Extension</source>
          <target state="translated">RFC 2347, TFTP 옵션 확장</target>
        </trans-unit>
        <trans-unit id="bbc82bb105613050636fa25569250ca1eee846e0" translate="yes" xml:space="preserve">
          <source>RFC 2348, TFTP Blocksize Option</source>
          <target state="translated">RFC 2348, TFTP 블록 크기 옵션</target>
        </trans-unit>
        <trans-unit id="58b78666477f6c30faf4308df7d8a596afe3e335" translate="yes" xml:space="preserve">
          <source>RFC 2349, TFTP Timeout Interval and Transfer Size Options</source>
          <target state="translated">RFC 2349, TFTP 시간 초과 간격 및 전송 크기 옵션</target>
        </trans-unit>
        <trans-unit id="59a4f7837e70ac5999135a8d3596c58b849ab6fc" translate="yes" xml:space="preserve">
          <source>RFC 2830</source>
          <target state="translated">RFC 2830</target>
        </trans-unit>
        <trans-unit id="4b90d6cab31b63063971c3605ede011c0f69a6ae" translate="yes" xml:space="preserve">
          <source>RFC 4510 - RFC 4519</source>
          <target state="translated">RFC 4510-RFC 4519</target>
        </trans-unit>
        <trans-unit id="e045a28c1bf7b6ecab4874ab74282cfdb4c62672" translate="yes" xml:space="preserve">
          <source>RFC 4716 SSH Public-Key Files</source>
          <target state="translated">RFC 4716 SSH 공개 키 파일</target>
        </trans-unit>
        <trans-unit id="d99facf0134d096b722a33331e4fe8b6452b7572" translate="yes" xml:space="preserve">
          <source>RFC 4716 SSH files looks confusingly like PEM files, but there are some differences:</source>
          <target state="translated">RFC 4716 SSH 파일은 PEM 파일과 혼동 될 수 있지만 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1da6885bf9a20f8d0085f4bb97f71554cbe07e08" translate="yes" xml:space="preserve">
          <source>RFC 6733 is unclear about the semantics of the M-bit. One the one hand, the CCF specification in section 3.2 documents AVP in a command grammar as meaning &lt;strong&gt;any&lt;/strong&gt; arbitrary AVP; on the other hand, 1.3.4 states that AVPs setting the M-bit cannot be added to an existing command: the modified command must instead be placed in a new Diameter application.</source>
          <target state="translated">RFC 6733은 M- 비트의 의미에 대해 명확하지 않습니다. 하나 한편, 3.2 문서를 의미하는 것으로 명령 문법 AVP 섹션의 CCF 사양 &lt;strong&gt;어떤&lt;/strong&gt; 임의 AVP 단계; 반면, 1.3.4에서는 M- 비트를 설정하는 AVP를 기존 명령에 추가 할 수 없다고 설명합니다. 대신 수정 된 명령을 새 직경 응용 프로그램에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a00bbd3345e1dc4481f48b2eb823bd6a52b39bc" translate="yes" xml:space="preserve">
          <source>RFC1155, 1157, 1212 and 1215 (SNMPv1)</source>
          <target state="translated">RFC1155, 1157, 1212 및 1215 (SNMPv1)</target>
        </trans-unit>
        <trans-unit id="776412993c8f2099a41ff3173b993a46e8d2ffc2" translate="yes" xml:space="preserve">
          <source>RFC1157, RFC1905 and/or RFC2272 should be studied carefully before using this module, &lt;code&gt;snmp_pdus&lt;/code&gt;.</source>
          <target state="translated">이 모듈 &lt;code&gt;snmp_pdus&lt;/code&gt; 를 사용하기 전에 RFC1157, RFC1905 및 / 또는 RFC2272를주의해서 연구해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1168b5a47f86b0c1ab1cefa353e2e20f382b649a" translate="yes" xml:space="preserve">
          <source>RFC1901-1907 (SNMPv2c)</source>
          <target state="translated">RFC1901-1907 (SNMPv2c)</target>
        </trans-unit>
        <trans-unit id="8f47f36a71eeb2e19619fed1c9a260fe790b894f" translate="yes" xml:space="preserve">
          <source>RFC1908, 2089 (coexistence between SNMPv1 and SNMPv2)</source>
          <target state="translated">RFC1908, 2089 (SNMPv1과 SNMPv2의 공존)</target>
        </trans-unit>
        <trans-unit id="b65e8c8967997cf54ae07d33911cd338bcfd5fea" translate="yes" xml:space="preserve">
          <source>RFC2271, RFC2273 (SNMP std MIBs)</source>
          <target state="translated">RFC2271, RFC2273 (SNMP 표준 MIB)</target>
        </trans-unit>
        <trans-unit id="0af95ef1de17ae695b66479ee11b7103aa465be4" translate="yes" xml:space="preserve">
          <source>RIPEMD</source>
          <target state="translated">RIPEMD</target>
        </trans-unit>
        <trans-unit id="56d91d770f6fd64e188020f40d1d915be6e046dc" translate="yes" xml:space="preserve">
          <source>RSA</source>
          <target state="translated">RSA</target>
        </trans-unit>
        <trans-unit id="2eaf7255c3d0769be8db606fdc4cb3c75a6bc45e" translate="yes" xml:space="preserve">
          <source>RSA Private Key with Password</source>
          <target state="translated">암호가있는 RSA 개인 키</target>
        </trans-unit>
        <trans-unit id="6ea4c0026f066dc5abcb51545da113f964141a7c" translate="yes" xml:space="preserve">
          <source>RSA is available with all OpenSSL versions compatible with Erlang CRYPTO if not disabled by configuration. To dynamically check availability, check that the atom &lt;code&gt;rsa&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">RSA는 구성에 의해 비활성화되지 않은 경우 Erlang CRYPTO와 호환되는 모든 OpenSSL 버전에서 사용할 수 있습니다. 가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 원자 &lt;code&gt;rsa&lt;/code&gt; 가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7048ce67ecec532f7cc5dce118117bd7056bb418" translate="yes" xml:space="preserve">
          <source>RSA key generation is only available if the runtime was built with dirty scheduler support. Otherwise, attempting to generate an RSA key will raise exception &lt;code&gt;error:notsup&lt;/code&gt;.</source>
          <target state="translated">RSA 키 생성은 런타임이 더티 스케줄러 지원으로 빌드 된 경우에만 사용할 수 있습니다. 그렇지 않으면 RSA 키를 생성하려고하면 예외 &lt;code&gt;error:notsup&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f8914ca9f86bbe9f10be1026bac810afc6078c5e" translate="yes" xml:space="preserve">
          <source>RSA key generation is only available if the runtime was built with dirty scheduler support. Otherwise, attempting to generate an RSA key will throw exception &lt;code&gt;error:notsup&lt;/code&gt;.</source>
          <target state="translated">RSA 키 생성은 런타임이 더티 스케줄러 지원으로 빌드 된 경우에만 사용 가능합니다. 그렇지 않으면 RSA 키를 생성하려고 시도하면 예외 &lt;code&gt;error:notsup&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f8a99f35d61ceca4837d76f44bfe87e13e69d5a3" translate="yes" xml:space="preserve">
          <source>RSASSA-PSS signature schemes</source>
          <target state="translated">RSASSA-PSS 서명 체계</target>
        </trans-unit>
        <trans-unit id="05d92fe0db12744e04d5c42042cf1cefb4d02e52" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;undef&lt;/code&gt; exception with a stacktrace, indicating that &lt;code&gt;Module:Function/N&lt;/code&gt; is undefined.</source>
          <target state="translated">&lt;code&gt;Module:Function/N&lt;/code&gt; 이 정의되지 않았 음을 나타내는 스택 추적으로 &lt;code&gt;undef&lt;/code&gt; 예외를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="459599ff17e3d64ffa950ad44a266ffa3f086014" translate="yes" xml:space="preserve">
          <source>Range = 1..2^32, Hash = 1..Range</source>
          <target state="translated">범위 = 1..2 ^ 32, 해시 = 1 .. 범위</target>
        </trans-unit>
        <trans-unit id="a7f829a993da34443f81cc1e6ec49f9944aa415e" translate="yes" xml:space="preserve">
          <source>Ranges of taken salt (if any) and returned value depend on the hash type.</source>
          <target state="translated">소금의 범위 (있는 경우)와 반환 값의 범위는 해시 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4739ff05fa329071f045d72b76e29a97728b5a87" translate="yes" xml:space="preserve">
          <source>Ranges operate in the collating sequence of character values. They can also be used for characters specified numerically, for example, [\000-\037]. Ranges can include any characters that are valid for the current mode.</source>
          <target state="translated">범위는 문자 값의 조합 순서로 작동합니다. 숫자로 지정된 문자 (예 : [\ 000- \ 037])에도 사용할 수 있습니다. 범위에는 현재 모드에 유효한 모든 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b944ab1d190ffab8bdf5f92747b67f829f474fa" translate="yes" xml:space="preserve">
          <source>Rarely used. Determines the ACK time (specified by &lt;code&gt;assoc_value&lt;/code&gt;, in milliseconds) for the specified association or the whole endpoint if &lt;code&gt;assoc_value = 0&lt;/code&gt; (default).</source>
          <target state="translated">드물게 사용되는. &lt;code&gt;assoc_value = 0&lt;/code&gt; (기본값) 인 경우 지정된 연관 또는 전체 엔드 포인트에 대한 ACK 시간 ( &lt;code&gt;assoc_value&lt;/code&gt; 로 지정됨 ( 밀리 초)을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="acb7267dc157944fbc4f68b9244986a8dd01d029" translate="yes" xml:space="preserve">
          <source>Rather than reading the &lt;code&gt;Emakefile&lt;/code&gt; specify configuration explicitly.</source>
          <target state="translated">&lt;code&gt;Emakefile&lt;/code&gt; 을 읽는 대신 구성을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="47883c793c16264c0bf3a9f6e7125312a6498763" translate="yes" xml:space="preserve">
          <source>Raw filenames were introduced together with Unicode filename support in ERTS 5.8.2 (Erlang/OTP R14B01). The reason &quot;raw filenames&quot; were introduced in the system was to be able to represent filenames, specified in different encodings on the same system, consistently. It can seem practical to have the VM automatically translate a filename that is not in UTF-8 to a list of Unicode characters, but this would open up for both duplicate filenames and other inconsistent behavior.</source>
          <target state="translated">원시 파일 이름은 ERTS 5.8.2 (Erlang / OTP R14B01)에서 유니 코드 파일 이름 지원과 함께 도입되었습니다. &quot;원시 파일 이름&quot;이 시스템에 도입 된 이유는 동일한 시스템에서 다른 인코딩으로 지정된 파일 이름을 일관되게 나타낼 수 있기 때문입니다. VM에서 UTF-8이 아닌 파일 이름을 유니 코드 문자 목록으로 자동 변환하는 것이 실용적으로 보일 수 있지만 중복 된 파일 이름과 다른 일관되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="795061f45c0310d22fcc247f07c3b4e23fa83463" translate="yes" xml:space="preserve">
          <source>Raw files use the file system of the host machine of the node. For normal files (non-raw), the file server is used to find the files, and if the node is running its file server as slave to the file server of another node, and the other node runs on some other host machine, they can have different file systems. However, this is seldom a problem.</source>
          <target state="translated">원시 파일은 노드 호스트 시스템의 파일 시스템을 사용합니다. 일반 파일 (비원시)의 경우 파일 서버는 파일을 찾는 데 사용되며 노드가 다른 노드의 파일 서버에 대한 슬레이브로 파일 서버를 실행하고 다른 노드는 다른 호스트 시스템에서 실행되는 경우 다른 파일 시스템을 가질 수 있습니다. 그러나 이것은 거의 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c84575df9844c415b455e79411320007894aa74" translate="yes" xml:space="preserve">
          <source>Raw socket options, such as &lt;code&gt;packet&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; must not be specified on the command line.</source>
          <target state="translated">&lt;code&gt;packet&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 와 같은 원시 소켓 옵션 은 명령 행에 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="1a1608e0a1ead364bb6ddf1ef14e4576861c85e2" translate="yes" xml:space="preserve">
          <source>Re-Auth-Answer</source>
          <target state="translated">Re-Auth-Answer</target>
        </trans-unit>
        <trans-unit id="cea1207d9889c12a36609f11fca3aa3647d57966" translate="yes" xml:space="preserve">
          <source>Re-Auth-Request</source>
          <target state="translated">Re-Auth-Request</target>
        </trans-unit>
        <trans-unit id="16429bb7f0689c5c487b46f0ec26c0177f1ef94a" translate="yes" xml:space="preserve">
          <source>Re-Auth-Request-Type AVP</source>
          <target state="translated">재 인증 요청 유형 AVP</target>
        </trans-unit>
        <trans-unit id="7bc3f1950022396c1453ed6991b28afe5cc3b167" translate="yes" xml:space="preserve">
          <source>Re-Auth-Request-Type AVP Values</source>
          <target state="translated">재 인증 요청 유형 AVP 값</target>
        </trans-unit>
        <trans-unit id="77e1d4c89a77db083b40468156c72a44aaeb8a27" translate="yes" xml:space="preserve">
          <source>Re-defining the match operation</source>
          <target state="translated">일치 작업 재정의</target>
        </trans-unit>
        <trans-unit id="33eb91045c8eb5bfc8955b6b24ea62f8a0bae9e0" translate="yes" xml:space="preserve">
          <source>Re-keying</source>
          <target state="translated">Re-keying</target>
        </trans-unit>
        <trans-unit id="19c1fde66df90cd89fae9d3e8cfddd3b6967eaae" translate="yes" xml:space="preserve">
          <source>Re-send a megaco message.</source>
          <target state="translated">megaco 메시지를 다시 보내십시오.</target>
        </trans-unit>
        <trans-unit id="8f461656f4f97af8310e6bbba806a6dfac4836a2" translate="yes" xml:space="preserve">
          <source>Re-send of messages, handling pending transactions, acknowledgements etc. is handled automatically by the Megaco application but the user is free to override the default behaviour by the various configuration possibilities. See megaco:update_user_info/2 and megaco:update_conn_info/2 about the possibilities.</source>
          <target state="translated">메시지 재전송, 보류중인 트랜잭션 처리, 승인 등은 Megaco 응용 프로그램에서 자동으로 처리하지만 사용자는 다양한 구성 가능성에 따라 기본 동작을 자유롭게 무시할 수 있습니다. 가능성에 대해서는 megaco : update_user_info / 2 및 megaco : update_conn_info / 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc298594d701205369ec5adc40340226d9806b5c" translate="yes" xml:space="preserve">
          <source>Read a compiled mib.</source>
          <target state="translated">컴파일 된 mib를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="d29eaf7d5b0696daa9e2eb7af2a4eda9b4483580" translate="yes" xml:space="preserve">
          <source>Read a file dump produced by &lt;code&gt;&lt;a href=&quot;#to_file-1&quot;&gt; to_file(Filename)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#to_file-1&quot;&gt; to_file(Filename)&lt;/a&gt;&lt;/code&gt; 의해 생성 된 파일 덤프를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="2d219c0f4eafc3f8960679e044824d76e3076ea1" translate="yes" xml:space="preserve">
          <source>Read a file dump produced by &lt;code&gt;&lt;a href=&quot;#to_file-1&quot;&gt;to_file(Filename)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#to_file-1&quot;&gt;to_file(Filename)&lt;/a&gt;&lt;/code&gt; 의해 생성 된 파일 덤프를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="094a01892ae368406b5fc03359c07f6767d0465e" translate="yes" xml:space="preserve">
          <source>Read a record from the mib-storage table.</source>
          <target state="translated">mib-storage 테이블에서 레코드를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f6ff77a0a3df9a2261cdc95790a6b678efe244aa" translate="yes" xml:space="preserve">
          <source>Read atomic value.</source>
          <target state="translated">원자 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fae42d0f132843e9c05600efe03222c799da3c90" translate="yes" xml:space="preserve">
          <source>Read back a stored value:</source>
          <target state="translated">저장된 값을 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="27567215dc4334b10c37b9ca844dcffd0d6a48fd" translate="yes" xml:space="preserve">
          <source>Read counter value.</source>
          <target state="translated">카운터 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9b417049ca594705f8e80c3117ca276b4d1ab2aa" translate="yes" xml:space="preserve">
          <source>Read data on the connected socket identified by &lt;code&gt;ctx&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; 로 식별되는 연결된 소켓에서 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="8d5d990ecf5aa325dd10c8954d8f4a8821e157b8" translate="yes" xml:space="preserve">
          <source>Read locks an rwlock. The calling thread is blocked until the rwlock has been read locked. A thread that currently has read or read/write locked the rwlock &lt;strong&gt;cannot&lt;/strong&gt; lock the same rwlock again.</source>
          <target state="translated">읽기는 rwlock을 잠급니다. rwlock이 읽혀질 때까지 호출 스레드가 차단됩니다. 현재 rwlock을 읽거나 읽거나 쓴 잠금 스레드 는 동일한 rwlock을 다시 잠글 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="76ccfbe9ca99e346c048962da6d197423a7cbd46" translate="yes" xml:space="preserve">
          <source>Read locks can be shared. This means that if one transaction manages to acquire a read lock on an item, other transactions can also acquire a read lock on the same item. However, if someone has a read lock, no one can acquire a write lock at the same item. If someone has a write lock, no one can acquire either a read lock or a write lock at the same item.</source>
          <target state="translated">읽기 잠금을 공유 할 수 있습니다. 즉, 한 트랜잭션이 항목에 대한 읽기 잠금을 획득하면 다른 트랜잭션도 동일한 항목에 대한 읽기 잠금을 획득 할 수 있습니다. 그러나 누군가에게 읽기 잠금이 있으면 아무도 같은 항목에서 쓰기 잠금을 얻을 수 없습니다. 누군가 쓰기 잠금이있는 경우 아무도 같은 항목에서 읽기 잠금 또는 쓰기 잠금을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="456c28f5533d4eb09cd97080da5711f1478a5dcf" translate="yes" xml:space="preserve">
          <source>Read more about behaviours and callback modules in &lt;code&gt; OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; OTP Design Principles&lt;/code&gt; 동작 및 콜백 모듈에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="ab3b8c2401387cd20afc043cfe4cdb6d7fad5178" translate="yes" xml:space="preserve">
          <source>Read more about behaviours and callback modules in &lt;code&gt;OTP Design Principles&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OTP Design Principles&lt;/code&gt; 에서 동작 및 콜백 모듈에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="61362260d54488c95a5f54ff4abb862733375e24" translate="yes" xml:space="preserve">
          <source>Read more about funs in &lt;code&gt;&lt;a href=&quot;expressions#funs&quot;&gt; Fun Expressions&lt;/a&gt;&lt;/code&gt;. For more examples, see &lt;code&gt; Programming Examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;expressions#funs&quot;&gt; Fun Expressions&lt;/a&gt;&lt;/code&gt; 에서 funs에 대해 자세히 알아보십시오 . 더 많은 예제는 &lt;code&gt; Programming Examples&lt;/code&gt; 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07143977457b982ffd87794e7909594ac2808846" translate="yes" xml:space="preserve">
          <source>Read more about funs in &lt;code&gt;&lt;a href=&quot;expressions#funs&quot;&gt;Fun Expressions&lt;/a&gt;&lt;/code&gt;. For more examples, see &lt;code&gt;Programming Examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;expressions#funs&quot;&gt;Fun Expressions&lt;/a&gt;&lt;/code&gt; 의 재미 에 대해 자세히 알아보십시오 . 자세한 예는 &lt;code&gt;Programming Examples&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5940b2687eed5e9f65b97bfd87d49fb0609ebc83" translate="yes" xml:space="preserve">
          <source>Read more about maps in &lt;code&gt;&lt;a href=&quot;expressions#map_expressions&quot;&gt; Map Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;expressions#map_expressions&quot;&gt; Map Expressions&lt;/a&gt;&lt;/code&gt; 에서 지도 에 대해 자세히 알아보세요 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
