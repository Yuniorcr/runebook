<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d362d3cf60cb0af09ab64c13d49db2cee633e8f5" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = cancel&lt;/code&gt;.</source>
          <target state="translated">요청이 성공적으로 인코딩되어 전송되었지만 응답을 받기 전에 해당 서비스가 중지 된 경우 &lt;code&gt;Reason = cancel&lt;/code&gt; 으로 &lt;code&gt;handle_error/4&lt;/code&gt; 콜백이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="61d25df3bedf5d0be2cd7d314bbaa9b30da48753" translate="yes" xml:space="preserve">
          <source>If the request reached the peer, was handled and the response reached the requesting node the &lt;code&gt;&lt;a href=&quot;#type-req_status&quot;&gt;req_status()&lt;/a&gt;&lt;/code&gt; is the status reported from the peer.</source>
          <target state="translated">요청이 피어에 도달하고 처리되었으며 응답이 요청 노드에 도달 한 경우 &lt;code&gt;&lt;a href=&quot;#type-req_status&quot;&gt;req_status()&lt;/a&gt;&lt;/code&gt; 는 피어에서보고 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="9756cb158d71aee0a6ade83d17f9f5f0e83f232d" translate="yes" xml:space="preserve">
          <source>If the requested data is available, the subentry is associated with &lt;code&gt;Name&lt;/code&gt; so that the value of the element can be read with &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; provided &lt;code&gt;Name&lt;/code&gt; is used instead of the whole &lt;code&gt;Required&lt;/code&gt; term.</source>
          <target state="translated">요청 된 데이터를 사용할 수있는 경우 하위 항목이와 관련된 &lt;code&gt;Name&lt;/code&gt; 때문에 요소의 값을 읽을 수 있다는 &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; 제공 &lt;code&gt;Name&lt;/code&gt; 대신에 전체의 사용 &lt;code&gt;Required&lt;/code&gt; 용어.</target>
        </trans-unit>
        <trans-unit id="5e0bd29420b56350fa2aea428f5bb429a285d8aa" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands &lt;code&gt;q()&lt;/code&gt; and &lt;code&gt;init:stop()&lt;/code&gt; is used as fallback.</source>
          <target state="translated">에뮬레이터 시작 중에 STDLIB 변수를 설정하여 제한 쉘이 활성화되고 콜백 모듈을로드 할 수없는 경우 명령 &lt;code&gt;q()&lt;/code&gt; 및 &lt;code&gt;init:stop()&lt;/code&gt; 만 허용하는 기본 제한 쉘 이 폴백으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="724b8206454c6a949fb926da63637eb525b4710d" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt; start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">제한된 쉘이 &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt; start_restricted/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 활성화 되고 콜백 모듈을로드 할 수없는 경우 오류 보고서가 오류 로거에 전송되고 호출이 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ffe48dc12c1fe598f1a22c84e21f70cadbb61864" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 제한된 쉘이 활성화 되고 콜백 모듈을로드 할 수없는 경우 오류 보고서가 오류 로거로 전송되고 호출은 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d723ff157f68fb866c4e720b4a0eacba9b30b870" translate="yes" xml:space="preserve">
          <source>If the result of the list comprehension will &lt;strong&gt;obviously&lt;/strong&gt; not be used, a list will not be constructed. For example, in this code:</source>
          <target state="translated">목록 이해의 결과가 &lt;strong&gt;분명히&lt;/strong&gt; 사용되지 않으면 목록이 구성되지 않습니다. 예를 들어,이 코드에서 :</target>
        </trans-unit>
        <trans-unit id="ef688930e9bc0a09ddfd80d412acb665d77d541c" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">런타임 시스템이 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt; 인 경우 런타임 시스템이 &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 이 변경된 것을 감지하면 시간 오프셋이 변경됩니다 . 그러나 런타임 시스템은 이것이 발생할 때이를 즉시 감지하지 않습니다. 시간 오프셋을 검사하는 작업은 최소 1 분에 한 번 실행되도록 예약되므로 정상 작동시 1 분 이내에 감지되지만로드가 많은 경우 시간이 더 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee5563a77256009bf8489bde46cade77b9f2b67" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">런타임 시스템이 &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; 인 경우 런타임 시스템이 &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 이 변경된 것을 감지하면 시간 오프셋이 변경됩니다 . 그러나 런타임 시스템은 이것이 발생할 때이를 즉시 감지하지 않습니다. 시간 오프셋을 검사하는 작업은 최소 1 분에 한 번 실행되도록 예약되어 있습니다. 따라서 정상 작동시 1 분 이내에 감지되지만로드가 많은 경우 시간이 더 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="842b5ecda8b77bc83a3f2909c3c676e780a3ce01" translate="yes" xml:space="preserve">
          <source>If the same option is set at two different levels, the one at the highest level is used.</source>
          <target state="translated">동일한 옵션이 두 가지 다른 수준으로 설정되면 가장 높은 수준의 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="554e754ec098db2cf4c76a2930674bed5aa17796" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="translated">&lt;code&gt;https&lt;/code&gt; 체계 를 사용하는 경우 &lt;code&gt;SSL&lt;/code&gt; 애플리케이션을 시작해야합니다. 때 &lt;code&gt;https&lt;/code&gt; 링크가 프록시를 통해 갈 필요가, HTTP-1.1에 CONNECT 방법 확장 터널을 설정하는 데 사용 된 후 연결이 TLS로 업그레이드됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt; 에 따른 &quot;TLS 업그레이드&quot; 는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c3e2a035a8c91596ec4431ba0d0a851882160c2" translate="yes" xml:space="preserve">
          <source>If the second operand for &lt;code&gt;is_number/2&lt;/code&gt; is a literal, it will be moved to X register 1023. Then &lt;code&gt;is_number/2&lt;/code&gt; will test whether the value stored in X register 1023 is a number.</source>
          <target state="translated">&lt;code&gt;is_number/2&lt;/code&gt; 의 두 번째 피연산자 가 리터럴이면 X 레지스터 1023으로 이동합니다. 그런 다음 &lt;code&gt;is_number/2&lt;/code&gt; 는 X 레지스터 1023에 저장된 값이 숫자인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="35c6f2a7a376dda13bb7ffd101ed27e0bb2c89e4" translate="yes" xml:space="preserve">
          <source>If the selected cipher needs to have the input data partioned into blocks of a certain size, the &lt;code&gt;init_fun()&lt;/code&gt; should return the second form of return value with the &lt;code&gt;chunk_size()&lt;/code&gt; set to the block size. If the &lt;code&gt;chunk_size()&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;chunk_size()&lt;/code&gt; is intended for block crypto. A &lt;code&gt;chunk_size()&lt;/code&gt; can be changed in the return from the &lt;code&gt;crypto_fun()&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">선택한 암호가 입력 데이터를 특정 크기의 블록으로 &lt;code&gt;init_fun()&lt;/code&gt; 경우 init_fun () 은 블록 크기로 설정된 &lt;code&gt;chunk_size()&lt;/code&gt; 와 함께 두 번째 형식의 반환 값을 반환해야 합니다. 상기 중간 &lt;code&gt;chunk_size()&lt;/code&gt; 되는 &lt;code&gt;undefined&lt;/code&gt; 의 크기 &lt;code&gt;PlainBin&lt;/code&gt; 이것은 고정 된 반면, 스트림 암호화를 대상으로하기 때문에 S 다르기 &lt;code&gt;chunk_size()&lt;/code&gt; 블록 암호화를 위해 의도된다. &lt;code&gt;chunk_size()&lt;/code&gt; 로부터 반환에 변경 될 수 있습니다 &lt;code&gt;crypto_fun()&lt;/code&gt; . 값은 &lt;code&gt;pos_integer()&lt;/code&gt; 와 &lt;code&gt;undefined&lt;/code&gt; 사이에서 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8d199b5f396cd79b8cc290ec04cb85c9575f0f8" translate="yes" xml:space="preserve">
          <source>If the sender would have to be suspended to do the send, &lt;code&gt;nosuspend&lt;/code&gt; is returned instead.</source>
          <target state="translated">송신자가 송신을 수행하기 위해 일시 ​​중단되어야하는 경우, 대신 &lt;code&gt;nosuspend&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="603b5cbedb1c18808b9a489511a61b63ed3b0c0b" translate="yes" xml:space="preserve">
          <source>If the server changes callback module using any of the actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow.</source>
          <target state="translated">서버가 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt; 작업 중 하나를 사용하여 콜백 모듈을 변경 하는 경우 항상이 콜백 호출을받을 현재 콜백 모듈이라는 점에 유의하십시오. 현재 콜백 모듈이 현재 상태를 처리하고 데이터 업데이트를 처리하는 것은 놀라운 일이 아니지만, 익숙하지 않은 상태 및 데이터의 일부도 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7e6d3e8ae70c643b6deb59daac018ce037067a9f" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">서버가 구성 파일에 지정되지 않은 경우 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d8838b36f111de63a4782ef1a364bbbead7e4773" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">서버가 구성 파일에 지정되지 않은 경우 대신 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="70355032eca4c9d76df601e10da3a7d335f3ed0d" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in this module), use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">서버 옵션이 구성 파일에 지정되거나 이름 지정된 클라이언트가 로깅 목적으로 필요한 경우 ( 이 모듈의 &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; 섹션 참조 ) 대신 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57f23c3daad60ed51515d51367aea45626c02cd9" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">서버 옵션이 구성 파일에 지정된 경우 대신 &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dcdba9665f7f05be3244027d112ec31bf32434c" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the &lt;code&gt;sni_hosts&lt;/code&gt; option, the specific options for that host will override previously specified options. The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">서버가 클라이언트로부터 &lt;code&gt;sni_hosts&lt;/code&gt; 옵션에 나열된 호스트와 일치하는 SNI (서버 이름 표시)를 수신하면 해당 호스트에 대한 특정 옵션이 이전에 지정된 옵션보다 우선합니다. &lt;code&gt;sni_fun&lt;/code&gt; 및 &lt;code&gt;sni_hosts&lt;/code&gt; 옵션 은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="6872d76e7fd0c2b2043184ce306dcf6a44377861" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; list. The function should be defined as: fun(ServerName :: string()) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">서버가 클라이언트로부터 SNI (Server Name Indication)를 받으면 지정된 서버에 대한 &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; 을 검색하기 위해 지정된 함수가 호출됩니다 . 이러한 옵션은 미리 정의 된 &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; 목록에 병합됩니다 . 함수는 다음과 같이 정의해야합니다. fun (ServerName :: string ())-&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; fun 또는 fun으로 지정 될 수 있습니다 &lt;code&gt;fun module:function/1&lt;/code&gt; 옵션 &lt;code&gt;sni_fun&lt;/code&gt; 및 &lt;code&gt;sni_hosts&lt;/code&gt; 는 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="f88346e63ca31b635eaa59afabe4ac1246f3dd96" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;[ssl_option()]&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;[ssl_option()]&lt;/code&gt;. The function should be defined as: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">서버가 클라이언트로부터 SNI (Server Name Indication)를 수신하면 지정된 서버에 대해 &lt;code&gt;[ssl_option()]&lt;/code&gt; 을 검색하기 위해 지정된 함수가 호출됩니다 . 이러한 옵션은 사전 정의 된 &lt;code&gt;[ssl_option()]&lt;/code&gt; 병합됩니다 . 이 함수는 &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; 으로 정의해야하며 fun 또는 named &lt;code&gt;fun module:function/1&lt;/code&gt; 로 지정할 수 있습니다 . function / 1 옵션 &lt;code&gt;sni_fun&lt;/code&gt; 및 &lt;code&gt;sni_hosts&lt;/code&gt; 는 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="37d0a58e6098abfba1624874ecb647d5100c0c46" translate="yes" xml:space="preserve">
          <source>If the size of the files is decreased, the change immediately affects the current log. It does not change the size of log files already full until the next time they are used.</source>
          <target state="translated">파일 크기가 줄어들면 변경 내용이 현재 로그에 즉시 영향을줍니다. 다음에 사용할 때까지 이미 가득 찬 로그 파일의 크기는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48531719e2548f233ac5471f827038efdab7d452" translate="yes" xml:space="preserve">
          <source>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</source>
          <target state="translated">프로세스의 라이브 데이터 크기가 최소 힙 크기보다 작은 경우 프로세스가 깨어 난 후 발생하는 첫 번째 가비지 콜렉션은 힙 크기가 최소 힙 크기보다 작지 않은 크기로 변경되도록합니다.</target>
        </trans-unit>
        <trans-unit id="55a92bc9b80ccffb05ef0f4d2b0d2c00367ee298" translate="yes" xml:space="preserve">
          <source>If the skipped test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">건너 뛴 테스트 케이스가 테스트 케이스 그룹에 속하는 경우 첫 번째 인수는 튜플 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; 이고 그렇지 않은 경우 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a70f753063df0478c5593d2eec5283aea16d43ef" translate="yes" xml:space="preserve">
          <source>If the snmp agent is configured as a distributed Erlang application, it will during takeover try to load the same MIBs that were loaded at the old node. It uses the same filenames as the old node. If the MIBs are not located in the same paths at the different nodes, the MIBs must be loaded explicitly after takeover.</source>
          <target state="translated">snmp 에이전트가 분산 Erlang 애플리케이션으로 구성된 경우 인계 중에 이전 노드에로드 된 동일한 MIB를로드하려고 시도합니다. 이전 노드와 동일한 파일 이름을 사용합니다. MIB가 다른 노드의 동일한 경로에없는 경우 인계 후에 MIB를 명시 적으로로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="512aa9feb42b459cd059aa3fe2168a1e5258567a" translate="yes" xml:space="preserve">
          <source>If the socket is a listen socket, we use a separate (regular) file for two purposes:</source>
          <target state="translated">소켓이 청취 소켓 인 경우 두 가지 목적을 위해 별도의 (일반) 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc7067034e5330d9330814dab9d3d85a46c9af7c" translate="yes" xml:space="preserve">
          <source>If the socket is closed, the following message is delivered:</source>
          <target state="translated">소켓이 닫히면 다음 메시지가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4128dcf4e6f00732687760eccb66b0c9d45f8d7a" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;active&lt;/a&gt;&lt;/code&gt; mode data received data is delivered to the controlling process as messages:</source>
          <target state="translated">소켓이 &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;active&lt;/a&gt;&lt;/code&gt; 모드에있는 경우 수신 된 데이터는 메시지로 제어 프로세스에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c4248f996c2d366444661dd551e1e934e80a81f5" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode data can be received through the &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; calls.</source>
          <target state="translated">소켓이 &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; 모드이면 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; 호출을 통해 데이터를받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c734cf077ea6e84216c28020bf0dfe0c224786a4" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details) and its message counter drops to &lt;code&gt;0&lt;/code&gt;, the following message is delivered to indicate that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:</source>
          <target state="translated">소켓이 &lt;code&gt;{active, N}&lt;/code&gt; 모드에 있고 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; 참조) 메시지 카운터가 &lt;code&gt;0&lt;/code&gt; 으로 떨어지면 소켓이 수동 ( &lt;code&gt;{active, false}&lt;/code&gt; )으로 전환되었음을 나타내는 다음 메시지가 전달됩니다. 양식:</target>
        </trans-unit>
        <trans-unit id="bb22ea2f6ffe71f664a8e18b7f47a0d62e0aa24d" translate="yes" xml:space="preserve">
          <source>If the socket is in a busy state, the socket is set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4 kB.</source>
          <target state="translated">소켓이 사용 중 상태 인 경우, ERTS 소켓 구현에 의해 내부적으로 대기중인 데이터의 양이이 한계 아래로 떨어지면 소켓이 사용 중이 아닌 상태로 설정됩니다. 기본값은 4 kB입니다.</target>
        </trans-unit>
        <trans-unit id="0860cb89a1cd48e8809f57a8b0f0cb44187efe24" translate="yes" xml:space="preserve">
          <source>If the socket is not in an active mode, data can be retrieved through the &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; calls. Notice that arriving UDP packets that are longer than the receive buffer option specifies can be truncated without warning.</source>
          <target state="translated">소켓이 활성 모드가 아닌 경우 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; 호출을 통해 데이터를 검색 할 수 있습니다 . 수신 버퍼 옵션이 지정한 것보다 긴 도착 UDP 패킷은 경고없이 잘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="479b7a4579a072626569e57eba743d1c2936d55c" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfer is complete may cause this.</source>
          <target state="translated">소켓이 활성 모드로 설정된 경우이 기능은 호출자의 사서함에있는 모든 메시지를 새 제어 프로세스로 전송합니다. 전송이 진행되는 동안 다른 프로세스가 소켓과 상호 작용하는 경우 전송이 제대로 작동하지 않을 수 있으며 메시지가 호출자의 사서함에 남아있을 수 있습니다. 예를 들어 전송이 완료되기 전에 소켓 활성 모드를 변경하면이 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886690ee1274e874585cd62a60964392f36c218d" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfere is complete may cause this.</source>
          <target state="translated">소켓이 활성 모드로 설정된 경우이 기능은 발신자의 사서함에있는 모든 메시지를 새로운 제어 프로세스로 전송합니다. 전송이 진행되는 동안 다른 프로세스가 소켓과 상호 작용하는 경우 전송이 올바르게 작동하지 않고 메시지가 발신자의 사서함에 남아있을 수 있습니다. 예를 들어, 전송이 완료되기 전에 소켓 활성 모드를 변경하면이 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef7d7003c6284dd13030d6ae0c0a5544dc8ae67" translate="yes" xml:space="preserve">
          <source>If the socket message queue is in a busy state, the socket message queue is set in a not busy state when the amount of data queued in the message queue falls below this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 4 kB.</source>
          <target state="translated">소켓 메시지 큐가 사용 중 상태 인 경우, 메시지 큐에 대기중인 데이터의 양이이 한계 아래로 떨어지면 소켓 메시지 큐가 사용 중이 아닌 상태로 설정됩니다. 이 한계는 아직 ERTS 내부 소켓 구현에 도달하지 않은 데이터에만 적용됩니다. 기본값은 4 kB입니다.</target>
        </trans-unit>
        <trans-unit id="0489cec8cde9abcfab25b3cd056616ee2153c497" translate="yes" xml:space="preserve">
          <source>If the source file and/or the output file cannot be opened using &lt;code&gt;file:open/2&lt;/code&gt;, the function returns &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; where &lt;code&gt;File&lt;/code&gt; is the file name and &lt;code&gt;Reason&lt;/code&gt; is the error reason.</source>
          <target state="translated">&lt;code&gt;file:open/2&lt;/code&gt; 를 사용하여 소스 파일 및 / 또는 출력 파일을 열 수없는 경우 , 함수는 &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; 을 리턴합니다. 여기서 &lt;code&gt;File&lt;/code&gt; 은 파일 이름이고 &lt;code&gt;Reason&lt;/code&gt; 은 오류 이유입니다.</target>
        </trans-unit>
        <trans-unit id="8e799a198169d10fe4c08d9a95c18d2093196332" translate="yes" xml:space="preserve">
          <source>If the spawn operation succeeds, a new process is created on the node identified by &lt;code&gt;Node&lt;/code&gt;. When a spawn operation succeeds, the caller will by default be sent a message on the form &lt;code&gt;{ReplyTag, ReqId, ok, Pid}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. Such a message is referred to as a</source>
          <target state="translated">생성 작업이 성공하면 &lt;code&gt;Node&lt;/code&gt; 로 식별되는 노드 에 새 프로세스가 생성됩니다 . 스폰 작업이 성공하면 기본적으로 호출자에게 &lt;code&gt;{ReplyTag, ReqId, ok, Pid}&lt;/code&gt; 형식으로 메시지가 전송됩니다. 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 새로 생성 된 프로세스의 프로세스 식별자입니다. 이러한 메시지를</target>
        </trans-unit>
        <trans-unit id="d585722d9492cc72567d38442d77e34fd8ab9264" translate="yes" xml:space="preserve">
          <source>If the special process is set to trap exits and if the parent process terminates, the expected behavior is to terminate with the same reason:</source>
          <target state="translated">특수 프로세스가 종료를 트랩하도록 설정되고 상위 프로세스가 종료되는 경우 동일한 동작으로 예상되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="7455375f6d9089c7881123f4a8458dbe542389f7" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;SessionId&lt;/code&gt; is equal to the current session Id, an error is returned.</source>
          <target state="translated">지정된 &lt;code&gt;SessionId&lt;/code&gt; 가 현재 세션 ID와 같으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d619307390edd39ec2b02ca669e7b364961dec45" translate="yes" xml:space="preserve">
          <source>If the specified allocator types are not enabled, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">지정된 할당 자 유형을 사용하지 않으면 &lt;code&gt;{error, not_enabled}&lt;/code&gt; 호출이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="45c304ea9f8890bedad2957ce64c3d9052640688" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">지정된 응용 프로그램이로드되지 않았거나 호출을 실행하는 프로세스가 응용 프로그램에 속하지 않으면이 함수는 &lt;code&gt;[]&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="661935b4fcb704bdedb21cd7cd8d1037467c6a3a" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, the function returns &lt;code&gt;undefined&lt;/code&gt;. If the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">지정된 애플리케이션이로드 &lt;code&gt;undefined&lt;/code&gt; 경우 함수는 undefined를 리턴합니다 . 호출을 실행하는 프로세스가 응용 프로그램에 속하지 않으면이 함수는 &lt;code&gt;[]&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3ee2eec511fb223edba405cd2c1e33b5dd8cf299" translate="yes" xml:space="preserve">
          <source>If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. If the event manager dies before or during the request this function returns &lt;code&gt;{error,{Reason, EventMgrRef}}&lt;/code&gt;.</source>
          <target state="translated">지정된 이벤트 핸들러가 설치되지 않은 경우 함수는 &lt;code&gt;{error,bad_module}&lt;/code&gt; 을 반환합니다 . 콜백 함수가 &lt;code&gt;Reason&lt;/code&gt; 과 함께 실패 하거나 예기치 않은 값 &lt;code&gt;Term&lt;/code&gt; 을 반환하는 경우이 함수는 각각 &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 또는 &lt;code&gt;{error,Term}&lt;/code&gt; 을 반환합니다 . 이벤트 관리자가 요청 전이나 요청 중에 죽으면이 함수는 &lt;code&gt;{error,{Reason, EventMgrRef}}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a926434bb6d9a3523835439ccc5767bd6572dff3" translate="yes" xml:space="preserve">
          <source>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">지정된 프로세스가 응용 프로그램에 속하지 않거나 지정된 프로세스 나 모듈이 존재하지 않으면 함수는 &lt;code&gt;undefined&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2b16c97bb4dc09a19744a2eb9750dd2d9bb5ce54" translate="yes" xml:space="preserve">
          <source>If the startup procedure fails, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the cryptic tuple &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt;. To get more information about the start failure, use command-line arguments &lt;code&gt;-boot start_sasl&lt;/code&gt; as argument to the &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">시작 절차가 실패하면 &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; 함수는 암호화 튜플 &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt; 반환합니다 . 시작 실패에 대한 자세한 정보를 얻으려면 명령 행 인수 &lt;code&gt;-boot start_sasl&lt;/code&gt; 을 &lt;code&gt;erl&lt;/code&gt; 스크립트의 인수로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cbaf50d401e5c21095fb8f1fd28f9a45786128e" translate="yes" xml:space="preserve">
          <source>If the state changes, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">상태가 변경되면 들어오는 이벤트 큐가 가장 오래된 연기로 시작되도록 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c8895677551ffa4a3c90ee4e7e492bffa6d9c323" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge. The challenge message can have two different formats:</source>
          <target state="translated">상태가 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;ok_simultaneous&lt;/code&gt; 이면 &lt;code&gt;B&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 에게 또 다른 메시지 인 챌린지를 보내는 동안 핸드 셰이크가 계속됩니다 . 챌린지에는 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로 처음 보낸 &quot;이름&quot;메시지와 동일한 유형의 정보와 32 비트 챌린지가 포함됩니다. 챌린지 메시지는 두 가지 형식을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36cb412738e6e082151303db455deefb75f1506a" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge:</source>
          <target state="translated">상태가 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;ok_simultaneous&lt;/code&gt; 인 경우 핸드 셰이크는 &lt;code&gt;B&lt;/code&gt; 에게 &lt;code&gt;A&lt;/code&gt; 에게 다른 메시지 (도전)를 보내 면서 계속됩니다 . 이 챌린지는 처음에 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로 전송 된 &quot;name&quot;메시지와 동일한 유형의 정보와 32 비트 챌린지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="beeeb7c98813879b37a7bf671f3521d70f7d4fcc" translate="yes" xml:space="preserve">
          <source>If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, that is, a disc-less node, &lt;code&gt;Mnesia&lt;/code&gt; does not use the disc on that particular node. The disc use is enabled by changing the storage type of table &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;disc_copies&lt;/code&gt;.</source>
          <target state="translated">스키마의 스토리지 유형이 &lt;code&gt;ram_copies&lt;/code&gt; 즉, 디스크가없는 노드 인 경우 &lt;code&gt;Mnesia&lt;/code&gt; 는 해당 특정 노드에서 디스크를 사용하지 않습니다. 디스크 사용은 테이블 &lt;code&gt;schema&lt;/code&gt; 의 스토리지 유형 을 &lt;code&gt;disc_copies&lt;/code&gt; 로 변경하여 사용 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="72c9602796f4ff2e2861a3fe314dbf863ef6f3fa" translate="yes" xml:space="preserve">
          <source>If the structured type has a component with an embedded &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; which embedded type in turn is a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, it gives a record with the &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; addition as in the following example:</source>
          <target state="translated">구조화 된 유형에 임베디드 유형이 차례로 &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; 인 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; 가 포함 된 컴포넌트가있는 경우 다음 예제 와 같이 &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; 가 추가 된 레코드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3f062c1144e1678c566106b319cf580ce31c88b8" translate="yes" xml:space="preserve">
          <source>If the style sheet is installed as in this example, the categories are private to the suite in question. They can be used by all test cases in the suite, but cannot be used by other suites. A suite private style sheet, if specified, is used in favor of a global style sheet (one specified with flag &lt;code&gt;-stylesheet&lt;/code&gt;). A stylesheet tuple (as returned by &lt;code&gt;suite/0&lt;/code&gt; above) can also be returned from a test case information function. In this case the categories specified in the style sheet can only be used in that particular test case. A test case private style sheet is used in favor of a suite or global level style sheet.</source>
          <target state="translated">이 예제에서와 같이 스타일 시트가 설치된 경우 카테고리는 해당 스위트 전용입니다. 스위트의 모든 테스트 케이스에서 사용할 수 있지만 다른 스위트에서는 사용할 수 없습니다. 지정된 경우 스위트 전용 스타일 시트는 글로벌 스타일 시트 (flag &lt;code&gt;-stylesheet&lt;/code&gt; 로 지정된 하나 )를 위해 사용됩니다. 스타일 시트 튜플 ( 위의 &lt;code&gt;suite/0&lt;/code&gt; 에 의해 리턴 된)은 테스트 케이스 정보 함수에서 리턴 될 수도 있습니다. 이 경우 스타일 시트에 지정된 카테고리는 해당 특정 테스트 케이스에서만 사용할 수 있습니다. 테스트 케이스 전용 스타일 시트는 스위트 또는 글로벌 레벨 스타일 시트를 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef2b08f553195b967c4c1ec0d687b8410583635" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;.</source>
          <target state="translated">제목이 &quot;aaaac ...&quot;인 경우 첫 번째 일치 시도가 실패한 후 (문자열의 첫 번째 문자에서 시작) 시작점은 &quot;c&quot;에서 다음 시도를 시작하기 위해 건너 뜁니다. 소유 수량 화기는이 예제와 동일한 효과를 갖지 않습니다. 첫 번째 일치 시도 중에 역 추적을 억제하지만 두 번째 시도는 &quot;c&quot;로 건너 뛰지 않고 두 번째 문자에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="325365b23f57e117a3a5f1be4ba75e874fad7352" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.</source>
          <target state="translated">주제가 &quot;abac&quot;인 경우 Perl은 일치하지만 그룹의 두 번째 반복에서 (* COMMIT)이 작동하므로 PCRE가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2a1b1d46006ae1cc02a5125b44f3a589d400f8b8" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.)</source>
          <target state="translated">피사체가 &quot;ba&quot;인 경우이 패턴이 일치하지 않습니다. 같이 .*? 이해가 안되며 처음에는 0 문자와 일치합니다. 그런 다음 조건 (? = a)이 실패하고 문자 &quot;b&quot;는 일치하지만 &quot;c&quot;는 일치하지 않습니다. 이 시점에서 일치는. *로 역 추적하지 않습니까? 의 존재에서 예상 할 수있는 | 캐릭터. 조건부 하위 패턴은 전체 패턴을 구성하는 단일 대안의 일부이므로 일치하지 않습니다. (. *?에 역 추적이있어 &quot;b&quot;와 일치하게되면 일치합니다.)</target>
        </trans-unit>
        <trans-unit id="61ab084c99ad2f6aacca28fcd587b3400e6c929a" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.</source>
          <target state="translated">제목이 &quot;xyz123abc123&quot;인 경우 일치점은 네 번째 문자입니다. 따라서 이러한 패턴은 암시 적으로 고정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f58702e52fe311a5928a0c529284a25593f9a63b" translate="yes" xml:space="preserve">
          <source>If the subsystems option is not present, the value of &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.</source>
          <target state="translated">서브 시스템 옵션이 없으면 &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; 이 사용됩니다. 이는 기본적으로 sftp 서브 시스템을 활성화합니다. 데몬이 서브 시스템을 실행하지 못하게하려면 옵션을 빈 목록으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56f01b4c736d33d8a8e4b807a7321e237504b729" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully created (that is, if all child process start functions return &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;), the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the supervisor.</source>
          <target state="translated">수퍼바이저와 해당 하위 프로세스가 성공적으로 작성되면 (즉, 모든 하위 프로세스 시작 함수가 &lt;code&gt;{ok,Child}&lt;/code&gt; , &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 를 리턴 하거나 &lt;code&gt;ignore&lt;/code&gt; ) 함수는 &lt;code&gt;{ok,Pid}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 감독자의 pid입니다.</target>
        </trans-unit>
        <trans-unit id="ce27df4e7a72330922127644fc5b4154720386f2" translate="yes" xml:space="preserve">
          <source>If the supervisor bridge and the subsystem are successfully started, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is is the pid of the supervisor bridge.</source>
          <target state="translated">수퍼바이저 브릿지와 서브 시스템이 성공적으로 시작되면이 함수는 &lt;code&gt;{ok,Pid}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 수퍼바이저 브릿지의 pid입니다.</target>
        </trans-unit>
        <trans-unit id="ee5bca92e596da338cae7a1a6835c08aaca7ab2c" translate="yes" xml:space="preserve">
          <source>If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the &lt;code&gt;pid()&lt;/code&gt; of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification identifier is specified instead of a &lt;code&gt;pid()&lt;/code&gt;, the function returns &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저가 &lt;code&gt;simple_one_for_one&lt;/code&gt; 인 경우 &lt;code&gt;Id&lt;/code&gt; 는 하위 프로세스 의 &lt;code&gt;pid()&lt;/code&gt; 여야합니다 . 지정된 프로세스가 활성 상태이지만 지정된 수퍼바이저의 자식이 아닌 &lt;code&gt;{error,not_found}&lt;/code&gt; 함수는 {error, not_found}를 반환합니다 . 자식 스펙 식별자가 &lt;code&gt;pid()&lt;/code&gt; 대신 지정된 경우, 함수는 &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fde2c4d92373b2df91d47d89bec456be3c098325" translate="yes" xml:space="preserve">
          <source>If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; to remove the child specification.</source>
          <target state="translated">수퍼바이저가되지 않으면 &lt;code&gt;simple_one_for_one&lt;/code&gt; , &lt;code&gt;Id&lt;/code&gt; 자식 사양 식별자 여야합니다. 프로세스가있는 경우 프로세스가 종료되며 임시 하위 프로세스가 아닌 경우 하위 스펙은 감독자가 유지합니다. 하위 프로세스는 나중에 관리자가 다시 시작할 수 있습니다. 자식 프로세스는 &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 명시 적으로 다시 시작할 수도 있습니다 . 하위 스펙을 제거 하려면 &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="22f9e859ab134b7ee555cf61c0b88a7c31c26892" translate="yes" xml:space="preserve">
          <source>If the supervisor is not running, the function fails with the reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저가 실행 중이 &lt;code&gt;badarg&lt;/code&gt; 이유와 함께 함수가 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="5f1a06a02433874f4dbf2fb6692571bffc468e3a" translate="yes" xml:space="preserve">
          <source>If the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is increased, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스의 일시 중단 횟수 가 증가하면 &lt;code&gt;true&lt;/code&gt; 가 반환되고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d5607c3dc66f8ee4fed4118cbb2c89a903f53e7" translate="yes" xml:space="preserve">
          <source>If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:</source>
          <target state="translated">재귀 적 서브 패턴 호출 (번호 또는 이름)이 구문을 참조하는 괄호 밖에서 사용되는 경우 프로그래밍 언어의 서브 루틴처럼 작동합니다. 호출 된 서브 패턴은 참조 전후에 정의 될 수 있습니다. 다음 예와 같이 번호가 매겨진 참조는 절대적이거나 상대적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c95678de3724de5573a03d131e0386d7f73cde7" translate="yes" xml:space="preserve">
          <source>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, &lt;code&gt;sync_nodes&lt;/code&gt;, can be used to synchronize the release handler processes at a number of nodes, see the &lt;code&gt;appup(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">시스템이 여러 Erlang 노드로 구성된 경우 각 노드는 고유 한 버전의 릴리스를 사용할 수 있습니다. 릴리스 핸들러는 로컬로 등록 된 프로세스이며 업그레이드 또는 다운 그레이드가 필요한 각 노드에서 호출해야합니다. 릴리스 처리 명령 &lt;code&gt;sync_nodes&lt;/code&gt; 를 사용하여 여러 노드에서 릴리스 핸들러 프로세스를 동기화 할 수 있습니다 . SASL 의 &lt;code&gt;appup(4)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a9dfa8802f7c28fb7268599a87d430596fb7e4c" translate="yes" xml:space="preserve">
          <source>If the system is halted by the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt;, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message is enough to understand the problem, but some messages are described here. Notice that the suggested reasons for the crash are &lt;strong&gt;only suggestions&lt;/strong&gt;. The exact reasons for the errors can vary depending on the local applications and the underlying operating system.</source>
          <target state="translated">시스템이 BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; 에 의해 정지 된 경우 슬로건은 BIF에 전달 된 문자열 매개 변수입니다. 그렇지 않으면 에뮬레이터 또는 (Erlang) 커널에 의해 생성 된 설명입니다. 일반적으로 메시지는 문제를 이해하기에 충분하지만 여기에 일부 메시지가 설명되어 있습니다. 충돌에 대한 제안 된 이유는 &lt;strong&gt;단지 제안 일뿐&lt;/strong&gt; 입니다. 오류의 정확한 이유는 로컬 응용 프로그램 및 기본 운영 체제에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a757ef96ac1cd490bb1c008318b2e3635c8724c" translate="yes" xml:space="preserve">
          <source>If the system is to be rebooted because of missing heartbeats, or a terminated Erlang runtime system, environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt; must be set before the system is started. If this variable is not set, a warning text is printed but the system does not reboot.</source>
          <target state="translated">누락 된 하트 비트 또는 종료 된 Erlang 런타임 시스템으로 인해 시스템을 재부팅 하려면 시스템을 시작하기 전에 환경 변수 &lt;code&gt;HEART_COMMAND&lt;/code&gt; 를 설정해야합니다. 이 변수를 설정하지 않으면 경고 텍스트가 인쇄되지만 시스템은 재부팅되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7201254cce87e2757d3c2088109f6b9433e91391" translate="yes" xml:space="preserve">
          <source>If the system upgrade fails, &lt;code&gt;Mnesia&lt;/code&gt; must be restarted on all &lt;code&gt;db_nodes&lt;/code&gt; to restore the old database. The fallback is automatically deinstalled after a successful startup. The function &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; can also be used to deinstall the fallback after a successful system upgrade. Again, this is a distributed operation that is either performed on all &lt;code&gt;db_nodes&lt;/code&gt; or none. Both the installation and deinstallation of fallbacks require Erlang to be operational on all &lt;code&gt;db_nodes&lt;/code&gt;, but it does not matter if &lt;code&gt;Mnesia&lt;/code&gt; is running or not.</source>
          <target state="translated">시스템 업그레이드가 실패 할 경우, &lt;code&gt;Mnesia&lt;/code&gt; 는 모든에 다시 시작해야합니다 &lt;code&gt;db_nodes&lt;/code&gt; 이전 데이터베이스를 복원 할 수 있습니다. 폴백은 성공적인 시작 후 자동으로 설치 제거됩니다. &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 시스템 업그레이드에 성공한 후 폴백을 제거 할 수도 있습니다. 다시, 이것은 모든 &lt;code&gt;db_nodes&lt;/code&gt; 에서 수행 되거나 전혀 수행 되지 않는 분산 작업입니다 . 폴백 설치 및 제거 모두 Erlang이 모든 &lt;code&gt;db_nodes&lt;/code&gt; 에서 작동해야 하지만 &lt;code&gt;Mnesia&lt;/code&gt; 가 실행 중인지 여부 는 중요 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="820e07b72de8d7275e79b190e2ecc622e6ffa577" translate="yes" xml:space="preserve">
          <source>If the system uses release handling, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">시스템이 릴리스 처리를 사용하는 경우 &lt;code&gt;start_erl.exe&lt;/code&gt; 와 유사한 프로그램으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0d7a8bf37699409a1736ff33b25beed75456c38" translate="yes" xml:space="preserve">
          <source>If the table has been fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the time when the table was first fixed by a process, which either is or is not one of the processes it is fixed by now.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 테이블을 수정 한 경우, 호출은 테이블이 프로세스에 의해 처음 수정 된 시간 인 &lt;code&gt;FixationTime&lt;/code&gt; 이며 현재 수정 된 프로세스 중 하나이거나 그렇지 않은 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="28d80bca5a16b32c018007fa19be0d36c5975d0c" translate="yes" xml:space="preserve">
          <source>If the table identifier is invalid.</source>
          <target state="translated">테이블 식별자가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="510048f902d277dbbdb552040e33a360934aad3f" translate="yes" xml:space="preserve">
          <source>If the table is a hash table, that is, if it is not an &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">테이블이 해시 테이블 인 경우, 즉 &lt;code&gt;ordered_set&lt;/code&gt; 이 아닌 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="8586c3c8b193a91489791658c1ee464303da1bd1" translate="yes" xml:space="preserve">
          <source>If the table is a hash table. Contains statistics about the table, such as the maximum, minimum, and average chain length. Having a maximum much larger than the average, and a standard deviation much larger than the expected standard deviation is a sign that the hashing of the terms behaves badly for some reason.</source>
          <target state="translated">테이블이 해시 테이블 인 경우 최대, 최소 및 평균 체인 길이와 같은 테이블에 대한 통계를 포함합니다. 평균보다 최대 값이 훨씬 크고 표준 편차가 표준 편차보다 훨씬 크다는 것은 해싱이 어떤 이유로 든 나쁜 행동을한다는 ​​신호입니다.</target>
        </trans-unit>
        <trans-unit id="fcb4375c9095616a2c1fcb3c7937a674a11eced4" translate="yes" xml:space="preserve">
          <source>If the table is an &lt;code&gt;ordered_set&lt;/code&gt;. (The number of elements is the same as the number of objects in the table.)</source>
          <target state="translated">테이블은 경우 &lt;code&gt;ordered_set&lt;/code&gt; . (요소 수는 테이블의 개체 수와 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="fe825b9dd24dc79930168b7d8e9410fc4ed428ff" translate="yes" xml:space="preserve">
          <source>If the table is deleted, the &lt;code&gt;tid()&lt;/code&gt; will be invalid even if another named table is created with the same name.</source>
          <target state="translated">테이블이 삭제되면 동일한 이름을 가진 다른 명명 된 테이블을 생성하더라도 &lt;code&gt;tid()&lt;/code&gt; 는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e50f5b3f9353a3565bdface1fd102e6a022cef3" translate="yes" xml:space="preserve">
          <source>If the table is empty, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">테이블이 비어 있으면 &lt;code&gt;'$end_of_table'&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="060a5cb7c2a9190e262dad862fd197847d59b457" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt; ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">&lt;code&gt; ets:safe_fixtable/2&lt;/code&gt; 또는 일부 내부 메커니즘을 사용하여 테이블이 고정 된 경우 .</target>
        </trans-unit>
        <trans-unit id="2f3fb17408533c8e1e68861ca6b015faef26d511" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt; safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the last time when the table changed from unfixed to fixed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt; safe_fixtable/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 테이블이 고정 된 경우 호출 은 테이블이 고정되지 않음 에서 &lt;code&gt;FixationTime&lt;/code&gt; 으로 변경된 마지막 시간 인 FixationTime 이 있는 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a3adb98d90a256345bb402384863d0ffa16d7d03" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">&lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; 또는 일부 내부 메커니즘을 사용하여 테이블을 수정 한 경우</target>
        </trans-unit>
        <trans-unit id="ab8f1f3f8186f2a911707d67d645de8494934784" translate="yes" xml:space="preserve">
          <source>If the table is not fixed at all, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">테이블이 전혀 고정되지 않은 경우 호출은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a5a1ad070d201f061059ad07a51c09a4b677d0c7" translate="yes" xml:space="preserve">
          <source>If the table never has been fixed, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">테이블이 수정되지 않은 경우 호출은 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1106f60b23247fd532e1f3435b3e146b85e02356" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;ordered_set&lt;/code&gt; and the key of the inserted object &lt;strong&gt;compares equal&lt;/strong&gt; to the key of any object in the table, the old object is replaced.</source>
          <target state="translated">테이블 유형이 &lt;code&gt;ordered_set&lt;/code&gt; 이고 삽입 된 오브젝트 의 키가 테이블에있는 오브젝트의 키와 &lt;strong&gt;동일한&lt;/strong&gt; 경우 이전 오브젝트가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="4533fa2ede8fbfe73be80457c07b8f040691fe23" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">테이블 유형이 &lt;code&gt;set&lt;/code&gt; 되고 주어진 키에 둘 이상의 오브젝트가 존재하면 오브젝트 중 하나가 선택됩니다. 입력 함수에 의해 리턴 된 오브젝트 순서에서 주어진 키를 갖는 마지막 오브젝트 일 필요는 없습니다. 중복 키를 피하십시오. 그렇지 않으면 파일이 불필요하게 조각화됩니다. 이것은 &lt;code&gt;bag&lt;/code&gt; 유형의 테이블에 저장된 복제 된 오브젝트에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="56d2753779e61ff48cb39b5aa4b2593e74eb1601" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">테이블 유형이 &lt;code&gt;set&lt;/code&gt; 되고 주어진 키에 둘 이상의 오브젝트가 존재하면 오브젝트 중 하나가 선택됩니다. 입력 함수에 의해 리턴 된 오브젝트 순서에서 주어진 키를 갖는 마지막 오브젝트 일 필요는 없습니다. 이것은 &lt;code&gt;bag&lt;/code&gt; 유형의 테이블에 저장된 복제 된 오브젝트에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cae4c49d2565269908072cf718d1492a11aec56f" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and the key of the inserted objects &lt;strong&gt;matches&lt;/strong&gt; the key of any object in the table, the old object is replaced.</source>
          <target state="translated">테이블 유형이 &lt;code&gt;set&lt;/code&gt; 되고 삽입 된 오브젝트 의 키가 테이블에있는 오브젝트의 키 &lt;strong&gt;와 일치&lt;/strong&gt; 하면 이전 오브젝트가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="a9fdebabfb947c83919e8f9a54708d4bc09db924" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt;, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt;, the function returns a list of arbitrary length.</source>
          <target state="translated">테이블 유형이 &lt;code&gt;set&lt;/code&gt; 되면 지정된 키를 가진 오브젝트가 둘 이상있을 수 없으므로 함수는 비어있는 목록 또는 하나의 오브젝트가있는 목록을 리턴합니다. 테이블 유형이 &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 인 경우, 함수는 임의 길이의 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="52326346a5221b9ea31e1cab3b15e1198497f8cc" translate="yes" xml:space="preserve">
          <source>If the table uses &lt;code&gt;==/2&lt;/code&gt; when comparing keys for equality, the &lt;code&gt;qlc&lt;/code&gt; module looks up the constant regardless of which operator is used in the QLC. However, &lt;code&gt;==/2&lt;/code&gt; is to be preferred:</source>
          <target state="translated">키가 동일한 지 비교할 때 테이블에서 &lt;code&gt;==/2&lt;/code&gt; 를 사용하는 경우, &lt;code&gt;qlc&lt;/code&gt; 모듈은 QLC에서 사용되는 연산자에 관계없이 상수를 찾습니다. 그러나 &lt;code&gt;==/2&lt;/code&gt; 가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c174173c48e462e86139389a0e63bdc440243b08" translate="yes" xml:space="preserve">
          <source>If the table was compressed.</source>
          <target state="translated">테이블이 압축 된 경우</target>
        </trans-unit>
        <trans-unit id="c18aa6aeb37dae91506c755f84a591f149b7a42e" translate="yes" xml:space="preserve">
          <source>If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows:</source>
          <target state="translated">대상 호스트가 &quot;특별한&quot;노드 인 경우 다음과 같이 구성 파일에 FTP 주소를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba53604fe2dbaeba0c697aca59ebed25bdd01e29" translate="yes" xml:space="preserve">
          <source>If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings):</source>
          <target state="translated">대상 호스트가 다른 호스트 (예 : UNIX 호스트) 인 경우 구성 파일에는 사용자 이름과 비밀번호 (두 문자열 모두)도 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="df661b54e46a56f3d279f98bcc4be4b32bc0814f" translate="yes" xml:space="preserve">
          <source>If the test case function crashes or exits purposely, it is considered &lt;strong&gt;failed&lt;/strong&gt;. If it returns a value (no matter what value), it is considered successful. An exception to this rule is the return value &lt;code&gt;{skip,Reason}&lt;/code&gt;. If this tuple is returned, the test case is considered skipped and is logged as such.</source>
          <target state="translated">테스트 케이스 기능이 충돌하거나 의도적으로 종료되면 &lt;strong&gt;실패한&lt;/strong&gt; 것으로 간주됩니다 . 값이 무엇이든 상관없이 값을 반환하면 성공한 것으로 간주됩니다. 이 규칙의 예외는 리턴 값 &lt;code&gt;{skip,Reason}&lt;/code&gt; 입니다. 이 튜플이 반환되면 테스트 사례는 건너 뛴 것으로 간주되어 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4997e9150d0cf8e0e80015106a039f2b0f15d2c2" translate="yes" xml:space="preserve">
          <source>If the test case returns the tuple &lt;code&gt;{comment,Comment}&lt;/code&gt;, the case is considered successful and &lt;code&gt;Comment&lt;/code&gt; is printed in the overview log file. This is equal to calling &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 사례가 &lt;code&gt;{comment,Comment}&lt;/code&gt; 튜플을 반환하면 사례가 성공한 것으로 간주 되고 개요가 파일에 &lt;code&gt;Comment&lt;/code&gt; 이 인쇄됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="60f08b0f13ca3dba151d2fa93224be6770ab9243" translate="yes" xml:space="preserve">
          <source>If the test is started with option &lt;code&gt;create_priv_dir&lt;/code&gt; set to &lt;code&gt;manual_per_tc&lt;/code&gt;, in order for the test case to use the private directory, it must first create it by calling this function.</source>
          <target state="translated">&lt;code&gt;create_priv_dir&lt;/code&gt; 옵션 을 &lt;code&gt;manual_per_tc&lt;/code&gt; 로 설정 하여 테스트를 시작한 경우 테스트 케이스가 개인 디렉토리를 사용하려면 먼저이 함수를 호출하여 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff477a5e0193222aeda2ed720ed9cd26684dd49a" translate="yes" xml:space="preserve">
          <source>If the test session is instead started with a call to &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt;, the result is that test &lt;code&gt;t1&lt;/code&gt; does not run on &lt;code&gt;ct_node@host_x&lt;/code&gt; (or any other node) while test &lt;code&gt;t3&lt;/code&gt; runs on both &lt;code&gt;ct_node@host_y&lt;/code&gt; and &lt;code&gt;ct_node@host_z&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt; 호출하여 테스트 세션을 시작 하면 테스트 &lt;code&gt;t1&lt;/code&gt; 이 &lt;code&gt;ct_node@host_x&lt;/code&gt; (또는 다른 노드) 에서 실행되지 않습니다. 테스트 &lt;code&gt;t3&lt;/code&gt; 은 &lt;code&gt;ct_node@host_y&lt;/code&gt; 및 &lt;code&gt;ct_node@host_z&lt;/code&gt; 모두에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="66bd8e7ff485cff1898efb9a85ff8aa7af9d4928" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt; Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">괄호 사이의 텍스트가 일련의 숫자로 구성된 경우 해당 번호의 캡처 하위 패턴이 이전에 일치하면 조건이 참입니다. 동일한 번호를 가진 캡처 링 하위 패턴이 둘 이상있는 경우 ( 앞서 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt; Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 하위 패턴 번호 섹션 참조 ) 일치하는 항목이 있으면 조건이 참입니다. 다른 표기법은 숫자 앞에 더하기 또는 빼기 부호를 붙이는 것입니다. 이 경우 하위 패턴 번호는 절대적이 아니라 상대적입니다. 가장 최근에 연 괄호는 (? (-1), 다음으로 가장 최근의 괄호는 (? (-2) 등으로 참조 할 수 있습니다. 루프 내부에서 후속 그룹을 참조하는 것도 의미가 있습니다. 다음 괄호는 be open은 (? (+ 1) 등으로 참조 할 수 있습니다. 이러한 형식의 값 0은 사용되지 않으며 컴파일 타임 오류를 유발합니다.)</target>
        </trans-unit>
        <trans-unit id="a10a6be714753d43b2d04e3f31a9e74da2fca330" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">괄호 안의 텍스트가 일련의 숫자로 구성된 경우 해당 번호의 캡처 하위 패턴이 이전에 일치 한 경우 조건이 적용됩니다. 동일한 번호를 가진 캡처 서브 패턴이 둘 이상 존재하는 경우 ( 이전에 &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; 서브 패턴 번호 섹션 참조 ) 조건이 일치하면 조건이 참입니다. 다른 표기법은 숫자 앞에 더하기 또는 빼기 부호를 붙이는 것입니다. 이 경우 하위 패턴 번호는 절대 값이 아니라 상대 값입니다. 가장 최근에 열린 괄호는 (? (-1), 다음으로 가장 최근의 (? (-2) 등)으로 참조 할 수 있습니다. 내부 루프에서도 후속 그룹을 참조하는 것이 좋습니다. 열림은 (? (+ 1) 등으로 참조 될 수 있습니다. (이러한 형식의 값 0은 사용되지 않으며 컴파일 타임 오류를 유발합니다.)</target>
        </trans-unit>
        <trans-unit id="6ca3d61691a2fc7b57ea4b8b07508db553495848" translate="yes" xml:space="preserve">
          <source>If the timer is of type &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;, then for each intermediate timout, the reply will be resent (this is valid until the ack is received or the timer expires).</source>
          <target state="translated">타이머가 &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; 유형 인 경우 각 중간 시간 초과에 대해 응답이 재전송됩니다 (ack가 수신되거나 타이머가 만료 될 때까지 유효 함).</target>
        </trans-unit>
        <trans-unit id="0e94483da50a1b3ed8b94f80ddcd411d6145f16b" translate="yes" xml:space="preserve">
          <source>If the trace tuple has five elements, the fifth element will be sent as the &lt;code&gt;extra&lt;/code&gt; value in the &lt;code&gt;Opts&lt;/code&gt; maps.</source>
          <target state="translated">추적 튜플에 5 개의 요소가 있으면 다섯 번째 요소가 &lt;code&gt;Opts&lt;/code&gt; 맵 에서 &lt;code&gt;extra&lt;/code&gt; 값 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ce02e8f59bcb0c0b8b781eb7d69a7e655a35279" translate="yes" xml:space="preserve">
          <source>If the traced node is diskless, &lt;code&gt;ttb&lt;/code&gt; must be started from a trace control node with disk access, and option &lt;code&gt;file&lt;/code&gt; must be specified to function &lt;code&gt;tracer/2&lt;/code&gt; with value &lt;code&gt;{local, File}&lt;/code&gt;, for example:</source>
          <target state="translated">추적 된 노드에 디스크가없는 경우 디스크 액세스 권한이있는 추적 제어 노드에서 &lt;code&gt;ttb&lt;/code&gt; 를 시작해야하며 옵션 &lt;code&gt;file&lt;/code&gt; 은 &lt;code&gt;{local, File}&lt;/code&gt; 값으로 &lt;code&gt;tracer/2&lt;/code&gt; 기능을 수행하도록 지정해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83ebb917b401f97bb196808428e528b58ff6d85f" translate="yes" xml:space="preserve">
          <source>If the tracing process/port dies or the tracer module returns &lt;code&gt;remove&lt;/code&gt;, the flags are silently removed.</source>
          <target state="translated">추적 프로세스 / 포트가 종료되거나 추적 프로그램 모듈이 &lt;code&gt;remove&lt;/code&gt; 를 리턴 하면 플래그가 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="73568089bc427934a8063420408d7fe082af563e" translate="yes" xml:space="preserve">
          <source>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt;. The tracing has to be stopped at a suitable later time using &lt;code&gt;fprof:trace(stop)&lt;/code&gt;.</source>
          <target state="translated">함수가 리턴 된 후 추적을 계속해야하는 경우 (예 &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt; 프로파일 링 할 프로세스를 생성하는 시작 함수 인 경우) fprof : apply (M, F, Args, [continue | OtherOpts])를 사용할 수 있습니다. &lt;code&gt;fprof:trace(stop)&lt;/code&gt; 사용하여 적절한 나중에 추적을 중지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1df5baebd9c38dac3e2f05812c6dc531db1c4b38" translate="yes" xml:space="preserve">
          <source>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback rejects the candidates, then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = failover&lt;/code&gt;. If a peer is selected then a &lt;code&gt;prepare_retransmit/3&lt;/code&gt; callback takes place, after which the semantics are the same as following an initial &lt;code&gt;prepare_request/3&lt;/code&gt; callback.</source>
          <target state="translated">요청이 전송 된 후 응답이 수신되기 전에 피어와의 전송 연결이 끊어지면 요청을 대체 피어로 다시 보내려고합니다. 그러한 피어를 사용할 수 없거나 후속 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백이 후보를 거부하면 &lt;code&gt;handle_error/4&lt;/code&gt; 콜백이 &lt;code&gt;Reason = failover&lt;/code&gt; 합니다. 피어가 선택된 경우, &lt;code&gt;prepare_retransmit/3&lt;/code&gt; 콜백이 발생하고, 그 후 시맨틱은 초기 &lt;code&gt;prepare_request/3&lt;/code&gt; 콜백 을 따르는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="94a9657c264118b8bd17be6e7ec65d9a46f4bb3e" translate="yes" xml:space="preserve">
          <source>If the upgrade or downgrade fails, the application can end up in an inconsistent state.</source>
          <target state="translated">업그레이드 또는 다운 그레이드에 실패하면 응용 프로그램이 일관성이없는 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf53bce4100d9193f2229bae322274401770092" translate="yes" xml:space="preserve">
          <source>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from &lt;code&gt;seq_trace:get_token/1&lt;/code&gt;) and include trace information in the message data sent to their respective ports.</source>
          <target state="translated">어떤 이유로 사용자가 추적 토큰을 포트로 전달하려면 포트 제어 프로세스 코드에서 수동으로 수행해야합니다. 포트 제어 프로세스는 &lt;code&gt;seq_trace:get_token/1&lt;/code&gt; 에서 얻은 순차 추적 설정을 확인하고 해당 포트로 전송 된 메시지 데이터에 추적 정보를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e2e034ddd571c04bf0e9592e1523dc28c51cfbb" translate="yes" xml:space="preserve">
          <source>If the user has configured transports &lt;strong&gt;with&lt;/strong&gt; options then those will take precedence over these options. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;agent information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="translated">사용자가 옵션을 사용하여 전송 &lt;strong&gt;을&lt;/strong&gt; 구성한 경우 해당 옵션이 이러한 옵션보다 우선합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;agent information&lt;/a&gt;&lt;/code&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="99b23a58d8baa9de2a26d48114ccdc0aba9a7898" translate="yes" xml:space="preserve">
          <source>If the user specifies a whole directory of test suites for the test, the execution order of the suites depends on how the files are listed by the operating system, which varies between systems.</source>
          <target state="translated">사용자가 테스트를 위해 전체 테스트 스위트 디렉토리를 지정하는 경우 스위트의 실행 순서는 운영 체제별로 파일이 나열되는 방식에 따라 달라지며 시스템마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ec74a0aa34a3fff9b86b849a4c4f4303fc09ca09" translate="yes" xml:space="preserve">
          <source>If the user wants to run all test suites for a test object (or an OTP application) by specifying only the top directory (for example, with start flag/option &lt;code&gt;dir&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; primarily looks for test suite modules in a subdirectory named &lt;code&gt;test&lt;/code&gt;. If this subdirectory does not exist, the specified top directory is assumed to be the test directory, and test suites are read from there instead.</source>
          <target state="translated">사용자가 (시작 플래그 / 옵션, 예를 들면 단지 상위 디렉토리를 지정하여 테스트 객체에 대한 모든 테스트 스위트 (또는 OTP 응용 프로그램)을 실행하고자 할 경우 &lt;code&gt;dir&lt;/code&gt; ), &lt;code&gt;Common Test&lt;/code&gt; 주로 하위 디렉토리 이름에서 테스트 스위트 모듈을 찾습니다 &lt;code&gt;test&lt;/code&gt; . 이 서브 디렉토리가 존재하지 않으면 지정된 최상위 디렉토리가 테스트 디렉토리 인 것으로 가정하고 대신 테스트 스위트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="effd9156da460f544cefc46b3b70768d9f3c1b10" translate="yes" xml:space="preserve">
          <source>If the user wants to update the record, it is more efficient to use &lt;code&gt;write/sticky_write&lt;/code&gt; as the &lt;code&gt;LockKind&lt;/code&gt;. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</source>
          <target state="translated">사용자가 레코드를 업데이트하고자하는 경우, 사용하는 것이 더 효율적입니다 &lt;code&gt;write/sticky_write&lt;/code&gt; 은 AS &lt;code&gt;LockKind&lt;/code&gt; . 테이블에서 다수 점검이 활성화 된 경우 쓰기 잠금이 시도 되 자마자 점검됩니다. 대부분의 조건이 충족되지 않으면 빠르게 종료하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0e7330d21e34b34dfa69e0d3eeb795d5ed2f32" translate="yes" xml:space="preserve">
          <source>If the user wants to view load values as percentage of machine capacity, then this way of measuring presents a problem, because the load values are not restricted to a fixed interval. In this case, the following simple mathematical transformation can produce the load value as a percentage:</source>
          <target state="translated">사용자가 부하 값을 기계 용량의 백분율로보고자하는 경우,이 측정 방법은 부하 값이 고정 된 간격으로 제한되지 않기 때문에 문제가됩니다. 이 경우 다음과 같은 간단한 수학적 변환으로 하중 값을 백분율로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02fc968f89b25d7af28da18289c9216741ffd871" translate="yes" xml:space="preserve">
          <source>If the user's DSA, RSA or ECDSA key is protected by a passphrase, it can be supplied with thoose options.</source>
          <target state="translated">사용자의 DSA, RSA 또는 ECDSA 키가 암호 문구로 보호되는 경우 선택 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="753352e4298655af61f31e670724bf4c6d758094" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;Value&lt;/code&gt; is equal to the value previously stored for the key, &lt;code&gt;put/2&lt;/code&gt; will do nothing and return quickly.</source>
          <target state="translated">값 경우 &lt;code&gt;Value&lt;/code&gt; 이전 키에 저장된 값, 동일 &lt;code&gt;put/2&lt;/code&gt; 아무것도하지 않고 빠르게 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="3cf4ed00376d14751e45211a8a3a5480eebc775a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt; (passive mode), the process must explicitly receive incoming data by calling &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (depending on the type of socket).</source>
          <target state="translated">값이 &lt;code&gt;false&lt;/code&gt; (수동 모드) 인 경우 프로세스는 소켓 유형에 따라 &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; 를 호출하여 수신 데이터를 명시 적으로 수신해야합니다 . ).</target>
        </trans-unit>
        <trans-unit id="f8c0f324daf0fe9bcb732c8ba7fcf4c76dd808ad" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt;, Igor will read source files without passing them through the Erlang preprocessor (&lt;code&gt;epp&lt;/code&gt;), in order to avoid expansion of preprocessor directives such as &lt;code&gt;-include(...).&lt;/code&gt;, &lt;code&gt;-define(...).&lt;/code&gt; and &lt;code&gt;-ifdef(...)&lt;/code&gt;, and macro calls such as &lt;code&gt;?LINE&lt;/code&gt; and &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;, i.e., preprocessing is not done. (See the module &lt;code&gt;epp_dodger&lt;/code&gt; for details.)</source>
          <target state="translated">값이 &lt;code&gt;false&lt;/code&gt; 인 경우 Igor는 &lt;code&gt;-include(...).&lt;/code&gt; 와 같은 전 처리기 지시문의 확장을 피하기 위해 Erlang 전 처리기 ( &lt;code&gt;epp&lt;/code&gt; )를 통해 소스 파일을 전달하지 않고 소스 파일을 읽습니다 . , &lt;code&gt;-define(...).&lt;/code&gt; 및 &lt;code&gt;-ifdef(...)&lt;/code&gt; 와 같은 매크로 호출 &lt;code&gt;?LINE&lt;/code&gt; 와 &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt; . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다 . 즉, 전처리가 수행되지 않습니다. (자세한 내용은 &lt;code&gt;epp_dodger&lt;/code&gt; 모듈 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="c37d2b8a16c01a498b8f51d057c13420aaeecac6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;once&lt;/code&gt; (&lt;code&gt;{active, once}&lt;/code&gt;), &lt;strong&gt;one&lt;/strong&gt; data message from the socket is sent to the process. To receive one more message, &lt;code&gt;setopts/2&lt;/code&gt; must be called again with option &lt;code&gt;{active, once}&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;once&lt;/code&gt; 이면 ( &lt;code&gt;{active, once}&lt;/code&gt; ) 소켓에서 &lt;strong&gt;하나의&lt;/strong&gt; 데이터 메시지가 프로세스로 전송됩니다. 하나 이상의 메시지를 수신하려면 &lt;code&gt;{active, once}&lt;/code&gt; 옵션으로 &lt;code&gt;setopts/2&lt;/code&gt; 를 다시 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0edabfc9ae44692cbce9f0269af3098b558ce7c2" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all &lt;code&gt;-import(...)&lt;/code&gt; declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 원래 코드의 모든 &lt;code&gt;-import(...)&lt;/code&gt; 선언이 결과에서 확장됩니다. 그렇지 않으면 원래 수입 신고서의 최대한 많은 내용이 보존됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ec9a61337586e188fec4ae4002aa86a696c3f2b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all import statements will be removed and calls to imported functions will be expanded to explicit remote calls. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 모든 가져 오기 문이 제거되고 가져온 함수에 대한 호출이 명시 적 원격 호출로 확장됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b8cea8ff6b46a563bc83a9fce55c5e6cf84c9e7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all information messages and warning messages will be suppressed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 모든 정보 메시지 및 경고 메시지가 표시되지 않습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3bccb9c8103eb8444c9724207cd93db68090eda5" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all matches &quot;&lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt;&quot; where &lt;code&gt;E&lt;/code&gt; is a case-, if- or receive-expression whose branches all return n-tuples (or explicitly throw exceptions) will be rewritten to bind and export the variables &lt;code&gt;V1&lt;/code&gt;, ..., &lt;code&gt;Vn&lt;/code&gt; directly. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 &quot; &lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt; &quot; 와 일치합니다. 여기서 &lt;code&gt;E&lt;/code&gt; 는 브랜치가 모두 n- 튜플을 반환하는 (또는 명시 적으로 예외를 throw하는) 경우, if 또는 receive 표현입니다. 변수 &lt;code&gt;V1&lt;/code&gt; , ..., &lt;code&gt;Vn&lt;/code&gt; 을 직접 바인딩하고 내보내려면 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e252402ddfc7629809ad75d385749bf1c28429eb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all options that affect how the code is modified are set to &quot;no changes&quot;. For example, to only update guard tests, and nothing else, use the options &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt;. (Recall that options closer to the beginning of the list have higher precedence.)</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 코드 수정 방법에 영향을주는 모든 옵션이 &quot;변경 사항 없음&quot;으로 설정됩니다. 예를 들어, 가드 테스트 만 업데이트하고 다른 업데이트는하지 않으려면 &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt; 옵션을 사용하십시오 . (목록의 시작 부분에 가까울수록 옵션이 우선 순위가 높습니다.)</target>
        </trans-unit>
        <trans-unit id="661aadd35dfccaaf93a78302865c3cfe6ab3529d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, calls to &lt;code&gt;lists:map/2&lt;/code&gt; and &lt;code&gt;lists:filter/2&lt;/code&gt; will be rewritten using list comprehensions. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;lists:map/2&lt;/code&gt; 및 &lt;code&gt;lists:filter/2&lt;/code&gt; 호출 은 list comprehensions를 사용하여 다시 작성됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db560d66c74e2b5edc2b415e1318b63374234171" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the &lt;code&gt;backup_suffix&lt;/code&gt; option to the original name. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 쓰기 위해 새 파일을 열기 전에 기존 파일의 이름이 바뀝니다. 새로운 이름은 &lt;code&gt;backup_suffix&lt;/code&gt; 옵션이 제공 한 문자열 을 원래 이름 에 추가하여 구성됩니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f45a2885644fae2f95e314f116a38cf230d32c75" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be changed to use the old names instead of the new ones, e.g. &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;false&lt;/code&gt;. This option overrides the &lt;code&gt;new_guard_tests&lt;/code&gt; option.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 가드 테스트는 새 이름 대신 이전 이름을 사용하도록 변경됩니다 &lt;code&gt;integer(X)&lt;/code&gt; 예 : &quot; &lt;code&gt;is_integer(X)&lt;/code&gt; &quot; 대신 &quot; integer (X) &quot; ) . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이 옵션은 &lt;code&gt;new_guard_tests&lt;/code&gt; 옵션보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="fd7cd8fb5c207c507a51e1775733171389edb7af" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be updated to use the new names, e.g. &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;true&lt;/code&gt;. See also &lt;code&gt;old_guard_tests&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 새 &lt;code&gt;integer(X)&lt;/code&gt; 를 사용하도록 가드 테스트가 업데이트됩니다 &lt;code&gt;is_integer(X)&lt;/code&gt; 예 : &quot; integer (X) &quot; 대신 &quot; is_integer (X) &quot; ) . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. &lt;code&gt;old_guard_tests&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3065ef5e6ab38f54db2ee2363766ab33259e9b9" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, instead of the file being written to disk it will be printed to stdout. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 파일을 디스크에 쓰는 대신 stdout에 인쇄합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54052ea83b3ce0b0af928cdbcc55b6fae8e4433d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 대상 모듈의 이름이 입력 모듈과 동일하지 않더라도 결과 모듈 상단에 배너 주석이 추가되지 않습니다. 대신 Igor는 코드가 출력의 맨 위에있는 모듈의 모양을 유지하려고합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f87660fc4a181394247f96baa377c54c6755f37" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 파일이 수정되지 않습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df3ab32bc54bd17610cc1947d346139f4464db6e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified; this is typically most useful if the &lt;code&gt;verbose&lt;/code&gt; flag is enabled, to generate reports about the program files without affecting them. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 파일이 수정되지 않습니다. 이는 일반적으로 &lt;code&gt;verbose&lt;/code&gt; 플래그가 사용 가능한 경우 영향을주지 않고 프로그램 파일에 대한 보고서를 생성 하는 데 가장 유용 합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c857b2ddea91c4f1382dc10632fa790ebcc157d4" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is &lt;code&gt;false&lt;/code&gt;, which means that section headers are normally added whenever more than two or more modules are merged.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 특정 입력 모듈에서 생성 된 각 코드 섹션 시작 부분에 결과 모듈에 헤더 주석이 추가되지 않습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 이며, 둘 이상의 모듈이 병합 될 때마다 섹션 헤더가 일반적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f7502caa9d0a180e8b6ee5deb22eb2a7558a013b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, preprocessing will be done when reading the source code. See &lt;code&gt;merge_files/4&lt;/code&gt; for details.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 소스 코드를 읽을 때 전처리가 수행됩니다. 자세한 내용은 &lt;code&gt;merge_files/4&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ba203d3ce53c0ee7058adbf1504acdd24b9e757" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;quiet&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 가 아닌 한 프로그램이 실행되는 동안 진행 메시지가 출력됩니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="915746ee8197f7425e23cffea24b153e1f1e18c8" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value when calling &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;quiet&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 가 아닌 한 프로그램이 실행되는 동안 진행 메시지가 출력됩니다 . &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; 를 호출 할 때의 기본값 은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b91774a83e666475650d9139217c76fff02c41ca" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running; the default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 프로그램이 실행되는 동안 진행 메시지가 출력됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87c71038a7138f9d28b15166013d2ec5e72ecbcc" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, source code comments in the original files will be preserved in the output. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 원본 파일의 소스 코드 주석이 출력에 유지됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40369b32150fd62bc05caf551bc811ec5c61e8d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 대상 모듈과 이름이 같지 않은 내 보낸 모든 모듈에 대해 스텁 모듈 파일이 자동으로 생성됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b9de1f4216e6f225a7647de788bed6302d6db97" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, subdirectories will be visited recursively. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 서브 디렉토리가 재귀 적으로 방문됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8586c382194eee0170ba6e0221153350f302413e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, symbolic directory links will be followed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 기호 디렉토리 링크가 따라옵니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3143c0f4c2f0487a47c16bc04f718d7c6ca270ba" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the resulting code will be processed using the &lt;code&gt;erl_tidy&lt;/code&gt; module, which removes unused functions and does general code cleanup. (See &lt;code&gt;erl_tidy:module/2&lt;/code&gt; for additional options.) The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 결과 코드는 &lt;code&gt;erl_tidy&lt;/code&gt; 모듈을 사용하여 처리됩니다.이 모듈은 사용되지 않는 함수를 제거하고 일반 코드 정리를 수행합니다. ( 추가 옵션 은 &lt;code&gt;erl_tidy:module/2&lt;/code&gt; 를 참조하십시오 .) 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d698e4a7611a1338e29756a796838536c672223" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, this is equivalent to listing all of the input modules in the &lt;code&gt;export&lt;/code&gt; option. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 인 경우 이는 &lt;code&gt;export&lt;/code&gt; 옵션 에 모든 입력 모듈을 나열하는 것과 같습니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="365ed702372c3b3974abae9c5b1bac335c2e40e6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, unused functions will not be removed from the code. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 사용되지 않는 함수가 코드에서 제거되지 않습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c43f17f91393f09fcaccf937fae28a97b0723f0d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, which is the default, everything received from the socket is sent as messages to the receiving process.</source>
          <target state="translated">기본값 인 값이 &lt;code&gt;true&lt;/code&gt; 이면 소켓에서 수신 된 모든 것이 메시지로 수신 프로세스에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8c39732459bb5c7d2ede3da9e66866784c1270ea" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, all file attributes &lt;code&gt;-file(...)&lt;/code&gt; in the input sources will be preserved in the resulting code. If the value is &lt;code&gt;comment&lt;/code&gt;, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is &lt;code&gt;no&lt;/code&gt;, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the &lt;code&gt;comment&lt;/code&gt; case. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;yes&lt;/code&gt; 이면 입력 소스의 모든 파일 속성 &lt;code&gt;-file(...)&lt;/code&gt; 이 결과 코드에 유지됩니다. 값이 &lt;code&gt;comment&lt;/code&gt; 인 경우 주석 으로 바뀌지 만 다른 소스 코드 형식과 비교하여 코드에서 원래 위치에 남아 있습니다. 값이 &lt;code&gt;no&lt;/code&gt; 이면 주석을 첨부하지 않은 경우 모든 파일 속성이 코드에서 제거되며,이 경우 &lt;code&gt;comment&lt;/code&gt; 에서와 같이 처리됩니다 . 기본값은 &lt;code&gt;no&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="adbcfdf4ba5a2347d9fb627ce201117dc5c0ef19" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, comments will be inserted where important changes have been made in the code. If the value is &lt;code&gt;always&lt;/code&gt;, &lt;strong&gt;all&lt;/strong&gt; changes to the code will be commented. If the value is &lt;code&gt;no&lt;/code&gt;, changes will be made without comments. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;yes&lt;/code&gt; 인 경우 코드에서 중요한 변경이 이루어진 곳에 주석이 삽입됩니다. 값이 &lt;code&gt;always&lt;/code&gt; 인 경우 코드에 대한 &lt;strong&gt;모든&lt;/strong&gt; 변경 사항에 주석이 달립니다. 값이 &lt;code&gt;no&lt;/code&gt; 이면 주석없이 변경됩니다. 기본값은 &lt;code&gt;yes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f6e4b8b19f612e8db0497538210759f4a802a7a" translate="yes" xml:space="preserve">
          <source>If the value is an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is &lt;code&gt;0&lt;/code&gt;. If a negative value is specified, and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to &lt;code&gt;0&lt;/code&gt;. Once the socket's message count reaches &lt;code&gt;0&lt;/code&gt;, either because of sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages &lt;code&gt;setopts/2&lt;/code&gt; must be called again to set the socket back into an active mode.</source>
          <target state="translated">값이 -32768-32767 (포함) 범위 의 정수 &lt;code&gt;N&lt;/code&gt; 인 경우 제어 프로세스로 전송 된 소켓의 데이터 메시지 수에 값이 추가됩니다. 소켓의 기본 메시지 수는 &lt;code&gt;0&lt;/code&gt; 입니다. 음수 값을 지정하고 해당 크기가 소켓의 현재 메시지 수 이상인 경우 소켓의 메시지 수는 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 수신 된 메시지를 프로세스로 전송하거나 명시 적으로 설정 하여 소켓의 메시지 수가 &lt;code&gt;0&lt;/code&gt; 에 도달하면 소켓 유형에 따라 특수 메시지를 통해 프로세스에 소켓이 수동 모드로 들어갔다는 알림이 표시됩니다. 소켓이 수동 모드로 들어가면 더 많은 메시지를 수신하기 위해 &lt;code&gt;setopts/2&lt;/code&gt; 소켓을 다시 활성 모드로 설정하려면 다시 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d64e50bdb357fa38cbabe7df4a1ba284de8e2a3" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is not changed. To reset unspecified data to default values, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;config&lt;/code&gt; 키 의 경우처럼 값이 불완전한 경우 지정되지 않은 부분이 설정되는 방법은 처리기 구현에 달려 있습니다. 커널 애플리케이션의 모든 핸들러에 대해 &lt;code&gt;config&lt;/code&gt; 키의 지정되지 않은 데이터 는 변경되지 않습니다. 지정되지 않은 데이터를 기본값으로 재설정하려면 &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config/3&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5530eeda0dbd39b2cfac3192200b6c910a3a3fc5" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is set to default values. To update only specified data, and keep the existing configuration for the rest, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-3&quot;&gt; update_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;config&lt;/code&gt; 키 의 경우처럼 값이 불완전한 경우 지정되지 않은 부분이 설정되는 방법은 처리기 구현에 달려 있습니다. 커널 애플리케이션의 모든 핸들러에 대해 &lt;code&gt;config&lt;/code&gt; 키의 지정되지 않은 데이터 가 기본값으로 설정됩니다. 지정된 데이터 만 업데이트하고 나머지는 기존 구성을 유지하려면 &lt;code&gt;&lt;a href=&quot;#update_handler_config-3&quot;&gt; update_handler_config/3&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f27ae6e2444bd7a3381110a92ec6a09bd736a61c" translate="yes" xml:space="preserve">
          <source>If the value is unreached, the socket closes for that connection.</source>
          <target state="translated">값에 도달하지 않으면 해당 연결을 위해 소켓이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f1873f4ce26bcbe85d55d9e02a463ab1ca24901c" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;keep_labels&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default, the &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; of vertices and edges of &lt;code&gt;Digraph&lt;/code&gt; are used for the subgraph as well. If the value is &lt;code&gt;false&lt;/code&gt;, default label &lt;code&gt;[]&lt;/code&gt; is used for the vertices and edges of the subgroup.</source>
          <target state="translated">옵션의 값 경우 &lt;code&gt;keep_labels&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; 기본 인,의 &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; 정점과 가장자리의 &lt;code&gt;Digraph&lt;/code&gt; 뿐만 아니라 서브 그래프에 사용됩니다. 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 하위 레이블 의 정점과 가장자리에 기본 레이블 &lt;code&gt;[]&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff461d2c9c387ebf9328f2e5d5e82024d6aaa59" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션의 값 경우 &lt;code&gt;type&lt;/code&gt; 이다 &lt;code&gt;inherit&lt;/code&gt; 의 기본 인,의 유형 &lt;code&gt;Digraph&lt;/code&gt; 뿐만 아니라 서브 그래프에 사용됩니다. 그렇지 않으면 &lt;code&gt;type&lt;/code&gt; 의 옵션 값이 &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; 의 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcc67adc4c7849178ee3be6d998ddde43abc28f4" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;digraph:new/1&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;type&lt;/code&gt; 의 값 이 &lt;code&gt;inherit&lt;/code&gt; 인 경우 (기본값) &lt;code&gt;Digraph&lt;/code&gt; 의 유형이 서브 그래프에도 사용됩니다. 그렇지 않으면 &lt;code&gt;type&lt;/code&gt; 의 옵션 값이 &lt;code&gt;digraph:new/1&lt;/code&gt; 의 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba47bdc09cc087bab1feb6d4f337fa682850229e" translate="yes" xml:space="preserve">
          <source>If the values listed in &lt;code&gt;os_mon.app&lt;/code&gt; do not suit your needs, do &lt;strong&gt;not&lt;/strong&gt; edit that file. Instead &lt;strong&gt;override&lt;/strong&gt; the values in a &lt;strong&gt;system configuration file&lt;/strong&gt;, the full pathname of which is given on the command line to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os_mon.app&lt;/code&gt; 에 나열된 값이 필요에 맞지 &lt;strong&gt;않으면&lt;/strong&gt; 해당 파일을 편집 하지 &lt;strong&gt;마십시오&lt;/strong&gt; . 대신 &lt;strong&gt;시스템 구성 파일&lt;/strong&gt; 의 값을 &lt;strong&gt;대체&lt;/strong&gt; 하십시오 . 전체 경로 이름은 명령 행에 &lt;code&gt;erl&lt;/code&gt; 로 지정되어 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637ddb8332f78117eadb8a8c376db3cd6652f59a" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;V&lt;/code&gt; is unbound, it becomes bound to the value associated with the key &lt;code&gt;K&lt;/code&gt;, which must exist in the map &lt;code&gt;M&lt;/code&gt;. If the variable &lt;code&gt;V&lt;/code&gt; is bound, it must match the value associated with &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">변수 &lt;code&gt;V&lt;/code&gt; 가 바인드되지 않은 경우, 키 &lt;code&gt;K&lt;/code&gt; 와 연관된 값에 바인드되며,이 키 는 맵 &lt;code&gt;M&lt;/code&gt; 에 있어야합니다 . 변수 경우 &lt;code&gt;V&lt;/code&gt; 가 결합되어, 그것과 관련된 값과 일치해야합니다 &lt;code&gt;K&lt;/code&gt; 에서 &lt;code&gt;M&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e06ed1ef13287cb442c8f8b9883fc1684b5a4b49" translate="yes" xml:space="preserve">
          <source>If the variable is set to &lt;code&gt;0&lt;/code&gt; seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">변수가 &lt;code&gt;0&lt;/code&gt; 초로 설정 되면 런타임 시스템은 크래시 덤프 파일 쓰기도 시도하지 않습니다. 종료 만됩니다. 이 옵션의 경우 기본입니다 &lt;code&gt;-heart&lt;/code&gt; 전달됩니다 &lt;code&gt;erl&lt;/code&gt; 과 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 가 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="259fac0804e610fe7290a6be7722e9d68bc70fed" translate="yes" xml:space="preserve">
          <source>If the variable is set to a positive value &lt;code&gt;S&lt;/code&gt;, wait for &lt;code&gt;S&lt;/code&gt; seconds to complete the crash dump file and then terminates the runtime system with a &lt;code&gt;SIGALRM&lt;/code&gt; signal.</source>
          <target state="translated">변수가 양의 값으로 설정되어 있으면 &lt;code&gt;S&lt;/code&gt; 에 대한 대기 &lt;code&gt;S&lt;/code&gt; 의 초 충돌 덤프 파일을 완료하고 다음으로 런타임 시스템을 종료하는 &lt;code&gt;SIGALRM&lt;/code&gt; 의 신호.</target>
        </trans-unit>
        <trans-unit id="f5ca06888e679b9ce4fb0be32462ee441fe3c9ca" translate="yes" xml:space="preserve">
          <source>If the verify callback fun always returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</source>
          <target state="translated">콜백 확인 기능이 항상 &lt;code&gt;{valid, UserState}&lt;/code&gt; 반환 하면 TLS / DTLS 핸드 셰이크는 확인 실패와 관련하여 종료되지 않으며 연결이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="719c8b9484d3005b5e9e676b6c959670afe78ad3" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</source>
          <target state="translated">콜백 확인 기능이 &lt;code&gt;{fail, Reason}&lt;/code&gt; 반환 하면 확인 프로세스가 즉시 중지되고 경고가 피어에게 전송되고 TLS / DTLS 핸드 셰이크가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="cde2fb6c16d058822f25ed6337c5a200ce4ffc36" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped. If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process is continued. This can be used to accept specific path validation errors, such as &lt;code&gt;selfsigned_peer&lt;/code&gt;, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">콜백 확인 기능이 &lt;code&gt;{fail, Reason}&lt;/code&gt; 반환 하면 확인 프로세스가 즉시 중지됩니다. 콜백 확인 기능이 &lt;code&gt;{valid, UserState}&lt;/code&gt; 반환 하면 확인 프로세스가 계속됩니다. 이는 &lt;code&gt;selfsigned_peer&lt;/code&gt; 와 같은 특정 경로 유효성 검증 오류를 승인하고 애플리케이션 별 확장을 확인하는 데 사용될 수 있습니다 . 사용자 애플리케이션에 알려지지 않은 확장자로 호출 된 경우, 리턴 값 &lt;code&gt;{unknown, UserState}&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce417b1938b35d2181946cc1bbef96b4151dd19" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process continues.</source>
          <target state="translated">콜백 확인 기능이 &lt;code&gt;{valid, UserState}&lt;/code&gt; 반환 하면 확인 프로세스가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="0df79b705a85e7a2500ba7951bd6d85a1ee9ec5b" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">개발 시스템 의 &lt;code&gt;OTP_VERSION&lt;/code&gt; 파일에서 읽은 버전 에 &lt;code&gt;**&lt;/code&gt; 접미사가 &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; 시스템은 otp_patch_apply 도구를 사용하여 패치 된 것 입니다. 이 경우 시스템은 여러 OTP 버전의 응용 프로그램 버전으로 구성됩니다. &lt;code&gt;**&lt;/code&gt; 접미사 앞의 버전은 패치 된 기본 시스템의 OTP 버전에 해당합니다. &lt;code&gt;otp_patch_apply&lt;/code&gt; 이외의 다른 방법으로 개발 시스템을 업데이트 하면 &lt;code&gt;OTP_VERSION&lt;/code&gt; 파일 이 잘못된 OTP 버전을 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e21657b92f7a7a61994f9d4f2c34a81fd507ae44" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;otp_patch_apply&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">개발 시스템 의 &lt;code&gt;OTP_VERSION&lt;/code&gt; 파일에서 읽은 버전 에 &lt;code&gt;**&lt;/code&gt; 접미사가 &lt;code&gt;otp_patch_apply&lt;/code&gt; 시스템이 otp_patch_apply 도구를 사용하여 패치 된 것 입니다. 이 경우 시스템은 여러 OTP 버전의 애플리케이션 버전으로 구성됩니다. &lt;code&gt;**&lt;/code&gt; 접미사 앞의 버전은 패치 된 기본 시스템의 OTP 버전에 해당합니다. 개발 시스템이 아닌 다른 방법으로 업데이트하면 것을 알 수 &lt;code&gt;otp_patch_apply&lt;/code&gt; , 파일 &lt;code&gt;OTP_VERSION&lt;/code&gt; 이 잘못된 OTP 버전을 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f230a4391a7ac08d14e4fb4510c5ba298ff9d5d7" translate="yes" xml:space="preserve">
          <source>If the wrap log is not full because all files are not yet used, &lt;code&gt;{error, end_of_log}&lt;/code&gt; is returned if trying to step outside the log.</source>
          <target state="translated">모든 파일이 아직 사용되지 않아 랩 로그가 가득 &lt;code&gt;{error, end_of_log}&lt;/code&gt; 않은 경우 로그 외부로 나 가려고하면 {error, end_of_log} 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f46b1e432470475ec50697579521d2c2bae67ee6" translate="yes" xml:space="preserve">
          <source>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</source>
          <target state="translated">그런 다음 모듈의 새 인스턴스가로드되면 (예 : 오류 수정으로 인해) 이전 인스턴스의 코드가 '이전'이되고 이전 인스턴스를 참조하는 모든 내보내기 항목이 제거됩니다. 그 후 새 인스턴스가 처음으로로드되고 '현재'가됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c29be5cd8e91fa1db97518d47656645435250e" translate="yes" xml:space="preserve">
          <source>If there already exists a child specification with the specified identifier, &lt;code&gt;ChildSpec&lt;/code&gt; is discarded, and the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt;, depending on if the corresponding child process is running or not.</source>
          <target state="translated">지정된 식별자를 가진 하위 스펙이 이미있는 경우 &lt;code&gt;ChildSpec&lt;/code&gt; 은 삭제되고 해당 하위 프로세스가 실행 중인지 여부에 따라 &lt;code&gt;{error,already_present}&lt;/code&gt; 또는 &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="29f67842a562c035ba90f5d1c233372af3669459" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupBridgeName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">지정된 &lt;code&gt;SupBridgeName&lt;/code&gt; 을 가진 프로세스가 이미 존재하는 경우 , 함수는 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 해당 프로세스의 pid입니다.</target>
        </trans-unit>
        <trans-unit id="b068d3b22b44bd5f6e7c211c147d05d61566b01d" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">지정된 &lt;code&gt;SupName&lt;/code&gt; 을 가진 프로세스가 이미 존재하는 경우 , 함수는 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 해당 프로세스의 pid입니다.</target>
        </trans-unit>
        <trans-unit id="b8fb3b2e8b37c9a0306fd62b9b9f0fc3fa52b199" translate="yes" xml:space="preserve">
          <source>If there already is current code for the module, that code will remain current and can be called until the &lt;code&gt;on_load&lt;/code&gt; function has returned. If the &lt;code&gt;on_load&lt;/code&gt; function fails, the current code (if any) will remain current. If there is no current code for a module, any process that makes an external call to the module before the &lt;code&gt;on_load&lt;/code&gt; function has finished will be suspended until the &lt;code&gt;on_load&lt;/code&gt; function have finished.</source>
          <target state="translated">모듈에 대한 현재 코드가 이미있는 경우 해당 코드는 최신 상태로 유지되며 &lt;code&gt;on_load&lt;/code&gt; 함수가 반환 될 때까지 호출 할 수 있습니다 . 는 IF &lt;code&gt;on_load&lt;/code&gt; 의 함수가 실패, 현재 코드 (있는 경우) 현재 남아있게됩니다. 모듈에 대한 현재 코드의 전 모듈에 외부 호출하게 모든 프로세스가없는 경우 &lt;code&gt;on_load&lt;/code&gt; 의 때까지 정지됩니다 완료 기능 &lt;code&gt;on_load&lt;/code&gt; 의 기능을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="e6ff40b943ba1d358ca3fc56a993cb85906a59fb" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence.</source>
          <target state="translated">대기열에 포함 된 이벤트가 있는 경우 새 상태에 대한 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 이 대기열 에 포함 된 가장 오래된 이벤트와 함께 호출되고이 시퀀스의 맨 위에서 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="828714b66dcf56b96deedb054ba47d438cc6af67" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this list.</source>
          <target state="translated">대기열에 포함 된 이벤트가있는 경우 가능한 가장 새로운 상태에 대한 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; 이 가장 오래된 대기열에 포함 된 이벤트와 함께 호출되며이 목록의 맨 위에서 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e9b0222c78d7e23a53bc0a01971716c3d93b0537" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt; erlang:garbage_collect/0 &lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">최대 절전 모드가 요청 될 때 처리 할 대기열에 추가 된 이벤트가있는 경우, 이는 최대 절전 모드가 아닌 대신 &lt;code&gt; erlang:garbage_collect/0 &lt;/code&gt; 을 호출 하여 &lt;code&gt;gen_statem&lt;/code&gt; 이 최대 절전 모드에 들어갔고 대기열에 추가 된 이벤트에 의해 즉시 깨어 난 것을 시뮬레이션하여 최적화 됩니다.</target>
        </trans-unit>
        <trans-unit id="44555dd341d5b0e52ff1661ee5eda131159416ee" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">동면 요청이있을 때 처리 할 대기열에있는 이벤트가있는 경우, 동면하지 않고 &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; 을 호출 하여 &lt;code&gt;gen_statem&lt;/code&gt; 이 동면 상태에 들어가서 대기열에있는 이벤트에 의해 즉시 깨어 났음 을 시뮬레이션합니다 .</target>
        </trans-unit>
        <trans-unit id="8322fe14ba9a9426d69e7f2423c508cc09e9ca48" translate="yes" xml:space="preserve">
          <source>If there are more than one modify_algorithms options, the result is undefined.</source>
          <target state="translated">하나 이상의 modify_algorithms 옵션이 있으면 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3690ce212d6493d7841d406b4cec0802d81f2e96" translate="yes" xml:space="preserve">
          <source>If there are no more associations in the iterator, &lt;code&gt;none&lt;/code&gt; is returned.</source>
          <target state="translated">반복자에 더 이상 연관이 없으면 &lt;code&gt;none&lt;/code&gt; 리턴 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e9815b352e2d989c9ac48ca673c35c72745e841d" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is not recommended to use this atom as the key for any user records.</source>
          <target state="translated">테이블에 레코드가 없으면이 함수는 atom &lt;code&gt;'$end_of_table'&lt;/code&gt; 리턴합니다 . 이 원자를 사용자 레코드의 키로 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="45cad60d0486a292ed0c0af70654056064441d58" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</source>
          <target state="translated">테이블에 레코드가 없으면이 함수는 atom &lt;code&gt;'$end_of_table'&lt;/code&gt; 리턴합니다 . 따라서이 원자를 사용자 레코드의 키로 사용하는 것은 바람직하지 않지만 허용되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8503df3ac3ca7273d732e58802cad2a3a0dfc645" translate="yes" xml:space="preserve">
          <source>If there are no suitable peers, or if &lt;code&gt;pick_peer/4&lt;/code&gt; rejects them by returning &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;{error,no_connection}&lt;/code&gt; is returned. Otherwise &lt;code&gt;pick_peer/4&lt;/code&gt; is followed by a &lt;code&gt;prepare_request/3&lt;/code&gt; callback, the message is encoded and then sent.</source>
          <target state="translated">거기에 더 적합한 또래없는 경우 또는 경우 &lt;code&gt;pick_peer/4&lt;/code&gt; 반환하여 거부를 &lt;code&gt;false&lt;/code&gt; 한 후 &lt;code&gt;{error,no_connection}&lt;/code&gt; 반환됩니다. 그렇지 않으면 &lt;code&gt;pick_peer/4&lt;/code&gt; 다음에 준비 _ 요청 &lt;code&gt;prepare_request/3&lt;/code&gt; 콜백 이 이어지며 메시지가 인코딩 된 후 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="17bbd36158389d16f581ae00cabe7d0d4b0d0c37" translate="yes" xml:space="preserve">
          <source>If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">연결에 열린 NETCONF 세션이있는 경우 잔인하게 중단됩니다. 이를 피하려면 &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt; 로 각 세션을 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="744bfeb045fa800e48c24a368ddf960ab780e491" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">운전자의 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 있다면 , 운전자의 참조 카운트는 단지 감소되어, 발신자는 더 이상 운전자 의 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 로 간주되지 않는다 . 사용 시나리오 는이 모듈의 시작 부분에 있는 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad1eb612ef6dd4e45361d0987788045dfb4b5f75" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">운전자의 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가있는 경우 , 운전자의 참조 횟수는 감소되어 발신자가 더 이상 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 간주되지 않습니다 . 사용 시나리오 는이 모듈의 시작 부분에 있는 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a3b63451c0aef92b5965292576792be22d886c0" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this driver, the function returns &lt;code&gt;{error, pending_process}&lt;/code&gt;, but if there are no other users, the function call hangs until all open ports are closed.</source>
          <target state="translated">이 드라이버의 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가있는 경우 함수는 &lt;code&gt;{error, pending_process}&lt;/code&gt; 리턴 하지만 다른 사용자가없는 경우 열려있는 모든 포트가 닫힐 때까지 함수 호출이 정지됩니다.</target>
        </trans-unit>
        <trans-unit id="ddfc5d95528ec782f6cb446ae853ade32ce2c1f9" translate="yes" xml:space="preserve">
          <source>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</source>
          <target state="translated">두 개의 활성 테이블 복제본이있는 경우 하나의 복제본이 실패해도 모든 정보를 계속 사용할 수 있습니다. 이것은 많은 응용 프로그램에서 중요한 속성이 될 수 있습니다. 또한 테이블 복제본이 두 개의 특정 노드에 존재하는 경우 이러한 노드 중 하나에서 실행되는 응용 프로그램은 네트워크에 액세스하지 않고도 테이블에서 데이터를 읽을 수 있습니다. 네트워크 작업은 로컬 작업보다 상당히 느리고 많은 리소스를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="4c985df66903880210d4fc66a0001c590df114fc" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;erase/1&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 관련된 이전 영구 용어 가있는 경우 &lt;code&gt;erase/1&lt;/code&gt; 이 반환 될 때 전역 GC가 시작되었습니다 . &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="370b7e007fd730b4b67804cb8f3411b765c85a30" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;put/2&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 와 관련된 이전 영구 용어 가있는 경우 &lt;code&gt;put/2&lt;/code&gt; 가 반환 될 때 전역 GC가 시작되었습니다 . &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02a74b61b8a7a65ef993947d91f15d8fda49a9eb" translate="yes" xml:space="preserve">
          <source>If there has not been any exceptions in a process, the stacktrace is &lt;code&gt;[]&lt;/code&gt;. After a code change for the process, the stacktrace can also be reset to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">프로세스에 예외가없는 경우 스택 추적은 &lt;code&gt;[]&lt;/code&gt; 입니다. 프로세스의 코드 변경 후 stacktrace를 &lt;code&gt;[]&lt;/code&gt; 로 재설정 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="231307e5b86795ba02c3c7007a265d1b3815a9d6" translate="yes" xml:space="preserve">
          <source>If there is NO &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field will be checked. All &lt;code&gt;CN&lt;/code&gt; names will be compared to all hostnames</source>
          <target state="translated">&lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드 가 없으면 &lt;code&gt;Subject&lt;/code&gt; 필드가 확인됩니다. 모든 &lt;code&gt;CN&lt;/code&gt; 이름은 모든 호스트 이름과 비교됩니다</target>
        </trans-unit>
        <trans-unit id="68e6d1b8204d4e4cbe66b0a3f70bd3fdbea57001" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;{uri_id,string()}&lt;/code&gt; in the function call will be compared to any &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; in the Certificate field. If the two &lt;code&gt;strings()&lt;/code&gt; are equal (case insensitive), there is a match. The same applies for any &lt;code&gt;{dns_id,string()}&lt;/code&gt; in the call which is compared with all &lt;code&gt;{dNSName,string()}&lt;/code&gt; in the Certificate field.</source>
          <target state="translated">가있는 경우 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드의 &lt;code&gt;{uri_id,string()}&lt;/code&gt; 함수 호출에 어떤 비교됩니다 &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; 인증서 필드에 입력하십시오. 두 &lt;code&gt;strings()&lt;/code&gt; 이 같으면 (대 / 소문자를 구분하지 않음) 일치하는 것입니다. 인증서 필드의 모든 &lt;code&gt;{dNSName,string()}&lt;/code&gt; 과 비교되는 호출의 모든 &lt;code&gt;{dns_id,string()}&lt;/code&gt; 에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f945a017af252bdab418ccd24ce5005c146d8f7" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt; such that &lt;code&gt;Pred(Value)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;{value, Value}&lt;/code&gt; for the first such &lt;code&gt;Value&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 있으면 &lt;code&gt;Value&lt;/code&gt; 의 &lt;code&gt;List&lt;/code&gt; 있도록 &lt;code&gt;Pred(Value)&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 반환 &lt;code&gt;{value, Value}&lt;/code&gt; 최초의에 대한 &lt;code&gt;Value&lt;/code&gt; , 그렇지 않으면 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f55a97af173d19104e4db4d68ae43bf0a349635" translate="yes" xml:space="preserve">
          <source>If there is a garbage collection before the result is stored, the stack will move and if the &lt;code&gt;d&lt;/code&gt; operand refered to a Y register, the pointer will no longer be valid. (Y registers are stored on the stack.)</source>
          <target state="translated">결과가 저장되기 전에 가비지 컬렉션이 있으면 스택이 이동하고 &lt;code&gt;d&lt;/code&gt; 피연산자가 Y 레지스터를 참조하면 포인터가 더 이상 유효하지 않습니다. (Y 레지스터는 스택에 저장됩니다.)</target>
        </trans-unit>
        <trans-unit id="d37a03a5a10dfe3b584b5087ad2e3ee6b552e40a" translate="yes" xml:space="preserve">
          <source>If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).</source>
          <target state="translated">오른쪽에 일치하는 실패가 있으면 (* PRUNE) 역 추적으로 인해 트리거되고 조치가 수행됩니다. (* COMMIT)에는 역 추적 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="772eaa5a9bb7c808e1d1ad944ded54de87cfcbf6" translate="yes" xml:space="preserve">
          <source>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</source>
          <target state="translated">텍스트 어딘가에 구문 오류가있는 경우 (위의 두 번째 절에서 누락 된 세미콜론과 같이) Merl은 소스 코드의 정확한 행을 가리키는 오류 메시지를 생성 할 수 있습니다. (목록에서 문자열을 쉼표로 구분해야합니다. 그렇지 않으면 Erlang은 문자열 조각을 마치 단일 문자열 인 것처럼 연결합니다.)</target>
        </trans-unit>
        <trans-unit id="eb988198b3b89a8ead41c2c06ba00583a45e57ec" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; option on some level the whole set is replaced by that in that option and &lt;strong&gt;all modify_algorithms are applied&lt;/strong&gt; in level ordering.</source>
          <target state="translated">어떤 레벨에 &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; 옵션 이있는 경우 전체 세트가 해당 옵션의 옵션으로 대체되고 &lt;strong&gt;모든 modify_algorithms가&lt;/strong&gt; 레벨 순서에 &lt;strong&gt;적용&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f8de65cd10bf00bba2999acc7df58c16d7692021" translate="yes" xml:space="preserve">
          <source>If there is data buffered in the socket port, the attempt to shutdown the socket is postponed until that data is written to the kernel socket send buffer. If any errors are encountered, the socket is closed and &lt;code&gt;{error, closed}&lt;/code&gt; is returned on the next &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">소켓 포트에 버퍼링 된 데이터가있는 경우 해당 데이터가 커널 소켓 송신 버퍼에 기록 될 때까지 소켓 종료 시도가 연기됩니다. 오류가 발생하면 소켓이 닫히고 다음 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;{error, closed}&lt;/code&gt; 가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab5c589483e29b598b39704e5336b70db6c69642" translate="yes" xml:space="preserve">
          <source>If there is more than one subpattern with the same name, the earliest one is used.</source>
          <target state="translated">이름이 같은 하위 패턴이 두 개 이상인 경우 가장 빠른 하위 패턴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc551c6c725ba0dac8c61943a105b6a103c7e97" translate="yes" xml:space="preserve">
          <source>If there is no matching message in the mailbox, the timeout occurs immediately.</source>
          <target state="translated">사서함에 일치하는 메시지가 없으면 시간 초과가 즉시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cc738995866b9be8195d9f8399cccd32d281ee8b" translate="yes" xml:space="preserve">
          <source>If there is no matching pattern with a true guard sequence, a &lt;code&gt;case_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">실제 가드 시퀀스와 일치하는 패턴이 없으면 &lt;code&gt;case_clause&lt;/code&gt; 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f5a0ffa17cfe9167811739038f7d8ac026fb1794" translate="yes" xml:space="preserve">
          <source>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys.</source>
          <target state="translated">사용 가능한 지정된 유형의 공개 키가 없으면 해당 항목이 무시됩니다. 사용 가능한 세트는 기본 암호화 및 현재 사용자의 공개 키에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2104c47ce32bc96eff6c32dbc5479f514ba24093" translate="yes" xml:space="preserve">
          <source>If there is not enough space available on the heap to satisfy the &lt;code&gt;test_heap&lt;/code&gt; instructions request for memory, then a garbage collection is initiated. It may happen immediately in the &lt;code&gt;test_heap&lt;/code&gt; instruction, or it can be delayed until a later time depending on what state the process is in. If the garbage collection is delayed, any memory needed will be allocated in heap fragments. Heap fragments are extra memory blocks that are a part of the young heap, but are not allocated in the contigious area where terms normally reside. See &lt;code&gt;&lt;a href=&quot;#The-young-heap&quot;&gt;The young heap&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">메모리에 대한 &lt;code&gt;test_heap&lt;/code&gt; 명령 요청 을 충족시키기 위해 힙에 사용 가능한 공간이 충분하지 않으면 가비지 콜렉션이 시작됩니다. &lt;code&gt;test_heap&lt;/code&gt; 명령어 에서 즉시 발생 하거나 프로세스가 어떤 상태에 있는지에 따라 나중에 지연 될 수 있습니다. 가비지 수집이 지연되면 필요한 메모리가 힙 조각에 할당됩니다. 힙 조각은 젊은 힙의 일부인 추가 메모리 블록이지만 용어가 일반적으로 상주하는 인접 영역에 할당되지 않습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#The-young-heap&quot;&gt;The young heap&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c43ed956f51818838543c55451a2fcd8d8fee88" translate="yes" xml:space="preserve">
          <source>If there was a supervised connection between &lt;code&gt;Handler1&lt;/code&gt; and a process &lt;code&gt;Pid&lt;/code&gt;, there is a supervised connection between &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Pid&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Handler1&lt;/code&gt; 과 프로세스 &lt;code&gt;Pid&lt;/code&gt; 사이에 감독 연결이있는 경우 , 대신 &lt;code&gt;Handler2&lt;/code&gt; 와 &lt;code&gt;Pid&lt;/code&gt; 사이에 감독 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c67211fc881043f6c0597b9ecfceb976f47baf4" translate="yes" xml:space="preserve">
          <source>If there was some bug in &lt;code&gt;lists:reverse/1&lt;/code&gt; that made it return something other than &lt;code&gt;[2,1]&lt;/code&gt; when it got &lt;code&gt;[1,2]&lt;/code&gt; as input, then the last test above would throw a &lt;code&gt;badmatch&lt;/code&gt; error. The first two (we assume they do not get a &lt;code&gt;badmatch&lt;/code&gt;) would simply return &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt;, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</source>
          <target state="translated">&lt;code&gt;lists:reverse/1&lt;/code&gt; 에 입력으로 &lt;code&gt;[1,2]&lt;/code&gt; 를 받았을 때 &lt;code&gt;[2,1]&lt;/code&gt; 이외의 것을 반환하게하는 버그가 있으면 위의 마지막 테스트에서 &lt;code&gt;badmatch&lt;/code&gt; 오류가 발생합니다. 처음 두 개 ( &lt;code&gt;badmatch&lt;/code&gt; 가 없다고 가정 )는 단순히 각각 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;[1]&lt;/code&gt; 을 반환 하므로 둘 다 성공합니다. (EUnit은 심령이 아닙니다. 잘못된 값이더라도 값을 반환하는 테스트를 작성하는 경우 EUnit은이를 성공으로 간주합니다. 결과는 그렇지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="ac4dc8c4f9cc87ef06af906dc31bb54276084fd9" translate="yes" xml:space="preserve">
          <source>If these requirements are not fulfilled, the system may behave very bad.</source>
          <target state="translated">이러한 요구 사항이 충족되지 않으면 시스템이 매우 잘못 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b741a6b0067d17a99e20727d386f0f44e405815c" translate="yes" xml:space="preserve">
          <source>If these return values are used from a &lt;strong&gt;state enter call&lt;/strong&gt; the &lt;code&gt;OldState&lt;/code&gt; does not change, but if used from an event handling &lt;strong&gt;state callback&lt;/strong&gt; the new &lt;strong&gt;state enter call's&lt;/strong&gt;&lt;code&gt;OldState&lt;/code&gt; will be the current state.</source>
          <target state="translated">이러한 반환 값이 &lt;strong&gt;상태 입력 호출&lt;/strong&gt; 에서 사용되는 경우 &lt;code&gt;OldState&lt;/code&gt; 는 변경되지 않지만 이벤트 처리 &lt;strong&gt;상태 콜백&lt;/strong&gt; 에서 사용되는 경우 새 &lt;strong&gt;상태 입력 호출의 &lt;/strong&gt; &lt;code&gt;OldState&lt;/code&gt; 가 현재 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="5e69ed9e46453ec19298157c854f6a3eaec0abc5" translate="yes" xml:space="preserve">
          <source>If this attribute is not specified, the version defaults to the MD5 checksum of the module.</source>
          <target state="translated">이 속성을 지정하지 않으면 버전의 기본값은 모듈의 MD5 체크섬입니다.</target>
        </trans-unit>
        <trans-unit id="aa0c65a5a17658e764f89aa9eb9e0a1ff2afe4bb" translate="yes" xml:space="preserve">
          <source>If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return &lt;code&gt;{State,Info}&lt;/code&gt;, where &lt;code&gt;Info&lt;/code&gt; says nothing but the fact that &lt;code&gt;format_status/2&lt;/code&gt; has crashed.</source>
          <target state="translated">이 콜백을 내보내지만 실패로 민감한 데이터를 숨길 수없는 경우 기본 함수는 &lt;code&gt;{State,Info}&lt;/code&gt; 를 대신 반환합니다 . 여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;format_status/2&lt;/code&gt; 가 충돌 했다는 사실 만 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="714e5e0a8e521c47efda0340fa656dbd50e5c01b" translate="yes" xml:space="preserve">
          <source>If this configuration parameter is set, it replaces both the default report callback, and any report callback found in metadata. That is, all reports are converted by this configured function.</source>
          <target state="translated">이 구성 매개 변수가 설정되면 기본 보고서 콜백과 메타 데이터에서 발견 된 모든 보고서 콜백을 모두 대체합니다. 즉, 모든 보고서는이 구성된 기능에 의해 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1be583879f0eb7412bbdfda911217bb43a748c07" translate="yes" xml:space="preserve">
          <source>If this does not work on your system, the documentation is included as HTML in the Erlang/OTP release. You can also read the documentation as HTML or download it as PDF from either of the sites www.erlang.se (commercial Erlang) or www.erlang.org (open source). For example, for Erlang/OTP release R9B:</source>
          <target state="translated">이것이 시스템에서 작동하지 않으면, 문서는 Erlang / OTP 릴리스에서 HTML로 포함됩니다. www.erlang.se (상업용 Erlang) 또는 www.erlang.org (오픈 소스) 사이트에서 설명서를 HTML로 읽거나 PDF로 다운로드 할 수도 있습니다. 예를 들어 Erlang / OTP 릴리스 R9B의 경우 :</target>
        </trans-unit>
        <trans-unit id="a3eb530f2543acfe6aa144c1bf97c7dbef8076b8" translate="yes" xml:space="preserve">
          <source>If this feature is used while no such &lt;code&gt;TimeoutType&lt;/code&gt; is running then a time-out event is immediately delivered as when starting a &lt;code&gt;&lt;a href=&quot;#Time-Out%20Zero&quot;&gt;Time-Out Zero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;code&gt;TimeoutType&lt;/code&gt; 이 실행 되지 않는 동안이 기능을 사용 하면 &lt;code&gt;&lt;a href=&quot;#Time-Out%20Zero&quot;&gt;Time-Out Zero&lt;/a&gt;&lt;/code&gt; 를 시작할 때와 같이 시간 제한 이벤트가 즉시 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7ae399292df5e1214de0f1c430950be7c775936" translate="yes" xml:space="preserve">
          <source>If this flag is present, &lt;code&gt;global&lt;/code&gt; does not maintain a fully connected network of distributed Erlang nodes, and then global name registration cannot be used; see &lt;code&gt;global(3)&lt;/code&gt;.</source>
          <target state="translated">이 플래그가 있으면 &lt;code&gt;global&lt;/code&gt; 은 분산 된 Erlang 노드의 완전히 연결된 네트워크를 유지하지 않으므로 전역 이름 등록을 사용할 수 없습니다. &lt;code&gt;global(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f07b81995e2058716b31282ea839a19974f67348" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; is returned when there are errors. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 플래그가 설정되면 &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; 가있을 때 {error, Errors, Warnings} 가 리턴됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5398762fceee6e07d9e93fb018e02eda7d682593" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; is returned when there are errors.</source>
          <target state="translated">이 플래그가 설정되면 &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; 가있을 때 {error, ErrorList, WarningList} 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6be13d0e071b42b8d41878615f2879c487393169" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field containing &lt;code&gt;Warnings&lt;/code&gt; is added to the tuple returned upon success. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 플래그를 설정하면 &lt;code&gt;Warnings&lt;/code&gt; 가 포함 된 추가 필드가 성공시 반환 된 튜플에 추가됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3313bf48f0cdfa74884b1da2da53a7543532d3d4" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field, containing &lt;code&gt;WarningList&lt;/code&gt;, is added to the tuples returned on success.</source>
          <target state="translated">이 플래그가 설정되면 &lt;code&gt;WarningList&lt;/code&gt; 를 포함하는 추가 필드 가 성공시 리턴 된 튜플에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a4261f0fa61ea721311b8153168daa7bcae82ceb" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to process the action requests itself or to delegate the processing to this function.</source>
          <target state="translated">이 함수가 호출되는지의 여부는 handle_trans_request / 3에 대한 이전 호출의 응답에 의해 제어됩니다. handle_trans_request / 3 함수는 조치 요청 자체를 처리하거나 처리를이 함수에 위임하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="759c6aff89e36cb13b1929cdb56543f2723e5912" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not, is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to return {handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} meaning that you need an immediate acknowledgement of the reply and that this function should be invoked to handle the acknowledgement.</source>
          <target state="translated">이 함수가 호출되는지의 여부는 handle_trans_request / 3에 대한 이전 호출의 응답에 의해 제어됩니다. handle_trans_request / 3 함수는 {handle_ack, ack_data ()} 또는 {handle_sloppy_ack, ack_data ()}를 리턴하도록 결정할 수 있습니다. 즉, 응답을 즉시 승인해야하며 승인을 처리하기 위해이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="2db2202db664ddf13d01713aaa8bc9ba006f0ed4" translate="yes" xml:space="preserve">
          <source>If this function is called, it can only be called once and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt; library are called.</source>
          <target state="translated">이 함수가 호출되면 한 번만 호출 할 수 있으며 &lt;code&gt;ei&lt;/code&gt; 라이브러리의 다른 함수가 호출되기 전에 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="63459ad5b8a5024794d9f8294a76e897d53d7890" translate="yes" xml:space="preserve">
          <source>If this function is called, it may only be called once directly after the call to function &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수가 호출되면 함수 &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt; 호출 직후에 한 번만 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdd06471c1b7c9a2e79736c5c3baade29102ed76" translate="yes" xml:space="preserve">
          <source>If this function is called, it will be called again, either with &lt;code&gt;undo&lt;/code&gt; or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">이 함수가 호출되면 &lt;code&gt;undo&lt;/code&gt; 또는 첫 번째 인수 로 &lt;code&gt;set&lt;/code&gt; 다시 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="57d5ad72a18485e89bafa2b5eeeeaab800a1356c" translate="yes" xml:space="preserve">
          <source>If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise.</source>
          <target state="translated">이 함수가 호출되지 않으면 시작 함수는 오류 튜플을 반환하거나 (링크 및 / 또는 시간 초과가 사용 된 경우) 그렇지 않으면 정지합니다.</target>
        </trans-unit>
        <trans-unit id="8c7cb778dcaeb301678f8381c719400450da4a70" translate="yes" xml:space="preserve">
          <source>If this function returns with a next state that does not match equal (&lt;code&gt;=/=&lt;/code&gt;) to the current state, all postponed events are retried in the next state.</source>
          <target state="translated">이 함수가 현재 상태 와 같거나 ( &lt;code&gt;=/=&lt;/code&gt; ) 일치하지 않는 다음 상태로 리턴되면 연기 된 모든 이벤트가 다음 상태에서 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="3a0ed99dde48840d29c014e939552bc11b14d1d1" translate="yes" xml:space="preserve">
          <source>If this function's body does not return an inline constant value the callback module is doing something strange.</source>
          <target state="translated">이 함수의 본문이 인라인 상수 값을 반환하지 않으면 콜백 모듈이 이상한 일을합니다.</target>
        </trans-unit>
        <trans-unit id="33d0e448805fb8a37d99a0aff84679f18601e686" translate="yes" xml:space="preserve">
          <source>If this is a &lt;strong&gt;state change&lt;/strong&gt;, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">이것이 &lt;strong&gt;상태 변경&lt;/strong&gt; 인 경우 들어오는 이벤트의 큐는 가장 오래된 연기 된 것부터 시작하도록 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="82460753c54ada648d7c9b05b35bd78eae8d83fe" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean use something like this:</source>
          <target state="translated">이것이 문제라면; 부울을 생성하려면 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c64d2ab7023f50eed11754a4818012e0a3833abd" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean with these algorithms use something like this:</source>
          <target state="translated">이것이 문제라면; 이 알고리즘으로 부울을 생성하려면 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ac87d883ad765b014bd68fa86e8b2ac8f132c75" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings.</source>
          <target state="translated">이 매크로가 정의되면 NOASSERT 매크로를 대체하여 다른 설정에 상관없이 어설 션 매크로를 항상 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ef12b2a17adab036f91ae1c37a457dabe1673cb6" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled.</source>
          <target state="translated">이 매크로가 정의되면 NODEBUG 매크로를 대체하여 디버깅 매크로를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f89fd4ecae86929dc6deae32a5e245a30ab74c60" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt;. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled.</source>
          <target state="translated">이 매크로가 정의되어 있으면 테스트를 사용하지 않도록 설정해도 어설 션 매크로가 적용되지 않습니다. &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 테스트가 활성화되면 어설 션 매크로는 항상 자동으로 활성화되며 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="79358b57c58e42b823acfaf278614ec9c7ce54cc" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the automatic exporting or stripping of test functions will be disabled.</source>
          <target state="translated">이 매크로가 정의되면 테스트 기능의 자동 내보내기 또는 스트리핑이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6681ab5371316488374f8d3a60e956558c52d69e" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the debugging macros will have no effect. See &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NODEBUG&lt;/code&gt; also implies &lt;code&gt;NOASSERT&lt;/code&gt;, unless testing is enabled.</source>
          <target state="translated">이 매크로가 정의되어 있으면 디버깅 매크로가 적용되지 않습니다. &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; 참조하십시오 . &lt;code&gt;NODEBUG&lt;/code&gt; 은 또한 의미 &lt;code&gt;NOASSERT&lt;/code&gt; 을 시험 사용하지 않으면.</target>
        </trans-unit>
        <trans-unit id="781581d91da20944d9d397cd0ddb27951b613d6e" translate="yes" xml:space="preserve">
          <source>If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;, get much slower. The key element is not compressed.</source>
          <target state="translated">이 옵션이 존재하면, 테이블 데이터는 더 적은 메모리를 사용하기 위해보다 컴팩트 한 형식으로 저장됩니다. 그러나 테이블 작업 속도가 느려집니다. 특히 &lt;code&gt;match&lt;/code&gt; 및 &lt;code&gt;select&lt;/code&gt; 와 같은 전체 객체를 검사해야하는 작업이 훨씬 느려집니다. 키 요소가 압축되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="39baea08169404ce3fe44fe53586745d1c2f63db" translate="yes" xml:space="preserve">
          <source>If this option is present, the table is registered under its &lt;code&gt;Name&lt;/code&gt; which can then be used instead of the table identifier in subsequent operations.</source>
          <target state="translated">이 옵션이 존재하면 테이블은 &lt;code&gt;Name&lt;/code&gt; 아래에 등록 된 후 후속 조작에서 테이블 ID 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee4b6929098a40cbdbaf168a7fca6dd6bafa6ed5" translate="yes" xml:space="preserve">
          <source>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as &lt;code&gt;(?&amp;gt;&lt;/code&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as &lt;code&gt;{1,3}&lt;/code&gt;. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</source>
          <target state="translated">이 옵션을 설정하면 이스케이프되거나 문자 클래스 내부를 제외하고 패턴의 대부분의 공백 문자가 완전히 무시됩니다. 그러나 &lt;code&gt;(?&amp;gt;&lt;/code&gt; 와 같이 다양한 괄호로 묶인 하위 패턴을 도입하는 시퀀스 나 &lt;code&gt;{1,3}&lt;/code&gt; 과 같은 숫자 한정자 내에 공백은 허용되지 않지만 무시할 수있는 공백은 항목과 다음 수량 자 사이 및 양도 및 소 유력을 나타내는 다음 +.</target>
        </trans-unit>
        <trans-unit id="fdc99f2839fcd867c278ae874f9e2a13c5e1d784" translate="yes" xml:space="preserve">
          <source>If this option is written in the source code, as a &lt;code&gt;-compile&lt;/code&gt; directive, the syntax &lt;code&gt;F/A&lt;/code&gt; can be used instead of &lt;code&gt;{F,A}&lt;/code&gt;, for example:</source>
          <target state="translated">이 옵션이 소스 코드에서 &lt;code&gt;-compile&lt;/code&gt; 지시문 으로 작성된 경우 &lt;code&gt;{F,A}&lt;/code&gt; 대신 구문 &lt;code&gt;F/A&lt;/code&gt; 를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd13526ac2fef0e27a961572d9dc8a9a077d1b66" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/hosts&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수가 지정 되지 않은 경우 환경 변수 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; 이 설정 되지 않은 경우 기본값은 &lt;code&gt;/etc/hosts&lt;/code&gt; 이며,이 파일의 디렉토리를 &lt;code&gt;/etc&lt;/code&gt; 이외의 다른 디렉토리로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fe1c08841ffeb7fe23cca25114d889442e8c01cb" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/resolv.conf&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수가 지정 되지 않은 경우 환경 변수 &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; 이 설정 되지 않은 경우 기본값은 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 이며,이 파일의 디렉토리를 &lt;code&gt;/etc&lt;/code&gt; 이외의 다른 디렉토리로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="45ec4c57907492a2ec83d9fdbff265e2b0072af9" translate="yes" xml:space="preserve">
          <source>If this pattern is embedded in a larger one, a relative reference can be used:</source>
          <target state="translated">이 패턴이 더 큰 패턴에 포함 된 경우 상대 참조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8050ea746b1df5e9d9c36102bf42da460ef8d08" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file, which uses Apache-like syntax. The file must include all properties listed under mandatory properties. The Apache-like syntax is the property, written as one word where each new word begins with a capital, followed by a white-space, followed by the value, followed by a new line.</source>
          <target state="translated">이 속성이 정의되면 &lt;code&gt;Inets&lt;/code&gt; 는이 파일에 정의 된 다른 모든 속성을 찾을 것으로 예상합니다. 이 속성은 Apache와 유사한 구문을 사용합니다. 파일에는 필수 특성 아래에 나열된 모든 특성이 포함되어야합니다. Apache와 유사한 구문은 각각의 새 단어가 대문자로 시작하고 공백, 값, 줄 바꿈이 차례로 나오는 한 단어로 작성된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="09a2a375a69f2029267ac74ac850aabd642821a4" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties.</source>
          <target state="translated">이 속성이 정의되면 &lt;code&gt;Inets&lt;/code&gt; 는이 파일에 정의 된 다른 모든 속성을 찾습니다. 파일에는 필수 특성 아래에 나열된 모든 특성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd3402a2f2f441f42f83cdd07b86e7ab04f0ace1" translate="yes" xml:space="preserve">
          <source>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</source>
          <target state="translated">이 상황이 수용 가능하지 않으면이 함수를 사용하여 Mnesia 테이블로드 알고리즘의 전략을 대체 할 수 있습니다. 이로 인해 일관성없는 데이터베이스로 인해 일부 트랜잭션 효과가 손실되는 상황이 발생할 수 있지만 일부 응용 프로그램의 경우 일관성있는 데이터보다 고 가용성이 더 중요합니다.</target>
        </trans-unit>
        <trans-unit id="059c4f891420c8ec95d1abb34b55edc8941662f6" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each mib- entry is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic mibentry name is used for different oid's.</source>
          <target state="translated">이 값이 false이면 mib를로드 할 때 mib를 설치하기 전에 각 mib 항목을 검사합니다. 이 검사의 목적은 동일한 기호 이름의 이름이 다른 OID에 사용되지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5be0ef33ffc0742762d89cfb5dcdc57978e4cec" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each trap is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic trap name is used for different trap's.</source>
          <target state="translated">이 값이 false이면 mib를로드 할 때 mib를 설치하기 전에 각 트랩을 검사합니다. 점검의 목적은 동일한 트랩 이름이 다른 트랩에 사용되지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d93bdc2ebb6849c84f900f395d346a1101af31f5" translate="yes" xml:space="preserve">
          <source>If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:</source>
          <target state="translated">이것이 더 큰 패턴의 일부인 경우 전체 패턴을 되풀이하고 싶지 않으므로 대신 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="739efd088e9bee0d304554cfa5fdd5c4e61ba305" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time can warp forwards or stop, or even freeze for extended periods of time. There are then no guarantees that the frequency of the Erlang monotonic clock is accurate or stable.</source>
          <target state="translated">시간 수정이 비활성화 된 경우 Erlang 단조 시간은 앞으로 이동하거나 중지하거나 장시간 정지 할 수 있습니다. Erlang 모노 토닉 클록의 주파수가 정확하거나 안정적이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="ffd673f8288d651f4732e547bc38b22a211807fc" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time leaps forward if OS system time leaps forward. If OS system time leaps backwards, Erlang monotonic time stops briefly, but it does not freeze for extended periods of time. This as the time offset is changed to align Erlang system time with OS system time.</source>
          <target state="translated">시간 수정이 비활성화 된 경우, OS 시스템 시간이 도약하면 Erlang 단조 시간이 도약합니다. OS 시스템 시간이 거꾸로 증가하면 Erlang 단조 시간이 잠깐 멈추지 만 오랜 시간 동안 멈추지 않습니다. Erlang 시스템 시간을 OS 시스템 시간에 맞추기 위해 시간 오프셋이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="e95c3e3e415f307880ab62a824dbb61d407166b0" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, changes in OS system time affects the monotonic clock the same way as when the &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">시간 수정이 비활성화 된 경우 OS 시스템 시간의 변경은 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 를 사용할 때와 같은 방식으로 단조로운 시계에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="d01b0a13b53f09d09cc8091e67871a996e4027e2" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, adjustments to the Erlang monotonic clock are made to keep its frequency as correct as possible. However, &lt;strong&gt;no&lt;/strong&gt; adjustments are made trying to align Erlang system time and OS system time. That is, during the preliminary phase Erlang system time and OS system time can diverge from each other, and no attempt is made to prevent this.</source>
          <target state="translated">시간 수정이 활성화 된 경우 Erlang 모노 토닉 클록을 조정하여 주파수를 최대한 정확하게 유지합니다. 그러나 Erlang 시스템 시간과 OS 시스템 시간을 조정하려고 조정 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 즉, 예비 단계에서 Erlang 시스템 시간과 OS 시스템 시간이 서로 다를 수 있으며이를 방지하려는 시도는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5d7906513f874fdde48593a22b63bd033c683a3" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, the Erlang runtime system makes use of both &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;, to adjust the frequency of the Erlang monotonic clock. Time correction ensures that &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; does not warp and that the frequency is relatively accurate. The type of frequency adjustments depends on the time warp mode used. Section &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; provides more details.</source>
          <target state="translated">시간 수정이 사용 가능한 경우 Erlang 런타임 시스템은 &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; 을 모두 사용 하여 Erlang 모노 토닉 시계의 주파수를 조정합니다. 시간 보정을 통해 &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 이 왜곡되지 않고 주파수가 상대적으로 정확합니다. 주파수 조정 유형은 사용 된 타임 워프 모드에 따라 다릅니다. 섹션 &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; 는 자세한 내용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86c57207a0af2011d419b53ca97897d73a612495" translate="yes" xml:space="preserve">
          <source>If time correction is not enabled, Erlang monotonic time freezes when OS system time leaps backwards. The freeze of monotonic time continues until OS system time catches up. The freeze can continue for a long time. When OS system time leaps forwards, Erlang monotonic time also leaps forward.</source>
          <target state="translated">시간 수정을 사용하지 않으면 OS 시스템 시간이 거꾸로 증가하면 Erlang 단조 시간이 정지됩니다. 단조로운 시간의 동결은 OS 시스템 시간이 따라갈 때까지 계속됩니다. 동결은 오랫동안 계속 될 수 있습니다. OS 시스템 시간이 도약 할 때 Erlang 단조 시간도 도약합니다.</target>
        </trans-unit>
        <trans-unit id="ef091f899ba472aeda63ed1965cfed9d0bedc0a4" translate="yes" xml:space="preserve">
          <source>If trace mode is turned on this tells the ODBC driver to write a trace log to the file SQL.LOG that is placed in the current directory of the erlang emulator. This information may be useful if you suspect there might be a bug in the erlang ODBC application, and it might be relevant for you to send this file to our support. Otherwise you will probably not have much use of this.</source>
          <target state="translated">추적 모드가 켜져 있으면 ODBC 드라이버가 erlang 에뮬레이터의 현재 디렉토리에있는 SQL.LOG 파일에 추적 로그를 쓰도록 지시합니다. 이 정보는 erlang ODBC 응용 프로그램에 버그가 있다고 생각되는 경우 유용 할 수 있으며이 파일을 지원 부서에 보내는 것이 관련 될 수 있습니다. 그렇지 않으면 아마도 이것을 많이 사용하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="06cb7989133609c0050ffc5dbb44bd39095de5a4" translate="yes" xml:space="preserve">
          <source>If tracing could be enabled for &lt;code&gt;P&lt;/code&gt; and all processes in &lt;code&gt;Rootset&lt;/code&gt;, the function returns &lt;code&gt;{ok,Value}&lt;/code&gt; when &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; returns with the value &lt;code&gt;Value&lt;/code&gt;, or &lt;code&gt;{error,Reason}&lt;/code&gt; if &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; fails with exit reason &lt;code&gt;Reason&lt;/code&gt;. Otherwise it returns &lt;code&gt;{error, Reason}&lt;/code&gt; immediately.</source>
          <target state="translated">추적하는 것이 가능하게 할 수있는 경우 &lt;code&gt;P&lt;/code&gt; 와의 모든 프로세스 &lt;code&gt;Rootset&lt;/code&gt; 는 , 함수가 반환 &lt;code&gt;{ok,Value}&lt;/code&gt; &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; 값으로 반환 &lt;code&gt;Value&lt;/code&gt; , 또는 &lt;code&gt;{error,Reason}&lt;/code&gt; 하면 &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; 종료 이유 실패 &lt;code&gt;Reason&lt;/code&gt; . 그렇지 않으면 즉시 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="171abc361e25e3e1820951c40db50f386bc4e18d" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference.</source>
          <target state="translated">참이면 ECC 곡선 선택에 서버의 기본 설정을 사용하십시오. false 인 경우 (기본값) 클라이언트의 환경 설정을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f6448c429179ffe9a0559b10e022f36f7d57c48b" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</source>
          <target state="translated">true이면 암호 선택에 서버의 환경 설정을 사용하십시오. false 인 경우 (기본값) 클라이언트의 환경 설정을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93560debed8026dcf2a2983b09444126fc93994e" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Dates&lt;/code&gt; are specified, reports that occurred between those dates are returned.</source>
          <target state="translated">두 개의 &lt;code&gt;Dates&lt;/code&gt; 를 지정하면 해당 날짜 사이에 발생한 보고서가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="33b891be28a40228827989eecbc682bd1e8b9bf9" translate="yes" xml:space="preserve">
          <source>If two matching keys are declared, the latter key takes precedence.</source>
          <target state="translated">두 개의 일치하는 키가 선언되면 후자의 키가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="67258d8af06879035a6caf89796f47f253a79805" translate="yes" xml:space="preserve">
          <source>If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it.</source>
          <target state="translated">두 개의 프로세스가 동일한 이름과 인수를 제공하여 동일한 테이블을 열면 테이블에 두 명의 사용자가 있습니다. 한 사용자가 테이블을 닫으면 두 번째 사용자가 닫을 때까지 테이블이 열린 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2c7260077a6430e57fb912e3299409f44a7a3f23" translate="yes" xml:space="preserve">
          <source>If two processes perform &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simultaneously, both updates take effect without the risk of losing one of the updates. The new value &lt;code&gt;NewVal&lt;/code&gt; of the counter is returned.</source>
          <target state="translated">두 프로세스가 &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; 를 동시에 수행하는 경우 두 업데이트는 업데이트 중 하나를 잃을 위험없이 적용됩니다. 카운터 의 새로운 값 &lt;code&gt;NewVal&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b5c7e523459e9f766dca300b6ab1c5e2e9c17d90" translate="yes" xml:space="preserve">
          <source>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">가드의 최상위 레벨에서 사용되는 경우 인수가 부동 소수점 숫자인지 테스트합니다. 명확성을 위해 &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c1158bf11097606b6592798bf3682a97d2961056" translate="yes" xml:space="preserve">
          <source>If verification is turned on and the file was written with option &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt;, reading the file is slower and consumes radically more CPU time than otherwise.</source>
          <target state="translated">확인이 설정되어 있고 파일이 &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt; 옵션으로 작성된 경우 파일을 읽는 속도가 느리고 그렇지 않은 경우보다 훨씬 많은 CPU 시간을 소비합니다.</target>
        </trans-unit>
        <trans-unit id="79df61d77a356cef20daff35817557c31ea1feae" translate="yes" xml:space="preserve">
          <source>If warnings are turned on (option &lt;code&gt;report_warnings&lt;/code&gt; described earlier), the following options control what type of warnings that are generated.  Except from &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt;, the following options have two forms:</source>
          <target state="translated">경고가 설정되어있는 경우 ( &lt;code&gt;report_warnings&lt;/code&gt; 설명한 옵션 report_warnings ) 다음 옵션은 생성되는 경고 유형을 제어합니다. &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt; 를 제외하고 다음 옵션에는 두 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="46f6514af342c03660ff3a127d8c0abce6e94d29" translate="yes" xml:space="preserve">
          <source>If we are connected (and if the connection handle is not &lt;code&gt;NULL&lt;/code&gt;), we log out from the database. We need to check if we should encode an &lt;code&gt;'ok'&lt;/code&gt;, as we can get here from function &lt;code&gt;stop&lt;/code&gt;, which does not return data to the emulator:</source>
          <target state="translated">연결되어 있고 연결 핸들이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 데이터베이스에서 로그 아웃합니다. 에뮬레이터에 데이터를 반환하지 않는 함수 &lt;code&gt;stop&lt;/code&gt; 에서 얻을 수 있으므로 &lt;code&gt;'ok'&lt;/code&gt; 인코딩해야하는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e3531248524d3e767663c5b51a2a6884e4678a8" translate="yes" xml:space="preserve">
          <source>If we are not at security-level &lt;code&gt;noAuthNoPriv&lt;/code&gt;, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</source>
          <target state="translated">보안 레벨 &lt;code&gt;noAuthNoPriv&lt;/code&gt; 에 있지 않으면 에이전트가 2 단계를 계속 수행하기 전에 usm 관련 업데이트를 수행해야하기 때문에 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d4840bdbaaa7e01cbfc9ee43e1a031173374de2" translate="yes" xml:space="preserve">
          <source>If we are not connecting, we wait for results from a &lt;code&gt;PQsendQuery&lt;/code&gt;, so we get the result and return it. The encoding is done with the same functions as in the earlier example.</source>
          <target state="translated">연결하지 않으면 &lt;code&gt;PQsendQuery&lt;/code&gt; 에서 결과를 기다리 므로 결과를 가져 와서 반환합니다. 인코딩은 이전 예제와 동일한 기능으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="337a2fc4e3a2d30ff212f197ed2e62e6a68516c6" translate="yes" xml:space="preserve">
          <source>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as &quot;safe&quot;, and all calls between them will become local. Note that if the target module itself is specified as safe, &quot;remote&quot; calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop.</source>
          <target state="translated">이러한 상황이 발생할 수 없다고 확신하는 경우 관련 모듈을 &quot;안전한&quot;것으로 지정할 수 있으며 이들 사이의 모든 호출은 로컬이됩니다. 대상 모듈 자체가 안전한 것으로 지정되면 &quot;원격&quot;자체 호출이 로컬 호출로 바뀝니다. 이것은 전형적인 서버 루프의 코드 대체 속성을 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="7b66416ada226ef11ca8c9b5f2f89c92815edf3c" translate="yes" xml:space="preserve">
          <source>If we disregard the contended cases, we will inevitably get a higher latency when scheduling signals for execution at a later time than by executing the signal immediately. In order to preserve the low latency we now first check if this is a contended case or not. If it is, we schedule the signal for later execution; otherwise, we execute the signal immediately. It is a contended case if other signals already are scheduled on the port, or if we fail to acquire the port lock. That is we will not block waiting for the lock.</source>
          <target state="translated">경합 된 경우를 무시하면 신호를 즉시 실행하는 것보다 나중에 실행하도록 신호를 예약 할 때 필연적으로 더 높은 지연 시간을 얻게됩니다. 낮은 지연 시간을 유지하기 위해 먼저 이것이 경합 사례인지 아닌지 확인합니다. 그렇다면 나중에 실행되도록 신호를 예약합니다. 그렇지 않으면 즉시 신호를 실행합니다. 다른 신호가 이미 포트에 예약되어 있거나 포트 잠금을 획득하지 못한 경우는 논쟁의 여지가 있습니다. 즉, 잠금 대기를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d97b9f19e72ab9cc61b4cedbac5bd537174daa35" translate="yes" xml:space="preserve">
          <source>If we disregard the locking issues, the original solution is very appealing. The mapping from process identifier to index into the array is very fast, and this property is something we would like to keep. The vast majority of operations on these tables are lookups so optimizing for lookups is what we want to do.</source>
          <target state="translated">잠금 문제를 무시하면 원래 솔루션이 매우 매력적입니다. 프로세스 식별자에서 인덱스로의 배열로의 매핑은 매우 빠르며이 속성은 유지하고 싶은 것입니다. 이러한 테이블에 대한 대부분의 작업은 조회이므로 조회를 최적화하는 것이 우리가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea9c359ef122e371e6ca40c1302512863ec587e1" translate="yes" xml:space="preserve">
          <source>If we have a result from a connect, indicated by having data in the &lt;code&gt;x&lt;/code&gt; buffer, we no longer need to select on output (&lt;code&gt;ready_output&lt;/code&gt;), so we remove this by calling &lt;code&gt;driver_select&lt;/code&gt;.</source>
          <target state="translated">우리는 커넥트 결과가있는 경우에 데이터를 표시함으로써 &lt;code&gt;x&lt;/code&gt; 버퍼 출력 (우리의 선택이 더 이상 필요 &lt;code&gt;ready_output&lt;/code&gt; 우리는 호출이 제거되도록) &lt;code&gt;driver_select&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="b39cddb5344c13a7bcee4c7a5972425c4aa9fc95" translate="yes" xml:space="preserve">
          <source>If we have forgotten the &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; there would be a message similar to this:</source>
          <target state="translated">&lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; 잊어 버린 경우 다음 과 유사한 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dce67181f9dec94f63a49d2d4f68889369954004" translate="yes" xml:space="preserve">
          <source>If we now add the filter to the running &lt;code&gt;Collector&lt;/code&gt;:</source>
          <target state="translated">이제 필터를 실행중인 &lt;code&gt;Collector&lt;/code&gt; 추가하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3ffad68dd3aaa3ee27c0008bb99580f0a57f8f2" translate="yes" xml:space="preserve">
          <source>If we now send a message from the shell on the node &lt;code&gt;ant@stack&lt;/code&gt;, where all sends from the shell are traced:</source>
          <target state="translated">&lt;code&gt;ant@stack&lt;/code&gt; 노드의 쉘에서 메시지를 보내면 쉘에서 보내는 모든 것이 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="43717b37beb4229f520c407e6567fb6706951645" translate="yes" xml:space="preserve">
          <source>If we only want debug messages from a specific process it is possible to do this with a filter like this:</source>
          <target state="translated">특정 프로세스의 디버그 메시지 만 원하는 경우 다음과 같은 필터를 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bcc29b0b458c2d8c07af3ed4af13280313ed829" translate="yes" xml:space="preserve">
          <source>If we only want to match operands of a certain type, we can use a type constraint. A type constraint consists of one or more lowercase letters, each specifying a type. For example:</source>
          <target state="translated">특정 유형의 피연산자 만 일치 시키려면 유형 제약 조건을 사용할 수 있습니다. 유형 제약은 각각 유형을 지정하는 하나 이상의 소문자로 구성됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="fd0ecc6f7afe07e419db3c1ee4dc39311f3c9091" translate="yes" xml:space="preserve">
          <source>If we remove the &lt;code&gt;-no_next&lt;/code&gt; directive, the code would look like this:</source>
          <target state="translated">&lt;code&gt;-no_next&lt;/code&gt; 지시문 을 제거하면 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71461022e8b1964785f01d0fea411534999fdbfe" translate="yes" xml:space="preserve">
          <source>If we run it like this: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; The result will be &lt;code&gt;result_xs.html&lt;/code&gt;. When the input file is of the same structure as the previous &quot;motorcycles&quot; XML files but it has a little more 'bike' elements and the 'manufacturer' elements are not in order.</source>
          <target state="translated">다음과 같이 실행하면 &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; 결과는 &lt;code&gt;result_xs.html&lt;/code&gt; 입니다. 입력 파일이 이전 &quot;오토바이&quot;XML 파일과 동일한 구조이지만 '자전거'요소가 더 많고 '제조업체'요소가 순서가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="245971475847fb8e843dded9b9424bc7fe234a7a" translate="yes" xml:space="preserve">
          <source>If we would have had a huge amount of unique identifiers available, it would have tempting to drop or modify this ordering property as described above. The ordering property could for example be based on the scheduler performing the spawn operation. It would have been possible to reserve large ranges of identifiers exclusive for each scheduler thread which could be used minimizing the need for communication when allocating identifiers. The amount of identifiers we got to work with today is, however, not even close to be enough for such an approach.</source>
          <target state="translated">엄청난 양의 고유 식별자를 사용할 수 있었다면 위에서 설명한대로이 정렬 속성을 삭제하거나 수정하려는 유혹이있을 것입니다. 예를 들어 ordering 속성은 spawn 작업을 수행하는 스케줄러를 기반으로 할 수 있습니다. 식별자를 할당 할 때 통신의 필요성을 최소화하는 데 사용할 수있는 각 스케줄러 스레드에 대해 배타적 인 광범위한 식별자를 예약하는 것이 가능했을 것입니다. 그러나 오늘날 우리가 작업해야하는 식별자의 양은 그러한 접근 방식에 충분하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b8886cb75b357ed32d80a6eee9f949abb29be57" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; x, then x = y (&lt;code&gt;F&lt;/code&gt; is antisymmetric).</source>
          <target state="translated">x &lt;code&gt;F&lt;/code&gt; y 및 y &lt;code&gt;F&lt;/code&gt; x이면 x = y ( &lt;code&gt;F&lt;/code&gt; 는 비대칭 임)</target>
        </trans-unit>
        <trans-unit id="6b92816031334184272820ee86857aab64402f87" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; z, then x &lt;code&gt;F&lt;/code&gt; z (&lt;code&gt;F&lt;/code&gt; is transitive).</source>
          <target state="translated">x &lt;code&gt;F&lt;/code&gt; y 및 y &lt;code&gt;F&lt;/code&gt; z 인 경우 x &lt;code&gt;F&lt;/code&gt; z ( &lt;code&gt;F&lt;/code&gt; 는 전이).</target>
        </trans-unit>
        <trans-unit id="efd0edc2f934fb0989fdc0ef3a93bc0dc5861448" translate="yes" xml:space="preserve">
          <source>If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family.</source>
          <target state="translated">x가 I에서 X까지의 패밀리 인 경우 x [i]는 인덱스 i의 함수 값을 나타냅니다. &quot;X의 패밀리&quot;라는 표기법은 이러한 패밀리에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0460fccf75563cd103af603f5ff0df7bee5d29db" translate="yes" xml:space="preserve">
          <source>If x is a family of subsets of X, the union of the range of x is called the &lt;strong&gt;union of the family&lt;/strong&gt; x.</source>
          <target state="translated">x가 X의 부분 집합 계열 인 경우 x 범위의 합집합을 x의 &lt;strong&gt;합집합&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="7f8b7662a485e830efd5dc24b42b4f66a23c755f" translate="yes" xml:space="preserve">
          <source>If x is non-empty (the index set is non-empty), the &lt;strong&gt;intersection of the family&lt;/strong&gt; x is the intersection of the range of x.</source>
          <target state="translated">x가 비어 있지 않은 경우 (인덱스 세트가 비어 있지 않은 경우) x의 &lt;strong&gt;교집합은&lt;/strong&gt; x 범위의 교집합입니다.</target>
        </trans-unit>
        <trans-unit id="a742ef9245b7658b6ec0801964c4c0ea9a5eb508" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;must&lt;/strong&gt; return all data stored in the Ets table, you can use &lt;code&gt;ets:tab2list/1&lt;/code&gt;. However, usually you are only interested in a subset of the information in which case &lt;code&gt;ets:tab2list/1&lt;/code&gt; is expensive. If you only want to extract one field from each record, for example, the age of every person, then:</source>
          <target state="translated">Ets 테이블에 저장된 모든 데이터 &lt;strong&gt;를&lt;/strong&gt; 반환 &lt;strong&gt;해야하는&lt;/strong&gt; 경우 &lt;code&gt;ets:tab2list/1&lt;/code&gt; 을 사용할 수 있습니다 . 그러나 일반적으로 &lt;code&gt;ets:tab2list/1&lt;/code&gt; 이 비싼 정보의 하위 집합에만 관심 이 있습니다. 각 레코드에서 하나의 필드 (예 : 모든 사람의 나이) 만 추출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6695ce447118dd0e7ea4d4f74aa540c19c250112" translate="yes" xml:space="preserve">
          <source>If you are building Erlang/OTP from git you will need to run &lt;code&gt;./otp_build autoconf&lt;/code&gt; to generate the configure scripts.</source>
          <target state="translated">git에서 Erlang / OTP를 빌드하는 경우 &lt;code&gt;./otp_build autoconf&lt;/code&gt; 를 실행 하여 구성 스크립트를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="da52602929c7fc0635b8326b6c38bbbd66979f5f" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version of Erlang, you should set up PATHs etc a little differently. We have two templates to make things work in both Cygwin and MSYS but needs editing to work with MSYS2 (see the comments in the script). The following one is for 32 bits:</source>
          <target state="translated">Erlang의 64 비트 버전을 빌드하는 경우 PATH 등을 조금 다르게 설정해야합니다. Cygwin과 MSYS에서 작동하도록 두 가지 템플릿이 있지만 MSYS2와 작동하려면 편집해야합니다 (스크립트의 주석 참조). 다음은 32 비트 용입니다.</target>
        </trans-unit>
        <trans-unit id="28fd7cee740e8f1e008d545c9af326623f6f2da9" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version, you supply &lt;code&gt;otp_build&lt;/code&gt; with an architecture parameter:</source>
          <target state="translated">64 비트 버전을 빌드하는 경우 아키텍처 매개 변수와 함께 &lt;code&gt;otp_build&lt;/code&gt; 를 제공 하십시오 .</target>
        </trans-unit>
        <trans-unit id="11d01d76312a6e1beca90d30f576e8ba920e3045" translate="yes" xml:space="preserve">
          <source>If you are building in &lt;code&gt;git&lt;/code&gt; you first need to generate the &lt;code&gt;configure&lt;/code&gt; scripts:</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 에서 빌드하는 경우 먼저 &lt;code&gt;configure&lt;/code&gt; 스크립트 를 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="08ca29e8fc627bd8865e44b098a309f0c218de8e" translate="yes" xml:space="preserve">
          <source>If you are building in Git, you want to read the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section of &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">Git에서 빌드하는 경우 계속하기 전에 &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; 에서 빌드 섹션 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="059356cb46cb61018f3078a8c089ba933432567b" translate="yes" xml:space="preserve">
          <source>If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:</source>
          <target state="translated">다른 사람들이 컴파일하고 실행할 수 있도록 응용 프로그램의 소스 코드를 배포하는 경우 EUnit을 사용할 수없는 경우에도 코드가 컴파일되도록해야합니다. 이전 섹션의 예와 같이 공통 헤더 파일에 다음 줄을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f548e035d4acfc541b42547c9972c54765ffd2c" translate="yes" xml:space="preserve">
          <source>If you are executing in a mode where time offset can change, and you want to get the actual Erlang system time when the event occurred, you can save the time offset as a third element in the tuple (the least significant element when comparing three-tuples).</source>
          <target state="translated">시간 오프셋이 변경 될 수있는 모드에서 실행 중이고 이벤트가 발생할 때 실제 Erlang 시스템 시간을 얻으려면 시간 오프셋을 튜플의 세 번째 요소 (세 가지 요소를 비교할 때 가장 중요하지 않은 요소)로 저장할 수 있습니다 튜플).</target>
        </trans-unit>
        <trans-unit id="65eab1decf1d5f02b76e57b9a0f013425229d73c" translate="yes" xml:space="preserve">
          <source>If you are going to build a 64bit Windows version, you should make sure to get MinGW's 64bit gcc installed with Cygwin. It's in one of the development packages.</source>
          <target state="translated">64 비트 Windows 버전을 구축하려는 경우 Cygwin과 함께 MinGW의 64 비트 gcc를 설치해야합니다. 개발 패키지 중 하나에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e873962d506d0453e258cd67b870cfcf9fdf56aa" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">이벤트가 발생한 시점의 Erlang 시스템 시간에 관심이있는 경우 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 을 사용하여 이벤트를 저장하기 전이나 후에 시간 오프셋을 저장할 수도 있습니다 . 시간 오프셋과 함께 추가 된 Erlang 단조로운 시간은 Erlang 시스템 시간에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="abcce25aa490a7895d515f9ea238920455b90682" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">이벤트가 발생한 시점의 Erlang 시스템 시간에 관심이있는 경우 &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; 을 사용하여 이벤트를 저장하기 전후에 시간 오프셋을 저장할 수도 있습니다 . 시간 오프셋과 함께 추가 된 Erlang 단조 시간은 Erlang 시스템 시간에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2501e29b8883667aa63c6065f64ad533173ff055" translate="yes" xml:space="preserve">
          <source>If you are new to &lt;code&gt;gen_statem&lt;/code&gt; and want an overview of concepts and operation the section &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; located in the User's Guide &lt;code&gt; OTP Design Principles &lt;/code&gt; is recommended to read before this reference manual, possibly after the Description section you are reading here.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 을 처음 사용 하고 개념 및 작동에 대한 개요를 원하는 경우 사용자 가이드 &lt;code&gt; OTP Design Principles &lt;/code&gt; 에있는 &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; 섹션 을이 참조 설명서 이전에, 아마도 여기에서 읽고있는 설명 섹션 이후에 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6ec4906363d7f3a0f656197645460eb641bfd86b" translate="yes" xml:space="preserve">
          <source>If you are not familiar with Cygwin, MSYS, MSYS2 or a Unix environment, you&amp;rsquo;ll probably need to read up a bit on how that works. There are plenty of documentation about this online.</source>
          <target state="translated">Cygwin, MSYS, MSYS2 또는 Unix 환경에 익숙하지 않은 경우 작동 방식에 대해 약간 읽어 봐야합니다. 이 온라인에 대한 많은 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="79e81e9c6f10164072a2c4df28a3214be53b197f" translate="yes" xml:space="preserve">
          <source>If you are not sure that OS system time is correct, set it to a time that is guaranteed to be earlier than actual POSIX time before starting the Erlang runtime system, just to be safe.</source>
          <target state="translated">OS 시스템 시간이 정확한지 확실하지 않으면 Erlang 런타임 시스템을 시작하기 전에 실제 POSIX 시간보다 빠른 시간으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="139e4db82ce537b7ca402bb5648cb80768493b2d" translate="yes" xml:space="preserve">
          <source>If you are only interested in the age of all persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">&quot;Bryan&quot;이라는 모든 사람의 나이에만 관심이 있다면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a4b3fb25184745a8c5de1f41ef693f7c3d65a1fb" translate="yes" xml:space="preserve">
          <source>If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</source>
          <target state="translated">If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</target>
        </trans-unit>
        <trans-unit id="12bada1e7a2afb8d739c0b1c4888bc6d1de99967" translate="yes" xml:space="preserve">
          <source>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one &lt;code&gt;Common Test&lt;/code&gt; is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">분산 Erlang 애플리케이션을 테스트하는 경우 코드 적용 범위 분석에 포함하려는 코드가 &lt;code&gt;Common Test&lt;/code&gt; 가 실행되는 것과 다른 Erlang 노드에서 실행될 수 있습니다. 그렇다면 표지 스펙 파일에서 이러한 다른 노드를 지정하거나 노드를 코드 적용 범위 세트에 동적으로 추가해야합니다. 후자에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c864b6e67ea1285ed3a001c19cfbf05fe7b8b75d" translate="yes" xml:space="preserve">
          <source>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</source>
          <target state="translated">용어를 올바르게 해제했는지 확실하지 않은 경우 다음 기능을 사용하여 고정 용어 할당 자의 상태를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="785964c082f500e973ee23af1227a47d2e13719e" translate="yes" xml:space="preserve">
          <source>If you can edit and recompile the source code, it is convenient to insert &lt;code&gt;fprof:trace(start)&lt;/code&gt; and &lt;code&gt;fprof:trace(stop)&lt;/code&gt; before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt;.</source>
          <target state="translated">소스 코드를 편집하고 다시 컴파일 할 수 있으면 프로파일 링 할 코드 전후에 &lt;code&gt;fprof:trace(start)&lt;/code&gt; 및 &lt;code&gt;fprof:trace(stop)&lt;/code&gt; 을 삽입하는 것이 편리합니다 . 생성 된 모든 프로세스도 추적됩니다. 기본값 이외의 다른 파일 이름을 원하면 &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt; 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5adefb435e12cfcf7b44d388cd53353f9f445a0" translate="yes" xml:space="preserve">
          <source>If you combine catching exceptions from this function with &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt; for example in the event of network problems. So why not just let the calling process die by not catching the exception?</source>
          <target state="translated">호출이 시간 종료 될 때 호출 프로세스가 종료되는 것을 피하기 &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; 함수의 예외 포착을 {dirty_timeout, T} 와 결합 하면 늦은 응답을 처리 할 준비가되어 있어야합니다. 예를 들어 네트워크 문제가 발생하는 경우 &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; 또는 &lt;code&gt;infinity&lt;/code&gt; 를 사용 하더라도 응답이 늦어 질 가능성이 있습니다. 그렇다면 예외를 포착하지 않고 호출 프로세스를 죽이는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="926494dd9305a4cb191069b2570f8e16c82b75b1" translate="yes" xml:space="preserve">
          <source>If you compare with the code you will see there also that &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; was called only from &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; and itself, and called only &lt;code&gt;file:write/2&lt;/code&gt;, note the number of calls to &lt;code&gt;file:write/2&lt;/code&gt;. But here we see that &lt;code&gt;suspend&lt;/code&gt; was called a few times. This is a pseudo function that indicates that the process was suspended while executing in &lt;code&gt;foo:create_file_slow/3&lt;/code&gt;, and since there is no &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;erlang:yield/0&lt;/code&gt; in the code, it must be Erlang scheduling suspensions, or the trace file driver compensating for large file write operations (these are regarded as a schedule out followed by a schedule in to the same process).</source>
          <target state="translated">코드와 비교하면 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 가 &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; 에서 자체적 으로 호출되고 &lt;code&gt;file:write/2&lt;/code&gt; 만 호출 된 경우 &lt;code&gt;file:write/2&lt;/code&gt; 에 대한 호출 수를 확인 하십시오 . 그러나 여기서는 &lt;code&gt;suspend&lt;/code&gt; 이 몇 번 호출 되었다는 것을 알 수 있습니다. 에서 실행하는 동안이 프로세스가 중단되었음을 나타냅니다 유사 기능입니다 &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; 와 있기 때문에 더 &lt;code&gt;receive&lt;/code&gt; 또는 &lt;code&gt;erlang:yield/0&lt;/code&gt; 코드에서, 그것은 얼랑 스케줄링 현탁액, 또는 추적 파일 드라이버 보상해야 대용량 파일 쓰기 작업의 경우 (이는 동일한 프로세스의 일정이 뒤 따르는 일정으로 간주 됨).</target>
        </trans-unit>
        <trans-unit id="4da979d104276d1b284d0d0ed5628a6c4ba8264c" translate="yes" xml:space="preserve">
          <source>If you compile with the following, the result is one merged module &lt;code&gt;MyModule.erl&lt;/code&gt; with the generated code from the three ASN.1 specs:</source>
          <target state="translated">다음을 사용하여 컴파일 하면 세 개의 ASN.1 사양에서 생성 된 코드 가 포함 된 하나의 병합 된 모듈 &lt;code&gt;MyModule.erl&lt;/code&gt; 이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="229f423b538bb335420959949ffa6439771ff69b" translate="yes" xml:space="preserve">
          <source>If you compose your own &lt;code&gt;cipher_suites()&lt;/code&gt; make sure they are filtered for cryptolib support &lt;code&gt;&lt;a href=&quot;#filter_cipher_suites-2&quot;&gt; ssl:filter_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; Additionaly the functions &lt;code&gt;&lt;a href=&quot;#append_cipher_suites-2&quot;&gt; ssl:append_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#prepend_cipher_suites-2&quot;&gt; ssl:prepend_cipher_suites/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#suite_to_str-1&quot;&gt;ssl:suite_to_str/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#str_to_suite-1&quot;&gt;ssl:str_to_suite/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#suite_to_openssl_str-1&quot;&gt;ssl:suite_to_openssl_str/1&lt;/a&gt;&lt;/code&gt; also exist to help creating customized cipher suite lists.</source>
          <target state="translated">당신이 당신의 자신의 구성 경우 &lt;code&gt;cipher_suites()&lt;/code&gt; 확인 그들은 cryptolib 지원에 대한 필터링 &lt;code&gt;&lt;a href=&quot;#filter_cipher_suites-2&quot;&gt; ssl:filter_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; Additionaly 기능 &lt;code&gt;&lt;a href=&quot;#append_cipher_suites-2&quot;&gt; ssl:append_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#prepend_cipher_suites-2&quot;&gt; ssl:prepend_cipher_suites/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#suite_to_str-1&quot;&gt;ssl:suite_to_str/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#str_to_suite-1&quot;&gt;ssl:str_to_suite/1&lt;/a&gt;&lt;/code&gt; , 및 &lt;code&gt;&lt;a href=&quot;#suite_to_openssl_str-1&quot;&gt;ssl:suite_to_openssl_str/1&lt;/a&gt;&lt;/code&gt; 은 사용자 지정 암호 그룹 목록을 만드는 데 도움을주기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2523acc9d9b699bb6e45fe3319252f79d5b73690" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip, Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">결국 테스트 케이스를 실행하지 않기로 결정했다면 &lt;code&gt;{skip, Reason}&lt;/code&gt; 반환 합니다. 그런 다음 HTML 결과 페이지의 &lt;code&gt;Comment&lt;/code&gt; 필드에 &lt;code&gt;Reason&lt;/code&gt; 가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="34553151842c57d51c700a2176df03643a8e288f" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip,Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">테스트 케이스를 실행하지 않기로 결정한 경우 &lt;code&gt;{skip,Reason}&lt;/code&gt; 을 리턴하십시오 . 그런 다음 HTML 결과 페이지의 &lt;code&gt;Comment&lt;/code&gt; 필드에 &lt;code&gt;Reason&lt;/code&gt; 가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc41ca02f8abc69bcba03c2039a4711eec766fcf" translate="yes" xml:space="preserve">
          <source>If you desire to also use some other general cover configuration together with this option you should insert the AppName in between the option and its value creating a three tuple.</source>
          <target state="translated">이 옵션과 함께 다른 일반 커버 구성도 사용하려면 옵션과 해당 값 사이에 AppName을 삽입하여 3 개의 튜플을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="32b5510ec0b67d605ceab6963978d04cd1ab40d6" translate="yes" xml:space="preserve">
          <source>If you develop linked-in drivers (shared library) you need to link using &lt;code&gt;gcc&lt;/code&gt; and the flags &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt;. You also include &lt;code&gt;-fno-common&lt;/code&gt; in &lt;code&gt;CFLAGS&lt;/code&gt; when compiling. Use &lt;code&gt;.so&lt;/code&gt; as the library suffix.</source>
          <target state="translated">링크 된 드라이버 (공유 라이브러리)를 개발하는 경우 &lt;code&gt;gcc&lt;/code&gt; 및 &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt; 플래그를 사용하여 링크해야합니다 . 또한 컴파일 할 때 &lt;code&gt;CFLAGS&lt;/code&gt; 에 &lt;code&gt;-fno-common&lt;/code&gt; 을 포함 시킵니다. 라이브러리 접미사로 &lt;code&gt;.so&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9af22866bc3303d3e5e15bb7da268298a32e5b69" translate="yes" xml:space="preserve">
          <source>If you do not have a complete binary of the file content, you can instead chunk through the file and check part by part. The return-tuple &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; from function &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; comes in handy. The incomplete rest from one chunk of data read from the file is prepended to the next chunk and we therefore avoid the problem of character boundaries when reading chunks of bytes in UTF-8 encoding:</source>
          <target state="translated">파일 내용의 완전한 이진 파일이없는 경우 대신 파일을 청크하고 부분적으로 확인할 수 있습니다. 함수 &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; 의 리턴 튜플 &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; 이 편리합니다. 파일에서 읽은 하나의 데이터 청크에서 불완전한 휴식은 다음 청크 앞에 추가되므로 UTF-8 인코딩으로 바이트 청크를 읽을 때 문자 경계 문제를 피합니다.</target>
        </trans-unit>
        <trans-unit id="d69c0d8ff5a49420e5ccb90500698b1a5b852393" translate="yes" xml:space="preserve">
          <source>If you do not need the statistical quality of this function, there are faster algorithms in the &lt;code&gt;rand&lt;/code&gt; module.</source>
          <target state="translated">이 함수의 통계적 품질이 필요하지 않은 경우 &lt;code&gt;rand&lt;/code&gt; 모듈 에 더 빠른 알고리즘이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec8d18a133f467591527f3dafe062626f3a3e3a8" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt; enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">NIF 호출에서 데이터를 재 할당하거나 유지할 필요가없는 경우 가능한 경우 프로세스 힙에 작은 바이너리를 할당하므로 &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt; enif_make_new_binary&lt;/a&gt;&lt;/code&gt; 를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="45fdd3948b5b8d018a253264434e3fdb3b1f2c9e" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">NIF 호출에서 데이터를 재 할당하거나 유지할 필요가없는 경우 가능한 경우 프로세스 힙에 작은 이진을 할당하므로 &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; 를 대신 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="0d84e01d642f906e2813071c9f195dfd3ff33506" translate="yes" xml:space="preserve">
          <source>If you do ordinary &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;receive&lt;/code&gt; trace on the system, you will only see ordinary message passing, not the other information transfers listed above.</source>
          <target state="translated">당신이 평범한 할 경우 &lt;code&gt;send&lt;/code&gt; 하거나 &lt;code&gt;receive&lt;/code&gt; 시스템에 추적을, 당신은 단지 일반적인 메시지 전달이 아닌 위에 나열된 다른 정보 전송을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5226c0c04d7fd8e63c97c31f497edc30ae0498fc" translate="yes" xml:space="preserve">
          <source>If you don't use X-windows, you might want to setup the Windows console window by selecting properties in the console system menu (upper left corner of the window, the Cygwin icon in the title bar). Especially setting a larger screen buffer size (lines) is useful as it gets you a scrollbar so you can see whatever error messages that might appear.</source>
          <target state="translated">X-windows를 사용하지 않는 경우, 콘솔 시스템 메뉴 (창 왼쪽 상단, 제목 표시 줄의 Cygwin 아이콘)에서 특성을 선택하여 Windows 콘솔 창을 설정할 수 있습니다. 특히 더 큰 화면 버퍼 크기 (라인)를 설정하면 스크롤 막대가 표시되어 나타날 수있는 오류 메시지를 볼 수 있으므로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c1c77e78076b1c45254b83e1685877227a58e370" translate="yes" xml:space="preserve">
          <source>If you explicitly want to set the program name in the argument vector, option &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">인수 벡터에서 프로그램 이름을 명시 적으로 설정하려면 옵션 &lt;code&gt;arg0&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f75fbec32c4686a4e8aec99dc351f8983616950b" translate="yes" xml:space="preserve">
          <source>If you fail to clear thread-specific data in an emulator thread before letting it out of your control, you might never be able to clear this data with later unexpected errors in other parts of the system as a result.</source>
          <target state="translated">제어에서 벗어나기 전에 에뮬레이터 스레드에서 스레드 특정 데이터를 지우지 못하면 결과적으로 시스템의 다른 부분에서 예기치 않은 오류로이 데이터를 지우지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="09268e829b124cfcf4bd5de6e9875906ac8513d6" translate="yes" xml:space="preserve">
          <source>If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions to our &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; and patches to our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; directories mostly. The &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; directory is for common code.</source>
          <target state="translated">환경에 익숙하고 시스템을 구축하고 필요한 모든 도구를 갖추었다면 Windows 용 Erlang / OTP 배포를 개선 할 수있는 좋은 기회입니다. &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; 에 대한 제안 사항 과 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; 에 대한 패치를 제출 하여 다음 버전의 Erlang으로 안내하십시오. makefile과 같은 빌드 시스템을 변경하는 경우 Unix / VxWorks에서 동일한 makefile이 사용되므로 변경 사항으로 인해 다른 플랫폼이 손상되지 않습니다. 물론 C 코드도 마찬가지입니다. 시스템 특정 코드는 주로 &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; 및 &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; 디렉토리에 있습니다. &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; 디렉토리는 공통 코드입니다.</target>
        </trans-unit>
        <trans-unit id="c1e46734643c479e7f6063eb73e949cb06d69d85" translate="yes" xml:space="preserve">
          <source>If you find that some common Logger usage is missing from this guide, please open a pull request on github with the suggested addition</source>
          <target state="translated">이 가이드에서 일반적인 Logger 사용법이 누락 된 것을 발견하면 제안 된 추가와 함께 github에서 pull 요청을여십시오.</target>
        </trans-unit>
        <trans-unit id="6c7e44c265926484064ef3996081db76eb5b3893" translate="yes" xml:space="preserve">
          <source>If you frequently do a lookup on a field that is not the key of the table, you lose performance using &quot;mnesia:select/match_object&quot; as this function traverses the whole table. You can create a secondary index instead and use &quot;mnesia:index_read&quot; to get faster access, however this requires more memory.</source>
          <target state="translated">테이블의 키가 아닌 필드를 자주 조회하면이 함수가 전체 테이블을 통과하므로 &quot;mnesia : select / match_object&quot;를 사용하여 성능이 저하됩니다. 대신 보조 인덱스를 만들고 &quot;mnesia : index_read&quot;를 사용하여 더 빠르게 액세스 할 수 있지만 더 많은 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d250cbc8ce8f103748e70e8012ae4812e69e6b6e" translate="yes" xml:space="preserve">
          <source>If you got a public key &lt;code&gt;PubKey&lt;/code&gt; and a related list of attributes &lt;code&gt;Attributes&lt;/code&gt; as returned by &lt;code&gt;ssh_decode/2&lt;/code&gt;, you can create a new SSH file, for example:</source>
          <target state="translated">공개 키 &lt;code&gt;PubKey&lt;/code&gt; 및 &lt;code&gt;ssh_decode/2&lt;/code&gt; 에서 리턴 한 속성 &lt;code&gt;Attributes&lt;/code&gt; 관련 목록이 있는 경우 새 SSH 파일을 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d64558ffe085d81fb4c2a7370d51643970e9b47a" translate="yes" xml:space="preserve">
          <source>If you hack the emulator, you can build the emulator executable by standing in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and do a simple</source>
          <target state="translated">에뮬레이터를 해킹하면 &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; emulator에 서서 에뮬레이터 실행 파일을 빌드하고 간단한 작업을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="57dee92dc02000c0c82e5fb9e2da62997a25dbd7" translate="yes" xml:space="preserve">
          <source>If you have Xcode 4.3, or later, you will also need to download &quot;Command Line Tools&quot; via the Downloads preference pane in Xcode.</source>
          <target state="translated">Xcode 4.3 이상이있는 경우 Xcode의 다운로드 기본 설정 창을 통해 &quot;명령 줄 도구&quot;를 다운로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="709a85ba273f4493deb19337d8dab86c17b51b44" translate="yes" xml:space="preserve">
          <source>If you have a list of lists &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt;, then you can sum the lengths of all the strings in &lt;code&gt;L&lt;/code&gt; as follows:</source>
          <target state="translated">당신은리스트의 목록이있는 경우 &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt; , 당신은 모든 문자열의 길이의 합 수 &lt;code&gt;L&lt;/code&gt; 다음을 :</target>
        </trans-unit>
        <trans-unit id="06562602ec1a77035c75bd6f06f61c39f1543c77" translate="yes" xml:space="preserve">
          <source>If you have added the declaration &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; to your module, as described above, you only need to compile the module, and run the automatically exported function &lt;code&gt;test()&lt;/code&gt;. For example, if your module was named &lt;code&gt;m&lt;/code&gt;, then calling &lt;code&gt;m:test()&lt;/code&gt; will run EUnit on all the tests defined in the module. You do not need to write &lt;code&gt;-export&lt;/code&gt; declarations for the test functions. This is all done by magic.</source>
          <target state="translated">위에서 설명한대로 &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; 선언 을 모듈에 추가 한 경우 모듈을 컴파일하고 자동으로 내 보낸 함수 &lt;code&gt;test()&lt;/code&gt; 실행하면됩니다 . 예를 들어, 모듈 이름이 &lt;code&gt;m&lt;/code&gt; 인 경우 &lt;code&gt;m:test()&lt;/code&gt; 를 호출 하면 모듈에 정의 된 모든 테스트에서 EUnit이 실행됩니다. 테스트 함수에 대해 &lt;code&gt;-export&lt;/code&gt; 선언 을 작성할 필요가 없습니다 . 이것은 모두 마술에 의해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="144f513a5aa39876b81ef2c80a71c2be4b26f4ef" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;install&lt;/code&gt; target, install the documentation using the &lt;code&gt;install-docs&lt;/code&gt; target. Install locations determined by &lt;code&gt;configure&lt;/code&gt; will be used. &lt;code&gt;$DESTDIR&lt;/code&gt; can be used the same way as when doing &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;install&lt;/code&gt; 대상을 사용하여 Erlang / OTP를 설치 한 경우 &lt;code&gt;install-docs&lt;/code&gt; 대상을 사용하여 문서를 설치하십시오 . &lt;code&gt;configure&lt;/code&gt; 에 의해 결정된 설치 위치 가 사용됩니다. &lt;code&gt;$DESTDIR&lt;/code&gt; 은 make install 을 수행 &lt;code&gt;make install&lt;/code&gt; 때와 같은 방식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f15d88801e622a2cdd2d2c7fe2a4a670f216ed9a" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;release&lt;/code&gt; target, install the documentation using the &lt;code&gt;release_docs&lt;/code&gt; target. You typically want to use the same &lt;code&gt;RELEASE_ROOT&lt;/code&gt; as when invoking &lt;code&gt;make release&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;release&lt;/code&gt; 대상을 사용하여 Erlang / OTP를 설치 한 경우 &lt;code&gt;release_docs&lt;/code&gt; 대상을 사용하여 문서를 설치하십시오 . 일반적으로 &lt;code&gt;make release&lt;/code&gt; 를 호출 할 때 와 동일한 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="56c20a2d676e8cfb31affcccb02e9255a03aa95c" translate="yes" xml:space="preserve">
          <source>If you have installed documentation in the OTP installation, also build the documentation:</source>
          <target state="translated">OTP 설치에 문서를 설치 한 경우 문서도 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="e2d1684e846a6a2121920a90b95e7857c8b4feb5" translate="yes" xml:space="preserve">
          <source>If you have just built Erlang/OTP in the current source tree, you have already ran &lt;code&gt;configure&lt;/code&gt; and do not need to do this again; otherwise, run &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">현재 소스 트리에서 Erlang / OTP를 방금 구축 한 경우 이미 &lt;code&gt;configure&lt;/code&gt; 실행 했으므로 다시 수행 할 필요가 없습니다. 그렇지 않으면 &lt;code&gt;configure&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="636ce5c9d1bb03f9748b5bbe5ec2f545e4d839b3" translate="yes" xml:space="preserve">
          <source>If you have many servers in one node and they have some state(s) in their lifetime in which the servers can be expected to idle for a while, and the amount of heap memory all these servers need is a problem, then the memory footprint of a server can be mimimized by hibernating it through &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">하나의 노드에 많은 서버가 있고 수명 기간 동안 서버가 잠시 유휴 상태가 될 것으로 예상되는 상태가 있고 이러한 서버에 필요한 힙 메모리의 양에 문제가있는 경우 메모리 풋 프린트 서버의 &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; 를 통해 최대 절전 모드로 설정하면 서버를 최소화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9cf69c3d3514b68c365fa229d8d36e057061c7ae" translate="yes" xml:space="preserve">
          <source>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; and related for the tracing step.</source>
          <target state="translated">프로파일 링하려는 작업을 수행하는 하나의 함수가 있고 프로파일 링이 중지 될 때 함수가 반환되는 경우 &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; 를 사용하고 추적 단계와 관련된 함수 를 사용하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="4add882c433457afa2edf542bb650cc29a895ccb" translate="yes" xml:space="preserve">
          <source>If you have public-key data and want to create a PEM file this can be done by calling functions &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; and &lt;code&gt;pem_encode/1&lt;/code&gt; and saving the result to a file. For example, assume that you have &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt;. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file (ASN.1 type &lt;code&gt;'RSAPublicKey'&lt;/code&gt;) or a PEM-&quot;PUBLIC KEY&quot; file (&lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 type).</source>
          <target state="translated">공개 키 데이터가 있고 PEM 파일을 작성하려는 경우 &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; 및 &lt;code&gt;pem_encode/1&lt;/code&gt; 함수를 호출 하고 결과를 파일에 저장하여 수행 할 수 있습니다 . 예를 들어 &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt; 이 있다고 가정하십시오 . 그런 다음 PEM- &quot;RSA PUBLIC KEY&quot;파일 (ASN.1 유형 &lt;code&gt;'RSAPublicKey'&lt;/code&gt; ) 또는 PEM- &quot;PUBLIC KEY&quot;파일 ( &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 유형)을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bff364d7b744c7c80f16da3e2585cd7454157cd3" translate="yes" xml:space="preserve">
          <source>If you have system configuration data that is neither file-location-dependent nor site-dependent, it can be convenient to create &lt;code&gt;sys.config&lt;/code&gt; early, so it becomes part of the target system tar file created by &lt;code&gt;target_system:create/1&lt;/code&gt;. In fact, if you in the current directory create not only the file &lt;code&gt;mysystem.rel&lt;/code&gt;, but also file &lt;code&gt;sys.config&lt;/code&gt;, the latter file is tacitly put in the appropriate directory.</source>
          <target state="translated">파일 위치 또는 사이트에 의존하지 않는 시스템 구성 데이터가있는 경우 &lt;code&gt;sys.config&lt;/code&gt; 를 일찍 작성하는 것이 편리 할 수 ​​있으므로 &lt;code&gt;target_system:create/1&lt;/code&gt; 에 의해 작성된 대상 시스템 tar 파일의 일부가됩니다 . 실제로 현재 디렉토리에 &lt;code&gt;mysystem.rel&lt;/code&gt; 파일 뿐만 아니라 &lt;code&gt;sys.config&lt;/code&gt; 파일도 작성 하면 후자의 파일이 암묵적으로 적절한 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="dd12871aeecfcf251ad76c0f1867361b2f02e152" translate="yes" xml:space="preserve">
          <source>If you have your cross compilation configuration in a file, pass it using the &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; command line argument. If not, pass &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt;, and the configuration variables using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax on the command line (same as in (3)). Note that &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; have to be passed one way or the other; either by using &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; in the configuration file, or by using the &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, and &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; command line arguments.</source>
          <target state="translated">파일에 크로스 컴파일 구성이있는 경우 &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; 명령 줄 인수를 사용하여 전달하십시오 . 그렇지 않은 경우 명령 줄 에서 &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; 구문을 사용하여 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; , &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 및 구성 변수를 전달하십시오 ((3)과 동일). 참고 &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; 방법은 하나 또는 다른을 전달하는 한, 어느 이용한 &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 과 &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 구성 파일, 또는 사용하여 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 및 &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; 명령 행 인수.</target>
        </trans-unit>
        <trans-unit id="496f196f55a6fe378376abb5b448050f783c1628" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another &lt;strong&gt;state callback&lt;/strong&gt; of yours, you have not done a &lt;strong&gt;state change&lt;/strong&gt; and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">당신이 경우 &lt;code&gt;gen_statem&lt;/code&gt; , 예를 들어, 하나의 상태에서 이벤트를 연기하고 다른 통화 &lt;strong&gt;상태 콜백&lt;/strong&gt; 당신의를, 당신은하지 않은 &lt;strong&gt;상태 변경을&lt;/strong&gt; 따라서 연기 이벤트는 논리적이지만 혼동 될 수있는 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a130450837fa7de4006e06dfdf6e7651f3519c93" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another state callback of yours, you have not changed states and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">당신이 경우 &lt;code&gt;gen_statem&lt;/code&gt; , 예를 들어, 당신의 다른 상태 콜백을 한 상태에서 이벤트를 연기하고 전화, 당신은 상태를 변경하지 않은 따라서 연기 이벤트는 논리적이지만 혼동 될 수있는 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b9dac884f6e658e0d27a929573db5f362853b18" translate="yes" xml:space="preserve">
          <source>If you instead receives the XML doc as a string you can parse it by &lt;code&gt;xmerl_scan:string/1&lt;/code&gt;. Both file/2 and string/2 exists where the second argument is a list of options to the parser, see the &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대신 XML 문서를 문자열로 받으면 &lt;code&gt;xmerl_scan:string/1&lt;/code&gt; 로 구문 분석 할 수 있습니다 . file / 2와 string / 2는 두 번째 인수가 구문 분석기에 대한 옵션 목록 인 경우 &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3677b7b2be331958bb1cd558066c15e2ccbebc50" translate="yes" xml:space="preserve">
          <source>If you know that the binaries you return are always small, you are advised to use driver API calls that do not require a pre-allocated binary, for example, &lt;code&gt;driver_output()&lt;/code&gt; or &lt;code&gt;erl_drv_output_term()&lt;/code&gt;, using the &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; format, to allow the runtime to construct a heap binary.</source>
          <target state="translated">반환하는 바이너리가 항상 작다는 것을 알고 있다면 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 형식을 사용하여 사전 할당 된 바이너리가 필요하지 않은 드라이버 API 호출 &lt;code&gt;driver_output()&lt;/code&gt; 예 : driver_output () 또는 &lt;code&gt;erl_drv_output_term()&lt;/code&gt; 을 사용하여 런타임을 허용하는 것이 좋습니다 힙 바이너리를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ec9a6635ce4a0b540125a17cac3147d60753ebe4" translate="yes" xml:space="preserve">
          <source>If you know the location of the &lt;code&gt;escript&lt;/code&gt; executable, the first line can directly give the path to &lt;code&gt;escript&lt;/code&gt;, for example:</source>
          <target state="translated">당신의 위치를 알고있는 경우 &lt;code&gt;escript&lt;/code&gt; 의 실행을 첫 번째 줄에 직접 경로를 제공 할 수 있습니다 &lt;code&gt;escript&lt;/code&gt; 예를 :</target>
        </trans-unit>
        <trans-unit id="b659d556ba001a4273a3f6f58c5f3fae0a2ecf0c" translate="yes" xml:space="preserve">
          <source>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">당신은 당신이 당신의 통제의 스레드를 할 때 에뮬레이터 스레드에 잠겨 뮤텍스를두면, 당신은 할 &lt;strong&gt;가능성이 높다&lt;/strong&gt; 전체 에뮬레이터를 교착 상태.</target>
        </trans-unit>
        <trans-unit id="1b0a6367d887c72eef350e1e461ed2440088fd89" translate="yes" xml:space="preserve">
          <source>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">당신은 당신이 당신의 통제의 스레드를 할 때 에뮬레이터 스레드에 잠겨으로 rwlock을두면, 당신은 할 &lt;strong&gt;가능성이 높다&lt;/strong&gt; 전체 에뮬레이터를 교착 상태.</target>
        </trans-unit>
        <trans-unit id="2051d057687b13e60280ea15afa70933db6bc2e6" translate="yes" xml:space="preserve">
          <source>If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. &lt;code&gt;erl_tar&lt;/code&gt; will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of &lt;code&gt;erl_tar&lt;/code&gt; or &lt;code&gt;tar&lt;/code&gt; which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually.</source>
          <target state="translated">USTAR tar 형식과의 호환성을 유지해야하는 경우 저장되는 파일 경로가 총 255 바이트 미만이어야하며 최대 파일 이름 구성 요소 길이는 100 바이트입니다. USTAR는 이름 필드 외에 헤더 필드 (접두사)를 사용하고 100 바이트보다 긴 파일 경로를 두 부분으로 분할합니다. 이 분할은 디렉토리 경계에서 수행되며이 두 필드에서 사용 가능한 공간을 최대한 활용하는 방식으로 수행되지만 실제로는 경로에 대해 255 바이트 미만을 의미합니다. &lt;code&gt;erl_tar&lt;/code&gt; 는 더 긴 파일 이름을 처리하기 위해 형식을 PAX로 자동 업그레이드하므로 &lt;code&gt;erl_tar&lt;/code&gt; 또는 &lt;code&gt;tar&lt;/code&gt; 의 이전 구현으로 아카이브를 추출해야하는 경우에만 문제가됩니다.PAX를 지원하지 않는 이 경우 PAX 헤더는 일반 파일로 추출되므로 수동으로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="25dcb500f427185c223988b86fbacdec9413c19c" translate="yes" xml:space="preserve">
          <source>If you need all information stored in the Ets table about persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">이름이 &quot;Bryan&quot;인 사람에 대한 Ets 테이블에 저장된 모든 정보가 필요하면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f37451567abb8a5fc173c77a71ec77e3d5bec387" translate="yes" xml:space="preserve">
          <source>If you need cryptographically strong random numbers use &lt;code&gt;&lt;a href=&quot;#rand_seed_alg_s-1&quot;&gt;rand_seed_alg_s/1&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Alg =:= crypto&lt;/code&gt; or &lt;code&gt;Alg =:= crypto_cache&lt;/code&gt;.</source>
          <target state="translated">강력한 암호화 난수가 필요한 경우 &lt;code&gt;Alg =:= crypto&lt;/code&gt; 또는 &lt;code&gt;Alg =:= crypto_cache&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;#rand_seed_alg_s-1&quot;&gt;rand_seed_alg_s/1&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0103403298226ace2d2d7dda7dc0c9b1cec0d2bd" translate="yes" xml:space="preserve">
          <source>If you need to access a relational database such as &lt;code&gt;sqlserver&lt;/code&gt;, &lt;code&gt;mysql&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt;, &lt;code&gt;cybase&lt;/code&gt; etc. from your erlang application using the Erlang ODBC interface is a good way to go about it.</source>
          <target state="translated">Erlang ODBC 인터페이스를 사용하여 erlang 응용 프로그램에서 &lt;code&gt;sqlserver&lt;/code&gt; , &lt;code&gt;mysql&lt;/code&gt; , &lt;code&gt;postgres&lt;/code&gt; , &lt;code&gt;oracle&lt;/code&gt; , &lt;code&gt;cybase&lt;/code&gt; 등과 같은 관계형 데이터베이스에 액세스해야하는 경우이 방법을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="062952594b89959967de93ea3f7d77ceb7f51d4f" translate="yes" xml:space="preserve">
          <source>If you need to be able to repeat the sequence use this function.</source>
          <target state="translated">시퀀스를 반복해야하는 경우이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e9153977b046897dff8af7e0a644f81df1265049" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that a time-out message cannot arrive after this, unless you have postponed it before (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may have arrived just before you cancelling it, so you may have to read out such a message from the process mailbox depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">다른 이벤트로 인해 타이머를 취소해야하는 경우 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 사용할 수 있습니다 . 시간 초과 메시지는 이전에 연기하지 않은 한 (다음 섹션 참조) 이후에 도착할 수 없으므로 실수로 그러한 메시지를 연기하지 않도록하십시오. 또한 시간 종료 메시지는 취소하기 직전에 도착했을 수 있으므로 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 의 리턴 값에 따라 프로세스 메일 함에서 해당 메시지를 읽어야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c795f2c3cb53282059f2c8f8a7e14a7e129d266c" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that no time-out message will arrive after this (because the timer has been explicitly canceled), unless you have already postponed one earlier (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may arrive during a &lt;strong&gt;state callback&lt;/strong&gt; that is cancelling the timer, so you may have to read out such a message from the process mailbox, depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">다른 이벤트로 인해 타이머를 취소해야하는 경우 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 사용할 수 있습니다 . 타이머가 명시 적으로 취소 되었기 때문에 시간 초과 메시지가 도착하지 않을 것입니다 (타이머가 명시 적으로 취소 되었기 때문에). 이전에 이미 연기하지 않은 경우 (다음 섹션 참조) 실수로 이러한 메시지를 연기하지 않도록하십시오. 또한 타이머를 취소 하는 &lt;strong&gt;상태 콜백&lt;/strong&gt; 중에 시간 초과 메시지가 도착할 수 있으므로 &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; 의 반환 값에 따라 프로세스 사서함에서 이러한 메시지를 읽어야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f62eb303efefa39c68fc73abc117f5184daeab26" translate="yes" xml:space="preserve">
          <source>If you need to define a new function that does garbage collection, you should give it the prefix &lt;code&gt;erts_gc_&lt;/code&gt;. If that is not possible you should update the regular expression so that it will match your new function.</source>
          <target state="translated">가비지 컬렉션을 수행하는 새 함수를 정의해야하는 경우 접두사 &lt;code&gt;erts_gc_&lt;/code&gt; 를 지정해야합니다 . 가능하지 않은 경우 새 함수와 일치하도록 정규식을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="05af26e95eb9bb5371b21575710d131d97fecf50" translate="yes" xml:space="preserve">
          <source>If you need to perform configuration operations to run your test, you can implement configuration functions in your suite. The result from a configuration function is configuration data, or &lt;code&gt;Config&lt;/code&gt;. This is a list of key-value tuples that get passed from the configuration function to the test cases (possibly through configuration functions on &quot;lower level&quot;). The data flow looks as follows:</source>
          <target state="translated">테스트를 실행하기 위해 구성 작업을 수행해야하는 경우 제품군에서 구성 기능을 구현할 수 있습니다. 구성 함수의 결과는 구성 데이터 또는 &lt;code&gt;Config&lt;/code&gt; 입니다. 구성 기능에서 테스트 케이스로 전달되는 키-값 튜플의 목록입니다 ( &quot;낮은 레벨&quot;의 구성 기능을 통해 가능). 데이터 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1580293999144403cc43337470ad032b5154d650" translate="yes" xml:space="preserve">
          <source>If you need to use Erlang code that is not &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;, and you need to start the Erlang runtime system before OS system time has been corrected, you may want to use the single time warp mode.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; 하지 않은 Erlang 코드를 사용해야 하고 OS 시스템 시간이 수정되기 전에 Erlang 런타임 시스템을 시작해야하는 경우 단일 시간 왜곡 모드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3af53f2c07526824c69b1abdb7517239318228" translate="yes" xml:space="preserve">
          <source>If you need to use thread-specific data in an emulator thread, only have the thread-specific data set while the thread is under your control, and clear the thread-specific data before you let the thread out of your control.</source>
          <target state="translated">에뮬레이터 스레드에서 스레드 특정 데이터를 사용해야하는 경우 스레드가 제어하는 ​​동안 스레드 특정 데이터 만 설정하고 스레드에서 제어를 해제하기 전에 스레드 특정 데이터를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="4f32b6b35644f5b16edce6c4d78753a25d38ebfb" translate="yes" xml:space="preserve">
          <source>If you need to verify the bootstrap beam files match the provided source files, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; to create a new commit that contains differences, if any exist.</source>
          <target state="translated">부트 스트랩 빔 파일이 제공된 소스 파일과 일치하는지 확인해야하는 경우, &lt;code&gt;./otp_build update_primary&lt;/code&gt; 를 사용하여 차이가있는 새 커밋을 작성하십시오 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="a564a81cdbcd1f7df3fcca09ff995949d4ddcb79" translate="yes" xml:space="preserve">
          <source>If you or your system has special requirements please read the &lt;code&gt;Makefile&lt;/code&gt; for additional configuration information.</source>
          <target state="translated">사용자 또는 시스템에 특별한 요구 사항이있는 경우 추가 구성 정보 는 &lt;code&gt;Makefile&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="c9741cf8a267768b2bd92351adecbc979f0aa0dd" translate="yes" xml:space="preserve">
          <source>If you plan to change code without restarting your system, you must use an external fun (&lt;code&gt;fun Module:Function/Arity&lt;/code&gt;) as function &lt;code&gt;Resolve&lt;/code&gt;. If you use a local fun, you can never replace the code for the module that the fun belongs to.</source>
          <target state="translated">시스템을 다시 시작하지 않고 코드를 변경하려면 &lt;code&gt;Resolve&lt;/code&gt; 함수로 외부 &lt;code&gt;fun Module:Function/Arity&lt;/code&gt; ( fun Module : Function / Arity )을 사용해야 합니다. 로컬 재미를 사용하는 경우 재미가 속한 모듈의 코드를 대체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d19108a84a5eb3bb48cef4ccb2f6536e5feabf9" translate="yes" xml:space="preserve">
          <source>If you read back the option value using &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; and get no value, the option does not exist in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 옵션 값을 다시 읽고 값을 가져 오지 않으면 호스트 운영 체제에 옵션이 없습니다. 동일한 포트에서 수신 대기하는 IPv6 및 IPv4 소켓과 IPv4 트래픽을 가져 오는 IPv6 소켓의 동작을 더 이상 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="85b82b7060fb8d9f6ed2cb286e33072d08347f0f" translate="yes" xml:space="preserve">
          <source>If you really, really want to, you may call it &quot;Inga&quot;.</source>
          <target state="translated">정말로, 정말로 원한다면, &quot;Inga&quot;라고 부를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad8b8f8006dc094fc060a805431e5051049c527" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;call&lt;/code&gt; trace flag, you also have to set a &lt;strong&gt;trace pattern&lt;/strong&gt; for the functions you want to trace:</source>
          <target state="translated">당신은 설정하면 &lt;code&gt;call&lt;/code&gt; 추적 플래그를, 당신은 또한 설정해야 &lt;strong&gt;추적 패턴을&lt;/strong&gt; 추적 할 기능을 :</target>
        </trans-unit>
        <trans-unit id="593fb6e309e5d0f221339df106e191b090ca84ba" translate="yes" xml:space="preserve">
          <source>If you simply want to format a paragraph of plain text, you probably want to use the &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; function, as in the following example:</source>
          <target state="translated">단순히 일반 텍스트의 단락을 형식화 하려면 다음 예제와 같이 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; 함수 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="da6562fe0a7c0b54c043b4d0278072613df57ef3" translate="yes" xml:space="preserve">
          <source>If you start this program with &lt;code&gt;code_lock:start([17])&lt;/code&gt; you can unlock with &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;code_lock:start([17])&lt;/code&gt; 로이 프로그램을 시작하면 &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt; 하여 잠금을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cace6db1c9825fe249b9c220bf578982c6ffbbda" translate="yes" xml:space="preserve">
          <source>If you successfully parse the XML file with the validation on as in: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; you know that the XML document is valid and has the structure according to the DTD.</source>
          <target state="translated">&lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; 에서와 같이 유효성 검증을 사용하여 XML 파일을 구문 분석하면 XML 문서가 유효하며 DTD에 따른 구조를가집니다.</target>
        </trans-unit>
        <trans-unit id="d59053b915a39ff162dae55e7504e339f09a4e42" translate="yes" xml:space="preserve">
          <source>If you try to do the same again with another city, an error is returned:</source>
          <target state="translated">다른 도시와 동일한 작업을 다시 시도하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a798d01202205d436563f3b0bd17d64f51325641" translate="yes" xml:space="preserve">
          <source>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</source>
          <target state="translated">레지스트리에 개체를 저장하려고 할 때 같은 키를 가진 기존 개체가 있으면 새 값이 이전 값을 대체합니다. 이 작업은 새 객체와 기존 객체의 유형이 같은지 여부에 관계없이 수행되므로 문자열을 정수로 바꿀 수 있습니다. 기존 값이 문자열 또는 이진 인 경우 새 값이 할당되기 전에 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="515a151c90cdd13d9e4906d959838a101ec214d6" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;erl_connect_init()&lt;/code&gt;, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;erl_connect_init()&lt;/code&gt; 를 사용하면 노드의 이름이 짧습니다. 즉, 정규화 된 이름이 아닙니다. 정규화 된 (긴) 이름을 사용해야하는 경우 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0d834de6c7b4bcac9902d0548059107a16f86a8b" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the code for each application is placed in a separate directory following a pre-defined &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">코드 패키징을 위해 Erlang / OTP 도구 인 &lt;code&gt;systools&lt;/code&gt; 를 사용하는 경우 ( &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; 참조 ) 각 응용 프로그램의 코드는 사전 정의 된 &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt; 에 따라 별도의 디렉토리에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dfdc592f173581c774f93af24400d86f856a5e1" translate="yes" xml:space="preserve">
          <source>If you use an old apace-like configuration file.</source>
          <target state="translated">오래된 apace와 같은 구성 파일을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="16a79b696fe4d902f78f4a9ec278a5c8cacbb001" translate="yes" xml:space="preserve">
          <source>If you use multiple CTHs, the first part of the return tuple is used as input for the next CTH. So in the previous example the next CTH can get &lt;code&gt;{fail,Reason}&lt;/code&gt; as the second parameter. If you have many CTHs interacting, do not let each CTH return &lt;code&gt;fail&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;. Instead, return that an action is to be taken through the &lt;code&gt;Config&lt;/code&gt; list and implement a CTH that, at the end, takes the correct action.</source>
          <target state="translated">여러 CTH를 사용하는 경우 리턴 튜플의 첫 번째 부분이 다음 CTH에 대한 입력으로 사용됩니다. 따라서 이전 예에서 다음 CTH는 두 번째 매개 변수로 &lt;code&gt;{fail,Reason}&lt;/code&gt; 을 얻을 수 있습니다 . 상호 작용하는 CTH가 많은 경우 각 CTH 리턴이 &lt;code&gt;fail&lt;/code&gt; 하거나 &lt;code&gt;skip&lt;/code&gt; 않도록하십시오 . 대신, &lt;code&gt;Config&lt;/code&gt; 목록을 통해 조치가 취해 지도록 리턴 하고 마지막에 올바른 조치를 취하는 CTH를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="930cef54ac87bd2c1ca6f2387bf6edcd93ce9313" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Erl_Interface&lt;/code&gt; functions in a threaded application based on POSIX threads or Solaris threads, then &lt;code&gt;Erl_Interface&lt;/code&gt; needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define &lt;code&gt;_REENTRANT&lt;/code&gt; and either &lt;code&gt;STHREADS&lt;/code&gt; or &lt;code&gt;PTHREADS&lt;/code&gt;. The default is to use POSIX threads if &lt;code&gt;_REENTRANT&lt;/code&gt; is specified.</source>
          <target state="translated">POSIX 스레드 또는 Solaris 스레드를 기반으로하는 스레드 응용 프로그램에서 &lt;code&gt;Erl_Interface&lt;/code&gt; 함수 를 사용하는 경우 &lt;code&gt;Erl_Interface&lt;/code&gt; 는 스레드 패키지의 일부 동기화 기능에 액세스해야합니다. 사용하는 패키지를 나타내려면 추가 컴파일러 플래그를 지정해야합니다. &lt;code&gt;_REENTRANT&lt;/code&gt; 및 &lt;code&gt;STHREADS&lt;/code&gt; 또는 &lt;code&gt;PTHREADS&lt;/code&gt; 를 정의하십시오 . &lt;code&gt;_REENTRANT&lt;/code&gt; 가 지정된 경우 기본값은 POSIX 스레드를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="918394c05671a0235e153985bd2840211574395e" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;ct_run&lt;/code&gt; program, you can start the Erlang shell and &lt;code&gt;Common Test&lt;/code&gt; in one go by using the flag &lt;code&gt;-shell&lt;/code&gt; and, optionally, flag &lt;code&gt;-config&lt;/code&gt; and/or &lt;code&gt;-userconfig&lt;/code&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;ct_run&lt;/code&gt; 의 프로그램을, 당신은 얼랑 쉘 및 시작할 수 있습니다 &lt;code&gt;Common Test&lt;/code&gt; 플래그를 사용하여 한 번에 &lt;code&gt;-shell&lt;/code&gt; , 선택적 플래그 및 &lt;code&gt;-config&lt;/code&gt; 및 / 또는 &lt;code&gt;-userconfig&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3feb64f146fe919b2a69ce546c85439b7b8b28d7" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">Erlang 노드가 시작부터 원격 작업을 활성화하도록하려면 (기본 로컬 작업이 아닌) &lt;code&gt;-remsh&lt;/code&gt; 플래그를 사용하여 Erlang을 시작 합니다 (예 : &lt;code&gt;erl -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2153b220590bbe864e1f5e224d987fcb64330153" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">Erlang 노드가 기본 로컬 작업 대신 시작부터 원격 작업을 활성화하도록하려면 플래그 &lt;code&gt;-remsh&lt;/code&gt; 로 Erlang을 시작하십시오 ( 예 : &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50de302c93e8bacbc69e071b7eec983f033e6a07" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#call-4&quot;&gt;erpc:call()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="translated">결과를 구별하는 기능을 원한다면 &lt;code&gt;erpc&lt;/code&gt; 모듈 의 &lt;code&gt;&lt;a href=&quot;erpc#call-4&quot;&gt;erpc:call()&lt;/a&gt;&lt;/code&gt; 함수를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="00e8ce10cfe9321c8cbd6786fc123b13ea0a780a" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#multicall-4&quot;&gt;erpc:multicall()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="translated">결과를 구별하는 기능을 원한다면 &lt;code&gt;erpc&lt;/code&gt; 모듈 에서 &lt;code&gt;&lt;a href=&quot;erpc#multicall-4&quot;&gt;erpc:multicall()&lt;/a&gt;&lt;/code&gt; 함수를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="88f9444d15f637070cc1c5665eb79410298eb57c" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#send_request-4&quot;&gt;erpc:send_request()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead. This also gives you the ability retrieve the results in other useful ways.</source>
          <target state="translated">결과를 구별하는 기능을 원하면 &lt;code&gt;erpc&lt;/code&gt; 모듈 에서 &lt;code&gt;&lt;a href=&quot;erpc#send_request-4&quot;&gt;erpc:send_request()&lt;/a&gt;&lt;/code&gt; 함수를 대신 사용하는 것이 좋습니다. 이것은 또한 다른 유용한 방법으로 결과를 검색하는 능력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a4038140d6bff952f2f9f5f48acf2d27c3f6092b" translate="yes" xml:space="preserve">
          <source>If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; only (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the &lt;code&gt;Handle&lt;/code&gt; value.</source>
          <target state="translated">연결 만 &lt;code&gt;Handle&lt;/code&gt; 와 연관 시키려면 (예를 들어, 호스트에 대한 여러 연결을 열어야하는 경우) 구성 변수 이름 인 &lt;code&gt;Key&lt;/code&gt; 를 사용하여 대상을 지정하십시오. 연관된 대상 이름이없는 연결은 &lt;code&gt;Handle&lt;/code&gt; 값으로 만 닫을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c1ebb966c6523b3c1b7beffcce3bfa9b40caeb1" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt; erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 에서 반환 한 것과 동일한 형식을 원하면 &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt; erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="92c8c9a37ae2934ad0217ae03b7ce8edb49f913c" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; 에서 리턴 한 것과 동일한 형식을 원하면 &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="340edf748ea085618e9e02efc24d38acd583eead" translate="yes" xml:space="preserve">
          <source>If you want to add the information about a black Harley Davidsson 1200 cc Sportster motorcycle from 2003 that is in shape as new in the motorcycles.xml document you can put the data in a simple-form data structure like:</source>
          <target state="translated">motorcycles.xml 문서의 새로운 모양 인 2003 년의 검은 색 Harley Davidsson 1200 cc Sportster 오토바이에 대한 정보를 추가하려면 다음과 같은 간단한 형식의 데이터 구조에 데이터를 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e13e233caef4d78d7dc7bb7c518cb87cbe184c" translate="yes" xml:space="preserve">
          <source>If you want to apply patches of multiple OTP applications that resides in different OTP versions, you have to apply these patches in multiple steps. It is only possible to apply multiple OTP applications from the same OTP version at once.</source>
          <target state="translated">다른 OTP 버전에있는 여러 OTP 응용 프로그램의 패치를 적용하려면이 패치를 여러 단계로 적용해야합니다. 동일한 OTP 버전의 여러 OTP 응용 프로그램을 한 번에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42438cc3a906ec708300aa20929e7d2e6e66a173" translate="yes" xml:space="preserve">
          <source>If you want to build the &lt;code&gt;wx&lt;/code&gt; application, you will need to get wxWidgets-3.0 (&lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt;) or get it from github with bug fixes:</source>
          <target state="translated">&lt;code&gt;wx&lt;/code&gt; 애플리케이션 을 빌드하려면 &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt; 에서 wxWidgets-3.0 ( &lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; ) 을 가져와야합니다. 3.0.3.tar.bz2 ) 또는 버그 수정으로 github에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="60d473a6aa433acfb9c1c6ca737fe13eaf0848c9" translate="yes" xml:space="preserve">
          <source>If you want to build using a compatible Erlang/OTP system in the &lt;code&gt;$PATH&lt;/code&gt;, jump to (3).</source>
          <target state="translated">&lt;code&gt;$PATH&lt;/code&gt; 에서 호환 가능한 Erlang / OTP 시스템을 사용하여 빌드 하려면 (3)으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="eb5df9d9054fc0c4d2d1fdf02282b9d140be554d" translate="yes" xml:space="preserve">
          <source>If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with &lt;code&gt;{source_name, SourceName}&lt;/code&gt;. If unset it will default to the name of the opened file.</source>
          <target state="translated">사전 처리 중에 삽입 된 암시 적 -file () 속성의 파일 이름을 변경하려면 &lt;code&gt;{source_name, SourceName}&lt;/code&gt; 수행 할 수 있습니다 . 설정하지 않으면 기본적으로 열린 파일의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c541b95485f056deb59b7660fe1bc3263ea0c2c7" translate="yes" xml:space="preserve">
          <source>If you want to copy a library (an application) newly built, to a release area, you do like with the emulator:</source>
          <target state="translated">새로 빌드 한 라이브러리 (응용 프로그램)를 릴리스 영역으로 복사하려면 에뮬레이터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="478802cbe47a5a6b031caf1a058324304adf72a9" translate="yes" xml:space="preserve">
          <source>If you want to do structured logging, but still want to have some control of how the final log message is formatted you can give a &lt;code&gt;report_cb&lt;/code&gt; as part of the metadata with your log event.</source>
          <target state="translated">구조화 된 로깅을 수행하고 싶지만 최종 로그 메시지의 형식을 일부 제어하려면 로그 이벤트와 함께 메타 데이터의 일부로 &lt;code&gt;report_cb&lt;/code&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af39ab464f4c4ad6184b7312f8ff3491ab00be0a" translate="yes" xml:space="preserve">
          <source>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).</source>
          <target state="translated">패턴의 특정 지점에서 일치 실패를 강제하려면 빈 문자열이 항상 일치하므로 가장 편리한 방법은 (?!)입니다. 따라서 빈 문자열이 없어야하는 어설 션은 항상 실패해야합니다. 역 추적 제어 동사 (* FAIL) 또는 (* F)는 (?!)의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="b53c1301abde2142a7a519277a4e352002bba7dc" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after a &lt;strong&gt;state change&lt;/strong&gt;, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">현재 상태의 특정 이벤트를 무시하고 향후 상태에서 처리하려면 이벤트를 연기 할 수 있습니다. 연기 된 이벤트는 &lt;strong&gt;상태 변경&lt;/strong&gt; 후 재 시도 &lt;code&gt;OldState =/= NewState&lt;/code&gt; . 즉, OldState = / = NewState 입니다.</target>
        </trans-unit>
        <trans-unit id="1d95e36a6d42c79b8d9f3cbb7ca6b72d1dfb12b0" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after the state has changed, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">현재 상태의 특정 이벤트를 무시하고 향후 상태에서 처리하려는 경우 이벤트를 연기 할 수 있습니다. 연기 된 이벤트는 상태가 변경된 후 다시 시도됩니다 (즉, &lt;code&gt;OldState =/= NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b637ab1ccef72c8ef19f9dd28f47f58deee1a99" translate="yes" xml:space="preserve">
          <source>If you want to limit the size of the trace logs, you can use wrap logs. This works almost like a circular buffer. You can specify the maximum number of binary logs and the maximum size of each log. &lt;code&gt;ttb&lt;/code&gt; then creates a new binary log each time a log reaches the maximum size. When the maximum number of logs are reached, the oldest log is deleted before a new one is created.</source>
          <target state="translated">추적 로그의 크기를 제한하려면 랩 로그를 사용할 수 있습니다. 이것은 거의 원형 버퍼처럼 작동합니다. 최대 이진 로그 수와 각 로그의 최대 크기를 지정할 수 있습니다. &lt;code&gt;ttb&lt;/code&gt; 다음 ttb 는 로그가 최대 크기에 도달 할 때마다 새로운 이진 로그를 만듭니다. 최대 로그 수에 도달하면 새 로그를 만들기 전에 가장 오래된 로그가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3ba20665ef257abe2a78ab66aec5b8422b06c770" translate="yes" xml:space="preserve">
          <source>If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:</source>
          <target state="translated">전형적인 회문 구문을 일치 시키려면 패턴은 다음과 같이 수행 할 수있는 단어가 아닌 모든 문자를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="ecc0e9164bc34f28d81e7ffb4afcab4e5c0c14b8" translate="yes" xml:space="preserve">
          <source>If you want to only print run-time per thread type you can do:</source>
          <target state="translated">스레드 유형별로 런타임 만 인쇄하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="be41c980691226fb7b2d6a9c0782adc2d56de58a" translate="yes" xml:space="preserve">
          <source>If you want to output the content of an XML element or an attribute you will get the value as a string by the &lt;code&gt;value_of&lt;/code&gt; function:</source>
          <target state="translated">XML 요소 또는 속성의 내용을 출력하려면 &lt;code&gt;value_of&lt;/code&gt; 함수를 통해 값을 문자열로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e7aef053601a6ea882918cfebb175091d4d52943" translate="yes" xml:space="preserve">
          <source>If you want to parse the XML file motorcycles.xml you run it in the Erlang shell like:</source>
          <target state="translated">XML 파일 motorcycles.xml을 구문 분석하려면 다음과 같이 Erlang 쉘에서 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6e509b56bd064c6196e8412d4a6710ea854feb39" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">바이너리를 전달하고 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 바이너리의 내용이 아직없는 경우 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 를 생성 한 다음 ERL_DRV_BINARY를 통해 바이너리를 전달하는 대신 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 를 사용 하는 것이 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; . 런타임 시스템은 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 가 사용되는 경우 바이너리를 더 스마트하게 할당하는 경우가 많습니다 . 그러나 전달할 바이너리의 콘텐츠가 이미 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 에있는 경우 일반적으로 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 및 문제의 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 를 사용하여 바이너리를 전달하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c0f0b294d62ab97983874294bfe640932bf22f5a" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">바이너리를 전달하고 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 에 바이너리의 내용이없는 경우 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 를 생성하는 대신 &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 를 사용하여 ERL_DRV_BINARY 를 통해 바이너리를 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 있습니다. &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; 가 사용되는 경우 런타임 시스템은 종종 바이너리를 더 똑똑하게 할당합니다 . 그러나 전달할 이진 컨텐츠가 이미 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 에있는 경우 일반적으로 &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; 및 해당 &lt;code&gt;ErlDrvBinary&lt;/code&gt; 를 사용하여 이진을 전달하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="480d25bad4b8ee292973eb9f4a96b57aec47c435" translate="yes" xml:space="preserve">
          <source>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named &lt;code&gt;m_tests&lt;/code&gt; (note: not &lt;code&gt;m_test&lt;/code&gt;), if your module is named &lt;code&gt;m&lt;/code&gt;. Then, whenever you ask EUnit to test the module &lt;code&gt;m&lt;/code&gt;, it will also look for the module &lt;code&gt;m_tests&lt;/code&gt; and run those tests as well. See &lt;code&gt;ModuleName&lt;/code&gt; in the section &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">당신이 당신의 정상적인 코드에서 테스트 코드를 구분합니다 (내 보낸 함수를 테스트하기 위해 적어도), 당신은 단순히 모듈 이름의 테스트 기능을 쓸 수 있습니다 &lt;code&gt;m_tests&lt;/code&gt; (주 : &lt;code&gt;m_test&lt;/code&gt; ), 모듈의 이름은 경우 &lt;code&gt;m&lt;/code&gt; 을 . 그런 다음 EUnit에게 &lt;code&gt;m&lt;/code&gt; 모듈을 테스트하도록 요청할 때마다 &lt;code&gt;m_tests&lt;/code&gt; 모듈을 찾고 해당 테스트도 실행합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; 요소 섹션에서 &lt;code&gt;ModuleName&lt;/code&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="7febab41e67d722699474affa70aca83861a7f64" translate="yes" xml:space="preserve">
          <source>If you want to tailor your Erlang/OTP build and installation, please read on for detailed information about the individual steps.</source>
          <target state="translated">Erlang / OTP 빌드 및 설치를 조정하려면 개별 단계에 대한 자세한 정보를 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="5c51074011b9826995f35f468d11eff897ad5c37" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">함수 호출을 추적하려면 (즉, 프로세스에 추적 플래그 &lt;code&gt;call&lt;/code&gt; 설정된 경우 ) &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; 을 사용하여 필요한 함수에 추적 패턴을 설정해야합니다 . / 2,3,4 . 함수는 추적 패턴이있는 경우에만 추적됩니다. 추적 패턴은 일치 스펙을 사용하여 함수를 추적하는 방법을 지정합니다. 일치 스펙은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c40a044ef678327852ece515ee5ae9954050c2e8" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#tp-2&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#tpl-2&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">함수 호출을 추적하려는 경우 (즉, 프로세스에 추적 플래그 &lt;code&gt;call&lt;/code&gt; 설정된 경우 ) &lt;code&gt;&lt;a href=&quot;ttb#tp-2&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ttb#tpl-2&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; 을 사용하여 필요한 함수에 대한 추적 패턴도 설정해야합니다 . / 2,3,4 . 함수는 추적 패턴이있는 경우에만 추적됩니다. 추적 패턴은 일치 스펙을 사용하여 함수를 추적하는 방법을 지정합니다. 일치 사양은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4204e5cb6bf67f77002e41cae41377b945558f43" translate="yes" xml:space="preserve">
          <source>If you want your systems logs to be printed to a file instead, you must configure the default handler to do so. The simplest way is to include the following in your &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">시스템 로그를 파일로 인쇄하려면 기본 처리기를 구성해야합니다. 가장 간단한 방법은 &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt; 에 다음을 포함시키는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="bc1242f30c23d446d1188a6ac120aa5dbc4659e1" translate="yes" xml:space="preserve">
          <source>If you wish to exit the interactive mode (for example, to start an automated test run with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), call function &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt;. This shuts down the running &lt;code&gt;ct&lt;/code&gt; application. Associations between configuration names and data created with &lt;code&gt;require&lt;/code&gt; are consequently deleted. Function &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; takes you back into interactive mode, but the previous state is not restored.</source>
          <target state="translated">대화식 모드를 종료하려면 (예 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 로 자동 테스트 실행을 시작하려면 ) &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt; 함수를 호출하십시오 . 실행중인 &lt;code&gt;ct&lt;/code&gt; 응용 프로그램 이 종료됩니다 . 구성 이름과 &lt;code&gt;require&lt;/code&gt; 로 작성된 데이터 간의 연관 은 결과적으로 삭제됩니다. &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; 함수 는 대화식 모드로 되돌아 가지만 이전 상태는 복원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e10f84ca92ffa048cba38c4e906ca1f626ae3a34" translate="yes" xml:space="preserve">
          <source>If you wish to store an arbitrary pointer in the registry, specify a &lt;code&gt;size&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;. In this case, the object itself is not transferred by an &lt;code&gt;ei_reg_dump()&lt;/code&gt; operation, only the pointer value.</source>
          <target state="translated">레지스트리에 임의의 포인터를 저장하려면 &lt;code&gt;size&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 지정하십시오 . 이 경우 객체 자체는 포인터 값만으로 &lt;code&gt;ei_reg_dump()&lt;/code&gt; 연산으로 전송되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ebce7ca5b1598f3fc834609ac79ed9ef57b76a9b" translate="yes" xml:space="preserve">
          <source>If you're unable to produce back-ticks on your keyboard, you can use the ksh variant:</source>
          <target state="translated">키보드에서 백틱을 생성 할 수없는 경우 ksh 변형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="898016192f939b5abb6e665e68d4a556cad78625" translate="yes" xml:space="preserve">
          <source>If you're using MinGW's MSYS instead, you need to change the &lt;code&gt;C_DRV&lt;/code&gt; setting, which would read:</source>
          <target state="translated">MinGW의 MSYS를 대신 사용하는 경우 &lt;code&gt;C_DRV&lt;/code&gt; 설정 을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b80191fd2f2a93c0231ee04e580f333dbbc4b2c1" translate="yes" xml:space="preserve">
          <source>If you've upgraded the source with a patch you may need to clean up from previous builds before the new build. Make sure to read the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; section below before doing a &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">패치로 소스를 업그레이드 한 경우 새 빌드 전에 이전 빌드에서 정리해야합니다. &lt;code&gt;make clean&lt;/code&gt; 하기 전에 아래 의 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; 섹션을 반드시 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="94d3d2824c70cd2f197cb4a4e891f6adbf0d6555" translate="yes" xml:space="preserve">
          <source>If your application has multiple levels of supervision, then do not simply set the restart intensities to the same values on all levels. Keep in mind that the total number of restarts (before the top level supervisor gives up and terminates the application) will be the product of the intensity values of all the supervisors above the failing child process.</source>
          <target state="translated">응용 프로그램에 여러 수준의 감독이있는 경우 모든 수준에서 다시 시작 강도를 동일한 값으로 설정하지 마십시오. 총 다시 시작 횟수 (최상위 수퍼바이저가 응용 프로그램을 포기하고 종료하기 전)는 실패한 자식 프로세스 위의 모든 수퍼바이저의 강도 값의 곱이됩니다.</target>
        </trans-unit>
        <trans-unit id="8bdaa0464a895b83db580413a1dfb239d0cea7a3" translate="yes" xml:space="preserve">
          <source>If your driver supports scrollable cursors you have a little more freedom, and can do things like this.</source>
          <target state="translated">드라이버가 스크롤 가능한 커서를 지원하면 약간 더 자유롭고 이와 같은 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4baf8bf70284fc593a0f0c3da52f4c0847c8447" translate="yes" xml:space="preserve">
          <source>If your process logic is convenient to describe as a state machine, and you want any of these &lt;code&gt;gen_statem&lt;/code&gt; key features:</source>
          <target state="translated">프로세스 로직이 상태 머신으로 설명하기 편리하고 다음과 같은 &lt;code&gt;gen_statem&lt;/code&gt; 주요 기능 중 하나를 원하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3a769c81046d5475e30518ad57d42d8c20c63372" translate="yes" xml:space="preserve">
          <source>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the &lt;code&gt;user&lt;/code&gt; output stream, as in &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt;. The recommended way of doing this is to use the EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;, which make it much simpler.</source>
          <target state="translated">테스트 코드가 표준 출력에 쓰면 테스트가 실행될 때 콘솔에 텍스트가 나타나지 않는 것에 놀랄 수 있습니다. EUnit은 테스트 기능 (설정 및 정리 기능은 포함하지만 생성기 기능은 포함하지 않음)의 모든 표준 출력을 캡처하므로 오류가 발생할 경우 테스트 보고서에 포함 할 수 있습니다. 테스트하는 동안 EUnit을 무시하고 텍스트를 콘솔에 직접 인쇄하려면 &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt; 과 같이 &lt;code&gt;user&lt;/code&gt; 출력 스트림에 쓸 수 있습니다 . 이 작업을 수행하는 데 권장되는 방법은 EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; 를 사용하여 훨씬 간단하게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e46e774253b8a01c9e57b4a236314fe7c6f0933" translate="yes" xml:space="preserve">
          <source>If, for example, only information originating from the UNIX kernel is to be supervised, the line is to begin with &lt;code&gt;kern.LEVEL&lt;/code&gt;. For the possible values of &lt;code&gt;LEVEL&lt;/code&gt;, see &lt;code&gt;syslog.conf(5)&lt;/code&gt;.</source>
          <target state="translated">예를 들어, UNIX 커널에서 시작된 정보 만 감독 &lt;code&gt;kern.LEVEL&lt;/code&gt; 경우, 행은 kern.LEVEL 로 시작해야합니다 . 가능한 &lt;code&gt;LEVEL&lt;/code&gt; 값 은 &lt;code&gt;syslog.conf(5)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5e15af770ad74c816f0b9bed18089dc4b7b6949" translate="yes" xml:space="preserve">
          <source>If, however, the more brutal variant is preferred, the the release upgrade file can be handwritten using only the single upgrade instruction &lt;code&gt;restart_emulator&lt;/code&gt;. This instruction, in contrast to &lt;code&gt;restart_new_emulator&lt;/code&gt;, causes the emulator to restart with the new versions of &lt;strong&gt;all&lt;/strong&gt; applications.</source>
          <target state="translated">그러나보다 잔인한 변형이 선호되는 경우 릴리스 업그레이드 파일은 단일 업그레이드 명령 &lt;code&gt;restart_emulator&lt;/code&gt; 만 사용하여 손으로 작성할 수 있습니다 . &lt;code&gt;restart_new_emulator&lt;/code&gt; 와 달리이 명령어 는 에뮬레이터가 &lt;strong&gt;모든&lt;/strong&gt; 버전의 &lt;strong&gt;모든&lt;/strong&gt; 응용 프로그램 으로 다시 시작되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="8767a6609841ad161f8c8ba70fce614ffbb6d735" translate="yes" xml:space="preserve">
          <source>If, however, the profiling time is short, and the host machine OS does not support high resolution cpu time measurements, some few OS schedulings may show up as ridiculously long execution times for functions doing practically nothing. An example of a function more or less just composing a tuple in about 100 times the normal execution time has been seen, and when the tracing was repeated, the execution time became normal.</source>
          <target state="translated">그러나 프로파일 링 시간이 짧고 호스트 시스템 OS가 고해상도 CPU 시간 측정을 지원하지 않는 경우, 일부 OS 스케줄링은 실제로 아무 것도 수행하지 않는 기능에 대해 엄청나게 긴 실행 시간으로 표시 될 수 있습니다. 정상 실행 시간의 약 100 배로 튜플을 구성하는 함수의 예가 보였고 추적이 반복되면 실행 시간이 정상이되었습니다.</target>
        </trans-unit>
        <trans-unit id="59b8380df4e4f344feb44d33018af07ce17468c9" translate="yes" xml:space="preserve">
          <source>Ifopts :: &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt;getifaddrs_ifopts()&lt;/a&gt;&lt;/code&gt;}]} |</source>
          <target state="translated">Ifopts :: &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt;getifaddrs_ifopts()&lt;/a&gt;&lt;/code&gt;}]} |</target>
        </trans-unit>
        <trans-unit id="28ab139e8caa6336e1a75280870aaa88d194b8f0" translate="yes" xml:space="preserve">
          <source>Ignores the next term.</source>
          <target state="translated">다음 용어를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="556c1293becdd2112a2dbef3ccdc8818c38e5526" translate="yes" xml:space="preserve">
          <source>Igor will look for terms &lt;code&gt;{igor, List}&lt;/code&gt; in the compile options, where &lt;code&gt;List&lt;/code&gt; is a list of Igor-specific options, as follows:</source>
          <target state="translated">Igor는 컴파일 옵션에서 &lt;code&gt;{igor, List}&lt;/code&gt; 라는 용어를 찾습니다 . 여기서 &lt;code&gt;List&lt;/code&gt; 는 다음과 같이 Igor 관련 옵션의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="12b0ac37014df125334c7cd0aa5d1e3fd4b2112b" translate="yes" xml:space="preserve">
          <source>Igor: the Module Merger and Renamer.</source>
          <target state="translated">Igor : 모듈 합병 및 Renamer.</target>
        </trans-unit>
        <trans-unit id="434e93d1be37385e2cb586a90949b6d54ba9fb45" translate="yes" xml:space="preserve">
          <source>Illegal record use</source>
          <target state="translated">불법 기록 사용</target>
        </trans-unit>
        <trans-unit id="3e2e754eaf99ea7ee3f9e02b703f2ea22dce19f1" translate="yes" xml:space="preserve">
          <source>Imagine two nodes, &lt;code&gt;A&lt;/code&gt; that initiates the handshake and &lt;code&gt;B&lt;/code&gt; that accepts the connection.</source>
          <target state="translated">핸드 셰이크를 시작하는 &lt;code&gt;A&lt;/code&gt; 와 연결을 수락하는 &lt;code&gt;B&lt;/code&gt; 의 두 노드를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="8170de3694759bfa15c0e42d75a0e2dbd2eae04c" translate="yes" xml:space="preserve">
          <source>Immediately after &lt;code&gt;{addr,_}&lt;/code&gt; follows &lt;code&gt;{netmask,_}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{addr,_}&lt;/code&gt; 직후에 &lt;code&gt;{netmask,_}&lt;/code&gt; 뒤에옵니다 .</target>
        </trans-unit>
        <trans-unit id="e1bf55aaa279dcec7c69afe67e49a23edfac3d7b" translate="yes" xml:space="preserve">
          <source>Immediately closes a socket in one or two directions.</source>
          <target state="translated">소켓을 한 방향 또는 두 방향으로 즉시 닫습니다.</target>
        </trans-unit>
        <trans-unit id="0146e3e7271e73fd4397519ed5ac080aa4266f79" translate="yes" xml:space="preserve">
          <source>Immediately thereafter follows &lt;code&gt;{broadaddr,_}&lt;/code&gt; if flag &lt;code&gt;broadcast&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; set and flag &lt;code&gt;pointtopoint&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; set.</source>
          <target state="translated">그 직후에 다음 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 플래그 경우 &lt;code&gt;broadcast&lt;/code&gt; 되어 &lt;strong&gt;있지&lt;/strong&gt; 설정하고 플래그 &lt;code&gt;pointtopoint&lt;/code&gt; 가&lt;strong&gt;되어&lt;/strong&gt; 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cb29b93b7dda93ac46a90e113b640a73b1abac2b" translate="yes" xml:space="preserve">
          <source>Immediately thereafter may &lt;code&gt;{broadaddr,_}&lt;/code&gt; follow if &lt;code&gt;broadcast&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;, or &lt;code&gt;{dstaddr,_}&lt;/code&gt; if &lt;code&gt;pointtopoint&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;. Both &lt;code&gt;{dstaddr,_}&lt;/code&gt; and &lt;code&gt;{broadaddr,_}&lt;/code&gt; does not occur for the same &lt;code&gt;{addr,_}&lt;/code&gt;.</source>
          <target state="translated">그 직후에 할 수있다 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 경우에 따라 &lt;code&gt;broadcast&lt;/code&gt; 의 구성원 &lt;code&gt;Flags&lt;/code&gt; , 또는 &lt;code&gt;{dstaddr,_}&lt;/code&gt; 하는 경우 &lt;code&gt;pointtopoint&lt;/code&gt; 가 의 구성원 &lt;code&gt;Flags&lt;/code&gt; . 두 &lt;code&gt;{dstaddr,_}&lt;/code&gt; 과 &lt;code&gt;{broadaddr,_}&lt;/code&gt; 는 같은 발생하지 않습니다 &lt;code&gt;{addr,_}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="bc83afa84755c20a6573a25450865f22d16b7af9" translate="yes" xml:space="preserve">
          <source>Implement a User-Specific Handler</source>
          <target state="translated">사용자 별 처리기 구현</target>
        </trans-unit>
        <trans-unit id="3848d63613aeeb25bb34384b1787a4b8da6d6ff9" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;outputv&lt;/code&gt; callback (instead of an &lt;code&gt;output&lt;/code&gt; callback) in the driver. If a driver has an &lt;code&gt;outputv&lt;/code&gt; callback, refc binaries passed in an iolist in the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_command/2&lt;/code&gt; will be passed as references to the driver.</source>
          <target state="translated">드라이버에서 &lt;code&gt;outputv&lt;/code&gt; 콜백 ( &lt;code&gt;output&lt;/code&gt; 콜백 대신)을 구현 하십시오. 드라이버에 &lt;code&gt;outputv&lt;/code&gt; 콜백 이있는 경우 &lt;code&gt;port_command/2&lt;/code&gt; 의 &lt;code&gt;Data&lt;/code&gt; 인수 에서 iolist로 전달 된 refc 바이너리 는 드라이버에 대한 참조로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2550fab1130c47b29d0bf324dcd951c87cbd4c20" translate="yes" xml:space="preserve">
          <source>Implement the user(s).</source>
          <target state="translated">사용자를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="48c5877ca241f34b3f104510084da2e3f17d9449" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">구현 : 균형 이진 검색 트리가 사용됩니다. 시간 복잡도는 log N에 비례하며, 여기서 N은 사용 가능한 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="986bf772c885393163838b577762f2d1f9c7f455" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</source>
          <target state="translated">구현 : 균형 이진 검색 트리가 사용됩니다. 시간 복잡도는 log N에 비례하며, 여기서 N은 사용 가능한 블록의 크기 수입니다.</target>
        </trans-unit>
        <trans-unit id="bd869e893b5f7a40f0a166908e0bc628120afba1" translate="yes" xml:space="preserve">
          <source>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">구현 : 균형 이진 검색 트리가 사용됩니다. 시간 복잡도는 log N에 비례하며, 여기서 N은 사용 가능한 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="46bfb88bf9e53e73f8388ee9ed0d26c11b02304f" translate="yes" xml:space="preserve">
          <source>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</source>
          <target state="translated">구현 : 자유 목록의 첫 번째 블록을 검사하십시오. 요청을 충족하면 요청이 사용되며, 그렇지 않으면 새 이동 통신사가 작성됩니다. 구현은 일정한 시간 복잡성을 갖는다.</target>
        </trans-unit>
        <trans-unit id="c6a2194bfaf5e060ecf03c5376d35a554cce3c35" translate="yes" xml:space="preserve">
          <source>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현 : 구현시 최대 블록 검색 깊이 (각 목록에서)와 함께 분리 된 자유 목록을 사용하여 적절한 결과를 신속하게 찾습니다. 최대 블록 검색 깊이가 작 으면 (기본적으로 3)이 구현은 일정한 시간 복잡성을 갖습니다. 최대 블록 검색 깊이는 &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt; 매개 변수를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8aa4a22b5053f3e953012b88774f1658cf1eb84b" translate="yes" xml:space="preserve">
          <source>Implementing a Manager Application.</source>
          <target state="translated">관리자 응용 프로그램 구현</target>
        </trans-unit>
        <trans-unit id="d1d356a99f2a68bb32f56a5afc4fc7243ac4c122" translate="yes" xml:space="preserve">
          <source>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and table operations, is generated without any programming.</source>
          <target state="translated">MIB 구현은 지루한 작업이 될 수 있습니다. 모든 테이블과 변수가 구현되기 전에 에이전트를 테스트해야 할 수도 있습니다. 이 경우 기본 계측 기능이 유용합니다. 툴킷은 변수는 물론 테이블에 대한 기본 계측 기능을 생성 할 수 있습니다. 결과적으로 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;get-next&lt;/code&gt; 및 table 작업을 처리 할 수있는 실행중인 프로토 타입 에이전트 가 프로그래밍없이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5089bf216d6ab81557737c36828f21a117ecd8d4" translate="yes" xml:space="preserve">
          <source>Implementing support for Unicode character sets is an ongoing process. The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and specified a default encoding in binaries that all Unicode-aware modules are to handle in the future.</source>
          <target state="translated">유니 코드 문자 집합에 대한 지원을 구현하는 과정은 진행 중입니다. EEP (Erlang Enhancement Proposal) 10은 유니 코드 지원의 기본 사항을 설명하고 향후 모든 유니 코드 인식 모듈이 처리 할 바이너리로 기본 인코딩을 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="afb6d8666156732e31fdfd33a4e37fa8e0ff12b1" translate="yes" xml:space="preserve">
          <source>Implementing the MIB</source>
          <target state="translated">MIB 구현</target>
        </trans-unit>
        <trans-unit id="3598443bca8912627263e77be152abb2f8fea1d8" translate="yes" xml:space="preserve">
          <source>Implements &lt;strong&gt;call streams with promises&lt;/strong&gt;, a type of RPC that does not suspend the caller until the result is finished. Instead, a key is returned, which can be used later to collect the value. The key can be viewed as a promise to deliver the answer.</source>
          <target state="translated">결과가 끝날 때까지 호출자를 일시 중단하지 않는 RPC 유형 인 &lt;strong&gt;promise으로 호출 스트림을&lt;/strong&gt; 구현 &lt;strong&gt;합니다&lt;/strong&gt; . 대신에 키를 반환하여 나중에 값을 수집하는 데 사용할 수 있습니다. 열쇠는 답을 전하겠다는 약속으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="701e88bfb66430bf554605afebb5bc817eba6c88" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt; ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">내부 CRL (Certificate Revocation List) 캐시를 구현합니다. &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt; ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; 동작 을 구현하는 것 외에도 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5852555552878975a45593281d37fefa3026933d" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">내부 CRL (인증서 해지 목록) 캐시를 구현합니다. &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; 동작 을 구현하는 것 외에도 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29c8d309278d1184cdf0686f160a939ff31d257" translate="yes" xml:space="preserve">
          <source>Implements global (repetitive) search (flag &lt;code&gt;g&lt;/code&gt; in Perl). Each match is returned as a separate &lt;code&gt;list()&lt;/code&gt; containing the specific match and any matching subexpressions (or as specified by option &lt;code&gt;capture&lt;/code&gt;. The &lt;code&gt;Captured&lt;/code&gt; part of the return value is hence a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s when this option is specified.</source>
          <target state="translated">전역 (반복) 검색을 구현합니다 ( Perl의 플래그 &lt;code&gt;g&lt;/code&gt; ). 각 일치 항목은 특정 일치 항목과 일치하는 하위 표현식이 포함 된 별도의 &lt;code&gt;list()&lt;/code&gt; (또는 옵션 &lt;code&gt;capture&lt;/code&gt; 에 의해 지정된대로)로 리턴됩니다. 따라서 리턴 값 의 &lt;code&gt;Captured&lt;/code&gt; 부분은 이 옵션이 지정된 경우 &lt;code&gt;list()&lt;/code&gt; 의 &lt;code&gt;list()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0d6b7b06bc0717a09a0609e9b93d5b110576e74" translate="yes" xml:space="preserve">
          <source>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is included in the source code.</source>
          <target state="translated">컴파일 타임에 변환을 구현합니다. 이 함수는 헤더 파일 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 이 소스 코드에 포함되어있는 경우와 소스 코드 변환을 수행하기 위해 컴파일러에서 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6edd4a0551006932a13f07152c0a0aa13d34aeb3" translate="yes" xml:space="preserve">
          <source>Implements the transformation when the &lt;code&gt;fun2ms/1&lt;/code&gt; functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as &lt;code&gt;BoundEnvironment&lt;/code&gt;. The result is a term, normalized, that is, not in abstract format.</source>
          <target state="translated">&lt;code&gt;fun2ms/1&lt;/code&gt; 함수가 쉘에서 호출 될 때 변환을 구현합니다 . 이 경우 추상 형식은 하나의 단일 재미를위한 것입니다 (Erlang 쉘로 구문 분석 됨). 가져온 모든 변수는 &lt;code&gt;BoundEnvironment&lt;/code&gt; 로 전달 된 키-값 목록에 있어야 합니다. 결과는 정규화 된 용어, 즉 추상적 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5157539667ba028bf842cb4d314ce494573a8908" translate="yes" xml:space="preserve">
          <source>Implicitly when a specific instruction is defined. This is by far the most common way. Whenever a specific instruction is created, &lt;strong&gt;beam_makeops&lt;/strong&gt; automatically creates an internal generic instruction if it does not previously exist.</source>
          <target state="translated">특정 명령어가 정의 된 경우 암시 적으로. 이것이 가장 일반적인 방법입니다. 특정 명령어가 생성 될 때마다 &lt;strong&gt;beam_makeops&lt;/strong&gt; 는 이전에 존재하지 않는 경우 내부 일반 명령어를 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b7c113ae3f8b579e4a0169b23cb527018f3cd218" translate="yes" xml:space="preserve">
          <source>Import configuration data (similar to &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt;).</source>
          <target state="translated">구성 데이터를 가져 오십시오 ( &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="64200c8515980ead3d6f6d1c54b72c0df1647038" translate="yes" xml:space="preserve">
          <source>Imported functions. Can be called the same way as local functions, that is, without any module prefix.</source>
          <target state="translated">가져온 함수. 로컬 함수와 같은 방식으로, 즉 모듈 접두사없이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e96159a0570df1d76f4d6b6b63ad56985185ffc2" translate="yes" xml:space="preserve">
          <source>Imports coverage data from the file &lt;code&gt;ExportFile&lt;/code&gt; created with &lt;code&gt;cover:export/1,2&lt;/code&gt;. Any analysis performed after this will include the imported data.</source>
          <target state="translated">&lt;code&gt;cover:export/1,2&lt;/code&gt; 로 작성된 &lt;code&gt;ExportFile&lt;/code&gt; 파일에서 적용 범위 데이터를 가져 옵니다 . 이후에 수행 된 모든 분석에는 가져온 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6293ff4a8408c9b4904b5c4c8135a7dbb83fe606" translate="yes" xml:space="preserve">
          <source>Improper use can seriously degrade system performance.</source>
          <target state="translated">잘못 사용하면 시스템 성능이 심각하게 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68545fd32c1a3f37a53bcab05bb6a3c24b6ca95e" translate="yes" xml:space="preserve">
          <source>In .emacs, the slash character &quot;/&quot; can be used as path separator. But if you decide to use the backslash character &quot;\&quot;, please not that you must use double backslashes, since they are treated as escape characters by Emacs.</source>
          <target state="translated">.emacs에서는 슬래시 문자 &quot;/&quot;를 경로 구분 기호로 사용할 수 있습니다. 그러나 백 슬래시 문자 &quot;\&quot;를 사용하기로 결정한 경우 이중 백 슬래시는 Emacs에서 이스케이프 문자로 취급되므로 이중 백 슬래시를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0f7795a31a2f6e68385e615d1e0b39534a4a427f" translate="yes" xml:space="preserve">
          <source>In 1994 the global tagging mode &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; was introduced. By putting &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; in the module header, the ASN.1 compiler automatically adds tags when needed. The following is the same specification in &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; mode:</source>
          <target state="translated">1994 년에 글로벌 태깅 모드 인 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 가 도입되었습니다. 모듈 헤더 에 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 를 넣으면 ASN.1 컴파일러는 필요할 때 자동으로 태그를 추가합니다. 다음은 &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; 모드 에서 동일한 사양입니다 .</target>
        </trans-unit>
        <trans-unit id="b2eae1b23e89f4b197bf1ba45908178d3aa172d8" translate="yes" xml:space="preserve">
          <source>In 8-bit, non-UTF-8 mode, only the characters with code points &amp;lt; 256 are relevant.</source>
          <target state="translated">8 비트 비 UTF-8 모드에서는 코드 포인트가 &amp;lt;256 인 문자 만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb066c655ce1aa010477f09bef3fac0ead37f56" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under Cygwin/MSYS/MSYS2.</source>
          <target state="translated">에서 &lt;code&gt;$ERL_TOP&lt;/code&gt; ,라는 스크립트가 &lt;code&gt;otp_build&lt;/code&gt; . 즉, 스크립트 핸들에 대한 모든 권리 매개 변수를 제공하는 번거 로움 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 하고 또한 Cygwin에서 / MSYS / MSYS2에서 얼랑 소스와 작업에 올바른 환경 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38e9bf33d69940366928f0c1e758698b02736bd6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under WSL.</source>
          <target state="translated">에서 &lt;code&gt;$ERL_TOP&lt;/code&gt; ,라는 스크립트가 &lt;code&gt;otp_build&lt;/code&gt; . 이 스크립트는 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; 모든 올바른 매개 변수를 제공하는 번거 로움을 처리하고 WSL에서 Erlang 소스와 함께 작동하도록 올바른 환경 변수를 설정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c1e4870154b4a5f3a6bba7d020678f1436a7aad2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant; the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant; the rest are to be 0. See &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;ID&lt;/code&gt; , 18 비트 만이 중요하다; 나머지는 0이어야합니다. &lt;code&gt;Creation&lt;/code&gt; 에서는 두 비트 만 중요합니다. 나머지는 0 입니다. &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0025e78fbaf5c3757dcab01eedc653609a16493" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Mnesia&lt;/code&gt;, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property &lt;code&gt;record_name&lt;/code&gt;, the following code ensures that all records in the tables have the same name as the table:</source>
          <target state="translated">에서 &lt;code&gt;Mnesia&lt;/code&gt; 테이블의 모든 레코드는 같은 이름이 있어야합니다. 모든 레코드는 동일한 레코드 유형의 인스턴스 여야합니다. 그러나이 사용자 안내서에있는 대부분의 예에서 레코드 이름이 반드시 테이블 이름과 같을 필요는 없습니다. &lt;code&gt;record_name&lt;/code&gt; 특성없이 테이블을 작성하는 경우 다음 코드는 테이블의 모든 레코드가 테이블과 동일한 이름을 갖도록합니다.</target>
        </trans-unit>
        <trans-unit id="770b380d53bce026d82e5f70351df3a234e00dd1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Module:Name/Arity&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt;, and &lt;code&gt;Name&lt;/code&gt; are atoms and &lt;code&gt;Arity&lt;/code&gt; is an integer. Starting from Erlang/OTP R15, &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Arity&lt;/code&gt; can also be variables. A fun defined in this way refers to the function &lt;code&gt;Name&lt;/code&gt; with arity &lt;code&gt;Arity&lt;/code&gt; in the &lt;strong&gt;latest&lt;/strong&gt; version of module &lt;code&gt;Module&lt;/code&gt;. A fun defined in this way is not dependent on the code for the module in which it is defined.</source>
          <target state="translated">에서 &lt;code&gt;Module:Name/Arity&lt;/code&gt; , &lt;code&gt;Module&lt;/code&gt; , 그리고 &lt;code&gt;Name&lt;/code&gt; 원자와 &lt;code&gt;Arity&lt;/code&gt; 정수입니다. Erlang / OTP R15부터 &lt;code&gt;Module&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Arity&lt;/code&gt; 도 변수가 될 수 있습니다. 이런 방식으로 정의 된 재미 는 &lt;strong&gt;최신&lt;/strong&gt; 버전의 모듈 &lt;code&gt;Module&lt;/code&gt; 에서 arity &lt;code&gt;Arity&lt;/code&gt; 를 가진 &lt;code&gt;Name&lt;/code&gt; 함수를 말합니다 . 이러한 방식으로 정의 된 재미는 그것이 정의 된 모듈의 코드에 의존하지 않습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5df66c12eaa68ca0a48283d550d16d991720df0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Name/Arity&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; is an atom and &lt;code&gt;Arity&lt;/code&gt; is an integer. &lt;code&gt;Name/Arity&lt;/code&gt; must specify an existing local function. The expression is syntactic sugar for:</source>
          <target state="translated">에서 &lt;code&gt;Name/Arity&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; 원자이며, &lt;code&gt;Arity&lt;/code&gt; 정수입니다. &lt;code&gt;Name/Arity&lt;/code&gt; 은 기존 로컬 기능을 지정해야합니다. 이 표현은 다음에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="943fe69f8dfd82f02ed43163f6738a7b0394f445" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;OTP Configuration Parameters&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a472768ac00c2b862480bf36de83581f96978047" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Type_List&lt;/code&gt; the &quot;path&quot; from the top type to each undecoded subcomponents is described. The top type of the path is an atom, the name of it. The action on each component/type that follows is described by one of &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;Type_List&lt;/code&gt; 각 디코드되지 않은 부성분 상부 형에서 &quot;경로&quot;를 설명한다. 경로의 최상위 유형은 원자 이름입니다. 다음에 나오는 각 구성 요소 / 유형에 대한 조치는 &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt; 중 하나로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="893648209f7036a7f9ac95fdc3c4a7d64bef1838" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;allocate_heap&lt;/code&gt;, the last operand is the number of live registers. It will only be used if there is not enough heap space and a garbage collection must be performed.</source>
          <target state="translated">에서 &lt;code&gt;allocate_heap&lt;/code&gt; , 마지막 피연산자는 라이브 레지스터의 수입니다. 힙 공간이 충분하지 않고 가비지 콜렉션을 수행해야하는 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c54988a1f913bda4c57ecea3e6f820b07cee1aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;attr&lt;/code&gt; the attributes of the object are stored as the logical &lt;strong&gt;OR&lt;/strong&gt; of its type (one of &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_BIN&lt;/code&gt;, and &lt;code&gt;EI_STR&lt;/code&gt;), whether it is marked for deletion (&lt;code&gt;EI_DELET&lt;/code&gt;), and whether it has been modified since the last backup to &lt;code&gt;Mnesia&lt;/code&gt; (&lt;code&gt;EI_DIRTY&lt;/code&gt;).</source>
          <target state="translated">에서는 &lt;code&gt;attr&lt;/code&gt; 객체의 속성 논리적으로 저장된다 &lt;strong&gt;OR&lt;/strong&gt; 의 타입 (하나의 &lt;code&gt;EI_INT&lt;/code&gt; , &lt;code&gt;EI_FLT&lt;/code&gt; , &lt;code&gt;EI_BIN&lt;/code&gt; 및 &lt;code&gt;EI_STR&lt;/code&gt; 가 삭제 (표시되어 있는지 여부) &lt;code&gt;EI_DELET&lt;/code&gt; ), 그리고 마지막 백업 이후 수정되었는지 &lt;code&gt;Mnesia&lt;/code&gt; ( &lt;code&gt;EI_DIRTY&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9643419e6aee2e17ffb863a8ef01b8323b347a6e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions are given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">위의 &lt;code&gt;ch1.erl&lt;/code&gt; 및 &lt;code&gt;ch2.erl&lt;/code&gt; 에서 &lt;code&gt;channels/0&lt;/code&gt; , &lt;code&gt;alloc/1&lt;/code&gt; 및 &lt;code&gt;free/2&lt;/code&gt; 의 구현은 예제와 관련이 없으므로 의도적으로 생략되었습니다. 완성도를 높이기 위해 이러한 기능을 작성하는 방법은 다음과 같습니다. 이것은 단지 예일 뿐이며 현실적인 구현은 할당 할 채널 부족과 같은 상황을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="27aabe06bd512676435ef4845535c23e8c05bacb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions is given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">위의 &lt;code&gt;ch1.erl&lt;/code&gt; 및 &lt;code&gt;ch2.erl&lt;/code&gt; 에서 &lt;code&gt;channels/0&lt;/code&gt; , &lt;code&gt;alloc/1&lt;/code&gt; 및 &lt;code&gt;free/2&lt;/code&gt; 의 구현은 예제와 관련이 없기 때문에 의도적으로 생략되었습니다. 완전성을 위해 이러한 함수를 작성하는 한 가지 방법이 아래에 나와 있습니다. 이것은 예일 뿐이며, 현실적인 구현은 할당 할 채널 부족과 같은 상황을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ab0d5c626ce8dc42f39e1abeabf7105631919c54" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, parameter &lt;code&gt;s&lt;/code&gt; is to point to a dynamically (malloc) allocated string of &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a &lt;code&gt;NULL&lt;/code&gt; pointer. The string can be reallocated (and &lt;code&gt;*s&lt;/code&gt; can be updated) by this function if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The string returned is &lt;code&gt;NULL&lt;/code&gt;-terminated.</source>
          <target state="translated">에서 &lt;code&gt;ei_s_print_term()&lt;/code&gt; , 매개 변수 &lt;code&gt;s&lt;/code&gt; 동적으로 (의 malloc)의 할당 된 문자열에 점입니다 &lt;code&gt;BUFSIZ&lt;/code&gt; 가 바이트 또는 &lt;code&gt;NULL&lt;/code&gt; 의 포인터. 결과가 &lt;code&gt;BUFSIZ&lt;/code&gt; 문자 보다 많은 경우이 함수로 문자열을 재 할당 할 수 있으며 &lt;code&gt;*s&lt;/code&gt; 를 업데이트 할 수 있습니다 . 리턴 된 문자열은 &lt;code&gt;NULL&lt;/code&gt; 로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0a141cc5ac15d20e41285b60b7e1dbadddb212ee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;file_logger&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;file_logger&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7fbf17e1fc5bc4462fd00e9068033e131292be59" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;gen_statem&lt;/code&gt; we define a &lt;strong&gt;state change&lt;/strong&gt; as a &lt;strong&gt;state transition&lt;/strong&gt; in which the new state &lt;code&gt;S'&lt;/code&gt; is different from the current state &lt;code&gt;S&lt;/code&gt;, where &quot;different&quot; means Erlang's strict inequality: &lt;code&gt;=/=&lt;/code&gt; also known as &quot;does not match&quot;. &lt;code&gt;gen_statem&lt;/code&gt; does more things during &lt;strong&gt;state changes&lt;/strong&gt; than during other &lt;strong&gt;state transitions&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 에서는 새로운 상태 &lt;code&gt;S'&lt;/code&gt; 가 현재 상태 &lt;code&gt;S&lt;/code&gt; 와 다른 &lt;strong&gt;상태 전환&lt;/strong&gt; 으로 &lt;strong&gt;상태 변경&lt;/strong&gt; 을 정의합니다 . 여기서 &quot;다름&quot;은 Erlang의 엄격한 불평등을 의미합니다. &lt;code&gt;=/=&lt;/code&gt; &quot;일치하지 않음&quot;이라고도합니다. &lt;code&gt;gen_statem&lt;/code&gt; 은 다른 &lt;strong&gt;상태 전환&lt;/strong&gt; 보다 &lt;strong&gt;상태 변경&lt;/strong&gt; 중에 더 많은 작업을 수행 합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5dd48fe409f725dfa23be2b6d97df3560da702c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;is_eq_exact&lt;/code&gt;, the failure address (the first operand) will only be used if the two register operands are not equal.</source>
          <target state="translated">에서는 &lt;code&gt;is_eq_exact&lt;/code&gt; 개의 레지스터 피연산자가 동일하지 않을 경우, 고장 어드레스 (제 피연산자)에만 사용한다.</target>
        </trans-unit>
        <trans-unit id="c6953b7249dfd9871d1537ea03ef11de631fd526" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, filenames are bytewise encoded. This allows for list representation of all filenames in the system. However, a a file named &quot;&amp;Ouml;stersund.txt&quot;, appears in &lt;code&gt;file:list_dir/1&lt;/code&gt; either as &quot;&amp;Ouml;stersund.txt&quot; (if the filename was encoded in bytewise ISO Latin-1 by the program creating the file) or more probably as &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt;, which is a list containing UTF-8 bytes (not what you want). If you use Unicode filename translation on such a system, non-UTF-8 filenames are ignored by functions like &lt;code&gt;file:list_dir/1&lt;/code&gt;. They can be retrieved with function &lt;code&gt;file:list_dir_all/1&lt;/code&gt;, but wrongly encoded filenames appear as &quot;raw filenames&quot;.</source>
          <target state="translated">에서는 &lt;code&gt;latin1&lt;/code&gt; 모드 파일명은 바이트 단위로 인코딩된다. 이를 통해 시스템의 모든 파일 이름을 목록으로 표시 할 수 있습니다. 그러나 &quot;&amp;Ouml;stersund.txt&quot;라는 파일은 &lt;code&gt;file:list_dir/1&lt;/code&gt; 에 &quot;&amp;Ouml;stersund.txt&quot;(파일을 만드는 프로그램에 의해 파일 이름이 바이트 단위 ISO Latin-1로 인코딩 된 경우) 또는 &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt; -UTF-8 바이트를 포함하는 목록입니다 (원하는 것은 아님). 이러한 시스템에서 유니 코드 파일 이름 변환을 사용하는 경우 UTF-8이 아닌 파일 이름은 &lt;code&gt;file:list_dir/1&lt;/code&gt; 과 같은 함수에서 무시됩니다 . 함수 &lt;code&gt;file:list_dir_all/1&lt;/code&gt; 로 검색 할 수 있지만 잘못 인코딩 된 파일 이름은 &quot;원시 파일 이름&quot;으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="116bd7f6b497e889e6e51bc1f52782d94cab61ab" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, the Erlang VM does not change the encoding of filenames. In &lt;code&gt;utf8&lt;/code&gt; mode, filenames can contain Unicode characters greater than 255 and the VM converts filenames back and forth to the native filename encoding (usually UTF-8, but UTF-16 on Windows).</source>
          <target state="translated">에서 &lt;code&gt;latin1&lt;/code&gt; 모드에서 얼랑 VM은 파일 이름의 인코딩을 변경하지 않습니다. 에서 &lt;code&gt;utf8&lt;/code&gt; 모드, 파일 이름은 앞뒤로 기본 파일 이름 인코딩 (Windows에서 일반적으로 UTF-8,하지만 UTF-16) 255보다 큰 유니 코드 문자와 VM의 변환 파일 이름을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efaf4d06886c110e8f2a1c0d7f556c6c220cdc32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;list_max/2&lt;/code&gt;, you walk down the list and use &lt;code&gt;Head&lt;/code&gt; instead of &lt;code&gt;Result_so_far&lt;/code&gt; when &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;when&lt;/code&gt; is a special word used before the -&amp;gt; in the function to say that you only use this part of the function if the test that follows is true. A test of this type is called &lt;strong&gt;guard&lt;/strong&gt;. If the guard is false (that is, the guard fails), the next part of the function is tried. In this case, if &lt;code&gt;Head&lt;/code&gt; is not greater than &lt;code&gt;Result_so_far&lt;/code&gt;, then it must be smaller or equal to it. This means that a guard on the next part of the function is not needed.</source>
          <target state="translated">에서 &lt;code&gt;list_max/2&lt;/code&gt; , 당신은 목록을 아래로 걸어 사용하는 &lt;code&gt;Head&lt;/code&gt; 대신 &lt;code&gt;Result_so_far&lt;/code&gt; &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt; . &lt;code&gt;when&lt;/code&gt; 는 함수에서-&amp;gt; 앞에 사용되는 특수 단어로, 다음 테스트가 참인 경우 함수의이 부분 만 사용한다고 말합니다. 이 유형의 테스트를 &lt;strong&gt;guard&lt;/strong&gt; 라고 합니다. 가드가 거짓 인 경우 (즉, 가드가 실패하면) 함수의 다음 부분이 시도됩니다. 이 경우 &lt;code&gt;Head&lt;/code&gt; 가 &lt;code&gt;Result_so_far&lt;/code&gt; 보다 크지 않으면 더 작거나 같아야합니다. 이것은 기능의 다음 부분에 가드가 필요하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5487ffcf59e4dcb4dda76a98d92b6b90dc718bb3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;macros.tab&lt;/code&gt;, there is a definition of &lt;code&gt;GC_REGEXP&lt;/code&gt;. It will be described in &lt;code&gt;&lt;a href=&quot;#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition&quot;&gt;a later section&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;macros.tab&lt;/code&gt; 에는 GC_REGEXP 의 정의가 &lt;code&gt;GC_REGEXP&lt;/code&gt; . 이에 대해서는 &lt;code&gt;&lt;a href=&quot;#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition&quot;&gt;a later section&lt;/a&gt;&lt;/code&gt; 에서 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="02cb096eaff82424f4a89dbad61cc6a39bc0e575" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sort&lt;/code&gt; the fun is used:</source>
          <target state="translated">에서 &lt;code&gt;sort&lt;/code&gt; 재미가 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="12c27e7f6632f170be6359162707f4b8a39d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;terminal_logger&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;terminal_logger&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bbd6fe570f64e2ea4d9df82e02a34c966281d919" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;unicode&lt;/code&gt; mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &amp;gt; 127) are treated as literals.</source>
          <target state="translated">에서 &lt;code&gt;unicode&lt;/code&gt; 모드 만 ASCII 숫자와 문자는 백 슬래시 후 특별한 의미를 가지고있다. 다른 모든 문자 (특히 코드 포인트가 127보다 큰 문자)는 리터럴로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3192c3cf3b67f79505ca334fb569ea62ed1d48cb" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and check the authenticity the &lt;code&gt;PlainText&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) using the &lt;code&gt;CipherTag&lt;/code&gt;. May return &lt;code&gt;error&lt;/code&gt; if the decryption or validation fail's</source>
          <target state="translated">AEAD (관련 데이터로 인증 된 암호화) 모드에서 &lt;code&gt;Type&lt;/code&gt; 블록 암호 에 따라 &lt;code&gt;CipherText&lt;/code&gt; 를 해독하고 CipherTag 를 사용 하여 &lt;code&gt;PlainText&lt;/code&gt; 및 &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data)의 &lt;code&gt;CipherTag&lt;/code&gt; . 암호 해독 또는 유효성 검사에 실패하면 &lt;code&gt;error&lt;/code&gt; 반환 할 수 있음</target>
        </trans-unit>
        <trans-unit id="11cacd0985503ba6b7aa7e02c729d4cf5d9ec8c0" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and calculate &lt;code&gt;CipherTag&lt;/code&gt; that also authenticates the &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data).</source>
          <target state="translated">AEAD (관련 데이터를 사용한 인증 된 암호화) 모드에서 &lt;code&gt;Type&lt;/code&gt; 블록 암호 에 따라 &lt;code&gt;PlainText&lt;/code&gt; 를 암호화하고 &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) 도 인증하는 &lt;code&gt;CipherTag&lt;/code&gt; 를 계산 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c038f0a7011f32aa3c2253ea59f81adb573ae04f" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is also possible to have components that are themselves structured types. For example, it is possible to have the following:</source>
          <target state="translated">ASN.1에서는 자체 구조화 된 유형의 구성 요소를 가질 수도 있습니다. 예를 들어, 다음을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd6892220150bfbf692aea6c817cdbc6b525af4" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is possible to have:</source>
          <target state="translated">ASN.1에서는 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ac981922e3d2be3099b7dd819f976f8cd431aa5c" translate="yes" xml:space="preserve">
          <source>In ASN.1, &lt;code&gt;BIT STRING&lt;/code&gt; definitions can look as follows:</source>
          <target state="translated">ASN.1에서 &lt;code&gt;BIT STRING&lt;/code&gt; 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4c809e7fa181f22943bb3998e2675cc28fadeb7" translate="yes" xml:space="preserve">
          <source>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</source>
          <target state="translated">Megaco / H.248 사양 (RFC 3525)의 부록 A에는 대표적인 통화 흐름을 나타내는 약 30 개의 메시지가 있습니다. 또한 버전 1, 버전 2 및 버전 3 메시지가 추가되었습니다. 이 메시지를 측정의 기초로 사용했습니다. 우리의 수치는 미디어 게이트웨이와 컨트롤러간에 서로 다른 종류의 메시지가 얼마나 자주 전송되는지에 대해서는 가중치를 두지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a6d6cb54546267c7ab63766eec09cee649711a31" translate="yes" xml:space="preserve">
          <source>In Erlang code it can look as follows:</source>
          <target state="translated">Erlang 코드에서는 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba42f54367f97fea68495b7cac79db5d13869f6" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt; erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt; erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">Erlang에서 BIF &lt;code&gt; erlang:term_to_binary/1,2&lt;/code&gt; 는 용어를 외부 형식으로 변환하는 데 사용됩니다. 이진 데이터 인코딩을 용어로 변환하기 위해 BIF &lt;code&gt; erlang:binary_to_term/1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e5807093e6d87fdc7a49890d975be36f4a0da6c" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">Erlang에서 BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; 는 용어를 외부 형식으로 변환하는 데 사용됩니다. 이진 데이터 인코딩을 용어로 변환하기 위해 BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cfeed77756208eb4d9dfb0d9a3e58ff900cc5da1" translate="yes" xml:space="preserve">
          <source>In Erlang the following can apply:</source>
          <target state="translated">Erlang에서는 다음이 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55425998bade0d03c70bf896550329d58b5b495b" translate="yes" xml:space="preserve">
          <source>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</source>
          <target state="translated">Erlang에서 Bin은 바이너리를 구성하고 바이너리 패턴을 일치시키는 데 사용됩니다. Bin은 다음 구문으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="27260c403bb29fda2001d4a6be0835230872a64b" translate="yes" xml:space="preserve">
          <source>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is, code point by code point, a subrange of the Unicode character set.</source>
          <target state="translated">Erlang에서 문자열은 정수 목록입니다. 문자열은 Erlang / OTP R13이 ISO Latin-1 (ISO 8859-1) 문자 세트로 인코딩되도록 정의 될 때까지, 즉 코드 포인트 별, 유니 코드 문자 세트의 하위 범위입니다.</target>
        </trans-unit>
        <trans-unit id="000d471cb67467678d1ade49d91a91cbdff773ac" translate="yes" xml:space="preserve">
          <source>In Erlang, the &lt;code&gt;SET&lt;/code&gt; type is used exactly as &lt;code&gt;SEQUENCE&lt;/code&gt;. Notice that if BER or DER encoding rules are used, decoding a &lt;code&gt;SET&lt;/code&gt; is slower than decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; because the components must be sorted.</source>
          <target state="translated">Erlang에서 &lt;code&gt;SET&lt;/code&gt; 유형은 &lt;code&gt;SEQUENCE&lt;/code&gt; 로 정확하게 사용됩니다 . BER 또는 DER 인코딩 규칙을 사용 하는 경우 구성 요소를 정렬해야하므로 &lt;code&gt;SET&lt;/code&gt; 디코딩은 &lt;code&gt;SEQUENCE&lt;/code&gt; 디코딩보다 속도가 느립니다 .</target>
        </trans-unit>
        <trans-unit id="111866cd1ba49a2b43af4850505bc155722873f8" translate="yes" xml:space="preserve">
          <source>In Erlang, the full UTF-16 range is supported when applicable, like in the &lt;code&gt;unicode&lt;/code&gt; module and in the bit syntax.</source>
          <target state="translated">Erlang에서는 &lt;code&gt;unicode&lt;/code&gt; 모듈 및 비트 구문과 같이 적용 가능한 경우 전체 UTF-16 범위가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a7efb592ded3e962f361d6c4ea93e492befd66f" translate="yes" xml:space="preserve">
          <source>In Erlang, there is no interface to retrieve a mark with &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt;, so only the secondary purpose is relevant to the Erlang programmer.</source>
          <target state="translated">Erlang에는 &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; 으로 마크를 검색하기위한 인터페이스가 없으므로 2 차 목적 만 Erlang 프로그래머와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c60f9a05486134b501e5953f76c349e506d6f0f" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched to UTF-8.</source>
          <target state="translated">Erlang / OTP 17.0에서 Erlang 소스 파일의 인코딩 기본값이 UTF-8로 전환되었습니다.</target>
        </trans-unit>
        <trans-unit id="6916e39092e66107b55f61baa3016b3f04cf8426" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module names, application names, and node names are still restricted to the ISO Latin-1 range.</source>
          <target state="translated">Erlang / OTP 20.0에서 원자와 함수는 유니 코드 문자를 포함 할 수 있습니다. 모듈 이름, 응용 프로그램 이름 및 노드 이름은 여전히 ​​ISO Latin-1 범위로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="198d0d1078d6039827840866a4f6899fdbe8d43c" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 21.0, a new API for logging was added. The old &lt;code&gt;error_logger&lt;/code&gt; module can still be used by legacy code, but log events are redirected to the new Logger API. New code should use the Logger API directly.</source>
          <target state="translated">Erlang / OTP 21.0에는 로깅을위한 새로운 API가 추가되었습니다. 기존 &lt;code&gt;error_logger&lt;/code&gt; 모듈은 여전히 ​​레거시 코드에서 사용할 수 있지만 로그 이벤트는 새로운 Logger API로 리디렉션됩니다. 새 코드는 로거 API를 직접 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0d8b8d2cdbb6065786dcebb0086f01cf068b155" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R16B the syntax of Erlang tokens was extended to handle Unicode. The support was limited to string literals and comments. More about the usage of Unicode in Erlang source files can be found in &lt;code&gt;STDLIB's User's Guide&lt;/code&gt;.</source>
          <target state="translated">Erlang / OTP R16B에서 Erlang 토큰의 구문은 유니 코드를 처리하도록 확장되었습니다. 지원은 문자열 리터럴 및 주석으로 제한되었습니다. Erlang 소스 파일에서의 유니 코드 사용법에 대한 자세한 내용은 &lt;code&gt;STDLIB's User's Guide&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24ca06e1e4890e17adbf7557eee37d1f56256f49" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_Interface application (3.2.1 in the recent example).</source>
          <target state="translated">Erlang / OTP R5B 및 이후 버전의 OTP에서 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;lib&lt;/code&gt; 디렉토리는 &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; 아래에 있습니다 . 여기서 &lt;code&gt;OTPROOT&lt;/code&gt; 는 OTP 설치의 루트 디렉토리입니다 ( 최근 예에서는 &lt;code&gt;/usr/local/otp&lt;/code&gt; ). &lt;code&gt;VSN&lt;/code&gt; 은 Erl_Interface 애플리케이션의 버전입니다 (최근 예에서는 3.2.1).</target>
        </trans-unit>
        <trans-unit id="36bdb9cf8a7d0b24c3ea497881807594aa4ad9c3" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_interface application (3.2.1 in the recent example).</source>
          <target state="translated">Erlang / OTP R5B 및 이후 버전의 OTP에서 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;lib&lt;/code&gt; 디렉토리는 &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; 아래에 있습니다 . 여기서 &lt;code&gt;OTPROOT&lt;/code&gt; 는 OTP 설치의 루트 디렉토리입니다 ( 최근 예의 경우 &lt;code&gt;/usr/local/otp&lt;/code&gt; ). &lt;code&gt;VSN&lt;/code&gt; 은 Erl_interface 애플리케이션의 버전입니다 (최근 예에서는 3.2.1).</target>
        </trans-unit>
        <trans-unit id="e2c46173457c64237f426cb5d2c876573b902705" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R6B, a library similar to Erl_Interface for Java was added called &lt;strong&gt;jinterface&lt;/strong&gt;. It provides a tool for Java programs to communicate with Erlang nodes.</source>
          <target state="translated">얼랑 / OTP R6B에서, Java 용 Erl_Interface에 도서관 유사한라고 하였다 &lt;strong&gt;jinterface을&lt;/strong&gt; . Java 프로그램이 Erlang 노드와 통신 할 수있는 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1be37b0c5d13632dad76da8a59a995e7c35b67e8" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP SSH</source>
          <target state="translated">Erlang / OTP SSH에서</target>
        </trans-unit>
        <trans-unit id="f9e5f8580820830244cd23f79a16074f3a89cc2a" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules &lt;code&gt;gen_tcp&lt;/code&gt; and &lt;code&gt;gen_udp&lt;/code&gt; in Kernel. Both are easy to use and do not require detailed knowledge about the socket concept.</source>
          <target state="translated">Erlang / OTP에서 TCP / IP 및 UDP 소켓에 대한 액세스 는 커널의 &lt;code&gt;gen_tcp&lt;/code&gt; 및 &lt;code&gt;gen_udp&lt;/code&gt; 모듈에 의해 제공됩니다 . 둘 다 사용하기 쉽고 소켓 개념에 대한 자세한 지식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d098b9b5017423de630d21112a6b6fdc9450e7b2" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception &lt;code&gt;error:notsup&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">FIPS 모드에서는 모든 비 FIPS 호환 알고리즘이 비활성화되고 예외 &lt;code&gt;error:notsup&lt;/code&gt; 합니다. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; FIPS 모드에서 사용 가능한 알고리즘의 제한된 목록을 반환하도록 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="a321356801dc3e599cf50b6af4d5dd7265663386" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and throw exception &lt;code&gt;not_supported&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">FIPS 모드에서는 모든 비 FIPS 호환 알고리즘이 비활성화되고 예외 &lt;code&gt;not_supported&lt;/code&gt; 가 발생 합니다 . Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; FIPS 모드에서 사용 가능한 제한된 알고리즘 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9654a53fa988a8beebddaefffba6dff20182607b" translate="yes" xml:space="preserve">
          <source>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</source>
          <target state="translated">FIPS 모드에서는 유효성이 검증되지 않은 알고리즘이 비활성화됩니다. 이로 인해 암호화에 의존하는 응용 프로그램에서 예기치 않은 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd282a1087eca416799317762a7b472853e3b7b" translate="yes" xml:space="preserve">
          <source>In German, the letter &quot;&amp;szlig;&quot; (sharp s) is in lower case, but the uppercase equivalent is &quot;SS&quot;.</source>
          <target state="translated">독일어에서 문자 &quot;&amp;szlig;&quot;(sharp s)는 소문자이지만 대문자는 &quot;SS&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b43a09972d3f89ca539f6f835ed50cfae17cb115" translate="yes" xml:space="preserve">
          <source>In Greek, the letter &quot;&amp;Sigma;&quot; has two different lowercase forms, &quot;&amp;sigmaf;&quot; in word-final position and &quot;&amp;sigma;&quot; elsewhere.</source>
          <target state="translated">그리스어에서 문자 &quot;&amp;Sigma;&quot;는 단어 최종 위치에 &quot;&amp;sigmaf;&quot;와 다른 곳에 &quot;&amp;sigma;&quot;의 두 가지 소문자 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc72349c6922ca4db9e6cdf6ae70618450c536a" translate="yes" xml:space="preserve">
          <source>In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; Module:callback_mode/0 &lt;/a&gt;&lt;/code&gt; was introduced.</source>
          <target state="translated">OTP 19.1에서는 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 에서 반환 튜플의 하위 호환되지 않는 변경 이 이루어졌으며 필수 콜백 함수 &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; Module:callback_mode/0 &lt;/a&gt;&lt;/code&gt; 이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e33a7d9a961a4a7fa95fde9918750cd7d701cd7" translate="yes" xml:space="preserve">
          <source>In OTP 20 it is desirable to remove all cipher suites that uses rsa kexchange (removed from default in 21)</source>
          <target state="translated">OTP 20에서는 rsa kexchange를 사용하는 모든 암호 제품군을 제거하는 것이 바람직합니다 (21에서 기본값에서 제거됨).</target>
        </trans-unit>
        <trans-unit id="7d0e8cf6bf94176944af04a938b90942b47513e4" translate="yes" xml:space="preserve">
          <source>In OTP 20.0 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt; generic time-outs &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="translated">OTP 20.0에서 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt; generic time-outs &lt;/a&gt;&lt;/code&gt; 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="10e2f6c474b1b1d220a10a173940715aea514162" translate="yes" xml:space="preserve">
          <source>In OTP 22.1 time-out content &lt;code&gt;&lt;a href=&quot;#type-timeout_update_action&quot;&gt; update &lt;/a&gt;&lt;/code&gt; and explicit time-out &lt;code&gt;&lt;a href=&quot;#type-timeout_cancel_action&quot;&gt; cancel &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="translated">OTP 22.1에서 시간 초과 콘텐츠 &lt;code&gt;&lt;a href=&quot;#type-timeout_update_action&quot;&gt; update &lt;/a&gt;&lt;/code&gt; 및 명시 적 시간 초과 &lt;code&gt;&lt;a href=&quot;#type-timeout_cancel_action&quot;&gt; cancel &lt;/a&gt;&lt;/code&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="622615c8bd1e5f7d554b06396b647aa8c7919009" translate="yes" xml:space="preserve">
          <source>In OTP 22.3 the possibility to change the callback module with actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, was added.</source>
          <target state="translated">OTP 22.3에서는 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt; 작업으로 콜백 모듈을 변경할 수있는 가능성 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="94dd0ef79035e7eb69969f59887721bb5f12a900" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All pids are now encoded using &lt;code&gt;NEW_PID_EXT&lt;/code&gt;, even external pids received as &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="translated">OTP 23 배포 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; 에서 필수가되었습니다. 모든 pid는 이제 &lt;code&gt;NEW_PID_EXT&lt;/code&gt; 를 사용하여 인코딩 되며 , 이전 노드에서 &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; 로 수신 된 외부 pid도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="86d163fad14d17015b8103733844b0e3f38ec8db" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All ports are now encoded using &lt;code&gt;NEW_PORT_EXT&lt;/code&gt;, even external ports received as &lt;code&gt;&lt;a href=&quot;#PORT_EXT&quot;&gt;PORT_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="translated">OTP 23 배포 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; 에서 필수가되었습니다. 이제 모든 포트는 &lt;code&gt;NEW_PORT_EXT&lt;/code&gt; 를 사용하여 인코딩 되며 이전 노드에서 &lt;code&gt;&lt;a href=&quot;#PORT_EXT&quot;&gt;PORT_EXT&lt;/a&gt;&lt;/code&gt; 로 수신 된 외부 포트도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a5fb5345ccfcb78e9b4e7ee07de85592dd8a9f4" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All references are now encoded using &lt;code&gt;NEWER_REFERENCE_EXT&lt;/code&gt;, even external references received as &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="translated">OTP 23 배포 플래그 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; 에서 필수가되었습니다. 모든 참조는 이제 &lt;code&gt;NEWER_REFERENCE_EXT&lt;/code&gt; 를 사용하여 인코딩 되며 이전 노드에서 &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 로 수신 된 외부 참조도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="3265c64793aa53ad0a1577895b26f55843cba1fb" translate="yes" xml:space="preserve">
          <source>In OTP R16, modules are loaded without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire load operation. The code loading is carried out by a normal Erlang process that is scheduled like all the others. The load operation is completed by making the loaded code visible to all processes in a consistent way with one single atomic instruction. Non-blocking code loading will improve real-time characteristics when modules are loaded/upgraded on a running SMP system.</source>
          <target state="translated">OTP R16에서 모듈은 VM을 차단하지 않고로드됩니다. Erlang 프로세스는 전체로드 작업 중에 방해없이 병렬로 계속 실행될 수 있습니다. 코드 로딩은 다른 모든 것과 마찬가지로 예약 된 정상적인 Erlang 프로세스에 의해 수행됩니다. 로드 작업은로드 된 코드가 하나의 단일 원자 명령으로 모든 프로세스에 일관된 방식으로 표시되도록함으로써 완료됩니다. 비 차단 코드 로딩은 실행중인 SMP 시스템에서 모듈이로드 / 업그레이드 될 때 실시간 특성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="12e0125ea56af5dfd2fd2fd039ae24bfa32ef473" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, &lt;code&gt;uper&lt;/code&gt; or &lt;code&gt;jer&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">OTP R16에서는 옵션이 단순화되었습니다. 백엔드는 &lt;code&gt;ber&lt;/code&gt; , &lt;code&gt;per&lt;/code&gt; , &lt;code&gt;uper&lt;/code&gt; 또는 &lt;code&gt;jer&lt;/code&gt; 옵션 중 하나를 사용하여 선택됩니다 . 옵션 &lt;code&gt;optimize&lt;/code&gt; , &lt;code&gt;nif&lt;/code&gt; 및 &lt;code&gt;driver&lt;/code&gt; 옵션은 더 이상 필요하지 않습니다 (사용되는 경우 ASN.1 컴파일러가 경고를 생성 함). 옵션 &lt;code&gt;ber_bin&lt;/code&gt; , &lt;code&gt;per_bin&lt;/code&gt; 및 &lt;code&gt;uper_bin&lt;/code&gt; 옵션은 계속 작동하지만 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6c8d7cdc42675f7eb3ae5329539c1c0357e28904" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, or &lt;code&gt;uper&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">OTP R16에서는 옵션이 단순화되었습니다. 백엔드는 &lt;code&gt;ber&lt;/code&gt; , &lt;code&gt;per&lt;/code&gt; 또는 &lt;code&gt;uper&lt;/code&gt; 옵션 중 하나를 사용하여 선택됩니다 . 옵션 &lt;code&gt;optimize&lt;/code&gt; , &lt;code&gt;nif&lt;/code&gt; 및 &lt;code&gt;driver&lt;/code&gt; 옵션은 더 이상 필요하지 않습니다 (그리고 ASN.1 컴파일러는 사용되는 경우 경고를 생성 함). 옵션 &lt;code&gt;ber_bin&lt;/code&gt; , &lt;code&gt;per_bin&lt;/code&gt; 및 &lt;code&gt;uper_bin&lt;/code&gt; 옵션 여전히 작동하지만 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7beb2f37419ff75d8af6c1507fb66b318ae63c2b" translate="yes" xml:space="preserve">
          <source>In OTP R16, trace breakpoints are set in the code without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire operation. The same base technique is used as for code loading. A staging area of breakpoints is prepared and then made active with a single atomic operation.</source>
          <target state="translated">OTP R16에서 추적 중단 점은 VM을 차단하지 않고 코드에 설정됩니다. Erlang 프로세스는 전체 작업 중에 방해없이 병렬로 계속 실행될 수 있습니다. 코드 로딩과 동일한 기본 기술이 사용됩니다. 중단 점의 스테이징 영역이 준비된 다음 단일 원자 작업으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d070e27ec63b672cbbc0cd22453c8a0bbd814f44" translate="yes" xml:space="preserve">
          <source>In OTP releases before R9C, the abstract code after some more processing was stored in the Beam file. The first element of the tuple would be either &lt;code&gt;abstract_v1&lt;/code&gt; (in OTP R7B) or &lt;code&gt;abstract_v2&lt;/code&gt; (in OTP R8B).</source>
          <target state="translated">R9C 이전의 OTP 릴리스에서 일부 추가 처리 후 추상 코드가 Beam 파일에 저장되었습니다. 튜플의 첫 번째 요소는 &lt;code&gt;abstract_v1&lt;/code&gt; (OTP R7B) 또는 &lt;code&gt;abstract_v2&lt;/code&gt; (OTP R8B)입니다.</target>
        </trans-unit>
        <trans-unit id="921af396e8f5461445f280e270dd2b5414708d3b" translate="yes" xml:space="preserve">
          <source>In OTP, &lt;strong&gt;application&lt;/strong&gt; denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with &lt;strong&gt;application controller&lt;/strong&gt;, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</source>
          <target state="translated">OTP에서 &lt;strong&gt;응용 프로그램&lt;/strong&gt; 은 특정 기능을 구현하는 구성 요소로, 장치로 시작 및 중지 할 수 있으며 다른 시스템에서 재사용 할 수 있습니다. 이 모듈 은 모든 Erlang 런타임 시스템에서 시작된 프로세스 인 &lt;strong&gt;application controller&lt;/strong&gt; 와 상호 작용 합니다. 이 모듈에는 응용 프로그램 제어 (예 : 응용 프로그램 시작 및 중지) 기능과 응용 프로그램에 대한 정보 (예 : 구성 매개 변수)에 액세스하는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eca3632f8a0f156b49e9fa89891e0ee96a189926" translate="yes" xml:space="preserve">
          <source>In OTP, an &lt;strong&gt;event manager&lt;/strong&gt; is a named object to which events can be sent. An &lt;strong&gt;event&lt;/strong&gt; can be, for example, an error, an alarm, or some information that is to be logged.</source>
          <target state="translated">OTP에서 &lt;strong&gt;이벤트 관리자&lt;/strong&gt; 는 이벤트를 전송할 수있는 명명 된 오브젝트입니다. &lt;strong&gt;이벤트는&lt;/strong&gt; , 예를 들어, 오류, 알람, 또는 기록 될 것입니다 몇 가지 정보가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="457a0e3d6ddd599be8d5102b7c849920a5dc095d" translate="yes" xml:space="preserve">
          <source>In OTP-21 the default primary log level is &lt;code&gt;notice&lt;/code&gt;. The means that many log messages are by default not printed. This includes the progress reports of supervisors. In order to get progress reports you need to raise the primary log level to &lt;code&gt;info&lt;/code&gt;</source>
          <target state="translated">OTP-21에서 기본 기본 로그 수준은 &lt;code&gt;notice&lt;/code&gt; 입니다. 이는 많은 로그 메시지가 기본적으로 인쇄되지 않음을 의미합니다. 여기에는 감독자의 진행 보고서가 포함됩니다. 진행 상황 보고서를 받으려면 기본 로그 수준을 &lt;code&gt;info&lt;/code&gt; 로 올려야합니다.</target>
        </trans-unit>
        <trans-unit id="d287ac5001b044c81427ccf014f3ddfd35b4ee5b" translate="yes" xml:space="preserve">
          <source>In OpenSSH</source>
          <target state="translated">OpenSSH에서</target>
        </trans-unit>
        <trans-unit id="a90aedd16eab7e90ca5158413abefdf208107564" translate="yes" xml:space="preserve">
          <source>In PCRE, a subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number.</source>
          <target state="translated">: PCRE에서 서브 패턴은 세 가지 방법 중 하나로 이름을 지정할 수 있습니다 &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 또는 &lt;code&gt;(?'name'...)&lt;/code&gt; 펄처럼, 또는 &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 에서와 같이 파이썬. 역 참조, 재귀 및 조건과 같은 패턴의 다른 부분에서 괄호를 캡처하는 것에 대한 참조는 이름 및 번호로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="256aeea3c9968f0c93cc31456d90fd25ae389948" translate="yes" xml:space="preserve">
          <source>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value.</source>
          <target state="translated">PCRE에서는 &quot;bab&quot;와 일치합니다. 첫 번째 캡처 괄호는 &quot;b&quot;와 일치하고, 두 번째 그룹에서 역 참조 \ 1이 &quot;b&quot;와 일치하지 않으면 두 번째 대체는 &quot;a&quot;와 일치 한 다음 되풀이됩니다. 재귀에서 \ 1은 이제 &quot;b&quot;와 일치하므로 전체 일치가 성공합니다. Perl에서는 재귀 호출 내부에서 \ 1 외부 설정 값에 액세스 할 수 없으므로 패턴이 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bdbe179924ece7a6399c61e126213e1ec2fdb03" translate="yes" xml:space="preserve">
          <source>In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.</source>
          <target state="translated">Perl에서 \ l, \ L, \ u 및 \ U 시퀀스는 문자열 핸들러로 인식되어 다음 문자의 대소 문자를 수정하는 데 사용됩니다. PCRE는 이러한 이스케이프 시퀀스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c9f67deea2c96d4c87a2b517cca3a419aaafb51" translate="yes" xml:space="preserve">
          <source>In R4B and earlier versions of OTP, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are situated under &lt;code&gt;OTPROOT/usr&lt;/code&gt;.</source>
          <target state="translated">R4B 및 이전 버전의 OTP에서 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;lib&lt;/code&gt; 는 &lt;code&gt;OTPROOT/usr&lt;/code&gt; 아래에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a3afab8c285c30f15c650612a9e9a18aec7d293" translate="yes" xml:space="preserve">
          <source>In SNMP, the &lt;code&gt;set&lt;/code&gt; operation is atomic. Either all variables which are specified in a &lt;code&gt;set&lt;/code&gt; operation are changed, or none are changed. Therefore, the &lt;code&gt;set&lt;/code&gt; operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked:</source>
          <target state="translated">SNMP에서 &lt;code&gt;set&lt;/code&gt; 작업은 원 자성입니다. &lt;code&gt;set&lt;/code&gt; 조작에 지정된 모든 변수 가 변경되거나 변경되지 않습니다. 따라서, &lt;code&gt;set&lt;/code&gt; 동작은 2 단계로 나누어진다. 첫 번째 단계에서 각 변수의 새 값은 MIB의 변수 정의와 비교하여 확인됩니다. 다음 정의가 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="021a1af44ce27aa9f05d1c38410af20ca7b60806" translate="yes" xml:space="preserve">
          <source>In SNMPv1 and SNMPv2c, the community string in the message was used for (at least) three different purposes:</source>
          <target state="translated">SNMPv1 및 SNMPv2c에서 메시지의 커뮤니티 문자열은 적어도 세 가지 다른 목적으로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="02cb323587a2984dde2a87bd71f9d85e1a736a34" translate="yes" xml:space="preserve">
          <source>In SNMPv3, each of these usage areas has its own unique mechanism. A context is identified by the name of the SNMP entity, &lt;code&gt;contextEngineID&lt;/code&gt;, and the name of the context, &lt;code&gt;contextName&lt;/code&gt;. Each SNMPv3 message contains values for these two parameters.</source>
          <target state="translated">SNMPv3에서 이러한 각 사용 영역에는 고유 한 메커니즘이 있습니다. 컨텍스트는 SNMP 엔티티 이름 &lt;code&gt;contextEngineID&lt;/code&gt; 및 컨텍스트 이름 &lt;code&gt;contextName&lt;/code&gt; 으로 식별 됩니다. 각 SNMPv3 메시지에는이 두 매개 변수의 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c5e1bb8d75f3351aa564c900b00a6b87a8524ac7" translate="yes" xml:space="preserve">
          <source>In TLS 1.3 the session reuse is replaced by a new session tickets mechanism based on the pre shared key concept. This mechanism also obsoletes the session tickets from RFC5077, not implemented by this application. See also &lt;code&gt;Session Tickets and Session Resumption in TLS-1.3 &lt;/code&gt;</source>
          <target state="translated">TLS 1.3에서 세션 재사용은 사전 공유 키 개념을 기반으로하는 새로운 세션 티켓 메커니즘으로 대체됩니다. 이 메커니즘은 또한이 애플리케이션에서 구현하지 않은 RFC5077의 세션 티켓을 폐기합니다. &lt;code&gt;Session Tickets and Session Resumption in TLS-1.3 &lt;/code&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5895f59f593a11e2ddc456b6ee6229093c87afb4" translate="yes" xml:space="preserve">
          <source>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case forms.</source>
          <target state="translated">터키어에서는 점과 점이없는 &quot;i&quot;가 모두 소문자와 대문자로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="878884e2dc7ceb0c8586c874280425307fca0f37" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values &amp;gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.</source>
          <target state="translated">UTF-8 모드에서 값이 255 (0xffff) 인 문자는 리터럴 데이터 단위 문자열로 또는 \ x {이스케이프 메커니즘을 사용하여 클래스에 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0723db02fb1375caa6de0f6695a31f67e99a568d" translate="yes" xml:space="preserve">
          <source>In Unicode filename mode, filenames given to BIF &lt;code&gt;open_port/2&lt;/code&gt; with option &lt;code&gt;{spawn_executable,...}&lt;/code&gt; are also interpreted as Unicode. So is the parameter list specified in option &lt;code&gt;args&lt;/code&gt; available when using &lt;code&gt;spawn_executable&lt;/code&gt;. The UTF-8 translation of arguments can be avoided using binaries, see section &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유니 코드 파일 이름 모드에서 &lt;code&gt;{spawn_executable,...}&lt;/code&gt; 옵션 을 사용하여 BIF &lt;code&gt;open_port/2&lt;/code&gt; 에 지정된 파일 이름 도 유니 코드로 해석됩니다. &lt;code&gt;spawn_executable&lt;/code&gt; 을 사용할 때 옵션 &lt;code&gt;args&lt;/code&gt; 에 지정된 매개 변수 목록도 있습니다 . 바이너리를 사용하여 인수의 UTF-8 변환을 피할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19f2c130abf603c133bbd0f5a1747bb0969bbb8c" translate="yes" xml:space="preserve">
          <source>In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).</source>
          <target state="translated">유니 코드 모드에서 한정자는 개별 데이터 단위가 아닌 문자에 적용됩니다. 예를 들어, \ x {100} {2}는 두 문자와 일치하며 각 문자는 UTF-8 문자열에서 2 바이트 시퀀스로 표시됩니다. 마찬가지로, \ X {3}은 3 개의 유니 코드 확장 그래 핀 클러스터와 일치하며, 각 클러스터는 여러 데이터 단위 길이 일 수 있으며 길이가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a58382bb2f1e4ec5560be47f72bd53dd8fd73e07" translate="yes" xml:space="preserve">
          <source>In Unicode mode, two more characters whose code points are &amp;gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.</source>
          <target state="translated">유니 코드 모드에서는 LS (줄 구분 기호, U + 2028)와 PS (문단 구분 기호, U + 2029)의 코드 포인트가 255보다 큰 두 문자가 추가됩니다. 이러한 문자를 인식하기 위해 유니 코드 문자 속성 지원이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9bcf8117b716659d525a533ec0fd6a684678ba1" translate="yes" xml:space="preserve">
          <source>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</source>
          <target state="translated">Windows에서 모든 디렉토리 구분 기호는 슬래시이며 드라이브 문자는 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="ad12d1518ecf9a65e8a75f2907c07a876915311c" translate="yes" xml:space="preserve">
          <source>In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windows에서 인수에 백 슬래시가 포함되어 있어도 모든 함수는 슬래시 만있는 파일 이름을 반환합니다. 중복 디렉토리 분리자를 제거하여 파일 이름을 정규화하려면 &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ef00d820ea8134fdb18c86e4ae50113bc762dcc" translate="yes" xml:space="preserve">
          <source>In a .config file:</source>
          <target state="translated">.config 파일에서 :</target>
        </trans-unit>
        <trans-unit id="fd45d713b47049d2ce36151c1dc290fc396f5a95" translate="yes" xml:space="preserve">
          <source>In a CTH, behavior can be hooked in after the following functions:</source>
          <target state="translated">CTH에서 다음 기능 후에 동작을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a4189b805358c6e1539d1f92304f2c6381b6deb" translate="yes" xml:space="preserve">
          <source>In a CTH, the behavior can be hooked in before the following functions:</source>
          <target state="translated">CTH에서 다음 기능 전에 동작을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="effbd836389d7d8b463c9fd530b435aef42b51ae" translate="yes" xml:space="preserve">
          <source>In a KDE environment, select &lt;strong&gt;KDE Control Center (Personal Settings)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Accessibility&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard Layout&lt;/strong&gt;.</source>
          <target state="translated">KDE 환경에서 &lt;strong&gt;KDE 제어 센터 (개인 설정)&lt;/strong&gt; &amp;gt; &lt;strong&gt;지역 및 접근성&lt;/strong&gt; &amp;gt; &lt;strong&gt;키보드 레이아웃을 선택하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff429dd35571b630c89a291b69ebf06abbcfc55" translate="yes" xml:space="preserve">
          <source>In a Supervision Tree</source>
          <target state="translated">감독 트리에서</target>
        </trans-unit>
        <trans-unit id="33bc2d5f0d660142d0d63fc0df9ecd908613840a" translate="yes" xml:space="preserve">
          <source>In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and \R escapes, which can match different numbers of data units, are not permitted either.</source>
          <target state="translated">UTF 모드에서 PCRE는 \ C 이스케이프 (UTF 모드에서도 단일 데이터 단위와 일치)가 lookbehind 어설 션에 나타나는 것을 허용하지 않으므로 lookbehind의 길이를 계산할 수 없습니다. 다른 수의 데이터 단위와 일치 할 수있는 \ X 및 \ R 이스케이프도 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c87d0f65600acbab54733adb07b3f71b63b4920" translate="yes" xml:space="preserve">
          <source>In a Unix (Bourne) shell, it can look as follows (line breaks are for readability, they are not to be there when typed):</source>
          <target state="translated">유닉스 (Bourne) 셸에서는 다음과 같이 보일 수 있습니다 (줄 바꿈은 읽기 쉽게하기 위해 입력 할 때 없어야 함).</target>
        </trans-unit>
        <trans-unit id="9d1062a9134da719f643aea0a4d7fbb853ab2580" translate="yes" xml:space="preserve">
          <source>In a black-box testing scenario, &lt;code&gt;Common Test&lt;/code&gt;-based test programs connect to the target system(s) through standard O&amp;amp;M and CLI protocols. &lt;code&gt;Common Test&lt;/code&gt; provides implementations of, and wrapper interfaces to, some of these protocols (most of which exist as standalone components and applications in OTP). The wrappers simplify configuration and add verbosity for logging purposes. &lt;code&gt;Common Test&lt;/code&gt; is continously extended with useful support modules. However, notice that it is a straightforward task to use any Erlang/OTP component for testing purposes with &lt;code&gt;Common Test&lt;/code&gt;, without needing a &lt;code&gt;Common Test&lt;/code&gt; wrapper for it. It is as simple as calling Erlang functions. A number of target-independent interfaces are supported in &lt;code&gt;Common Test&lt;/code&gt;, such as Generic Telnet and FTP. These can be specialized or used directly for controlling instruments, traffic load generators, and so on.</source>
          <target state="translated">블랙 박스 테스트 시나리오에서 &lt;code&gt;Common Test&lt;/code&gt; 기반 테스트 프로그램은 표준 O &amp;amp; M 및 CLI 프로토콜을 통해 대상 시스템에 연결됩니다. &lt;code&gt;Common Test&lt;/code&gt; 는 이러한 프로토콜 중 일부에 대한 구현 및 랩퍼 인터페이스를 제공합니다 (대부분 OTP에서 독립형 구성 요소 및 애플리케이션으로 존재 함). 래퍼는 로깅을 위해 구성을 단순화하고 세부 정보를 추가합니다. 유용한 &lt;code&gt;Common Test&lt;/code&gt; 모듈로 공통 테스트 가 지속적으로 확장됩니다. 그러나 &lt;code&gt;Common Test&lt;/code&gt; 랩퍼 가 없어도 &lt;code&gt;Common Test&lt;/code&gt; Erlang / OTP 구성 요소를 테스트 목적으로 사용하는 것은 간단한 작업 입니다. Erlang 함수를 호출하는 것만 큼 간단합니다. 다양한 대상 독립 인터페이스가 지원됩니다. &lt;code&gt;Common Test&lt;/code&gt; 일반 Telnet 및 FTP와 같은 공통 테스트 계측기, 교통 부하 발생기 등을 제어하기 위해 특수화하거나 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1500508d272e3e1ef6dd2792fe28503800aeebb" translate="yes" xml:space="preserve">
          <source>In a callback module:</source>
          <target state="translated">콜백 모듈에서 :</target>
        </trans-unit>
        <trans-unit id="87ab655f4b96d81d49f137e06e1185ae6b220c3d" translate="yes" xml:space="preserve">
          <source>In a debug-compiled emulator, &lt;code&gt;ASSERT(VALID_INSTR(next_pf));&lt;/code&gt; makes sure that &lt;code&gt;next_pf&lt;/code&gt; is a valid instruction (that is, that it points within the &lt;code&gt;process_main()&lt;/code&gt; function in &lt;code&gt;beam_emu.c&lt;/code&gt;).</source>
          <target state="translated">디버그 컴파일 된 에뮬레이터에서 &lt;code&gt;ASSERT(VALID_INSTR(next_pf));&lt;/code&gt; &lt;code&gt;next_pf&lt;/code&gt; 가 유효한 명령어 인지 확인합니다 (즉, &lt;code&gt;beam_emu.c&lt;/code&gt; 의 &lt;code&gt;process_main()&lt;/code&gt; 함수 내를 가리킴 ).</target>
        </trans-unit>
        <trans-unit id="f3b8b640abb829ff4cbfb271a5e40f88ec8ec137" translate="yes" xml:space="preserve">
          <source>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a &lt;strong&gt;hidden node&lt;/strong&gt; can be used.</source>
          <target state="translated">분산 Erlang 시스템에서는 때때로 다른 모든 노드에 연결하지 않고 노드에 연결하는 것이 유용합니다. 시스템 상태를 방해하지 않고 검사하는 데 사용되는 일종의 O &amp;amp; M 기능이 그 예입니다. 이를 위해 &lt;strong&gt;숨겨진 노드를&lt;/strong&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aec9cfbd2b5a5b825d96878372130aac2263b76" translate="yes" xml:space="preserve">
          <source>In a distributed system with several Erlang nodes, it can be necessary to control applications in a distributed manner. If the node, where a certain application is running, goes down, the application is to be restarted at another node.</source>
          <target state="translated">여러 Erlang 노드가있는 분산 시스템에서는 분산 방식으로 응용 프로그램을 제어해야 할 수 있습니다. 특정 응용 프로그램이 실행중인 노드가 다운되면 응용 프로그램이 다른 노드에서 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="23225511bfc3875384d2792bd043f1c701a2c0ca" translate="yes" xml:space="preserve">
          <source>In a future Erlang/OTP release, it might be implemented a way to (optionally) preserve sharing.</source>
          <target state="translated">향후 Erlang / OTP 릴리스에서는 공유를 선택적으로 유지하는 방법으로 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a6305081dfcb5f7cad2ca28aa531435457c8383" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Dir&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">향후 릴리스에서 &lt;code&gt;Dir&lt;/code&gt; 인수에 잘못된 유형 이있을 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a6542a84ddb6812f9a19d1cc7c1b8efff7c3a54" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Filename&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">다음 릴리스에서 &lt;code&gt;Filename&lt;/code&gt; 인수의 유형이 잘못 되면 예외가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f07b31928724d837c06543b0d4ac70cbfb01f2cb" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">향후 릴리스에서이 함수는 더 많은 값과 범위를 반환 할 수 있습니다. 호환성 문제를 방지하려면 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f9e2eab173886fa1c16faadaf18c5a216f901d1c" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 릴리스에서이 함수는 더 많은 값과 범위를 반환 할 수 있습니다. 호환성 문제를 피하려면 &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ab65a5239391014eb913ce30baf2efae7d72ed7b" translate="yes" xml:space="preserve">
          <source>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.</source>
          <target state="translated">더 큰 패턴에서는 괄호 숫자를 추적하는 것이 까다로울 수 있습니다. 상대 참조를 사용하면이 작업이 쉬워집니다. 위 패턴에서 (? 1) 대신 (? -2)를 쓰면 재귀 앞에 가장 최근에 열린 두 번째 괄호를 나타낼 수 있습니다. 즉, 음수는 캡처 된 괄호를 마주 치는 지점부터 왼쪽으로 셉니다.</target>
        </trans-unit>
        <trans-unit id="521f7cdd5ab3fc62df36d3dfb682c92be20244f3" translate="yes" xml:space="preserve">
          <source>In a larger system with a user (in this case an MGC) distributed over several Erlang nodes, it looks a little bit different. Here the encoding is performed on the originating Erlang node (1) and the binary is forwarded to the node (2) with the physical network interface. When the potential message reply is received on the interface on node (2), it is decoded there and then different actions will be taken for each transaction in the message. The transaction reply will be forwarded in its decoded form to the originating node (1) while the other types of transactions will be handled locally on node (2).</source>
          <target state="translated">여러 Erlang 노드에 분산 된 사용자 (이 경우 MGC)가있는 더 큰 시스템에서는 약간 다르게 보입니다. 여기서 인코딩은 원래 Erlang 노드 (1)에서 수행되고 바이너리는 물리적 네트워크 인터페이스를 통해 노드 (2)로 전달됩니다. 잠재적 인 메시지 응답이 노드 (2)의 인터페이스에서 수신되면, 거기에서 디코딩되고 메시지의 각 트랜잭션에 대해 다른 조치가 수행됩니다. 트랜잭션 응답은 디코딩 된 형식으로 발신 노드 (1)로 전달되는 반면 다른 유형의 트랜잭션은 노드 (2)에서 로컬로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="976ebf70f5a3964ad2dc1b919f7c060f1cb37e38" translate="yes" xml:space="preserve">
          <source>In a manner similar to the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, except that this function requires the following conditions:</source>
          <target state="translated">&lt;code&gt;mnesia:index_read/3&lt;/code&gt; 함수와 유사한 방식으로 , 레코드를 일치 시키려고 할 때 모든 인덱스 정보를 사용할 수 있습니다. 이 함수는 다음 조건이 필요하다는 점을 제외하고 &lt;code&gt;mnesia:match_object/3&lt;/code&gt; 함수와 동일한 규칙을 따르는 패턴을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="4c4bc3edae976085e9a0d189975eeda0ad921051" translate="yes" xml:space="preserve">
          <source>In a monotonically increasing sequence of values, all values that have a predecessor are either larger than or equal to its predecessor.</source>
          <target state="translated">단조 증가하는 값 시퀀스에서 선행 작업이있는 모든 값은 이전 작업보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ab70776fb35c924c17c1cd7488da7d1d0d285f9" translate="yes" xml:space="preserve">
          <source>In a new version of the release, the application &lt;code&gt;ch_app&lt;/code&gt; is to be included in &lt;code&gt;prim_app&lt;/code&gt;. That is, its topmost supervisor &lt;code&gt;ch_sup&lt;/code&gt; is to be started as a child process to &lt;code&gt;prim_sup&lt;/code&gt;.</source>
          <target state="translated">릴리스의 새 버전에서 응용 프로그램 &lt;code&gt;ch_app&lt;/code&gt; 이 포함되어야한다 &lt;code&gt;prim_app&lt;/code&gt; . 즉 자사의 최상위 감독자 인 &lt;code&gt;ch_sup&lt;/code&gt; 가 할 수있는 자식 프로세스로 시작되어야한다 &lt;code&gt;prim_sup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="274b316a1d6a226ddaa81a91a28524b871d26fde" translate="yes" xml:space="preserve">
          <source>In a pattern matching, a left-hand side &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; is matched against a right-hand side &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt;. If the matching succeeds, any unbound variables in the pattern become bound. If the matching fails, a run-time error occurs.</source>
          <target state="translated">패턴 매칭에서, 좌측 사이드 &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 우측면 대해 일치 &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt; . 일치가 성공하면 패턴의 바인딩되지 않은 변수가 바인딩됩니다. 일치하지 않으면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a946839a1f3091d7ba3fdcd58b538b74992aa355" translate="yes" xml:space="preserve">
          <source>In a strictly monotonically increasing sequence of values, all values that have a predecessor are larger than its predecessor.</source>
          <target state="translated">엄격하게 단조 증가하는 값 시퀀스에서 선행 작업이있는 모든 값은 이전 작업보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="31ff33f4c7a5907d10bf958b213e55ba1dc343c7" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers such as error loggers.</source>
          <target state="translated">감독 트리에서 많은 프로세스는 유사한 구조를 가지며 유사한 패턴을 따릅니다. 예를 들어, 수퍼바이저의 구조는 비슷합니다. 그들 사이의 유일한 차이점은 그들이 감독하는 자식 프로세스입니다. 많은 작업자가 서버-클라이언트 관계, 유한 상태 시스템 또는 오류 로거와 같은 이벤트 핸들러의 서버입니다.</target>
        </trans-unit>
        <trans-unit id="3efaceff063003bf44950693b3f902b21784c28f" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers.</source>
          <target state="translated">감독 트리에서 많은 프로세스는 유사한 구조를 가지고 있으며 유사한 패턴을 따릅니다. 예를 들어 감독자는 구조가 비슷합니다. 그들 사이의 유일한 차이점은 그들이 감독하는 자식 프로세스입니다. 대부분의 작업자는 서버-클라이언트 관계의 서버, 유한 상태 머신 또는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="bd210cc6dd528624657860bc47c1121fbe29a1ff" translate="yes" xml:space="preserve">
          <source>In a system implemented according to the OTP design principles, all processes, except system processes and special processes, reside in one of the behaviours &lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;. These belong to the STDLIB application and upgrading/downgrading normally requires an emulator restart.</source>
          <target state="translated">OTP 설계 원칙에 따라 구현 된 시스템에서 시스템 프로세스 및 특수 프로세스를 제외한 모든 프로세스는 동작 &lt;code&gt;supervisor&lt;/code&gt; , &lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_fsm&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; 또는 &lt;code&gt;gen_event&lt;/code&gt; 중 하나에 있습니다. 이들은 STDLIB 애플리케이션에 속하며 일반적으로 업그레이드 / 다운 그레이드에는 에뮬레이터를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="554c457d1fb565b9a6393985044814faed4608a5" translate="yes" xml:space="preserve">
          <source>In a system of &lt;code&gt;Mnesia&lt;/code&gt; nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate &lt;code&gt;Mnesia&lt;/code&gt; data behaves identically regardless of where the data resides.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 노드 시스템 에서 모든 노드는 모든 테이블의 현재 위치를 알고 있습니다. 이 예에서 데이터는 두 노드 모두에 복제되며 테이블의 데이터를 조작하는 함수는 두 노드 중 하나에서 실행될 수 있습니다. &lt;code&gt;Mnesia&lt;/code&gt; 데이터 를 조작하는 코드는 데이터가있는 위치에 관계없이 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8b48851f5568a382a621cc92c48317c0fa23d6e3" translate="yes" xml:space="preserve">
          <source>In a system structured according to the OTP design principles, any process would be a child process belonging to a supervisor, see &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; in Changing a Supervisor.</source>
          <target state="translated">OTP 설계 원칙에 따라 구성된 시스템에서 모든 프로세스는 수퍼바이저에 속하는 &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; 입니다. 수퍼바이저 변경에서 하위 프로세스 추가 및 삭제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44ba56c896fa716f74253d95bcea0e44a23d8f58" translate="yes" xml:space="preserve">
          <source>In a system that use comparatively few processes, performance &lt;strong&gt;might&lt;/strong&gt; be improved by increasing the minimum heap size using either the &lt;code&gt;+h&lt;/code&gt; option for &lt;code&gt;erl&lt;/code&gt; or on a process-per-process basis using the &lt;code&gt;min_heap_size&lt;/code&gt; option for &lt;code&gt;spawn_opt/4&lt;/code&gt;.</source>
          <target state="translated">비교적 소수의 프로세스를 사용하는 시스템에서 성능이 &lt;strong&gt;있습니다&lt;/strong&gt; 중 하나를 사용하여 최소 힙 크기를 증가시킴으로써 향상 될 수 &lt;code&gt;+h&lt;/code&gt; 에 대한 옵션 &lt;code&gt;erl&lt;/code&gt; 또는 사용하여 프로세스 프로세스 당 기준으로 &lt;code&gt;min_heap_size&lt;/code&gt; 에 대한 옵션 &lt;code&gt;spawn_opt/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f12319f42fd8dda78673d0ca45eab01cc78900" translate="yes" xml:space="preserve">
          <source>In a system with TCP-based distribution, this data is kept in the &lt;strong&gt;Erlang port mapper daemon&lt;/strong&gt; (&lt;code&gt;epmd&lt;/code&gt;), which is contacted when a distributed node starts. The lock file and a convention for the UDS listen socket's name remove the need for &lt;code&gt;epmd&lt;/code&gt; when using this distribution module. UDS is always restricted to one host, why avoiding a port mapper is easy.</source>
          <target state="translated">TCP 기반 배포가있는 시스템에서이 데이터는 &lt;strong&gt;Erlang 포트 매퍼 데몬&lt;/strong&gt; ( &lt;code&gt;epmd&lt;/code&gt; )에 보관되며 분산 노드가 시작될 때 연결됩니다. UDS 청취 소켓 이름에 대한 잠금 파일 및 규칙은 이 배포 모듈 을 &lt;code&gt;epmd&lt;/code&gt; 때 epmd 가 필요하지 않습니다 . UDS는 항상 하나의 호스트로 제한되므로 포트 매퍼를 피하는 것이 쉬운 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5ccaddcd0c823bd477d387b9058aa0fc21906850" translate="yes" xml:space="preserve">
          <source>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</source>
          <target state="translated">SNMP가 모니터하는 테이블에서 모든 요소는 정수, 문자열 또는 정수 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f62f7aaa3c520340c959fbaf0d8e529944b88886" translate="yes" xml:space="preserve">
          <source>In a target system, the release upgrade file is to be located in directory &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;.</source>
          <target state="translated">대상 시스템에서 릴리스 업그레이드 파일은 &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; 디렉토리에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ac283a89487dcb253786b8bd6bb529084d29ffc" translate="yes" xml:space="preserve">
          <source>In a test suite, one must &lt;strong&gt;require&lt;/strong&gt; that a configuration variable (&lt;code&gt;CfgVarName&lt;/code&gt; in the previous definition) exists before attempting to read the associated value in a test case or configuration function.</source>
          <target state="translated">테스트 스위트 번 수행해야 &lt;strong&gt;요구&lt;/strong&gt; (구성 변수 것을 &lt;code&gt;CfgVarName&lt;/code&gt; 이전 정의)는 테스트 케이스 구성 또는 기능에 관련된 값을 판독하기 전에 존재한다.</target>
        </trans-unit>
        <trans-unit id="4fb9fe0e283f20ff6583d865477e2f5797757ef1" translate="yes" xml:space="preserve">
          <source>In a tuple &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt;, if &lt;code&gt;CSSFile&lt;/code&gt; is specified with a path, for example, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt;, this full name is used to locate the file. However, if only the file name is specified, for example, &lt;code&gt;categories.css&lt;/code&gt;, the CSS file is assumed to be located in the data directory, &lt;code&gt;data_dir&lt;/code&gt;, of the suite. The latter use is recommended, as it is portable compared to hard coding path names in the suite.</source>
          <target state="translated">튜플 &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt; 에서 &lt;code&gt;CSSFile&lt;/code&gt; 이 경로와 함께 지정된 경우 ( 예 : &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt; )이 전체 이름은 파일을 찾는 데 사용됩니다. 그러나 파일 이름 만 지정된 경우 (예 : &lt;code&gt;categories.css&lt;/code&gt; ) CSS 파일은 스위트 의 데이터 디렉토리 &lt;code&gt;data_dir&lt;/code&gt; 에 있다고 가정합니다 . 후자의 사용은 제품군의 하드 코딩 경로 이름과 비교하여 이식성이 있으므로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="1286250e203085fab759937a2009fa429066e481" translate="yes" xml:space="preserve">
          <source>In absence of spawn operation failures, atomically sets up a link between the calling process and the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#link-1&quot;&gt;link(Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process.</source>
          <target state="translated">생성 작업 실패가없는 경우 호출 프로세스와 새로 생성 된 프로세스 간의 링크를 원자 적으로 설정합니다. 즉, 호출 프로세스가 &lt;code&gt;&lt;a href=&quot;#link-1&quot;&gt;link(Pid)&lt;/a&gt;&lt;/code&gt; 호출 한 것과 같 으며 &lt;code&gt;Pid&lt;/code&gt; 는 새로 생성 된 프로세스의 프로세스 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="ea7833417b997c143c87f40d58a519fc4541a0bf" translate="yes" xml:space="preserve">
          <source>In addition to specifying a type letter, the actual value for the type can be specified. For example:</source>
          <target state="translated">유형 문자를 지정하는 것 외에도 유형의 실제 값을 지정할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1c5578dc50a0864bd8d9d5138f6fed8f654dd2af" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;{Item,Value}&lt;/code&gt; pairs defined for &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, the following items are allowed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; 에 대해 정의 된 &lt;code&gt;{Item,Value}&lt;/code&gt; 쌍 외에도 다음 항목이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a79ac5033930298cd0d6e70aec5390fc42e348e" translate="yes" xml:space="preserve">
          <source>In addition to the Call Graph there is a graph called the  &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt;. This is a graph of calls (From, To) such that there is a chain of calls from From to To in the Call Graph, and every From and To is an exported function or an unused local function. The vertices are the same as for the Call Graph.</source>
          <target state="translated">Call Graph 외에도 &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt; 라는 &lt;strong id=&quot;inter_call_graph&quot;&gt;그래프가&lt;/strong&gt; 있습니다. 이것은 호출 그래프 (From, To)로서 호출 그래프에 From에서 To까지의 호출 체인이 있으며 모든 From 및 To는 내 보낸 함수 또는 사용되지 않는 로컬 함수입니다. 꼭짓점은 호출 그래프와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5ea131aa8ce39e0fad64d7f37053c449509534e3" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="translated">키 교환, 페이로드 암호화, 메시지 인증 및 의사 난수 계산에 사용되는 암호 제품군에 의해 협상 된 알고리즘 외에도 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; 의 TLS 서명 알고리즘 확장 섹션 7.4.1.4.1이 TLS 1.2부터 사용될 수 있습니다. TLS 핸드 셰이크 중에 사용할 서명 알고리즘. 1.2보다 낮은 TLS 버전이 지원되지 않으면 클라이언트는이 옵션으로 지정된 알고리즘과 함께 TLS 서명 알고리즘 확장을 보냅니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="8211e020ecaee607aa2a72d41a52382183c4a8b5" translate="yes" xml:space="preserve">
          <source>In addition to the collection algorithm described above, the Erlang garbage collector also provides generational garbage collection. An additional heap, called the old heap, is used where the long lived data is stored. The original heap is called the young heap, or sometimes the allocation heap.</source>
          <target state="translated">위에서 설명한 수집 알고리즘 외에도 Erlang 가비지 수집기는 세대 별 가비지 수집도 제공합니다. 이전 힙이라고하는 추가 힙은 수명이 긴 데이터가 저장되는 곳에 사용됩니다. 원래 힙을 젊은 힙 또는 할당 힙이라고합니다.</target>
        </trans-unit>
        <trans-unit id="cfba226beccd4a1427fc9d1c6106071bf62f4d15" translate="yes" xml:space="preserve">
          <source>In addition to the documentation here Erlang is described in several recent books like:</source>
          <target state="translated">여기에 문서 외에도 Erlang은 다음과 같은 최근의 여러 책에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="88d44d718b6e7d7989a95592c66be31f11e98097" translate="yes" xml:space="preserve">
          <source>In addition to the earlier:</source>
          <target state="translated">이전 이외에 :</target>
        </trans-unit>
        <trans-unit id="890bb829697d00b41e1b4a5c52b5061881f7d784" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/2&lt;/code&gt; and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">필수 콜백 함수 &lt;code&gt;log/2&lt;/code&gt; 외에도 핸들러 모듈은 선택적 콜백 함수 인 &lt;code&gt;adding_handler/1&lt;/code&gt; , &lt;code&gt;changing_config/2&lt;/code&gt; 및 &lt;code&gt;removing_handler/1&lt;/code&gt; _handler / 1을 내보낼 수 있습니다 . 이 함수에 대한 자세한 내용은 logger (3) 매뉴얼 페이지의 &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4485e35d13b31a5f17e0ec8540bc97bc5f63738e" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/3&lt;/code&gt;, &lt;code&gt;filter_config/1&lt;/code&gt;, and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">필수 콜백 함수에 더하여 &lt;code&gt;log/2&lt;/code&gt; , 처리기 모듈은 선택적 콜백 함수 내보낼 수 &lt;code&gt;adding_handler/1&lt;/code&gt; , &lt;code&gt;changing_config/3&lt;/code&gt; , &lt;code&gt;filter_config/1&lt;/code&gt; 및 &lt;code&gt;removing_handler/1&lt;/code&gt; . 이 함수에 대한 자세한 정보는 logger (3) 매뉴얼 페이지의 &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45082fc3acc3b9bc0e8feada04ef6474816b9ee7" translate="yes" xml:space="preserve">
          <source>In addition to the ordinary functions for receiving and sending files (see &lt;code&gt;recv/2&lt;/code&gt;, &lt;code&gt;recv/3&lt;/code&gt;, &lt;code&gt;send/2&lt;/code&gt;, and &lt;code&gt;send/3&lt;/code&gt;) there are functions for receiving remote files as binaries (see &lt;code&gt;recv_bin/2&lt;/code&gt;) and for sending binaries to be stored as remote files (see &lt;code&gt;send_bin/3&lt;/code&gt;).</source>
          <target state="translated">파일 수신 및 전송을위한 일반 기능 ( &lt;code&gt;recv/2&lt;/code&gt; , &lt;code&gt;recv/3&lt;/code&gt; , &lt;code&gt;send/2&lt;/code&gt; 및 &lt;code&gt;send/3&lt;/code&gt; 참조 ) 외에도 원격 파일을 바이너리로 수신하고 ( &lt;code&gt;recv_bin/2&lt;/code&gt; 참조 ) 바이너리를 전송하는 기능이 있습니다. 원격 파일로 저장됩니다 ( &lt;code&gt;send_bin/3&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="af29f18311535fbae0f8e4ae58bbff8300a8115f" translate="yes" xml:space="preserve">
          <source>In addition to the representations described earlier, the following deprecated representations are available if the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;:</source>
          <target state="translated">사양이 &lt;code&gt;legacy_erlang_types&lt;/code&gt; 옵션으로 컴파일 된 경우 앞에서 설명한 표현 외에도 다음과 같은 더 이상 사용되지 않는 표현을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86f6f7e492ba3b7949f4b38c0a7d47daec6054a6" translate="yes" xml:space="preserve">
          <source>In addition to the representations of forms, the list that represents a module declaration (as returned by functions in &lt;code&gt;epp(3)&lt;/code&gt; and &lt;code&gt;erl_parse(3)&lt;/code&gt;) can contain the following:</source>
          <target state="translated">양식 표현 외에도 모듈 선언을 나타내는 목록 ( &lt;code&gt;epp(3)&lt;/code&gt; 및 &lt;code&gt;erl_parse(3)&lt;/code&gt; 함수에 의해 리턴 됨 )은 다음을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3b0823be609b58f269a346f9f2725dc8f84272" translate="yes" xml:space="preserve">
          <source>In addition to the signature_algorithms extension from TLS 1.2, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt;adds the signature_algorithms_cert extension which enables having special requirements on the signatures used in the certificates that differs from the requirements on digital signatures as a whole. If this is not required this extension is not needed.</source>
          <target state="translated">TLS 1.2의 signature_algorithms 확장 외에도 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt; 은 전체적으로 디지털 서명에 대한 요구 사항과 다른 인증서에 사용되는 서명에 대한 특수 요구 사항을 가질 수 있도록하는 signature_algorithms_cert 확장을 추가합니다. 이것이 필요하지 않은 경우이 확장은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ad8f4e74819a6f7578284e9cf32df82a24e4ca4" translate="yes" xml:space="preserve">
          <source>In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \w and \s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the &lt;code&gt;ucp&lt;/code&gt; option is passed. However, they can also be used explicitly. The properties are as follows:</source>
          <target state="translated">앞에서 설명한 표준 유니 코드 속성 외에도 PCRE는 유니 코드 속성을 사용하도록 \ w 및 \ s와 같은 기존 이스케이프 시퀀스를 변환 할 수있는 네 가지를 더 지원합니다. PCRE는 &lt;code&gt;ucp&lt;/code&gt; 옵션이 전달 될 때 이러한 비표준 비 Perl 특성을 내부적으로 사용합니다 . 그러나 명시 적으로 사용할 수도 있습니다. 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="698d80c93fc7667e3d673153ab193877506b308a" translate="yes" xml:space="preserve">
          <source>In addition to the static supervision tree, dynamic child processes can be added to an existing supervisor with the following call:</source>
          <target state="translated">정적 감독 트리 외에도 다음과 같은 호출을 통해 동적 자식 프로세스를 기존 감독자에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58454c75737b607a068b4e77b1a88fd258a15b57" translate="yes" xml:space="preserve">
          <source>In addition to the trace log file(s), a file with extension &lt;code&gt;.ti&lt;/code&gt; is created when Trace Tool Builder is started. This is the trace information file. It is a binary file, which contains the process information, trace flags used, the name of the node to which it belongs, and all information written with function &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;.ti&lt;/code&gt; files are always fetched with other logs when the trace is stopped.</source>
          <target state="translated">추적 도구 파일 이 시작되면 Trace Tool Builder가 시작될 때 확장자가 &lt;code&gt;.ti&lt;/code&gt; 인 파일 이 생성됩니다. 이것은 추적 정보 파일입니다. 이 파일은 프로세스 정보, 사용 된 추적 플래그, 해당 노드의 이름 및 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; 함수로 작성된 모든 정보를 포함하는 2 진 파일 입니다. 추적이 중지되면 &lt;code&gt;.ti&lt;/code&gt; 파일은 항상 다른 로그와 함께 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ead83cfe423b6f87966ff81fd05657fc8c719fd4" translate="yes" xml:space="preserve">
          <source>In addition to these options, &lt;strong&gt;raw&lt;/strong&gt; option specifications can be used. The raw options are specified as a tuple of arity four, beginning with tag &lt;code&gt;raw&lt;/code&gt;, followed by the protocol level, the option number, and the option value specified as a binary. This corresponds to the second, third, and fourth arguments to the &lt;code&gt;setsockopt&lt;/code&gt; call in the C socket API. The option value must be coded in the native endianess of the platform and, if a structure is required, must follow the structure alignment conventions on the specific platform.</source>
          <target state="translated">이러한 옵션 외에도 &lt;strong&gt;원시&lt;/strong&gt; 옵션 사양을 사용할 수 있습니다. 원시 옵션 태그로 시작, 인수에 대응 네 튜플로 지정됩니다 &lt;code&gt;raw&lt;/code&gt; , 프로토콜 수준, 옵션 번호 및 바이너리로 지정된 옵션 값 하였다. 이는 C 소켓 API 의 &lt;code&gt;setsockopt&lt;/code&gt; 호출에 대한 두 번째, 세 번째 및 네 번째 인수에 해당 합니다. 옵션 값은 플랫폼의 고유 엔디안으로 코딩되어야하며 구조가 필요한 경우 특정 플랫폼의 구조 정렬 규칙을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="ae1cf5f2bfcd3b60ef15c86d1e7f135dfc63d587" translate="yes" xml:space="preserve">
          <source>In addition to these, the following fields are automatically inserted by Logger, values taken from the two first parameters to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이 외에도 다음 필드가 Logger에 의해 자동으로 삽입되며, 두 개의 첫 번째 매개 변수에서 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 로 가져온 값입니다 .</target>
        </trans-unit>
        <trans-unit id="e583d04eef0dfd18104660d17dcc9b07446e62d3" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide contains the following chapters:</source>
          <target state="translated">이 소개 장 외에도 &lt;code&gt;Event Tracers&lt;/code&gt; 사용 설명서에는 다음 장이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd1509d104b7597ab782042099faae460d5ff6b5" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Megaco User's Guide contains the following chapters:</source>
          <target state="translated">이 소개 장 외에도 Megaco 사용 설명서에는 다음 장이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ad3911ee58ff673506ee22db5a2de1ed84850c6" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Reltool User's Guide contains the following chapters:</source>
          <target state="translated">이 소개 장 외에도 Reltool 사용자 안내서에는 다음 장이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f5fdf190092c245c6414244e40560909cfcd608" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the SNMP User's Guide contains the following chapters:</source>
          <target state="translated">이 소개 장 외에도 SNMP 사용 설명서에는 다음 장이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb294dab84ef10ba93b7376a3a5eeb757826cec4" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;#Record.Name&lt;/code&gt; returns the index in the tuple representation of &lt;code&gt;Name&lt;/code&gt; of the record &lt;code&gt;Record&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;#Record.Name&lt;/code&gt; 은 레코드 &lt;code&gt;Record&lt;/code&gt; 의 &lt;code&gt;Name&lt;/code&gt; 튜플 표현으로 인덱스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eec4f051098dd6dcb667d9032abc1d31d3cca680" translate="yes" xml:space="preserve">
          <source>In addition, EUnit will also look for another module whose name is &lt;code&gt;ModuleName&lt;/code&gt; plus the suffix &lt;code&gt;_tests&lt;/code&gt;, and if it exists, all the tests from that module will also be added. (If &lt;code&gt;ModuleName&lt;/code&gt; already contains the suffix &lt;code&gt;_tests&lt;/code&gt;, this is not done.) E.g., the specification &lt;code&gt;{module, mymodule}&lt;/code&gt; will run all tests in the modules &lt;code&gt;mymodule&lt;/code&gt; and &lt;code&gt;mymodule_tests&lt;/code&gt;. Typically, the &lt;code&gt;_tests&lt;/code&gt; module should only contain test cases that use the public interface of the main module (and no other code).</source>
          <target state="translated">또한 EUnit은 이름이 &lt;code&gt;ModuleName&lt;/code&gt; 에 접미사 &lt;code&gt;_tests&lt;/code&gt; 를 더한 다른 모듈을 찾고 해당되는 경우 해당 모듈의 모든 테스트도 추가됩니다. (경우 &lt;code&gt;ModuleName&lt;/code&gt; 이미 접미사 포함 &lt;code&gt;_tests&lt;/code&gt; 를 ,이 작업이 완료되지 않습니다.) 예를 들면, 사양 &lt;code&gt;{module, mymodule}&lt;/code&gt; 모든 모듈에서 테스트를 실행 &lt;code&gt;mymodule&lt;/code&gt; 과 &lt;code&gt;mymodule_tests&lt;/code&gt; 을 . 일반적으로 &lt;code&gt;_tests&lt;/code&gt; 모듈에는 주 모듈의 공용 인터페이스를 사용하고 다른 코드는 사용하지 않는 테스트 사례 만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec506ee3c0304b67799c67e512b132d1927abb1c" translate="yes" xml:space="preserve">
          <source>In addition, table properties can be set and changed. For details, see &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">또한 테이블 속성을 설정하고 변경할 수 있습니다. 자세한 내용 &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfbb12ad016ab1664756254ead2ae4c40b6031b7" translate="yes" xml:space="preserve">
          <source>In addition, the following three built-in types exist and can be thought as defined below, though strictly their &quot;type definition&quot; is not valid syntax according to the type language defined above.</source>
          <target state="translated">또한 다음 세 가지 기본 제공 유형이 존재하며 아래에 정의 된대로 생각할 수 있지만 &quot;유형 정의&quot;는 위에 정의 된 유형 언어에 따라 유효한 구문이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2ba8529808e3d5d63f2c2cd138891fddd10121b3" translate="yes" xml:space="preserve">
          <source>In addition, the record fields can be further specified when using a record type by adding type information about the field as follows:</source>
          <target state="translated">또한 레코드 유형을 사용할 때 다음과 같이 필드에 대한 유형 정보를 추가하여 레코드 필드를 추가로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c6af5a9419b35f362c885bc58714fd954a7c605" translate="yes" xml:space="preserve">
          <source>In addition, you'll probably want to familiarize yourself with the &lt;code&gt;dbg&lt;/code&gt; module and possibly &lt;code&gt;seq_trace&lt;/code&gt; module as well.</source>
          <target state="translated">또한 &lt;code&gt;dbg&lt;/code&gt; 모듈 및 가능하면 &lt;code&gt;seq_trace&lt;/code&gt; 모듈 에 익숙해지기를 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fb5db34bbd4674c5c25f061b695fba808bb59735" translate="yes" xml:space="preserve">
          <source>In all functions errors, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt;, can be thrown, where &lt;code&gt;Reason&lt;/code&gt; describes the error.</source>
          <target state="translated">모든 함수 오류에서 &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt; 가 발생할 수 있으며 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 오류를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fe9689d5a6e2657c5f322d20399fbd839acfe486" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;code&gt;ReplyInfo&lt;/code&gt; has the following structure:</source>
          <target state="translated">이 모든 경우에 &lt;code&gt;ReplyInfo&lt;/code&gt; 의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5f12a8e126b9f100f177dad18ae6f54278d47be" translate="yes" xml:space="preserve">
          <source>In all other cases.</source>
          <target state="translated">다른 모든 경우에.</target>
        </trans-unit>
        <trans-unit id="44ae32a10f43de59e7c1339560b615fa6de7f95e" translate="yes" xml:space="preserve">
          <source>In all other senses, the &lt;code&gt;_tmo&lt;/code&gt; functions inherit all the return values and the semantics from the functions without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">다른 모든 감각에서 &lt;code&gt;_tmo&lt;/code&gt; 의 기능이없이 모두에게 함수의 리턴 값을 의미 상속 &lt;code&gt;_tmo&lt;/code&gt; 의 접미사.</target>
        </trans-unit>
        <trans-unit id="fd966c15dbde5c1d758c9f9740c69468c511589a" translate="yes" xml:space="preserve">
          <source>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</source>
          <target state="translated">위의 모든 예에서 객체는 반드시 존재해야하며 지정된 작업에 적합한 유형이어야합니다. 객체의 유형을 모르는 경우 다음을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9216f7534e9c31fef68910373cd1fdb3e3fbdb95" translate="yes" xml:space="preserve">
          <source>In an OTP source code tree, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can be constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt;.</source>
          <target state="translated">OTP 소스 코드 트리에서 텍스트 파일 &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt; 에서 OTP 버전을 읽을 수 있습니다 . &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt; 을 호출하여 파일의 절대 경로를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a595d061787336fdc6e9d2d4c2dc217d3ec6e25" translate="yes" xml:space="preserve">
          <source>In an earlier version of this API, the &lt;code&gt;lookup&lt;/code&gt; function received two arguments, omitting &lt;code&gt;Issuer&lt;/code&gt;. For compatibility, this is still supported: if there is no &lt;code&gt;lookup/3&lt;/code&gt; function in the callback module, &lt;code&gt;lookup/2&lt;/code&gt; is called instead.</source>
          <target state="translated">이 API의 이전 버전에서 &lt;code&gt;lookup&lt;/code&gt; 함수는 &lt;code&gt;Issuer&lt;/code&gt; 를 생략하고 두 개의 인수를 받았습니다 . 호환성을 위해이 기능은 계속 지원됩니다. 콜백 모듈에 &lt;code&gt;lookup/3&lt;/code&gt; 기능 이 없으면 &lt;code&gt;lookup/2&lt;/code&gt; 가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b323e21a2ec47acd1da236b19d4a2d70f45bb77d" translate="yes" xml:space="preserve">
          <source>In an embedded system, there is usually no interactive shell. However, an operator can attach to the Erlang system by command &lt;code&gt;to_erl&lt;/code&gt;. The operator is then connected to the Erlang shell and can give ordinary Erlang commands. All interaction with the system through this shell is logged in a special directory.</source>
          <target state="translated">임베디드 시스템에는 일반적으로 대화식 쉘이 없습니다. 그러나 운영자는 &lt;code&gt;to_erl&lt;/code&gt; 명령으로 Erlang 시스템에 연결할 수 있습니다 . 그런 다음 작업자가 Erlang 셸에 연결되고 일반적인 Erlang 명령을 제공 할 수 있습니다. 이 쉘을 통한 시스템과의 모든 상호 작용은 특수 디렉토리에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6affeed9ea78db2ead1d48cc4e80d6afbfafb4eb" translate="yes" xml:space="preserve">
          <source>In an installed OTP development system, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can by constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;releases&quot;,&lt;/code&gt;&lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</source>
          <target state="translated">설치된 OTP 개발 시스템에서 텍스트 파일 &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt; 에서 OTP 버전을 읽을 수 있습니다 . 파일의 절대 경로는 &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;releases&quot;,&lt;/code&gt; &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt; 을 호출하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4061d8e63786063b3eeabb1b52df7fa369545be" translate="yes" xml:space="preserve">
          <source>In an interactive system, the code loader provides demand-driven code loading, but in an embedded system the code loader loads all code immediately. The same version of &lt;code&gt;code&lt;/code&gt; is used in both cases. The code server calls &lt;code&gt;init:get_argument(mode)&lt;/code&gt; to determine if it is to run in demand mode or non-demand driven mode.</source>
          <target state="translated">대화식 시스템에서 코드 로더는 수요 중심 코드로드를 제공하지만 임베디드 시스템에서 코드 로더는 모든 코드를 즉시로드합니다. 두 경우 모두 동일한 버전의 &lt;code&gt;code&lt;/code&gt; 가 사용됩니다. 코드 서버는 &lt;code&gt;init:get_argument(mode)&lt;/code&gt; 를 호출 하여 수요 모드 또는 비 요구 구동 모드에서 실행할지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="40c287b596d5b896af6235aa0ac1f4766bfd7a16" translate="yes" xml:space="preserve">
          <source>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</source>
          <target state="translated">두 경우 모두 현재 토큰이 설정됩니다. 특히, 수신 된 메시지의 토큰이 비어 있으면 프로세스의 현재 토큰이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb81d52aa37dc7833d69efc8ceea8d49076b214" translate="yes" xml:space="preserve">
          <source>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</source>
          <target state="translated">두 경우 모두 테이블의 첫 번째 액세스 가능 요소가 리턴되어야합니다. 키 열에 액세스 할 수 없으므로 세 번째 열이 첫 번째 행임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8bcfe99dfb6ce58aa580ed57d8b7b2260bf8c45" translate="yes" xml:space="preserve">
          <source>In both previous examples, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; resets the trace token immediately after the traced function to avoid many trace messages because of the printouts in the Erlang shell.</source>
          <target state="translated">이전의 두 예제에서 &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; 은 추적 된 함수 바로 다음에 추적 토큰을 재설정하여 Erlang 셸의 출력으로 인해 많은 추적 메시지를 피합니다.</target>
        </trans-unit>
        <trans-unit id="b04f25164a1486f33a08ec5a081e04f72ebc9e3b" translate="yes" xml:space="preserve">
          <source>In both storages, the documentation is written in the exactly same format: an Erlang term serialized to binary via &lt;code&gt; term_to_binary/1&lt;/code&gt;. The term may be optionally compressed when serialized. It must follow the type specification below:</source>
          <target state="translated">두 저장소 모두에서 문서는 정확히 동일한 형식으로 작성됩니다. 즉 &lt;code&gt; term_to_binary/1&lt;/code&gt; 을 통해 바이너리로 직렬화 된 Erlang 용어 입니다. 이 용어는 직렬화 될 때 선택적으로 압축 될 수 있습니다. 아래 유형 사양을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="1e9979f7dc9c90d9448aea9a33897846d951ecc0" translate="yes" xml:space="preserve">
          <source>In brief, &lt;code&gt;Common Test&lt;/code&gt; supports:</source>
          <target state="translated">간단히, &lt;code&gt;Common Test&lt;/code&gt; 는 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="219af38196dae5e5cf8e3928cdad6f56580aeb9d" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to do the following:</source>
          <target state="translated">간단히 말해 CTH를 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7808f617380ab0dd07679578966aad4ed29b5be3" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to:</source>
          <target state="translated">간단히 말해 CTH를 통해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="515fe8110084161af1176bfde998dc3668536ede" translate="yes" xml:space="preserve">
          <source>In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either &lt;strong&gt;succeeds&lt;/strong&gt;, by returning some value (which is ignored), or &lt;strong&gt;fails&lt;/strong&gt;, by throwing an exception.</source>
          <target state="translated">간단히 말해서 간단한 테스트 개체는 인수를 사용하지 않는 단일 함수로 구성됩니다 (일부 추가 메타 데이터 (예 : 줄 번호)로 주석 달기 가능). 함수의 평가는 일부 값을 반환 하여 &lt;strong&gt;성공&lt;/strong&gt; 하거나 (무시 됨) 예외를 발생시켜 &lt;strong&gt;실패합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6c31b5ceac197ebb6de3ed74b4d965acf33272" translate="yes" xml:space="preserve">
          <source>In case of a &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; checking the user, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument.</source>
          <target state="translated">사용자를 확인 하는 &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; 의 경우 atom &lt;code&gt;pubkey&lt;/code&gt; 가 암호 인수에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 필드 의 ReferenceID와 CN 값 사이의 일치 조작의 경우 fun에 대한 첫 번째 인수는 ReferenceID에서 추출 된 호스트 이름이고 두 번째 인수는 &lt;code&gt;Subject&lt;/code&gt; 에서 가져온 튜플 &lt;code&gt;{cn, string()}&lt;/code&gt; 입니다. 들. 따라서 &lt;code&gt;Subject&lt;/code&gt; 필드와 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 필드 에서 제시된 ID에 대해 별도의 일치 규칙을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14abcc78e4a8808dcb7c6c248f2d73041919e75b" translate="yes" xml:space="preserve">
          <source>In case of a sftp request, an sftp server is started in with the user's rights. So it could read, write or delete files if allowed for that user.</source>
          <target state="translated">sftp 요청의 경우 사용자 권한으로 sftp 서버가 시작됩니다. 따라서 해당 사용자에게 허용되는 경우 파일을 읽거나 쓰거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오류 (예 : &lt;code&gt;addr_unreachable&lt;/code&gt; )의 경우 필드 &lt;code&gt;error&lt;/code&gt; 는 더 많은 진단을 제공합니다. 이 경우 이벤트 &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; 에서 반환 한 &lt;code&gt;error&lt;/code&gt; 용어로 자동 변환됩니다 . &lt;code&gt;error&lt;/code&gt; 필드 값을 사용하여 문자열로 변환 할 수있다 &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">오류가 발생하면 모든 계측 기능이 SNMPv1 또는 SNMPv2 오류 코드를 반환 할 수 있습니다. SNMPv2 코드를 리턴하면 SNMPv1 관리자에게 전송되기 전에 SNMPv1 코드로 변환됩니다. 자세한 내용은 모든 계측 기능에 대해 SNMPv2 오류 코드를 사용하는 것이 좋습니다. 오류 코드 변환에 대한 설명은 &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53574543ae936142434ad121e0424851d134f56f" translate="yes" xml:space="preserve">
          <source>In case of an sftp request, an sftp server is started with the rights of the user of the Erlang emulator's OS process. So with sftp the authenticated user does not influence the rights.</source>
          <target state="translated">sftp 요청의 경우 sftp 서버는 Erlang 에뮬레이터의 OS 프로세스 사용자 권한으로 시작됩니다. 따라서 sftp를 사용하면 인증 된 사용자가 권한에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">목록의 경우 퍼센트 인코딩 만 있습니다. 그러나 바이너리에서는 바이너리 인코딩과 퍼센트 인코딩이 모두 고려됩니다. &lt;code&gt;transcode/2&lt;/code&gt; 는 지원되는 인코딩 사이를 변환하는 수단을 제공합니다. &lt;code&gt;uri_string()&lt;/code&gt; 및 인바운드 및 아웃 바운드 인코딩을 지정하는 옵션 목록이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">로드의 경우, 수 모니터링을 &lt;strong&gt;하지&lt;/strong&gt; 유일한 옵션을 사용하여 트리거 얻을 &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; 뿐만 아니라로드 오류가 일시적인 특별한 경우. 따라서 &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; 는 기본적으로 &lt;strong&gt;모든&lt;/strong&gt; 실제 상황에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c09622d21ce9a9b2d2c2d392f9cbc9b05b57cfb1" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;&lt;a href=&quot;#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; is set, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid.</source>
          <target state="translated">의 경우 &lt;code&gt;&lt;a href=&quot;#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; 가 설정되어, 원자 &lt;code&gt;pubkey&lt;/code&gt; 는 공개 키 로그인의 유효성을 검사 할 때 암호 인수에 배치됩니다. 그러면 pwdfun은 사용자 이름이 유효한지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2a8bc8abb7f5d55980d9c87519b99d19822bd2d" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;{direct, exec_fun()}&lt;/code&gt; variant or no exec-option at all, all reads from &lt;code&gt;standard_input&lt;/code&gt; will be from the received data-events of type 0. Those are sent by the client. Similarily all writes to &lt;code&gt;standard_output&lt;/code&gt; will be sent as data-events to the client. An OS shell client like the command 'ssh' will usally use stdin and stdout for the user interface.</source>
          <target state="translated">의 경우 &lt;code&gt;{direct, exec_fun()}&lt;/code&gt; 변형 또는 전혀 간부-옵션 모두에서 읽어 &lt;code&gt;standard_input&lt;/code&gt; 사람들은 클라이언트에 의해 전송되는 0을 입력의 수신 된 데이터-이벤트에서있을 것입니다. 마찬가지로 &lt;code&gt;standard_output&lt;/code&gt; 에 대한 모든 쓰기는 데이터 이벤트로 클라이언트에 전송됩니다. 'ssh'명령과 같은 OS 셸 클라이언트는 일반적으로 사용자 인터페이스에 stdin 및 stdout을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Subject&lt;/code&gt; 인증서 필드 에서 제시된 ID를 가져 오는 경우 이름에 와일드 카드 문자가 포함될 수 있습니다. 이 기능은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; 정의 된대로이를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OctetString () 및 파생 유형에 대해 string () 및 binary () 유형 중에서 선택할 수있는 경우, 표현은 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; 의 값에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">제목 문자열에 줄 바꿈이 포함되어 있지 않은 것으로 알려진 경우 &lt;code&gt;dotall&lt;/code&gt; 을 설정 하여이 최적화를 얻거나 ^을 사용하여 명시 적으로 앵커를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">표준 입력 및 / 또는 표준 출력을 리디렉션하거나 파이프 라인에서 Erlang을 사용하려는 경우 &lt;code&gt;werl&lt;/code&gt; 이 적합하지 않으며 &lt;code&gt;erl&lt;/code&gt; 프로그램이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">특정 출력 함수 및 쉘의 리턴 값 출력에서 ​​Erlang은 경험적으로 목록 및 이진에서 문자열 데이터를 감지하려고 시도합니다. 일반적으로 다음과 같은 상황에서 휴리스틱 탐지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">특정 상황에서, 특히 표준 출력이 리디렉션 될 때 오류 메시지에 특정한 I / O 서버에 대한 액세스가 편리 할 수 ​​있습니다. I / O 장치 &lt;code&gt;standard_error&lt;/code&gt; 를 사용하여 현재 운영 체제가 오류 출력에 적합한 I / O 장치로 간주하는 모든 항목으로 출력을 보낼 수 있습니다. 유닉스 계열 운영 체제의 예 :</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">와 결합 &lt;code&gt;{locations, true}&lt;/code&gt; 이 옵션은 각 항목에 대한 통계와 함께 잠금 작업 소스 파일과 줄 번호 엔트리 포인트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 또는 &lt;code&gt;-MF&lt;/code&gt; 옵션과 함께 각 종속성에 대한 가짜 대상을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;-M&lt;/code&gt; 또는 &lt;code&gt;-MF&lt;/code&gt; 와 함께 생성 된 규칙의 이름을 &lt;code&gt;Target&lt;/code&gt; 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 또는 &lt;code&gt;-MF&lt;/code&gt; 옵션과 함께 누락 된 헤더를 생성 된 파일로 간주하여 종속성에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">RPC와 달리 다중 호출은 한 클라이언트에서 여러 서버로 동시에 전송되는 RPC입니다. 이는 노드 세트에서 정보를 수집하거나 일부 부작용을 달성하기 위해 노드 세트에서 함수를 호출하는 데 유용합니다. 의미 적으로 모든 노드에서 일련의 RPC를 반복적으로 만드는 것과 동일하지만 모든 요청이 동시에 전송되고 돌아올 때 하나씩 하나씩 수집되므로 다중 호출이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">대부분의 다른 콜백 함수와 &lt;code&gt;stop_select&lt;/code&gt; 는 모든 포트와 독립적으로 호출됩니다. &lt;code&gt;ErlDrvData&lt;/code&gt; 인수가 함수에 전달 되지 않았습니다 . 드라이버 잠금 또는 포트 잠금은 유지되지 않습니다. 라고하는 포트 &lt;code&gt;driver_select&lt;/code&gt; 가 도 시간에 마감 될 수 &lt;code&gt;stop_select&lt;/code&gt; 이 라고합니다. 그러나 &lt;code&gt;stop_select&lt;/code&gt; 가 &lt;code&gt;erl_driver:driver_select&lt;/code&gt; 에 의해 직접 호출 되는 경우도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">대조적으로, 번호가 매겨진 서브 패턴에 대한 서브 루틴 호출은 항상 주어진 번호를 가진 패턴에서 첫 번째를 참조합니다. 다음 패턴은 &quot;abcabc&quot;또는 &quot;defabc&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">크래시 덤프에서는 스택, 메시지 및 프로세스 사전이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b30e844f19c774b16c52548000fcb4af87d281" translate="yes" xml:space="preserve">
          <source>In decryption, the &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; removes such padding, if present. The &lt;code&gt;&lt;a href=&quot;#type-otp_padding&quot;&gt;otp_padding&lt;/a&gt;&lt;/code&gt; is not removed - it has to be done elsewhere.</source>
          <target state="translated">복호화에서 &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; 은 이러한 패딩이있는 경우이를 제거합니다. &lt;code&gt;&lt;a href=&quot;#type-otp_padding&quot;&gt;otp_padding&lt;/a&gt;&lt;/code&gt; 는 다른 곳 수행해야합니다 - 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">더티 컨텍스트, 즉 &lt;code&gt;sync_dirty&lt;/code&gt; 또는 &lt;code&gt;async_dirty&lt;/code&gt; 에서 수정 된 레코드는 로컬 사본에 저장되지 않습니다. 대신 각 레코드가 개별적으로 업데이트됩니다. 테이블에 다른 노드에 복제본이 있고 더티 작업에 발생하는 다른 모든 단점이있는 경우 많은 네트워크 트래픽이 생성됩니다. 특히 &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; 명령의 경우 , &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; 에 대해 이전에 설명한 것과 동일한 단점이 적용됩니다. 즉, 반복 중에 테이블에 대한 쓰기는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">각 &lt;code&gt;Viewer&lt;/code&gt; 에는 활성 필터가 하나만 있으며, &lt;code&gt;Collector&lt;/code&gt; 에서 &lt;code&gt;Viewer&lt;/code&gt; 가 가져 오는 모든 추적 &lt;code&gt;Events&lt;/code&gt; 는 해당 필터를 통해 전달됩니다. 영리한 필터를 작성 하면 뷰어에서 &lt;code&gt;Events&lt;/code&gt; 가 표시되는 방식을 사용자 정의 할 수 있습니다 . &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; 의 다음 필터 는 액터 이름 &lt;code&gt;mnesia_tm&lt;/code&gt; 및 &lt;code&gt;mnesia_locker&lt;/code&gt; 를 대체 하고 레코드에 다른 모든 것을 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">각 반복에서 바이너리의 처음 8 비트는 건너 뛰지 않고 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">이전 Erlang / OTP 릴리스에서 너무 큰 바이너리에 대한 작업은 일반적으로 실패하거나 잘못된 결과를 제공합니다. 다음 릴리스에서는 바이너리를 만드는 다른 작업 (예 : &lt;code&gt;list_to_binary/1&lt;/code&gt; )도 같은 제한을 적용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">두 경우 모두 에이전트는 아무 것도 수행하지 않지만 검색된 ManagerEngineID를 반환하고 ( 자세한 정보 는 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 참조 ) 감지 프로세스의 2 단계를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">내장 모드에서는 모든 스크립트가 부팅 스크립트에 따라 시스템 시작 중에로드됩니다. 나중에 코드 서버에 명시 적으로 주문하여 코드를로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">내장 모드에서는 먼저 모든 모듈이로드됩니다. 그런 다음 모든 &lt;code&gt;on_load&lt;/code&gt; 함수가 호출됩니다. 모든 &lt;code&gt;on_load&lt;/code&gt; 함수가 &lt;code&gt;ok&lt;/code&gt; 를 반환 하지 않으면 시스템이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">내장 모드에서는 모듈이 자동으로로드되지 않습니다. 로드되지 않은 모듈을 사용하려고하면 오류가 발생합니다. 이 모드는 부트 스크립트가 일반적으로 OTP 릴리스에서 수행되므로 모든 모듈을로드 할 때 권장됩니다. 코드 서버에서 명시 적으로 주문하여 나중에 코드를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1f53217834ce9f061b0ce0f9fd6ed43fb29178a" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt; erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">제한된 양의 RAM이 있고 가상 메모리가없는 임베디드 시스템에서는 &lt;code&gt;Number&lt;/code&gt; 를 0 으로 설정 하여 메모리를 보존 할 수 있습니다 . (값은 전역으로 설정할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt; erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RAM이 적고 가상 메모리가없는 내장 시스템에서는 &lt;code&gt;Number&lt;/code&gt; 를 0 으로 설정 하여 메모리를 보존 할 수 있습니다 . (값은 전체적으로 설정할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">본질적으로, 함수는 동일한 동작을 수행 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 을 하지만, 대신에 사용하는 &lt;code&gt;ei_x_buff&lt;/code&gt; 를 함수는 문자 포인터 (포인터 기대 &lt;code&gt;mbufp&lt;/code&gt; 문자 포인터에 의해 할당 된 메모리 영역에 점이다) &lt;code&gt;malloc&lt;/code&gt; . 인수 &lt;code&gt;bufsz&lt;/code&gt; 는 메모리 영역의 정확한 크기 (바이트)를 포함하는 정수에 대한 포인터입니다. 이러한 경우에 메모리 영역과 의지를 재 할당 할 수있는 기능은 새 크기를 넣어 &lt;code&gt;*bufsz&lt;/code&gt; 및 업데이트 &lt;code&gt;*mbufp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">&lt;code&gt;DocumentRoot&lt;/code&gt; 또는 &lt;code&gt;Alias&lt;/code&gt; 아래의 모든 디렉토리에서 사용자는 액세스 파일을 배치 할 수 있습니다. 액세스 파일은 웹 서버가 요청에 응답하기 전에 고려해야 할 제한 사항을 지정하는 일반 텍스트 파일입니다. 요청 된 자산의 경로에 둘 이상의 액세스 파일이있는 경우 자산에 가장 가까운 디렉토리에있는 액세스 파일의 지시문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">실제로 임의의 데이터가 캐시되므로 시도하면 일부 숫자가 재생산 될 수 있지만 이는 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">운 좋게도 불일치는 특정 응용 프로그램에 속하는 테이블에서만 볼 수 있습니다. 그러나 강제 트랜잭션 복구 결정으로 인해 스키마 트랜잭션이 일관되지 않게 복구되면 불일치의 영향이 치명적일 수 있습니다. 그러나 높은 우선 순위가 일관성이 아닌 가용성 인 경우 위험 할만한 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">일반적으로 버그는 최신 &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; 에서만 수정 되며 새로운 기능은 개발중인 다음 릴리스에 도입되었습니다. 그러나 내부 이유로 인해 이전 릴리스의 버그를 수정하면 해당 버그도 사용 가능하고 발표됩니다.</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">일반적으로 일치하는 값이 할당되지 않은 하위 패턴은 &lt;code&gt;type&lt;/code&gt; 이 &lt;code&gt;index&lt;/code&gt; 일 때 튜플 &lt;code&gt;{-1,0}&lt;/code&gt; 로 반환됩니다 . 할당되지 않은 하위 패턴은 다른 반환 유형에 대해 각각 빈 이진 또는 목록으로 반환됩니다. 다음 정규식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="264b6524a328aed18af181468f92444ef5d0e1cd" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;ei&lt;/code&gt; library is guaranteed to be compatible with other Erlang/OTP components that are 2 major releases older or newer than the &lt;code&gt;ei&lt;/code&gt; library itself.</source>
          <target state="translated">일반적으로 &lt;code&gt;ei&lt;/code&gt; 라이브러리는 &lt;code&gt;ei&lt;/code&gt; 라이브러리 자체 보다 이전 버전이거나 최신 버전 인 2 개의 주요 릴리스 인 다른 Erlang / OTP 구성 요소와 호환되도록 보장 됩니다.</target>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">일반적으로 시간 초과를 사용하여 분산 Erlang 시스템의 일부를 감독하는 것보다 더 나은 방법이 있습니다. 시간 초과는 일반적으로 외부 이벤트를 감독하는 데 적합합니다 (예 : 지정된 시간 내에 일부 외부 시스템에서 메시지를 예상 한 경우). 예를 들어, 사용자가 메신저 시스템에 액세스하지 않은 경우 (예 : 10 분) 시간 초과를 사용하여 메신저 시스템에서 로그 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">일반적으로 튜플은 &quot;레코드&quot;또는 &quot;구조체&quot;가 다른 언어로 사용되는 경우에 사용됩니다. 또한, 크기는 다양한 크기, 즉 링크 된 목록이 다른 언어로 사용되는 것을 나타낼 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">일반적으로 버전은 3 개 이상의 부분을 가질 수 있습니다. 그런 다음 버전은 부분적으로 만 주문됩니다. 이러한 버전은 예외적 인 경우에만 사용됩니다. 추가 부품 (일반 3 개 부품 중)이 버전 번호에 추가되면 새 버전의 분기가 작성됩니다. 새 브랜치는 기본 버전에 대해 선형 순서를 갖습니다. 그러나 다른 브랜치의 버전에는 순서가 없으므로 가장 가까운 공통 조상에 포함 된 내용이 모두 포함되어 있다고 결론을 내릴 수 있습니다. 동일한 기본 버전에서 여러 번 분기하는 경우 고유 버전을 찾을 때까지 기본 버전과 최하위 &lt;code&gt;1&lt;/code&gt; 개 부품 사이에 &lt;code&gt;0&lt;/code&gt; 개의 부품이 추가 됩니다. 순서가있는 버전은 이전 단락에서 설명한대로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba987c1f9181380720aed267fac74a6f9ee0f607" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used when branching off from another branch. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">일반적으로 버전은 세 부분 이상을 가질 수 있습니다. 버전은 부분적으로 만 주문됩니다. 이러한 버전은 다른 분기에서 분기 할 때만 사용됩니다. 추가 부품 (일반 세 부품 중)이 버전 번호에 추가되면 새 버전 분기가 만들어집니다. 새 분기는 기본 버전에 대해 선형 순서를 갖습니다. 그러나 서로 다른 브랜치의 버전은 순서가 없으므로 가장 가까운 공통 조상에 포함 된 것이 모두 포함되어 있다고 결론을 내릴 수 있습니다. 동일한 기본 버전에서 여러 번 분기하는 경우 고유 한 버전을 찾을 때까지 기본 버전과 최하위 &lt;code&gt;1&lt;/code&gt; 개 부분 사이에 &lt;code&gt;0&lt;/code&gt; 개 부분이 추가 됩니다. 주문이있는 버전은 이전 단락에 설명 된대로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">글로벌 추적 모드에서 콜렉터는 연결된 모든 Erlang 노드에서 자동으로 추적을 시작합니다. 노드가 연결되면 해당 노드에서 포트 추적기가 시작되고 콜렉터 노드에서 해당 추적 클라이언트가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="f00745ad8caa1afca6bdd4f2b710aba925b97dcb" translate="yes" xml:space="preserve">
          <source>In instructions that will not always execute the next instruction. For example:</source>
          <target state="translated">항상 다음 명령어를 실행하지 않는 명령어에서. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">대화식 모드에서 코드는 처음 참조 할 때 동적으로로드됩니다. 모듈에서 함수를 호출하고 모듈이로드되지 않으면 코드 서버는 코드 경로를 검색하여 모듈을 시스템에로드합니다.</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">대화식 모드에서 코드 서버 는 모듈 목록을로드 할 때 순차적으로 검색하는 디렉토리 목록으로 구성된 검색 경로 (일반적으로 &lt;strong&gt;코드 경로)를&lt;/strong&gt; 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">대화식 모드 (기본값)에서는 시스템 시작 중에 기본적으로 런타임 시스템에 필요한 모듈 중 일부 코드 만로드됩니다. 다른 코드는 처음 참조 할 때 동적으로로드됩니다. 특정 모듈에서 함수를 호출하고 모듈이로드되지 않으면 코드 서버는 모듈을 검색하여로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">가장 간단한 형식에서 &lt;code&gt;match_spec&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">로컬 모드에서 코드는 현재 노드에서만 해석됩니다. 전역 모드에서 코드는 알려진 모든 노드에서 해석됩니다. 해석 된 코드를 실행하는 다른 노드의 프로세스는 모니터 창에 자동으로 표시되며 다른 디버깅 된 프로세스와 마찬가지로 첨부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">메모리 부족 시스템 (특히 가상 메모리가없는 시스템)에서 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하면 메모리를 절약하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">많은 응용 프로그램에서 트랜잭션 처리 오버 헤드로 인해 성능이 저하 될 수 있습니다. 더티 작업은 많은 처리를 우회하고 트랜잭션 속도를 높이는 지름길입니다.</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">많은 시스템에서 오버로드 된 큐의 임시 상태는 정상입니다. 이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 한다고해서 다른 노드가 응답하지 않는 것은 아니지만 일시적인 과부하 일 수 있습니다. 또한 반환 값이 &lt;code&gt;true&lt;/code&gt; 인 것은 차단없이 (TCP) 채널에서 메시지를 보낼 수 있다는 의미 일뿐입니다. 메시지가 원격 노드에 도착한다고 보장되지는 않습니다. 연결이 끊긴 비 응답 노드의 경우 반환 값은 &lt;code&gt;true&lt;/code&gt; 입니다 (연산자 &lt;code&gt;!&lt;/code&gt; 의 동작과 유사 함 ). 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때 예상되는 동작 및 수행 할 작업 은 응용 프로그램 및 하드웨어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">일치하는 경우이 기본값은 마지막 요소에만 유효합니다. 일치하는 다른 모든 비트 문자열 또는 이진 요소의 크기 사양이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">마이크로 초</target>
        </trans-unit>
        <trans-unit id="74df42bf134f27883f855d9ef2904cba9dbfb304" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;verify_none&lt;/code&gt; 모드 에서 기본 동작은 모든 x509 경로 유효성 검사 오류를 허용하는 것입니다. &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt; 옵션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;verify_none&lt;/code&gt; 모드 에서 기본 동작은 모든 x509 경로 유효성 검사 오류를 허용하는 것입니다. 또한 &lt;code&gt;verify_fun&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">보다 기술적 인 용어로, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; 는 프로세스의 호출 스택을 버리고 가비지가 프로세스를 수집합니다. 이후 모든 라이브 데이터는 하나의 연속 힙에 있습니다. 그런 다음 힙은 보유하고있는 라이브 데이터와 정확히 동일한 크기로 축소됩니다 (해당 크기가 프로세스의 최소 힙 크기보다 작더라도).</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 주소 계열을 사용할 수있는 대부분의 API 함수에서 포트 번호는 &lt;code&gt;0&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;RootDir&lt;/code&gt; 매개 변수는 &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (또는 구성 매개 변수가 설정되지 않은 경우 &lt;code&gt;code:root_dir()&lt;/code&gt; 호출에 사용 된 &lt;code&gt;root_dir&lt;/code&gt; 구성 매개 변수 와 동일하게 설정해야합니다 . 경우에 따라 다른 루트 디렉토리에 대해 동일한 대상 사양을 평가하는 것이 유용 할 수 있습니다. 그러나 모든 루트에서 동등한 파일 구조가 필요하므로 매우주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">일반 모드에서 사용자의 키 입력은 &lt;code&gt;tty&lt;/code&gt; 에 의해 수집되고 해석됩니다 . 대부분의 &lt;strong&gt;Emacs&lt;/strong&gt; 라인 편집 명령이 지원됩니다. 다음은 지원되는 라인 편집 명령의 전체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">정상적인 작동에서 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 통화는 거의 무료입니다. 추적이 필요한 경우 이러한 기능에 대한 추적을 명시 적으로 활성화 할 수 있습니다. 또는 당신의 사용을 결합 할 수 있습니다 &lt;code&gt;trace_global&lt;/code&gt; 을 의 사용과 &lt;code&gt;trace_pattern&lt;/code&gt; . 설정하면 &lt;code&gt;trace_pattern&lt;/code&gt; 이 연결된 모든 노드에서 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="eae1f10c8b9d4c5e175d3fc8937d4ffde9c0f51a" translate="yes" xml:space="preserve">
          <source>In order for an &lt;code&gt;erpc&lt;/code&gt; operation to succeed, the remote node also needs to support &lt;code&gt;erpc&lt;/code&gt;. Typically only ordinary Erlang nodes as of OTP 23 have &lt;code&gt;erpc&lt;/code&gt; support.</source>
          <target state="translated">위해서는 &lt;code&gt;erpc&lt;/code&gt; 의 작업이 성공하는 원격 노드는 지원해야 &lt;code&gt;erpc&lt;/code&gt; 을 . 일반적으로 OTP 23부터 일반 Erlang 노드 만 &lt;code&gt;erpc&lt;/code&gt; 를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">구현에서 향상된 SNMPv2 오류 코드를 완전히 활용하려면 오류가 발생할 경우 계측 기능이 항상 SNMPv2 오류 코드를 반환해야합니다. 필요한 경우 에이전트가 해당 SNMPv1 오류 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="91f9f99c50f34dfe6347f220890a64d23f9ce151" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">Erlang 드라이버 스레드 API가 작동하려면 런타임 시스템에서 스레드 지원을 활성화해야합니다. Erlang 드라이버는 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; 를 사용하여 스레드 지원이 활성화되었는지 확인할 수 있습니다 . Erlang 드라이버 API의 일부 함수는 런타임 시스템이 SMP를 지원하는 경우에만 스레드로부터 안전 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; 정보는 driver_system_info를 통해 검색 할 수도 있습니다 . 또한 통지 얼랭 드라이버 API의 많은 기능이 있다고 &lt;strong&gt;하지&lt;/strong&gt; 관계없이 SMP 지원이 활성화되어 있는지의 여부, 스레드 안전합니다. 함수가 스레드로부터 안전한 것으로 문서화 &lt;strong&gt;되지 않은 경우&lt;/strong&gt; 스레드로부터 안전 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">Erlang 드라이버 스레드 API가 작동하려면 런타임 시스템에서 스레드 지원이 사용 가능해야합니다. Erlang 드라이버는 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 를 사용하여 스레드 지원이 사용 가능한지 확인할 수 있습니다 . Erlang 드라이버 API의 일부 기능은 런타임 시스템이 SMP를 지원하는 경우에만 스레드로부터 안전하며 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 를 통해이 정보를 검색 할 수 있습니다 . 또한 통지 얼랭 드라이버 API의 많은 기능이 있다고 &lt;strong&gt;하지&lt;/strong&gt; 관계없이 SMP 지원이 활성화되어 있는지의 여부, 스레드 안전합니다. 함수가 스레드 안전으로 문서화되지 않은 경우 스레드 안전 상태가 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">중단 / 계속 기능이 작동 하려면 &lt;code&gt;Common Test&lt;/code&gt; &lt;code&gt;stdin&lt;/code&gt; 을 제어하는 쉘 프로세스를 해제해야합니다 . 시작 옵션 &lt;code&gt;release_shell&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하면됩니다 . 자세한 내용 은 사용자 안내서 &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; 에서 테스트 실행 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e5ab42b46c29034052cc72be40b7ac14c2d1e1e" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt; +sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이 스케줄러를 바인드 할 수 있으려면 CPU 토폴로지를 알아야합니다. 런타임 시스템이 CPU 토폴로지를 자동으로 감지하지 못하는 경우이를 정의 할 수 있습니다. CPU 토폴로지를 정의하는 방법에 대한 자세한 내용 은 &lt;code&gt;erl(1)&lt;/code&gt; 명령 줄 플래그 &lt;code&gt; +sct&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템이 스케줄러를 바인드 할 수 있으려면 CPU 토폴로지를 알아야합니다. 런타임 시스템이 CPU 토폴로지를 자동으로 감지하지 못하면 정의 할 수 있습니다. CPU 토폴로지를 정의하는 방법에 대한 자세한 내용 은 &lt;code&gt;erl(1)&lt;/code&gt; 명령 줄 플래그 &lt;code&gt;+sct&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">이 기능이 제대로 작동하려면 다음 두 가지 요구 사항이 충족되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7316234f8d0404e7bccb8d56aec4837d25e8e904" translate="yes" xml:space="preserve">
          <source>In order to allow minimizing the performance loss, the &lt;code&gt;file_check&lt;/code&gt; parameter can be set to a positive integer value, &lt;code&gt;N&lt;/code&gt;. The handler will then skip reading the file information prior to writing, as long as no more than &lt;code&gt;N&lt;/code&gt; milliseconds have passed since it was last read.</source>
          <target state="translated">성능 손실을 최소화하기 위해 &lt;code&gt;file_check&lt;/code&gt; 매개 변수를 양의 정수 값 &lt;code&gt;N&lt;/code&gt; 으로 설정할 수 있습니다 . 그런 다음 핸들러 는 마지막으로 읽은 이후 &lt;code&gt;N&lt;/code&gt; 밀리 초를 넘지 않는 한 쓰기 전에 파일 정보 읽기를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">이 데이터를 motorcycles.xml 문서의 끝에 추가하려면 파일을 구문 분석하고 루트 요소 컨텐츠의 끝에 데이터를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="1cc2af703c741622a9752f6130d1aed382c381ac" translate="yes" xml:space="preserve">
          <source>In order to avoid these situations we wanted to be able to do most of the fundamental operations on a process without having to acquire a lock on the process. Some examples of such fundamental operations are, moving a process between run queues, detecting if we need to insert it into a run queue or not, detecting if it is alive or not.</source>
          <target state="translated">이러한 상황을 피하기 위해 우리는 프로세스에 대한 잠금을 획득하지 않고도 프로세스에 대한 대부분의 기본 작업을 수행 할 수 있기를 원했습니다. 이러한 기본적인 작업의 몇 가지 예는 실행 큐 사이에서 프로세스 이동, 실행 큐에 삽입해야하는지 여부 감지, 활성 여부 감지입니다.</target>
        </trans-unit>
        <trans-unit id="9606b78a849c5b14fbde9a528c5423519c626033" translate="yes" xml:space="preserve">
          <source>In order to be able to decide which run queue to use without having to lock any run queues, we moved all fixed balancing information out of the run queues into a global memory block. That is, migration paths and run queue limits. Information that need to be frequently updated, like for example maximum run queue length, were kept in the run queue, but instead of operating on this information under locks we now use atomic memory operations when accessing this information. This made it possible to first determine which run queue to use, without locking any run queues, and when decided, lock the chosen run queue and insert the process.</source>
          <target state="translated">실행 큐를 잠그지 않고 사용할 실행 큐를 결정할 수 있도록 실행 큐에서 모든 고정 균형 정보를 전역 메모리 블록으로 이동했습니다. 즉, 마이그레이션 경로 및 실행 큐 제한입니다. 예를 들어 최대 실행 큐 길이와 같이 자주 업데이트해야하는 정보는 실행 큐에 보관되었지만 잠금 상태에서이 정보에 대해 작업하는 대신 이제이 정보에 액세스 할 때 원자 메모리 작업을 사용합니다. 이를 통해 실행 큐를 잠그지 않고 사용할 실행 큐를 먼저 결정하고, 결정되면 선택한 실행 큐를 잠그고 프로세스를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c4f9a3c32af1c0aebd8c724db9f1fd7c9cd27f7" translate="yes" xml:space="preserve">
          <source>In order to be able to detect when it is safe to deallocate a previously used process structure, reference counting of the structure was used. Also this was problematic, since simultaneous lookups needed to modify the reference counter which also caused contention on the cache line where the reference counter was located. This since all modifications needs to be communicated between all involved processors.</source>
          <target state="translated">이전에 사용 된 프로세스 구조를 할당 해제하는 것이 안전한시기를 감지 할 수 있도록 구조의 참조 카운팅이 사용되었습니다. 또한 동시 조회를 통해 참조 카운터를 수정해야했기 때문에 참조 카운터가 위치한 캐시 라인에서 경합이 발생했습니다. 이는 모든 수정 사항이 관련된 모든 프로세서간에 전달되어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="248b6946fb3d78aedfd7eb1945dab3d08fcb73b1" translate="yes" xml:space="preserve">
          <source>In order to be able to determine when all managed threads have reached the states that we are interested in we need to communicate between all involved threads. We of course want to minimize this communication.</source>
          <target state="translated">모든 관리 스레드가 우리가 관심있는 상태에 도달 한시기를 확인할 수 있으려면 관련된 모든 스레드간에 통신해야합니다. 물론 우리는 이러한 의사 소통을 최소화하고자합니다.</target>
        </trans-unit>
        <trans-unit id="b21c20f0ab3dedd86e0307763e8d967cc669941c" translate="yes" xml:space="preserve">
          <source>In order to be able to remove a carrier from one allocator instance and add it to another we need to be able to move references to the free blocks of the carrier between the allocator instances. The allocator instance specific data structure referring to the free blocks it manages often refers to the same carrier from multiple places. For example, when the address order best-fit strategy is used this data structure is a binary search tree spanning all carriers that the allocator instance manages. Free blocks in one specific carrier can be referred to from potentially every other carrier that is managed, and the amount of such references can be huge. That is, the work of removing the free blocks of such a carrier from the search tree will be huge. One way of solving this could be not to migrate carriers that contain lots of free blocks, but this would prevent us from migrating carriers that potentially need to be migrated in order to solve the problem we set out to solve.</source>
          <target state="translated">하나의 할당 자 인스턴스에서 캐리어를 제거하고 다른 인스턴스에 추가 할 수 있으려면 할당 자 인스턴스간에 캐리어의 사용 가능한 블록에 대한 참조를 이동할 수 있어야합니다. 관리하는 자유 블록을 참조하는 할당 자 인스턴스 특정 데이터 구조는 종종 여러 위치에서 동일한 캐리어를 참조합니다. 예를 들어, 주소 순서 최적 전략이 사용되는 경우이 데이터 구조는 할당 자 인스턴스가 관리하는 모든 캐리어에 걸친 이진 검색 트리입니다. 하나의 특정 캐리어의 자유 블록은 잠재적으로 관리되는 다른 모든 캐리어에서 참조 될 수 있으며 이러한 참조의 양은 엄청날 수 있습니다. 즉, 검색 트리에서 그러한 캐리어의 여유 블록을 제거하는 작업은 엄청날 것입니다. 이를 해결하는 한 가지 방법은 사용 가능한 블록이 많은 캐리어를 마이그레이션하지 않는 것입니다.그러나 이것은 우리가 해결하기 위해 설정 한 문제를 해결하기 위해 잠재적으로 마이그레이션해야하는 이동 통신사를 마이그레이션하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">Erlang 코드를 컴파일하려면 작은 Erlang 부트 스트랩 시스템을 구축해야하거나, 구축 된 시스템과 동일한 릴리스의 Erlang / OTP 시스템을 &lt;code&gt;$PATH&lt;/code&gt; 제공해야합니다 . 대상 시스템의 Erlang / OTP는이 Erlang 시스템을 사용하여 제공된 크로스 컴파일 도구와 함께 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="33c36db64d09c1349048183a11365e092986cc43" translate="yes" xml:space="preserve">
          <source>In order to determine when the events has happened we use a global counter that is incremented when all managed threads have called &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; (or &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt;). This could naively be implemented using a &quot;thread confirmed&quot; counter. This would however cause an explosion of communication where all involved processors would need to communicate with each other at each update.</source>
          <target state="translated">이벤트가 언제 발생했는지 확인하기 위해 모든 관리 스레드가 &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; (또는 &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt; )를 호출 할 때 증가하는 전역 카운터를 사용합니다 . 이것은 &quot;스레드 확인&quot;카운터를 사용하여 순진하게 구현 될 수 있습니다. 그러나 이것은 모든 관련 프로세서가 각 업데이트에서 서로 통신해야하는 통신 폭발을 야기합니다.</target>
        </trans-unit>
        <trans-unit id="fa8bd01b2e2143b89a5d070a42db3498a1a3a7f5" translate="yes" xml:space="preserve">
          <source>In order to ensure data integrity, mutex'es are taken when needed. So, do not call this function often.</source>
          <target state="translated">데이터 무결성을 보장하기 위해 필요할 때 뮤텍스를 사용합니다. 따라서이 함수를 자주 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3bbb01425e78fa9829f765ceacdcbc84ac1251f2" translate="yes" xml:space="preserve">
          <source>In order to fit better into your existing logging infrastructure Logger can format its logging messages any way you want to. Either you can use the built-in formatter, or you can build your own.</source>
          <target state="translated">기존 로깅 인프라에 더 잘 맞도록 Logger는 원하는 방식으로 로깅 메시지를 형식화 할 수 있습니다. 내장 포맷터를 사용하거나 직접 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">내부 형식을 완전히 이해하려면 Megaco / H.248 프로토콜에 대한 ASN.1 사양을 유지하고 위의 규칙을 적용해야합니다. ASN.1과 해당 내부 형식 간의 매핑 시맨틱에 대한 자세한 내용은 Erlang / OTP의 ASN.1 컴파일러 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">추적을 더욱 단순화하기 위해 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 함수를 사용할 수 있습니다 . 이러한 기능은 응용 프로그램에 강조 표시해야 할 흥미로운 &lt;code&gt;Events&lt;/code&gt; 가있을 때 다른 응용 프로그램에서 호출하기위한 것 입니다. 원자를 돌려주는 것 외에는 아무것도하지 않기 때문에 함수는 매우 가볍습니다. 이러한 기능은 특별히 추적하도록 설계되었습니다. 호출자가 명시 적으로 &lt;code&gt;Event Record&lt;/code&gt; 필드 값을 제공하므로 기본 &lt;code&gt;Collector Filter&lt;/code&gt; 는 사용자 정의 필터 기능없이 사용자 정의 된 &lt;code&gt;Event Record&lt;/code&gt; 를 자동으로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d72fdffcde207532623f4383c3bcc9252d8eb8ee" translate="yes" xml:space="preserve">
          <source>In order to implement delay of thread progress from unmanaged threads we use two reference counters. One being &lt;code&gt;current&lt;/code&gt; and one being &lt;code&gt;waiting&lt;/code&gt;. When an unmanaged thread wants to delay thread progress it increments &lt;code&gt;current&lt;/code&gt; and gets a handle back to the reference counter it incremented. When it later wants to enable continuation of thread progress it uses the handle to decrement the reference counter it previously incremented.</source>
          <target state="translated">관리되지 않는 스레드에서 스레드 진행 지연을 구현하기 위해 두 개의 참조 카운터를 사용합니다. 하나는 &lt;code&gt;current&lt;/code&gt; 이고 하나는 &lt;code&gt;waiting&lt;/code&gt; 있습니다. 관리되지 않는 스레드가 스레드 진행을 지연 시키려면 &lt;code&gt;current&lt;/code&gt; 증가 시키고 증가한 참조 카운터에 대한 핸들을 다시 가져옵니다. 나중에 스레드 진행을 계속하려면 핸들을 사용하여 이전에 증가시킨 참조 카운터를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="03fc72bd9eea1c19e5c0da63c18725fd1977b35e" translate="yes" xml:space="preserve">
          <source>In order to improve this, state information was re-organized in the port structer, so that we can access it using atomic memory operations. This together with the new port table implementation, enabled us to lookup the port and inspect the state before acquiring the port lock, which in turn made it possible to perform preparations of signal data before acquiring the port lock.</source>
          <target state="translated">이를 개선하기 위해 포트 구조자에서 상태 정보를 재구성하여 원자 메모리 작업을 사용하여 액세스 할 수 있습니다. 이를 통해 새로운 포트 테이블 구현과 함께 포트 잠금을 획득하기 전에 포트를 조회하고 상태를 검사 할 수 있었으며,이를 통해 포트 잠금을 획득하기 전에 신호 데이터 준비를 수행 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">외부 참조를 쉽게 사용할 수 있도록하기 위해 몇 가지 일반적인 작업을 수행하는 사전 정의 된 분석이 있습니다. 일반적으로 정의되지 않은 함수에 대한 호출을 모듈 또는 릴리스에서 확인할 수 있습니다. 다소 고급 사용자에게는 분석 된 시스템의 일부를 선택하고 선택된 호출에 대한 간단한 그래프 분석을 수행하는 데 사용할 수있는 작지만 융통성있는 언어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aea5444714eb91d126874c6a93a730087a09d9a5" translate="yes" xml:space="preserve">
          <source>In order to migrate carriers between allocator instances we move them through a pool of carriers. In order for a carrier migration to complete, one scheduler needs to move the carrier into the pool, and another scheduler needs to take the carrier out of the pool.</source>
          <target state="translated">할당 자 인스턴스간에 캐리어를 마이그레이션하기 위해 캐리어 풀을 통해 캐리어를 이동합니다. 캐리어 마이그레이션을 완료하려면 한 스케줄러가 캐리어를 풀로 이동해야하고 다른 스케줄러는 캐리어를 풀에서 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">초기 메시지, 서비스 변경 요청의 전송을 위해 MG를 준비하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">초기 메시지, 서비스 변경 요청을 수신하기 위해 MGC를 준비하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="45fb88d2abad8087318cf9186878fe028a795bdf" translate="yes" xml:space="preserve">
          <source>In order to prevent multiple schedulers from trying to execute signals to/from the same port simultaneously, we need to be able to ensure that all signals to/from a port are executed in sequence on one scheduler. More or less, the only way to do this is to schedule all types of signals. Signals corresponding to a port can then be executed in sequence by one single scheduler thread. If only one thread tries to execute the port, no contention will appear on the port lock. Besides getting rid of the contention, processes sending signals to the port can also continue execution of their own Erlang code on other schedulers at the same time as the signaling code is executing on another scheduler.</source>
          <target state="translated">여러 스케줄러가 동일한 포트로 /에서 동시에 신호를 실행하지 못하도록하려면 포트에서 송수신되는 모든 신호가 하나의 스케줄러에서 순서대로 실행되도록 할 수 있어야합니다. 이 작업을 수행하는 유일한 방법은 모든 유형의 신호를 예약하는 것입니다. 포트에 해당하는 신호는 단일 스케줄러 스레드에 의해 순서대로 실행될 수 있습니다. 하나의 스레드 만 포트를 실행하려고하면 포트 잠금에 경합이 나타나지 않습니다. 경합을 제거하는 것 외에도 포트로 신호를 보내는 프로세스는 신호 코드가 다른 스케줄러에서 실행되는 동시에 다른 스케줄러에서 자신의 Erlang 코드를 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403d69677374c07e6c15d9b1403b168e3385a4f8" translate="yes" xml:space="preserve">
          <source>In order to prevent scenarios like this we've implemented support for migration of multi-block carriers between allocator instances.</source>
          <target state="translated">이와 같은 시나리오를 방지하기 위해 할당 자 인스턴스 간의 다중 블록 캐리어 마이그레이션 지원을 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">MG 및 MGC의 확장 가능한 구현을위한 솔루션을 제공하기 위해 사용자는 여러 Erlang 노드에 분산 될 수 있습니다. Erlang 노드 중 하나가 실제 네트워크 인터페이스에 연결되어 있지만 다른 노드에서 메시지가 전송 될 수 있으며 응답은 자동으로 원래 노드로 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7d500551c4dcb114f3424b88510f43e715d2cf" translate="yes" xml:space="preserve">
          <source>In order to reduce contention due to locking of allocator instances we introduced completely lock free instances tied to each scheduler thread, and an extra locked instance for other threads. The scheduler threads in the system is expected to do the major part of the work. Other threads may still be needed but should not perform any major and/or time critical work. The limited amount of contention that appears on the locked allocator instance can more or less be disregarded.</source>
          <target state="translated">할당 자 인스턴스의 잠금으로 인한 경합을 줄이기 위해 각 스케줄러 스레드에 연결된 완전 잠금 해제 인스턴스와 다른 스레드에 대한 추가 잠금 인스턴스를 도입했습니다. 시스템의 스케줄러 스레드가 작업의 주요 부분을 수행 할 것으로 예상됩니다. 다른 스레드가 여전히 필요할 수 있지만 주요 및 / 또는 시간이 중요한 작업을 수행해서는 안됩니다. 잠긴 할당 자 인스턴스에 나타나는 제한된 양의 경합은 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f092b8785b0c724e3673cc03096bbd3fea047bff" translate="yes" xml:space="preserve">
          <source>In order to retrieve keylog information on a TLS 1.3 connection, it must be configured in advance to keep the client_random and various handshake secrets.</source>
          <target state="translated">TLS 1.3 연결에서 키로그 정보를 검색하려면 client_random 및 다양한 핸드 셰이크 비밀을 유지하도록 미리 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">의 본격 비교 정보 참조하기 위해서는 &lt;code&gt;Event&lt;/code&gt; 는 클릭 수 &lt;code&gt;Event&lt;/code&gt; [시작하기 위해 &lt;code&gt;Contents Viewer&lt;/code&gt; 그것을 위해 &lt;code&gt;Event&lt;/code&gt; . 에서 &lt;code&gt;Contents Viewer&lt;/code&gt; 가도 검사 할 수있는 필터 메뉴입니다 &lt;code&gt;Event&lt;/code&gt; 뷰어에서 선택한 것과 다른 뷰에서입니다. 온 딸깍 &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; 원인이됩니다 &lt;code&gt;Contents Viewer&lt;/code&gt; 게재하며, 팝업 창을 &lt;code&gt;Event&lt;/code&gt; 에 &lt;code&gt;mgr_actors&lt;/code&gt; 보기 :</target>
        </trans-unit>
        <trans-unit id="dbccfc8cfa22ee2e381053c5b4b92eaa192ba4f4" translate="yes" xml:space="preserve">
          <source>In order to set a different socket path the &lt;code id=&quot;SOCKET_PATH&quot;&gt;socket_path&lt;/code&gt; option can be set.</source>
          <target state="translated">다른 소켓 경로를 설정하기 위해 &lt;code id=&quot;SOCKET_PATH&quot;&gt;socket_path&lt;/code&gt; 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92ff9cab23ed1e1a7df0e6479aae0e38297e97c3" translate="yes" xml:space="preserve">
          <source>In order to solve this, we introduced a new busy feature, namely &quot;busy port queue&quot;. The port has a limit of &lt;code&gt;command&lt;/code&gt; data that is allowed to be enqueued in the task queue. When this limit is reached, the port will automatically enter a busy port queue state. When in this state, senders of &lt;code&gt;command&lt;/code&gt; signals will be suspended, but &lt;code&gt;command&lt;/code&gt; signals will still be delivered to the port unless it is also in a busy port state. This limit is known as the high limit.</source>
          <target state="translated">이 문제를 해결하기 위해 &quot;사용중인 포트 대기열&quot;이라는 새로운 사용 중 기능을 도입했습니다. 포트에는 작업 대기열에 넣을 수있는 &lt;code&gt;command&lt;/code&gt; 데이터 제한이 있습니다. 이 제한에 도달하면 포트는 자동으로 사용중인 포트 대기열 상태로 들어갑니다. 이 상태에서 &lt;code&gt;command&lt;/code&gt; 신호의 발신자는 일시 중지되지만 &lt;code&gt;command&lt;/code&gt; 신호는 사용중인 포트 상태가 아닌 한 포트로 계속 전달됩니다. 이 한계를 상한이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c0e67fa06e1bd38aa13f81fc5e8041b9e05f7af4" translate="yes" xml:space="preserve">
          <source>In order to test modifications of the process table we ran a couple of benchmarks where lots of processes are spawned and terminated simultaneously, and got a speedup of between 150-200%. Running a similar benchmark but with ports we got a speedup of about 130%.</source>
          <target state="translated">프로세스 테이블의 수정을 테스트하기 위해 많은 프로세스가 동시에 생성되고 종료되는 몇 가지 벤치 마크를 실행하고 150-200 % 사이의 속도를 높였습니다. 유사한 벤치 마크를 실행했지만 포트를 사용하면 약 130 %의 속도가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">태그 시스템을 사용하려면 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일을 작성해야합니다. 파일은 프로젝트의 모든 파일에있는 모든 기능, 레코드 및 매크로에 대한 데이터베이스로 볼 수 있습니다. &lt;code&gt;TAGS&lt;/code&gt; 파일은 얼랑에 대한 두 가지 다른 방법을 사용하여 만들 수 있습니다. 첫 번째는 표준 Emacs 유틸리티 &quot;etags&quot;이고 두 번째는 Erlang 모듈 &lt;code&gt;tags&lt;/code&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">측정 결과 ASN.1 BER과 간단한 텍스트 형식간에 메시지 크기에 큰 차이가 없음을 확인했습니다. 예쁜 텍스트 스타일 (프로토콜 사양에 포함되어 있고 디버깅 세션 중에 선호되는 모든 예제에서 사용됨)을 사용할 때는 메시지가 상당히 클 수 있으므로주의해야합니다. 메시지 크기가 실제로 심각한 문제인 경우 ASN.1 PER 형식이 다른 모든 대안보다 훨씬 컴팩트하므로 인코더 당 인코더를 사용해야합니다. 주요 단점은 유효한 Megaco / H.248 메시지 인코딩으로 승인되지 않았다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">실제로, 객체 세트는 일반적으로 확장 가능한 것으로 선언되어 나중에 더 많은 객체를 세트에 추가 할 수 있습니다. 확장 성은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">이전 버전의 &lt;code&gt;file&lt;/code&gt; 에서 모드는 목록 대신 원자 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;read_write&lt;/code&gt; 중 하나로 지정되었습니다 . 이전 버전과의 호환성을 위해 여전히 허용되지만 새 코드에는 사용되지 않습니다. 또한 &lt;code&gt;read_write&lt;/code&gt; 는 모드 목록에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">원칙적으로이 함수 는 &lt;code&gt;spawn&lt;/code&gt; 을 통해 &lt;code&gt;process_received_message/4&lt;/code&gt; 함수를 호출 하여 실제 처리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">클라이언트 시작 재협상을 지원하는 프로토콜에서 이러한 작업의 자원 비용은 클라이언트보다 서버에 더 높습니다. 이는 서비스 거부 공격을위한 벡터 역할을 할 수 있습니다. SSL 응용 프로그램은 이미 이러한 시도에 대응하기위한 조치를 취하고 있지만이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 클라이언트 시작 재협상을 엄격히 비활성화 할 수 있습니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 재협상을 비활성화하면 기본 암호 제품군이 암호화 할 수있는 메시지 수의 제한으로 인해 장기 연결을 사용할 수 없게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">드문 경우이지만이 기능은 Unix에서 실패 할 수 있습니다. 현재 디렉토리의 상위 디렉토리에 대한 읽기 권한이없는 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">실제로 데이터 모델은 거의 정규화되지 않습니다. 표준화 된 데이터베이스 모델에 대한 현실적인 대안은 첫 번째 정규 형식이 아닌 데이터 모델입니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 유연한 방식으로 데이터를 쉽게 구성 할 수 있기 때문에 통신과 같은 애플리케이션에 적합합니다. &lt;code&gt;Mnesia&lt;/code&gt; 의 데이터베이스는 항상 테이블의 집합으로 구성되어있다. 각 테이블은 행, 개체 및 레코드로 채워집니다. 어떤 설정 &lt;code&gt;Mnesia&lt;/code&gt; 을 분리하는 것은 레코드의 개별 필드가 복합 데이터 구조의 모든 유형을 포함 할 수 있다는 것입니다. 레코드의 개별 필드에는 목록, 튜플, 함수 및 레코드 코드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">시나리오 1에서 테스트 케이스 프로세스 는 &lt;code&gt;case A&lt;/code&gt; 가 오류를 감지하지 않고 테스트 코드 실행을 완료 한 후 정상적으로 종료됩니다 . 테스트 케이스 함수는 값을 리턴하고 &lt;code&gt;Common Test&lt;/code&gt; 는 테스트 케이스를 성공으로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">시나리오 2에서 테스트 &lt;code&gt;case B&lt;/code&gt; 실행 중에 오류가 감지되었습니다 . 이로 인해 테스트 &lt;code&gt;case B&lt;/code&gt; 함수가 예외를 생성하고 결과적으로 테스트 케이스 프로세스가 정상 이외의 이유로 종료됩니다. &lt;code&gt;Common Test&lt;/code&gt; 는 이를 실패한 (실패한) 테스트 사례로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">신화에 대한 섹션에서 다음과 같은 신화가 드러났습니다. &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">간단히 말해 &lt;code&gt;DebugType&lt;/code&gt; 은 디버깅 전용입니다. 생산 중 로그는 표준 Erlang 로깅 기능으로 더 잘 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">요컨대 :</target>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">일부 응용 프로그램에서는 개별 로그의 회신이 무시되는 것이 허용되지 않을 수 있습니다. 이러한 상황에 대한 대안은 하나의 분산 디스크 로그 대신 많은 로컬 디스크 로그를 사용하고 &lt;code&gt;disk_log&lt;/code&gt; 모듈 을 사용하지 않고 분배를 구현하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">몇몇 양상들에서, Erlang MIB 컴파일러는 SMI를 완전히 따르거나 구현하지 않는다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">일부 측면에서 에이전트는 SNMP를 완전히 구현하지 않습니다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">경우에 따라 Erlang 구문 규칙을 사용하면 원하는 곳에 메타 변수를 직접 배치 할 수 없습니다. 예를 들어 다음과 같이 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">경우에 따라 선택 / 일치 작업이 전체 테이블을 스캔하지 않아도됩니다. 예를 들어, &lt;code&gt;ordered_set&lt;/code&gt; 테이블을 검색 할 때 키의 일부가 바인드 되거나 Mnesia 테이블이고 선택 / 일치되는 필드에 보조 인덱스가있는 경우. 키가 완전히 바인드 된 경우 백 테이블이없고 특정 키가있는 요소의 서브 세트에만 관심이없는 경우 선택 / 일치를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">일부 컨텍스트에서는 문자열 또는 정수만 허용됩니다. 예를 들어 &lt;code&gt;-file(Name, Line)&lt;/code&gt; 지시문 은 &lt;code&gt;Name&lt;/code&gt; 이 문자열 리터럴이고 &lt;code&gt;Line&lt;/code&gt; 이 정수 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;locked&lt;/code&gt; 상태 에서 버튼을 누르면 마지막으로 누른 버튼을 올바른 코드 길이까지 수집하여 올바른 코드와 비교합니다. 결과에 따라 도어가 잠금 해제되고 &lt;code&gt;gen_statem&lt;/code&gt; 이 &lt;code&gt;open&lt;/code&gt; 상태가 되거나 도어가 &lt;code&gt;locked&lt;/code&gt; 상태로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">state &lt;code&gt;open&lt;/code&gt; 상태 에서 버튼 이벤트는 동일한 상태를 유지하여 무시됩니다. 이것은 또한 반환하여 수행 할 수 있습니다 &lt;code&gt;{keep_state, Data}&lt;/code&gt; 또는 이후이 경우 &lt;code&gt;Data&lt;/code&gt; 반환하여 변경도 &lt;code&gt;keep_state_and_data&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="96ad0dfc8fa4580e2165853ef7429bd0d01832d6" translate="yes" xml:space="preserve">
          <source>In systems which create and delete &lt;strong&gt;many&lt;/strong&gt; sockets dynamically, it (the socket registry) could become a bottleneck. For such systems, there are a couple of ways to control the use of the socket registry.</source>
          <target state="translated">&lt;strong&gt;많은&lt;/strong&gt; 소켓을 동적으로 생성 및 삭제하는 시스템에서는 소켓 레지스트리가 병목 현상이 될 수 있습니다. 이러한 시스템의 경우 소켓 레지스트리 사용을 제어하는 ​​몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">많은 프로세스가있는 시스템에서 짧은 시간 동안 실행되는 계산 작업을 최소 힙 크기가 더 높은 새 프로세스로 생성 할 수 있습니다. 프로세스가 완료되면 계산 결과를 다른 프로세스로 보내고 종료합니다. 최소 힙 크기가 올바르게 계산되면 프로세스에서 가비지 콜렉션을 전혀 수행하지 않아도됩니다. &lt;strong&gt;적절한 측정 없이는이 최적화를 시도하지 않아야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">통신 애플리케이션에서는 기존 DBMS에서 제공하는 기능과는 다른 요구가 있습니다. 현재 Erlang으로 구현 된 애플리케이션에는 광범위한 기능이 혼합되어있어 일반적으로 기존 DBMS에서는 충족되지 않습니다. Mnesia는 다음과 같은 요구 사항을 염두에두고 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">Erlang의 32 비트 구현에서 536,870,911 바이트는 비트 구문을 사용하여 구성하거나 일치시킬 수있는 가장 큰 바이너리입니다. 64 비트 구현에서 최대 크기는 2,305,843,009,213,693,951 바이트입니다. 제한이 초과되면 비트 구문 구성은 &lt;code&gt;system_limit&lt;/code&gt; 예외로 실패하고 너무 큰 이진 파일과 일치하려는 시도는 실패합니다. 이 제한은 R11B-4부터 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">에서 &lt;code&gt;MatchBody&lt;/code&gt; 및 &lt;code&gt;MatchCondition&lt;/code&gt; 부품, 이전에 바인딩 변수 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">에서 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 의 부분에는 바인드 변수이므로, 허용되는 &lt;code&gt;'_'&lt;/code&gt; 자체 (원자)로서 해석된다. 변수는 &lt;code&gt;MatchHead&lt;/code&gt; 부분 에만 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">에서 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; 의 부품, 해석은 서로 다른 몇 가지 방법입니다. 이 부분의 리터럴은 튜플을 제외한 모든 리터럴에 대해 작동하는 &quot;있는 그대로&quot;또는 특수 양식 &lt;code&gt;{const, T}&lt;/code&gt; 를 사용하여 작성할 수 있습니다. 여기서 &lt;code&gt;T&lt;/code&gt; 는 Erlang 용어입니다.</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">에서 &lt;code&gt;MatchHead&lt;/code&gt; 의 부분 (위의 변수를 제외한) 모든 리터럴 &quot;그대로&quot;해석된다.</target>
        </trans-unit>
        <trans-unit id="62822ca5758004378978f550b70109b8f746b1ba" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;compiler&lt;/code&gt; application, in the file &lt;code&gt;genop.tab&lt;/code&gt;, there is the following line:</source>
          <target state="translated">에서 &lt;code&gt;compiler&lt;/code&gt; 응용 프로그램, 파일에 &lt;code&gt;genop.tab&lt;/code&gt; , 다음 줄이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;do_perm&lt;/code&gt; 우리는 할당 된 구조에서 작동하는 일을 &lt;code&gt;output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">위의 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 예제 에서 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 을 소스 코드 에 포함 시켜야 합니다 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 유효한 일치 스펙 에 대한 ets : fun2ms / 1 호출 의 구문 분석 변환을 트리거하기 때문 입니다. 이는 또한 컴파일시 변환이 수행되고 (쉘에서 호출 된 경우 제외) 런타임에 리소스를 사용하지 않음을 의미합니다. 즉, 더 직관적 인 재미있는 구문을 사용하더라도 일치 스펙을 직접 작성하는 것만 큼 런타임에서 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">에서 &lt;code&gt;main&lt;/code&gt; 기능은 C 프로그램이 선택된 부호화에있어서, 얼랑로부터 메시지를 수신하고 인 / 디코딩 방식, 전화 기능에 인수 번째 바이트되는 함수 결정하는 첫 번째 바이트를 사용한다. 함수를 호출 한 결과는 Erlang으로 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="a69877ecee07d6d60ef5a7f12b95eb172cfc8ddd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;option&lt;/code&gt; info tuple are only the options included that differs from the default values.</source>
          <target state="translated">에서 &lt;code&gt;option&lt;/code&gt; 정보 튜플 만 옵션이 기본 값에서 해당 다르다 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">에서 &lt;code&gt;ready_async&lt;/code&gt; 함수 출력 에뮬레이터로 다시 보내진다. &lt;code&gt;ei&lt;/code&gt; 대신 드라이버 용어 형식을 사용합니다 . 이것은 Erlang 코드가 &lt;code&gt;binary_to_term/1&lt;/code&gt; 을 호출하지 않고도 Erlang 용어를 드라이버로 직접 보내는 유일한 방법 입니다. 간단한 예제에서 이것은 잘 작동 하며 이진 용어 형식을 처리 하기 위해 &lt;code&gt;ei&lt;/code&gt; 를 사용할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="262d5d76fc96e92282d6cd6556cb095d00a57bcd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ssh.app&lt;/code&gt; file, in the &lt;code&gt;env&lt;/code&gt; part</source>
          <target state="translated">에서 &lt;code&gt;ssh.app&lt;/code&gt; 의 에서 파일, &lt;code&gt;env&lt;/code&gt; 일부</target>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">Megaco의 API에서 사용자는 작업 요청을 명시 적으로 보낼 수 있지만, 트랜잭션 식별자 생성, 원격 사용자에 대한 메시지의 인코딩 및 실제 전송은 실제 연결 구성에 따라 프로토콜 엔진에 의해 자동으로 처리됩니다. Megaco 메시지는 API에 노출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">Erlang 런타임 시스템에서 스케줄러가 여러 개인 경우에만 엔티티가 병렬로 실행됩니다. 따라서 &lt;code&gt;lcnt&lt;/code&gt; 는 많은 코어에서 많은 스케줄러를 사용하는 시스템에서 더 많은 경합 지점을 표시하므로 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">커널 애플리케이션에서 :</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">Mnesia 테이블에서 두 개의 키 열은 두 개의 요소가있는 튜플로 저장됩니다. 따라서 테이블의 arity는 3입니다.</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">4.4BSD Unix에 포함 된 POSIX.2 호환 라이브러리에서 못생긴 구문 [[: &amp;lt;:]] 및 [[:&amp;gt; :]]는 &quot;단어 시작&quot;과 &quot;단어 끝&quot;을 일치시키는 데 사용됩니다. PCRE는 이러한 항목을 다음과 같이 취급합니다.</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">PRF (pseud-random function)에서 PFS를 사용하지 않는 암호 제품군에서 키 자료를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">SSL 애플리케이션에서 추가 분배 모듈 인 &lt;code&gt;inet_tls_dist&lt;/code&gt; 가 대안으로 사용될 수 있습니다. 모든 분배 연결은 TLS를 사용하며 분산 시스템의 모든 참여 Erlang 노드는이 분배 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">STDLIB 애플리케이션에서 :</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">위의 예에서 &quot;ping&quot;이 시작될 때 &quot;pong&quot;의 ID를 제공 할 수 있도록 &quot;pong&quot;이 처음 작성되었습니다. 즉, 어떤 식 으로든 &quot;ping&quot;은 메시지를 보낼 수 있도록 &quot;pong&quot;의 ID를 알 수 있어야합니다. 때때로 서로의 아이덴티티를 알아야하는 프로세스는 서로 독립적으로 시작됩니다. 따라서 Erlang은 프로세스에 이름을 부여하는 메커니즘을 제공하므로 이러한 이름을 pid 대신 ID로 사용할 수 있습니다. 이는 &lt;code&gt;register&lt;/code&gt; BIF 를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e32e6dd34c52e0e8f5c4ffcf8e60b4a055b8ae5e" translate="yes" xml:space="preserve">
          <source>In the above example, the small binary &lt;code&gt;B&lt;/code&gt; was copied while the larger binary &lt;code&gt;C&lt;/code&gt; references binary &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 작은 바이너리 &lt;code&gt;B&lt;/code&gt; 는 복사되고 더 큰 바이너리 &lt;code&gt;C&lt;/code&gt; 는 바이너리 &lt;code&gt;A&lt;/code&gt; 를 참조 합니다.</target>
        </trans-unit>
        <trans-unit id="dd30adfebd9b33e07add4e9cc9b71db937dd48cf" translate="yes" xml:space="preserve">
          <source>In the absence of spawn operation failures, atomically sets up a monitor to the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor(process, Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. The &lt;code&gt;ReqId&lt;/code&gt; returned by &lt;code&gt;spawn_request()&lt;/code&gt; is also used as monitor reference as if it was returned from &lt;code&gt;monitor(process, Pid)&lt;/code&gt;.</source>
          <target state="translated">스폰 작업 실패가없는 경우 새로 생성 된 프로세스에 대한 모니터를 원자 적으로 설정합니다. 즉, 호출하는 프로세스가 &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor(process, Pid)&lt;/a&gt;&lt;/code&gt; 호출 한 것처럼 여기에서 &lt;code&gt;Pid&lt;/code&gt; 는 새로 생성 된 프로세스의 프로세스 식별자입니다. &lt;code&gt;ReqId&lt;/code&gt; 의해 반환 &lt;code&gt;spawn_request()&lt;/code&gt; 그것으로부터 반환 된 것과 같은 모니터 기준으로서 사용되는 &lt;code&gt;monitor(process, Pid)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">기본 시나리오에서 각 사용자는 드라이버를 사용하기 전에 드라이버를로드하고 완료되면 드라이버를 언로드합니다. 참조 횟수는 프로세스 및 각 프로세스 별로드 수를 추적합니다. 이렇게하면 아무도 원하지 않을 때만 (사용자가없는 경우) 드라이버가 언로드됩니다. 드라이버는 또한 열린 포트를 추적합니다. 이렇게하면 모든 포트가 닫힐 때까지 언로드가 지연되거나 드라이버가 언로드 될 때 드라이버를 사용하는 모든 포트가 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">위의 경우 메신저 예제의 다른 모든 파일과 동일한 디렉토리에서 파일을 가져옵니다. (*설명서*).</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">업그레이드의 경우 &lt;code&gt;OldVsn&lt;/code&gt; 은 &lt;code&gt;Vsn&lt;/code&gt; 이고 다운 그레이드의 경우 &lt;code&gt;OldVsn&lt;/code&gt; 은 &lt;code&gt;{down,Vsn}&lt;/code&gt; 입니다. &lt;code&gt;Vsn&lt;/code&gt; 은 이전 버전의 콜백 모듈 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;vsn&lt;/code&gt; 속성으로 정의됩니다 . 그러한 속성이 정의되어 있지 않으면 버전은 BEAM 파일의 체크섬입니다.</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">응답의 경우 megaco는 응답을 취소하고이 정보는 콜백 함수 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; 호출을 통해 사용자에게 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요청의 경우 megaco는 &lt;code&gt;megaco:cancel&lt;/code&gt; 이 성공적으로 전송 된 후 호출 된 것과 거의 같은 방식으로 메시지를 취소합니다 . 정보는 요청이 발행 된 방법에 따라 다르게 사용자에게 다시 전파됩니다. &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 을 사용하여 발행 된 요청의 경우 정보가 리턴 값으로 전달됩니다. &lt;code&gt;megaco:cast&lt;/code&gt; 를 사용하여 발행 된 요청의 경우 정보는 콜백 함수 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 에 대한 호출을 통해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;Destination&lt;/code&gt; 인 &lt;code&gt;File&lt;/code&gt; , 인쇄 MEGACO 추적 이벤트는 파일로 인쇄 할 &lt;code&gt;File&lt;/code&gt; 일반 사용 &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">경우에 때 &lt;code&gt;Destination&lt;/code&gt; 입니다 &lt;code&gt;io&lt;/code&gt; 인쇄 MEGACO 추적 이벤트가 일반 사용하여 표준 출력에 인쇄됩니다, &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3e58c5c2505dec49b18b9e8525ca602801333f" translate="yes" xml:space="preserve">
          <source>In the case when its not possible to immediately establish a connection, the function will return with the &lt;code&gt;&lt;a href=&quot;#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;, a subsequent call to connect will then establish the connection).</source>
          <target state="translated">즉시 연결을 설정할 수없는 경우 함수는 &lt;code&gt;&lt;a href=&quot;#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt; 와 함께 반환됩니다 . 그런 다음 호출자는 선택 메시지, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; 를 기다릴 수 있습니다 (여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;SelectInfo&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드이며 연결을위한 후속 호출은 연결을 설정합니다).</target>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">pdu 유형이 &lt;code&gt;report&lt;/code&gt; 인 경우 &lt;code&gt;MsgData&lt;/code&gt; 는 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="42c6fc4cd12daba8d11cdd4982445015e66db822" translate="yes" xml:space="preserve">
          <source>In the case when there is no connections waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when a client connects (a subsequent call to accept will then return the socket).</source>
          <target state="translated">대기중인 연결이없는 경우 함수는 &lt;code&gt;SelectInfo&lt;/code&gt; 와 함께 반환됩니다 . 그러면 호출자는 클라이언트가 연결될 때 &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;SelectInfo&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드) 선택 메시지를 기다릴 수 있습니다 ( 수락을위한 후속 호출은 소켓을 반환합니다).</target>
        </trans-unit>
        <trans-unit id="97b308070b86e9f2f5cfb71e46c5c56ad9f43c5a" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recv will then return the data).</source>
          <target state="translated">대기중인 데이터가없는 경우 함수는 &lt;code&gt;SelectInfo&lt;/code&gt; 와 함께 반환됩니다 . 그러면 호출자는 데이터가 도착했을 때 &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;SelectInfo&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드) 선택 메시지를 기다릴 수 있습니다 (다음 에 recv를 호출하면 데이터가 반환됩니다).</target>
        </trans-unit>
        <trans-unit id="c310b42286356d0fc14eede396b80bde97e8a3eb" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvfrom will then return the data).</source>
          <target state="translated">대기중인 데이터가없는 경우 함수는 &lt;code&gt;SelectInfo&lt;/code&gt; 와 함께 반환됩니다 . 호출자는 데이터가 도착했을 때 &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;SelectInfo&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드 임) 선택 메시지를 기다릴 수 있습니다 (다음 에 recvfrom을 호출하면 데이터가 반환됩니다).</target>
        </trans-unit>
        <trans-unit id="79a9e35d675f34065de5084906faf62c1cb4d28b" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvmsg will then return the data).</source>
          <target state="translated">대기중인 데이터가없는 경우 함수는 &lt;code&gt;SelectInfo&lt;/code&gt; 와 함께 반환됩니다 . 호출자는 데이터가 도착했을 때 &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;SelectInfo&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드 임) 선택 메시지를 기다릴 수 있습니다 (다음 에 recvmsg를 호출하면 데이터가 반환됩니다).</target>
        </trans-unit>
        <trans-unit id="79128b360c469ba004c95bafdca01e1b34773296" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to send will then send the data).</source>
          <target state="translated">(system-) 버퍼에 공간이없는 경우 함수는 &lt;code&gt;SelectInfo&lt;/code&gt; 와 함께 반환됩니다 . 호출자는 다음 선택 메시지, 기다리고 있습니다 &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (여기서 &lt;code&gt;Info&lt;/code&gt; 는 IS &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드는에서 &lt;code&gt;SelectInfo&lt;/code&gt; 더 많은 데이터를위한 공간 (다음 보내드립니다 전송에 대한 후속 호출이있을 때) 데이터).</target>
        </trans-unit>
        <trans-unit id="e8a00bf019c9ad7cc3ae0aa6563d03144ab91886" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendmsg will then send the data).</source>
          <target state="translated">(system-) 버퍼에 공간이없는 경우 함수는 &lt;code&gt;SelectInfo&lt;/code&gt; 와 함께 반환됩니다 . 그러면 호출자는 더 많은 데이터를위한 공간이있을 때 &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;SelectInfo&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드) 선택 메시지를 기다릴 수 있습니다 (그런 다음 sendmsg에 대한 후속 호출이 데이터).</target>
        </trans-unit>
        <trans-unit id="67338ab252943970a15e1afbfd3aa9bc7bd17164" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendto will then send the data).</source>
          <target state="translated">(system-) 버퍼에 공간이없는 경우 함수는 &lt;code&gt;SelectInfo&lt;/code&gt; 와 함께 반환됩니다 . 그러면 호출자는 더 많은 데이터를위한 공간이있을 때 &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (여기서 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;SelectInfo&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 필드) 선택 메시지를 기다릴 수 있습니다 (그다음 sendto에 대한 후속 호출은 데이터).</target>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">이 섹션의 시작 부분에있는 코드 조각에서는 &lt;code&gt;Bin&lt;/code&gt; 에 추가하는 것이 저렴하지만 &lt;code&gt;Bin0&lt;/code&gt; 에 추가 하면 새 바이너리가 &lt;code&gt;Bin0&lt;/code&gt; 의 내용을 복사 하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="245dbc6eca2c173af60f0ff749e12a7fd20aabc1" translate="yes" xml:space="preserve">
          <source>In the configuration above we first raise the primary log level to max in order for the debug log events to get to the handlers. Then we configure the default handler to only log notice and below events, the default log level for a handler is &lt;code&gt;all&lt;/code&gt;. Then the debug handler is configured with a filter to stop any log message that is not a debug level message.</source>
          <target state="translated">위의 구성에서 먼저 디버그 로그 이벤트가 핸들러에 도달하기 위해 기본 로그 레벨을 최대로 올립니다. 그런 다음 알림 만 기록하고 이벤트 아래에만 기본 처리기를 구성합니다. 처리기의 기본 로그 수준은 &lt;code&gt;all&lt;/code&gt; 입니다. 그런 다음 디버그 처리기는 디버그 수준 메시지가 아닌 모든 로그 메시지를 중지하는 필터로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">표지 사양 파일에서 필요한 수준의 코드 범위 분석을 지정할 수도 있습니다. &lt;code&gt;details&lt;/code&gt; 또는 &lt;code&gt;overview&lt;/code&gt; . 상세 모드에서는 모듈 당 총 커버리지 비율을 보여주는 커버리지 개요 페이지가 표시됩니다. 또한 테스트 중에 코드의 어떤 부분이 실행되었는지 정확하게 보여주는 분석에 포함 된 각 모듈에 대해 HTML 파일이 인쇄됩니다. 개요 모드에서는 코드 적용 범위 개요 페이지 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">현재 &lt;code&gt;Common Test&lt;/code&gt; 버전에서 &lt;code&gt;silent_connections&lt;/code&gt; 기능은 Telnet 및 SSH 연결에서만 작동합니다. 다른 연결 유형에 대한 지원은 향후 &lt;code&gt;Common Test&lt;/code&gt; 버전 에서 추가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang / SCTP 바인딩의 현재 구현에서이 이벤트는 내부적 으로 &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 &lt;code&gt;error&lt;/code&gt; 용어로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">현재 구현에서 모든 객체 삽입 및 조회 작업으로 객체의 사본이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">릴리스 의 현재 버전 &lt;code&gt;CurVsn&lt;/code&gt; 에서 &lt;code&gt;myapp&lt;/code&gt; 의 응용 프로그램 디렉토리 는 &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; 입니다. 새로운 버전의 &lt;code&gt;NewVsn&lt;/code&gt; 은 릴리스 핸들러 외부에서 압축이 풀리고 릴리스 핸들러는 다음과 같이 호출하여이를 알립니다.</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">&lt;code&gt;data_dir&lt;/code&gt; 데이터 디렉토리 에서 테스트 모듈에는 테스트에 필요한 자체 파일이 있습니다. 이름 &lt;code&gt;data_dir&lt;/code&gt; 은 다음에 테스트 스위트의 이름입니다 &lt;code&gt;&quot;_data&quot;&lt;/code&gt; . 예를 들어, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; 에는 &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; 데이터 디렉토리가 있습니다. 이식성을 위해, 즉 스위트에서 디렉토리 이름을 하드 코딩하지 않으려면이 디렉토리를 사용하십시오. 데이터 디렉토리는 테스트 스위트와 동일한 디렉토리에 저장되므로 테스트 스위트 디렉토리에 대한 경로가 테스트 스위트 구현과 실행간에 변경된 경우에도 런타임시 해당 디렉토리에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">다음 설명에서는 기본값을 변경하는 데 사용되는 양식이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">노드에 대한 세부 정보 창에 원래 노드와 연결된 노드의 프로세스 간 기존 링크 및 모니터가 표시됩니다. &lt;strong&gt;추가 정보&lt;/strong&gt; 에는 디버그 정보 (에뮬레이터가 디버그 컴파일 된 경우 작성된 ​​특수 정보) 또는 오류 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ba5880443f43a3af428d4fbb8404826ac0d26fd" translate="yes" xml:space="preserve">
          <source>In the end, the C compiler will probably optimize this code to the same native code as the first version, but the first version is certainly much easier to read for human readers.</source>
          <target state="translated">결국 C 컴파일러는이 코드를 첫 번째 버전과 동일한 네이티브 코드로 최적화 할 것입니다.하지만 첫 번째 버전은 사람이 읽기에 훨씬 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="14e4ef55ecc440a106bcf9a15acab47c72a79a18" translate="yes" xml:space="preserve">
          <source>In the erl command line:</source>
          <target state="translated">erl 명령 줄에서 :</target>
        </trans-unit>
        <trans-unit id="fe10364408e4f6b1e20c24b12efb18fb322cbcc9" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period are to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">이벤트 관리자에는 0 개, 1 개 또는 여러 개의 &lt;strong&gt;이벤트 처리기&lt;/strong&gt; 가 설치됩니다. 이벤트 관리자가 이벤트에 대해 알림을 받으면 설치된 모든 이벤트 핸들러에서 이벤트를 처리합니다. 예를 들어, 오류를 처리하기위한 이벤트 관리자는 기본적으로 터미널에 오류 메시지를 기록하는 핸들러를 설치할 수 있습니다. 특정 기간 동안의 오류 메시지도 파일에 저장되는 경우 사용자는이를 수행하는 다른 이벤트 핸들러를 추가합니다. 파일에 로깅이 더 이상 필요하지 않으면이 이벤트 핸들러가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">이벤트 관리자에는 0 개, 1 개 또는 많은 &lt;strong&gt;이벤트 핸들러&lt;/strong&gt; 가 설치됩니다. 이벤트 관리자에게 이벤트에 대한 알림이 표시되면 설치된 모든 이벤트 핸들러에서 이벤트를 처리합니다. 예를 들어, 오류를 처리하기위한 이벤트 관리자는 기본적으로 핸들러를 설치하여 오류 메시지를 터미널에 기록 할 수 있습니다. 특정 기간 동안 오류 메시지를 파일에 저장하려는 경우 사용자는이를 수행하는 다른 이벤트 핸들러를 추가합니다. 파일에 로깅 할 필요가 없으면이 이벤트 핸들러가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8841b315d1e28c3d331ee376f7a7d69baa5c6c9d" translate="yes" xml:space="preserve">
          <source>In the example above the &lt;code&gt; &lt;strong&gt;on_load&lt;/strong&gt;&lt;/code&gt; directive is used get function &lt;code&gt;init&lt;/code&gt; called automatically when the module is loaded. Function &lt;code&gt;init&lt;/code&gt; in turn calls &lt;code&gt;&lt;a href=&quot;erlang#load_nif-2&quot;&gt;erlang:load_nif/2&lt;/a&gt;&lt;/code&gt; which loads the NIF library and replaces the &lt;code&gt;hello&lt;/code&gt; function with its native implementation in C. Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">위의 예에서 &lt;code&gt; &lt;strong&gt;on_load&lt;/strong&gt;&lt;/code&gt; 지시문은 모듈이로드 될 때 자동으로 호출 되는 get 함수 &lt;code&gt;init&lt;/code&gt; 를 사용 합니다. &lt;code&gt;init&lt;/code&gt; 함수 는 차례로 NIF 라이브러리를로드하고 &lt;code&gt;hello&lt;/code&gt; 함수를 C의 기본 구현으로 대체하는 &lt;code&gt;&lt;a href=&quot;erlang#load_nif-2&quot;&gt;erlang:load_nif/2&lt;/a&gt;&lt;/code&gt; 를 호출 합니다 . 일단로드되면 NIF 라이브러리는 영구적입니다. 속한 모듈 코드 버전이 제거 될 때까지 언로드되지 않습니다. &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">위의 예에서 유효한 &lt;code&gt;keys&lt;/code&gt; 는 &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; 및 &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; 일 수 있지만 &lt;code&gt;&quot;hi&quot;&lt;/code&gt; , &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; 및 &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; 가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">아래 예에서, 라인 번호 2,4,6,8 및 11은 실행 가능한 라인입니다.</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">이전 섹션의 예에서 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;ch3:start_link()&lt;/code&gt; 호출하여 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">이전 섹션의 예제에서 &lt;code&gt;gen_statem&lt;/code&gt; 은 &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; 호출하여 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">이 예에서 제시된 ID는 &lt;code&gt;example.com&lt;/code&gt; 및 &lt;code&gt;*.example.com&lt;/code&gt; 과 일치하는 호스트 이름 입니다. 예를 들어 &lt;code&gt;foo.example.com&lt;/code&gt; 과 &lt;code&gt;bar.example.com&lt;/code&gt; 은 모두 &lt;code&gt;foo.bar.example.com&lt;/code&gt; 과 일치하지만 일치하지는 않습니다 . &lt;code&gt;erlang.org&lt;/code&gt; 라는 이름 은 CN이 아니기 때문에 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">이 예에서, 들어 오고 나가는 각 메시지마다 &lt;code&gt;handle_debug&lt;/code&gt; 가 호출됩니다. 형식 함수 &lt;code&gt;Func&lt;/code&gt; 는 &lt;code&gt;ch4:write_debug/3&lt;/code&gt; 함수이며, &lt;code&gt;io:format/3&lt;/code&gt; 을 사용하여 메시지를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예 에서, &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; 의 첫 번째 인코딩 된 요소의 구성 요소 &lt;code&gt;number&lt;/code&gt; 가 선택됩니다. 이는 &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 섹션의 ASN.1 사양에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">이 예에서 &lt;code&gt;==/2&lt;/code&gt; 연산자 는 &lt;code&gt;=:=/2&lt;/code&gt; 처럼 처리되었습니다. 그러나 일부 상수에 정수가없는 것으로 컴파일 시간에 판별 할 수없고 테이블이 동일한 키를 비교할 때 &lt;code&gt;=:=/2&lt;/code&gt; 를 사용하는 경우 ( &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; 옵션 참조 ) &lt;code&gt;qlc&lt;/code&gt; 모듈은 상수를 찾지 않습니다. . 그 이유는 일반적으로 이러한 상수와 동일하게 비교할 수있는 키 값의 수에는 상한이 없기 때문입니다. 모든 정수와 부동 소수점 조합을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">이 예에서는 동기식 시작이 사용됩니다. 프로세스는 &lt;code&gt;ch4:start_link()&lt;/code&gt; 를 호출하여 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">이 예에서 일반 노드 이름은 &lt;code&gt;c1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">예제에서 :</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">예제에서 기본 Erlang 쉘은 ISO Latin1 범위의 문자 만 인쇄 가능으로 해석하고 문자열 데이터를 포함하는 &quot;인쇄 가능&quot;문자가있는 목록 또는 바이너리 만 감지 함을 알 수 있습니다. 러시아어 &quot;Юникод&quot;를 포함하는 유효한 UTF-8 바이너리는 문자열로 인쇄되지 않습니다. 인쇄 가능한 모든 유니 코드 문자 ( &lt;code&gt;+pc unicode&lt;/code&gt; )로 시작하면 쉘은 인쇄 가능한 유니 코드 데이터 (바이너리, UTF-8 또는 바이트 단위 인코딩)를 문자열 데이터로 포함하는 모든 것을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">비 익명 PFS (완전 순방향 비밀)를 제공하는 암호 제품군의 DH 매개 변수 교환</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">함수 호출의 첫 번째 형식 인 &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; 에서 &lt;code&gt;ExprM&lt;/code&gt; 및 &lt;code&gt;ExprF&lt;/code&gt; 는 각각 원자 또는 원자로 평가되는 표현식이어야합니다. 함수는 &lt;strong&gt;완전한 함수 이름&lt;/strong&gt; 을 사용하여 호출된다고합니다 . 이것은 종종 &lt;strong&gt;원격&lt;/strong&gt; 또는 &lt;strong&gt;외부 함수 호출이라고&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f6d99757df807bd06e120fa43c0767f20375e1c3" translate="yes" xml:space="preserve">
          <source>In the first section (&lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt;), actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that &lt;strong&gt;callback module&lt;/strong&gt;&lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">첫 번째 섹션 ( &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; )에서 작업은 일반 상태 머신 모델의 일부로 언급되었습니다. 이러한 일반적인 작업은 &lt;code&gt;gen_statem&lt;/code&gt; 엔진으로 돌아 가기 전에 이벤트 처리 콜백 함수에서 &lt;strong&gt;콜백 모듈 &lt;/strong&gt; &lt;code&gt;gen_statem&lt;/code&gt; 이 실행 하는 코드로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">첫 번째 섹션에서 &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; 조치는 일반 상태 머신 모델의 일부로 언급되었습니다. 이러한 일반 조치는 &lt;code&gt;gen_statem&lt;/code&gt; 엔진으로 리턴하기 전에 콜백 모듈 &lt;code&gt;gen_statem&lt;/code&gt; 이 이벤트 처리 콜백 함수에서 실행 하는 코드로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; 의 첫 번째 단어 (4 바이트) 에서는 18 비트 만 중요하고 나머지는 0이어야합니다. &lt;code&gt;Creation&lt;/code&gt; 에서는 2 비트 만 중요하고 나머지는 0입니다.</target>
        </trans-unit>
        <trans-unit id="5e047fa558c6b3687797900dae4cc1f9d07908ea" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest must be 0.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; 의 첫 번째 단어 (4 바이트) 에서는 18 비트 만 중요하고 나머지는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">다음 설명에서 &lt;strong&gt;Point&lt;/strong&gt; 라는 단어의 사용은 &quot;포인트는 커서의 위치로 볼 수 있습니다.보다 정확하게 말하면, 커서는 포인트 뒤의 문자 위에 그려지는 동안 두 문자 사이의 위치입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">다음 설명에서 &lt;strong&gt;그룹 노드&lt;/strong&gt; 는 로컬 노드와 동일한 글로벌 그룹에 속하는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">다음의 설명에서, 모든 기능은 이유와 함께 실패 &lt;code&gt;badarg&lt;/code&gt; 경우 &lt;code&gt;heart&lt;/code&gt; 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">다음 예에서는 QLC &lt;code&gt;V2&lt;/code&gt; 가 삽입되어 결합 된 생성기와 선택된 결합 방법을 보여줍니다. 조회 조인에 규칙이 사용됩니다. 첫 번째 생성기 ( &lt;code&gt;G2&lt;/code&gt; )는 트래버 싱 된 것이고, 두 번째 생성기 ( &lt;code&gt;G1&lt;/code&gt; )는 상수를 찾는 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">다음 예에서 병합 결합의 캐시 된 결과는 각 &lt;code&gt;A&lt;/code&gt; 값에 대해 순회됩니다 . 옵션 &lt;code&gt;cache&lt;/code&gt; 가 없으면 조인이 &lt;code&gt;A&lt;/code&gt; 의 각 값에 대해 한 번씩 세 번 수행되었을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">다음 예에서는 두 개의 프로세스가 만들어지고 여러 번 서로에게 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">다음 예에서는 옵션 &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; 를 보유하기 위해 두 개의 간단한 QLC가 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">이 프로그램을 사용하는 다음 예에서 노드는 네 개의 다른 컴퓨터에서 시작됩니다. 네트워크에 사용 가능한 머신이 많지 않은 경우 동일한 머신에서 여러 노드를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">다음 예에서, &lt;code&gt;Common Test&lt;/code&gt; 발견 실행한다 두 시험으로부터의 경로에 대해 하나의 &lt;code&gt;top2&lt;/code&gt; 에 &lt;code&gt;sub2X2&lt;/code&gt; 통해 &lt;code&gt;sub21&lt;/code&gt; 및 하나 &lt;code&gt;top2&lt;/code&gt; 에 &lt;code&gt;sub2X2&lt;/code&gt; 통해 &lt;code&gt;sub22&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">다음 예에서 &lt;code&gt;{Pid, hello_world}&lt;/code&gt; 는 등록 된 프로세스 &lt;code&gt;my_server&lt;/code&gt; 로 전송됩니다 . 메시지는 &lt;code&gt;erl_send()&lt;/code&gt; 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b55abcde93dfcf59993923892aaa3fe74b62110" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서 &lt;code&gt;{Pid, hello_world}&lt;/code&gt; 는 등록 된 프로세스 &lt;code&gt;my_server&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">다음 예제에서 고유 경로 &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; 를 지정하면 하나의 테스트 만 실행됩니다. &lt;code&gt;top2&lt;/code&gt; 에서 &lt;code&gt;sub2X2&lt;/code&gt; (이전 예제에서)까지 가능한 두 번째 경로 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">다음 예에서 함수 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; 이 순차 추적을위한 트리거로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">다음 예제에서 2, 4, 6, 8 및 11 행은 실행 가능한 행입니다.</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 모듈 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">다음 예제에서 BIF &lt;code&gt;self()&lt;/code&gt; 는 호출 프로세스의 pid를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5409dc0e8a019858263b90292ca1f90716b01a8e" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies as Erlang messages.</source>
          <target state="translated">다음 예에서 Erlang 셸은 Erlang 메시지로 채널 응답을받는 클라이언트 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">다음 예에서 Erlang 쉘은 채널 응답을받는 클라이언트 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">다음 예에서는이 ASN.1 사양이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">다음 예에서는 &lt;code&gt;my_SUITE&lt;/code&gt; 테스트를 위한 두 개의 이벤트 핸들러 가 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; 섹션 의 &lt;code&gt;gb_table&lt;/code&gt; 모듈을 사용하여 6 개의 키를 찾아야합니다. &lt;code&gt;{1,a}&lt;/code&gt; , &lt;code&gt;{1,b}&lt;/code&gt; , &lt;code&gt;{1,c}&lt;/code&gt; , &lt;code&gt;{2,a}&lt;/code&gt; , &lt;code&gt;{2,b}&lt;/code&gt; 및 &lt;code&gt;{2,c}&lt;/code&gt; . 그 이유는 키 &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; 의 두 요소가 별도로 비교되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">다음 예에서는 XML 파일 &quot;motorcycles.xml&quot;과 해당 DTD &quot;motorcycles.dtd&quot;를 사용합니다. motorcycles.xml은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">다음 그림에서는 표시된 요소 만 &lt;code&gt;selected_decode_Window2&lt;/code&gt; 에 의해 디코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">다음 그림에서 사각형 상자는 감독자를 나타내고 원은 근로자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">다음 목록에서 초기화 플래그는 &quot;(init flag)&quot;로 표시됩니다. 달리 지정되지 않는 한 다른 모든 플래그는 사용자 플래그이며 &lt;code&gt;init:get_argument/1&lt;/code&gt; 을 호출하여 값을 검색 할 수 있습니다 . 사용자 플래그 목록이 완전한 것은 아니며 해당 응용 프로그램 설명서에 설명 된 응용 프로그램 별 플래그가 더있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">다음 섹션에서는 이러한 주제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">다음 섹션에서는 필요한 도구 설치에 대해 최대한 많이 설명했습니다. 도구가 설치되면 구축이 매우 쉽습니다. 우리는 또한 유닉스 경험이 제한적인 사람들이이 지침을 이해할 수 있도록 노력했습니다. Cygwin / MSYS / MSYS2는 일부 Windows 사용자에게 완전히 새로운 환경이므로 환경 변수 등에 대한 신중한 설명이 필요한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fd2193cd39cfac6403a706b39a45fed6722ffda" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. WSL is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">다음 섹션에서는 필요한 도구의 설치에 대해 가능한 한 많이 설명했습니다. 도구가 설치되면 구축이 매우 쉽습니다. 우리는 또한 제한된 Unix 경험을 가진 사람들이 이러한 지침을 이해할 수 있도록 노력했습니다. WSL은 일부 Windows 사용자에게 완전히 새로운 환경이며, 환경 변수 등에 대한주의 깊은 설명이있는 것처럼 보였습니다.</target>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">다음과 같은 상황 &lt;code&gt;lists:flatten/1&lt;/code&gt; 호출을 쉽게 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">다음 예제 표에서 &lt;code&gt;Data&lt;/code&gt; 는 I / O 목록이어야합니다. I / O 목록은 0 또는 ..255 범위의 이진 또는 정수 또는 이진의 정수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cded6a813afbe8a22f1a0d31c8b7cd61b0e5883b" translate="yes" xml:space="preserve">
          <source>In the following terms that may cause confusion are explained.</source>
          <target state="translated">혼동을 일으킬 수있는 용어를 다음과 같이 설명합니다.</target>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">아래 정의 된 기능에서 다음 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">향후 디버그 기능은 Erlang 드라이버 스레드 API와 통합 될 것입니다. 엔터티를 만드는 모든 함수에는 &lt;code&gt;name&lt;/code&gt; 인수가 사용됩니다. 현재 &lt;code&gt;name&lt;/code&gt; 인수는 사용되지 않지만 디버그 기능이 구현 될 때 사용됩니다. 작성된 모든 엔티티의 이름을 올바르게 지정하면 디버그 기능이 더 나은 오류 보고서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">생성 된 부팅 스크립트에서 모든 응용 프로그램 디렉토리는 &lt;code&gt;App-Vsn/ebin&lt;/code&gt; 으로 구성 됩니다. &lt;code&gt;$ROOT/lib&lt;/code&gt; 에있는 것으로 가정합니다 . 여기서 &lt;code&gt;$ROOT&lt;/code&gt; 는 설치된 릴리스의 루트 디렉토리입니다. &lt;code&gt;local&lt;/code&gt; 옵션 이 지정되면 대신 응용 프로그램이 발견 된 실제 디렉토리가 사용됩니다. 생성 된 부팅 스크립트를 로컬에서 테스트하는 유용한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">마지막 예제에서 분석 할 모듈은 &lt;code&gt;m/1&lt;/code&gt; 에 대한 인수로 제공되었으며 코드 경로는 (암시 적으로) &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; 로 사용되었습니다 . 이 예제에서는 &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; 가 사용되어 응용 프로그램 및 릴리스를 분석하고 라이브러리 경로를 명시 적으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">마지막 줄에서 튜플 {256,10, -2}는 특수 표기법에서 실수 2.56이며 숫자를 단순히 &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; 으로 표시하는 것보다 빠르게 인코딩 됩니다. arity 3 튜플은 &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; 입니다 . 즉, Mantissa * Base ^ Exponent입니다.</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">두 방향 (cf &lt;code&gt;cipher&lt;/code&gt; ) 에 대해 두 개로 나뉘어 진 목록 에서 한 번에 두 방향을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">두 방향 (cf &lt;code&gt;cipher&lt;/code&gt; ) 에 대해 두 개로 나누어 진 목록에서 다음 방향 중 하나만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">요청이 처리되는 루프에서 이제 송신 제한 시간을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">메신저 예제에서 전송되는 메시지가 무엇인지에 대한 가정은 없었습니다. 유효한 Erlang 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8edc784c5711aef4324569d61cb733c3b77cb091" translate="yes" xml:space="preserve">
          <source>In the modified lock free version of this approach we more or less do it the same way, but with some important modifications trying to avoid unnecessary contention when multiple schedulers create processes simultaneously. Since multiple threads might be trying to search for the next free slot at the same time from the same starting point we want subsequent slots to be located in different cache lines. Multiple schedulers simultaneously writing new pointers into the table are therefore very likely to write into adjacent slots. If adjacent slots are located in the same cache line all modification of this cache line needs to be communicated between all involved processors which will be very expensive and scale very poor. By locating adjacent slots in different cache lines only true conflicts will trigger communication between involved processors, i.e., avoiding false sharing.</source>
          <target state="translated">이 접근 방식의 수정 된 잠금없는 버전에서는 거의 동일한 방식으로 수행하지만 여러 스케줄러가 동시에 프로세스를 생성 할 때 불필요한 경합을 피하기 위해 몇 가지 중요한 수정 사항이 있습니다. 여러 스레드가 동일한 시작점에서 동시에 다음 빈 슬롯을 검색하려고 할 수 있으므로 후속 슬롯이 다른 캐시 라인에 위치하기를 원합니다. 따라서 테이블에 새 포인터를 동시에 쓰는 여러 스케줄러는 인접한 슬롯에 쓸 가능성이 매우 높습니다. 인접 슬롯이 동일한 캐시 라인에있는 경우이 캐시 라인의 모든 수정은 매우 비싸고 확장 성이 매우 낮은 모든 관련 프로세서간에 통신해야합니다. 서로 다른 캐시 라인에서 인접한 슬롯을 찾는 경우에만 진정한 충돌이 관련 프로세서 간의 통신을 트리거합니다., 허위 공유를 피합니다.</target>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">모니터 메시지에서 &lt;code&gt;MonitorRef&lt;/code&gt; 및 &lt;code&gt;Type&lt;/code&gt; 은 앞에서 설명한 것과 동일하며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6af58c3bd490620b572e86c6ee20f0568469a3cc" translate="yes" xml:space="preserve">
          <source>In the new design the old wheel was dropped and instead replaced by one struct (&lt;code&gt;GenericBp&lt;/code&gt;) to hold the data for all types of breakpoints for each instrumented function. A bit-flag field is used to indicate what different type of break actions that are enabled.</source>
          <target state="translated">새로운 디자인에서는 이전 휠이 삭제되고 대신 하나의 구조체 ( &lt;code&gt;GenericBp&lt;/code&gt; )로 대체되어 각 계측 된 함수에 대한 모든 유형의 중단 점에 대한 데이터를 보유합니다. 비트 플래그 필드는 활성화 된 다른 유형의 중단 작업을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a775ef8f9dc8be5c9fdaee0cab605f0e25c280e" translate="yes" xml:space="preserve">
          <source>In the next garbage collection, any pointers to the old heap will be ignored and not scanned. This way the garbage collector does not have to scan the long-lived terms.</source>
          <target state="translated">다음 가비지 컬렉션에서 이전 힙에 대한 포인터는 무시되고 검색되지 않습니다. 이렇게하면 가비지 수집기가 수명이 긴 용어를 스캔 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6d0c33ad0d8698789ff1ce734a374e0b8dc46cb" translate="yes" xml:space="preserve">
          <source>In the next word the tagged atom &lt;code&gt;id&lt;/code&gt; is stored.</source>
          <target state="translated">다음 단어에는 태그가 지정된 원자 &lt;code&gt;id&lt;/code&gt; 가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">일반적인 경우 버전은 &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; 로 구성 되며 여기서 &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; 가 가장 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">필드의 초기 값이있는 경우 다음과 같이 초기화 후에 유형을 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">이전 예에서는 어떤 프로토콜이 예상되는지 표시하지 않았습니다. 따라서 클라이언트는 웹 서버, LDAP 서버 또는 연결된 sip 서버인지 여부를 표시하지 않습니다. 인증서에이를 나타낼 수있는 필드가 있습니다. 보다 정확하게 말하면 rfc 는 &lt;code&gt;X509v3 extensions&lt;/code&gt; 필드 에 &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; 의 사용법을 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">이전 예에서 &quot;ping&quot;및 &quot;pong&quot;은 두 개의 개별 Erlang 노드의 쉘에서 시작되었습니다. &lt;code&gt;spawn&lt;/code&gt; 을 사용하여 다른 노드에서 프로세스를 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">이전 예에서 &lt;code&gt;all/0&lt;/code&gt; 이 &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; 순서로 그룹 이름 참조를 리턴 하면 구성 함수 및 테스트 케이스의 순서는 다음과 같습니다 ( &lt;code&gt;init_per_testcase/2&lt;/code&gt; 및 &lt;code&gt;end_per_testcase/2:&lt;/code&gt; 항상 호출되지만 단순화를 위해이 예제에는 포함되지 않음) :</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">이전 예에서 감독자는 &lt;code&gt;ch_sup:start_link()&lt;/code&gt; 호출하여 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">이전 예제에서는 이전 변수 인 &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;TheRest&lt;/code&gt; , &lt;code&gt;E1&lt;/code&gt; , &lt;code&gt;E2&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 를 재사용하는 대신 새 변수 이름이 사용되었습니다 . 그 이유는 변수 (컨텍스트)에서 변수에 값을 한 번만 제공 할 수 있기 때문입니다. 나중에 이것에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">SMP를 지원하는 런타임 시스템에서 드라이버는 드라이버 레벨 또는 포트 레벨 (드라이버 인스턴스 레벨)에서 잠 깁니다. 기본적으로 드라이버 레벨 잠금이 사용됩니다. 즉, 한 번에 하나의 에뮬레이터 스레드 만 드라이버에서 코드를 실행합니다. 포트 레벨 잠금이 사용되는 경우 여러 에뮬레이터 스레드가 동시에 드라이버에서 코드를 실행할 수 있습니다. 그러나 한 번에 하나의 스레드 만 동일한 포트에 해당하는 드라이버 콜백을 호출합니다. 포트 레벨 잠금을 사용하려면 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 사용 하는 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 에서 &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; 드라이버 플래그 를 설정하십시오 . 포트 레벨 잠금이 사용되면 드라이버 기록기는 포트 (드라이버 인스턴스)가 공유하는 데이터에 대한 모든 액세스를 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">두 번째 예에서는 기본 추적 처리기 함수를 사용합니다. 이 핸들러는 IO 요청을 &lt;code&gt;user&lt;/code&gt; 프로세스 로 전송하여 tty로 인쇄합니다 . Erlang이 이전 쉘 모드에서 시작되면 쉘 프로세스는 &lt;code&gt;user&lt;/code&gt; 를 그룹 리더로 사용 하므로이 예제에서 추적 프로그램 프로세스도 마찬가지입니다. &lt;code&gt;user&lt;/code&gt; 가 &lt;code&gt;lists&lt;/code&gt; 에서 함수를 호출 하기 때문에 첫 번째 IO 요청이 전송되는 즉시 교착 상태가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">두 번째 형태의 함수 호출 &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; 에서 &lt;code&gt;ExprF&lt;/code&gt; 는 원자이거나 재미로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">시퀀스 차트에서 액터 (심볼 적으로 &lt;code&gt;Event&lt;/code&gt; 를 수행 한 액터 )는 이름이 지정된 세로 막대로 표시됩니다. 액터의 순서는 액터의 이름 태그를 드래그하여 (작업 중에 마우스 버튼 1을 누르고 있음) 다른 곳에 놓으면 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7823fdfa2d6e99d8afc1d184adab525e34685552" translate="yes" xml:space="preserve">
          <source>In the setup of the SSH connection a secret cipher key is generated by co-operation of the client and the server. Keeping this key secret is crucial for keeping the communication secret. As time passes and encrypted messages are exchanged, the probability that a listener could guess that key increases.</source>
          <target state="translated">SSH 연결 설정에서 클라이언트와 서버의 협력에 의해 비밀 암호 키가 생성됩니다. 이 키 비밀을 유지하는 것은 통신 비밀을 유지하는 데 중요합니다. 시간이 지나고 암호화 된 메시지가 교환되면 리스너가 키를 추측 할 수있는 확률이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">쉘에서 유니 코드 입력 장치를 사용하거나 UTF-8로 저장된 소스 코드에서 &lt;code&gt;$&lt;/code&gt; 뒤에 바로 정수를 생성하는 유니 코드 문자가 올 수 있습니다. 다음 예에서, 키릴의 코드 포인트 &lt;code&gt;с&lt;/code&gt; 가 출력된다 :</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">노드가 글로벌 그룹의 다른 노드와의 연결이 끊어졌지만 다른 글로벌 그룹의 노드와의 연결이있는 경우 다른 글로벌 그룹의 요청이 부정확하거나 잘못된 결과를 초래할 수 있습니다. 예를 들어 격리 된 노드는 글로벌 그룹에 등록 된 이름에 대한 정보가 정확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45354ca6d5ea2475e4f281fd6c145d031cdf7187" translate="yes" xml:space="preserve">
          <source>In the supervisor &lt;code&gt;child specification&lt;/code&gt; there is a list of modules which is recommended to contain only the callback module. For a &lt;code&gt;gen_statem&lt;/code&gt; with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade &lt;strong&gt;that&lt;/strong&gt; module whenever a &lt;strong&gt;synchronized code replacement&lt;/strong&gt; is done. Then the release handler concludes that an upgrade that upgrades &lt;strong&gt;that&lt;/strong&gt; module needs to suspend, code change, and resume any server whose child specification declares that it is using &lt;strong&gt;that&lt;/strong&gt; module. And again; the &lt;strong&gt;current&lt;/strong&gt; callback module will get the &lt;code&gt;Module:code_change/4&lt;/code&gt; call.</source>
          <target state="translated">수퍼바이저 &lt;code&gt;child specification&lt;/code&gt; 에는 콜백 모듈 만 포함하도록 권장되는 모듈 목록이 있습니다. 여러 콜백 모듈이 있는 &lt;code&gt;gen_statem&lt;/code&gt; 의 경우 실제로 모두 나열 할 필요가 없습니다. 코드 업그레이드 후 목록이 변경 될 수 있기 때문에 가능하지 않을 수도 있습니다. 권장되는대로이 목록에 시작 콜백 모듈 만 포함되는 경우 중요한 것은 &lt;strong&gt;동기화 된 코드 교체&lt;/strong&gt; 가 완료 될 때마다 &lt;strong&gt;해당&lt;/strong&gt; 모듈 을 업그레이드 &lt;strong&gt;하는&lt;/strong&gt; 것입니다. 그런 다음 릴리스 핸들러는 해당 모듈을 업그레이드하는 업그레이드가 &lt;strong&gt;해당&lt;/strong&gt; 모듈을 사용 &lt;strong&gt;하고 있다고&lt;/strong&gt; 선언 한 하위 사양이있는 서버를 일시 중단하고 코드 변경하고 다시 시작해야 한다고 결론을 내립니다 . 그리고 다시; &lt;strong&gt;현재&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;콜백 모듈은 &lt;code&gt;Module:code_change/4&lt;/code&gt; 호출을받습니다.</target>
        </trans-unit>
        <trans-unit id="34787be2516bd25bc51ccdee0b0ac4c6d7eba78b" translate="yes" xml:space="preserve">
          <source>In the tail part of the data structure we find a pointer to the last element of the list, or at least something that is near the end of the list. In the uncontended case it will point to the end of the list, but when simultaneous insert operations are performed it will point to something near the end of the list.</source>
          <target state="translated">데이터 구조의 꼬리 부분에서 목록의 마지막 요소 또는 적어도 목록의 끝 근처에있는 항목에 대한 포인터를 찾습니다. 경합되지 않는 경우에는 목록의 끝을 가리 키지 만 동시 삽입 작업이 수행되면 목록의 끝 근처에있는 항목을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">대상 디렉토리에서 &lt;code&gt;releases/start_erl.data&lt;/code&gt; 파일을 읽고 Erlang 런타임 시스템 버전 ( &quot;5.10.4&quot;)을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">텍스트 인코딩에서 구현자는 짧은 키워드와 긴 키워드를 혼합하여 사용할 수 있습니다. 가독성을 높이기 위해 공백을 추가 할 수도 있습니다. 키워드가 가장 짧고 공백이없는 문자 메시지에 대해서는 압축이라는 용어를 사용하고, 긴 키워드를 사용하여 잘 들여 쓰기 된 텍스트 형식과 Megaco / H.248 사양의 텍스트 예와 같이 들여 쓰기 스타일에 적합한 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a5c95ea342ee7c08382d8806e33a6d11792130c7" translate="yes" xml:space="preserve">
          <source>In the traditional transport entries, when the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="translated">기존 전송 항목에서 &lt;code&gt;Addr&lt;/code&gt; 값에 포트 번호가 포함되지 않은 경우 &lt;code&gt;intAgentUDPPort&lt;/code&gt; 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8436cdbd307ab8656dafbbaa0b4535513613e69" translate="yes" xml:space="preserve">
          <source>In the wake of this the function &lt;code&gt;sys:get_debug/3&lt;/code&gt; that returns data with undocumented and internal format (and therefore is practically useless) has been deprecated, and a new function &lt;code&gt;sys:get_log/1&lt;/code&gt; has been added, that hopefully does what the deprecated function was intended for.</source>
          <target state="translated">이로 인해 문서화되지 않은 내부 형식 (따라서 사실상 쓸모가 없음)으로 데이터를 반환하는 &lt;code&gt;sys:get_debug/3&lt;/code&gt; 함수 는 더 이상 사용되지 않으며 새 함수 &lt;code&gt;sys:get_log/1&lt;/code&gt; 이 추가되어 더 이상 사용되지 않는 작업을 수행합니다. 기능이 의도되었습니다.</target>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">xmerl_xs 함수에서 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; 기능인 select (String) 호출을 제공 할 수 있습니다 . 자세한 내용은 xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">이 경우 ProtocolVersion 기본 버전은 정적 연결 구성에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">이 에이전트 시스템에는 관리 정보를 동적으로 설치하는 두 가지 방법이 있습니다. 가장 일반적인 방법은 MIB를 에이전트에로드하는 것입니다. 다른 방법은 응용 프로그램에서 제어하며 자체 등록 및 등록 취소가 가능한 하위 에이전트를 사용하는 것입니다. 서브 에이전트는 서브 트리 관리를 위해 자체 등록 할 수 있습니다 ( &lt;code&gt;erlang:register&lt;/code&gt; 와 혼용해서는 안 됨 ). 하위 트리는 개체 식별자로 식별됩니다. 서브 에이전트가 등록되면이 특정 서브 트리에 대한 모든 요청을 수신하고 응답해야합니다. 또한 서브 에이전트는 언제든지 시작하고 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">이 호출에서 &lt;code&gt;[1, 1]&lt;/code&gt; 은 &lt;code&gt;RowIndex&lt;/code&gt; 이며 키 1에는 값 1이 있고 키 2에는 값 1이 있으며 &lt;code&gt;[3, 5]&lt;/code&gt; 는 요청 된 열 목록입니다. 함수는 이제 사전 식으로 다음 요소를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">이 경우 새로운 구성 요소 &lt;code&gt;b&lt;/code&gt; 가 있습니다. 따라서, 디코딩 된 수신 메시지는이 것보다 더 많거나 열이 많은 구성 요소를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">이 경우 테스트 스위트 의 &lt;code&gt;ct_hooks&lt;/code&gt; 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">이 경우 구성 파일에는 최소한 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">이 경우 필터는 &lt;code&gt;QH1&lt;/code&gt; 및 &lt;code&gt;QH2&lt;/code&gt; 에 대한 모든 가능한 응답 쌍에 한 번에 하나씩 적용됩니다. &lt;code&gt;QH1&lt;/code&gt; 에 대한 M 개의 답변 과 &lt;code&gt;QH2&lt;/code&gt; 에 대한 N 개의 답변이 있는 경우 필터는 M * N 회 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">이 경우 &lt;code&gt;CTH&lt;/code&gt; 는 CTH 의 모듈 이름이거나 모듈 이름과 초기 인수가있는 튜플 일 수 있으며 선택적으로 CTH의 후크 우선 순위 일 수 있습니다. 예를 들어, 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">이 경우 컴파일러 옵션 &lt;code&gt;encrypt_debug_info&lt;/code&gt; 를 사용할 수 있습니다 &lt;code&gt;compile(3)&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">이 경우 첫 번째 인수를 제외한 모든 인수는 무시되고 함수는 단순히 내부 상태를 다시 반환합니다. 코드 만 확장 된 경우 충분합니다. 내부 상태가 (의 예와 유사하게 변경하는 대신 경우 &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; )이이 기능에서 수행하고 &lt;code&gt;{ok,Chs2}&lt;/code&gt; 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">이 경우 &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; 중 하나 이상 이 바인딩되지 않은 변수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">이 경우 간단한 코드 교체로는 충분하지 않습니다. 새로운 버전의 콜백 모듈로 전환하기 전에 프로세스는 콜백 함수 &lt;code&gt;code_change&lt;/code&gt; 를 사용하여 명시 적으로 상태를 변환해야합니다 . 따라서 동기화 된 코드 교체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">이 경우 간단한 코드 교체로는 충분하지 않습니다. 특수 프로세스에 대한 새 버전의 체류 모듈이로드 될 때 프로세스는 루프 코드를 완전히 호출하여 새 코드로 전환해야합니다. 따라서 동기화 된 코드 교체를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">이 경우 호출 프로세스는 쉘이므로 다음 결과가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">이 경우 해당 모듈에서 기능을 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">이 경우, 주요 &lt;code&gt;Key&lt;/code&gt; 후속 호출에 사용될 수 리턴은하기 &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; 평가 값 검색 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 노드에서 &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">이 경우, 새로운 상태는 이용 가능한 채널 ( &lt;code&gt;Chs2&lt;/code&gt; )의 업데이트 된리스트이다 . &lt;code&gt;gen_server&lt;/code&gt; 는 이제 새로운 요청에 대한 준비가되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">이 경우 &lt;code&gt;.appup&lt;/code&gt; 파일 을 지정하지 않고도 릴리스 패키지의 자동 패킹 및 언 패킹, 자동 경로 업데이트 등이 포함 된 릴리스 핸들러 프레임 워크를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">이 경우, 응답은 할당 된 채널 ( &lt;code&gt;Ch&lt;/code&gt; ) 이고 새로운 상태는 남아있는 이용 가능한 채널 ( &lt;code&gt;Chs2&lt;/code&gt; )의 세트이다 .</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">이 경우 감독자는 등록되지 않습니다. 대신 pid를 사용해야합니다. &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; 또는 &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; 를 호출하여 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">이 경우 두 항을 독립적으로 해제합니다. &lt;code&gt;Erl_Interface&lt;/code&gt; 라이브러리는 참조 횟수를 사용하여 객체를 제거하기에 안전한시기를 결정 하므로 용어 &lt;code&gt;ep&lt;/code&gt; 및 &lt;code&gt;ep2&lt;/code&gt; 를 해제하는 순서는 중요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">이 예에서는 XML 파일의 특정 데이터를 검사하려는 상황을 고려하십시오. 예를 들어, 각 오토바이가 기록 된 시간을 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">이 예제에서 Pea 애플리케이션이 변경되었으며 ERTS, Kernel, STDLIB 및 SASL 애플리케이션도 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 숫자는 정수이고 코드 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 의 함수 인수는 변수라고합니다. 변수는 대문자로 시작해야합니다 ( &lt;code&gt;Variables&lt;/code&gt; 참조 ). 변수의 예는 &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;ShoeSize&lt;/code&gt; 및 &lt;code&gt;Age&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00141d9820384d0fe96047499c682c85df54a263" translate="yes" xml:space="preserve">
          <source>In this example we first create a new cons cell with an integer and a tuple with some text. Then a tuple of size three wrapping the other values with an atom tag is created and returned.</source>
          <target state="translated">이 예제에서 우리는 먼저 정수와 텍스트가있는 튜플이있는 새로운 cons 셀을 만듭니다. 그런 다음 원자 태그로 다른 값을 감싸는 크기 3의 튜플이 생성되고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">이 예에서는 값을 &quot;운반&quot;하는 목록 (이 경우 &lt;code&gt;Result_so_far&lt;/code&gt; )을 살펴 봅니다 . &lt;code&gt;list_max/1&lt;/code&gt; 은 단순히리스트의 최대 값이리스트의 헤드라고 가정하고리스트 의 나머지와리스트의 헤드 값으로 &lt;code&gt;list_max/2&lt;/code&gt; 를 호출 합니다. 위에서 이것은 &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; 입니다. 당신이 사용하려고하는 경우 &lt;code&gt;list_max/1&lt;/code&gt; 빈 목록 또는 모두에서 목록이 아닙니다 뭔가를 사용하려고하면 오류가 발생할 것입니다. Erlang 철학은 이러한 유형의 오류를 발생하는 함수에서 처리하는 것이 아니라 다른 곳에서 수행해야합니다. 나중에 이것에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">이 예에서 &lt;code&gt;suite/0&lt;/code&gt; 은 &lt;code&gt;Common Test&lt;/code&gt; 에 Telnet 및 SSH 연결의 출력을 억제하도록 지시 합니다. 이것은 모든 테스트 사례에 유효합니다. 그러나 &lt;code&gt;my_testcase1/0&lt;/code&gt; 은이 테스트 사례에 대해 SSH 만 자동으로 지정하도록 지정합니다. 결과적으로 &lt;code&gt;my_testcase1&lt;/code&gt; 은 SSH 정보가 아닌 로그에 Telnet 정보 (있는 경우)를 인쇄합니다. &lt;code&gt;my_testcase2&lt;/code&gt; 는 인쇄 된 연결에서 정보를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="f2f906325545f1417f1e6e7ea85883ce6305f126" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received.</source>
          <target state="translated">이 예에서는 &lt;code&gt;{Pid, Something}&lt;/code&gt; 이 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 &lt;code&gt;{Pid, Something}&lt;/code&gt; 이 수신되었습니다. 수신 된 pid는 &lt;code&gt;{goodbye,Pid}&lt;/code&gt; 를 리턴하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">이 예에서, 일련의 바이트가 외부 소스로부터 수신 된 다음 바이트는 유효한 Erlang 용어로 디코딩됩니다. 이것은 &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; 호출로 달성되었으며 ASN.1 유형 &lt;code&gt;Person&lt;/code&gt; 의 Erlang 값을 리턴했습니다 . 그런 다음 정의 된 ASN.1 유형의 인스턴스를 가져 와서 BER 또는 PER 인코딩 규칙에 따라 이진으로 변환하는 &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; 를 사용하여 응답을 구성하고 인코딩 했습니다.</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">이 예제에서 NIF 백엔드가있는 추적 프로그램 모듈 은 발신자와 수신자 만 포함하는 각 &lt;code&gt;send&lt;/code&gt; 추적 태그 에 대해 메시지를 보냅니다 . 이 추적 프로그램 모듈을 사용하면 훨씬 더 가벼운 메시지 추적 프로그램이 사용되며 누가 메시지를 보낸 사람 만 기록합니다.</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 환경 변수 &lt;code&gt;DISPLAY&lt;/code&gt; 가 &lt;code&gt;gin:0&lt;/code&gt; 으로 설정된 Erlang 런타임 시스템이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 문자열 형식 지정 지시문 &lt;code&gt;&quot;~s&quot;&lt;/code&gt; 하여 단일 문자 65를 출력하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">이 예에서, io : format 호출이 완료되면 호출 프로세스에서 설정된 모든 사용자 태그가 I / O 서버로 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">이 예제에서 각 런타임 시스템에는 각각 온라인으로 두 개의 스케줄러가 있으며 모든 온라인 스케줄러는 다른 코어에서 실행됩니다. 하나의 런타임 시스템에서 하나의 스케줄러를 온라인으로 변경하고 다른 하나의 스케줄러를 온라인으로 세 개의 스케줄러로 변경해도 온라인의 모든 스케줄러는 여전히 다른 코어에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">이 예에서 function &lt;code&gt;terminate/3&lt;/code&gt; 는 문이 열려 있으면 잠그므로 감독 트리가 종료 될 때 실수로 문을 열어 두지 않습니다.</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">첫 번째 요소는 키를 있었다면이 예에서는, 그것은에서 해당 키와 일치하는 것이 훨씬 더 효율적입니다 &lt;code&gt;MatchHead&lt;/code&gt; 의 보다 부분을 &lt;code&gt;MatchConditions&lt;/code&gt; 의 일부입니다. 일치 키를 가진 개체 만 검색 할 수 있도록 &lt;code&gt;MatchHead&lt;/code&gt; 와 관련하여 테이블의 검색 공간이 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">이 예제에서는 &lt;code&gt;open&lt;/code&gt; 상태 에서 버튼 이벤트를 무시하지 않고 이를 연기 할 수 있으며 대기 상태가되고 나중에 &lt;code&gt;locked&lt;/code&gt; 상태 에서 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">이 예에서는 다음 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">이 예에서는 &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; 섹션과 동일한 ASN.1 사양 이 사용됩니다. 다음은 유효한 선택적 디코딩 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">이 예에서 &quot;b.spec&quot;및 &quot;c.spec&quot;파일에 정의 된 테스트 용어는 소스 사양 &quot;a.spec&quot;(있는 경우)의 용어와 결합됩니다. &quot;d.spec&quot;및 &quot;e.spec&quot;사양을 포함 시키면 두 개의 독립적 인 독립적 인 테스트 실행이 포함됩니다 (포함 된 각 사양마다 하나씩).</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">이 예에서는 보관하려는 데이터 크기의 두 배 이상 이진을 참조하는 경우 이진 내용을 &lt;code&gt;gb_sets:set()&lt;/code&gt; 에 삽입하기 전에 이진 내용을 복사하기로했습니다 . 물론 다른 프로그램에 복사 할 때는 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">이 예에서는 'diffie-hellman-group1-sha1'을 먼저 넣고 &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; 을 kex 목록의 끝으로 이동 합니다. 즉, &lt;code&gt;append&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">이 예에서는 두 가지 옵션 ( &lt;code&gt;preferred_algorithms&lt;/code&gt; 및 &lt;code&gt;modify_algorithms&lt;/code&gt; )을 모두 사용 하고 지원되지 않는 알고리즘을 앞에 추가하려고합니다. 지원되지 않는 알고리즘은 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">이 예에서는 다음 ASN.1 사양의 정의가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">다음 예에서 비밀번호는 &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">이 모드에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">이 모듈에서 V는 비워 둘 수 있습니다. 이렇게 얻은 고유 한 digraph를 &lt;strong id=&quot;empty_digraph&quot;&gt;빈 digraph&lt;/strong&gt; 라고합니다 . 정점과 모서리는 모두 고유 한 Erlang 용어로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">이 모듈에서 고려되는 유일한 패밀리는 일부 세트 X의 서브 세트 패밀리입니다. 이하에서, &quot;패밀리&quot;라는 단어는 이러한 서브 세트 패밀리에 사용된다.</target>
        </trans-unit>
        <trans-unit id="9df8795a77ab5095acba5e23497d16dae8d5c2f4" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the time-out since the time-out event is the only possible reason to do a &lt;strong&gt;state change&lt;/strong&gt; from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">시간 제한 이벤트가 할 수있는 유일한 가능한 이유 때문에이 특별한 경우에 우리는 시간 제한을 취소 할 필요가 없습니다 &lt;strong&gt;상태 변경을&lt;/strong&gt; 에서 &lt;code&gt;open&lt;/code&gt; 에 &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">시간 제한 이벤트에서 상태를 변경하는 유일한 가능한 이유 때문에이 특별한 경우에 우리는 타임 아웃을 취소 할 필요가 없습니다 &lt;code&gt;open&lt;/code&gt; 에 &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">이 특정 경우, 명령 &lt;code&gt;i&lt;/code&gt; ( &quot;인터럽트&quot;)는 루핑 프로그램을 종료하고 명령 &lt;code&gt;c&lt;/code&gt; 는 쉘에 다시 연결됩니다. 프로세스가 &lt;code&gt;** exception exit: killed&lt;/code&gt; 되기 전에 백그라운드에서 실행 중 이었으므로 &quot; ** exception exit : killed &quot; 메시지가 표시되기 전에 더 많은 인쇄가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">이 시나리오에서 ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; 을 보호하는 잠금 은 대부분의 대기 시간을 소비했습니다. 60 초 동안 실행 된 테스트에서 1.8 초입니다. 시간은 또한 8 개의 다른 스케줄러 스레드에 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Domain&lt;/code&gt; 필드 중 하나, 즉 반송 도메인이다 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 또는 &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; 은 및 &lt;code&gt;Addr&lt;/code&gt; 필드가있다 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 튜플.</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">이 섹션에서 &lt;code&gt;Address&lt;/code&gt; 필드는 &lt;code&gt;{Domain, Addr}&lt;/code&gt; 튜플이며 여기서 &lt;code&gt;Domain&lt;/code&gt; 은 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 또는 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; 이고 &lt;code&gt;Addr&lt;/code&gt; 은 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">이 섹션에는 모든 유효한 Erlang 표현식이 나열됩니다. Erlang 프로그램을 작성할 때 매크로 및 레코드 표현식을 사용할 수도 있습니다. 그러나 이러한 표현식은 컴파일 중에 확장되며 그런 의미에서 Erlang 표현식이 아닙니다. 매크로 및 레코드 표현식은 별도의 섹션으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">이 섹션에서는 사용자 이름이 &lt;code&gt;otpuser&lt;/code&gt; 이고 해당 사용자의 홈 디렉토리 가 다음 과 같다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">이 섹션에서는 다음과 같은 용어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">이 간단한 경우에, 가독성 측면에서 전자의 표현이 바람직 할 것이다.</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">이런 식으로 링크를 사용하여 트랜잭션의 모든 프로세스를 함께 연결할 수 있습니다. 프로세스 중 하나가 비정상적으로 종료되면 트랜잭션의 모든 프로세스가 종료됩니다. 종종 같은 시간에 그것을 프로세스와 링크를 만들고 싶었되기 때문에,이 특별한 BIF이다 &lt;code&gt;spawn_link&lt;/code&gt; 과 동일하지 &lt;code&gt;spawn&lt;/code&gt; , 또한 생성 된 프로세스에 대한 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="04cd30a6181cf29b11e39620fc1e71c03e622ab5" translate="yes" xml:space="preserve">
          <source>In those circumstances, &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; must be invoked to set up the pointer again. &lt;strong&gt;beam_makeops&lt;/strong&gt; will notice if there is a call to a function that does a garbage collection and &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; is not called.</source>
          <target state="translated">이러한 상황 에서 포인터를 다시 설정하려면 &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; 를 호출해야합니다. &lt;strong&gt;beam_makeops&lt;/strong&gt; 는 가비지 콜렉션을 수행하는 함수에 대한 호출이 있고 &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; 가 호출되지 않은 경우이를 알립니다 .</target>
        </trans-unit>
        <trans-unit id="12987c6a024d031823b3213c0fb06e759b8cd0bf" translate="yes" xml:space="preserve">
          <source>In those functions the internal crypto state is first created and initialized with the cipher type, the key and possibly other data. Then the single binary is encrypted or decrypted, the crypto state is de-allocated and the result of the crypto operation is returned.</source>
          <target state="translated">이러한 기능에서 내부 암호화 상태는 먼저 암호화 유형, 키 및 기타 데이터로 생성되고 초기화됩니다. 그런 다음 단일 바이너리가 암호화되거나 해독되고, 암호화 상태가 할당 해제되고 암호화 작업의 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">기존의 관계형 데이터베이스 용어에서이 작업을 선택이라고하며 투영이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StartMessage&lt;/code&gt; 유형에서 필드 &lt;code&gt;content&lt;/code&gt; 뒤의 제한 조건 은 &lt;code&gt;StartMessage&lt;/code&gt; 유형 의 값에서 필드 &lt;code&gt;content&lt;/code&gt; 의 값이 msgId 필드 에서 선택한 동일한 오브젝트에서 &lt;code&gt;msgId&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">megaco 표준 버전 3에서는 세분화 패키지가 도입되었습니다. 간단히 말해서,이 패키지는 자동으로이를 수행하지 않는 전송 (예 : UDP)을 사용할 때 megaco 메시지 (트랜잭션 응답)를 분할하는 절차를 정의합니다. &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63b6f2d5cd37bdba6df81460e958046ee197cfa0" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard, the concept of &lt;code&gt;segmentation package&lt;/code&gt; was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">megaco 표준 버전 3에서는 &lt;code&gt;segmentation package&lt;/code&gt; 개념 이 도입되었습니다. 간단히 말해서,이 패키지는이를 자동으로 수행하지 않는 전송 (예 : UDP)을 사용할 때 megaco 메시지 (트랜잭션 응답)를 분할하는 절차를 정의합니다. &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">&lt;code&gt;kernel-3.0&lt;/code&gt; -3.0은 어떤 OTP 버전에 도입 되었습니까?</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">자체 추적 처리기 함수에서 &lt;code&gt;io&lt;/code&gt; 함수 대신 &lt;code&gt;erlang:display/1&lt;/code&gt; 을 호출 하거나 &lt;code&gt;user&lt;/code&gt; 가 그룹 리더로 사용되지 않는 경우 기본 그룹 리더 대신 &lt;code&gt;user&lt;/code&gt; 에게 인쇄 하십시오. 예 : &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">인 밴드 보안 ID AVP</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">인 밴드 보안 ID AVP (코드 299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">Inband-Security-Id의 기본값은 빈 목록으로, 0을 포함하는 목록 (NO_INBAND_SECURITY)과 같습니다. 1 (TLS)이 지정된 경우 피어에서 수신 한 CER / CEA가이를 제공하면 TLS가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">바이너리의 인바운드 바이너리 인코딩</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">목록 및 이진의 인바운드 백분율 인코딩</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">또한 테스트 사례가 수정 되면 실제로 &lt;code&gt;channel&lt;/code&gt; 버그를 발견해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">Erlang의 경로에 &lt;code&gt;dir&lt;/code&gt; 을 포함하십시오 . &lt;code&gt;-include_lib()&lt;/code&gt; 지시문 이있는 파일을 분석 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="cae53151741eb56a1003fee69921d65824bcd040" translate="yes" xml:space="preserve">
          <source>Include Directories and Macro Definitions</source>
          <target state="translated">디렉터리 및 매크로 정의 포함</target>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">디렉토리도 테스트 사양에 지정 될 수 있습니다 포함, 참조 &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">파일 포함</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">포함 파일은 일반적으로 여러 모듈이 공유하는 레코드 및 매크로 정의에 사용됩니다. 포함 파일에는 파일 이름 확장자 &lt;code&gt;.hrl&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6ec71a4f09bb1029d3d4fb8244b9d00627d2bcc0" translate="yes" xml:space="preserve">
          <source>Include the correct tool's include file</source>
          <target state="translated">올바른 도구의 포함 파일 포함</target>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">토큰 주석에 토큰 텍스트를 포함하십시오. 텍스트는 토큰에 해당하는 입력 부분입니다.</target>
        </trans-unit>
        <trans-unit id="1318cfcd94087f09bec8c0a46a0ba00bc818ff6b" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return value(s).</source>
          <target state="translated">구조화 된 리턴 값을 무시하거나 가능한 많은 리턴 값 중 하나와 일치하지 않는 함수 호출에 대한 경고를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="b72333c2c10be7a2ac2a052bd2a51691c99a5707" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return values. However, no warnings are included if the possible return values are a union of atoms or a union of numbers.</source>
          <target state="translated">구조화 된 반환 값을 무시하거나 가능한 많은 반환 값 중 하나와 일치하지 않는 함수 호출에 대한 경고를 포함합니다. 그러나 가능한 반환 값이 원자 합집합 또는 숫자 합집합이면 경고가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="787b1e3adc3eb7a1d5a6e75a6a8e36064a54f61d" translate="yes" xml:space="preserve">
          <source>Include warnings for functions that only return by an exception.</source>
          <target state="translated">예외에 의해서만 리턴되는 함수에 대한 경고를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="c9c702014dc9102936a21eccc903c8d6fd60705b" translate="yes" xml:space="preserve">
          <source>Include warnings for possible race conditions. Notice that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk.</source>
          <target state="translated">가능한 경쟁 조건에 대한 경고를 포함하십시오. 데이터 레이스를 찾는 분석은 절차 내 데이터 흐름 분석을 수행하며 때로는 시간이지나면서 폭발 할 수 있습니다. 자신의 책임하에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c2da810ae50606f552a617f96c162b1a8a5cbb8d" translate="yes" xml:space="preserve">
          <source>Included test messages</source>
          <target state="translated">포함 된 테스트 메시지</target>
        </trans-unit>
        <trans-unit id="d01cc8205d9d2d88536ce346d12fc476f915ab3e" translate="yes" xml:space="preserve">
          <source>Includes a section containing call statistics for all calls regardless of process, in the analysis.</source>
          <target state="translated">프로세스에 관계없이 모든 통화에 대한 통화 통계를 포함하는 섹션을 분석에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="529e9b923d0287eecd76a416e52d97fdc8ea0d45" translate="yes" xml:space="preserve">
          <source>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지에 타임 스탬프를 포함합니다. 타임 스탬프 (Ts)는 &lt;code&gt;erlang:now()&lt;/code&gt; 반환 한 형식과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c46ef04f4bea55e14a8a6db20798656add229d29" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지에 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 스탬프를 포함 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; 의해 생성 된 것과 동일한 형식 및 값을 갖습니다 . 이 플래그는 &lt;code&gt;cpu_timestamp&lt;/code&gt; 플래그를 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="21580f3961c21f1aceb751d4061a09b3a76955d6" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지에 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 스탬프를 포함 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; 의해 생성 된 것과 동일한 형식과 값을 갖습니다 . 이 플래그는 &lt;code&gt;cpu_timestamp&lt;/code&gt; 플래그를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="029776045f3168e0cc5e9e683547f1e18a0a84fc" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt; erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지 에 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 과 단조 증가하는 정수 로 구성된 타임 스탬프를 포함 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt; erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt; erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 에 의해 생성 된 것과 동일한 형식 및 값을 갖습니다 . 이 플래그는 &lt;code&gt;cpu_timestamp&lt;/code&gt; 플래그를 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="7123f161553e4dd460e1a837d1a70b743db16fa4" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">모든 추적 메시지에서 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; 과 단조 증가 정수 로 구성된 타임 스탬프를 포함 합니다. 타임 스탬프 (Ts)는 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 에서 생성 한 것과 동일한 형식과 값을 갖습니다 . 이 플래그는 &lt;code&gt;cpu_timestamp&lt;/code&gt; 플래그를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="59a53faa5ece992bf6eb22ad8651276afec5c122" translate="yes" xml:space="preserve">
          <source>Includes custom debug information in the form of a &lt;code&gt;Backend&lt;/code&gt; module with custom &lt;code&gt;Data&lt;/code&gt; in the compiled beam module. The given module must implement a &lt;code&gt;debug_info/4&lt;/code&gt; function and is responsible for generating different code representations, as described in the &lt;code&gt;debug_info&lt;/code&gt; under &lt;code&gt;beam_lib(3)&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 빔 모듈에 사용자 정의 &lt;code&gt;Data&lt;/code&gt; 가있는 &lt;code&gt;Backend&lt;/code&gt; 모듈 형식의 사용자 정의 디버그 정보를 포함 합니다. 지정된 모듈은 &lt;code&gt;debug_info/4&lt;/code&gt; 함수를 구현해야하며 &lt;code&gt;beam_lib(3)&lt;/code&gt; 아래 의 &lt;code&gt;debug_info&lt;/code&gt; 에 설명 된대로 다른 코드 표현을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="09654fa1bf12f6550a22d7f012f2848d49adaf98" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt; Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">컴파일 된 빔 모듈 의 &lt;code&gt;debug_info&lt;/code&gt; 청크에 &lt;code&gt; Erlang Abstract Format&lt;/code&gt; 형식 의 디버그 정보를 포함 합니다. Debugger, Xref 및 Cover와 같은 도구를 사용하려면 디버그 정보를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="b72745ef15f97e2eed8ddb85c88ed3745778131f" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt;Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">컴파일 된 빔 모듈 의 &lt;code&gt;debug_info&lt;/code&gt; 청크에 &lt;code&gt;Erlang Abstract Format&lt;/code&gt; 형식 의 디버그 정보를 포함 합니다. Debugger, Xref 및 Cover와 같은 도구에는 디버그 정보가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="50ee9bd2b0973e0a8782664b4e20754ea8733fba" translate="yes" xml:space="preserve">
          <source>Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option &lt;code&gt;debug_info&lt;/code&gt; as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code.</source>
          <target state="translated">디버그 정보를 포함하지만 키를 제공하지 않으면 액세스 할 수 없도록 암호화합니다. ( &lt;code&gt;debug_info&lt;/code&gt; 옵션도 제공 할 수 있지만 반드시 필요한 것은 아닙니다.)이 옵션을 사용하면 테스트 중에 디버그 정보를 항상 사용할 수 있지만 소스 코드는 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="805a2af44ca1e2b71562d035c3b42720d4a88944" translate="yes" xml:space="preserve">
          <source>Includes property &lt;code&gt;{role, client | server}&lt;/code&gt;. Currently this is the only predefined property, there can also be user-defined properties. See also application environment variable &lt;code&gt;session_cb_init_args&lt;/code&gt;.</source>
          <target state="translated">속성 포함 &lt;code&gt;{role, client | server}&lt;/code&gt; . 현재이 속성은 사전 정의 된 유일한 속성이며 사용자 정의 속성도있을 수 있습니다. 응용 프로그램 환경 변수 &lt;code&gt;session_cb_init_args&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3537d431c47b4e76cf518f3b56096886e6209c2b" translate="yes" xml:space="preserve">
          <source>Including Literal Strings</source>
          <target state="translated">리터럴 문자열 포함</target>
        </trans-unit>
        <trans-unit id="7705cf570e0db2364f0a8b0f968c2b052243e5be" translate="yes" xml:space="preserve">
          <source>Incoming Connections</source>
          <target state="translated">들어오는 연결</target>
        </trans-unit>
        <trans-unit id="cfffe82b107254cee4127c092afe584c0200b55a" translate="yes" xml:space="preserve">
          <source>Incoming Diameter messages are decoded from binary() before being communicated to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; module for transmission. The functions documented here implement the default encode/decode.</source>
          <target state="translated">들어오는 Diameter 메시지는 &lt;code&gt;diameter_app(3)&lt;/code&gt; 콜백 에 전달되기 전에 binary ()에서 디코딩됩니다 . 마찬가지로, 나가는 Diameter 메시지는 전송 을 위해 적절한 &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; 모듈 로 전달되기 전에 binary ()로 인코딩됩니다 . 여기에 문서화 된 기능은 기본 인코딩 / 디코딩을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c632222fe59d6393835f1d6b41daa8dcbb54dc28" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and normally decoded successfully. But if the decoding failed this function is called in order to decide if the originator should get a reply message (reply) or if the reply silently should be discarded (no_reply).</source>
          <target state="translated">들어오는 메시지는 megaco : receive_message / 4에 의해 전달되고 정상적으로 디코딩됩니다. 그러나 디코딩에 실패한 경우이 기능이 호출되어 발신자가 회신 메시지를 받아야하는지 (응답) 또는 회신을 자동으로 폐기해야하는지 (no_reply) 결정합니다.</target>
        </trans-unit>
        <trans-unit id="bbb9b00cfc07d6474962cea0fb79594d0c7f33f6" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions and this function is invoked for each TransactionRequest in the message.</source>
          <target state="translated">들어오는 메시지는 megaco : receive_message / 4에 의해 전달되고 성공적으로 디코딩됩니다. 일반적으로 메시지에는 트랜잭션 목록이 포함되어 있으며이 함수는 메시지의 각 TransactionRequest에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2155d7b153e6ddad7244575ab829476e447287" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions, but it may instead contain an ErrorDescriptor on top level of the message.</source>
          <target state="translated">들어오는 메시지는 megaco : receive_message / 4에 의해 전달되고 성공적으로 디코딩됩니다. 일반적으로 메시지에는 트랜잭션 목록이 포함되지만 대신 메시지의 최상위 레벨에 ErrorDescriptor가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="793c36e1e4e2e9196eba0419d11fe32cd2342b1a" translate="yes" xml:space="preserve">
          <source>Incompatible changes may occur between releases.</source>
          <target state="translated">릴리스간에 호환되지 않는 변경이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e211548a14ccbf061765bad659c7e963fece50" translate="yes" xml:space="preserve">
          <source>Inconsistent stream state.</source>
          <target state="translated">스트림 상태가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f91465c3f77f3d3269bf0de89bd0e5136eadf0ec" translate="yes" xml:space="preserve">
          <source>Incorrect UTF encoding.</source>
          <target state="translated">잘못된 UTF 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="845a0fc6405933efbba9490c6fc4f32adaee1aa6" translate="yes" xml:space="preserve">
          <source>Incr :: integer()) -&amp;gt;</source>
          <target state="translated">증분 :: 정수 ())-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1d24ce4d50ea5331d982cda5d863bb706d720600" translate="yes" xml:space="preserve">
          <source>Increases the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스에서 일시 중단 횟수를 늘리고 해당 상태가 아닌 경우 일시 중단 상태로 만듭니다. 일시 중단 된 프로세스는 프로세스가 재개 될 때까지 실행 예약되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="360be904729f90e5380efbfa1ebc525a6bb6168c" translate="yes" xml:space="preserve">
          <source>Increasingly bad performance of mmap/munmap as the number of mmap'ed areas grow.</source>
          <target state="translated">mmap 영역의 수가 증가함에 따라 mmap / munmap의 성능이 점점 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="c1ce75ee57dec21e5d02eb0055b76a4460422603" translate="yes" xml:space="preserve">
          <source>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</source>
          <target state="translated">NIF 라이브러리가 호환되지 않는 변경 사항이 Erlang 런타임 시스템에 적용될 때 증가합니다. 일반적으로 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; 이 변경 되면 NIF 라이브러리를 다시 컴파일하면 충분 하지만 드문 경우지만 NIF 라이브러리를 약간 수정해야 할 수도 있습니다. 그렇다면, 이것은 문서화 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="84678a3e577756daefc285cd45b2bc2e297ad5ec" translate="yes" xml:space="preserve">
          <source>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</source>
          <target state="translated">새로운 기능이 추가되면 증가합니다. 런타임 시스템은 부 버전을 사용하여 사용할 기능을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="57135dbc3bf5f91f10354efacc0f552c2d6e0f14" translate="yes" xml:space="preserve">
          <source>Increments a variable in the MIB with &lt;code&gt;N&lt;/code&gt;, or one if &lt;code&gt;N&lt;/code&gt; is not specified.</source>
          <target state="translated">MIB에서 변수를 &lt;code&gt;N&lt;/code&gt; 으로 증가 시키거나 &lt;code&gt;N&lt;/code&gt; 이 지정되지 않은 경우 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="9c9e63796462f25fa87f2866f5f82ef633d51dee" translate="yes" xml:space="preserve">
          <source>Increments map iterator to point to the next key-value entry.</source>
          <target state="translated">이터레이터는 다음 키-값 항목을 가리 키도록 반복자를 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="8f239c48f8608dfc7dad0cea2bfd35ef11b36366" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">인수 ( &lt;code&gt;pdl&lt;/code&gt; ) 로 전달 된 포트 데이터 잠금의 참조 횟수를 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="d877566e1bec90ff2d29720de068fd3d3fddd99b" translate="yes" xml:space="preserve">
          <source>Increments the reference count on &lt;code&gt;bin&lt;/code&gt; and returns the reference count reached after the increment.</source>
          <target state="translated">에 증가 참조 카운트를 &lt;code&gt;bin&lt;/code&gt; 반환은 참조 횟수가 증가 후에 도달했다.</target>
        </trans-unit>
        <trans-unit id="6885d93d080432a665a8c21adf295eb79d2e88f7" translate="yes" xml:space="preserve">
          <source>Increments the variable associated with a discarded pdu. This function can be used when the net_if process receives a &lt;code&gt;discarded_pdu&lt;/code&gt; message from the agent.</source>
          <target state="translated">폐기 된 pdu와 연관된 변수를 증가시킵니다. 이 기능은 net_if 프로세스 가 에이전트로부터 &lt;code&gt;discarded_pdu&lt;/code&gt; pp 메시지를 수신 할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aacf42132cce6cf5c1608a5d27f90fcbf93ae851" translate="yes" xml:space="preserve">
          <source>Indent</source>
          <target state="translated">Indent</target>
        </trans-unit>
        <trans-unit id="a1dc8ae1f28e23fc7131a69f785c7a7e4f9ac70d" translate="yes" xml:space="preserve">
          <source>Indents a document a number of character positions to the right. Note that &lt;code&gt;N&lt;/code&gt; may be negative, shifting the text to the left, or zero, in which case &lt;code&gt;D&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">문서를 오른쪽으로 여러 문자 위치를 들여 씁니다. 참고 &lt;code&gt;N&lt;/code&gt; 은 케이스있는 왼쪽, 또는 제로의 텍스트를 이동, 음수 일 수 &lt;code&gt;D&lt;/code&gt; 는 그대로 리턴된다.</target>
        </trans-unit>
        <trans-unit id="b03e59c23d6f82c97ce8cf0f7790602979c8e4da" translate="yes" xml:space="preserve">
          <source>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</source>
          <target state="translated">인덱스는 무료로 제공되지 않습니다. 테이블 크기에 비례하는 공간을 차지하며 테이블 삽입이 약간 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="66f3ae8a6cbff45c5e61fef46e620b30441f2993" translate="yes" xml:space="preserve">
          <source>Indexes in a table must be objects, not types (deviates from SMIv1 only).</source>
          <target state="translated">테이블의 인덱스는 유형이 아닌 객체 여야합니다 (SMIv1과 다름).</target>
        </trans-unit>
        <trans-unit id="41fd24de9543beb15639d7be950596afb05d2918" translate="yes" xml:space="preserve">
          <source>Indexes into atomic arrays are one-based. An atomic array of arity N contains N atomics with index from 1 to N.</source>
          <target state="translated">원자 배열에 대한 인덱스는 1 기반입니다. arity N의 원자 배열에는 인덱스가 1에서 N까지 인 N 원자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d1276b938031e0556a12602f87fa510de52c86d9" translate="yes" xml:space="preserve">
          <source>Indexes into counter arrays are one-based. A counter array of size N contains N counters with index from 1 to N.</source>
          <target state="translated">카운터 배열에 대한 인덱스는 1부터 시작합니다. 크기가 N 인 카운터 배열에는 인덱스가 1부터 N까지 인 N 카운터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="617aa3438335193f784faa90321050a9a7e9ecfd" translate="yes" xml:space="preserve">
          <source>Indicate if the elements of the array will be treated as signed or unsigned integers. Default is &lt;code&gt;true&lt;/code&gt; (signed).</source>
          <target state="translated">배열의 요소가 부호있는 정수 또는 부호없는 정수로 처리되는지 여부를 나타냅니다. 기본값은 &lt;code&gt;true&lt;/code&gt; (서명 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="295bcf395f6ba1c793b51510dd315c49a1cd7e27" translate="yes" xml:space="preserve">
          <source>Indicates a broken link. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes.</source>
          <target state="translated">끊어진 링크를 나타냅니다. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; 및 &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; 에는 연결된 프로세스의 pid가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6278f3e704c53d6a2b0b2b9ee6bea9f7e00a82d7" translate="yes" xml:space="preserve">
          <source>Indicates a customized prologue file which the user may want to use instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; which is otherwise included at the beginning of the resulting parser file. &lt;strong&gt;N.B.&lt;/strong&gt; The &lt;code&gt;Includefile&lt;/code&gt; is included 'as is' in the parser file, so it must not have a module declaration of its own, and it should not be compiled. It must, however, contain the necessary export declarations. The default is indicated by &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">결과 파서 파일의 시작 부분에 포함 된 기본 파일 &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; 대신 사용자가 사용할 수있는 사용자 정의 된 프롤로그 파일을 나타냅니다 . &lt;strong&gt;NB &lt;/strong&gt; &lt;code&gt;Includefile&lt;/code&gt; 는 그것의 자신의 모듈 선언이 없어야하므로, 파서 파일에 '있는 그대로', 그리고 컴파일하지 말아야 포함되어 있습니다. 그러나 필요한 내보내기 선언이 포함되어 있어야합니다. 기본값은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7baca088d4a47e1b532691a75a666d58750c6872" translate="yes" xml:space="preserve">
          <source>Indicates change of the status of the IP address of the peer specified by &lt;code&gt;addr&lt;/code&gt; within association &lt;code&gt;assoc_id&lt;/code&gt;. Possible values of &lt;code&gt;state&lt;/code&gt; (mostly self-explanatory) include:</source>
          <target state="translated">연관 &lt;code&gt;assoc_id&lt;/code&gt; 내에서 &lt;code&gt;addr&lt;/code&gt; 로 지정된 피어의 IP 주소 상태 변경을 나타냅니다 . 가능한 &lt;code&gt;state&lt;/code&gt; 값 (주로 자체 설명)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1e223ab1bee245ce8340356f73b51f2137316ba" translate="yes" xml:space="preserve">
          <source>Indicates character range</source>
          <target state="translated">문자 범위를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="ac69dafa8c067eb5122ac56c8384ac8f712d4875" translate="yes" xml:space="preserve">
          <source>Indicates if all application code paths are to be updated (&lt;code&gt;Bool==true&lt;/code&gt;) or if only code paths for modified applications are to be updated (&lt;code&gt;Bool==false&lt;/code&gt;, default). This option has only effect for other application directories than the default &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt;, that is, application directories specified in argument &lt;code&gt;AppDirs&lt;/code&gt; in a call to &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 응용 프로그램 코드 경로를 업데이트할지 ( &lt;code&gt;Bool==true&lt;/code&gt; ) 수정 된 응용 프로그램의 코드 경로 만 업데이트할지 ( &lt;code&gt;Bool==false&lt;/code&gt; , 기본값)를 나타냅니다. 이 옵션은 기본 &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt; 이외의 다른 응용 프로그램 디렉토리 , 즉 &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 AppDirs 인수에 지정된 응용 프로그램 디렉토리 &lt;code&gt;AppDirs&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
