<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="243bac6201188d4c8745d8544eb1a7983b8606fa" translate="yes" xml:space="preserve">
          <source>Depending on current directory, and writing there:</source>
          <target state="translated">현재 디렉토리에 따라 작성 :</target>
        </trans-unit>
        <trans-unit id="cdde803659c57ac2ddc339522c646af01e6694a2" translate="yes" xml:space="preserve">
          <source>Depending on execution order:</source>
          <target state="translated">실행 순서에 따라</target>
        </trans-unit>
        <trans-unit id="4e25fe3d3f1520c00d56f174734b9eb9bce227c1" translate="yes" xml:space="preserve">
          <source>Depending on how your state machine is specified, this can be a very useful feature, but it forces you to handle the &lt;strong&gt;state enter calls&lt;/strong&gt; in all states. See also the &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Actions&quot;&gt; State Enter Actions &lt;/a&gt;&lt;/code&gt; section.</source>
          <target state="translated">상태 시스템을 지정하는 방법에 따라 이것은 매우 유용한 기능이 될 수 있지만 모든 상태에서 &lt;strong&gt;상태 입력 호출&lt;/strong&gt; 을 처리 &lt;strong&gt;해야합니다&lt;/strong&gt; . &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Actions&quot;&gt; State Enter Actions &lt;/a&gt;&lt;/code&gt; 섹션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dee5fe53ac8542b7adfcc26071a2cc098a90e75" translate="yes" xml:space="preserve">
          <source>Depending on how your state machine is specified, this can be a very useful feature, but it forces you to handle the state enter calls in all states. See also the &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Actions&quot;&gt;State Enter Actions&lt;/a&gt;&lt;/code&gt; chapter.</source>
          <target state="translated">상태 시스템을 지정하는 방법에 따라이 기능은 매우 유용한 기능이지만 모든 상태에서 상태 입력 호출을 처리하도록합니다. &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Actions&quot;&gt;State Enter Actions&lt;/a&gt;&lt;/code&gt; 장도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9291af56bff8b9929663e0373b04939eaa6165fd" translate="yes" xml:space="preserve">
          <source>Depending on the application, it can be a good idea to use the dirty functions for certain operations. Almost all Mnesia functions that can be called within transactions have a dirty equivalent, which is much more efficient.</source>
          <target state="translated">응용 프로그램에 따라 특정 작업에 더티 기능을 사용하는 것이 좋습니다. 트랜잭션 내에서 호출 할 수있는 거의 모든 Mnesia 함수는 더티에 상응하는 더티를 가지고있어 훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dabd0167e15f1eb7094245774e052022449eed10" translate="yes" xml:space="preserve">
          <source>Depending on the encoding rules, the encoder can also compare the given value to the default value and automatically omit the encoding if the values are equal. How much effort the encoder makes to compare the values depends on the encoding rules. The DER encoding rules forbid encoding a value equal to the default value, so it has a more thorough and time-consuming comparison than the encoders for the other encoding rules.</source>
          <target state="translated">인코딩 규칙에 따라 인코더는 주어진 값을 기본값과 비교하고 값이 같은 경우 인코딩을 자동으로 생략 할 수 있습니다. 인코더가 값을 비교하기 위해 얼마나 많은 노력을 기울이는지는 인코딩 규칙에 따라 다릅니다. DER 인코딩 규칙은 기본값과 같은 값을 인코딩하는 것을 금지하므로 다른 인코딩 규칙의 인코더보다 더 철저하고 시간이 많이 소요됩니다.</target>
        </trans-unit>
        <trans-unit id="08626437fb40efba7dbca9b44d332c33a8162802" translate="yes" xml:space="preserve">
          <source>Depending on the encoding, different methods of reading and writing data is preferred. The default encoding of &lt;code&gt;latin1&lt;/code&gt; implies using this module (&lt;code&gt;file&lt;/code&gt;) for reading and writing data as the interfaces provided here work with byte-oriented data. Using other (Unicode) encodings makes the &lt;code&gt;io(3)&lt;/code&gt; functions &lt;code&gt;get_chars&lt;/code&gt;, &lt;code&gt;get_line&lt;/code&gt;, and &lt;code&gt;put_chars&lt;/code&gt; more suitable, as they can work with the full Unicode range.</source>
          <target state="translated">인코딩에 따라 데이터를 읽고 쓰는 다른 방법이 선호됩니다. &lt;code&gt;latin1&lt;/code&gt; 의 기본 인코딩은 여기에 제공된 인터페이스가 바이트 지향 데이터와 작동하므로 데이터를 읽고 쓰는 데이 모듈 ( &lt;code&gt;file&lt;/code&gt; )을 사용함을 의미 합니다. 다른 (유니 코드) 인코딩을 사용하면 &lt;code&gt;io(3)&lt;/code&gt; 함수 &lt;code&gt;get_chars&lt;/code&gt; , &lt;code&gt;get_line&lt;/code&gt; 및 &lt;code&gt;put_chars&lt;/code&gt; 가 전체 유니 코드 범위에서 작동 할 수 있으므로 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="3a4a2bd194c4b302cc838a7198f9734aad7fbc66" translate="yes" xml:space="preserve">
          <source>Depending on the platform, the value may need to be quoted if the shell itself interprets certain characters. On Unix, terms containing tuples and lists must be quoted. Terms containing spaces must be quoted on all platforms.</source>
          <target state="translated">셸 자체가 특정 문자를 해석하는 경우 플랫폼에 따라 값을 인용해야 할 수 있습니다. 유닉스에서는 튜플과리스트를 포함하는 용어를 인용해야합니다. 공백이 포함 된 용어는 모든 플랫폼에서 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="03c613c2a141cff91e371843ee43ffefd0b81ace" translate="yes" xml:space="preserve">
          <source>Depending on the type of &lt;code&gt;Node&lt;/code&gt;, the size of some groups may be variable (e.g., the group consisting of all the elements of a tuple), while others always contain the same number of elements - usually exactly one (e.g., the group containing the argument expression of a case-expression). Note, however, that the exact structure of the returned list (for a given node type) should in general not be depended upon, since it might be subject to change without notice.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 의 유형에 따라 일부 그룹의 크기는 가변적 일 수 있지만 (예 : 튜플의 모든 요소로 구성된 그룹) 다른 그룹은 항상 같은 수의 요소를 포함합니다 (일반적으로 정확히 하나 (예 : case-expression의 인수 표현식). 그러나 리턴 된 목록의 정확한 구조 (주어진 노드 유형에 대한)는 일반적으로 예고없이 변경 될 수 있으므로 의존하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="377f14389e9e0ac790724578e98e3d818a0aadfe" translate="yes" xml:space="preserve">
          <source>Depending on the underlying OS:es links might be followed and info on the final file, directory etc is returned. See &lt;code&gt;&lt;a href=&quot;#read_link_info-2&quot;&gt;read_link_info/2&lt;/a&gt;&lt;/code&gt; on how to get information on links instead.</source>
          <target state="translated">기본 OS에 따라 링크를 따라갈 수 있으며 최종 파일, 디렉토리 등에 대한 정보가 반환됩니다. 대신 링크에 대한 정보를 얻는 방법에 대해서는 &lt;code&gt;&lt;a href=&quot;#read_link_info-2&quot;&gt;read_link_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f72e0a79aede683f74da3cac9428753ce30b12f5" translate="yes" xml:space="preserve">
          <source>Depending on the underlying OS:es links might be followed and info on the final file, directory etc is returned. See &lt;code&gt;&lt;a href=&quot;#read_link_info-2&quot;&gt;ssh_sftp::read_link_info/2&lt;/a&gt;&lt;/code&gt; on how to get information on links instead.</source>
          <target state="translated">기본 OS : es 링크에 따라 최종 파일, 디렉토리 등의 정보가 반환 될 수 있습니다. 링크에 대한 정보를 얻는 방법에 대해서는 &lt;code&gt;&lt;a href=&quot;#read_link_info-2&quot;&gt;ssh_sftp::read_link_info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccc799c653ce6450978e4f7f091a0e0d6ab495d4" translate="yes" xml:space="preserve">
          <source>Depending on the value of the &lt;code&gt;open/1&lt;/code&gt; options &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;head_func&lt;/code&gt;, or set by function &lt;code&gt;change_header/2&lt;/code&gt;, the value of &lt;code&gt;Head&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt; (default), &lt;code&gt;{head, H}&lt;/code&gt; (&lt;code&gt;head&lt;/code&gt; option), or &lt;code&gt;{M,F,A}&lt;/code&gt; (&lt;code&gt;head_func&lt;/code&gt; option).</source>
          <target state="translated">&lt;code&gt;open/1&lt;/code&gt; 옵션 &lt;code&gt;head&lt;/code&gt; 및 &lt;code&gt;head_func&lt;/code&gt; 의 값에 따라 또는 &lt;code&gt;change_header/2&lt;/code&gt; 함수에 의해 설정된 &lt;code&gt;Head&lt;/code&gt; 의 값 은 &lt;code&gt;none&lt;/code&gt; (기본값), &lt;code&gt;{head, H}&lt;/code&gt; ( &lt;code&gt;head&lt;/code&gt; option) 또는 &lt;code&gt;{M,F,A}&lt;/code&gt; 입니다. ( &lt;code&gt;head_func&lt;/code&gt; 옵션).</target>
        </trans-unit>
        <trans-unit id="28c197c51b5a2b60df55d2b8e85ac6377c6edcdf" translate="yes" xml:space="preserve">
          <source>Depending on use, issue appropriate memory barrier.</source>
          <target state="translated">사용에 따라 적절한 메모리 배리어를 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="7bb075a29d7a66c030bf16e5aa81d3289b5d0649" translate="yes" xml:space="preserve">
          <source>Deprecated Functions. All deprecated exported functions and all used deprecated BIFs.</source>
          <target state="translated">더 이상 사용되지 않는 함수. 더 이상 사용되지 않는 내 보낸 함수 및 사용되지 않는 모든 BIF.</target>
        </trans-unit>
        <trans-unit id="a556f0c9e78725f0dc7ec5f5f6ccfab7c94fba9a" translate="yes" xml:space="preserve">
          <source>Deprecated Functions. All deprecated functions to be removed in next version or next major release.</source>
          <target state="translated">더 이상 사용되지 않는 함수. 더 이상 사용되지 않는 모든 기능은 다음 버전 또는 다음 주요 릴리스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d871c4d8fedf1c0044ae045b46fd1f875d4207" translate="yes" xml:space="preserve">
          <source>Deprecated Functions. All deprecated functions to be removed in next version, next major release, or later.</source>
          <target state="translated">더 이상 사용되지 않는 함수. 더 이상 사용되지 않는 모든 기능은 다음 버전, 다음 주요 릴리스 또는 이후 버전에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f45d730453472e45c49f2d3ea99fe5527787aad8" translate="yes" xml:space="preserve">
          <source>Deprecated Functions. All deprecated functions to be removed in next version.</source>
          <target state="translated">더 이상 사용되지 않는 함수. 더 이상 사용되지 않는 모든 기능은 다음 버전에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5da4152a4415189ae859a586a766eb23b8a72225" translate="yes" xml:space="preserve">
          <source>Deprecated Representations for BIT STRING</source>
          <target state="translated">BIT STRING에 사용되지 않는 표현</target>
        </trans-unit>
        <trans-unit id="362d66bda77ba72de253405d1082913585d5d87f" translate="yes" xml:space="preserve">
          <source>Deprecated and replaced by &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">더 이상 사용되지 않으며 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 으로 대체</target>
        </trans-unit>
        <trans-unit id="8dfe918164e8ddccb6f55f262eee83b0adbb2128" translate="yes" xml:space="preserve">
          <source>Deprecated and replaced by gen_statem</source>
          <target state="translated">더 이상 사용되지 않으며 gen_statem으로 대체</target>
        </trans-unit>
        <trans-unit id="2d09e5160c09486ccb7f3219abc0b47f86c4eaad" translate="yes" xml:space="preserve">
          <source>Deprecated functionality will be documented as deprecated, and compiler warnings will be issued, when appropriate, as early as possible. That is, the new preferred functionality will appear at the same time as the deprecation is issued. A new deprecation will at least be announced in a release note and the documentation.</source>
          <target state="translated">더 이상 사용되지 않는 기능은 더 이상 사용되지 않는 것으로 문서화되며 가능한 경우 가능한 빨리 컴파일러 경고가 발행됩니다. 즉, 새로운 선호 기능은 지원 중단이 발행되는 동시에 나타납니다. 새로운 지원 중단은 최소한 릴리스 노트와 문서에서 발표 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="5501a25bd160cca4c73c256fc484e054f744501e" translate="yes" xml:space="preserve">
          <source>Deprecated functions which for the time being are kept for backwards compatibility. Invokes &lt;code&gt;et:trace_me/4&lt;/code&gt; and &lt;code&gt;et:trace_me/5&lt;/code&gt; respectively.</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 이전 버전과의 호환성을 위해 유지됩니다. &lt;code&gt;et:trace_me/4&lt;/code&gt; 및 &lt;code&gt;et:trace_me/5&lt;/code&gt; 를 각각 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="965c6319eb78a51b51236820480c381b647f09bb" translate="yes" xml:space="preserve">
          <source>Deprecated in OTP 21, use &lt;code&gt;&lt;a href=&quot;#cipher_suites-2&quot;&gt;cipher_suites/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">OTP 21에서 사용되지 &lt;code&gt;&lt;a href=&quot;#cipher_suites-2&quot;&gt;cipher_suites/2&lt;/a&gt;&lt;/code&gt; 대신 cipher_suites / 2를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25f06dfe2aac9021d2c4c0bc121eaf600a0aee3b" translate="yes" xml:space="preserve">
          <source>Deprecated in OTP 21, use &lt;code&gt;&lt;a href=&quot;#handshake-1&quot;&gt;handshake/[1,2]&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">OTP 21에서 사용되지 않으며 , &lt;code&gt;&lt;a href=&quot;#handshake-1&quot;&gt;handshake/[1,2]&lt;/a&gt;&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8b63d6692da10960246b76d0c20aee73217670bc" translate="yes" xml:space="preserve">
          <source>Deprecated in OTP 21, use &lt;code&gt;&lt;a href=&quot;#handshake-3&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">OTP 21에서 사용되지 않으며, 대신 &lt;code&gt;&lt;a href=&quot;#handshake-3&quot;&gt;handshake/[2,3]&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5a7061dbbf40f9e3bde38b8239ae3785a056588f" translate="yes" xml:space="preserve">
          <source>Deprecated since OTP-17, has no affect.</source>
          <target state="translated">OTP-17부터 사용되지 않으며 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5abdc016e3ae09e4ee089a39076e52bb4e75f1b8" translate="yes" xml:space="preserve">
          <source>Deprecated symbolic representations kept for backwards-compatibility.</source>
          <target state="translated">더 이상 사용되지 않는 기호 표현은 이전 버전과의 호환성을 위해 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="e933a4c105525e5dfc66dc5b016c7a5b06ca6392" translate="yes" xml:space="preserve">
          <source>Dequeue &lt;code&gt;count&lt;/code&gt; bytes from the I/O queue. If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the new size of the queue is placed there.</source>
          <target state="translated">I / O 큐에서 &lt;code&gt;count&lt;/code&gt; 바이트를 큐에서 빼십시오 . &lt;code&gt;size&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 새로운 큐 크기가 여기에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="8547a26aec952c41fbd7b425889713b88c8b7d6f" translate="yes" xml:space="preserve">
          <source>Dequeues data by moving the head pointer forward in the driver queue by &lt;code&gt;size&lt;/code&gt; bytes. The data in the queue is deallocated.</source>
          <target state="translated">드라이버 큐에서 헤드 포인터를 &lt;code&gt;size&lt;/code&gt; 바이트 단위로 앞으로 이동하여 데이터를 대기열에서 제외시킵니다 . 대기열의 데이터가 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b853231d0010f08413d6054783b30b188c434c4a" translate="yes" xml:space="preserve">
          <source>Derefrence aliases only in finding the base.</source>
          <target state="translated">베이스를 찾을 때만 Derefrence 가명.</target>
        </trans-unit>
        <trans-unit id="5c2b102c8b83b66f415c2f7f1cf6b0396528bb0f" translate="yes" xml:space="preserve">
          <source>Derefrence aliases only when searching.</source>
          <target state="translated">검색 할 때만 Derefrence 별명.</target>
        </trans-unit>
        <trans-unit id="755b53dcef95fd29638c16d7fa9871ffe3d7b5e1" translate="yes" xml:space="preserve">
          <source>Derived AVP Data Formats</source>
          <target state="translated">파생 된 AVP 데이터 형식</target>
        </trans-unit>
        <trans-unit id="d6478c428f7d07b93ad21693c15abb2cd2e82f3b" translate="yes" xml:space="preserve">
          <source>Descend recursively down all the directories in &lt;code&gt;DirList&lt;/code&gt; and create a &lt;code&gt;TAGS&lt;/code&gt; file based on all files found.</source>
          <target state="translated">&lt;code&gt;DirList&lt;/code&gt; 의 모든 디렉토리를 재귀 적으로 내려 가서 찾은 모든 파일을 기반으로 &lt;code&gt;TAGS&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cc3d8cf36128f6171cdd77d236ce5ede8a12c4f" translate="yes" xml:space="preserve">
          <source>Descend recursively down the directory &lt;code&gt;Dir&lt;/code&gt; and create a &lt;code&gt;TAGS&lt;/code&gt; file based on all files found.</source>
          <target state="translated">디렉토리 &lt;code&gt;Dir&lt;/code&gt; 을 재귀 적으로 내려 가서 찾은 모든 파일을 기반으로 &lt;code&gt;TAGS&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="891725ab5273cf87959338e5bc21f141aba5aa78" translate="yes" xml:space="preserve">
          <source>Describes a NIF by its name, arity, and implementation.</source>
          <target state="translated">NIF의 이름, 특성 및 구현을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="499f6cd092c8652ffec52836471379de11dd40d4" translate="yes" xml:space="preserve">
          <source>Description of &lt;code&gt;UtilDesc = {Cpus, Busy, NonBusy, Misc}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;UtilDesc = {Cpus, Busy, NonBusy, Misc}&lt;/code&gt; 설명 = {Cpus, Busy, NonBusy, Misc} :</target>
        </trans-unit>
        <trans-unit id="412f84d6c51e529e7f68c4a06240d52b125fd201" translate="yes" xml:space="preserve">
          <source>Description of the Document Set</source>
          <target state="translated">문서 세트에 대한 설명</target>
        </trans-unit>
        <trans-unit id="d59825af02793e907b66e437b654eff9f3807b1e" translate="yes" xml:space="preserve">
          <source>Description of the host that owns the &lt;code&gt;PublicHostKey&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PublicHostKey&lt;/code&gt; 를 소유 한 호스트에 대한 설명입니다 .</target>
        </trans-unit>
        <trans-unit id="292c41cb165afd021dffaa514987a15d6445b9ee" translate="yes" xml:space="preserve">
          <source>Description of the host with one or more IP addresses or hostnames.</source>
          <target state="translated">하나 이상의 IP 주소 또는 호스트 이름이있는 호스트에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="87643cd5a8d832b71e24272865a5a2ded4e2c63e" translate="yes" xml:space="preserve">
          <source>Description of the host.</source>
          <target state="translated">호스트에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="04f0f87cdf30f41863595935bdd7b915c84a0c3d" translate="yes" xml:space="preserve">
          <source>Deseret</source>
          <target state="translated">Deseret</target>
        </trans-unit>
        <trans-unit id="83c759c4a62a19e65caab6e8de56c9cb7053ee02" translate="yes" xml:space="preserve">
          <source>Desired SFTP protocol version. The actual version is the minimum of the desired version and the maximum supported versions by the SFTP server.</source>
          <target state="translated">원하는 SFTP 프로토콜 버전. 실제 버전은 원하는 버전의 최소 버전과 SFTP 서버가 지원하는 최대 버전입니다.</target>
        </trans-unit>
        <trans-unit id="652ab8315d7abab90d9e337481a24abc1229eff3" translate="yes" xml:space="preserve">
          <source>Despite its name, the &lt;code&gt;write_concurrency&lt;/code&gt; optimization does not improve &lt;code&gt;put&lt;/code&gt;. A call to &lt;code&gt;put&lt;/code&gt; is a relatively heavy operation compared to the very lightweight and scalable &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#sub-3&quot;&gt; sub&lt;/a&gt;&lt;/code&gt;. The cost for a &lt;code&gt;put&lt;/code&gt; with &lt;code&gt;write_concurrency&lt;/code&gt; is like a &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;get &lt;/a&gt;&lt;/code&gt; plus a &lt;code&gt;put&lt;/code&gt; without &lt;code&gt;write_concurrency&lt;/code&gt;.</source>
          <target state="translated">이름에도 불구하고 &lt;code&gt;write_concurrency&lt;/code&gt; 최적화는 &lt;code&gt;put&lt;/code&gt; 을 개선하지 않습니다 . &lt;code&gt;put&lt;/code&gt; 호출 은 매우 가볍고 확장 가능한 &lt;code&gt;&lt;a href=&quot;#add-3&quot;&gt;add&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#sub-3&quot;&gt; sub&lt;/a&gt;&lt;/code&gt; 에 비해 상대적으로 무거운 작업 입니다. A에 대한 비용 &lt;code&gt;put&lt;/code&gt; 와 &lt;code&gt;write_concurrency&lt;/code&gt; 는 유사한입니다 &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;get &lt;/a&gt;&lt;/code&gt; 플러스 &lt;code&gt;put&lt;/code&gt; 없이 &lt;code&gt;write_concurrency&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019fcd14827e4a50079afc44c4fe1765763ca455" translate="yes" xml:space="preserve">
          <source>Dest :: term(),</source>
          <target state="translated">목적지 :: term (),</target>
        </trans-unit>
        <trans-unit id="b52d2e5001c6beab510f1e417136efb8ee6c86c6" translate="yes" xml:space="preserve">
          <source>DestMod :: module(),</source>
          <target state="translated">DestMod :: module(),</target>
        </trans-unit>
        <trans-unit id="d01e9be8767f7e2e6949f04a35d1a79f0e103c92" translate="yes" xml:space="preserve">
          <source>Destination to use when replying through, for example, the &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{reply,From,Reply}&lt;/code&gt; to a process that has called the &lt;code&gt;gen_statem&lt;/code&gt; server using &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;gen_statem&lt;/code&gt; 서버를 호출 한 프로세스에 &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;action()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{reply,From,Reply}&lt;/code&gt; 과 같이 응답 할 때 사용할 대상 입니다.</target>
        </trans-unit>
        <trans-unit id="8ddcb395a27a31d4dfd5b2bb0dc66b34ad576576" translate="yes" xml:space="preserve">
          <source>Destination-Host AVP</source>
          <target state="translated">대상 호스트 AVP</target>
        </trans-unit>
        <trans-unit id="b299ccf590d9a47c91911a41b7d51c688221f560" translate="yes" xml:space="preserve">
          <source>Destination-Realm AVP</source>
          <target state="translated">대상 -Realm AVP</target>
        </trans-unit>
        <trans-unit id="fc2125ded371f86e9696529d4db25dedd6c7c623" translate="yes" xml:space="preserve">
          <source>Destroy the I/O queue and free all of it's contents</source>
          <target state="translated">I / O 대기열을 삭제하고 모든 내용을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="686336652b0b8485839d71165534446f3f08ddd2" translate="yes" xml:space="preserve">
          <source>Destroys a condition variable previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_cond_create&quot;&gt; erl_drv_cond_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_cond_create&quot;&gt; erl_drv_cond_create&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 조건 변수를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="6b90c654815fb3f69b2082f0f64d7d604be536d4" translate="yes" xml:space="preserve">
          <source>Destroys a condition variable previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_cond_create&quot;&gt;erl_drv_cond_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_cond_create&quot;&gt;erl_drv_cond_create&lt;/a&gt;&lt;/code&gt; 가 이전에 작성한 조건 변수를 파기합니다 .</target>
        </trans-unit>
        <trans-unit id="4fded6dd473e9af526f374078b9cb9f47a5c41b7" translate="yes" xml:space="preserve">
          <source>Destroys a map iterator created by &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_create&quot;&gt; enif_map_iterator_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_map_iterator_create&quot;&gt; enif_map_iterator_create&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 맵 반복기를 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="e9ccd649edff0e0054033a6999d53c7cb699f818" translate="yes" xml:space="preserve">
          <source>Destroys a map iterator created by &lt;code&gt;&lt;a href=&quot;#enif_map_iterator_create&quot;&gt;enif_map_iterator_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_map_iterator_create&quot;&gt;enif_map_iterator_create&lt;/a&gt;&lt;/code&gt; 에 의해 작성된 맵 반복자를 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="bdf95201e16b693cf6f94bf4481ff5340ba5d6a7" translate="yes" xml:space="preserve">
          <source>Destroys a mutex previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_mutex_create&quot;&gt; erl_drv_mutex_create&lt;/a&gt;&lt;/code&gt;. The mutex must be in an unlocked state before it is destroyed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_mutex_create&quot;&gt; erl_drv_mutex_create&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 뮤텍스를 제거 합니다. 뮤텍스는 소멸되기 전에 잠금 해제 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="edc5f8f0098d5350b10b0be3993f3fb15f2a5f4d" translate="yes" xml:space="preserve">
          <source>Destroys a mutex previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_mutex_create&quot;&gt;erl_drv_mutex_create&lt;/a&gt;&lt;/code&gt;. The mutex must be in an unlocked state before it is destroyed.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;#erl_drv_mutex_create&quot;&gt;erl_drv_mutex_create&lt;/a&gt;&lt;/code&gt; 로 작성된 뮤텍스를 제거 합니다. 뮤텍스는 파괴되기 전에 잠금 해제 상태에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc40d70420852faca2590402be5acb9907ef63f2" translate="yes" xml:space="preserve">
          <source>Destroys a thread-specific data key previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_key_create&quot;&gt; erl_drv_tsd_key_create&lt;/a&gt;&lt;/code&gt;. All thread-specific data using this key in all threads must be cleared (see &lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_set&quot;&gt; erl_drv_tsd_set&lt;/a&gt;&lt;/code&gt;) before the call to &lt;code&gt;erl_drv_tsd_key_destroy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_key_create&quot;&gt; erl_drv_tsd_key_create&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 스레드 특정 데이터 키를 파기합니다 . 모든 스레드에서이 키를 사용하는 모든 스레드 특정 데이터 (참조 지워야합니다 &lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_set&quot;&gt; erl_drv_tsd_set&lt;/a&gt;&lt;/code&gt; 를 호출하기 전에) &lt;code&gt;erl_drv_tsd_key_destroy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d44a717d9aab8a55fea66c1028c0d144717bb04" translate="yes" xml:space="preserve">
          <source>Destroys a thread-specific data key previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_key_create&quot;&gt;erl_drv_tsd_key_create&lt;/a&gt;&lt;/code&gt;. All thread-specific data using this key in all threads must be cleared (see &lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_set&quot;&gt;erl_drv_tsd_set&lt;/a&gt;&lt;/code&gt;) before the call to &lt;code&gt;erl_drv_tsd_key_destroy&lt;/code&gt;.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_key_create&quot;&gt;erl_drv_tsd_key_create&lt;/a&gt;&lt;/code&gt; 로 작성된 스레드 특정 데이터 키를 파기합니다 . 모든 스레드에서이 키를 사용하는 모든 스레드 특정 데이터 (참조 지워야합니다 &lt;code&gt;&lt;a href=&quot;#erl_drv_tsd_set&quot;&gt;erl_drv_tsd_set&lt;/a&gt;&lt;/code&gt; 를 호출하기 전에) &lt;code&gt;erl_drv_tsd_key_destroy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e658c382534c856d431058beb111c01082645188" translate="yes" xml:space="preserve">
          <source>Destroys an rwlock previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_rwlock_create&quot;&gt; erl_drv_rwlock_create&lt;/a&gt;&lt;/code&gt;. The rwlock must be in an unlocked state before it is destroyed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_rwlock_create&quot;&gt; erl_drv_rwlock_create&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 rwlock을 제거 합니다. rwlock은 소멸되기 전에 잠금 해제 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="21b3af691689dac990e8e2ccddd4e24df729f48e" translate="yes" xml:space="preserve">
          <source>Destroys an rwlock previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_rwlock_create&quot;&gt;erl_drv_rwlock_create&lt;/a&gt;&lt;/code&gt;. The rwlock must be in an unlocked state before it is destroyed.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;#erl_drv_rwlock_create&quot;&gt;erl_drv_rwlock_create&lt;/a&gt;&lt;/code&gt; 로 작성된 rwlock을 제거 합니다. rwlock은 잠금 해제 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a4e23cf2d48d29757ae624f3a6516ed15e25c39f" translate="yes" xml:space="preserve">
          <source>Destroys thread options previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_opts_create&quot;&gt; erl_drv_thread_opts_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_thread_opts_create&quot;&gt; erl_drv_thread_opts_create&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 스레드 옵션을 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="6f60f49d47af6ed0c00205d050757b397270ed04" translate="yes" xml:space="preserve">
          <source>Destroys thread options previously created by &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_opts_create&quot;&gt;erl_drv_thread_opts_create&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#erl_drv_thread_opts_create&quot;&gt;erl_drv_thread_opts_create&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 작성된 스레드 옵션을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="db7dbdd40f8bae0fb5f7afe2f1bddf7982c90e55" translate="yes" xml:space="preserve">
          <source>Details of these features are described in the following sections.</source>
          <target state="translated">이러한 기능에 대한 자세한 내용은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3e7cdda7f4aca965020ab0e29b81d2360a041c83" translate="yes" xml:space="preserve">
          <source>Determine Order of Events</source>
          <target state="translated">이벤트 순서 결정</target>
        </trans-unit>
        <trans-unit id="6ad97781dba7865aa1783063debcdb2d537a0ac1" translate="yes" xml:space="preserve">
          <source>Determine Order of Events with Time of the Event</source>
          <target state="translated">이벤트 시간에 따른 이벤트 순서 결정</target>
        </trans-unit>
        <trans-unit id="aa1c5cb64107d746ebde75e0958a8f3a6e27958e" translate="yes" xml:space="preserve">
          <source>Determine the order of events by saving a time stamp with &lt;code&gt;erlang:now/0&lt;/code&gt; when the event occurs.</source>
          <target state="translated">이벤트 발생시 &lt;code&gt;erlang:now/0&lt;/code&gt; 을 사용하여 타임 스탬프를 저장하여 이벤트 순서를 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="24c4a586b3011bab7b0f4e3856359ff4e771deb5" translate="yes" xml:space="preserve">
          <source>Determine the order of events by saving a tuple containing &lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;monotonic time&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;strictly monotonically increasing integer&lt;/a&gt;&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#monotonic_time-0&quot;&gt;monotonic time&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;strictly monotonically increasing integer&lt;/a&gt;&lt;/code&gt; 를 포함하는 튜플 을 다음과 같이 저장하여 이벤트 순서를 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="caceed1b4e4a0639759a625df6beeb4bac2b9f9c" translate="yes" xml:space="preserve">
          <source>Determine the order of events by saving the integer returned by &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; when the event occurs. These integers are strictly monotonically ordered on current runtime system instance corresponding to creation time.</source>
          <target state="translated">이벤트 발생시 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; 반환 된 정수를 저장하여 이벤트 순서를 결정 합니다. 이러한 정수는 생성 시간에 해당하는 현재 런타임 시스템 인스턴스에서 엄격하게 단조롭게 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8ae8da9095099ca068859dc483a63073a1a878ab" translate="yes" xml:space="preserve">
          <source>Determine the order of events by saving the integer returned by &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; when the event occurs. These integers are strictly monotonically ordered on current runtime system instance corresponding to creation time.</source>
          <target state="translated">이벤트 발생시 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; 리턴 한 정수를 저장하여 이벤트 순서를 판별하십시오 . 이 정수는 생성 시간에 해당하는 현재 런타임 시스템 인스턴스에서 엄격하게 단조롭게 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="fdebe34699b9ee4d99aed0852756308878b8bc53" translate="yes" xml:space="preserve">
          <source>Determine the type of currently executing thread. A positive value indicates a scheduler thread while a negative value or zero indicates another type of thread. Currently the following specific types exist (which may be extended in the future):</source>
          <target state="translated">현재 실행중인 스레드의 유형을 결정하십시오. 양수 값은 스케줄러 스레드를 나타내고 음수 값 또는 0은 다른 유형의 스레드를 나타냅니다. 현재 다음과 같은 특정 유형이 존재합니다 (향후 확장 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="adde7c24299e69435a0426b9738108140c225ee8" translate="yes" xml:space="preserve">
          <source>Determine where the top directory of your OTP installation is. To find this, start Erlang and enter the following command at the Eshell prompt:</source>
          <target state="translated">OTP 설치의 최상위 디렉토리 위치를 결정하십시오. 이를 찾으려면 Erlang을 시작하고 Eshell 프롬프트에서 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="cac67eecea540c0d8b80ffd58fa1854184fabfdc" translate="yes" xml:space="preserve">
          <source>Determines association parameters for the association(s) specified by &lt;code&gt;assoc_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;assoc_id&lt;/code&gt; 로 지정된 연관에 대한 연관 매개 변수를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="077579a209e2327105a616031f529dd3c6552c1e" translate="yes" xml:space="preserve">
          <source>Determines if garbage collection is allowed when performing the operation. If &lt;code&gt;{allow_gc, false}&lt;/code&gt; is passed, and a garbage collection is needed to determine the result of the operation, the operation is aborted (see information on &lt;code&gt;CheckResult&lt;/code&gt; below). The default is to allow garbage collection, that is, &lt;code&gt;{allow_gc, true}&lt;/code&gt;.</source>
          <target state="translated">작업을 수행 할 때 가비지 수집이 허용되는지 여부를 결정합니다. 경우 &lt;code&gt;{allow_gc, false}&lt;/code&gt; 통과하며, 가비지 콜렉션은 연산의 결과를 결정하는데 필요한 상기 동작 (ON 정보 참조 중단 &lt;code&gt;CheckResult&lt;/code&gt; 아래 참조). 기본값은 가비지 콜렉션, 즉 &lt;code&gt;{allow_gc, true}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="53ce682c952fe8edaea9c1423565e6576408341f" translate="yes" xml:space="preserve">
          <source>Determines if the FTP communication is to be verbose or not.</source>
          <target state="translated">FTP 통신이 자세한 지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="494dbc80105974dbc6fb49506b454d2e0d793029" translate="yes" xml:space="preserve">
          <source>Determines retransmission time-out parameters, in milliseconds, for the association(s) specified by &lt;code&gt;assoc_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;assoc_id&lt;/code&gt; 로 지정된 연결에 대한 재전송 시간 제한 매개 변수 (밀리 초)를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="c58d40a211958b5e215990f2db8b6a14f80c8fc1" translate="yes" xml:space="preserve">
          <source>Determines the behaviour of the &lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; function. When this configuration parameter is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;get_system_memory_data()&lt;/code&gt; behaves as it has done up until the point of the introduction of the configuration parameter. When set to &lt;code&gt;true&lt;/code&gt; new tagged tuples are allowed in the result. Such new tuples may be introduced at any time without prior notice. The classification of &lt;code&gt;cached_memory&lt;/code&gt; on Linux systems will also change so that more memory is classified as &lt;code&gt;cached_memory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#get_system_memory_data-0&quot;&gt;get_system_memory_data()&lt;/a&gt;&lt;/code&gt; 함수 의 동작을 결정합니다 . 이 구성 매개 변수가 &lt;code&gt;false&lt;/code&gt; 이면 &lt;code&gt;get_system_memory_data()&lt;/code&gt; 는 구성 매개 변수가 도입 될 때까지 수행 한대로 작동합니다. &lt;code&gt;true&lt;/code&gt; 로 설정하면 태그가 지정된 새 튜플이 결과에 허용됩니다. 이러한 새로운 튜플은 사전 통보없이 언제든지 도입 될 수 있습니다. Linux 시스템 에서 &lt;code&gt;cached_memory&lt;/code&gt; 분류 도 변경되어 더 많은 메모리가 &lt;code&gt;cached_memory&lt;/code&gt; 로 분류됩니다 .</target>
        </trans-unit>
        <trans-unit id="083ff9a731e189edd69feae97ddfd7141e0e3a9e" translate="yes" xml:space="preserve">
          <source>Determines the buffer space that would be needed by &lt;code&gt;t&lt;/code&gt; if it were encoded into Erlang external format by &lt;code&gt;erl_encode()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erl_encode()&lt;/code&gt; 의해 Erlang 외부 형식으로 인코딩 된 경우 &lt;code&gt;t&lt;/code&gt; 에 필요한 버퍼 공간을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="77798bfac995896462ccc3ef147a4e0ae7afccf2" translate="yes" xml:space="preserve">
          <source>Determines the default parameters that this socket tries to negotiate with its peer while establishing an association with it. Is to be set after &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/*&lt;/a&gt;&lt;/code&gt; but before the first &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;#sctp_initmsg{}&lt;/code&gt; can also be used as ancillary data with the first call of &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send/*&lt;/a&gt;&lt;/code&gt; to a new peer (when a new association is created).</source>
          <target state="translated">소켓이 연결을 설정하는 동안이 소켓이 피어와 협상하려고하는 기본 매개 변수를 결정합니다. &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/*&lt;/a&gt;&lt;/code&gt; 이후 에 첫 번째 &lt;code&gt;&lt;a href=&quot;#connect-4&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt; 전에 설정 됩니다. &lt;code&gt;#sctp_initmsg{}&lt;/code&gt; 는 새 피어에 대한 첫 번째 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;send/*&lt;/a&gt;&lt;/code&gt; 호출 (보조 연결이 생성 될 때) 을 보조 데이터로 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55a2f53f97f755fd2dbcd1b670c65f1dc001d09f" translate="yes" xml:space="preserve">
          <source>Determines the length of a proper list.</source>
          <target state="translated">적절한 목록의 길이를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e2a8218334957019102a6de9a1ec80fa4cca7917" translate="yes" xml:space="preserve">
          <source>Determines the maximum chunk size if message fragmentation is used. If &lt;code&gt;0&lt;/code&gt;, the chunk size is limited by the Path MTU only.</source>
          <target state="translated">메시지 조각화가 사용되는 경우 최대 청크 크기를 결정합니다. 경우 &lt;code&gt;0&lt;/code&gt; , 청크 크기에만 경로 MTU에 의해 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7a2c66961d77ac3d187d28893d33c58111b6ef76" translate="yes" xml:space="preserve">
          <source>Determines the time, in seconds, after which an idle association is automatically closed. &lt;code&gt;0&lt;/code&gt; means that the association is never automatically closed.</source>
          <target state="translated">유휴 연결이 자동으로 닫힌 후 시간 (초)을 결정합니다. &lt;code&gt;0&lt;/code&gt; 은 연결이 자동으로 닫히지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="515405b131cb1928594e2abd951d111519cdd02e" translate="yes" xml:space="preserve">
          <source>Determines the time-out, in seconds, for flushing unsent data in the &lt;code&gt;close/1&lt;/code&gt; socket call.</source>
          <target state="translated">&lt;code&gt;close/1&lt;/code&gt; 소켓 호출 에서 전송되지 않은 데이터를 플러시하기위한 시간 제한 (초)을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="dfea908ad3f80022ee7a6824d7720b3ffbfb7ffe" translate="yes" xml:space="preserve">
          <source>Determines the time-out, in seconds, for flushing unsent data in the &lt;code&gt;close/1&lt;/code&gt; socket call. If the first component of the value tuple is &lt;code&gt;false&lt;/code&gt;, the second is ignored. This means that &lt;code&gt;close/1&lt;/code&gt; returns immediately, not waiting for data to be flushed. Otherwise, the second component is the flushing time-out, in seconds.</source>
          <target state="translated">&lt;code&gt;close/1&lt;/code&gt; 소켓 호출 에서 보내지 않은 데이터를 플러시하기위한 시간 제한 (초)을 결정합니다 . 값 튜플의 첫 번째 구성 요소가 &lt;code&gt;false&lt;/code&gt; 인 경우 두 번째 구성 요소 는 무시됩니다. 이는 데이터가 플러시되기를 기다리지 않고 &lt;code&gt;close/1&lt;/code&gt; 이 즉시 리턴 됨을 의미합니다 . 그렇지 않으면 두 번째 구성 요소는 세척 시간 초과 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="731b42a8df83c81b419568ef3bb86ac028eef737" translate="yes" xml:space="preserve">
          <source>Determines the type of data returned from &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 데이터 유형을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="66920f12401db8094f5300be52c85662ab8939e0" translate="yes" xml:space="preserve">
          <source>Determines the type of the given term. The term must be an ordinary Erlang term and not one of the special terms returned by &lt;code&gt;&lt;a href=&quot;#enif_raise_exception&quot;&gt; enif_raise_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, or similar.</source>
          <target state="translated">주어진 용어의 유형을 결정합니다. 용어는 일반 Erlang 용어 여야하며 &lt;code&gt;&lt;a href=&quot;#enif_raise_exception&quot;&gt; enif_raise_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt; 또는 이와 유사한 항목 에서 반환 된 특수 용어 중 하나가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="df0c701d33903386824172bab733ce9700d585ae" translate="yes" xml:space="preserve">
          <source>Determines various per-address parameters for the association specified by &lt;code&gt;assoc_id&lt;/code&gt; and the peer address &lt;code&gt;address&lt;/code&gt; (the SCTP protocol supports multi-homing, so more than one address can correspond to a specified association).</source>
          <target state="translated">&lt;code&gt;assoc_id&lt;/code&gt; 및 피어 주소 &lt;code&gt;address&lt;/code&gt; 지정된 연관에 대한 주소 별 매개 변수를 판별 합니다 (SCTP 프로토콜은 멀티 홈을 지원하므로 둘 이상의 주소가 지정된 연관에 해당 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ff32eb1db11aaa5dba28236c5193d1eda53b59af" translate="yes" xml:space="preserve">
          <source>Determines whether the compiler generates a &lt;code&gt;beam&lt;/code&gt; file with the given options. &lt;code&gt;true&lt;/code&gt; means that a &lt;code&gt;beam&lt;/code&gt; file is generated. &lt;code&gt;false&lt;/code&gt; means that the compiler generates some listing file, returns a binary, or merely checks the syntax of the source code.</source>
          <target state="translated">컴파일러 가 주어진 옵션 으로 &lt;code&gt;beam&lt;/code&gt; 파일을 생성하는지 여부를 결정합니다 . &lt;code&gt;true&lt;/code&gt; 는 &lt;code&gt;beam&lt;/code&gt; 파일이 생성됨을 의미합니다 . &lt;code&gt;false&lt;/code&gt; 는 컴파일러가 목록 파일을 생성하거나 바이너리를 반환하거나 소스 코드의 구문 만 검사 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0fde766270c08bb2c143bb1ffbdcba5107b28312" translate="yes" xml:space="preserve">
          <source>Determines whether the parser generator should give full information about resolved and unresolved parse action conflicts (&lt;code&gt;true&lt;/code&gt;), or only about those conflicts that prevent a parser from being generated from the input grammar (&lt;code&gt;false&lt;/code&gt;, the default).</source>
          <target state="translated">파서 생성기가 해결 된 구문 분석 동작과 해결되지 않은 구문 분석 동작 충돌 ( &lt;code&gt;true&lt;/code&gt; ) 또는 구문 분석기가 입력 문법에서 생성되지 못하게하는 충돌 에 대한 전체 정보를 제공해야하는지 여부를 결정합니다 ( 기본값 : &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f5765dc87a449f2a174d7f995a9dba949217fc42" translate="yes" xml:space="preserve">
          <source>Determines which module to call for accessing the file server. The default value is &lt;code&gt;ssh_sftpd_file&lt;/code&gt;, which uses the &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;filelib&lt;/code&gt; APIs to access the standard OTP file server. This option can be used to plug in other file servers.</source>
          <target state="translated">파일 서버에 액세스하기 위해 호출 할 모듈을 결정합니다. 기본값은 &lt;code&gt;ssh_sftpd_file&lt;/code&gt; 이며 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;filelib&lt;/code&gt; API를 사용하여 표준 OTP 파일 서버에 액세스합니다. 이 옵션은 다른 파일 서버를 연결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="194e22e942d1687afcd0c6b99914e56add4b87df" translate="yes" xml:space="preserve">
          <source>Determining what data to keep after a communication failure is outside the scope of &lt;code&gt;Mnesia&lt;/code&gt;. One approach is to determine which &quot;island&quot; contains most of the nodes. Using option &lt;code&gt;{majority,true}&lt;/code&gt; for critical tables can be a way to ensure that nodes that are not part of a &quot;majority island&quot; cannot update those tables. Notice that this constitutes a reduction in service on the minority nodes. This would be a tradeoff in favor of higher consistency guarantees.</source>
          <target state="translated">통신 실패 후 유지할 데이터 결정은 &lt;code&gt;Mnesia&lt;/code&gt; 의 범위를 벗어납니다 . 한 가지 방법은 어떤 &quot;섬&quot;에 대부분의 노드가 포함되어 있는지 확인하는 것입니다. 중요 테이블에 &lt;code&gt;{majority,true}&lt;/code&gt; 옵션을 사용하면 &quot;주요 섬&quot;에 속하지 않은 노드가 해당 테이블을 업데이트 할 수 없도록 할 수 있습니다. 이는 소수 노드에서의 서비스 감소를 구성합니다. 이것은 더 높은 일관성 보장을 선호하는 트레이드 오프입니다.</target>
        </trans-unit>
        <trans-unit id="08783d6c0e8f974bda4d0f0259a9bced7702d406" translate="yes" xml:space="preserve">
          <source>Dets organizes data as a linear hash list and the hash list grows gracefully as more data is inserted into the table. Space management on the file is performed by what is called a buddy system. The current implementation keeps the entire buddy system in RAM, which implies that if the table gets heavily fragmented, quite some memory can be used up. The only way to defragment a table is to close it and then open it again with option &lt;code&gt;repair&lt;/code&gt; set to &lt;code&gt;force&lt;/code&gt;.</source>
          <target state="translated">Dets는 데이터를 선형 해시 목록으로 구성하고 더 많은 데이터가 테이블에 삽입되면 해시 목록이 정상적으로 커집니다. 파일의 공간 관리는 버디 시스템이라고합니다. 현재 구현에서는 전체 버디 시스템을 RAM에 유지하므로 테이블이 심하게 조각화되면 일부 메모리를 사용할 수 있습니다. 테이블 조각 모음을 수행하는 유일한 방법은 테이블을 닫은 다음 옵션 &lt;code&gt;repair&lt;/code&gt; 옵션 을 &lt;code&gt;force&lt;/code&gt; 설정하여 다시 여는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d589e63f8dc652ae3141561171bed423eef70c79" translate="yes" xml:space="preserve">
          <source>Dets tables must be opened before they can be updated or read, and when finished they must be properly closed. If a table is not properly closed, Dets automatically repairs the table. This can take a substantial time if the table is large. A Dets table is closed when the process which opened the table terminates. If many Erlang processes (users) open the same Dets table, they share the table. The table is properly closed when all users have either terminated or closed the table. Dets tables are not properly closed if the Erlang runtime system terminates abnormally.</source>
          <target state="translated">Dets 테이블은 업데이트 또는 읽기 전에 열어야하며, 완료되면 올바르게 닫아야합니다. 테이블이 제대로 닫히지 않으면 Dets는 자동으로 테이블을 복구합니다. 테이블이 큰 경우 상당한 시간이 걸릴 수 있습니다. 테이블을 연 프로세스가 종료되면 Dets 테이블이 닫힙니다. 많은 Erlang 프로세스 (사용자)가 동일한 Dets 테이블을 열면 테이블을 공유합니다. 모든 사용자가 테이블을 종료하거나 닫으면 테이블이 올바르게 닫힙니다. Erlang 런타임 시스템이 비정상적으로 종료되면 Dets 테이블이 올바르게 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3376a9770679682419b8a2b1d090a087ba2468b" translate="yes" xml:space="preserve">
          <source>Devanagari</source>
          <target state="translated">Devanagari</target>
        </trans-unit>
        <trans-unit id="456219399c5e2e2d6869a33bf75f63ddc05cd05c" translate="yes" xml:space="preserve">
          <source>Developers must always invoke the &lt;code&gt;debug_info/4&lt;/code&gt; function and never rely on the &lt;code&gt;Data&lt;/code&gt; stored in the &lt;code&gt;debug_info&lt;/code&gt; chunk, as it is opaque and may change at any moment. &lt;code&gt;no_debug_info&lt;/code&gt; means that chunk &lt;code&gt;&quot;Dbgi&quot;&lt;/code&gt; is present, but empty.</source>
          <target state="translated">개발자는 항상 &lt;code&gt;debug_info/4&lt;/code&gt; 함수를 호출해야 하며 &lt;code&gt;debug_info&lt;/code&gt; 청크에 저장된 &lt;code&gt;Data&lt;/code&gt; 에 의존하지 않아야합니다. 이는 불투명하고 언제든지 변경 될 수 있기 때문입니다. &lt;code&gt;no_debug_info&lt;/code&gt; 는 &lt;code&gt;&quot;Dbgi&quot;&lt;/code&gt; 청크 가 존재하지만 비어 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="16446bdea2b981010fbb150f3aca921d223adb77" translate="yes" xml:space="preserve">
          <source>Developers should rely on stacktrace entries only for debugging purposes.</source>
          <target state="translated">개발자는 디버깅 목적으로 만 스택 추적 항목을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c2648f2b3ce72e567281814263f70dc09c18843" translate="yes" xml:space="preserve">
          <source>Deviations from the standard</source>
          <target state="translated">표준 편차</target>
        </trans-unit>
        <trans-unit id="cb81d10268def1ddcd9e7ea7d13651d61cbb6e0a" translate="yes" xml:space="preserve">
          <source>Device-Watchdog-Answer</source>
          <target state="translated">Device-Watchdog-Answer</target>
        </trans-unit>
        <trans-unit id="ded250e2e75f5d9108516c8323ac1f5e2d1f881d" translate="yes" xml:space="preserve">
          <source>Device-Watchdog-Request</source>
          <target state="translated">Device-Watchdog-Request</target>
        </trans-unit>
        <trans-unit id="64f91465847372ce990aad877a06eb2ed199d44b" translate="yes" xml:space="preserve">
          <source>Dialyzer GUI version.</source>
          <target state="translated">투석기 GUI 버전.</target>
        </trans-unit>
        <trans-unit id="4147ae5f76685fdd79ca81b8faa42c7d8a8edcc8" translate="yes" xml:space="preserve">
          <source>Dialyzer can also be used directly from Erlang. See &lt;code&gt;&lt;a href=&quot;dialyzer&quot;&gt;dialyzer(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang에서 직접 투석기를 사용할 수도 있습니다. &lt;code&gt;&lt;a href=&quot;dialyzer&quot;&gt;dialyzer(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="628db5ea350d60eef0f983d37cdceaf38ea7f18b" translate="yes" xml:space="preserve">
          <source>Dialyzer can be called from the command line, from Erlang, and from a GUI.</source>
          <target state="translated">Dialyzer는 명령 줄, Erlang 및 GUI에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e7d2d8ec7f1493ae5e9513f0acbf5fb6b111813" translate="yes" xml:space="preserve">
          <source>Dialyzer can be used directly from Erlang. Both the GUI and the command-line versions are also available. The options are similar to the ones given from the command line, see section &lt;code&gt;&lt;a href=&quot;#command_line&quot;&gt; Using Dialyzer from the Command Line&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Dialyzer는 Erlang에서 직접 사용할 수 있습니다. GUI 및 명령 줄 버전도 사용할 수 있습니다. 옵션은 명령 줄에서 제공되는 옵션과 유사합니다. 명령 줄에서 &lt;code&gt;&lt;a href=&quot;#command_line&quot;&gt; Using Dialyzer from the Command Line&lt;/a&gt;&lt;/code&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="1d35fb792c27e96d88efcff82ddb3bdb62e1411a" translate="yes" xml:space="preserve">
          <source>Dialyzer can be used directly from Erlang. Both the GUI and the command-line versions are also available. The options are similar to the ones given from the command line, see section &lt;code&gt;&lt;a href=&quot;#command_line&quot;&gt;Using Dialyzer from the Command Line&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang에서 직접 투석기를 사용할 수 있습니다. GUI와 명령 행 버전도 모두 사용할 수 있습니다. 옵션은 명령 행에서 제공되는 옵션과 유사합니다 (명령 행에서 &lt;code&gt;&lt;a href=&quot;#command_line&quot;&gt;Using Dialyzer from the Command Line&lt;/a&gt;&lt;/code&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="d8021a0b92f30253eca0f240a4f65bb36bd5a3b5" translate="yes" xml:space="preserve">
          <source>Dialyzer command-line version.</source>
          <target state="translated">투석기 명령 줄 버전.</target>
        </trans-unit>
        <trans-unit id="efa6b71916bdfbf21fa4dff08a93a9d1ac41b102" translate="yes" xml:space="preserve">
          <source>Dialyzer has a command-line version for automated use. See &lt;code&gt;&lt;a href=&quot;dialyzer&quot;&gt;dialyzer(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Dialyzer에는 자동화 된 사용을위한 명령 줄 버전이 있습니다. &lt;code&gt;&lt;a href=&quot;dialyzer&quot;&gt;dialyzer(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da84b06d671a1c03ee7934e17676e95918b41dab" translate="yes" xml:space="preserve">
          <source>Dialyzer has a command-line version for automated use. This section provides a brief description of the options. The same information can be obtained by writing the following in a shell:</source>
          <target state="translated">Dialyzer에는 자동화 된 사용을위한 명령 줄 버전이 있습니다. 이 섹션에서는 옵션에 대한 간단한 설명을 제공합니다. 쉘에 다음을 작성하여 동일한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21cb03f781be29c029b6c322b9928599481570de" translate="yes" xml:space="preserve">
          <source>Dialyzer has two analysis modes: &quot;Byte Code&quot; and &quot;Source Code&quot;. They are controlled by the buttons in the top-middle part of the main window, under &lt;strong&gt;Analysis Options&lt;/strong&gt;.</source>
          <target state="translated">Dialyzer에는 &quot;Byte Code&quot;와 &quot;Source Code&quot;의 두 가지 분석 모드가 있습니다. 메인 창의 상단 중간에있는 &lt;strong&gt;분석 옵션&lt;/strong&gt; 아래에있는 버튼으로 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a5351192a936d150a3e55c047000d982954a92b" translate="yes" xml:space="preserve">
          <source>Dialyzer is a static analysis tool that identifies software discrepancies, such as definite type errors, code that has become dead or unreachable because of programming error, and unnecessary tests, in single Erlang modules or entire (sets of) applications.</source>
          <target state="translated">Dialyzer는 단일 유형의 Erlang 모듈 또는 전체 (세트) 응용 프로그램에서 명확한 유형 오류, 프로그래밍 오류로 인해 오류가 발생했거나 도달 할 수없는 코드 및 불필요한 테스트와 같은 소프트웨어 불일치를 식별하는 정적 분석 도구입니다.</target>
        </trans-unit>
        <trans-unit id="4856ad4cc2225ddaaa94171f074e8b6f1592a9b9" translate="yes" xml:space="preserve">
          <source>Dialyzer looks if there is an environment variable called &lt;code&gt;DIALYZER_PLT&lt;/code&gt; and places the PLT at this location. If no such variable is set, Dialyzer places the PLT at &lt;code&gt;$HOME/.dialyzer_plt&lt;/code&gt;. The placement can also be specified using the options &lt;code&gt;--plt&lt;/code&gt; or &lt;code&gt;--output_plt&lt;/code&gt;.</source>
          <target state="translated">Dialyzer는 &lt;code&gt;DIALYZER_PLT&lt;/code&gt; 라는 환경 변수가 있는지 확인 하고이 위치에 PLT를 배치합니다. 그러한 변수가 설정되어 있지 않으면 Dialyzer는 PLT를 &lt;code&gt;$HOME/.dialyzer_plt&lt;/code&gt; 합니다. &lt;code&gt;--plt&lt;/code&gt; 또는 &lt;code&gt;--output_plt&lt;/code&gt; 옵션을 사용하여 배치를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a144d9aa62d8283331e0453d170211eae479447c" translate="yes" xml:space="preserve">
          <source>Dialyzer starts its analysis from either debug-compiled BEAM bytecode or from Erlang source code. The file and line number of a discrepancy is reported along with an indication of what the discrepancy is about. Dialyzer bases its analysis on the concept of success typings, which allows for sound warnings (no false positives).</source>
          <target state="translated">Dialyzer는 디버그 컴파일 된 BEAM 바이트 코드 또는 Erlang 소스 코드에서 분석을 시작합니다. 불일치의 파일 및 행 번호가 불일치에 대한 표시와 함께보고됩니다. 투석기는 성공한 타이핑 개념을 기반으로 분석하여 소리 경고 (오 탐지 없음)를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="10608feb501f52bd03b6ddf98a4210f55bd5af23" translate="yes" xml:space="preserve">
          <source>Dialyzer stores the information of the analyzed functions in a Persistent Lookup Table (PLT), see section &lt;code&gt;&lt;a href=&quot;#plt&quot;&gt;The Persistent Lookup Table&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">투석기 섹션을 참조 영구 조회 테이블 (PLT)의 분석 기능의 정보를 저장하는 &lt;code&gt;&lt;a href=&quot;#plt&quot;&gt;The Persistent Lookup Table&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="494e2325bcc3322adec1ce4f072ada1bb99b4f8d" translate="yes" xml:space="preserve">
          <source>Dialyzer stores the result of an analysis in a Persistent Lookup Table (PLT). The PLT can then be used as a starting point for later analyses. It is recommended to build a PLT with the Erlang/OTP applications that you are using, but also to include your own applications that you are using frequently.</source>
          <target state="translated">투석기는 분석 결과를 PLT (Persistent Lookup Table)에 저장합니다. PLT는 이후 분석을위한 시작점으로 사용될 수 있습니다. 사용중인 Erlang / OTP 응용 프로그램을 사용하여 PLT를 작성하고 자주 사용하는 응용 프로그램도 포함시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="838da0bec6523e8f2f3da58812e9f1ef6f9a9fc7" translate="yes" xml:space="preserve">
          <source>Dialyzer then reanalyzes the changed files and the files that depend on these files. Notice that this consistency check is performed automatically the next time you run Dialyzer with this PLT. Option &lt;code&gt;--check_plt&lt;/code&gt; is only for doing so without doing any other analysis.</source>
          <target state="translated">그런 다음 투석기는 변경된 파일과이 파일에 의존하는 파일을 다시 분석합니다. 이 일관성 검사는 다음에이 PLT로 Dialyzer를 실행할 때 자동으로 수행됩니다. &lt;code&gt;--check_plt&lt;/code&gt; 옵션 은 다른 분석없이 수행하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="510a8a06e0d737b5aa0df793bf420e94ca04a8ea" translate="yes" xml:space="preserve">
          <source>Dialyzer, a DIscrepancy AnaLYZer for ERlang programs.</source>
          <target state="translated">ERlang 프로그램의 DIscrepancy AnalyZer 인 Dialyzer.</target>
        </trans-unit>
        <trans-unit id="07d09b590e7c65396fb0af8b4e685bc5f08fc46f" translate="yes" xml:space="preserve">
          <source>Diameter AVPs</source>
          <target state="translated">직경 AVP</target>
        </trans-unit>
        <trans-unit id="595221e9670fe2806542b1909df3759ecc51c609" translate="yes" xml:space="preserve">
          <source>Diameter Answer Processing</source>
          <target state="translated">직경 응답 처리</target>
        </trans-unit>
        <trans-unit id="492ddd4795919309b00e3cb99b03e084593644b2" translate="yes" xml:space="preserve">
          <source>Diameter Application Compliance</source>
          <target state="translated">직경 응용 프로그램 준수</target>
        </trans-unit>
        <trans-unit id="233b44598089548f0cb439d8260d802c42d8d926" translate="yes" xml:space="preserve">
          <source>Diameter Base Protocol AVPs</source>
          <target state="translated">직경 기본 프로토콜 AVP</target>
        </trans-unit>
        <trans-unit id="95745ee3caa29c97347231fc7062812cc1cabc48" translate="yes" xml:space="preserve">
          <source>Diameter Command Naming Conventions</source>
          <target state="translated">직경 명령 명명 규칙</target>
        </trans-unit>
        <trans-unit id="f8e96b9bc84f819f28cac97e61334c92e49b6d2c" translate="yes" xml:space="preserve">
          <source>Diameter Header</source>
          <target state="translated">직경 헤더</target>
        </trans-unit>
        <trans-unit id="fb85483589f2a0d213806104d451a8bbb89a7a0f" translate="yes" xml:space="preserve">
          <source>Diameter Message Processing</source>
          <target state="translated">직경 메시지 처리</target>
        </trans-unit>
        <trans-unit id="cf7b0cf80edb413895d382c150dbc8ff733c12d1" translate="yes" xml:space="preserve">
          <source>Diameter Path Authorization</source>
          <target state="translated">직경 경로 인증</target>
        </trans-unit>
        <trans-unit id="07688cd69d8a46c450445f8b85d3d9fe42582147" translate="yes" xml:space="preserve">
          <source>Diameter Peer Discovery</source>
          <target state="translated">직경 피어 발견</target>
        </trans-unit>
        <trans-unit id="de4ce74cc36fc385d21c9d15a70dc2b2131b85a5" translate="yes" xml:space="preserve">
          <source>Diameter Peers</source>
          <target state="translated">직경 피어</target>
        </trans-unit>
        <trans-unit id="305ef1f7771347650724f9757c11f8edfa0beab3" translate="yes" xml:space="preserve">
          <source>Diameter Protocol</source>
          <target state="translated">직경 프로토콜</target>
        </trans-unit>
        <trans-unit id="2877c6abfd87eef90c657292849be45de67435cd" translate="yes" xml:space="preserve">
          <source>Diameter Protocol-Related Configurable Parameters</source>
          <target state="translated">직경 프로토콜 관련 구성 가능한 매개 변수</target>
        </trans-unit>
        <trans-unit id="41c8a11b72baca5ae179f4f1fcd33229819687ce" translate="yes" xml:space="preserve">
          <source>Diameter Request Routing Overview</source>
          <target state="translated">직경 요청 라우팅 개요</target>
        </trans-unit>
        <trans-unit id="32dcfb391752d0e475c6c43a642bd9b52b1747e5" translate="yes" xml:space="preserve">
          <source>Diameter User Sessions</source>
          <target state="translated">직경 사용자 세션</target>
        </trans-unit>
        <trans-unit id="803d3673bba0aa163b1bd90094ca9f273861f900" translate="yes" xml:space="preserve">
          <source>Diameter applications to which the transport should be restricted. Defaults to all applications configured on the service in question. Applications not configured on the service in question are ignored.</source>
          <target state="translated">운송을 제한해야하는 직경 어플리케이션. 해당 서비스에 구성된 모든 응용 프로그램이 기본값입니다. 해당 서비스에 구성되지 않은 응용 프로그램은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a6fa8fdf84e2a98961b3740684166200004f3961" translate="yes" xml:space="preserve">
          <source>Diameter dictionary compilation.</source>
          <target state="translated">직경 사전 편집.</target>
        </trans-unit>
        <trans-unit id="2addd157d30e019e6a4e7e180d209a97e4c55ca4" translate="yes" xml:space="preserve">
          <source>Diameter transport interface.</source>
          <target state="translated">직경 운송 인터페이스.</target>
        </trans-unit>
        <trans-unit id="43b3cac5780593e4e3d7bc6239e48a349da15068" translate="yes" xml:space="preserve">
          <source>Diameter transport over SCTP.</source>
          <target state="translated">SCTP를 통한 직경 전송.</target>
        </trans-unit>
        <trans-unit id="acdb14fc245c23daf5748b9e75a3fe1897608e0b" translate="yes" xml:space="preserve">
          <source>Diameter transport over TCP.</source>
          <target state="translated">TCP를 통한 직경 전송.</target>
        </trans-unit>
        <trans-unit id="7b58dbac06038c0f0528d8a4e1d07f33a1316add" translate="yes" xml:space="preserve">
          <source>Dictionary as returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 사전 .</target>
        </trans-unit>
        <trans-unit id="87d89e495b6fa6aeacaa5f11b3b341c160db5603" translate="yes" xml:space="preserve">
          <source>Dictionary interface of the diameter application.</source>
          <target state="translated">직경 응용의 사전 인터페이스.</target>
        </trans-unit>
        <trans-unit id="8e8972c07f023589103328ced29174f0a45e8b6f" translate="yes" xml:space="preserve">
          <source>Dictionary module generation also results in a hrl file that defines records for the messages and Grouped AVPs defined by the dictionary, these records being what a user of the diameter application sends and receives, modulo other possible formats as discussed in &lt;code&gt;diameter_app(3)&lt;/code&gt;. These records and the underlying Erlang data types corresponding to Diameter data formats are discussed in &lt;code&gt;&lt;a href=&quot;#MESSAGE_RECORDS&quot;&gt;MESSAGE RECORDS&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt; respectively. The generated hrl also contains macro definitions for the possible values of AVPs of type Enumerated.</source>
          <target state="translated">사전 모듈을 생성하면 메시지에 대한 레코드와 사전에 정의 된 그룹화 된 AVP에 대한 레코드를 정의하는 hrl 파일이 생성됩니다. 이러한 레코드는 &lt;code&gt;diameter_app(3)&lt;/code&gt; 에서 설명한대로 다른 가능한 형식의 모듈 식 애플리케이션이 보내고받는 것 입니다. 직경 데이터 형식에 해당하는 이러한 레코드 및 기본 Erlang 데이터 형식은 각각 &lt;code&gt;&lt;a href=&quot;#MESSAGE_RECORDS&quot;&gt;MESSAGE RECORDS&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#DATA_TYPES&quot;&gt;DATA TYPES&lt;/a&gt;&lt;/code&gt; 에서 설명 합니다. 생성 된 hrl에는 열거 유형의 가능한 AVP 값에 대한 매크로 정의도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2239e5358e76aa29c75a70053325a0133f68eb6a" translate="yes" xml:space="preserve">
          <source>Different Information Transfers</source>
          <target state="translated">다른 정보 전송</target>
        </trans-unit>
        <trans-unit id="f28cb22fc88809e7a4c9bd4d34ed7db7571189a7" translate="yes" xml:space="preserve">
          <source>Different applications using this library may have very different requirements. One application could be running on a high performance server, while another is running on a small device with very limited cpu capacity. For example, the first one may accept many users simultaneously logged in, while the second one wants to limit them to only one.</source>
          <target state="translated">이 라이브러리를 사용하는 응용 프로그램마다 요구 사항이 매우 다를 수 있습니다. 한 응용 프로그램은 고성능 서버에서 실행되고 다른 응용 프로그램은 CPU 용량이 매우 제한된 소형 장치에서 실행될 수 있습니다. 예를 들어, 첫 번째 사용자는 동시에 로그인 한 많은 사용자를 수락 할 수 있지만 두 번째 사용자는 한 명으로 만 제한하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6883ae1d8644737fc04ee8e419ba151be5af18e0" translate="yes" xml:space="preserve">
          <source>Different databases may also support creating of procedures that contains more than one SQL query. For example, the following SQLServer-specific statement creates a procedure that returns a result set containing information about employees that work at the department and a result set listing the customers of that department.</source>
          <target state="translated">다른 데이터베이스는 둘 이상의 SQL 쿼리를 포함하는 프로 시저 작성을 지원할 수도 있습니다. 예를 들어, 다음 SQLServer 특정 명령문은 부서에서 근무하는 직원에 대한 정보와 해당 부서의 고객을 나열하는 결과 세트를 포함하는 결과 세트를 리턴하는 프로 시저를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5612af3537f6d424dafb548b8d0f2861de1fab1e" translate="yes" xml:space="preserve">
          <source>Different definitions exist for the week of the year. This module contains a week of the year implementation conforming to the ISO 8601 standard. As the week number for a specified date can fall on the previous, the current, or on the next year, it is important to specify both the year and the week number. Functions &lt;code&gt;iso_week_number/0&lt;/code&gt; and &lt;code&gt;iso_week_number/1&lt;/code&gt; return a tuple of the year and the week number.</source>
          <target state="translated">연중 다른 정의가 존재합니다. 이 모듈에는 ISO 8601 표준을 준수하는 일주일의 구현이 포함되어 있습니다. 지정된 날짜의 주 번호는 이전, 현재 또는 다음 해에 해당 할 수 있으므로 연도와 주 번호를 모두 지정하는 것이 중요합니다. &lt;code&gt;iso_week_number/0&lt;/code&gt; 및 &lt;code&gt;iso_week_number/1&lt;/code&gt; 함수 는 연도 및 주 번호의 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce0e98d45f7debe7b95b821f0db8cec8b4e61285" translate="yes" xml:space="preserve">
          <source>Different hardware architectures have different memory models. Some architectures allows very aggressive reordering of memory accesses while other architectures only reorder a few specific cases. Common to all modern hardware is, however, that some type of reordering will occur. When using locks to protect all memory accesses made from multiple threads such reorderings will not be visible. The locking primitives will ensure that the memory accesses will be ordered. When using lock free algorithms one do however have to take this reordering made by the hardware into account.</source>
          <target state="translated">하드웨어 아키텍처마다 메모리 모델이 다릅니다. 일부 아키텍처는 메모리 액세스의 매우 적극적인 재정렬을 허용하는 반면 다른 아키텍처는 몇 가지 특정 사례 만 재정렬합니다. 그러나 모든 최신 하드웨어의 공통점은 일부 유형의 재정렬이 발생한다는 것입니다. 잠금을 사용하여 여러 스레드에서 이루어진 모든 메모리 액세스를 보호하면 이러한 재정렬이 표시되지 않습니다. 잠금 프리미티브는 메모리 액세스가 정렬되도록 보장합니다. 잠금없는 알고리즘을 사용할 때 하드웨어에 의해 만들어진 이러한 재정렬을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="a780becc239b49b491b75f64fbceae7f3572be1d" translate="yes" xml:space="preserve">
          <source>Different operating systems and tools support different encodings. For example, Linux and MacOS X have chosen the UTF-8 encoding, which is backward compatible with 7-bit ASCII and therefore affects programs written in plain English the least. Windows supports a limited version of UTF-16, namely all the code planes where the characters can be stored in one single 16-bit entity, which includes most living languages.</source>
          <target state="translated">다른 운영 체제 및 도구는 다른 인코딩을 지원합니다. 예를 들어 Linux 및 MacOS X는 UTF-8 인코딩을 선택했습니다. UTF-8 인코딩은 7 비트 ASCII와 역 호환되므로 일반 영어로 작성된 프로그램에 가장 영향을 미칩니다. Windows는 제한된 버전의 UTF-16, 즉 대부분의 살아있는 언어를 포함하여 하나의 단일 16 비트 엔터티에 문자를 저장할 수있는 모든 코드 평면을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2e33264a68973aa9eaf05e50aaef661eca484cb2" translate="yes" xml:space="preserve">
          <source>Different parts of the system will be handled differently regarding compatibility. The following items describe how different parts of the system are handled.</source>
          <target state="translated">시스템의 다른 부분은 호환성과 관련하여 다르게 처리됩니다. 다음 항목은 시스템의 다른 부분을 처리하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0cabc30640c262e4e1ee03e71abfde75a1286e90" translate="yes" xml:space="preserve">
          <source>Different runtime system instances will use different unspecified points in time as base for their Erlang monotonic clocks. That is, it is &lt;strong&gt;pointless&lt;/strong&gt; comparing monotonic times from different runtime system instances. Different runtime system instances can also place this unspecified point in time different relative runtime system start. It can be placed in the future (time at start is a negative value), the past (time at start is a positive value), or the runtime system start (time at start is zero). The monotonic time at runtime system start can be retrieved by calling &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt; erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 런타임 시스템 인스턴스는 Erlang 단조로운 시계의 기준으로 지정되지 않은 다른 시점을 사용합니다. 즉, 그것은이다 &lt;strong&gt;무의미&lt;/strong&gt; 다른 런타임 시스템 인스턴스에서 단조 시간을 비교. 다른 런타임 시스템 인스턴스는이 지정되지 않은 시점을 다른 상대 런타임 시스템 시작에 배치 할 수도 있습니다. 미래 (시작 시간은 음수 값), 과거 (시작 시간은 양수 값) 또는 런타임 시스템 시작 (시작 시간은 0)에 배치 할 수 있습니다. 런타임 시스템 시작시 단조로운 시간은 &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt; erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; 을 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aed32969a09a784815b2c2d1e9d839fe9acde992" translate="yes" xml:space="preserve">
          <source>Different runtime system instances will use different unspecified points in time as base for their Erlang monotonic clocks. That is, it is &lt;strong&gt;pointless&lt;/strong&gt; comparing monotonic times from different runtime system instances. Different runtime system instances can also place this unspecified point in time different relative runtime system start. It can be placed in the future (time at start is a negative value), the past (time at start is a positive value), or the runtime system start (time at start is zero). The monotonic time at runtime system start can be retrieved by calling &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 런타임 시스템 인스턴스는 Erlang 모노 토닉 시계의 기본으로 다른 지정되지 않은 시점을 사용합니다. 즉, 그것은이다 &lt;strong&gt;무의미&lt;/strong&gt; 다른 런타임 시스템 인스턴스에서 단조 시간을 비교. 다른 런타임 시스템 인스턴스는이 지정되지 않은 특정 시점을 다른 상대적 런타임 시스템 시작으로 둘 수도 있습니다. 미래 (시작 시간은 음수 값), 과거 (시작 시간은 양수 값) 또는 런타임 시스템 시작 (시작 시간은 0 임)에 배치 할 수 있습니다. 런타임 시스템 시작시 단조 시간은 &lt;code&gt;&lt;a href=&quot;#system_info_start_time&quot;&gt;erlang:system_info(start_time)&lt;/a&gt;&lt;/code&gt; 을 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b3df3df2ca9d872263d17d4c6946b215d1cf6da" translate="yes" xml:space="preserve">
          <source>Different transaction managers employ different strategies to satisfy the isolation property. &lt;code&gt;Mnesia&lt;/code&gt; uses the standard technique of two phase locking. That is, locks are set on records before they are read or written. &lt;code&gt;Mnesia&lt;/code&gt; uses the following lock types:</source>
          <target state="translated">서로 다른 트랜잭션 관리자는 서로 다른 전략을 사용하여 격리 속성을 충족시킵니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 2 단계 잠금의 표준 기술을 사용합니다. 즉, 잠금은 레코드를 읽거나 쓰기 전에 레코드에 설정됩니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 다음과 같은 잠금 유형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f30aa1d84a5056694b8a279afb906ca8147af45" translate="yes" xml:space="preserve">
          <source>Diffie-Hellman</source>
          <target state="translated">Diffie-Hellman</target>
        </trans-unit>
        <trans-unit id="1799dfd79ce2607c8a41d935527b9f4ab8fcdd66" translate="yes" xml:space="preserve">
          <source>Diffie-Hellman Keys and parameters</source>
          <target state="translated">Diffie-Hellman 키 및 매개 변수</target>
        </trans-unit>
        <trans-unit id="335eaacb0e06e9f01d986f626e623ea878a4ed44" translate="yes" xml:space="preserve">
          <source>Diffie-Hellman computations are available with OpenSSL versions compatible with Erlang CRYPTO if not disabled by configuration. To dynamically check availability, check that the atom &lt;code&gt;dh&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Diffie-Hellman 계산은 구성에 의해 비활성화되지 않은 경우 Erlang CRYPTO와 호환되는 OpenSSL 버전에서 사용할 수 있습니다. 가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 원자 &lt;code&gt;dh&lt;/code&gt; 가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="cef6fbd636e82ab4f62121042f17cc0a73b0b502" translate="yes" xml:space="preserve">
          <source>DigestType ::</source>
          <target state="translated">DigestType ::</target>
        </trans-unit>
        <trans-unit id="132c55c7377232a793fc2764c202db07a983c1ab" translate="yes" xml:space="preserve">
          <source>Digests and hash</source>
          <target state="translated">다이제스트 및 해시</target>
        </trans-unit>
        <trans-unit id="cc94430bcd2bf3633999f075c4aa5f4c6e00a26c" translate="yes" xml:space="preserve">
          <source>Digital signatures &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/drafts/fips186-3/fips_186-3.pdf&quot;&gt;Digital Signature Standard (DSS)&lt;/a&gt;&lt;/code&gt; and&lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf&quot;&gt; Elliptic Curve Digital Signature Algorithm (ECDSA) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">디지털 서명 &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/drafts/fips186-3/fips_186-3.pdf&quot;&gt;Digital Signature Standard (DSS)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf&quot;&gt; Elliptic Curve Digital Signature Algorithm (ECDSA) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2d1527ad440c65c78936fafa709eaae0056a11c" translate="yes" xml:space="preserve">
          <source>Digraph &lt;code&gt;G&lt;/code&gt; is traversed in a breadth-first manner, and the first found path is returned.</source>
          <target state="translated">Digraph &lt;code&gt;G&lt;/code&gt; 는 너비 우선으로 탐색되고 처음 발견 된 경로가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="70e541d54d4571932b5458248248c88322d737b3" translate="yes" xml:space="preserve">
          <source>Digraph &lt;code&gt;G&lt;/code&gt; is traversed in a depth-first manner, and the first found path is returned.</source>
          <target state="translated">Digraph &lt;code&gt;G&lt;/code&gt; 는 깊이 우선 방식으로 순회하고 첫 번째 발견 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93dca2efcca5c19009fb242e9a74ae8b5859f1a9" translate="yes" xml:space="preserve">
          <source>Digraphs can be annotated with more information. Such information can be attached to the vertices and to the edges of the digraph. An annotated digraph is called a &lt;strong&gt;labeled digraph&lt;/strong&gt;, and the information attached to a vertex or an edge is called a &lt;strong id=&quot;label&quot;&gt;label&lt;/strong&gt;.</source>
          <target state="translated">더 많은 정보로 Digraphs에 주석을 달 수 있습니다. 이러한 정보는 정점과 digraph의 가장자리에 첨부 될 수 있습니다. 주석이 달린 digraph를 &lt;strong&gt;레이블이 붙은 digraph&lt;/strong&gt; 라고하며 정점 또는 가장자리에 첨부 된 정보를 &lt;strong id=&quot;label&quot;&gt;label&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="2bdb5f32ccbfb6d3d1a3147e65f438a4ec636024" translate="yes" xml:space="preserve">
          <source>Digraphs can be annotated with more information. Such information can be attached to the vertices and to the edges of the digraph. An annotated digraph is called a &lt;strong&gt;labeled digraph&lt;/strong&gt;, and the information attached to a vertex or an edge is called a &lt;strong id=&quot;label&quot;&gt;label&lt;/strong&gt;. Labels are Erlang terms.</source>
          <target state="translated">더 많은 정보로 Digraphs에 주석을 달 수 있습니다. 이러한 정보는 정점과 digraph의 가장자리에 첨부 될 수 있습니다. 주석이 달린 digraph를 &lt;strong&gt;레이블이 붙은 digraph&lt;/strong&gt; 라고하며 정점 또는 가장자리에 첨부 된 정보를 &lt;strong id=&quot;label&quot;&gt;label&lt;/strong&gt; 이라고합니다 . 레이블은 Erlang 용어입니다.</target>
        </trans-unit>
        <trans-unit id="8c283a0fe4d5df5390c92bd0efb703342217ba6b" translate="yes" xml:space="preserve">
          <source>Digraphs will not be garbage collected. The ETS tables used for a digraph will only be deleted when &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; is called or the process that created the digraph terminates.</source>
          <target state="translated">Digraph는 가비지 수집되지 않습니다. digraph에 사용 된 ETS 테이블은 &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; 이 호출되거나 digraph를 생성 한 프로세스가 종료 될 때만 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="a5e38d6b903ccda016759402d329e33a83548707" translate="yes" xml:space="preserve">
          <source>Dir :: &lt;code&gt;&lt;a href=&quot;#type-filename&quot;&gt;filename()&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">Dir :: &lt;code&gt;&lt;a href=&quot;#type-filename&quot;&gt;filename()&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ad2c0ce42ca198c5519523a969e131463983adf5" translate="yes" xml:space="preserve">
          <source>Directed graphs.</source>
          <target state="translated">지시 된 그래프.</target>
        </trans-unit>
        <trans-unit id="243cff888dae22be4e6f01a534ee25469aa6a683" translate="yes" xml:space="preserve">
          <source>Directly by using module &lt;code&gt;seq_trace&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seq_trace&lt;/code&gt; 모듈을 사용하여 직접 .</target>
        </trans-unit>
        <trans-unit id="c9ecc417c112f66b0e63b1f01eb83e8458007c11" translate="yes" xml:space="preserve">
          <source>Directories containing Erlang modules to be included in a code coverage test must exist in the code server path. Otherwise, the Cover tool fails to recompile the modules. It is not sufficient to specify these directories in the cover specification file for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">코드 커버리지 테스트에 포함될 Erlang 모듈을 포함하는 디렉토리는 코드 서버 경로에 존재해야합니다. 그렇지 않으면 표지 도구가 모듈을 다시 컴파일하지 못합니다. &lt;code&gt;Common Test&lt;/code&gt; 의 표지 스펙 파일에서이 디렉토리를 지정하는 것만으로는 충분하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5ab4b58d628fe3f03e24fefd9e79c9cd5305431f" translate="yes" xml:space="preserve">
          <source>Directories passed to &lt;code&gt;Common Test&lt;/code&gt; can have either relative or absolute paths.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 전달 된 디렉토리는 상대 또는 절대 경로를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6cb58a29cb92f80451b089ee8dcc6df2383846" translate="yes" xml:space="preserve">
          <source>Directory &lt;code&gt;Dir&lt;/code&gt; is to be added to the code path.</source>
          <target state="translated">디렉터리 &lt;code&gt;Dir&lt;/code&gt; 코드 경로에 추가해야한다.</target>
        </trans-unit>
        <trans-unit id="37da76e6522f5231ccef0cde70e3579a65e938f9" translate="yes" xml:space="preserve">
          <source>Directory Listings</source>
          <target state="translated">디렉토리 목록</target>
        </trans-unit>
        <trans-unit id="fd7d9fd644987840c54fd62d80a891889bfcc421" translate="yes" xml:space="preserve">
          <source>Directory Structure Guidelines for a Development Environment</source>
          <target state="translated">개발 환경을위한 디렉토리 구조 지침</target>
        </trans-unit>
        <trans-unit id="ef0d89c504070d30a057e3e2666364d93ceb17ea" translate="yes" xml:space="preserve">
          <source>Directory contents</source>
          <target state="translated">디렉토리 내용</target>
        </trans-unit>
        <trans-unit id="406373555c5db06a112c39c5633ef075b4eb9b4c" translate="yes" xml:space="preserve">
          <source>Directory names not starting with &lt;code&gt;/&lt;/code&gt; are assumed to be relative the current working directory.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 로 시작하지 않는 디렉토리 이름 은 현재 작업 디렉토리에 상대적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="69c1b321a3a3f10dbb43a3ed72a72c42e77de3a4" translate="yes" xml:space="preserve">
          <source>Directory names should not be capitalized.</source>
          <target state="translated">디렉토리 이름은 대문자로 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a65c287fbc14b015d2a237c8c17c5222537b05bb" translate="yes" xml:space="preserve">
          <source>Directory names starting with &lt;code&gt;/&lt;/code&gt; are assumed to be absolute path names.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 로 시작하는 디렉토리 이름 은 절대 경로 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f87cbc37768d43bb57fe075ed3cecacb04c89d4c" translate="yes" xml:space="preserve">
          <source>Directory separators must always be written as &lt;code&gt;/&lt;/code&gt;, even on Windows.</source>
          <target state="translated">Windows에서도 디렉토리 구분 기호는 항상 &lt;code&gt;/&lt;/code&gt; 로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="caac219f13e886f255200fff4fa6a28d1f9a338f" translate="yes" xml:space="preserve">
          <source>Directory where the profile can save persistent data. If omitted, all cookies are treated as session cookies.</source>
          <target state="translated">프로파일이 지속적 데이터를 저장할 수있는 디렉토리입니다. 생략하면 모든 쿠키가 세션 쿠키로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="284afc0808fc43fcb8ad33e37b614c07e484dbef" translate="yes" xml:space="preserve">
          <source>Dirty IO schedulers will have scheduler identifiers in the range &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt; erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers) +&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_io_schedulers&quot;&gt; erlang:system_info(dirty_io_schedulers)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Dirty IO 스케줄러는 &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt; erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt; erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers) +&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_io_schedulers&quot;&gt; erlang:system_info(dirty_io_schedulers)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dde8a410b2cef8745dc367bbeecd37822cd25d7" translate="yes" xml:space="preserve">
          <source>Dirty IO schedulers will have scheduler identifiers in the range &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers) +&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#system_info_dirty_io_schedulers&quot;&gt;erlang:system_info(dirty_io_schedulers)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">더러운 IO 스케줄러가 스케줄러 범위 내의 식별자 것이다 &lt;code&gt;&lt;a href=&quot;#system_info_schedulers&quot;&gt;erlang:system_info(schedulers)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_cpu_schedulers&quot;&gt;erlang:system_info(dirty_cpu_schedulers)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&amp;lt; SchedulerId =&amp;lt; erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers) +&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#system_info_dirty_io_schedulers&quot;&gt;erlang:system_info(dirty_io_schedulers)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03c764c23e6f3e21522962d8392207a9aec42ffc" translate="yes" xml:space="preserve">
          <source>Dirty NIF support is available only when the emulator is configured with dirty scheduler support. As of ERTS version 9.0, dirty scheduler support is enabled by default on the runtime system with SMP support. The Erlang runtime without SMP support does &lt;strong&gt;not&lt;/strong&gt; support dirty schedulers even when the dirty scheduler support is explicitly enabled. To check at runtime for the presence of dirty scheduler threads, code can use the &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt; enif_system_info()&lt;/a&gt;&lt;/code&gt; API function.</source>
          <target state="translated">Dirty NIF 지원은 에뮬레이터가 Dirty 스케줄러 지원으로 구성된 경우에만 사용할 수 있습니다. ERTS 버전 9.0부터 더티 스케줄러 지원은 SMP를 지원하는 런타임 시스템에서 기본적으로 활성화됩니다. SMP가 지원되지 &lt;strong&gt;않는&lt;/strong&gt; Erlang 런타임 은 더티 스케줄러 지원이 명시 적으로 활성화 된 경우에도 더티 스케줄러를 지원하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 더티 스케줄러 스레드가 있는지 런타임에 확인하기 위해 코드는 &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt; enif_system_info()&lt;/a&gt;&lt;/code&gt; API 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f776c53728b9a78e34582415361299583c2f7ae1" translate="yes" xml:space="preserve">
          <source>Dirty NIF support is available only when the emulator is configured with dirty scheduler support. As of ERTS version 9.0, dirty scheduler support is enabled by default on the runtime system with SMP support. The Erlang runtime without SMP support does &lt;strong&gt;not&lt;/strong&gt; support dirty schedulers even when the dirty scheduler support is explicitly enabled. To check at runtime for the presence of dirty scheduler threads, code can use the &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info()&lt;/a&gt;&lt;/code&gt; API function.</source>
          <target state="translated">더티 NIF 지원은 에뮬레이터가 더티 스케줄러 지원으로 구성된 경우에만 사용할 수 있습니다. ERTS 버전 9.0부터 SMP를 지원하는 런타임 시스템에서 더티 스케줄러 지원이 기본적으로 사용됩니다. SMP를 지원하지 &lt;strong&gt;않는&lt;/strong&gt; Erlang 런타임 은 더티 스케줄러 지원이 명시 적으로 활성화 된 경우에도 더티 스케줄러를 지원하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 더티 스케줄러 스레드가 있는지 런타임에 확인하기 위해 코드는 &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info()&lt;/a&gt;&lt;/code&gt; API 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a963571ffbcc2363316cb4131267d7bb18e560a3" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:all_keys/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:all_keys/1&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6730f17243320e93c4820bdb3347a524eb6f76be" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:delete/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete/3&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="4803a712add1388359b074286a97c71ac03a18ec" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:delete_object/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:delete_object/3&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9819320bcc19465d5dbe72db932ce31e969e4f47" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:index_match_object/4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:index_match_object/4&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ae95fb440f9f0e27b1eda44b2c952a05213b976d" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:index_read/3&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="064b2b60b7cec261b9641cfb6150d6b98fa5d361" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:match_object/3&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d027124011b6d5898913193904cb44d1bf7613d9" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:read/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:read/3&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8d5501c6a210dcc1de9608082f9d1e416032c68f" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:select/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:select/2&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="18d67f692bf5bd1046b2d5956ee8e53a74a3f5c6" translate="yes" xml:space="preserve">
          <source>Dirty equivalent of the function &lt;code&gt;mnesia:write/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mnesia:write/3&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="72b8a4c5a40ea145e7c00b5e635182a9120bdea4" translate="yes" xml:space="preserve">
          <source>Dirty operation are often useful, for example, in a datagram routing application where &lt;code&gt;Mnesia&lt;/code&gt; stores the routing table, and it is time consuming to start a whole transaction every time a packet is received. &lt;code&gt;Mnesia&lt;/code&gt; has therefore functions that manipulate tables without using transactions. This alternative to processing is known as a dirty operation. However, notice the trade-off in avoiding the overhead of transaction processing:</source>
          <target state="translated">예를 들어, &lt;code&gt;Mnesia&lt;/code&gt; 가 라우팅 테이블을 저장 하는 데이터 그램 라우팅 응용 프로그램에서 더티 연산이 유용 하며 패킷을 수신 할 때마다 전체 트랜잭션을 시작하는 데 시간이 걸립니다. 따라서 &lt;code&gt;Mnesia&lt;/code&gt; 에는 트랜잭션을 사용하지 않고 테이블을 조작하는 기능이 있습니다. 처리에 대한이 대안을 더티 작업이라고합니다. 그러나 트랜잭션 처리의 오버 헤드를 피할 때의 절충점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="136014a72498b6b9b3b61aa360cdefc56a3dc1d1" translate="yes" xml:space="preserve">
          <source>Dirty operations</source>
          <target state="translated">더러운 작업</target>
        </trans-unit>
        <trans-unit id="c4275fbd897af2315c2118648b50df4435cebdd9" translate="yes" xml:space="preserve">
          <source>Dirty operations always contain only one update and thus no activity event is sent.</source>
          <target state="translated">더티 작업에는 항상 하나의 업데이트 만 포함되므로 활동 이벤트가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa50ffb6abfb356d785f0330d2d417505b69d837" translate="yes" xml:space="preserve">
          <source>Dirty operations are written to disc if they are performed on a table of type &lt;code&gt;disc_copies&lt;/code&gt; or type &lt;code&gt;disc_only_copies&lt;/code&gt;. &lt;code&gt;Mnesia&lt;/code&gt; also ensures that all replicas of a table are updated if a dirty write operation is performed on a table.</source>
          <target state="translated">더티 작업은 &lt;code&gt;disc_copies&lt;/code&gt; 유형 또는 &lt;code&gt;disc_only_copies&lt;/code&gt; 유형의 테이블에서 수행되는 경우 디스크에 기록됩니다 . &lt;code&gt;Mnesia&lt;/code&gt; 는 또한 테이블에서 더티 쓰기 작업이 수행되는 경우 테이블의 모든 복제본이 업데이트되도록합니다.</target>
        </trans-unit>
        <trans-unit id="853438de86dac28cac55a35b9641e0bd67c6f648" translate="yes" xml:space="preserve">
          <source>DirtyCPUSchedulersOnline) -&amp;gt;</source>
          <target state="translated">DirtyCPUSchedulersOnline)-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="46015467f190d633f418a569f23109bb67051807" translate="yes" xml:space="preserve">
          <source>Disable automatic gc of the mib server cache.</source>
          <target state="translated">mib 서버 캐시의 자동 gc를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="bbc557db02430ed632f545e4b3a20960ff5fe9b2" translate="yes" xml:space="preserve">
          <source>Disable one-time execution.</source>
          <target state="translated">일회성 실행을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="76bd3c5c018e2a61d5610b964b32a5deefa1bba1" translate="yes" xml:space="preserve">
          <source>Disable the auto-compilation feature (similar to &lt;code&gt;ct_run -no_auto_compile&lt;/code&gt;).</source>
          <target state="translated">자동 컴파일 기능을 비활성화합니다 ( &lt;code&gt;ct_run -no_auto_compile&lt;/code&gt; 과 유사 ).</target>
        </trans-unit>
        <trans-unit id="197dd9bc80386b0df3c823b696ec70695af97e98" translate="yes" xml:space="preserve">
          <source>Disable the mib server cache.</source>
          <target state="translated">mib 서버 캐시를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="73f00fae8033ed7aa00f57da49d8f4afc54218e6" translate="yes" xml:space="preserve">
          <source>Disables SAC delay</source>
          <target state="translated">SAC 지연을 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="5b110f63f186be3c7c93c8e0719d6c40201f32e3" translate="yes" xml:space="preserve">
          <source>Disables all allocators that can be disabled.</source>
          <target state="translated">비활성화 할 수있는 모든 할당자를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b1603559997a45d4ab53133ad023c7c6fbd13e90" translate="yes" xml:space="preserve">
          <source>Disables all breakpoints.</source>
          <target state="translated">모든 중단 점을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f0f1900b113d92659c235dfcb60389ba9de8dc08" translate="yes" xml:space="preserve">
          <source>Disables automatic Path MTU discovery</source>
          <target state="translated">자동 경로 MTU 검색 비활성화</target>
        </trans-unit>
        <trans-unit id="5ab25d2aff103bc762d22d0efc7b35138f46952e" translate="yes" xml:space="preserve">
          <source>Disables automatic escaping of special HTML characters. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;Logging chapter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특수 HTML 문자의 자동 이스케이프를 비활성화합니다. &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;Logging chapter&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63f7882a53b38e4243f12b5b79a4cd7893cd5b26" translate="yes" xml:space="preserve">
          <source>Disables busy port message queue functionality. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_busy_msgq_limits&quot;&gt; erl_driver:erl_drv_busy_msgq_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용중인 포트 메시지 대기열 기능을 비활성화합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_busy_msgq_limits&quot;&gt; erl_driver:erl_drv_busy_msgq_limits&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7593253a728d7cf78461e61c33450c17030aafde" translate="yes" xml:space="preserve">
          <source>Disables busy port message queue functionality. For more information, see &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_busy_msgq_limits&quot;&gt;erl_driver:erl_drv_busy_msgq_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용중인 포트 메시지 큐 기능을 비활성화합니다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_busy_msgq_limits&quot;&gt;erl_driver:erl_drv_busy_msgq_limits&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70bb3a7d47ffdd3bc94f55af3bbfd79dcc5fd262" translate="yes" xml:space="preserve">
          <source>Disables features that cannot be enabled while creating an allocator configuration with &lt;code&gt; erts_alloc_config(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; erts_alloc_config(3)&lt;/code&gt; 할당 자 구성을 생성하는 동안 활성화 할 수없는 기능을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="37be9cbf19e8c4d94f4cdadb90d4e87688cdbc77" translate="yes" xml:space="preserve">
          <source>Disables features that cannot be enabled while creating an allocator configuration with &lt;code&gt;erts_alloc_config(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config(3)&lt;/code&gt; 할당 자 구성을 작성하는 동안 사용할 수없는 기능을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a614d492ceaa156affdf5d4bdefafec5576bcceb" translate="yes" xml:space="preserve">
          <source>Disables heartbeat</source>
          <target state="translated">하트 비트를 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="ef9f0619eb9caef8a34d63963c121785d1466e86" translate="yes" xml:space="preserve">
          <source>Disables optimization that can malfunction if &quot;Special start-of-pattern items&quot; are present in the regular expression. A typical example would be when matching &quot;DEFABC&quot; against &quot;(*COMMIT)ABC&quot;, where the start optimization of PCRE would skip the subject up to &quot;A&quot; and never realize that the (*COMMIT) instruction is to have made the matching fail. This option is only relevant if you use &quot;start-of-pattern items&quot;, as discussed in section &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Expression Details&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;특수 패턴 시작 항목&quot;이 정규식에있는 경우 오작동 할 수있는 최적화를 비활성화합니다. 일반적인 예는 &quot;DEFABC&quot;를 &quot;(* COMMIT) ABC&quot;와 일치시킬 때 PCRE의 최적화 시작이 주제를 &quot;A&quot;까지 건너 뛰고 (* COMMIT) 명령이 일치한다는 것을 결코 인식하지 못하는 경우입니다. 불합격. 이 옵션은 &lt;code&gt;&lt;a href=&quot;#regexp_syntax_details&quot;&gt;PCRE Regular Expression Details&lt;/a&gt;&lt;/code&gt; 섹션에서 설명한대로 &quot;패턴 시작 항목&quot;을 사용하는 경우에만 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c404f858a3fcd9bae301bbd98fe536b9fe7a1a7c" translate="yes" xml:space="preserve">
          <source>Disables the &lt;code&gt;os_sup&lt;/code&gt; service. Needed on Solaris only.</source>
          <target state="translated">&lt;code&gt;os_sup&lt;/code&gt; 서비스를 비활성화합니다 . Solaris에서만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d93c1136104c42e8c7c1536818cabe58700fba0c" translate="yes" xml:space="preserve">
          <source>Disables the automatic test suite compilation feature (described earlier).</source>
          <target state="translated">자동 테스트 스위트 컴파일 기능을 비활성화합니다 (앞서 설명).</target>
        </trans-unit>
        <trans-unit id="91d420658fc46ab94b4ff3545d61fc2d3c8cde2c" translate="yes" xml:space="preserve">
          <source>Disables the default handler. This allows another application to add its own default handler.</source>
          <target state="translated">기본 처리기를 비활성화합니다. 이를 통해 다른 응용 프로그램이 자체 기본 처리기를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="133d6494dcd6c46493ddf1685293a36623e293f5" translate="yes" xml:space="preserve">
          <source>Disables the sticky directory facility of the Erlang code server; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">Erlang 코드 서버의 고정 디렉토리 기능을 사용하지 않습니다. &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8303ac8a6039acc7c220b67fab46629f1b907fc" translate="yes" xml:space="preserve">
          <source>Disables the use of numbered capturing parentheses in the pattern. Any opening parenthesis that is not followed by &lt;code&gt;?&lt;/code&gt; behaves as if it is followed by &lt;code&gt;?:&lt;/code&gt;. Named parentheses can still be used for capturing (and they acquire numbers in the usual way). There is no equivalent option in Perl.</source>
          <target state="translated">패턴에 번호 매기기 캡처 괄호를 사용하지 않습니다. 뒤에 괄호가없는 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt; 뒤에 오는 것처럼 동작합니다 . 명명 된 괄호는 여전히 캡처에 사용될 수 있습니다 (그리고 일반적인 방법으로 숫자를 얻습니다). Perl에는 동등한 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="62c3939a2d0370b4df3b4f65b029525d3f10ac74" translate="yes" xml:space="preserve">
          <source>Disables time correction.</source>
          <target state="translated">시간 수정을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f747dca83f7e533bc9f21ec112a00de20b04ac59" translate="yes" xml:space="preserve">
          <source>Disables tracing for all received messages. Any match specification is removed.</source>
          <target state="translated">수신 된 모든 메시지에 대한 추적을 비활성화합니다. 모든 일치 사양이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c6f60ed2d58ddd2546f1c92f3b23c7fc7b8db7" translate="yes" xml:space="preserve">
          <source>Disables tracing for all sent messages. Any match specification is removed.</source>
          <target state="translated">보낸 모든 메시지에 대한 추적을 비활성화합니다. 모든 일치 사양이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="052bd1ec9b7d0195d48f3445314353c790266505" translate="yes" xml:space="preserve">
          <source>Disables tracing for the matching functions. Any match specification is removed.</source>
          <target state="translated">일치하는 기능에 대한 추적을 비활성화합니다. 모든 일치 사양이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b4aed9d646971376493a208349a826cb4c12b9" translate="yes" xml:space="preserve">
          <source>Disabling arity checks affects the form of messages at encode/decode. In particular, decoded AVPs are represented as lists of values, regardless of the AVP's arity (ie. expected number in the message/AVP grammar in question), and values are expected to be supplied as lists at encode. This differs from the historic decode behaviour of representing AVPs of arity 1 as bare values, not wrapped in a list.</source>
          <target state="translated">arity check를 비활성화하면 인코딩 / 디코딩시 메시지 형식에 영향을줍니다. 특히, 디코딩 된 AVP는 AVP의 특성 (즉, 해당 메시지 / AVP 문법의 예상 수)에 관계없이 값의 목록으로 표현되며, 값은 인코딩시 목록으로 제공 될 것으로 예상된다. 이것은 arity 1의 AVP를 목록으로 묶지 않은 베어 값으로 표시하는 기록 디코드 동작과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="019544662459c34c84ab1f2f72c6fedddbe538f0" translate="yes" xml:space="preserve">
          <source>Disabling counters is a performance improvement, but means that the omitted counters are not returned by &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">카운터를 비활성화하면 성능이 향상되지만 생략 된 카운터는 &lt;code&gt;&lt;a href=&quot;#service_info-2&quot;&gt;service_info/2&lt;/a&gt;&lt;/code&gt; 에서 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="76a831e0997e7ea4fb9c444b8f508021eca00f12" translate="yes" xml:space="preserve">
          <source>Disabling shell and exec in a daemon</source>
          <target state="translated">데몬에서 쉘 및 exec 비활성화</target>
        </trans-unit>
        <trans-unit id="30dcc2129cb59bbec6b75af27e09310eb15a967b" translate="yes" xml:space="preserve">
          <source>Disaster Recovery</source>
          <target state="translated">재해 복구</target>
        </trans-unit>
        <trans-unit id="ad694189656d6d69aa0303359764d4f191934c22" translate="yes" xml:space="preserve">
          <source>Disc-less nodes</source>
          <target state="translated">디스크없는 노드</target>
        </trans-unit>
        <trans-unit id="ba6ed47955f40df472a5f8beac813210c9595e35" translate="yes" xml:space="preserve">
          <source>Disclaimer: The author accepts no responsibility for errors introduced in code that has been processed by the program. It has been reasonably well tested, but the possibility of errors remains. Keep backups of your original code safely stored, until you feel confident that the new, modified code can be trusted.</source>
          <target state="translated">면책 조항 : 저자는 프로그램에서 처리 한 코드에 발생한 오류에 대해 책임을지지 않습니다. 잘 테스트되었지만 오류 가능성은 여전히 ​​남아 있습니다. 새로운 수정 된 코드를 신뢰할 수 있다고 확신 할 때까지 원래 코드의 백업을 안전하게 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="cfd988cdc067039f90d04d2baa7c90c660553b55" translate="yes" xml:space="preserve">
          <source>Disclaimer: the author of this program takes no responsibility for the correctness of the produced output, or for any effects of its execution. In particular, the author may not be held responsible should Igor include the code of a deceased madman in the result.</source>
          <target state="translated">면책 조항 :이 프로그램의 저자는 생성 된 출력의 정확성 또는 실행 결과에 대해 책임을지지 않습니다. 특히 Igor가 사망 한 매드 먼의 코드를 결과에 포함 시키면 저자는 책임을지지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2cce7325057892153f44eaa30a90a3c86e5de3" translate="yes" xml:space="preserve">
          <source>Disconnect-Cause AVP</source>
          <target state="translated">연결 끊김 원인 AVP</target>
        </trans-unit>
        <trans-unit id="ff1396a2181372840b5ab3bd74b8cad283adf658" translate="yes" xml:space="preserve">
          <source>Disconnect-Cause AVP Values</source>
          <target state="translated">연결 끊김 원인 AVP 값</target>
        </trans-unit>
        <trans-unit id="f14abc14828dff0b3991be236d7f7cf54da51f12" translate="yes" xml:space="preserve">
          <source>Disconnect-Cause to send, &lt;code&gt;REBOOTING&lt;/code&gt;, &lt;code&gt;BUSY&lt;/code&gt; and &lt;code&gt;DO_NOT_WANT_TO_TALK_TO_YOU&lt;/code&gt; respectively. Defaults to &lt;code&gt;rebooting&lt;/code&gt; for &lt;code&gt;Reason=service|application&lt;/code&gt; and &lt;code&gt;goaway&lt;/code&gt; for &lt;code&gt;Reason=transport&lt;/code&gt;.</source>
          <target state="translated">연결 끊기-원인, &lt;code&gt;REBOOTING&lt;/code&gt; , &lt;code&gt;BUSY&lt;/code&gt; 및 &lt;code&gt;DO_NOT_WANT_TO_TALK_TO_YOU&lt;/code&gt; 를 각각 보냅니다 . 기본값은 &lt;code&gt;rebooting&lt;/code&gt; 을위한 &lt;code&gt;Reason=service|application&lt;/code&gt; 및 &lt;code&gt;goaway&lt;/code&gt; 에 대한 &lt;code&gt;Reason=transport&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb6f5b85df7280837caa7684c21ebca654127f2" translate="yes" xml:space="preserve">
          <source>Disconnect-Peer-Answer</source>
          <target state="translated">Disconnect-Peer-Answer</target>
        </trans-unit>
        <trans-unit id="ac00be15043552408adbb950359743263da6af3c" translate="yes" xml:space="preserve">
          <source>Disconnect-Peer-Request</source>
          <target state="translated">Disconnect-Peer-Request</target>
        </trans-unit>
        <trans-unit id="0b89ba1fee4ae5db5b5cbdc2a3e20cb0bb715a06" translate="yes" xml:space="preserve">
          <source>Disconnecting Peer Connections</source>
          <target state="translated">피어 연결 끊기</target>
        </trans-unit>
        <trans-unit id="4130fdb42bbd68fda4590cd56ee038ef4ac9d67b" translate="yes" xml:space="preserve">
          <source>Disconnecting a client from the server</source>
          <target state="translated">서버에서 클라이언트 연결 끊기</target>
        </trans-unit>
        <trans-unit id="4777f6524a18a233a6b8a935dab6c2675a1c7aaf" translate="yes" xml:space="preserve">
          <source>Discovery can only be performed towards one manager at a time.</source>
          <target state="translated">한 번에 한 명의 관리자에게만 검색을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcb2aee26678c8fa201281e24483d3205c8e34b7" translate="yes" xml:space="preserve">
          <source>Disk log format. Defaults to &lt;code&gt;internal&lt;/code&gt;.</source>
          <target state="translated">디스크 로그 형식. 기본값은 &lt;code&gt;internal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4601cd5c257aa63f669ff263176f89589ca3b4c9" translate="yes" xml:space="preserve">
          <source>Disk-Less and/or Read-Only Clients</source>
          <target state="translated">디스크없는 및 / 또는 읽기 전용 클라이언트</target>
        </trans-unit>
        <trans-unit id="17a3fc955cb5b0276df9b096dfd6ba69365aa9bf" translate="yes" xml:space="preserve">
          <source>Disk-based term storage</source>
          <target state="translated">디스크 기반 용어 저장소</target>
        </trans-unit>
        <trans-unit id="e1031ece5a091584f5140674ba7245074e05f5c1" translate="yes" xml:space="preserve">
          <source>Diskless Node</source>
          <target state="translated">디스크없는 노드</target>
        </trans-unit>
        <trans-unit id="0ec64952288dde39e7db9059f483c43d01b58273" translate="yes" xml:space="preserve">
          <source>Display the full path names of files for which warnings are emitted.</source>
          <target state="translated">경고가 발생하는 파일의 전체 경로 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="407bbaf1e0c2d0df752601703a3d425897a28222" translate="yes" xml:space="preserve">
          <source>Displays a brief help text.</source>
          <target state="translated">간단한 도움말 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="809fd057f19b915d80930c6f7d96f0ece197660c" translate="yes" xml:space="preserve">
          <source>Displays a sequence chart for trace events (messages/actions)</source>
          <target state="translated">추적 이벤트 (메시지 / 작업)에 대한 시퀀스 차트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b4addbd06f3a7b652cedffa28ba11f824f0e54ed" translate="yes" xml:space="preserve">
          <source>Displays help information: all valid shell internal commands, and commands in this module.</source>
          <target state="translated">도움말 정보 : 모든 유효한 쉘 내부 명령 및이 모듈의 명령을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ee3534b5896b26b70a09071e094b09fecc246f93" translate="yes" xml:space="preserve">
          <source>Displays information about &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 에 대한 정보를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="1e2cdacb04ccc59eb03b366e2ce6107106171ce9" translate="yes" xml:space="preserve">
          <source>Displays information about a process, Equivalent to &lt;code&gt;process_info(pid(X, Y, Z))&lt;/code&gt;, but location transparent.</source>
          <target state="translated">&lt;code&gt;process_info(pid(X, Y, Z))&lt;/code&gt; 와 동일하지만 위치가 투명한 프로세스에 대한 정보를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="8676997e6d31e5d1792fc72017136c1969e4743f" translate="yes" xml:space="preserve">
          <source>Displays information about all ETS tables on a terminal.</source>
          <target state="translated">터미널의 모든 ETS 테이블에 대한 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="af76d957f2761590236e17f9749346c28a31a1c0" translate="yes" xml:space="preserve">
          <source>Displays information about all traced processes and ports.</source>
          <target state="translated">추적 된 모든 프로세스 및 포트에 대한 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="492951a4c4a95971c08b9e19f0dc88adebe37075" translate="yes" xml:space="preserve">
          <source>Displays information about the loaded modules, including the files from which they have been loaded.</source>
          <target state="translated">로드 된 파일을 포함하여로드 된 모듈에 대한 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ee93296f3843197e51b182a1bafc98d3a64cbf54" translate="yes" xml:space="preserve">
          <source>Displays more details about the running tests.</source>
          <target state="translated">실행중인 테스트에 대한 자세한 내용을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e0eaa044d1402f6158dbb94e6f37cec632aa9c72" translate="yes" xml:space="preserve">
          <source>Displays online help information.</source>
          <target state="translated">온라인 도움말 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="df72e35e6b1d65a27a8d6d508bdb3a1cdc2b8d9e" translate="yes" xml:space="preserve">
          <source>Displays the back trace of the process, a summary of the current function calls on the stack, in the Trace area. Requires that the Trace area is visible and that the Stack Trace option is &lt;strong&gt;Stack On, Tail&lt;/strong&gt; or &lt;strong&gt;Stack On, No Tail&lt;/strong&gt;.</source>
          <target state="translated">스택의 현재 함수 호출에 대한 요약 인 프로세스의 역 추적을 추적 영역에 표시합니다. 추적 영역이 표시되고 스택 추적 옵션이 &lt;strong&gt;스택 켜짐, 꼬리&lt;/strong&gt; 또는 &lt;strong&gt;스택 켜짐, 꼬리 없음이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b1b1e3477e899e5e51d8015f9d12fef517565150" translate="yes" xml:space="preserve">
          <source>Displays the help message above.</source>
          <target state="translated">위의 도움말 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5e637c32ead50fb05a7176006aa2e317c3d4a119" translate="yes" xml:space="preserve">
          <source>Displays the help of &lt;code&gt;etop&lt;/code&gt; and its options.</source>
          <target state="translated">&lt;code&gt;etop&lt;/code&gt; 및 해당 옵션 의 도움말을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="5a62bffd61747c2b3f643917a2167e1db67450af" translate="yes" xml:space="preserve">
          <source>Displays the manual page for the Erlang module &lt;code&gt;Module&lt;/code&gt;. Only supported on Unix.</source>
          <target state="translated">Erlang 모듈 &lt;code&gt;Module&lt;/code&gt; 의 매뉴얼 페이지를 표시합니다 . 유닉스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5a8997e7d54421e54131f64252ff4df84aeddf01" translate="yes" xml:space="preserve">
          <source>Displays the reports that match the provided filters.</source>
          <target state="translated">제공된 필터와 일치하는 보고서를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7d09436ef1c7f1d4275b15c0e3bfd26a0e52a4a3" translate="yes" xml:space="preserve">
          <source>Dissecting form-urlencoded query strings into a list of key-value pairs</source>
          <target state="translated">양식으로 인코딩 된 쿼리 문자열을 키-값 쌍 목록으로 해부</target>
        </trans-unit>
        <trans-unit id="6639179da9a9db22208ccf1f96fbd66121e3d490" translate="yes" xml:space="preserve">
          <source>Dissects an urlencoded &lt;code&gt;QueryString&lt;/code&gt; and returns a &lt;code&gt;QueryList&lt;/code&gt;, a list of non-percent-encoded key-value pairs. Form-urlencoding is defined in section 4.10.21.6 of the &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; specification and in section 4.10.22.6 of the &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; specification for non-UTF-8 encodings.</source>
          <target state="translated">urlencoded &lt;code&gt;QueryString&lt;/code&gt; 을 분석 하고 백분율로 인코딩되지 않은 키-값 쌍의 목록 인 &lt;code&gt;QueryList&lt;/code&gt; 를 리턴합니다 . Form-urlencoding은 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html52/&quot;&gt;HTML 5.2&lt;/a&gt;&lt;/code&gt; 사양의 4.10.21.6 섹션과 비 UTF-8 인코딩 의 &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/html50/&quot;&gt;HTML 5.0&lt;/a&gt;&lt;/code&gt; 사양 4.10.22.6 섹션에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="357d35fa45410f9789ac601d8a4028142c2abc4b" translate="yes" xml:space="preserve">
          <source>Distinguish between different exception classes.</source>
          <target state="translated">다른 예외 클래스를 구별하십시오.</target>
        </trans-unit>
        <trans-unit id="3154ac05c2e6649bcc819cae0791db7441479164" translate="yes" xml:space="preserve">
          <source>Distinguished Encoding Rules (DER), a specialized form of BER that is used in security-conscious applications</source>
          <target state="translated">보안에 민감한 응용 프로그램에 사용되는 특수화 된 BER 형식 인 DER (Distinguished Encoding Rules)</target>
        </trans-unit>
        <trans-unit id="9f5bcc7ade38e78551b447d80b79861812a69887" translate="yes" xml:space="preserve">
          <source>Distributed Disk Logs</source>
          <target state="translated">분산 디스크 로그</target>
        </trans-unit>
        <trans-unit id="d179b3dee705e502ba9df5acd57b35bada26be1a" translate="yes" xml:space="preserve">
          <source>Distributed Erlang</source>
          <target state="translated">분산 된 Erlang</target>
        </trans-unit>
        <trans-unit id="df5f720cb5c3693e400bc2af610c190506b2e22e" translate="yes" xml:space="preserve">
          <source>Distributed applications are controlled by both the application controller and a distributed application controller process, &lt;code&gt;dist_ac&lt;/code&gt;. Both these processes are part of the Kernel application. Distributed applications are thus specified by configuring the Kernel application, using the following configuration parameter (see also &lt;code&gt;kernel(6)&lt;/code&gt;):</source>
          <target state="translated">분산 애플리케이션은 애플리케이션 컨트롤러 및 분산 애플리케이션 컨트롤러 프로세스 &lt;code&gt;dist_ac&lt;/code&gt; 모두에 의해 제어됩니다 . 이 두 프로세스는 커널 응용 프로그램의 일부입니다. 따라서 분산 응용 프로그램은 다음 구성 매개 변수를 사용하여 커널 응용 프로그램을 구성하여 지정됩니다 ( &lt;code&gt;kernel(6)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="777820c0dccfcaf6763a1dc23065b452f73b88aa" translate="yes" xml:space="preserve">
          <source>Distributed data because of distributed applications</source>
          <target state="translated">분산 응용 프로그램으로 인한 분산 데이터</target>
        </trans-unit>
        <trans-unit id="1058cfc322dd64ad274d9afc48318f15475644a8" translate="yes" xml:space="preserve">
          <source>Distributed message sending, that is, if &lt;code&gt;Expr1&lt;/code&gt; evaluates to a tuple &lt;code&gt;{Name,Node}&lt;/code&gt; (or a pid located at another node), also never fails.</source>
          <target state="translated">분산 메시지 전송, 즉 &lt;code&gt;Expr1&lt;/code&gt; 이 튜플 &lt;code&gt;{Name,Node}&lt;/code&gt; (또는 다른 노드에 위치한 pid)로 평가되는 경우에도 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="646778caa7cd85accfc80935a72b9a69681a64bf" translate="yes" xml:space="preserve">
          <source>Distributed named process groups.</source>
          <target state="translated">분산 명명 된 프로세스 그룹.</target>
        </trans-unit>
        <trans-unit id="fe70fcb303dd369d876e8b04a66fbb3f051957f9" translate="yes" xml:space="preserve">
          <source>Distributed tables</source>
          <target state="translated">분산 테이블</target>
        </trans-unit>
        <trans-unit id="ef3a717afb5526323e5d0fa2e1c8c91f28e31043" translate="yes" xml:space="preserve">
          <source>Distributed test execution control for &lt;code&gt;Common Test&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 대한 분산 테스트 실행 제어 .</target>
        </trans-unit>
        <trans-unit id="f23d56f2b96b77ba15c94f5727ade9fc8a5345f9" translate="yes" xml:space="preserve">
          <source>Distributed test execution control for Common Test.</source>
          <target state="translated">공통 테스트에 대한 분산 테스트 실행 제어</target>
        </trans-unit>
        <trans-unit id="6b1412269556b8a825737e56637796f585ef89c0" translate="yes" xml:space="preserve">
          <source>Distributes the value &lt;code&gt;X&lt;/code&gt; over the unary functions in the list, turning them into nullary test functions. An &lt;code&gt;AbstractTestFun&lt;/code&gt; is like an ordinary test fun, but takes one argument instead of zero - it's basically missing some information before it can be a proper test. In practice, &lt;code&gt;{with, X, [F_1, ..., F_N]}&lt;/code&gt; is equivalent to &lt;code&gt;[fun () -&amp;gt; F_1(X) end, ..., fun () -&amp;gt; F_N(X) end]&lt;/code&gt;. This is particularly useful if your abstract test functions are already implemented as proper functions: &lt;code&gt;{with, FD, [fun filetest_a/1, fun filetest_b/1, fun filetest_c/1]}&lt;/code&gt; is equivalent to &lt;code&gt;[fun () -&amp;gt; filetest_a(FD) end, fun () -&amp;gt; filetest_b(FD) end, fun () -&amp;gt; filetest_c(FD) end]&lt;/code&gt;, but much more compact. See also &lt;code&gt;&lt;a href=&quot;#Fixtures&quot;&gt;Fixtures&lt;/a&gt;&lt;/code&gt;, below.</source>
          <target state="translated">목록의 단항 함수에 &lt;code&gt;X&lt;/code&gt; 값을 분배하여 널 테스트 함수로 바꿉니다. &lt;code&gt;AbstractTestFun&lt;/code&gt; 는 일반 테스트 재미와 비슷하지만 제로 대신 하나 개의 인자를 - 그것은 적절한 테스트 할 수 있습니다 전에 기본적으로 몇 가지 정보를 실종. 실제로 &lt;code&gt;{with, X, [F_1, ..., F_N]}&lt;/code&gt; 은 &lt;code&gt;[fun () -&amp;gt; F_1(X) end, ..., fun () -&amp;gt; F_N(X) end]&lt;/code&gt; . 이것은 추상 테스트 함수가 이미 적절한 함수로 구현 된 경우에 특히 유용합니다. &lt;code&gt;{with, FD, [fun filetest_a/1, fun filetest_b/1, fun filetest_c/1]}&lt;/code&gt; 는 &lt;code&gt;[fun () -&amp;gt; filetest_a(FD) end, fun () -&amp;gt; filetest_b(FD) end, fun () -&amp;gt; filetest_c(FD) end]&lt;/code&gt; , 훨씬 더 간결합니다. 또한보십시오 &lt;code&gt;&lt;a href=&quot;#Fixtures&quot;&gt;Fixtures&lt;/a&gt;&lt;/code&gt; 아래의 비품 .</target>
        </trans-unit>
        <trans-unit id="1d3c457cbe3e35739086346e0a4048653efa42e7" translate="yes" xml:space="preserve">
          <source>Distribution</source>
          <target state="translated">Distribution</target>
        </trans-unit>
        <trans-unit id="1fb2ec77dec0827e6e0ae703f668a7a543d0ca5f" translate="yes" xml:space="preserve">
          <source>Distribution and fault tolerance</source>
          <target state="translated">분배 및 내결함성</target>
        </trans-unit>
        <trans-unit id="c005e1759172af47ea6a2a358db5688f108d75cf" translate="yes" xml:space="preserve">
          <source>Distribution of applications is highly dependent of the global group definitions. It is not recommended that an application is distributed over many global groups, as the registered names can be moved to another global group at failover/takeover. Nothing prevents this to be done, but the application code must then handle the situation.</source>
          <target state="translated">응용 프로그램 배포는 글로벌 그룹 정의에 따라 크게 달라집니다. 페일 오버 / 인계시 등록 된 이름을 다른 글로벌 그룹으로 이동할 수 있으므로 응용 프로그램을 여러 글로벌 그룹에 배포하지 않는 것이 좋습니다. 이 작업을 수행 할 수있는 것은 없지만 응용 프로그램 코드는 상황을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cf125e37f22237a163b399ac03840410729489d" translate="yes" xml:space="preserve">
          <source>Distribution over TLS/SSL, See the &lt;code&gt; Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">TLS / SSL을 통한 &lt;code&gt; Using SSL for Erlang Distribution&lt;/code&gt; , 안전한 분산 노드를 설정하는 방법에 대한 자세한 내용 은 Erlang 배포에 SSL 사용 사용자 가이드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9dfeb8d1362ff3508945cdb79fdb677bffbb7cb3" translate="yes" xml:space="preserve">
          <source>Distribution over TLS/SSL, See the &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; User's Guide for details on how to setup a secure distributed node.</source>
          <target state="translated">TLS / SSL을 통한 배포. 보안 분산 노드를 설정하는 방법에 대한 자세한 내용 &lt;code&gt;Using SSL for Erlang Distribution&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19983b43869ec19057fd09428fe2401294f12747" translate="yes" xml:space="preserve">
          <source>Distribution sequential/parallel</source>
          <target state="translated">순차 / 병렬 분배</target>
        </trans-unit>
        <trans-unit id="22bdf47be3fd0a53ecdf5d6edbde0a2c6b97f0e0" translate="yes" xml:space="preserve">
          <source>Do</source>
          <target state="translated">Do</target>
        </trans-unit>
        <trans-unit id="47613c6fda4292bd08e25bf20eb869bc678389c9" translate="yes" xml:space="preserve">
          <source>Do &lt;strong&gt;not&lt;/strong&gt; declare the &lt;code&gt;driver_entry&lt;/code&gt;&lt;code&gt;const&lt;/code&gt;. This because the emulator must modify the &lt;code&gt;handle&lt;/code&gt; and the &lt;code&gt;handle2&lt;/code&gt; fields. A statically allocated, and &lt;code&gt;const&lt;/code&gt;-declared &lt;code&gt;driver_entry&lt;/code&gt; can be located in read-only memory, which causes the emulator to crash.</source>
          <target state="translated">마십시오 &lt;strong&gt;하지&lt;/strong&gt; 선언 &lt;code&gt;driver_entry&lt;/code&gt; 의 &lt;code&gt;const&lt;/code&gt; . 에뮬레이터가 &lt;code&gt;handle&lt;/code&gt; 및 &lt;code&gt;handle2&lt;/code&gt; 필드를 수정해야하기 때문 입니다. 정적으로 할당되고 &lt;code&gt;const&lt;/code&gt; 로 선언 된 &lt;code&gt;driver_entry&lt;/code&gt; 는 읽기 전용 메모리에 위치 할 수 있으며 이로 인해 에뮬레이터가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="156a410dd8c4aec29054efddcf1aca187e334ab2" translate="yes" xml:space="preserve">
          <source>Do a one-time execution of a remote command over &lt;code&gt;ssh&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ssh&lt;/code&gt; 를 통해 원격 명령을 한 번 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="61182cd5c5652e8bcee439979d35fb7735c6a0ae" translate="yes" xml:space="preserve">
          <source>Do an one-time execution of a remote OS command (&quot;pwd&quot;) over &lt;code&gt;ssh&lt;/code&gt; to the ssh server of the OS at the host &quot;tarlop&quot;:</source>
          <target state="translated">호스트 &quot;tarlop&quot;에있는 OS의 ssh 서버에 대해 &lt;code&gt;ssh&lt;/code&gt; 를 통해 원격 OS 명령 ( &quot;pwd&quot;)을 한 번 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="d221ae72367256bfa0f670f2336dceacee61b0d4" translate="yes" xml:space="preserve">
          <source>Do as follows:</source>
          <target state="translated">다음과 같이하십시오 :</target>
        </trans-unit>
        <trans-unit id="f27b06d07e1966b0b6864e00ebac2e38b9abf992" translate="yes" xml:space="preserve">
          <source>Do not assume that the fastest implementation of a given algorithm on computer architecture X is also the fastest on computer architecture Y.</source>
          <target state="translated">컴퓨터 아키텍처 X에서 주어진 알고리즘의 가장 빠른 구현이 컴퓨터 아키텍처 Y에서 가장 빠르다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="60772b6696dbf4ac12380ab3e94aae181f9d5c26" translate="yes" xml:space="preserve">
          <source>Do not auto-import any functions from &lt;code&gt;erlang&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;erlang&lt;/code&gt; 모듈 에서 기능을 자동으로 가져 오지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="3d5e059893acb8b0449b6d1e96a2752f9bacf037" translate="yes" xml:space="preserve">
          <source>Do not break Hangul (a Korean script) syllable sequences. Hangul characters are of five types: L, V, T, LV, and LVT. An L character can be followed by an L, V, LV, or LVT character. An LV or V character can be followed by a V or T character. An LVT or T character can be followed only by a T character.</source>
          <target state="translated">한글 (한국어 스크립트) 음절 시퀀스를 끊지 마십시오. 한글 문자는 L, V, T, LV 및 LVT의 5 가지 유형입니다. L 문자 뒤에 L, V, LV 또는 LVT 문자가 올 수 있습니다. LV 또는 V 문자 뒤에 V 또는 T 문자가 올 수 있습니다. LVT 또는 T 문자 뒤에는 T 문자 만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="651bee959850d9f68d5849e0d8ebd34b2d42f910" translate="yes" xml:space="preserve">
          <source>Do not call &lt;code&gt;port_call&lt;/code&gt; with an unknown &lt;code&gt;Port&lt;/code&gt; identifier and expect &lt;code&gt;badarg&lt;/code&gt; exception. Any undefined behavior is possible (including node crash) depending on how the port driver interprets the supplied arguments.</source>
          <target state="translated">알 수없는 &lt;code&gt;Port&lt;/code&gt; 식별자로 &lt;code&gt;port_call&lt;/code&gt; 을 호출하지 말고 &lt;code&gt;badarg&lt;/code&gt; 예외를 예상 하십시오 . 포트 드라이버가 제공된 인수를 해석하는 방법에 따라 정의되지 않은 모든 동작 (노드 충돌 포함)이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5c9ced6e360a50fea15816bc67ccef8964b7f8f6" translate="yes" xml:space="preserve">
          <source>Do not call &lt;code&gt;port_control/3&lt;/code&gt; with an unknown &lt;code&gt;Port&lt;/code&gt; identifier and expect &lt;code&gt;badarg&lt;/code&gt; exception. Any undefined behavior is possible (including node crash) depending on how the port driver interprets the supplied arguments.</source>
          <target state="translated">알 수없는 &lt;code&gt;Port&lt;/code&gt; 식별자로 &lt;code&gt;port_control/3&lt;/code&gt; 을 호출하지 말고 &lt;code&gt;badarg&lt;/code&gt; 예외를 예상 하십시오 . 포트 드라이버가 제공된 인수를 해석하는 방법에 따라 정의되지 않은 모든 동작 (노드 충돌 포함)이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b521b45cda7d42ddb8d4e9de9054fb540ecd742d" translate="yes" xml:space="preserve">
          <source>Do not compile (that is, do not produce object code) the generated &lt;code&gt;.erl&lt;/code&gt; file. If this option is omitted, the generated Erlang module is compiled.</source>
          <target state="translated">생성 된 &lt;code&gt;.erl&lt;/code&gt; 파일을 컴파일하지 마십시오 (즉, 오브젝트 코드를 생성하지 마십시오) . 이 옵션을 생략하면 생성 된 Erlang 모듈이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="14f32868df4cab74a92ca7e529102aa97cd5b714" translate="yes" xml:space="preserve">
          <source>Do not confuse item (?R) with condition (R), which tests for recursion. Consider the following pattern, which matches text in angle brackets, allowing for arbitrary nesting. Only digits are allowed in nested brackets (that is, when recursing), while any characters are permitted at the outer level.</source>
          <target state="translated">항목 (? R)을 재귀를 테스트하는 조건 (R)과 혼동하지 마십시오. 꺾쇠 괄호 안의 텍스트와 일치하여 임의의 중첩을 허용하는 다음 패턴을 고려하십시오. 중첩 된 대괄호에는 숫자 만 사용할 수 있으며 (즉, 되풀이 할 때) 문자는 외부 수준에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37e72f477291161d4ca7e88c63da4fba798ca16b" translate="yes" xml:space="preserve">
          <source>Do not confuse this feature with the &lt;code&gt;repeat&lt;/code&gt; property of a test case group. The options described here are used to repeat execution of entire test runs, while the &lt;code&gt;repeat&lt;/code&gt; property of a test case group makes it possible to repeat execution of sets of test cases within a suite. For more information about the latter, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups &lt;/a&gt;&lt;/code&gt; in section Writing Test Suites.</source>
          <target state="translated">이 기능을 테스트 케이스 그룹 의 &lt;code&gt;repeat&lt;/code&gt; 특성 과 혼동하지 마십시오 . 여기에 설명 된 옵션은 전체 테스트 실행을 반복하는 데 사용되는 반면 테스트 케이스 그룹 의 &lt;code&gt;repeat&lt;/code&gt; 속성을 사용하면 스위트 내에서 테스트 케이스 세트를 반복 실행할 수 있습니다. 후자에 대한 자세한 내용은 테스트 스위트 작성 섹션의 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups &lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15b14d23d02c2d810eb7ff4dafcb04db866620a8" translate="yes" xml:space="preserve">
          <source>Do not confuse this feature with the &lt;code&gt;repeat&lt;/code&gt; property of a test case group. The options described here are used to repeat execution of entire test runs, while the &lt;code&gt;repeat&lt;/code&gt; property of a test case group makes it possible to repeat execution of sets of test cases within a suite. For more information about the latter, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; in section Writing Test Suites.</source>
          <target state="translated">이 기능을 테스트 사례 그룹 의 &lt;code&gt;repeat&lt;/code&gt; 속성 과 혼동하지 마십시오 . 여기에 설명 된 옵션은 전체 테스트 실행을 반복하는 데 사용되는 반면 테스트 사례 그룹 의 &lt;code&gt;repeat&lt;/code&gt; 속성을 사용하면 제품군 내에서 테스트 사례 집합을 반복 실행할 수 있습니다. 후자에 대한 자세한 내용은 테스트 스위트 작성 섹션의 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fd5a1472c6fe43a652bdd8bc5aa386723882a15" translate="yes" xml:space="preserve">
          <source>Do not depend on the current working directory for reading and writing data files, as this is not portable. All scratch files are to be written in the &lt;code&gt;priv_dir&lt;/code&gt; and all data files are to be located in &lt;code&gt;data_dir&lt;/code&gt;. Also, the &lt;code&gt;Common Test&lt;/code&gt; server sets the current working directory to the test case log directory at the start of every case.</source>
          <target state="translated">데이터 파일을 읽고 쓰는 현재 작업 디렉토리에 의존하지 마십시오. 이식 가능하지 않습니다. 모든 스크래치 파일은 &lt;code&gt;priv_dir&lt;/code&gt; 에 작성 되고 모든 데이터 파일은 &lt;code&gt;data_dir&lt;/code&gt; 에 있습니다. 또한 &lt;code&gt;Common Test&lt;/code&gt; 서버는 모든 작업 시작시 현재 작업 디렉토리를 테스트 케이스 로그 디렉토리로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7194a989708cb9ceda8cc7192a66b9bda23def2c" translate="yes" xml:space="preserve">
          <source>Do not depend on the scheduling to remain exactly as it is today. Scheduling is likely to be changed in a future release to use available processor cores better.</source>
          <target state="translated">현재 상태 그대로 유지되도록 일정에 의존하지 마십시오. 사용 가능한 프로세서 코어를 더 잘 사용하기 위해 향후 릴리스에서 일정이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f31ff69a8594f7ef57326c9ad5ac44bf992a75" translate="yes" xml:space="preserve">
          <source>Do not disable the Erlang shell while running the GUI.</source>
          <target state="translated">GUI를 실행하는 동안 Erlang 쉘을 비활성화하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9940ce9bb1d237e4d18a0edeb4db476b18a97e5d" translate="yes" xml:space="preserve">
          <source>Do not enable &lt;code&gt;parallel_logins&lt;/code&gt; without protecting the server by other means, for example, by the &lt;code&gt;max_sessions&lt;/code&gt; option or a firewall configuration. If set to &lt;code&gt;true&lt;/code&gt;, there is no protection against DOS attacks.</source>
          <target state="translated">다른 방법 (예 : &lt;code&gt;max_sessions&lt;/code&gt; 옵션 또는 방화벽 구성)으로 서버를 보호하지 않고 &lt;code&gt;parallel_logins&lt;/code&gt; 를 사용하지 마십시오 . &lt;code&gt;true&lt;/code&gt; 로 설정하면 DOS 공격에 대한 보호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c71ebfa08b5476018b372c85a3329c913b294dc2" translate="yes" xml:space="preserve">
          <source>Do not end after prepend characters.</source>
          <target state="translated">접두사 문자 다음에 끝나지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d8c471ab6552051ae9d3261971ab9ca63bf52f14" translate="yes" xml:space="preserve">
          <source>Do not end before extending characters or spacing marks. Characters with the &quot;mark&quot; property always have the &quot;extend&quot; grapheme breaking property.</source>
          <target state="translated">문자 나 간격 표시를 확장하기 전에 끝나지 마십시오. &quot;mark&quot;속성을 가진 문자는 항상 &quot;extend&quot;grapheme breaking 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3c01623e5d9ea8f28b667a75484db29adf450c8b" translate="yes" xml:space="preserve">
          <source>Do not end between CR and LF; otherwise end after any control character.</source>
          <target state="translated">CR과 LF 사이에서 끝나지 마십시오. 그렇지 않으면 제어 문자 다음에 끝납니다.</target>
        </trans-unit>
        <trans-unit id="8d0cf1528511fb26d91115dbca4234d18f655418" translate="yes" xml:space="preserve">
          <source>Do not fetch data that you already have.</source>
          <target state="translated">이미 가지고있는 데이터를 가져 오지 마십시오.</target>
        </trans-unit>
        <trans-unit id="188b0c662f5109429f4e7982a599520d181b7813" translate="yes" xml:space="preserve">
          <source>Do not forget to consider the burst rate. If you set intensity to 1 and period to 6, it gives the same sustained error rate as 5/30 or 10/60, but will not allow even 2 restart attempts in quick succession. This is probably not what you wanted.</source>
          <target state="translated">버스트 속도를 고려해야합니다. 강도를 1로 설정하고주기를 6으로 설정하면 5/30 또는 10/60과 동일한 지속 오류율을 제공하지만 2 번의 재시작 시도도 빠르게 연속 할 수 없습니다. 이것은 아마도 당신이 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cb6ff35f68a8fe238498bd152090f1aefc3c00b3" translate="yes" xml:space="preserve">
          <source>Do not insert line breaks in types, contracts, and Erlang Code when formatting warnings.</source>
          <target state="translated">경고 서식을 지정할 때 유형, 계약 및 Erlang 코드에 줄 바꿈을 삽입하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="78a25e53c1d1a1e9e8efea26b3a8a018a5711c79" translate="yes" xml:space="preserve">
          <source>Do not rely too much on the order of &lt;code&gt;Flag&lt;/code&gt; atoms or &lt;code&gt;Ifopt&lt;/code&gt; tuples. There are however some rules:</source>
          <target state="translated">&lt;code&gt;Flag&lt;/code&gt; 원자 또는 &lt;code&gt;Ifopt&lt;/code&gt; 튜플 순서에 너무 의존하지 마십시오 . 그러나 몇 가지 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5a829acbf86b446537c7e77035b74ae3ff6884" translate="yes" xml:space="preserve">
          <source>Do not rely too much on the order of &lt;code&gt;Flags&lt;/code&gt; atoms or the &lt;code&gt;Ifopt&lt;/code&gt; tuples. There are however some rules:</source>
          <target state="translated">&lt;code&gt;Flags&lt;/code&gt; 원자 또는 &lt;code&gt;Ifopt&lt;/code&gt; 튜플 의 순서에 너무 많이 의존하지 마십시오 . 그러나 몇 가지 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1c9c02fa7973c5d114818811d89f50e2cadfc9c" translate="yes" xml:space="preserve">
          <source>Do not segment outgoing reply messages. This is useful when either it is known that messages are never to large or that the transport protocol can handle such things on its own (e.g. TCP or SCTP).</source>
          <target state="translated">발신 응답 메시지를 분류하지 마십시오. 이것은 메시지가 크지 않다는 것이 알려 지거나 전송 프로토콜이 그러한 것들을 자체적으로 처리 할 수있는 경우에 유용합니다 (예 : TCP 또는 SCTP).</target>
        </trans-unit>
        <trans-unit id="80935dcf9b5a6ea229aecf6d20098f3db3dec414" translate="yes" xml:space="preserve">
          <source>Do not send data to an unknown port. Any undefined behavior is possible (including node crash) depending on how the port driver interprets the data.</source>
          <target state="translated">알 수없는 포트로 데이터를 보내지 마십시오. 포트 드라이버가 데이터를 해석하는 방법에 따라 정의되지 않은 동작 (노드 충돌 포함)이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7d463f746b0b7fd7109b1a49ad6fea1f1a13ac94" translate="yes" xml:space="preserve">
          <source>Do not send messages or issue port commands to the &lt;code&gt;Tracee&lt;/code&gt; in any of the callbacks. This is not allowed and can cause all sorts of strange behavior, including, but not limited to, infinite recursions.</source>
          <target state="translated">콜백에서 메시지를 보내거나 포트 명령을 &lt;code&gt;Tracee&lt;/code&gt; 에 발행하지 마십시오 . 이것은 허용되지 않으며 무한 재귀를 포함한 모든 종류의 이상한 동작을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a73abdea57b18933ecedd87b093ff6419e3300f" translate="yes" xml:space="preserve">
          <source>Do not set the period to a very high value if you want to tolerate bursts. If you set intensity to 5 and period to 3600 (one hour), the supervisor will allow a short burst of 5 restarts, but then gives up if it sees another single restart almost an hour later. You probably want to regard those crashes as separate incidents, so setting the period to 5 or 10 minutes will be more reasonable.</source>
          <target state="translated">버스트를 허용하려면주기를 매우 높은 값으로 설정하지 마십시오. 강도를 5로 설정하고 기간을 3600 (1 시간)으로 설정하면 수퍼바이저는 5 번의 짧은 재시작을 허용하지만 거의 1 시간 후에 또 다른 단일 재시작이 발생하면 포기합니다. 이러한 충돌을 별도의 사고로 간주 할 수 있으므로 기간을 5 분 또는 10 분으로 설정하는 것이 더 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="b65301fb79ef8b7b35e60f636541eaf5d9009d6f" translate="yes" xml:space="preserve">
          <source>Do not tamper with the socket options &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;active&lt;/code&gt;, &lt;code&gt;packet&lt;/code&gt;, &lt;code&gt;nodelay&lt;/code&gt; and &lt;code&gt;deliver&lt;/code&gt; since they are used by the distribution protocol handler itself. Other raw socket options such as &lt;code&gt;packet_size&lt;/code&gt; may interfere severely, so beware!</source>
          <target state="translated">소켓 옵션 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;binary&lt;/code&gt; , &lt;code&gt;active&lt;/code&gt; , &lt;code&gt;packet&lt;/code&gt; , &lt;code&gt;nodelay&lt;/code&gt; 및 배급 프로토콜 처리기 자체에서 사용 &lt;code&gt;deliver&lt;/code&gt; 때문에 전달 하지 마십시오 . &lt;code&gt;packet_size&lt;/code&gt; 와 같은 다른 원시 소켓 옵션 은 심각하게 간섭 할 수 있으므로주의하십시오!</target>
        </trans-unit>
        <trans-unit id="d8589c5d62b43bc732186af17da7031d4ee16b0e" translate="yes" xml:space="preserve">
          <source>Do not try to work around these problems by using alternative implementations of the missing algorithms! An application can only claim to be using a FIPS 140-2 validated cryptographic module if it uses it exclusively for every cryptographic operation.</source>
          <target state="translated">누락 된 알고리즘의 대체 구현을 사용하여 이러한 문제점을 해결하려고 시도하지 마십시오! 응용 프로그램이 모든 암호화 작업에 독점적으로 사용하는 경우 FIPS 140-2 인증 암호화 모듈 만 사용한다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5651954dc46885391a1490aca0bd0b8cd7aaad8" translate="yes" xml:space="preserve">
          <source>Do not use a &lt;code&gt;Context&lt;/code&gt; as argument in more than one call to hmac_update or hmac_final. The semantics of reusing old contexts in any way is undefined and could even crash the VM in earlier releases. The reason for this limitation is a lack of support in the underlying OpenSSL API.</source>
          <target state="translated">hmac_update 또는 hmac_final을 두 번 이상 호출 할 때 &lt;code&gt;Context&lt;/code&gt; 를 인수로 사용하지 마십시오 . 어떤 식 으로든 이전 컨텍스트를 재사용하는 의미는 정의되어 있지 않으며 이전 릴리스에서는 VM을 손상시킬 수도 있습니다. 이 제한의 이유는 기본 OpenSSL API에서 지원이 부족하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f5aebc45ba913c9940dd21c63300e4d022b07a05" translate="yes" xml:space="preserve">
          <source>Do not use a &lt;code&gt;Context&lt;/code&gt; as argument in more than one call to hmac_update or hmac_final. The semantics of reusing old contexts in any way is undefined and could even crash the VM in earlier releases. The reason for this limitation is a lack of support in the underlying libcrypto API.</source>
          <target state="translated">hmac_update 또는 hmac_final에 대한 둘 이상의 호출에서 &lt;code&gt;Context&lt;/code&gt; 를 인수로 사용하지 마십시오 . 어떤 방식 으로든 이전 컨텍스트를 재사용하는 의미는 정의되지 않았으며 이전 릴리스에서는 VM이 ​​충돌 할 수도 있습니다. 이 제한의 이유는 기본 libcrypto API에서 지원이 부족하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="71cc879e1a9b34f9f8f3f275c6f8a0b14927f088" translate="yes" xml:space="preserve">
          <source>Do not use any of the keys in these examples. Use your own keys.</source>
          <target state="translated">이 예제에서는 키를 사용하지 마십시오. 자신의 키를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e3d2471e72d9c62935331dbceb31a316086f28e" translate="yes" xml:space="preserve">
          <source>Do not use atom cache over this connection.</source>
          <target state="translated">이 연결을 통해 아톰 캐시를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="25bba2adbeee67303d12a8d397918f4ee984e826" translate="yes" xml:space="preserve">
          <source>Do not use the &lt;code&gt;&lt;a href=&quot;#compile_server&quot;&gt;compile server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#compile_server&quot;&gt;compile server&lt;/a&gt;&lt;/code&gt; 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="1356865819ece0e9984d524eb4ee4ec65b6f89d1" translate="yes" xml:space="preserve">
          <source>Do recover from a testcase failure using CTHs only a last resort. If used wrongly, it can be very difficult to determine which tests that pass or fail in a test run.</source>
          <target state="translated">최후의 수단으로 CTH를 사용하여 테스트 케이스 실패에서 복구하십시오. 잘못 사용하면 테스트 실행에서 통과하거나 실패한 테스트를 결정하기가 매우 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c7dd7ef6767859363ae1932a37452672de1454" translate="yes" xml:space="preserve">
          <source>Do something like this:</source>
          <target state="translated">다음과 같이하십시오 :</target>
        </trans-unit>
        <trans-unit id="038970f21cbb8e0488428da90f3fabf1886c4212" translate="yes" xml:space="preserve">
          <source>Do the following:</source>
          <target state="translated">다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a21d03cec610102299b9a7e2e16ecfa597e7dd26" translate="yes" xml:space="preserve">
          <source>Do this on the command line or add the flags to the &lt;code&gt;LDFLAGS&lt;/code&gt; definition in your &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">명령 행 에서이를 수행하거나 &lt;code&gt;Makefile&lt;/code&gt; 의 &lt;code&gt;LDFLAGS&lt;/code&gt; 정의에 플래그를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a47ab2b6ee02bee6a7cd7e90891dab0064937d7b" translate="yes" xml:space="preserve">
          <source>DoS (Denial of Service) attacks are hard to fight at the node level. Here are firewalls and other means needed, but that is out of scope for this guide. However, some measures could be taken in the configuration of the SSH server to increase the resilence. The options to use are:</source>
          <target state="translated">DoS (Denial of Service) 공격은 노드 수준에서 싸우기 어렵습니다. 다음은 방화벽 및 기타 필요한 수단이지만이 가이드에서는 다루지 않습니다. 그러나 복원력을 높이기 위해 SSH 서버의 구성에서 몇 가지 조치를 취할 수 있습니다. 사용할 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70b871cacc7e26cab738e21fdfbb99e29543867f" translate="yes" xml:space="preserve">
          <source>Documents can be joined into a single new document using the constructor functions of this module. Note that the new document often represents a larger number of possible layouts than just the sum of the components.</source>
          <target state="translated">이 모듈의 생성자 함수를 사용하여 문서를 하나의 새 문서로 결합 할 수 있습니다. 새 문서는 종종 구성 요소의 합보다 많은 레이아웃을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95accc1330c740146e565879f30ee3adeae7d539" translate="yes" xml:space="preserve">
          <source>Does a combined map/fold operation on the nodes of the tree. It begins by calling &lt;code&gt;Pre&lt;/code&gt; on the tree, using the &lt;code&gt;Initial&lt;/code&gt; value. It then deconstructs the top node of the returned tree and recurses on the children, using the returned value as the new initial and carrying the returned values from one call to the next. Finally it reassembles the top node from the children, calls &lt;code&gt;Post&lt;/code&gt; on it and returns the result.</source>
          <target state="translated">트리의 노드에서 결합 된 맵 / 폴드 작업을 수행합니다. &lt;code&gt;Initial&lt;/code&gt; 값을 사용하여 트리에서 &lt;code&gt;Pre&lt;/code&gt; 를 호출하여 시작됩니다 . 그런 다음 반환 된 트리의 최상위 노드를 분해하고 반환 된 값을 새 이니셜로 사용하고 한 호출에서 다음 호출로 반환 된 값을 전달하여 자식에서 반복합니다. 마지막으로 자식에서 최상위 노드를 재 조립하고 &lt;code&gt;Post&lt;/code&gt; 를 호출 하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8fa79c867895a507674579a9fc26baed8ad72e50" translate="yes" xml:space="preserve">
          <source>Does a combined map/fold operation on the nodes of the tree. This is similar to &lt;code&gt;map/2&lt;/code&gt;, but also propagates a value from each application of &lt;code&gt;Function&lt;/code&gt; to the next, starting with the given value &lt;code&gt;Initial&lt;/code&gt;, while doing a post-order traversal of the tree, much like &lt;code&gt;fold/3&lt;/code&gt;.</source>
          <target state="translated">트리의 노드에서 결합 된 맵 / 폴드 작업을 수행합니다. 이것은 &lt;code&gt;map/2&lt;/code&gt; 와 유사 하지만 &lt;code&gt;fold/3&lt;/code&gt; 과 같이 트리의 사후 순회를 수행하면서 주어진 값 &lt;code&gt;Initial&lt;/code&gt; 로 시작하여 &lt;code&gt;Function&lt;/code&gt; 의 각 응용 프로그램 에서 다음 값으로 값을 전파합니다 .</target>
        </trans-unit>
        <trans-unit id="7f98f19de9abb11350f639509d2fefdec19472e9" translate="yes" xml:space="preserve">
          <source>Does a fold operation over the nodes of the tree. The result is the value of &lt;code&gt;Function(X1, Function(X2, ... Function(Xn, Unit) ... ))&lt;/code&gt;, where &lt;code&gt;X1, ..., Xn&lt;/code&gt; are the nodes of &lt;code&gt;Tree&lt;/code&gt; in a post-order traversal.</source>
          <target state="translated">트리의 노드에 대해 접기 작업을 수행합니다. 결과는 &lt;code&gt;Function(X1, Function(X2, ... Function(Xn, Unit) ... ))&lt;/code&gt; . 여기서 &lt;code&gt;X1, ..., Xn&lt;/code&gt; 은 주문 후 순회에서 &lt;code&gt;Tree&lt;/code&gt; 의 노드입니다 .</target>
        </trans-unit>
        <trans-unit id="b1cfa809f5e0beeb3084719dfa48bc7be279ead2" translate="yes" xml:space="preserve">
          <source>Does a mapfold operation over the immediate subtrees of a syntax tree. This is similar to &lt;code&gt;mapfold/3&lt;/code&gt;, but only on the immediate subtrees of &lt;code&gt;Tree&lt;/code&gt;, in left-to-right order; it does not include the root node of &lt;code&gt;Tree&lt;/code&gt;.</source>
          <target state="translated">구문 트리의 바로 하위 트리에 대해 맵 폴딩 작업을 수행합니다. 이것은 &lt;code&gt;mapfold/3&lt;/code&gt; 와 비슷 하지만 &lt;code&gt;Tree&lt;/code&gt; 의 직계 하위 트리에서만 왼쪽에서 오른쪽으로; &lt;code&gt;Tree&lt;/code&gt; 의 루트 노드는 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7c7eea79bea4b2b9cde4e71269ff5f714a49433e" translate="yes" xml:space="preserve">
          <source>Does any calculated expression give the same result each time?</source>
          <target state="translated">계산 된 표현식이 매번 동일한 결과를 제공합니까?</target>
        </trans-unit>
        <trans-unit id="bba1dfbc290a2c0b8836c89e393aabd52f91892a" translate="yes" xml:space="preserve">
          <source>Does the IO polling for the emulator. See &lt;code&gt;erl +IOt&lt;/code&gt; for more details.</source>
          <target state="translated">에뮬레이터의 IO 폴링을 수행합니다. 자세한 내용은 &lt;code&gt;erl +IOt&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7bb0a8f4f91e9cee2cc8f3782dde3817b9d0995c" translate="yes" xml:space="preserve">
          <source>Does the same as &lt;code&gt;compile/1,2&lt;/code&gt;, but uses an existing &lt;code&gt;.beam&lt;/code&gt; file as base, i.e. the module is not compiled from source. Thus &lt;code&gt;compile_beam/1&lt;/code&gt; is faster than &lt;code&gt;compile/1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compile/1,2&lt;/code&gt; 와 동일 하지만 기존 &lt;code&gt;.beam&lt;/code&gt; 파일을 기본으로 사용합니다. 즉, 모듈이 소스에서 컴파일되지 않습니다. 따라서 &lt;code&gt;compile_beam/1&lt;/code&gt; 은 &lt;code&gt;compile/1,2&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="75b2ead98f7bae72a0d0db8e893db529be8b23f3" translate="yes" xml:space="preserve">
          <source>Does this mean that 3 is in inches? Or does it mean that 3 is in centimeters and is to be converted to inches? Erlang has a way to group things together to make things more understandable. These are called &lt;strong&gt;tuples&lt;/strong&gt; and are surrounded by curly brackets, &quot;{&quot; and &quot;}&quot;.</source>
          <target state="translated">이것은 3이 인치라는 것을 의미합니까? 아니면 3이 센티미터이고 인치로 변환된다는 의미입니까? Erlang은 사물을 더 이해하기 쉽도록 그룹화 할 수 있습니다. 이것을 &lt;strong&gt;튜플&lt;/strong&gt; 이라고 하며 중괄호 &quot;{&quot;및 &quot;}&quot;로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="6ed065e8e03cc0ab27b9fb8825a8074464256599" translate="yes" xml:space="preserve">
          <source>Doing &lt;code&gt;./otp_build save_bootstrap&lt;/code&gt; from the &lt;code&gt;$ERL_TOP&lt;/code&gt; directory before doing &lt;code&gt;make clean&lt;/code&gt; will ensure that it will be possible to build after doing &lt;code&gt;make clean&lt;/code&gt;. &lt;code&gt;./otp_build save_bootstrap&lt;/code&gt; will be invoked automatically when &lt;code&gt;make&lt;/code&gt; is invoked from &lt;code&gt;$ERL_TOP&lt;/code&gt; with either the &lt;code&gt;clean&lt;/code&gt; target, or the default target. It is also automatically invoked if &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; is invoked.</source>
          <target state="translated">이렇게 &lt;code&gt;./otp_build save_bootstrap&lt;/code&gt; 를 으로부터 &lt;code&gt;$ERL_TOP&lt;/code&gt; 수행하기 전에 디렉토리 &lt;code&gt;make clean&lt;/code&gt; 이 수행 한 후 빌드 할 수있을 것이라는 점을 보장한다 &lt;code&gt;make clean&lt;/code&gt; . &lt;code&gt;./otp_build save_bootstrap&lt;/code&gt; 이 때 자동으로 호출됩니다 &lt;code&gt;make&lt;/code&gt; 에서 호출 &lt;code&gt;$ERL_TOP&lt;/code&gt; 중 하나와 &lt;code&gt;clean&lt;/code&gt; 대상 또는 기본 대상입니다. &lt;code&gt;./otp_build remove_prebuilt_files&lt;/code&gt; 가 호출 되면 자동으로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="d5095e2d590b30dd7a9838e94c8dcfb9378c175e" translate="yes" xml:space="preserve">
          <source>Doing &lt;code&gt;make clean&lt;/code&gt; in an arbitrary directory of the source tree, may remove files needed for bootstrapping the build.</source>
          <target state="translated">소스 트리의 임의의 디렉토리에서 &lt;code&gt;make clean&lt;/code&gt; 하면 빌드 부트 스트랩에 필요한 파일이 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ce2e932ba7981e63888adfbaf825292b137d8d5" translate="yes" xml:space="preserve">
          <source>Doing it this way we will get a communication pattern of information going from the leader thread out to all other managed threads and then back from the other threads to the leader thread. This since only the leader thread will write to the global counter and all other threads will only read it, and since each confirmation cache lines will only be written by one specific thread and only read by the leader thread. When each managed thread is distributed over different processors, the communication between processors will be a reflection of this communication pattern between threads.</source>
          <target state="translated">이렇게하면 리더 스레드에서 다른 모든 관리 스레드로 이동 한 다음 다른 스레드에서 리더 스레드로 돌아가는 정보의 통신 패턴을 얻을 수 있습니다. 리더 스레드 만 글로벌 카운터에 쓰고 다른 모든 스레드는 읽기만하기 때문에 각 확인 캐시 라인은 하나의 특정 스레드에 의해서만 쓰여지고 리더 스레드에 의해서만 읽혀지기 때문입니다. 각 관리 스레드가 서로 다른 프로세서에 분산 될 때 프로세서 간의 통신은 스레드 간의이 통신 패턴을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="7bc2ad929348c83942c5653f9bd9442fa893930a" translate="yes" xml:space="preserve">
          <source>Doing it this way we will preserve the low latency at the expense of lost potential parallel execution of the signal and other code in the process sending the signal. This default behaviour can however be changed on port basis or system wide, forcing scheduling of all signals from processes to ports that are not part of a synchronous communication. That is, an unconditional request/response pair of asynchronous signals. In this case it is no potential for parallelism, and by that no point forcing scheduling of the request signal.</source>
          <target state="translated">이렇게하면 신호를 보내는 프로세스에서 신호 및 기타 코드의 잠재적 병렬 실행이 손실되는 대신 낮은 지연 시간을 유지할 수 있습니다. 그러나이 기본 동작은 포트 기반 또는 시스템 전체에서 변경 될 수 있으므로 프로세스에서 동기 통신의 일부가 아닌 포트로 모든 신호를 예약해야합니다. 즉, 비동기 신호의 무조건 요청 / 응답 쌍입니다. 이 경우 병렬 처리 가능성이 없으며 요청 신호의 스케줄링을 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c13571de66cf331de3075eb6e61e83544211de9" translate="yes" xml:space="preserve">
          <source>Doing too much work in each NIF call will &lt;code&gt;degrade responsiveness of the VM&lt;/code&gt;. Doing too little work may mean that the gain of the faster processing in the NIF is eaten up by the overhead of calling the NIF and checking the arguments.</source>
          <target state="translated">각 NIF 호출에서 너무 많은 작업을 수행하면 &lt;code&gt;degrade responsiveness of the VM&lt;/code&gt; 이 저하 됩니다 . 너무 적은 작업을 수행한다는 것은 NIF를 호출하고 인수를 확인하는 오버 헤드로 인해 NIF에서 더 빠른 처리의 이점을 얻었음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3e8da48850a3c1cd0e52b36112de4478075ac8" translate="yes" xml:space="preserve">
          <source>Doing, for example, a &lt;code&gt;file:list_dir/1&lt;/code&gt; on one of these systems can return Unicode lists with code points &amp;gt; 255, depending on the content of the file system.</source>
          <target state="translated">예를 들어, 이러한 시스템 중 하나 에서 &lt;code&gt;file:list_dir/1&lt;/code&gt; 을 수행하면 파일 시스템의 내용에 따라 코드 포인트가&amp;gt; 255 인 유니 코드 목록을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f88a9bb9f4ec699c8ec64acf057a2ef9a2bf7c" translate="yes" xml:space="preserve">
          <source>Domain name</source>
          <target state="translated">도메인 이름</target>
        </trans-unit>
        <trans-unit id="a0d641b3f1afe93a0323a0128a013778c7d8ae93" translate="yes" xml:space="preserve">
          <source>Domains</source>
          <target state="translated">Domains</target>
        </trans-unit>
        <trans-unit id="a3f7119b88e739226568a8bca00099c4a3fd6f89" translate="yes" xml:space="preserve">
          <source>Domains are used to specify which subsystem a certain log event originates from. The default handler will by default only log events with the domain &lt;code&gt;[otp]&lt;/code&gt; or without a domain. If you would like to include SSL log events into the default handler log you could do this:</source>
          <target state="translated">도메인은 특정 로그 이벤트가 발생하는 하위 시스템을 지정하는 데 사용됩니다. 기본 처리기는 기본적으로 도메인 &lt;code&gt;[otp]&lt;/code&gt; 또는 도메인없이 이벤트 만 기록 합니다. SSL 로그 이벤트를 기본 핸들러 로그에 포함하려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfed24b7dd9052ba2e02af6212f78e990e171c40" translate="yes" xml:space="preserve">
          <source>Don't</source>
          <target state="translated">Don't</target>
        </trans-unit>
        <trans-unit id="630fe2c2ec0f26d7c7ab82e064c7272e10c58466" translate="yes" xml:space="preserve">
          <source>Don't trace the &lt;code&gt;user&lt;/code&gt; process if using the default trace handler function.</source>
          <target state="translated">기본 추적 핸들러 기능을 사용하는 경우 &lt;code&gt;user&lt;/code&gt; 프로세스를 추적하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="d72584f09d299f253db50d82b0ad0f89ba8e4dfc" translate="yes" xml:space="preserve">
          <source>Don't trace the group leader of the tracer process. If tracing has been switched on for all processes, call &lt;code&gt;dbg:p(TracerGLPid,clear)&lt;/code&gt; to stop tracing the group leader (&lt;code&gt;TracerGLPid&lt;/code&gt;). &lt;code&gt;process_info(TracerPid,group_leader)&lt;/code&gt; tells you which process this is (&lt;code&gt;TracerPid&lt;/code&gt; is returned from &lt;code&gt;dbg:get_tracer/0&lt;/code&gt;).</source>
          <target state="translated">추적 프로그램 프로세스의 그룹 리더를 추적하지 마십시오. 모든 프로세스에 대해 추적이 설정된 경우 &lt;code&gt;dbg:p(TracerGLPid,clear)&lt;/code&gt; 를 호출 하여 그룹 리더 ( &lt;code&gt;TracerGLPid&lt;/code&gt; ) 추적을 중지하십시오 . &lt;code&gt;process_info(TracerPid,group_leader)&lt;/code&gt; 는 이것이 어떤 프로세스인지 알려줍니다 ( &lt;code&gt;TracerPid&lt;/code&gt; 는 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; 에서 반환됩니다 ).</target>
        </trans-unit>
        <trans-unit id="054d20e29b31a7dc242eecac1da33a510fa0468c" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;&lt;a href=&quot;crypto#mac-3&quot;&gt;mac/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;crypto#macN-4&quot;&gt;macN/4&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! 사용 &lt;code&gt;&lt;a href=&quot;crypto#mac-3&quot;&gt;mac/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;crypto#macN-4&quot;&gt;macN/4&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;the new api&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ba45b217c72f3f75416d0775d28dd10e48873a" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;&lt;a href=&quot;crypto#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;crypto#macN-5&quot;&gt;macN/5&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! 사용 &lt;code&gt;&lt;a href=&quot;crypto#mac-4&quot;&gt;mac/4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;crypto#macN-5&quot;&gt;macN/5&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;the new api&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b547dd5eb8a9ab71774df482eaf9a63b99216e9" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;&lt;a href=&quot;crypto#mac_final-1&quot;&gt;mac_final/1&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! &lt;code&gt;the new api&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;crypto#mac_final-1&quot;&gt;mac_final/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3c1eb5c704da26324afa628da4101d147e12985" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;&lt;a href=&quot;crypto#mac_finalN-2&quot;&gt;mac_finalN/2&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! 사용 &lt;code&gt;&lt;a href=&quot;crypto#mac_finalN-2&quot;&gt;mac_finalN/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;the new api&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4bf31835f16c522a03db912ad57fda743aa9ac" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;&lt;a href=&quot;crypto#mac_init-3&quot;&gt;mac_init/3&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! 사용 &lt;code&gt;&lt;a href=&quot;crypto#mac_init-3&quot;&gt;mac_init/3&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;the new api&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0d36416c033d36d114a19002281936f351061e7" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;&lt;a href=&quot;crypto#mac_update-2&quot;&gt;mac_update/2&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! 사용 &lt;code&gt;&lt;a href=&quot;crypto#mac_update-2&quot;&gt;mac_update/2&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;the new api&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e0ca68b6e317c3f3073a2a5d354b33b114b9e8" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;supports/1&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! &lt;code&gt;the new api&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;supports/1&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="93f156c9d5846e41687691e96e6feaa98351982e" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;the new api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! &lt;code&gt;the new api&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="556496238ed71dda06d56a97bfeabfb740671257" translate="yes" xml:space="preserve">
          <source>Don't use this function for new programs! Use &lt;code&gt;the-new-api&lt;/code&gt;.</source>
          <target state="translated">새 프로그램에이 기능을 사용하지 마십시오! &lt;code&gt;the-new-api&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a383c2a1d1bc03092c280bce505afe5bc0da6bba" translate="yes" xml:space="preserve">
          <source>Double UTF-8 Encoding</source>
          <target state="translated">이중 UTF-8 인코딩</target>
        </trans-unit>
        <trans-unit id="3ecae28cccab7ebddc79205dd193d3992e39be12" translate="yes" xml:space="preserve">
          <source>Double click on a module to launch its module window.</source>
          <target state="translated">모듈을 두 번 클릭하여 모듈 창을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="524d6b5e2eb391c06d7d662842ea304a3428ac3a" translate="yes" xml:space="preserve">
          <source>Double click on an application name to launch an application window.</source>
          <target state="translated">응용 프로그램 이름을 두 번 클릭하여 응용 프로그램 창을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="717495e0494703ed6df39cf7df4eec3540f9699b" translate="yes" xml:space="preserve">
          <source>Double click on an application to launch its application window.</source>
          <target state="translated">응용 프로그램을 두 번 클릭하여 응용 프로그램 창을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="e3ef104fbe6551b62e8dd5aed2698114cc2960eb" translate="yes" xml:space="preserve">
          <source>Double click on an module name to launch a module window.</source>
          <target state="translated">모듈 이름을 두 번 클릭하여 모듈 창을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c9ca655edf4df9beaad28b4f1e93729b97bd7328" translate="yes" xml:space="preserve">
          <source>Double quote</source>
          <target state="translated">큰 따옴표</target>
        </trans-unit>
        <trans-unit id="03b4a91fa37fa8f5be07f6954e031f5c6ab94101" translate="yes" xml:space="preserve">
          <source>Double-click to view the table content, or right-click and select option &lt;strong&gt;Show Table Content&lt;/strong&gt;. To view table information, select the table and activate menu &lt;strong&gt;View &amp;gt; Table information&lt;/strong&gt;, or right-click and select option &lt;strong&gt;Table info&lt;/strong&gt;.</source>
          <target state="translated">테이블 컨텐츠를 두 번 클릭하여 보거나 마우스 오른쪽 단추를 클릭하고 &lt;strong&gt;테이블 컨텐츠 표시&lt;/strong&gt; 옵션을 선택하십시오 . 테이블 정보를 보려면 테이블을 선택하고 메뉴 &lt;strong&gt;보기&amp;gt; 테이블 정보를&lt;/strong&gt; 활성화 하거나 마우스 오른쪽 단추를 클릭하고 &lt;strong&gt;테이블 정보&lt;/strong&gt; 옵션을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5ea8d16867528d169d37b0acf9151c1e9bd53c9" translate="yes" xml:space="preserve">
          <source>Double-clicking a module brings up the View Module window.</source>
          <target state="translated">모듈을 두 번 클릭하면 모듈보기 창이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bc28dc5bddbb75b67327c00dba2ea708871fd1af" translate="yes" xml:space="preserve">
          <source>Double-clicking a row in the &lt;strong&gt;Funs&lt;/strong&gt; tab has no effect.</source>
          <target state="translated">&lt;strong&gt;기능&lt;/strong&gt; 탭 에서 행을 두 번 클릭 &lt;strong&gt;해도&lt;/strong&gt; 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="32db7d6a7602f3bd7441157fad4ae41131e6d87d" translate="yes" xml:space="preserve">
          <source>Double-clicking a row in the &lt;strong&gt;Timers&lt;/strong&gt; tab has no effect.</source>
          <target state="translated">&lt;strong&gt;타이머&lt;/strong&gt; 탭 에서 행을 두 번 클릭해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="124373b861cdaa55ee48064bb5c358db179e8021" translate="yes" xml:space="preserve">
          <source>Downgrades an application &lt;code&gt;App&lt;/code&gt; from the current version to a previous version &lt;code&gt;OldVsn&lt;/code&gt; located in &lt;code&gt;Dir&lt;/code&gt; according to the &lt;code&gt;.appup&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; 파일 에 따라 응용 프로그램 &lt;code&gt;App&lt;/code&gt; 을 현재 버전 에서 &lt;code&gt;Dir&lt;/code&gt; 에 있는 이전 버전 &lt;code&gt;OldVsn&lt;/code&gt; 으로 다운 그레이드 합니다.</target>
        </trans-unit>
        <trans-unit id="700c1cf0a5db3e391a57da8114050240b46bbc58" translate="yes" xml:space="preserve">
          <source>Download and run the installer from: URL: &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">URL : &lt;code&gt;&lt;a href=&quot;http://nsis.sourceforge.net/download&quot;&gt;http://nsis.sourceforge.net/download&lt;/a&gt;&lt;/code&gt; 에서 설치 프로그램을 다운로드하여 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="213b68c824beb73900e74352c19c9f193673f2e0" translate="yes" xml:space="preserve">
          <source>Download from &lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/wxwindows/files/3.0.0/&quot;&gt;http://sourceforge.net/projects/wxwindows/files/3.0.0/&lt;/a&gt;&lt;/code&gt; or get it from GitHub: &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets&quot;&gt;https://github.com/wxWidgets/wxWidgets&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://sourceforge.net/projects/wxwindows/files/3.0.0/&quot;&gt;http://sourceforge.net/projects/wxwindows/files/3.0.0/&lt;/a&gt;&lt;/code&gt; 에서 다운로드 하거나 GitHub 에서 다운로드 하십시오 : &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets&quot;&gt;https://github.com/wxWidgets/wxWidgets&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8386933fe8a4856441fadd580fff299db5a4ba8b" translate="yes" xml:space="preserve">
          <source>Download from &lt;code&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads&lt;/a&gt;&lt;/code&gt;. We have also tested with IBM's JDK 1.6.0.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads&lt;/a&gt;&lt;/code&gt; 에서 다운로드 하십시오 . 또한 IBM의 JDK 1.6.0으로 테스트했습니다.</target>
        </trans-unit>
        <trans-unit id="a9768700bae7b9637335b2ee2dad1a46acc972fd" translate="yes" xml:space="preserve">
          <source>Driver binaries are created with &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">드라이버 바이너리는 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b39a8d218c5ca3f8fc57bb3b20d659b2903e3cd" translate="yes" xml:space="preserve">
          <source>Driver binaries are created with &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">드라이버 바이너리는 &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2925af43f193d05bd9c132c6b819683491e75cf" translate="yes" xml:space="preserve">
          <source>Driver binaries are used in the &lt;code&gt;driver_output2&lt;/code&gt; and &lt;code&gt;driver_outputv&lt;/code&gt; calls, and in the queue. Also the driver callback &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt; outputv&lt;/a&gt;&lt;/code&gt; uses driver binaries.</source>
          <target state="translated">드라이버 바이너리는 &lt;code&gt;driver_output2&lt;/code&gt; 및 &lt;code&gt;driver_outputv&lt;/code&gt; 호출과 대기열에서 사용됩니다. 또한 드라이버 콜백 &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt; outputv&lt;/a&gt;&lt;/code&gt; 는 드라이버 바이너리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="226324127bebbb68d2978adef667b4d99ce22ea6" translate="yes" xml:space="preserve">
          <source>Driver binaries are used in the &lt;code&gt;driver_output2&lt;/code&gt; and &lt;code&gt;driver_outputv&lt;/code&gt; calls, and in the queue. Also the driver callback &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; uses driver binaries.</source>
          <target state="translated">드라이버 바이너리는 &lt;code&gt;driver_output2&lt;/code&gt; 및 &lt;code&gt;driver_outputv&lt;/code&gt; 호출과 큐에서 사용됩니다. 또한 드라이버 콜백 &lt;code&gt;&lt;a href=&quot;driver_entry#outputv&quot;&gt;outputv&lt;/a&gt;&lt;/code&gt; 는 드라이버 바이너리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="124a28d8951fffb18c027deaea920077ee90b6a5" translate="yes" xml:space="preserve">
          <source>Driver callback &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; now gets &lt;code&gt;ErlDrvSizeT&lt;/code&gt; as 4th and 6th arguments instead of previously &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">드라이버 콜백 &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 이제 이전의 &lt;code&gt;int&lt;/code&gt; 대신 4 번째 및 6 번째 인수로 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="d01a22bd67104135a24eaf6baba00db329c9e8ca" translate="yes" xml:space="preserve">
          <source>Driver callback &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; now gets &lt;code&gt;ErlDrvSizeT&lt;/code&gt; as 4th and 6th arguments instead of previously &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">드라이버 콜백 &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 이제 이전의 &lt;code&gt;int&lt;/code&gt; 대신 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 를 4 번째 및 6 번째 인수로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="1ecab8b8577923531622a9e5fde5fb02223fdfd2" translate="yes" xml:space="preserve">
          <source>Driver callback &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; now gets &lt;code&gt;ErlDrvSizeT&lt;/code&gt; as 3rd argument instead of previously &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">드라이버 콜백 &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; 이제 이전의 &lt;code&gt;int&lt;/code&gt; 대신 세 번째 인수로 &lt;code&gt;ErlDrvSizeT&lt;/code&gt; 를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="114ae7f217d84b109210122fb59fad19e5bf87ab" translate="yes" xml:space="preserve">
          <source>Driver entries added by the &lt;code&gt;erl_ddll&lt;/code&gt; Erlang interface cannot be removed by using this interface.</source>
          <target state="translated">&lt;code&gt;erl_ddll&lt;/code&gt; Erlang 인터페이스 에서 추가 한 드라이버 항목은 이 인터페이스를 사용하여 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82d2f62d7632df80ba77337f6c50bfc5274b667e" translate="yes" xml:space="preserve">
          <source>Driver reload is already requested by another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; when option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; was specified.</source>
          <target state="translated">옵션 &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; 이 지정된 경우 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 이미 드라이버 다시로드를 요청했습니다 .</target>
        </trans-unit>
        <trans-unit id="7e9c5911b425f5ebbb8cd801d9119d40f84c087f" translate="yes" xml:space="preserve">
          <source>Drivers in General</source>
          <target state="translated">일반적인 드라이버</target>
        </trans-unit>
        <trans-unit id="bdb0405c87a9568c87483f079e1ba66cba5e95d4" translate="yes" xml:space="preserve">
          <source>Drops elements &lt;code&gt;Elem&lt;/code&gt; from &lt;code&gt;List1&lt;/code&gt; while &lt;code&gt;Pred(Elem)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; and returns the remaining list.</source>
          <target state="translated">&lt;code&gt;Pred(Elem)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환하고 나머지 목록을 반환하는 동안 &lt;code&gt;Elem&lt;/code&gt; 요소 를 &lt;code&gt;List1&lt;/code&gt; 에서 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="57da8705f25d5b4e6976bd3ef06dda9c36e25b6f" translate="yes" xml:space="preserve">
          <source>Drops the last element of a &lt;code&gt;List&lt;/code&gt;. The list is to be non-empty, otherwise the function crashes with a &lt;code&gt;function_clause&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; 의 마지막 요소를 삭제합니다 . 이 목록은 비어 있지 않아야 &lt;code&gt;function_clause&lt;/code&gt; . 그렇지 않으면 함수가 function_clause와 충돌 합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc89c1203fd6f662ab09bafe6724b5d26d8fe8d" translate="yes" xml:space="preserve">
          <source>Drops usage of the latin1 atom encoding and unconditionally use utf8 encoding for all atoms. This will be changed to the default in a future major release of Erlang/OTP. Erlang/OTP systems as of R16B can decode this representation.</source>
          <target state="translated">latin1 아톰 인코딩 사용을 삭제하고 모든 원자에 무조건 utf8 인코딩을 사용합니다. 이것은 Erlang / OTP의 향후 주요 릴리스에서 기본값으로 변경 될 것입니다. R16B 기준 Erlang / OTP 시스템은이 표현을 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da6b942d555f9de8c518f3adfc3e33593613231" translate="yes" xml:space="preserve">
          <source>Due to a known bug in the underlying zlib library, &lt;code&gt;WindowBits&lt;/code&gt; values 8 and -8 do not work as expected. In zlib versions before 1.2.9 values 8 and -8 are automatically changed to 9 and -9. &lt;strong&gt;From zlib version 1.2.9 value -8 is rejected&lt;/strong&gt; causing &lt;code&gt;zlib:deflateInit/6&lt;/code&gt; to fail (8 is still changed to 9). It also seem possible that future versions of zlib may fix this bug and start accepting 8 and -8 as is.</source>
          <target state="translated">기본 zlib 라이브러리의 알려진 버그로 인해 &lt;code&gt;WindowBits&lt;/code&gt; 값 8 및 -8이 예상대로 작동하지 않습니다. 1.2.9 이전의 zlib 버전에서 값 8과 -8은 자동으로 9와 -9로 변경됩니다. &lt;strong&gt;ZLIB 버전 1.2.9 값으로부터 -11 거절&lt;/strong&gt; 원인 &lt;code&gt;zlib:deflateInit/6&lt;/code&gt; 실패 (8 여전히 9로 변경된다). 또한 향후 버전의 zlib에서이 버그를 수정하고 8과 -8을 그대로 받아 들일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2822bca8453c024a99d2e74a4a983430ebe051e4" translate="yes" xml:space="preserve">
          <source>Due to irregular naming conventions, some cipher names in the old api are substitued by new names in the new api. For a list of retired names, see &lt;code&gt;Retired cipher names&lt;/code&gt;.</source>
          <target state="translated">불규칙한 이름 지정 규칙으로 인해 이전 API의 일부 암호 이름이 새 API의 새 이름으로 대체됩니다. 폐기 된 이름 목록은 폐기 된 &lt;code&gt;Retired cipher names&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d53965dff14f4c80f0cc877167f2591ff39df7af" translate="yes" xml:space="preserve">
          <source>Due to the above, pull requests are only accepted on the &lt;code&gt;maint&lt;/code&gt; and the &lt;code&gt;master&lt;/code&gt; branches in our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git repository&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;maint&lt;/code&gt; branch contains changes planned for the next &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;maintenance patch package&lt;/a&gt;&lt;/code&gt; on the latest OTP release and the &lt;code&gt;master&lt;/code&gt; branch contain changes planned for the upcoming OTP release.</source>
          <target state="translated">위의 이유로 인해 pull 요청은 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git repository&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;maint&lt;/code&gt; 및 &lt;code&gt;master&lt;/code&gt; 브랜치 에서만 수락됩니다 . &lt;code&gt;maint&lt;/code&gt; 지점은 다음 계획 변경이 포함되어 &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;maintenance patch package&lt;/a&gt;&lt;/code&gt; 최신 OTP 릴리스에와 &lt;code&gt;master&lt;/code&gt; 분기를 곧 OTP 릴리스 계획 변경이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e660da5a81bd948d3a902e014b76d86f2073ccc5" translate="yes" xml:space="preserve">
          <source>Due to the specific event handlers, the output format slightly differed from other log events.</source>
          <target state="translated">특정 이벤트 핸들러로 인해 출력 형식이 다른 로그 이벤트와 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3b3085bf736f2191e0ea07d229bfdc596b32d81d" translate="yes" xml:space="preserve">
          <source>Due to this, it impossible to list in documentation what algorithms that are available in a certain installation.</source>
          <target state="translated">이로 인해 특정 설치에서 사용 가능한 알고리즘을 문서에 나열하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ca23fb39635657b375eb678fc3b116eafb204f3f" translate="yes" xml:space="preserve">
          <source>Dump All Data from EPMD</source>
          <target state="translated">EPMD에서 모든 데이터 덤프</target>
        </trans-unit>
        <trans-unit id="ce420c0f0f57998f7dfd12f03c2f66c6e5fb8dfe" translate="yes" xml:space="preserve">
          <source>Dump support for registries in erl_interface.</source>
          <target state="translated">erl_interface의 레지스트리에 대한 덤프 지원.</target>
        </trans-unit>
        <trans-unit id="1f4861e7450b77c73b64988357d50c9f18f21437" translate="yes" xml:space="preserve">
          <source>Dump the call graph into the specified file whose format is determined by the filename extension. Supported extensions are: &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;dot&lt;/code&gt;, and &lt;code&gt;ps&lt;/code&gt;. If something else is used as filename extension, default format &lt;code&gt;.raw&lt;/code&gt; is used.</source>
          <target state="translated">파일 이름 확장자에 의해 형식이 결정되는 지정된 파일로 호출 그래프를 덤프하십시오. 지원되는 확장자는 &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;dot&lt;/code&gt; 및 &lt;code&gt;ps&lt;/code&gt; 입니다. 파일 이름 확장자로 다른 것이 사용되는 경우 기본 형식 &lt;code&gt;.raw&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7184caff176c543302376cf7fec1ce54dda7f0ad" translate="yes" xml:space="preserve">
          <source>Dump the mib-server data to &lt;code&gt;stdio&lt;/code&gt; (Destination = &lt;code&gt;io&lt;/code&gt;) or the specified file.</source>
          <target state="translated">mib 서버 데이터를 &lt;code&gt;stdio&lt;/code&gt; (Destination = &lt;code&gt;io&lt;/code&gt; ) 또는 지정된 파일로 덤프 하십시오.</target>
        </trans-unit>
        <trans-unit id="b43f288c439d0cc70ad21f7402ed35ef10441966" translate="yes" xml:space="preserve">
          <source>Dumping tables</source>
          <target state="translated">덤핑 테이블</target>
        </trans-unit>
        <trans-unit id="0e499b1b81d04e4a0963798172f050c39de889ef" translate="yes" xml:space="preserve">
          <source>Dumps a set of &lt;code&gt;ram_copies&lt;/code&gt; tables to disc. The next time the system is started, these tables are initiated with the data found in the files that are the result of this dump. None of the tables can have disc-resident replicas.</source>
          <target state="translated">&lt;code&gt;ram_copies&lt;/code&gt; 테이블 세트 를 디스크에 덤프합니다 . 다음에 시스템이 시작될 때이 테이블은이 덤프의 결과 인 파일에서 찾은 데이터로 시작됩니다. 어떤 테이블도 디스크 상주 복제본을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="618d5bf84eb8eca747b739ce93060fbefb9445fd" translate="yes" xml:space="preserve">
          <source>Dumps all local tables of a Mnesia system into a text file, which can be edited (by a normal text editor) and then be reloaded with &lt;code&gt;mnesia:load_textfile/1&lt;/code&gt;. Only use this function for educational purposes. Use other functions to deal with real backups.</source>
          <target state="translated">Mnesia 시스템의 모든 로컬 테이블을 텍스트 파일로 덤프합니다.이 파일은 일반 텍스트 편집기로 편집 한 다음 &lt;code&gt;mnesia:load_textfile/1&lt;/code&gt; 로 다시로드 할 수 있습니다 . 교육 목적으로 만이 기능을 사용하십시오. 다른 기능을 사용하여 실제 백업을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="2352588b3802464c989b95a72e96df7dfb9c6a62" translate="yes" xml:space="preserve">
          <source>Dumps table &lt;code&gt;Tab&lt;/code&gt; to file &lt;code&gt;Filename&lt;/code&gt;.</source>
          <target state="translated">테이블 &lt;code&gt;Tab&lt;/code&gt; 을 &lt;code&gt;Filename&lt;/code&gt; 파일로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="64618333cf2b9688dec82445992bc0cf066f76aa" translate="yes" xml:space="preserve">
          <source>Dumps the contents of a registry to a &lt;code&gt;Mnesia&lt;/code&gt; table in an atomic manner, that is, either all data or no data is updated. If any errors are encountered while backing up the data, the entire operation is aborted.</source>
          <target state="translated">원자 적 방식으로, 즉 모든 데이터 또는 데이터가 업데이트되지 않은 상태 로 레지스트리의 내용을 &lt;code&gt;Mnesia&lt;/code&gt; 테이블에 덤프합니다 . 데이터를 백업하는 동안 오류가 발생하면 전체 작업이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="381fbf5f76a0f53fc2e4740d2ab79b2103d820ba" translate="yes" xml:space="preserve">
          <source>Dumps the current display to a text file.</source>
          <target state="translated">현재 디스플레이를 텍스트 파일로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="be9c5accb485dc0af7b5ea90f3fd262da4a6064d" translate="yes" xml:space="preserve">
          <source>Dumps the current microstate statistics counters to a file that can be parsed with &lt;code&gt; file:consult/1&lt;/code&gt;.</source>
          <target state="translated">현재 microstate 통계 카운터를 &lt;code&gt; file:consult/1&lt;/code&gt; 로 구문 분석 할 수있는 파일로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="bf5d48b8bd681f58ec639f6849aa1f7b2833bc07" translate="yes" xml:space="preserve">
          <source>Dumps the current microstate statistics counters to a file that can be parsed with &lt;code&gt;file:consult/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file:consult/1&lt;/code&gt; 로 구문 분석 할 수있는 파일에 현재 마이크로 스테이트 통계 카운터를 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="ce3c464e1eb2b91ec8a590cec1b8615bf230f5fd" translate="yes" xml:space="preserve">
          <source>Duplicate keys are allowed in matching and match each pattern associated to the keys:</source>
          <target state="translated">중복 키는 일치하도록 허용되며 키와 연관된 각 패턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6d0d7bffffa2a241910a42a63e36f337c3babbe2" translate="yes" xml:space="preserve">
          <source>Duployan</source>
          <target state="translated">Duployan</target>
        </trans-unit>
        <trans-unit id="74dd08678521bd750ecafbc34a117a08ebb03272" translate="yes" xml:space="preserve">
          <source>Durability</source>
          <target state="translated">Durability</target>
        </trans-unit>
        <trans-unit id="d87dba077b41e186992c67cc1c5d9b2114870c66" translate="yes" xml:space="preserve">
          <source>During OTP adaptation it was tested on:</source>
          <target state="translated">OTP 적응 중에는 다음에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="c602387b4583b4dcd026c20a3a1e8e7bf61738f3" translate="yes" xml:space="preserve">
          <source>During VM execution, code is accessed through a number of data structures. These &lt;strong&gt;code access structures&lt;/strong&gt; are</source>
          <target state="translated">VM 실행 중에 코드는 여러 데이터 구조를 통해 액세스됩니다. 이러한 &lt;strong&gt;코드 액세스 구조&lt;/strong&gt; 는</target>
        </trans-unit>
        <trans-unit id="fc319898536d39c91dbdba24fb8261626c9c368d" translate="yes" xml:space="preserve">
          <source>During decoding, the &lt;code&gt;b&lt;/code&gt; field of the record gets the decoded value of the &lt;code&gt;b&lt;/code&gt; component, if present, otherwise the value &lt;code&gt;asn1_NOVALUE&lt;/code&gt;.</source>
          <target state="translated">디코딩 중에 레코드 의 &lt;code&gt;b&lt;/code&gt; 필드는 &lt;code&gt;b&lt;/code&gt; 구성 요소 의 디코딩 된 값 (있는 경우), 그렇지 않은 경우 값 &lt;code&gt;asn1_NOVALUE&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5902a6cefe9cb9c77a6268f9ff9e2f539dc55d82" translate="yes" xml:space="preserve">
          <source>During development of test suites, make no assumptions on the execution order of the test cases or suites. For example, a test case must not assume that a server it depends on is already started by a previous test case. Reasons for this follows:</source>
          <target state="translated">테스트 스위트를 개발하는 동안 테스트 케이스 또는 스위트의 실행 순서를 가정하지 마십시오. 예를 들어 테스트 사례는 종속 된 서버가 이미 이전 테스트 사례에 의해 시작되었다고 가정해서는 안됩니다. 이에 대한 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a18568484e447163575693c3283eebfe40833924" translate="yes" xml:space="preserve">
          <source>During development, this implementation was tested on:</source>
          <target state="translated">개발 과정에서이 구현은 다음에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="60d0badad83e33a80707cc8700ad85c090cff46a" translate="yes" xml:space="preserve">
          <source>During evaluation of a function, no calls can be made to local functions. An undefined function error would be generated. However, the optional argument &lt;code&gt;LocalFunctionHandler&lt;/code&gt; can be used to define a function that is called when there is a call to a local function. The argument can have the following formats:</source>
          <target state="translated">함수를 평가하는 동안 로컬 함수를 호출 할 수 없습니다. 정의되지 않은 함수 오류가 발생합니다. 그러나 선택적 인수 &lt;code&gt;LocalFunctionHandler&lt;/code&gt; 를 사용하여 로컬 함수에 대한 호출이있을 때 호출되는 함수를 정의 할 수 있습니다. 인수는 다음 형식을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e943e84a017c01c905cb5e4d5d51f8602aca5de" translate="yes" xml:space="preserve">
          <source>During execution of tests started with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, the Erlang shell process, controlling &lt;code&gt;stdin&lt;/code&gt;, remains the top-level process of the &lt;code&gt;Common Test&lt;/code&gt; system of processes. Consequently, the Erlang shell is not available for interaction during the test run. If this is not desirable, for example, because the shell is needed for debugging purposes or for interaction with the SUT during test execution, set start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; (in the call to &lt;code&gt;ct:run_test/1&lt;/code&gt; or by using the corresponding test specification term, described later). This makes &lt;code&gt;Common Test&lt;/code&gt; release the shell immediately after the test suite compilation stage. To accomplish this, a test runner process is spawned to take control of the test execution. The effect is that &lt;code&gt;ct:run_test/1&lt;/code&gt; returns the pid of this process rather than the test result, which instead is printed to tty at the end of the test run.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 로 시작한 테스트를 실행하는 동안 &lt;code&gt;stdin&lt;/code&gt; 을 제어하는 Erlang 쉘 프로세스 는 &lt;code&gt;Common Test&lt;/code&gt; 시스템 프로세스의 최상위 프로세스로 남아 있습니다. 따라서 Erlang 셸은 테스트 실행 중에 상호 작용할 수 없습니다. 예를 들어, 테스트 실행 중 쉘 목적이 디버깅 목적이나 SUT와의 상호 작용을 위해 필요하기 때문에 이것이 바람직하지 않은 경우, 시작 옵션 &lt;code&gt;release_shell&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 ( &lt;code&gt;ct:run_test/1&lt;/code&gt; 에 대한 호출에서 또는 해당 테스트 스펙을 사용하여) 용어는 후술한다). 이것은 &lt;code&gt;Common Test&lt;/code&gt; 테스트 스위트 컴파일 단계 직후에 쉘을 해제하십시오. 이를 위해 테스트 실행 프로세스를 제어하기 위해 테스트 실행기 프로세스가 생성됩니다. 결과적으로 &lt;code&gt;ct:run_test/1&lt;/code&gt; 은 테스트 결과가 아닌이 프로세스의 pid를 반환하고 테스트 실행이 끝날 때 tty로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="13400d5db5a1edd12b574982f7247626a4d1afa8" translate="yes" xml:space="preserve">
          <source>During finalization, the time offset is adjusted and fixed so that current Erlang system time aligns with the current OS system time. As the time offset can change during the finalization, Erlang system time can do a time warp at this point. The time offset is from now on fixed until the runtime system terminates. If time correction has been enabled, the time correction from now on also makes adjustments to align Erlang system time with OS system time. When the system is in the final phase, it behaves exactly as in &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마무리하는 동안 현재 Erlang 시스템 시간이 현재 OS 시스템 시간과 일치하도록 시간 오프셋이 조정 및 고정됩니다. 종료 중에 시간 오프셋이 변경 될 수 있으므로 Erlang 시스템 시간은이 시점에서 시간 왜곡을 수행 할 수 있습니다. 시간 오프셋은 지금부터 고정 시스템이 종료 될 때까지 고정되어 있습니다. 시간 수정이 활성화 된 경우 지금부터 시간 수정은 Erlang 시스템 시간을 OS 시스템 시간에 맞추도록 조정합니다. 시스템이 최종 단계에 있으면 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 가 없는 것처럼 정확하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="b5ae35332de729b88634ea8fa41480ea60f856d4" translate="yes" xml:space="preserve">
          <source>During high load scenarios, the length of the handler message queue rarely grows in a linear and predictable way. Instead, whenever the handler process is scheduled in, it can have an almost arbitrary number of messages waiting in the message queue. It is for this reason that the overload protection mechanism is focused on acting quickly, and quite drastically, such as immediately dropping or flushing messages, when a large queue length is detected.</source>
          <target state="translated">로드가 많은 시나리오에서는 처리기 메시지 큐의 길이가 선형적이고 예측 가능한 방식으로 거의 커지지 않습니다. 대신 핸들러 프로세스가 스케줄 될 때마다 메시지 큐에서 거의 임의의 수의 메시지가 대기 할 수 있습니다. 이러한 이유로 과부하 보호 메커니즘은 대기열 길이가 길어질 때 메시지를 즉시 삭제 또는 플러시하는 것과 같이 신속하고 매우 급격하게 작동하는 데 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="7aee45b439d948d5b7d76272a33b0c86bf4997e8" translate="yes" xml:space="preserve">
          <source>During model testing, the first test results in &lt;code&gt;{badmatch,16}&lt;/code&gt; in &lt;code&gt;{toy,start,1}&lt;/code&gt;, why?</source>
          <target state="translated">모델 테스트 중에 첫 번째 테스트 결과 는 &lt;code&gt;{toy,start,1}&lt;/code&gt; 에서 &lt;code&gt;{badmatch,16}&lt;/code&gt; 이 됩니다 . 왜 그렇 습니까?</target>
        </trans-unit>
        <trans-unit id="455e439587f82803aed60d48bf6da00489a0f0b5" translate="yes" xml:space="preserve">
          <source>During release handling, non-affected processes continue normal execution. This can lead to time-outs or other problems. For example, new processes created in the time window between suspending processes using a certain module, and loading a new version of this module, can execute old code.</source>
          <target state="translated">릴리스 처리 중에 영향을받지 않는 프로세스는 계속 정상적으로 실행됩니다. 시간이 초과되거나 다른 문제가 발생할 수 있습니다. 예를 들어, 특정 모듈을 사용하여 프로세스를 일시 중단하고이 모듈의 새 버전을로드하는 사이에 시간 창에서 생성 된 새 프로세스는 이전 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18e5c5d63b2a2373e5f2ba0870a87b60d5f9fcf" translate="yes" xml:space="preserve">
          <source>During runtime, Logger configuration is changed via API functions. See section &lt;code&gt;&lt;a href=&quot;logger#configuration_API&quot;&gt;Configuration API Functions&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;logger(3)&lt;/code&gt; manual page.</source>
          <target state="translated">런타임 중에 로거 구성은 API 기능을 통해 변경됩니다. &lt;code&gt;logger(3)&lt;/code&gt; 매뉴얼 페이지 의 &lt;code&gt;&lt;a href=&quot;logger#configuration_API&quot;&gt;Configuration API Functions&lt;/a&gt;&lt;/code&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="379217a163897fd309c000e61bde6b6a65a2d7a3" translate="yes" xml:space="preserve">
          <source>During the lifetime of a socket, the file descriptor &lt;strong&gt;has&lt;/strong&gt; to remain the same. That is, repeated calls to this callback with the same context &lt;code&gt;should&lt;/code&gt; always report the same file descriptor.</source>
          <target state="translated">소켓의 수명 동안, 파일 기술자 &lt;strong&gt;가&lt;/strong&gt; 동일하게 유지 할 수 있습니다. 즉, 동일한 컨텍스트로이 콜백에 대한 반복 호출 &lt;code&gt;should&lt;/code&gt; 항상 동일한 파일 설명자를보고 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f4912b2aa75fe22c51b1c959d8391db7589b749" translate="yes" xml:space="preserve">
          <source>During the lifetime of a socket, the pointer &lt;code&gt;*ctx&lt;/code&gt;&lt;strong&gt;has&lt;/strong&gt; to remain the same. That is, it cannot later be relocated.</source>
          <target state="translated">소켓의 수명 동안 포인터 &lt;code&gt;*ctx&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 동일하게 유지되어야합니다. 즉, 나중에 재배치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20bc30338e4de5739d661e0625d9f9d24eeca0b3" translate="yes" xml:space="preserve">
          <source>During the start of a system, when a client application &lt;strong&gt;could&lt;/strong&gt; start prior to the SNMP manager but is dependent upon it, and therefor has to wait for it to start.</source>
          <target state="translated">시스템 시작 중에 클라이언트 응용 프로그램 &lt;strong&gt;이&lt;/strong&gt; SNMP 관리자보다 먼저 시작할 &lt;strong&gt;수&lt;/strong&gt; 있지만 종속되어 있으므로 시작될 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="6fcbdddd017956cd0019e350d24a1939cbcd022e" translate="yes" xml:space="preserve">
          <source>During use of a port opened using &lt;code&gt;{spawn, Name}&lt;/code&gt;, &lt;code&gt;{spawn_driver, Name}&lt;/code&gt;, or &lt;code&gt;{spawn_executable, Name}&lt;/code&gt;, errors arising when sending messages to it are reported to the owning process using signals of the form &lt;code&gt;{'EXIT', Port, PosixCode}&lt;/code&gt;. For the possible values of &lt;code&gt;PosixCode&lt;/code&gt;, see &lt;code&gt;file(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn, Name}&lt;/code&gt; , &lt;code&gt;{spawn_driver, Name}&lt;/code&gt; 또는 &lt;code&gt;{spawn_executable, Name}&lt;/code&gt; 사용하여 열린 포트를 사용하는 동안 메시지를 보낼 때 발생하는 오류는 &lt;code&gt;{'EXIT', Port, PosixCode}&lt;/code&gt; 형식의 신호를 사용하여 소유 프로세스에보고됩니다 , PosixCode} . 가능한 &lt;code&gt;PosixCode&lt;/code&gt; 값 은 &lt;code&gt;file(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b34f8bde4114e100ca5b54c517844199b48657fc" translate="yes" xml:space="preserve">
          <source>Dynamic Erlang Driver Linking</source>
          <target state="translated">다이나믹 얼랭 드라이버 링크</target>
        </trans-unit>
        <trans-unit id="a44067361315b05c273ea0405f7864e1bd1bf576" translate="yes" xml:space="preserve">
          <source>Dynamic driver loader and linker.</source>
          <target state="translated">동적 드라이버 로더 및 링커</target>
        </trans-unit>
        <trans-unit id="8d5b8175b7f2d3d1d7c21e7c0e5bbee352f3bc51" translate="yes" xml:space="preserve">
          <source>Dynamic node name. This is not a capability but rather used as a request from the connecting node to receive its node name from the accepting node as part of the handshake.</source>
          <target state="translated">동적 노드 이름. 이것은 기능이 아니라 핸드 셰이크의 일부로 수락 노드에서 노드 이름을 받기 위해 연결 노드의 요청으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d13cc2f7953cdc9f758c18be9f7b8a02412bfdd7" translate="yes" xml:space="preserve">
          <source>Dynamic reconfiguration</source>
          <target state="translated">동적 재구성</target>
        </trans-unit>
        <trans-unit id="13aa9a50086b6ac76b1cb8c6f3e9af0f9dba8709" translate="yes" xml:space="preserve">
          <source>Dynamic version detection</source>
          <target state="translated">동적 버전 감지</target>
        </trans-unit>
        <trans-unit id="8c2f2c4c8b8adb6ccd5249a4e952ee59713af7b6" translate="yes" xml:space="preserve">
          <source>Dynamically adds a child specification to supervisor &lt;code&gt;SupRef&lt;/code&gt;, which starts the corresponding child process.</source>
          <target state="translated">동적 관리자에 아이 사양 추가 &lt;code&gt;SupRef&lt;/code&gt; 해당 자식 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d3ec976f32b93a40ffe278626358ad5300808f4e" translate="yes" xml:space="preserve">
          <source>Dynamically load an engine from default directory</source>
          <target state="translated">기본 디렉토리에서 동적으로 엔진로드</target>
        </trans-unit>
        <trans-unit id="fdde27315f8fe4afa9c39d16385e94b637fcfb0c" translate="yes" xml:space="preserve">
          <source>Dynamically loaded into the Erlang machines address space, which is the only alternative if a precompiled version of Erlang is to be used</source>
          <target state="translated">Erlang 머신 주소 공간에 동적으로로드됩니다. 사전 컴파일 된 Erlang 버전을 사용하는 경우 유일한 대안입니다.</target>
        </trans-unit>
        <trans-unit id="47cb4a6e83f17f59d314ef1f01f8353a46aca8ff" translate="yes" xml:space="preserve">
          <source>Dynamically started services are not handled by application takeover and failover behavior when &lt;code&gt;Inets&lt;/code&gt; is run as a distributed application. Nor are they automatically restarted when the &lt;code&gt;Inets&lt;/code&gt; application is restarted. As long as the &lt;code&gt;Inets&lt;/code&gt; application is operational, they are supervised and can be soft code upgraded.</source>
          <target state="translated">&lt;code&gt;Inets&lt;/code&gt; 가 분산 응용 프로그램으로 실행될 때 응용 프로그램 인계 및 장애 조치 동작에 의해 동적으로 시작된 서비스가 처리되지 않습니다 . &lt;code&gt;Inets&lt;/code&gt; 응용 프로그램이 다시 시작될 때 자동으로 다시 시작되지도 않습니다 . 만큼으로 &lt;code&gt;Inets&lt;/code&gt; 의 응용 프로그램이 작동, 그들은 감독하고 부드러운 코드를 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f230b8bfa12c208281cb0fc0f2a5f1622391c2" translate="yes" xml:space="preserve">
          <source>Dynamically starts an &lt;code&gt;FTP&lt;/code&gt; session after the &lt;code&gt;ftp&lt;/code&gt; application has been started.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; 응용 프로그램이 시작된 후 &lt;code&gt;FTP&lt;/code&gt; 세션을 동적 으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1096e1dba137c5f15869f0236240de198946ed71" translate="yes" xml:space="preserve">
          <source>Dynamically starts an &lt;code&gt;Inets&lt;/code&gt; service after the &lt;code&gt;Inets&lt;/code&gt; application has been started.</source>
          <target state="translated">&lt;code&gt;Inets&lt;/code&gt; 응용 프로그램이 시작된 후 &lt;code&gt;Inets&lt;/code&gt; 서비스를 동적 으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3be880303bce628299b41c673e201ce5941eb9d6" translate="yes" xml:space="preserve">
          <source>Dynamically updates the compression level and compression strategy. The interpretation of &lt;code&gt;Level&lt;/code&gt; and &lt;code&gt;Strategy&lt;/code&gt; is as in &lt;code&gt;&lt;a href=&quot;#deflateInit-6&quot;&gt;deflateInit/6&lt;/a&gt;&lt;/code&gt;. This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and can be flushed); the new level takes effect only at the next call of &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">압축 수준 및 압축 전략을 동적으로 업데이트합니다. 의 해석 &lt;code&gt;Level&lt;/code&gt; 과 &lt;code&gt;Strategy&lt;/code&gt; 에서 같다 &lt;code&gt;&lt;a href=&quot;#deflateInit-6&quot;&gt;deflateInit/6&lt;/a&gt;&lt;/code&gt; . 이것은 입력 데이터의 압축과 직선 복사 사이를 전환하거나 다른 전략을 요구하는 다른 종류의 입력 데이터로 전환하는 데 사용할 수 있습니다. 압축 수준이 변경되면 지금까지 사용 가능한 입력이 이전 수준으로 압축되고 플러시 될 수 있습니다. 새로운 레벨은 다음 &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt; 호출에서만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ff063a21bc0ed86e6a4e8962b8993962632c55d" translate="yes" xml:space="preserve">
          <source>ECDSA</source>
          <target state="translated">ECDSA</target>
        </trans-unit>
        <trans-unit id="80e3d524de972452501598eb804f71534022451d" translate="yes" xml:space="preserve">
          <source>ECDSA is available with OpenSSL 0.9.8o or later if not disabled by configuration. To dynamically check availability, check that the atom &lt;code&gt;ecdsa&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt;. If the atom &lt;code&gt;ec_gf2m&lt;/code&gt; also is present, the characteristic two field curves are available.</source>
          <target state="translated">ECDSA는 구성에 의해 비활성화되지 않은 경우 OpenSSL 0.9.8o 이상에서 사용할 수 있습니다. 가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 원자 &lt;code&gt;ecdsa&lt;/code&gt; 가 있는지 확인합니다 . 원자 &lt;code&gt;ec_gf2m&lt;/code&gt; 도 존재하는 경우 특성 두 필드 곡선을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ebc0a5394d8ebbe656f6c55943154c331bf1d57" translate="yes" xml:space="preserve">
          <source>EEP 40 suggests that the language is also to allow for Unicode characters &amp;gt; 255 in variable names. Whether to implement that EEP is yet to be decided.</source>
          <target state="translated">EEP 40은이 언어가 변수 이름에 255보다 큰 유니 코드 문자를 허용 할 것을 제안합니다. 해당 EEP를 구현할지 여부는 아직 결정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="db5d4c5f39084ed8a98f2f308319f6fc3f3fec69" translate="yes" xml:space="preserve">
          <source>ERL Scheme</source>
          <target state="translated">ERL 제도</target>
        </trans-unit>
        <trans-unit id="778ad9b263b62197707df5c99c6055f019a776e0" translate="yes" xml:space="preserve">
          <source>ERTS</source>
          <target state="translated">ERTS</target>
        </trans-unit>
        <trans-unit id="084c82f27172e39caac8b32a5c5a3de227cdada9" translate="yes" xml:space="preserve">
          <source>ERTS 5.9 introduced two new integer types, &lt;code&gt;&lt;a href=&quot;#ErlDrvSizeT&quot;&gt;ErlDrvSizeT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#ErlDrvSSizeT&quot;&gt;ErlDrvSSizeT&lt;/a&gt;&lt;/code&gt;, which can hold 64-bit sizes if necessary.</source>
          <target state="translated">ERTS 5.9에는 필요한 경우 64 비트 크기를 보유 할 수있는 두 개의 새로운 정수 유형 인 &lt;code&gt;&lt;a href=&quot;#ErlDrvSizeT&quot;&gt;ErlDrvSizeT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#ErlDrvSSizeT&quot;&gt;ErlDrvSSizeT&lt;/a&gt;&lt;/code&gt; 가 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="85dc1296e2947a844efb66d65438ec8b2ad8252a" translate="yes" xml:space="preserve">
          <source>ERTS User's Guide</source>
          <target state="translated">ERTS 사용자 안내서</target>
        </trans-unit>
        <trans-unit id="44f592d8979778308c2fb81544db747d809abcc9" translate="yes" xml:space="preserve">
          <source>ERTS version the release is intended for.</source>
          <target state="translated">이 릴리스의 ERTS 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b612ad3744b82b6590ec2ed7801b6b4e71c44b19" translate="yes" xml:space="preserve">
          <source>ERTS/erl_driver</source>
          <target state="translated">ERTS/erl_driver</target>
        </trans-unit>
        <trans-unit id="c73f4aaaa252f5447d44e10d202890c287a9dd79" translate="yes" xml:space="preserve">
          <source>ERTS/erl_nif</source>
          <target state="translated">ERTS/erl_nif</target>
        </trans-unit>
        <trans-unit id="6dba289d5b794a18ff5aa78141b1611e24fd604f" translate="yes" xml:space="preserve">
          <source>ERTS/erl_prim_loader</source>
          <target state="translated">ERTS/erl_prim_loader</target>
        </trans-unit>
        <trans-unit id="003545865b7dee179c081e0d8ec83daa48033c14" translate="yes" xml:space="preserve">
          <source>ERTS/erl_tracer</source>
          <target state="translated">ERTS/erl_tracer</target>
        </trans-unit>
        <trans-unit id="207651703485ebb3590aa930b3610f9237b9b992" translate="yes" xml:space="preserve">
          <source>ERTS/erlang</source>
          <target state="translated">ERTS/erlang</target>
        </trans-unit>
        <trans-unit id="b64df6cef05617dfbd4d20c2d8b1cc669b3edfb0" translate="yes" xml:space="preserve">
          <source>ERTS/init</source>
          <target state="translated">ERTS/init</target>
        </trans-unit>
        <trans-unit id="95d08dc392df8636331cdbdbd25742c1d876eac5" translate="yes" xml:space="preserve">
          <source>ERTS/zlib</source>
          <target state="translated">ERTS/zlib</target>
        </trans-unit>
        <trans-unit id="4ecfa2773154e370fba9b018a43ed42a95f19d49" translate="yes" xml:space="preserve">
          <source>ESI</source>
          <target state="translated">ESI</target>
        </trans-unit>
        <trans-unit id="4bfaf341d88c4cc708fd53de2a4d0b2f36cb3596" translate="yes" xml:space="preserve">
          <source>ESI Callback Functions</source>
          <target state="translated">ESI 콜백 함수</target>
        </trans-unit>
        <trans-unit id="7eceb14d6ed554f3e39c3487db659c8d63e28acd" translate="yes" xml:space="preserve">
          <source>ETS</source>
          <target state="translated">ETS</target>
        </trans-unit>
        <trans-unit id="535109603d1d3983bd1504d46e58246d0b9b5c5b" translate="yes" xml:space="preserve">
          <source>ETS match specifications produce a return value. Usually the &lt;code&gt;MatchBody&lt;/code&gt; contains one single &lt;code&gt;ConditionExpression&lt;/code&gt; that defines the return value without any side effects. Calls with side effects are not allowed in the ETS context.</source>
          <target state="translated">ETS 일치 스펙은 리턴 값을 생성합니다. 일반적으로 &lt;code&gt;MatchBody&lt;/code&gt; 에는 부작용없이 반환 값을 정의하는 단일 &lt;code&gt;ConditionExpression&lt;/code&gt; 이 포함되어 있습니다 . 부작용이있는 통화는 ETS 컨텍스트에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46b5844c30f17802c3dbe2a6160c75fb2768d9bb" translate="yes" xml:space="preserve">
          <source>EUnit builds on ideas from the family of unit testing frameworks for Object Oriented languages that originated with JUnit by Beck and Gamma (and Beck's previous framework SUnit for Smalltalk). However, EUnit uses techniques more adapted to functional and concurrent programming, and is typically less verbose than its relatives.</source>
          <target state="translated">EUnit은 Beck과 Gamma (Jack의 이전 프레임 워크 SUnit for Smalltalk)에 의해 시작된 객체 지향 언어에 대한 단위 테스트 프레임 워크 패밀리의 아이디어를 기반으로합니다. 그러나 EUnit은 기능 및 동시 프로그래밍에보다 적합한 기술을 사용하며 일반적으로 친척보다 덜 장황합니다.</target>
        </trans-unit>
        <trans-unit id="bb84cfb674cc9c07befa3e836772f6d49451b0b9" translate="yes" xml:space="preserve">
          <source>EUnit is a unit testing framework for Erlang. It is very powerful and flexible, is easy to use, and has small syntactical overhead.</source>
          <target state="translated">EUnit은 Erlang의 단위 테스트 프레임 워크입니다. 매우 강력하고 유연하며 사용하기 쉽고 구문상의 오버 헤드가 적습니다.</target>
        </trans-unit>
        <trans-unit id="dcb5c9416725af47e0dde86a44e3726fa172542f" translate="yes" xml:space="preserve">
          <source>EVAL Scheme</source>
          <target state="translated">평가 체계</target>
        </trans-unit>
        <trans-unit id="e986cd2e713da6eeece44cdc6f88d025029df261" translate="yes" xml:space="preserve">
          <source>EXPERIMENTAL support in &lt;code&gt;Common Test&lt;/code&gt; for calling property-based tests.</source>
          <target state="translated">속성 기반 테스트 호출을위한 &lt;code&gt;Common Test&lt;/code&gt; 실험적 지원 .</target>
        </trans-unit>
        <trans-unit id="3535800729023232937a5a75329edb6d668dc3ac" translate="yes" xml:space="preserve">
          <source>EXPERIMENTAL support in Common Test for calling property-based tests.</source>
          <target state="translated">속성 기반 테스트 호출을위한 공통 테스트의 실험적 지원.</target>
        </trans-unit>
        <trans-unit id="d179ef076d3ba549c1eaefd6c4000085c521b739" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;-spec&lt;/code&gt; contract is to be a subtype of the respective &lt;code&gt;-callback&lt;/code&gt; contract.</source>
          <target state="translated">각 &lt;code&gt;-spec&lt;/code&gt; 계약은 각각의 하위 유형이 될 것입니다 &lt;code&gt;-callback&lt;/code&gt; 계약.</target>
        </trans-unit>
        <trans-unit id="bbeba8f50a6d88947fa61a1c562fdec9908b5f80" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;&lt;a href=&quot;#cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; is included in some strongly connected component, which implies that a &lt;code&gt;&lt;a href=&quot;#topsort&quot;&gt;topological ordering&lt;/a&gt;&lt;/code&gt; of the created digraph always exists.</source>
          <target state="translated">각 &lt;code&gt;&lt;a href=&quot;#cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; 는 강하게 연결된 일부 구성 요소에 포함 되므로 작성된 digraph 의 &lt;code&gt;&lt;a href=&quot;#topsort&quot;&gt;topological ordering&lt;/a&gt;&lt;/code&gt; 가 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="b91672b8b9d9c1074d5c3616da5bbe87be145768" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver use &lt;strong&gt;literally&lt;/strong&gt; the same pathname for the driver when demanding load, but the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; are not concerned with if the driver is already loaded from the file system or if the object code must be loaded from file system.</source>
          <target state="translated">드라이버의 각 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 는 로드를 요구할 때 드라이버에 대해 &lt;strong&gt;문자 그대로&lt;/strong&gt; 동일한 경로 이름을 사용 하지만 드라이버가 파일 시스템에서 이미로드되었는지 또는 오브젝트 코드가 파일 시스템에서로드되어야하는지에 대해서는 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 걱정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b7b0c5e0a6ab9f7071cc3d4509396575aab0f1b" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Application&lt;/code&gt; (atom) and &lt;code&gt;AppVsn&lt;/code&gt; is the name and version of an application included in the release. The minimal release based on Erlang/OTP consists of the Kernel and STDLIB applications, so these applications must be included in the list.</source>
          <target state="translated">각 &lt;code&gt;Application&lt;/code&gt; (아톰) 및 &lt;code&gt;AppVsn&lt;/code&gt; 은 릴리스에 포함 된 응용 프로그램의 이름 및 버전입니다. Erlang / OTP 기반의 최소 릴리스는 커널 및 STDLIB 응용 프로그램으로 구성되므로 이러한 응용 프로그램은 목록에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="756a2cbaa3819961fd2a604970deabef7e47b59c" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;DownToVsn&lt;/code&gt; is a previous version of the application to downgrade to.</source>
          <target state="translated">각 &lt;code&gt;DownToVsn&lt;/code&gt; 은 다운 그레이드 할 이전 버전의 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="00de80a9bd6be23947f13b18c11247e44b2c0111" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Instructions&lt;/code&gt; is a list of release handling instructions.</source>
          <target state="translated">각 &lt;code&gt;Instructions&lt;/code&gt; 은 릴리스 처리 지침의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="cc4e66320e4a665094adabc03dbd562a3b958289" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Opt&lt;/code&gt; is a tuple &lt;code&gt;{Key,Value}&lt;/code&gt;, which define a certain property of the application. All keys are optional. Default values are used for any omitted keys.</source>
          <target state="translated">각 &lt;code&gt;Opt&lt;/code&gt; 은 응용 프로그램의 특정 특성을 정의 하는 튜플 &lt;code&gt;{Key,Value}&lt;/code&gt; 입니다. 모든 키는 선택 사항입니다. 생략 된 키에는 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="12aba37f1fd213ff8df833310991e7fddad7fb81" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Opt&lt;/code&gt; is a tuple &lt;code&gt;{Key,Value}&lt;/code&gt;, which defines a certain property of the application. All keys are optional. Default values are used for any omitted keys.</source>
          <target state="translated">각 &lt;code&gt;Opt&lt;/code&gt; 는 애플리케이션의 특정 속성을 정의 하는 튜플 &lt;code&gt;{Key,Value}&lt;/code&gt; 입니다. 모든 키는 선택 사항입니다. 생략 된 키에는 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="481b5fd9f4ed559d8d313890de73dd0798ebaefc" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;UpFromVsn&lt;/code&gt; is a previous version of the application to upgrade from.</source>
          <target state="translated">각 &lt;code&gt;UpFromVsn&lt;/code&gt; 은 업그레이드 할 이전 버전의 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="67d62d9c347c69602abcb833f8f9c4300f1c4701" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;declaration&lt;/code&gt; or &lt;code&gt;rule&lt;/code&gt; ends with a dot (the character &lt;code&gt;'.'&lt;/code&gt;).</source>
          <target state="translated">각 &lt;code&gt;declaration&lt;/code&gt; 또는 &lt;code&gt;rule&lt;/code&gt; 은 점 (문자 &lt;code&gt;'.'&lt;/code&gt; )으로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="65770ef193425908bddd8a2670963b17addf7cbb" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;vacmViewTreeFamilyViewName&lt;/code&gt; refers to a collection of sub-trees.</source>
          <target state="translated">각 &lt;code&gt;vacmViewTreeFamilyViewName&lt;/code&gt; 은 하위 트리 모음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5ed7282900bb5fdbff5958dd466870a2cefa9c4c" translate="yes" xml:space="preserve">
          <source>Each CPU will be specified separately (assuming this information can be retrieved from the operating system), that is, a list with one &lt;code&gt;UtilDesc&lt;/code&gt; per CPU will be returned.</source>
          <target state="translated">각 CPU는 별도로 지정됩니다 (운영 체제에서이 정보를 검색 할 수 있다고 가정). 즉, CPU 당 하나의 &lt;code&gt;UtilDesc&lt;/code&gt; 가 있는 목록 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="34310bfb92de50fb3fdb84c9be6468f58c6dd477" translate="yes" xml:space="preserve">
          <source>Each Diameter application defined on a service is configured with a callback module that implements the &lt;code&gt;application interface&lt;/code&gt; through which diameter communicates the connectivity of remote peers, requests peer selection for outgoing requests, and communicates the reception of incoming Diameter request and answer messages. An application using diameter implements these application callback modules to provide the functionality of the Diameter node(s) it implements.</source>
          <target state="translated">서비스에 정의 된 각 Diameter 응용 프로그램은 Diameter 가 원격 피어의 연결을 통신하고 나가는 요청에 대한 피어 선택을 요청하고 들어오는 Diameter 요청 및 응답 메시지의 수신을 통신하는 &lt;code&gt;application interface&lt;/code&gt; 를 구현하는 콜백 모듈로 구성됩니다 . Diameter를 사용하는 응용 프로그램은 이러한 응용 프로그램 콜백 모듈을 구현하여 해당 응용 프로그램이 구현하는 Diameter 노드의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55244236933611821163d373997b240e1ad6204a" translate="yes" xml:space="preserve">
          <source>Each Diameter application is also configured with a dictionary module that provide encode/decode functionality for outgoing/incoming Diameter messages belonging to the application. A dictionary module is generated from a &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc&lt;/a&gt;&lt;/code&gt; utility. Dictionaries for the RFC 6733 Diameter Common Messages, Base Accounting and Relay applications are provided with the diameter application.</source>
          <target state="translated">각 Diameter 애플리케이션에는 애플리케이션에 속하는 발신 / 수신 Diameter 메시지에 대한 인코딩 / 디코딩 기능을 제공하는 사전 모듈도 구성되어 있습니다. 사전 모듈은 &lt;code&gt;&lt;a href=&quot;diameterc&quot;&gt;diameterc&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용하여 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; 에서 생성됩니다 . RFC 6733 직경 공통 메시지, 기본 회계 및 릴레이 애플리케이션에 대한 사전이 직경 애플리케이션과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a9b6fe619d4d507768382269489dfde40d427b" translate="yes" xml:space="preserve">
          <source>Each Erlang process has its own stack and heap which are allocated in the same memory block and grow towards each other. When the stack and the heap &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L387&quot;&gt;meet&lt;/a&gt;&lt;/code&gt;, the garbage collector is triggered and memory is reclaimed. If not enough memory was reclaimed, the heap will grow.</source>
          <target state="translated">각 Erlang 프로세스에는 동일한 메모리 블록에 할당되고 서로를 향해 성장하는 자체 스택과 힙이 있습니다. 스택과 힙이 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L387&quot;&gt;meet&lt;/a&gt;&lt;/code&gt; 가비지 수집기가 트리거되고 메모리가 회수됩니다. 충분한 메모리가 회수되지 않으면 힙이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="8b240e5a20e54b9eb0bd09de0e35e15bc9e2fc55" translate="yes" xml:space="preserve">
          <source>Each Logger handler has a configured formatter specified as a module and a configuration term. The purpose of the formatter is to translate the log events to a final printable string (&lt;code&gt;unicode:chardata() &lt;/code&gt;) which can be written to the output device of the handler. See sections &lt;code&gt;&lt;a href=&quot;logger_chapter#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_chapter#formatters&quot;&gt;Formatters&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for more information.</source>
          <target state="translated">각 로거 핸들러에는 모듈 및 구성 용어로 지정된 구성된 포맷터가 있습니다. 포맷터의 목적은 로그 이벤트를 핸들러의 출력 장치에 기록 할 수 있는 최종 인쇄 가능한 문자열 ( &lt;code&gt;unicode:chardata() &lt;/code&gt; )로 변환하는 것입니다. 자세한 내용 은 Kernel User 's Guide의 &lt;code&gt;&lt;a href=&quot;logger_chapter#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_chapter#formatters&quot;&gt;Formatters&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9eadf73a0c0284009b59a288825d06c68918732" translate="yes" xml:space="preserve">
          <source>Each Logger handler has a configured formatter specified as a module and a configuration term. The purpose of the formatter is to translate the log events to a final printable string (&lt;code&gt;unicode:chardata()&lt;/code&gt;) which can be written to the output device of the handler. See sections &lt;code&gt;&lt;a href=&quot;logger_chapter#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_chapter#formatters&quot;&gt;Formatters&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for more information.</source>
          <target state="translated">각 로거 핸들러에는 모듈 및 구성 용어로 지정된 구성된 포맷터가 있습니다. 포맷터의 목적은 로그 이벤트를 처리기의 출력 장치에 쓸 수 있는 최종 인쇄 가능 문자열 ( &lt;code&gt;unicode:chardata()&lt;/code&gt; )로 변환하는 것입니다. 자세한 내용 은 커널 사용 설명서의 &lt;code&gt;&lt;a href=&quot;logger_chapter#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_chapter#formatters&quot;&gt;Formatters&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a2217ea4fb630dde08bc31f8f4df9f225a8d461" translate="yes" xml:space="preserve">
          <source>Each MIB is contained in one application. The MIB text files are stored under &lt;code&gt;mibs/&amp;lt;MIB&amp;gt;.mib&lt;/code&gt; in the application directory. The generated &lt;code&gt;.hrl&lt;/code&gt; files with constant declarations are stored under &lt;code&gt;include/&amp;lt;MIB&amp;gt;.hrl&lt;/code&gt;, and the compiled MIBs are stored under &lt;code&gt;priv/mibs/&amp;lt;MIB&amp;gt;.bin&lt;/code&gt;.</source>
          <target state="translated">각 MIB는 하나의 애플리케이션에 포함됩니다. MIB 텍스트 파일은 응용 프로그램 디렉토리의 &lt;code&gt;mibs/&amp;lt;MIB&amp;gt;.mib&lt;/code&gt; 에 저장됩니다 . 상수 선언이 있는 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 파일은 &lt;code&gt;include/&amp;lt;MIB&amp;gt;.hrl&lt;/code&gt; 에 저장되고 컴파일 된 MIB는 &lt;code&gt;priv/mibs/&amp;lt;MIB&amp;gt;.bin&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f596e5edca19c4fb206995b44af1186fe1cc57ca" translate="yes" xml:space="preserve">
          <source>Each MIB is contained in one application. The MIB text files are stored under &lt;code&gt;mibs/&amp;lt;MIB&amp;gt;.mib&lt;/code&gt; in the application directory. The generated &lt;code&gt;.hrl&lt;/code&gt; files with constant declarations are stored under &lt;code&gt;include/&amp;lt;MIB&amp;gt;.hrl&lt;/code&gt;, and the compiled MIBs are stored under &lt;code&gt;priv/mibs/&amp;lt;MIB&amp;gt;.bin&lt;/code&gt;. For example, the &lt;code&gt;OTP-MIB&lt;/code&gt; is included in the SASL application:</source>
          <target state="translated">각 MIB는 하나의 응용 프로그램에 포함되어 있습니다. MIB 텍스트 파일은 응용 프로그램 디렉토리의 &lt;code&gt;mibs/&amp;lt;MIB&amp;gt;.mib&lt;/code&gt; 에 저장됩니다 . 상수 선언으로 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 파일은 &lt;code&gt;include/&amp;lt;MIB&amp;gt;.hrl&lt;/code&gt; 아래에 저장되고 컴파일 된 MIB는 &lt;code&gt;priv/mibs/&amp;lt;MIB&amp;gt;.bin&lt;/code&gt; 아래에 저장됩니다 . 예를 들어 &lt;code&gt;OTP-MIB&lt;/code&gt; 는 SASL 응용 프로그램에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9402652033c3052c1ef00f2688bbca891d3a41f8" translate="yes" xml:space="preserve">
          <source>Each NIF must have an implementation in Erlang to be invoked if the function is called before the NIF library is successfully loaded. A typical such stub implementation is to call &lt;code&gt;&lt;a href=&quot;erlang#nif_error-1&quot;&gt; erlang:nif_error&lt;/a&gt;&lt;/code&gt; which will raise an exception. The Erlang function can also be used as a fallback implementation if the NIF library lacks implementation for some OS or hardware architecture for example.</source>
          <target state="translated">NIF 라이브러리가 성공적으로로드되기 전에 함수가 호출되면 각 NIF에는 Erlang에 구현이 있어야합니다. 일반적인 스텁 구현은 예외를 발생시키는 &lt;code&gt;&lt;a href=&quot;erlang#nif_error-1&quot;&gt; erlang:nif_error&lt;/a&gt;&lt;/code&gt; 를 호출 하는 것입니다. 예를 들어 NIF 라이브러리에 일부 OS 또는 하드웨어 아키텍처에 대한 구현이없는 경우 Erlang 함수를 대체 구현으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="96c9a5aa6202f44778f708491759e58be7229aa8" translate="yes" xml:space="preserve">
          <source>Each OAM component in OTP is implemented as one sub-application, which can be included in a management application for the system. Notice that such a complete management application is not in the scope of this generic functionality. However, this section includes examples illustrating how such an application can be built.</source>
          <target state="translated">OTP의 각 OAM 구성 요소는 시스템의 관리 응용 프로그램에 포함될 수있는 하나의 하위 응용 프로그램으로 구현됩니다. 이러한 완전한 관리 응용 프로그램은이 일반 기능의 범위에 속하지 않습니다. 그러나이 섹션에는 이러한 응용 프로그램을 구축하는 방법을 보여주는 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f070d243c99f1d0073b04e83aa5a92016f0467" translate="yes" xml:space="preserve">
          <source>Each Object Identifier (OID) is made up of a table name and a key. For example, if an employee record is represented by the tuple &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt;, this record has an OID, which is the tuple &lt;code&gt;{employee, 104732}&lt;/code&gt;.</source>
          <target state="translated">각 OID (Object Identifier)는 테이블 이름과 키로 구성됩니다. 예를 들어, 직원 레코드가 튜플 &lt;code&gt;{employee, 104732, klacke, 7, male, 98108, {221, 015}}&lt;/code&gt; 로 표시되는 경우이 레코드는 OID를 가지며 이는 튜플 &lt;code&gt;{employee, 104732}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="407a711f08b93a1ab121c3edfb578a68342eed52" translate="yes" xml:space="preserve">
          <source>Each SSH client or daemon presents themselves to each other with brand and version. This may look like</source>
          <target state="translated">각 SSH 클라이언트 또는 데몬은 브랜드 및 버전과 함께 서로에게 표시됩니다. 이것은 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19d3a9c7f3953415557107b9a4fed3fe829f6388" translate="yes" xml:space="preserve">
          <source>Each Xref server is referred to by a unique name. The name is given when creating the server:</source>
          <target state="translated">각 외부 참조 서버는 고유 한 이름으로 참조됩니다. 서버를 만들 때 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="305e27dbe27580eb3422e180a4b909efd7529202" translate="yes" xml:space="preserve">
          <source>Each allocator instance keeps track of the current utilization of its multi-block carriers. When the total utilization falls below the &quot;abandon carrier utilization limit&quot; it starts to inspect the utilization of the current carrier when deallocations are made. If also the utilization of the carrier falls below the &quot;abandon carrier utilization limit&quot; it unlinks the carrier from its data structure of available free blocks and inserts the carrier into the pool.</source>
          <target state="translated">각 할당 자 인스턴스는 다중 블록 캐리어의 현재 사용률을 추적합니다. 총 사용률이 &quot;abandon carrier 사용 한계&quot;아래로 떨어지면 할당 해제가 이루어질 때 현재 캐리어의 사용률을 검사하기 시작합니다. 또한 캐리어의 사용률이 &quot;abandon carrier 사용 한계&quot;아래로 떨어지면 사용 가능한 사용 가능한 블록의 데이터 구조에서 캐리어의 링크를 해제하고 캐리어를 풀에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="55f7fd00c871ae23ab70f17a8c5addef99b7eb4f" translate="yes" xml:space="preserve">
          <source>Each breakpoint has a &lt;strong&gt;trigger action&lt;/strong&gt; that specifies what is to happen when a process has reached it (and stopped):</source>
          <target state="translated">각 중단 점에는 프로세스가 도달하여 중지 될 때 발생하는 상황을 지정 하는 &lt;strong&gt;트리거 조치&lt;/strong&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b7aaf3eab007c9a636fe0aee9104cf045a98ec" translate="yes" xml:space="preserve">
          <source>Each carrier has an atomic word containing a pointer to the employing allocator instance and three bit flags; IN_POOL, BUSY and HOMECOMING.</source>
          <target state="translated">각 반송파에는 사용하는 할당 자 인스턴스에 대한 포인터와 3 개의 비트 플래그를 포함하는 원자 단어가 있습니다. IN_POOL, BUSY 및 HOMECOMING.</target>
        </trans-unit>
        <trans-unit id="37cf7b36c1772164368bfd9e88986c528dd6631f" translate="yes" xml:space="preserve">
          <source>Each certificate in the certificate chain is issued by the previous one.</source>
          <target state="translated">인증서 체인의 각 인증서는 이전 인증서에서 발급됩니다.</target>
        </trans-unit>
        <trans-unit id="69b524a56767c5a464e26aa46fb5fd446cb873ad" translate="yes" xml:space="preserve">
          <source>Each channel is an isolated &quot;pipe&quot; between a client-side process and a server-side process. Thoose process pairs could handle for example file transfers (sftp) or remote command execution (shell, exec and/or cli). If a custom shell is implemented, the user of the client could execute the special commands remotely. Note that the user is not necessarily a human but probably a system interfacing the SSH app.</source>
          <target state="translated">각 채널은 클라이언트 쪽 프로세스와 서버 쪽 프로세스 사이의 격리 된 &quot;파이프&quot;입니다. 선택한 프로세스 쌍은 예를 들어 파일 전송 (sftp) 또는 원격 명령 실행 (shell, exec 및 / 또는 cli)을 처리 할 수 ​​있습니다. 사용자 정의 쉘이 구현되면 클라이언트 사용자가 특수 명령을 원격으로 실행할 수 있습니다. 사용자는 반드시 사람 일 필요는 없지만 SSH 앱을 인터페이스하는 시스템 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfca402560954e5b142511c310fe441400c48117" translate="yes" xml:space="preserve">
          <source>Each channel is an isolated &quot;pipe&quot; between a client-side process and a server-side process. Those process pairs could handle for example file transfers (sftp) or remote command execution (shell, exec and/or cli). If a custom shell is implemented, the user of the client could execute the special commands remotely. Note that the user is not necessarily a human but probably a system interfacing the SSH app.</source>
          <target state="translated">각 채널은 클라이언트 측 프로세스와 서버 측 프로세스 사이의 분리 된 &quot;파이프&quot;입니다. 이러한 프로세스 쌍은 예를 들어 파일 전송 (sftp) 또는 원격 명령 실행 (shell, exec 및 / 또는 cli)을 처리 할 수 ​​있습니다. 사용자 지정 셸이 구현되면 클라이언트 사용자가 원격으로 특수 명령을 실행할 수 있습니다. 사용자는 반드시 사람 일 필요는 없지만 SSH 앱과 인터페이스하는 시스템 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab979cd854906b4b575e775a64fa69a8a251b961" translate="yes" xml:space="preserve">
          <source>Each character has exactly one Unicode general category property, specified by a two-letter acronym. For compatibility with Perl, negation can be specified by including a circumflex between the opening brace and the property name. For example, \p{^Lu} is the same as \P{Lu}.</source>
          <target state="translated">각 문자에는 정확히 두 글자로 지정된 유니 코드 일반 범주 속성이 있습니다. Perl과의 호환성을 위해 여는 중괄호와 속성 이름 사이에 곡절 곡면을 포함시켜 부정을 지정할 수 있습니다. 예를 들어, \ p {^ Lu}는 \ P {Lu}와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee28d4558757e9383cb566bdb9b21b23482e6efe" translate="yes" xml:space="preserve">
          <source>Each character in the entry's name and value that cannot be expressed using the selected character encoding, is replaced by a string consisting of a U+0026 AMPERSAND character (&amp;amp;), a &quot;#&quot; (U+0023) character, one or more ASCII digits representing the Unicode code point of the character in base ten, and finally a &quot;;&quot; (U+003B) character.</source>
          <target state="translated">선택한 문자 인코딩을 사용하여 표현할 수없는 항목 이름 및 값의 각 문자는 U + 0026 앰퍼샌드 문자 (&amp;amp;), &quot;#&quot;(U + 0023) 문자, 하나 이상의 ASCII로 구성된 문자열로 대체됩니다. 10 진 문자의 유니 코드 코드 포인트를 나타내는 숫자이며 마지막으로 &quot;;&quot; (U + 003B) 문자</target>
        </trans-unit>
        <trans-unit id="4e32cc8ee72e653d2a8bc902dfb063ec8881e171" translate="yes" xml:space="preserve">
          <source>Each character is stored in one to four bytes depending on code point. The encoding is backward compatible with bytewise representation of 7-bit ASCII, as all 7-bit characters are stored in one single byte in UTF-8. The characters beyond code point 127 are stored in more bytes, letting the most significant bit in the first character indicate a multi-byte character. For details on the encoding, the RFC is publicly available.</source>
          <target state="translated">각 문자는 코드 포인트에 따라 1-4 바이트로 저장됩니다. 모든 7 비트 문자가 UTF-8에서 하나의 단일 바이트에 저장되므로 인코딩은 7 비트 ASCII의 바이트 단위 표현과 역 호환됩니다. 코드 포인트 127 이후의 문자는 더 많은 바이트에 저장되므로 첫 번째 문자에서 최상위 비트가 멀티 바이트 문자를 나타낼 수 있습니다. 인코딩에 대한 자세한 내용은 RFC를 공개적으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4fc3cbdbc904d26469c742d8bcc9d626c6068c21" translate="yes" xml:space="preserve">
          <source>Each client and server in &lt;code&gt;Inets&lt;/code&gt; is viewed as a service. Services can be configured to be started at application startup or dynamically in runtime. To run &lt;code&gt;Inets&lt;/code&gt; as a distributed application that handles application failover and takeover, configure the services to be started at application startup. When starting the &lt;code&gt;Inets&lt;/code&gt; application, the &lt;code&gt;Inets&lt;/code&gt; top supervisor starts a number of subsupervisors and worker processes for handling the provided services. When starting services dynamically, new children are added to the supervision tree, unless the service is started with the standalone option. In this case the service is linked to the calling process and all OTP application features, such as soft upgrade, are lost.</source>
          <target state="translated">&lt;code&gt;Inets&lt;/code&gt; 의 각 클라이언트와 서버 는 서비스로 간주됩니다. 서비스는 응용 프로그램 시작시 또는 런타임에 동적으로 시작되도록 구성 할 수 있습니다. 응용 프로그램 장애 조치 및 인계를 처리하는 분산 응용 프로그램으로 &lt;code&gt;Inets&lt;/code&gt; 를 실행하려면 응용 프로그램 시작시 시작되도록 서비스를 구성하십시오. &lt;code&gt;Inets&lt;/code&gt; 애플리케이션을 시작할 때 &lt;code&gt;Inets&lt;/code&gt; 최고 수퍼바이저는 제공된 서비스를 처리하기 위해 여러 하위 수퍼바이저와 작업자 프로세스를 시작합니다. 서비스를 동적으로 시작할 때 서비스가 독립형 옵션으로 시작되지 않는 한 새 하위가 감독 트리에 추가됩니다. 이 경우 서비스가 호출 프로세스에 연결되고 소프트 업그레이드와 같은 모든 OTP 응용 프로그램 기능이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="ea67a6cd5709298d77de8bb9187376f1a4c88dd1" translate="yes" xml:space="preserve">
          <source>Each connection may have its own configuration of callback modules, re-send timers, transaction id ranges etc. and they may be re-configured on-the-fly.</source>
          <target state="translated">각 연결에는 콜백 모듈, 재전송 타이머, 트랜잭션 ID 범위 등의 자체 구성이있을 수 있으며 즉석에서 재구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20dd79dc25ece038d84ac0a232d7057d3f1bdbf6" translate="yes" xml:space="preserve">
          <source>Each directory in the path to the requested asset is searched for an access file (default is &lt;code&gt;.htaccess&lt;/code&gt;), which restricts the web servers rights to respond to a request. If an access file is found, the rules in that file is applied to the request.</source>
          <target state="translated">요청 된 자산 경로의 각 디렉토리에서 액세스 파일 (기본값은 &lt;code&gt;.htaccess&lt;/code&gt; )을 검색 하여 웹 서버 권한이 요청에 응답하도록 제한합니다. 액세스 파일을 찾으면 해당 파일의 규칙이 요청에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b25bd9fdb05a15b59ad44d21195b54cd7e275826" translate="yes" xml:space="preserve">
          <source>Each driver instance is associated with a port. Every port has a port owner process. Communication with the port is normally done through the port owner process. Most of the functions take the &lt;code&gt;port&lt;/code&gt; handle as an argument. This identifies the driver instance. Notice that this port handle must be stored by the driver, it is not given when the driver is called from the emulator (see &lt;code&gt;&lt;a href=&quot;driver_entry#emulator&quot;&gt; driver_entry&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">각 드라이버 인스턴스는 포트와 연결됩니다. 모든 포트에는 포트 소유자 프로세스가 있습니다. 포트와의 통신은 일반적으로 포트 소유자 프로세스를 통해 수행됩니다. 대부분의 함수는 &lt;code&gt;port&lt;/code&gt; 핸들을 인수로 사용합니다. 이것은 드라이버 인스턴스를 식별합니다. 이 포트 핸들은 드라이버에 의해 저장되어야하며 드라이버가 에뮬레이터에서 호출 될 때 제공되지 않습니다 ( &lt;code&gt;&lt;a href=&quot;driver_entry#emulator&quot;&gt; driver_entry&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2e833d3f6d71147154bc1a01e9a0319de7a5932f" translate="yes" xml:space="preserve">
          <source>Each driver instance is associated with a port. Every port has a port owner process. Communication with the port is normally done through the port owner process. Most of the functions take the &lt;code&gt;port&lt;/code&gt; handle as an argument. This identifies the driver instance. Notice that this port handle must be stored by the driver, it is not given when the driver is called from the emulator (see &lt;code&gt;&lt;a href=&quot;driver_entry#emulator&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">각 드라이버 인스턴스는 포트와 연결됩니다. 모든 포트에는 포트 소유자 프로세스가 있습니다. 포트와의 통신은 일반적으로 포트 소유자 프로세스를 통해 수행됩니다. 대부분의 함수는 &lt;code&gt;port&lt;/code&gt; 핸들을 인수로 사용합니다. 드라이버 인스턴스를 식별합니다. 이 포트 핸들은 드라이버에 의해 저장되어야하며 드라이버가 에뮬레이터에서 호출 될 때 제공되지 않습니다 ( &lt;code&gt;&lt;a href=&quot;driver_entry#emulator&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="56bbcc2fd8950bda744a20f900b28a4f1c7248c3" translate="yes" xml:space="preserve">
          <source>Each element &lt;code&gt;Ei&lt;/code&gt; specifies a &lt;strong&gt;segment&lt;/strong&gt; of the bit string. Each element &lt;code&gt;Ei&lt;/code&gt; is a value, followed by an optional &lt;strong&gt;size expression&lt;/strong&gt; and an optional &lt;strong&gt;type specifier list&lt;/strong&gt;.</source>
          <target state="translated">각 요소 &lt;code&gt;Ei&lt;/code&gt; 는 비트 열의 &lt;strong&gt;세그먼트&lt;/strong&gt; 를 지정한다 . 각 요소 &lt;code&gt;Ei&lt;/code&gt; 는 값이며, 선택적 &lt;strong&gt;크기 표현식&lt;/strong&gt; 과 선택적 &lt;strong&gt;유형 지정자 목록이 이어&lt;/strong&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="003d91a46f3f2bb18a1d90076a666cbaafc26e27" translate="yes" xml:space="preserve">
          <source>Each element specifies a certain &lt;strong&gt;segment&lt;/strong&gt; of the bitstring. A segment is a set of contiguous bits of the binary (not necessarily on a byte boundary). The first element specifies the initial segment, the second element specifies the following segment, and so on.</source>
          <target state="translated">각 요소 는 비트 열의 특정 &lt;strong&gt;세그먼트&lt;/strong&gt; 를 지정합니다 . 세그먼트는 이진의 연속적인 비트 집합입니다 (반드시 바이트 경계에있을 필요는 없음). 첫 번째 요소는 초기 세그먼트를 지정하고 두 번째 요소는 다음 세그먼트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5dc571d2da8f66291be308f1e1c565752924414f" translate="yes" xml:space="preserve">
          <source>Each employee works on a number of projects, hence the &lt;code&gt;in_proj&lt;/code&gt; relationship.</source>
          <target state="translated">각 직원은 여러 프로젝트에서 작업하므로 &lt;code&gt;in_proj&lt;/code&gt; 관계입니다.</target>
        </trans-unit>
        <trans-unit id="94646e4e155f2a1439c478997cfa6928f0711fd2" translate="yes" xml:space="preserve">
          <source>Each entry in the resulting list contains the following corresponding information about the program forms:</source>
          <target state="translated">결과 목록의 각 항목에는 프로그램 양식에 대한 다음과 같은 해당 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="864db500c08a498afdb397e4ebfd890146597d0d" translate="yes" xml:space="preserve">
          <source>Each entry is a term:</source>
          <target state="translated">각 항목은 다음과 같은 용어입니다.</target>
        </trans-unit>
        <trans-unit id="70625b8b976b15fa4bf08d632aae581c8cb53c9f" translate="yes" xml:space="preserve">
          <source>Each entry is a tuple of size four:</source>
          <target state="translated">각 항목은 크기가 4 인 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="ef1dcdb71453a9f45d4f9107238b7424b3b3c1cb" translate="yes" xml:space="preserve">
          <source>Each entry is a tuple of size two:</source>
          <target state="translated">각 항목은 크기가 2 인 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="a06e8aaaa5386a6a92b409b8c6444e276227cb07" translate="yes" xml:space="preserve">
          <source>Each entry is a tuple:</source>
          <target state="translated">각 항목은 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="d485e82d6d63995f59c4df6b1bc20bfb19eec6ff" translate="yes" xml:space="preserve">
          <source>Each entry is one of the terms, one entry corresponds to one row in one of the tables.</source>
          <target state="translated">각 항목은 용어 중 하나이며, 하나의 항목은 테이블 중 하나의 한 행에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4b7bb37e8a1565d711f264425424279d0037ae37" translate="yes" xml:space="preserve">
          <source>Each event handler is implemented as a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</source>
          <target state="translated">각 이벤트 핸들러는 사전 정의 된 함수 세트를 내보내는 콜백 모듈로 구현됩니다. 비헤이비어 함수와 콜백 함수의 관계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2b50254a125e7c325c0c24b3cf7ecc55cb97d9a" translate="yes" xml:space="preserve">
          <source>Each execution of a match specification is done against a match target term. The format and content of the target term depends on the context in which the match is done. The match target for ETS is always a full table tuple. The match target for call trace is always a list of all function arguments. The match target for event trace depends on the event type, see table below.</source>
          <target state="translated">일치 스펙의 각 실행은 일치 대상 용어에 대해 수행됩니다. 대상 용어의 형식과 내용은 일치하는 컨텍스트에 따라 다릅니다. ETS의 일치 대상은 항상 전체 테이블 튜플입니다. 호출 추적에 대한 일치 대상은 항상 모든 함수 인수의 목록입니다. 이벤트 추적에 대한 일치 대상은 이벤트 유형에 따라 다릅니다 (아래 표 참조).</target>
        </trans-unit>
        <trans-unit id="6e17c8755f13e7dc1db4b809ecd86d0b89dadb10" translate="yes" xml:space="preserve">
          <source>Each field in a record declaration can have an optional, explicit, default initializer expression, and an optional type.</source>
          <target state="translated">레코드 선언의 각 필드는 선택적, 명시 적, 기본 이니셜 라이저 표현식 및 선택적 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35a4d77421dde7b897b30082bb04311e87287900" translate="yes" xml:space="preserve">
          <source>Each file in the list will be read and processed separately. For every file, each reference to some module M, such that there is an entry &lt;code&gt;{&amp;lt;em&amp;gt;M&amp;lt;/em&amp;gt;, &amp;lt;em&amp;gt;M1&amp;lt;/em&amp;gt;}&lt;/code&gt; in &lt;code&gt;Renamings&lt;/code&gt;, will be changed to the corresponding M1. Furthermore, if a file F defines module M, and there is an entry &lt;code&gt;{&amp;lt;em&amp;gt;M&amp;lt;/em&amp;gt;, &amp;lt;em&amp;gt;M1&amp;lt;/em&amp;gt;}&lt;/code&gt; in &lt;code&gt;Renamings&lt;/code&gt;, a new file named &lt;code&gt;&amp;lt;em&amp;gt;M1&amp;lt;/em&amp;gt;.erl&lt;/code&gt; will be created in the same directory as F, containing the source code for module M, renamed to M1. If M does not have an entry in &lt;code&gt;Renamings&lt;/code&gt;, the module is not renamed, only updated, and the resulting source code is written to &lt;code&gt;&amp;lt;em&amp;gt;M&amp;lt;/em&amp;gt;.erl&lt;/code&gt; (typically, this overwrites the original file). The &lt;code&gt;suffix&lt;/code&gt; option (see below) can be used to change the default &quot;&lt;code&gt;.erl&lt;/code&gt;&quot; suffix for the generated files.</source>
          <target state="translated">목록의 각 파일은 개별적으로 읽고 처리됩니다. 모든 파일에 대해, 일부 모듈 M에 대한 각 참조는 항목이되도록 &lt;code&gt;{&amp;lt;em&amp;gt;M&amp;lt;/em&amp;gt;, &amp;lt;em&amp;gt;M1&amp;lt;/em&amp;gt;}&lt;/code&gt; 에 &lt;code&gt;Renamings&lt;/code&gt; 해당 M1로 변경한다. 또한 파일 F가 모듈 M을 정의 하고 &lt;code&gt;Renamings&lt;/code&gt; 에 항목 &lt;code&gt;{&amp;lt;em&amp;gt;M&amp;lt;/em&amp;gt;, &amp;lt;em&amp;gt;M1&amp;lt;/em&amp;gt;}&lt;/code&gt; 이 있으면 &lt;code&gt;&amp;lt;em&amp;gt;M1&amp;lt;/em&amp;gt;.erl&lt;/code&gt; 이라는 새 파일이 있습니다. erl 은 모듈 M의 소스 코드가 포함 된 F와 동일한 디렉토리에 M1로 이름이 변경됩니다. M에 &lt;code&gt;Renamings&lt;/code&gt; 에 항목 이 없으면 모듈 이름 이 바뀌지 않고 업데이트 만되며 결과 소스 코드는 &lt;code&gt;&amp;lt;em&amp;gt;M&amp;lt;/em&amp;gt;.erl&lt;/code&gt; (일반적으로,원본 파일을 덮어 씁니다.) 그만큼 &lt;code&gt;suffix&lt;/code&gt; 옵션 (아래 참조)을 사용 하여 생성 된 파일 의 기본 &quot; &lt;code&gt;.erl&lt;/code&gt; &quot;접미사 를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49eefe6dc97d048f34dac5cabf7a205b16b70416" translate="yes" xml:space="preserve">
          <source>Each filter set consists of a &lt;strong&gt;log level check&lt;/strong&gt;, followed by zero or more &lt;strong&gt;filter functions&lt;/strong&gt;.</source>
          <target state="translated">각 필터 세트는 &lt;strong&gt;로그 레벨 검사&lt;/strong&gt; 와 0 개 이상의 &lt;strong&gt;필터 기능으로 구성&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a9677f896b4c452b2ab214f54b61495167737353" translate="yes" xml:space="preserve">
          <source>Each function takes the argument &lt;code&gt;NameDb&lt;/code&gt;, which is a tuple &lt;code&gt;{Name, Db}&lt;/code&gt;, to identify which database the functions should use. &lt;code&gt;Name&lt;/code&gt; is the symbolic name of the managed object as defined in the MIB, and &lt;code&gt;Db&lt;/code&gt; is either &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;persistent&lt;/code&gt;, or &lt;code&gt;mnesia&lt;/code&gt;. If it is &lt;code&gt;mnesia&lt;/code&gt;, all variables are stored in the Mnesia table &lt;code&gt;snmp_variables&lt;/code&gt; which must be a table with two attributes (not a Mnesia SNMP table). The SNMP tables are stored in Mnesia tables with the same names as the SNMP tables. All functions assume that a Mnesia table exists with the correct name and attributes. It is the programmer's responsibility to ensure this. Specifically, if variables are stored in Mnesia, the table &lt;code&gt;snmp_variables&lt;/code&gt; must be created by the programmer. The record definition for this table is defined in the file &lt;code&gt;snmp/include/snmp_types.hrl&lt;/code&gt;.</source>
          <target state="translated">각 함수는 인수로 사용할 데이터베이스를 식별하기 위해 튜플 &lt;code&gt;{Name, Db}&lt;/code&gt; 인 &lt;code&gt;NameDb&lt;/code&gt; 인수 를 사용합니다. &lt;code&gt;Name&lt;/code&gt; 은 MIB에 정의 된 관리 대상 객체의 기호 이름이며 &lt;code&gt;Db&lt;/code&gt; 는 &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;persistent&lt;/code&gt; 또는 &lt;code&gt;mnesia&lt;/code&gt; 입니다. 그것이 &lt;code&gt;mnesia&lt;/code&gt; 인 경우 모든 변수는 Mnesia 테이블 &lt;code&gt;snmp_variables&lt;/code&gt; 에 저장됩니다Mnesia SNMP 테이블이 아닌 두 개의 속성이있는 테이블이어야합니다. SNMP 테이블은 SNMP 테이블과 동일한 이름으로 Mnesia 테이블에 저장됩니다. 모든 함수는 Mnesia 테이블이 올바른 이름과 속성으로 존재한다고 가정합니다. 이를 보장하는 것은 프로그래머의 책임입니다. 특히 변수가 Mnesia에 저장된 경우 프로그래머가 &lt;code&gt;snmp_variables&lt;/code&gt; 테이블을 작성 해야합니다. 이 테이블의 레코드 정의는 &lt;code&gt;snmp/include/snmp_types.hrl&lt;/code&gt; 파일에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c3a776596635896e94dd107e595da2486f16447" translate="yes" xml:space="preserve">
          <source>Each generic instruction has an opcode. The opcode is an integer, greater than or equal to 1. For an external generic instruction, it must be explicitly given &lt;code&gt;genop.tab&lt;/code&gt;, while internal generic instructions are automatically numbered by &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="translated">각 일반 명령어에는 opcode가 있습니다. opcode는 1보다 크거나 같은 정수입니다. 외부 일반 명령어의 경우 명시 적으로 &lt;code&gt;genop.tab&lt;/code&gt; 을 지정해야 하며 내부 일반 명령어는 자동으로 &lt;strong&gt;beam_makeops&lt;/strong&gt; 번호가 &lt;strong&gt;지정&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="4c1190978962592425d6b4592ae603c7ba88ca4d" translate="yes" xml:space="preserve">
          <source>Each instance of &lt;code&gt;ErlNifResourceType&lt;/code&gt; represents a class of memory-managed resource objects that can be garbage collected. Each resource type has a unique name and a destructor function that is called when objects of its type are released.</source>
          <target state="translated">&lt;code&gt;ErlNifResourceType&lt;/code&gt; 의 각 인스턴스는 가비지 수집 될 수있는 메모리 관리 리소스 개체 클래스를 나타냅니다. 각 자원 유형에는 고유 한 이름과 해당 유형의 오브젝트가 해제 될 때 호출되는 소멸자 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e1ea35cab57f7ba717000c69e30acd0ba46d49" translate="yes" xml:space="preserve">
          <source>Each key part is 64 bits (in CBC mode only 8 bits are used)</source>
          <target state="translated">각 키 부분은 64 비트입니다 (CBC 모드에서는 8 비트 만 사용됨)</target>
        </trans-unit>
        <trans-unit id="35103fefad295298276e9cfdc33729d99099ac1d" translate="yes" xml:space="preserve">
          <source>Each key-value association in the map is called an &lt;strong&gt;association pair&lt;/strong&gt;. The key and value parts of the pair are called &lt;strong&gt;elements&lt;/strong&gt;. The number of association pairs is said to be the &lt;strong&gt;size&lt;/strong&gt; of the map.</source>
          <target state="translated">맵의 각 키-값 연관을 &lt;strong&gt;연관 쌍&lt;/strong&gt; 이라고합니다 . 쌍의 키와 값 부분을 &lt;strong&gt;요소&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; . 연관 쌍의 수 는 맵 의 &lt;strong&gt;크기&lt;/strong&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="603c93584be31e061e41c3144cba0c9593d7cc4e" translate="yes" xml:space="preserve">
          <source>Each list element is copied only once. The growing result &lt;code&gt;Acc&lt;/code&gt; is the right operand for the &lt;code&gt;++&lt;/code&gt; operator, and it is &lt;strong&gt;not&lt;/strong&gt; copied.</source>
          <target state="translated">각 목록 요소는 한 번만 복사됩니다. 증가하는 결과 &lt;code&gt;Acc&lt;/code&gt; 는 &lt;code&gt;++&lt;/code&gt; 연산자에 대한 올바른 피연산자이며 복사 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="53cec8595242fffcee11b05ab4b26518e9f93ca7" translate="yes" xml:space="preserve">
          <source>Each managed object can exist in many instances within a SNMP entity. To identify the instances, specified by an MIB module, a method to distinguish the actual instance by its 'scope' or context is used. Often the context is a physical or a logical device. It can include multiple devices, a subset of a single device or a subset of multiple devices, but the context is always defined as a subset of a single SNMP entity. To be able to identify a specific item of management information within an SNMP entity, the context, the object type and its instance must be used.</source>
          <target state="translated">각 관리 대상 개체는 SNMP 엔터티 내의 여러 인스턴스에 존재할 수 있습니다. MIB 모듈에 의해 지정된 인스턴스를 식별하기 위해 실제 범위를 '범위'또는 컨텍스트로 구별하는 방법이 사용됩니다. 문맥은 종종 물리적 또는 논리적 장치입니다. 여기에는 여러 장치, 단일 장치의 하위 집합 또는 여러 장치의 하위 집합이 포함될 수 있지만 컨텍스트는 항상 단일 SNMP 엔터티의 하위 집합으로 정의됩니다. SNMP 엔티티 내에서 특정 관리 정보 항목을 식별하려면 컨텍스트, 오브젝트 유형 및 해당 인스턴스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="19f263cbfb73620501381b721ea1278aa4679eb0" translate="yes" xml:space="preserve">
          <source>Each match spec in the file ends with a full stop (&lt;code&gt;.&lt;/code&gt;) and new (syntactically correct) match specifications can be added to the file manually.</source>
          <target state="translated">파일의 각 일치 스펙은 전체 중지 ( &lt;code&gt;.&lt;/code&gt; )로 끝나고 새 (구문 적으로 올바른) 일치 스펙을 파일에 수동으로 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="452318e4e784ce1e7d0ad04612ebccef8576f3c0" translate="yes" xml:space="preserve">
          <source>Each megaco application maintains its own set of counters. So in a large (distributed) MG/MGC it could be necessary to collect the statistics from several nodes (each) running the megaco application (only one of them with the transport).</source>
          <target state="translated">각 megaco 응용 프로그램은 자체 카운터 세트를 유지 관리합니다. 따라서 대규모 (분산 된) MG / MGC에서 megaco 응용 프로그램을 실행하는 여러 노드 (각각)에서 통계를 수집해야합니다 (전송이있는 노드 중 하나만).</target>
        </trans-unit>
        <trans-unit id="4a78fbb6a60dc9e6fef3ef416e95740b3e7b0bfe" translate="yes" xml:space="preserve">
          <source>Each module that implements server functionality using the Erlang web server API is to implement the following call back functions:</source>
          <target state="translated">Erlang 웹 서버 API를 사용하여 서버 기능을 구현하는 각 모듈은 다음 콜백 함수를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="93853d05ce58ebbbdc0ba0d0956af3c6652ad3e5" translate="yes" xml:space="preserve">
          <source>Each name in &lt;code&gt;Element_List&lt;/code&gt; must be a constructed type except the last name, which can be any type.</source>
          <target state="translated">&lt;code&gt;Element_List&lt;/code&gt; 의 각 이름은 성을 제외한 생성 된 유형이어야하며 어떤 유형이든 가능합니다.</target>
        </trans-unit>
        <trans-unit id="01165d972ec961ccac57f0f5b0159f2b826a6985" translate="yes" xml:space="preserve">
          <source>Each normal scheduler has one run queue that it manages. If dirty schedulers schedulers are supported, all dirty CPU schedulers share one run queue, and all dirty IO schedulers share one run queue. That is, we have multiple normal run queues, one dirty CPU run queue and one dirty IO run queue. Work can &lt;strong&gt;not&lt;/strong&gt; migrate between the different types of run queues. Only work in normal run queues can migrate to other normal run queues. This has to be taken into account when evaluating the result.</source>
          <target state="translated">각 일반 스케줄러에는 하나의 실행 큐가 관리합니다. 더티 스케줄러 스케줄러가 지원되면 모든 더티 CPU 스케줄러가 하나의 실행 큐를 공유하고 모든 더티 IO 스케줄러가 하나의 실행 큐를 공유합니다. 즉, 여러 개의 일반 실행 큐, 하나의 더티 CPU 실행 큐 및 하나의 더티 IO 실행 큐가 있습니다. 다른 유형의 실행 큐간에 작업을 마이그레이션 할 수 &lt;strong&gt;없습니다&lt;/strong&gt; . 일반 실행 큐의 작업 만 다른 일반 실행 큐로 마이그레이션 할 수 있습니다. 결과를 평가할 때이 점을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="353f12c04da0c03581d99ccf42ebe1a0217c5270" translate="yes" xml:space="preserve">
          <source>Each of the &lt;code&gt;...&lt;/code&gt; can be a &lt;code&gt;algs_list()&lt;/code&gt; as the argument to the &lt;code&gt;preferred_algorithms&lt;/code&gt; option.</source>
          <target state="translated">각 &lt;code&gt;...&lt;/code&gt; 은 &lt;code&gt;preferred_algorithms&lt;/code&gt; 옵션 의 인수로 &lt;code&gt;algs_list()&lt;/code&gt; 가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d164e93e542a99949cf0db6b6c3b3b7a076d10ae" translate="yes" xml:space="preserve">
          <source>Each of the following examples shows a simple system configuration file that configures Logger according to the description.</source>
          <target state="translated">다음 각 예는 설명에 따라 로거를 구성하는 간단한 시스템 구성 파일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4dbc90fa1fdea3ab66bbf8b0c21d295490ffe46d" translate="yes" xml:space="preserve">
          <source>Each of the following macros takes a single &lt;code&gt;ETERM&lt;/code&gt; pointer as an argument. The macros return a non-zero value if the test is true, otherwise &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">다음 매크로 각각은 단일 &lt;code&gt;ETERM&lt;/code&gt; 포인터를 인수로 사용합니다. 테스트가 true이면 매크로는 0이 아닌 값을 반환하고, 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="179773253948546e5bdc1e564395d6ef5da831bc" translate="yes" xml:space="preserve">
          <source>Each of the functions described below accept either the filename (as a string) or a binary containing the BEAM module.</source>
          <target state="translated">아래에 설명 된 각 함수는 파일 이름 (문자열) 또는 BEAM 모듈을 포함하는 바이너리를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="71dbb11141d1b29bdf605883a9525fa04b5926c7" translate="yes" xml:space="preserve">
          <source>Each of the functions described below accept either the module name, the filename, or a binary containing the BEAM module.</source>
          <target state="translated">아래 설명 된 각 기능은 모듈 이름, 파일 이름 또는 BEAM 모듈을 포함하는 이진을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8027ec76b3d9944bc76e04598ff295232263ba37" translate="yes" xml:space="preserve">
          <source>Each operand of a generic instruction is tagged with its type. A generic instruction can have one of the following types:</source>
          <target state="translated">일반 명령어의 각 피연산자는 해당 유형으로 태그가 지정됩니다. 일반 명령어는 다음 유형 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a9a70f579bb2d61aec78b5a4d09bff55e0674f" translate="yes" xml:space="preserve">
          <source>Each pair of lowercase and uppercase escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair. The sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all fail, as there is no character to match.</source>
          <target state="translated">소문자와 대문자 이스케이프 시퀀스의 각 쌍은 완전한 문자 세트를 두 개의 분리 된 세트로 분할합니다. 주어진 문자는 각 쌍 중 하나만 일치합니다. 시퀀스는 내부 및 외부의 문자 클래스 모두에 나타날 수 있습니다. 이들은 각각 적절한 유형의 한 문자와 일치합니다. 현재 일치 지점이 제목 문자열의 끝에 있으면 일치하는 문자가 없으므로 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5f109778bad8f5715e79853119dab9d94dca5e64" translate="yes" xml:space="preserve">
          <source>Each port is protected by its own lock to protect against simultaneous execution in multiple threads. Previously when a process, executing on a scheduler thread, sent a port a signal, it locked the port lock and synchronously executed the code corresponding to the signal. If the lock was busy, the scheduler thread blocked waiting until it could lock the lock. If multiple processes executing simultaneously on different scheduler threads, sent signals to the same port, schedulers suffered from heavy lock contention. Such contention could also occur between I/O signals for the port executing on one scheduler thread, and a signal from a process to the port executing on another scheduler thread. Beside the contention issues, we also loose potential work to execute in parallel on different scheduler threads. This since the process sending the &lt;strong&gt;asynchronous&lt;/strong&gt; signal is blocked while the code implementing the signal is executed synchronously.</source>
          <target state="translated">각 포트는 여러 스레드에서 동시에 실행되는 것을 방지하기 위해 자체 잠금으로 보호됩니다. 이전에는 스케줄러 스레드에서 실행되는 프로세스가 포트에 신호를 보낼 때 포트 잠금을 잠그고 신호에 해당하는 코드를 동 기적으로 실행했습니다. 잠금이 사용 중이면 스케줄러 스레드가 잠금을 잠글 수있을 때까지 대기하는 것을 차단했습니다. 여러 프로세스가 서로 다른 스케줄러 스레드에서 동시에 실행되고 동일한 포트로 신호를 보내면 스케줄러에 과도한 잠금 경합이 발생했습니다. 이러한 경합은 하나의 스케줄러 스레드에서 실행되는 포트에 대한 I / O 신호와 프로세스에서 다른 스케줄러 스레드에서 실행중인 포트로의 신호간에 발생할 수도 있습니다. 경합 문제 외에도 다른 스케줄러 스레드에서 병렬로 실행할 잠재적 인 작업을 잃어 버립니다. 이것은 전송 프로세스 이후&lt;strong&gt;&lt;/strong&gt;신호를 구현하는 코드가 동 기적으로 실행되는 동안 &lt;strong&gt;비동기&lt;/strong&gt; 신호는 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="541ed98ae654af7db259dfc961c4315c8d1d922e" translate="yes" xml:space="preserve">
          <source>Each predefined analysis is a shorthand for a &lt;code&gt;&lt;a href=&quot;xref#query&quot;&gt;query&lt;/a&gt;&lt;/code&gt;, a sentence of a tiny language providing cross reference data as values of &lt;code&gt;&lt;a href=&quot;xref#predefined_variable&quot;&gt;predefined variables&lt;/a&gt;&lt;/code&gt;. The check for calls to undefined functions can thus be stated as a query:</source>
          <target state="translated">각각의 사전 정의 된 분석은 &lt;code&gt;&lt;a href=&quot;xref#predefined_variable&quot;&gt;predefined variables&lt;/a&gt;&lt;/code&gt; 값으로 상호 참조 데이터를 제공하는 작은 언어의 문장 인 &lt;code&gt;&lt;a href=&quot;xref#query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; 의 약어입니다 . 정의되지 않은 함수에 대한 호출 확인은 쿼리로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3bb6f4a5547e885fc3c22cefa6ca8cc6b8272be" translate="yes" xml:space="preserve">
          <source>Each process can only be traced by one tracer. Therefore, attempts to trace an already traced process fail.</source>
          <target state="translated">각 프로세스는 하나의 추적 프로그램 만 추적 할 수 있습니다. 따라서 이미 추적 된 프로세스를 추적하려는 시도는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f53dfe1cf607f1f76b3cdacc1a7c9ad3df04d899" translate="yes" xml:space="preserve">
          <source>Each process encodes and decodes their messages. The number of messages processed in total (for all processes) is the mstone value.</source>
          <target state="translated">각 프로세스는 메시지를 인코딩하고 디코딩합니다. 전체적으로 (모든 프로세스에 대해) 처리 된 메시지 수는 mstone 값입니다.</target>
        </trans-unit>
        <trans-unit id="8ce0c9866e7ef56611d672edfd84466b1d3ddb78" translate="yes" xml:space="preserve">
          <source>Each process has a &lt;strong&gt;trace token&lt;/strong&gt;, which can be empty or not empty. When not empty, the trace token can be seen as the tuple &lt;code&gt;{Label, Flags, Serial, From}&lt;/code&gt;. The trace token is passed invisibly when information is passed between processes. In most cases the information is passed in ordinary messages between processes, but information is also passed between processes by other means. For example, by spawning a new process. An information transfer between two processes is represented by a send event and a receive event regardless of how it is passed.</source>
          <target state="translated">각 프로세스에는 비어 있거나 비어 있지 않을 수 있는 &lt;strong&gt;추적 토큰&lt;/strong&gt; 이 있습니다. 비어 있지 않은 경우 추적 토큰은 &lt;code&gt;{Label, Flags, Serial, From}&lt;/code&gt; 튜플로 볼 수 있습니다 . 추적 토큰은 프로세스간에 정보가 전달 될 때 보이지 않게 전달됩니다. 대부분의 경우 정보는 프로세스간에 일반 메시지로 전달되지만 정보는 다른 방법으로 프로세스 간에도 전달됩니다. 예를 들어, 새 프로세스를 생성합니다. 두 프로세스 간의 정보 전송은 전달 방법에 관계없이 전송 이벤트와 수신 이벤트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a21488145b83b166a252047079205488e77b957" translate="yes" xml:space="preserve">
          <source>Each process has a &lt;strong&gt;trace token&lt;/strong&gt;, which can be empty or not empty. When not empty, the trace token can be seen as the tuple &lt;code&gt;{Label, Flags, Serial, From}&lt;/code&gt;. The trace token is passed invisibly with each message.</source>
          <target state="translated">각 프로세스에는 비어 있거나 비어 있지 않은 &lt;strong&gt;추적 토큰&lt;/strong&gt; 이 있습니다. 비어 있지 않으면 추적 토큰은 튜플 &lt;code&gt;{Label, Flags, Serial, From}&lt;/code&gt; 로 볼 수 있습니다 . 추적 토큰은 각 메시지와 함께 보이지 않게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="62f3da47feea5422680300f867c5ab0500b7eef7" translate="yes" xml:space="preserve">
          <source>Each process has a current trace token which is &quot;invisibly&quot; passed from the parent process on creation of the process.</source>
          <target state="translated">각 프로세스에는 프로세스 생성시 상위 프로세스에서 &quot;보이지 않게&quot;전달되는 현재 추적 토큰이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e73293ff85edf8b221fca58a7375966b63368aa5" translate="yes" xml:space="preserve">
          <source>Each process has a current trace token. Initially, the token is empty. When the process sends a message to another process, a copy of the current token is sent &quot;invisibly&quot; along with the message.</source>
          <target state="translated">각 프로세스에는 현재 추적 토큰이 있습니다. 처음에는 토큰이 비어 있습니다. 프로세스가 다른 프로세스로 메시지를 보내면 현재 토큰의 사본이 메시지와 함께 &quot;보이지 않게&quot;전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5144322b868d1af68042a24893fdf17ce8ae7e7a" translate="yes" xml:space="preserve">
          <source>Each process has a heap reserved for its use and no references between heaps of different processes are allowed. Messages passed between processes are copied between heaps.</source>
          <target state="translated">각 프로세스에는 사용을 위해 예약 된 힙이 있으며 다른 프로세스의 힙간에 참조가 허용되지 않습니다. 프로세스간에 전달 된 메시지는 힙간에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d795f27c853b15d567e346c313ca515710ccd7a9" translate="yes" xml:space="preserve">
          <source>Each process has a virtual binary heap associated with it that has the size of all the current off-heap binaries that the process has references to. The virtual binary heap also has a limit and grows and shrinks depending on how off-heap binaries are used by the process. The same growth and shrink mechanisms are used for the binary heap and for the term heap, so first a Fibonacci like series and then 20% growth.</source>
          <target state="translated">각 프로세스에는 프로세스가 참조하는 현재 오프 힙 바이너리의 크기를 가진 가상 바이너리 힙이 연결되어 있습니다. 가상 바이너리 힙에는 또한 한계가 있으며 프로세스에서 오프 힙 바이너리를 사용하는 방법에 따라 늘어나거나 줄어 듭니다. 바이너리 힙과 용어 힙에도 동일한 성장 및 축소 메커니즘이 사용되므로 먼저 피보나치 계열 계열과 20 % 성장이 차례로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="096913c6437e32f4cf474b346e119faa89b965e8" translate="yes" xml:space="preserve">
          <source>Each process has its own input queue for messages it receives. New messages received are put at the end of the queue. When a process executes a &lt;code&gt;receive&lt;/code&gt;, the first message in the queue is matched against the first pattern in the &lt;code&gt;receive&lt;/code&gt;. If this matches, the message is removed from the queue and the actions corresponding to the pattern are executed.</source>
          <target state="translated">각 프로세스에는 수신되는 메시지에 대한 자체 입력 대기열이 있습니다. 수신 된 새 메시지는 큐의 끝에 놓입니다. 프로세스가 실행되면 &lt;code&gt;receive&lt;/code&gt; (가)에서, 대기열의 첫 번째 메시지는 상기 제 1 패턴에 대해 매칭되는 &lt;code&gt;receive&lt;/code&gt; . 일치하면 메시지가 큐에서 제거되고 패턴에 해당하는 조치가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3a4ee2d15983f4a7bc92b54819b47d8c32a6e680" translate="yes" xml:space="preserve">
          <source>Each process has its own process dictionary, accessed by calling the following BIFs:</source>
          <target state="translated">각 프로세스에는 다음 BIF를 호출하여 액세스하는 자체 프로세스 사전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1effb1c4303b519ce39735425f5a670ab0dcb4b" translate="yes" xml:space="preserve">
          <source>Each release version has a status, which can be &lt;code&gt;unpacked&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;permanent&lt;/code&gt;, or &lt;code&gt;old&lt;/code&gt;. There is always one latest release, which either has status &lt;code&gt;permanent&lt;/code&gt; (normal case) or &lt;code&gt;current&lt;/code&gt; (installed, but not yet made permanent). The meaning of the status values are illustrated in the following table:</source>
          <target state="translated">각 릴리스 버전의 상태는 &lt;code&gt;unpacked&lt;/code&gt; , &lt;code&gt;current&lt;/code&gt; , &lt;code&gt;permanent&lt;/code&gt; 또는 &lt;code&gt;old&lt;/code&gt; 상태 일 수 있습니다 . 최신 릴리스는 항상 &lt;code&gt;permanent&lt;/code&gt; (일반 경우) 또는 &lt;code&gt;current&lt;/code&gt; (설치되었지만 아직 영구적이 아님) 상태입니다. 상태 값의 의미는 다음 표에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="b22912e88f3fff6681ff427aa02b35651d16061b" translate="yes" xml:space="preserve">
          <source>Each request &lt;code&gt;*_REQ&lt;/code&gt; is preceded by a 2 byte length field. Thus, the overall request format is as follows:</source>
          <target state="translated">각 요청 &lt;code&gt;*_REQ&lt;/code&gt; 앞에는 2 바이트 길이 필드가 있습니다. 따라서 전체 요청 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="214cfe9188b99ecc651497388a529d4ed886ff20" translate="yes" xml:space="preserve">
          <source>Each row defines a &lt;strong&gt;manager user&lt;/strong&gt; of the manager.</source>
          <target state="translated">각 행은 &lt;strong&gt;관리자&lt;/strong&gt; 의 &lt;strong&gt;관리자 사용자&lt;/strong&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ca374bc8a75c956aa890688fd1192654850ec9a4" translate="yes" xml:space="preserve">
          <source>Each row defines a context in the agent. This information is used in the table &lt;code&gt;vacmContextTable&lt;/code&gt; in the SNMP-VIEW-BASED-ACM-MIB.</source>
          <target state="translated">각 행은 에이전트의 컨텍스트를 정의합니다. 이 정보는 SNMP-VIEW-BASED-ACM-MIB의 &lt;code&gt;vacmContextTable&lt;/code&gt; 테이블에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8644f9741490487b00047e43487ce1247a0d6219" translate="yes" xml:space="preserve">
          <source>Each row specifies which security model to use, along with security level and security parameters.</source>
          <target state="translated">각 행은 보안 수준 및 보안 매개 변수와 함께 사용할 보안 모델을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2b467749361658abb4d12ab5e9dc82af9af422e5" translate="yes" xml:space="preserve">
          <source>Each scheduler thread has its own set of references, and all other threads have a shared set of references. Each set of references consist of &lt;code&gt;2⁶⁴ - 1&lt;/code&gt; unique references. That is, the total amount of unique references that can be produced on a runtime system instance is &lt;code&gt;(NoSchedulers + 1) &amp;times; (2⁶⁴ - 1)&lt;/code&gt;.</source>
          <target state="translated">각 스케줄러 스레드에는 고유 한 참조 세트가 있으며 다른 모든 스레드에는 공유 참조 세트가 있습니다. 각 참조 세트는 &lt;code&gt;2⁶⁴ - 1&lt;/code&gt; 고유 참조 로 구성됩니다 . 즉, 런타임 시스템 인스턴스에서 생성 될 수있는 고유 참조의 총량은 &lt;code&gt;(NoSchedulers + 1) &amp;times; (2⁶⁴ - 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd0f886f081fb98e606d025bb4bf36be701fdf0b" translate="yes" xml:space="preserve">
          <source>Each schema has a unique cookie, which can be regarded as a unique schema identifier. The cookie must be the same on all nodes where Mnesia is supposed to run. For details, see the User's Guide.</source>
          <target state="translated">각 스키마에는 고유 한 쿠키가 있으며 이는 고유 한 스키마 식별자로 간주 될 수 있습니다. 쿠키는 Mnesia가 실행될 모든 노드에서 동일해야합니다. 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="549337d666fba4ddace993e54e248a26130c024d" translate="yes" xml:space="preserve">
          <source>Each segment has the following general syntax:</source>
          <target state="translated">각 세그먼트에는 다음과 같은 일반적인 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cd372994dfc3344f859a57d088fd0676fe4b69b" translate="yes" xml:space="preserve">
          <source>Each segment in a binary can consist of zero or more bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size evenly divisible by 8 (or divisible by the unit size, if the unit size has been changed). A segment of type &lt;code&gt;bitstring&lt;/code&gt; has no restrictions on the size.</source>
          <target state="translated">이진의 각 세그먼트는 0 개 이상의 비트로 구성 될 수 있습니다. &lt;code&gt;binary&lt;/code&gt; 유형의 세그먼트는 8로 균등하게 나눌 수있는 크기를 가져야합니다 (또는 단위 크기가 변경된 경우 단위 크기로 나눌 수 있음). &lt;code&gt;bitstring&lt;/code&gt; 유형의 세그먼트 에는 크기에 대한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1aa9835051b7281d11e9f067f29f705681499a78" translate="yes" xml:space="preserve">
          <source>Each segment in a binary can consist of zero or more bits. A segment of type &lt;code&gt;binary&lt;/code&gt; must have a size evenly divisible by 8 (or divisible by the unit size, if the unit size has been changed). A segment of type &lt;code&gt;bitstring&lt;/code&gt; has no restrictions on the size. A segment of type &lt;code&gt;float&lt;/code&gt; must have size 64 or 32.</source>
          <target state="translated">바이너리의 각 세그먼트는 0 개 이상의 비트로 구성 될 수 있습니다. &lt;code&gt;binary&lt;/code&gt; 유형의 세그먼트는 8로 균등하게 나눌 수있는 크기 (또는 단위 크기가 변경된 경우 단위 크기로 나눌 수 있음)를 가져야합니다. &lt;code&gt;bitstring&lt;/code&gt; 유형의 세그먼트 에는 크기에 대한 제한이 없습니다. &lt;code&gt;float&lt;/code&gt; 유형의 세그먼트 는 크기가 64 또는 32 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f1671b1a7b09bbb4a1297d80f839111ba93c1ee9" translate="yes" xml:space="preserve">
          <source>Each segment in a binary can consist of zero or more bits. There are no alignment rules for individual segments of type &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt;. For binaries and bitstrings without size, the unit specifies the alignment. Since the default alignment for the &lt;code&gt;binary&lt;/code&gt; type is 8, the size of a binary segment must be a multiple of 8 bits, that is, only whole bytes.</source>
          <target state="translated">이진의 각 세그먼트는 0 개 이상의 비트로 구성 될 수 있습니다. &lt;code&gt;integer&lt;/code&gt; 및 &lt;code&gt;float&lt;/code&gt; 유형의 개별 세그먼트에 대한 정렬 규칙이 없습니다 . 크기가없는 이진 및 비트 열의 경우 단위는 정렬을 지정합니다. &lt;code&gt;binary&lt;/code&gt; 유형 의 기본 정렬 은 8이므로 이진 세그먼트의 크기는 8 비트의 배수, 즉 전체 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e9282b1591676f5d2f51bfb0beccffd06d1eb513" translate="yes" xml:space="preserve">
          <source>Each separate (variable) package is generated as a separate file in the same directory as the &lt;code&gt;ReleaseName.tar.gz&lt;/code&gt; file.</source>
          <target state="translated">각각의 개별 (변수) 패키지는 &lt;code&gt;ReleaseName.tar.gz&lt;/code&gt; 파일 과 동일한 디렉토리에 별도의 파일로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="024f41e5f9df7f8bc9804c8c5a80f4b99f3d7274" translate="yes" xml:space="preserve">
          <source>Each separate (variable) package is included in the main &lt;code&gt;ReleaseName.tar.gz&lt;/code&gt; file. This is the default.</source>
          <target state="translated">각 개별 (변수) 패키지는 기본 &lt;code&gt;ReleaseName.tar.gz&lt;/code&gt; 파일에 포함되어 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c3e8c329b13e4f651f71df7ff5c490cb04afca90" translate="yes" xml:space="preserve">
          <source>Each signal my be set to one of the following options:</source>
          <target state="translated">각 신호는 다음 옵션 중 하나로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="14b191f37496bd40bb6e48f5c7122d0518587ab2" translate="yes" xml:space="preserve">
          <source>Each specific instructions is defined by following the name of the instruction with the types for each operand. An operand type is a single letter. For example, &lt;code&gt;x&lt;/code&gt; means an X register, &lt;code&gt;y&lt;/code&gt; means a Y register, and &lt;code&gt;c&lt;/code&gt; is a &quot;constant&quot; (a tagged term such as an integer, an atom, or a literal).</source>
          <target state="translated">각 특정 명령어는 각 피연산자의 유형과 함께 명령어 이름을 따라 정의됩니다. 피연산자 유형은 단일 문자입니다. 예를 들어, &lt;code&gt;x&lt;/code&gt; 는 X 레지스터, &lt;code&gt;y&lt;/code&gt; 는 Y 레지스터, &lt;code&gt;c&lt;/code&gt; 는 &quot;상수&quot;(정수, 원자 또는 리터럴과 같은 태그 지정된 용어)를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4d75df3fed93d33a1b26f0df41aacf7a9c5e0bb4" translate="yes" xml:space="preserve">
          <source>Each sub-agent calls the instrumentation for its loaded MIBs.</source>
          <target state="translated">각 하위 에이전트는로드 된 MIB에 대해 계측을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a920af7f1bd15ab26a0a0f35363ebaf253b19753" translate="yes" xml:space="preserve">
          <source>Each sub-agent can implement its own mechanisms for &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;get-next&lt;/code&gt;. For example, if the application requires the &lt;code&gt;get&lt;/code&gt; mechanism to be asynchronous, or needs a N-phase &lt;code&gt;set&lt;/code&gt; mechanism, a specialized sub-agent should be used.</source>
          <target state="translated">각 하위 에이전트는 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;get-next&lt;/code&gt; 에 대한 자체 메커니즘을 구현할 수 있습니다 . 예를 들어, 응용 프로그램에 &lt;code&gt;get&lt;/code&gt; 메커니즘이 비동기 적이거나 N 단계 &lt;code&gt;set&lt;/code&gt; 메커니즘이 필요한 경우 특수 서브 에이전트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="82ff02bedfa4335374a1f6b3ca8faa6ef8a2d000" translate="yes" xml:space="preserve">
          <source>Each tab in the main window contains an information page. If no information is found for an item, the page is empty. The reason for not finding information about an item can be the following:</source>
          <target state="translated">기본 창의 각 탭에는 정보 페이지가 있습니다. 항목에 대한 정보가 없으면 페이지가 비어 있습니다. 항목에 대한 정보를 찾지 못한 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="552992daca4c23db6bff1830043b762334b97510" translate="yes" xml:space="preserve">
          <source>Each table retains its old contents in a checkpoint retainer. For performance critical applications, it can be important to realize the processing overhead associated with checkpoints. In a worst case scenario, the checkpoint retainer consumes more memory than the table itself. Also, each update becomes slightly slower on those nodes where checkpoint retainers are attached to the tables.</source>
          <target state="translated">각 테이블은 이전 내용을 체크 포인트 보유자에 보유합니다. 성능이 중요한 응용 프로그램의 경우 검사 점과 관련된 처리 오버 헤드를 실현하는 것이 중요 할 수 있습니다. 최악의 시나리오에서 검사 점 보유자는 테이블 자체보다 많은 메모리를 소비합니다. 또한 체크 포인트 리테이너가 테이블에 연결된 노드에서 각 업데이트가 약간 느려집니다.</target>
        </trans-unit>
        <trans-unit id="791a1f2a4037ba80b05edb94447b37b4e2364aa6" translate="yes" xml:space="preserve">
          <source>Each term &lt;code&gt;Term&lt;/code&gt; in the list is called an &lt;strong&gt;element&lt;/strong&gt;. The number of elements is said to be the &lt;strong&gt;length&lt;/strong&gt; of the list.</source>
          <target state="translated">각 용어 &lt;code&gt;Term&lt;/code&gt; 목록은이라고 &lt;strong&gt;요소&lt;/strong&gt; . 요소의 수 는 목록 의 &lt;strong&gt;길이&lt;/strong&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="ed00d75d5c4d6192c54f9d2b21cf805e6461e449" translate="yes" xml:space="preserve">
          <source>Each term &lt;code&gt;Term&lt;/code&gt; in the tuple is called an &lt;strong&gt;element&lt;/strong&gt;. The number of elements is said to be the &lt;strong&gt;size&lt;/strong&gt; of the tuple.</source>
          <target state="translated">각 용어 &lt;code&gt;Term&lt;/code&gt; 튜플의는이라고 &lt;strong&gt;요소&lt;/strong&gt; . 요소의 수 는 튜플 의 &lt;strong&gt;크기&lt;/strong&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="5abbd52c08a811a8e991cd9188a923d201e7731f" translate="yes" xml:space="preserve">
          <source>Each test case is executed by a dedicated Erlang process. The process is spawned when the test case starts, and terminated when the test case is finished. The configuration functions &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt; execute on the same process as the test case.</source>
          <target state="translated">각 테스트 케이스는 전용 Erlang 프로세스에 의해 실행됩니다. 테스트 케이스가 시작되면 프로세스가 생성되고 테스트 케이스가 완료되면 프로세스가 종료됩니다. &lt;code&gt;init_per_testcase&lt;/code&gt; 및 &lt;code&gt;end_per_testcase&lt;/code&gt; 구성 함수 는 테스트 케이스와 동일한 프로세스에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5c925270da28c693f61f4f9343e6c13b128264b9" translate="yes" xml:space="preserve">
          <source>Each test suite module can contain the optional configuration functions &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">각 테스트 스위트 모듈에는 선택적 구성 함수 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; 이 포함될 수 있습니다 . init 함수가 정의 된 경우 end 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="fa673338880fff3b8ab5d57c56ce74931075ef5e" translate="yes" xml:space="preserve">
          <source>Each test suite module can contain the optional configuration functions &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">각 테스트 스위트 모듈에는 선택적 구성 함수 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 가 포함될 수 있습니다 . init 함수가 정의 된 경우 end 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9be9dbf46883bfb6649b9dde3024776b2bfb78fc" translate="yes" xml:space="preserve">
          <source>Each test suite module can contain the optional configuration functions &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">각 테스트 스위트 모듈에는 선택적 구성 기능 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; 이 포함될 수 있습니다 . init 함수가 정의 된 경우 종료 함수도 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5dab76f0335fb30cc022494a15a9102a1b1aa7be" translate="yes" xml:space="preserve">
          <source>Each test suite module can contain the optional configuration functions &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">각 테스트 스위트 모듈에는 선택적 구성 함수 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; 가 포함될 수 있습니다 . init 함수가 정의 된 경우 종료 함수도 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5862fbfb3f074c11d24b7727c36cf9bdbbbda72" translate="yes" xml:space="preserve">
          <source>Each test suite module must export function &lt;code&gt;&lt;a href=&quot;common_test#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt;, which returns the list of all test case groups and test cases to be executed in that module.</source>
          <target state="translated">각 테스트 스위트 모듈은 &lt;code&gt;&lt;a href=&quot;common_test#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt; 함수를 내 보내야합니다.이 기능 은 해당 모듈에서 실행될 모든 테스트 케이스 그룹 및 테스트 케이스 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fd56725b7b7c70889ceb04697172f3594442c52b" translate="yes" xml:space="preserve">
          <source>Each test suite module must export function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt;, which returns the list of all test case groups and test cases to be executed in that module.</source>
          <target state="translated">각 테스트 스위트 모듈은 해당 모듈에서 실행될 모든 테스트 케이스 그룹 및 테스트 케이스 목록을 리턴하는 함수 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:all-0&quot;&gt;all/0&lt;/a&gt;&lt;/code&gt; 을 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="a82d0b878fdfaab3c22f520d67abc9156fa79d67" translate="yes" xml:space="preserve">
          <source>Each time a function in a Cover compiled module is called, information about the call is added to an internal database of Cover. The coverage analysis is performed by examining the contents of the Cover database. The output &lt;code&gt;Answer&lt;/code&gt; is determined by two parameters, &lt;code&gt;Level&lt;/code&gt; and &lt;code&gt;Analysis&lt;/code&gt;.</source>
          <target state="translated">Cover 컴파일 된 모듈의 함수가 호출 될 때마다 호출에 대한 정보가 Cover의 내부 데이터베이스에 추가됩니다. 커버리지 분석은 Cover 데이터베이스의 내용을 검사하여 수행됩니다. 출력 &lt;code&gt;Answer&lt;/code&gt; 은 &lt;code&gt;Level&lt;/code&gt; 및 &lt;code&gt;Analysis&lt;/code&gt; 의 두 매개 변수에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d291b759129a65a7c92477a04e632cac3277ae53" translate="yes" xml:space="preserve">
          <source>Each time a function in the Cover compiled module &lt;code&gt;channel&lt;/code&gt; is called, information about the call will be added to the Cover database. Run the test case:</source>
          <target state="translated">Cover 컴파일 된 모듈 &lt;code&gt;channel&lt;/code&gt; 의 함수가 호출 될 때마다 호출에 대한 정보가 Cover 데이터베이스에 추가됩니다. 테스트 케이스를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9e8ff16c70c1fc0240fb75f09e0d951deab35788" translate="yes" xml:space="preserve">
          <source>Each tuple contains an atom describing the type of memory as first element and the amount of allocated memory in bytes as second element. When information about allocated and used memory is present, also a third element is present, containing the amount of used memory in bytes.</source>
          <target state="translated">각 튜플에는 첫 번째 요소로 메모리 유형을 설명하고 두 번째 요소로 할당 된 메모리 양을 바이트 단위로 나타내는 원자가 들어 있습니다. 할당 및 사용 된 메모리에 대한 정보가 있으면 사용 된 메모리의 양을 바이트 단위로 포함하는 세 번째 요소도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fbaab76ee048157643094a4fa7baae8b1f26b60" translate="yes" xml:space="preserve">
          <source>Each tuple will produce one table in the order of their places in the list.</source>
          <target state="translated">각 튜플은 목록에있는 순서대로 하나의 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="51cb2aa921488217e96ac224fc5c13f88ab59cb5" translate="yes" xml:space="preserve">
          <source>Each undecoded part that is to be decoded must be fed into function &lt;code&gt;decode_part/2&lt;/code&gt; as follows:</source>
          <target state="translated">디코딩 될 각각의 디코딩되지 않은 부분은 다음과 같이 함수 &lt;code&gt;decode_part/2&lt;/code&gt; 에 공급되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="a3eef4129b67bd506209f344f64f0d81fa4e275d" translate="yes" xml:space="preserve">
          <source>Each update is appended to the transaction log and occasionally (depending on how it is configured) dumped to the tables files. The table file storage is more compact than the transaction log storage, especially if the same record is updated repeatedly. If the thresholds for dumping the transaction log are reached before the previous dump is finished, an overload event is triggered.</source>
          <target state="translated">각 업데이트는 트랜잭션 로그에 추가되며 때때로 (구성 방법에 따라) 테이블 파일에 덤프됩니다. 테이블 파일 스토리지는 특히 동일한 레코드가 반복적으로 업데이트되는 경우 트랜잭션 로그 스토리지보다 컴팩트합니다. 이전 덤프가 완료되기 전에 트랜잭션 로그 덤프에 대한 임계 값에 도달하면 과부하 이벤트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="91222363ea25938785424fffb48446fa72022ad1" translate="yes" xml:space="preserve">
          <source>Each user is represented by a tuple with the Mid of the user and a list of config parameters (each parameter is in turn a tuple: &lt;code&gt;{Item, Value}&lt;/code&gt;).</source>
          <target state="translated">각 사용자는 사용자 중간과 구성 매개 변수 목록이있는 튜플로 표시됩니다 (각 매개 변수는 튜플 : &lt;code&gt;{Item, Value}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c5960487e6583117a3e71addee6d735530434ddc" translate="yes" xml:space="preserve">
          <source>Earlier it was mentioned that a variable can only be given a value once in its scope. In the above you see that &lt;code&gt;Result_so_far&lt;/code&gt; is given several values. This is OK since every time you call &lt;code&gt;list_max/2&lt;/code&gt; you create a new scope and one can regard &lt;code&gt;Result_so_far&lt;/code&gt; as a different variable in each scope.</source>
          <target state="translated">이전에는 변수가 해당 범위에서 한 번만 값을 제공 할 수 있다고 언급했습니다. 위의 결과에서 &lt;code&gt;Result_so_far&lt;/code&gt; 에는 여러 값이 제공됩니다. &lt;code&gt;list_max/2&lt;/code&gt; 를 호출 할 때마다 새 범위를 작성하고 &lt;code&gt;Result_so_far&lt;/code&gt; 를 각 범위에서 다른 변수로 간주 할 수 있으므로 이는 정상 입니다.</target>
        </trans-unit>
        <trans-unit id="ed6caed0e440a7ff0deaaa66f177152c69eb3afa" translate="yes" xml:space="preserve">
          <source>Earlier version of the release to downgrade to.</source>
          <target state="translated">다운 그레이드 할 이전 버전의 릴리스입니다.</target>
        </trans-unit>
        <trans-unit id="4f12071fcb232719f7acbb29f4900300360385fd" translate="yes" xml:space="preserve">
          <source>Earlier version of the release to upgrade from.</source>
          <target state="translated">업그레이드 할 이전 버전.</target>
        </trans-unit>
        <trans-unit id="65cd0c7004f4d160355d98a242b0f8b159d1373f" translate="yes" xml:space="preserve">
          <source>Earlier versions of Perl and PCRE used to give an error at compile time for such patterns. However, as there are cases where this can be useful, such patterns are now accepted. However, if any repetition of the subpattern matches no characters, the loop is forcibly broken.</source>
          <target state="translated">이전 버전의 Perl 및 PCRE는 이러한 패턴에 대해 컴파일시 오류를 발생시키는 데 사용되었습니다. 그러나 이것이 유용 할 수있는 경우가 있으므로 이제 이러한 패턴이 허용됩니다. 그러나 하위 패턴의 반복이 문자와 일치하지 않으면 루프가 강제로 끊어집니다.</target>
        </trans-unit>
        <trans-unit id="a53b52768e55858c81dd4d8fab520a67888c0d03" translate="yes" xml:space="preserve">
          <source>Earlier versions of the ASN.1 compiler required that modules that were imported from had to be compiled before the module that imported. This caused problems when ASN.1 modules had circular dependencies.</source>
          <target state="translated">이전 버전의 ASN.1 컴파일러에서는 가져온 모듈을 가져온 모듈보다 먼저 컴파일해야했습니다. ASN.1 모듈에 순환 종속성이있을 때 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e9d22090baa7934a13d02450261873967d2a0be1" translate="yes" xml:space="preserve">
          <source>Earlier, &lt;code&gt;Fun&lt;/code&gt; could also be specified as &lt;code&gt;{Module, Function}&lt;/code&gt;, equivalent to &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt;. &lt;strong&gt;This use is deprecated and will stop working in a future release.&lt;/strong&gt;</source>
          <target state="translated">이전에는 &lt;code&gt;Fun&lt;/code&gt; 을 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 와 동일한 &lt;code&gt;{Module, Function}&lt;/code&gt; 으로 지정할 수도 있습니다 . &lt;strong&gt;이 사용은 더 이상 사용되지 않으며 향후 릴리스에서 작동이 중지됩니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a827c06f458eb4b34a5493fad94681c358ea9853" translate="yes" xml:space="preserve">
          <source>Early data and 0-RTT not supported</source>
          <target state="translated">초기 데이터 및 0-RTT는 지원되지 않음</target>
        </trans-unit>
        <trans-unit id="e93bb4ae1ee898eabe1fd55cee195f346cb5664b" translate="yes" xml:space="preserve">
          <source>Early versions of the SMP support for the runtime system completely relied on locking in order to protect data accesses from multiple threads. In some cases this isn't that problematic, but in some cases it really is. It complicates the code, ensuring all locks needed are actually held, and ensuring that all locks are acquired in such an order that no deadlock occur. Acquiring locks in the right order often also involve releasing locks held, forcing threads to reread data already read. A good recipe for creation of bugs. Trying to use more fine-grained locking in order to increase possible parallelism in the system makes the complexity situation even worse. Having to acquire a bunch of locks when doing operations also often cause heavy lock contention which cause poor scalability.</source>
          <target state="translated">런타임 시스템에 대한 SMP 지원의 초기 버전은 여러 스레드에서 데이터 액세스를 보호하기 위해 잠금에 완전히 의존했습니다. 어떤 경우에는 문제가되지 않지만 어떤 경우에는 실제로 문제가됩니다. 코드를 복잡하게하여 필요한 모든 잠금을 실제로 보유하고 교착 상태가 발생하지 않는 순서로 모든 잠금을 획득하도록합니다. 올바른 순서로 잠금을 획득하려면 종종 보유 된 잠금을 해제하여 스레드가 이미 읽은 데이터를 다시 읽도록합니다. 버그 생성을위한 좋은 방법입니다. 시스템에서 가능한 병렬 처리를 늘리기 위해 더 세분화 된 잠금을 사용하려고하면 복잡성 상황이 더욱 악화됩니다. 작업을 수행 할 때 많은 잠금을 획득해야하는 경우에도 종종 심각한 잠금 경합이 발생하여 확장 성이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="c686e62b44ec832b4f549d529f5cabc55a92a0e4" translate="yes" xml:space="preserve">
          <source>Easy-to-use time-outs (&lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Outs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Outs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-Outs&lt;/a&gt;&lt;/code&gt; (named time-outs))</source>
          <target state="translated">사용하기 쉬운 타임 아웃 ( &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Outs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Outs&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-Outs&lt;/a&gt;&lt;/code&gt; (명명 타임 아웃))</target>
        </trans-unit>
        <trans-unit id="5887655182350a5c85026cd7362d3a2f232dbf4f" translate="yes" xml:space="preserve">
          <source>Easy-to-use timeouts (&lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Outs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Outs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-outs&lt;/a&gt;&lt;/code&gt; (named time-outs))</source>
          <target state="translated">사용하기 쉬운 시간 초과 ( &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Outs&lt;/a&gt;&lt;/code&gt; 초과 , &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;Event Time-Outs&lt;/a&gt;&lt;/code&gt; 초과 및 &lt;code&gt;&lt;a href=&quot;#Generic%20Time-Outs&quot;&gt;Generic Time-outs&lt;/a&gt;&lt;/code&gt; 초과 (이름이 지정된 시간 초과))</target>
        </trans-unit>
        <trans-unit id="b7a4d28f1dcb53979e4d42597be409788c8c24e0" translate="yes" xml:space="preserve">
          <source>EdDSA</source>
          <target state="translated">EdDSA</target>
        </trans-unit>
        <trans-unit id="acaad14ae3e35bc5c73d5e321dcb75cadd81a530" translate="yes" xml:space="preserve">
          <source>EdDSA is available with OpenSSL 1.1.1 or later if not disabled by configuration. To dynamically check availability, check that the atom &lt;code&gt;eddsa&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">EdDSA는 구성에 의해 비활성화되지 않은 경우 OpenSSL 1.1.1 이상에서 사용할 수 있습니다. 가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 원자 &lt;code&gt;eddsa&lt;/code&gt; 가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="31ae59bd2171bda6147d55588f9a8b6efcfaac82" translate="yes" xml:space="preserve">
          <source>Edit - Arrows</source>
          <target state="translated">편집-화살표</target>
        </trans-unit>
        <trans-unit id="387693905beccb2acf0088228590ecc875a53e2d" translate="yes" xml:space="preserve">
          <source>Edit - Comment/Uncomment Region</source>
          <target state="translated">편집-주석 / 주석 제거 영역</target>
        </trans-unit>
        <trans-unit id="3bc821a9e3f4964085c2a30d0c26d8c14aa5da39" translate="yes" xml:space="preserve">
          <source>Edit - Fill Comment</source>
          <target state="translated">편집-주석 채우기</target>
        </trans-unit>
        <trans-unit id="c2dac947ec0acff1f5944051e24327213806c67c" translate="yes" xml:space="preserve">
          <source>Edit - Function Header Commands</source>
          <target state="translated">편집-함수 헤더 명령</target>
        </trans-unit>
        <trans-unit id="7b76420fb41ff4f81dc37493d7f65967ae412e88" translate="yes" xml:space="preserve">
          <source>Edit - Marking</source>
          <target state="translated">편집-표시</target>
        </trans-unit>
        <trans-unit id="fd879ab973df7fb91e2bc55f2a3c82dc78b25bb9" translate="yes" xml:space="preserve">
          <source>Edit - Moving the marker</source>
          <target state="translated">편집-마커 이동</target>
        </trans-unit>
        <trans-unit id="33c5225e7c12b757b24805fea66268f9fbf3a6f5" translate="yes" xml:space="preserve">
          <source>Edit Menu</source>
          <target state="translated">메뉴 편집</target>
        </trans-unit>
        <trans-unit id="ff096aaeb82c6666e39fc680c917cdb6ff501824" translate="yes" xml:space="preserve">
          <source>Edits configuration data.</source>
          <target state="translated">구성 데이터를 편집합니다.</target>
        </trans-unit>
        <trans-unit id="07db18ae9dcddd7fea233a4299ad559f0aca25b2" translate="yes" xml:space="preserve">
          <source>Edits the environment block for the service. Every environment variable specified is added to the system environment block. If a variable specified here has the same name as a system-wide environment variable, the specified value overrides the system-wide. Environment variables are added to this list by specifying &amp;lt;variable&amp;gt;=&amp;lt;value&amp;gt; and deleted from the list by specifying &amp;lt;variable&amp;gt; alone. The environment block is automatically sorted. Any number of &lt;code&gt;-env&lt;/code&gt; options can be specified in one command. Default is to use the system environment block unmodified (except for two additions, see section &lt;code&gt;&lt;a href=&quot;#002&quot;&gt;Environment&lt;/a&gt;&lt;/code&gt; below).</source>
          <target state="translated">서비스의 환경 블록을 편집합니다. 지정된 모든 환경 변수가 시스템 환경 블록에 추가됩니다. 여기에 지정된 변수가 시스템 전체 환경 변수와 이름이 같은 경우 지정된 값이 시스템 전체를 대체합니다. 환경 변수는 &amp;lt;변수&amp;gt; = &amp;lt;값&amp;gt;을 지정하여이 목록에 추가되고 &amp;lt;변수&amp;gt; 만 지정하여 목록에서 삭제됩니다. 환경 블록이 자동으로 정렬됩니다. 하나의 명령으로 여러 개의 &lt;code&gt;-env&lt;/code&gt; 옵션을 지정할 수 있습니다. 기본값은 수정되지 않은 시스템 환경 블록을 사용하는 것입니다 (두 개의 추가를 제외하고 아래 &lt;code&gt;&lt;a href=&quot;#002&quot;&gt;Environment&lt;/a&gt;&lt;/code&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7c924cdd3b737d8ecc484367e45f459b20ec7e9f" translate="yes" xml:space="preserve">
          <source>Effects like this are improbable but possible. The probability will further be reduced (if not vanish) if table option &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt; is not enabled. This can also only be a potential concern for &lt;code&gt;ordered_set&lt;/code&gt; where the traversal order is defined.</source>
          <target state="translated">이와 같은 효과는 불가능하지만 가능합니다. 테이블 옵션 &lt;code&gt;&lt;a href=&quot;#new_2_write_concurrency&quot;&gt;write_concurrency&lt;/a&gt;&lt;/code&gt; 가 활성화되지 않은 경우 가능성이 더 감소합니다 (소멸되지 않는 경우) . 이는 순회 순서가 정의 된 &lt;code&gt;ordered_set&lt;/code&gt; 의 잠재적 인 문제 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a956986208caa4daeb338ab4f70268aa64edc8b" translate="yes" xml:space="preserve">
          <source>Efficient code can be well-structured and clean, based on a sound overall architecture and sound algorithms. Efficient code can be highly implementation-code that bypasses documented interfaces and takes advantage of obscure quirks in the current implementation.</source>
          <target state="translated">사운드 전체 아키텍처 및 사운드 알고리즘을 기반으로 효율적인 코드를 체계적으로 정리하고 정리할 수 있습니다. 효율적인 코드는 문서화 된 인터페이스를 우회하고 현재 구현에서 모호한 단점을 이용하는 높은 구현 코드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95eb187386528f0442d2d1a0d814ad6080e6245c" translate="yes" xml:space="preserve">
          <source>Efficiently reads the terms that are appended to an internally formatted log. It minimizes disk I/O by reading 64 kilobyte chunks from the file. Functions &lt;code&gt;bchunk/2,3&lt;/code&gt; return the binaries read from the file, they do not call &lt;code&gt;binary_to_term()&lt;/code&gt;. Apart from that, they work just like &lt;code&gt;chunk/2,3&lt;/code&gt;.</source>
          <target state="translated">내부적으로 형식화 된 로그에 추가 된 용어를 효율적으로 읽습니다. 파일에서 64 킬로바이트 청크를 읽음으로써 디스크 I / O를 최소화합니다. &lt;code&gt;bchunk/2,3&lt;/code&gt; 함수 는 파일에서 읽은 이진을 반환하며 &lt;code&gt;binary_to_term()&lt;/code&gt; 호출하지는 않습니다 . 그 외에도 그들은 &lt;code&gt;chunk/2,3&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="bb212465dbae7203df4ab62ae8863407da33e722" translate="yes" xml:space="preserve">
          <source>Egyptian_Hieroglyphs</source>
          <target state="translated">Egyptian_Hieroglyphs</target>
        </trans-unit>
        <trans-unit id="b605c9a1d38aeb2128970f4cfddf46cfbbab5716" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;Location&lt;/code&gt; is illegal, or it is evaluated to a negative offset in the file. Notice that if the resulting position is a negative value, the result is an error, and after the call the file position is undefined.</source>
          <target state="translated">어느 &lt;code&gt;Location&lt;/code&gt; 불법, 또는이 파일에 오프셋 부정적으로 평가된다. 결과 위치가 음수 인 경우 결과는 오류이며 호출 후 파일 위치는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="821623002947dfb13bf46c9ba373aec903676684" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;*bitoffsp&lt;/code&gt; returns the number of unused bits in the first byte pointed to by &lt;code&gt;*pp&lt;/code&gt;. The value of &lt;code&gt;*bitoffsp&lt;/code&gt; is between 0 and 7. Unused bits in the first byte are the most significant bits.</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 &lt;code&gt;*bitoffsp&lt;/code&gt; 의 복귀 첫 번째 바이트에 사용되지 않는 비트 수를 가리키는 &lt;code&gt;*pp&lt;/code&gt; . &lt;code&gt;*bitoffsp&lt;/code&gt; 의 값은 0에서 7 사이입니다. 첫 번째 바이트에서 사용되지 않은 비트가 최상위 비트입니다.</target>
        </trans-unit>
        <trans-unit id="38b33826fe0b1c666930574c956c3943ee063250" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;*nbitsp&lt;/code&gt; returns the length of the bit string in &lt;strong&gt;bits&lt;/strong&gt;.</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 &lt;code&gt;*nbitsp&lt;/code&gt; 의 수익률 비트 문자열의 길이 &lt;strong&gt;비트&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8e8cc57d2a9968ec2ba254f6454f8c8cc973ee" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;*pp&lt;/code&gt; returns a pointer to the first byte of the bit string. The returned bit string is readable as long as the buffer pointed to by &lt;code&gt;buf&lt;/code&gt; is readable and not written to.</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 &lt;code&gt;*pp&lt;/code&gt; 반환 비트 문자열의 첫 번째 바이트에 대한 포인터를. 반환 된 비트 문자열은 &lt;code&gt;buf&lt;/code&gt; 가 가리키는 버퍼 를 읽을 수 있고 쓰지 않는 한 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d30f451140817c7d120ec001c6cece0c48331e09" translate="yes" xml:space="preserve">
          <source>Either a back reference, or the two characters &quot;8&quot; and &quot;1&quot;</source>
          <target state="translated">역 참조 또는 두 문자 &quot;8&quot;및 &quot;1&quot;</target>
        </trans-unit>
        <trans-unit id="cd46349522982f37a5a0818f644ecd4fc728303c" translate="yes" xml:space="preserve">
          <source>Either sends a message and returns &lt;code&gt;ok&lt;/code&gt;, or does not send the message but returns something else (see below). Otherwise the same as &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;erlang:send/2&lt;/a&gt;&lt;/code&gt;. For more detailed explanation and warnings, see &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt; erlang:send_nosuspend/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지를 보내고 &lt;code&gt;ok&lt;/code&gt; 를 반환 하거나 메시지를 보내지 않고 다른 것을 반환합니다 (아래 참조). 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;erlang:send/2&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 자세한 설명 및 경고는 &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt; erlang:send_nosuspend/2,3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6f7085abc2ccef85b192b8c6868e5479f1516a2" translate="yes" xml:space="preserve">
          <source>Either sends a message and returns &lt;code&gt;ok&lt;/code&gt;, or does not send the message but returns something else (see below). Otherwise the same as &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;erlang:send/2&lt;/a&gt;&lt;/code&gt;. For more detailed explanation and warnings, see &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지를 보내고 &lt;code&gt;ok&lt;/code&gt; 를 반환 하거나 메시지를 보내지 않지만 다른 것을 반환합니다 (아래 참조). 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;erlang:send/2&lt;/a&gt;&lt;/code&gt; 와 동일 합니다. 자세한 설명 및 경고는 &lt;code&gt;&lt;a href=&quot;#send_nosuspend-2&quot;&gt;erlang:send_nosuspend/2,3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c7329b4b0e253e39f89da454478a65965c06ad0" translate="yes" xml:space="preserve">
          <source>Either set all or none of the &lt;code&gt;DED_LD*&lt;/code&gt; variables.</source>
          <target state="translated">&lt;code&gt;DED_LD*&lt;/code&gt; 변수를 모두 설정하거나 설정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="4e7799671ee9bcf125ace44830967d9f98d8d690" translate="yes" xml:space="preserve">
          <source>Either set all or none of the &lt;code&gt;LFS_*&lt;/code&gt; variables.</source>
          <target state="translated">&lt;code&gt;LFS_*&lt;/code&gt; 변수를 모두 설정하거나 설정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="93c3f6c0504a02d19f3c9ca403c6b9bad1813d62" translate="yes" xml:space="preserve">
          <source>Either the atom &lt;code&gt;longnames&lt;/code&gt; or the atom &lt;code&gt;shortnames&lt;/code&gt; indicating whether long or short names is used.</source>
          <target state="translated">어느 원자 &lt;code&gt;longnames&lt;/code&gt; 또는 원자 &lt;code&gt;shortnames&lt;/code&gt; 이 길거나 짧은 이름이 사용되는지 여부를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="487f7c8a7538e9346944b722752c3236ffa482d3" translate="yes" xml:space="preserve">
          <source>Either the exit reason of the process, &lt;code&gt;noproc&lt;/code&gt; (process or port did not exist at the time of monitor creation), or &lt;code&gt;noconnection&lt;/code&gt; (no connection to the node where the monitored process resides).</source>
          <target state="translated">어느 프로세스의 종료 이유는, &lt;code&gt;noproc&lt;/code&gt; , 또는 (프로세스 또는 포트는 모니터 작성시 존재하지 않았다) &lt;code&gt;noconnection&lt;/code&gt; (노드 모니터링되는 프로세스가 상주에 연결되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="c34e480bf57ef7e38dbf93bd6c9f5b3abdddea2f" translate="yes" xml:space="preserve">
          <source>Elbasan</source>
          <target state="translated">Elbasan</target>
        </trans-unit>
        <trans-unit id="92bdb0ad601fb48f836694c9ca704b151de6f4e6" translate="yes" xml:space="preserve">
          <source>Element &lt;code&gt;GroupSpec&lt;/code&gt; makes it possible to specify group execution properties that overrides those in the group definition (that is, in &lt;code&gt;groups/0&lt;/code&gt;). Execution properties for subgroups might be overridden as well. This feature makes it possible to change properties of groups at the time of execution, without having to edit the test suite. The same feature is available for &lt;code&gt;group&lt;/code&gt; elements in the &lt;code&gt;Suite:all/0&lt;/code&gt; list. For details and examples, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt; Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GroupSpec&lt;/code&gt; 요소 를 사용하면 그룹 정의 (즉, &lt;code&gt;groups/0&lt;/code&gt; ) 에있는 속성을 재정의하는 그룹 실행 속성을 지정할 수 있습니다 . 하위 그룹의 실행 속성도 재정의 될 수 있습니다. 이 기능을 사용하면 테스트 스위트를 편집하지 않고도 실행시 그룹의 속성을 변경할 수 있습니다. &lt;code&gt;Suite:all/0&lt;/code&gt; 목록 의 &lt;code&gt;group&lt;/code&gt; 요소에 동일한 기능을 사용할 수 있습니다 . 자세한 내용과 예는 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt; Test Case Groups&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3ca208403466a4841f552219491c8eba018e929" translate="yes" xml:space="preserve">
          <source>Element &lt;code&gt;GroupSpec&lt;/code&gt; makes it possible to specify group execution properties that overrides those in the group definition (that is, in &lt;code&gt;groups/0&lt;/code&gt;). Execution properties for subgroups might be overridden as well. This feature makes it possible to change properties of groups at the time of execution, without having to edit the test suite. The same feature is available for &lt;code&gt;group&lt;/code&gt; elements in the &lt;code&gt;Suite:all/0&lt;/code&gt; list. For details and examples, see section &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GroupSpec&lt;/code&gt; 요소 를 사용하면 그룹 정의 (즉, &lt;code&gt;groups/0&lt;/code&gt; )의 특성을 대체하는 그룹 실행 특성을 지정할 수 있습니다 . 하위 그룹의 실행 속성도 재정의 될 수 있습니다. 이 기능을 사용하면 테스트 스위트를 편집하지 않고도 실행시 그룹의 특성을 변경할 수 있습니다. &lt;code&gt;Suite:all/0&lt;/code&gt; 목록 의 &lt;code&gt;group&lt;/code&gt; 요소에 동일한 기능을 사용할 수 있습니다 . 세부 사항 및 예제는 &lt;code&gt;&lt;a href=&quot;write_test_chapter#test_case_groups&quot;&gt;Test Case Groups&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e3308f88fa7e4a90eab00a6aeedd94b192c76f8" translate="yes" xml:space="preserve">
          <source>Element &lt;code&gt;Location&lt;/code&gt; at the end is optional. Omitting it is equivalent to specifying an empty list.</source>
          <target state="translated">마지막 요소 &lt;code&gt;Location&lt;/code&gt; 는 선택 사항입니다. 생략하면 빈 목록을 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec9d8fff696522dd91cca874c3d28af6c174f71c" translate="yes" xml:space="preserve">
          <source>Element is any of:</source>
          <target state="translated">요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="968e60ba1bd927549a1b23411ba40213ea222600" translate="yes" xml:space="preserve">
          <source>Elements from the &lt;code&gt;Config&lt;/code&gt; list can, for example, be read with &lt;code&gt;proplists:get_value/2&lt;/code&gt; in STDLIB (or the macro &lt;code&gt;?config&lt;/code&gt; defined in &lt;code&gt;ct.hrl&lt;/code&gt;).</source>
          <target state="translated">예를 들어 &lt;code&gt;Config&lt;/code&gt; 목록의 요소 는 STDLIB의 &lt;code&gt;proplists:get_value/2&lt;/code&gt; (또는 &lt;code&gt;ct.hrl&lt;/code&gt; 에 정의 된 매크로 &lt;code&gt;?config&lt;/code&gt; ) 로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb2cb18900c542ca840a5c213e23f0b3dc15b660" translate="yes" xml:space="preserve">
          <source>Elements in a tuple</source>
          <target state="translated">튜플의 요소</target>
        </trans-unit>
        <trans-unit id="d545793775877375fff2627af68fdce76d7bc2fa" translate="yes" xml:space="preserve">
          <source>Elen</source>
          <target state="translated">Elen</target>
        </trans-unit>
        <trans-unit id="5da3766347deb74cc1b458df110c22be94db592b" translate="yes" xml:space="preserve">
          <source>Elliptic Curve Diffie-Hellman</source>
          <target state="translated">타원 곡선 Diffie-Hellman</target>
        </trans-unit>
        <trans-unit id="fa431301195dd48fed6f23a7bbd84655388a6540" translate="yes" xml:space="preserve">
          <source>Elliptic Curve Diffie-Hellman is available with OpenSSL 0.9.8o or later if not disabled by configuration. To dynamically check availability, check that the atom &lt;code&gt;ecdh&lt;/code&gt; is present in the list returned by &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Elliptic Curve Diffie-Hellman은 구성에 의해 비활성화되지 않은 경우 OpenSSL 0.9.8o 이상에서 사용할 수 있습니다. 가용성을 동적으로 확인하려면 &lt;code&gt;&lt;a href=&quot;crypto#supports-1&quot;&gt;crypto:supports(public_keys)&lt;/a&gt;&lt;/code&gt; 반환 한 목록에 atom &lt;code&gt;ecdh&lt;/code&gt; 가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e73e966bd4df71c027a4c118ea65eb7371a4243d" translate="yes" xml:space="preserve">
          <source>Elliptic Curve cipher suites are supported if the Crypto application supports it and named curves are used.</source>
          <target state="translated">암호화 응용 프로그램에서 지원하고 명명 된 곡선이 사용되는 경우 타원 곡선 암호화 제품군이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e700b1007a66e60f0a7f4f535b564650dfff800d" translate="yes" xml:space="preserve">
          <source>Elliptic Curves</source>
          <target state="translated">타원 곡선</target>
        </trans-unit>
        <trans-unit id="2c85b928f430187c761aebf5278e8b29dec297af" translate="yes" xml:space="preserve">
          <source>Else the subdirectory &lt;code&gt;.ssh&lt;/code&gt; in the home directory of the user executing the OS process of the Erlang emulator is used.</source>
          <target state="translated">그렇지 않으면 Erlang 에뮬레이터의 OS 프로세스를 실행하는 사용자의 홈 디렉터리에 있는 하위 디렉터리 &lt;code&gt;.ssh&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ce2f8df70b3b9f7f699376e6dadcb10ce14fcd" translate="yes" xml:space="preserve">
          <source>Else, If the option &lt;code&gt;user_dir&lt;/code&gt; is defined, that directory is used,</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;user_dir&lt;/code&gt; 옵션 이 정의 된 경우 해당 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7b0201083ca11d6276fbd37e317c08dff08162" translate="yes" xml:space="preserve">
          <source>Else, if the &lt;code&gt;user_passwords&lt;/code&gt; option is defined and the username and the password matches, the authentication is a success.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;user_passwords&lt;/code&gt; 옵션이 정의되고 사용자 이름과 암호가 일치하면 인증이 성공한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a589281f720ad2a72d778b5bb32dc24d843f4342" translate="yes" xml:space="preserve">
          <source>Else, if the option &lt;code&gt;password&lt;/code&gt; is defined and matches the password the authentication is a success. Note that the use of this option is not recommended in non-test code.</source>
          <target state="translated">그렇지 않으면 옵션 &lt;code&gt;password&lt;/code&gt; 가 정의되어 있고 암호와 일치하면 인증이 성공한 것입니다. 테스트 코드가 아닌 경우이 옵션을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4222989fc4f8ea6a86e6368dd890fe3a7e3a9888" translate="yes" xml:space="preserve">
          <source>Em quad</source>
          <target state="translated">엠 쿼드</target>
        </trans-unit>
        <trans-unit id="b895da879ed23d9e84111f08fcadea33bce091c1" translate="yes" xml:space="preserve">
          <source>Em space</source>
          <target state="translated">엠 스페이스</target>
        </trans-unit>
        <trans-unit id="9bf49a8e8e16e64d1e80f11162b14dd5a6925b12" translate="yes" xml:space="preserve">
          <source>Emacs integration</source>
          <target state="translated">이맥스 통합</target>
        </trans-unit>
        <trans-unit id="74ecfadd2780297c01438b6cea78b633f6b22ee8" translate="yes" xml:space="preserve">
          <source>Emakefile</source>
          <target state="translated">Emakefile</target>
        </trans-unit>
        <trans-unit id="57277b8bd9c47d99e492b166fbdc87545de80f47" translate="yes" xml:space="preserve">
          <source>Embedded Named Types</source>
          <target state="translated">임베디드 명명 된 유형</target>
        </trans-unit>
        <trans-unit id="53217bbe98515c64d0537b3a416e9cda98f14cfd" translate="yes" xml:space="preserve">
          <source>Embedded Structured Types</source>
          <target state="translated">임베디드 구조화 된 유형</target>
        </trans-unit>
        <trans-unit id="1a9e1619cb718522f7ab0f0dba6e08852aa8d86c" translate="yes" xml:space="preserve">
          <source>Emits warnings for all implicitly exported variables referred to after the primitives where they were first defined. By default, the compiler only emits warnings for exported variables referred to in a pattern.</source>
          <target state="translated">처음 정의 된 기본 요소 다음에 참조되는 내재적으로 내 보낸 모든 변수에 대해 경고를 표시합니다. 기본적으로 컴파일러는 패턴에서 참조 된 내 보낸 변수에 대해서만 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d4c2117b6ef3fcf84bfe3899fed68d89773c2661" translate="yes" xml:space="preserve">
          <source>Emits warnings for unused imported functions. Default is to emit no warnings for unused imported functions.</source>
          <target state="translated">사용하지 않은 가져온 함수에 대한 경고를 표시합니다. 기본적으로 사용하지 않는 가져온 함수에 대해서는 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8599dc127f27a271f0836cf6a62d5941fe3178a" translate="yes" xml:space="preserve">
          <source>Emitting Exit Signals</source>
          <target state="translated">출구 신호 방출</target>
        </trans-unit>
        <trans-unit id="d901413f50becfae6fdd27d649c08a5d538e0014" translate="yes" xml:space="preserve">
          <source>Empty documents are occasionally useful; in particular, they have the property that &lt;code&gt;above(X, empty())&lt;/code&gt; will force a new line after &lt;code&gt;X&lt;/code&gt; without leaving an empty line below it; since this is a common idiom, the utility function &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;break/1&lt;/a&gt;&lt;/code&gt; will place a given document in such a context.</source>
          <target state="translated">빈 문서는 때때로 유용합니다. 특히, 그것들은 &lt;code&gt;above(X, empty())&lt;/code&gt; 가 빈 줄을 그 아래에 남기지 않고 &lt;code&gt;X&lt;/code&gt; 뒤에 새 줄을 강제 한다는 속성을 가지고 있습니다. 이것은 일반적인 관용구이기 때문에 유틸리티 함수 &lt;code&gt;&lt;a href=&quot;#break-1&quot;&gt;break/1&lt;/a&gt;&lt;/code&gt; 은 주어진 상황에 해당 문서를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="fc00f52599abed8376aa0a197e15e0ea835df63f" translate="yes" xml:space="preserve">
          <source>Emulator flag &lt;code&gt;+fnu&lt;/code&gt; is ignored.</source>
          <target state="translated">에뮬레이터 플래그 &lt;code&gt;+fnu&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="55e05c2f7b68cf5e80a54adf43f642d47a0f59b3" translate="yes" xml:space="preserve">
          <source>En quad</source>
          <target state="translated">엔 쿼드</target>
        </trans-unit>
        <trans-unit id="5b62229c904d32c8112d3be27a54257af67d740a" translate="yes" xml:space="preserve">
          <source>En space</source>
          <target state="translated">공간</target>
        </trans-unit>
        <trans-unit id="25ffb040887bf2788091d6954b71659dc5c37d66" translate="yes" xml:space="preserve">
          <source>Enable automatic gc of the mib server cache.</source>
          <target state="translated">mib 서버 캐시의 자동 gc를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd6f2bb237a816f3fbfe6d4d2c6878e556d33f2f" translate="yes" xml:space="preserve">
          <source>Enable code coverage analysis (similar to &lt;code&gt;ct_run -cover&lt;/code&gt;).</source>
          <target state="translated">코드 커버리지 분석을 활성화합니다 ( &lt;code&gt;ct_run -cover&lt;/code&gt; 와 유사 ).</target>
        </trans-unit>
        <trans-unit id="90a330d2bc3b5e0f4b42739d294b1f200e628844" translate="yes" xml:space="preserve">
          <source>Enable or disable debug during the open call.</source>
          <target state="translated">공개 호출 중에 디버그를 활성화하거나 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c21cd0052bbd4aec688bd575486e424a3296ba0c" translate="yes" xml:space="preserve">
          <source>Enable or disable use of the socket registry for this socket. This overrides the global value.</source>
          <target state="translated">이 소켓에 대한 소켓 레지스트리 사용을 활성화 또는 비활성화합니다. 이것은 전역 값을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="47033a4bb8f28d29d58e4994c4d9050176047e9e" translate="yes" xml:space="preserve">
          <source>Enable process tracing for new processes and use &lt;code&gt;dyntrace&lt;/code&gt; as tracer backend.</source>
          <target state="translated">새 프로세스에 대해 프로세스 추적을 사용하고 &lt;code&gt;dyntrace&lt;/code&gt; 를 추적 프로그램 백엔드로 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="42b73ef7216dacb5d34f7ba030c613404e7e43a1" translate="yes" xml:space="preserve">
          <source>Enable the mib server cache.</source>
          <target state="translated">mib 서버 캐시를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="4d4a9638a58d251377650d5cc7a8a58f9862c35d" translate="yes" xml:space="preserve">
          <source>Enable the process_register LTTng tracepoint for Erlang.</source>
          <target state="translated">Erlang에 대해 process_register LTTng 추적 점을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a59268c48f3b857ba83c67b5ea54f91ebdaa5a0" translate="yes" xml:space="preserve">
          <source>Enables (&lt;code&gt;Enable = true&lt;/code&gt;) or disables (&lt;code&gt;Enable = false&lt;/code&gt;) FIPS mode. Returns &lt;code&gt;true&lt;/code&gt; if the operation was successful or &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">FIPS 모드를 활성화 ( &lt;code&gt;Enable = true&lt;/code&gt; )하거나 비활성화 ( &lt;code&gt;Enable = false&lt;/code&gt; )합니다. 작업이 성공하면 &lt;code&gt;true&lt;/code&gt; 를 반환 &lt;code&gt;false&lt;/code&gt; 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="086f907d75188b886010563f8bd5580d7dfa5ad7" translate="yes" xml:space="preserve">
          <source>Enables (&lt;code&gt;Flag == true&lt;/code&gt;) or disables (&lt;code&gt;Flag == false&lt;/code&gt;) printout of standard events to the terminal.</source>
          <target state="translated">표준 이벤트를 터미널로 출력하는 것을 활성화 ( &lt;code&gt;Flag == true&lt;/code&gt; )하거나 비활성화 ( &lt;code&gt;Flag == false&lt;/code&gt; )합니다.</target>
        </trans-unit>
        <trans-unit id="c455979edd964441a42bf74cc46c686c8c9674e4" translate="yes" xml:space="preserve">
          <source>Enables (&lt;code&gt;true&lt;/code&gt;) or disables (&lt;code&gt;false&lt;/code&gt;) the possibility to tunnel a TCP/IP connection in to a &lt;code&gt;server&lt;/code&gt;. Disabled per default.</source>
          <target state="translated">TCP / IP 연결을 &lt;code&gt;server&lt;/code&gt; 로 터널링 할 수있는 가능성을 활성화 ( &lt;code&gt;true&lt;/code&gt; ) 또는 비활성화 ( &lt;code&gt;false&lt;/code&gt; ) 합니다 . 기본적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c34c585883308ccf10a9a0f2b7ca4c0bea6cad17" translate="yes" xml:space="preserve">
          <source>Enables (&lt;code&gt;true&lt;/code&gt;) or disables (&lt;code&gt;false&lt;/code&gt;) the possibility to tunnel a TCP/IP connection out of a &lt;code&gt;server&lt;/code&gt;. Disabled per default.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 에서 TCP / IP 연결을 터널링 할 수있는 가능성을 활성화 ( &lt;code&gt;true&lt;/code&gt; ) 또는 비활성화 ( &lt;code&gt;false&lt;/code&gt; ) 합니다 . 기본적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="19643cf04bb22173cf35df90be432b41c2c0c80f" translate="yes" xml:space="preserve">
          <source>Enables &lt;code&gt;sys_alloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sys_alloc&lt;/code&gt; 을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2925b3bafb5ae4152db5d7ac7ad43b60459fcd09" translate="yes" xml:space="preserve">
          <source>Enables SAC delay</source>
          <target state="translated">SAC 지연 가능</target>
        </trans-unit>
        <trans-unit id="60585639720a7d6f2dcd45081510159d2d44e676" translate="yes" xml:space="preserve">
          <source>Enables a table-specific parameterization of a generic hash module. This property can explicitly be set at table creation. Default is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">일반 해시 모듈의 테이블 별 매개 변수화를 사용합니다. 이 특성은 테이블 작성시 명시 적으로 설정할 수 있습니다. 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8e12000a8c8fd6dc64847bf440cb7b251ca8594" translate="yes" xml:space="preserve">
          <source>Enables all allocators (default).</source>
          <target state="translated">모든 할당자를 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="66de0b189789174995d11e9a7ecdc4b4c55056e9" translate="yes" xml:space="preserve">
          <source>Enables all breakpoints.</source>
          <target state="translated">모든 중단 점을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="77e83ac48ceff1b4f43eaffc497baace9759de30" translate="yes" xml:space="preserve">
          <source>Enables allocator &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">할당 자 &lt;code&gt;&amp;lt;S&amp;gt;&lt;/code&gt; 를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2df58c7f8ed4e32b890b81f44943b59779b18455" translate="yes" xml:space="preserve">
          <source>Enables autoload tracing, displaying information while loading code.</source>
          <target state="translated">코드를로드하는 동안 정보를 표시하여 자동로드 추적을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e63213e4ec392a2d1540f7cfff72fc5cfb579a1d" translate="yes" xml:space="preserve">
          <source>Enables automatic &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;timetrap time-out&lt;/a&gt;&lt;/code&gt; scaling.</source>
          <target state="translated">자동 &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;timetrap time-out&lt;/a&gt;&lt;/code&gt; 스케일링을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="7c1880c250eb08af05373e2f459afdf06f86ade5" translate="yes" xml:space="preserve">
          <source>Enables automatic Path MTU discovery</source>
          <target state="translated">자동 경로 MTU 발견 가능</target>
        </trans-unit>
        <trans-unit id="4a450a6d403248f14eea46a3f225948ab6482c2b" translate="yes" xml:space="preserve">
          <source>Enables checking of the &lt;code&gt;&lt;a href=&quot;#type-authentication_client_options&quot;&gt;client's user name&lt;/a&gt;&lt;/code&gt; in the server when doing public key authentication. It is disabled by default.</source>
          <target state="translated">공개 키 인증을 수행 할 때 서버에서 &lt;code&gt;&lt;a href=&quot;#type-authentication_client_options&quot;&gt;client's user name&lt;/a&gt;&lt;/code&gt; 을 확인할 수 있습니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aaeb3427c0032642a4226c0cd3b5f50f5fb209d" translate="yes" xml:space="preserve">
          <source>Enables debug output. The more &lt;code&gt;-d&lt;/code&gt; flags specified, the more debug output you will get (to a certain limit). This option is most useful when the &lt;code&gt;epmd&lt;/code&gt; daemon is not started as a daemon.</source>
          <target state="translated">디버그 출력을 활성화합니다. 더 많은 &lt;code&gt;-d&lt;/code&gt; 플래그는, (특정 한도에) 당신이 얻을 것이다 더 많은 디버그 출력을 지정했습니다. 이 옵션은 &lt;code&gt;epmd&lt;/code&gt; 데몬이 데몬으로 시작되지 않은 경우에 가장 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="dc4bb9c9b6967fcf2db9ac785f5fa835fda825a8" translate="yes" xml:space="preserve">
          <source>Enables definition of an alternative hashing scheme. The module must implement the &lt;code&gt;&lt;a href=&quot;mnesia_frag_hash&quot;&gt;mnesia_frag_hash&lt;/a&gt;&lt;/code&gt; callback behavior. This property can explicitly be set at table creation. Default is &lt;code&gt;mnesia_frag_hash&lt;/code&gt;.</source>
          <target state="translated">대체 해싱 체계를 정의 할 수 있습니다. 모듈은 &lt;code&gt;&lt;a href=&quot;mnesia_frag_hash&quot;&gt;mnesia_frag_hash&lt;/a&gt;&lt;/code&gt; 콜백 동작을 구현해야합니다 . 이 특성은 테이블 작성시 명시 적으로 설정할 수 있습니다. 기본값은 &lt;code&gt;mnesia_frag_hash&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a700ff4718bb88a01bb446ce6cbb93500e0f99a" translate="yes" xml:space="preserve">
          <source>Enables fetching of CRLs specified as http URIs in&lt;code&gt;X509 certificate extensions&lt;/code&gt;. Requires the OTP inets application.</source>
          <target state="translated">&lt;code&gt;X509 certificate extensions&lt;/code&gt; 에서 http URI로 지정된 CRL을 페치 할 수 있습니다 . OTP inets 애플리케이션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ad67ee1b0fedae077d66e983c37484352f51633e" translate="yes" xml:space="preserve">
          <source>Enables heartbeat</source>
          <target state="translated">하트 비트 사용</target>
        </trans-unit>
        <trans-unit id="a3907a70a0b2989a151817232d2aeddc263d8c16" translate="yes" xml:space="preserve">
          <source>Enables installation of alternative debug functions. An example of such a function is a trigger, a function that waits for some special event and performs some action when the event is generated. For example, turning on low-level tracing.</source>
          <target state="translated">대체 디버그 기능을 설치할 수 있습니다. 이러한 함수의 예로는 이벤트가 생성 될 때 일부 특수 이벤트를 대기하고 일부 조치를 수행하는 함수 인 트리거가 있습니다. 예를 들어, 저수준 추적을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ffe6f57150e2b9c16f36b6e2673242748d6ce067" translate="yes" xml:space="preserve">
          <source>Enables modification of the logging behavior, see &lt;code&gt;&lt;a href=&quot;run_test_chapter#logopts&quot;&gt;Log options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로깅 동작을 수정할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;run_test_chapter#logopts&quot;&gt;Log options&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="357280b780d03061af846c26360d95eeff0c67f7" translate="yes" xml:space="preserve">
          <source>Enables modified timing and sets the modified timing level. Valid range is 0-9. The timing of the runtime system is changed. A high level usually means a greater change than a low level. Changing the timing can be very useful for finding timing-related bugs.</source>
          <target state="translated">수정 된 타이밍을 활성화하고 수정 된 타이밍 레벨을 설정합니다. 유효한 범위는 0-9입니다. 런타임 시스템의 타이밍이 변경되었습니다. 높은 수준은 일반적으로 낮은 수준보다 더 큰 변화를 의미합니다. 타이밍 변경은 타이밍 관련 버그를 찾는 데 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2af7dc33c7cb12530925d2f6df368f232e29cfaa" translate="yes" xml:space="preserve">
          <source>Enables or disables &lt;code&gt; scheduler utilization&lt;/code&gt; balancing of load. By default scheduler utilization balancing is disabled and instead scheduler compaction of load is enabled, which strives for a load distribution that causes as many scheduler threads as possible to be fully loaded (that is, not run out of work). When scheduler utilization balancing is enabled, the system instead tries to balance scheduler utilization between schedulers. That is, strive for equal scheduler utilization on all schedulers.</source>
          <target state="translated">로드의 &lt;code&gt; scheduler utilization&lt;/code&gt; 균형을 활성화하거나 비활성화합니다 . 기본적으로 스케줄러 활용 밸런싱은 비활성화되고 대신 스케줄러의로드 압축이 활성화되어 가능한 한 많은 스케줄러 스레드가 완전히로드되도록 (즉, 작업이 부족하지 않도록)로드 분산을 위해 노력합니다. 스케줄러 사용 밸런싱이 활성화되면 시스템은 대신 스케줄러간에 스케줄러 사용 밸런싱을 시도합니다. 즉, 모든 스케줄러에서 동일한 스케줄러 활용을 위해 노력해야합니다.</target>
        </trans-unit>
        <trans-unit id="615f0c0aff5e4fca8ae52bd7ab1a8c331579d793" translate="yes" xml:space="preserve">
          <source>Enables or disables &lt;code&gt;&lt;a href=&quot;time_correction#Time_Correction&quot;&gt;time correction&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Time_Correction&quot;&gt;time correction&lt;/a&gt;&lt;/code&gt; 활성화 또는 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="d823391dc2d43021b24dfe428d56fd43f464182a" translate="yes" xml:space="preserve">
          <source>Enables or disables &lt;code&gt;scheduler utilization&lt;/code&gt; balancing of load. By default scheduler utilization balancing is disabled and instead scheduler compaction of load is enabled, which strives for a load distribution that causes as many scheduler threads as possible to be fully loaded (that is, not run out of work). When scheduler utilization balancing is enabled, the system instead tries to balance scheduler utilization between schedulers. That is, strive for equal scheduler utilization on all schedulers.</source>
          <target state="translated">로드 &lt;code&gt;scheduler utilization&lt;/code&gt; 밸런싱을 활성화 또는 비활성화합니다 . 기본적으로 스케줄러 사용률 균형 조정이 비활성화되고 대신로드 스케줄러 압축이 활성화되어 가능한 많은 스케줄러 스레드가 완전히로드되도록 (즉, 작업이 부족하지 않은)로드 분배를 위해 노력합니다. 스케줄러 사용률 밸런싱이 활성화되면 시스템은 대신 스케줄러 간 스케쥴러 사용률을 조정하려고합니다. 즉, 모든 스케줄러에서 동일한 스케줄러 활용을 위해 노력하십시오.</target>
        </trans-unit>
        <trans-unit id="1e32eab9107eaf08c77b89032d18371faffb6cdc" translate="yes" xml:space="preserve">
          <source>Enables or disables &lt;strong&gt;call tracing&lt;/strong&gt; for one or more functions. Must be combined with &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; to set the &lt;code&gt;call&lt;/code&gt; trace flag for one or more processes.</source>
          <target state="translated">하나 이상의 기능에 대한 &lt;strong&gt;통화 추적&lt;/strong&gt; 을 활성화 또는 비활성화 합니다. 하나 이상의 프로세스에 대한 &lt;code&gt;call&lt;/code&gt; 추적 플래그 를 설정하려면 &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; 와 결합해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2526ae91dd204d3d2ab7ffcfeb2b5857d6c093f2" translate="yes" xml:space="preserve">
          <source>Enables or disables OS signals.</source>
          <target state="translated">OS 신호를 활성화 또는 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1c4032d67b9cd3bef26458eda1149afa48dbaf5f" translate="yes" xml:space="preserve">
          <source>Enables or disables printout of standard events to a file.</source>
          <target state="translated">표준 이벤트를 파일로 인쇄 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="f873933c3614b84347efc49bd44a15cf27eb0ad2" translate="yes" xml:space="preserve">
          <source>Enables or disables scheduler compaction of load. By default scheduler compaction of load is enabled. When enabled, load balancing strives for a load distribution, which causes as many scheduler threads as possible to be fully loaded (that is, not run out of work). This is accomplished by migrating load (for example, runnable processes) into a smaller set of schedulers when schedulers frequently run out of work. When disabled, the frequency with which schedulers run out of work is not taken into account by the load balancing logic.</source>
          <target state="translated">로드 스케줄러 압축을 활성화하거나 비활성화합니다. 로드 스케줄러 압축은 기본적으로 사용됩니다. 사용 가능한 경우로드 밸런싱은로드 분배를 시도하여 가능한 많은 스케줄러 스레드가 완전히로드되도록합니다 (즉, 작업이 부족하지 않음). 스케줄러가 자주 작업을 수행 할 때로드 (예 : 실행 가능한 프로세스)를 더 작은 스케줄러 세트로 마이그레이션하면됩니다. 비활성화하면 스케줄러의 작업 부족 빈도가로드 밸런싱 로직에 의해 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cac6a4d74e5fb7ad5378afd8802105af7c1d25f" translate="yes" xml:space="preserve">
          <source>Enables or disables the collection of statistics. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, the statistical collection is returned.</source>
          <target state="translated">통계 수집을 활성화하거나 비활성화합니다. 경우 &lt;code&gt;Flag&lt;/code&gt; 입니다 &lt;code&gt;get&lt;/code&gt; , 통계 수집이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="38ff1c7d6436d6406a601e79d21b1dc7a693e097" translate="yes" xml:space="preserve">
          <source>Enables or disables the logging of all system events in text format to the file. The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt;). The file is opened with encoding UTF-8.</source>
          <target state="translated">텍스트 형식의 모든 시스템 이벤트를 파일에 기록하는 기능을 활성화하거나 비활성화합니다. 이벤트는 이벤트를 생성 한 프로세스에 의해 정의 된 함수 ( &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4&lt;/a&gt;&lt;/code&gt; 에 대한 호출)로 형식화됩니다 . 파일은 UTF-8 인코딩으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="706a0f363687eafe06b91d6585ebbab3881c8cb3" translate="yes" xml:space="preserve">
          <source>Enables saving of abstract structure on file for debugging purpose.</source>
          <target state="translated">디버깅 목적으로 파일에 추상 구조를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9853ba1a8ea65043efdb893f1250a28d51ec84b" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;os_sup&lt;/code&gt; service. Needed on Solaris only.</source>
          <target state="translated">&lt;code&gt;os_sup&lt;/code&gt; 서비스를 활성화합니다 . Solaris에서만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3299ed2aa6cc796f27c06b5528ac008312e30a87" translate="yes" xml:space="preserve">
          <source>Enables the TLS/DTLS server to have a local policy for deciding if a session is to be reused or not. Meaningful only if &lt;code&gt;reuse_sessions&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;SuggestedSessionId&lt;/code&gt; is a &lt;code&gt;binary()&lt;/code&gt;, &lt;code&gt;PeerCert&lt;/code&gt; is a DER-encoded certificate, &lt;code&gt;Compression&lt;/code&gt; is an enumeration integer, and &lt;code&gt;CipherSuite&lt;/code&gt; is of type &lt;code&gt;ciphersuite()&lt;/code&gt;.</source>
          <target state="translated">TLS / DTLS 서버가 세션의 재사용 여부를 결정하기위한 로컬 정책을 갖도록합니다. &lt;code&gt;reuse_sessions&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우에만 의미 가 있습니다 . &lt;code&gt;SuggestedSessionId&lt;/code&gt; 는 &lt;code&gt;binary()&lt;/code&gt; 이고 &lt;code&gt;PeerCert&lt;/code&gt; 는 DER로 인코딩 된 인증서이고 &lt;code&gt;Compression&lt;/code&gt; 은 열거 정수이며 &lt;code&gt;CipherSuite&lt;/code&gt; 는 &lt;code&gt;ciphersuite()&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c522128b3a7019b49d9a0b8a5e0473a314dfc7fa" translate="yes" xml:space="preserve">
          <source>Enables the autoresume feature. When enabled, remote nodes try to reconnect to the controlling node if they are restarted. The feature requires application Runtime_Tools to be started (so it has to be present in the &lt;code&gt;.boot&lt;/code&gt; scripts if the traced nodes run with embedded Erlang). If this is not possible, resume can be performed manually by starting &lt;code&gt;Runtime_Tools&lt;/code&gt; remotely using &lt;code&gt;rpc:call/4&lt;/code&gt;.</source>
          <target state="translated">자동 재시작 기능을 활성화합니다. 사용 가능한 경우, 원격 노드는 다시 시작되면 제어 노드에 다시 연결을 시도합니다. 이 기능을 사용하려면 Runtime_Tools 응용 프로그램을 시작해야합니다 (따라서 추적 된 노드가 내장 된 Erlang으로 실행되는 경우 &lt;code&gt;.boot&lt;/code&gt; 스크립트 에 있어야 함 ). 이것이 가능하지 않은 경우 &lt;code&gt;rpc:call/4&lt;/code&gt; 를 사용하여 원격으로 &lt;code&gt;Runtime_Tools&lt;/code&gt; 를 시작 하여 수동으로 재개를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44c529662c2d69b9e4411fc182619f06a2aa4994" translate="yes" xml:space="preserve">
          <source>Enables the code path cache of the code server; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">코드 서버의 코드 경로 캐시를 활성화합니다. &lt;code&gt;code(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27f7a0694e3964dbe3f3f0deff4a82e761a20c55" translate="yes" xml:space="preserve">
          <source>Enables time correction. This is the default if time correction is supported on the specific platform.</source>
          <target state="translated">시간 수정을 활성화합니다. 특정 플랫폼에서 시간 수정이 지원되는 경우 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1f48bf86a5ea414b568d06bccd0c39df4107ada1" translate="yes" xml:space="preserve">
          <source>Enables to efficiently read the terms that are appended to a log. Minimises disk I/O by reading 64 kilobyte chunks from the file.</source>
          <target state="translated">로그에 추가 된 용어를 효율적으로 읽을 수 있습니다. 파일에서 64 킬로바이트 청크를 읽음으로써 디스크 I / O를 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="9a0c56d593d7b6385220fb5c3c0f22c02a031e9c" translate="yes" xml:space="preserve">
          <source>Enables tracing for all received messages (to &lt;code&gt;'receive'&lt;/code&gt; traced processes). Any match specification is removed. &lt;strong&gt;This is the default&lt;/strong&gt;.</source>
          <target state="translated">수신 된 모든 메시지에 대한 추적을 활성화합니다 ( 추적 된 프로세스 를 &lt;code&gt;'receive'&lt;/code&gt; 하기 위해 ). 모든 일치 사양이 제거됩니다. &lt;strong&gt;이것이 기본값&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0650d46dedcd7a949e16c3270a03871e5edb6c2" translate="yes" xml:space="preserve">
          <source>Enables tracing for all sent messages (from &lt;code&gt;send&lt;/code&gt; traced processes). Any match specification is removed. &lt;strong&gt;This is the default&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 추적 프로세스 에서 전송 된 모든 메시지에 대한 추적을 사용합니다 . 모든 일치 사양이 제거됩니다. &lt;strong&gt;이것이 기본값&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24884b0a02a3d3730cdbdf4ea864f21b5887858d" translate="yes" xml:space="preserve">
          <source>Enables tracing for the matching functions. Any match specification is removed.</source>
          <target state="translated">일치하는 기능에 대한 추적을 활성화합니다. 모든 일치 사양이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4dbe510dd55a873bed641c91ad586814883d3ac4" translate="yes" xml:space="preserve">
          <source>Enables verbose output.</source>
          <target state="translated">자세한 출력을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1d63208713c20c60f36d4a0bd52fdfeeaac74557" translate="yes" xml:space="preserve">
          <source>Enables/disables periodic transmission on a connected socket when no other data is exchanged. If the other end does not respond, the connection is considered broken and an error message is sent to the controlling process. Defaults to &lt;code&gt;disabled&lt;/code&gt;.</source>
          <target state="translated">다른 데이터가 교환되지 않을 때 연결된 소켓에서 주기적 전송을 활성화 / 비활성화합니다. 다른 쪽 끝이 응답하지 않으면 연결이 끊어진 것으로 간주되고 제어 프로세스에 오류 메시지가 전송됩니다. 기본값은 &lt;code&gt;disabled&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc8852a728863245cf6c2ea5864c53ec32099900" translate="yes" xml:space="preserve">
          <source>Enables/disables permission to send broadcasts.</source>
          <target state="translated">브로드 캐스트 전송 권한을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="50b6e1cb035c7e1653d306c33b0528a17000184c" translate="yes" xml:space="preserve">
          <source>Enables/disables routing bypass for outgoing messages.</source>
          <target state="translated">발신 메시지에 대한 라우팅 바이 패스를 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9fcc3abb54019e5dbbe11160d545772b5ffb3c9a" translate="yes" xml:space="preserve">
          <source>Enabling FIPS mode will also disable algorithms and features.</source>
          <target state="translated">FIPS 모드를 활성화하면 알고리즘과 기능도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="573a8fde2e1fa269c9fcf8e97134769f903a40af" translate="yes" xml:space="preserve">
          <source>Enabling the service includes actions which require root privileges, such as change of ownership and file privileges of an executable binary file, and creating a modified copy of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. When &lt;code&gt;os_sup&lt;/code&gt; is terminated, the service must be disabled, meaning the original configuration must be restored. Enabling/disabling can be done either outside or inside &lt;code&gt;os_sup&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">서비스를 사용 가능하게하려면 실행 가능한 2 진 파일의 소유권 변경 및 파일 권한, &lt;code&gt;syslogd&lt;/code&gt; 구성 파일의 수정 된 사본 작성과 같은 루트 권한이 필요한 조치가 포함됩니다 . 때 &lt;code&gt;os_sup&lt;/code&gt; 가 종료, 서비스는 원래 구성을 복원해야합니다 의미 비활성화해야합니다. 사용 / 사용 중 외부 또는 내부에 수행 할 수 있습니다 디스 에이블 &lt;code&gt;os_sup&lt;/code&gt; 를 참조 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 아래.</target>
        </trans-unit>
        <trans-unit id="d9f192da9606fd7fd5869526f37b21f3dd2a7c7e" translate="yes" xml:space="preserve">
          <source>Enabling the service includes actions which require root privileges, such as change of ownership and file privileges of an executable binary file, and creating a modified copy of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. When &lt;code&gt;os_sup&lt;/code&gt; is terminated, the service must be disabled, meaning the original configuration must be restored. Enabling/disabling can be done either outside or inside &lt;code&gt;os_sup&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; below.</source>
          <target state="translated">서비스 활성화에는 실행 가능한 바이너리 파일의 소유권 및 파일 권한 변경, &lt;code&gt;syslogd&lt;/code&gt; 에 대한 구성 파일의 수정 된 사본 생성과 같이 루트 권한이 필요한 작업이 포함됩니다 . 때 &lt;code&gt;os_sup&lt;/code&gt; 가 종료, 서비스는 원래 구성을 복원해야합니다 의미 비활성화해야합니다. 활성화 / 비활성화는 &lt;code&gt;os_sup&lt;/code&gt; 외부 또는 내부에서 수행 할 수 있습니다 . 아래 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c23d78e950c37608799201d0c2cc33f07da966c6" translate="yes" xml:space="preserve">
          <source>EncFlag :: true) -&amp;gt;</source>
          <target state="translated">EncFlag :: true) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c511033aa027d017fda29e8a006bfb9f353b3a48" translate="yes" xml:space="preserve">
          <source>EncFlag) -&amp;gt;</source>
          <target state="translated">EncFlag) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f4393b5f9d380987d4ced572aaef9ee8a74133bf" translate="yes" xml:space="preserve">
          <source>Enclosing mark</source>
          <target state="translated">인클로저 마크</target>
        </trans-unit>
        <trans-unit id="bca8cc4256c0c31c63935cf063643e54997e3d43" translate="yes" xml:space="preserve">
          <source>Encode (generate) an SDP construct.</source>
          <target state="translated">SDP 구성을 인코딩 (생성)하십시오.</target>
        </trans-unit>
        <trans-unit id="bc6b76a0bae3808e8c4c861292502c13fd082970" translate="yes" xml:space="preserve">
          <source>Encode a Diameter message.</source>
          <target state="translated">직경 메시지를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="f48c48f6cdcaa4ee965faed6f3e5d2dd4fe0ed0a" translate="yes" xml:space="preserve">
          <source>Encode a megaco action reply. If this, for whatever reason, is not supported, the function should return the error reason &lt;code&gt;not_implemented&lt;/code&gt;.</source>
          <target state="translated">megaco 액션 응답을 인코딩하십시오. 어떤 이유로 든 지원되지 않는 경우 함수는 &lt;code&gt;not_implemented&lt;/code&gt; 오류 이유를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="919696abd8a16da6f19a76ce339cffb55a6348e1" translate="yes" xml:space="preserve">
          <source>Encode a megaco message.</source>
          <target state="translated">megaco 메시지를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="267e2bf6ea12bf30c6d27046637855d09ac7cfca" translate="yes" xml:space="preserve">
          <source>Encode a megaco transaction. If this, for whatever reason, is not supported, the function should return the error reason &lt;code&gt;not_implemented&lt;/code&gt;.</source>
          <target state="translated">megaco 거래를 인코딩하십시오. 어떤 이유로 든 지원되지 않는 경우 함수는 &lt;code&gt;not_implemented&lt;/code&gt; 오류 이유를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="70ef8fa05ae9c6457354b1cad354772ba81b3d6f" translate="yes" xml:space="preserve">
          <source>Encode and Decode Functions for SNMP PDUs</source>
          <target state="translated">SNMP PDU의 인코딩 및 디코딩 기능</target>
        </trans-unit>
        <trans-unit id="102d654a81f03bcc7db3fbb3416263b493d476e7" translate="yes" xml:space="preserve">
          <source>Encode megaco action requests. This function is called when the user calls the function &lt;code&gt;&lt;a href=&quot;megaco#encode_actions&quot;&gt;encode_actions/3&lt;/a&gt;&lt;/code&gt;. If that function is never used or if the codec cannot support this (the encoding of individual actions), then return with error reason &lt;code&gt;not_implemented&lt;/code&gt;.</source>
          <target state="translated">megaco 활동 요청을 인코딩하십시오. 이 함수는 사용자가 &lt;code&gt;&lt;a href=&quot;megaco#encode_actions&quot;&gt;encode_actions/3&lt;/a&gt;&lt;/code&gt; 함수를 호출 할 때 호출됩니다 . 해당 함수를 사용하지 않거나 코덱에서이를 지원할 수없는 경우 (개별 조치의 인코딩), &lt;code&gt;not_implemented&lt;/code&gt; 오류 이유와 함께 리턴 하십시오 .</target>
        </trans-unit>
        <trans-unit id="27f649a79f32171afe094c758b92176d7cfd9a23" translate="yes" xml:space="preserve">
          <source>Encoded as an atom, using &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt; ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt;. Is the module that the fun is implemented in.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt; ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt; 를 사용하여 원자로 인코딩됩니다 . 재미가 구현되는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="cc7359ada67aed32ddecafb9495d6e88769570ad" translate="yes" xml:space="preserve">
          <source>Encoded as an atom, using &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt;. Is the module that the fun is implemented in.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt; 를 사용하여 아톰으로 인코딩됩니다 . 재미가 구현 된 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="e3b928bc70891ebc97a0d114e15fcabc81155c57" translate="yes" xml:space="preserve">
          <source>Encoded as an atom, using &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt; ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt;. This is the module that the fun is implemented in.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt; ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt; 를 사용하여 원자로 인코딩됩니다 . 재미가 구현되는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="a95dc8048f6280b2e1bb9aeb3ae170e17dd6166e" translate="yes" xml:space="preserve">
          <source>Encoded as an atom, using &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt;. This is the module that the fun is implemented in.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt; 를 사용하여 아톰으로 인코딩됩니다 . 재미가 구현되는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="5443536e350a97a2172212037b9f508ff80ac36e" translate="yes" xml:space="preserve">
          <source>Encodes SNMP UsmSecurityParameters into a list of bytes.</source>
          <target state="translated">SNMP UsmSecurityParameters를 바이트 목록으로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="05c49e564fbd4be907c60f1d9484dc8cfc4ffd8d" translate="yes" xml:space="preserve">
          <source>Encodes a GCC &lt;code&gt;long long&lt;/code&gt; or Visual C++ &lt;code&gt;__int64&lt;/code&gt; (64-bit) integer in the binary format.</source>
          <target state="translated">GCC &lt;code&gt;long long&lt;/code&gt; 또는 Visual C ++ &lt;code&gt;__int64&lt;/code&gt; (64 비트) 정수를 이진 형식으로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="8ea1eab2759b39f44eff8aedf3f696f0b6c8fa67" translate="yes" xml:space="preserve">
          <source>Encodes a GCC &lt;code&gt;long long&lt;/code&gt; or Visual C++ &lt;code&gt;__int64&lt;/code&gt; (64-bit) integer in the binary format. This function is missing in the VxWorks port.</source>
          <target state="translated">GCC &lt;code&gt;long long&lt;/code&gt; 또는 Visual C ++ &lt;code&gt;__int64&lt;/code&gt; (64 비트) 정수를 이진 형식으로 인코딩합니다. 이 기능은 VxWorks 포트에 없습니다.</target>
        </trans-unit>
        <trans-unit id="d64be51e43c6327060d25b2637eaf89a5fdf21ec" translate="yes" xml:space="preserve">
          <source>Encodes a GCC &lt;code&gt;unsigned long long&lt;/code&gt; or Visual C++ &lt;code&gt;unsigned __int64&lt;/code&gt; (64-bit) integer in the binary format.</source>
          <target state="translated">GCC &lt;code&gt;unsigned long long&lt;/code&gt; 또는 Visual C ++ &lt;code&gt;unsigned __int64&lt;/code&gt; (64 비트) 정수를 이진 형식으로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="39db68723a1e70c2f41cfe15c0c139b726cce330" translate="yes" xml:space="preserve">
          <source>Encodes a GCC &lt;code&gt;unsigned long long&lt;/code&gt; or Visual C++ &lt;code&gt;unsigned __int64&lt;/code&gt; (64-bit) integer in the binary format. This function is missing in the VxWorks port.</source>
          <target state="translated">GCC &lt;code&gt;unsigned long long&lt;/code&gt; 또는 Visual C ++ &lt;code&gt;unsigned __int64&lt;/code&gt; (64 비트) 정수를 이진 형식으로 인코딩합니다. 이 기능은 VxWorks 포트에 없습니다.</target>
        </trans-unit>
        <trans-unit id="55cf245f3abef1d97562ca0510d5aa54ddef2103" translate="yes" xml:space="preserve">
          <source>Encodes a GMP &lt;code&gt;mpz_t&lt;/code&gt; integer to binary format. To use this function, the &lt;code&gt;ei&lt;/code&gt; library must be configured and compiled to use the GMP library.</source>
          <target state="translated">GMP &lt;code&gt;mpz_t&lt;/code&gt; 정수를 이진 형식으로 인코딩 합니다. 이 기능을 사용하려면 &lt;code&gt;ei&lt;/code&gt; 라이브러리를 구성하고 GMP 라이브러리를 사용하도록 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="544dc6535c1f9dfc1c63c385c2a64dabd5493e6d" translate="yes" xml:space="preserve">
          <source>Encodes a binary in the binary format. The data is at &lt;code&gt;p&lt;/code&gt;, of &lt;code&gt;len&lt;/code&gt; bytes length.</source>
          <target state="translated">이진을 이진 형식으로 인코딩합니다. 데이터는 &lt;code&gt;p&lt;/code&gt; 의 &lt;code&gt;len&lt;/code&gt; 바이트 길이입니다.</target>
        </trans-unit>
        <trans-unit id="d8c975263ee4e63639cef44170082c635d8ecbe5" translate="yes" xml:space="preserve">
          <source>Encodes a bit string in the binary format.</source>
          <target state="translated">이진 형식으로 비트 문자열을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="299ae563f3b560341ecaf360dad29cc4e64c195f" translate="yes" xml:space="preserve">
          <source>Encodes a boolean value as the atom &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;p&lt;/code&gt; is not zero, or &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;p&lt;/code&gt; is zero.</source>
          <target state="translated">원자로서 부울 값 인코딩 &lt;code&gt;true&lt;/code&gt; 한다면 &lt;code&gt;p&lt;/code&gt; 가 0이 아닌이거나 &lt;code&gt;false&lt;/code&gt; 있다면 &lt;code&gt;p&lt;/code&gt; 제로이다.</target>
        </trans-unit>
        <trans-unit id="142d43fe975c5f4b8920a4641578639d19a398ce" translate="yes" xml:space="preserve">
          <source>Encodes a char (8-bit) as an integer between 0-255 in the binary format. For historical reasons the integer argument is of type &lt;code&gt;char&lt;/code&gt;. Your C code is to consider the specified argument to be of type &lt;code&gt;unsigned char&lt;/code&gt; even if the C compilers and system may define &lt;code&gt;char&lt;/code&gt; to be signed.</source>
          <target state="translated">문자 (8 비트)를 이진 형식으로 0-255 사이의 정수로 인코딩합니다. 역사적 이유로 정수 인수는 &lt;code&gt;char&lt;/code&gt; 유형 입니다. C 컴파일러와 시스템이 &lt;code&gt;char&lt;/code&gt; 를 서명하도록 정의하더라도 C 코드는 지정된 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 유형으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="67efd073e483aab3ad7bd50ac03659126a68c7e9" translate="yes" xml:space="preserve">
          <source>Encodes a double-precision (64-bit) floating point number in the binary format.</source>
          <target state="translated">배정도 (64 비트) 부동 소수점 숫자를 이진 형식으로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="db6231d4a9f50aa12152f662f310840279de88e9" translate="yes" xml:space="preserve">
          <source>Encodes a fun in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to an &lt;code&gt;erlang_fun&lt;/code&gt; structure. The &lt;code&gt;erlang_fun&lt;/code&gt; is not freed automatically, the &lt;code&gt;free_fun&lt;/code&gt; is to be called if the fun is not needed after encoding.</source>
          <target state="translated">이진 형식으로 재미를 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;erlang_fun&lt;/code&gt; 구조를 가리 킵니다 . &lt;code&gt;erlang_fun&lt;/code&gt; 가 자동으로 해제되지는 &lt;code&gt;free_fun&lt;/code&gt; 는 재미가 인코딩 후 필요하지 않은 경우라고 할 수있다.</target>
        </trans-unit>
        <trans-unit id="f3eb79e01a1e1ed3ff93bc0825828edeff65ab2a" translate="yes" xml:space="preserve">
          <source>Encodes a hexadecimal encoded URI.</source>
          <target state="translated">16 진수로 인코딩 된 URI를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="5399714ce3209e4c7dc2e47140aed28f61fcb18b" translate="yes" xml:space="preserve">
          <source>Encodes a list header, with a specified arity. The next &lt;code&gt;arity+1&lt;/code&gt; terms are the elements (actually its &lt;code&gt;arity&lt;/code&gt; cons cells) and the tail of the list. Lists and tuples are encoded recursively, so that a list can contain another list or tuple.</source>
          <target state="translated">지정된 arity로 목록 헤더를 인코딩합니다. 다음 &lt;code&gt;arity+1&lt;/code&gt; 항은 요소 (실제로 &lt;code&gt;arity&lt;/code&gt; cons 셀)와 목록의 꼬리입니다. 목록과 튜플은 재귀 적으로 인코딩되므로 목록에 다른 목록이나 튜플이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c38845bcb5dace03433d108ba34545ffac9a2ca1" translate="yes" xml:space="preserve">
          <source>Encodes a list of SSH file entries (public keys and attributes) to a binary. Possible attributes depend on the file type, see &lt;code&gt;&lt;a href=&quot;#ssh_decode-2&quot;&gt; ssh_decode/2 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SSH 파일 항목 (공개 키 및 속성) 목록을 바이너리로 인코딩합니다. 가능한 속성은 파일 유형에 따라 다릅니다 . &lt;code&gt;&lt;a href=&quot;#ssh_decode-2&quot;&gt; ssh_decode/2 &lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="147dc6f64e18686ce3670e474f6c9a004c8a9d94" translate="yes" xml:space="preserve">
          <source>Encodes a list of SSH file entries (public keys and attributes) to a binary. Possible attributes depend on the file type, see &lt;code&gt;&lt;a href=&quot;#ssh_decode-2&quot;&gt;ssh_decode/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SSH 파일 항목 (공개 키 및 속성) 목록을 이진으로 인코딩합니다. 가능한 속성은 파일 유형에 따라 다릅니다 ( &lt;code&gt;&lt;a href=&quot;#ssh_decode-2&quot;&gt;ssh_decode/2&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6f31b421de29ccdfdf7d6795da67adc1e51b10ef" translate="yes" xml:space="preserve">
          <source>Encodes a long integer in the binary format. If the code is 64 bits, the function &lt;code&gt;ei_encode_long()&lt;/code&gt; is the same as &lt;code&gt;ei_encode_longlong()&lt;/code&gt;.</source>
          <target state="translated">이진 형식으로 긴 정수를 인코딩합니다. 코드가 64 비트이면, 기능 &lt;code&gt;ei_encode_long()&lt;/code&gt; 와 동일 &lt;code&gt;ei_encode_longlong()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e21387f38bf5a4c0a9713f0fa95d428b5ff9e790" translate="yes" xml:space="preserve">
          <source>Encodes a map header, with a specified arity. The next &lt;code&gt;arity*2&lt;/code&gt; terms encoded will be the keys and values of the map encoded in the following order: &lt;code&gt;K1, V1, K2, V2, ..., Kn, Vn&lt;/code&gt;.</source>
          <target state="translated">지정된 arity를 ​​사용하여 맵 헤더를 인코딩합니다. 인코딩 된 다음 &lt;code&gt;arity*2&lt;/code&gt; 항은 &lt;code&gt;K1, V1, K2, V2, ..., Kn, Vn&lt;/code&gt; 순서로 인코딩 된 맵의 키와 값입니다 .</target>
        </trans-unit>
        <trans-unit id="2546def3bbd440ddf28860d54071b17b07162883" translate="yes" xml:space="preserve">
          <source>Encodes a map. The &lt;code&gt;Arity&lt;/code&gt; field is an unsigned 4 byte integer in big-endian format that determines the number of key-value pairs in the map. Key and value pairs (&lt;code&gt;Ki =&amp;gt; Vi&lt;/code&gt;) are encoded in section &lt;code&gt;Pairs&lt;/code&gt; in the following order: &lt;code&gt;K1, V1, K2, V2,..., Kn, Vn&lt;/code&gt;. Duplicate keys are &lt;strong&gt;not allowed&lt;/strong&gt; within the same map.</source>
          <target state="translated">지도를 인코딩합니다. &lt;code&gt;Arity&lt;/code&gt; 필드 맵의 키 - 값 쌍들의 수를 결정 빅 엔디안 포맷의 부호 4 바이트의 정수이다. 키 및 값 쌍 ( &lt;code&gt;Ki =&amp;gt; Vi&lt;/code&gt; )은 &lt;code&gt;K1, V1, K2, V2,..., Kn, Vn&lt;/code&gt; 순서대로 &lt;code&gt;Pairs&lt;/code&gt; 으로 인코딩됩니다 . 동일한 맵 내에서 중복 키를 사용할 수 &lt;strong&gt;없습니다&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b27883b4382c2510b413fda75eddb65df243c0c9" translate="yes" xml:space="preserve">
          <source>Encodes a message record to a list of bytes.</source>
          <target state="translated">메시지 레코드를 바이트 목록으로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b6f25f641b062915fd5ff3685b3d015468c770da" translate="yes" xml:space="preserve">
          <source>Encodes a plain ASCII string into base64. The result is 33% larger than the data.</source>
          <target state="translated">일반 ASCII 문자열을 base64로 인코딩합니다. 결과는 데이터보다 33 % 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="b802ae599eede9a33aeccb37997540cbabbc2e45" translate="yes" xml:space="preserve">
          <source>Encodes a port identifier (obtained from &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;Node&lt;/code&gt; is an encoded atom, that is, &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ID&lt;/code&gt; is a 32-bit big endian unsigned integer. Only 28 bits are significant; the rest are to be 0. The &lt;code&gt;Creation&lt;/code&gt; works just like in &lt;code&gt;&lt;a href=&quot;#NEW_PID_EXT&quot;&gt;NEW_PID_EXT&lt;/a&gt;&lt;/code&gt;. Port operations are not allowed across node boundaries.</source>
          <target state="translated">포트 식별자를 인코딩합니다 ( &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 에서 가져옴 ). &lt;code&gt;Node&lt;/code&gt; 는 인코딩 된 원자, 즉 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;ID&lt;/code&gt; 는 32 비트 빅 엔디안 부호없는 정수입니다. 28 비트 만 중요합니다. 나머지는 0이됩니다. &lt;code&gt;Creation&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#NEW_PID_EXT&quot;&gt;NEW_PID_EXT&lt;/a&gt;&lt;/code&gt; 에서처럼 작동합니다 . 노드 경계를 넘어 포트 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f259a9111053ee9b0ff27ad8b8e26394495297ef" translate="yes" xml:space="preserve">
          <source>Encodes a port object (obtained from &lt;code&gt;erlang:open_port/2&lt;/code&gt;). The &lt;code&gt;ID&lt;/code&gt; is a node-specific identifier for a local port. Port operations are not allowed across node boundaries. The &lt;code&gt;Creation&lt;/code&gt; works just like in &lt;code&gt;&lt;a href=&quot;#REFERENCE_EXT&quot;&gt;REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트 오브젝트를 인코딩합니다 ( &lt;code&gt;erlang:open_port/2&lt;/code&gt; 에서 얻음 ). &lt;code&gt;ID&lt;/code&gt; 는 로컬 포트 노드 고유 식별자이다. 포트 경계는 노드 경계에서 허용되지 않습니다. &lt;code&gt;Creation&lt;/code&gt; 그냥 같이 작동 &lt;code&gt;&lt;a href=&quot;#REFERENCE_EXT&quot;&gt;REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="932182b383208ca8056944faa1099a6c8e6ac0c8" translate="yes" xml:space="preserve">
          <source>Encodes a process identifier object (obtained from &lt;code&gt;erlang:spawn/3&lt;/code&gt; or friends). The &lt;code&gt;ID&lt;/code&gt; and &lt;code&gt;Creation&lt;/code&gt; fields works just like in &lt;code&gt;&lt;a href=&quot;#REFERENCE_EXT&quot;&gt;REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;, while the &lt;code&gt;Serial&lt;/code&gt; field is used to improve safety. In &lt;code&gt;ID&lt;/code&gt;, only 15 bits are significant; the rest are to be 0.</source>
          <target state="translated">프로세스 식별자 객체를 인코딩합니다 ( &lt;code&gt;erlang:spawn/3&lt;/code&gt; 또는 friends 에서 얻음 ). &lt;code&gt;ID&lt;/code&gt; 와 &lt;code&gt;Creation&lt;/code&gt; 필드는 그냥 같이 작동 &lt;code&gt;&lt;a href=&quot;#REFERENCE_EXT&quot;&gt;REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; 그동안, &lt;code&gt;Serial&lt;/code&gt; 필드가 안전을 개선하는 데 사용됩니다. 에서는 &lt;code&gt;ID&lt;/code&gt; , 15 비트 만이 중요하다; 나머지는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d1d57a8c127d4d4f839416c50c0fbbba2f4d4ff0" translate="yes" xml:space="preserve">
          <source>Encodes a public-key entity with ASN.1 DER encoding.</source>
          <target state="translated">ASN.1 DER 인코딩으로 공개 키 엔터티를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="d5c308d0994008ccda7fbbad7266dbb74c32be53" translate="yes" xml:space="preserve">
          <source>Encodes a reference object (an object generated with &lt;code&gt;erlang:make_ref/0&lt;/code&gt;). The &lt;code&gt;Node&lt;/code&gt; term is an encoded atom, that is, &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;ID&lt;/code&gt; field contains a big-endian unsigned integer, but &lt;strong&gt;is to be regarded as uninterpreted data&lt;/strong&gt;, as this field is node-specific. &lt;code&gt;Creation&lt;/code&gt; is a byte containing a node serial number, which makes it possible to separate old (crashed) nodes from a new one.</source>
          <target state="translated">참조 객체 ( &lt;code&gt;erlang:make_ref/0&lt;/code&gt; 으로 생성 된 객체)를 인코딩합니다 . &lt;code&gt;Node&lt;/code&gt; 용어이며, 인코딩 원자이다 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#ATOM_CACHE_REF&quot;&gt;ATOM_CACHE_REF&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ID&lt;/code&gt; 의 필드는 빅 엔디안 부호 정수를 포함하고 있지만, &lt;strong&gt;해석되지 않은 데이터로 간주 될&lt;/strong&gt; 이 필드는 특정 노드와 같이. &lt;code&gt;Creation&lt;/code&gt; 은 노드 일련 번호를 포함하는 바이트이므로 오래된 (크래쉬 된) 노드를 새 노드와 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="24deef8b706bf9138b53949d3749385135e65888" translate="yes" xml:space="preserve">
          <source>Encodes a reference term generated with &lt;code&gt;erlang:make_ref/0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:make_ref/0&lt;/code&gt; 으로 생성 된 참조 용어를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="6983fa67de59179a533f84dd86b3b1e63cddb353" translate="yes" xml:space="preserve">
          <source>Encodes a string in the binary format. (A string in Erlang is a list, but is encoded as a character array in the binary format.) The string is to be &lt;code&gt;NULL&lt;/code&gt;-terminated, except for the &lt;code&gt;ei_x_encode_string_len()&lt;/code&gt; function.</source>
          <target state="translated">이진 형식으로 문자열을 인코딩합니다. (Erlang의 문자열은 목록이지만 이진 형식의 문자 배열로 인코딩됩니다.) 문자열은 &lt;code&gt;ei_x_encode_string_len()&lt;/code&gt; 함수를 제외하고 &lt;code&gt;NULL&lt;/code&gt; 로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="e2ae83f97c681fcce7637008f4816fc10f123e4c" translate="yes" xml:space="preserve">
          <source>Encodes a tuple header, with a specified arity. The next &lt;code&gt;arity&lt;/code&gt; terms encoded will be the elements of the tuple. Tuples and lists are encoded recursively, so that a tuple can contain another tuple or list.</source>
          <target state="translated">지정된 arity로 튜플 헤더를 인코딩합니다. 인코딩 된 다음 &lt;code&gt;arity&lt;/code&gt; 용어는 튜플의 요소입니다. 튜플과 목록은 재귀 적으로 인코딩되므로 튜플에 다른 튜플이나 목록이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af2b02a0991d4ce3fe7390de348cf477759d00a2" translate="yes" xml:space="preserve">
          <source>Encodes a tuple. The &lt;code&gt;Arity&lt;/code&gt; field is an unsigned byte that determines how many elements that follows in section &lt;code&gt;Elements&lt;/code&gt;.</source>
          <target state="translated">튜플을 인코딩합니다. &lt;code&gt;Arity&lt;/code&gt; 필드는 다음 섹션에서 얼마나 많은 요소 결정 부호 바이트 &lt;code&gt;Elements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2f2a72085c885a819e529abe0ff0a7d2d676e0" translate="yes" xml:space="preserve">
          <source>Encodes a version magic number for the binary format. Must be the first token in a binary term.</source>
          <target state="translated">이진 형식의 버전 매직 번호를 인코딩합니다. 이진 용어의 첫 번째 토큰이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae0c72ad2f8d0c485999de767a4b3183dca88051" translate="yes" xml:space="preserve">
          <source>Encodes an &lt;code&gt;ETERM&lt;/code&gt;, as obtained from &lt;code&gt;erl_interface&lt;/code&gt;. Parameter &lt;code&gt;t&lt;/code&gt; is actually an &lt;code&gt;ETERM&lt;/code&gt; pointer. This function does not free the &lt;code&gt;ETERM&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erl_interface&lt;/code&gt; 에서 얻은 &lt;code&gt;ETERM&lt;/code&gt; 을 인코딩합니다 . 매개 변수 &lt;code&gt;t&lt;/code&gt; 는 실제로 &lt;code&gt;ETERM&lt;/code&gt; 포인터입니다. 이 기능은 &lt;code&gt;ETERM&lt;/code&gt; 을 해제하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10d886679d977f90bbba34649f46a0bc55f76d91" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang port in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to a &lt;code&gt;erlang_port&lt;/code&gt; structure (which should have been obtained earlier with &lt;code&gt;ei_decode_port()&lt;/code&gt;).</source>
          <target state="translated">Erlang 포트를 이진 형식으로 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;erlang_port&lt;/code&gt; 구조를 가리 킵니다 (이는 &lt;code&gt;ei_decode_port()&lt;/code&gt; 이전에 얻어야 함 ).</target>
        </trans-unit>
        <trans-unit id="57c2dd5bf4d9ab71118fad79de37a4af2bd1eb60" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang port in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to an &lt;code&gt;erlang_port&lt;/code&gt; structure which should have been obtained earlier with &lt;code&gt;&lt;a href=&quot;#ei_decode_port&quot;&gt;ei_decode_port()&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">바이너리 형식으로 Erlang 포트를 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 이전에 &lt;code&gt;&lt;a href=&quot;#ei_decode_port&quot;&gt;ei_decode_port()&lt;/a&gt;&lt;/code&gt; 로 얻어야 하는 &lt;code&gt;erlang_port&lt;/code&gt; 구조를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="84cff2ec5d925031dfc127de573af284d6e74099" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang process identifier (pid) in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to an &lt;code&gt;erlang_pid&lt;/code&gt; structure (which should have been obtained earlier with &lt;code&gt;ei_decode_pid()&lt;/code&gt;).</source>
          <target state="translated">Erlang 프로세스 식별자 (pid)를 이진 형식으로 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;erlang_pid&lt;/code&gt; 구조를 가리 킵니다 (이는 &lt;code&gt;ei_decode_pid()&lt;/code&gt; 이전에 얻어야 함 ).</target>
        </trans-unit>
        <trans-unit id="76d4026c81383707cf21ce4f5ea832412535d302" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang process identifier (pid) in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to an &lt;code&gt;erlang_pid&lt;/code&gt; structure which should either have been obtained earlier with &lt;code&gt;&lt;a href=&quot;#ei_decode_pid&quot;&gt;ei_decode_pid()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ei_connect#ei_self&quot;&gt;ei_self()&lt;/a&gt;&lt;/code&gt; or created by &lt;code&gt;&lt;a href=&quot;ei_connect#ei_make_pid&quot;&gt;ei_make_pid()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">바이너리 형식으로 Erlang 프로세스 식별자 (pid)를 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#ei_decode_pid&quot;&gt;ei_decode_pid()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ei_connect#ei_self&quot;&gt;ei_self()&lt;/a&gt;&lt;/code&gt; 이전에 얻었 거나 &lt;code&gt;&lt;a href=&quot;ei_connect#ei_make_pid&quot;&gt;ei_make_pid()&lt;/a&gt;&lt;/code&gt; 의해 생성 되어야 하는 &lt;code&gt;erlang_pid&lt;/code&gt; 구조를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="3be5890e73faf95f1e9738591e16dd49e1a75403" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang process identifier object.</source>
          <target state="translated">Erlang 프로세스 식별자 개체를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="9ce17988f46a89b28dc4f99e5d98e8c260c68401" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang reference in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to a &lt;code&gt;erlang_ref&lt;/code&gt; structure (which should have been obtained earlier with &lt;code&gt;ei_decode_ref()&lt;/code&gt;).</source>
          <target state="translated">Erlang 참조를 이진 형식으로 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;erlang_ref&lt;/code&gt; 구조를 가리 킵니다 (이는 &lt;code&gt;ei_decode_ref()&lt;/code&gt; 이전에 얻어야 함 ).</target>
        </trans-unit>
        <trans-unit id="42aec85ff02503e0f4c4f2565e162785b5c185dc" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang reference in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to an &lt;code&gt;erlang_ref&lt;/code&gt; structure which either should have been obtained earlier with &lt;code&gt;&lt;a href=&quot;#ei_decode_ref&quot;&gt;ei_decode_ref()&lt;/a&gt;&lt;/code&gt;, or created by &lt;code&gt;&lt;a href=&quot;ei_connect#ei_make_ref&quot;&gt;ei_make_ref()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">바이너리 형식으로 Erlang 참조를 인코딩합니다. 파라미터 &lt;code&gt;p&lt;/code&gt; 포인트 &lt;code&gt;erlang_ref&lt;/code&gt; 의 하나와 이전 획득 했어야 구조 &lt;code&gt;&lt;a href=&quot;#ei_decode_ref&quot;&gt;ei_decode_ref()&lt;/a&gt;&lt;/code&gt; 의해, 또는 생성 &lt;code&gt;&lt;a href=&quot;ei_connect#ei_make_ref&quot;&gt;ei_make_ref()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0c685069d4686caf8919a29aeb6dfc4a6579c5a" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang trace token in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to a &lt;code&gt;erlang_trace&lt;/code&gt; structure (which should have been obtained earlier with &lt;code&gt;ei_decode_trace()&lt;/code&gt;).</source>
          <target state="translated">Erlang 추적 토큰을 이진 형식으로 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;erlang_trace&lt;/code&gt; 구조를 가리 킵니다 (이는 &lt;code&gt;ei_decode_trace()&lt;/code&gt; 이전에 얻어야 함 ).</target>
        </trans-unit>
        <trans-unit id="cccb0cf6d3e8be746acb491ce06d7536ce870985" translate="yes" xml:space="preserve">
          <source>Encodes an Erlang trace token in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; points to a &lt;code&gt;erlang_trace&lt;/code&gt; structure which should have been obtained earlier with &lt;code&gt;&lt;a href=&quot;#ei_decode_trace&quot;&gt;ei_decode_trace()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 추적 토큰을 바이너리 형식으로 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#ei_decode_trace&quot;&gt;ei_decode_trace()&lt;/a&gt;&lt;/code&gt; 하여 이전에 얻어야 하는 &lt;code&gt;erlang_trace&lt;/code&gt; 구조를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="b9f856403e1104e3c2f173fa6a9b9b6e634523b8" translate="yes" xml:space="preserve">
          <source>Encodes an SNMP Pdu into a list of bytes.</source>
          <target state="translated">SNMP Pdu를 바이트 목록으로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="9d75b733671e6cee7bbd4d4fc7c1ed464bbc1703" translate="yes" xml:space="preserve">
          <source>Encodes an SNMP ScopedPdu into a list of bytes, which can be encrypted, and after encryption, encoded with a call to &lt;code&gt;enc_encrypted_scoped_pdu/1&lt;/code&gt;; or it can be used as the &lt;code&gt;data&lt;/code&gt; field in a &lt;code&gt;message&lt;/code&gt; record, which then can be encoded with &lt;code&gt;enc_message_only/1&lt;/code&gt;.</source>
          <target state="translated">SNMP ScopedPdu를 바이트 목록으로 인코딩합니다. 바이트 목록은 암호화 할 수 있으며 암호화 후 &lt;code&gt;enc_encrypted_scoped_pdu/1&lt;/code&gt; ; 또는 &lt;code&gt;message&lt;/code&gt; 레코드 의 &lt;code&gt;data&lt;/code&gt; 필드 로 사용 된 다음 &lt;code&gt;enc_message_only/1&lt;/code&gt; 로 인코딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fa4782273dd88937b487ef08be79b1c172a8262" translate="yes" xml:space="preserve">
          <source>Encodes an atom in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; is the name of the atom in Latin-1 encoding. Only up to &lt;code&gt;MAXATOMLEN-1&lt;/code&gt; bytes are encoded. The name is to be &lt;code&gt;NULL&lt;/code&gt;-terminated, except for the &lt;code&gt;ei_x_encode_atom_len()&lt;/code&gt; function.</source>
          <target state="translated">원자를 이진 형식으로 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 라틴 -1 인코딩에서 아톰의 이름입니다. 최대 &lt;code&gt;MAXATOMLEN-1&lt;/code&gt; 바이트 만 인코딩됩니다. &lt;code&gt;ei_x_encode_atom_len()&lt;/code&gt; 함수를 제외하고 이름은 &lt;code&gt;NULL&lt;/code&gt; 로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="f94986d6669031c5feff3d3d35f84974a46d32f0" translate="yes" xml:space="preserve">
          <source>Encodes an atom in the binary format. Parameter &lt;code&gt;p&lt;/code&gt; is the name of the atom with character encoding &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;from_enc&lt;/a&gt;&lt;/code&gt; (ASCII, Latin-1, or UTF-8). The name must either be &lt;code&gt;NULL&lt;/code&gt;-terminated or a function variant with a &lt;code&gt;len&lt;/code&gt; parameter must be used.</source>
          <target state="translated">원자를 이진 형식으로 인코딩합니다. 매개 변수 &lt;code&gt;p&lt;/code&gt; 는 문자 인코딩 &lt;code&gt;&lt;a href=&quot;#erlang_char_encoding&quot;&gt;from_enc&lt;/a&gt;&lt;/code&gt; (ASCII, Latin-1 또는 UTF-8) 가있는 아톰의 이름입니다 . 이름은 &lt;code&gt;NULL&lt;/code&gt; 로 끝나거나 &lt;code&gt;len&lt;/code&gt; 매개 변수가 있는 함수 변형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e3d0bd7014773a7515a0eaf7ab7f8024249203d" translate="yes" xml:space="preserve">
          <source>Encodes an empty list. It is often used at the tail of a list.</source>
          <target state="translated">빈 목록을 인코딩합니다. 목록의 맨 끝에 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2b02552e4f57bba027c20fbe76f0bfb0d75eba" translate="yes" xml:space="preserve">
          <source>Encodes an encrypted SNMP ScopedPdu into an OCTET STRING that can be used as the &lt;code&gt;data&lt;/code&gt; field in a &lt;code&gt;message&lt;/code&gt; record, that later can be encoded with a call to &lt;code&gt;enc_message_only/1&lt;/code&gt;.</source>
          <target state="translated">암호화 된 SNMP ScopedPdu를 &lt;code&gt;message&lt;/code&gt; 레코드 의 &lt;code&gt;data&lt;/code&gt; 필드 로 사용할 수있는 OCTET STRING 으로 인코딩하고 나중에 &lt;code&gt;enc_message_only/1&lt;/code&gt; 에 대한 호출로 인코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="962d839134381a7bc1e8c5ef4283f55dd77d150b" translate="yes" xml:space="preserve">
          <source>Encodes an unsigned long integer in the binary format. If the code is 64 bits, the function &lt;code&gt;ei_encode_ulong()&lt;/code&gt; is the same as &lt;code&gt;ei_encode_ulonglong()&lt;/code&gt;.</source>
          <target state="translated">부호없는 long 정수를 이진 형식으로 인코딩합니다. 코드가 64 비트이면, 기능 &lt;code&gt;ei_encode_ulong()&lt;/code&gt; 와 동일 &lt;code&gt;ei_encode_ulonglong()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5e1d27c122466d30fe5743763ed3cb3299cfda" translate="yes" xml:space="preserve">
          <source>Encodes lists of action requests for one or more transaction request(s).</source>
          <target state="translated">하나 이상의 트랜잭션 요청에 대한 작업 요청 목록을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="bbe3771766e51314eec821af32519256d9e1cc6d" translate="yes" xml:space="preserve">
          <source>Encodes the message into a sequence of bytes.</source>
          <target state="translated">메시지를 일련의 바이트로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="a2c2a3dc80ffb53312ecf36ad1055545de7126f8" translate="yes" xml:space="preserve">
          <source>Encoding Public-Key Data to PEM Format</source>
          <target state="translated">공개 키 데이터를 PEM 형식으로 인코딩</target>
        </trans-unit>
        <trans-unit id="cf6e4cd7c6b0e3f5f929b22e1120f33b38cfc968" translate="yes" xml:space="preserve">
          <source>Encoding and decoding a string with Unicode characters:</source>
          <target state="translated">유니 코드 문자로 문자열 인코딩 및 디코딩 :</target>
        </trans-unit>
        <trans-unit id="a833e98a67285a4ac9faa7fbff167440c5860f43" translate="yes" xml:space="preserve">
          <source>Encoding and decoding must be done explicitly when writing your own Net if process.</source>
          <target state="translated">자체 Net if 프로세스를 작성할 때 인코딩 및 디코딩을 명시 적으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="821139729ae337d85e016cf0241920c56421ecd7" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of Erlang data types for transmission or storage</source>
          <target state="translated">전송 또는 저장을위한 Erlang 데이터 유형의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="f9f2b1897f0182522c31ea4a8622e8b2d5090ec8" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of Erlang terms.</source>
          <target state="translated">Erlang 용어의 인코딩 및 디코딩.</target>
        </trans-unit>
        <trans-unit id="362851a55df47e950b8ac4b7e6c244c360537b26" translate="yes" xml:space="preserve">
          <source>Encoding and decoding some strings:</source>
          <target state="translated">일부 문자열 인코딩 및 디코딩 :</target>
        </trans-unit>
        <trans-unit id="957bacdea81312911c1ae130271010f5a65da159" translate="yes" xml:space="preserve">
          <source>Encoding callback module which exports encode_message/2 and decode_message/2. The function EncodingMod:encode_message(EncodingConfig, MegacoMessage) is invoked whenever a 'MegacoMessage' record needs to be translated into an Erlang binary. The function EncodingMod:decode_message(EncodingConfig, Binary) is invoked whenever an Erlang binary needs to be translated into a 'MegacoMessage' record.</source>
          <target state="translated">encode_message / 2 및 decode_message / 2를 내보내는 인코딩 콜백 모듈. EncodingMod : encode_message (EncodingConfig, MegacoMessage) 함수는 'MegacoMessage'레코드를 Erlang 바이너리로 변환해야 할 때마다 호출됩니다. EnlangMod : decode_message (EncodingConfig, Binary) 함수는 Erlang 바이너리를 'MegacoMessage'레코드로 변환해야 할 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6dcbba484d1d5cfa44ed74c9d6e15650c65e9b" translate="yes" xml:space="preserve">
          <source>Encoding is &quot;overlong&quot;, meaning that a number should have been encoded in fewer bytes.</source>
          <target state="translated">인코딩은 &quot;길다&quot;입니다. 즉, 숫자가 더 적은 바이트로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="07619d75ac86081189ed5a07edb91fcbca8bed3f" translate="yes" xml:space="preserve">
          <source>Encoding module config.</source>
          <target state="translated">인코딩 모듈 구성.</target>
        </trans-unit>
        <trans-unit id="5fb7ced99a059fd0dc7bab3f9bf3bb8440646b2e" translate="yes" xml:space="preserve">
          <source>Encoding, decoding, and sending Erlang terms</source>
          <target state="translated">Erlang 용어의 인코딩, 디코딩 및 전송</target>
        </trans-unit>
        <trans-unit id="df2853591e29cd99c0fa5882b318aef52125c157" translate="yes" xml:space="preserve">
          <source>Encrypt &lt;code&gt;PlainText&lt;/code&gt; according to &lt;code&gt;Type&lt;/code&gt; block cipher.</source>
          <target state="translated">암호화 &lt;code&gt;PlainText&lt;/code&gt; 에있어서, &lt;code&gt;Type&lt;/code&gt; 블록을 암호화.</target>
        </trans-unit>
        <trans-unit id="43483bf8b1f6e3650db5b3d5c23dd089bcdb2fa2" translate="yes" xml:space="preserve">
          <source>Encrypt &lt;code&gt;PlainText&lt;/code&gt; according to &lt;code&gt;Type&lt;/code&gt; block cipher. &lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector.</source>
          <target state="translated">암호화 &lt;code&gt;PlainText&lt;/code&gt; 에있어서, &lt;code&gt;Type&lt;/code&gt; 블록을 암호화. &lt;code&gt;IVec&lt;/code&gt; 은 임의의 초기화 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="381b8d80049d7a04cdf2994121808a8cdf165223" translate="yes" xml:space="preserve">
          <source>Encrypt with the private key:</source>
          <target state="translated">개인 키로 암호화하십시오.</target>
        </trans-unit>
        <trans-unit id="9703c3f11251af2de6116ae0c93744a07f772858" translate="yes" xml:space="preserve">
          <source>Encrypt with the public key:</source>
          <target state="translated">공개 키로 암호화하십시오.</target>
        </trans-unit>
        <trans-unit id="80dae3701dd53c67de85f8a43dc357a2e8e2e978" translate="yes" xml:space="preserve">
          <source>Encrypted Debug Information</source>
          <target state="translated">암호화 된 디버그 정보</target>
        </trans-unit>
        <trans-unit id="3a59ab59dac8804687753e19c3d53c00d3eedb1a" translate="yes" xml:space="preserve">
          <source>Encryption and authentication is added.</source>
          <target state="translated">암호화 및 인증이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d09656784058ea42ea6ac009c67cf6b347770cc2" translate="yes" xml:space="preserve">
          <source>Encryption and decryption</source>
          <target state="translated">암호화 및 복호화</target>
        </trans-unit>
        <trans-unit id="5e0dab077d689a486cbd877d4183f36242417a19" translate="yes" xml:space="preserve">
          <source>Encrypts &lt;code&gt;PlainText&lt;/code&gt; according to the stream cipher &lt;code&gt;Type&lt;/code&gt; specified in stream_init/3. &lt;code&gt;Text&lt;/code&gt; can be any number of bytes. The initial &lt;code&gt;State&lt;/code&gt; is created using &lt;code&gt;&lt;a href=&quot;#stream_init-2&quot;&gt;stream_init&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NewState&lt;/code&gt; must be passed into the next call to &lt;code&gt;stream_encrypt&lt;/code&gt;.</source>
          <target state="translated">stream_init / 3에 지정된 스트림 암호 &lt;code&gt;Type&lt;/code&gt; 에 따라 &lt;code&gt;PlainText&lt;/code&gt; 를 암호화 합니다. &lt;code&gt;Text&lt;/code&gt; 는 임의의 바이트 수일 수 있습니다. 초기 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#stream_init-2&quot;&gt;stream_init&lt;/a&gt;&lt;/code&gt; 를 사용하여 작성됩니다 . &lt;code&gt;stream_encrypt&lt;/code&gt; 에 대한 다음 호출로 &lt;code&gt;NewState&lt;/code&gt; 를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9217b6473788c015aacdede9c8b8e5f29a5c7690" translate="yes" xml:space="preserve">
          <source>Encrypts the &lt;code&gt;PlainText&lt;/code&gt; (message digest) using the &lt;code&gt;PublicKey&lt;/code&gt; and returns the &lt;code&gt;CipherText&lt;/code&gt;. This is a low level signature operation used for instance by older versions of the SSL protocol. See also &lt;code&gt;public_key:encrypt_public/[2,3]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PublicKey&lt;/code&gt; 를 사용하여 &lt;code&gt;PlainText&lt;/code&gt; (메시지 요약)를 암호화하고 &lt;code&gt;CipherText&lt;/code&gt; 를 리턴합니다 . 예를 들어 이전 버전의 SSL 프로토콜에서 사용되는 하위 수준 서명 작업입니다. 참조 &lt;code&gt;public_key:encrypt_public/[2,3]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6aba32daed03d9e5587e8d7857b21ac52bb10760" translate="yes" xml:space="preserve">
          <source>Encrypts the &lt;code&gt;PlainText&lt;/code&gt; using the &lt;code&gt;PrivateKey&lt;/code&gt; and returns the ciphertext. This is a low level signature operation used for instance by older versions of the SSL protocol. See also &lt;code&gt;public_key:encrypt_private/[2,3]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PrivateKey&lt;/code&gt; 를 사용 하여 &lt;code&gt;PlainText&lt;/code&gt; 를 암호화하고 암호문을 리턴합니다. 예를 들어 이전 버전의 SSL 프로토콜에서 사용되는 하위 수준 서명 작업입니다. 참조 &lt;code&gt;public_key:encrypt_private/[2,3]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a45a71f8411b2012ac69eee03c3cb9761ef63f0" translate="yes" xml:space="preserve">
          <source>Encrypts the source configuration file with DES3 and saves the result in file &lt;code&gt;EncryptFileName&lt;/code&gt;. The key, a string, must be available in a text file named &lt;code&gt;.ct_config.crypt&lt;/code&gt;, either in the current directory, or the home directory of the user (it is searched for in that order).</source>
          <target state="translated">소스 구성 파일을 DES3으로 암호화하고 결과를 &lt;code&gt;EncryptFileName&lt;/code&gt; 파일에 저장합니다 . 문자열 인 키 는 현재 디렉토리 또는 사용자의 홈 디렉토리 (순서대로 검색 됨)에 &lt;code&gt;.ct_config.crypt&lt;/code&gt; 라는 텍스트 파일에서 사용 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1b7e8ad6b293828786733653b84e98f56e63171" translate="yes" xml:space="preserve">
          <source>Encrypts the source configuration file with DES3 and saves the result in the target file &lt;code&gt;EncryptFileName&lt;/code&gt;. The encryption key to use is either the value in &lt;code&gt;{key,Key}&lt;/code&gt; or the value stored in the file specified by &lt;code&gt;{file,File}&lt;/code&gt;.</source>
          <target state="translated">소스 구성 파일을 DES3으로 암호화하고 결과를 대상 파일 &lt;code&gt;EncryptFileName&lt;/code&gt; 에 저장합니다 . 사용할 암호화 키는 &lt;code&gt;{key,Key}&lt;/code&gt; 의 값이거나 &lt;code&gt;{file,File}&lt;/code&gt; 에 지정된 파일에 저장된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="a2bb9d34b8a1a79665858d354585cf147e0dee4e" translate="yes" xml:space="preserve">
          <source>End</source>
          <target state="translated">End</target>
        </trans-unit>
        <trans-unit id="de60abfb17a90423ee6919dc63adf8282f5b06fb" translate="yes" xml:space="preserve">
          <source>End at the end of the subject string.</source>
          <target state="translated">제목 문자열의 끝에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="57a63878b5826fd26a531b55737bab2bbbbaebcc" translate="yes" xml:space="preserve">
          <source>End of file was encountered before any more tokens.</source>
          <target state="translated">토큰이 더 이상 나오기 전에 파일 끝이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="026ff6a17a44a34ca50397b4a1b628c91e49b9d7" translate="yes" xml:space="preserve">
          <source>End of file was encountered by the I/O server.</source>
          <target state="translated">I / O 서버에서 파일 끝을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="e31ad58996b6f675a81eae4e18dab4de0ed09a2f" translate="yes" xml:space="preserve">
          <source>End of file was encountered by the tokenizer.</source>
          <target state="translated">토크 나이저가 파일 끝을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="a212d4671531affb8d170219150ca3d881db83f3" translate="yes" xml:space="preserve">
          <source>End of file was encountered.</source>
          <target state="translated">파일 끝이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e3ce0d3bac0fd9f1bf58f3420981013f4efbb94" translate="yes" xml:space="preserve">
          <source>End of file was encountered. &lt;code&gt;LeftOverChars&lt;/code&gt; are the input characters not used.</source>
          <target state="translated">파일 끝이 발견되었습니다. &lt;code&gt;LeftOverChars&lt;/code&gt; 는 사용되지 않는 입력 문자입니다.</target>
        </trans-unit>
        <trans-unit id="a8e61f729a44e47cf20e58421010bf77fedcd7c3" translate="yes" xml:space="preserve">
          <source>End of line</source>
          <target state="translated">줄의 끝</target>
        </trans-unit>
        <trans-unit id="60aa06caf4ce9d91f78983d5c80292d55ad0043f" translate="yes" xml:space="preserve">
          <source>End subpattern</source>
          <target state="translated">하위 패턴 종료</target>
        </trans-unit>
        <trans-unit id="b750001d7ab130d7ac487cd2ca42bd5cd9f92224" translate="yes" xml:space="preserve">
          <source>End the scope of a prefix-URI mapping.</source>
          <target state="translated">접두사 URI 매핑 범위를 끝냅니다.</target>
        </trans-unit>
        <trans-unit id="21e320b076f89e4cd5f68347182e92594c72d3c2" translate="yes" xml:space="preserve">
          <source>Ends an FTP session, created using function &lt;code&gt;&lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 작성된 FTP 세션을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="95951d40d8039b0e33d4c019627487ef398366d4" translate="yes" xml:space="preserve">
          <source>Ends the deflate session and cleans all data used. Notice that this function throws a &lt;code&gt;data_error&lt;/code&gt; exception if the last call to &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt; was not called with &lt;code&gt;Flush&lt;/code&gt; set to &lt;code&gt;finish&lt;/code&gt;.</source>
          <target state="translated">수축 세션을 종료하고 사용 된 모든 데이터를 정리합니다. &lt;code&gt;Flush&lt;/code&gt; 가 &lt;code&gt;finish&lt;/code&gt; 로 설정된 상태에서 &lt;code&gt;&lt;a href=&quot;#deflate-3&quot;&gt;deflate/3&lt;/a&gt;&lt;/code&gt; 에 대한 마지막 호출이 호출 되지 않은 경우이 함수는 &lt;code&gt;data_error&lt;/code&gt; 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="8b45853fd46d5ba321de71a27af54573d044a5ee" translate="yes" xml:space="preserve">
          <source>Ends the inflate session and cleans all data used. Notice that this function throws a &lt;code&gt;data_error&lt;/code&gt; exception if no end of stream was found (meaning that not all data has been uncompressed).</source>
          <target state="translated">팽창 세션을 종료하고 사용 된 모든 데이터를 정리합니다. 스트림 끝이 발견되지 않은 &lt;code&gt;data_error&lt;/code&gt; 함수는 data_error 예외를 발생 시킵니다 (모든 데이터가 압축되지 않은 것은 아닙니다).</target>
        </trans-unit>
        <trans-unit id="ab9116cba897b6ab266baa70720fa04bcdb04dc2" translate="yes" xml:space="preserve">
          <source>Enforces chunking of a HTTP PUT or POST body data to be deliverd to the mod_esi callback. Note this is not supported for mod_cgi. Default is no limit e.i the whole body is deliverd as one entity, which could be very memory consuming. &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">HTTP PUT 또는 POST 본문 데이터 청크를 mod_esi 콜백으로 전달하도록합니다. mod_cgi에서는 지원되지 않습니다. 몸 전체가 하나의 엔티티로 전달되는 경우 기본값은 제한이 없으며, 이는 매우 메모리 소비가 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;mod_esi&quot;&gt;mod_esi(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df9bb310faa70aa0d761987d05cd45db9928b704" translate="yes" xml:space="preserve">
          <source>Engine API</source>
          <target state="translated">엔진 API</target>
        </trans-unit>
        <trans-unit id="4274910e7ccb1de8bd66b8871cfb848933020382" translate="yes" xml:space="preserve">
          <source>Enhanced Remote Procedure Call</source>
          <target state="translated">향상된 원격 프로 시저 호출</target>
        </trans-unit>
        <trans-unit id="f62489d96dcaee9fe090844ec3761e76e272966a" translate="yes" xml:space="preserve">
          <source>Enhanced error codes.</source>
          <target state="translated">향상된 오류 코드.</target>
        </trans-unit>
        <trans-unit id="b0af252697cfc3bd079e25301b747579d8cb929b" translate="yes" xml:space="preserve">
          <source>Enqueue the &lt;code&gt;bin&lt;/code&gt; into &lt;code&gt;q&lt;/code&gt; skipping the first &lt;code&gt;skip&lt;/code&gt; bytes.</source>
          <target state="translated">&lt;code&gt;bin&lt;/code&gt; 을 &lt;code&gt;q&lt;/code&gt; 로 큐에 넣으면 첫 번째 &lt;code&gt;skip&lt;/code&gt; 바이트를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="f6dbd5b5f41e43310556c16363a928d564f24e99" translate="yes" xml:space="preserve">
          <source>Enqueue the &lt;code&gt;iovec&lt;/code&gt; into &lt;code&gt;q&lt;/code&gt; skipping the first &lt;code&gt;skip&lt;/code&gt; bytes.</source>
          <target state="translated">첫 번째 &lt;code&gt;skip&lt;/code&gt; 바이트를 건너 뛰고 &lt;code&gt;iovec&lt;/code&gt; 를 &lt;code&gt;q&lt;/code&gt; 에 큐에 넣 습니다 .</target>
        </trans-unit>
        <trans-unit id="c52745843cb391f37a0d2a1328df5d9cae8a3eb4" translate="yes" xml:space="preserve">
          <source>Enqueues a driver binary in the driver queue. The data in &lt;code&gt;bin&lt;/code&gt; at &lt;code&gt;offset&lt;/code&gt; with length &lt;code&gt;len&lt;/code&gt; is placed at the end of the queue. This function is most often faster than &lt;code&gt;&lt;a href=&quot;#driver_enq&quot;&gt;driver_enq&lt;/a&gt;&lt;/code&gt;, because no data must be copied.</source>
          <target state="translated">드라이버 대기열에서 드라이버 바이너리를 큐에 넣습니다. 길이가 &lt;code&gt;len&lt;/code&gt; 인 &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;bin&lt;/code&gt; 에 있는 데이터 는 큐의 끝에 배치됩니다. 이 함수는 데이터를 복사 할 필요가 없으므로 &lt;code&gt;&lt;a href=&quot;#driver_enq&quot;&gt;driver_enq&lt;/a&gt;&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="5687001b5e2fa4b62bebc2dc93d279fbbdd53c1f" translate="yes" xml:space="preserve">
          <source>Enqueues data in the driver queue. The data in &lt;code&gt;buf&lt;/code&gt; is copied (&lt;code&gt;len&lt;/code&gt; bytes) and placed at the end of the driver queue. The driver queue is normally used in a FIFO way.</source>
          <target state="translated">드라이버 큐에서 데이터를 큐에 넣습니다. &lt;code&gt;buf&lt;/code&gt; 의 데이터 가 복사되고 ( &lt;code&gt;len&lt;/code&gt; 바이트) 드라이버 큐의 끝에 배치됩니다. 드라이버 큐는 일반적으로 FIFO 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da9bea378d6eda4a2eccc46e57c3a42efdd7761b" translate="yes" xml:space="preserve">
          <source>Enqueues the data in &lt;code&gt;ev&lt;/code&gt;, skipping the first &lt;code&gt;skip&lt;/code&gt; bytes of it, at the end of the driver queue. It is faster than &lt;code&gt;&lt;a href=&quot;#driver_enq&quot;&gt;driver_enq&lt;/a&gt;&lt;/code&gt;, because no data must be copied.</source>
          <target state="translated">드라이버 큐의 끝에서 데이터 의 첫 번째 &lt;code&gt;skip&lt;/code&gt; 바이트를 건너 뛰고 &lt;code&gt;ev&lt;/code&gt; 의 데이터를 큐에 넣습니다. 데이터를 복사 할 필요가 없으므로 &lt;code&gt;&lt;a href=&quot;#driver_enq&quot;&gt;driver_enq&lt;/a&gt;&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="014cabf718cf24ef9b31ec84cd11c02beef4f694" translate="yes" xml:space="preserve">
          <source>Ensure that all nodes (Erlang-, C-, and Java nodes) of a distributed Erlang system is of the same Erlang/OTP release, or from two different Erlang/OTP releases X and Y, where &lt;strong&gt;all&lt;/strong&gt; Y nodes have compatibility mode X.</source>
          <target state="translated">분산 Erlang 시스템의 모든 노드 (Erlang-, C- 및 Java 노드)가 동일한 Erlang / OTP 릴리스이거나 두 개의 서로 다른 Erlang / OTP 릴리스 X 및 Y에서 제공되는지 확인 &lt;strong&gt;하십시오&lt;/strong&gt; . 여기서 &lt;strong&gt;모든&lt;/strong&gt; Y 노드는 호환 모드 X입니다.</target>
        </trans-unit>
        <trans-unit id="958b68eb429026f1debb7fb95959ba06f9687fcd" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;code&gt;priv&lt;/code&gt; directory, where the C program is located, is included in the new release package:</source>
          <target state="translated">C 프로그램이 있는 &lt;code&gt;priv&lt;/code&gt; 디렉토리가 새 릴리스 패키지에 포함되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4983262d3266b73c45b4b7746403f7f7b7d9740" translate="yes" xml:space="preserve">
          <source>Ensure that the configuration parameters for the &lt;code&gt;os_sup&lt;/code&gt; module in the &lt;code&gt;os_mon&lt;/code&gt; application are correct.</source>
          <target state="translated">&lt;code&gt;os_mon&lt;/code&gt; 응용 프로그램 에서 &lt;code&gt;os_sup&lt;/code&gt; 모듈 의 구성 매개 변수 가 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6fc8dbfdde6b1e68d82e36f6f6fa0143435b8681" translate="yes" xml:space="preserve">
          <source>Ensure that the following configuration parameters have correct values:</source>
          <target state="translated">다음 구성 매개 변수의 값이 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3c544c06d01afec781e1835ca1c990d2bf3d3fdb" translate="yes" xml:space="preserve">
          <source>Ensure that the header is included when using &lt;code&gt;ets&lt;/code&gt; and &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; in compiled code.</source>
          <target state="translated">컴파일 된 코드에서 &lt;code&gt;ets&lt;/code&gt; 및 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 을 사용할 때 헤더가 포함되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c48b0c8103147c698d11fdc42ece8fa98d1b45c" translate="yes" xml:space="preserve">
          <source>Ensure you know what a binary contains before converting it to a string. If no other option exists, try heuristics:</source>
          <target state="translated">바이너리를 문자열로 변환하기 전에 바이너리에 포함 된 내용을 알고 있어야합니다. 다른 옵션이 없으면 추론을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="b1ea6f53738aaf6c0f29ca61cdc22d0e4ce92e45" translate="yes" xml:space="preserve">
          <source>Ensures that a copy of all events of type &lt;code&gt;Event-Category&lt;/code&gt; are sent to the calling process</source>
          <target state="translated">&lt;code&gt;Event-Category&lt;/code&gt; 유형의 모든 이벤트 사본 이 호출 프로세스로 전송되도록합니다.</target>
        </trans-unit>
        <trans-unit id="5dced8b350b5f94877c96cbc4ab7c21ba7f688da" translate="yes" xml:space="preserve">
          <source>Ensures that a copy of all events of type &lt;code&gt;EventCategory&lt;/code&gt; is sent to the caller. The available event types are described in the &lt;code&gt;&lt;a href=&quot;mnesia_chap5#event_handling&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EventCategory&lt;/code&gt; 유형의 모든 이벤트 사본이 호출자에게 전송되도록합니다. 사용 가능한 이벤트 유형은 &lt;code&gt;&lt;a href=&quot;mnesia_chap5#event_handling&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef731b04fa2fb82f85b737d70f620dea873787e1" translate="yes" xml:space="preserve">
          <source>Ensures that a pool master is running and includes &lt;code&gt;Node&lt;/code&gt; in the pool master's pool of nodes.</source>
          <target state="translated">보장은 풀 마스터는 실행 포함되는 &lt;code&gt;Node&lt;/code&gt; 의 노드 풀 마스터의 풀.</target>
        </trans-unit>
        <trans-unit id="d5e41d06cf30ae1415f82183a24356df8156803f" translate="yes" xml:space="preserve">
          <source>Ensures that all parent directories for the specified file or directory name &lt;code&gt;Name&lt;/code&gt; exist, trying to create them if necessary.</source>
          <target state="translated">지정된 파일 또는 디렉토리 이름 &lt;code&gt;Name&lt;/code&gt; 에 대한 모든 상위 디렉토리가 존재하는지 확인하고 필요한 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6c6ccaf34a6cba3c5b5de6abfd26bbd92cd970b6" translate="yes" xml:space="preserve">
          <source>Ensures that all updates made to table &lt;code&gt;Name&lt;/code&gt; are written to disk. This also applies to tables that have been opened with flag &lt;code&gt;ram_file&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. In this case, the contents of the RAM file are flushed to disk.</source>
          <target state="translated">테이블 &lt;code&gt;Name&lt;/code&gt; 대한 모든 업데이트 가 디스크에 기록되도록합니다. 이는 &lt;code&gt;ram_file&lt;/code&gt; 플래그 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 상태에서 열린 테이블에도 적용됩니다 . 이 경우 RAM 파일의 내용이 디스크로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="179be22883a6aff731d18c72553f15ebd6342f7c" translate="yes" xml:space="preserve">
          <source>Ensures that any buffers kept by the operating system (not by the Erlang runtime system) are written to disk. In many ways it resembles &lt;code&gt;fsync&lt;/code&gt; but it does not update some of the metadata of the file, such as the access time. On some platforms this function has no effect.</source>
          <target state="translated">Erlang 런타임 시스템이 아닌 운영 체제가 유지하는 버퍼가 디스크에 기록되도록합니다. 여러 가지면에서 &lt;code&gt;fsync&lt;/code&gt; 와 비슷 하지만 액세스 시간과 같은 파일의 일부 메타 데이터는 업데이트하지 않습니다. 일부 플랫폼에서는이 기능이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52b1c024e514cd8bc30b642609203a562f517997" translate="yes" xml:space="preserve">
          <source>Ensures that any buffers kept by the operating system (not by the Erlang runtime system) are written to disk. On some platforms, this function might have no effect.</source>
          <target state="translated">Erlang 런타임 시스템이 아닌 운영 체제가 유지하는 버퍼가 디스크에 기록되도록합니다. 일부 플랫폼에서는이 기능이 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bf2bc1e9755470f51dfd03724a8f65fe715b5ae" translate="yes" xml:space="preserve">
          <source>Ensures that the Erlang runtime system never tries to read any input. Implies &lt;code&gt;-noshell&lt;/code&gt;.</source>
          <target state="translated">Erlang 런타임 시스템이 입력을 읽지 않도록합니다. &lt;code&gt;-noshell&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="fe6fc0efb68605c111d7aad1e10930fb3e4c27d7" translate="yes" xml:space="preserve">
          <source>Ensures that the contents of the log are written to the disk. This is usually a rather expensive operation.</source>
          <target state="translated">로그 내용이 디스크에 기록되도록합니다. 이것은 일반적으로 다소 비싼 작업입니다.</target>
        </trans-unit>
        <trans-unit id="483ad84b3b9a9460f181b8df2506d3da9749a272" translate="yes" xml:space="preserve">
          <source>Ensures that the local transaction log file is synced to disk. On a single node system, data written to disk tables since the last dump can be lost if there is a power outage. See &lt;code&gt;&lt;a href=&quot;#dump_log-0&quot;&gt;dump_log/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬 트랜잭션 로그 파일이 디스크에 동기화되었는지 확인하십시오. 단일 노드 시스템에서 정전이 발생하면 마지막 덤프 이후 디스크 테이블에 기록 된 데이터가 손실 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#dump_log-0&quot;&gt;dump_log/0&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b10764358fd20fca794865132b50fac708751e7" translate="yes" xml:space="preserve">
          <source>Enter command &lt;code&gt;&lt;a href=&quot;rb#help-0&quot;&gt;rb:help()&lt;/a&gt;&lt;/code&gt; to access the report browser online help system.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;rb#help-0&quot;&gt;rb:help()&lt;/a&gt;&lt;/code&gt; 명령을 입력 하여 보고서 브라우저 온라인 도움말 시스템에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="6c4d5a3c58a4c3838082c4cf0b51e1e37c9596f3" translate="yes" xml:space="preserve">
          <source>Enter shell break mode</source>
          <target state="translated">쉘 브레이크 모드로 들어가기</target>
        </trans-unit>
        <trans-unit id="934d0063917157179a390d3ca343867e46640984" translate="yes" xml:space="preserve">
          <source>Enter the &lt;code&gt;telnet_settings&lt;/code&gt; term in a configuration file included in the test and &lt;code&gt;ct_telnet&lt;/code&gt; retrieves the information automatically.</source>
          <target state="translated">입력 &lt;code&gt;telnet_settings&lt;/code&gt; 의 테스트에 포함 된 구성 파일에 용어와 &lt;code&gt;ct_telnet&lt;/code&gt; 은 자동으로 정보를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="8246546eefded8a17ce0a5c88984bec6f308377e" translate="yes" xml:space="preserve">
          <source>Enter the following code in a file named &lt;code&gt;tut1.erl&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tut1.erl&lt;/code&gt; 파일에 다음 코드를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b1f029dd1bd7aa1c9278ca0308da576f46de6b2" translate="yes" xml:space="preserve">
          <source>Enter the next program in a file named &lt;code&gt;tut2.erl&lt;/code&gt;). It can be useful for converting from inches to centimeters and conversely:</source>
          <target state="translated">&lt;code&gt;tut2.erl&lt;/code&gt; 파일에 다음 프로그램을 입력하십시오 .) 인치에서 센티미터로 또는 반대로 변환하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="115b9de9f1e80ff76c3ea96d77950a47bd332297" translate="yes" xml:space="preserve">
          <source>Entering and leaving FIPS mode on a node already running crypto is not supported. The reason is that OpenSSL is designed to prevent an application requesting FIPS mode to end up accidentally running in non-FIPS mode. If entering FIPS mode fails (e.g. the Object Module is not found or is compromised) any subsequent use of the OpenSSL API would terminate the emulator.</source>
          <target state="translated">이미 암호화를 실행중인 노드에서 FIPS 모드로 들어가고 나가는 것은 지원되지 않습니다. OpenSSL은 FIPS 모드를 요청하는 응용 프로그램이 비 FIPS 모드에서 실수로 실행되지 않도록 설계 되었기 때문입니다. FIPS 모드 진입에 실패하면 (예 : 오브젝트 모듈이 없거나 손상됨) OpenSSL API를 이후에 사용하면 에뮬레이터가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0d6a83dcf4276ea47f6fec92e31ab033e3e3cf" translate="yes" xml:space="preserve">
          <source>Entering at the front and exiting at the rear are reverse operations on the queue.</source>
          <target state="translated">앞쪽으로 들어가고 뒤쪽으로 나가는 것은 대기열에서의 역 동작입니다.</target>
        </trans-unit>
        <trans-unit id="f6b1269b202f34cf628bd423eacf8afa6ad2feb0" translate="yes" xml:space="preserve">
          <source>Entries in &lt;code&gt;Comments&lt;/code&gt; represent multi-line comments. For each entry, &lt;code&gt;Line&lt;/code&gt; is the line number and &lt;code&gt;Column&lt;/code&gt; the left column of the comment (the column of the first comment-introducing &quot;&lt;code&gt;%&lt;/code&gt;&quot; character). &lt;code&gt;Indentation&lt;/code&gt; is the number of character positions between the last non-whitespace character before the comment (or the left margin) and the left column of the comment. &lt;code&gt;Text&lt;/code&gt; is a list of strings representing the consecutive comment lines in top-down order, where each string contains all characters following (but not including) the comment-introducing &quot;&lt;code&gt;%&lt;/code&gt;&quot; and up to (but not including) the terminating newline. (Cf. module &lt;code&gt;erl_comment_scan&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;Comments&lt;/code&gt; 항목 은 여러 줄 주석을 나타냅니다. 각 항목에 대해 &lt;code&gt;Line&lt;/code&gt; 줄 번호이고 &lt;code&gt;Column&lt;/code&gt; 주석의 왼쪽 열 (첫 번째 주석 도입 &quot;의 열 &lt;code&gt;%&lt;/code&gt; &quot;문자). &lt;code&gt;Indentation&lt;/code&gt; 는 주석 앞의 마지막 비 공백 문자 (또는 왼쪽 여백)와 주석의 왼쪽 열 사이의 문자 위치 수입니다. &lt;code&gt;Text&lt;/code&gt; 는 연속 된 주석 행을 위에서 아래로 나타내는 문자열 목록입니다. 여기서 각 문자열에는 주석을 도입 한 &quot; &lt;code&gt;%&lt;/code&gt; &quot; 다음에 나오는 문자 (포함 되지 않음)와 종료하는 개행 문자 (포함하지 않음)가 모두 포함됩니다. (참조 모듈 &lt;code&gt;erl_comment_scan&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f83c27f29cda32a5c88a37a073106cf111ae03bb" translate="yes" xml:space="preserve">
          <source>Entry point for the the new process.</source>
          <target state="translated">새 프로세스의 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="6749984c5ebae89f18b1be2a7e0c97e3f86eb6c8" translate="yes" xml:space="preserve">
          <source>Environment Variable Passing (RFC 4254, section 6.4)</source>
          <target state="translated">환경 변수 전달 (RFC 4254, 섹션 6.4)</target>
        </trans-unit>
        <trans-unit id="d714f219a186c0491f87d10110aaba7764529397" translate="yes" xml:space="preserve">
          <source>Environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt; (defined in the operating system) can be used to define more library directories to be handled in the same way as the standard OTP library directory described above, except that directories without an &lt;code&gt;ebin&lt;/code&gt; directory are ignored.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_LIBS&lt;/code&gt; (운영 체제에 정의 됨)를 사용하여 &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 없는 디렉토리는 무시 되는 것을 제외하고 위에서 설명한 표준 OTP 라이브러리 디렉토리와 동일한 방식으로 처리 할 라이브러리 디렉토리를 더 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6daa47d47d30c06a68597fafd923e987f5a36cd" translate="yes" xml:space="preserve">
          <source>Environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt; (if defined) is to contain a colon-separated (for Unix-like systems) or semicolon-separated (for Windows) list of additional libraries.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_LIBS&lt;/code&gt; (정의 된 경우)는 추가 라이브러리의 콜론으로 구분 된 (유닉스 계열 시스템의 경우) 또는 세미콜론으로 구분 된 (Windows의 경우) 목록을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c57186053f185252b9718153515cfe2460506345" translate="yes" xml:space="preserve">
          <source>Environment variable &lt;code&gt;RELDIR&lt;/code&gt; can be set before calling this example, which sets the directory where to find the release files.</source>
          <target state="translated">릴리스 파일을 찾을 디렉토리를 설정하는이 예제를 호출하기 전에 환경 변수 &lt;code&gt;RELDIR&lt;/code&gt; 을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1eaa79bc837d6866d6b6f457d286e20d9c99f7f" translate="yes" xml:space="preserve">
          <source>Environment variables and their interpretation are handled much in the same way as filenames. If Unicode filenames are enabled, environment variables as well as parameters to the Erlang VM are expected to be in Unicode.</source>
          <target state="translated">환경 변수와 그 해석은 파일 이름과 같은 방식으로 처리됩니다. 유니 코드 파일 이름이 활성화되면 Erlang VM에 대한 매개 변수뿐만 아니라 환경 변수도 유니 코드 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cd7c85d03b98190d36904693a2164d38b1a38d5f" translate="yes" xml:space="preserve">
          <source>Environment variables can be passed before starting the shell/command. Is to be called by a client channel processes.</source>
          <target state="translated">쉘 / 명령을 시작하기 전에 환경 변수를 전달할 수 있습니다. 클라이언트 채널 프로세스에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="39882a4b7ec9443b18dbf778a96b5f0d21018ee8" translate="yes" xml:space="preserve">
          <source>Environment variables can be passed to the shell/command to be started later. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#setenv-5&quot;&gt; ssh_connection:setenv/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">환경 변수는 나중에 시작하기 위해 쉘 / 명령에 전달할 수 있습니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#setenv-5&quot;&gt; ssh_connection:setenv/5&lt;/a&gt;&lt;/code&gt; 호출의 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfb3775bf1b5456a3e06e36f98664cca58126e02" translate="yes" xml:space="preserve">
          <source>Environment variables can be passed to the shell/command to be started later. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#setenv-5&quot;&gt;ssh_connection:setenv/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">환경 변수는 나중에 시작하기 위해 쉘 / 명령으로 전달 될 수 있습니다. 이 이벤트는 &lt;code&gt;&lt;a href=&quot;ssh_connection#setenv-5&quot;&gt;ssh_connection:setenv/5&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="44890b07830149c521ba5c9ad6cfa1ad85c5f3e9" translate="yes" xml:space="preserve">
          <source>Ephemeral Diffie-Hellman cipher suites are supported, but not Diffie Hellman Certificates cipher suites.</source>
          <target state="translated">임시 Diffie-Hellman 암호 제품군은 지원되지만 Diffie Hellman 인증서 암호 제품군은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13b9a04dcb3e0ce7661aca803fc0ceecf849e1d8" translate="yes" xml:space="preserve">
          <source>Equal to</source>
          <target state="translated">동일</target>
        </trans-unit>
        <trans-unit id="dcf80d8cab4aa6589affe9378df2d8dcf3a48955" translate="yes" xml:space="preserve">
          <source>Equal to 1 + n + m.</source>
          <target state="translated">1 + n + m과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09bb5e7c769262bf6d1a2aaff9bd4edf5501c760" translate="yes" xml:space="preserve">
          <source>Equal to &lt;code&gt;112&lt;/code&gt; (pass through).</source>
          <target state="translated">같음 &lt;code&gt;112&lt;/code&gt; (통과).</target>
        </trans-unit>
        <trans-unit id="05c13973f975cc581a5888850198e264ef30dee6" translate="yes" xml:space="preserve">
          <source>Equal to d + n + m.</source>
          <target state="translated">d + n + m과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16b53a690e60aff7bf7cb6594412ef2ab0ee11e0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#ann_c_bitstr-6&quot;&gt;ann_c_bitstr(As, Value, Size, abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가에 &lt;code&gt;&lt;a href=&quot;#ann_c_bitstr-6&quot;&gt;ann_c_bitstr(As, Value, Size, abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4371bb175da3106bcb8069b1e138ae8955b39c79" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#ann_c_clause-4&quot;&gt;ann_c_clause(As, Patterns, c_atom(true), Body)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#ann_c_clause-4&quot;&gt;ann_c_clause(As, Patterns, c_atom(true), Body)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="426e43a8cca6f35d12cbaa419095ab24bb54a147" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#ann_c_receive-4&quot;&gt;ann_c_receive(As, Clauses, c_atom(infinity), c_atom(true))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#ann_c_receive-4&quot;&gt;ann_c_receive(As, Clauses, c_atom(infinity), c_atom(true))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57131c4f5251e48576073e9ae91ab0dd3431ac0f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#ann_c_var-2&quot;&gt;ann_c_var(As, {Atom, Arity})&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#ann_c_var-2&quot;&gt;ann_c_var(As, {Atom, Arity})&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a2eecf99e77358f8e73373df62b8ac930c49352" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#ann_make_list-3&quot;&gt;ann_make_list(As, List, none)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#ann_make_list-3&quot;&gt;ann_make_list(As, List, none)&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b3143e9955ab9adddb2b4dd2f3b4517e127a1a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#attribute-2&quot;&gt;attribute(Name, none)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가에 &lt;code&gt;&lt;a href=&quot;#attribute-2&quot;&gt;attribute(Name, none)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ae4ec2e93db85feb5a2578e005f1e4886d234c3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#basedir-3&quot;&gt;basedir(Type,Application, #{})&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가에 &lt;code&gt;&lt;a href=&quot;#basedir-3&quot;&gt;basedir(Type,Application, #{})&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4b1f57c66209d56e715b24a7143c02e424c2a1e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#basedir_3_1&quot;&gt; basedir(PathType, Application, #{})&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#basedir_3_2&quot;&gt; basedir(PathsType, Application, #{})&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#basedir_3_1&quot;&gt; basedir(PathType, Application, #{})&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#basedir_3_2&quot;&gt; basedir(PathsType, Application, #{})&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="582aebe00b21d5836a2498deb6d665024c07f6cb" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best(Tree, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#best-2&quot;&gt;best(Tree, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f918eb40249a6defccff4175d40e68cfa2e2dee0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#binary_field-2&quot;&gt;binary_field(Body, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#binary_field-2&quot;&gt;binary_field(Body, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a6125894016cef185475df8034bb52c772f1e365" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#c_bitstr-5&quot;&gt;c_bitstr(Value, Size, abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;&lt;a href=&quot;#c_bitstr-5&quot;&gt;c_bitstr(Value, Size, abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91416c2a47641a61221f60e3af3ff79f8fc791fa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#c_bitstr-5&quot;&gt;c_bitstr(Value, abstract(all), abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가에 &lt;code&gt;&lt;a href=&quot;#c_bitstr-5&quot;&gt;c_bitstr(Value, abstract(all), abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e083c319e8db2f5270e0830102043f89b198f901" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#c_clause-3&quot;&gt;c_clause(Patterns, c_atom(true), Body)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#c_clause-3&quot;&gt;c_clause(Patterns, c_atom(true), Body)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce39d94d40077a836dd6fc4a347035c2aff1db6e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#c_module-4&quot;&gt;c_module(Name, Exports, [], Definitions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#c_module-4&quot;&gt;c_module(Name, Exports, [], Definitions)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="102237203e3bbf092a460bf7f8aa761f4ba6d295" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#c_receive-3&quot;&gt;c_receive(Clauses, c_atom(infinity), c_atom(true))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#c_receive-3&quot;&gt;c_receive(Clauses, c_atom(infinity), c_atom(true))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d54191892c882d880f2a51b32fc5643c07541c4f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#c_var-1&quot;&gt;c_var({Name, Arity})&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#c_var-1&quot;&gt;c_var({Name, Arity})&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c852d2a7e09eb55c48f03a8f28bb6f72b6141d58" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#capture_get-1&quot;&gt;ct:capture_get([default])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#capture_get-1&quot;&gt;ct:capture_get([default])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1c49fe52a91556ff0aaa7944a2bc8b6e613b0b7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#clause-3&quot;&gt;clause([], Guard, Body)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#clause-3&quot;&gt;clause([], Guard, Body)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa8a2e37f287064a6e3f946a19187bec0ce0ac5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#cmd-3&quot;&gt;ct_telnet:cmd(Connection, Cmd, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#cmd-3&quot;&gt;ct_telnet:cmd(Connection, Cmd, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="928a260bdb3b3e5d3caf0e440128bbb17938454c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#cmdf-4&quot;&gt;ct_telnet:cmdf(Connection, CmdFormat, Args, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#cmdf-4&quot;&gt;ct_telnet:cmdf(Connection, CmdFormat, Args, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="684e9655a8ec58d496dd036380b5470505aec75d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#comment-2&quot;&gt;comment(none, Strings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#comment-2&quot;&gt;comment(none, Strings)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ddbe0b3f767b85def18a6f538394f315db70b95f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile(Code, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile(Code, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4746c2d2b85dce9582bc7fd1835cfb6190066aff" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#compile_and_load-2&quot;&gt;compile_and_load(Code, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#compile_and_load-2&quot;&gt;compile_and_load(Code, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="34c3413e854719b0fdea410e48287f5f055af37f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;ct_ssh:connect(KeyOrName, ConnType, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;ct_ssh:connect(KeyOrName, ConnType, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa210fba1d3569a7a58c6f3bf220d9b782fa4cc2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;ct_ssh:connect(KeyOrName, host, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;ct_ssh:connect(KeyOrName, host, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9d6a6a81b7654b8215baad7f8ccd2d21ee286d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#cont_state-2&quot;&gt;cont_state(ContinuationState, S)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cont_state-2&quot;&gt;cont_state(ContinuationState, S)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="32756e4dc130dec691ae949f865ea7edf04d260d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; followed by &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt;, but does not free and reallocate all the internal compression state. The stream keeps the same compression level and any other attributes.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;&lt;a href=&quot;#deflateInit-1&quot;&gt;deflateInit/1,2,6&lt;/a&gt;&lt;/code&gt; - 하지만 무료로하지 않는 모든 내부 압축 상태를 재 할당. 스트림은 동일한 압축 수준과 다른 속성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0b6695db18a2f2dd98d7dd3f365cdbbbafda43a3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#dir-1&quot;&gt;dir(&quot;&quot;)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#dir-1&quot;&gt;dir(&quot;&quot;)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2c23622ea4c2372f9268551a9c4cc18a67a0a649" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir(Dir, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir(Dir, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="652b45ea11a1ce0fa9b4d6dc294b0e3c62bfcff8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#enif_fprintf&quot;&gt;enif_fprintf&lt;/a&gt;&lt;/code&gt; except that its called with a &lt;code&gt;va_list&lt;/code&gt; instead of a variable number of arguments.</source>
          <target state="translated">가변 개수의 인수 대신 &lt;code&gt;va_list&lt;/code&gt; 로 호출 한 것을 제외하고 &lt;code&gt;&lt;a href=&quot;#enif_fprintf&quot;&gt;enif_fprintf&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ce8f3d87e78ddae6d3f4b53dea2eed3842f805e4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#enif_snprintf&quot;&gt;enif_snprintf&lt;/a&gt;&lt;/code&gt; except that its called with a &lt;code&gt;va_list&lt;/code&gt; instead of a variable number of arguments.</source>
          <target state="translated">가변 개수의 인수 대신 &lt;code&gt;va_list&lt;/code&gt; 를 사용 하여 호출 한 것을 제외하고 &lt;code&gt;&lt;a href=&quot;#enif_snprintf&quot;&gt;enif_snprintf&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="40e5dfc329510d56dfeca51783615fe5be99ae88" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#event_state-2&quot;&gt;event_state(EventState, S)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#event_state-2&quot;&gt;event_state(EventState, S)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0822b99fc1db87c102d8944b91b0d47d78c92c70" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#exec-3&quot;&gt;ct_ssh:exec(SSH, Command, DefaultTimeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#exec-3&quot;&gt;ct_ssh:exec(SSH, Command, DefaultTimeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f749471e89ae46c17f92a3f8623d58c76ab4410" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#expect-3&quot;&gt;ct_telnet:expect(Connections, Patterns, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#expect-3&quot;&gt;ct_telnet:expect(Connections, Patterns, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53258dbd9b4c7a9e2fd1a5cca64f75032c0d6e84" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#export-3&quot;&gt;export(Data, Callback, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#export-3&quot;&gt;export(Data, Callback, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4cc4c14f33a49c9f42d6c4d916b5e3b17d0d09f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#export_simple-3&quot;&gt;export_simple(Content, Callback, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#export_simple-3&quot;&gt;export_simple(Content, Callback, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5479a778e5dff6538cd581dcd60edf566f436a01" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#fetch_state-2&quot;&gt;fetch_state(FetchState, S)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#fetch_state-2&quot;&gt;fetch_state(FetchState, S)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bf3f8d846a3d7912cbd2a46e4afbf7705e4e3dbd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file(Filename, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file(Filename, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f40228bea002526f6dd9192eca4c4d2a44c23921" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file(Name, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#file-2&quot;&gt;file(Name, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0b11106b6d688183433883568c03ecb5e7c95160" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#floating-3&quot;&gt;floating(D, 0, 0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#floating-3&quot;&gt;floating(D, 0, 0)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7409ce92240a99bb687331e86d1562839b83251f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#follow-3&quot;&gt;follow(D1, D2, 0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#follow-3&quot;&gt;follow(D1, D2, 0)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e87ef28b8ea2817254f842c3a48fc6a838b2ab2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt; format(CrashReport, latin1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상응하는 &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt; format(CrashReport, latin1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c489e8c7139b8f43147689cd42f9bc1c6af4163b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format(CrashReport, latin1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상응하는 &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format(CrashReport, latin1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70e8c43e3058793de183c9f16830fd6cfbc7d1fb" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format(D, 80)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format(D, 80)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b4d0ee5dd2b855eb33bd99a8a50f0cf9bc94f6a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format(Tree, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#format-2&quot;&gt;format(Tree, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6d1a5fec2195ff4e40181e992b455c707bba03aa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format(D, PaperWidth, 65)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#format-3&quot;&gt;format(D, PaperWidth, 65)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7fae69455d869a0b7ebb1ada8defd3089ff9387" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#from_list-2&quot;&gt;from_list(List, undefined)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#from_list-2&quot;&gt;from_list(List, undefined)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="99e70718d2848b64a547637e78268770d0aaf785" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#from_orddict-2&quot;&gt;from_orddict(Orddict, undefined)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#from_orddict-2&quot;&gt;from_orddict(Orddict, undefined)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5608d95603de58cc55eae36484f15c095b2086bc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#function_type-2&quot;&gt;function_type(any_arity, Type)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#function_type-2&quot;&gt;function_type(any_arity, Type)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc826b0fca1c5dadf35269879027b11f5557ead" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#get_config-3&quot;&gt;ct:get_config(Required, Default, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#get_config-3&quot;&gt;ct:get_config(Required, Default, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31d74b3bb9d8e21565792d25a739f19c3dced447" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#get_config-3&quot;&gt;ct:get_config(Required, undefined, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#get_config-3&quot;&gt;ct:get_config(Required, undefined, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de26403ff29a5f94199e561aaaf5a64b1a96fee6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#hook_state-2&quot;&gt;hook_state(HookState, S)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#hook_state-2&quot;&gt;hook_state(HookState, S)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4ef8b521ad0c1199b211d0467922ee92c5e23a6b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#inflate-3&quot;&gt;inflate(Z, Data, [])&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">당량 &lt;code&gt;&lt;a href=&quot;#inflate-3&quot;&gt;inflate(Z, Data, [])&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9453f561abca3673472314180640b1dd67d37e0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#inflateEnd-1&quot;&gt;inflateEnd/1&lt;/a&gt;&lt;/code&gt; followed by &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt;, but does not free and reallocate all the internal decompression state. The stream will keep attributes that could have been set by &lt;code&gt;inflateInit/1,2&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#inflateEnd-1&quot;&gt;inflateEnd/1&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;&lt;a href=&quot;#inflateInit-1&quot;&gt;inflateInit/1&lt;/a&gt;&lt;/code&gt; 하지만 무료로하지 않는 모든 내부 감압 상태를 재 할당. 스트림은 &lt;code&gt;inflateInit/1,2&lt;/code&gt; 에 의해 설정 될 수있는 속성을 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="493def41aaecfc7ac142be1b24f624231144cb36" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#label-2&quot;&gt;label(Tree, 0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#label-2&quot;&gt;label(Tree, 0)&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7229176aa8687e3ace20595b98b2167d75c17ad2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout(Tree, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#layout-2&quot;&gt;layout(Tree, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="495ce089c721e454dbee6f4d4c9f70c5eed41844" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#list-2&quot;&gt;list(List, none)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#list-2&quot;&gt;list(List, none)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22ede575071e89d794133470da9ef9e63ed3be8b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(alert,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(alert,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="96fc6e6987a2592263865919948ca920427939ae" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(critical,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(critical,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bdbbee6065747c1e726e943a8952d721bfb3041c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(debug,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(debug,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="30ac05a356e0df5a38b45ed160d3843d24041880" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(emergency,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(emergency,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="843545483e6b90487c50735820ade8a00f8c158f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(error,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(error,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="07f018f04f3b382e02d814f5ca34e99f73093dbc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(info,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(info,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="effe595c7e33bea5f348ed478d2dd412222f5593" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(notice,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(notice,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="909dd42f0266829be1bcfc81baf284b864756039" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(warning,...)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log(warning,...)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="031e62392f8b08c26ecfd5a63b767af5b2410005" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-5&quot;&gt;ct:log(Category, Importance, Format, FormatArgs, Opts)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#log-5&quot;&gt;ct:log(Category, Importance, Format, FormatArgs, Opts)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f78c74016c2ef95eb55b46f915e05a429b746c54" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-5&quot;&gt;ct:log(Category, Importance, Format, FormatArgs, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#log-5&quot;&gt;ct:log(Category, Importance, Format, FormatArgs, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="505fd95ce8db366d54edc502b7dee81fbdde38c6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#log-5&quot;&gt;ct:log(default, 50, Format, [], [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#log-5&quot;&gt;ct:log(default, 50, Format, [], [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9aae0057a0fab531d0ad07f8b10a8cc7377ee3f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#macro-2&quot;&gt;macro(Name, none)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가에 &lt;code&gt;&lt;a href=&quot;#macro-2&quot;&gt;macro(Name, none)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f7c5f5029244f4d68c3600f0d04a632db381519" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#make_list-2&quot;&gt;make_list(List, none)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;&lt;a href=&quot;#make_list-2&quot;&gt;make_list(List, none)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2b356415f1c1d0fd662228c416ab1a936d4a3a2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#map_expr-2&quot;&gt;map_expr(none, Fields)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#map_expr-2&quot;&gt;map_expr(none, Fields)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d1b1c0a4d526bb9484aac2f70daf6dbda88b735c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#map_type-1&quot;&gt;map_type(any_size)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#map_type-1&quot;&gt;map_type(any_size)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c8460b3918f4611b439fc4fabc2dabf75810d353" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#merge-3&quot;&gt;merge(Name, Files, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#merge-3&quot;&gt;merge(Name, Files, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="058dca5fef272e099ea76f35dd557286960d85df" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#merge_files-4&quot;&gt;merge_files(Name, [], Files, Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#merge_files-4&quot;&gt;merge_files(Name, [], Files, Options)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b5be16c6e3ce9dce377c124b8b86e0dd70e104" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#module-2&quot;&gt;module(Forms, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#module-2&quot;&gt;module(Forms, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9dff7bc3a95b3d2751d732f4f61bae3bff575214" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#node_cookie-2&quot;&gt;node_cookie(Node, Cookie)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#node_cookie-2&quot;&gt;node_cookie(Node, Cookie)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fbe56e3a6d4c4c4d056d19f87306c2b02cda9418" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;ct_telnet:open(Name, telnet)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;ct_telnet:open(Name, telnet)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9074015814dfdcda73445d0bb6e483a88fb30e37" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:ct_telnet:open(KeyOrName, ConnType, TargetMod, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#open-4&quot;&gt;ct_telnet:ct_telnet:open(KeyOrName, ConnType, TargetMod, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fe23231fc9809b7b87073f0fedc1728bd143d12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#pal-5&quot;&gt;ct:pal(Category, Importance, Format, FormatArgs, Opts)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#pal-5&quot;&gt;ct:pal(Category, Importance, Format, FormatArgs, Opts)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fddf0305a41900f720db893c1b025d24f5d57976" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#pal-5&quot;&gt;ct:pal(Category, Importance, Format, FormatArgs, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#pal-5&quot;&gt;ct:pal(Category, Importance, Format, FormatArgs, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2db3eb8f9e318ab9cb1176763427f045aa1eaa3d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#pal-5&quot;&gt;ct:pal(default, 50, Format, [], [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#pal-5&quot;&gt;ct:pal(default, 50, Format, [], [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e694e97a0df6b8bd3fe42d77130aff60cc089d7c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par(Ds, 0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당량 &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par(Ds, 0)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a79ecf48b582b5855fe12375ff3b195eb0c23cb0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#parse-2&quot;&gt;parse(IODevice, 1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#parse-2&quot;&gt;parse(IODevice, 1)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1d3131562cf48362cfd9a9e385cf4a230fb3e6c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#parse-3&quot;&gt;parse(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#parse-3&quot;&gt;parse(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28d88e4a38d4759d866979030f4ad9a3e958000c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file(File, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#parse_file-2&quot;&gt;parse_file(File, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="916c501e4401286d2e8e7591743632d2e9e079da" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#parse_form-3&quot;&gt;parse_form(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#parse_form-3&quot;&gt;parse_form(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ee37c4b617207780a88dcbc33d40ef16cffd02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#peernames-2&quot;&gt;peernames(Socket, 0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#peernames-2&quot;&gt;peernames(Socket, 0)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b5796bfde1378041039e80c7d77bc7ef1952313" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#print-5&quot;&gt;ct:print(Category, Importance, Format, FormatArgs, Opts)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#print-5&quot;&gt;ct:print(Category, Importance, Format, FormatArgs, Opts)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe90e72bb9403cedd2354abb523c2f6b59eaade1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#print-5&quot;&gt;ct:print(Category, Importance, Format, FormatArgs, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#print-5&quot;&gt;ct:print(Category, Importance, Format, FormatArgs, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d53de3e423970ed78f487a85dc4ee2dfc925444b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#print-5&quot;&gt;ct:print(default, 50, Format, [], [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#print-5&quot;&gt;ct:print(default, 50, Format, [], [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="685bd8420dff68959c9c4bac76f0135fc06c0392" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#process_schema-2&quot;&gt;process_schema(Schema, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#process_schema-2&quot;&gt;process_schema(Schema, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0281413d62a4d2a6f4f3901d8ea1c0c99c3ec440" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#process_schema-2&quot;&gt;process_schema(Schemas, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#process_schema-2&quot;&gt;process_schema(Schemas, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2307340747392bf7458f2055790759706fe2d6cb" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#process_validate-3&quot;&gt;process_validate(Schema, Xml, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#process_validate-3&quot;&gt;process_validate(Schema, Xml, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f2a5c5b7acd67a6550329c7640c70eadfa9bbdc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#quick_parse-2&quot;&gt;quick_parse(IODevice, 1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#quick_parse-2&quot;&gt;quick_parse(IODevice, 1)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1de891905e2e1a7b28384d0a8089b088c42cdf02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#quick_parse-3&quot;&gt;quick_parse(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#quick_parse-3&quot;&gt;quick_parse(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db445508d4699ebd2d86938da09208b59a495f31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#quick_parse_file-2&quot;&gt;quick_parse_file(File, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#quick_parse_file-2&quot;&gt;quick_parse_file(File, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="981024e7eceead14c19c9252f00804dea25cf405" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#quick_parse_form-3&quot;&gt;quick_parse_form(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#quick_parse_form-3&quot;&gt;quick_parse_form(IODevice, StartLine, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86599ee28ea3d0bf9edecbffc71bbd8071a2bb71" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#receive_expr-3&quot;&gt;receive_expr(Clauses, none, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#receive_expr-3&quot;&gt;receive_expr(Clauses, none, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="192a0c055b0a7f305086e17c8d52a91bbdb3e3dc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#receive_response-3&quot;&gt;ct_ssh:receive_response(SSH, ChannelId, close)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#receive_response-3&quot;&gt;ct_ssh:receive_response(SSH, ChannelId, close)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a152765304b128f527af338bc05c41eab2dcc311" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#receive_response-4&quot;&gt;ct_ssh:receive_response(SSH, ChannelId, End, DefaultTimeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#receive_response-4&quot;&gt;ct_ssh:receive_response(SSH, ChannelId, End, DefaultTimeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d250fdf49915e189b7b0130f0aa3faa67965d0f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#record_expr-3&quot;&gt;record_expr(none, Type, Fields)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;&lt;a href=&quot;#record_expr-3&quot;&gt;record_expr(none, Type, Fields)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f487a795ccb5b3fdfb85baefaa33578a7eb710e2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#record_field-2&quot;&gt;record_field(Name, none)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;&lt;a href=&quot;#record_field-2&quot;&gt;record_field(Name, none)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38656cab93b86ea74a998970c9b0544d386c6958" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#reduce-2&quot;&gt;reduce(Cs, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#reduce-2&quot;&gt;reduce(Cs, [])&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="696d369384e5d978cb226b92c9abd9144508c96f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#rename-3&quot;&gt;rename(Files, Renamings, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#rename-3&quot;&gt;rename(Files, Renamings, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597e95a32f82e2835176c69b48afb4438664a140" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#rules_state-2&quot;&gt;rules_state(RulesState, S)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#rules_state-2&quot;&gt;rules_state(RulesState, S)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eb92da3443dcfab77967e8cf4e2bc5e36700dc84" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#run-4&quot;&gt;ct_master:run(TestSpecs, false, InclNodes, ExclNodes)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#run-4&quot;&gt;ct_master:run(TestSpecs, false, InclNodes, ExclNodes)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3135af91c20771eb093b83d0faf3312b92b6f30c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#run-4&quot;&gt;ct_master:run(TestSpecs, false, [], [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#run-4&quot;&gt;ct_master:run(TestSpecs, false, [], [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32ffd1be0fd6193cee701eaac01c190adaef08e0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#run_on_node-3&quot;&gt;ct_master:run_on_node(TestSpecs, false, Node)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#run_on_node-3&quot;&gt;ct_master:run_on_node(TestSpecs, false, Node)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b32b5b0e405a63e2563aa6475f1fddf39e3b546" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;ct_telnet:send(Connection, Cmd, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#send-3&quot;&gt;ct_telnet:send(Connection, Cmd, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63f62404934f90ad154a6a24bcde3026eed8da1f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;ct_ssh:send(SSH, ChannelId, 0, Data, DefaultTimeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;ct_ssh:send(SSH, ChannelId, 0, Data, DefaultTimeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc923e4fd5096607780b11e6dd43151ead2d96d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;ct_ssh:send(SSH, ChannelId, 0, Data, Timeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#send-5&quot;&gt;ct_ssh:send(SSH, ChannelId, 0, Data, Timeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb108cc17a2794d7db63f1d180faebf6e2d46a5e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#send_and_receive-4&quot;&gt;ct_ssh:send_and_receive(SSH, ChannelId, Data, close)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#send_and_receive-4&quot;&gt;ct_ssh:send_and_receive(SSH, ChannelId, Data, close)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="093aebead82785744f51a5f644ae70298b854a6c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#send_and_receive-6&quot;&gt;ct_ssh:send_and_receive(SSH, ChannelId, 0, Data, End, Timeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#send_and_receive-6&quot;&gt;ct_ssh:send_and_receive(SSH, ChannelId, 0, Data, End, Timeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a308097eb51467b4d7a5348b10aabe977ac9ca34" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#send_and_receive-6&quot;&gt;ct_ssh;send_and_receive(SSH, ChannelId, 0, Data, End, DefaultTimeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#send_and_receive-6&quot;&gt;ct_ssh;send_and_receive(SSH, ChannelId, 0, Data, End, DefaultTimeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5531a67354abe2466d4f6bdcf4cb300aed1b289a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#sendf-4&quot;&gt;ct_telnet:sendf(Connection, CmdFormat, Args, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#sendf-4&quot;&gt;ct_telnet:sendf(Connection, CmdFormat, Args, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28d60fb429ec157bfba67f0024b3f13e4b30f298" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#session_open-2&quot;&gt;ct_ssh:session_open(SSH, DefaultTimeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#session_open-2&quot;&gt;ct_ssh:session_open(SSH, DefaultTimeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="748fc47780e0cffa40f2a4d6684163ed9f8a388d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#shell-3&quot;&gt;ct_ssh:shell(SSH, ChannelId, DefaultTimeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;&lt;a href=&quot;#shell-3&quot;&gt;ct_ssh:shell(SSH, ChannelId, DefaultTimeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5847b1d6a4c1cbd5f9c7a9d17a643c6495212b2b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#socknames-2&quot;&gt;socknames(Socket, 0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#socknames-2&quot;&gt;socknames(Socket, 0)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="984186eb7309dbab51162e38d9773627b7539190" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; except it returns &lt;code&gt;ok&lt;/code&gt; for already started applications.</source>
          <target state="translated">이미 시작된 응용 프로그램에 대해 &lt;code&gt;ok&lt;/code&gt; 를 반환하는 것을 제외하고 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="559f72d708af708ecaccec78db858d90a2a93952" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start(Config, MgrAgentConfName, undefined)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#start-3&quot;&gt;ct_snmp:start(Config, MgrAgentConfName, undefined)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7465f3b70b812611f2b839f4be2f68f7756bd422" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt; stop(Process, normal, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt; stop(Process, normal, infinity)&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="87d4bb462cb2b05b3682a59f158cf0c1eac2da50" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(Process, normal, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#stop-3&quot;&gt;stop(Process, normal, infinity)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fc48bb6764fb6905d96cb3af30a21cb3522075e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#string-2&quot;&gt;string(Test, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#string-2&quot;&gt;string(Test, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3082ff8847953fbb53b67ee205753da5412f05b0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#string-2&quot;&gt;string(Text, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#string-2&quot;&gt;string(Text, [])&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3983bb17205ecce0781b18cfc33ffa250f3f9b17" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#string-3&quot;&gt;string(Str, Doc, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#string-3&quot;&gt;string(Str, Doc, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0f34e497a773dfe8e54c1c139a731148987e9d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#string-5&quot;&gt;string(Str, Doc, [], Doc, Options)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#string-5&quot;&gt;string(Str, Doc, [], Doc, Options)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da1e8a62e145e55d0bd478bbeb5ac881b7ffeacb" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#subsystem-4&quot;&gt;ct_ssh:subsystem(SSH, ChannelId, Subsystem, DefaultTimeout)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;#subsystem-4&quot;&gt;ct_ssh:subsystem(SSH, ChannelId, Subsystem, DefaultTimeout)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78f28f79846ca0d9d0380c448740fa3ab461f085" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#test-2&quot;&gt;test(Tests, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#test-2&quot;&gt;test(Tests, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="46bdb4ffd5f07ccfe657f5f363eace18e995517c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par(Text, 0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par(Text, 0)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2c778c9538e4aaf70ffe1027c64dcd4ad52318" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#to_comment-2&quot;&gt;to_comment(Tree, &quot;% &quot;)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;&lt;a href=&quot;#to_comment-2&quot;&gt;to_comment(Tree, &quot;% &quot;)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172f30366b5eca51448ccd156117ffe4ef4dd270" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree(Type, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree(Type, [])&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b4290fa5b9abeafbfbee520a470759133a359776" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#try_expr-3&quot;&gt;try_expr(Body, [], Handlers)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#try_expr-3&quot;&gt;try_expr(Body, [], Handlers)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a98cc95b855b196a73d2dbe2e87621b4e9461e44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#try_expr-4&quot;&gt;try_expr(Body, Clauses, Handlers, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#try_expr-4&quot;&gt;try_expr(Body, Clauses, Handlers, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="393eab34c4091b6c396a9cb3f5afdce92b4d5690" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#try_expr-4&quot;&gt;try_expr(Body, [], [], After)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#try_expr-4&quot;&gt;try_expr(Body, [], [], After)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3525075cc649f0b865bf28dc206116f3a75e6bb0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#tuple_type-1&quot;&gt;tuple_type(any_size)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tuple_type-1&quot;&gt;tuple_type(any_size)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a65926c5005cfc07b105de8bdb2f49ec2fd7bd0b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#update_c_bitstr-6&quot;&gt;update_c_bitstr(Node, Value, Size, abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;&lt;a href=&quot;#update_c_bitstr-6&quot;&gt;update_c_bitstr(Node, Value, Size, abstract(1), Type, Flags)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b300fe7fb5ee04fa800d8b1594780a62dd5668f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#update_c_var-2&quot;&gt;update_c_var(Old, {Atom, Arity})&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;&lt;a href=&quot;#update_c_var-2&quot;&gt;update_c_var(Old, {Atom, Arity})&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0ae2cb3c1ac8a7815d4c943853ad68b65894a7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#update_list-3&quot;&gt;update_list(Old, List, none)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#update_list-3&quot;&gt;update_list(Old, List, none)&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e65f3d4be993cb540daefebbf089c080fd2bcc0a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#user_state-2&quot;&gt;user_state(UserState, S)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#user_state-2&quot;&gt;user_state(UserState, S)&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0a648640af68a7a3424b5fa2d1643a50975caaa7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;#validate-3&quot;&gt;validate(Element, State, [])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;#validate-3&quot;&gt;validate(Element, State, [])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="873f285eec04cc2d338a6f123c329f06b8d6906b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;abcast([node()|nodes()], Name, Msg)&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;abcast([node()|nodes()], Name, Msg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2314ba79d059b9f70d68a46f23db90b5096b14" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;assert(not (BoolExpr))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;assert(not (BoolExpr))&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="49d07bde253c258b6e5119a225803e592c5bd6ac" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;c(Mod, Fun, Args, all)&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;c(Mod, Fun, Args, all)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7b0942fc111607cfd507cff77f9604132227b3e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;clause_arity(hd(case_clauses(Node)))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">동등 &lt;code&gt;clause_arity(hd(case_clauses(Node)))&lt;/code&gt; 하지만 잠재적으로 더 효율적.</target>
        </trans-unit>
        <trans-unit id="0d2693afafa3a4f522422a66ff265fc275322d11" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_accept&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수가있는 &lt;code&gt;ei_accept&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fe93afc73c3f9764478bef4e6997aedccefb7c5e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_connect&lt;/code&gt; and &lt;code&gt;ei_xconnect&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 &lt;code&gt;ei_xconnect&lt;/code&gt; 있는 &lt;code&gt;ei_connect&lt;/code&gt; 및 ei_xconnect 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d69ae914c44fa51e4abff901abcf4cf2e12608" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_connect&lt;/code&gt;, &lt;code&gt;ei_xconnect&lt;/code&gt;, &lt;code&gt;ei_connect_host_port&lt;/code&gt; and &lt;code&gt;ei_xconnect_host_port&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">에 해당 &lt;code&gt;ei_connect&lt;/code&gt; , &lt;code&gt;ei_xconnect&lt;/code&gt; , &lt;code&gt;ei_connect_host_port&lt;/code&gt; 및 &lt;code&gt;ei_xconnect_host_port&lt;/code&gt; 를 , 선택 시간 초과 인수와 함께이 매뉴얼 페이지의 시작 부분에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6766d6e6f0ca259b2b4fe7c18d6a021733bb029" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_publish&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수를 사용하는 &lt;code&gt;ei_publish&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="357549a951b93d2fe1f08d3b6ce8fccccc5909f8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_receive&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수 를 사용하여 &lt;code&gt;ei_receive&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ed6d9c26f3211088345464d7195820fb0b683b7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_receive_encoded&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수가있는 &lt;code&gt;ei_receive_encoded&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0dea09ecf0ce4ef083abe1c68f78072b2acdfe8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_receive_msg&lt;/code&gt; and &lt;code&gt;ei_xreceive_msg&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; 있는 &lt;code&gt;ei_receive_msg&lt;/code&gt; 및 ei_xreceive_msg 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1daf5aab84994ce8b1b17f8217407ad9a9421362" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_reg_send&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수가있는 &lt;code&gt;ei_reg_send&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f5b7ce6688fd79fb13af97726b953d122ae14a5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_send&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수 를 사용하여 &lt;code&gt;ei_send&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa3a62b004169854deb46f3ea23711d52ec99e19" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_send_encoded&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수가있는 &lt;code&gt;ei_send_encoded&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fdbbdcd826b12d9b063c0edb20f26039bf62f2c5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_send_reg_encoded&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수가있는 &lt;code&gt;ei_send_reg_encoded&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3771da7911206304296a139bb6ab1cd431ea448f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ei_unpublish&lt;/code&gt; with an optional time-out argument, see the description at the beginning of this manual page.</source>
          <target state="translated">선택적 시간 제한 인수가있는 &lt;code&gt;ei_unpublish&lt;/code&gt; 와 동일 하므로이 매뉴얼 페이지의 시작 부분에있는 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8372ca82b2bf9f43c79046f3c267b8c75e3fba27" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;epp:open([{name, FileName}, {includes, IncludePath}, {macros, PredefMacros}])&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;epp:open([{name, FileName}, {includes, IncludePath}, {macros, PredefMacros}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198cb07298ed627519d26597d6831ad8e028d1bc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;epp:open([{name, FileName}, {includes, IncludePath}])&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;epp:open([{name, FileName}, {includes, IncludePath}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53d242559dae93c7b2e26e415d4624b964dba226" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;epp:parse_file(FileName, [{includes, IncludePath}, {macros, PredefMacros}])&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;epp:parse_file(FileName, [{includes, IncludePath}, {macros, PredefMacros}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0b0a7825fa600d273f72548e8689855e692d68f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;eval_everywhere([node()|nodes()], Module, Function, Args)&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;eval_everywhere([node()|nodes()], Module, Function, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f2381fc4af295f43d8475e70b96168d889f6df" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;file2tab(Filename, [])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file2tab(Filename, [])&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="842a9683942021cace77766f96d9ce37582d38fd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;find_source(Base, Dir)&lt;/code&gt;, where &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;filename:dirname(FilePath)&lt;/code&gt; and &lt;code&gt;Base&lt;/code&gt; is &lt;code&gt;filename:basename(FilePath)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;find_source(Base, Dir)&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;Dir&lt;/code&gt; 은 &lt;code&gt;filename:dirname(FilePath)&lt;/code&gt; 이고 &lt;code&gt;Base&lt;/code&gt; 는 &lt;code&gt;filename:basename(FilePath)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bb51d51da2854ce584486e5a63cedf1b672710c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;flush_trace_port(node())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flush_trace_port(node())&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cfe7f1272df44e504d688e8961f8495f03a9acf6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;format(File,[])&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;format(File,[])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7507752d4a1ae2cdc8159320ce2dc9fd525a44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;get_tracer(node())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_tracer(node())&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8675407d0eefd7e1fa96e369c0e4f4fdca1b2267" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;get_value(Key, List, undefined)&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;get_value(Key, List, undefined)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba1efd80b03330c9f85a8c53359c4a37ca62862" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;httpc:request(get, {Url, []}, [], [])&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;httpc:request(get, {Url, []}, [], [])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="676ae76dfcb047db9b4cd53c668edaa9a70d3c1b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;length(flatten(DeepList))&lt;/code&gt;, but more efficient.</source>
          <target state="translated">상당 &lt;code&gt;length(flatten(DeepList))&lt;/code&gt; 있지만 효율적.</target>
        </trans-unit>
        <trans-unit id="1f8190e1f3904664c2b059b79267ce3617135122" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;limit(Tree, Depth, Text)&lt;/code&gt; using the text &lt;code&gt;&quot;...&quot;&lt;/code&gt; as default replacement.</source>
          <target state="translated">텍스트 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 를 기본 대체로 사용하여 &lt;code&gt;limit(Tree, Depth, Text)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="be09fc87aab378494fce066f0485d5a0d7499916" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;multi_server_call([node()|nodes()], Name, Msg)&lt;/code&gt;.</source>
          <target state="translated">에 해당 &lt;code&gt;multi_server_call([node()|nodes()], Name, Msg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ffd80c51ac16407654fdc702f764a022d0760d1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;multicall(Nodes, Module, Function, Args, infinity)&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;multicall(Nodes, Module, Function, Args, infinity)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c65892943e712456d18bca5e8a8e46eef1b642c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;multicall([node()|nodes()], Module, Function, Args, Timeout)&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;multicall([node()|nodes()], Module, Function, Args, Timeout)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faabbe69bfb964b589ccd6cd72f8899c84ab075e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;multicall([node()|nodes()], Module, Function, Args, infinity)&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;multicall([node()|nodes()], Module, Function, Args, infinity)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc35a1c84693226736068e8931d9c9ad030d643e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;nb_yield(Key, 0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nb_yield(Key, 0)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6261c8ba9c7577bfb3094bced71d443552a3aece" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;new([])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new([])&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="311411e636025da0e8fca30ce8313dba2f022a6c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;p(Item, [m])&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;p(Item, [m])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f746dc814af09ad51f8158cdfa5e12800a67f5a9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sbcast([node()|nodes()], Name, Msg)&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;sbcast([node()|nodes()], Name, Msg)&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
