<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="51bb3389ce8effbbb1e7082b3ae1de9569a30494" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션으로 지정된 알고리즘은 TLS-1.2에 도입 된 서명 알고리즘 협상에서 서버가 승인 한 알고리즘입니다. 클라이언트 인증서가 요청되면 알고리즘도 클라이언트에 제공됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4e6804a383e502432af39ff151c1928a9f75f02" translate="yes" xml:space="preserve">
          <source>The algorithms specified by this option will be the ones accepted by the server in a signature algorithm negotiation, introduced in TLS-1.2. The algorithms will also be offered to the client if a client certificate is requested. For more details see the &lt;code&gt;&lt;a href=&quot;#type-client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 옵션으로 지정된 알고리즘은 TLS-1.2에 도입 된 서명 알고리즘 협상에서 서버가 허용하는 알고리즘입니다. 클라이언트 인증서가 요청되면 알고리즘도 클라이언트에 제공됩니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#type-client_signature_algs&quot;&gt;corresponding client option&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b2fe8210e9b69a3cc07735de1a6330b93954baa" translate="yes" xml:space="preserve">
          <source>The algoritm for modifications works like this:</source>
          <target state="translated">수정 알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="24adcb7d68961d8f0a870550a960cd9eb67c1117" translate="yes" xml:space="preserve">
          <source>The allocator instance that created a carrier &lt;strong&gt;owns&lt;/strong&gt; it.</source>
          <target state="translated">캐리어를 생성 한 할당 자 인스턴스가 이를 &lt;strong&gt;소유&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="653b6f4757ea27c31c0c448ccd9f5fac52d31c8d" translate="yes" xml:space="preserve">
          <source>The allocator instance that created a carrier is called its &lt;strong&gt;owner&lt;/strong&gt;. Ownership never changes.</source>
          <target state="translated">캐리어를 생성 한 할당 자 인스턴스를 &lt;strong&gt;소유자&lt;/strong&gt; 라고합니다 . 소유권은 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21d1f0815a6d444af90bd4312ec8e5903fa532a8" translate="yes" xml:space="preserve">
          <source>The allocator instance that has the responsibility to perform deallocations in a carrier is called its &lt;strong&gt;employer&lt;/strong&gt;. The employer may also perform allocations if the carrier is not in the pool. Employment may change when a carrier is fetched from or inserted into the pool.</source>
          <target state="translated">캐리어에서 할당 해제를 수행 할 책임이있는 할당 자 인스턴스를 &lt;strong&gt;고용주&lt;/strong&gt; 라고합니다 . 고용주는 운송 업체가 풀에없는 경우 할당을 수행 할 수도 있습니다. 캐리어를 풀에서 가져 오거나 풀에 삽입하면 고용이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecacc86ad4cc59e19da91bbb213a08cf8976a29a" translate="yes" xml:space="preserve">
          <source>The allocator instance that uses a carrier &lt;strong&gt;employs&lt;/strong&gt; it.</source>
          <target state="translated">캐리어를 사용하는 할당 자 인스턴스가 이를 &lt;strong&gt;사용&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="10574335a609a1059aa012db0f86b9ea475e61d4" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Defaults to all &lt;code&gt;alloc_util&lt;/code&gt; allocators.</source>
          <target state="translated">검색 할 할당 자 유형 기본값은 모든 &lt;code&gt;alloc_util&lt;/code&gt; 할당 자입니다.</target>
        </trans-unit>
        <trans-unit id="c7aaf2a06a430d8ee61ee710cc5151971b25f4ab" translate="yes" xml:space="preserve">
          <source>The allocator types that will be searched. Note that blocks can move freely between allocator types, so restricting the search to certain allocators may return unexpected types (e.g. process heaps when searching binary_alloc), or hide blocks that were migrated out.</source>
          <target state="translated">검색 할 할당 자 유형입니다. 블록은 할당 자 유형간에 자유롭게 이동할 수 있으므로 검색을 특정 할당 자로 제한하면 예기치 않은 유형 (예 : binary_alloc 검색시 힙 처리)을 반환하거나 마이그레이션 된 블록을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f12057feba7f44e75f727b96980ea9629634e93c" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt; mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="translated">테이블 의 허용 된 &lt;code&gt;AccessMode&lt;/code&gt; 는 &lt;code&gt;read_only&lt;/code&gt; 또는 &lt;code&gt;read_write&lt;/code&gt; 로 정의 할 수 있습니다 . 런타임에서 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt; mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; 함수로 토글 할 수 있습니다 . &lt;code&gt;read_only&lt;/code&gt; 테이블과 &lt;code&gt;local_content&lt;/code&gt; 테이블은 다른 노드에서 테이블을 복사 할 필요가 없기 때문에 항상 로컬로로드됩니다. 테이블이 이미로드되어 있거나 실행중인 &lt;code&gt;Mnesia&lt;/code&gt; 가 이미 테이블을로드하기로 결정한 경우 다른 테이블은 주로 다른 노드의 활성 복제본에서 원격으로로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="f7ed9195c9091feda9cc03849f91a3d0e1313381" translate="yes" xml:space="preserve">
          <source>The allowed &lt;code&gt;AccessMode&lt;/code&gt; of a table can be defined to be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;. It can be toggled with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; in runtime. &lt;code&gt;read_only&lt;/code&gt; tables and &lt;code&gt;local_content&lt;/code&gt; tables are always loaded locally, as there is no need for copying the table from other nodes. Other tables are primarily loaded remotely from active replicas on other nodes if the table has been loaded there already, or if the running &lt;code&gt;Mnesia&lt;/code&gt; has decided to load the table there already.</source>
          <target state="translated">테이블 의 허용 된 &lt;code&gt;AccessMode&lt;/code&gt; 는 &lt;code&gt;read_only&lt;/code&gt; 또는 &lt;code&gt;read_write&lt;/code&gt; 로 정의 될 수 있습니다 . 런타임시 &lt;code&gt;&lt;a href=&quot;mnesia#change_table_access_mode-2&quot;&gt;mnesia:change_table_access_mode(Tab, AccessMode)&lt;/a&gt;&lt;/code&gt; 함수로 전환 할 수 있습니다 . &lt;code&gt;read_only&lt;/code&gt; 테이블 및 &lt;code&gt;local_content&lt;/code&gt; 테이블은 다른 노드에서 테이블을 복사 할 필요가 없으므로 항상 로컬로로드됩니다. 테이블이 이미로드되어 있거나 실행중인 &lt;code&gt;Mnesia&lt;/code&gt; 가 이미 테이블을로드하기로 결정한 경우 다른 테이블은 주로 다른 노드의 활성 복제본에서 원격으로로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="c9cd2b75bdb0d580c661ccb5efbc7ebe47d4aa8f" translate="yes" xml:space="preserve">
          <source>The allowed range is 1..256. Defaults to 1 for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt;, and to 8 for &lt;code&gt;binary&lt;/code&gt;. No unit specifier must be given for the types &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;.</source>
          <target state="translated">허용되는 범위는 1..256입니다. &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;bitstring&lt;/code&gt; 의 경우 기본값은 1 이고 &lt;code&gt;binary&lt;/code&gt; 의 경우 8입니다 . &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 유형에는 단위 지정자를 지정하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="ad89fe4bac55bef5e612143241645e3f39f837c7" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;Operation&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 에 허용되는 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91eabbe1745620d58dbabfc6b149c475cb3f775e" translate="yes" xml:space="preserve">
          <source>The amount of dirty CPU schedulers is limited by the amount of normal schedulers in order to limit the effect on processes executing on ordinary schedulers. If the amount of dirty CPU schedulers was allowed to be unlimited, dirty CPU bound jobs would potentially starve normal jobs.</source>
          <target state="translated">더티 CPU 스케줄러의 양은 일반 스케줄러에서 실행되는 프로세스에 대한 영향을 제한하기 위해 일반 스케줄러의 양에 의해 제한됩니다. 더티 CPU 스케줄러의 수가 무제한으로 허용되면 더티 CPU 바운드 작업이 잠재적으로 일반 작업에 굶주리게됩니다.</target>
        </trans-unit>
        <trans-unit id="27a9761aa8b41fe03707985ac819ffa2294674b4" translate="yes" xml:space="preserve">
          <source>The amount of dirty IO schedulers is not limited by the amount of normal schedulers &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt;. This since only I/O bound work is expected to execute on dirty I/O schedulers. If the user should schedule CPU bound jobs on dirty I/O schedulers, these jobs might starve ordinary jobs executing on ordinary schedulers.</source>
          <target state="translated">더티 IO 스케줄러 &lt;code&gt;&lt;a href=&quot;#+SDcpu&quot;&gt;like the amount of dirty CPU schedulers&lt;/a&gt;&lt;/code&gt; 일반 스케줄러의 양에 의해 제한되지 않습니다 . 이는 I / O 바운드 작업 만 더티 I / O 스케줄러에서 실행될 것으로 예상되기 때문입니다. 사용자가 더티 I / O 스케줄러에서 CPU 바운드 작업을 예약해야하는 경우 이러한 작업은 일반 스케줄러에서 실행중인 일반 작업에 굶주릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="664e7e56a2225929620ef872c0ebcd0c6fb9c4c1" translate="yes" xml:space="preserve">
          <source>The amount of free memory available to the Erlang emulator for allocation.</source>
          <target state="translated">Erlang 에뮬레이터가 할당 할 수있는 사용 가능한 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="856f5380158f6d7ba56eebb6ae41011bd9432d40" translate="yes" xml:space="preserve">
          <source>The amount of memory available to the whole operating system. This may well be equal to &lt;code&gt;total_memory&lt;/code&gt; but not necessarily.</source>
          <target state="translated">전체 운영 체제에서 사용할 수있는 메모리 양 이것은 &lt;code&gt;total_memory&lt;/code&gt; 와 같을 수도 있지만 반드시 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="177a7f5e407b489cea8a1c26cd218274ba08f36c" translate="yes" xml:space="preserve">
          <source>The amount of memory the system has available for disk swap.</source>
          <target state="translated">시스템이 디스크 스왑에 사용할 수있는 메모리 양.</target>
        </trans-unit>
        <trans-unit id="7656a9402d240df34705d7b544f4dff29a5abe83" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for cached files read from disk.</source>
          <target state="translated">시스템이 디스크에서 읽은 캐시 된 파일에 사용하는 메모리의 양입니다.</target>
        </trans-unit>
        <trans-unit id="eee7cda7742ee86ae7d191faad9371151f0ebd25" translate="yes" xml:space="preserve">
          <source>The amount of memory the system uses for temporary storing raw disk blocks.</source>
          <target state="translated">원시 디스크 블록을 임시 저장하기 위해 시스템이 사용하는 메모리의 양입니다.</target>
        </trans-unit>
        <trans-unit id="1082b666267c1d0a05f9d3fc735ec44903b5cce2" translate="yes" xml:space="preserve">
          <source>The amount of time that passes between a signal is sent and the arrival of the signal at the destination is unspecified but positive. If the receiver has terminated, the signal does not arrive, but it can trigger another signal. For example, a link signal sent to a non-existing process triggers an exit signal, which is sent back to where the link signal originated from. When communicating over the distribution, signals can be lost if the distribution channel goes down.</source>
          <target state="translated">신호 사이를 통과하는 시간이 전송되고 목적지에 신호가 도착하는 것은 지정되지 않았지만 양수입니다. 수신기가 종료되면 신호가 도착하지 않지만 다른 신호를 트리거 할 수 있습니다. 예를 들어, 존재하지 않는 프로세스로 전송 된 링크 신호는 종료 신호를 트리거하며,이 신호는 링크 신호가 발생한 위치로 다시 전송됩니다. 분배를 통해 통신 할 때 분배 채널이 중단되면 신호가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4519c04c3df5357f9581cfbf162358aa5fec4d97" translate="yes" xml:space="preserve">
          <source>The amount of total amount of memory the system has available for disk swap.</source>
          <target state="translated">시스템이 디스크 스왑에 사용할 수있는 총 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="acb741068fefaff7489583de212a734f3e2cfa94" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap, in words. This information is usually useless.</source>
          <target state="translated">각 힙에서 사용되지 않은 메모리의 양 (단어)입니다. 이 정보는 일반적으로 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="784b5a2e886a3960b27831ea309171f77ba1c2b8" translate="yes" xml:space="preserve">
          <source>The amount of unused memory on each heap. This information is usually useless.</source>
          <target state="translated">각 힙에서 사용되지 않은 메모리의 양입니다. 이 정보는 일반적으로 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eaa8449008b96acfc6b47fd80ac7ade7e1100e51" translate="yes" xml:space="preserve">
          <source>The analysis result can either be for all modules, or for one module. In either case a call count limit can be given to filter out the functions with a call count below the limit. The all modules analysis does &lt;strong&gt;not&lt;/strong&gt; contain the module &lt;code&gt;cprof&lt;/code&gt; itself, it can only be analysed by specifying it as a single module to analyse.</source>
          <target state="translated">분석 결과는 모든 모듈 또는 하나의 모듈 일 수 있습니다. 두 경우 모두 호출 수 제한을 지정하여 호출 수를 제한 아래로 사용하여 기능을 필터링 할 수 있습니다. 모든 모듈 분석 에는 모듈 &lt;code&gt;cprof&lt;/code&gt; 자체가 포함되어 있지 &lt;strong&gt;않으며&lt;/strong&gt; 분석 할 단일 모듈로 지정해야만 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="665b53498dfc4b5081b2898303b46c4e6c1e3b19" translate="yes" xml:space="preserve">
          <source>The analysis starts from an empty PLT and creates a new one from the files specified with &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt;. This option only works for BEAM files. To override the default PLT location, use &lt;code&gt;--plt&lt;/code&gt; or &lt;code&gt;--output_plt&lt;/code&gt;.</source>
          <target state="translated">빈 PLT에서 분석이 시작되고 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-r&lt;/code&gt; 로 지정된 파일에서 새로운 PLT가 작성 됩니다. 이 옵션은 BEAM 파일에만 작동합니다. 기본 PLT 위치를 재정의하려면 &lt;code&gt;--plt&lt;/code&gt; 또는 &lt;code&gt;--output_plt&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a17bc48533ec6b4b1d93aa9a618a8199d8ee18c" translate="yes" xml:space="preserve">
          <source>The ancillary data &lt;code&gt;AncData&lt;/code&gt; contains options that for this single message override the default options for the socket, an operation that may not be supported on all platforms, and if so return &lt;code&gt;{error, einval}&lt;/code&gt;. Using more than one of an ancillary data item type may also not be supported. &lt;code&gt;AncData =:= []&lt;/code&gt; is always supported.</source>
          <target state="translated">보조 데이터 &lt;code&gt;AncData&lt;/code&gt; 에는이 단일 메시지에 대해 소켓의 기본 옵션, 모든 플랫폼에서 지원되지 않을 수있는 작업을 재정의하는 옵션이 포함되어 있으며, 그렇다면 &lt;code&gt;{error, einval}&lt;/code&gt; 반환 합니다. 하나 이상의 보조 데이터 항목 유형을 사용하는 것도 지원되지 않을 수 있습니다. &lt;code&gt;AncData =:= []&lt;/code&gt; 는 항상 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cdcf511f2d0831631f6fdd22a140605914418760" translate="yes" xml:space="preserve">
          <source>The answer to the request is encoded to a UDP Protocol Data Unit (PDU).</source>
          <target state="translated">요청에 대한 답변은 UDP 프로토콜 데이터 유닛 (PDU)으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf1e9025d3f661f3470ed7afc4906eb1f7fc756" translate="yes" xml:space="preserve">
          <source>The answers are found by evaluating the qualifiers from left to right, backtracking when some filter returns &lt;code&gt;false&lt;/code&gt;, or collecting the template when all filters return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">한정자는 왼쪽에서 오른쪽으로 한정자를 평가 하거나 일부 필터가 &lt;code&gt;false&lt;/code&gt; 를 반환하면 역 추적 하거나 모든 필터가 &lt;code&gt;true&lt;/code&gt; 를 반환하면 템플릿을 수집하여 답을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f318a6ba118898a63239c22ec72006a08d5ca687" translate="yes" xml:space="preserve">
          <source>The application can be specified by its name &lt;code&gt;Application&lt;/code&gt;. In this case, the application controller searches the code path for the application resource file &lt;code&gt;Application.app&lt;/code&gt; and loads the specification it contains.</source>
          <target state="translated">응용 프로그램은 이름 &lt;code&gt;Application&lt;/code&gt; 으로 지정할 수 있습니다 . 이 경우 응용 프로그램 컨트롤러는 응용 프로그램 리소스 파일 &lt;code&gt;Application.app&lt;/code&gt; 에 대한 코드 경로를 검색하고 포함 된 사양을로드합니다.</target>
        </trans-unit>
        <trans-unit id="620c94d66204ee923841db86e6b7d75bbdd11ef8" translate="yes" xml:space="preserve">
          <source>The application concept applies both to program structure (processes) and directory structure (modules).</source>
          <target state="translated">응용 프로그램 개념은 프로그램 구조 (프로세스) 및 디렉토리 구조 (모듈)에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f58d25a7007e6f3798c0b59bdfac842192b77950" translate="yes" xml:space="preserve">
          <source>The application controller automatically loads any included applications when loading a primary application, but does not start them. Instead, the top supervisor of the included application must be started by a supervisor in the including application.</source>
          <target state="translated">응용 프로그램 제어기는 기본 응용 프로그램을로드 할 때 포함 된 응용 프로그램을 자동으로로드하지만 시작하지는 않습니다. 대신 포함 된 응용 프로그램의 최고 감독자는 포함하는 응용 프로그램의 감독자가 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="98f6f34774d04811ed29ee462b6732dccb9d0043" translate="yes" xml:space="preserve">
          <source>The application controller checks the value of the application specification key &lt;code&gt;applications&lt;/code&gt;, to ensure that all applications needed to be started before this application are running. Otherwise, &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; is returned, where &lt;code&gt;App&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">응용 프로그램 제어기는 응용 프로그램 스펙 키 &lt;code&gt;applications&lt;/code&gt; 프로그램의 값을 검사 하여이 응용 프로그램을 실행하기 전에 시작해야하는 모든 응용 프로그램을 확인합니다. 그렇지 않으면 &lt;code&gt;{error,{not_started,App}}&lt;/code&gt; 가 리턴되며 여기서 &lt;code&gt;App&lt;/code&gt; 은 누락 된 애플리케이션의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f3a71b2d510c249b1ef4dc36fecf08094449baa7" translate="yes" xml:space="preserve">
          <source>The application controller creates an application master for the application</source>
          <target state="translated">응용 프로그램 컨트롤러는 응용 프로그램의 응용 프로그램 마스터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="83a95923e1f732ae145bb3e38ddb63679bc6a37a" translate="yes" xml:space="preserve">
          <source>The application controller then creates an &lt;strong&gt;application master&lt;/strong&gt; for the application. The application master becomes the group leader of all the processes in the application. I/O is forwarded to the previous group leader, though, this is just a way to identify processes that belong to the application. Used for example to find itself from any process, or, reciprocally, to kill them all when it terminates.</source>
          <target state="translated">그런 다음 응용 프로그램 컨트롤러는 &lt;strong&gt;응용 프로그램&lt;/strong&gt; 의 &lt;strong&gt;응용 프로그램 마스터&lt;/strong&gt; 를 만듭니다 . 응용 프로그램 마스터는 응용 프로그램의 모든 프로세스의 그룹 리더가됩니다. I / O는 이전 그룹 리더에게 전달되지만 이는 응용 프로그램에 속하는 프로세스를 식별하는 방법 일뿐입니다. 예를 들어 모든 프로세스에서 자신을 찾거나 상호 적으로 종료 될 때 프로세스를 모두 종료하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0f6ae5fb0c8a7581cb9e8e067ef2f56d1995bb" translate="yes" xml:space="preserve">
          <source>The application dependencies can be checked using the Erlang shell. Application dependencies are verified among installed applications by &lt;code&gt;otp_patch_apply&lt;/code&gt;, but these are not necessarily those actually loaded. By calling &lt;code&gt;system_information:sanity_check()&lt;/code&gt; one can validate dependencies among applications actually loaded.</source>
          <target state="translated">응용 프로그램 종속성은 Erlang 셸을 사용하여 확인할 수 있습니다. &lt;code&gt;otp_patch_apply&lt;/code&gt; 에 의해 설치된 응용 프로그램간에 응용 프로그램 종속성이 확인 되지만 실제로로드 된 것은 아닙니다. &lt;code&gt;system_information:sanity_check()&lt;/code&gt; 를 호출하면 실제로로드 된 응용 프로그램 간의 종속성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb62df0e58b18cc0a3dd6823066bbe7bee60e95d" translate="yes" xml:space="preserve">
          <source>The application is started at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. The application is started as usual. That is, an application master is created and calls the application callback function:</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;distributed&lt;/code&gt; 구성 매개 변수 의 노드 목록에 나열된 첫 번째 운영 노드에서 시작됩니다 . 응용 프로그램은 평소와 같이 시작됩니다. 즉, 응용 프로그램 마스터가 만들어지고 응용 프로그램 콜백 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="89049fedc72f84958aace187301d7f02b79550e8" translate="yes" xml:space="preserve">
          <source>The application is started by the application master calling:</source>
          <target state="translated">응용 프로그램은 응용 프로그램 마스터 호출에 의해 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="bfedb4900bc06eb3b379ebe1429d3cb0e9392954" translate="yes" xml:space="preserve">
          <source>The application is started the normal way at the new node, that is, by the application master calling:</source>
          <target state="translated">응용 프로그램은 새 노드에서 정상적으로 시작됩니다. 즉, 응용 프로그램 마스터 호출에 의해 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="10822e972b13555d1eff4f5137f6287954df0861" translate="yes" xml:space="preserve">
          <source>The application master calls &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; to start the top supervisor.</source>
          <target state="translated">응용 프로그램 마스터 는 최상위 감독자를 시작하기 위해 &lt;code&gt;Module:start(normal, StartArgs)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e29776b842b696055e58002f88fb65232061b2ab" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;Module:start/2&lt;/code&gt; as defined by the application specification key &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 마스터 는 응용 프로그램 사양 키 &lt;code&gt;mod&lt;/code&gt; 로 정의 된 응용 프로그램 콜백 함수 &lt;code&gt;Module:start/2&lt;/code&gt; 를 호출하여 응용 프로그램을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="8cabb4f62fd98a4ff2c6678b3ed5fdfd959999a1" translate="yes" xml:space="preserve">
          <source>The application master starts the application by calling the application callback function &lt;code&gt;start/2&lt;/code&gt; in the module, and with the start argument, defined by the &lt;code&gt;mod&lt;/code&gt; key in the &lt;code&gt;.app&lt;/code&gt; file.</source>
          <target state="translated">응용 프로그램 마스터는 모듈에서 응용 프로그램 콜백 함수 &lt;code&gt;start/2&lt;/code&gt; 를 시작 하고 &lt;code&gt;.app&lt;/code&gt; 파일 의 &lt;code&gt;mod&lt;/code&gt; 키로 정의 된 start 인수를 사용 하여 응용 프로그램을 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="13734b250f5eb9d546b03086cf7b41b4dea34d6f" translate="yes" xml:space="preserve">
          <source>The application master stops the application by telling the top supervisor to shut down. The top supervisor tells all its child processes to shut down, and so on; the entire tree is terminated in reversed start order. The application master then calls the application callback function &lt;code&gt;stop/1&lt;/code&gt; in the module defined by the &lt;code&gt;mod&lt;/code&gt; key.</source>
          <target state="translated">응용 프로그램 마스터는 최고 감독자에게 시스템 종료를 지시하여 응용 프로그램을 중지합니다. 최고 감독자는 모든 하위 프로세스에 종료 등을 지시합니다. 전체 트리는 시작 순서가 반대로 종료됩니다. 그런 다음 응용 프로그램 마스터 는 &lt;code&gt;mod&lt;/code&gt; 키로 정의 된 모듈에서 응용 프로그램 콜백 함수 &lt;code&gt;stop/1&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b526c8807809b1d1a78677dccccf183dc7531782" translate="yes" xml:space="preserve">
          <source>The application master then calls &lt;code&gt;Module:start/2&lt;/code&gt; for the primary application, followed by calls to &lt;code&gt;Module:start_phase/3&lt;/code&gt; for each start phase (as defined for the primary application), both for the primary application and for each of its included applications, for which the start phase is defined.</source>
          <target state="translated">그런 다음 응용 프로그램 마스터 는 기본 응용 프로그램에 대해 &lt;code&gt;Module:start/2&lt;/code&gt; 를 호출 한 다음 기본 응용 프로그램 및 포함 된 각 응용 프로그램에 대해 기본 응용 프로그램에 대해 정의 된대로 각 시작 단계에 대해 &lt;code&gt;Module:start_phase/3&lt;/code&gt; 를 호출합니다 . 시작 단계가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a163c20a5a18b97757a743989413cf19c582f80f" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R10B or later.</source>
          <target state="translated">이 응용 프로그램에는 Erlang / OTP 릴리스 R10B 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="47de7b9f1554880fd51a51ad6a1c134e4bb1c43b" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13B02 or later.</source>
          <target state="translated">이 응용 프로그램에는 Erlang / OTP 릴리스 R13B02 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="04c072f323859be092a04c77c0d3a8f3932431a9" translate="yes" xml:space="preserve">
          <source>The application requires Erlang/OTP release R13BB or later. If you use the old &lt;code&gt;GS&lt;/code&gt; based GUI it does suffice with R7B.</source>
          <target state="translated">이 응용 프로그램에는 Erlang / OTP 릴리스 R13BB 이상이 필요합니다. 이전 &lt;code&gt;GS&lt;/code&gt; 기반 GUI 를 사용하는 경우 R7B로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="705f938ebc82f5cfe9e917670d636ce442e4f982" translate="yes" xml:space="preserve">
          <source>The application resource file is to be called &lt;code&gt;Application.app&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in directory &lt;code&gt;ebin&lt;/code&gt; for the application.</source>
          <target state="translated">응용 프로그램 자원 파일의 이름은 &lt;code&gt;Application.app&lt;/code&gt; 이며 여기서 &lt;code&gt;Application&lt;/code&gt; 은 응용 프로그램 이름입니다. 파일은 응용 프로그램의 디렉토리 &lt;code&gt;ebin&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8095bda3db4836c710654adeb79de3919a1733c3" translate="yes" xml:space="preserve">
          <source>The application settings page is rather incomplete.</source>
          <target state="translated">응용 프로그램 설정 페이지가 다소 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="a30b190dbffeb37d7579aa94007cbfaeb029e782" translate="yes" xml:space="preserve">
          <source>The application specification can also be specified directly as a tuple &lt;code&gt;AppSpec&lt;/code&gt;, having the format and contents as described in &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 사양은 &lt;code&gt;&lt;a href=&quot;app&quot;&gt;app(4)&lt;/a&gt;&lt;/code&gt; 설명 된 형식과 내용을 가진 튜플 &lt;code&gt;AppSpec&lt;/code&gt; 으로 직접 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae0f5edbfbc9e079896bc2aadb1ec402b1e46966" translate="yes" xml:space="preserve">
          <source>The application upgrade file is to be called &lt;code&gt;Application.appup&lt;/code&gt;, where &lt;code&gt;Application&lt;/code&gt; is the application name. The file is to be located in the &lt;code&gt;ebin&lt;/code&gt; directory for the application.</source>
          <target state="translated">애플리케이션 업그레이드 파일의 이름은 &lt;code&gt;Application.appup&lt;/code&gt; 이며 여기서 &lt;code&gt;Application&lt;/code&gt; 은 애플리케이션 이름입니다. 파일은 응용 프로그램 의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="01be2b299856c125d638a3713ccfbcb4f60476f7" translate="yes" xml:space="preserve">
          <source>The application version of the SSL application.</source>
          <target state="translated">SSL 애플리케이션의 애플리케이션 버전입니다.</target>
        </trans-unit>
        <trans-unit id="73e6b27f7140dc43719697a589e7dc915f9cffa1" translate="yes" xml:space="preserve">
          <source>The application window is started by double clicking on an application name. The application window consists of four pages (tabs):</source>
          <target state="translated">응용 프로그램 이름은 응용 프로그램 이름을 두 번 클릭하여 시작됩니다. 응용 프로그램 창은 4 개의 페이지 (탭)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c8077f9793de81202aa1676c65a0451a20a5cbbb" translate="yes" xml:space="preserve">
          <source>The application-neutral representation of an AVP. Primarily intended for use by relay applications that need to handle arbitrary Diameter applications. A service implementing a specific Diameter application (for which it configures a dictionary) can manipulate values of type &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">AVP의 응용 프로그램 중립적 표현. 기본적으로 임의의 직경 응용 프로그램을 처리해야하는 릴레이 응용 프로그램에 사용됩니다. 사전을 구성하는 특정 직경 응용 프로그램을 구현하는 서비스는 대신 &lt;code&gt;&lt;a href=&quot;#message&quot;&gt;message()&lt;/a&gt;&lt;/code&gt; 유형의 값을 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e81712f8fd17dfa5b0951414305dbd11e0bfbc67" translate="yes" xml:space="preserve">
          <source>The applications are sorted according to the dependencies between the applications. Where there are no dependencies, the order in the &lt;code&gt;.rel&lt;/code&gt; file is kept.</source>
          <target state="translated">응용 프로그램은 응용 프로그램 간의 종속성에 따라 정렬됩니다. 종속성이없는 경우 &lt;code&gt;.rel&lt;/code&gt; 파일 의 순서 가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="82097ff09c0ae197dc0287ade0a7e0d61d1b24de" translate="yes" xml:space="preserve">
          <source>The applied function called &lt;code&gt;exit(ExitReason)&lt;/code&gt; and did not catch this exception. The exit reason &lt;code&gt;ExitReason&lt;/code&gt; equals the argument passed to &lt;code&gt;exit/1&lt;/code&gt;.</source>
          <target state="translated">적용된 함수는 &lt;code&gt;exit(ExitReason)&lt;/code&gt; 예외를 포착하지 못했습니다. 종료 이유 &lt;code&gt;ExitReason&lt;/code&gt; 은 &lt;code&gt;exit/1&lt;/code&gt; 에 전달 된 인수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="58807661154d4de0263adc44bf6decafbe204083" translate="yes" xml:space="preserve">
          <source>The applied function called &lt;code&gt;throw(Value)&lt;/code&gt; and did not catch this exception. The exception reason &lt;code&gt;Value&lt;/code&gt; equals the argument passed to &lt;code&gt;throw/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;throw(Value)&lt;/code&gt; 라는 적용된 함수 가이 예외를 포착하지 못했습니다. 예외 이유 &lt;code&gt;Value&lt;/code&gt; 가 &lt;code&gt;throw/1&lt;/code&gt; 에 전달 된 인수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="85353072338b2dbf168feea1aabc66961c7a142d" translate="yes" xml:space="preserve">
          <source>The archive must be closed with &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">아카이브는 &lt;code&gt;&lt;a href=&quot;#zip_close-1&quot;&gt;zip_close/1&lt;/a&gt;&lt;/code&gt; 로 닫아야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd634904a6b19656df55ba94518706b87469aeb9" translate="yes" xml:space="preserve">
          <source>The archive size is limited to 2 GB (32 bits).</source>
          <target state="translated">아카이브 크기는 2GB (32 비트)로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="cd12ca75aaea91ed2a310f36dcea8f4976e41af5" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;DefaultAgentConfig&lt;/code&gt; is used as default values when this user register agents.</source>
          <target state="translated">이 사용자가 에이전트를 등록 할 때 &lt;code&gt;DefaultAgentConfig&lt;/code&gt; 인수 가 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69004e83d19b67fea82f2e443fe9acacd301728c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Extra&lt;/code&gt; is just an opaque data structure passed to the user via the callback functions in the &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt;. Note however that if &lt;code&gt;Extra&lt;/code&gt; has the value &lt;code&gt;extra_undefined&lt;/code&gt; the argument will be ignored (same as if &lt;code&gt;process_received_message/4&lt;/code&gt; had been called). See the documentation for the behaviour of the callback module, &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt;, for more info.</source>
          <target state="translated">&lt;code&gt;Extra&lt;/code&gt; 인수 는 &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;user callback module&lt;/a&gt;&lt;/code&gt; 의 콜백 함수를 통해 사용자에게 전달되는 불투명 한 데이터 구조 입니다. 그러나 &lt;code&gt;Extra&lt;/code&gt; 에 &lt;code&gt;extra_undefined&lt;/code&gt; 값이 있으면 인수는 무시됩니다 ( &lt;code&gt;process_received_message/4&lt;/code&gt; 가 호출 된 것과 동일 ). 자세한 내용은 콜백 모듈 &lt;code&gt;&lt;a href=&quot;megaco_user&quot;&gt;megaco_user&lt;/a&gt;&lt;/code&gt; 의 동작에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f459c21deb16ca0d8a2238ea1bb013af1aa40900" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to read for future connections.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; 인수 는 원래 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 콜백 에서 전달 된 핸들 입니다. 인수 &lt;code&gt;Opts&lt;/code&gt; 는 향후 연결을 위해 읽을 수있는 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="debf3f82b456b10623118b0f8614068c9ab5fae7" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Listen&lt;/code&gt; is the handle originally passed from the &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; callback. The argument &lt;code&gt;Opts&lt;/code&gt; is a list of options to set on future connections.</source>
          <target state="translated">&lt;code&gt;Listen&lt;/code&gt; 인수 는 원래 &lt;code&gt;&lt;a href=&quot;#listen&quot;&gt;listen/1&lt;/a&gt;&lt;/code&gt; 콜백 에서 전달 된 핸들 입니다. 인수 &lt;code&gt;Opts&lt;/code&gt; 는 향후 연결에서 설정할 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6f649282c95c4ff27efd3a1061e1c2bdcdf508eb" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;Opaque&lt;/code&gt; is forwarded to the backup module. It returns &lt;code&gt;{atomic, TabList}&lt;/code&gt; if successful, or the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt; if there is an error. &lt;code&gt;TabList&lt;/code&gt; is a list of the restored tables. Tables that are restored are write-locked during the restore operation. However, regardless of any lock conflict caused by this, applications can continue to do their work during the restore operation.</source>
          <target state="translated">&lt;code&gt;Opaque&lt;/code&gt; 인수 는 백업 모듈로 전달됩니다. 성공하면 &lt;code&gt;{atomic, TabList}&lt;/code&gt; 를, 오류가 있으면 튜플 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 리턴합니다 . &lt;code&gt;TabList&lt;/code&gt; 는 복원 된 테이블의 목록입니다. 복원 된 테이블은 복원 작업 중에 쓰기 잠금 상태입니다. 그러나 이로 인한 잠금 충돌에 관계없이 응용 프로그램은 복원 조작 중에 계속 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfff5e2db73b8f539cd9908f48d194bda191ddfc" translate="yes" xml:space="preserve">
          <source>The argument can also be a list of modules or filenames, in which case the function tries to interpret each module as specified earlier. The function then always returns &lt;code&gt;ok&lt;/code&gt;, but prints some information to &lt;code&gt;stdout&lt;/code&gt; if a module cannot be interpreted.</source>
          <target state="translated">인수는 모듈 또는 파일 이름 목록 일 수도 있습니다.이 경우 함수는 이전에 지정된대로 각 모듈을 해석하려고합니다. 그런 다음이 함수는 항상 &lt;code&gt;ok&lt;/code&gt; 를 반환 하지만 모듈을 해석 할 수없는 경우 일부 정보를 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="f72a488906a1bc4231e746b4ff7b4a8e45eb6fc3" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt;, where the precision is the number of digits written. The default precision is 6 and it cannot be &amp;lt; 2.</source>
          <target state="translated">인수는 &lt;code&gt;[-]d.ddde+-ddd&lt;/code&gt; 로 작성된 부동 소수점입니다 . 여기서 정밀도는 기록 된 자릿수입니다. 기본 정밀도는 6이며 &amp;lt;2는 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="93d3f166ed7f071a0cf8c5e27837f3a0c6681247" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;[-]ddd.ddd&lt;/code&gt;, where the precision is the number of digits after the decimal point. The default precision is 6 and it cannot be &amp;lt; 1.</source>
          <target state="translated">인수는 &lt;code&gt;[-]ddd.ddd&lt;/code&gt; 로 작성된 부동 소수점입니다 . 여기서 정밀도는 소수점 뒤의 자릿수입니다. 기본 정밀도는 6이며 &amp;lt;1 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="049df39b974433b181b76b3894315e239a3ad777" translate="yes" xml:space="preserve">
          <source>The argument is a float that is written as &lt;code&gt;f&lt;/code&gt;, if it is &amp;gt;= 0.1 and &amp;lt; 10000.0. Otherwise, it is written in the &lt;code&gt;e&lt;/code&gt; format. The precision is the number of significant digits. It defaults to 6 and is not to be &amp;lt; 2. If the absolute value of the float does not allow it to be written in the &lt;code&gt;f&lt;/code&gt; format with the desired number of significant digits, it is also written in the &lt;code&gt;e&lt;/code&gt; format.</source>
          <target state="translated">인수는 &amp;gt; = 0.1이고 &amp;lt;10000.0 인 경우 &lt;code&gt;f&lt;/code&gt; 로 작성된 부동 소수점입니다 . 그렇지 않으면 &lt;code&gt;e&lt;/code&gt; 형식으로 작성 됩니다. 정밀도는 유효 자릿수입니다. 기본값은 6이며 &amp;lt;2는 아닙니다. float의 절대 값으로 원하는 수의 유효 자릿수 를 사용하여 &lt;code&gt;f&lt;/code&gt; 형식으로 쓸 수없는 경우 &lt;code&gt;e&lt;/code&gt; 형식으로도 씁니다.</target>
        </trans-unit>
        <trans-unit id="fd2ce2991cd1ed1c5544565d4bc9f56a7a9da522" translate="yes" xml:space="preserve">
          <source>The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example:</source>
          <target state="translated">인수는 ASCII 코드로 해석되는 숫자입니다. 정밀도는 문자가 인쇄되는 횟수이며 기본값은 필드 너비이며 기본값은 1입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="41417c1b36d7d073dd070139b59528225284b877" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;init_per_suite&lt;/code&gt; is &lt;code&gt;Config&lt;/code&gt;, that is, the same key-value list of runtime configuration data that each test case takes as input argument. &lt;code&gt;init_per_suite&lt;/code&gt; can modify this parameter with information that the test cases need. The possibly modified &lt;code&gt;Config&lt;/code&gt; list is the return value of the function.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; 의 인수 는 &lt;code&gt;Config&lt;/code&gt; 입니다 . 즉, 각 테스트 케이스가 입력 인수로 취하는 동일한 런타임 구성 데이터의 키-값 목록입니다. &lt;code&gt;init_per_suite&lt;/code&gt; 는 테스트 케이스에 필요한 정보로이 매개 변수를 수정할 수 있습니다. 수정 가능한 &lt;code&gt;Config&lt;/code&gt; 목록은 함수의 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="19116289e2a06f46f52b99e7a354d07e181d8263" translate="yes" xml:space="preserve">
          <source>The argument type change is from signed to unsigned. This can cause problems for, for example, loop termination conditions or error conditions if you only change the types all over the place.</source>
          <target state="translated">인수 유형 변경은 부호에서 부호없는 것으로 변경됩니다. 예를 들어, 장소 전체에서 유형 만 변경하면 루프 종료 조건이나 오류 조건에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518f1110847b76edf7686b0d43ca29a942986a62" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;{local, error_man}&lt;/code&gt; specifies the name. The event manager is then locally registered as &lt;code&gt;error_man&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{local, error_man}&lt;/code&gt; 인수 는 이름을 지정합니다. 그런 다음 이벤트 관리자는 로컬로 &lt;code&gt;error_man&lt;/code&gt; 으로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="0afbf43c606253c8ecf1c39998b54bbb8fa67440" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;FormatArgs&lt;/code&gt; in &lt;code&gt;ct:log/print/pal&lt;/code&gt; are always passed on to the STDLIB function &lt;code&gt;io:format/3&lt;/code&gt; (For details, see the &lt;code&gt;io&lt;/code&gt; manual page).</source>
          <target state="translated">인수의 &lt;code&gt;Format&lt;/code&gt; 과 &lt;code&gt;FormatArgs&lt;/code&gt; 에서 &lt;code&gt;ct:log/print/pal&lt;/code&gt; 항상 STDLIB 함수에 전달되는 &lt;code&gt;io:format/3&lt;/code&gt; (자세한 내용은 참조 &lt;code&gt;io&lt;/code&gt; 매뉴얼 페이지를).</target>
        </trans-unit>
        <trans-unit id="ad2c02ade68b15ea95b904a33d006adc1b1cf304" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SnmpInfo&lt;/code&gt; relates in the following way:</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 및 &lt;code&gt;SnmpInfo&lt;/code&gt; 인수 는 다음과 같은 방식으로 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="c80eb8b8ff0c248539e0d4f345648274f59f93c8" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt; filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="translated">인수는 실행 파일에 제공되기 전에 쉘에 의해 확장되지 않습니다. 특히 이것은 파일 와일드 카드 확장이 발생하지 않음을 의미합니다. 인수에 대한 와일드 카드를 확장하려면 &lt;code&gt; filelib:wildcard/1&lt;/code&gt; 을 사용하십시오 . 프로그램이 Unix 셸 스크립트 (즉, 셸이 궁극적으로 호출됨을 의미) 인 경우에도 와일드 카드 확장이 발생하지 않으며 스크립트에 변경되지 않은 인수가 제공됩니다. Windows에서 와일드 카드 확장은 항상 프로그램 자체에 달려 있으므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b287b1ceba326e901144e95b8db2f9f2999be1d" translate="yes" xml:space="preserve">
          <source>The arguments are not expanded by the shell before they are supplied to the executable. Most notably this means that file wildcard expansion does not occur. To expand wildcards for the arguments, use &lt;code&gt;filelib:wildcard/1&lt;/code&gt;. Notice that even if the program is a Unix shell script, meaning that the shell ultimately is invoked, wildcard expansion does not occur, and the script is provided with the untouched arguments. On Windows, wildcard expansion is always up to the program itself, therefore this is not an issue.</source>
          <target state="translated">인수는 실행 파일에 제공되기 전에 쉘에 의해 확장되지 않습니다. 특히 이것은 파일 와일드 카드 확장이 발생하지 않음을 의미합니다. 인수의 와일드 카드를 확장하려면 &lt;code&gt;filelib:wildcard/1&lt;/code&gt; 을 사용하십시오 . 프로그램이 Unix 쉘 스크립트 인 경우에도 쉘이 궁극적으로 호출되고 와일드 카드 확장이 발생하지 않으며 스크립트는 수정되지 않은 인수와 함께 제공됩니다. Windows에서 와일드 카드 확장은 항상 프로그램 자체에 달려 있으므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="522ee4260f97c142662210e82bcb713e534c2aad" translate="yes" xml:space="preserve">
          <source>The arguments can be divided into &lt;strong&gt;emulator flags&lt;/strong&gt;, &lt;strong&gt;flags&lt;/strong&gt;, and &lt;strong&gt;plain arguments&lt;/strong&gt;:</source>
          <target state="translated">인수는 &lt;strong&gt;에뮬레이터 플래그&lt;/strong&gt; , &lt;strong&gt;플래그&lt;/strong&gt; 및 &lt;strong&gt;일반 인수&lt;/strong&gt; 로 나눌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6ed9ef38109b234ba45603e287f33458c0a6ac4" translate="yes" xml:space="preserve">
          <source>The arguments can be of different data types. The following order is defined:</source>
          <target state="translated">인수는 다른 데이터 유형이 될 수 있습니다. 다음 순서가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c8d0f8904d643db2998fe9360557663dfc7593df" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;system_monitor/2&lt;/code&gt; specifies how all system monitoring on the node should be done, not how it should be changed. This means only one process at a time (&lt;code&gt;MonitorPid&lt;/code&gt;) can be the receiver of system monitor messages. Also, the way to clear a specific monitor option is to not include it in the list &lt;code&gt;Options&lt;/code&gt;. All system monitoring will, however, be cleared if the process identified by &lt;code&gt;MonitorPid&lt;/code&gt; terminates.</source>
          <target state="translated">&lt;code&gt;system_monitor/2&lt;/code&gt; 에 대한 인수 는 노드의 모든 시스템 모니터링이 변경되어야하는 방법이 아니라 수행되어야하는 방법을 지정합니다. 이것은 한 번에 하나의 프로세스 ( &lt;code&gt;MonitorPid&lt;/code&gt; ) 만 시스템 모니터 메시지의 수신자가 될 수 있음을 의미합니다. 또한 특정 모니터 옵션을 지우는 방법은 &lt;code&gt;Options&lt;/code&gt; 목록에 포함하지 않는 것입니다 . 그러나 &lt;code&gt;MonitorPid&lt;/code&gt; 로 식별 된 프로세스가 종료 되면 모든 시스템 모니터링이 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="ffa892e870535324db1c0ec38851cc864f132069" translate="yes" xml:space="preserve">
          <source>The arguments:</source>
          <target state="translated">인수 :</target>
        </trans-unit>
        <trans-unit id="a8a87576167815553ae803598fc43fec00d99fc0" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) for the current function.</source>
          <target state="translated">현재 함수의 arity (인수).</target>
        </trans-unit>
        <trans-unit id="f4a92fd68167fdb3dffdde93bfe14f1434196818" translate="yes" xml:space="preserve">
          <source>The arity of the function implementing the fun.</source>
          <target state="translated">재미를 구현하는 기능의 arity.</target>
        </trans-unit>
        <trans-unit id="2e0c7ead6f817b15595de5c93baf2426dbf01b86" translate="yes" xml:space="preserve">
          <source>The arity of the function must match the number of arguments, else a compilation error occurs.</source>
          <target state="translated">함수의 arity는 인수의 수와 일치해야합니다. 그렇지 않으면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a567fbfc0f0119591979c89645ce71555342bc2e" translate="yes" xml:space="preserve">
          <source>The array length, that is, the function arity. &lt;code&gt;argv[N-1]&lt;/code&gt; thus denotes the Nth argument to the NIF. Notice that the argument &lt;code&gt;argc&lt;/code&gt; allows for the same C function to implement several Erlang functions with different arity (but probably with the same name).</source>
          <target state="translated">배열 길이, 즉 함수 arity &lt;code&gt;argv[N-1]&lt;/code&gt; 은 NIF에 대한 N 번째 인수를 나타냅니다. 인수 &lt;code&gt;argc&lt;/code&gt; 를 사용하면 동일한 C 함수가 다른 arity (그러나 아마도 이름이 같은)를 가진 여러 Erlang 함수를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="415f03b07c8ba3c8c05edaadd6e77c05a2cd0868" translate="yes" xml:space="preserve">
          <source>The array never shrinks automatically. If an index &lt;code&gt;I&lt;/code&gt; has been used to set an entry successfully, all indices in the range [0,&lt;code&gt;I&lt;/code&gt;] stay accessible unless the array size is explicitly changed by calling &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열은 자동으로 축소되지 않습니다. 인덱스 &lt;code&gt;I&lt;/code&gt; 을 사용하여 항목을 성공적으로 설정 한 경우 &lt;code&gt;&lt;a href=&quot;#resize-2&quot;&gt;resize/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 배열 크기를 명시 적으로 변경하지 않으면 [0, &lt;code&gt;I&lt;/code&gt; ] 범위의 모든 인덱스에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41821fc2a208b561d81f20833df1e2cf397cd22d" translate="yes" xml:space="preserve">
          <source>The associated code contains &lt;code&gt;pseudo variables&lt;/code&gt;&lt;code&gt;'$1'&lt;/code&gt;, &lt;code&gt;'$2'&lt;/code&gt;, &lt;code&gt;'$3'&lt;/code&gt;, etc. which refer to (are bound to) the values associated previously by the parser with the symbols of the right hand side of the rule. When these symbols are terminal categories, the values are token tuples of the input string (see above).</source>
          <target state="translated">연관된 코드에는 &lt;code&gt;pseudo variables&lt;/code&gt; &lt;code&gt;'$1'&lt;/code&gt; , &lt;code&gt;'$2'&lt;/code&gt; , &lt;code&gt;'$3'&lt;/code&gt; 등이 포함되며, 이는 규칙의 오른쪽 기호로 구문 분석기가 이전에 연관시킨 값을 참조합니다. 이러한 기호가 터미널 범주 인 경우 값은 입력 문자열의 토큰 튜플입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="3898cfb8a11a62ffe2fdba8be9357512d68bb196" translate="yes" xml:space="preserve">
          <source>The associated code may not only be used to build structures associated with phrases, but may also be used for syntactic and semantic tests, printout actions (for example for tracing), etc. during the parsing process. Since tokens contain positional (line number) information, it is possible to produce error messages which contain line numbers. If there is no associated code after the right hand side of the rule, the value &lt;code&gt;'$undefined'&lt;/code&gt; is associated with the phrase.</source>
          <target state="translated">연관된 코드는 구문과 연관된 구조를 빌드하는 데 사용될뿐만 아니라 구문 분석 프로세스 동안 구문 및 의미 론적 테스트, 인쇄 조치 (예 : 추적) 등에도 사용될 수 있습니다. 토큰은 위치 (행 번호) 정보를 포함하므로 행 번호를 포함하는 오류 메시지를 생성 할 수 있습니다. 규칙의 오른쪽 뒤에 연결된 코드가 없으면 &lt;code&gt;'$undefined'&lt;/code&gt; 값 이 문구와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="3ece07e37195ede709e7f03b9006e9af2c0f25d9" translate="yes" xml:space="preserve">
          <source>The association between carrier pool and allocator is very loose. The associations are more or less only there to get names for the amount of carrier pools needed and names of carrier pools that can be easily identified by the &lt;code&gt;:&lt;/code&gt; value.</source>
          <target state="translated">캐리어 풀과 할당 자 간의 연결이 매우 느슨합니다. 연결은 필요한 캐리어 풀의 양에 대한 이름과 &lt;code&gt;:&lt;/code&gt; 값 으로 쉽게 식별 할 수있는 캐리어 풀의 이름을 가져 오기 위해 어느 정도 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="6b6e33dc105b7762f1d530b48ab29c546fd13258" translate="yes" xml:space="preserve">
          <source>The association cannot be established (&lt;code&gt;connect/*&lt;/code&gt; failure).</source>
          <target state="translated">연결을 설정할 수 없습니다 ( &lt;code&gt;connect/*&lt;/code&gt; failure).</target>
        </trans-unit>
        <trans-unit id="ef9716ac7174f55cae16eacb1845e6a71402ef24" translate="yes" xml:space="preserve">
          <source>The association file &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; for the real implementation looks as follows:</source>
          <target state="translated">실제 구현을위한 연관 파일 &lt;code&gt;EX1-MIB.funcs&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81d1ef649b0dc2cac7a3f4619510067970a6fd77" translate="yes" xml:space="preserve">
          <source>The association file, which contains the names of instrumentation functions for the MIB, should have the suffix &lt;code&gt;.funcs&lt;/code&gt;. If the compiler does not find the association file, it gives a warning message and uses default instrumentation functions. (See &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; for more details).</source>
          <target state="translated">MIB의 인스 트루먼 테이션 함수 이름이 포함 된 연관 파일은 접미 부 &lt;code&gt;.funcs&lt;/code&gt; 를 가져야 합니다. 컴파일러가 연결 파일을 찾지 못하면 경고 메시지가 표시되고 기본 계측 기능을 사용합니다. (자세한 내용은 &lt;code&gt;&lt;a href=&quot;snmp_instr_functions#snmp_3&quot;&gt;Default Instrumentation&lt;/a&gt;&lt;/code&gt; 을 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="9e61865049f08d1e62a4b88bd1b23185c90eb9da" translate="yes" xml:space="preserve">
          <source>The asymetric encryption algorithm used in the server's private-public host key pair. Examples include the well-known RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; and elliptic curve &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt;.</source>
          <target state="translated">서버의 개인-공용 호스트 키 쌍에서 사용되는 비대칭 암호화 알고리즘. 그 예로는 잘 알려진 RSA &lt;code&gt;'ssh-rsa'&lt;/code&gt; 와 타원 곡선 &lt;code&gt;'ecdsa-sha2-nistp521'&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e53d0f60e0c53dc5f649aa03a42efcad9929a69" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비동기 스레드 풀의 크기는 명령 줄 인수로 설정 될 수 &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; . 비동기 스레드 풀을 사용할 수없는 경우 &lt;code&gt;driver_async&lt;/code&gt; 를 호출하는 스레드에서 동 기적으로 호출이 이루어집니다 . 비동기 스레드 풀의 현재 비동기 스레드 수는 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt; 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00b06000d023218a0553695852ada6423beef957" translate="yes" xml:space="preserve">
          <source>The async thread pool size can be set with command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;. If an async thread pool is unavailable, the call is made synchronously in the thread calling &lt;code&gt;driver_async&lt;/code&gt;. The current number of async threads in the async thread pool can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비동기 스레드 풀 크기는 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 에서 명령 행 인수 &lt;code&gt;&lt;a href=&quot;erl#async_thread_pool_size&quot;&gt;+A&lt;/a&gt;&lt;/code&gt; 를 사용 하여 설정할 수 있습니다 . 비동기 스레드 풀을 사용할 수없는 경우 &lt;code&gt;driver_async&lt;/code&gt; 를 호출하는 스레드에서 동 기적으로 호출 됩니다. 비동기 스레드 풀의 현재 비동기 스레드 수는 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d949b17e0550064c4ba8e06402f035e12b3129f" translate="yes" xml:space="preserve">
          <source>The asynchronous API for drivers is complicated. First, the work must be prepared. In the example, this is done in &lt;code&gt;output&lt;/code&gt;. We could have used &lt;code&gt;control&lt;/code&gt;, but we want some variation in the examples. In our driver, we allocate a structure that contains anything that is needed for the asynchronous task to do the work. This is done in the main emulator thread. Then the asynchronous function is called from a driver thread, separate from the main emulator thread. Notice that the driver functions are not re-entrant, so they are not to be used. Finally, after the function is completed, the driver callback &lt;code&gt;ready_async&lt;/code&gt; is called from the main emulator thread, this is where we return the result to Erlang. (We cannot return the result from within the asynchronous function, as we cannot call the driver functions.)</source>
          <target state="translated">드라이버의 비동기 API는 복잡합니다. 먼저 작업을 준비해야합니다. 이 예에서는 &lt;code&gt;output&lt;/code&gt; 에서 수행됩니다 . 우리는 &lt;code&gt;control&lt;/code&gt; 을 사용할 수 있었지만 예제에서 약간의 변형을 원합니다. 드라이버에서 비동기 작업이 작업을 수행하는 데 필요한 모든 것을 포함하는 구조를 할당합니다. 이것은 메인 에뮬레이터 스레드에서 수행됩니다. 그런 다음 비동기 함수는 기본 에뮬레이터 스레드와 별도로 드라이버 스레드에서 호출됩니다. 드라이버 기능은 다시 입력 할 수 없으므로 사용하지 마십시오. 마지막으로 함수가 완료된 후 드라이버 콜백 &lt;code&gt;ready_async&lt;/code&gt; 메인 에뮬레이터 스레드에서 호출되며, 여기서 결과를 Erlang으로 반환합니다. 드라이버 함수를 호출 할 수 없으므로 비동기 함수 내에서 결과를 반환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb8f8a1d61eec151d7bbdbad482f3278e892dcab" translate="yes" xml:space="preserve">
          <source>The asynchronous request &lt;code&gt;free(Ch)&lt;/code&gt; is implemented using &lt;code&gt;gen_server:cast/2&lt;/code&gt;:</source>
          <target state="translated">비동기 요청 &lt;code&gt;free(Ch)&lt;/code&gt; 는 &lt;code&gt;gen_server:cast/2&lt;/code&gt; 를 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="13cb8db4869505cfe3b89f4b66cbde4b8e730e2a" translate="yes" xml:space="preserve">
          <source>The asynchronous version of the driver is in the sample files &lt;code&gt;pg_async.c&lt;/code&gt; and &lt;code&gt;pg_asyng.erl&lt;/code&gt;.</source>
          <target state="translated">드라이버의 비동기 버전은 샘플 파일 &lt;code&gt;pg_async.c&lt;/code&gt; 및 &lt;code&gt;pg_asyng.erl&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ad31c862f53147c29592fd7356527c9ffced30" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Behaviour&lt;/code&gt; gives the name of the behaviour, which can be a user-defined behaviour or one of the following OTP standard behaviours:</source>
          <target state="translated">Atom &lt;code&gt;Behaviour&lt;/code&gt; 는 사용자 정의 동작 또는 다음 OTP 표준 동작 중 하나 일 수있는 동작의 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b6c48f50dc1798aeaec7a743fffe7be10b28e3a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;Name&lt;/code&gt; is the table name. The table name must be provided in all subsequent operations on the table. The name can be used by other processes as well, and many processes can share one table.</source>
          <target state="translated">아톰 &lt;code&gt;Name&lt;/code&gt; 은 테이블 이름입니다. 테이블의 모든 후속 작업에서 테이블 이름을 제공해야합니다. 이름은 다른 프로세스에서도 사용할 수 있으며 많은 프로세스가 하나의 테이블을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c510ba5b1215726673e2f72d3059e72c9e136b36" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;activity&lt;/code&gt;</source>
          <target state="translated">원자 &lt;code&gt;activity&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9710032c39f79ee3070e26173f96829389498bd7" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;finished&lt;/code&gt; is sent to &quot;pong&quot; (causing it to terminate as described above) and &quot;ping finished&quot; is written to the output. &quot;Ping&quot; then terminates as it has nothing left to do.</source>
          <target state="translated">&lt;code&gt;finished&lt;/code&gt; 원자 는 &quot;퐁&quot;으로 보내지고 (위에서 설명한대로 종료 됨) &quot;핑 완료&quot;가 출력에 기록됩니다. &quot;Ping&quot;은 남은 작업이 없기 때문에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d82cb2c455d0963906d4919213af14bc97a0dc7e" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;hibernate&lt;/code&gt; in the action list on the last line when entering the &lt;code&gt;{open,_}&lt;/code&gt; state is the only change. If any event arrives in the &lt;code&gt;{open,_},&lt;/code&gt; state, we do not bother to rehibernate, so the server stays awake after any event.</source>
          <target state="translated">원자 &lt;code&gt;hibernate&lt;/code&gt; 유입 마지막 행의 작업리스트 &lt;code&gt;{open,_}&lt;/code&gt; 상태는 단지 변화이다. 어떤 이벤트가 &lt;code&gt;{open,_},&lt;/code&gt; 상태에 도달하면 , 우리는 재개를 귀찮게하지 않으므로 서버는 이벤트 후에 깨어 있습니다.</target>
        </trans-unit>
        <trans-unit id="356f9715c2aad0ed355593e69081e1f8b8476d8f" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending&lt;/code&gt;, which means that a monitor is to be created whenever a load operation is delayed,</source>
          <target state="translated">atom &lt;code&gt;pending&lt;/code&gt; 은로드 조작이 지연 될 때마다 모니터가 작성됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="161e6641a902cec6d4ca9159bb2b569a7ff90c0a" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;pending_driver&lt;/code&gt;, in which a monitor is created whenever the operation is delayed because of open ports to an otherwise unused driver.</source>
          <target state="translated">atom &lt;code&gt;pending_driver&lt;/code&gt; . 사용되지 않는 드라이버에 대한 열린 포트로 인해 조작이 지연 될 때마다 모니터가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d60a51c643f2a02e17349df9085c521ad7bd0aa" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;system&lt;/code&gt;</source>
          <target state="translated">원자 &lt;code&gt;system&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42969bfd0b03becb2a706b91287d2fd18b7a8038" translate="yes" xml:space="preserve">
          <source>The atom &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">원자 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c920e9113121f0b04e27b3e131485fc54743c" translate="yes" xml:space="preserve">
          <source>The atomicity and the isolation properties of &lt;code&gt;Mnesia&lt;/code&gt; are lost.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 원자 성과 분리 특성 이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8c1bd67e98ea142e16fbd8328c31a4abe8ce1c" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;big&lt;/code&gt; and &lt;code&gt;little&lt;/code&gt; denote big- or little-endian encoding.</source>
          <target state="translated">원자 &lt;code&gt;big&lt;/code&gt; 및 &lt;code&gt;little&lt;/code&gt; 나타낸다 BIG-또는 리틀 엔디안 인코딩.</target>
        </trans-unit>
        <trans-unit id="eec0aca30bfb32af191c5b7f63bda050342a54ff" translate="yes" xml:space="preserve">
          <source>The atoms &lt;code&gt;send&lt;/code&gt;, &lt;code&gt;'receive'&lt;/code&gt;, and &lt;code&gt;timeout&lt;/code&gt; for sends and receives (&lt;code&gt;'receive'&lt;/code&gt; when a message is received and &lt;code&gt;timeout&lt;/code&gt; when a receive times out)</source>
          <target state="translated">원자들은 &lt;code&gt;send&lt;/code&gt; , &lt;code&gt;'receive'&lt;/code&gt; , 및 &lt;code&gt;timeout&lt;/code&gt; 에 대한 송신하고 (수신 &lt;code&gt;'receive'&lt;/code&gt; 메시지가 수신 될 때 &lt;code&gt;timeout&lt;/code&gt; A가 시간을 수신 할 때)</target>
        </trans-unit>
        <trans-unit id="d6808e92018a30d64fa086f0dfa84d2f8448d1ef" translate="yes" xml:space="preserve">
          <source>The attribute OID name atoms and their corresponding value types are as follows:</source>
          <target state="translated">속성 OID 이름 원자 및 해당 값 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f3b18eb4341c86b8c0684826dff3c42219fcc2" translate="yes" xml:space="preserve">
          <source>The author can choose to put many or few tests into each test case. Some things to keep in mind follows:</source>
          <target state="translated">작성자는 각 테스트 사례에 여러 테스트를 수행하도록 선택할 수 있습니다. 명심해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="badc70f1a60a87b4c3438b8a7de6f4c78b5a65bc" translate="yes" xml:space="preserve">
          <source>The auto save interval. The table is flushed to disk whenever not accessed for this amount of time.</source>
          <target state="translated">자동 저장 간격. 이 시간 동안 테이블에 액세스하지 않으면 테이블이 디스크로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="c039d5fb00e0ef90ed0ae37b0f2d061a360a486a" translate="yes" xml:space="preserve">
          <source>The autostart feature requires more data to be stored on traced nodes. By default, the data is stored automatically to the file named &quot;ttb_autostart.bin&quot; in the currect working directory (cwd) of the traced node. Users can change this behaviour (that is, on diskless nodes) by specifying their own module to handle autostart data storage and retrieval (&lt;code&gt;ttb_autostart_module&lt;/code&gt; environment variable of &lt;code&gt;runtime_tools&lt;/code&gt;). For information about the API, see module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;. The following example shows the default handler:</source>
          <target state="translated">자동 시작 기능을 사용하려면 추적 된 노드에 더 많은 데이터를 저장해야합니다. 기본적으로 데이터는 추적 된 노드의 정확한 작업 디렉토리 (cwd)에있는 &quot;ttb_autostart.bin&quot;파일에 자동으로 저장됩니다. 사용자는 자동 시작 데이터 저장 및 검색을 처리하기 위해 자체 모듈을 지정하여 (디스크가없는 노드에서)이 동작을 변경할 수 있습니다 ( &lt;code&gt;runtime_tools&lt;/code&gt; 의 &lt;code&gt;ttb_autostart_module&lt;/code&gt; 환경 변수 ). API에 대한 정보는 모듈 &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 다음 예제는 기본 핸들러를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ec0674516ee9bb18698545632ddcef7eb77a1e62" translate="yes" xml:space="preserve">
          <source>The available OID names are as follows:</source>
          <target state="translated">사용 가능한 OID 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="270053ab9a2cdd71b431ca1b29230d0131168ac8" translate="yes" xml:space="preserve">
          <source>The available configuration options are as follows:</source>
          <target state="translated">사용 가능한 구성 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ffd517ca47007c093bb8a7cefdb756ebfdced63" translate="yes" xml:space="preserve">
          <source>The available configuration properties are as follows:</source>
          <target state="translated">사용 가능한 구성 특성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d5fbe85b0c98fe746cb7e16c8187e2dfc18521e" translate="yes" xml:space="preserve">
          <source>The average run-time for the schedulers. This is the average amount of time the schedulers did not sleep.</source>
          <target state="translated">스케줄러의 평균 런타임 스케줄러가 휴면하지 않은 평균 시간입니다.</target>
        </trans-unit>
        <trans-unit id="aaf853276797e4d431ffd98c86f3b72f5161ab87" translate="yes" xml:space="preserve">
          <source>The average time spent collecting data in the threads. This should be close to the time which data was collected.</source>
          <target state="translated">스레드에서 데이터를 수집하는 데 소요 된 평균 시간입니다. 이것은 데이터가 수집 된 시간에 근접해야합니다.</target>
        </trans-unit>
        <trans-unit id="70cab81b62df4bb768ae5b9f87b1769a35f91166" translate="yes" xml:space="preserve">
          <source>The backslash character has many uses. First, if it is followed by a character that is not a number or a letter, it takes away any special meaning that a character can have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">백 슬래시 문자는 여러 용도로 사용됩니다. 첫째, 숫자 나 문자가 아닌 문자가 뒤에 오는 경우 문자가 가질 수있는 특별한 의미를 제거합니다. 이스케이프 문자로 백 슬래시를 사용하면 내부 및 외부 문자 클래스에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbe5fe5807b426b9440606cd7c73c539d1bcdeff" translate="yes" xml:space="preserve">
          <source>The backup data is divided into two sections. The first section contains information related to the schema. All schema-related items are tuples where the first field equals the atom schema. The second section is the record section. Schema records cannot be mixed with other records and all schema records must be located first in the backup.</source>
          <target state="translated">백업 데이터는 두 섹션으로 나뉩니다. 첫 번째 섹션에는 스키마와 관련된 정보가 포함되어 있습니다. 모든 스키마 관련 항목은 첫 번째 필드가 원자 스키마와 동일한 튜플입니다. 두 번째 섹션은 레코드 섹션입니다. 스키마 레코드는 다른 레코드와 혼합 할 수 없으며 백업에서 모든 스키마 레코드를 먼저 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="5cb61dbbe8949ce8224db389cdf36c3f301c26b1" translate="yes" xml:space="preserve">
          <source>The base AVPs are defined in the common dictionary provided by diameter. There are common dictionaries for both RFC 3588 and RFC 6733 since the latter made changes to both syntax and semantics.</source>
          <target state="translated">기본 AVP는 직경으로 제공되는 공통 사전에 정의되어 있습니다. RFC 3588과 RFC 6733에 대한 공통 사전이 있는데, 후자는 구문과 의미를 모두 변경했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="37b6dd9b192c11e194c06eb99987679081a97762" translate="yes" xml:space="preserve">
          <source>The base name of the compiled file</source>
          <target state="translated">컴파일 된 파일의 기본 이름</target>
        </trans-unit>
        <trans-unit id="d6fbdeb4864f0e11b719e81c27b780c593542153" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt; deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">창 크기의 밑이 2 인 로그 (히스토리 버퍼의 크기). 8에서 15까지의 범위에 있어야합니다. 값이 클수록 메모리 사용량이 줄어드는 대신 압축률이 높아집니다. &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt; deflateInit/2&lt;/a&gt;&lt;/code&gt; 를 사용하는 경우 기본값은 15 입니다. 음의 &lt;code&gt;WindowBits&lt;/code&gt; 값은 스트림에서 zlib 헤더 (및 체크섬)를 억제합니다. zlib 소스는 이것을 문서화되지 않은 기능으로 만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="13db919a8612a7a4080781ff054af866565ed391" translate="yes" xml:space="preserve">
          <source>The base two logarithm of the window size (the size of the history buffer). It is to be in the range 8 through 15. Larger values result in better compression at the expense of memory usage. Defaults to 15 if &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; is used. A negative &lt;code&gt;WindowBits&lt;/code&gt; value suppresses the zlib header (and checksum) from the stream. Notice that the zlib source mentions this only as a undocumented feature.</source>
          <target state="translated">윈도우 크기의 기본 2 로그 (이력 버퍼 크기). 값은 8에서 15 사이 여야합니다. 값이 클수록 메모리 사용량을 희생하여 압축 성능이 향상됩니다. &lt;code&gt;&lt;a href=&quot;#deflateInit-2&quot;&gt;deflateInit/2&lt;/a&gt;&lt;/code&gt; 가 사용되는 경우 기본값은 15 입니다. 음수의 &lt;code&gt;WindowBits&lt;/code&gt; 값은 스트림에서 zlib 헤더 및 체크섬을 억제합니다. zlib 소스는이를 문서화되지 않은 기능으로 만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="8818564f19c5c56bd354986044623c1ba1d3d72f" translate="yes" xml:space="preserve">
          <source>The basic concept is that of a &lt;strong&gt;MIB view&lt;/strong&gt;. An MIB view is a subset of all the objects implemented by an agent. A manager has access to a certain MIB view, depending on which security parameters are used, in which context the request is made, and which type of request is made.</source>
          <target state="translated">기본 개념은 &lt;strong&gt;MIB보기&lt;/strong&gt; 의 개념입니다 . MIB보기는 에이전트가 구현 한 모든 개체의 하위 집합입니다. 관리자는 사용되는 보안 매개 변수, 요청 된 컨텍스트 및 요청 유형에 따라 특정 MIB보기에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4956ca9b4e8f3cd207abf9624e243d3cdb794f4d" translate="yes" xml:space="preserve">
          <source>The basic idea of syntax highlighting is to make the structure of a program clearer. For example, the highlighting will make it easier to spot simple bugs. Have not you ever written a variable in lower-case only? With syntax highlighting a variable will colored while atoms will be shown with the normal text color.</source>
          <target state="translated">구문 강조의 기본 개념은 프로그램의 구조를 더 명확하게하는 것입니다. 예를 들어, 강조 표시를 사용하면 간단한 버그를 쉽게 찾을 수 있습니다. 소문자로만 변수를 쓰지 않았습니까? 구문 강조 표시를 사용하면 변수에 색상이 표시되고 원자는 일반 텍스트 색상으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad538ab434ab340ba09c1c90fc3a4a6dea30af6" translate="yes" xml:space="preserve">
          <source>The basic idea with exclusive decode is to specify which parts of the message you want to exclude from being decoded. These parts remain encoded and are returned in the value structure as binaries. They can be decoded in turn by passing them to a certain &lt;code&gt;decode_part/2&lt;/code&gt; function. The performance gain is high for large messages. You can do an exclusive decode and later one or more decodes of the parts, or a second complete decode instead of two or more complete decodes.</source>
          <target state="translated">독점적 인 디코딩의 기본 아이디어는 디코딩 할 메시지에서 제외 할 메시지 부분을 지정하는 것입니다. 이러한 부분은 인코딩 된 상태로 유지되며 값 구조에서 이진으로 반환됩니다. 그것들은 그것들을 특정한 &lt;code&gt;decode_part/2&lt;/code&gt; 함수 에 전달함으로써 차례로 해독 될 수 있습니다 . 큰 메시지의 경우 성능이 향상됩니다. 배타적 디코딩과 나중에 파트의 하나 이상의 디코드 또는 두 개 이상의 완전한 디코드 대신 두 번째 완전한 디코드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34b055b96b341faab090f12091572854579bc39" translate="yes" xml:space="preserve">
          <source>The basic ideas from the original protocol still hold. The I/O server and client communicate with one single, rather simplistic protocol and no server state is ever present in the client. Any I/O server can be used together with any client code, and the client code does not need to be aware of the I/O device that the I/O server communicates with.</source>
          <target state="translated">원래 프로토콜의 기본 아이디어는 여전히 유효합니다. I / O 서버 및 클라이언트는 하나의 단순한 프로토콜과 통신하며 클라이언트에 서버 상태가 없습니다. 모든 I / O 서버는 모든 클라이언트 코드와 함께 사용될 수 있으며 클라이언트 코드는 I / O 서버가 통신하는 I / O 장치를 인식 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="06f35fc40ac6c0c6f620803908f2d0ce6893c711" translate="yes" xml:space="preserve">
          <source>The basic message file</source>
          <target state="translated">기본 메시지 파일</target>
        </trans-unit>
        <trans-unit id="7b96cdbd69bdcaed6a11b07691044f3fc504705b" translate="yes" xml:space="preserve">
          <source>The behavior if a file specified in &lt;code&gt;sys.config&lt;/code&gt; does not exist, or is erroneous, is backwards compatible. Starting the runtime system will fail. Installing a new release version will not fail, but an error message is returned and the erroneous file is ignored.</source>
          <target state="translated">&lt;code&gt;sys.config&lt;/code&gt; 에 지정된 파일 이 없거나 오류가있는 경우 동작이 이전 버전과 호환됩니다. 런타임 시스템 시작에 실패합니다. 새 릴리스 버전을 설치해도 실패하지 않지만 오류 메시지가 반환되고 잘못된 파일은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a86acb8a0f20fdc979242a6b86b6e670d328548d" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if any process performs a write operation on the table while traversing the table with the function &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; This is because &lt;code&gt;write&lt;/code&gt; operations on a &lt;code&gt;Mnesia&lt;/code&gt; table can lead to internal reorganizations of the table itself. This is an implementation detail, but remember that the dirty functions are low-level functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;dirty_next/2&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 테이블을 순회하는 동안 프로세스가 테이블에서 쓰기 작업을 수행하는 경우 동작이 정의되지 않습니다. 이는 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에 대한 &lt;code&gt;write&lt;/code&gt; 작업으로 인해 테이블 자체의 내부 재구성이 발생할 수 있기 때문 입니다. 이것은 구현 세부 사항이지만 더티 함수는 저수준 함수라는 것을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="1a796a85b7d7280f632e4dcbf6b4a44abe35956e" translate="yes" xml:space="preserve">
          <source>The behavior of (*PRUNE:NAME) is the not the same as (*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(* PRUNE : NAME)의 동작은 (* MARK : NAME) (* PRUNE)과 다릅니다. 이름이 호출자에게 다시 전달 된 것으로 기억된다는 점에서 (* MARK : NAME)과 같습니다. 그러나 (* SKIP : NAME)은 (* MARK)로 설정된 이름 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="47227c0747ba0b82f4e36ef4aee5b965307890ad" translate="yes" xml:space="preserve">
          <source>The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).</source>
          <target state="translated">(* THEN : NAME)의 동작은 (* MARK : NAME) (* THEN)과 다릅니다. 이름이 호출자에게 다시 전달 된 것으로 기억된다는 점에서 (* MARK : NAME)과 같습니다. 그러나 (* SKIP : NAME)은 (* MARK)로 설정된 이름 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e44b071bcc39a063eb56d16dfbf4c6bb36987d8b" translate="yes" xml:space="preserve">
          <source>The behavior of a socket with this option set to &lt;code&gt;true&lt;/code&gt; is the only portable one. The original idea when IPv6 was new of using IPv6 for all traffic is now not recommended by FreeBSD (you can use &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; to override the recommended system default value), forbidden by OpenBSD (the supported GENERIC kernel), and impossible on Windows (which has separate IPv4 and IPv6 protocol stacks). Most Linux distros still have a system default value of &lt;code&gt;false&lt;/code&gt;. This policy shift among operating systems to separate IPv6 from IPv4 traffic has evolved, as it gradually proved hard and complicated to get a dual stack implementation correct and secure.</source>
          <target state="translated">이 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 소켓의 동작은 유일한 이식성입니다. IPv6가 모든 트래픽에 IPv6을 처음 사용했을 때의 원래 아이디어는 FreeBSD에서 권장하지 않으며 ( &lt;code&gt;{ipv6_v6only,false}&lt;/code&gt; 를 사용하여 권장 시스템 기본값을 무시할 수 있음) OpenBSD (지원되는 GENERIC 커널)에서 금지하며 불가능합니다. Windows (별도의 IPv4 및 IPv6 프로토콜 스택이 있음). 대부분의 Linux 배포판에는 여전히 시스템 기본값이 &lt;code&gt;false&lt;/code&gt; 입니다. IPv6 트래픽을 IPv4 트래픽과 분리하기위한 운영 체제 간의 이러한 정책 전환은 점차적으로 이중 스택 구현을 정확하고 안전하게 얻는 것이 어렵고 복잡 해짐에 따라 발전했습니다.</target>
        </trans-unit>
        <trans-unit id="1a4c4b510c91839af2b2d840f0dd22a548ca7548" translate="yes" xml:space="preserve">
          <source>The behavior of dot regarding newlines can be changed. If option &lt;code&gt;dotall&lt;/code&gt; is set, a dot matches any character, without exception. If the two-character sequence CRLF is present in the subject string, it takes two dots to match it.</source>
          <target state="translated">개행에 관한 도트의 동작을 변경할 수 있습니다. &lt;code&gt;dotall&lt;/code&gt; 옵션 이 설정되면 점은 예외없이 모든 문자와 일치합니다. 두 문자 시퀀스 CRLF가 제목 문자열에 있으면 두 점이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7965ee081ee817356aeac4f791276c29588e7325" translate="yes" xml:space="preserve">
          <source>The behavior of shell escape can be changed by the STDLIB application variable &lt;code&gt;shell_esc&lt;/code&gt;. The value of the variable can be either &lt;code&gt;jcl&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt;) or &lt;code&gt;abort&lt;/code&gt; (&lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt;). The first option sets &lt;code&gt;^G&lt;/code&gt; to activate &lt;code&gt;JCL&lt;/code&gt; mode (which is also default behavior). The latter sets &lt;code&gt;^G&lt;/code&gt; to terminate the current shell and start a new one. &lt;code&gt;JCL&lt;/code&gt; mode cannot be invoked when &lt;code&gt;shell_esc&lt;/code&gt; is set to &lt;code&gt;abort&lt;/code&gt;.</source>
          <target state="translated">쉘 이스케이프 동작은 STDLIB 애플리케이션 변수 &lt;code&gt;shell_esc&lt;/code&gt; 에 의해 변경 될 수 있습니다 . 변수 값은 &lt;code&gt;jcl&lt;/code&gt; ( &lt;code&gt;erl -stdlib shell_esc jcl&lt;/code&gt; ) 또는 &lt;code&gt;abort&lt;/code&gt; ( &lt;code&gt;erl -stdlib shell_esc abort&lt;/code&gt; ) 일 수 있습니다. 첫 번째 옵션은 &lt;code&gt;^G&lt;/code&gt; 를 설정 하여 &lt;code&gt;JCL&lt;/code&gt; 모드 를 활성화 합니다 (기본 동작이기도 함). 후자는 &lt;code&gt;^G&lt;/code&gt; 를 설정 하여 현재 쉘을 종료하고 새로운 쉘을 시작합니다. &lt;code&gt;shell_esc&lt;/code&gt; 가 &lt;code&gt;abort&lt;/code&gt; 로 설정 되면 &lt;code&gt;JCL&lt;/code&gt; 모드를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9f28c17be27978977c1d4772358e7a511e0dfa71" translate="yes" xml:space="preserve">
          <source>The behavior of these verbs in repeated groups, assertions, and in subpatterns called as subroutines (whether or not recursively) is described below.</source>
          <target state="translated">반복 그룹, 어설 션 및 서브 루틴이라고하는 서브 패턴 (재귀 적이든 아니든)에서이 동사의 동작은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f409290159e0122d24e0b32bc792ec356f3f9c" translate="yes" xml:space="preserve">
          <source>The behavior of this function changed radically in &lt;code&gt;Common Test&lt;/code&gt; 1.6.2. To keep some backwards compatability, it is still possible to do:</source>
          <target state="translated">이 기능의 동작은 &lt;code&gt;Common Test&lt;/code&gt; 1.6.2 에서 급격히 변했습니다 . 이전 버전과의 호환성을 유지하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cecdaf7589f62bdef0c740b1516c756288d9c79" translate="yes" xml:space="preserve">
          <source>The behavior of this function is undefined if the table is written on while being traversed. The function &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; can be used to ensure that no transaction-protected writes are performed during the iteration.</source>
          <target state="translated">이송 중에 테이블을 쓰면이 기능의 동작이 정의되지 않습니다. &lt;code&gt;&lt;a href=&quot;mnesia#read_lock_table-1&quot;&gt;mnesia:read_lock_table(Tab)&lt;/a&gt;&lt;/code&gt; 함수 는 반복 동안 트랜잭션으로 보호 된 쓰기가 수행되지 않도록하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad444f7fffcddf3e1072340ed21b0cb1ac9f4b6" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of posponed messages and other metadata. It receives all process messages, handles the system messages, and calls the callback module with machine specific events.</source>
          <target state="translated">동작 엔진은 상태 머신 상태, 서버 데이터, 타이머 참조, 대기중인 메시지 큐 및 기타 메타 데이터를 보유합니다. 모든 프로세스 메시지를 수신하고 시스템 메시지를 처리하며 기계 별 이벤트로 콜백 모듈을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="81091c06f62b758fa79bf459317221a8b60aa4f7" translate="yes" xml:space="preserve">
          <source>The behaviour engine holds the state machine state, server data, timer references, a queue of postponed messages and other metadata. It receives all process messages, handles the system messages, and calls the &lt;strong&gt;callback module&lt;/strong&gt; with machine specific events.</source>
          <target state="translated">동작 엔진은 상태 머신 상태, 서버 데이터, 타이머 참조, 연기 된 메시지 큐 및 기타 메타 데이터를 보유합니다. 모든 프로세스 메시지를 수신하고 시스템 메시지를 처리하며 시스템 특정 이벤트와 함께 &lt;strong&gt;콜백 모듈&lt;/strong&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="0880fce4c0b15834624e11a3dadca1d45ea29226" translate="yes" xml:space="preserve">
          <source>The behaviour module is part of Erlang/OTP. To implement a process such as a supervisor, the user only has to implement the callback module which is to export a pre-defined set of functions, the &lt;strong&gt;callback functions&lt;/strong&gt;.</source>
          <target state="translated">행동 모듈은 Erlang / OTP의 일부입니다. 수퍼바이저와 같은 프로세스를 구현하려면 사용자는 사전 정의 된 함수 세트 인 &lt;strong&gt;콜백 함수&lt;/strong&gt; 를 내보내는 콜백 모듈 만 구현하면 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f12a9631818d9d069082f70af478c5b6e70157" translate="yes" xml:space="preserve">
          <source>The benchmarks were run on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers.</source>
          <target state="translated">벤치 마크는 8 개의 스케줄러를 사용하는 하이퍼 스레딩 기능이있는 Intel i7 쿼드 코어 프로세서가 장착 된 비교적 새로운 시스템에서 실행되었습니다.</target>
        </trans-unit>
        <trans-unit id="f62e2973e3a88e1a9aafc89e21ac3f85591af54e" translate="yes" xml:space="preserve">
          <source>The benchmarks were run on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers. On a machine with more communication overhead and/or larger amount of logical processors the speedups are expected to be even larger.</source>
          <target state="translated">벤치 마크는 8 개의 스케줄러를 사용하는 하이퍼 스레딩 기능이있는 Intel i7 쿼드 코어 프로세서가 장착 된 비교적 새로운 시스템에서 실행되었습니다. 더 많은 통신 오버 헤드 및 / 또는 더 많은 양의 논리 프로세서가있는 시스템에서는 속도 향상이 훨씬 더 클 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="59e8c63ca2b59778b1c251bfe4d9af4a1c121cce" translate="yes" xml:space="preserve">
          <source>The benefit of this is that Megaco handles the starting, holding and the supervision of the driver and port.</source>
          <target state="translated">이것의 이점은 Megaco가 드라이버와 포트의 시작, 유지 및 감독을 처리한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1929daa6d9f07ef87baa0d2108c05731636b180d" translate="yes" xml:space="preserve">
          <source>The best place is in the &lt;code&gt;sys.config&lt;/code&gt; system configuration file of the release.</source>
          <target state="translated">가장 좋은 장소는 릴리스 의 &lt;code&gt;sys.config&lt;/code&gt; 시스템 구성 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d72c83f4147d145bc84c3d37b05a70b520d273ab" translate="yes" xml:space="preserve">
          <source>The binaries do not contain whole bytes (bit strings).</source>
          <target state="translated">이진은 전체 바이트 (비트 문자열)를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c99eedcea168087b25493bcc8656037a8c03177" translate="yes" xml:space="preserve">
          <source>The binary boot script file &lt;code&gt;Name.boot&lt;/code&gt; is generated from the boot script file &lt;code&gt;Name.script&lt;/code&gt;, using the function &lt;code&gt;systools:script2boot(File)&lt;/code&gt;.</source>
          <target state="translated">바이너리 부팅 스크립트 파일 인 &lt;code&gt;Name.boot&lt;/code&gt; 는 &lt;code&gt;systools:script2boot(File)&lt;/code&gt; 함수를 사용하여 부팅 스크립트 파일 인 &lt;code&gt;Name.script&lt;/code&gt; 에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c63a3b170852a27feb1e79f6999b69d62a7625a7" translate="yes" xml:space="preserve">
          <source>The binary boot script renamed to &lt;code&gt;start.boot&lt;/code&gt;</source>
          <target state="translated">이진 부팅 스크립트의 이름이 &lt;code&gt;start.boot&lt;/code&gt; 로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fdaeab197086e91b2d818626cc54633ed2fa6700" translate="yes" xml:space="preserve">
          <source>The binary executable file must be owned by root, have &lt;code&gt;rwsr-xr-x&lt;/code&gt; file privileges, in particular the &lt;code&gt;setuid&lt;/code&gt; bit of the user must be set.</source>
          <target state="translated">이진 실행 파일은 root가 소유하고 &lt;code&gt;rwsr-xr-x&lt;/code&gt; 파일 권한을 가져야 하며 , 특히 사용자 의 &lt;code&gt;setuid&lt;/code&gt; 비트를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f05ddacf84bb36fa321e41835d584b6e76e30a8" translate="yes" xml:space="preserve">
          <source>The binary heap works as a large object space for binary terms that are greater than 64 bytes (from now on called off-heap binaries). The binary heap is &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counted&lt;/a&gt;&lt;/code&gt; and a pointer to the off-heap binary is stored on the process heap. To keep track of when to decrement the reference counter of the off-heap binary, a linked list (the MSO - mark and sweep object list) containing funs and externals as well as off-heap binaries is woven through the heap. After a garbage collection is done, the &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2299&quot;&gt;MSO list is swept&lt;/a&gt;&lt;/code&gt; and any off-heap binary that does not have a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2325&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; written into the header words has its reference &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2344-L2367&quot;&gt;decremented and is potentially freed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 힙은 64 바이트보다 큰 이진 용어에 대한 대형 오브젝트 공간으로 작동합니다 (이제부터는 오프 힙 이진이라고 함). 바이너리 힙은 &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counted&lt;/a&gt;&lt;/code&gt; 가 계산 되고 힙 오프 바이너리에 대한 포인터는 프로세스 힙에 저장됩니다. 오프 힙 바이너리의 참조 카운터를 감소시킬시기를 추적하기 위해 오프 힙 바이너리뿐만 아니라 funs 및 externals를 포함하는 연결 목록 (MSO-마크 및 스윕 개체 목록)이 힙을 통해 짜여집니다. 가비지 수집이 완료되면 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2299&quot;&gt;MSO list is swept&lt;/a&gt;&lt;/code&gt; 되고 헤더 단어에 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2325&quot;&gt;move marker&lt;/a&gt;&lt;/code&gt; 기록 되지 않은 힙 오프 바이너리 는 참조가 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2344-L2367&quot;&gt;decremented and is potentially freed&lt;/a&gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="00fa7003833fa581d83179258571e8a367f39ad2" translate="yes" xml:space="preserve">
          <source>The binary object can be referenced by any number of ProcBins from any number of processes. The object contains a reference counter to keep track of the number of references, so that it can be removed when the last reference disappears.</source>
          <target state="translated">이진 개체는 여러 프로세스의 여러 ProcBins에서 참조 할 수 있습니다. 이 개체에는 참조 수를 추적하는 참조 카운터가 포함되어 있으므로 마지막 참조가 사라질 때 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="127151f66b51ac3efe997eb464906c3d0948c0d1" translate="yes" xml:space="preserve">
          <source>The binary object itself, stored outside all process heaps</source>
          <target state="translated">모든 프로세스 힙 외부에 저장된 이진 객체 자체</target>
        </trans-unit>
        <trans-unit id="4cf0fde8a2120eccfe9fdc8a249b8de5265ff4ee" translate="yes" xml:space="preserve">
          <source>The binary output file produced by the compiler is read by the agent at MIB load time (see the figure &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt;). The instrumentation is ordinary Erlang code which is loaded explicitly or automatically the first time it is called.</source>
          <target state="translated">컴파일러가 생성 한 이진 출력 파일은 MIB로드 시간에 에이전트가 읽습니다 ( &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;Starting the Agent&lt;/a&gt;&lt;/code&gt; 그림 참조 ). 계측은 일반 Erlang 코드이며 처음 호출 될 때 명시 적 또는 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d082c75a002a09432e39d447b940479e08b9f5e4" translate="yes" xml:space="preserve">
          <source>The bit syntax contains types for handling binary data in the three main encodings. The types are named &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt;. The &lt;code&gt;utf16&lt;/code&gt; and &lt;code&gt;utf32&lt;/code&gt; types can be in a big-endian or a little-endian variant:</source>
          <target state="translated">비트 구문에는 세 가지 주요 인코딩에서 이진 데이터를 처리하기위한 유형이 포함되어 있습니다. 유형의 이름은 &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 입니다. &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 유형은 빅 엔디안 또는 리틀 엔디안 변형 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7305cb0adee2541b623171c05bf3f3d1ecacd9f6" translate="yes" xml:space="preserve">
          <source>The body of the fun is used to construct the resulting value. When selecting from tables, one usually construct a suiting term here, using ordinary Erlang term construction, like tuple parentheses, list brackets, and variables matched out in the head, possibly with the occasional constant. Whatever expressions are allowed in guards are also allowed here, but no special functions exist except &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;bindings&lt;/code&gt; (see further down), which returns the whole matched object and all known variable bindings, respectively.</source>
          <target state="translated">재미의 몸은 결과 값을 구성하는 데 사용됩니다. 테이블에서 선택할 때 일반적으로 튜플 괄호, 목록 괄호 및 머리에서 일치하는 변수와 같은 일반적인 Erlang 용어 구성을 사용하여 적합한 용어를 여기에 적합하게 구성합니다. 가드에서 허용되는 표현식도 여기에서 허용되지만 &lt;code&gt;object&lt;/code&gt; 와 &lt;code&gt;bindings&lt;/code&gt; 제외한 특별한 함수는 존재하지 않습니다 (아래 참조). 일치하는 객체와 알려진 모든 변수 바인딩을 각각 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9fdf4a0d35c62b0782bd25eb4544517276991d8" translate="yes" xml:space="preserve">
          <source>The boolean value true specifies that the server will agree to reuse sessions. Setting it to false will result in an empty session table, that is no sessions will be reused. See also option &lt;code&gt;&lt;a href=&quot;#type-server_reuse_session&quot;&gt;reuse_session&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">부울 값 true는 서버가 세션 재사용에 동의 함을 지정합니다. false로 설정하면 빈 세션 테이블이 생성되어 세션이 재사용되지 않습니다. &lt;code&gt;&lt;a href=&quot;#type-server_reuse_session&quot;&gt;reuse_session&lt;/a&gt;&lt;/code&gt; 옵션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d4ca0de7223fe258efb581336c1e0197d5d0edd2" translate="yes" xml:space="preserve">
          <source>The boot script included in a release package must be generated from the same &lt;code&gt;.rel&lt;/code&gt; file as the release package itself.</source>
          <target state="translated">릴리스 패키지에 포함 된 부팅 스크립트 는 릴리스 패키지 자체 와 동일한 &lt;code&gt;.rel&lt;/code&gt; 파일 에서 생성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ddcf162c693f295280c787fbd8290adee7c45ca3" translate="yes" xml:space="preserve">
          <source>The boot script is stored in a file with extension &lt;code&gt;.script&lt;/code&gt;. The file has the following syntax:</source>
          <target state="translated">부팅 스크립트는 확장명이 &lt;code&gt;.script&lt;/code&gt; 인 파일에 저장됩니다 . 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41a09207a22769c0574e34261e0d72dca94a1cd1" translate="yes" xml:space="preserve">
          <source>The branches of an &lt;code&gt;if&lt;/code&gt;-expression are scanned sequentially until a guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; that evaluates to true is found. Then the corresponding &lt;code&gt;Body&lt;/code&gt; (sequence of expressions separated by ',') is evaluated.</source>
          <target state="translated">의 가지 &lt;code&gt;if&lt;/code&gt; -expression는 가드 시퀀스까지 순차적으로 스캔 &lt;code&gt;GuardSeq&lt;/code&gt; true로 평가가 발견된다. 그런 다음 해당 &lt;code&gt;Body&lt;/code&gt; ( ','으로 구분 된 표현식 순서)이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c635f7fb465fc59e43a777e3d06741481d050b03" translate="yes" xml:space="preserve">
          <source>The browser must run as a separate OS process, otherwise VTS hangs.</source>
          <target state="translated">브라우저는 별도의 OS 프로세스로 실행해야합니다. 그렇지 않으면 VTS가 정지됩니다.</target>
        </trans-unit>
        <trans-unit id="1acf68389c692a738d63487b4a06a4e7162935c1" translate="yes" xml:space="preserve">
          <source>The buffer pointed to by &lt;code&gt;v&lt;/code&gt; must be large enough to hold the return data, that is, it must be a pointer to one of &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt;, or &lt;code&gt;void*&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 가 가리키는 버퍼는 리턴 데이터를 보유 할만큼 충분히 커야합니다 . 즉, 각각 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;char*&lt;/code&gt; 또는 &lt;code&gt;void*&lt;/code&gt; 중 하나에 대한 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="eaa6a3f621852e6e7b5c05f1f4dfe807f43eee5b" translate="yes" xml:space="preserve">
          <source>The build system, including cross compilation configuration variables used, may be subject to non backward compatible changes without prior notice. Current cross build system has been tested when cross compiling some Linux/GNU systems, but has only been partly tested for more esoteric platforms. The VxWorks example file is highly dependent on our environment and is here more or less only for internal use.</source>
          <target state="translated">사용 된 크로스 컴파일 구성 변수를 포함한 빌드 시스템은 사전 통지없이 이전 버전과 호환되지 않는 변경 사항이 적용될 수 있습니다. 현재의 크로스 빌드 시스템은 일부 Linux / GNU 시스템을 크로스 컴파일 할 때 테스트되었지만 좀 더 난해한 플랫폼에 대해서만 부분적으로 테스트되었습니다. VxWorks 예제 파일은 환경에 따라 크게 달라지며 내부 용으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6fef17f4398287d703d6c8738ea77d284a4abce3" translate="yes" xml:space="preserve">
          <source>The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like &lt;code&gt;crypto:rand_seed/0&lt;/code&gt;.</source>
          <target state="translated">내장 난수 생성기 알고리즘은 암호화 적으로 강력하지 않습니다. 암호화 적으로 강력한 난수 생성기가 필요한 경우 &lt;code&gt;crypto:rand_seed/0&lt;/code&gt; 과 같은 것을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="067acc920ec0fee7fa628aac8051ca95ed671e0c" translate="yes" xml:space="preserve">
          <source>The busy message queue feature can be disabled either by setting the &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver, or by calling this function with &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; as a limit (either low or high). When this feature has been disabled, it cannot be enabled again. When reading the limits, both are &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; if this feature has been disabled.</source>
          <target state="translated">통화 중 메시지 대기열 기능은 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; 사용 하는 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;ERL_DRV_FLAG_NO_BUSY_MSGQ&lt;/code&gt; 드라이버 플래그 를 설정 하거나 &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; 를 제한 (낮음 또는 높음) 으로이 기능을 호출 하여 비활성화 할 수 있습니다 . 이 기능이 비활성화되면 다시 활성화 할 수 없습니다. 이 기능을 사용하지 않으면 한계를 읽을 때 둘 다 &lt;code&gt;ERL_DRV_BUSY_MSGQ_DISABLED&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33650cf8255f90c21ac81005064a8fbf5483e732" translate="yes" xml:space="preserve">
          <source>The button takes you to the code coverage overview page. If you have successfully performed a detailed coverage analysis, links to each individual module coverage page are found here.</source>
          <target state="translated">이 버튼으로 코드 적용 범위 개요 페이지로 이동합니다. 세부 범위 분석을 성공적으로 수행 한 경우 각 개별 모듈 범위 페이지에 대한 링크가 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="709ea736382b67af3f9c144683016c97550b6e99" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a code point in the invalid Unicode range.</source>
          <target state="translated">바이트가 유효하지 않은 유니 코드 범위의 코드 포인트로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="276396b4a984d3ef578929de68a65d7f15a4afbf" translate="yes" xml:space="preserve">
          <source>The bytes are decoded to a too large number.</source>
          <target state="translated">바이트가 너무 큰 숫자로 디코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="9be93d248e619868f8b04b5a5303526269804682" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt; crypto app's &lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">캐시 크기는 &lt;code&gt; crypto app's &lt;/code&gt; 구성 매개 변수 &lt;code&gt;rand_cache_size&lt;/code&gt; 를 사용하여 기본값에서 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="953ab7ba3d595c2a841438d3ab4f4c182fb2eff6" translate="yes" xml:space="preserve">
          <source>The cache size can be changed from its default value using the &lt;code&gt;crypto app's&lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">캐시 크기는 &lt;code&gt;crypto app's&lt;/code&gt; 구성 매개 변수 &lt;code&gt;rand_cache_size&lt;/code&gt; 를 사용하여 기본값에서 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bba971c6589524e2b87b07ee118d11ab2b5ec5e2" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:call(Node, Module, Function, Args)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:call(Node, Module, Function, Args, infinity)&lt;/code&gt;</source>
          <target state="translated">호 &lt;code&gt;erpc:call(Node, Module, Function, Args)&lt;/code&gt; 호에 해당 &lt;code&gt;erpc:call(Node, Module, Function, Args, infinity)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ca6b0dafdc23056fe13a565a84397b1490c9ec" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:call(Node,Fun)&lt;/code&gt; is the same as the call &lt;code&gt;erpc:call(Node,Fun,infinity)&lt;/code&gt;.</source>
          <target state="translated">콜 &lt;code&gt;erpc:call(Node,Fun)&lt;/code&gt; 호출과 동일 &lt;code&gt;erpc:call(Node,Fun,infinity)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5af71d5240d81c230e56c0fedb791afdbf3e003" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args, infinity)&lt;/code&gt;. These calls are also equivalent to calling &lt;code&gt;my_multicall(Nodes, Module, Function, Args)&lt;/code&gt; if one disregard performance and failure behavior:</source>
          <target state="translated">호 &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args)&lt;/code&gt; 호에 해당 &lt;code&gt;erpc:multicall(Nodes, Module, Function, Args, infinity)&lt;/code&gt; . 이러한 호출은 성능 및 실패 동작을 무시하는 경우 &lt;code&gt;my_multicall(Nodes, Module, Function, Args)&lt;/code&gt; 을 호출하는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="79b9b9d99c8ecce8485a4983dcd83e4894a6b989" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:multicall(Nodes,Fun)&lt;/code&gt; is the same as the call &lt;code&gt;erpc:multicall(Nodes,Fun, infinity)&lt;/code&gt;.</source>
          <target state="translated">콜 &lt;code&gt;erpc:multicall(Nodes,Fun)&lt;/code&gt; 호출과 동일 &lt;code&gt;erpc:multicall(Nodes,Fun, infinity)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d0b458c6aae29c39ad3c25a6af2742eb4013be" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:receive_response(RequestId)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:receive_response(RequestId, infinity)&lt;/code&gt;.</source>
          <target state="translated">호 &lt;code&gt;erpc:receive_response(RequestId)&lt;/code&gt; 호에 해당 &lt;code&gt;erpc:receive_response(RequestId, infinity)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a152c6617bd51e1fb2b711ebf4373faae6094d4" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;erpc:wait_response(RequestId)&lt;/code&gt; is equivalent to the call &lt;code&gt;erpc:wait_response(RequestId, 0)&lt;/code&gt;. That is, poll for a response message to a &lt;code&gt;call&lt;/code&gt; request previously made by the calling process.</source>
          <target state="translated">호 &lt;code&gt;erpc:wait_response(RequestId)&lt;/code&gt; 호에 해당 &lt;code&gt;erpc:wait_response(RequestId, 0)&lt;/code&gt; . 즉, 이전에 호출 프로세스에서 만든 &lt;code&gt;call&lt;/code&gt; 요청 에 대한 응답 메시지를 폴링 합니다.</target>
        </trans-unit>
        <trans-unit id="49f53eb411418a4e5fc2e2575c742546457d6c88" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_event:wait_response(gen_event:send_request(EventMgrRef,Handler,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_event:call(EventMgrRef,Handler,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="translated">호출 &lt;code&gt;gen_event:wait_response(gen_event:send_request(EventMgrRef,Handler,Request), Timeout)&lt;/code&gt; 과 동일하게 볼 수 &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_event:call(EventMgrRef,Handler,Request,Timeout)&lt;/a&gt;&lt;/code&gt; , 오류 처리를 무시.</target>
        </trans-unit>
        <trans-unit id="1d937cd40cd03a99573acdf02ba260b024e4d3ab" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_server:wait_response(gen_server:send_request(ServerRef,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_server:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="translated">호출 &lt;code&gt;gen_server:wait_response(gen_server:send_request(ServerRef,Request), Timeout)&lt;/code&gt; 과 동일하게 볼 수있다 &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_server:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt; 에러 처리를 무시.</target>
        </trans-unit>
        <trans-unit id="cff8030a297aeb35ab5d6884ca11e4edf2e73f36" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout)&lt;/code&gt; can be seen as equivalent to &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_statem:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt;, ignoring the error handling.</source>
          <target state="translated">호출 &lt;code&gt;gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout)&lt;/code&gt; 과 동일하게 볼 수 &lt;code&gt;&lt;a href=&quot;#call-3&quot;&gt;gen_statem:call(Server,Request,Timeout)&lt;/a&gt;&lt;/code&gt; , 오류 처리를 무시.</target>
        </trans-unit>
        <trans-unit id="2e019f9fcd17a687470aea637478863f5e134cb3" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;module_info(Key)&lt;/code&gt;, where &lt;code&gt;Key&lt;/code&gt; is an atom, returns a single piece of information about the module.</source>
          <target state="translated">&lt;code&gt;module_info(Key)&lt;/code&gt; 호출 ( 여기서 &lt;code&gt;Key&lt;/code&gt; 는 원 자임)은 모듈에 대한 단일 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a72f41bd0ef1a660b71b19854f4a2f611d367c22" translate="yes" xml:space="preserve">
          <source>The call can also fail, for example, if the &lt;code&gt;gen_statem&lt;/code&gt; dies before or during this function call.</source>
          <target state="translated">예를 들어 &lt;code&gt;gen_statem&lt;/code&gt; 이이 함수 호출 전이나 도중에 죽으면 호출도 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8367b12b1eaff6fc40fd96b320d7987c710ba242" translate="yes" xml:space="preserve">
          <source>The call can fail for many reasons, including time-out and the called &lt;code&gt;gen_server&lt;/code&gt; process dying before or during the call.</source>
          <target state="translated">시간 초과 및 호출 전 또는 호출 중에 호출 된 &lt;code&gt;gen_server&lt;/code&gt; 프로세스를 포함하여 여러 가지 이유로 호출에 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4739e34ca18c32d95d687955ecad4a46982e910c" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are paused at their current count.</source>
          <target state="translated">통화 횟수 중단 점이있는 모든 일치하는 기능에 대한 통화 카운터는 현재 카운트에서 일시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="52c5d88794b3b9c10b033bc03376b7dc1bc55692" translate="yes" xml:space="preserve">
          <source>The call counters for all matching functions that has got call count breakpoints are set to zero and running.</source>
          <target state="translated">호출 횟수 중단 점을 가진 일치하는 모든 기능에 대한 호출 카운터가 0으로 설정되어 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="fcd429bca91d28345133d5ddfc12f2039568c7e0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">호출은 실패 &lt;code&gt;{badmap,Map}&lt;/code&gt; 경우 예외 &lt;code&gt;Map1&lt;/code&gt; 지도없는, 또는 함께 &lt;code&gt;{badkey,Key}&lt;/code&gt; 값이 연결되지 않은 경우 예외 &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a765e0cc7b8afeedc4b406e029455c41a2e05717" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; 이 맵이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="3bcc437b0d2af2e5401d95afab2b22b04d0cd309" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; or &lt;code&gt;Map2&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; 또는 &lt;code&gt;Map2&lt;/code&gt; 가 맵이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f8317a62b38be81b80524eaf41aa4ccce539a0" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map, or with a &lt;code&gt;{badkey,Key}&lt;/code&gt; exception if no value is associated with &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">호출은 실패 &lt;code&gt;{badmap,Map}&lt;/code&gt; 경우 예외 &lt;code&gt;Map&lt;/code&gt; 지도없는, 또는 함께 &lt;code&gt;{badkey,Key}&lt;/code&gt; 값이 연결되지 않은 경우 예외 &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3d448e3253ce8fb6ba525c95cf4c520a4dd69a" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 이 맵 이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="16f4ecacaaaef2b7ebc1761887fc6a38ffe0b906" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">&lt;code&gt;MapOrIter&lt;/code&gt; 가 맵 또는 유효한 반복자 가 아닌 경우 또는 &lt;code&gt;badarg&lt;/code&gt; &lt;code&gt;Fun&lt;/code&gt; 이 arity 2의 함수가 아닌 경우 badarg 가있는 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 호출에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="12f759a8b6547e05c46e411430a759d92783001f" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Fun&lt;/code&gt; is not a function of arity 3.</source>
          <target state="translated">&lt;code&gt;MapOrIter&lt;/code&gt; 가 맵 또는 유효한 반복자 가 아닌 경우 또는 &lt;code&gt;badarg&lt;/code&gt; &lt;code&gt;Fun&lt;/code&gt; 이 arity 3의 함수가 아닌 경우 badarg 가있는 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 호출에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="ac940292242acb2f76654b1a0d7f61a1dafc1f65" translate="yes" xml:space="preserve">
          <source>The call fails with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;MapOrIter&lt;/code&gt; is not a map or valid iterator, or with &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Pred&lt;/code&gt; is not a function of arity 2.</source>
          <target state="translated">호출은 실패 &lt;code&gt;{badmap,Map}&lt;/code&gt; 경우 예외 &lt;code&gt;MapOrIter&lt;/code&gt; 은 지도 나 유효 반복자, 또는하지입니다 &lt;code&gt;badarg&lt;/code&gt; 경우 &lt;code&gt;Pred&lt;/code&gt; 를 가산이 인수에 대응 2의 기능이 아니다.</target>
        </trans-unit>
        <trans-unit id="2892cf3454075f0053d7bd91a8d8a1dd21669320" translate="yes" xml:space="preserve">
          <source>The call format may be different if a customized prologue file has been included when generating the parser instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt;.</source>
          <target state="translated">기본 파일 &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; 대신 파서를 생성 할 때 사용자 정의 된 프롤로그 파일이 포함 된 경우 호출 형식이 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e8198892cee32a7b8526bf6bc65cdd83e83fc69" translate="yes" xml:space="preserve">
          <source>The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4:</source>
          <target state="translated">호출은 첫 번째 명시 적으로 캡처 된 하위 패턴이 &quot;(abcd)&quot;이고, 길이가 4 인 (0부터 시작) 위치 3의 주제에서 &quot;abcd&quot;와 일치하는 다음 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="daf666a091f35efff4124fee9f5b0c58cdf83623" translate="yes" xml:space="preserve">
          <source>The call is wrapped in a case statement and will be evaluated only if &lt;code&gt;Level&lt;/code&gt; is equal to or below the configured log level.</source>
          <target state="translated">호출은 케이스 문으로 랩핑되며 &lt;code&gt;Level&lt;/code&gt; 이 구성된 로그 레벨 이하인 경우에만 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="de78c6fd6e7546e57186f359788dd6c58cc04ff8" translate="yes" xml:space="preserve">
          <source>The call of this function will trigger the callback function UserMod:handle_connect/2 to be invoked. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">이 함수를 호출하면 콜백 함수 UserMod : handle_connect / 2가 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6eff7cd52eb9afdfc9d628f7416b2b3d981918c" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;io:format/2&lt;/code&gt; will never be executed, but a return address will still be pushed to the stack each time &lt;code&gt;loop/0&lt;/code&gt; is called recursively. The correct tail-recursive version of the function looks as follows:</source>
          <target state="translated">&lt;code&gt;io:format/2&lt;/code&gt; 에 대한 호출 은 절대 실행되지 않지만 &lt;code&gt;loop/0&lt;/code&gt; 이 재귀 적으로 호출 될 때마다 반환 주소가 여전히 스택으로 푸시됩니다 . 올바른 꼬리 재귀 버전의 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69e4234e48da562de4b3fe66e96e15cc38ad9a57" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; must be made &lt;strong&gt;directly&lt;/strong&gt; from the Erlang code of the module that the NIF library belongs to. It returns either &lt;code&gt;ok&lt;/code&gt;, or &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; if loading fails. &lt;code&gt;Reason&lt;/code&gt; is one of the following atoms while &lt;code&gt;Text&lt;/code&gt; is a human readable string that can give more information about the failure:</source>
          <target state="translated">NIF 라이브러리가 속하는 모듈의 Erlang 코드에서 &lt;strong&gt;직접 &lt;/strong&gt; &lt;code&gt;load_nif/2&lt;/code&gt; 를 호출 해야합니다 . 로드에 실패하면 &lt;code&gt;ok&lt;/code&gt; 또는 &lt;code&gt;{error,{Reason,Text}}&lt;/code&gt; 를 리턴 합니다. &lt;code&gt;Reason&lt;/code&gt; 는 다음 원자 중 하나이며 &lt;code&gt;Text&lt;/code&gt; 는 사람이 읽을 수있는 문자열로 실패에 대한 자세한 정보를 제공 할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65c74848bb8184c1160ce5aeb1b1f12389a01cd3" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;load_nif/2&lt;/code&gt; was made from the old code of a module that has been upgraded; this is not allowed.</source>
          <target state="translated">&lt;code&gt;load_nif/2&lt;/code&gt; 에 대한 호출 은 업그레이드 된 모듈의 이전 코드에서 작성되었습니다. 이것은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9645f8ce41967acca4649554ceab30271d3386df" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;return_trace&lt;/code&gt; results in a trace message when the function returns. It applies only to the specific function call triggering the match specification (and matching the head/guards of the match specification). This is by far the most common call in the body of a &lt;code&gt;dbg&lt;/code&gt; match specification.</source>
          <target state="translated">&lt;code&gt;return_trace&lt;/code&gt; 를 호출 하면 함수가 리턴 될 때 추적 메시지가 생성됩니다. 일치 사양을 트리거하고 일치 사양의 헤드 / 가드를 일치시키는 특정 함수 호출에만 적용됩니다. 이것은 &lt;code&gt;dbg&lt;/code&gt; 일치 스펙 본문에서 가장 일반적인 호출입니다 .</target>
        </trans-unit>
        <trans-unit id="92d19c83ca0b80ba803b67a868b3108e7fb7711b" translate="yes" xml:space="preserve">
          <source>The call to the analyze function must be as follows:</source>
          <target state="translated">분석 함수에 대한 호출은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="55e6d7779dabe02d283cfb249b485592e929b71e" translate="yes" xml:space="preserve">
          <source>The call will fail with a &lt;code&gt;{badmap,Map}&lt;/code&gt; exception if &lt;code&gt;Map1&lt;/code&gt; is not a map.</source>
          <target state="translated">&lt;code&gt;Map1&lt;/code&gt; 이 맵이 아닌 경우 &lt;code&gt;{badmap,Map}&lt;/code&gt; 예외로 인해 호출이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="fa1f952e3b1c0797c615bedda4b65ed54a10a69e" translate="yes" xml:space="preserve">
          <source>The call will return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the check. The caller do not need to handle the matching rules in the rfc. The matching will proceed as:</source>
          <target state="translated">확인에 따라 호출이 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . 호출자는 rfc에서 일치 규칙을 처리 할 필요가 없습니다. 일치는 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="104de9fe47518d4f0de85d87c6a5c1db2f88d084" translate="yes" xml:space="preserve">
          <source>The call:</source>
          <target state="translated">호출:</target>
        </trans-unit>
        <trans-unit id="1514747db293879c8ce291ed88a8dae74c64014f" translate="yes" xml:space="preserve">
          <source>The callback function UserMod:handle_trans_reply/4 is invoked when the reply arrives, when the request timer eventually times out or when the outstanding requests are explicitly cancelled. See the megaco_user module for more info about the callback arguments.</source>
          <target state="translated">콜백 함수 UserMod : handle_trans_reply / 4는 응답이 도착할 때, 요청 타이머가 결국 시간 초과되거나 미해결 요청이 명시 적으로 취소 될 때 호출됩니다. 콜백 인수에 대한 자세한 정보는 megaco_user 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e40447571e80d72283361f5ca0d8dcdb93fefaa2" translate="yes" xml:space="preserve">
          <source>The callback function handling the &lt;code&gt;stop&lt;/code&gt; request returns a tuple &lt;code&gt;{stop,normal,State1}&lt;/code&gt;, where &lt;code&gt;normal&lt;/code&gt; specifies that it is a normal termination and &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;. This causes the &lt;code&gt;gen_server&lt;/code&gt; to call &lt;code&gt;terminate(normal, State1)&lt;/code&gt; and then it terminates gracefully.</source>
          <target state="translated">취급 콜백 함수 &lt;code&gt;stop&lt;/code&gt; 요청이 반환 튜플 &lt;code&gt;{stop,normal,State1}&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; 지정 그것이 정상 종료라고하고 &lt;code&gt;State1&lt;/code&gt; 정는 의 상태에 대한 새로운 값 &lt;code&gt;gen_server&lt;/code&gt; . 이로 인해 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;terminate(normal, State1)&lt;/code&gt; 를 호출 한 다음 정상적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="728b1d3be49a797310af6aa94681789dfdda4be1" translate="yes" xml:space="preserve">
          <source>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors and so on. The function is not invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. However, it is invoked if the functions fail (crash).</source>
          <target state="translated">콜백 함수는 열린 파일 디스크립터 닫기 등과 같이 파일 전송이 중단 된 후 사용 된 자원을 정리합니다. 다른 콜백 함수 중 하나가 이미 필요한 리소스를 정리했을 것으로 예상되므로 오류를 반환하면 함수가 호출되지 않습니다. 그러나 함수가 실패하면 (충돌) 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="109919e956ac7fc9c9c7ca8c3328e95855910a87" translate="yes" xml:space="preserve">
          <source>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</source>
          <target state="translated">콜백 함수는 마지막 파일 청크가 발생할 때 파일을 닫을 것으로 예상됩니다. 오류가 발생하면 열린 파일 디스크립터 닫기와 같은 파일 전송 중단 후 콜백 함수가 정리됩니다. 두 경우 모두 더 이상 콜백 함수에 대한 호출이 없습니다.</target>
        </trans-unit>
        <trans-unit id="84bacd9fc6215821a0c57cf0a99b64819b895b8b" translate="yes" xml:space="preserve">
          <source>The callback function is to be defined as follows:</source>
          <target state="translated">콜백 함수는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="898a8e55f83f4732a3d9a1c55861f5556e256a82" translate="yes" xml:space="preserve">
          <source>The callback function itself did the updates.</source>
          <target state="translated">콜백 함수 자체가 업데이트를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="1d90b6e19e5f31bc52641082a2d815396c2a8af1" translate="yes" xml:space="preserve">
          <source>The callback function to use. &lt;code&gt;Module&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; are atoms and &lt;code&gt;Args&lt;/code&gt; is a list of terms. When an OS message &lt;code&gt;Msg&lt;/code&gt; is received, this function is called as &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt;.</source>
          <target state="translated">사용할 콜백 함수 &lt;code&gt;Module&lt;/code&gt; 과 &lt;code&gt;Function&lt;/code&gt; 은 원자이고 &lt;code&gt;Args&lt;/code&gt; 는 용어 목록입니다. OS 메시지 &lt;code&gt;Msg&lt;/code&gt; 가 수신되면이 함수를 &lt;code&gt;apply(Module, Function, [Msg | Args])&lt;/code&gt; 로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="bf66fa0dd7df5d0912660af5ccc84e8028f914a6" translate="yes" xml:space="preserve">
          <source>The callback function works as described in &lt;code&gt;os_sup(3)&lt;/code&gt;.</source>
          <target state="translated">콜백 함수는 &lt;code&gt;os_sup(3)&lt;/code&gt; 설명 된대로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="1ea45999ad4acd01ff35ccee071d905b456a15b2" translate="yes" xml:space="preserve">
          <source>The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt).</source>
          <target state="translated">콜백 함수는 컴파일 된 코드에서 호출 된 함수의 실행을 허용하거나 거부하는 데 사용할 수 없습니다 (쉘 프롬프트에서 입력 된 표현식에서 호출 된 함수 만).</target>
        </trans-unit>
        <trans-unit id="96dd8e426598dea1368d28980aebceed3f1b20a0" translate="yes" xml:space="preserve">
          <source>The callback functions of the module can be specified either directly by the exported function &lt;code&gt;behaviour_info/1&lt;/code&gt;:</source>
          <target state="translated">내 보낸 함수 &lt;code&gt;behaviour_info/1&lt;/code&gt; 에 의해 모듈의 콜백 함수를 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c0541a4b27e58b4de7bee93e3d77a109876a92d" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test &lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="translated">테스트 스위트에서 구현할 콜백 함수는 모두 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test &lt;/a&gt;&lt;/code&gt; 모듈에 나열되어 있습니다. 또한이 사용자 가이드의 뒷부분에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="54dd23c9ceb4245139e54c85cd25b72ecec0fba9" translate="yes" xml:space="preserve">
          <source>The callback functions to be implemented by the test suite are all listed in module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;. They are also described in more detail later in this User's Guide.</source>
          <target state="translated">테스트 스위트가 구현할 콜백 함수는 모두 &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; 모듈에 나열됩니다 . 또한이 사용자 안내서의 뒷부분에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85791b6dc548416b6612b724000cfadda018f22a" translate="yes" xml:space="preserve">
          <source>The callback interface is based on that the user sends a fun with the correct signature to the parser.</source>
          <target state="translated">콜백 인터페이스는 사용자가 올바른 서명으로 재미를 파서에 보낸다는 것을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="59e965f4c45d1fd48637f0634a7fe7cb62c0c3bd" translate="yes" xml:space="preserve">
          <source>The callback interface of the transport module contains several functions. Some of which are mandatory while others are only optional:</source>
          <target state="translated">전송 모듈의 콜백 인터페이스에는 몇 가지 기능이 있습니다. 일부는 필수이지만 다른 일부는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="cd251fb009bc0977864cd404e86e72a74db2ce5c" translate="yes" xml:space="preserve">
          <source>The callback is made by a middleman process, hence the file transfer is not affected by the code in the progress callback function. If the callback crashes, this is detected by the FTP connection process, which then prints an info-report and goes on as if the progress option was set to &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">콜백은 중개자 프로세스에 의해 이루어 지므로 파일 전송은 진행 콜백 함수의 코드에 영향을받지 않습니다. 콜백이 충돌하면 FTP 연결 프로세스에서이를 감지하여 정보 보고서를 인쇄하고 진행률 옵션이 &lt;code&gt;ignore&lt;/code&gt; 로 설정된 것처럼 진행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e8e4051d9662c60ffac0c38b92a0a52ef07de6ce" translate="yes" xml:space="preserve">
          <source>The callback mode &lt;code&gt;handle_event_function&lt;/code&gt; enables using a non-atom state as described in section &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt;, for example, a complex state term like a tuple.</source>
          <target state="translated">콜백 모드 &lt;code&gt;handle_event_function&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Modes&lt;/a&gt;&lt;/code&gt; 섹션에 설명 된대로 원자가 아닌 상태 ( 예 : 튜플과 같은 복잡한 상태 용어)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9074f752748f19027b380bf6c6083917557b4d1" translate="yes" xml:space="preserve">
          <source>The callback mode is selected at server start and may be changed with a code upgrade/downgrade.</source>
          <target state="translated">콜백 모드는 서버 시작시 선택되며 코드 업그레이드 / 다운 그레이드로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1b667b206213a5b84a8db86f75c2c72599f104c" translate="yes" xml:space="preserve">
          <source>The callback mode is selected by implementing a mandatory callback function &lt;code&gt;Module:callback_mode()&lt;/code&gt; that returns one of the callback modes.</source>
          <target state="translated">콜백 모드는 콜백 모드 중 하나를 반환 하는 필수 콜백 함수 &lt;code&gt;Module:callback_mode()&lt;/code&gt; 를 구현하여 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bae742a256a71cd7955e770e21832abee7463ec" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt; rewrite from &lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">콜백 모델 (들) &lt;code&gt;gen_statem&lt;/code&gt; 에 대한 것과 다른 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; , 그러나 그것은 매우 쉽게하기 여전히 &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt; rewrite from &lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_fsm&lt;/code&gt; 하는 &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ead6e2ff311fd428d1dc6968b3919ecff631ec58" translate="yes" xml:space="preserve">
          <source>The callback model(s) for &lt;code&gt;gen_statem&lt;/code&gt; differs from the one for &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt;, but it is still fairly easy to &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt;&lt;code&gt;gen_fsm&lt;/code&gt; to &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">콜백 모델 (들) &lt;code&gt;gen_statem&lt;/code&gt; 에 대한 것과 다른 &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; , 그러나 그것은 매우 쉽게하기 여전히 &lt;code&gt;&lt;a href=&quot;gen_fsm#Migration%20to%20gen_statem&quot;&gt;rewrite from&lt;/a&gt;&lt;/code&gt; &lt;code&gt;gen_fsm&lt;/code&gt; 하는 &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd40cbe96a6a7878da940a8badb97c6c9caeb25" translate="yes" xml:space="preserve">
          <source>The callback module contains functions that implement the state machine. When an event occurs, the &lt;code&gt;gen_statem&lt;/code&gt; behaviour engine calls a function in the callback module with the event, current state and server data. This function performs the actions for this event, and returns the new state and server data and also actions to be performed by the behaviour engine.</source>
          <target state="translated">콜백 모듈은 상태 머신을 구현하는 함수를 포함합니다. 이벤트가 발생하면 &lt;code&gt;gen_statem&lt;/code&gt; 비헤이비어 엔진은 이벤트, 현재 상태 및 서버 데이터와 함께 콜백 모듈의 함수를 호출합니다. 이 함수는이 이벤트에 대한 조치를 수행하고 새 상태 및 서버 데이터와 동작 엔진이 수행 할 조치를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="abbecd682f4918a42592a94b71742e36915e1bab" translate="yes" xml:space="preserve">
          <source>The callback module does not have to access real &lt;code&gt;Mnesia&lt;/code&gt; tables, it is free to do whatever it wants as long as the callback interface is fulfilled.</source>
          <target state="translated">콜백 모듈은 실제 &lt;code&gt;Mnesia&lt;/code&gt; 테이블 에 액세스 할 필요가 없으며 콜백 인터페이스가 충족되는 한 원하는대로 자유롭게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb2d562d838a71a4ba446f4da81f7701d757f5f" translate="yes" xml:space="preserve">
          <source>The callback module for a supervisor starting the server from &lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; can look as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;gen_server_concepts#ex&quot;&gt;gen_server Behaviour&lt;/a&gt;&lt;/code&gt; 에서 서버를 시작하는 수퍼바이저의 콜백 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="517a681e26aeb83ed7549fbd52cdab0059ff31b1" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to a file can look as follows:</source>
          <target state="translated">오류 메시지를 파일에 쓰는 이벤트 핸들러의 콜백 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7722a0fd22c0aced7aea92994c66dc97a4d0fdd" translate="yes" xml:space="preserve">
          <source>The callback module for the event handler writing error messages to the terminal can look as follows:</source>
          <target state="translated">터미널에 오류 메시지를 쓰는 이벤트 핸들러의 콜백 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="344a5e28ddcbac85a390899bb7eafc0bb7e415bf" translate="yes" xml:space="preserve">
          <source>The callback module implementing the handler is responsible for checking the correctness of configuration strings.</source>
          <target state="translated">핸들러를 구현하는 콜백 모듈은 구성 문자열의 정확성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97f313867ce48aba95bd9c378dbac9f612a9aacd" translate="yes" xml:space="preserve">
          <source>The callback module is used to check that the provided public key is one of the user's pre-stored. In case of the default callback module, the files &lt;code&gt;authorized_keys&lt;/code&gt; and &lt;code&gt;authorized_keys2&lt;/code&gt; are searched in a directory found in the following order:</source>
          <target state="translated">콜백 모듈은 제공된 공개 키가 사용자의 사전 저장된 키 중 하나인지 확인하는 데 사용됩니다. 기본 콜백 모듈의 경우 &lt;code&gt;authorized_keys&lt;/code&gt; 및 &lt;code&gt;authorized_keys2&lt;/code&gt; 파일 은 다음 순서로 찾은 디렉토리에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="0b0838bae2efd3e8ec52bba36939ac5379dcb0f2" translate="yes" xml:space="preserve">
          <source>The callback module must implement the &lt;code&gt;tftp&lt;/code&gt; behavior, see &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">콜백 모듈은 &lt;code&gt;tftp&lt;/code&gt; 동작을 구현해야합니다 ( &lt;code&gt;&lt;a href=&quot;#tftp_callback&quot;&gt;CALLBACK FUNCTIONS&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7c16c7638772ec54a79c0e6462748feea41441fe" translate="yes" xml:space="preserve">
          <source>The callback module of the socket.</source>
          <target state="translated">소켓의 콜백 모듈</target>
        </trans-unit>
        <trans-unit id="8b2bd7c81f3fa7abf6044482ee91de57b2f57d61" translate="yes" xml:space="preserve">
          <source>The callback will be removed if the system reboots.</source>
          <target state="translated">시스템이 재부팅되면 콜백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1a547d0b36068b79f0e702e418ab428ce5c3cc09" translate="yes" xml:space="preserve">
          <source>The called function &lt;code&gt;throw&lt;/code&gt;s a term that does &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;{'EXIT',_}&lt;/code&gt;.</source>
          <target state="translated">호출 된 함수 는 &lt;code&gt;{'EXIT',_}&lt;/code&gt; 와 일치 하지 &lt;strong&gt;않는&lt;/strong&gt; 용어를 &lt;code&gt;throw&lt;/code&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f852af73e27bcafb08e2076230e176b0693da4a5" translate="yes" xml:space="preserve">
          <source>The called function &lt;code&gt;throws&lt;/code&gt; a term that matches &lt;code&gt;{'EXIT', _}&lt;/code&gt;.</source>
          <target state="translated">호출 된 함수 &lt;code&gt;throws&lt;/code&gt; &lt;code&gt;{'EXIT', _}&lt;/code&gt; 와 일치하는 용어를 던집니다 .</target>
        </trans-unit>
        <trans-unit id="352f667fc05f32e342942fb39e336eda11373186" translate="yes" xml:space="preserve">
          <source>The called function fails with an &lt;code&gt;error&lt;/code&gt; exception.</source>
          <target state="translated">호출 된 함수가 &lt;code&gt;error&lt;/code&gt; 예외 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="f86af8fc0d6dc4ec61f07ecb92e7902186c04bb2" translate="yes" xml:space="preserve">
          <source>The called function fails with an &lt;code&gt;exit&lt;/code&gt; exception.</source>
          <target state="translated">호출 된 함수가 &lt;code&gt;exit&lt;/code&gt; 예외 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="db6c226767131f116119f4a068f6de4330aaa924" translate="yes" xml:space="preserve">
          <source>The called function returns a term that matches &lt;code&gt;{'EXIT', _}&lt;/code&gt;.</source>
          <target state="translated">호출 된 함수는 &lt;code&gt;{'EXIT', _}&lt;/code&gt; 와 일치하는 용어를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dfa82d7675b5e6bd93834e8fd74a124b66bdd5d8" translate="yes" xml:space="preserve">
          <source>The called function returns normally with a term that does &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;{'EXIT',_}&lt;/code&gt;.</source>
          <target state="translated">호출 된 함수는 &lt;code&gt;{'EXIT',_}&lt;/code&gt; 와 일치 하지 &lt;strong&gt;않는&lt;/strong&gt; 용어와 함께 정상적으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="55cc105f61cd981bcf32511925e36d658bc51fff" translate="yes" xml:space="preserve">
          <source>The called hook function is to return a (possibly deep) list of characters. Function &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; is useful in a hook.</source>
          <target state="translated">호출 된 후크 함수는 문자 목록을 리턴하는 것입니다. &lt;code&gt;&lt;a href=&quot;#expr-4&quot;&gt;expr/4&lt;/a&gt;&lt;/code&gt; 함수 는 후크에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dd19dd71cdd2bc7e1309239a2dc9ab10df17269d" translate="yes" xml:space="preserve">
          <source>The caller (of the discovery function) will make the needed updates later.</source>
          <target state="translated">발견 기능의 호출자는 나중에 필요한 업데이트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="524e0413b79c29af01dbca40fc74eeea51a2d73c" translate="yes" xml:space="preserve">
          <source>The caller can now make another call to the recv function and now expect data.</source>
          <target state="translated">호출자는 이제 recv 함수를 다시 호출 할 수 있으며 이제 데이터를 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be52289a60f89b006753632d58c58744da7ef87" translate="yes" xml:space="preserve">
          <source>The caller can then make another call to the recv function and now expect data.</source>
          <target state="translated">그런 다음 호출자는 recv 함수를 다시 호출하고 이제 데이터를 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ead89ef805808ff104ff5c388ca47931019854a" translate="yes" xml:space="preserve">
          <source>The caller can use own extraction and matching rules. This is done with the two options &lt;code&gt;fqdn_fun&lt;/code&gt; and &lt;code&gt;match_fun&lt;/code&gt;.</source>
          <target state="translated">발신자는 자체 추출 및 일치 규칙을 사용할 수 있습니다. 이것은 두 가지 옵션 &lt;code&gt;fqdn_fun&lt;/code&gt; 및 &lt;code&gt;match_fun&lt;/code&gt; 로 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="a7fc9c78e44578fd025d978ee708e79b0fa261e4" translate="yes" xml:space="preserve">
          <source>The caller is now displayed in the &quot;additional message&quot; part of the trace output, and the following is displayed after a while:</source>
          <target state="translated">이제 발신자가 추적 출력의 &quot;추가 메시지&quot;부분에 표시되고 잠시 후 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c55c238696091394e0bd56b82b698a5c47bb3d12" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; can set a limit on the number of times the internal match() function is called and on the maximum depth of recursive calls. These facilities are provided to catch runaway matches that are provoked by patterns with huge matching trees (a typical example is a pattern with nested unlimited repeats) and to avoid running out of system stack by too much recursion. When one of these limits is reached, &lt;code&gt;pcre_exec()&lt;/code&gt; gives an error return. The limits can also be set by items at the start of the pattern of the following forms:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; 의 호출자는 내부 match () 함수가 호출되는 횟수와 최대 재귀 호출 깊이에 대한 제한을 설정할 수 있습니다. 이러한 기능은 거대한 일치하는 트리가있는 패턴 (일반적인 예는 중첩 된 무제한 반복이있는 패턴)에 의해 유발되는 런 어웨이 일치를 포착하고 너무 많은 재귀에 의해 시스템 스택이 부족하지 않도록하기 위해 제공됩니다. 이러한 제한 중 하나에 도달하면 &lt;code&gt;pcre_exec()&lt;/code&gt; 는 오류를 반환합니다. 다음 양식의 패턴 시작시 항목별로 제한을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f03c64f9f710de5955e68843c690db2e8c0fc8ca" translate="yes" xml:space="preserve">
          <source>The caller of &lt;code&gt;driver_create_port&lt;/code&gt; is allowed to manipulate the newly created port when &lt;code&gt;driver_create_port&lt;/code&gt; has returned. When &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; is used, the creating port is only allowed to manipulate the newly created port until the current driver callback, which was called by the emulator, returns.</source>
          <target state="translated">의 호출 &lt;code&gt;driver_create_port&lt;/code&gt; 이 때 새로 생성 된 포트를 조작 할 수있다 &lt;code&gt;driver_create_port&lt;/code&gt; 이 돌아왔다. 때 &lt;code&gt;&lt;a href=&quot;#smp_support&quot;&gt;port level locking&lt;/a&gt;&lt;/code&gt; 사용하는 경우, 생성 포트는 에뮬레이터, 반환에 의해 호출 된 현재 드라이버 콜백 할 때까지 새로 만든 포트를 조작 할 수있다.</target>
        </trans-unit>
        <trans-unit id="621fc2d91134d4db21b3517ae8ac3625fde2ce09" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">이 함수의 호출자는 &lt;code&gt;net_kernel&lt;/code&gt; 의 대표자 ( &lt;code&gt;net_kernel&lt;/code&gt; 로 등록 된 프로세스 일 수도 있고 아닐 수도 있음 ) 이며이 문서에서 &lt;code&gt;Kernel&lt;/code&gt; 로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="80825902e9ea39352717e07e7e143bd52944e894" translate="yes" xml:space="preserve">
          <source>The caller of this function is a representative for &lt;code&gt;net_kernel&lt;/code&gt; (this may or may not be the process registered as &lt;code&gt;net_kernel&lt;/code&gt;) and is in this document identified as &lt;code&gt;Kernel&lt;/code&gt;. When a connection has been accepted by the acceptor process, it needs to inform &lt;code&gt;Kernel&lt;/code&gt; about the accepted connection. This is done by passing a message on the form:</source>
          <target state="translated">이 함수의 호출자는 &lt;code&gt;net_kernel&lt;/code&gt; 의 대표자 ( &lt;code&gt;net_kernel&lt;/code&gt; 로 등록 된 프로세스 일 수도 있고 아닐 수도 있음 ) 이며이 문서에서 &lt;code&gt;Kernel&lt;/code&gt; 로 식별됩니다 . 수락 자 프로세스가 연결을 수락하면 수락 된 연결에 대해 &lt;code&gt;Kernel&lt;/code&gt; 에 알려야 합니다. 이것은 양식에 메시지를 전달하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="17dc5e2470f7e3eb401d50cfc358de49382160b2" translate="yes" xml:space="preserve">
          <source>The calling NIF must use the return value of &lt;code&gt;enif_schedule_nif&lt;/code&gt; as its own return value.</source>
          <target state="translated">호출 NIF는 리턴 값 &lt;code&gt;enif_schedule_nif&lt;/code&gt; 를 고유 한 리턴 값으로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b39ce61a3bf5f9ff14b9a7cd2356d7e2ed9376ab" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is aborted and &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">포트가 사용 중이면 호출 프로세스가 일시 중단되지 않고 대신 포트 명령이 중단되고 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ce0ba9d7309f260b173565ca438b3eeea1bd4473" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트가 사용 중이면 호출 프로세스가 일시 중단되지 않고 대신 포트 명령이 강제 실행됩니다. 포트 드라이버가이를 지원하지 않으면 &lt;code&gt;notsup&lt;/code&gt; 예외로 호출이 실패 합니다. 자세한 내용은 드라이버 플래그 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="629c5b3b630ae0172907db307b7e38fd8b753106" translate="yes" xml:space="preserve">
          <source>The calling process is not suspended if the port is busy, instead the port command is forced through. The call fails with a &lt;code&gt;notsup&lt;/code&gt; exception if the driver of the port does not support this. For more information, see driver flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">포트가 사용 중이면 호출 프로세스가 일시 중단되지 않고 포트 명령이 강제 실행됩니다. 포트 드라이버가이를 지원하지 않으면 &lt;code&gt;notsup&lt;/code&gt; 예외 와 함께 호출이 실패 합니다. 자세한 정보는 드라이버 플래그 &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;![CDATA[ERL_DRV_FLAG_SOFT_BUSY]]&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a1251fc069f821f07a282196dbe91995966e598" translate="yes" xml:space="preserve">
          <source>The calling process subscribes or unsubscribes to node status change messages. A &lt;code&gt;nodeup&lt;/code&gt; message is delivered to all subscribing processes when a new node is connected, and a &lt;code&gt;nodedown&lt;/code&gt; message is delivered when a node is disconnected.</source>
          <target state="translated">호출 프로세스는 노드 상태 변경 메시지를 구독하거나 구독 취소합니다. &lt;code&gt;nodeup&lt;/code&gt; 된 새 노드가 연결되었을 때 메시지가 모든 등록 프로세스로 전달되고, &lt;code&gt;nodedown&lt;/code&gt; 노드가 해제 될 때 메시지가 전달된다.</target>
        </trans-unit>
        <trans-unit id="3fd0eba81e7afeb40af7403b8df7ac0d5fe56351" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, &lt;code&gt;application&lt;/code&gt; configuration must be matched by corresponding &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; configuration, of *-Application-Id AVPs in particular.</source>
          <target state="translated">노드가 보급 한 기능은 구성된 응용 프로그램과 일치해야합니다. 특히 &lt;code&gt;application&lt;/code&gt; 구성은 특히 * -Application-Id AVP의 해당 &lt;code&gt;&lt;a href=&quot;#capability&quot;&gt;capability()&lt;/a&gt;&lt;/code&gt; 구성 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f7b2ec0f22afdbc01fa422caed0e98c532f9b08" translate="yes" xml:space="preserve">
          <source>The capabilities advertised by a node must match its configured applications. In particular, setting &lt;code&gt;applications&lt;/code&gt; on a transport typically implies having to set matching *-Application-Id AVPs in a &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; tuple.</source>
          <target state="translated">노드가 보급 한 기능은 구성된 응용 프로그램과 일치해야합니다. 특히, 전송에서 &lt;code&gt;applications&lt;/code&gt; 을 설정하는 것은 일반적으로 &lt;code&gt;&lt;a href=&quot;#capabilities&quot;&gt;capabilities()&lt;/a&gt;&lt;/code&gt; 튜플 에서 일치하는 * -Application-Id AVP를 설정해야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="172ff57f871dcdd5d0b54942cc29dbee89bb8d9d" translate="yes" xml:space="preserve">
          <source>The capture tuple is built up as follows:</source>
          <target state="translated">캡처 튜플은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="734624d49a0e505e194d0a3e203f3707e0a9ce89" translate="yes" xml:space="preserve">
          <source>The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below.</source>
          <target state="translated">잘린 UTF의 경우 특수하게 처리됩니다. 불완전한 이진에 대한 단락을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf787b1c131df12f5b5608740bbea97ec8c5c67e" translate="yes" xml:space="preserve">
          <source>The cases are executed in a sequence as described in section &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; in section Dependencies Between Test Cases and Suites.</source>
          <target state="translated">섹션에 설명 된대로의 경우는 순서대로 실행되는 &lt;code&gt;&lt;a href=&quot;dependencies_chapter#sequences&quot;&gt;Sequences&lt;/a&gt;&lt;/code&gt; 테스트 케이스 및 스위트 사이 섹션 종속성에.</target>
        </trans-unit>
        <trans-unit id="a67cf4e28458acef6485593f3479b26ebbee2e4f" translate="yes" xml:space="preserve">
          <source>The cases in the group are executed in random order.</source>
          <target state="translated">그룹의 사례는 무작위 순서로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="79326758fa4216db5c43f358f0c9d48cf3066915" translate="yes" xml:space="preserve">
          <source>The center area of the main window contains the information tabs. Each tab displays information about a specific item or a list of items. Select a tab by clicking the tab title.</source>
          <target state="translated">기본 창의 중앙 영역에는 정보 탭이 있습니다. 각 탭에는 특정 항목 또는 항목 목록에 대한 정보가 표시됩니다. 탭 제목을 클릭하여 탭을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="2e333bd4d7da78b5f5a1e212afc4f6afc672a38c" translate="yes" xml:space="preserve">
          <source>The certificate MUST allow the key to be used for signing with a signature scheme indicated in the client's &quot;signature_algorithms&quot;/&quot;signature_algorithms_cert&quot; extensions</source>
          <target state="translated">인증서는 클라이언트의 &quot;signature_algorithms&quot;/ &quot;signature_algorithms_cert&quot;확장에 표시된 서명 체계로 서명하는 데 키를 사용할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2b65e59eb08b76012cdc739d366b164e936d686" translate="yes" xml:space="preserve">
          <source>The certificate type MUST be X.509v3, unless explicitly negotiated otherwise</source>
          <target state="translated">명시 적으로 달리 협상하지 않는 한 인증서 유형은 X.509v3이어야합니다.</target>
        </trans-unit>
        <trans-unit id="136170ec67e23d4bdc746cf64630b0fc4f944a3d" translate="yes" xml:space="preserve">
          <source>The certificates MUST be signed using an acceptable signature algorithm</source>
          <target state="translated">인증서는 허용 가능한 서명 알고리즘을 사용하여 서명되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4592ee81cac18e24ff040ed72913569d66a68da6" translate="yes" xml:space="preserve">
          <source>The certificates attributes are valid.</source>
          <target state="translated">인증서 속성이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a7eaa8135e803f2fb327a77633a52bb48c129b5b" translate="yes" xml:space="preserve">
          <source>The chain consisted only of one self-signed certificate.</source>
          <target state="translated">체인은 하나의 자체 서명 된 인증서로만 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e0a9851e387d6b9bd8489d5d8385b78fdd1efbf" translate="yes" xml:space="preserve">
          <source>The change is permanent, as long as the log is not deleted. That means, the log size is remembered across reboots.</source>
          <target state="translated">로그가 삭제되지 않는 한 변경은 영구적입니다. 즉, 로그 크기는 재부팅시 기억됩니다.</target>
        </trans-unit>
        <trans-unit id="209a620344bc5ac686ada38b14f368934eb2469b" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 디스크 공간 확인 후 적용되며 비 지속적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7324d42150f9730491b8b6dcf07acbe2a4287488" translate="yes" xml:space="preserve">
          <source>The change will take effect after the next memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 메모리 검사 후에 적용되며 비 영구적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8308604a253081056bdf717b82fcf33a719c92f1" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next disk space check and is non-persist. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 디스크 공간 확인 중에 적용되며 비 지속적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9ee001de4f9c2acc5f959f9da7fbe9021fe19db" translate="yes" xml:space="preserve">
          <source>The change will take effect during the next periodic memory check and is non-persistent. That is, in case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음주기 메모리 점검 중에 적용되며 비 지속적입니다. 즉, 프로세스를 다시 시작할 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48592559cdd27064407e93ea03790b5d39d21da9" translate="yes" xml:space="preserve">
          <source>The change will take effect for the next memory check and is non-persistent. That is, in the case of a process restart, this value is forgotten and the default value will be used. See &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; above.</source>
          <target state="translated">변경 사항은 다음 메모리 검사에 적용되며 비 영구적입니다. 즉, 프로세스 재시작의 경우이 값을 잊어 버리고 기본값이 사용됩니다. 위의 &lt;code&gt;&lt;a href=&quot;#config&quot;&gt;Configuration&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a55eac8fba728a49ba83a1ba16426f587e19122" translate="yes" xml:space="preserve">
          <source>The changes do not affect existing child processes. For example, changing the start function only specifies how the child process is to be restarted, if needed later on.</source>
          <target state="translated">변경 사항은 기존 자식 프로세스에 영향을 미치지 않습니다. 예를 들어, 시작 기능을 변경하면 나중에 필요할 경우 하위 프로세스를 다시 시작하는 방법 만 지정합니다.</target>
        </trans-unit>
        <trans-unit id="17ef826dd60e0b23be9ebb72e959e4616f5a6f10" translate="yes" xml:space="preserve">
          <source>The channel behavior sends a close message to the other side, if such a message has not already been sent. Then it terminates the channel with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">해당 메시지가 아직 전송되지 않은 경우 채널 비헤이비어는 상대방에게 닫기 메시지를 보냅니다. 그런 다음 reason &lt;code&gt;normal&lt;/code&gt; 채널을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="2d0641d9544e5c0fe01329a75590e893fef99690" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Advanced Agent Topics&lt;/strong&gt; describes the more advanced agent related features of the SNMP development tool. The following topics are covered:</source>
          <target state="translated">&lt;strong&gt;고급 에이전트 주제&lt;/strong&gt; 장에서는 SNMP 개발 도구의 고급 에이전트 관련 기능에 대해 설명합니다. 다음과 같은 주제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="2e272ab9ddbed68131c16ba5014e291dc03d4f2d" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Audit Trail Log&lt;/strong&gt; describes the audit trail logging.</source>
          <target state="translated">&lt;strong&gt;감사 추적 로그&lt;/strong&gt; 장에서는 &lt;strong&gt;감사&lt;/strong&gt; 추적 로깅에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3f08decf0e83874ab43a9d84e18e36f372618712" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;Running the application&lt;/strong&gt; describes how the application is configured and started. The topics include:</source>
          <target state="translated">&lt;strong&gt;응용 프로그램 실행&lt;/strong&gt; 장에서는 응용 프로그램의 구성 및 시작 방법에 대해 설명합니다. 주제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72b08f124553e2dc5540039b611421ca2a1cb7f5" translate="yes" xml:space="preserve">
          <source>The chapter &lt;strong&gt;The MIB Compiler&lt;/strong&gt; describes the MIB compiler and contains the following topics:</source>
          <target state="translated">&lt;strong&gt;MIB 컴파일러&lt;/strong&gt; 장에서는 &lt;strong&gt;MIB 컴파일러에&lt;/strong&gt; 대해 설명하고 다음 주제를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d2d9fc11f8e7828565eb35f14517412a40b0d378" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;?&lt;/code&gt; can be added to the end of an operand to indicate that the operand will not be used every time the instruction is executed. For example:</source>
          <target state="translated">캐릭터 &lt;code&gt;?&lt;/code&gt; 명령이 실행될 때마다 피연산자가 사용되지 않음을 나타 내기 위해 피연산자 끝에 추가 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ddb91809478ddb72a376ffa2ae9889076265397b" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;C&lt;/code&gt; determines the type of control sequence to be used. It is the only required field. All of &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, &lt;code&gt;Pad&lt;/code&gt;, and &lt;code&gt;Mod&lt;/code&gt; are optional. For example, to use a &lt;code&gt;#&lt;/code&gt; for &lt;code&gt;Pad&lt;/code&gt; but use the default values for &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;, you can write &lt;code&gt;~..#C&lt;/code&gt;.</source>
          <target state="translated">문자 &lt;code&gt;C&lt;/code&gt; 는 사용될 제어 순서의 유형을 결정합니다. 유일한 필수 필드입니다. 모든 &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; , &lt;code&gt;Pad&lt;/code&gt; , 그리고 &lt;code&gt;Mod&lt;/code&gt; 선택 사항입니다. 예를 들어, &lt;code&gt;Pad&lt;/code&gt; 에는 &lt;code&gt;#&lt;/code&gt; 을 사용하고 &lt;code&gt;F&lt;/code&gt; 와 &lt;code&gt;P&lt;/code&gt; 에는 기본값을 사용하려면 &lt;code&gt;~..#C&lt;/code&gt; 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d64a4036522ec8f78050362f7b7c36c9cac056c3" translate="yes" xml:space="preserve">
          <source>The character encoding used in strings and atoms. The only supported encoding is &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; for ISO Latin-1 (8-bit ASCII).</source>
          <target state="translated">문자열과 원자에 사용되는 문자 인코딩. 지원되는 유일한 인코딩은 ISO Latin-1 (8 비트 ASCII)의 경우 &lt;code&gt;ERL_NIF_LATIN1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d193b1def3415cd7c10a5af19c4d201098e3350" translate="yes" xml:space="preserve">
          <source>The character encodings used for atoms. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; represents 7-bit ASCII. Latin-1 and UTF-8 are different extensions of 7-bit ASCII. All 7-bit ASCII characters are valid Latin-1 and UTF-8 characters. ASCII and Latin-1 both represent each character by one byte. An UTF-8 character can consist of 1-4 bytes. Notice that these constants are bit-flags and can be combined with bitwise OR.</source>
          <target state="translated">원자에 사용되는 문자 인코딩. &lt;code&gt;ERLANG_ASCII&lt;/code&gt; 는 7 비트 ASCII를 나타냅니다. 라틴 -1과 UTF-8은 7 비트 ASCII의 다른 확장입니다. 모든 7 비트 ASCII 문자는 유효한 Latin-1 및 UTF-8 문자입니다. ASCII와 Latin-1은 모두 각 문자를 1 바이트로 나타냅니다. UTF-8 문자는 1-4 바이트로 구성 될 수 있습니다. 이 상수는 비트 플래그이며 비트 OR과 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bce2007ce7233de084f6c74cc17834bdadef1f7" translate="yes" xml:space="preserve">
          <source>The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V, \w, and \W can appear in a character class, and add the characters that they match to the class. For example, [\dABCDEF] matches any hexadecimal digit. In UTF modes, option &lt;code&gt;ucp&lt;/code&gt; affects the meanings of \d, \s, \w and their uppercase partners, just as it does when they appear outside a character class, as described in section &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; earlier. The escape sequence \b has a different meaning inside a character class; it matches the backspace character. The sequences \B, \N, \R, and \X are not special inside a character class. Like any other unrecognized escape sequences, they are treated as the literal characters &quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and &quot;X&quot;.</source>
          <target state="translated">문자 이스케이프 시퀀스 \ d, \ D, \ h, \ H, \ p, \ P, \ s, \ S, \ v, \ V, \ w 및 \ W는 문자 클래스에 나타날 수 있으며 클래스와 일치하는 문자 예를 들어, [\ dABCDEF]는 16 진수와 일치합니다. UTF 모드에서 &lt;code&gt;ucp&lt;/code&gt; 옵션 은 \ d, \ s, \ w 및 대문자 파트너의 의미에 영향을 미칩니다 ( 이전의 &lt;code&gt;&lt;a href=&quot;#generic_character_types&quot;&gt;Generic Character Types&lt;/a&gt;&lt;/code&gt; 섹션에서 설명한대로 문자 클래스 외부에 나타날 때와 동일 함) . 이스케이프 시퀀스 \ b는 문자 클래스 내에서 다른 의미를 갖습니다. 백 스페이스 문자와 일치합니다. \ B, \ N, \ R 및 \ X 시퀀스는 문자 클래스 내에서 특별하지 않습니다. 인식 할 수없는 다른 이스케이프 시퀀스와 마찬가지로 리터럴 문자 &quot;B&quot;, &quot;N&quot;, &quot;R&quot;및 &quot;X&quot;로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="89f86657075f7d2532ecb276650adc58a9119d7f" translate="yes" xml:space="preserve">
          <source>The character used as time designator, that is, the date and time separator. The default is &lt;code&gt;$T&lt;/code&gt;.</source>
          <target state="translated">시간 지정자로 사용되는 문자, 즉 날짜 및 시간 구분 기호입니다. 기본값은 &lt;code&gt;$T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7d9d6c64abc51b03bd1675467e660789635b1bd" translate="yes" xml:space="preserve">
          <source>The characters in the line terminated by a line feed (or end of file). If the I/O device supports Unicode, the data can represent codepoints &amp;gt; 255 (the &lt;code&gt;latin1&lt;/code&gt; range). If the I/O server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O device supports Unicode).</source>
          <target state="translated">줄의 문자는 줄 바꿈 (또는 파일 끝)으로 끝납니다. I / O 장치가 유니 코드를 지원하는 경우 데이터는&amp;gt; 255 ( &lt;code&gt;latin1&lt;/code&gt; 범위)를 나타낼 수 있습니다 . I / O 서버가 바이너리를 전달하도록 설정된 경우, I / O 장치가 유니 코드를 지원하는지 여부에 관계없이 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="56bc68334532732a987644276bf7e27ba2ed6340" translate="yes" xml:space="preserve">
          <source>The characters in the name (if specified as a list) can only be &amp;gt; 255 if the Erlang virtual machine is started in Unicode filename translation mode. Otherwise the name of the executable is limited to the ISO Latin-1 character set.</source>
          <target state="translated">Erlang 가상 머신이 유니 코드 파일 이름 변환 모드에서 시작된 경우 이름의 문자 (목록으로 지정된 경우)는 255보다 클 수 있습니다. 그렇지 않으면 실행 파일 이름이 ISO Latin-1 문자 세트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4c340bb094927d6516a270b8c7260c59f1b0e9ac" translate="yes" xml:space="preserve">
          <source>The check for calls to undefined functions is an example of a predefined analysis, probably the most useful one. Other examples are the analyses that find unused local functions, or functions that call some given functions. See the &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; functions for a complete list of predefined analyses.</source>
          <target state="translated">정의되지 않은 함수 호출 확인은 사전 정의 된 분석의 예이며 아마도 가장 유용한 분석 일 것입니다. 다른 예로는 사용하지 않는 로컬 함수 또는 특정 함수를 호출하는 함수를 찾는 분석이 있습니다. 사전 정의 된 분석의 전체 목록은 &lt;code&gt;&lt;a href=&quot;xref#analyze&quot;&gt;analyze/2,3&lt;/a&gt;&lt;/code&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5e1916c5d50a9c907628d5b592b7e3e35726d5e" translate="yes" xml:space="preserve">
          <source>The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This can occur when nodes go down or when a replica is deleted. Checkpoints are also deactivated with this function. &lt;code&gt;Name&lt;/code&gt; is the name of an active checkpoint.</source>
          <target state="translated">체크 포인트는 관련된 테이블 중 일부에 보유자가없는 경우 자동으로 비활성화됩니다. 노드가 중단되거나 복제본이 삭제 될 때 발생할 수 있습니다. 이 기능으로 체크 포인트도 비활성화됩니다. &lt;code&gt;Name&lt;/code&gt; 은 활성화 된 체크 포인트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d9393d9861ac13bac497a84046277f971838af74" translate="yes" xml:space="preserve">
          <source>The checks performed before the boot script is generated can be extended with some cross reference checks by specifying option &lt;code&gt;exref&lt;/code&gt;. These checks are performed with the Xref tool. All applications, or the applications specified with &lt;code&gt;{exref,[App]}&lt;/code&gt;, are checked by Xref and warnings are issued for calls to undefined functions.</source>
          <target state="translated">부트 스크립트가 생성되기 전에 수행 된 검사는 &lt;code&gt;exref&lt;/code&gt; 옵션을 지정하여 일부 상호 참조 검사로 확장 될 수 있습니다 . 이러한 검사는 외부 참조 도구를 사용하여 수행됩니다. 모든 애플리케이션 또는 &lt;code&gt;{exref,[App]}&lt;/code&gt; 로 지정된 애플리케이션 은 외부 참조에 의해 검사되며 정의되지 않은 함수에 대한 호출에 대한 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="b71574456dfb07437b35ad062527dd44aa7aea5a" translate="yes" xml:space="preserve">
          <source>The child specification for a stopped child process is deleted with the following call:</source>
          <target state="translated">중지 된 하위 프로세스의 하위 스펙은 다음 호출로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="67c92024750696ea3d3e50b512e7251afc6c23fc" translate="yes" xml:space="preserve">
          <source>The children of a supervisor are defined as a list of &lt;strong&gt;child specifications&lt;/strong&gt;. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</source>
          <target state="translated">감독자의 &lt;strong&gt;자녀&lt;/strong&gt; 는 &lt;strong&gt;자녀 규격&lt;/strong&gt; 목록으로 정의됩니다 . 감독자가 시작되면이 목록에 따라 하위 프로세스가 왼쪽에서 오른쪽으로 순서대로 시작됩니다. 수퍼바이저가 종료되면 먼저 오른쪽에서 왼쪽으로 하위 프로세스를 시작 순서가 반대로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="51bde16b1e029fca3eb55c7bba60557bdc4ece36" translate="yes" xml:space="preserve">
          <source>The choice between stateful or stateless depends on the server requirements as the session tickets are opaque for the clients. Generally, stateful tickets are smaller and the server can guarantee that tickets are only used once. Stateless tickets contain additional data, require less storage on the server side, but they offer different guarantees against anti-replay. See also &lt;code&gt; Anti-Replay Protection in TLS 1.3&lt;/code&gt;</source>
          <target state="translated">세션 티켓이 클라이언트에 대해 불투명하므로 상태 저장 또는 상태 비 저장 중 선택은 서버 요구 사항에 따라 다릅니다. 일반적으로 상태 저장 티켓은 더 작고 서버는 티켓이 한 번만 사용되도록 보장 할 수 있습니다. 상태 비 저장 티켓은 추가 데이터를 포함하고 서버 측에서 더 적은 스토리지를 필요로하지만 재생 방지에 대해 다른 보장을 제공합니다. &lt;code&gt; Anti-Replay Protection in TLS 1.3&lt;/code&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="814de93894ad7aadf116db8d46dcb0a1a2f6a6fc" translate="yes" xml:space="preserve">
          <source>The choice of configuration alters the location and load order of the tables. The alternatives are as follows:</source>
          <target state="translated">구성을 선택하면 테이블의 위치와로드 순서가 변경됩니다. 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="545828e5805f31f0b4dc4f2a83912e6bb6d32eb0" translate="yes" xml:space="preserve">
          <source>The choice of using a chunk or the filesystem is completely up to the language or library. In both cases, the documentation can be added or removed at any moment by stripping the &lt;code&gt;Docs&lt;/code&gt; chunk or by removing the doc/chunks directory.</source>
          <target state="translated">청크 또는 파일 시스템 사용의 선택은 전적으로 언어 또는 라이브러리에 달려 있습니다. 두 경우 모두 &lt;code&gt;Docs&lt;/code&gt; 청크를 제거하거나 doc / chunks 디렉토리를 제거하여 언제든지 문서를 추가하거나 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfaabaea33a1559baea30876e0db48c230aa2c6c" translate="yes" xml:space="preserve">
          <source>The chosen solution is instead for tracing to use the technique of replication applied on the data structures for breakpoints. Two generations of breakpoints are kept and indentified by index of 0 and</source>
          <target state="translated">대신 선택한 솔루션은 중단 점을 위해 데이터 구조에 적용된 복제 기술을 사용하여 추적하는 것입니다. 두 세대의 중단 점이 유지되고 인덱스 0으로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="92e209681f18120979ec8cf62515a80ebbdd5369" translate="yes" xml:space="preserve">
          <source>The chunk size used by the Erlang fallback to send data. If using the fallback, set this to a value that comfortably fits in the systems memory. Default is 20 MB.</source>
          <target state="translated">Erlang 폴 백이 데이터를 전송하는 데 사용하는 청크 크기입니다. 폴백을 사용하는 경우 시스템 메모리에 편안한 값으로 설정하십시오. 기본값은 20MB입니다.</target>
        </trans-unit>
        <trans-unit id="80fc5d4e3e9d8bfc9a8f58b63d628ca694feebf8" translate="yes" xml:space="preserve">
          <source>The ciphers &lt;code&gt;aes_cbc&lt;/code&gt;, &lt;code&gt;aes_cfb8&lt;/code&gt;, &lt;code&gt;aes_cfb128&lt;/code&gt;, &lt;code&gt;aes_ctr&lt;/code&gt;, &lt;code&gt;aes_ecb&lt;/code&gt;, &lt;code&gt;aes_gcm&lt;/code&gt; and &lt;code&gt;aes_ccm&lt;/code&gt; has no keylength in the &lt;code&gt;Type&lt;/code&gt; as opposed to for example &lt;code&gt;aes_128_ctr&lt;/code&gt;. They adapt to the length of the key provided in the encrypt and decrypt function. Therefor it is impossible to return a valid keylength in the map.</source>
          <target state="translated">암호 &lt;code&gt;aes_cbc&lt;/code&gt; , &lt;code&gt;aes_cfb8&lt;/code&gt; , &lt;code&gt;aes_cfb128&lt;/code&gt; , &lt;code&gt;aes_ctr&lt;/code&gt; , &lt;code&gt;aes_ecb&lt;/code&gt; , &lt;code&gt;aes_gcm&lt;/code&gt; 및 &lt;code&gt;aes_ccm&lt;/code&gt; 에는 예를 들어 &lt;code&gt;aes_128_ctr&lt;/code&gt; 과 달리 &lt;code&gt;Type&lt;/code&gt; 에 키 길이 가 없습니다 . 암호화 및 암호 해독 기능에서 제공되는 키의 길이에 맞게 조정됩니다. 따라서 맵에서 유효한 키 길이를 반환하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="bffd1151a2b3988ada1265de3c714b941ea9eba2" translate="yes" xml:space="preserve">
          <source>The ciphers are:</source>
          <target state="translated">암호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b290d8f7cbf9ebc957458f968fe0fad53d55bb94" translate="yes" xml:space="preserve">
          <source>The circumflex and dollar metacharacters are zero-width assertions. That is, they test for a particular condition to be true without consuming any characters from the subject string.</source>
          <target state="translated">곡절 및 달러 메타 문자는 너비가 0 인 어설 션입니다. 즉, 주제 문자열에서 문자를 소비하지 않고 특정 조건이 참인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5669e2ea35917008527e37b5ca4d88fc5112fe65" translate="yes" xml:space="preserve">
          <source>The classic edit-compile-bugfix cycle for Erlang is to edit the source file in an editor, save it to a file and switch to an Erlang shell. In the shell the compilation command is given. Should the compilation fail you have to bring out the editor and locate the correct line.</source>
          <target state="translated">Erlang의 고전적인 편집-컴파일-버그 수정주기는 ​​편집기에서 소스 파일을 편집하고 파일로 저장 한 다음 Erlang 쉘로 전환하는 것입니다. 쉘에는 컴파일 명령이 제공됩니다. 컴파일이 실패하면 편집기를 꺼내고 올바른 줄을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="fadd4266630fc260a3b4ea69de0cd9a6f41365a8" translate="yes" xml:space="preserve">
          <source>The classification of &lt;code&gt;cached_memory&lt;/code&gt; is changed. Also memory marked as reclaimable in the kernel slab allocator will be added to the value presented as &lt;code&gt;cached_memory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cached_memory&lt;/code&gt; 의 분류 가 변경되었습니다. 또한 커널 슬랩 할당 자에서 회수 가능으로 표시된 메모리가 &lt;code&gt;cached_memory&lt;/code&gt; 로 표시된 값에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b037a6b9c798a6a67eb72fefb14eec4bbb6f1f1d" translate="yes" xml:space="preserve">
          <source>The client automatically retrieves the information from the new URI and returns that as the result, instead of a 30X-result code.</source>
          <target state="translated">클라이언트는 자동으로 새 URI에서 정보를 검색하여 결과로 30X 결과 코드 대신 해당 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fbe84685ac1a559531b7c36291fb36841fab94a" translate="yes" xml:space="preserve">
          <source>The client can be stopped using &lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; or &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inets:stop(httpc, Pid)&lt;/code&gt; 또는 &lt;code&gt;inets:stop(httpc, Profile)&lt;/code&gt; 사용하여 클라이언트를 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="569ccd940c4f6a817b12bba1b1067ae1a9656ffb" translate="yes" xml:space="preserve">
          <source>The client can choose to accept some path evaluation errors, for example, a web browser can ask the user whether to accept an unknown CA root certificate. The server, if it requests a certificate, does however not accept any path validation errors. It is configurable if the server is to accept or reject an &quot;empty&quot; certificate as response to a certificate request.</source>
          <target state="translated">클라이언트는 경로 평가 오류를 허용하도록 선택할 수 있습니다. 예를 들어, 웹 브라우저는 사용자에게 알 수없는 CA 루트 인증서를 수락할지 여부를 묻습니다. 그러나 서버가 인증서를 요청하면 경로 유효성 검사 오류를 허용하지 않습니다. 서버가 인증서 요청에 대한 응답으로 &quot;빈&quot;인증서를 수락하거나 거부하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e096fcf12a451f0d8ba37109ec7b8520e84ee7a" translate="yes" xml:space="preserve">
          <source>The client checks that the host that presented the public key also possesses the private key of the key-pair. That check is part of the SSH protocol.</source>
          <target state="translated">클라이언트는 공개 키를 제공 한 호스트가 키 쌍의 개인 키도 소유하고 있는지 확인합니다. 이 검사는 SSH 프로토콜의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="c1b412fb6f7f703ee2ef8dff66ba99951cf7089b" translate="yes" xml:space="preserve">
          <source>The client is any Erlang process wishing to read or write data from/to the I/O device.</source>
          <target state="translated">클라이언트는 I / O 장치에서 데이터를 읽거나 쓰는 Erlang 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="c1f2e8007b5292b585147076187f8ae466cd3c94" translate="yes" xml:space="preserve">
          <source>The client processes has done some illegal operation.</source>
          <target state="translated">클라이언트 프로세스가 잘못된 작업을 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="9a26517024410b148cd294e33b877a64e550bcc2" translate="yes" xml:space="preserve">
          <source>The client remote username (&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">클라이언트 원격 사용자 이름 ( &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc931.txt&quot;&gt;RFC 931&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="41327174b5c9bc729859a7f6bf3b5c175db7b9d0" translate="yes" xml:space="preserve">
          <source>The client sends an &lt;code&gt;io_request&lt;/code&gt; tuple to the I/O server and the server eventually sends a corresponding &lt;code&gt;io_reply&lt;/code&gt; tuple.</source>
          <target state="translated">클라이언트는 &lt;code&gt;io_request&lt;/code&gt; 튜플을 I / O 서버로 보내고 서버는 결국 해당 &lt;code&gt;io_reply&lt;/code&gt; 튜플을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="0f8f061d93662344f07374622d9a9f5570dc6915" translate="yes" xml:space="preserve">
          <source>The client sends the message to the server by:</source>
          <target state="translated">클라이언트는 다음을 통해 서버에 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="072bdecf1b9485830f32e0b9aaa2f2cd201b4643" translate="yes" xml:space="preserve">
          <source>The client supports IPv6 as long as the underlying mechanisms also do so.</source>
          <target state="translated">기본 메커니즘도 지원하는 한 클라이언트는 IPv6을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f39527c54a4e7962b71c62198072191bb4f4c11d" translate="yes" xml:space="preserve">
          <source>The client will send a signature_algorithms_cert extension (ClientHello), if TLS version 1.3 or later is used, and the signature_algs_cert option is explicitly specified. By default, only the signature_algs extension is sent.</source>
          <target state="translated">TLS 버전 1.3 이상이 사용되고 signature_algs_cert 옵션이 명시 적으로 지정된 경우 클라이언트는 signature_algorithms_cert 확장 (ClientHello)을 보냅니다. 기본적으로 signature_algs 확장 만 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5795d28810329b4419d272a646663a21aa527543" translate="yes" xml:space="preserve">
          <source>The client-server model is characterized by a central server and an arbitrary number of clients. The client-server model is used for resource management operations, where several different clients want to share a common resource. The server is responsible for managing this resource.</source>
          <target state="translated">클라이언트-서버 모델은 중앙 서버와 임의의 수의 클라이언트로 구성됩니다. 클라이언트-서버 모델은 여러 다른 클라이언트가 공통 리소스를 공유하려는 리소스 관리 작업에 사용됩니다. 서버는이 자원을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="b8d268ee82b336a5c95688dda8482335e48cf69d" translate="yes" xml:space="preserve">
          <source>The clients ip address.</source>
          <target state="translated">클라이언트 IP 주소.</target>
        </trans-unit>
        <trans-unit id="a98219544eb3eff51a663b1a744e3bf13062abc6" translate="yes" xml:space="preserve">
          <source>The clock starts ticking when the request is sent.</source>
          <target state="translated">요청이 전송되면 시계가 똑딱 거리기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="be435ecc0cf1fa1a9c98c5cd0695f7dfa36eec57" translate="yes" xml:space="preserve">
          <source>The clone of the SSL application must enable the use of the SSL code in such an early bootstage as needed to set up the distribution. However, this makes it impossible to soft upgrade the SSL application.</source>
          <target state="translated">SSL 응용 프로그램의 복제본은 배포를 설정하는 데 필요한 초기 부팅 단계에서 SSL 코드를 사용할 수 있도록해야합니다. 그러나 이로 인해 SSL 응용 프로그램을 소프트 업그레이드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d756129312a76f266001381d64eeed8865f4919a" translate="yes" xml:space="preserve">
          <source>The code for a module can exist in two variants in a system: &lt;strong&gt;current code&lt;/strong&gt; and &lt;strong&gt;old code&lt;/strong&gt;. When a module is loaded into the system for the first time, the module code becomes 'current' and the global &lt;strong&gt;export table&lt;/strong&gt; is updated with references to all functions exported from the module.</source>
          <target state="translated">모듈의 코드는 시스템에서 &lt;strong&gt;현재 코드&lt;/strong&gt; 와 &lt;strong&gt;이전 코드의&lt;/strong&gt; 두 가지 변형으로 존재할 수 있습니다 . 모듈이 시스템에 처음으로로드되면 모듈 코드는 '현재'가되고 전역 &lt;strong&gt;내보내기 테이블&lt;/strong&gt; 은 모듈에서 내 보낸 모든 함수에 대한 참조로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e2397fc7367abe891aaddea1acfb84a0e33bbb71" translate="yes" xml:space="preserve">
          <source>The code for the server can be rewritten into a generic part &lt;code&gt;server.erl&lt;/code&gt;:</source>
          <target state="translated">서버 코드는 일반적인 부분 &lt;code&gt;server.erl&lt;/code&gt; 로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e4cf743be10d1f78796a8520fbbc62b88613fb4" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;error_handler&lt;/code&gt; is complex. Do not change it without fully understanding the interaction between the error handler, the &lt;code&gt;init&lt;/code&gt; process of the code server, and the I/O mechanism of the code.</source>
          <target state="translated">&lt;code&gt;error_handler&lt;/code&gt; 의 코드 는 복잡합니다. 오류 처리기, 코드 서버 의 &lt;code&gt;init&lt;/code&gt; 프로세스 및 코드의 I / O 메커니즘 간의 상호 작용을 완전히 이해하지 않고 변경하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="90cb7656e2a78a30cae10868a6acccf8aa88d091" translate="yes" xml:space="preserve">
          <source>The code in &lt;code&gt;server&lt;/code&gt; can be reused to build many different servers.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 의 코드는 많은 다른 서버를 구축하기 위해 재사용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04225ffb5d1e2cd3c54d5a022ccc010d6c271db5" translate="yes" xml:space="preserve">
          <source>The code is available in &lt;code&gt;pg_sync.c&lt;/code&gt; in the &lt;code&gt;sample&lt;/code&gt; directory of &lt;code&gt;erts&lt;/code&gt;.</source>
          <target state="translated">코드에서 사용할 수 &lt;code&gt;pg_sync.c&lt;/code&gt; 에서 &lt;code&gt;sample&lt;/code&gt; 디렉토리 &lt;code&gt;erts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9264957f8945993653ce298e5c1234e15d08f23" translate="yes" xml:space="preserve">
          <source>The code is explained in the next sections.</source>
          <target state="translated">코드는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0e3333c77c7ae219d3009900b602e3b49e21c916" translate="yes" xml:space="preserve">
          <source>The code is straightforward: all communication between Erlang and the driver is done with &lt;code&gt;port_control/3&lt;/code&gt;, and the driver returns data back using the &lt;code&gt;rbuf&lt;/code&gt;.</source>
          <target state="translated">얼랑와 드라이버 사이의 모든 통신이 이루어집니다 : 코드는 간단하다 &lt;code&gt;port_control/3&lt;/code&gt; 및 드라이버를 반환 데이터를 사용하여 백업 &lt;code&gt;rbuf&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f043529a1b5d337526e7bf30093ae19b9989356b" translate="yes" xml:space="preserve">
          <source>The code must return:</source>
          <target state="translated">코드는 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="507745f725c946f3bb38fa59ee9580fa6d304cd3" translate="yes" xml:space="preserve">
          <source>The code of a module can exist in two variants in a system: &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;. When a module is loaded into the system for the first time, the code becomes 'current'. If then a new instance of the module is loaded, the code of the previous instance becomes 'old' and the new instance becomes 'current'.</source>
          <target state="translated">모듈의 코드는 시스템에서 &lt;strong&gt;current&lt;/strong&gt; 와 &lt;strong&gt;old의&lt;/strong&gt; 두 가지 변형으로 존재할 수 있습니다 . 모듈이 시스템에 처음으로로드되면 코드는 '현재'가됩니다. 그런 다음 모듈의 새 인스턴스가로드되면 이전 인스턴스의 코드가 '이전'이되고 새 인스턴스가 '현재'가됩니다.</target>
        </trans-unit>
        <trans-unit id="922b2eb4a931c1204aa3e51a063d0b9c833303d1" translate="yes" xml:space="preserve">
          <source>The code path can be extended by using the command-line flags &lt;code&gt;-pa Directories&lt;/code&gt; and &lt;code&gt;-pz Directories&lt;/code&gt;. These add &lt;code&gt;Directories&lt;/code&gt; to the head or the end of the code path, respectively. Example:</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-pa Directories&lt;/code&gt; 및 &lt;code&gt;-pz Directories&lt;/code&gt; 를 사용하여 코드 경로를 확장 할 수 있습니다 . 이들은 각각 코드 경로의 헤드 또는 끝에 &lt;code&gt;Directories&lt;/code&gt; 를 추가 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="9688469fe16d88facce2f69f4687ce1df4ec41a4" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt; System Principles &lt;/code&gt;.</source>
          <target state="translated">코드 서버는 &lt;strong&gt;대화 형&lt;/strong&gt; (기본값) 또는 &lt;strong&gt;포함 된&lt;/strong&gt; 코드로드 전략에 따라 코드를로드 합니다. 대화 형 모드에서는 &lt;strong&gt;코드 경로&lt;/strong&gt; 에서 코드가 검색 되고 처음 참조 될 때로드됩니다. 임베디드 모드에서는 &lt;strong&gt;부팅 스크립트&lt;/strong&gt; 에 따라 시작시 코드가로드됩니다 . 이는 &lt;code&gt; System Principles &lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f2de033652fb4852b04d98599da41645cd5418" translate="yes" xml:space="preserve">
          <source>The code server loads code according to a code loading strategy, which is either &lt;strong&gt;interactive&lt;/strong&gt; (default) or &lt;strong&gt;embedded&lt;/strong&gt;. In interactive mode, code is searched for in a &lt;strong&gt;code path&lt;/strong&gt; and loaded when first referenced. In embedded mode, code is loaded at start-up according to a &lt;strong&gt;boot script&lt;/strong&gt;. This is described in &lt;code&gt;System Principles&lt;/code&gt;.</source>
          <target state="translated">코드 서버는 코드로드 전략에 따라 코드를로드하며, 이는 &lt;strong&gt;대화 형&lt;/strong&gt; (기본값) 또는 &lt;strong&gt;임베디드&lt;/strong&gt; 입니다. 대화식 모드에서 코드는 &lt;strong&gt;코드 경로&lt;/strong&gt; 에서 검색되어 처음 참조 될 때로드됩니다. 내장 모드에서는 &lt;strong&gt;부팅 스크립트&lt;/strong&gt; 에 따라 시작시 코드가로드됩니다 . 이것은 &lt;code&gt;System Principles&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c79fc2d0738d58b971f65c1fecd5a663cbf7ff9" translate="yes" xml:space="preserve">
          <source>The code server module &lt;code&gt;code&lt;/code&gt; contains a number of functions for modifying and checking the search path, see the &lt;code&gt;code(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">코드 서버 모듈 &lt;code&gt;code&lt;/code&gt; 에는 검색 경로를 수정하고 확인하기위한 여러 기능이 포함되어 있습니다 . 커널 의 &lt;code&gt;code(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="33c6dc6ea8623b6f6923c8e2b31c4332f8ba122e" translate="yes" xml:space="preserve">
          <source>The code server uses &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; to find the directory of the current (latest) version of Kernel, and then the subdirectory &lt;code&gt;include&lt;/code&gt; is searched for the file &lt;code&gt;file.hrl&lt;/code&gt;.</source>
          <target state="translated">코드 서버는 &lt;code&gt;code:lib_dir(kernel)&lt;/code&gt; 을 사용하여 현재 (최신) 커널 버전의 디렉토리 를 찾은 다음, 서브 디렉토리 &lt;code&gt;include&lt;/code&gt; 에서 &lt;code&gt;file.hrl&lt;/code&gt; 파일을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="705518a26a45215c147f7cfa28bbb3c76f850d6e" translate="yes" xml:space="preserve">
          <source>The code server uses module &lt;code&gt;erl_prim_loader&lt;/code&gt; in ERTS (possibly through &lt;code&gt;erl_boot_server&lt;/code&gt;) to read code files from archives. However, the functions in &lt;code&gt;erl_prim_loader&lt;/code&gt; can also be used by other applications to read files from archives. For example, the call &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; would list the contents of a directory inside an archive. See &lt;code&gt;erl_prim_loader(3)&lt;/code&gt;.</source>
          <target state="translated">코드 서버는 ERTS의 &lt;code&gt;erl_prim_loader&lt;/code&gt; 모듈 ( erl_boot_server 를 통해 &lt;code&gt;erl_boot_server&lt;/code&gt; )을 사용하여 아카이브에서 코드 파일을 읽습니다. 그러나 &lt;code&gt;erl_prim_loader&lt;/code&gt; 의 기능 을 다른 응용 프로그램에서 사용하여 아카이브에서 파일을 읽을 수도 있습니다. 예를 들어, &lt;code&gt;erl_prim_loader:list_dir( &quot;/otp/root/lib/mnesia-4.4.7.ez/mnesia-4.4.7/examples/bench)&quot;&lt;/code&gt; 호출 은 아카이브 내의 디렉토리 내용을 나열합니다. &lt;code&gt;erl_prim_loader(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b81d555b71a144677a82f4345434092ac25f42ef" translate="yes" xml:space="preserve">
          <source>The code that creates a process that runs this tracer function and sets that process as the system tracer can look like this:</source>
          <target state="translated">이 추적 프로그램 기능을 실행하는 프로세스를 작성하고 해당 프로세스를 시스템 추적 프로그램으로 설정하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01443bf8a10ddd3106bef27d3577d522575836f5" translate="yes" xml:space="preserve">
          <source>The code that executes inside the activity can consist of a series of table manipulation functions, which are performed in an &lt;code&gt;AccessContext&lt;/code&gt;. Currently, the following access contexts are supported:</source>
          <target state="translated">활동 내에서 실행되는 코드는 &lt;code&gt;AccessContext&lt;/code&gt; 에서 수행되는 일련의 테이블 조작 함수로 구성 될 수 있습니다 . 현재 다음과 같은 액세스 컨텍스트가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="84b1eccbd4506c4d8f052231d9e0606cf91a8b80" translate="yes" xml:space="preserve">
          <source>The code that executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is terminated and the function &lt;code&gt;transaction/1&lt;/code&gt; returns the tuple &lt;code&gt;{aborted, Reason}&lt;/code&gt;.</source>
          <target state="translated">트랜잭션 내에서 실행되는 코드는 일련의 테이블 조작 함수로 구성 될 수 있습니다. 사용자 오류 또는 특정 테이블을 사용할 수 없어서 트랜잭션 내부에 문제가 발생하면 전체 트랜잭션이 종료되고 &lt;code&gt;transaction/1&lt;/code&gt; 함수는 튜플 &lt;code&gt;{aborted, Reason}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a0cdd80f24fdd34e8443becb251df980268f8ee4" translate="yes" xml:space="preserve">
          <source>The code uses the &lt;code&gt;OTP_RELEASE&lt;/code&gt; macro to conditionally select code depending on release.</source>
          <target state="translated">이 코드는 &lt;code&gt;OTP_RELEASE&lt;/code&gt; 매크로를 사용하여 릴리스에 따라 조건부로 코드를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="30306274860dd65567cf17418a71525ff9fb2984" translate="yes" xml:space="preserve">
          <source>The code write permission &quot;lock&quot; seized in step 1 is the same as used by code loading. This will ensure that only one process at a time can stage new trace settings but it will also prevent concurrent code loading and make sure we see a consistent view of the beam code during the entire sequence.</source>
          <target state="translated">1 단계에서 확보 한 코드 쓰기 권한 &quot;잠금&quot;은 코드로드에서 사용한 것과 동일합니다. 이렇게하면 한 번에 하나의 프로세스 만 새로운 트레이스 설정을 준비 할 수 있지만 동시 코드로드를 방지하고 전체 시퀀스 동안 빔 코드의 일관된보기를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b9b7b5c18b986e4dcb6724716523fe3e0859402" translate="yes" xml:space="preserve">
          <source>The codec name is the name of the codec with which all messages in the &lt;code&gt;message_list()&lt;/code&gt; has been encoded.</source>
          <target state="translated">코덱 이름은 &lt;code&gt;message_list()&lt;/code&gt; 의 모든 메시지 가 인코딩 된 코덱의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="95a66f00b0729fc83f03c227254f16b97fe36011" translate="yes" xml:space="preserve">
          <source>The codes are named as &lt;code&gt;SSH_FX_*&lt;/code&gt; which are transformed into lowercase of the star-part. E.g. the error code &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; will cause the &lt;code&gt;reason()&lt;/code&gt; to be &lt;code&gt;no_such_file&lt;/code&gt;.</source>
          <target state="translated">코드 이름 은 별표의 소문자로 변환되는 &lt;code&gt;SSH_FX_*&lt;/code&gt; 로 지정됩니다 . 예를 들어 오류 코드 &lt;code&gt;SSH_FX_NO_SUCH_FILE&lt;/code&gt; 은 &lt;code&gt;reason()&lt;/code&gt; 이 &lt;code&gt;no_such_file&lt;/code&gt; 이 되도록 합니다.</target>
        </trans-unit>
        <trans-unit id="17206be2c27dcf13c38e698754daddf2e853496a" translate="yes" xml:space="preserve">
          <source>The collector collects trace events and keeps them ordered by their timestamp. The timestamp may either reflect the time when the actual trace data was generated (trace_ts) or when the trace data was transformed into an event record (event_ts). If the time stamp is missing in the trace data (missing timestamp option to erlang:trace/4) the trace_ts will be set to the event_ts.</source>
          <target state="translated">수집기는 추적 이벤트를 수집하여 타임 스탬프별로 정렬합니다. 타임 스탬프는 실제 추적 데이터가 생성 된 시간 (trace_ts) 또는 추적 데이터가 이벤트 레코드 (event_ts)로 변환 된 시간을 반영 할 수 있습니다. 추적 데이터에서 타임 스탬프가 누락 된 경우 (타임 스탬프 옵션이 erlang : trace / 4로 누락 됨) trace_ts가 event_ts로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="351503ceae71d258dda945d06961ceabf3006742" translate="yes" xml:space="preserve">
          <source>The collector has a built-in dictionary service. Any term may be stored as value in the dictionary and bound to a unique key. When new values are inserted with an existing key, the new values will overwrite the existing ones. Processes may subscribe on dictionary updates by using {subscriber, pid()} as dictionary key. All dictionary updates will be propagated to the subscriber processes matching the pattern {{subscriber, '_'}, '_'} where the first '_' is interpreted as a pid().</source>
          <target state="translated">수집기에는 기본 제공 사전 서비스가 있습니다. 모든 용어는 사전에 값으로 저장되어 고유 키에 바인딩 될 수 있습니다. 기존 키로 새 값을 삽입하면 새 값이 기존 값을 덮어 씁니다. 프로세스는 {subscriber, pid ()}를 사전 키로 사용하여 사전 업데이트를 구독 할 수 있습니다. 모든 사전 업데이트는 {{구독자, '_'}, '_'} 패턴과 일치하는 구독자 프로세스로 전파되며 여기서 첫 번째 '_'는 pid ()로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="aa24630865ec2d27852697992e86dceb8f652e0b" translate="yes" xml:space="preserve">
          <source>The column where the token begins.</source>
          <target state="translated">토큰이 시작되는 열입니다.</target>
        </trans-unit>
        <trans-unit id="630fd19e25bb44d0c633fc41e9f2c893976f1cf6" translate="yes" xml:space="preserve">
          <source>The columns are: CNT - the number of times the function has been called, ACC - the time spent in the function including called functions, and OWN - the time spent in the function not including called functions.</source>
          <target state="translated">CNT-함수가 호출 된 횟수, ACC-호출 된 함수를 포함한 함수에 소요 된 시간 및 OWN-호출 된 함수를 포함하지 않는 함수에 소비 된 시간.</target>
        </trans-unit>
        <trans-unit id="dba186e396734b41173da2352f4bdf8aa2299d12" translate="yes" xml:space="preserve">
          <source>The combined size of message buffers associated with the process.</source>
          <target state="translated">프로세스와 연관된 메시지 버퍼의 결합 된 크기입니다.</target>
        </trans-unit>
        <trans-unit id="cd9eaf4fbf041c4980649b3adc6f08d99e41387b" translate="yes" xml:space="preserve">
          <source>The command for starting the emulator. Defaults to &lt;code&gt;erl&lt;/code&gt; in the same directory as the &lt;code&gt;erlc&lt;/code&gt; program itself, or, if it does not exist, &lt;code&gt;erl&lt;/code&gt; in any of the directories specified in environment variable &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">에뮬레이터를 시작하는 명령입니다. 기본값 은 &lt;code&gt;erlc&lt;/code&gt; 프로그램 자체 와 동일한 디렉토리에서 &lt;code&gt;erl&lt;/code&gt; 로 설정 되거나 존재하지 않는 경우 환경 변수 &lt;code&gt;PATH&lt;/code&gt; 에 지정된 디렉토리에서 &lt;code&gt;erl&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb6501b3dc9f9f189fcbf95012d0127834e2f9cf" translate="yes" xml:space="preserve">
          <source>The command routine takes three parameters; the handle returned for the port by &lt;code&gt;uds_start&lt;/code&gt;, which is a pointer to the internal port structure, the data buffer, and the length of the data buffer. The buffer is the data sent from Erlang (a list of bytes) converted to an C array (of bytes).</source>
          <target state="translated">명령 루틴에는 세 가지 매개 변수가 있습니다. 내부 포트 구조, 데이터 버퍼 및 데이터 버퍼 길이에 대한 포인터 인 &lt;code&gt;uds_start&lt;/code&gt; 가 포트에 대해 리턴 한 핸들 버퍼는 Erlang (바이트 목록)에서 C 배열 (바이트)로 변환 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="aefc7b65db056c9f7f1b6802b3b0d8045a51356b" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the SSL/TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="translated">SSL / TLS 옵션을 지정하기위한 명령 행 인수의 이름은 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 이며 그 뒤에 SSL 옵션 쌍과 값 이옵니다 . 인수 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 는 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feabeafa48780ef513e8f91d43f78fb2ecb53e4a" translate="yes" xml:space="preserve">
          <source>The command-line argument for specifying the TLS options is named &lt;code&gt;-ssl_dist_opt&lt;/code&gt; and is to be followed by pairs of SSL options and their values. Argument &lt;code&gt;-ssl_dist_opt&lt;/code&gt; can be repeated any number of times.</source>
          <target state="translated">TLS 옵션을 지정하기위한 명령 줄 인수의 이름은 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 이며 그 뒤에 SSL 옵션 쌍과 해당 값 이옵니다 . 인수 &lt;code&gt;-ssl_dist_opt&lt;/code&gt; 는 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef15ee0f0b965418b78c604ce208be1ebb9ac987" translate="yes" xml:space="preserve">
          <source>The command-line flag &lt;code&gt;-init_debug&lt;/code&gt; makes the &lt;code&gt;init&lt;/code&gt; process write some debug information while interpreting the boot script:</source>
          <target state="translated">명령 행 플래그 &lt;code&gt;-init_debug&lt;/code&gt; 는 &lt;code&gt;init&lt;/code&gt; 프로세스가 부트 스크립트를 해석하는 동안 디버그 정보를 작성하게합니다.</target>
        </trans-unit>
        <trans-unit id="b095d3532fdf5b6b34b9ca43172bd2a70ed42870" translate="yes" xml:space="preserve">
          <source>The commands below are the built-in shell commands that are always available. In most system the commands listed in the &lt;code&gt;&lt;a href=&quot;c&quot;&gt;c(3)&lt;/a&gt;&lt;/code&gt; module are also available in the shell.</source>
          <target state="translated">아래 명령은 항상 사용할 수있는 내장 셸 명령입니다. 대부분의 시스템에서 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;c(3)&lt;/a&gt;&lt;/code&gt; 모듈에 나열된 명령 은 셸에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c50b8e09545158899f6b79057dc3ebb405cca8" translate="yes" xml:space="preserve">
          <source>The comment for &lt;code&gt;driver_output_binary&lt;/code&gt; also applies for &lt;code&gt;driver_outputv&lt;/code&gt;.</source>
          <target state="translated">에 대한 의견 &lt;code&gt;driver_output_binary&lt;/code&gt; 는 또한 적용 &lt;code&gt;driver_outputv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1280084aa272a9d5d8e48fb9a3f8a4bc2a35a205" translate="yes" xml:space="preserve">
          <source>The comment for the file in the zip archive</source>
          <target state="translated">zip 아카이브에있는 파일에 대한 주석</target>
        </trans-unit>
        <trans-unit id="576cdebf96e8a6e4c9f5687b31e5fae369f7ae54" translate="yes" xml:space="preserve">
          <source>The common I/O protocol has been present in OTP since the beginning, but has been undocumented and has also evolved over the years. In an addendum to Robert Virding's rationale, the original I/O protocol is described. This section describes the current I/O protocol.</source>
          <target state="translated">일반적인 I / O 프로토콜은 처음부터 OTP에 존재했지만 문서화되지 않았으며 수년에 걸쳐 발전해 왔습니다. Robert Virding의 이론적 근거에 대한 부록에서 원래 I / O 프로토콜이 설명됩니다. 이 섹션에서는 현재 I / O 프로토콜에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="615ef8c10dad53dc0e37ab3cc2865c03f16fe578" translate="yes" xml:space="preserve">
          <source>The communication protocol between sub-agents is the normal message passing which is used in distributed Erlang systems. This implies that sub-agent communication is very efficient compared to SMUX, DPI, AgentX, and similar protocols.</source>
          <target state="translated">하위 에이전트 간의 통신 프로토콜은 분산 Erlang 시스템에서 사용되는 일반적인 메시지 전달입니다. 이는 하위 에이전트 통신이 SMUX, DPI, AgentX 및 유사한 프로토콜에 비해 매우 효율적이라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="95e038ffe06742bd9a3eacaa7f1ab1768afde277" translate="yes" xml:space="preserve">
          <source>The community information should be stored in a file called &lt;code&gt;community.conf&lt;/code&gt;. It must be present if the agent is configured for SNMPv1 or SNMPv2c.</source>
          <target state="translated">커뮤니티 정보라는 파일에 저장해야 &lt;code&gt;community.conf&lt;/code&gt; . 에이전트가 SNMPv1 또는 SNMPv2c에 대해 구성된 경우 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae1b5318f7be646ee745ed8d6cfbf8aaace9d57c" translate="yes" xml:space="preserve">
          <source>The compilation option &lt;code&gt;debug_info&lt;/code&gt; can be specified to the compiler to have the abstract code stored in the &lt;code&gt;abstract_code&lt;/code&gt; chunk in the Beam file (for debugging purposes).</source>
          <target state="translated">컴파일 옵션 &lt;code&gt;debug_info&lt;/code&gt; 는 컴파일러에 지정되어 추상 코드 가 Beam 파일 의 &lt;code&gt;abstract_code&lt;/code&gt; 청크에 저장 되도록 할 수 있습니다 (디버깅 목적으로).</target>
        </trans-unit>
        <trans-unit id="63df141c1104124fe397af774c48987f851c9c8e" translate="yes" xml:space="preserve">
          <source>The compile server can be used to potentially speed up the build of multi-file projects by avoiding to start an Erlang system for each file to compile. Whether it will speed up the build depends on the nature of the project and the build machine.</source>
          <target state="translated">컴파일 서버는 컴파일 할 각 파일에 대해 Erlang 시스템을 시작하는 것을 피함으로써 잠재적으로 다중 파일 프로젝트의 빌드 속도를 높이는 데 사용할 수 있습니다. 빌드 속도를 높일 지 여부는 프로젝트 및 빌드 머신의 특성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="992839cad735d18aaa4ef05287e210db80780266" translate="yes" xml:space="preserve">
          <source>The compile time of the emulator running the originating node</source>
          <target state="translated">시작 노드를 실행하는 에뮬레이터의 컴파일 시간</target>
        </trans-unit>
        <trans-unit id="77923285d15f6d1638ca1085b0ea9ec5d8971d25" translate="yes" xml:space="preserve">
          <source>The compiled files of the imported MIBs must be present in the current directory, or a directory in the current path. The path is supplied with the &lt;code&gt;{i, Path}&lt;/code&gt; option, for example:</source>
          <target state="translated">가져온 MIB의 컴파일 된 파일은 현재 디렉토리 또는 현재 경로의 디렉토리에 있어야합니다. 경로는 &lt;code&gt;{i, Path}&lt;/code&gt; 옵션 과 함께 제공됩니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="6fb2caaa7af06a5fa0ebe6a620c35148002139db" translate="yes" xml:space="preserve">
          <source>The compiler also understands that assigning to '_' means that the value will not used. Therefore, the code in the following example will also be optimized:</source>
          <target state="translated">또한 컴파일러는 '_'에 할당하면 값이 사용되지 않음을 이해합니다. 따라서 다음 예제의 코드도 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="a0aa4f7feea676dc9f8b66e36fffc1af3c1c40f5" translate="yes" xml:space="preserve">
          <source>The compiler and other compile-time functions can also be started from the Erlang shell. Here follows a brief description of the primary functions. For a complete description of each function, see module &lt;code&gt;asn1ct&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컴파일러 및 기타 컴파일 타임 함수는 Erlang 쉘에서 시작할 수도 있습니다. 다음은 주요 기능에 대한 간략한 설명입니다. 각 기능에 대한 자세한 설명은 &lt;code&gt;&lt;a href=&quot;asn1ct&quot;&gt;ASN.1 Reference Manual&lt;/a&gt;&lt;/code&gt; 의 모듈 &lt;code&gt;asn1ct&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd83f86086df5c8234f8a9ae71fc626e0a86c59a" translate="yes" xml:space="preserve">
          <source>The compiler automatically inserts the two special, exported functions into each module:</source>
          <target state="translated">컴파일러는 자동으로 내 보낸 두 가지 특수 함수를 각 모듈에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0aa023f79e7e9fc3b1f355a1f8fb5632ee1a7886" translate="yes" xml:space="preserve">
          <source>The compiler can also be accessed from the OS prompt, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">컴파일러는 OS 프롬프트에서 액세스 할 수도 있습니다 &lt;code&gt;erl(1)&lt;/code&gt; ERTS 의 erl (1) 매뉴얼 페이지 참조 ) .</target>
        </trans-unit>
        <trans-unit id="dcd47ca4ce5f90e9af16a0a668c0506b2926c5f4" translate="yes" xml:space="preserve">
          <source>The compiler can also inline various list manipulation functions from the module &lt;code&gt;list&lt;/code&gt; in STDLIB.</source>
          <target state="translated">컴파일러는 STDLIB 의 모듈 &lt;code&gt;list&lt;/code&gt; 에서 다양한 목록 조작 함수를 인라인 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="246aeec2b67ad60a1d79d7bfcb202381eb810d23" translate="yes" xml:space="preserve">
          <source>The compiler can do function inlining within an Erlang module. Inlining means that a call to a function is replaced with the function body with the arguments replaced with the actual values. The semantics are preserved, except if exceptions are generated in the inlined code. Exceptions are reported as occurring in the function the body was inlined into. Also, &lt;code&gt;function_clause&lt;/code&gt; exceptions are converted to similar &lt;code&gt;case_clause&lt;/code&gt; exceptions.</source>
          <target state="translated">컴파일러는 Erlang 모듈 내에서 함수 인라인을 수행 할 수 있습니다. 인라인은 함수 호출이 함수 본문으로 바뀌고 인수가 실제 값으로 바뀐 것을 의미합니다. 인라인 코드에서 예외가 생성되는 경우를 제외하고 시맨틱은 유지됩니다. 본문이 인라인 된 함수에서 예외가보고됩니다. 또한 &lt;code&gt;function_clause&lt;/code&gt; 예외는 유사한 &lt;code&gt;case_clause&lt;/code&gt; 예외 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba61e82e2483a5192ba41d5a737c2246810798a9" translate="yes" xml:space="preserve">
          <source>The compiler can only do this optimization if it knows that the match context will not be shared. If it would be shared, the functional properties (also called referential transparency) of Erlang would break.</source>
          <target state="translated">일치 컨텍스트가 공유되지 않음을 알고있는 경우 컴파일러는이 최적화 만 수행 할 수 있습니다. 공유 할 경우 Erlang의 기능적 속성 (참조 투명성이라고도 함)이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="df9982300695d7d925cce5cf1cdd61f21ef202d8" translate="yes" xml:space="preserve">
          <source>The compiler does not warn for expressions that it does not attempt to optimize. For example, the compiler tries to evaluate &lt;code&gt;1/0&lt;/code&gt;, detects that it will cause an exception, and emits a warning. However, the compiler is silent about the similar expression, &lt;code&gt;X/0&lt;/code&gt;, because of the variable in it. Thus, the compiler does not even try to evaluate and therefore it emits no warnings.</source>
          <target state="translated">컴파일러는 최적화를 시도하지 않는 표현식에 대해 경고하지 않습니다. 예를 들어, 컴파일러는 &lt;code&gt;1/0&lt;/code&gt; 을 평가하려고 시도 하고 예외가 발생 함을 감지하고 경고를 표시합니다. 그러나 컴파일러는 변수로 인해 유사한 표현식 &lt;code&gt;X/0&lt;/code&gt; 에 대해 침묵 합니다. 따라서 컴파일러는 평가조차하지 않으므로 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="326ce5bdd2edeffbb0eff29680c2a35b2a0c7613" translate="yes" xml:space="preserve">
          <source>The compiler figures out if a variable is unused. The same code is generated for each of the following functions:</source>
          <target state="translated">컴파일러는 변수가 사용되지 않는지 알아냅니다. 다음 기능 각각에 대해 동일한 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="736c83a9c909e8b6995b93aa5a592a8cfd21644b" translate="yes" xml:space="preserve">
          <source>The compiler generates a &lt;code&gt;decode_part/2&lt;/code&gt; function when exclusive decode is chosen. This function decodes the parts that were left undecoded during the exclusive decode.</source>
          <target state="translated">배타적 디코딩을 선택하면 컴파일러에서 &lt;code&gt;decode_part/2&lt;/code&gt; 함수를 생성합니다 . 이 기능은 배타적 디코딩 동안 디코딩되지 않은 상태로 남은 부분을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="e4f37f01f0c640d21fe0c086a15f5624a101666e" translate="yes" xml:space="preserve">
          <source>The compiler generates the following files:</source>
          <target state="translated">컴파일러는 다음 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8ae89eb6c8e241efda8fbeedb553bd086502de6d" translate="yes" xml:space="preserve">
          <source>The compiler handles the &lt;code&gt;IMPORT&lt;/code&gt; statement. It is important to import the compiled file and not the ASN.1 (source) file. A MIB must be recompiled to make changes visible to other MIBs importing it.</source>
          <target state="translated">컴파일러는 &lt;code&gt;IMPORT&lt;/code&gt; 문을 처리합니다 . ASN.1 (소스) 파일이 아닌 컴파일 된 파일을 가져 오는 것이 중요합니다. MIB를 가져 오는 다른 MIB에 변경 사항을 표시하려면 MIB를 재 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef890ca9c7e8253725d98c0071846009690a22a4" translate="yes" xml:space="preserve">
          <source>The compiler internally rewrites the latter code into the former.</source>
          <target state="translated">컴파일러는 내부적으로 후자의 코드를 전자로 재 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1f2b065f3c16869915d5310d49119f53343cacb9" translate="yes" xml:space="preserve">
          <source>The compiler is located in the module &lt;code&gt;compile&lt;/code&gt; (see the &lt;code&gt;compile(3)&lt;/code&gt; manual page in Compiler).</source>
          <target state="translated">컴파일러는 모듈 &lt;code&gt;compile&lt;/code&gt; ( 컴파일러 의 &lt;code&gt;compile(3)&lt;/code&gt; 매뉴얼 페이지 참조).</target>
        </trans-unit>
        <trans-unit id="a6b51b2ed2bc7f46e25bc64dda5c32ec191ce10a" translate="yes" xml:space="preserve">
          <source>The compiler is started by &lt;code&gt;asn1ct:compile/1&lt;/code&gt; with default options, or &lt;code&gt;asn1ct:compile/2&lt;/code&gt; if explicit options are given.</source>
          <target state="translated">컴파일러는 기본 옵션 으로 &lt;code&gt;asn1ct:compile/1&lt;/code&gt; 로 시작 하거나 명시 적 옵션이 제공되면 &lt;code&gt;asn1ct:compile/2&lt;/code&gt; 로 시작 됩니다.</target>
        </trans-unit>
        <trans-unit id="7898d48c7095ef7080834ae1df25bb02756bfa73" translate="yes" xml:space="preserve">
          <source>The compiler parses the SMI file and associates each table or variable with an instrumentation function (see the figure &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt;). The actual instrumentation functions are not needed at MIB compile time, only their names.</source>
          <target state="translated">컴파일러는 SMI 파일을 구문 분석하고 각 테이블 또는 변수를 인스 트루먼 테이션 함수와 연관시킵니다 (그림 &lt;code&gt;&lt;a href=&quot;#image-1&quot;&gt;MIB Compiler Principles&lt;/a&gt;&lt;/code&gt; ). 실제 계측 기능은 MIB 컴파일시 필요하지 않으며 이름 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="29ced82347a929ec3d64773bda03ab575e2ebdf7" translate="yes" xml:space="preserve">
          <source>The compiler removes building of sub binaries in the second and third clauses, and it adds an instruction to the first clause that converts &lt;code&gt;Buffer&lt;/code&gt; from a match context to a sub binary (or do nothing if &lt;code&gt;Buffer&lt;/code&gt; is a binary already).</source>
          <target state="translated">컴파일러는 두 번째 및 세 번째 절에서 하위 이진 빌드를 제거하고 첫 번째 절에 &lt;code&gt;Buffer&lt;/code&gt; 를 일치 컨텍스트에서 하위 이진으로 변환하는 명령을 추가합니다 (또는 &lt;code&gt;Buffer&lt;/code&gt; 가 이미 이진 인 경우 아무 것도 수행하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="3e19fdc6630343c3d28603ee64052ea9f7070d01" translate="yes" xml:space="preserve">
          <source>The compiler returns the object code in a binary instead of creating an object file. If successful, the compiler returns &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 객체 파일을 생성하는 대신 객체 코드를 바이너리로 반환합니다. 성공하면 컴파일러는 &lt;code&gt;{ok,ModuleName,Binary}&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6c32c93e25c9ed677dd8b2dc76e27b04c3f91ef2" translate="yes" xml:space="preserve">
          <source>The compiler tries to avoid generating code that creates a sub binary, only to shortly afterwards create a new match context and discard the sub binary. Instead of creating a sub binary, the match context is kept.</source>
          <target state="translated">컴파일러는 하위 바이너리를 생성하는 코드 생성을 피하려고 시도하고 얼마 지나지 않아 새로운 일치 컨텍스트를 생성하고 하위 바이너리를 폐기합니다. 하위 바이너리를 만드는 대신 일치 컨텍스트가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="93271cc943214ad52c731246bc1c6f5f502dc5df" translate="yes" xml:space="preserve">
          <source>The compiler understands the module attribute &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; and issues warnings about missing callback functions, for example:</source>
          <target state="translated">컴파일러는 모듈 속성 &lt;code&gt;-behaviour(Behaviour)&lt;/code&gt; 이해하고 누락 된 콜백 함수에 대한 경고를 발행합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4e5de69deb63fd9f8e518572799240cd4dbb515" translate="yes" xml:space="preserve">
          <source>The compiler will compress the generated object code, which can be useful for embedded systems.</source>
          <target state="translated">컴파일러는 생성 된 객체 코드를 압축하여 임베디드 시스템에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6ca4a1bcb2bb18eb6fa6ea91946375fe8b63fd" translate="yes" xml:space="preserve">
          <source>The compiler will emit informational warnings about binary matching optimizations (both successful and unsuccessful). For more information, see the section about &lt;code&gt;bin_opt_info&lt;/code&gt; in the Efficiency Guide.</source>
          <target state="translated">컴파일러는 이진 일치 최적화에 대한 정보 경고를 표시합니다 (성공 및 실패). 자세한 내용 은 효율성 안내서에서 &lt;code&gt;bin_opt_info&lt;/code&gt; 에 대한 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="272c69253881a0e58a00b19dd140c32886a5264d" translate="yes" xml:space="preserve">
          <source>The compiler will generate code similar to this:</source>
          <target state="translated">컴파일러는 다음과 유사한 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a11970730484c5ef03d8b57a7d8f1200a3e88258" translate="yes" xml:space="preserve">
          <source>The complement message, from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, is only sent if node &lt;code&gt;A&lt;/code&gt; initially sent an old name message and received back a new challenge message from node &lt;code&gt;B&lt;/code&gt;. It contains complementary information missing in the initial old name message from node &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로의 보완 메시지 는 노드 &lt;code&gt;A&lt;/code&gt; 가 처음에 이전 이름 ​​메시지를 보내고 노드 &lt;code&gt;B&lt;/code&gt; 에서 새 챌린지 메시지를 다시받은 경우에만 전송됩니다 . 노드 &lt;code&gt;A&lt;/code&gt; 의 초기 이전 이름 ​​메시지에서 누락 된 보완 정보를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="f22d63ebef153d116952bd4b9cdc3d70b1deac48" translate="yes" xml:space="preserve">
          <source>The complete build environment is required while running &lt;code&gt;otp_patch_apply&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;otp_patch_apply&lt;/code&gt; 를 실행하는 동안 완전한 빌드 환경이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="991eb99483640f8d2cb258dac8893f15f032e622" translate="yes" xml:space="preserve">
          <source>The complete content of the history buffer can be written to a configuration file by calling &lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt;. Selected entries from the history can be written by calling &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt;, where &lt;code&gt;NumList&lt;/code&gt; is a list of integers pointing out the history entries to write. Moreover, the history buffer is always dumped to &lt;code&gt;ttb_last_config&lt;/code&gt; when &lt;code&gt;ttb:stop/0,1&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;ttb:write_config(ConfigFile,all)&lt;/code&gt; 를 호출하여 히스토리 버퍼의 전체 컨텐츠를 구성 파일에 쓸 수 있습니다 . 히스토리에서 선택된 항목은 &lt;code&gt;ttb:write_config(ConfigFile,NumList)&lt;/code&gt; 를 호출하여 작성할 수 있습니다 . 여기서 &lt;code&gt;NumList&lt;/code&gt; 는 쓸 히스토리 항목을 가리키는 정수 목록입니다. 또한 &lt;code&gt;ttb:stop/0,1&lt;/code&gt; 이 호출 될 때 히스토리 버퍼는 항상 &lt;code&gt;ttb_last_config&lt;/code&gt; 에 덤프됩니다 .</target>
        </trans-unit>
        <trans-unit id="06275c17581f810fa4579c2f0ccfc4b29d12ac2f" translate="yes" xml:space="preserve">
          <source>The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.</source>
          <target state="translated">완전한 일치 패턴은 항상 목록의 첫 번째 반환 값을 제공하고 나머지 하위 패턴은 정규식에서 발생한 순서대로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3a13431e36ebb44eb9fa84700a106f85f4b1ac47" translate="yes" xml:space="preserve">
          <source>The complete path to the Erlang emulator. Never use the &lt;code&gt;werl&lt;/code&gt; program for this. Defaults to the &lt;code&gt;erl.exe&lt;/code&gt; in the same directory as &lt;code&gt;erlsrv.exe&lt;/code&gt;. When release handling is used, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">Erlang 에뮬레이터의 전체 경로입니다. 이를 위해 &lt;code&gt;werl&lt;/code&gt; 프로그램을 사용하지 마십시오 . 받는 기본 &lt;code&gt;erl.exe&lt;/code&gt; 과 같은 디렉토리에 &lt;code&gt;erlsrv.exe&lt;/code&gt; . 릴리스 처리를 사용하는 경우 &lt;code&gt;start_erl.exe&lt;/code&gt; 와 유사한 프로그램으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b9e994208ced53dcfba8c8850e25b0dd795cc2c" translate="yes" xml:space="preserve">
          <source>The complete specification for the bit syntax appears in the &lt;code&gt;Reference Manual&lt;/code&gt;.</source>
          <target state="translated">비트 구문에 대한 전체 사양은 &lt;code&gt;Reference Manual&lt;/code&gt; 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="4b9f520763856efe6e5a044f5a2e1ee496c05b06" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;A -- B&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;. That is, it becomes very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists.</source>
          <target state="translated">&lt;code&gt;A -- B&lt;/code&gt; 의 복잡도는 &lt;code&gt;length(A)*length(B)&lt;/code&gt; 비례합니다 . 즉, &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 모두 긴 목록 이면 속도가 매우 느려집니다 .</target>
        </trans-unit>
        <trans-unit id="fab2bbfeb9763c6bdcd0f510a645aceccf277fc7" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;lists:subtract(A, B)&lt;/code&gt; is proportional to &lt;code&gt;length(A)*length(B)&lt;/code&gt;, meaning that it is very slow if both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are long lists. (If both lists are long, it is a much better choice to use ordered lists and &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lists:subtract(A, B)&lt;/code&gt; 의 복잡도는 &lt;code&gt;length(A)*length(B)&lt;/code&gt; 비례합니다 . 이는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 모두 긴 목록 인 경우 매우 느리다는 것을 의미 합니다. 두 목록이 모두 길면 정렬 된 목록과 &lt;code&gt;&lt;a href=&quot;ordsets#subtract-2&quot;&gt;ordsets:subtract/2&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6fc7384b856b0bd8d7f49596a4fe364f88395e2b" translate="yes" xml:space="preserve">
          <source>The complexity on set operations is bounded by either &lt;strong&gt;O(|S|)&lt;/strong&gt; or &lt;strong&gt;O(|T| * log(|S|))&lt;/strong&gt;, where S is the largest given set, depending on which is fastest for any particular function call. For operating on sets of almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For sets of very different sizes, however, this solution can be arbitrarily much faster; in practical cases, often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time, building up a large set (&amp;gt; 100-200 elements), and repeatedly testing for membership in the current set.</source>
          <target state="translated">세트 연산의 복잡성은 &lt;strong&gt;O (| S |)&lt;/strong&gt; 또는 &lt;strong&gt;O (| T | * log (| S |))로 제한됩니다&lt;/strong&gt; . 여기서 S는 특정 함수 호출에 가장 빠른 것에 따라 주어진 최대 세트입니다. 거의 동일한 크기의 세트에서 작동하는 경우이 구현은 정렬 된 목록 세트를 직접 사용하는 것보다 약 3 배 느립니다. 그러나 크기가 매우 다른 세트의 경우이 솔루션은 임의로 훨씬 빠릅니다. 실제 경우에는 종종 10 ~ 100 배. 이 구현은 특히 한 번에 몇 개의 요소를 누적하고 큰 세트 (&amp;gt; 100-200 요소)를 작성하고 현재 세트의 멤버쉽을 반복적으로 테스트하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1f0db048fd959939f98a5ab5ffcb76b17f2161e3" translate="yes" xml:space="preserve">
          <source>The component &lt;code&gt;b&lt;/code&gt; is treated as an original component when encoding a message. In this case, as it is not an optional element, it must be encoded.</source>
          <target state="translated">메시지 &lt;code&gt;b&lt;/code&gt; 를 인코딩 할 때 구성 요소 b 는 원래 구성 요소로 취급됩니다. 이 경우 선택적 요소가 아니므로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="95df5a7aa19b0879416444bcc5ff1ff82e16895f" translate="yes" xml:space="preserve">
          <source>The compressed term format is as follows:</source>
          <target state="translated">압축 용어 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b034a8ca7cf564d2716f7d145e9bf7ce76cd7cc" translate="yes" xml:space="preserve">
          <source>The compression algorithm none (= no compression) is removed so compression is enforced</source>
          <target state="translated">압축 알고리즘 없음 (= 압축 없음)이 제거되어 압축이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b5cdfaea7fccd1b20390cb4e9325498d3da1b59" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">압축기와 압축 해제 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 동일한 사전을 사용해야합니다 ( inflateSetDictionary / 2 참조 ).</target>
        </trans-unit>
        <trans-unit id="20f5418f59d5bf2e56046767d3d15b2e506ac3c4" translate="yes" xml:space="preserve">
          <source>The compressor and decompressor must use the same dictionary (see &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">압축기와 압축 해제 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 동일한 사전을 사용해야합니다 ( inflateSetDictionary / 2 참조 ).</target>
        </trans-unit>
        <trans-unit id="0c9ba98b827fef9b660205799a125d38d037fa2c" translate="yes" xml:space="preserve">
          <source>The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is &lt;code&gt;DBL_MIN&lt;/code&gt;, which is 2.0^(-1022).</source>
          <target state="translated">이 개념은 정확히 0을 얻을 확률이 매우 낮다는 것을 의미합니다. 이 함수는 실제로 0을 반환하지 않을 정도로 낮습니다. 리턴 할 수있는 가장 작은 숫자는 &lt;code&gt;DBL_MIN&lt;/code&gt; 이며 2.0 ^ (-1022)입니다.</target>
        </trans-unit>
        <trans-unit id="943911384cb6e7518951f5974b91a80146819bfa" translate="yes" xml:space="preserve">
          <source>The concept of &quot;raw filenames&quot; can be used to handle wrongly encoded filenames if one enables Unicode filename translation (&lt;code&gt;+fnu&lt;/code&gt;) on platforms where this is not the default.</source>
          <target state="translated">&quot;raw filenames&quot;개념은 이것이 기본값이 아닌 플랫폼에서 유니 코드 파일 이름 변환 ( &lt;code&gt;+fnu&lt;/code&gt; )을 사용하는 경우 잘못 인코딩 된 파일 이름을 처리하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5e9df0f0bca9d8678a66d1bcb07dea7aeeb1bd0" translate="yes" xml:space="preserve">
          <source>The concept of subtyping can be applied to integers and to other ASN.1 types. The details of subtyping are not explained here; for more information, see X.680. Various syntaxes are allowed when defining a type as an integer:</source>
          <target state="translated">서브 타이핑 개념은 정수 및 기타 ASN.1 유형에 적용될 수 있습니다. 하위 유형에 대한 자세한 내용은 여기에 설명되어 있지 않습니다. 자세한 내용은 X.680을 참조하십시오. 유형을 정수로 정의 할 때 다양한 구문이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ea91819bf64e3ece43df4e073d660a0ac1fb62c" translate="yes" xml:space="preserve">
          <source>The conceptual repository for management information is called the Management Information Base (MIB). It does not hold any data, merely a definition of what data can be accessed. A definition of an MIB is a description of a collection of managed objects.</source>
          <target state="translated">관리 정보의 개념적 저장소를 MIB (Management Information Base)라고합니다. 어떤 데이터도 보유하지 않으며 단지 어떤 데이터에 액세스 할 수 있는지에 대한 정의입니다. MIB의 정의는 관리 객체 모음에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="100c3255ddc27fa6383db8b2a42e843f2130c476" translate="yes" xml:space="preserve">
          <source>The condition can be inverted by using &lt;code&gt;%unless&lt;/code&gt; instead of &lt;code&gt;%if&lt;/code&gt;:</source>
          <target state="translated">조건 은 &lt;code&gt;%if&lt;/code&gt; 대신 &lt;code&gt;%unless&lt;/code&gt; 를 사용하여 반전 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f0f7f9a82dfed01500e86c2a2936e52983cbea0" translate="yes" xml:space="preserve">
          <source>The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. That is, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative, otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</source>
          <target state="translated">조건은 문자가 아닌 선택적 순서의 비 문자와 일치하는 긍정적 인 미리보기 어설 션입니다. 즉, 주제에 하나 이상의 문자가 있는지 테스트합니다. 문자가 발견되면 주제는 첫 번째 대안과 일치하고, 그렇지 않으면 두 번째 대안과 일치합니다. 이 패턴은 dd-aaa-dd 또는 dd-dd-dd 두 가지 형식 중 하나의 문자열과 일치합니다. 여기서 aaa는 문자이고 dd는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="2bb2d4ddfb9fd4340f3bf62302b4368f672d1819" translate="yes" xml:space="preserve">
          <source>The condition is specified by the user as a module name &lt;code&gt;CModule&lt;/code&gt; and a function name &lt;code&gt;CFunction&lt;/code&gt;. When a process reaches the breakpoint, &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; is evaluated. If and only if this function call returns &lt;code&gt;true&lt;/code&gt;, the process stops. If the function call returns &lt;code&gt;false&lt;/code&gt;, the breakpoint is silently ignored.</source>
          <target state="translated">조건은 사용자가 모듈 이름 &lt;code&gt;CModule&lt;/code&gt; 및 함수 이름 &lt;code&gt;CFunction&lt;/code&gt; 으로 지정 합니다. 프로세스가 중단 점에 도달하면 &lt;code&gt;CModule:CFunction(Bindings)&lt;/code&gt; 이 평가됩니다. 이 함수 호출이 &lt;code&gt;true&lt;/code&gt; 를 반환하는 경우에만 프로세스가 중지됩니다. 함수 호출이 &lt;code&gt;false&lt;/code&gt; 를 리턴 하면 중단 점이 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f7986bbea85397da9d57d44bc07228d7fb46c1a2" translate="yes" xml:space="preserve">
          <source>The conditional test is performed by calling &lt;code&gt;Module:Name(Bindings)&lt;/code&gt;, where &lt;code&gt;Bindings&lt;/code&gt; is the current variable bindings. The function must return &lt;code&gt;true&lt;/code&gt; (break) or &lt;code&gt;false&lt;/code&gt; (do not break). To retrieve the value of a variable &lt;code&gt;Var&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">조건부 테스트는 &lt;code&gt;Module:Name(Bindings)&lt;/code&gt; 를 호출하여 수행됩니다 . 여기서 &lt;code&gt;Bindings&lt;/code&gt; 는 현재 변수 바인딩입니다. 함수는 &lt;code&gt;true&lt;/code&gt; (중단) 또는 &lt;code&gt;false&lt;/code&gt; ( 중단 안 함)를 반환해야합니다 . 변수의 값을 검색하려면 &lt;code&gt;Var&lt;/code&gt; , 사용 &lt;code&gt;&lt;a href=&quot;int#get_binding-2&quot;&gt;int:get_binding(Var, Bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e22cdbb695181f6db56e9e8f9255cb87d1e5c71" translate="yes" xml:space="preserve">
          <source>The conditions for the range request are not fulfilled. The response must not be treated as a range request, instead it must be treated as an ordinary get request.</source>
          <target state="translated">범위 요청 조건이 충족되지 않았습니다. 응답은 범위 요청으로 취급되어서는 안되며 대신 일반 요청으로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d2a1a0885cb8c3972db243784463cc998671043e" translate="yes" xml:space="preserve">
          <source>The config file &lt;code&gt;ex3.config&lt;/code&gt; has the contents:</source>
          <target state="translated">구성 파일 &lt;code&gt;ex3.config&lt;/code&gt; 에는 다음 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c7d9b54f9813dcda9a518f9cbb3355ce28a2103" translate="yes" xml:space="preserve">
          <source>The config file directives stored as key-value tuples in an ETS table. Depicted &lt;code&gt;config_db()&lt;/code&gt; in function type declarations.</source>
          <target state="translated">구성 파일 지시문은 ETS 테이블에 키-값 튜플로 저장됩니다. 함수 타입 선언에서 &lt;code&gt;config_db()&lt;/code&gt; 를 묘사했습니다 .</target>
        </trans-unit>
        <trans-unit id="1c180f4dced667f5747360888d336f97b780f3ef" translate="yes" xml:space="preserve">
          <source>The configuration can be changed during runtime. This is done with the functions &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">런타임 중에 구성을 변경할 수 있습니다. 이것은 &lt;code&gt;&lt;a href=&quot;megaco#update_user_info&quot;&gt;megaco:update_user_info&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;megaco#update_conn_info&quot;&gt;megaco:update_conn_info&lt;/a&gt;&lt;/code&gt; 기능으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c0742cfd72a2d898508fa85616b5365c6647a68" translate="yes" xml:space="preserve">
          <source>The configuration created by &lt;code&gt;erts_alloc_config&lt;/code&gt; may perform bad, ever horrible, for runtime scenarios that are very different from the ones saved when creating the configuration. You are, therefore, advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the applications run when the configuration was made are changed, or if the load on the applications have changed since the configuration was made. You are also advised to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt; if the Erlang runtime system used is changed.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 구성은 구성을 생성 할 때 저장된 것과 매우 다른 런타임 시나리오에 대해 좋지 않은 성능 을 발휘할 수 있습니다. 따라서 구성을 변경할 때 응용 프로그램을 실행하거나 구성을 수행 한 후 응용 프로그램의로드가 변경된 경우 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행하는 것이 좋습니다 . 사용 된 Erlang 런타임 시스템이 변경된 경우 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1470d083b0e1db8406286192bd8eb1c282c6bd47" translate="yes" xml:space="preserve">
          <source>The configuration data that can be modified.</source>
          <target state="translated">수정할 수있는 구성 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="85fc09c0359e30e0ac0453b4dd29606f3be0cecc" translate="yes" xml:space="preserve">
          <source>The configuration file is to be called &lt;code&gt;Name.config&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is any name.</source>
          <target state="translated">구성 파일은 &lt;code&gt;Name.config&lt;/code&gt; 이며 여기서 &lt;code&gt;Name&lt;/code&gt; 은 임의의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2e343dc41431506d1bab7a8f1ff51c6eab8fb28a" translate="yes" xml:space="preserve">
          <source>The configuration file must be as for &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구성 파일은 &lt;code&gt;&lt;a href=&quot;#put-3&quot;&gt;ct_ftp:put/3&lt;/a&gt;&lt;/code&gt; 과 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="dea2779e1cbd9f4e936b9d22bec123fd3a929a25" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;community.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;community.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c155b3574ab962c920c1adb90ff1fbf8e4d0be7" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;context.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;context.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f94cc61e31a7b0de35c335106254d680dc12d2e8" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;notify.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;notify.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a287de08efb6a6960170e4a56df71f4fd0b681e" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;standard.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;standard.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="edf952b8d588b0a93a4ac1f9d47f9ec65e928fc4" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;usm.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;usm.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac382ba3d28511c043e21b8f905a371edc5d62a" translate="yes" xml:space="preserve">
          <source>The configuration file read is: &lt;code&gt;vacm.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;vacm.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3706f3f0276351526850c287f3491578e144daa" translate="yes" xml:space="preserve">
          <source>The configuration files are described in the SNMP User's Manual.</source>
          <target state="translated">구성 파일은 SNMP 사용자 매뉴얼에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6aaee960bcbac0afc5716e7f7102e83e8360020" translate="yes" xml:space="preserve">
          <source>The configuration files is to have &lt;code&gt;rw-r--r--&lt;/code&gt; file privileges and be owned by root.</source>
          <target state="translated">구성 파일은 &lt;code&gt;rw-r--r--&lt;/code&gt; 파일 권한을 가지며 루트가 소유합니다.</target>
        </trans-unit>
        <trans-unit id="7d385331a206f67eef31fa2a51c3328ec0a6039b" translate="yes" xml:space="preserve">
          <source>The configuration files read are: &lt;code&gt;target_addr.conf&lt;/code&gt; and &lt;code&gt;target_params.conf&lt;/code&gt;.</source>
          <target state="translated">읽은 구성 파일은 &lt;code&gt;target_addr.conf&lt;/code&gt; 및 &lt;code&gt;target_params.conf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="042a7891933367b39b8962f8cd2c79595dff050a" translate="yes" xml:space="preserve">
          <source>The configuration for a handler is a map with the following keys:</source>
          <target state="translated">핸들러의 구성은 다음 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="3a5cc2ceb258634736594f44cf8266aeb733951f" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3) &lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="translated">내장 처리기의 구성은 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3) &lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c1a1fcfff199b6a1287871c07c285d5f0e37425" translate="yes" xml:space="preserve">
          <source>The configuration for the built-in handlers is described in the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages.</source>
          <target state="translated">내장 핸들러의 구성은 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bec465458a3428115fd8e864e0c74437e5202fb" translate="yes" xml:space="preserve">
          <source>The configuration functions &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; execute, like test cases, on dedicated Erlang processes.</source>
          <target state="translated">&lt;code&gt;init_per_suite&lt;/code&gt; 및 &lt;code&gt;end_per_suite&lt;/code&gt; 구성 기능 은 테스트 사례처럼 전용 Erlang 프로세스에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ca028bc56c7a5d8a6feb5fb00bb7ad713784158b" translate="yes" xml:space="preserve">
          <source>The configuration functions are optional. The following example is a test suite without configuration functions, including one simple test case, to check that module &lt;code&gt;mymod&lt;/code&gt; exists (that is, can be successfully loaded by the code server):</source>
          <target state="translated">구성 기능은 선택 사항입니다. 다음 예제는 모듈 &lt;code&gt;mymod&lt;/code&gt; 가 존재 하는지 (즉, 코드 서버에 의해 성공적으로로드 될 수 있는지) 확인하기위한 간단한 테스트 케이스를 포함하여 구성 기능이없는 테스트 스위트입니다 .</target>
        </trans-unit>
        <trans-unit id="b7ecabb96142aae8632b3c398a0652fea4462151" translate="yes" xml:space="preserve">
          <source>The configuration is created based on information about a number of runtime scenarios. It is obviously impossible to foresee every runtime scenario that can occur. The important scenarios are those that cause maximum or minimum load on specific memory allocators. Load in this context is total size of memory blocks allocated.</source>
          <target state="translated">여러 런타임 시나리오에 대한 정보를 기반으로 구성이 작성됩니다. 발생할 수있는 모든 런타임 시나리오를 예측하는 것은 분명히 불가능합니다. 중요한 시나리오는 특정 메모리 할당 자에서 최대 또는 최소로드를 발생시키는 시나리오입니다. 이 컨텍스트에서로드는 할당 된 총 메모리 블록 크기입니다.</target>
        </trans-unit>
        <trans-unit id="a090830d0bfa6e8b71055c052afa6781c7336637" translate="yes" xml:space="preserve">
          <source>The configuration of a &lt;code&gt;Mnesia&lt;/code&gt; system is described in a schema. The schema is a special table that includes information such as the table names and the storage type of each table (that is, whether a table is to be stored in RAM, on disc, or on both, as well as its location).</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 시스템 의 구성은 스키마에 설명되어 있습니다. 스키마는 테이블 이름 및 각 테이블의 스토리지 유형과 같은 정보를 포함하는 특수 테이블입니다 (즉, 테이블을 RAM에 저장해야하는지 디스크에 저장해야하는지 여부와 위치에 관계없이).</target>
        </trans-unit>
        <trans-unit id="eb15a8828aadb5793353d2caed482552687928f9" translate="yes" xml:space="preserve">
          <source>The configuration of how the documentation should be rendered.</source>
          <target state="translated">문서를 렌더링하는 방법의 구성입니다.</target>
        </trans-unit>
        <trans-unit id="c9c07741d4c4f9e44d0dbd305d096f7efb62fc4f" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list.</source>
          <target state="translated">서버의 구성은 Erlang 속성 목록으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="50fec7a20842abcc0261e4b0c9e02b04cf3308e0" translate="yes" xml:space="preserve">
          <source>The configuration of the server is provided as an Erlang property list. For backwards compatibility, a configuration file using apache-style configuration directives is supported.</source>
          <target state="translated">서버 구성은 Erlang 등록 정보 목록으로 제공됩니다. 이전 버전과의 호환성을 위해 아파치 스타일 구성 지시문을 사용하는 구성 파일이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="42a81cb11873a89bc4dc7fee0b14edc95426ecba" translate="yes" xml:space="preserve">
          <source>The configuration option &lt;code&gt;filter_default&lt;/code&gt; specifies the behaviour if all filter functions return &lt;code&gt;ignore&lt;/code&gt;, or if no filters exist. &lt;code&gt;filter_default&lt;/code&gt; is by default set to &lt;code&gt;log&lt;/code&gt;, meaning that if all existing filters ignore a log event, Logger forwards the event to the handler callback. If &lt;code&gt;filter_default&lt;/code&gt; is set to &lt;code&gt;stop&lt;/code&gt;, Logger discards such events.</source>
          <target state="translated">구성 옵션 &lt;code&gt;filter_default&lt;/code&gt; 는 모든 필터 함수가 &lt;code&gt;ignore&lt;/code&gt; 를 반환 하거나 필터가없는 경우 동작을 지정 합니다. &lt;code&gt;filter_default&lt;/code&gt; 는 기본적으로 &lt;code&gt;log&lt;/code&gt; 로 설정됩니다 . 즉, 기존의 모든 필터가 로그 이벤트를 무시하면 Logger가 이벤트를 핸들러 콜백으로 전달합니다. 경우 &lt;code&gt;filter_default&lt;/code&gt; 가 설정되어 &lt;code&gt;stop&lt;/code&gt; , 로거는 이벤트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="7cbcc3590c5b004952bd57c5ea409bb2cbc75510" translate="yes" xml:space="preserve">
          <source>The configuration parameter does not exist.</source>
          <target state="translated">구성 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="81a4addb98ae9327dd483e9ad9426add086cb215" translate="yes" xml:space="preserve">
          <source>The configuration produced by &lt;code&gt;erts_alloc_config&lt;/code&gt; may need to be manually adjusted as already stated. Do not modify the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;; instead, put your modifications in another file and load this file after the file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. That is, put the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads your modification file later on the command-line than the &lt;code&gt;-args_file FileName&lt;/code&gt; argument that reads the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. If a memory allocation parameter appear multiple times, the last version of will be used, i.e., you can override parameters in the configuration file produced by &lt;code&gt;erts_alloc_config&lt;/code&gt;. Doing it this way simplifies things when you want to rerun &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 구성 은 이미 언급 한대로 수동으로 조정해야합니다. &lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 파일을 수정하지 마십시오 . 대신, 수정 사항을 다른 파일에 &lt;code&gt;erts_alloc_config&lt;/code&gt; 생성 한 파일 뒤에이 파일을로드하십시오 . 즉, 넣어 &lt;code&gt;-args_file FileName&lt;/code&gt; 댄 명령 줄에 나중에 수정 파일을 읽고 인수 &lt;code&gt;-args_file FileName&lt;/code&gt; 의해 생성 된 구성 파일을 읽고 인수 &lt;code&gt;erts_alloc_config&lt;/code&gt; 을 . 메모리 할당 매개 변수가 여러 번 나타나는 경우 마지막 버전이 사용됩니다. 즉, &lt;code&gt;erts_alloc_config&lt;/code&gt; 에 의해 생성 된 구성 파일의 매개 변수를 대체 할 수 있습니다.. 이 방법을 사용하면 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행할 때 작업이 단순화됩니다 .</target>
        </trans-unit>
        <trans-unit id="213a1cc6b8684b6f32c379587c37729fd6c0d583" translate="yes" xml:space="preserve">
          <source>The configuration string for this driver can be &lt;code&gt;config_server&lt;/code&gt;, if the &lt;code&gt;config_server.erl&lt;/code&gt; module that follows is compiled and exists in the code path during test execution:</source>
          <target state="translated">다음 의 &lt;code&gt;config_server.erl&lt;/code&gt; 모듈이 컴파일되어 테스트 실행 중 코드 경로에 존재하는 경우이 드라이버의 구성 문자열은 &lt;code&gt;config_server&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d419157999767488a1c56645c3a2365b2bbbcd93" translate="yes" xml:space="preserve">
          <source>The configuration term for &lt;code&gt;logger_formatter&lt;/code&gt; is a &lt;code&gt;map&lt;/code&gt;, and the following keys can be set as configuration parameters:</source>
          <target state="translated">&lt;code&gt;logger_formatter&lt;/code&gt; 의 구성 용어 는 &lt;code&gt;map&lt;/code&gt; 이며 다음 키를 구성 매개 변수로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712ad0cc82e1a88f726b7f711e243ab197e28193" translate="yes" xml:space="preserve">
          <source>The configure script allows you to customize a number of parameters; type &lt;code&gt;./configure --help&lt;/code&gt; or &lt;code&gt;./configure --help=recursive&lt;/code&gt; for details. &lt;code&gt;./configure --help=recursive&lt;/code&gt; will give help for all &lt;code&gt;configure&lt;/code&gt; scripts in all applications.</source>
          <target state="translated">configure 스크립트를 사용하면 여러 매개 변수를 사용자 정의 할 수 있습니다. 입력 &lt;code&gt;./configure --help&lt;/code&gt; 또는 &lt;code&gt;./configure --help=recursive&lt;/code&gt; 자세한 내용은. &lt;code&gt;./configure --help=recursive&lt;/code&gt; 는 모든 응용 프로그램의 모든 &lt;code&gt;configure&lt;/code&gt; 스크립트에 대한 도움말을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f871702162e9fe05aae1c9e32504517869931c15" translate="yes" xml:space="preserve">
          <source>The configure script is created by the GNU autoconf utility, which checks for system specific features and then creates a number of makefiles.</source>
          <target state="translated">configure 스크립트는 GNU autoconf 유틸리티에 의해 만들어지며 시스템 별 기능을 확인한 다음 여러 makefile을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7d4bba926aeb3883bfbd6d00a31923bc874078ac" translate="yes" xml:space="preserve">
          <source>The configure should be skipped and all tests should hopefully pass. For more details about how to use ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt;</source>
          <target state="translated">구성을 건너 뛰고 모든 테스트를 통과해야합니다. ts run &lt;code&gt;erl -s ts help -s init stop&lt;/code&gt; 사용 방법에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="3f6521bf4e434f67b356b39a99c1ade02b2e892c" translate="yes" xml:space="preserve">
          <source>The connect is done in two steps: first an internal &lt;code&gt;connection setup&lt;/code&gt; and then by calling the user &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; callback function. The first step could result in an error with &lt;code&gt;Reason = connect_reason()&lt;/code&gt; and the second an error with &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt;:</source>
          <target state="translated">연결은 먼저 내부 &lt;code&gt;connection setup&lt;/code&gt; 후 사용자 &lt;code&gt;&lt;a href=&quot;megaco_user#connect&quot;&gt;handle_connect&lt;/a&gt;&lt;/code&gt; 콜백 함수를 호출하여 두 단계로 수행됩니다 . 첫 번째 단계는 &lt;code&gt;Reason = connect_reason()&lt;/code&gt; 오류이고 두 번째 단계는 &lt;code&gt;Reason = handle_connect_reason()&lt;/code&gt; 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="371ea327d46ab20111d8dd7bba591b3794f31f48" translate="yes" xml:space="preserve">
          <source>The connection attempt can be traced by setting a trace level by either using &lt;code&gt;ei_set_tracelevel&lt;/code&gt; or by setting environment variable &lt;code&gt;EI_TRACELEVEL&lt;/code&gt;. The trace levels have the following messages:</source>
          <target state="translated">&lt;code&gt;ei_set_tracelevel&lt;/code&gt; 을 사용 하거나 환경 변수 &lt;code&gt;EI_TRACELEVEL&lt;/code&gt; 을 설정 하여 추적 레벨을 설정하여 연결 시도를 추적 할 수 있습니다 . 추적 레벨에는 다음 메시지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef16d7f5ec818bdeac2287eb2c52b738775d9e3" translate="yes" xml:space="preserve">
          <source>The connection created to the EPMD must be kept as long as the node is a distributed node. When the connection is closed, the node is automatically unregistered from the EPMD.</source>
          <target state="translated">노드가 분산 노드 인 한 EPMD에 생성 된 연결은 유지해야합니다. 연결이 닫히면 노드가 EPMD에서 자동으로 등록 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="5cbfa81fe3ccd8a5c63ea407c66f04845f8cea33" translate="yes" xml:space="preserve">
          <source>The connection is already encrypted. The connection is not affected.</source>
          <target state="translated">연결이 이미 암호화되었습니다. 연결에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="759c06525846f46120048a080c3029be1ff31bcc" translate="yes" xml:space="preserve">
          <source>The connection is associated with the process that created it and can only be accessed through it. The reason for this is to preserve the semantics of result sets and transactions when select_count/[2,3] is called or auto_commit is turned off. Attempts to use the connection from another process will fail. This will not effect the connection. On the other hand, if the client process dies the connection will be terminated.</source>
          <target state="translated">연결은 연결을 만든 프로세스와 연결되며 연결을 통해서만 액세스 할 수 있습니다. 그 이유는 select_count / [2,3]이 호출되거나 auto_commit이 해제되어있을 때 결과 집합 및 트랜잭션의 의미를 유지하기 위함입니다. 다른 프로세스에서 연결을 사용하려고하면 실패합니다. 연결에는 영향을 미치지 않습니다. 반면에 클라이언트 프로세스가 종료되면 연결이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6bd0a40ef6e388c1101ec314a27b945374892947" translate="yes" xml:space="preserve">
          <source>The connection is disallowed for some (unspecified) security reason.</source>
          <target state="translated">일부 지정되지 않은 보안상의 이유로 연결이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f988842124188a5fc24f10cf75663bb95aaa98aa" translate="yes" xml:space="preserve">
          <source>The connection setup failed (after &lt;code&gt;nodeup&lt;/code&gt; messages were sent).</source>
          <target state="translated">연결 설정에 실패했습니다 ( &lt;code&gt;nodeup&lt;/code&gt; 메시지가 전송 된 후 ).</target>
        </trans-unit>
        <trans-unit id="2c2c09cbaff852e46a92c401a3052832960adf16" translate="yes" xml:space="preserve">
          <source>The connection state.</source>
          <target state="translated">연결 상태</target>
        </trans-unit>
        <trans-unit id="21a557db3cf2f1855e12dfec5d40959655ffd926" translate="yes" xml:space="preserve">
          <source>The connection string is to be a connection string for postgres.</source>
          <target state="translated">연결 문자열은 postgres의 연결 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ab4adb70f93fe4eb3a4bc1933285abc2bb9e86ea" translate="yes" xml:space="preserve">
          <source>The connection to &lt;code&gt;Node&lt;/code&gt; was lost or could not be established. The function may or may not be applied.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 에 대한 연결 이 끊어 졌거나 설정할 수 없습니다. 기능이 적용되거나 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="577ebba31469c1b19a854e051f7d7bcd77b95482" translate="yes" xml:space="preserve">
          <source>The connection was closed.</source>
          <target state="translated">연결이 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="f85b0a947aa3ee4eeec0e9164d045d949bc237ff" translate="yes" xml:space="preserve">
          <source>The connection was disconnected (forced from the current node).</source>
          <target state="translated">연결이 끊어졌습니다 (현재 노드에서 강제 됨).</target>
        </trans-unit>
        <trans-unit id="faa62673d542db68465d9b4076b4c1a13a9c2ef7" translate="yes" xml:space="preserve">
          <source>The consistency property ensures that a transaction always leaves the DBMS in a consistent state. For example, &lt;code&gt;Mnesia&lt;/code&gt; ensures that no inconsistencies occur if Erlang, &lt;code&gt;Mnesia&lt;/code&gt;, or the computer crashes while a write operation is in progress.</source>
          <target state="translated">일관성 속성은 트랜잭션이 항상 DBMS를 일관된 상태로 유지하도록합니다. 예를 들어, &lt;code&gt;Mnesia&lt;/code&gt; 는 쓰기 작업이 진행되는 동안 Erlang, &lt;code&gt;Mnesia&lt;/code&gt; 또는 컴퓨터가 충돌하는 경우 불일치가 발생하지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="1ddfddbb8f225dd73ee75750b50447169433b54f" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; has value 50 (see &lt;code&gt;ct.hrl&lt;/code&gt;). At this level, all standard I/O gets printed. If a lower verbosity level is set, standard I/O printouts are ignored. Verbosity level 0 effectively turns all logging off (except from printouts made by &lt;code&gt;Common Test&lt;/code&gt; itself).</source>
          <target state="translated">상수 &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; 값은 50입니다 ( &lt;code&gt;ct.hrl&lt;/code&gt; 참조 ). 이 수준에서 모든 표준 I / O가 인쇄됩니다. 낮은 상세 수준을 설정하면 표준 I / O 출력이 무시됩니다. 상세 레벨 0은 모든 로깅을 효과적으로 해제합니다 ( &lt;code&gt;Common Test&lt;/code&gt; 자체 에서 작성된 출력물 제외 ).</target>
        </trans-unit>
        <trans-unit id="44db6a31ddf9435698ec11cd4e92a6b9b7ad2879" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;u$is_bif&lt;/code&gt; will test whether the given operand refers to a BIF. For example:</source>
          <target state="translated">제약 조건 &lt;code&gt;u$is_bif&lt;/code&gt; 는 주어진 피연산자가 BIF를 참조하는지 여부를 테스트합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="41f1224d66b802b926b2e31ecb1f284682edfb00" translate="yes" xml:space="preserve">
          <source>The construction &lt;code&gt;??Arg&lt;/code&gt;, where &lt;code&gt;Arg&lt;/code&gt; is a macro argument, is expanded to a string containing the tokens of the argument. This is similar to the &lt;code&gt;#arg&lt;/code&gt; stringifying construction in C.</source>
          <target state="translated">건설 &lt;code&gt;??Arg&lt;/code&gt; , &lt;code&gt;Arg&lt;/code&gt; 매크로 인자이고는 인수의 토큰을 포함하는 문자열로 확장된다. 이것은 C 의 &lt;code&gt;#arg&lt;/code&gt; stringifying 구성 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e122203f3d8b9817a2ea30ffb99c064337701c17" translate="yes" xml:space="preserve">
          <source>The content and meaning of these messages do not need to be interpreted by the process. Instead the following function is to be called:</source>
          <target state="translated">이러한 메시지의 내용과 의미는 프로세스에서 해석 할 필요가 없습니다. 대신 다음 기능을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="968fd451ababe1d06f33d9607e5b522cbdd869a3" translate="yes" xml:space="preserve">
          <source>The content of these variables are added to the end of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">이 변수의 내용은 &lt;code&gt;erl&lt;/code&gt; 의 명령 행 끝에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c18af4769f57f2942d42a8aca949de1aac0af981" translate="yes" xml:space="preserve">
          <source>The content of this file is &lt;strong&gt;only&lt;/strong&gt; valid if the system has been built with 'socket' (esock) support, which is the default.</source>
          <target state="translated">이 파일의 내용은 시스템이 기본값 인 'socket'(esock) 지원으로 빌드 된 경우 &lt;strong&gt;에만&lt;/strong&gt; 유효합니다.</target>
        </trans-unit>
        <trans-unit id="16b69fb0bdc6287d140f1bf18649d3746425bdf1" translate="yes" xml:space="preserve">
          <source>The content of this variable is added to the beginning of the command line for &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">이 변수의 내용은 &lt;code&gt;erl&lt;/code&gt; 의 명령 행 시작 부분에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a245ccccd6f901e15ebc8675d831502211bf76e" translate="yes" xml:space="preserve">
          <source>The content-length of the document transferred.</source>
          <target state="translated">전송 된 문서의 내용 길이</target>
        </trans-unit>
        <trans-unit id="a88162e7d9c808763714e1548a612b2fffddbc1c" translate="yes" xml:space="preserve">
          <source>The contents can be any term but in order to simplify post processing of the traced events, a plain list of {Key, Value} tuples is preferred.</source>
          <target state="translated">내용은 임의의 용어 일 수 있지만 추적 된 이벤트의 사후 처리를 단순화하기 위해 {Key, Value} 튜플의 일반 목록이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="40ce0e904e227f1f1d80e3e97a8e2fc6da1aa9d8" translate="yes" xml:space="preserve">
          <source>The contents of a &lt;code&gt;Mnesia&lt;/code&gt; table are read into the registry.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 테이블 의 내용은 레지스트리로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="63f1bf049157e992729a0f1938f590c49c434454" translate="yes" xml:space="preserve">
          <source>The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are many top-level alternatives, they do not all have to have the same fixed length. Thus, the following is permitted:</source>
          <target state="translated">lookbehind 어설 션의 내용은 일치하는 모든 문자열의 길이가 고정되도록 제한됩니다. 그러나 최상위 레벨 대안이 많은 경우 모두 동일한 고정 길이를 가질 필요는 없습니다. 따라서 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b15d542467bd5d0c49c3d5fddfb0a1dc700a2884" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file &lt;code&gt;ch_app.app&lt;/code&gt; for a supervision tree application like &lt;code&gt;ch_app&lt;/code&gt; looks as follows:</source>
          <target state="translated">최소한의 내용 &lt;code&gt;.app&lt;/code&gt; 파일 &lt;code&gt;ch_app.app&lt;/code&gt; 같은 감독 트리 응용 프로그램에 대한 &lt;code&gt;ch_app&lt;/code&gt; 의 모습은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="639b540a4a0d636d1f2615d8325b2b0b321bfb43" translate="yes" xml:space="preserve">
          <source>The contents of a minimal &lt;code&gt;.app&lt;/code&gt; file for a library application &lt;code&gt;libapp&lt;/code&gt; looks as follows:</source>
          <target state="translated">라이브러리 애플리케이션 &lt;code&gt;libapp&lt;/code&gt; 에 대한 최소 &lt;code&gt;.app&lt;/code&gt; 파일 의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19e5034ffd4ea4853bdf97e8c08d5113058028a3" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="translated">레지스트리의 내용은 &quot;근처&quot;Erlang 노드의 &lt;code&gt;Mnesia&lt;/code&gt; 에 백업 할 수 있습니다 . Erlang 노드에 대한 개방형 연결을 제공해야합니다 ( &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt; 참조 ). 또한 백업을 시작하기 전에 &lt;code&gt;Mnesia&lt;/code&gt; 3.0 이상이 Erlang 노드에서 실행되고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d3ce5ee568b5e2c08421124a730a9db183b8eb2" translate="yes" xml:space="preserve">
          <source>The contents of a registry can be backed up to &lt;code&gt;Mnesia&lt;/code&gt; on a &quot;nearby&quot; Erlang node. You must provide an open connection to the Erlang node (see &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;). Also, &lt;code&gt;Mnesia&lt;/code&gt; 3.0 or later must be running on the Erlang node before the backup is initiated:</source>
          <target state="translated">레지스트리의 내용은 &quot;가까운&quot;Erlang 노드 에서 &lt;code&gt;Mnesia&lt;/code&gt; 에 백업 할 수 있습니다 . Erlang 노드에 대한 열린 연결을 제공해야합니다 ( &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; 참조 ). 또한 백업이 시작되기 전에 &lt;code&gt;Mnesia&lt;/code&gt; 노드 에서 Mnesia 3.0 이상이 실행 중이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b51f4efadaec6a78fd43d4f67f7894facdff63a" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iovec&lt;/code&gt; 의 내용은 호출 된 nif 함수가 반환 될 때까지 유효합니다. nif 호출이 반환 된 후 &lt;code&gt;iovec&lt;/code&gt; 이 유효해야하는 경우 &lt;code&gt;NULL&lt;/code&gt; 환경 에서이 함수를 호출 할 수 있습니다. 환경이 주어지지 않으면 &lt;code&gt;iovec&lt;/code&gt; 은 벡터의 데이터를 소유하고 &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec &lt;/a&gt;&lt;/code&gt; 를 사용하여 명시 적으로 해제 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3123b00654d44c25109223170c4027e9b8ae5329" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;iovec&lt;/code&gt; is valid until the called nif function returns. If the &lt;code&gt;iovec&lt;/code&gt; should be valid after the nif call returns, it is possible to call this function with a &lt;code&gt;NULL&lt;/code&gt; environment. If no environment is given the &lt;code&gt;iovec&lt;/code&gt; owns the data in the vector and it has to be explicitly freed using &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iovec&lt;/code&gt; 의 내용은 호출 된 nif 함수가 리턴 될 때까지 유효합니다. nif 호출이 리턴 된 후 &lt;code&gt;iovec&lt;/code&gt; 가 유효해야하는 경우 &lt;code&gt;NULL&lt;/code&gt; 환경 에서이 함수를 호출 할 수 있습니다. 환경이 주어지지 않으면 &lt;code&gt;iovec&lt;/code&gt; 는 벡터의 데이터를 소유하며 &lt;code&gt;&lt;a href=&quot;#enif_free_iovec&quot;&gt;enif_free_iovec&lt;/a&gt;&lt;/code&gt; 를 사용하여 명시 적으로 해제 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="da4fbdeab301fdc5a2057978a62de987cbe0d76f" translate="yes" xml:space="preserve">
          <source>The contents of the configuration file can either be fetched from the history or specified directly as a list of &lt;code&gt;{Mod,Func,Args}&lt;/code&gt;.</source>
          <target state="translated">구성 파일의 컨텐츠는 히스토리에서 가져 오거나 &lt;code&gt;{Mod,Func,Args}&lt;/code&gt; 목록으로 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1edda41fc99de03ce1cd51669b6fb86e783cb0c4" translate="yes" xml:space="preserve">
          <source>The contents of the source file is displayed in the &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">소스 파일의 내용이 &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b8b2dc86a62154fcfa0997ece50bee44a97b77c" translate="yes" xml:space="preserve">
          <source>The context information should be stored in a file called &lt;code&gt;context.conf&lt;/code&gt;. The default context &lt;code&gt;&quot;&quot;&lt;/code&gt; need not be present.</source>
          <target state="translated">컨텍스트 정보는 &lt;code&gt;context.conf&lt;/code&gt; 파일에 저장해야합니다 . 기본 컨텍스트 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 없어도됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9be9c755c53e0d2a6b371cd0fc254f9029ad4a" translate="yes" xml:space="preserve">
          <source>The continuation of a sequence of fragmented messages looks like this:</source>
          <target state="translated">단편화 된 메시지 시퀀스의 연속은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b66a3e2b8c6b44620e15f4c494d018a17436828d" translate="yes" xml:space="preserve">
          <source>The continuation of the first call to the re-entrant input functions must be &lt;code&gt;[]&lt;/code&gt;. For a complete description of how the re-entrant input scheme works, see Armstrong, Virding and Williams: 'Concurrent Programming in Erlang', Chapter 13.</source>
          <target state="translated">재진입 입력 기능에 대한 첫 번째 호출의 연속은 &lt;code&gt;[]&lt;/code&gt; 이어야합니다 . 재진입 입력 체계의 작동 방식에 대한 자세한 설명은 암스트롱, 비디오 및 윌리엄스 : 'Erlang의 동시 프로그래밍', 13 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd08931a87a0bff5df1d5b202657eaee82a9ec50" translate="yes" xml:space="preserve">
          <source>The continuation pointer, that is, the return address for the current call. Usually useless for other than runtime system developers. This can be followed by the function into which the CP points, which is the function calling the current function.</source>
          <target state="translated">연속 포인터, 즉 현재 통화의 반환 주소입니다. 일반적으로 런타임 시스템 개발자 이외의 사용자에게는 쓸모가 없습니다. 그 다음에 CP가 가리키는 기능, 즉 현재 기능을 호출하는 기능이 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea909336d43c335fbcba40445c38198c897e80b9" translate="yes" xml:space="preserve">
          <source>The contracts specified with &lt;code&gt;-callback&lt;/code&gt; attributes in behaviour modules can be further refined by adding &lt;code&gt;-spec&lt;/code&gt; attributes in callback modules. This can be useful as &lt;code&gt;-callback&lt;/code&gt; contracts are usually generic. The same callback module with contracts for the callbacks:</source>
          <target state="translated">동작 모듈에서 &lt;code&gt;-callback&lt;/code&gt; 속성으로 지정된 계약 은 콜백 모듈에서 &lt;code&gt;-spec&lt;/code&gt; 속성 을 추가하여 세분화 할 수 있습니다 . &lt;code&gt;-callback&lt;/code&gt; 계약이 일반적 이므로 일반적으로 유용합니다 . 콜백 계약이있는 동일한 콜백 모듈 :</target>
        </trans-unit>
        <trans-unit id="3e6798c48093d78537c9e8593283bd4708fcad75" translate="yes" xml:space="preserve">
          <source>The control codes that we have defined are as follows:</source>
          <target state="translated">우리가 정의한 제어 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7099cc27d42d7b0589281942854b91087bea547b" translate="yes" xml:space="preserve">
          <source>The control interface gets a buffer to return its value in, but is free to allocate its own buffer if the provided one is too small. The &lt;code&gt;uds_control&lt;/code&gt; code is as follows:</source>
          <target state="translated">제어 인터페이스는 값을 리턴하기 위해 버퍼를 가져 오지만 제공된 버퍼가 너무 작 으면 자체 버퍼를 자유롭게 할당 할 수 있습니다. &lt;code&gt;uds_control&lt;/code&gt; 에 다음과 같이 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="8a434b940ea607f47b9b9c9664fa9c1e4002f5da" translate="yes" xml:space="preserve">
          <source>The convention is that all modules implementing some web server functionality has the name &lt;code&gt;mod_*&lt;/code&gt;. When configuring the web server, an appropriate selection of these modules is to be present in the module directive. Notice that there are some interaction dependencies to take into account, so the order of the modules cannot be random.</source>
          <target state="translated">일부 웹 서버 기능을 구현하는 모든 모듈의 이름은 &lt;code&gt;mod_*&lt;/code&gt; 입니다. 웹 서버를 구성 할 때 모듈 지시문에 이러한 모듈을 적절히 선택해야합니다. 고려해야 할 일부 상호 작용 종속성이 있으므로 모듈의 순서는 임의로 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcdf44cdd25837172eef411728f5162a4d169998" translate="yes" xml:space="preserve">
          <source>The cookie can also be specified as a list with a single atom element.</source>
          <target state="translated">쿠키는 단일 원자 요소가있는 목록으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bba610bff46dca728cdd7bc764ef95f9fb34e4c" translate="yes" xml:space="preserve">
          <source>The cookie extension has two main purposes. It allows the server to force the client to demonstrate reachability at their apparent network address (thus providing a measure of DoS protection). This is primarily useful for non-connection-oriented transports. It also allows to offload the server's state to the client. The cookie extension is enabled by default as it is a mandatory extension in RFC8446.</source>
          <target state="translated">쿠키 확장에는 두 가지 주요 목적이 있습니다. 이를 통해 서버는 클라이언트가 명백한 네트워크 주소에서 도달 가능성을 보여 주도록 강제 할 수 있습니다 (따라서 DoS 보호 조치 제공). 이것은 주로 비 연결 지향 전송에 유용합니다. 또한 서버의 상태를 클라이언트로 오프로드 할 수 있습니다. 쿠키 확장은 RFC8446의 필수 확장이므로 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a59a7d0400e25bda45d94942c1696b67b821c833" translate="yes" xml:space="preserve">
          <source>The cookie on the client node is set to &lt;code&gt;Cookie&lt;/code&gt; for this &lt;code&gt;rpc&lt;/code&gt; operation (used to match the server node cookie).</source>
          <target state="translated">클라이언트 노드의 &lt;code&gt;Cookie&lt;/code&gt; 는이 &lt;code&gt;rpc&lt;/code&gt; 조작에 대해 쿠키 로 설정됩니다 (서버 노드 쿠키와 일치시키기 위해 사용됨).</target>
        </trans-unit>
        <trans-unit id="6205a4b626543ee584a8b3de17a0bb2edfe3da9f" translate="yes" xml:space="preserve">
          <source>The cookies are never sent in cleartext and the handshake procedure expects the client (called &lt;code&gt;A&lt;/code&gt;) to be the first one to prove that it can generate a sufficient digest. The digest is generated with the MD5 message digest algorithm and the challenges are expected to be random numbers.</source>
          <target state="translated">쿠키는 절대로 일반 텍스트로 전송되지 않으며 핸드 셰이크 절차에서는 클라이언트 ( &lt;code&gt;A&lt;/code&gt; )가 충분한 다이제스트를 생성 할 수 있음을 증명하는 첫 번째 클라이언트가 될 것으로 예상합니다 . 다이제스트는 MD5 메시지 다이제스트 알고리즘으로 생성되며 문제는 난수 일 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="2ecaa6909338c5156841fd64226c00c498a1c90e" translate="yes" xml:space="preserve">
          <source>The cookies are text strings that can be viewed as passwords.</source>
          <target state="translated">쿠키는 비밀번호로 볼 수있는 텍스트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1a8ed05dd2354fe2176cfcf5ee50be7c3c648bcb" translate="yes" xml:space="preserve">
          <source>The core applications ERTS, Kernel, STDLIB, and SASL never allow real soft upgrade, but require the Erlang emulator to be restarted. This is indicated to the &lt;code&gt;release_handler&lt;/code&gt; by the upgrade instruction &lt;code&gt;restart_new_emulator&lt;/code&gt;. This instruction is always the very first instruction executed, and it restarts the emulator with the new versions of the above mentioned core applications and the old versions of all other applications. When the node is back up, all other upgrade instructions are executed, making sure each application is finally running its new version.</source>
          <target state="translated">핵심 응용 프로그램 ERTS, Kernel, STDLIB 및 SASL은 실제 소프트 업그레이드를 허용하지 않지만 Erlang 에뮬레이터를 다시 시작해야합니다. 업그레이드 명령 &lt;code&gt;restart_new_emulator&lt;/code&gt; 에 의해 &lt;code&gt;release_handler&lt;/code&gt; 에 표시됩니다 . 이 명령어는 항상 가장 먼저 실행되는 명령어이며 위에 언급 된 핵심 응용 프로그램의 새 버전과 다른 모든 응용 프로그램의 이전 버전으로 에뮬레이터를 다시 시작합니다. 노드가 백업되면 다른 모든 업그레이드 지침이 실행되어 각 응용 프로그램이 최종적으로 새 버전을 실행하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0fa547ec967437cac7e726eba19268112eb4cac1" translate="yes" xml:space="preserve">
          <source>The correct way to write this example is as follows:</source>
          <target state="translated">이 예제를 작성하는 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff048cb1599c9ae21644f42bc221284ba85f60d6" translate="yes" xml:space="preserve">
          <source>The correctness of each application is checked as follows:</source>
          <target state="translated">각 응용 프로그램의 정확성은 다음과 같이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="551bede0ac40e7793c4662c9c5f268e49a7cfe5a" translate="yes" xml:space="preserve">
          <source>The correctness of time values.</source>
          <target state="translated">시간 값의 정확성</target>
        </trans-unit>
        <trans-unit id="b2a787c3a6b18144a9dd01cea8e8539d0c49480c" translate="yes" xml:space="preserve">
          <source>The corresponding Erlang assignments:</source>
          <target state="translated">해당 Erlang 과제 :</target>
        </trans-unit>
        <trans-unit id="f464085c70da2d1c15ec4fc3d649680a6fc01752" translate="yes" xml:space="preserve">
          <source>The corresponding Mnesia table is specified as follows:</source>
          <target state="translated">해당 Mnesia 테이블은 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="355cfe7dcddd0f236158f7c90d39becfb4d1ea88" translate="yes" xml:space="preserve">
          <source>The corresponding SNMP table would have three columns: &lt;code&gt;department&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;telno&lt;/code&gt;.</source>
          <target state="translated">해당 SNMP 테이블에는 &lt;code&gt;department&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;telno&lt;/code&gt; 의 세 열이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ba81bc06294c512d15b4e936f20c56b7b7af738" translate="yes" xml:space="preserve">
          <source>The corresponding library callback was unsuccessful.</source>
          <target state="translated">해당 라이브러리 콜백이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="3ed401667a17ba645dc4af42fafc330362e9b09e" translate="yes" xml:space="preserve">
          <source>The corresponding process or port is traced. The process or port may be a remote process or port (on another Erlang node). The node must be in the list of traced nodes (see &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">해당 프로세스 또는 포트가 추적됩니다. 프로세스 또는 포트는 원격 프로세스 또는 포트 일 수 있습니다 (다른 Erlang 노드에 있음). 노드는 추적 된 노드 목록에 있어야합니다 ( &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7fb4487b624fe2c0e433c8d91bb58ba0e2b99b60" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpCommunityTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-COMMUNITY-MIB의 &lt;code&gt;snmpCommunityTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="536e0673fdce81c6dcbd3b335e2956e57d01fa8e" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpNotifyTable&lt;/code&gt; in the SNMP-NOTIFICATION-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-NOTIFICATION-MIB에서 &lt;code&gt;snmpNotifyTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6418aba8dde22da1e13b2bb9b3980fe5619feec0" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; in the SNMP-TARGET-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-TARGET-MIB의 &lt;code&gt;snmpTargetParamsTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffadaae2726db08a3b84abd6faf037b185f11f98" translate="yes" xml:space="preserve">
          <source>The corresponding table is &lt;code&gt;usmUserTable&lt;/code&gt; in the SNMP-USER-BASED-SM-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-USER-BASED-SM-MIB의 &lt;code&gt;usmUserTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7dfdea70a637914fff122f7c22e23e4ca4a56c8f" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; in the SNMP-TARGET-MIB and &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; in the SNMP-COMMUNITY-MIB.</source>
          <target state="translated">해당 테이블은 &lt;code&gt;snmpTargetAddrTable&lt;/code&gt; 는 SNMP-TARGET-MIB 및 예약 &lt;code&gt;snmpTargetAddrExtTable&lt;/code&gt; 는 SNMP-COMMUNITY-MIB있다.</target>
        </trans-unit>
        <trans-unit id="12ecd355d2a9f8a115a05cf588ffb85e072514b8" translate="yes" xml:space="preserve">
          <source>The corresponding tables are &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt;, &lt;code&gt;vacmAccessTable&lt;/code&gt; and &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; in the SNMP-VIEW-BASED-ACM-MIB.</source>
          <target state="translated">해당 테이블은 SNMP-VIEW-BASED-ACM-MIB의 &lt;code&gt;vacmSecurityToGroupTable&lt;/code&gt; , &lt;code&gt;vacmAccessTable&lt;/code&gt; 및 &lt;code&gt;vacmViewTreeFamilyTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09299475ac2ec70dc802979c73301c27a76fa68a" translate="yes" xml:space="preserve">
          <source>The corresponding values were as follows:</source>
          <target state="translated">해당 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="270bee1ebec250d3d9f95f9db65ee55f7e7e584a" translate="yes" xml:space="preserve">
          <source>The cost is substantial: every returned answer is stored in an ETS table. Before returning an answer, it is looked up in the ETS table to check if it has already been returned. Without the &lt;code&gt;unique&lt;/code&gt; option, all answers to &lt;code&gt;QH1&lt;/code&gt; would be returned followed by all answers to &lt;code&gt;QH2&lt;/code&gt;. The &lt;code&gt;unique&lt;/code&gt; option keeps the order between the remaining answers.</source>
          <target state="translated">비용은 상당합니다. 반환 된 모든 답변은 ETS 테이블에 저장됩니다. 답변을 반환하기 전에 ETS 테이블에서 검색되어 이미 반환되었는지 확인합니다. &lt;code&gt;unique&lt;/code&gt; 옵션이 없으면 &lt;code&gt;QH1&lt;/code&gt; 에 대한 모든 답변과 &lt;code&gt;QH2&lt;/code&gt; 에 대한 모든 답변이 반환됩니다 . &lt;code&gt;unique&lt;/code&gt; 옵션은 남아있는 답변의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="949377933f7f31ae27260e61d2614522203d38cb" translate="yes" xml:space="preserve">
          <source>The counter is per listening port. Thus, if two daemons are started, one with &lt;code&gt;{max_sessions,N}&lt;/code&gt; and the other with &lt;code&gt;{max_sessions,M}&lt;/code&gt;, in total &lt;code&gt;N+M&lt;/code&gt; connections are accepted for the whole &lt;code&gt;ssh&lt;/code&gt; application.</source>
          <target state="translated">카운터는 수신 포트 당입니다. 따라서 두 개의 데몬 (하나는 &lt;code&gt;{max_sessions,N}&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;{max_sessions,M}&lt;/code&gt; ) 을 시작하면 전체 &lt;code&gt;ssh&lt;/code&gt; 애플리케이션에 대해 총 &lt;code&gt;N+M&lt;/code&gt; 연결이 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="672049e9dcd3a0014488ab809e18dd017dc67fc3" translate="yes" xml:space="preserve">
          <source>The crash report contains the previously stored information, such as ancestors and initial function, the termination reason, and information about other processes that terminate as a result of this process terminating.</source>
          <target state="translated">충돌 보고서에는 조상 및 초기 기능, 종료 이유 및이 프로세스 종료의 결과로 종료되는 다른 프로세스에 대한 정보와 같은 이전에 저장된 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e9528cde8205383b9d47742f84a963524c2a4c48" translate="yes" xml:space="preserve">
          <source>The crashed node is distributed but has no references to other nodes.</source>
          <target state="translated">충돌 한 노드가 분배되었지만 다른 노드에 대한 참조는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7beaf4ed3a100b4464262b486f549894f0ca1c0e" translate="yes" xml:space="preserve">
          <source>The crashed node is not distributed.</source>
          <target state="translated">충돌 한 노드가 분배되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ce14bb9518e3053298709463f31e4be173e33cd1" translate="yes" xml:space="preserve">
          <source>The created digraph has the same type as &lt;code&gt;Digraph&lt;/code&gt;. All vertices and edges have the default &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">작성된 digraph의 유형은 &lt;code&gt;Digraph&lt;/code&gt; 와 동일합니다 . 모든 정점과 모서리에는 기본 &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c87493c7d1e0ec2480a156b7c0c0a9bef2ce5f3" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">작성된 프로세스는 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 레코드 에서 핸드 셰이크에 필요한 콜백 및 기타 정보를 제공 하고이 레코드로 &lt;code&gt;dist_util:handshake_other_started(HsData)&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e43aa2bf5d37514d385457e53e7dee018f509f4d" translate="yes" xml:space="preserve">
          <source>The created process should provide callbacks and other information needed for the handshake in a &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record and call &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; with this record.</source>
          <target state="translated">생성 된 프로세스는 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 레코드 에서 핸드 셰이크에 필요한 콜백 및 기타 정보를 제공 하고이 레코드로 &lt;code&gt;dist_util:handshake_we_started(HsData)&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c10988c8597611573efffc7c6d796d8de4ec9158" translate="yes" xml:space="preserve">
          <source>The created supervisor process calls &lt;code&gt;Module:init/1&lt;/code&gt; to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, &lt;code&gt;start_link/2,3&lt;/code&gt; does not return until &lt;code&gt;Module:init/1&lt;/code&gt; has returned and all child processes have been started.</source>
          <target state="translated">생성 된 수퍼바이저 프로세스는 &lt;code&gt;Module:init/1&lt;/code&gt; 을 호출 하여 재시작 전략, 최대 재시작 강도 및 하위 프로세스를 찾습니다. 동기화 된 시작 절차를 보장하기 위해 &lt;code&gt;start_link/2,3&lt;/code&gt; 은 &lt;code&gt;Module:init/1&lt;/code&gt; 이 리턴되고 모든 하위 프로세스가 시작될 때까지 리턴되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="524da289676a51a69540a11b458a8fd944a7b7d9" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="translated">생성 된 스레드 는 &lt;code&gt;func&lt;/code&gt; 가 반환되거나 스레드가 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 종료됩니다 . 스레드의 종료 값은 &lt;code&gt;func&lt;/code&gt; 에서 반환 되거나 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt; erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 에 인수로 전달됩니다 . 스레드를 생성 하는 드라이버는 드라이버가 언로드되기 전에 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 을 통해 스레드를 연결 해야합니다. &quot;분리 된&quot;스레드, 즉 결합 할 필요가없는 스레드는 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39edf1d66d588998727b714263ec502579dd9e7b" translate="yes" xml:space="preserve">
          <source>The created thread terminates either when &lt;code&gt;func&lt;/code&gt; returns or if &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; is called by the thread. The exit value of the thread is either returned from &lt;code&gt;func&lt;/code&gt; or passed as argument to &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt;. The driver creating the thread is responsible for joining the thread, through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;, before the driver is unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not need to be joined.</source>
          <target state="translated">작성된 스레드 는 &lt;code&gt;func&lt;/code&gt; 가 리턴되거나 스레드가 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 를 호출 하면 종료됩니다 . 스레드의 종료 값은 &lt;code&gt;func&lt;/code&gt; 에서 리턴 되거나 인수로 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_exit&quot;&gt;erl_drv_thread_exit&lt;/a&gt;&lt;/code&gt; 에 전달됩니다 . 스레드를 작성 하는 드라이버는 드라이버가 언로드되기 전에 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 을 통해 스레드를 결합 해야합니다. &quot;분리 된&quot;스레드, 즉 결합 할 필요가없는 스레드를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2caf2e3a9d3cd22055ea221541023c0a7f9e5f06" translate="yes" xml:space="preserve">
          <source>The creation number for a listen socket, which is calculated as (the value found in the lock-file + 1) rem 4. This creation value is also written back into the lock file, so that the next invocation of the emulator finds our value in the file.</source>
          <target state="translated">청취 소켓의 작성 번호는 (lock-file + 1에서 찾은 값) rem 4로 계산됩니다.이 작성 값은 잠금 파일에 다시 쓰여 지므로 다음 에뮬레이터 호출이 값을 찾습니다. 파일에서.</target>
        </trans-unit>
        <trans-unit id="adcdb05ae9295c817de82d7381820b023af67f91" translate="yes" xml:space="preserve">
          <source>The creation number in pid &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">PID의 번호 생성 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f64ba9b5d10763eb9a59dc112c16b79857dd73" translate="yes" xml:space="preserve">
          <source>The creation number in port &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">포트의 생성 번호 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50c7d8a3f3ea2d88f57c174b641c9f8441bf8c61" translate="yes" xml:space="preserve">
          <source>The creation number in ref &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">ref &lt;code&gt;t&lt;/code&gt; 의 생성 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="1597c6b33ee04607a4ecaec944fa0178d3d2dc29" translate="yes" xml:space="preserve">
          <source>The creation of the specification for a target system is performed in two steps. In the first step a complete specification is generated. It will likely contain much more files than you are interested in in your customized target system. In the second step the specification will be filtered according to your filters. There you have the ability to specify filters per application as well as system wide filters. You can also select a &lt;code&gt;profile&lt;/code&gt; for your system. Depending on the &lt;code&gt;profile&lt;/code&gt;, different default filters will be used. There are three different profiles to choose from: &lt;code&gt;development&lt;/code&gt;, &lt;code&gt;embedded&lt;/code&gt; and &lt;code&gt;standalone&lt;/code&gt;. &lt;code&gt;development&lt;/code&gt; is default. The parameters that are affected by the &lt;code&gt;profile&lt;/code&gt; are: &lt;code&gt;incl_sys_filters&lt;/code&gt;, &lt;code&gt;excl_sys_filters&lt;/code&gt;, &lt;code&gt;incl_app_filters&lt;/code&gt; and &lt;code&gt;excl_app_filters&lt;/code&gt;.</source>
          <target state="translated">대상 시스템에 대한 스펙 작성은 두 단계로 수행됩니다. 첫 번째 단계에서 완전한 사양이 생성됩니다. 사용자 정의 된 대상 시스템에 원하는 것보다 훨씬 많은 파일이 포함되어있을 것입니다. 두 번째 단계에서는 사양이 필터에 따라 필터링됩니다. 시스템 전체 필터뿐만 아니라 응용 프로그램 당 필터를 지정할 수 있습니다. 시스템에 대한 &lt;code&gt;profile&lt;/code&gt; 을 선택할 수도 있습니다. &lt;code&gt;profile&lt;/code&gt; 에 따라 다른 기본 필터가 사용됩니다. &lt;code&gt;development&lt;/code&gt; , &lt;code&gt;embedded&lt;/code&gt; 및 &lt;code&gt;standalone&lt;/code&gt; 세 가지 프로파일 중에서 선택할 수 있습니다 . &lt;code&gt;development&lt;/code&gt; 이 기본값입니다. 에 의해 영향을받는 매개 변수 &lt;code&gt;profile&lt;/code&gt; 은 &lt;code&gt;incl_sys_filters&lt;/code&gt; , &lt;code&gt;excl_sys_filters&lt;/code&gt; , &lt;code&gt;incl_app_filters&lt;/code&gt; 및 &lt;code&gt;excl_app_filters&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0455f1d04df5058ea9aa40b1a076812ef2243c2" translate="yes" xml:space="preserve">
          <source>The creation time for the dump</source>
          <target state="translated">덤프 작성 시간</target>
        </trans-unit>
        <trans-unit id="65280108d9a3568933bcafdbf482cccdf0bd7634" translate="yes" xml:space="preserve">
          <source>The cross cover mechanism allows cover analysis of modules across multiple tests. It is useful if some code, for example, a library module, is used by many different tests and the accumulated cover result is desirable.</source>
          <target state="translated">크로스 커버 메커니즘을 사용하면 여러 테스트에서 모듈을 커버 분석 할 수 있습니다. 라이브러리 모듈과 같은 일부 코드를 여러 가지 다른 테스트에서 사용하고 누적 된 표지 결과가 바람직한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b20f15741df0176d3ffd68b64d6a68cc69323d01" translate="yes" xml:space="preserve">
          <source>The crypto application supports using OpenSSL in FIPS mode. In this scenario only the validated algorithms provided by the Object Module are accessible, other algorithms usually available in OpenSSL (like md5) or implemented in the Erlang code (like SRP) are disabled.</source>
          <target state="translated">암호화 응용 프로그램은 FIPS 모드에서 OpenSSL 사용을 지원합니다. 이 시나리오에서는 Object Module에서 제공하는 검증 된 알고리즘 만 액세스 할 수 있으며 일반적으로 OpenSSL (md5와 같은)에서 사용 가능하거나 Erlang 코드 (SRP와 같은)에서 구현되는 다른 알고리즘은 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="67aa64b8718cdca92f0e4f9624ec881b790bb44a" translate="yes" xml:space="preserve">
          <source>The cryptolib OTP is linked with, usally the one the OS uses, probably OpenSSL,</source>
          <target state="translated">cryptolib OTP는 일반적으로 OS가 사용하는 것과 연결되며 아마도 OpenSSL과</target>
        </trans-unit>
        <trans-unit id="492e509e88f1a8adb3eb77ab3f838d0078ce68f0" translate="yes" xml:space="preserve">
          <source>The current URI implementation provides support for producing and consuming standard URIs. The API is not meant to be directly exposed in a Web browser's address bar where users can basically enter free text. Application designers shall implement proper heuristics to map the input into a parsable URI.</source>
          <target state="translated">현재 URI 구현은 표준 URI 생성 및 사용을 지원합니다. API는 사용자가 기본적으로 자유 텍스트를 입력 할 수있는 웹 브라우저의 주소 표시 줄에 직접 노출되는 것이 아닙니다. 응용 프로그램 설계자는 입력을 구문 분석 가능한 URI에 매핑하기 위해 적절한 휴리스틱을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f0da38521cbe8e331fa3581916f1bfca4dc26d7" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send a &quot;demonitor signal&quot; to the monitored entity and ignore any future results of the monitor.</source>
          <target state="translated">현재 동작은 두 가지 결합 된 작업으로 볼 수 있습니다. &quot;모니터링 신호&quot;를 모니터링 된 엔터티에 비동기 적으로 전송하고 향후 모니터 결과를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3c2e4d473b72e94c41373ad9e09ba22c294ebb64" translate="yes" xml:space="preserve">
          <source>The current behavior can be viewed as two combined operations: asynchronously send an &quot;unlink signal&quot; to the linked entity and ignore any future results of the link.</source>
          <target state="translated">현재 동작은 두 가지 결합 된 작업으로 볼 수 있습니다. 링크 된 엔터티에 &quot;링크 해제 신호&quot;를 비동기 적으로 보내고 링크의 향후 결과는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d5b1d2a40e48d00196c6b21b7ac5dc93cf3228c9" translate="yes" xml:space="preserve">
          <source>The current function of the process. These fields do not always exist.</source>
          <target state="translated">프로세스의 현재 기능. 이 필드가 항상 존재하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="976f361d5fa6f84f4966eb0b28babd0491898a1f" translate="yes" xml:space="preserve">
          <source>The current implementation assumes the requests to the same host, port combination will use the same socket options.</source>
          <target state="translated">현재 구현에서는 동일한 호스트에 대한 요청을 가정하고 포트 조합은 동일한 소켓 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="01444d008abb77ac03ebfb5697a017f621eb7172" translate="yes" xml:space="preserve">
          <source>The current implementation of &lt;code&gt;erts_alloc_config&lt;/code&gt; concentrate on configuration of multi-block carriers. Information gathered when a runtime scenario is saved is mainly current and maximum use of multi-block carriers. If a parameter that change the use of multi-block carriers is changed, a previously generated configuration is invalid and &lt;code&gt;erts_alloc_config&lt;/code&gt; needs to be run again. It is mainly the single block carrier threshold that effects the use of multi-block carriers, but other single-block carrier parameters might as well. If another value of a single block carrier parameter than the default is desired, use the desired value when running &lt;code&gt;erts_alloc_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erts_alloc_config&lt;/code&gt; 의 현재 구현은 다중 블록 반송파 구성에 중점을 둡니다 . 런타임 시나리오가 저장 될 때 수집되는 정보는 주로 현재 및 최대 멀티 블록 캐리어 사용입니다. 다중 블록 반송파 사용을 변경하는 매개 변수가 변경되면 이전에 생성 된 구성이 유효하지 않으며 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 다시 실행해야합니다. 다중 블록 반송파의 사용에 영향을 미치는 것은 주로 단일 블록 반송파 임계 값이지만 다른 단일 블록 반송파 매개 변수도 가능합니다. 기본값 이외의 단일 블록 캐리어 매개 변수의 다른 값이 필요한 경우 &lt;code&gt;erts_alloc_config&lt;/code&gt; 를 실행할 때 원하는 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b881e02c8b7eb97ec891648e528239530b927d31" translate="yes" xml:space="preserve">
          <source>The current implementation of Erlang does not care if the connection to the EPMD is broken.</source>
          <target state="translated">Erlang의 현재 구현은 EPMD에 대한 연결이 끊어 졌는지 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5aa015243755c53ad9ba52e113a6e0dd6e7a2f3a" translate="yes" xml:space="preserve">
          <source>The current implementation of persistent terms uses the literal &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;allocator&lt;/a&gt;&lt;/code&gt; also used for literals (constant terms) in BEAM code. By default, 1 GB of virtual address space is reserved for literals in BEAM code and persistent terms. The amount of virtual address space reserved for literals can be changed by using the &lt;code&gt;&lt;a href=&quot;erts_alloc#MIscs&quot;&gt;+MIscs option&lt;/a&gt;&lt;/code&gt; when starting the emulator.</source>
          <target state="translated">현재 영구 용어 구현은 BEAM 코드에서 리터럴 (상수 용어)에도 사용되는 리터럴 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;allocator&lt;/a&gt;&lt;/code&gt; 사용합니다. 기본적으로 1GB의 가상 주소 공간은 BEAM 코드 및 영구 용어의 리터럴 용으로 예약되어 있습니다. 에뮬레이터를 시작할 때 &lt;code&gt;&lt;a href=&quot;erts_alloc#MIscs&quot;&gt;+MIscs option&lt;/a&gt;&lt;/code&gt; 을 사용하여 리터럴 용으로 예약 된 가상 주소 공간의 양을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fc5fcd6f03a44ee0e92fb43ab0fad65cf1d2c29" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port program written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="translated">현재 구현은 실제 ODBC 드라이버를 사용하는 C로 작성된 포트 프로그램을 생성합니다. 이 포트 프로그램이 Erlang ODBC 응용 프로그램에 연결하는 데 기본 제한 시간은 5000 밀리 초입니다. 이 시간 제한은 ODBC 응용 프로그램에 대한 밀리 초 수로 응용 프로그램 특정 환경 변수 'port_timeout'을 설정하여 변경할 수 있습니다. 예 : [{odbc, [{port_timeout, 60000}]}]를 60 초로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="906db1d57b72f269a5be2b6efa0e34d3a4f40e71" translate="yes" xml:space="preserve">
          <source>The current implementation spawns a port programm written in C that utilizes the actual ODBC driver. There is a default timeout of 5000 msec for this port programm to connect to the Erlang ODBC application. This timeout can be changed by setting an application specific environment variable 'port_timeout' with the number of milliseconds for the ODBC application. E.g.: [{odbc, [{port_timeout, 60000}]}] to set it to 60 seconds.</source>
          <target state="translated">현재 구현은 실제 ODBC 드라이버를 사용하는 C로 작성된 포트 프로그램을 생성합니다. 이 포트 프로그램이 Erlang ODBC 응용 프로그램에 연결하기위한 기본 시간 종료는 5000msec입니다. ODBC 응용 프로그램에 대해 응용 프로그램 특정 환경 변수 'port_timeout'을 밀리 초 수로 설정하여이 시간 종료를 변경할 수 있습니다. 예 : [{odbc, [{port_timeout, 60000}]}]을 (를) 60 초로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a66939d304da82c348947adb4cca67a3063533ce" translate="yes" xml:space="preserve">
          <source>The current implementation uses a pair of Bloom filters to implement the last two mechanisms. Bloom filters are fast, memory-efficient, probabilistic data structures that can tell if an element may be in a set or if it is definitely not in the set.</source>
          <target state="translated">현재 구현에서는 한 쌍의 Bloom 필터를 사용하여 마지막 두 메커니즘을 구현합니다. 블룸 필터는 빠르고 메모리 효율적이며 확률적인 데이터 구조로 요소가 세트에 있는지 또는 확실히 세트에 없는지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d365424f69367126413adcf57829b464b5f9add" translate="yes" xml:space="preserve">
          <source>The current instruction pointer. This is only of interest for runtime system developers. The function into which the program counter points is the current function of the process.</source>
          <target state="translated">현재 명령어 포인터. 이것은 런타임 시스템 개발자에게만 해당됩니다. 프로그램 카운터가 가리키는 기능은 프로세스의 현재 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="translated">현재 줄 번호</target>
        </trans-unit>
        <trans-unit id="67653b4ba83e7d00b28af91f8d3fe0dae7dfae29" translate="yes" xml:space="preserve">
          <source>The current local working directory (compare &lt;code&gt;lpwd/1&lt;/code&gt;) is set to the value reported by &lt;code&gt;file:get_cwd/1&lt;/code&gt;, the wanted local directory.</source>
          <target state="translated">현재 로컬 작업 디렉토리 ( &lt;code&gt;lpwd/1&lt;/code&gt; 비교 )는 원하는 로컬 디렉토리 인 &lt;code&gt;file:get_cwd/1&lt;/code&gt; 에 의해보고 된 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bd1444e43ba871d9585120022333d4590131f8a" translate="yes" xml:space="preserve">
          <source>The current options are:</source>
          <target state="translated">현재 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5616c509d6bccb6c79f91ec22fce5ea75deae243" translate="yes" xml:space="preserve">
          <source>The current position of the file after the operation is undefined for &lt;code&gt;raw&lt;/code&gt; mode and unchanged for &lt;code&gt;ram&lt;/code&gt; mode.</source>
          <target state="translated">작업 후 파일의 현재 위치는 &lt;code&gt;raw&lt;/code&gt; 모드에 대해 정의되지 않고 &lt;code&gt;ram&lt;/code&gt; 모드에 대해 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="51b93308e4fc131191ae4908faed86620396f4d9" translate="yes" xml:space="preserve">
          <source>The current position of the file is undefined after the operation.</source>
          <target state="translated">조작 후 파일의 현재 위치는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a23e8329113f0ad4178af5cd91d27561b0a29cbd" translate="yes" xml:space="preserve">
          <source>The current reference count after the decrement has been performed is returned.</source>
          <target state="translated">감소가 수행 된 후 현재 참조 카운트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="24502690d2f3bb086d825806372b93e14c48a509" translate="yes" xml:space="preserve">
          <source>The current reference count after the increment has been performed is returned.</source>
          <target state="translated">증분이 수행 된 후 현재 참조 카운트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd7feb388311de9e1a9de0daaa94dc63a945932" translate="yes" xml:space="preserve">
          <source>The current status of the &lt;code&gt;init&lt;/code&gt; process can be inspected. During system startup (initialization), &lt;code&gt;InternalStatus&lt;/code&gt; is &lt;code&gt;starting&lt;/code&gt;, and &lt;code&gt;ProvidedStatus&lt;/code&gt; indicates how far the boot script has been interpreted. Each &lt;code&gt;{progress, Info}&lt;/code&gt; term interpreted in the boot script affects &lt;code&gt;ProvidedStatus&lt;/code&gt;, that is, &lt;code&gt;ProvidedStatus&lt;/code&gt; gets the value of &lt;code&gt;Info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 프로세스 의 현재 상태를 검사 할 수 있습니다. 시스템 시작 (초기화) 동안 &lt;code&gt;InternalStatus&lt;/code&gt; 가 &lt;code&gt;starting&lt;/code&gt; 되고 &lt;code&gt;ProvidedStatus&lt;/code&gt; 는 부팅 스크립트가 해석 된 정도를 나타냅니다. 부팅 스크립트에서 해석 된 각 &lt;code&gt;{progress, Info}&lt;/code&gt; 용어는 &lt;code&gt;ProvidedStatus&lt;/code&gt; 에 영향을줍니다 . 즉 &lt;code&gt;ProvidedStatus&lt;/code&gt; 는 &lt;code&gt;Info&lt;/code&gt; 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b80e18839956d4be32e5bd88643c826f791ac807" translate="yes" xml:space="preserve">
          <source>The current status, one of the following:</source>
          <target state="translated">다음 중 하나의 현재 상태 :</target>
        </trans-unit>
        <trans-unit id="c7113183a7426c44fe409b00b899d8a41fc5814b" translate="yes" xml:space="preserve">
          <source>The current system access to the file.</source>
          <target state="translated">파일에 대한 현재 시스템 액세스</target>
        </trans-unit>
        <trans-unit id="8ada96b90a0d9236a710ef755016c1b7cca9e74d" translate="yes" xml:space="preserve">
          <source>The current token of a process is set in one of the following two ways:</source>
          <target state="translated">프로세스의 현재 토큰은 다음 두 가지 방법 중 하나로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="283b878d1d463389e9688a4d3aa6791beee18572" translate="yes" xml:space="preserve">
          <source>The current type/state of the port, which can be one of the values declared above.</source>
          <target state="translated">포트의 현재 유형 / 상태. 위에서 선언 된 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d59825d9fb6ddec0b7e1b9ca60e8a4611098dbe2" translate="yes" xml:space="preserve">
          <source>The current version of &lt;code&gt;Mnesia&lt;/code&gt; does not require that the name of the table is the same as the record name, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 현재 버전 에서는 테이블 이름이 레코드 이름과 동일하지 않아도됩니다 ( &lt;code&gt;&lt;a href=&quot;mnesia_chap4#recordnames_tablenames&quot;&gt;Record Names versus Table Names.&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c67d44d5188c140bb3bee7f987dfb33d7ef9f83" translate="yes" xml:space="preserve">
          <source>The current working directory</source>
          <target state="translated">현재 작업 디렉토리</target>
        </trans-unit>
        <trans-unit id="76bbefce7d446f03b26631d5bb9ced8525a0f785" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This is to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="translated">현재 작업 디렉토리 &lt;code&gt;&quot;.&quot;&lt;/code&gt; , 컴파일러를 실행할 때 코드 경로에 포함되지 않습니다. 이는 컴파일러 또는 컴파일러가 사용하는 Erlang / OTP 시스템과 잠재적으로 충돌 할 수있는 현재 작업 디렉토리에서 Beam 파일을로드하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="61d4a882ed6c30c03ae65ca2d8cd5ad27f2a5741" translate="yes" xml:space="preserve">
          <source>The current working directory, &lt;code&gt;&quot;.&quot;&lt;/code&gt;, is not included in the code path when running the compiler. This to avoid loading Beam files from the current working directory that could potentially be in conflict with the compiler or the Erlang/OTP system used by the compiler.</source>
          <target state="translated">현재 작업 디렉토리 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 는 컴파일러를 실행할 때 코드 경로에 포함되지 않습니다. 이것은 현재 작업 디렉토리에서 컴파일러 또는 컴파일러가 사용하는 Erlang / OTP 시스템과 충돌 할 수있는 Beam 파일을로드하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="2fa5b9ac3977e02e3cf7d97b73ce85358c04959d" translate="yes" xml:space="preserve">
          <source>The currently executing process (that is, the sender) is not alive.</source>
          <target state="translated">현재 실행중인 프로세스 (즉, 발신자)가 활성 상태가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="953e09eadeb4be83fa11df49bf70c92f526cc8f1" translate="yes" xml:space="preserve">
          <source>The daemon is started automatically by command &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; if the node is to be distributed and no running instance is present. If automatically launched environment variables must be used to change the behavior of the daemon; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">노드가 분배되고 실행중인 인스턴스가없는 경우 명령 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; 의해 디먼이 자동으로 시작됩니다 . 자동으로 시작된 환경 변수를 사용하여 데몬의 동작을 변경해야합니다. &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d21e1220084b94119a9a3ad063df2a21e482723" translate="yes" xml:space="preserve">
          <source>The data bytes of the AVP.</source>
          <target state="translated">AVP의 데이터 바이트.</target>
        </trans-unit>
        <trans-unit id="f18388ef7ec4c10925540637ae1909f34a929370" translate="yes" xml:space="preserve">
          <source>The data contains errors.</source>
          <target state="translated">데이터에 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="078b2a841f3b60a68b21c7cb12cdb8e09a9dd362" translate="yes" xml:space="preserve">
          <source>The data delivery order can be relaxed by disabling features that require strict ordering. This is done by passing the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; returned by &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; record used when setting up the connection. When relaxed ordering is used, only the order of signals with the same sender/receiver pair has to be preserved. However, note that disabling the features that require strict ordering may have a negative impact on performance, throughput, and/or latency.</source>
          <target state="translated">엄격한 주문이 필요한 기능을 비활성화하여 데이터 전송 주문을 완화 할 수 있습니다. 연결 설정시 사용 된 &lt;code&gt;&lt;a href=&quot;#hs_data_record&quot;&gt;#hs_data{}&lt;/a&gt;&lt;/code&gt; 레코드 의 &lt;code&gt;&lt;a href=&quot;alt_dist#hs_data_reject_flags&quot;&gt;reject_flags&lt;/a&gt;&lt;/code&gt; 필드 에서 &lt;code&gt;dist_util:strict_order_flags/0&lt;/code&gt; 에 의해 리턴 된 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flags&lt;/a&gt;&lt;/code&gt; 를 전달하면 됩니다. 완화 된 순서를 사용하는 경우 동일한 발신자 / 수신자 쌍을 가진 신호의 순서 만 유지해야합니다. 그러나 엄격한 순서를 요구하는 기능을 비활성화하면 성능, 처리량 및 / 또는 대기 시간에 부정적인 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a26a04ef322bb19505a5c1dc8d45f5e01e5f3f" translate="yes" xml:space="preserve">
          <source>The data formats defined in sections 4.2 (&quot;Basic AVP Data Formats&quot;) and 4.3 (&quot;Derived AVP Data Formats&quot;) of RFC 6733 are encoded as values of the types defined here. Values are passed to &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; in a request record when sending a request, returned in a resulting answer record and passed to a &lt;code&gt;handle_request/3&lt;/code&gt; callback upon reception of an incoming request.</source>
          <target state="translated">RFC 6733의 섹션 4.2 ( &quot;기본 AVP 데이터 형식&quot;) 및 4.3 ( &quot;파생 AVP 데이터 형식&quot;)에 정의 된 데이터 형식은 여기에 정의 된 유형의 값으로 인코딩됩니다. 요청을 보낼 때 요청 레코드에서 값이 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 로 전달되고, 결과 응답 레코드로 리턴되며 수신 요청을 수신 하면 &lt;code&gt;handle_request/3&lt;/code&gt; 콜백으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdf833224017bb981586f311e5704bede95ecd92" translate="yes" xml:space="preserve">
          <source>The data in the boot script, fetched from the new application resource file &lt;code&gt;App.app&lt;/code&gt;</source>
          <target state="translated">새 응용 프로그램 리소스 파일 &lt;code&gt;App.app&lt;/code&gt; 에서 가져온 부팅 스크립트의 데이터</target>
        </trans-unit>
        <trans-unit id="bf8c73b58d26cdb1cd37eb82749dddb7b4d25b8e" translate="yes" xml:space="preserve">
          <source>The data in the header is sent as a list and the binary as an Erlang binary in the tail of the list.</source>
          <target state="translated">헤더의 데이터는 목록으로 전송되고 이진은 목록의 끝에 Erlang 이진으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fe96a6cdbbb26d9c1b8c04531c8c51ed5ebb111d" translate="yes" xml:space="preserve">
          <source>The data is at &lt;code&gt;p&lt;/code&gt;. The length of the bit string is &lt;code&gt;nbits&lt;/code&gt; bits. The first &lt;code&gt;bitoffs&lt;/code&gt; bits of the data at &lt;code&gt;p&lt;/code&gt; are unused. The first byte which is part of the bit string is &lt;code&gt;p[bitoffs/8]&lt;/code&gt;. The &lt;code&gt;bitoffs%8&lt;/code&gt; most significant bits of the first byte &lt;code&gt;p[bitoffs/8]&lt;/code&gt; are unused.</source>
          <target state="translated">데이터는 &lt;code&gt;p&lt;/code&gt; 에 있습니다. 비트 문자열의 길이는 &lt;code&gt;nbits&lt;/code&gt; 비트입니다. &lt;code&gt;p&lt;/code&gt; 에있는 데이터 의 첫 번째 &lt;code&gt;bitoffs&lt;/code&gt; 비트 는 사용되지 않습니다. 비트 문자열의 일부인 첫 번째 바이트는 &lt;code&gt;p[bitoffs/8]&lt;/code&gt; 입니다. 첫 번째 바이트 &lt;code&gt;p[bitoffs/8]&lt;/code&gt; 의 &lt;code&gt;bitoffs%8&lt;/code&gt; 최상위 비트 는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e8a427227bcde27fb34708c1f8037df0476db96" translate="yes" xml:space="preserve">
          <source>The data is queued in the port owner process' message queue. Notice that this does not yield to the emulator (as the driver and the emulator run in the same thread).</source>
          <target state="translated">데이터는 포트 소유자 프로세스의 메시지 큐에 대기합니다. 드라이버와 에뮬레이터가 동일한 스레드에서 실행되기 때문에 에뮬레이터에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5209f4c8cd33cb9b06c7cafb6cfe1d7ba8e19dd5" translate="yes" xml:space="preserve">
          <source>The data is thus at &lt;code&gt;buf[*index]&lt;/code&gt; when an &lt;code&gt;ei&lt;/code&gt; function is called.</source>
          <target state="translated">따라서 &lt;code&gt;ei&lt;/code&gt; 함수가 호출 될 때 데이터는 &lt;code&gt;buf[*index]&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0aaa71e50e0fe09624f658b5194caa4fc82ffa" translate="yes" xml:space="preserve">
          <source>The data model employed by &lt;code&gt;Mnesia&lt;/code&gt; is an extended relational data model. Data is organized as a set of tables and relations between different data records can be modeled as more tables describing the relationships. Each table contains instances of Erlang records. The records are represented as Erlang tuples.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 에서 사용하는 데이터 모델 은 확장 된 관계형 데이터 모델입니다. 데이터는 테이블 세트로 구성되며 다른 데이터 레코드 간의 관계는 관계를 설명하는 더 많은 테이블로 모델링 될 수 있습니다. 각 테이블에는 Erlang 레코드의 인스턴스가 있습니다. 레코드는 Erlang 튜플로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bcffc5bb38e63b17337f4be90db30aa76b246a80" translate="yes" xml:space="preserve">
          <source>The data produced by the lock counters will give an estimate on how well the runtime system will behave from a parallelizable view point for the scenarios tested. This tool was mainly developed to help Erlang runtime developers iron out potential and generic bottlenecks.</source>
          <target state="translated">잠금 카운터에 의해 생성 된 데이터는 테스트 된 시나리오에 대해 런타임 시스템이 병렬화 가능한 관점에서 얼마나 잘 작동하는지 추정합니다. 이 도구는 주로 Erlang 런타임 개발자가 잠재적이고 일반적인 병목 현상을 해결하도록 돕기 위해 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="2d27f50b0cd05524a7fd478c731d913e31e93736" translate="yes" xml:space="preserve">
          <source>The data representing a queue as used by this module is to be regarded as opaque by other modules. Any code assuming knowledge of the format is running on thin ice.</source>
          <target state="translated">이 모듈에서 사용되는 대기열을 나타내는 데이터는 다른 모듈에서는 불투명 한 것으로 간주됩니다. 형식에 대한 지식을 전제로 한 모든 코드는 얇은 얼음에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="53c6baece120e0ea5f4f690528bc1b24d8b68a2f" translate="yes" xml:space="preserve">
          <source>The data structure referring to this single linked list cover two cache lines. One cache line containing information about the head of the list, and one cache line containing information about the tail of the list. This in order to reduce cache line ping ponging of this data structure. The head of the list will only be manipulated by the thread owning the allocator instance, and the tail will be manipulated by other threads inserting deallocation jobs.</source>
          <target state="translated">이 단일 연결 목록을 참조하는 데이터 구조는 두 개의 캐시 라인을 포함합니다. 목록의 헤드에 대한 정보를 포함하는 하나의 캐시 라인과 목록의 꼬리에 대한 정보를 포함하는 하나의 캐시 라인. 이것은이 데이터 구조의 캐시 라인 핑퐁을 줄이기위한 것입니다. 목록의 헤드는 할당 자 인스턴스를 소유 한 스레드에 의해서만 조작되고 꼬리는 할당 해제 작업을 삽입하는 다른 스레드에 의해 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="966785b6ae629e19c8bed0b0d3e6ef6f991ec06e" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; in event &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 과 함께 제공되는 데이터는 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_done&quot;&gt;tc_done&lt;/a&gt;&lt;/code&gt; 이벤트의 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#failreason&quot;&gt;FailReason&lt;/a&gt;&lt;/code&gt; 과 동일한 형식을 따릅니다 . 자세한 내용 은 사용 설명서의 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb604c10fe966845cdde71367a93dbf6cc929795" translate="yes" xml:space="preserve">
          <source>The data that comes with &lt;code&gt;Reason&lt;/code&gt; follows the same format as events &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; For details, see section &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 와 함께 제공되는 데이터는 이벤트 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_auto_skip&quot;&gt;tc_auto_skip&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#tc_user_skip&quot;&gt;tc_user_skip&lt;/a&gt;&lt;/code&gt; 와 동일한 형식을 따릅니다. 자세한 내용 은 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;event_handler_chapter#events&quot;&gt;Event Handling&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ae9537a2b782dfe6dcee8743658b21ed9b0301d" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt;, is represented as the following erlang record:</source>
          <target state="translated">&lt;code&gt;'AttributeTypeAndValue'&lt;/code&gt; 데이터 유형 은 다음 erlang 레코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="feae33cf3d811c301bdaf1550728e179af863677" translate="yes" xml:space="preserve">
          <source>The data types &lt;code&gt;'Validity'&lt;/code&gt;, &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, and &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; are represented as the following Erlang records:</source>
          <target state="translated">&lt;code&gt;'Validity'&lt;/code&gt; , &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; 및 &lt;code&gt;'SubjectPublicKeyInfoAlgorithm'&lt;/code&gt; 데이터 유형 은 다음 Erlang 레코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="93bf041facbb4e82a9e8c285ac8447b2c8201746" translate="yes" xml:space="preserve">
          <source>The database can also become inconsistent if configuration parameter &lt;code&gt;max_wait_for_decision&lt;/code&gt; is used or if &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; is used.</source>
          <target state="translated">구성 매개 변수 &lt;code&gt;max_wait_for_decision&lt;/code&gt; 이 사용되거나 &lt;code&gt;mnesia:force_load_table/1&lt;/code&gt; 이 사용되는 경우에도 데이터베이스가 일치하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="264b842db8bf0ed81b261f12d4ee28f9ed7af246" translate="yes" xml:space="preserve">
          <source>The database can be reconfigured, and tables can be moved between nodes. These operations do not affect the user programs.</source>
          <target state="translated">데이터베이스를 재구성하고 노드간에 테이블을 이동할 수 있습니다. 이러한 작업은 사용자 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c3e27d69c9e2bbfe084964b4ba1a3ee0b761dd5" translate="yes" xml:space="preserve">
          <source>The database model is as follows:</source>
          <target state="translated">데이터베이스 모델은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b5b0c5d2b259e474f8fd1130e7a9869d03ac6fb" translate="yes" xml:space="preserve">
          <source>The date and time when the process was started.</source>
          <target state="translated">프로세스가 시작된 날짜 및 시간</target>
        </trans-unit>
        <trans-unit id="fe8362a1d9af54200a42df54d2c52d6145175ad5" translate="yes" xml:space="preserve">
          <source>The debug enabled runtime system features lock violation checking, assert checking and various sanity checks to help a developer ensure correctness. Some of these features can be enabled on a normal beam using appropriate configure options.</source>
          <target state="translated">디버그 가능 런타임 시스템은 잠금 위반 검사, 어설트 검사 및 다양한 온 전성 검사를 통해 개발자가 정확성을 보장 할 수 있습니다. 이러한 기능 중 일부는 적절한 구성 옵션을 사용하여 일반 빔에서 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6dd12423efe39c011d13a41f3ecdda00e9c96f5" translate="yes" xml:space="preserve">
          <source>The debug information can also be removed from BEAM files using &lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt;, and/or &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#strip-1&quot;&gt;strip/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#strip_files-1&quot;&gt;strip_files/1&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;#strip_release-1&quot;&gt;strip_release/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 디버그 정보를 BEAM 파일에서 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fcf3b68d8f8e511e6ff9331d892546d1029cbf5" translate="yes" xml:space="preserve">
          <source>The debug information can be encrypted to keep the source code secret, but still be able to use tools such as Debugger or Xref.</source>
          <target state="translated">디버그 정보는 소스 코드를 비밀로 유지하기 위해 암호화 될 수 있지만 여전히 디버거 또는 외부 참조와 같은 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fcc7761d46f20ec162261ce0e8d0b6a28d90fe6" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; is set by calling the function &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Level&lt;/code&gt;is one of the following:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 의 디버그 레벨은 mnesia &lt;code&gt;&lt;a href=&quot;mnesia#set_debug_level-1&quot;&gt;mnesia:set_debug_level(Level)&lt;/a&gt;&lt;/code&gt; 함수를 호출하여 설정됩니다 . 여기서 &lt;code&gt;Level&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="8f1bdc53b01108885cce2234b4e2d9b39baa8b28" translate="yes" xml:space="preserve">
          <source>The debug level of &lt;code&gt;Mnesia&lt;/code&gt; itself is also an application parameter, making it possible to start an Erlang system to turn on &lt;code&gt;Mnesia&lt;/code&gt; debug in the initial startup phase by using the following code:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 자체 의 디버그 수준은 응용 프로그램 매개 변수이기도하며 다음 코드를 사용하여 Erlang 시스템을 시작하여 초기 시작 단계에서 &lt;code&gt;Mnesia&lt;/code&gt; 디버그 를 켤 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f3b5f9fa804bcf46e507eb72dd7777e9dc6ab9" translate="yes" xml:space="preserve">
          <source>The decode and encode functions use a buffer and an index into the buffer, which points at the point where to encode and decode. The index is updated to point right after the term encoded/decoded. No checking is done whether the term fits in the buffer or not. If encoding goes outside the buffer, the program can crash.</source>
          <target state="translated">디코드 및 인코딩 함수는 버퍼에 대한 인덱스와 인덱스를 사용하며,이 인덱스는 인코딩 및 디코딩 할 지점을 가리 킵니다. 색인은 인코딩 / 디코딩 된 용어 바로 다음을 가리 키도록 업데이트됩니다. 용어가 버퍼에 맞는지 여부는 확인되지 않습니다. 인코딩이 버퍼를 벗어나면 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb7a0f41f8f9cd301571e70dc3544c6857e6778d" translate="yes" xml:space="preserve">
          <source>The decode functions return a record as result when decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; or a &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">디코딩 함수는 &lt;code&gt;SEQUENCE&lt;/code&gt; 또는 &lt;code&gt;SET&lt;/code&gt; 디코딩시 결과로 레코드를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cef0dcfb934889d6cf431e5ebf6fd74edf18c281" translate="yes" xml:space="preserve">
          <source>The decoded value of an AVP. Will be &lt;code&gt;undefined&lt;/code&gt; on decode if the data bytes could not be decoded, the AVP is unknown, or if the &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;. The type of a decoded value is as document in &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AVP의 디코딩 된 값. 됩니까 &lt;code&gt;undefined&lt;/code&gt; 데이터 바이트를 디코딩 할 수없는 경우 디코드에서 AVP를 알 수 없거나 경우 &lt;code&gt;&lt;a href=&quot;diameter#decode_format&quot;&gt;decode format&lt;/a&gt;&lt;/code&gt; 없는 &lt;code&gt;none&lt;/code&gt; . 디코딩 된 값의 유형은 &lt;code&gt;&lt;a href=&quot;diameter_dict#DATA_TYPES&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 문서와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9dd25b2c0dae34a4ccb0be97da547058ad3ae8fb" translate="yes" xml:space="preserve">
          <source>The decoder returns an atom if the value corresponds to a symbol in the &lt;code&gt;Named Number List&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;Named Number List&lt;/code&gt; 의 기호에 해당하면 디코더는 원자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c388aad8aed6c9f2fdd03a9ff95a76e605fea9f6" translate="yes" xml:space="preserve">
          <source>The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). If locale-specific matching is taking place, the list of space characters may be different; there may be fewer or more of them. &quot;Space&quot; used to be different to \s, which did not include VT, for Perl compatibility. However, Perl changed at release 5.18, and PCRE followed at release 8.34. &quot;Space&quot; and \s now match the same set of characters.</source>
          <target state="translated">기본 &quot;공백&quot;문자는 HT (9), LF (10), VT (11), FF (12), CR (13) 및 공백 (32)입니다. 로케일 별 일치가 발생하면 공백 문자 목록이 다를 수 있습니다. 더 적거나 더있을 수 있습니다. &quot;공간&quot;은 Perl 호환성을 위해 VT를 포함하지 않은 \ s와 다릅니다. 그러나 Perl은 릴리스 5.18에서 변경되었으며 PCRE는 릴리스 8.34에서 변경되었습니다. &quot;Space&quot;와 \ s는 이제 같은 문자 집합과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c59d65c8568f18df7ae19973d7555f547a715db3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Collector Filter&lt;/code&gt; converts the raw Erlang trace data format into &lt;code&gt;Event Records&lt;/code&gt;. If you want to perform this differently you can of course write your own &lt;code&gt;Collector Filter&lt;/code&gt; from scratch. But it may probably save you some efforts if you first apply the default filter in &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; before you apply your own conversions of its output.</source>
          <target state="translated">기본 &lt;code&gt;Collector Filter&lt;/code&gt; 는 원시 Erlang 추적 데이터 형식을 &lt;code&gt;Event Records&lt;/code&gt; 로 변환합니다 . 이 작업을 다르게 수행하려면 자신의 &lt;code&gt;Collector Filter&lt;/code&gt; 를 처음부터 새로 작성할 수 있습니다 . 그러나 자체 출력 변환을 적용하기 전에 &lt;code&gt;et_selector:parse_event/2&lt;/code&gt; 에서 기본 필터를 먼저 적용하면 약간의 노력을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57652a6dee935467cebeeed4f3fb7d6f7116fee" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Size&lt;/code&gt; depends on the type. For integer it is 8. For float it is 64. For binary it is all of the binary. In matching, this default value is only valid for the last element. All other binary elements in matching must have a size specification.</source>
          <target state="translated">기본 &lt;code&gt;Size&lt;/code&gt; 는 유형에 따라 다릅니다. 정수의 경우 8입니다. float의 경우 64입니다. binary의 경우 모든 2 진입니다. 일치하는 경우이 기본값은 마지막 요소에만 유효합니다. 일치하는 다른 모든 이진 요소에는 크기 사양이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4dbb7545b0f004e8ef75d97150f80d5c45826ac3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;StatisticsSpec&lt;/code&gt; is:</source>
          <target state="translated">기본 &lt;code&gt;StatisticsSpec&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7491f9d8e8f98f36325638513ac80bfc97bc47c" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt; +hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;message_queue_data&lt;/code&gt; 프로세스 플래그는 &lt;code&gt;erl(1)&lt;/code&gt; 명령 줄 인수 &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt; +hmqd&lt;/a&gt;&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f1c0b4c022d0f07743e56c51911904bc53375f9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;message_queue_data&lt;/code&gt; process flag is determined by command-line argument &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;message_queue_data&lt;/code&gt; 프로세스 플래그는 &lt;code&gt;erl(1)&lt;/code&gt; 명령 행 인수 &lt;code&gt;&lt;a href=&quot;erl#+hmqd&quot;&gt;+hmqd&lt;/a&gt;&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="572022a6b410479721a7992c7362b7aaff7907d4" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used and the result is returned to the client.</source>
          <target state="translated">기본 Erlang 평가 기가 사용되며 결과가 클라이언트로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eac2ba828452672a63c684b8e844a11cc19d5eee" translate="yes" xml:space="preserve">
          <source>The default Erlang evaluator is used both for exec and shell requests. The result is returned to the client.</source>
          <target state="translated">기본 Erlang 평가 기는 exec 및 셸 요청 모두에 사용됩니다. 결과는 클라이언트에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="88fd0465cd657366b4590ae0f113c518fee5324c" translate="yes" xml:space="preserve">
          <source>The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built-in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode code point for the character.</source>
          <target state="translated">Erlang의 기본 유니 코드 인코딩은 바이너리 UTF-8로되어 있으며, OTP의 내장 함수 및 라이브러리가 바이너리 유니 코드 데이터를 찾는 형식이기도합니다. 목록에서 유니 코드 데이터는 정수로 인코딩되며, 각 정수는 하나의 문자를 나타내며 문자의 유니 코드 코드 포인트로 간단하게 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="49cebb251d6b0aa1500584bc73027335bd0baea3" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116+). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="translated">기본 알고리즘은 &lt;code&gt;exrop&lt;/code&gt; (Xoroshiro116 +)입니다. 특정 알고리즘이 필요한 경우, 항상 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 상태를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="2258a0b4b5ba55503b1e33ac02535a01630a7012" translate="yes" xml:space="preserve">
          <source>The default algorithm is &lt;code&gt;exsss&lt;/code&gt; (Xorshift116**). If a specific algorithm is required, ensure to always use &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt; seed/1&lt;/a&gt;&lt;/code&gt; to initialize the state.</source>
          <target state="translated">기본 알고리즘은 &lt;code&gt;exsss&lt;/code&gt; (Xorshift116 **)입니다. 특정 알고리즘이 필요한 경우 항상 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt; seed/1&lt;/a&gt;&lt;/code&gt; 을 사용 하여 상태를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="3eb49c55e11d37a2c7f97be97bd91839e01e102b" translate="yes" xml:space="preserve">
          <source>The default behaviour in the two other cases (that is, abnormal exit) above is to:</source>
          <target state="translated">위의 두 가지 다른 경우 (즉, 비정상 종료)의 기본 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9aad933f8a23be0b8f60b2f0009c014495bcab97" translate="yes" xml:space="preserve">
          <source>The default behaviour is ignore the message. To get a printout for each message with &lt;code&gt;AlwaysDisplay = true&lt;/code&gt;, use for example &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</source>
          <target state="translated">기본 동작은 메시지를 무시하는 것입니다. &lt;code&gt;AlwaysDisplay = true&lt;/code&gt; 인 각 메시지에 대한 출력물을 얻으려면 &lt;code&gt;{ssh_msg_debug_fun, fun(_,true,M,_)-&amp;gt; io:format(&quot;DEBUG: ~p~n&quot;, [M]) end}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cc443fe9633fb1a0335c43045efe1e002d6805e" translate="yes" xml:space="preserve">
          <source>The default behaviour is to create a file named &lt;code&gt;TAGS&lt;/code&gt; in the current directory.</source>
          <target state="translated">기본 동작은 현재 디렉토리에 &lt;code&gt;TAGS&lt;/code&gt; 라는 파일을 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="26ca635941f675c5f6767b6598533eaee0bb0c9a" translate="yes" xml:space="preserve">
          <source>The default behaviour of a process that receives a normal exit is to ignore the signal.</source>
          <target state="translated">정상 종료를 수신하는 프로세스의 기본 동작은 신호를 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="47755f34cfe7e278db6d7efc977a211082ce5135" translate="yes" xml:space="preserve">
          <source>The default behaviour when a process receives an exit signal with an exit reason other than &lt;code&gt;normal&lt;/code&gt;, is to terminate and in turn emit exit signals with the same exit reason to its linked processes. An exit signal with reason &lt;code&gt;normal&lt;/code&gt; is ignored.</source>
          <target state="translated">프로세스가 &lt;code&gt;normal&lt;/code&gt; 이외의 종료 이유가있는 종료 신호를 수신 할 때의 기본 동작 은 링크 된 프로세스에 대해 동일한 종료 이유가있는 종료 신호를 종료 한 다음 방출하는 것입니다. 이유가 &lt;code&gt;normal&lt;/code&gt; 종료 신호 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9d70ec5c7098a4e4d6ce579440d90f6d0f1a9b44" translate="yes" xml:space="preserve">
          <source>The default boot file is &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt;, but in this case we need to specify a boot file from our target structure, typically &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt;. This is done with the &lt;code&gt;-boot&lt;/code&gt; command line option to &lt;code&gt;erl&lt;/code&gt;</source>
          <target state="translated">기본 부팅 파일은 &lt;code&gt;$OTP_ROOT/bin/start&lt;/code&gt; 이지만이 경우 대상 구조에서 부팅 파일을 지정해야합니다 (일반적으로 &lt;code&gt;&amp;lt;target-dir&amp;gt;/releases/&amp;lt;vsn&amp;gt;/&amp;lt;RelName&amp;gt;&lt;/code&gt; ) . 이것은 &lt;code&gt;-boot&lt;/code&gt; 명령 행 옵션을 사용하여 &lt;code&gt;erl&lt;/code&gt; 에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8deb6cfc40b154f0f3bc4c292fe3c4c01bead83c" translate="yes" xml:space="preserve">
          <source>The default callback module &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt;, has the following features:</source>
          <target state="translated">기본 콜백 모듈 &lt;code&gt;&lt;a href=&quot;ct_slave&quot;&gt;ct_slave&lt;/a&gt;&lt;/code&gt; 에는 다음과 같은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1389307405e87741972dcfbd8f36d70ed4c7e741" translate="yes" xml:space="preserve">
          <source>The default discovery handler will require additional actions by the caller and the discovery will not work if the security-level is higher then &lt;code&gt;noAuthNoPriv&lt;/code&gt;.</source>
          <target state="translated">기본 감지 핸들러는 호출자의 추가 조치가 필요하며 보안 레벨이 &lt;code&gt;noAuthNoPriv&lt;/code&gt; 보다 높으면 감지가 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d22df62b6d0da804bdfcd33682ee76feb0f23fda" translate="yes" xml:space="preserve">
          <source>The default encoding for Erlang source files is changed from Latin-1 to UTF-8 since Erlang/OTP 17.0.</source>
          <target state="translated">Erlang / OTP 17.0 이후 Erlang 소스 파일의 기본 인코딩이 Latin-1에서 UTF-8로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="28a5f2f414a2bcb3dd11d72abe5185c72fab49c5" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt; Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="translated">&lt;code&gt;standard_io&lt;/code&gt; 에 대한 I / O 서버의 기본 인코딩 은 &lt;code&gt;latin1&lt;/code&gt; 입니다 . 스크립트는 STDLIB 사용자 가이드의 비대화 형 터미널 ( &lt;code&gt; Summary of Options&lt;/code&gt; 섹션 참조 )에서 실행되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b3e3252c03a4fb54a27bf1c1fdc312100673449d" translate="yes" xml:space="preserve">
          <source>The default encoding of the I/O-server for &lt;code&gt;standard_io&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, as the script runs in a non-interactive terminal (see section &lt;code&gt;Summary of Options&lt;/code&gt;) in the STDLIB User's Guide.</source>
          <target state="translated">스크립트가 STDLIB 사용자 안내서 의 비 대화식 터미널 ( &lt;code&gt;Summary of Options&lt;/code&gt; 참조 )에서 실행되므로 &lt;code&gt;standard_io&lt;/code&gt; 에 대한 I / O 서버의 기본 인코딩 은 &lt;code&gt;latin1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fc4ad3abb12599963d8f41201b9099f8a6fadc8" translate="yes" xml:space="preserve">
          <source>The default encoding. Bytes supplied to the file, that is, &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; are written &quot;as is&quot; on the file. Likewise, bytes read from the file, that is, &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; are returned &quot;as is&quot;. If module &lt;code&gt;io(3)&lt;/code&gt; is used for writing, the file can only cope with Unicode characters up to code point 255 (the ISO Latin-1 range).</source>
          <target state="translated">기본 인코딩입니다. 파일에 제공된 바이트, 즉 &lt;code&gt;&lt;a href=&quot;#write-2&quot;&gt;write/2&lt;/a&gt;&lt;/code&gt; 는 파일에 &quot;있는 그대로&quot;기록됩니다. 마찬가지로 파일에서 읽은 바이트, 즉 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 는 &quot;있는 그대로&quot;반환됩니다. 모듈 &lt;code&gt;io(3)&lt;/code&gt; 을 사용하여 쓰는 경우 파일은 코드 포인트 255 (ISO Latin-1 범위)까지의 유니 코드 문자 만 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c8c72f780ad73f25b213fdc25585528f17513b" translate="yes" xml:space="preserve">
          <source>The default endianness is &lt;code&gt;big&lt;/code&gt;.</source>
          <target state="translated">기본 엔디안은 &lt;code&gt;big&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d83550f92d20198e2acab3ad30ef01b3a3ff2580" translate="yes" xml:space="preserve">
          <source>The default fallback behaviour. Template funs should end with:</source>
          <target state="translated">기본 폴백 동작입니다. 템플릿 재미는 다음과 같이 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="c9d9ffa8dde369b6838c3b5a3754294ebeb88aaa" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; cannot handle an object of type &lt;code&gt;NetworkAddress&lt;/code&gt; as INDEX (SNMPv1 only!). Use &lt;code&gt;IpAddress&lt;/code&gt; instead.</source>
          <target state="translated">기본 함수 및 &lt;code&gt;snmp_generic&lt;/code&gt; 은 &lt;code&gt;NetworkAddress&lt;/code&gt; 유형의 객체 를 INDEX (SNMPv1 만 해당)로 처리 할 수 ​​없습니다 . 대신 &lt;code&gt;IpAddress&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cd3d1fa535e347fbd4b38228c48e00bf23af7b2" translate="yes" xml:space="preserve">
          <source>The default functions and &lt;code&gt;snmp_generic&lt;/code&gt; do not check the range of each OCTET in textual conventions derived from OCTET STRING, e.g. &lt;code&gt;DisplayString&lt;/code&gt; and &lt;code&gt;DateAndTime&lt;/code&gt;. This must be checked in an overloaded &lt;code&gt;is_set_ok&lt;/code&gt; function.</source>
          <target state="translated">기본 함수 및 &lt;code&gt;snmp_generic&lt;/code&gt; 은 OCTET STRING에서 파생 된 텍스트 규칙 (예 : &lt;code&gt;DisplayString&lt;/code&gt; 및 &lt;code&gt;DateAndTime&lt;/code&gt; ) 에서 각 OCTET의 범위를 확인하지 않습니다 . 과부하 된 &lt;code&gt;is_set_ok&lt;/code&gt; 함수 에서 점검해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb7a8decc5695c83a52d57741dd6546a270063e4" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt; logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt; logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="translated">기본 처리기 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt; logger_std_h&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt; logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 는 과부하 보호 메커니즘을 갖추고있어 처리기가 고부하 기간 동안 (수많은 수신 로그 요청을 처리해야하는 경우) 응답을 유지할 수 있습니다. 메커니즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="93ec2b0bf3246052db6872a9a89f490a6940711d" translate="yes" xml:space="preserve">
          <source>The default handlers, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, feature an overload protection mechanism, which makes it possible for the handlers to survive, and stay responsive, during periods of high load (when huge numbers of incoming log requests must be handled). The mechanism works as follows:</source>
          <target state="translated">기본 처리기 인 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; 에는 과부하 보호 메커니즘이있어로드가 많은 기간 동안 (수 많은 수신 로그 요청을 처리해야하는 경우) 처리기가 생존하고 응답 상태를 유지할 수 있습니다. 이 메커니즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fef3702dc90f570ebd9028951e47041a3eec62af" translate="yes" xml:space="preserve">
          <source>The default initial heap size of 233 words is quite conservative to support Erlang systems with hundreds of thousands or even millions of processes. The garbage collector grows and shrinks the heap as needed.</source>
          <target state="translated">기본 초기 힙 크기 233 워드는 수십만 또는 수백만 개의 프로세스가있는 Erlang 시스템을 지원하는 데 상당히 보수적입니다. 가비지 수집기는 필요에 따라 힙을 늘리고 줄입니다.</target>
        </trans-unit>
        <trans-unit id="028f1e913dc597e5f47465aa0038982d46d84b7c" translate="yes" xml:space="preserve">
          <source>The default instrumentation allows the application on the manager side to be developed and tested simultaneously with the agent. As soon as the ASN.1 file is completed, let the MIB compiler generate a default implementation and develop the management application from this.</source>
          <target state="translated">기본 계측을 통해 관리자 측의 응용 프로그램을 에이전트와 동시에 개발하고 테스트 할 수 있습니다. ASN.1 파일이 완료 되 자마자 MIB 컴파일러가 기본 구현을 생성하고 이로부터 관리 응용 프로그램을 개발하게하십시오.</target>
        </trans-unit>
        <trans-unit id="2bcdc2b092cf0144876d346105d3638a289ddc47" translate="yes" xml:space="preserve">
          <source>The default instrumentation functions are defined in the module &lt;code&gt;snmp_generic&lt;/code&gt;. Refer to the Reference Manual, section SNMP, module &lt;code&gt;snmp_generic&lt;/code&gt; for details.</source>
          <target state="translated">기본 계측 기능은 &lt;code&gt;snmp_generic&lt;/code&gt; 모듈에 정의되어 있습니다. 자세한 내용은 참조 설명서의 SNMP 섹션 &lt;code&gt;snmp_generic&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a4f9d2c2e9dd957fcc3258b4a7c7be3758f84afc" translate="yes" xml:space="preserve">
          <source>The default is 30 seconds.</source>
          <target state="translated">기본값은 30 초입니다.</target>
        </trans-unit>
        <trans-unit id="697dc028cf7853b692477e62b3b0ccd825e45fa0" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;integer&lt;/code&gt;. &lt;code&gt;bytes&lt;/code&gt; is a shorthand for &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;bits&lt;/code&gt; is a shorthand for &lt;code&gt;bitstring&lt;/code&gt;. See below for more information about the &lt;code&gt;utf&lt;/code&gt; types.</source>
          <target state="translated">기본값은 &lt;code&gt;integer&lt;/code&gt; 입니다. &lt;code&gt;bytes&lt;/code&gt; 는 &lt;code&gt;binary&lt;/code&gt; 의 약자 이고 &lt;code&gt;bits&lt;/code&gt; 는 &lt;code&gt;bitstring&lt;/code&gt; 의 약자입니다 . &lt;code&gt;utf&lt;/code&gt; 유형 에 대한 자세한 내용은 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f0b6dd22860df8373214ee0633cf82a9776e5cd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;binary_alloc&lt;/code&gt; and &lt;code&gt;driver_alloc&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; for the other allocator types.</source>
          <target state="translated">기본값은 &lt;code&gt;true&lt;/code&gt; 에 대한 &lt;code&gt;binary_alloc&lt;/code&gt; 및 &lt;code&gt;driver_alloc&lt;/code&gt; , 그리고 &lt;code&gt;false&lt;/code&gt; 다른 할당 유형.</target>
        </trans-unit>
        <trans-unit id="9996cd482af4c98f3ef5c52e911a0d51db398668" translate="yes" xml:space="preserve">
          <source>The default is the process named &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;logger&lt;/code&gt; 라는 프로세스 입니다.</target>
        </trans-unit>
        <trans-unit id="f6c6037b1efc7d6b42e5368b46d0f3b99b3ee991" translate="yes" xml:space="preserve">
          <source>The default is to return a sequence of QLCs in a block, but if option &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; is specified, one single QLC is returned.</source>
          <target state="translated">디폴트는 블록에 일련의 QLC를 리턴하는 것이지만, &lt;code&gt;{flat,&amp;nbsp;false}&lt;/code&gt; 옵션 이 지정되면 하나의 단일 QLC가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b873bd22585e6e628d3df8c1732fa1e4731a1722" translate="yes" xml:space="preserve">
          <source>The default is to return a string, but if option &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; is specified, abstract code is returned instead. In the abstract code, port identifiers, references, and pids are represented by strings.</source>
          <target state="translated">디폴트는 문자열을 리턴하는 것이지만 옵션 &lt;code&gt;{format,&amp;nbsp;abstract_code}&lt;/code&gt; 가 지정되면 추상 코드가 대신 리턴됩니다. 추상 코드에서 포트 식별자, 참조 및 pid는 문자열로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6b16165d91c06ae4aeb2706afc9b7a0ac50cd9da" translate="yes" xml:space="preserve">
          <source>The default is to return all elements in lists, but if option &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; is specified, only a limited number of elements are returned.</source>
          <target state="translated">디폴트는리스트의 모든 요소를 ​​리턴하는 것이지만 옵션 &lt;code&gt;{n_elements,&amp;nbsp;NElements}&lt;/code&gt; 가 지정되면 제한된 수의 요소 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7b0f890d901ebd92c482f0beb121398b160a73" translate="yes" xml:space="preserve">
          <source>The default is to show all parts of objects and match specifications, but if option &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; is specified, parts of terms below a certain depth are replaced by &lt;code&gt;'...'&lt;/code&gt;.</source>
          <target state="translated">기본값은 오브젝트의 모든 부분을 표시하고 스펙을 일치시키는 것이지만 옵션 &lt;code&gt;{depth,&amp;nbsp;Depth}&lt;/code&gt; 가 지정된 경우 특정 깊이 아래의 용어 부분은 &lt;code&gt;'...'&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="d031478aad7c792d83bd41e0b1d60d3346429273" translate="yes" xml:space="preserve">
          <source>The default is to sort terms in ascending order, but that can be changed by value &lt;code&gt;descending&lt;/code&gt; or by specifying an ordering function &lt;code&gt;Fun&lt;/code&gt;. An ordering function is antisymmetric, transitive, and total. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; is to return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; comes before &lt;code&gt;B&lt;/code&gt; in the ordering, otherwise &lt;code&gt;false&lt;/code&gt;. An example of a typical ordering function is less than or equal to, &lt;code&gt;=&amp;lt;/2&lt;/code&gt;. Using an ordering function slows down the sort considerably. Functions &lt;code&gt;keysort&lt;/code&gt;, &lt;code&gt;keymerge&lt;/code&gt; and &lt;code&gt;keycheck&lt;/code&gt; do not accept ordering functions.</source>
          <target state="translated">기본적으로 용어는 오름차순으로 정렬되지만 값은 &lt;code&gt;descending&lt;/code&gt; 또는 정렬 함수 &lt;code&gt;Fun&lt;/code&gt; 을 지정하여 변경할 수 있습니다 . 주문 함수는 비대칭, 전이 및 총계입니다. &lt;code&gt;Fun(A,&amp;nbsp;B)&lt;/code&gt; 반환하는 것입니다 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;A&lt;/code&gt; 가 앞에 오는 &lt;code&gt;B&lt;/code&gt; 순서에, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; . 일반적인 순서 함수의 예는 &lt;code&gt;=&amp;lt;/2&lt;/code&gt; 보다 작거나 같습니다 . 정렬 기능을 사용하면 정렬 속도가 상당히 느려집니다. 기능 &lt;code&gt;keysort&lt;/code&gt; , &lt;code&gt;keymerge&lt;/code&gt; 을 하고 &lt;code&gt;keycheck&lt;/code&gt; 는 주문 기능을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="388c1ebba36e81e6d83c9829202075488730e57f" translate="yes" xml:space="preserve">
          <source>The default list is fetched from the &lt;code&gt;public_key&lt;/code&gt; application.</source>
          <target state="translated">기본 목록은 &lt;code&gt;public_key&lt;/code&gt; 애플리케이션 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6b3871f80aaa305c511a84fd9b3f91462dfdba6b" translate="yes" xml:space="preserve">
          <source>The default logging behavior of &lt;code&gt;ct_telnet&lt;/code&gt; is to print information about performed operations, commands, and their corresponding results to the test case HTML log. The following is not printed to the HTML log: text strings sent from the Telnet server that are not explicitly received by a &lt;code&gt;ct_telnet&lt;/code&gt; function, such as &lt;code&gt;expect/3&lt;/code&gt;. However, &lt;code&gt;ct_telnet&lt;/code&gt; can be configured to use a special purpose event handler, implemented in &lt;code&gt;ct_conn_log_h&lt;/code&gt;, for logging &lt;strong&gt;all&lt;/strong&gt; Telnet traffic. To use this handler, install a &lt;code&gt;Common Test&lt;/code&gt; hook named &lt;code&gt;cth_conn_log&lt;/code&gt;. Example (using the test suite information function):</source>
          <target state="translated">&lt;code&gt;ct_telnet&lt;/code&gt; 의 기본 로깅 동작 은 수행 된 작업, 명령 및 해당 결과에 대한 정보를 테스트 케이스 HTML 로그에 인쇄하는 것입니다. 다음은 HTML 로그에 인쇄되지 않습니다. 텔넷 서버에서 보낸 &lt;code&gt;ct_telnet&lt;/code&gt; 함수에 의해 명시 적으로 수신되지 않은 텍스트 문자열 ( 예 : &lt;code&gt;expect/3&lt;/code&gt; ) . 그러나 &lt;code&gt;ct_telnet&lt;/code&gt; 은 &lt;strong&gt;모든&lt;/strong&gt; Telnet 트래픽 을 로깅하기 위해 &lt;code&gt;ct_conn_log_h&lt;/code&gt; 에 구현 된 특수 목적 이벤트 핸들러를 사용하도록 구성 할 수 있습니다 . 이 핸들러를 사용하려면 &lt;code&gt;cth_conn_log&lt;/code&gt; 라는 &lt;code&gt;Common Test&lt;/code&gt; 후크를 설치하십시오 . 예 (테스트 스위트 정보 기능 사용) :&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2de8d81b3d3a2e14473bb755a7b9ea4746cd308a" translate="yes" xml:space="preserve">
          <source>The default matching handles dns_id and uri_id. In an uri_id the value is tested for equality with a value from the &lt;code&gt;Subject Alternate Name&lt;/code&gt;. If som other kind of matching is needed, use the &lt;code&gt;match_fun&lt;/code&gt; option.</source>
          <target state="translated">기본 일치는 dns_id 및 uri_id를 처리합니다. uri_id에서 값은 &lt;code&gt;Subject Alternate Name&lt;/code&gt; 의 값과 동일한 지 테스트됩니다 . 다른 종류의 일치가 필요한 경우 &lt;code&gt;match_fun&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="84111fd78857c9aae8ea5220ba7612eb708e45fa" translate="yes" xml:space="preserve">
          <source>The default matching transformes the ascii values in strings to lowercase before comparing. The &lt;code&gt;match_fun&lt;/code&gt; is however called without any transfomation applied to the strings. The reason is to enable the user to do unforseen handling of the strings where the original format is needed.</source>
          <target state="translated">기본 일치는 비교하기 전에 문자열의 ASCII 값을 소문자로 변환합니다. 그러나 &lt;code&gt;match_fun&lt;/code&gt; 은 문자열에 변형을 적용하지 않고 호출됩니다. 그 이유는 사용자가 원래 형식이 필요한 문자열을 예기치 않게 처리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="aa2a84cd90225c7ed3bdea62cdca292d4a45b475" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows and MacOS X enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">기본 모드는 운영 체제에 따라 다릅니다. Windows 및 MacOS X는 일관된 파일 이름 인코딩을 시행하므로 VM은 &lt;code&gt;utf8&lt;/code&gt; 모드를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a989c78863dde3eb5b7dac6806181cf8315faf2c" translate="yes" xml:space="preserve">
          <source>The default mode depends on the operating system. Windows, MacOS X and Android enforce consistent filename encoding and therefore the VM uses &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">기본 모드는 운영 체제에 따라 다릅니다. Windows, MacOS X 및 Android는 일관된 파일 이름 인코딩을 적용하므로 VM은 &lt;code&gt;utf8&lt;/code&gt; 모드를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="953f88f92bc1b24efaf4cf45547f40d0e648b131" translate="yes" xml:space="preserve">
          <source>The default object arity is smaller than &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">기본 객체 arity는 &lt;code&gt;&amp;lt;keypos&amp;gt;&lt;/code&gt; 보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="4de77215568172d7d29aabd76eae88688d23f0d0" translate="yes" xml:space="preserve">
          <source>The default options of the &lt;code&gt;erlsrv&lt;/code&gt; program are not sufficient for release handling. The machine started by &lt;code&gt;erlsrv&lt;/code&gt; is be specified as the &lt;code&gt;start_erl&lt;/code&gt; program and the arguments are to contain &lt;code&gt;++&lt;/code&gt; followed by the desired options.</source>
          <target state="translated">&lt;code&gt;erlsrv&lt;/code&gt; 프로그램 의 기본 옵션은 릴리스 처리에 충분하지 않습니다. &lt;code&gt;erlsrv&lt;/code&gt; 로 시작된 시스템 은 &lt;code&gt;start_erl&lt;/code&gt; 프로그램 으로 지정되며 인수는 &lt;code&gt;++&lt;/code&gt; 다음에 원하는 옵션 을 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="848dbed2df3f8df742ee9905b38e3696149b703a" translate="yes" xml:space="preserve">
          <source>The default password checking is with the list in the &lt;code&gt;&lt;a href=&quot;ssh#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; option in the SSH daemon. It could be replaced with a &lt;code&gt;&lt;a href=&quot;ssh#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; plugin. The arity four variant (&lt;code&gt;&lt;a href=&quot;ssh#type-pwdfun_4&quot;&gt;pwdfun_4()&lt;/a&gt;&lt;/code&gt;) can also be used for introducing delays after failed password checking attempts. Here is a simple example of such a pwdfun:</source>
          <target state="translated">기본 암호 검사는 SSH 데몬 의 &lt;code&gt;&lt;a href=&quot;ssh#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; 옵션 목록에 있습니다. &lt;code&gt;&lt;a href=&quot;ssh#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; 플러그인 으로 대체 할 수 있습니다 . arity 4 변형 ( &lt;code&gt;&lt;a href=&quot;ssh#type-pwdfun_4&quot;&gt;pwdfun_4()&lt;/a&gt;&lt;/code&gt; )은 비밀번호 확인 시도 실패 후 지연을 도입하는 데 사용할 수도 있습니다. 다음은 이러한 pwdfun의 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="fb1094b520cae2a88d55d90efc05453766135ad7" translate="yes" xml:space="preserve">
          <source>The default set of groups is listed in &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt;. This file may be regenerated like this:</source>
          <target state="translated">기본 그룹 세트는 &lt;code&gt;lib/public_key/priv/moduli&lt;/code&gt; 에 나열되어 있습니다. 이 파일은 다음과 같이 재생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a4dcf8371d190ef2c9a9faf32cf8b7eef5d4104" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt; prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">기본 쉘 프롬프트 기능은 노드 이름 (노드가 분산 시스템의 일부일 수있는 경우)과 현재 명령 번호를 표시합니다. 사용자는 &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt; prompt_func/1&lt;/a&gt;&lt;/code&gt; 을 호출 하거나 STDLIB 애플리케이션에 대한 애플리케이션 구성 매개 변수 &lt;code&gt;shell_prompt_func&lt;/code&gt; 를 설정 하여 프롬프트 기능을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c212e9694a3fd892d150f01a66f923860ff2fc9" translate="yes" xml:space="preserve">
          <source>The default shell prompt function displays the name of the node (if the node can be part of a distributed system) and the current command number. The user can customize the prompt function by calling &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; or by setting application configuration parameter &lt;code&gt;shell_prompt_func&lt;/code&gt; for the STDLIB application.</source>
          <target state="translated">기본 쉘 프롬프트 기능은 노드 이름 (노드가 분산 시스템의 일부일 수있는 경우) 및 현재 명령 번호를 표시합니다. 사용자는 &lt;code&gt;&lt;a href=&quot;#prompt_func-1&quot;&gt;prompt_func/1&lt;/a&gt;&lt;/code&gt; 을 호출 하거나 STDLIB 애플리케이션에 대한 애플리케이션 구성 매개 변수 &lt;code&gt;shell_prompt_func&lt;/code&gt; 를 설정 하여 프롬프트 기능을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00b63ca80d11da692b5651bc33e43d076e3793c3" translate="yes" xml:space="preserve">
          <source>The default signedness is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">기본 서명은 &lt;code&gt;unsigned&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff776579e06c4767b62b9f485e782cd999a09f7a" translate="yes" xml:space="preserve">
          <source>The default simple handler is called &lt;code&gt;alarm_handler&lt;/code&gt; and it can be exchanged by calling &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; as &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt;. &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; is called. For more details, see &lt;code&gt;gen_event(3)&lt;/code&gt; in STDLIB.</source>
          <target state="translated">기본 단순 핸들러는 &lt;code&gt;alarm_handler&lt;/code&gt; 라고 하며 &lt;code&gt;gen_event:swap_handler/3&lt;/code&gt; 를 &lt;code&gt;gen_event:swap_handler(alarm_handler, {alarm_handler, swap}, {NewHandler, Args})&lt;/code&gt; 로 호출하여 교환 할 수 있습니다 . &lt;code&gt;NewHandler:init({Args, {alarm_handler, Alarms}})&lt;/code&gt; 가 호출되었습니다. 자세한 내용은 &lt;code&gt;gen_event(3)&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edd4ef6f5a1e3a142885438b41744f5b5b26e5b7" translate="yes" xml:space="preserve">
          <source>The default socket options are &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt;.</source>
          <target state="translated">기본 소켓 옵션은 &lt;code&gt;[{mode,list},{packet, 0},{header, 0},{active, true}]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b0a75358d0df669ac13a835e5ee193bd00512b1" translate="yes" xml:space="preserve">
          <source>The default standard handler, &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt;, can be replaced by a disk_log handler at startup of the Kernel application. See an example of this below.</source>
          <target state="translated">기본 표준 핸들러 인 &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h&lt;/a&gt;&lt;/code&gt; 는 커널 애플리케이션 시작시 disk_log 핸들러로 대체 될 수 있습니다. 아래의 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="56e59dc663ec3168b6b7eec38a9c17da04f70aec" translate="yes" xml:space="preserve">
          <source>The default start option &lt;code&gt;{dir,Cwd}&lt;/code&gt; (to run all suites in the current working directory) is used if the function is called with an empty list of options.</source>
          <target state="translated">함수가 빈 옵션 목록으로 호출되면 기본 시작 옵션 &lt;code&gt;{dir,Cwd}&lt;/code&gt; (현재 작업 디렉토리의 모든 스위트를 실행)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8472d25153570bd73936053aa35b2f0053ff73f8" translate="yes" xml:space="preserve">
          <source>The default time limit for a test case is 30 minutes, unless a &lt;code&gt;timetrap&lt;/code&gt; is specified either by the suite-, group-, or test case information function. The timetrap time-out value defined by &lt;code&gt;suite/0&lt;/code&gt; is the value that is used for each test case in the suite (and for the configuration functions &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, and &lt;code&gt;end_per_group/2&lt;/code&gt;). A timetrap value defined by &lt;code&gt;group(GroupName)&lt;/code&gt; overrides one defined by &lt;code&gt;suite()&lt;/code&gt; and is used for each test case in group &lt;code&gt;GroupName&lt;/code&gt;, and any of its subgroups. If a timetrap value is defined by &lt;code&gt;group/1&lt;/code&gt; for a subgroup, it overrides that of its higher level groups. Timetrap values set by individual test cases (by the test case information function) override both group- and suite- level timetraps.</source>
          <target state="translated">&lt;code&gt;timetrap&lt;/code&gt; , 그룹 또는 테스트 케이스 정보 기능 으로 타임 트랩 을 지정 하지 않으면 테스트 케이스의 기본 시간 제한은 30 분 입니다. &lt;code&gt;suite/0&lt;/code&gt; 에 의해 정의 된 타임 트랩 시간 종료 값은 스위트의 각 테스트 케이스 (및 구성 함수 &lt;code&gt;init_per_suite/1&lt;/code&gt; , &lt;code&gt;end_per_suite/1&lt;/code&gt; , &lt;code&gt;init_per_group/2&lt;/code&gt; 및 &lt;code&gt;end_per_group/2&lt;/code&gt; 에 사용되는 값 )입니다. 에 의해 정의 된 값 timetrap &lt;code&gt;group(GroupName)&lt;/code&gt; 에 의해 정의 된 하나 겹쳐 &lt;code&gt;suite()&lt;/code&gt; 와 그룹의 각각의 테스트 케이스에 사용되는 &lt;code&gt;GroupName&lt;/code&gt; , 그것의 서브 그룹 중 어느. timetrap 값이 &lt;code&gt;group/1&lt;/code&gt; 에 의해 정의 된 경우하위 그룹의 경우 상위 그룹의 하위 그룹보다 우선합니다. 개별 테스트 케이스 (테스트 케이스 정보 기능에 의해)에 의해 설정된 타임 트랩 값은 그룹 및 스위트 레벨 타임 트랩을 모두 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b52b358a5f5402f0ac26ce2f8003f427f7c57d17" translate="yes" xml:space="preserve">
          <source>The default time-out is 5000 ms, unless otherwise specified. &lt;code&gt;timeout&lt;/code&gt; defines the time to wait for the process to respond to a request. If the process does not respond, the function evaluates &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt;.</source>
          <target state="translated">달리 지정하지 않는 한 기본 시간 제한은 5000ms입니다. &lt;code&gt;timeout&lt;/code&gt; 은 프로세스가 요청에 응답하기를 기다리는 시간을 정의합니다. 프로세스가 응답하지 않으면 함수는 &lt;code&gt;exit({timeout, {M, F, A}})&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="51ff8e06cc37d3f5fbc8359b214e014cbb5552d4" translate="yes" xml:space="preserve">
          <source>The default timeout is infinity</source>
          <target state="translated">기본 시간 초과는 무한대입니다</target>
        </trans-unit>
        <trans-unit id="517719740380d1d0fe303f5c01cd73d6a4f1b6a9" translate="yes" xml:space="preserve">
          <source>The default type (and currently the only type) of crypto algorithm is &lt;code&gt;des3_cbc&lt;/code&gt;, three rounds of DES. The key string is scrambled using &lt;code&gt;erlang:md5/1&lt;/code&gt; to generate the keys used for &lt;code&gt;des3_cbc&lt;/code&gt;.</source>
          <target state="translated">암호화 알고리즘의 기본 유형 (및 현재 유일한 유형)은 3 라운드의 DES 인 &lt;code&gt;des3_cbc&lt;/code&gt; 입니다. 키 문자열은 &lt;code&gt;des3_cbc&lt;/code&gt; 에 사용되는 키를 생성하기 위해 &lt;code&gt;erlang:md5/1&lt;/code&gt; 을 사용하여 스크램블 됩니다.</target>
        </trans-unit>
        <trans-unit id="545949e03721db9053ce25eb33d2946d85caf9f1" translate="yes" xml:space="preserve">
          <source>The default type for a segment is integer. The default type does not depend on the value, even if the value is a literal. For example, the default type in &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; is integer, not float.</source>
          <target state="translated">세그먼트의 기본 유형은 정수입니다. 기본 유형은 값이 리터럴 인 경우에도 값에 의존하지 않습니다. 예를 들어, &lt;code id=&quot;Defaults&quot;&gt;&amp;lt;&amp;lt;3.14&amp;gt;&amp;gt;&lt;/code&gt; 의 기본 유형은 부동이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="9c04943ccaa1784066dde4b82fadc56a0e22b6e6" translate="yes" xml:space="preserve">
          <source>The default unit depends on the the type. For &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bitstring&lt;/code&gt; it is 1. For binary it is 8.</source>
          <target state="translated">기본 단위는 유형에 따라 다릅니다. 들어 &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , 그리고 &lt;code&gt;bitstring&lt;/code&gt; 그것은 8 BINARY 1.이다.</target>
        </trans-unit>
        <trans-unit id="55a938cf0dbdbfb06f3894ab3968c86b760e35c4" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Timeout&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;. If &lt;code&gt;Timeout&lt;/code&gt; is specified and no connection is accepted within the given time, &lt;code&gt;{error, timeout}&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 의 기본값 은 &lt;code&gt;infinity&lt;/code&gt; 입니다. 경우 &lt;code&gt;Timeout&lt;/code&gt; 지정되고 아무 관련이 주어진 시간 내에 접수되지 않습니다, &lt;code&gt;{error, timeout}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="06729acf2bd67efa6a3b5f8c86f4f2fa259ed112" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 의 기본값 은 &lt;code&gt;normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79b49abd7127b03f5d3f046367a7810a9be6e9ef" translate="yes" xml:space="preserve">
          <source>The default value for both the limits is 10,000,000 in the Erlang VM. Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for Erlang is compiled in such a way that the match function never does recursion on the C stack.</source>
          <target state="translated">Erlang VM에서 두 제한의 기본값은 10,000,000입니다. Erlang의 PCRE는 match 함수가 C 스택에서 재귀를 수행하지 않는 방식으로 컴파일되므로 재귀 한계는 VM의 스택 깊이에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a019fd353ccc57a4984f8ab73e895be35e2ceca" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;code&gt;template&lt;/code&gt; configuration parameter depends on the value of the &lt;code&gt;single_line&lt;/code&gt; and &lt;code&gt;legacy_header&lt;/code&gt; configuration parameters as follows.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 구성 매개 변수 의 기본값 은 다음과 같이 &lt;code&gt;single_line&lt;/code&gt; 및 &lt;code&gt;legacy_header&lt;/code&gt; 구성 매개 변수 의 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0bf6d99215a41e23b30022357e71e9041cbda827" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;0&lt;/code&gt;, which means that there is no upper limit. If supplied, the number of filenames returned to the SFTP client per &lt;code&gt;READDIR&lt;/code&gt; request is limited to at most the given value.</source>
          <target state="translated">기본값은 &lt;code&gt;0&lt;/code&gt; 이며, 상한이 없음을 의미합니다. 제공되는 경우, &lt;code&gt;READDIR&lt;/code&gt; 요청 당 SFTP 클라이언트에 리턴 된 파일 이름 수는 최대 값으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8eb871dd540b5e77da06600e181f72827240ed7e" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;262144&lt;/code&gt;</source>
          <target state="translated">기본값은 &lt;code&gt;262144&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9199a189c47e6bb7d92e1a9dbf9ee3c0844e971b" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;{0,infinity}&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;{0,infinity}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4282a5ade1b153ec0ef3ef75770c03f967209ae" translate="yes" xml:space="preserve">
          <source>The default value is as required by RFC 3539: changing it results in non-standard behaviour that should only be used to simulate misbehaving nodes during test.</source>
          <target state="translated">기본값은 RFC 3539에서 요구하는대로입니다.이를 변경하면 테스트 중 오작동 노드를 시뮬레이션하는 데만 사용되는 비표준 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18ca71fb6a22d28ebdfdacf9ed5fe354e1ec6ffe" translate="yes" xml:space="preserve">
          <source>The default value is the &lt;code&gt;public_key&lt;/code&gt; entry in the list returned by &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;&lt;a href=&quot;#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 이 리턴 한 목록 의 &lt;code&gt;public_key&lt;/code&gt; 항목입니다 .</target>
        </trans-unit>
        <trans-unit id="2af35d2902848146372b486ac1179095a26eda1a" translate="yes" xml:space="preserve">
          <source>The default value is used as the value of uninitialized entries, and cannot be changed once the array has been created.</source>
          <target state="translated">기본값은 초기화되지 않은 항목의 값으로 사용되며 일단 어레이가 생성되면 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b459379a9db26d1ded876c98cb594522408f4fb6" translate="yes" xml:space="preserve">
          <source>The default value is: &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</source>
          <target state="translated">기본값은 &lt;code&gt;{auth_method_kb_interactive_data, {&quot;SSH server&quot;, &quot;Enter password for \&quot;&quot;++User++&quot;\&quot;&quot;, &quot;password: &quot;, false}&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f42ce984a7a7881db87f25a990a361103af516d" translate="yes" xml:space="preserve">
          <source>The default value of USERDIR is &lt;code&gt;/home/&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#LOCALUSER&quot;&gt;LOCALUSER&lt;/a&gt;&lt;/code&gt;&lt;code&gt;/.ssh&lt;/code&gt;.</source>
          <target state="translated">USERDIR의 기본값은 &lt;code&gt;/home/&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#LOCALUSER&quot;&gt;LOCALUSER&lt;/a&gt;&lt;/code&gt; &lt;code&gt;/.ssh&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="243fb9da1068fdc22926720a51604f4646125511" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;{ssh_file, []}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4850f9a420695e6f6e424866c3013c9d0bdbd2e3" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;{ssh_file, []}&lt;/code&gt;. See also the manpage of &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;{ssh_file, []}&lt;/code&gt; 입니다. &lt;code&gt;ssh_file&lt;/code&gt; 맨 페이지도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c469af55771eecab0c4f9a0edd001fdb31022bb8" translate="yes" xml:space="preserve">
          <source>The default value of this option shall provide the above mentioned security guarantees and it shall be reasonable for most applications (~353 TB).</source>
          <target state="translated">이 옵션의 기본값은 위에서 언급 한 보안 보장을 제공하며 대부분의 응용 프로그램에 적합합니다 (~ 353TB).</target>
        </trans-unit>
        <trans-unit id="3d73b09c02067144770d80033f5560b2a2552422" translate="yes" xml:space="preserve">
          <source>The default value reflects the fact that a transport module for a stream-oriented transport like TCP may not be able to recover from a message length error since such a transport must use the Message Length header to divide the incoming byte stream into individual Diameter messages. An invalid length leaves it with no reliable way to rediscover message boundaries, which may result in the failure of subsequent messages. See &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; for the behaviour of that module.</source>
          <target state="translated">기본값은 TCP와 같은 스트림 지향 전송에 대한 전송 모듈이 메시지 길이 오류를 복구하지 못할 수 있다는 사실을 반영합니다. 이러한 전송은 메시지 길이 헤더를 사용하여 수신 바이트 스트림을 개별 직경 메시지로 나누어야하기 때문입니다. 길이가 유효하지 않으면 메시지 경계를 다시 검색 할 수있는 신뢰할 수있는 방법이 없어 후속 메시지가 실패 할 수 있습니다. 해당 모듈의 동작에 대해서는 &lt;code&gt;&lt;a href=&quot;diameter_tcp&quot;&gt;diameter_tcp(3)&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="296cd192efc745b8c34964c030037a92790a5853" translate="yes" xml:space="preserve">
          <source>The default value used is normally &lt;code&gt;65536&lt;/code&gt;. However, if the runtime system is able to determine maximum amount of file descriptors that it is allowed to open and this value is larger than &lt;code&gt;65536&lt;/code&gt;, the chosen value will increased to a value larger or equal to the maximum amount of file descriptors that can be opened.</source>
          <target state="translated">사용되는 기본값은 보통 &lt;code&gt;65536&lt;/code&gt; 입니다. 그러나 런타임 시스템이 열 수있는 최대 파일 디스크립터 양을 판별 할 수 &lt;code&gt;65536&lt;/code&gt; 값이 65536 보다 큰 경우 선택된 값은 최대 파일 디스크립터 양보다 크거나 같은 값으로 증가합니다. 열었다.</target>
        </trans-unit>
        <trans-unit id="5e3d6bd0706de8063989ab67ca84fec01864e172" translate="yes" xml:space="preserve">
          <source>The default values are 1 restart per 5 seconds. This was chosen to be safe for most systems, even with deep supervision hierarchies, but you will probably want to tune the settings for your particular use case.</source>
          <target state="translated">기본값은 5 초당 1 회의 재시작입니다. 이는 심층 감독 계층 구조에서도 대부분의 시스템에서 안전하도록 선택되었지만 특정 사용 사례에 맞게 설정을 조정하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e004a8abd563009ef32e5cba1400cabe8dffcb" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;connect&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_connect_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 하도록 지정된 옵션의 기본값 은 커널 구성 매개 변수 &lt;code&gt;inet_default_connect_options&lt;/code&gt; 의 영향을받을 수 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40a15125494e475b38c160cdf12b36e7e3d1c3f9" translate="yes" xml:space="preserve">
          <source>The default values for options specified to &lt;code&gt;listen&lt;/code&gt; can be affected by the Kernel configuration parameter &lt;code&gt;inet_default_listen_options&lt;/code&gt;. For details, see &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;listen&lt;/code&gt; 하도록 지정된 옵션의 기본값 은 커널 구성 매개 변수 &lt;code&gt;inet_default_listen_options&lt;/code&gt; 의 영향을받을 수 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;inet&quot;&gt;inet(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50fa0bf131c13c670fdcc5fdce169d626f359cef" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;originating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;originating&lt;/code&gt; 발견 옵션 의 기본값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cb324b22317eaf8bd729f045fc4512eed8d2afc" translate="yes" xml:space="preserve">
          <source>The default values for the &lt;code&gt;terminating&lt;/code&gt; discovery options are:</source>
          <target state="translated">&lt;code&gt;terminating&lt;/code&gt; 감지 옵션 의 기본값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b5bd661368c7d8e299861344ca3c98352edac6c" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt;. But the send options above, may explicitly be overridden.</source>
          <target state="translated">보내기 옵션의 기본값은 &lt;code&gt;megaco:conn_info(ConnHandle, Item)&lt;/code&gt; 의해 얻습니다 . 그러나 위의 전송 옵션은 명시 적으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0aa1b655582755f5f4811f0eab7ca8a5d9f4319" translate="yes" xml:space="preserve">
          <source>The default values of the send options are obtained by megaco:conn_info(ConnHandle, Item). But the send options above, may explicitly be overridden.</source>
          <target state="translated">보내기 옵션의 기본값은 megaco : conn_info (ConnHandle, Item)에서 가져옵니다. 그러나 위의 전송 옵션은 명시 적으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ebf5b11205a5dd9778e91c6bfcc585a8fc51478" translate="yes" xml:space="preserve">
          <source>The default verbosity is &lt;code&gt;1&lt;/code&gt;. Verbosity &lt;code&gt;0&lt;/code&gt; can also be selected by option &lt;code&gt;nowarn_format&lt;/code&gt;.</source>
          <target state="translated">기본 상세 정보는 &lt;code&gt;1&lt;/code&gt; 입니다. 상세도 &lt;code&gt;0&lt;/code&gt; 도 옵션으로 선택할 수 있습니다 &lt;code&gt;nowarn_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8f7ea1b49fdcb48ab2c2517d37ecba5139e4ff8" translate="yes" xml:space="preserve">
          <source>The default when a connection is established between two nodes, is to immediately connect all other visible nodes as well. This way, there is always a fully connected network. If there are nodes with different cookies, this method can be inappropriate and the command-line flag &lt;code&gt;-connect_all false&lt;/code&gt; must be set, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">두 노드 사이에 연결이 설정되면 기본값은 다른 모든 가시적 노드도 즉시 연결하는 것입니다. 이런 식으로 항상 완전히 연결된 네트워크가 있습니다. 쿠키가 다른 노드가있는 경우이 방법이 부적절하고 명령 행 플래그 &lt;code&gt;-connect_all false&lt;/code&gt; 를 설정해야합니다 . ERTS 의 &lt;code&gt;erl(1)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cf210e7ecc7b461b7955d0d98ee29107a5a6b0b" translate="yes" xml:space="preserve">
          <source>The default. Only characters in the ISO Latin-1 range can be considered printable. This means that a character with a code point &amp;gt; 255 is never considered printable and that lists containing such characters are displayed as lists of integers rather than text strings by tools.</source>
          <target state="translated">기본값입니다. ISO Latin-1 범위의 문자 만 인쇄 가능한 것으로 간주 될 수 있습니다. 즉, 코드 포인트가 255보다 큰 문자는 인쇄 할 수없는 것으로 간주되며 이러한 문자가 포함 된 목록은 도구의 텍스트 문자열이 아닌 정수 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="46e506cdb258a82f462a7f2164d0f42a9f2072f8" translate="yes" xml:space="preserve">
          <source>The defaults are &lt;code&gt;Low = 4096&lt;/code&gt; and &lt;code&gt;High = 8192&lt;/code&gt; unless the driver itself does modifications of these values.</source>
          <target state="translated">드라이버 자체가 이러한 값을 수정하지 않는 한 기본값은 &lt;code&gt;Low = 4096&lt;/code&gt; 및 &lt;code&gt;High = 8192&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e29513f39a50cabbc123316e69281febedaa0e1c" translate="yes" xml:space="preserve">
          <source>The defaults are &lt;code&gt;Low = 4096&lt;/code&gt; and &lt;code&gt;High = 8192&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;Low = 4096&lt;/code&gt; 및 &lt;code&gt;High = 8192&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11fa3688f9aa1dc5e88e515adb5d88b7a205fe35" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;ErlMessage&lt;/code&gt; has changed since earlier versions of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlMessage&lt;/code&gt; 의 정의는 이전 버전의 &lt;code&gt;Erl_Interface&lt;/code&gt; 이후로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6fdae1ac6fb499a05429a1e07e8362960f5b8b56" translate="yes" xml:space="preserve">
          <source>The definition of a busy scheduler is when it is not idle and is not scheduling (selecting) a process or port, that is:</source>
          <target state="translated">사용중인 스케줄러의 정의는 유휴 상태가 아니고 프로세스 또는 포트를 스케줄 (선택)하지 않을 때입니다.</target>
        </trans-unit>
        <trans-unit id="82ba3b05846ab652707aa41300a0f8920d31d2e5" translate="yes" xml:space="preserve">
          <source>The degree to which the service allows multiple transport connections to the same peer, as identified by its Origin-Host at capabilities exchange.</source>
          <target state="translated">기능 교환시 Origin-Host에 의해 식별 된 서비스가 동일한 피어에 대한 여러 전송 연결을 허용하는 정도.</target>
        </trans-unit>
        <trans-unit id="1d3a7346db37c7fe972c4b73fbfa32235de91911" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt; erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="translated">추적 메시지 ( &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;seq_trace(3)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt; erlang:system_profile/2&lt;/a&gt;&lt;/code&gt; 에 의해 생성됨)의 전달은 시스템의 다른 이벤트와 비교하여 타임 라인 에서 어긋납니다 . &lt;code&gt;Tracee&lt;/code&gt; 가 실행에서 특정 지점을 통과 했음을 알고 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 지점까지 이벤트에 해당하는 모든 추적 메시지가 추적기에 도달 한시기를 알고 싶다면 erlang : trace_delivered (Tracee)를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="995215813ca9fa0e2bcd7a40357169c4691820c6" translate="yes" xml:space="preserve">
          <source>The delivery of trace messages (generated by &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;seq_trace(3)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt;) is dislocated on the time-line compared to other events in the system. If you know that &lt;code&gt;Tracee&lt;/code&gt; has passed some specific point in its execution, and you want to know when at least all trace messages corresponding to events up to this point have reached the tracer, use &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;.</source>
          <target state="translated">추적 메시지 전달 ( &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;seq_trace(3)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#system_profile-2&quot;&gt;erlang:system_profile/2&lt;/a&gt;&lt;/code&gt; 생성 )은 시스템의 다른 이벤트와 비교하여 타임 라인에서 이동합니다. &lt;code&gt;Tracee&lt;/code&gt; 가 실행에서 특정 지점을 통과 했다는 것을 알고 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 시점까지의 이벤트에 해당하는 모든 추적 메시지가 추적 프로그램에 도달 한 시점을 알고 싶다면 erlang : trace_delivered (Tracee)를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef74e5139b7ce6e4f98a4baef24c6182968b430c" translate="yes" xml:space="preserve">
          <source>The dependecies are created as a side effect to the normal compilation process. This means that the object file will also be produced. This option override the &lt;code&gt;makedep&lt;/code&gt; option.</source>
          <target state="translated">의존성은 일반적인 컴파일 프로세스에 대한 부작용으로 생성됩니다. 이것은 오브젝트 파일도 생성됨을 의미합니다. 이 옵션은 &lt;code&gt;makedep&lt;/code&gt; 옵션보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="d1ab3d1ea275bdf26541729c8fac923c58fe1c95" translate="yes" xml:space="preserve">
          <source>The dependency graph windows are launched from the file menu in the system window. The graph depicts all included and derived applications/modules and their dependencies.</source>
          <target state="translated">종속성 그래프 창은 시스템 창의 파일 메뉴에서 시작됩니다. 그래프에는 포함 및 파생 된 모든 응용 프로그램 / 모듈 및 해당 종속성이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a97d6fbaa7c8cc7934aab7b5d9a9bb87b6b518f" translate="yes" xml:space="preserve">
          <source>The described durability feature does not entirely apply to situations where &lt;code&gt;Mnesia&lt;/code&gt; is configured as a &quot;pure&quot; primary memory database.</source>
          <target state="translated">설명 된 내구성 기능은 &lt;code&gt;Mnesia&lt;/code&gt; 가 &quot;순수한&quot;기본 메모리 데이터베이스로 구성된 상황에는 전적으로 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c5fd3c33ad96d6f9da0b92a6b9de73850c0f031c" translate="yes" xml:space="preserve">
          <source>The described syntax can also be used in test specifications to change group properties at the time of execution, without having to edit the test suite. For more information, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">설명 된 구문은 테스트 스위트를 편집하지 않고도 실행시 그룹 특성을 변경하기 위해 테스트 스펙에서 사용될 수 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 실행 및 결과 분석 섹션의 테스트 사양 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="086c0b30f28f757ab34cbfdd1e7d1db76083baee" translate="yes" xml:space="preserve">
          <source>The description is based on &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt;, which is not to be further updated.</source>
          <target state="translated">설명은 &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/eeps/eep-0008.html&quot;&gt;EEP8 - Types and function specifications&lt;/a&gt;&lt;/code&gt; 기반으로 하며 더 이상 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b29537c79e1bc001111fcb298cafeaf2c947455f" translate="yes" xml:space="preserve">
          <source>The descriptions of the options uses the &lt;code&gt;Erlang Type Language&lt;/code&gt; with explaining text.</source>
          <target state="translated">옵션 설명은 설명 텍스트와 함께 &lt;code&gt;Erlang Type Language&lt;/code&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ccde6c91194772388df62e195ba8cf52e9380085" translate="yes" xml:space="preserve">
          <source>The design choice between two or three generations of code access structures is a trade-off between memory consumption and code loading latency.</source>
          <target state="translated">2 세대 또는 3 세대 코드 액세스 구조 사이의 디자인 선택은 메모리 소비와 코드 로딩 대기 시간 간의 균형입니다.</target>
        </trans-unit>
        <trans-unit id="45a17206933877eeb5bf9c5379a4ed51695a5147" translate="yes" xml:space="preserve">
          <source>The destination of these log events was configured by &lt;code&gt;SASL configuration parameters&lt;/code&gt;.</source>
          <target state="translated">이러한 로그 이벤트의 대상은 &lt;code&gt;SASL configuration parameters&lt;/code&gt; 로 구성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1700577536e62effc25b554cb01dfedd3d5fe8bb" translate="yes" xml:space="preserve">
          <source>The details of finding other nodes (that is, talking to &lt;code&gt;epmd&lt;/code&gt; or something similar)</source>
          <target state="translated">다른 노드 찾기에 대한 세부 사항 (즉, &lt;code&gt;epmd&lt;/code&gt; 또는 이와 유사한 항목과 통신)</target>
        </trans-unit>
        <trans-unit id="8904690d17dfc4476f5a61b68a154f7e139b04e4" translate="yes" xml:space="preserve">
          <source>The development package of OpenSSL including the header files are needed as well as the binary command program &lt;code&gt;openssl&lt;/code&gt;. At least version 0.9.8 of OpenSSL is required. Read more and download from &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 명령 프로그램 &lt;code&gt;openssl&lt;/code&gt; 뿐만 아니라 헤더 파일을 포함한 OpenSSL 개발 패키지가 필요합니다 . OpenSSL 버전 0.9.8 이상이 필요합니다. &lt;code&gt;&lt;a href=&quot;http://www.openssl.org&quot;&gt;http://www.openssl.org&lt;/a&gt;&lt;/code&gt; 에서 자세한 내용을 읽고 다운로드 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d180f092b7b3bd940337d54bfa93d4b66eb9f08" translate="yes" xml:space="preserve">
          <source>The diameter application includes five dictionary modules corresponding to applications defined in section 2.4 of RFC 6733: &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; and &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; for the Diameter Common Messages application with application identifier 0, &lt;code&gt;diameter_gen_accounting&lt;/code&gt; (for RFC 3588) and &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; for the Diameter Base Accounting application with application identifier 3 and &lt;code&gt;diameter_gen_relay&lt;/code&gt; the Relay application with application identifier 0xFFFFFFFF.</source>
          <target state="translated">직경 애플리케이션 다섯 개 사전 RFC 6733의 섹션 2.4에 정의 된 어플리케이션에 대응하는 모듈을 포함 &lt;code&gt;diameter_gen_base_rfc3588&lt;/code&gt; 및 &lt;code&gt;diameter_gen_base_rfc6733&lt;/code&gt; 어플리케이션 식별자가 0 인 직경 일반 메시지 애플리케이션을 &lt;code&gt;diameter_gen_accounting&lt;/code&gt; 및 (RFC 3588에 대해) &lt;code&gt;diameter_gen_acct_rfc6733&lt;/code&gt; 애플리케이션 식별자 (3)과 함께 직경베이스 회계 애플리케이션 및 &lt;code&gt;diameter_gen_relay&lt;/code&gt; 애플리케이션 식별자 0xFFFFFFFF로 함께 중계 어플리케이션.</target>
        </trans-unit>
        <trans-unit id="55ad411fdd3feccef9ab5e2a70e1c6ecf0dda6f6" translate="yes" xml:space="preserve">
          <source>The diameter application is an implementation of the Diameter protocol as defined by RFC 6733. It supports arbitrary Diameter applications by way of a &lt;strong&gt;dictionary&lt;/strong&gt; interface that allows messages and AVPs to be defined and input into diameter as configuration. It has support for all roles defined in the RFC: client, server and agent. This chapter provides a short overview of the application.</source>
          <target state="translated">직경 응용 프로그램은 RFC 6733에 정의 된대로 직경 프로토콜을 구현 한 것입니다. &lt;strong&gt;사전&lt;/strong&gt; 인터페이스를 통해 메시지 및 AVP를 정의하고 구성으로 직경에 입력 할 수 있는 임의의 직경 응용 프로그램을 지원 합니다. RFC에 정의 된 모든 역할 (클라이언트, 서버 및 에이전트)을 지원합니다. 이 장에서는 응용 프로그램에 대한 간략한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b44b3ae3e6de975127d9868877e61eebf74c5fa6" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before calling most functions in this module.</source>
          <target state="translated">이 모듈에서 대부분의 기능을 호출하기 전에 직경 적용을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="5970544b2f23768c3400e92a3796dc5f84073d7d" translate="yes" xml:space="preserve">
          <source>The diameter application must be started before starting a service. In a production system this is typically accomplished by a boot file, not by calling &lt;code&gt;start/0&lt;/code&gt; explicitly.</source>
          <target state="translated">서비스를 시작하기 전에 직경 적용을 시작해야합니다. 프로덕션 시스템에서 이는 일반적으로 &lt;code&gt;start/0&lt;/code&gt; 을 명시 적으로 호출하지 않고 부트 파일로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d87148c3c9af3d9845486aa30c973c1b2043ba3" translate="yes" xml:space="preserve">
          <source>The diameter application takes responsibility for exchanging CER/CEA with the peer. Upon successful completion of capabilities exchange the service calls each relevant application module's &lt;code&gt;peer_up/3&lt;/code&gt; callback after which the caller can exchange Diameter messages with the peer over the transport. In addition to CER/CEA, the service takes responsibility for the handling of DWR/DWA and required by RFC 3539, as well as for DPR/DPA.</source>
          <target state="translated">직경 적용은 피어와 CER / CEA를 교환하는 책임이 있습니다. 기능 교환이 성공적으로 완료되면 서비스는 각 관련 애플리케이션 모듈의 &lt;code&gt;peer_up/3&lt;/code&gt; 콜백을 호출 한 후 호출자가 전송을 통해 피어와 직경 메시지를 교환 할 수 있습니다. 이 서비스는 CER / CEA 외에도 DWR / DPA뿐만 아니라 RFC 3539에 의해 요구되고 DWR / DWA의 처리를 책임집니다.</target>
        </trans-unit>
        <trans-unit id="fb2713bf78bad945032228e7d72a8fff3c2317e0" translate="yes" xml:space="preserve">
          <source>The diameter user does not need to call functions here explicitly when sending and receiving messages using &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; and the callback interface documented in &lt;code&gt;diameter_app(3)&lt;/code&gt;: diameter itself provides encode/decode as a consequence of configuration passed to &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt;, and the results may differ from those returned by the functions documented here, depending on configuration.</source>
          <target state="translated">Diameter 사용자는 &lt;code&gt;&lt;a href=&quot;diameter#call-4&quot;&gt;diameter:call/4&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;diameter_app(3)&lt;/code&gt; 설명 된 콜백 인터페이스를 사용하여 메시지를 보내고받을 때 여기에서 명시 적으로 함수를 호출 할 필요가 없습니다 . diameter 자체는 &lt;code&gt;&lt;a href=&quot;diameter#start_service-2&quot;&gt;diameter:start_service/2&lt;/a&gt;&lt;/code&gt; 전달 된 구성의 결과로 인코딩 / 디코딩을 제공합니다 . 2 , 결과는 구성에 따라 여기에 설명 된 기능에 의해 반환 된 것과 다를 수있다.</target>
        </trans-unit>
        <trans-unit id="2251e3cdeb76f922995ac0b63ebf88f13a0667db" translate="yes" xml:space="preserve">
          <source>The diameterc utility is used to compile a diameter &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; into Erlang source. The resulting source implements the interface diameter required to encode and decode the dictionary's messages and AVPs.</source>
          <target state="translated">diameterc 유틸리티는 직경 &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;dictionary file&lt;/a&gt;&lt;/code&gt; 을 Erlang 소스로 컴파일하는 데 사용됩니다 . 결과 소스는 사전의 메시지와 AVP를 인코딩하고 디코딩하는 데 필요한 인터페이스 직경을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a115af3fd2bc7d650329a3a62d8207ca3be6bd75" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt; deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">압축기에서 선택한 사전은 반환 된 Adler 값에서 결정되거나 inflate 함수 호출에 의해 발생합니다. 압축기와 압축 해제 &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt; deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 동일한 사전을 사용해야합니다 ( deflateSetDictionary / 2 참조 ).</target>
        </trans-unit>
        <trans-unit id="a8b611f53150beb161ae68d1baa02e238a69d7fe" translate="yes" xml:space="preserve">
          <source>The dictionary chosen by the compressor can be determined from the Adler value returned or thrown by the call to the inflate function. The compressor and decompressor must use the same dictionary (See &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">압축기에 의해 선택된 사전은 팽창 함수 호출에 의해 리턴되거나 발생 된 Adler 값으로부터 결정될 수있다. 압축기와 압축 해제 &lt;code&gt;&lt;a href=&quot;#deflateSetDictionary-2&quot;&gt;deflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 동일한 사전을 사용해야합니다 ( deflateSetDictionary / 2 참조 ).</target>
        </trans-unit>
        <trans-unit id="dc7c7b0117c79bf085087df0d9077cbcde71b86c" translate="yes" xml:space="preserve">
          <source>The dictionary interface documented in &lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; provides extensibility, allowing the user to defined new AVPs, commands, and applications. Ready dictionaries are provided for the RFC 6733 common message, base accounting, and relay applications, as well as for RFC 7683, Diameter Overload Indicator Conveyance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;diameter_dict&quot;&gt;diameter_dict(4)&lt;/a&gt;&lt;/code&gt; 문서화 된 사전 인터페이스 는 확장 성을 제공하여 사용자가 새로운 AVP, 명령 및 응용 프로그램을 정의 할 수 있도록합니다. RFC 6733 공통 메시지, 기본 회계 및 릴레이 응용 프로그램뿐만 아니라 RFC 7683, 직경 과부하 표시기 전송에 대한 준비 사전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="569d4e7fc1379c78daae74de968aa2107c8de266" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; on one hand, and &lt;code&gt;ordered_set&lt;/code&gt; on the other, regarding the fact that &lt;code&gt;ordered_set&lt;/code&gt; view keys as equal when they &lt;strong&gt;compare equal&lt;/strong&gt; whereas the other table types regard them equal only when they &lt;strong&gt;match&lt;/strong&gt;, holds for &lt;code&gt;lookup_element/3&lt;/code&gt;.</source>
          <target state="translated">차이 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 및 &lt;code&gt;duplicate_bag&lt;/code&gt; 한편, 및 &lt;code&gt;ordered_set&lt;/code&gt; 사실에 관한 다른 한편, &lt;code&gt;ordered_set&lt;/code&gt; 동일로보기 버튼들이 &lt;strong&gt;동일한 비교&lt;/strong&gt; 다른 테이블 유형들이 언제 그들 만 동일 간주 반면 &lt;strong&gt;일치&lt;/strong&gt; 를 위해 보유 &lt;code&gt;lookup_element/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="623ffdc435a2f724f0836bec7cc8ec30bc41c15a" translate="yes" xml:space="preserve">
          <source>The difference between lists as semantic objects (built up of individual &quot;cons&quot; and &quot;nil&quot; terms) and the various syntactic forms for denoting lists may be bewildering at first. This module provides functions both for exact control of the syntactic representation as well as for the simple composition and deconstruction in terms of cons and head/tail operations.</source>
          <target state="translated">의미 적 객체 (개별 &quot;cons&quot;및 &quot;nil&quot;용어로 구성됨)로서의 목록과 목록을 표시하기위한 다양한 구문 형태의 차이는 처음에는 어리둥절 할 수 있습니다. 이 모듈은 구문 표현의 정확한 제어뿐만 아니라 단점과 헤드 / 테일 연산의 관점에서 간단한 구성과 해체를위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da1728bb07e837f250209bb055d7409170953dd6" translate="yes" xml:space="preserve">
          <source>The difference between the &lt;code&gt;config&lt;/code&gt; terms above is that with &lt;code&gt;ConfigDir&lt;/code&gt;, &lt;code&gt;ConfigBaseNames&lt;/code&gt; is a list of base names, that is, without directory paths. &lt;code&gt;ConfigFiles&lt;/code&gt; must be full names, including paths. For example, the following two terms have the same meaning:</source>
          <target state="translated">사이의 차이 &lt;code&gt;config&lt;/code&gt; 조건은 상기와이다 &lt;code&gt;ConfigDir&lt;/code&gt; , &lt;code&gt;ConfigBaseNames&lt;/code&gt; 는 디렉토리 경로없이 인베이스 이름들의 목록이다. &lt;code&gt;ConfigFiles&lt;/code&gt; 은 경로를 포함한 전체 이름이어야합니다. 예를 들어 다음 두 용어의 의미는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4f869b97b89ad5b7b934ce2b75aa574db5f22948" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is in how they get the modules to check. &lt;code&gt;versions1&lt;/code&gt; uses the app-file and &lt;code&gt;versions2&lt;/code&gt; uses the function &lt;code&gt;application:get_key&lt;/code&gt;.</source>
          <target state="translated">두 기능의 차이점은 모듈을 확인하는 방법에 있습니다. &lt;code&gt;versions1&lt;/code&gt; 은 app-file을 사용 하고 &lt;code&gt;versions2&lt;/code&gt; 는 &lt;code&gt;application:get_key&lt;/code&gt; 함수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="633f35639fdb5cc1cb10fd8f4689bf3336703581" translate="yes" xml:space="preserve">
          <source>The difference between these functions is the order the table is accessed for &lt;code&gt;ordered_set&lt;/code&gt; tables. For other table types the functions are equivalent.</source>
          <target state="translated">이 함수의 차이점은 &lt;code&gt;ordered_set&lt;/code&gt; 테이블에 대해 테이블에 액세스하는 순서 입니다. 다른 테이블 유형의 경우 기능이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="293fb4be14373398bacd278126f271ff3f4aab95" translate="yes" xml:space="preserve">
          <source>The difference between using the macros and the exported functions is that macros add location (originator) information to the metadata, and performs lazy evaluation by wrapping the logger call in a case statement, so it is only evaluated if the log level of the event passes the primary log level check.</source>
          <target state="translated">매크로를 사용하는 것과 내 보낸 함수의 차이점은 매크로는 메타 데이터에 위치 (생성자) 정보를 추가하고 로거 호출을 case 문에 랩핑하여 지연 평가를 수행하므로 이벤트의 로그 레벨이 통과하는 경우에만 평가된다는 것입니다 기본 로그 수준 확인</target>
        </trans-unit>
        <trans-unit id="9bd33d3347fbec04e6dd5bced0f65f041be1e03c" translate="yes" xml:space="preserve">
          <source>The difference here is that a check is made for two keys in each map argument. The other keys are ignored.</source>
          <target state="translated">차이점은 각 맵 인수에서 두 개의 키를 검사한다는 것입니다. 다른 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="57afc2a6da2d7ad1a93ff6f446c9b773c487ccf9" translate="yes" xml:space="preserve">
          <source>The difference is the same as between &lt;code&gt;=:=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">차이점은 &lt;code&gt;=:=&lt;/code&gt; 과 &lt;code&gt;==&lt;/code&gt; 의 경우와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a13a50925424597a830fc48487f1c8e6506ee4cb" translate="yes" xml:space="preserve">
          <source>The different &lt;code&gt;&lt;a href=&quot;#Time-Outs&quot;&gt;Time-Outs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;next_event&lt;/a&gt;&lt;/code&gt; actions generate new events with corresponding &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; Event Types and Event Content &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;&lt;a href=&quot;#Time-Outs&quot;&gt;Time-Outs&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#Inserted%20Events&quot;&gt;next_event&lt;/a&gt;&lt;/code&gt; 작업은 해당 &lt;code&gt;&lt;a href=&quot;#Event%20Types%20and%20Event%20Content&quot;&gt; Event Types and Event Content &lt;/a&gt;&lt;/code&gt; 함께 새 이벤트를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="37953effd4c1eb8de7eafd4f2558c81bd077904b" translate="yes" xml:space="preserve">
          <source>The different amounts of memory that are summed are &lt;strong&gt;not&lt;/strong&gt; gathered atomically, which introduces an error in the result.</source>
          <target state="translated">합산 된 다른 메모리 양은 원자 적으로 수집 &lt;strong&gt;되지 않으므로&lt;/strong&gt; 결과에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="63548572b896ecd0cf28068a1070f068efa94f1e" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; to load the MIB, and &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="translated">다른 애플리케이션은 MIB를 에이전트에로드하기 위해 다른 전략을 사용합니다. 일부 MIB 구현은 코드 전용이며 다른 MIB 구현은 서버가 필요합니다. 코드 전용 MIB 구현에서 사용되는 한 가지 방법은 사용자가 &lt;code&gt;otp_mib:load(Agent)&lt;/code&gt; 와 같은 함수를 호출 하여 MIB를로드하고 &lt;code&gt;otp_mib:unload(Agent)&lt;/code&gt; 와 같은 함수를 호출 하여 MIB 를 언로드하는 것입니다. 각 MIB를로드하는 방법에 대한 설명은 각 응용 프로그램의 설명서 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8edadae2095be022adc91aad4a672571547faa5" translate="yes" xml:space="preserve">
          <source>The different applications use different strategies for loading the MIBs into the agent. Some MIB implementations are code-only, while others need a server. One way, used by the code-only MIB implementations, is for the user to call a function such as &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; to load the MIB, and &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; to unload the MIB. See the manual page for each application for a description of how to load each MIB.</source>
          <target state="translated">서로 다른 애플리케이션은 MIB를 에이전트에로드하기 위해 서로 다른 전략을 사용합니다. 일부 MIB 구현은 코드 전용이고 다른 일부는 서버가 필요합니다. 코드 전용 MIB 구현에서 사용되는 한 가지 방법은 사용자가 &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; 와 같은 함수를 호출 하여 MIB를로드하고 &lt;code&gt;snmpa:unload_mibs(Agent, [Mib])&lt;/code&gt; 를 언로드하는 것입니다. MIB. 각 MIB를로드하는 방법에 대한 설명은 각 애플리케이션의 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b79b82512ebbf07ebe9d9f10fb15d9e8e743cedd" translate="yes" xml:space="preserve">
          <source>The different options that can be given to &lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#print-2&quot;&gt;print/2&lt;/a&gt;&lt;/code&gt; 에 부여 할 수있는 다른 옵션 .</target>
        </trans-unit>
        <trans-unit id="c7a06445034a6453f0f6ebe99a200207183eacb6" translate="yes" xml:space="preserve">
          <source>The different queries are described in section &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 쿼리는 &lt;code&gt;&lt;a href=&quot;#interactive_flags&quot;&gt;Interactive options&lt;/a&gt;&lt;/code&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39eab07bc9f9f2de5d553eb9e3b513aeec95de3f" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="translated">스레드가있을 수있는 여러 상태입니다. 자세한 내용은 &lt;code&gt; erlang:statistics(microstate_accounting)&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8fc4891f4df1692cd0b3f6e8badc0320a795dc5b" translate="yes" xml:space="preserve">
          <source>The different states that a thread can be in. See &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; for details.</source>
          <target state="translated">스레드가있을 수있는 여러 가지 상태. 자세한 내용은 &lt;code&gt;erlang:statistics(microstate_accounting)&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59070d2c07904f6e20fde995a37ca6d79f115caa" translate="yes" xml:space="preserve">
          <source>The different trace tags that the tracer is called with. Each trace tag is described in detail in &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추적 프로그램이 호출되는 다른 추적 태그 각 추적 태그는 &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="26366e48ea2a96c9fc5d9a43d23aaffa5017f9cd" translate="yes" xml:space="preserve">
          <source>The different types are as follows:</source>
          <target state="translated">다른 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33105c1c6606db02bff579f3c5759de25bdebf48" translate="yes" xml:space="preserve">
          <source>The different types of schedulers handle specific types of jobs. Every job is assigned to a specific scheduler type. Jobs can migrate between different schedulers of the same type, but never between schedulers of different types. This fact has to be taken under consideration when evaluating the result returned.</source>
          <target state="translated">다른 유형의 스케줄러는 특정 유형의 작업을 처리합니다. 모든 작업은 특정 스케줄러 유형에 지정됩니다. 작업은 동일한 유형의 다른 스케줄러간에 마이그레이션 할 수 있지만 다른 유형의 스케줄러 간에는 마이그레이션 할 수 없습니다. 반환 된 결과를 평가할 때이 사실을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="1be30a2a4e12fc360bee8dc49ed629e5a73999d2" translate="yes" xml:space="preserve">
          <source>The different values have the following relation to each other. Values beginning with an uppercase letter is not part of the result.</source>
          <target state="translated">서로 다른 값은 서로 다음과 같은 관계가 있습니다. 대문자로 시작하는 값은 결과의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="27f3bb8909ba5f23310f5128f455bc5958825585" translate="yes" xml:space="preserve">
          <source>The digraph can be read and modified by the creating process only.</source>
          <target state="translated">이 digraph는 작성 프로세스에 의해서만 읽고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5490f515ffc9d05efae42bd4eb4b5cd4c506605c" translate="yes" xml:space="preserve">
          <source>The digraph is to be kept &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이중 음자는 유지 될 &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a122eabc0003f4c72a6d838ab9da37d1a4643c2" translate="yes" xml:space="preserve">
          <source>The digraphs managed by this module are stored in &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS tables&lt;/a&gt;&lt;/code&gt;. That implies the following:</source>
          <target state="translated">이 모듈에서 관리하는 digraph는 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ETS tables&lt;/a&gt;&lt;/code&gt; 저장됩니다 . 이는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="08c044f6070f82e882ec6b0eabc539f770d3dd32" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-error(Term)&lt;/code&gt; causes a compilation error.</source>
          <target state="translated">&lt;code&gt;-error(Term)&lt;/code&gt; 지시문 은 컴파일 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b3797b9e1d8ee2883c9f63d0a42a95ca4d06540e" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;-warning(Term)&lt;/code&gt; causes a compilation warning.</source>
          <target state="translated">&lt;code&gt;-warning(Term)&lt;/code&gt; 지시문 은 컴파일 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="58617ed5f0889f1d1f3277ea479ef4c02a22c0a7" translate="yes" xml:space="preserve">
          <source>The directories given by the &lt;code&gt;include&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 옵션으로 제공된 디렉토리</target>
        </trans-unit>
        <trans-unit id="1f52da4640ac6f1c489638d9eafbfb94f7337064" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;-I&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">&lt;code&gt;-I&lt;/code&gt; 옵션을 사용하여 지정된 디렉토리 ; 마지막으로 지정된 디렉토리가 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="071745beb88d646a425661fabb7b2b140020baaf" translate="yes" xml:space="preserve">
          <source>The directories specified using option &lt;code&gt;i&lt;/code&gt;; the directory specified last is searched first</source>
          <target state="translated">옵션 &lt;code&gt;i&lt;/code&gt; 를 사용하여 지정된 디렉토리 ; 마지막으로 지정된 디렉토리가 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="be6fba73ebc340991bdfb6820c1ebc97ba0e0651" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;Path&lt;/code&gt;does not exist.</source>
          <target state="translated">디렉토리 &lt;code&gt;Path&lt;/code&gt; 가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bccd89dc32dbb0c503ff0753756340f2c3e005e" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션으로 디렉토리를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdb62f5fdc6e1ffa70960cbc73d316528fae55b5" translate="yes" xml:space="preserve">
          <source>The directory could be changed with the option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 디렉토리를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acc2f12b5fc8219c0bfb75133fa338329e4cc3b0" translate="yes" xml:space="preserve">
          <source>The directory does not exist.</source>
          <target state="translated">디렉토리가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="117b6acef024fb182d6e7698c7419f59fe7b75af" translate="yes" xml:space="preserve">
          <source>The directory for (1) back-up copy and (2) Erlang-specific configuration file for &lt;code&gt;syslogd&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;syslogd&lt;/code&gt; 에 대한 (1) 백업 사본 및 (2) Erlang 특정 구성 파일의 디렉토리</target>
        </trans-unit>
        <trans-unit id="339f3fbc63ee87a760e5d5881f1be19ceac96fd2" translate="yes" xml:space="preserve">
          <source>The directory is not empty.</source>
          <target state="translated">디렉토리가 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7febdc58b57a39ad1e446e02f6b42469827aa2db" translate="yes" xml:space="preserve">
          <source>The directory listing also contains one &lt;code&gt;.DAT&lt;/code&gt; file, which contains the schema itself, contained in the &lt;code&gt;schema.DAT&lt;/code&gt; file. The &lt;code&gt;DAT&lt;/code&gt; files are indexed files, and it is efficient to insert and search for records in these files with a specific key. The &lt;code&gt;.DAT&lt;/code&gt; files are used for the schema and for &lt;code&gt;disc_only_copies&lt;/code&gt; tables. The &lt;code&gt;Mnesia&lt;/code&gt; data files are currently implemented in the standard library module &lt;code&gt;dets&lt;/code&gt; in &lt;code&gt;STDLIB&lt;/code&gt;.</source>
          <target state="translated">디렉토리 목록에는 &lt;code&gt;schema.DAT&lt;/code&gt; 파일 에 포함 된 스키마 자체를 포함하는 하나의 &lt;code&gt;.DAT&lt;/code&gt; 파일 도 포함되어 있습니다 . &lt;code&gt;DAT&lt;/code&gt; 의 파일은 인덱스 파일이며, 삽입하고 특정 키 이러한 파일의 레코드를 검색 할 효율적입니다. &lt;code&gt;.DAT&lt;/code&gt; 의 파일은 스키마 및 사용되는 &lt;code&gt;disc_only_copies&lt;/code&gt; 의 테이블. &lt;code&gt;Mnesia&lt;/code&gt; 의 데이터 파일은 현재 표준 라이브러리 모듈에서 구현 &lt;code&gt;dets&lt;/code&gt; 에서 &lt;code&gt;STDLIB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc8511921c9959d184fd92a30bcce8e510e914f" translate="yes" xml:space="preserve">
          <source>The directory structure for the code installed by the release handler from a release package is as follows:</source>
          <target state="translated">릴리스 패키지에서 릴리스 핸들러가 설치 한 코드의 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a42562d2ee99aac69e248e9c1d20b489a29d934f" translate="yes" xml:space="preserve">
          <source>The directory to read the application from. This parameter can be used to point out a specific location to fetch the application from. This is useful for instance if the parent directory for some reason is no good as a library directory on system level.</source>
          <target state="translated">응용 프로그램을 읽을 디렉토리입니다. 이 매개 변수는 응용 프로그램을 가져올 특정 위치를 가리키는 데 사용할 수 있습니다. 이것은 어떤 이유로 상위 디렉토리가 시스템 레벨의 라이브러리 디렉토리로 좋지 않은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d7bfc486e65b60f6f17e8c030cc98aaf1f5887ba" translate="yes" xml:space="preserve">
          <source>The directory where temporary files are put can be chosen explicitly. The default, implied by value &lt;code&gt;&quot;&quot;&lt;/code&gt;, is to put temporary files on the same directory as the sorted output file. If output is a function (see below), the directory returned by &lt;code&gt;file:get_cwd()&lt;/code&gt; is used instead. The names of temporary files are derived from the Erlang nodename (&lt;code&gt;node()&lt;/code&gt;), the process identifier of the current Erlang emulator (&lt;code&gt;os:getpid()&lt;/code&gt;), and a unique integer (&lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt;). A typical name is &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt;, where &lt;code&gt;17&lt;/code&gt; is a sequence number. Existing files are overwritten. Temporary files are deleted unless some uncaught &lt;code&gt;EXIT&lt;/code&gt; signal occurs.</source>
          <target state="translated">임시 파일이있는 디렉토리를 명시 적으로 선택할 수 있습니다. &lt;code&gt;&quot;&quot;&lt;/code&gt; 값으로 암시되는 기본값 은 임시 파일을 정렬 된 출력 파일과 동일한 디렉토리에 두는 것입니다. 출력이 함수 인 경우 (아래 참조) &lt;code&gt;file:get_cwd()&lt;/code&gt; 반환 한 디렉토리 가 대신 사용됩니다. 임시 파일 이름은 Erlang 노드 이름 ( &lt;code&gt;node()&lt;/code&gt; ), 현재 Erlang 에뮬레이터의 프로세스 식별자 ( &lt;code&gt;os:getpid()&lt;/code&gt; ) 및 고유 한 정수 ( &lt;code&gt;erlang:unique_integer([positive])&lt;/code&gt; )에서 파생 됩니다. 일반적인 이름은 &lt;code&gt;fs_mynode@myhost_1763_4711.17&lt;/code&gt; 이며 여기서 &lt;code&gt;17&lt;/code&gt; 은 시퀀스 번호입니다. 기존 파일을 덮어 씁니다. 포착되지 않은 &lt;code&gt;EXIT&lt;/code&gt; 가 아니면 임시 파일이 삭제됩니다. 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="26b2546fb62728f487df23d7a64fc6038e2f04cd" translate="yes" xml:space="preserve">
          <source>The directory where the compiler is to place the output files. Defaults to the current working directory.</source>
          <target state="translated">컴파일러가 출력 파일을 배치 할 디렉토리입니다. 현재 작업 디렉토리가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="23d4b2c59c247070b6160ec438b2f4a12342bdf0" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the agent.</source>
          <target state="translated">구성 파일이있는 디렉토리는 에이전트에 매개 변수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f35f2fdf2411bb1709c721e727448cb07cb8e62e" translate="yes" xml:space="preserve">
          <source>The directory where the configuration files are found is given as a parameter to the manager.</source>
          <target state="translated">구성 파일이있는 디렉토리는 관리자에게 매개 변수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="57ac9409f64c817119b2a62c56ec2039ee44af45" translate="yes" xml:space="preserve">
          <source>The directory where the module is being compiled</source>
          <target state="translated">모듈이 컴파일되는 디렉토리</target>
        </trans-unit>
        <trans-unit id="a823ed8e05f4f19f697c128e1d3b1f2bf689cda5" translate="yes" xml:space="preserve">
          <source>The disconnect may either be made explicitly by a call to megaco:disconnect/2 or implicitly when the control process of the connection dies.</source>
          <target state="translated">연결 해제는 megaco : disconnect / 2에 대한 호출에 의해 명시 적으로 작성되거나 연결 제어 프로세스가 종료 될 때 내재적으로 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ffbc4f5819bc4c210bf785d2c507c9b376119c7" translate="yes" xml:space="preserve">
          <source>The discovery module may implement the following callback:</source>
          <target state="translated">감지 모듈은 다음 콜백을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84d184d395f04b053ca8e8de39c92096a4dfaac1" translate="yes" xml:space="preserve">
          <source>The discovery module needs to implement the same API as the regular &lt;code&gt;EPMD module&lt;/code&gt;. However, instead of communicating with EPMD you can connect to any service to find out connection details of other nodes. A discovery module is enabled by setting &lt;code&gt;-epmd_module&lt;/code&gt; when starting erlang. The discovery module must implement the following callbacks:</source>
          <target state="translated">검색 모듈은 일반 &lt;code&gt;EPMD module&lt;/code&gt; 과 동일한 API를 구현해야 합니다 . 그러나 EPMD와 통신하는 대신 모든 서비스에 연결하여 다른 노드의 연결 세부 사항을 찾을 수 있습니다. erlang을 시작할 때 &lt;code&gt;-epmd_module&lt;/code&gt; 을 설정하여 감지 모듈을 사용할 수 있습니다. 감지 모듈은 다음 콜백을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="99d7db3ae01fbb644d3dec6e8da4ab75b95c8848" translate="yes" xml:space="preserve">
          <source>The disk log process is not terminated as long as there are owners or users of the log. All owners must close the log, possibly by terminating. Also, any other process, not only the processes that have opened the log anonymously, can decrement the &lt;code&gt;users&lt;/code&gt; counter by closing the log. Attempts to close a log by a process that is not an owner are ignored if there are no users.</source>
          <target state="translated">로그의 소유자 또는 사용자가있는 한 디스크 로그 프로세스는 종료되지 않습니다. 모든 소유자는 종료하여 로그를 닫아야합니다. 또한 익명으로 로그를 연 프로세스뿐만 아니라 다른 프로세스도 로그 를 닫아 &lt;code&gt;users&lt;/code&gt; 카운터를 줄일 수 있습니다 . 사용자가없는 경우 소유자가 아닌 프로세스에서 로그를 닫으려는 시도는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="170e47f1105c3410c9337c315483a1099114bce2" translate="yes" xml:space="preserve">
          <source>The disk space required by Solaris can be minimized by using the Core User support installation. It requires about 80 MB of disk space. This installs only the minimum software required to boot and run Solaris. The disk space can be further reduced by deleting unnecessary individual files. However, unless disk space is a critical resource the effort required and the risks involved cannot be justified.</source>
          <target state="translated">핵심 사용자 지원 설치를 사용하여 Solaris에 필요한 디스크 공간을 최소화 할 수 있습니다. 약 80MB의 디스크 공간이 필요합니다. Solaris를 부트하고 실행하는 데 필요한 최소 소프트웨어 만 설치합니다. 불필요한 개별 파일을 삭제하여 디스크 공간을 더욱 줄일 수 있습니다. 그러나 디스크 공간이 중요한 리소스가 아니라면 필요한 노력과 관련된 위험을 정당화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe0b0c298992c4d4142451f12161d0c1045bd18b" translate="yes" xml:space="preserve">
          <source>The distributed &lt;code&gt;disk_log&lt;/code&gt; feature is as of &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; and will be removed in OTP 24.</source>
          <target state="translated">분산 된 &lt;code&gt;disk_log&lt;/code&gt; 기능은 &lt;code&gt;&lt;a href=&quot;deprecations#otp-23&quot;&gt;OTP 23 deprecated&lt;/a&gt;&lt;/code&gt; OTP 24에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3a6a6e83a54df4db4da031bb114c30e047aae690" translate="yes" xml:space="preserve">
          <source>The distributed disk log feature has been deprecated. This feature has also been scheduled for removal in OTP 24.</source>
          <target state="translated">분산 디스크 로그 기능은 더 이상 사용되지 않습니다. 이 기능은 OTP 24에서도 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="5252445bcfdf0c4e9a0db2f6abd1c5ab396bbcae" translate="yes" xml:space="preserve">
          <source>The distribution does this implicitly when sending messages across node boundaries.</source>
          <target state="translated">분배는 노드 경계를 통해 메시지를 보낼 때이를 암시 적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="54a389857119d0e949a971f667eeb2bc4135d70c" translate="yes" xml:space="preserve">
          <source>The distribution header format is as follows:</source>
          <target state="translated">배포 헤더 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec94c3993a60ce6a0e075478f122164e01b59597" translate="yes" xml:space="preserve">
          <source>The distribution header is sent by the erlang distribution to carry metadata about the coming &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; and potential payload. It is primarily used to handle the atom cache in the Erlang distribution. Since OTP-22 it is also used to fragment large distribution messages into multiple smaller fragments. For more information about how the distribution uses the distribution header, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="translated">배포 헤더는 다가오는 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; 및 잠재적 페이로드에 대한 메타 데이터를 전달하기 위해 erlang 배포에 의해 전송됩니다 . 주로 Erlang 배포판에서 원자 캐시를 처리하는 데 사용됩니다. OTP-22 이후 대용량 배포 메시지를 여러 개의 작은 조각으로 분할하는데도 사용됩니다. 배포에서 배포 헤더를 사용하는 방법에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; 설명서 에서 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7207d53f2df6dd951040b5a96c6e6f572abc8fba" translate="yes" xml:space="preserve">
          <source>The distribution header only contains an atom cache reference section, but can in the future contain more information. The distribution header precedes one or more Erlang terms on the external format. For more information, see the documentation of the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; documentation.</source>
          <target state="translated">배포 헤더에는 원자 캐시 참조 섹션 만 포함되어 있지만 나중에 추가 정보를 포함 할 수 있습니다. 배포 헤더는 외부 형식에서 하나 이상의 Erlang 용어 앞에옵니다. 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol&quot;&gt;distribution protocol&lt;/a&gt;&lt;/code&gt; 설명서 에서 &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;protocol between connected nodes&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2379df6378023fbabe88db9769e48826a29d56a" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is implemented using TCP/IP sockets. How to implement an alternative carrier is described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">분배 메커니즘은 TCP / IP 소켓을 사용하여 구현됩니다. 대체 운송 업체를 구현하는 방법은 &lt;code&gt;ERTS User's Guide&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62295fb74df53713cac7805be082a69085ad9fa7" translate="yes" xml:space="preserve">
          <source>The distribution mechanism is not backward compatible by default. This flag sets the emulator in compatibility mode with an earlier Erlang/OTP release &lt;code&gt;ReleaseNumber&lt;/code&gt;. The release number must be in the range &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt;. This limits the emulator, making it possible for it to communicate with Erlang nodes (as well as C- and Java nodes) running that earlier release.</source>
          <target state="translated">배포 메커니즘은 기본적으로 이전 버전과 호환되지 않습니다. 이 플래그는 에뮬레이터를 이전 Erlang / OTP 릴리스 &lt;code&gt;ReleaseNumber&lt;/code&gt; 와의 호환성 모드로 설정합니다 . 릴리스 번호는 &lt;code&gt;&amp;lt;current release&amp;gt;-2..&amp;lt;current release&amp;gt;&lt;/code&gt; 범위에 있어야합니다 . 이로 인해 에뮬레이터가 제한되어 이전 릴리스를 실행하는 Erlang 노드 (C 및 Java 노드)와 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cd5b036f8947d038790d0e5bd184b32b79cd32e" translate="yes" xml:space="preserve">
          <source>The distribution module expose an API that &lt;code&gt;net_kernel&lt;/code&gt; call in order to manage connections to other nodes. The module name should have the suffix &lt;code&gt;_dist&lt;/code&gt;.</source>
          <target state="translated">배포 모듈 은 다른 노드에 대한 연결을 관리하기 위해 &lt;code&gt;net_kernel&lt;/code&gt; 이 호출 하는 API를 노출합니다 . 모듈 이름의 접미사 &lt;code&gt;_dist&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9731f94ba0606fc85b916d2adf784a2aceb2f3dc" translate="yes" xml:space="preserve">
          <source>The distribution module for SSL/TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="translated">SSL / TLS 용 분배 모듈의 이름은 &lt;code&gt;inet_tls_dist&lt;/code&gt; 이며 명령 행에서 &lt;code&gt;-proto_dist&lt;/code&gt; 옵션을 사용하여 지정됩니다 . &lt;code&gt;-proto_dist&lt;/code&gt; 의 인수 는 접미 부 &lt;code&gt;_dist&lt;/code&gt; 가 없는 모듈 이름 입니다. 따라서이 분배 모듈은 명령 행에서 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1f0fad23847abdca6666c395577ff14f2547ccd" translate="yes" xml:space="preserve">
          <source>The distribution module for TLS is named &lt;code&gt;inet_tls_dist&lt;/code&gt; and is specified on the command line with option &lt;code&gt;-proto_dist&lt;/code&gt;. The argument to &lt;code&gt;-proto_dist&lt;/code&gt; is to be the module name without suffix &lt;code&gt;_dist&lt;/code&gt;. So, this distribution module is specified with &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; on the command line.</source>
          <target state="translated">TLS 용 배포 모듈의 이름은 &lt;code&gt;inet_tls_dist&lt;/code&gt; 이며 명령 줄에서 &lt;code&gt;-proto_dist&lt;/code&gt; 옵션으로 지정 됩니다. &lt;code&gt;-proto_dist&lt;/code&gt; 에 대한 인수 는 접미사 &lt;code&gt;_dist&lt;/code&gt; 가 없는 모듈 이름 입니다. 따라서이 배포 모듈은 명령 줄에서 &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aeea032ca4cef8b317244fbb44d9a32ae5f5898" translate="yes" xml:space="preserve">
          <source>The distribution protocol can be divided into four parts:</source>
          <target state="translated">배포 프로토콜은 다음 네 부분으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff1a3d4e65478d9f5f71da059cfc38ed2c96b5ba" translate="yes" xml:space="preserve">
          <source>The distribution starts at boot if all the above is specified and an &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; flag is present at the command line.</source>
          <target state="translated">위의 모든 사항이 지정되고 명령 줄에 &lt;code&gt;-sname &amp;lt;name&amp;gt;&lt;/code&gt; 플래그가 있으면 배포시 부팅이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b01c03572e2e4aaafce0356c4411e135ed1f526" translate="yes" xml:space="preserve">
          <source>The document returned by &lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; and &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt;. The type of the returned record depends on the value of the document option passed to the function.</source>
          <target state="translated">&lt;code&gt;xmerl_scan:string/[1,2]&lt;/code&gt; 및 &lt;code&gt;xmerl_scan:file/[1,2]&lt;/code&gt; 에서 리턴 한 문서 . 리턴 된 레코드의 유형은 함수에 전달 된 문서 옵션의 값에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="00d8e9f113e0a458f5df4e4708996df9d6090e13" translate="yes" xml:space="preserve">
          <source>The documentation can be installed either using the &lt;code&gt;install-docs&lt;/code&gt; target, or using the &lt;code&gt;release_docs&lt;/code&gt; target.</source>
          <target state="translated">&lt;code&gt;install-docs&lt;/code&gt; 대상을 사용하거나 &lt;code&gt;release_docs&lt;/code&gt; 대상을 사용하여 문서를 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5149c903e3309937ac98a7bf77705046a7abe19b" translate="yes" xml:space="preserve">
          <source>The dollar character is an assertion that is true only if the current matching point is at the end of the subject string, or immediately before a newline at the end of the string (by default). Notice however that it does not match the newline. Dollar needs not to be the last character of the pattern if some alternatives are involved, but it is to be the last item in any branch in which it appears. Dollar has no special meaning in a character class.</source>
          <target state="translated">달러 문자는 현재 일치 지점이 제목 문자열의 끝에 있거나 문자열 끝의 줄 바꿈 바로 앞에있는 경우에만 참인 어설 션입니다 (기본적으로). 그러나 개행과 일치하지 않습니다. 일부 대안이 포함 된 경우 달러는 패턴의 마지막 문자 일 필요는 없지만 그것이 나타나는 분기의 마지막 항목이어야합니다. 문자 클래스에서 달러는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0fbbfd153dd0451d5221908c40847d88ba4f1d83" translate="yes" xml:space="preserve">
          <source>The domain of a family is called the &lt;strong&gt;index set&lt;/strong&gt;, and the range is called the &lt;strong&gt;indexed set&lt;/strong&gt;.</source>
          <target state="translated">패밀리의 도메인을 &lt;strong&gt;인덱스 세트&lt;/strong&gt; 라고하며 범위를 &lt;strong&gt;인덱스 세트&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="5952578f1a7b818cc8da70c30b5eb53cf1931cf6" translate="yes" xml:space="preserve">
          <source>The dot metacharacter</source>
          <target state="translated">도트 메타 문자</target>
        </trans-unit>
        <trans-unit id="0c39bb4aef52ace658cb63c48687e207b1ca1ec6" translate="yes" xml:space="preserve">
          <source>The downgrade script can then be evaluated using &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt;. It is recommended to use &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; instead, but this function (&lt;code&gt;downgrade_script&lt;/code&gt;) is useful to inspect the contents of the script.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 를 사용하여 다운 그레이드 스크립트를 평가할 수 있습니다 . 대신 &lt;code&gt;&lt;a href=&quot;#downgrade_app-2&quot;&gt;downgrade_app/2,3&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 좋지만이 기능 ( &lt;code&gt;downgrade_script&lt;/code&gt; )은 스크립트의 내용을 검사하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1a9b899e09f583022f6155a633fa34d496d384c3" translate="yes" xml:space="preserve">
          <source>The downside of an enforced transaction recovery decision is that the decision can be incorrect, because of insufficient information about the recovery decisions from the other nodes. This can result in an inconsistent database where &lt;code&gt;Mnesia&lt;/code&gt; has committed the transaction on some nodes but terminated it on others.</source>
          <target state="translated">강제 트랜잭션 복구 결정의 단점은 다른 노드의 복구 결정에 대한 정보가 충분하지 않기 때문에 결정이 잘못 될 수 있다는 것입니다. 이로 &lt;code&gt;Mnesia&lt;/code&gt; 가 일부 노드에서 트랜잭션을 커밋했지만 다른 노드에서 트랜잭션을 종료 한 데이터베이스가 일치하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bcc2bcf2d8764baa874ccaf0e26026a8ea86d10" translate="yes" xml:space="preserve">
          <source>The drive does not exist.</source>
          <target state="translated">드라이브가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a20548a0f73bb216b4b211c372344d02764897f0" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is not present in the system.</source>
          <target state="translated">시스템에 드라이버 &lt;code&gt;Name&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="822e4982aaf8b56398bd1a181c2b6889e1c63b93" translate="yes" xml:space="preserve">
          <source>The driver &lt;code&gt;Name&lt;/code&gt; is present in the system, but there is no &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of it in this process.</source>
          <target state="translated">드라이버 &lt;code&gt;Name&lt;/code&gt; 이 시스템에 있지만 이 프로세스 에는 해당 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1b210ce4bf131d4b12dbe57304824a0514f38f51" translate="yes" xml:space="preserve">
          <source>The driver binary has a field, &lt;code&gt;orig_bytes&lt;/code&gt;, which marks the start of the data in the binary.</source>
          <target state="translated">드라이버 이진에는 &lt;code&gt;orig_bytes&lt;/code&gt; 필드가 있으며 이진 에서 데이터의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="790a2c01c39cd01e89b6ba7ec3e95447572133e7" translate="yes" xml:space="preserve">
          <source>The driver callback functions are called synchronously from the Erlang emulator. If they take too long before completing, they can cause time-outs in the emulator. Use the queue or asynchronous calls if necessary, as the emulator must be responsive.</source>
          <target state="translated">드라이버 콜백 함수는 Erlang 에뮬레이터에서 동 기적으로 호출됩니다. 완료하기까지 너무 오래 걸리면 에뮬레이터에서 시간 초과가 발생할 수 있습니다. 에뮬레이터가 응답해야하므로 필요한 경우 큐 또는 비동기 호출을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="157c45a036de0fa3ddd4ea0c8781ead7513f314e" translate="yes" xml:space="preserve">
          <source>The driver calls back to the emulator, using the API functions declared in &lt;code&gt;erl_driver.h&lt;/code&gt;. They are used for outputting data from the driver, using timers, and so on.</source>
          <target state="translated">드라이버는 &lt;code&gt;erl_driver.h&lt;/code&gt; 에 선언 된 API 함수를 사용하여 에뮬레이터를 다시 호출합니다 . 드라이버에서 데이터를 출력하거나 타이머 등을 사용하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc789bf203b3722793ad6336ed379ee48dc982f5" translate="yes" xml:space="preserve">
          <source>The driver can exit and signal errors up to Erlang. This is only for severe errors, when the driver cannot possibly keep open.</source>
          <target state="translated">드라이버는 Erlang까지 종료하고 오류를 표시 할 수 있습니다. 드라이버가 계속 열려있을 수없는 심각한 오류에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="6e77324ef81504134fd1f1323beb52a29f3e3f65" translate="yes" xml:space="preserve">
          <source>The driver can only be unloaded when there are no open ports using it and no more &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; require it to be loaded.</source>
          <target state="translated">드라이버는 사용중인 열린 포트가없고 더 이상 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가로드 할 필요 가없는 경우에만 언로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02d2238ddb29e9e347e288bd01312cba05b7f070" translate="yes" xml:space="preserve">
          <source>The driver data types and the functions available to the driver writer are defined in header file &lt;code&gt;erl_driver.h&lt;/code&gt; seated in Erlang's include directory. See the &lt;code&gt;erl_driver&lt;/code&gt; documentation for details of which functions are available.</source>
          <target state="translated">드라이버 라이터가 사용할 수있는 드라이버 데이터 유형 및 기능 은 Erlang의 include 디렉토리에 있는 헤더 파일 &lt;code&gt;erl_driver.h&lt;/code&gt; 에 정의되어 있습니다. 사용 가능한 기능에 대한 자세한 내용은 &lt;code&gt;erl_driver&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85f6b3a5e6e8b698b73cc7423736b57c1fc18515" translate="yes" xml:space="preserve">
          <source>The driver entry contains the functions that will be called by the emulator. In this example, only &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;control&lt;/code&gt; are provided:</source>
          <target state="translated">드라이버 항목에는 에뮬레이터에서 호출 할 함수가 포함되어 있습니다. 이 예제에서는 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 및 &lt;code&gt;control&lt;/code&gt; 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb368d133889289794fdcfad4ea08d3c6807b8d" translate="yes" xml:space="preserve">
          <source>The driver has made itself permanent, in which case it can no longer be manipulated by this interface (much like a statically linked-in driver).</source>
          <target state="translated">드라이버 자체는 영구적으로 만들어졌으며이 경우 더 이상이 인터페이스에서 더 이상 조작 할 수 없습니다 (정적으로 링크 된 드라이버와 유사 함).</target>
        </trans-unit>
        <trans-unit id="66000da869d699cedf77816fe5c89cc8b497a778" translate="yes" xml:space="preserve">
          <source>The driver has requested itself to be permanent, making it behave like an Erlang linked-in driver and can no longer be manipulated with this API.</source>
          <target state="translated">드라이버는 영구적으로 요청하여 Erlang 링크 된 드라이버처럼 작동하며 더 이상이 API로 조작 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f5e1b2ebfdf61236b9724f8274637d3ec47df15" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="translated">드라이버는 Erlang이 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 을 호출 할 때 호출되는 동기 인터페이스 인 제어 인터페이스를 구현합니다 . 이 인터페이스 만이 &lt;code&gt;data&lt;/code&gt; 모드 에있을 때 드라이버를 제어 할 수 있습니다 . 다음 opcode를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb99a228136eba922ef8092328ac0928261c0a09" translate="yes" xml:space="preserve">
          <source>The driver implements a control interface, which is a synchronous interface called when Erlang calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;. Only this interface can control the driver when it is in &lt;code&gt;data&lt;/code&gt; mode. It can be called with the following opcodes:</source>
          <target state="translated">드라이버는 제어 인터페이스를 구현합니다. 제어 인터페이스는 Erlang이 &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 호출되는 동기식 인터페이스 입니다. 이 인터페이스 만 &lt;code&gt;data&lt;/code&gt; 모드 에있을 때 드라이버를 제어 할 수 있습니다 . 다음 opcode를 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb42a7455c90c66663b33eefe7d7a842a5468cbc" translate="yes" xml:space="preserve">
          <source>The driver initialization routine is (usually) declared with a macro to make the driver easier to port between different operating systems (and flavors of systems). This is the only routine that must have a well-defined name. All other callbacks are reached through the driver structure. The macro to use is named &lt;code&gt;DRIVER_INIT&lt;/code&gt; and takes the driver name as parameter:</source>
          <target state="translated">드라이버 초기화 루틴은 일반적으로 매크로를 사용하여 선언되어 드라이버가 다른 운영 체제 (및 다양한 시스템)간에 쉽게 이식 할 수 있도록합니다. 이것은 잘 정의 된 이름을 가져야하는 유일한 루틴입니다. 다른 모든 콜백은 드라이버 구조를 통해 도달합니다. 사용할 매크로의 이름은 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 이며 드라이버 이름을 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df5c267a32b3ddcfaa0938eb24b89bd6abfd4b02" translate="yes" xml:space="preserve">
          <source>The driver is already loaded with other &lt;code&gt;DriverOptionList&lt;/code&gt; or a different &lt;strong&gt;literal&lt;/strong&gt;&lt;code&gt;Path&lt;/code&gt; argument.</source>
          <target state="translated">드라이버에는 다른 &lt;code&gt;DriverOptionList&lt;/code&gt; 또는 다른 &lt;strong&gt;리터럴 &lt;/strong&gt; &lt;code&gt;Path&lt;/code&gt; 인수 가 이미로드되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="123d2435bbdf7446863fb98cf76173c154e93eaf" translate="yes" xml:space="preserve">
          <source>The driver is loaded by other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; when option &lt;code&gt;{reload, pending_driver}&lt;/code&gt; was specified.</source>
          <target state="translated">옵션 &lt;code&gt;{reload, pending_driver}&lt;/code&gt; 가 지정 되면 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 드라이버를로드 합니다.</target>
        </trans-unit>
        <trans-unit id="de8f98e94d0922e6ef27e0959b36602f7f443810" translate="yes" xml:space="preserve">
          <source>The driver is loaded with &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt;. If this is successful, or if it is already loaded, it is opened. This will call the &lt;code&gt;start&lt;/code&gt; function in the driver.</source>
          <target state="translated">드라이버는 &lt;code&gt;erl_ddll:load_driver/2&lt;/code&gt; 로 로드됩니다 . 이것이 성공하거나 이미로드 된 경우 열립니다. 드라이버에서 &lt;code&gt;start&lt;/code&gt; 기능을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f2356f498f6f6669e3b679a9b55e2c73ebdf7ef2" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt; erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="translated">드라이버는 &lt;code&gt; erl_ddll:unload_driver/1&lt;/code&gt; 을 호출 한 결과 또는 에뮬레이터가 중지 된 경우 에만 언로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ebdfd6fd6dc142da610d573bd0e04e4e99b405d" translate="yes" xml:space="preserve">
          <source>The driver is only unloaded as a result of calling &lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt;, or when the emulator halts.</source>
          <target state="translated">&lt;code&gt;erl_ddll:unload_driver/1&lt;/code&gt; 을 호출 한 결과 또는 에뮬레이터가 중지 된 경우 에만 드라이버가 언로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa4be31a9519f969227f921236d7d6aa51f75a8a" translate="yes" xml:space="preserve">
          <source>The driver is synchronous, it uses the synchronous calls of the client library. This is only for simplicity, but not good, as it halts the emulator while waiting for the database. This is improved below with an asynchronous sample driver.</source>
          <target state="translated">드라이버는 동기식이며 클라이언트 라이브러리의 동기식 호출을 사용합니다. 이것은 데이터베이스를 기다리는 동안 에뮬레이터를 정지시키기 때문에 단순성을 위해서만 좋지는 않습니다. 이것은 비동기 샘플 드라이버로 아래에서 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2846f7d13f5d6eeed6af66056f38ff13c49aabc" translate="yes" xml:space="preserve">
          <source>The driver is to be compiled and linked to a shared library (DLL on Windows). With gcc, this is done with link flags &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fpic&lt;/code&gt;. As we use the &lt;code&gt;ei&lt;/code&gt; library, we should include it too. There are several versions of &lt;code&gt;ei&lt;/code&gt;, compiled for debug or non-debug and multi-threaded or single-threaded. In the makefile for the samples, the &lt;code&gt;obj&lt;/code&gt; directory is used for the &lt;code&gt;ei&lt;/code&gt; library, meaning that we use the non-debug, single-threaded version.</source>
          <target state="translated">드라이버는 컴파일되어 공유 라이브러리 (Windows의 DLL)에 연결됩니다. gcc를 사용하면 링크 플래그 &lt;code&gt;-shared&lt;/code&gt; 및 &lt;code&gt;-fpic&lt;/code&gt; 로 수행 됩니다. 우리는 &lt;code&gt;ei&lt;/code&gt; 라이브러리를 사용할 때 그것을 포함시켜야합니다. &lt;code&gt;ei&lt;/code&gt; 의 여러 버전이 있으며 디버그 또는 비디 버그 용으로 컴파일되고 멀티 스레드 또는 단일 스레드입니다. 샘플의 makefile에서 &lt;code&gt;obj&lt;/code&gt; 디렉토리는 &lt;code&gt;ei&lt;/code&gt; 라이브러리에 사용됩니다 . 즉, 디버그가 아닌 단일 스레드 버전을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8352df0d68d66243c84331cdb4bc76e073f0f8fd" translate="yes" xml:space="preserve">
          <source>The driver is to be provided as a dynamically linked library in an object code format specific for the platform in use, that is, &lt;code&gt;.so&lt;/code&gt; files on most Unix systems and &lt;code&gt;.ddl&lt;/code&gt; files on Windows. An Erlang linked-in driver must provide specific interfaces to the emulator, so this module is not designed for loading arbitrary dynamic libraries. For more information about Erlang drivers, see &lt;code&gt;erts:erl_driver&lt;/code&gt; .</source>
          <target state="translated">드라이버는 사용중인 플랫폼에 맞는 객체 코드 형식, 즉 대부분의 Unix 시스템의 &lt;code&gt;.so&lt;/code&gt; 파일과 Windows의 &lt;code&gt;.ddl&lt;/code&gt; 파일 로 동적으로 링크 된 라이브러리로 제공됩니다 . Erlang 링크드 드라이버는 에뮬레이터에 특정 인터페이스를 제공해야하므로이 모듈은 임의의 동적 라이브러리를로드하도록 설계되지 않았습니다. Erlang 드라이버에 대한 자세한 정보는 &lt;code&gt;erts:erl_driver&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f7d0670a21cf6663ffe1e7be79926c35deca09" translate="yes" xml:space="preserve">
          <source>The driver is to fail only when in severe error situations, when the driver cannot possibly keep open, for example, buffer allocation gets out of memory. For normal errors it is more appropriate to send error codes with &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">드라이버는 심각한 오류 상황에서 드라이버를 계속 열어 둘 수없는 경우에만 실패해야합니다 (예 : 버퍼 할당이 메모리 부족). 일반적인 오류의 경우 &lt;code&gt;&lt;a href=&quot;#driver_output&quot;&gt;driver_output&lt;/a&gt;&lt;/code&gt; 과 함께 오류 코드를 보내는 것이 더 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="12952854b617484d4a3a18ae5571038f275167c0" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="translated">드라이버 이름입니다. &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 에서 사용되는 atom 및 드라이버 라이브러리 파일의 이름 (확장자 없음)과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc198aad17d226134b089c46b5d58abebda6515e" translate="yes" xml:space="preserve">
          <source>The driver name. It must correspond to the atom used in &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;, and the name of the driver library file (without the extension).</source>
          <target state="translated">드라이버 이름 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 에 사용 된 아톰 및 드라이버 라이브러리 파일 이름 (확장자 제외)에 해당해야합니다.</target>
        </trans-unit>
        <trans-unit id="c745a240a8b09464690a74b0ded828b443277620" translate="yes" xml:space="preserve">
          <source>The driver names are returned as a list of strings rather than a list of atoms for historical reasons.</source>
          <target state="translated">드라이버 이름은 역사적 이유로 원자 목록이 아닌 문자열 목록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8c90e4dc558838312154093ae7e4d33a042314e8" translate="yes" xml:space="preserve">
          <source>The driver options for a specified driver name need always to be consistent, &lt;strong&gt;even when the driver is reloaded&lt;/strong&gt;, meaning that they are as much a part of the driver as the name.</source>
          <target state="translated">&lt;strong&gt;드라이버를 다시로드 할 때에도&lt;/strong&gt; 지정된 드라이버 이름에 대한 드라이버 옵션은 항상 일관성이 있어야합니다. 즉, 드라이버 이름 &lt;strong&gt;이 드라이버&lt;/strong&gt; 의 일부인 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec7187710cb97de822c20a1794719f5b691ec563" translate="yes" xml:space="preserve">
          <source>The driver queue is available to queue output from the emulator to the driver (data from the driver to the emulator is queued by the emulator in normal Erlang message queues). This can be useful if the driver must wait for slow devices, and so on, and wants to yield back to the emulator. The driver queue is implemented as an &lt;code&gt;ErlIOVec&lt;/code&gt;.</source>
          <target state="translated">드라이버 큐는 에뮬레이터에서 드라이버로 출력을 큐에 넣을 수 있습니다 (드라이버에서 에뮬레이터로의 데이터는 일반 Erlang 메시지 큐에서 에뮬레이터에 의해 큐에 대기됩니다). 드라이버가 느린 장치 등을 기다려야하고 에뮬레이터로 되돌려 보내려는 경우에 유용 할 수 있습니다. 드라이버 큐는 &lt;code&gt;ErlIOVec&lt;/code&gt; 으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="267e1ade55aca0a7989f62dc5c3745421b17592a" translate="yes" xml:space="preserve">
          <source>The driver structure contains the driver name and some 15 function pointers, which are called at different times by the emulator.</source>
          <target state="translated">드라이버 구조에는 드라이버 이름과 약 15 개의 함수 포인터가 포함되어 있으며 에뮬레이터에서 다른 시간에 호출합니다.</target>
        </trans-unit>
        <trans-unit id="777fa5f89808e7871ea95ba4af70a119a6124215" translate="yes" xml:space="preserve">
          <source>The driver structure is filled with the driver name and function pointers. It is returned from the special entry point, declared with the macro &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">드라이버 구조는 드라이버 이름과 함수 포인터로 채워져 있습니다. 매크로 &lt;code&gt;DRIVER_INIT(&amp;lt;driver_name&amp;gt;)&lt;/code&gt; 선언 된 특수 진입 점에서 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca38a39e87b4ab492f8fbeb01d018493a1577466" translate="yes" xml:space="preserve">
          <source>The driver structure is similar for statically linked-in drivers and dynamically loaded. However, some of the fields are to be left empty (that is, initialized to NULL) in the different types of drivers. The first field (the &lt;code&gt;init&lt;/code&gt; function pointer) is always left blank in a dynamically loaded driver, see line 26. &lt;code&gt;NULL&lt;/code&gt; on line 37 is always to be there, the field is no longer used and is retained for backward compatibility. No timers are used in this driver, why no callback for timers is needed. The &lt;code&gt;outputv&lt;/code&gt; field (line 40) can be used to implement an interface similar to Unix &lt;code&gt;writev&lt;/code&gt; for output. The Erlang runtime system could previously not use &lt;code&gt;outputv&lt;/code&gt; for the distribution, but it can as from ERTS 5.7.2. As this driver was written before ERTS 5.7.2 it does not use the &lt;code&gt;outputv&lt;/code&gt; callback. Using the &lt;code&gt;outputv&lt;/code&gt; callback is preferred, as it reduces copying of data. (We will however use scatter/gather I/O internally in the driver.)</source>
          <target state="translated">드라이버 구조는 정적으로 링크 된 드라이버와 유사하며 동적으로로드됩니다. 그러나 일부 필드는 다른 유형의 드라이버에서 비워 두어야합니다 (즉, NULL로 초기화 됨). 첫 번째 필드 ( &lt;code&gt;init&lt;/code&gt; 함수 포인터)는 동적으로로드 된 드라이버에서 항상 비워 둡니다 . 26 행을 참조하십시오. 37 행의 &lt;code&gt;NULL&lt;/code&gt; 은 항상 존재하며 필드는 더 이상 사용되지 않으며 이전 버전과의 호환성을 위해 유지됩니다. 이 드라이버에는 타이머가 사용되지 않으므로 타이머에 대한 콜백이 필요하지 않은 이유는 무엇입니까? &lt;code&gt;outputv&lt;/code&gt; 의 필드 (라인 40)은 유닉스와 유사한 인터페이스를 구현하는데 사용될 수 &lt;code&gt;writev&lt;/code&gt; 는 출력한다. Erlang 런타임 시스템은 이전에 &lt;code&gt;outputv&lt;/code&gt; 를 사용할 수 없었습니다.배포에 대해서는 ERTS 5.7.2에서와 같이 가능합니다. 이 드라이버는 ERTS 5.7.2 이전에 작성 &lt;code&gt;outputv&lt;/code&gt; 콜백을 사용하지 않습니다 . &lt;code&gt;outputv&lt;/code&gt; 콜백을 사용하는 것이 좋습니다. 데이터 복사가 줄어 듭니다. (하지만 내부적으로 분산 / 수집 I / O를 드라이버에서 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="13e83e61fa641454caf4f4f17446cac682b522d1" translate="yes" xml:space="preserve">
          <source>The driver used for Erlang distribution is to implement a reliable, order maintaining, variable length packet-oriented protocol. All error correction, resending and such need to be implemented in the driver or by the underlying communications protocol. If the protocol is stream-oriented (as is the case with both TCP/IP and our streamed Unix domain sockets), some mechanism for packaging is needed. We will use the simple method of having a header of four bytes containing the length of the package in a big-endian 32-bit integer. As Unix domain sockets only can be used between processes on the same machine, we do not need to code the integer in some special endianess, but we will do it anyway because in most situation you need to do it. Unix domain sockets are reliable and order maintaining, so we do not need to implement resends and such in the driver.</source>
          <target state="translated">Erlang 배포에 사용되는 드라이버는 안정적인 순서 유지 가변 길이 패킷 지향 프로토콜을 구현하는 것입니다. 모든 오류 수정, 재전송 등은 드라이버 또는 기본 통신 프로토콜로 구현해야합니다. 프로토콜이 스트림 지향 인 경우 (TCP / IP 및 스트리밍 된 Unix 도메인 소켓의 경우와 같이) 패키징을위한 일부 메커니즘이 필요합니다. 우리는 빅 엔디안 32 비트 정수로 패키지의 길이를 포함하는 4 바이트의 헤더를 갖는 간단한 방법을 사용할 것입니다. 유닉스 도메인 소켓은 동일한 머신의 프로세스간에 만 사용할 수 있기 때문에 특별한 엔디안으로 정수를 코딩 할 필요는 없지만 대부분의 상황에서 수행해야하기 때문에 어쨌든 수행합니다. 유닉스 도메인 소켓은 신뢰할 수 있고 순서를 유지하며따라서 드라이버에서 재전송 등을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="885a9c9f85b39e7698683efce0ff5bba88451a67" translate="yes" xml:space="preserve">
          <source>The driver was already loaded by another process or is in use by a living port, or both. The load by you is registered and a corresponding &lt;code&gt;try_unload&lt;/code&gt; is expected sometime in the future.</source>
          <target state="translated">드라이버가 다른 프로세스에 의해 이미로드되었거나 리빙 포트 또는 둘 다에서 사용 중입니다. 귀하의로드가 등록되었으며 나중에 해당 &lt;code&gt;try_unload&lt;/code&gt; 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="380ea6d015cef2cddc2581f363be87321f771e9f" translate="yes" xml:space="preserve">
          <source>The driver was immediately unloaded, meaning that the driver name is now free to use by other drivers and, if the underlying OS permits it, the memory occupied by the driver object code is now reclaimed.</source>
          <target state="translated">드라이버가 즉시 언로드되었습니다. 즉, 다른 드라이버가 드라이버 이름을 자유롭게 사용할 수 있으며 기본 OS에서 허용하는 경우 드라이버 개체 코드가 차지하는 메모리가 다시 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3da2e19322e3c6628d119e07b3e56934634eac8" translate="yes" xml:space="preserve">
          <source>The driver was loaded and is immediately usable.</source>
          <target state="translated">드라이버가로드되어 즉시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d864f9d9077463dec755426c28ec5da6f217e91e" translate="yes" xml:space="preserve">
          <source>The driver with the specified name is an Erlang statically linked-in driver, which cannot be manipulated with this API.</source>
          <target state="translated">지정된 이름을 가진 드라이버는 Erlang 정적으로 링크 된 드라이버이며이 API로 조작 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="75b79644c08326087c431ff0fd0e1f208afbe371" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt; driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">드라이버 작성자는 &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt; driver_monitor_process&lt;/a&gt;&lt;/code&gt; 호출시 모니터 저장을위한 메모리를 제공합니다 . 데이터의 주소는 드라이버 외부에 저장되지 않으므로 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 를 다른 데이터로 사용할 수 있으며 복사, 메모리에서 이동, 잊음 등이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f1eb9606d6f4220a244d8c3b7748d550c419a79a" translate="yes" xml:space="preserve">
          <source>The driver writer is to provide the memory for storing the monitor when calling &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt;. The address of the data is not stored outside of the driver, so &lt;code&gt;ErlDrvMonitor&lt;/code&gt; can be used as any other data, it can be copied, moved in memory, forgotten, and so on.</source>
          <target state="translated">드라이버 라이터는 &lt;code&gt;&lt;a href=&quot;#driver_monitor_process&quot;&gt;driver_monitor_process&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 모니터를 저장하기위한 메모리를 제공해야합니다 . 데이터 주소는 드라이버 외부에 저장되지 않으므로 &lt;code&gt;ErlDrvMonitor&lt;/code&gt; 를 다른 데이터로 사용할 수 있으며 복사, 메모리 이동, 잊어 버림 등을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4c87103ae153cd308d8f26cfae1b35225c5ea0c" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">나중에 드라이버 콜백 호출에서 전달되는 드라이버 정의 핸들입니다. 것을 알 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 이 새 드라이버 인스턴스에 대한 호출되지 않습니다. 드라이버 정의 핸들은 일반적으로 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt; erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 를 통해 포트가 생성 될 때 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4025b3383bc4889c1c9cd923cfef69764fc7fb73" translate="yes" xml:space="preserve">
          <source>The driver-defined handle that is passed in later calls to driver callbacks. Notice that the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; is not called for this new driver instance. The driver-defined handle is normally created in the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; when a port is created through &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">나중에 드라이버 콜백에 대한 호출에서 전달되는 드라이버 정의 핸들입니다. 것을 알 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 이 새 드라이버 인스턴스에 대한 호출되지 않습니다. 드라이버 정의 핸들은 일반적으로 &lt;code&gt;&lt;a href=&quot;erlang#open_port-2&quot;&gt;erlang:open_port/2&lt;/a&gt;&lt;/code&gt; 를 통해 포트가 작성 될 때 &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;driver start callback&lt;/a&gt;&lt;/code&gt; 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="394034fd0da749c1d06ef57ce69c6215ae425eb2" translate="yes" xml:space="preserve">
          <source>The driver-entry structure used by Erlang drivers.</source>
          <target state="translated">Erlang 드라이버가 사용하는 드라이버 입력 구조.</target>
        </trans-unit>
        <trans-unit id="e67bdfbeb3c1793f1075c60e9dfc86106434ef3f" translate="yes" xml:space="preserve">
          <source>The dump is truncated.</source>
          <target state="translated">덤프가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="58fd56942c22b98ca6dfc0e41f2fc24c62b5de4a" translate="yes" xml:space="preserve">
          <source>The dump is truncated. In this case, a warning is displayed in the status bar of the main window.</source>
          <target state="translated">덤프가 잘립니다. 이 경우 주 창의 상태 표시 줄에 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="26da6cb9d5e2b4d506bf3083a6055833ae7a4362" translate="yes" xml:space="preserve">
          <source>The durability property ensures that changes made to the DBMS by a transaction are permanent. Once a transaction is committed, all changes made to the database are durable, that is, they are written safely to disc and do not become corrupted and do not disappear.</source>
          <target state="translated">내구성 특성은 트랜잭션에 의해 DBMS에 대한 변경 사항이 영구적임을 보장합니다. 트랜잭션이 커밋되면 데이터베이스에 대한 모든 변경 사항이 지속됩니다. 즉, 디스크에 안전하게 기록되고 손상되지 않으며 사라지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7aa3c54478ccaa5bbddda8a5fe6086c5ab90507" translate="yes" xml:space="preserve">
          <source>The duration time is specified as &lt;code&gt;HHMMSS&lt;/code&gt;, for example, &lt;code&gt;-duration 012030&lt;/code&gt; or &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt;</source>
          <target state="translated">지속 시간은 &lt;code&gt;HHMMSS&lt;/code&gt; 로 지정됩니다 ( 예 : &lt;code&gt;-duration 012030&lt;/code&gt; 또는 &lt;code&gt;{duration,&quot;012030&quot;}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b34138fd668a3a91f262b3c8cc94e10c40614310" translate="yes" xml:space="preserve">
          <source>The dynamic engine is not supported in LibreSSL from version 2.2.1</source>
          <target state="translated">버전 2.2.1의 LibreSSL에서 동적 엔진이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46cf93457fc198c7fc4b11e05da4141275628e59" translate="yes" xml:space="preserve">
          <source>The earlier factorial example can act as a counter-example. It is not tail-recursive, since a multiplication is done on the result of the recursive call to &lt;code&gt;fact(N-1)&lt;/code&gt;.</source>
          <target state="translated">이전의 계승 예제는 반례로 작용할 수 있습니다. &lt;code&gt;fact(N-1)&lt;/code&gt; 에 대한 재귀 호출의 결과에 곱셈이 수행되므로 꼬리 재귀가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="7471d512bedffa6e5e516b4425ff9cbeaebad94b" translate="yes" xml:space="preserve">
          <source>The easiest path is to mimic the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet_tcp&lt;/code&gt; interfaces, but not much functionality in those modules needs to be implemented. In the example application, only a few of the usual interfaces are implemented, and they are much simplified.</source>
          <target state="translated">가장 쉬운 방법은 &lt;code&gt;inet&lt;/code&gt; 및 &lt;code&gt;inet_tcp&lt;/code&gt; 인터페이스 를 모방하는 것이지만 해당 모듈의 기능을 많이 구현할 필요는 없습니다. 예제 응용 프로그램에서는 일반적인 인터페이스 중 일부만 구현되며 훨씬 단순화되었습니다.</target>
        </trans-unit>
        <trans-unit id="5a4e2857f3f8ff97859f4357e2a194c2963da6e0" translate="yes" xml:space="preserve">
          <source>The easiest way of using &lt;code&gt;ET&lt;/code&gt;, is to just use it as a graphical tool for displaying message sequence charts. In order to do that you need to first start a &lt;code&gt;Viewer&lt;/code&gt; (which by default starts a &lt;code&gt;Collector&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;ET&lt;/code&gt; 를 사용하는 가장 쉬운 방법은 메시지 시퀀스 차트를 표시하기위한 그래픽 도구로 사용하는 것입니다. 그러기 위해서는 먼저 &lt;code&gt;Viewer&lt;/code&gt; 를 시작해야합니다 (기본적으로 &lt;code&gt;Collector&lt;/code&gt; 시작 ).</target>
        </trans-unit>
        <trans-unit id="3e2ec62c427c4d0d3ce97e74cc8645fe104a328c" translate="yes" xml:space="preserve">
          <source>The easiest way to start Crashdump Viewer is to use shell script &lt;code&gt;cdv&lt;/code&gt; with the full path to the Erlang crashdump as argument. The script is located in directory &lt;code&gt;priv&lt;/code&gt; of the Observer application. This starts the Crashdump Viewer GUI and loads the specified file. If no filename is specified, a file dialog is opened where the file can be selected.</source>
          <target state="translated">&lt;code&gt;cdv&lt;/code&gt; Viewer를 시작하는 가장 쉬운 방법은 쉘 스크립트 cdv 를 Erlang crashdump의 전체 경로와 함께 인수로 사용하는 것입니다. 스크립트는 Observer 응용 프로그램의 &lt;code&gt;priv&lt;/code&gt; 디렉토리에 있습니다 . Crashdump Viewer GUI가 시작되고 지정된 파일이로드됩니다. 파일 이름을 지정하지 않으면 파일을 선택할 수있는 파일 대화 상자가 열립니다.</target>
        </trans-unit>
        <trans-unit id="55d0d417d785ac1626163667303a6253a1c8a917" translate="yes" xml:space="preserve">
          <source>The effect of (*THEN) is now confined to the inner subpattern. After a failure in C, matching moves to (*FAIL), which causes the whole subpattern to fail, as there are no more alternatives to try. In this case, matching does now backtrack into A.</source>
          <target state="translated">(* THEN)의 효과는 이제 내부 서브 패턴으로 제한됩니다. C에서 실패한 후에는 일치하는 (* FAIL)로 이동하여 더 이상 시도 할 대안이 없으므로 전체 서브 패턴이 실패합니다. 이 경우 일치는 이제 A로 역 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="f16407eee4518305b005b9dbecb5884bd7cbf3bc" translate="yes" xml:space="preserve">
          <source>The effect of combining &lt;code&gt;set_on_first_link&lt;/code&gt; with &lt;code&gt;set_on_link&lt;/code&gt; is the same as &lt;code&gt;set_on_first_link&lt;/code&gt; alone. Likewise for &lt;code&gt;set_on_spawn&lt;/code&gt; and &lt;code&gt;set_on_first_spawn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_on_first_link&lt;/code&gt; 와 &lt;code&gt;set_on_link&lt;/code&gt; 를 결합한 효과는 &lt;code&gt;set_on_first_link&lt;/code&gt; 단독 과 동일 합니다. 마찬가지로에 대한 &lt;code&gt;set_on_spawn&lt;/code&gt; 및 &lt;code&gt;set_on_first_spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb46e1d7474732484a66c32367c6751904b1bed" translate="yes" xml:space="preserve">
          <source>The effect of option &lt;code&gt;cache&lt;/code&gt; is that when generator &lt;code&gt;QH2'&lt;/code&gt; is run the first time, every answer is stored in an ETS table. When the next answer of &lt;code&gt;QH1&lt;/code&gt; is tried, answers to &lt;code&gt;QH2'&lt;/code&gt; are copied from the ETS table, which is very fast. As for option &lt;code&gt;unique&lt;/code&gt; the cost is a possibly substantial amount of RAM memory.</source>
          <target state="translated">옵션 &lt;code&gt;cache&lt;/code&gt; 의 효과는 생성기 &lt;code&gt;QH2'&lt;/code&gt; 가 처음 실행될 때 모든 응답이 ETS 테이블에 저장 된다는 것입니다. &lt;code&gt;QH1&lt;/code&gt; 의 다음 답변 이 시도 될 때, &lt;code&gt;QH2'&lt;/code&gt; 대한 답변 이 ETS 테이블에서 복사되는데, 이는 매우 빠릅니다. 옵션 &lt;code&gt;unique&lt;/code&gt; 경우 비용은 상당한 양의 RAM 메모리입니다.</target>
        </trans-unit>
        <trans-unit id="46af5dbb6ad32f950d071087d55fd5eedd3a2dcc" translate="yes" xml:space="preserve">
          <source>The election process is modified as described in 5.6.4.</source>
          <target state="translated">선거 절차는 5.6.4에 설명 된대로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="cdd607a9ef230a55bb6d74140b011672a2b70ef4" translate="yes" xml:space="preserve">
          <source>The element in position &lt;code&gt;Pos&lt;/code&gt; in &lt;code&gt;Pattern&lt;/code&gt; must be bound. &lt;code&gt;Pos&lt;/code&gt; is an integer (&lt;code&gt;#record.Field&lt;/code&gt;) or an attribute name.</source>
          <target state="translated">위치에있는 요소 &lt;code&gt;Pos&lt;/code&gt; 의 &lt;code&gt;Pattern&lt;/code&gt; 결합해야합니다. &lt;code&gt;Pos&lt;/code&gt; 는 정수 ( &lt;code&gt;#record.Field&lt;/code&gt; ) 또는 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c52c7c2c532d8015d87a1ff9dad023e4fb851308" translate="yes" xml:space="preserve">
          <source>The element to update is also the key.</source>
          <target state="translated">업데이트 할 요소도 핵심 요소입니다.</target>
        </trans-unit>
        <trans-unit id="133139824edb56fee5c9537204f00d5c8e6d31f2" translate="yes" xml:space="preserve">
          <source>The element to update is not an integer.</source>
          <target state="translated">업데이트 할 요소가 정수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e2b6d90876d98adc6125d07f13d8d523ed72322" translate="yes" xml:space="preserve">
          <source>The embedded system and all the applications start automatically if the script file shown below is added to directory &lt;code&gt;/etc/rc3.d&lt;/code&gt;. The file must be owned and readable by &lt;code&gt;root&lt;/code&gt;. Its name cannot be arbitrarily assigned; the following name is recommended:</source>
          <target state="translated">아래에 표시된 스크립트 파일이 &lt;code&gt;/etc/rc3.d&lt;/code&gt; 디렉토리에 추가되면 내장 시스템 및 모든 응용 프로그램이 자동으로 시작됩니다 . 파일은 &lt;code&gt;root&lt;/code&gt; 가 소유하고 읽을 수 있어야합니다 . 이름은 임의로 지정할 수 없습니다. 다음 이름이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="bad88f7a085d192e2f6cec49768a38f2903f8ae0" translate="yes" xml:space="preserve">
          <source>The emulator calls the driver in the following situations:</source>
          <target state="translated">에뮬레이터는 다음 상황에서 드라이버를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="218b5d9983c658a4cef0aef4b47157f1b19f1a20" translate="yes" xml:space="preserve">
          <source>The emulator has been started with only one scheduler thread.</source>
          <target state="translated">에뮬레이터는 하나의 스케줄러 스레드로 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="00ecfc5e261b4531e61f24b2c4f3b8605c732361" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, and no scheduler threads are blocked. That is, all available scheduler threads schedule Erlang processes and execute Erlang code.</source>
          <target state="translated">에뮬레이터에 둘 이상의 스케줄러 스레드가 있으며 스케줄러 스레드가 차단되지 않았습니다. 즉, 사용 가능한 모든 스케줄러 스레드가 Erlang 프로세스를 예약하고 Erlang 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d1335d1e55e250963f0d3ef76a97d106ea1aeeed" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all normal scheduler threads except one are blocked. Notice that dirty schedulers are not blocked, and can schedule Erlang processes and execute native code.</source>
          <target state="translated">에뮬레이터에 둘 이상의 스케줄러 스레드가 있지만 하나를 제외한 모든 일반 스케줄러 스레드가 차단됩니다. 더티 스케줄러는 차단되지 않으며 Erlang 프로세스를 예약하고 기본 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e09f5c935221131fa5aa069cd7be0f9d773e6f4" translate="yes" xml:space="preserve">
          <source>The emulator has more than one scheduler thread, but all scheduler threads except one are blocked. That is, only one scheduler thread schedules Erlang processes and executes Erlang code.</source>
          <target state="translated">에뮬레이터에 둘 이상의 스케줄러 스레드가 있지만 하나를 제외한 모든 스케줄러 스레드가 차단됩니다. 즉, 하나의 스케줄러 스레드 만 Erlang 프로세스를 예약하고 Erlang 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9414404aaefeb3f5826ea98674c66ad27f121727" translate="yes" xml:space="preserve">
          <source>The emulator probably uses more memory, and because garbage collections occur less frequently, huge binaries can be kept much longer.</source>
          <target state="translated">에뮬레이터는 더 많은 메모리를 사용하고 가비지 수집이 덜 자주 발생하므로 큰 이진 파일을 훨씬 더 오래 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c90a0c569f6e401278d0c92d5efb3209b403c33" translate="yes" xml:space="preserve">
          <source>The emulator refuses to load a driver that does not use the extended driver interface, to allow for 64-bit capable drivers, as incompatible type changes for the callbacks &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; were introduced in Erlang/OTP R15B. A driver written with the old types would compile with warnings and when called return garbage sizes to the emulator, causing it to read random memory and create huge incorrect result blobs.</source>
          <target state="translated">콜백 &lt;code&gt;&lt;a href=&quot;driver_entry#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;driver_entry#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;driver_entry#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 에 대한 호환되지 않는 유형 변경 이 Erlang / OTP R15B에 도입되었으므로 64 비트 지원 드라이버를 허용하기 위해 확장 드라이버 인터페이스를 사용하지 않는 드라이버로드를 거부합니다 . 이전 유형으로 작성된 드라이버는 경고와 함께 컴파일되어 호출 가비지 크기를 에뮬레이터에 반환하면 임의의 메모리를 읽고 잘못된 잘못된 결과 Blob을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7a03fbfd7f6822486dc5e29a1dba526a017e4427" translate="yes" xml:space="preserve">
          <source>The emulator restart on Windows NT expects that the system is started using the &lt;code&gt;erlsrv&lt;/code&gt; program (as a service). Furthermore, the release handler expects that the service is named &lt;code&gt;NodeName&lt;/code&gt;_&lt;code&gt;Release&lt;/code&gt;, where &lt;code&gt;NodeName&lt;/code&gt; is the first part of the Erlang node name (up to, but not including the &quot;@&quot;) and &lt;code&gt;Release&lt;/code&gt; is the current release version. The release handler furthermore expects that a program like &lt;code&gt;start_erl.exe&lt;/code&gt; is specified as &quot;machine&quot; to &lt;code&gt;erlsrv&lt;/code&gt;. During upgrading with restart, a new service is registered and started. The new service is set to automatic and the old service is removed when the new release is made permanent.</source>
          <target state="translated">Windows NT에서 에뮬레이터를 다시 시작하면 &lt;code&gt;erlsrv&lt;/code&gt; 프로그램을 서비스로 사용하여 시스템이 시작될 것으로 예상 됩니다. 또한 릴리스 핸들러는 서비스 이름이 &lt;code&gt;NodeName&lt;/code&gt; _ &lt;code&gt;Release&lt;/code&gt; 인 것으로 예상합니다. 여기서 &lt;code&gt;NodeName&lt;/code&gt; 은 Erlang 노드 이름의 첫 부분 ( &quot;@&quot;까지 포함)이고 &lt;code&gt;Release&lt;/code&gt; 는 현재 릴리스 버전입니다. 릴리스 핸들러는 또한 같은 프로그램을 것으로 예상 &lt;code&gt;start_erl.exe&lt;/code&gt; 이 가 &quot;기계&quot;로 지정됩니다 &lt;code&gt;erlsrv&lt;/code&gt; . 다시 시작하여 업그레이드하는 동안 새 서비스가 등록되고 시작됩니다. 새 서비스가 자동으로 설정되고 새 서비스가 영구적으로 만들어지면 이전 서비스가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e59343153e5b1fe6b3e23daad5cd40c9373e3696" translate="yes" xml:space="preserve">
          <source>The encoder and decoder can also be run from the shell:</source>
          <target state="translated">셸에서 인코더와 디코더를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5524aa1d01a0ef49a1ac5386a1c63b808ac68425" translate="yes" xml:space="preserve">
          <source>The encoder callback interface is defined by the &lt;code&gt;megaco_encoder&lt;/code&gt; behaviour, see &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코더 콜백 인터페이스에 의해 정의된다 &lt;code&gt;megaco_encoder&lt;/code&gt; 의 행동을 참조 &lt;code&gt;&lt;a href=&quot;megaco_encoder&quot;&gt;megaco_encoder&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e115c3caf0848d64461367ca5e16e6bd2197d5d0" translate="yes" xml:space="preserve">
          <source>The encoding fails if &lt;code&gt;p&lt;/code&gt; is not a valid string in encoding &lt;code&gt;from_enc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;from_enc&lt;/code&gt; 인코딩에서 유효한 문자열이 아닌 경우 인코딩이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="09633aa618d0dc8af3be96ad739582e309ef108d" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 의 인코딩은 &lt;code&gt;epp(3)&lt;/code&gt; 설명 된 주석으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ac74f2d9e4b6b15103658ee4d9051874ee9e500" translate="yes" xml:space="preserve">
          <source>The encoding of &lt;code&gt;Filename&lt;/code&gt; can be set by a comment, as described in &lt;code&gt;epp(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; 의 인코딩은 &lt;code&gt;epp(3)&lt;/code&gt; 설명 된대로 주석으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d77e867cd506d61a5b722d136e431c9f033298c" translate="yes" xml:space="preserve">
          <source>The encoding of each file can be specified using comments as described in the &lt;code&gt;epp(3)&lt;/code&gt; module.</source>
          <target state="translated">각 파일의 인코딩은 &lt;code&gt;epp(3)&lt;/code&gt; 모듈에 설명 된대로 주석을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04f41a4c6fb716f1b91e8ba50a1b730e2b5f3a4d" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (&lt;code&gt;ber&lt;/code&gt;), Packed Encoding Rules (&lt;code&gt;per&lt;/code&gt;) aligned, PER unaligned (&lt;code&gt;uper&lt;/code&gt;) and JSON Encoding Rules (&lt;code&gt;jer&lt;/code&gt;). The &lt;code&gt;jer&lt;/code&gt; option can be used by itself to generate a module that only supports encoding/decoding to JER or it can be used as a supplementary option to ber, per and uper. In the latter case a module with for both the main encoding rules and JER will be generated. The exported functions for JER will then be &lt;code&gt;jer_encode(Type, Value)&lt;/code&gt; and &lt;code&gt;jer_decode(Type, Bytes)&lt;/code&gt;.</source>
          <target state="translated">사용할 인코딩 규칙입니다. 지원되는 인코딩 규칙은 Basic Encoding Rules ( &lt;code&gt;ber&lt;/code&gt; ), Packed Encoding Rules ( &lt;code&gt;per&lt;/code&gt; ) 정렬, PER unaligned ( &lt;code&gt;uper&lt;/code&gt; ) 및 JSON 인코딩 규칙 ( &lt;code&gt;jer&lt;/code&gt; )입니다. &lt;code&gt;jer&lt;/code&gt; 옵션 JER 디코드 / 만 지원하는 인코딩하는 모듈을 생성하기 위해 단독으로 사용하거나 당 uper 또, BER에 추가 옵션으로서 사용될 수있다. 후자의 경우 기본 인코딩 규칙과 JER 모두에 대한 모듈이 생성됩니다. JER에 대해 내 보낸 함수는 &lt;code&gt;jer_encode(Type, Value)&lt;/code&gt; 및 &lt;code&gt;jer_decode(Type, Bytes)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9e2118a8dc4b068a3e8e22ff922dd1be302891f7" translate="yes" xml:space="preserve">
          <source>The encoding rule to be used. The supported encoding rules are Basic Encoding Rules (BER), Packed Encoding Rules (PER) aligned, and PER unaligned. If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">사용될 인코딩 규칙. 지원되는 인코딩 규칙은 BER (Basic Encoding Rules), PER (Packed Encoding Rules) 정렬 및 PER 정렬되지 않음입니다. 인코딩 규칙 옵션을 생략하면 &lt;code&gt;ber&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6f95e0e32837beadf0f93d78df4e27d5991fa179" translate="yes" xml:space="preserve">
          <source>The encoding specified by the above mentioned comment applies to the script itself. The encoding of the I/O-server, however, must be set explicitly as follows:</source>
          <target state="translated">위에서 언급 한 주석으로 지정된 인코딩은 스크립트 자체에 적용됩니다. 그러나 I / O 서버의 인코딩은 다음과 같이 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1c828e598776df003c2646b5bcedb28e057c204" translate="yes" xml:space="preserve">
          <source>The encoding_config of the megaco_erl_dist_encoder module may be one of these:</source>
          <target state="translated">megaco_erl_dist_encoder 모듈의 encoding_config는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97065c3a3729efa68679ce76351a30a9cd3dfa65" translate="yes" xml:space="preserve">
          <source>The encryption or decryption is applied to the generated stream of bytes prior to sending the resulting stream to the SFTP server.</source>
          <target state="translated">암호화 또는 복호화는 결과 스트림을 SFTP 서버로 보내기 전에 생성 된 바이트 스트림에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f48fa03ddf781f161c43a06b94c0c75681b96550" translate="yes" xml:space="preserve">
          <source>The endianness specification can be either &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, or &lt;code&gt;native&lt;/code&gt;. Native-endian means that the endian is resolved at load time, to be either big-endian or little-endian, depending on what is &quot;native&quot; for the CPU that the Erlang machine is run on.</source>
          <target state="translated">엔디안 사양이 될 수 있습니다 &lt;code&gt;big&lt;/code&gt; , &lt;code&gt;little&lt;/code&gt; , 또는 &lt;code&gt;native&lt;/code&gt; . Native-endian은 Erlang 시스템이 실행되는 CPU의 &quot;네이티브&quot;에 따라 엔디안이로드시 빅 엔디안 또는 리틀 엔디안으로 해석됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="60e0f49d56e51cf1a5d46c013c216c0ae5dc1eb9" translate="yes" xml:space="preserve">
          <source>The entire contents of the cache will be deleted.</source>
          <target state="translated">캐시의 전체 내용이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a01a496ea7149df2179e8879a105341306c0f911" translate="yes" xml:space="preserve">
          <source>The entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;, even when a list of objects is inserted.</source>
          <target state="translated">개체 목록이 삽입 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 경우에도 전체 작업이 원자 적이며 격리 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a75cc762ec33088a0ac070865ceb613941ab44" translate="yes" xml:space="preserve">
          <source>The entire program is motorcycles2html.erl:</source>
          <target state="translated">전체 프로그램은 motorcycles2html.erl입니다.</target>
        </trans-unit>
        <trans-unit id="0ea59e660bb8e967761f1c651703a92fd998d941" translate="yes" xml:space="preserve">
          <source>The entire super carrier implementation is kept in erl_mmap.c. The name suggest that it can be viewed as our own mmap implementation.</source>
          <target state="translated">전체 슈퍼 캐리어 구현은 erl_mmap.c에 보관됩니다. 이름은 우리 자신의 mmap 구현으로 볼 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ac7e661e53cfa83634f92105a4582a374de077bb" translate="yes" xml:space="preserve">
          <source>The entire tar file is compressed, as if it has been run through the &lt;code&gt;gzip&lt;/code&gt; program. To abide to the convention that a compressed tar file is to end in &quot;&lt;code&gt;.tar.gz&lt;/code&gt;&quot; or &quot;&lt;code&gt;.tgz&lt;/code&gt;&quot;, add the appropriate extension.</source>
          <target state="translated">전체 tar 파일은 마치 &lt;code&gt;gzip&lt;/code&gt; 프로그램을 통해 실행 된 것처럼 압축 됩니다. 압축 된 tar 파일이 &quot; &lt;code&gt;.tar.gz&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;.tgz&lt;/code&gt; &quot; 로 끝나는 규칙을 준수하려면 적절한 확장자를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e1f58ced4a1c7fafa8f4a838e0a3347b18963414" translate="yes" xml:space="preserve">
          <source>The entities involved in this model are the agent, which terminates the management protocol, and the resources, which is to be managed, that is, the actual application entities. The resources should in general have no knowledge of the management protocol used, and the agent should have no knowledge of the managed resources. This implies that a translation mechanism is needed, to translate the management operations to operations on the resources. This translation mechanism is usually called &lt;strong&gt;instrumentation&lt;/strong&gt; and the function that implements it is called &lt;strong&gt;instrumentation function&lt;/strong&gt;. The instrumentation functions are written for each combination of management protocol and resource to be managed. For example, if an application is to be managed by SNMP and HTTP, two sets of instrumentation functions are defined; one that maps SNMP requests to the resources, and one that, for example, generates an HTML page for some resources.</source>
          <target state="translated">이 모델에 포함 된 엔터티는 관리 프로토콜을 종료하는 에이전트와 관리 할 리소스, 즉 실제 응용 프로그램 엔터티입니다. 일반적으로 자원에는 사용 된 관리 프로토콜에 대한 지식이 없어야하며 에이전트는 관리 자원에 대한 지식이 없어야합니다. 이는 관리 작업을 리소스에 대한 작업으로 변환하기 위해 변환 메커니즘이 필요함을 의미합니다. 이 변환 메커니즘을 일반적으로 &lt;strong&gt;계측&lt;/strong&gt; 이라고하며이를 구현하는 기능을 &lt;strong&gt;계측 기능&lt;/strong&gt; 이라고 &lt;strong&gt;합니다.&lt;/strong&gt;. 인스 트루먼 테이션 기능은 관리 할 각 관리 프로토콜 및 자원 조합에 대해 작성됩니다. 예를 들어, 어플리케이션이 SNMP 및 HTTP로 관리되는 경우 두 가지 계측 기능 세트가 정의됩니다. 하나는 SNMP 요청을 리소스에 매핑하고 다른 하나는 일부 리소스에 대한 HTML 페이지를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc41ee140a0e19b3389932dacfd061ee5abd2931" translate="yes" xml:space="preserve">
          <source>The entry format in all files are Erlang terms, separated by a '&lt;strong&gt;.&lt;/strong&gt;' and a &lt;strong&gt;newline&lt;/strong&gt;. In the following sections, the formats of these terms are described. Comments may be specified as ordinary Erlang comments.</source>
          <target state="translated">모든 파일의 입력 형식은 Erlang 용어이며 '로 구분됩니다 &lt;strong&gt;. &lt;/strong&gt;'와 &lt;strong&gt;줄 바꿈&lt;/strong&gt; . 다음 섹션에서는 이러한 용어의 형식에 대해 설명합니다. 코멘트는 일반적인 Erlang 코멘트로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb54532373ef856c343b0b5dff86075c30ed3fbc" translate="yes" xml:space="preserve">
          <source>The entry point of the process, that is, what function was referenced in the &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;spawn_link&lt;/code&gt; call that started the process.</source>
          <target state="translated">인 프로세스의 진입 점은, 어떤 기능은에서 참조 된 &lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;spawn_link&lt;/code&gt; 과정을 시작 호출.</target>
        </trans-unit>
        <trans-unit id="7f963220ca94e530caaeba1df441378f7d481672" translate="yes" xml:space="preserve">
          <source>The enumerated type is similar to an integer type, when defined with a set of predefined values. The difference is that an enumerated type can only have specified values, whereas an integer can have any value.</source>
          <target state="translated">열거 된 유형은 사전 정의 된 값 세트로 정의 될 때 정수 유형과 유사합니다. 차이점은 열거 된 유형은 지정된 값만 가질 수있는 반면 정수는 모든 값을 가질 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3be6551e42e26d4ead34f786dcb51c0272efaf5" translate="yes" xml:space="preserve">
          <source>The environment can also affect filename interpretation, if Erlang is started with flag &lt;code&gt;+fna&lt;/code&gt; (which is default from Erlang/OTP 17.0).</source>
          <target state="translated">Erlang이 플래그 &lt;code&gt;+fna&lt;/code&gt; (Erlang / OTP 17.0의 기본값 )로 시작되면 환경은 파일 이름 해석에도 영향을 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="913d6ab5c0934539b281e92b0bf02bbbfef5d5f9" translate="yes" xml:space="preserve">
          <source>The environment of an Erlang machine started as a service contains two special variables:</source>
          <target state="translated">서비스로 시작된 Erlang 시스템의 환경에는 두 가지 특수 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="572b1efce0a6ff1c606a8d7cea991c683d1b2312" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must be &lt;code&gt;NULL&lt;/code&gt; only if calling from a created thread.</source>
          <target state="translated">호출 프로세스의 환경. 작성된 스레드에서 호출하는 경우에만 &lt;code&gt;NULL&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="08711127236c0db559a0b4dc910c12dabe3750d5" translate="yes" xml:space="preserve">
          <source>The environment of the calling process. Must not be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스의 환경. &lt;code&gt;NULL&lt;/code&gt; 이 아니 어야합니다 .</target>
        </trans-unit>
        <trans-unit id="933ad549b39351dffb7bbbba0584672a0a00358b" translate="yes" xml:space="preserve">
          <source>The environment of the calling thread (&lt;code&gt;&lt;a href=&quot;#proc_bound_env&quot;&gt;process bound&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#callback_env&quot;&gt;callback&lt;/a&gt;&lt;/code&gt; environment) or &lt;code&gt;NULL&lt;/code&gt; if calling from a custom thread not spawned by ERTS.</source>
          <target state="translated">호출 스레드의 환경 ( &lt;code&gt;&lt;a href=&quot;#proc_bound_env&quot;&gt;process bound&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#callback_env&quot;&gt;callback&lt;/a&gt;&lt;/code&gt; 환경) 또는 ERTS에 의해 생성되지 않은 사용자 지정 스레드에서 호출하는 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="679199f710a5ea0668dae02978ff4e536ea45dcb" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt; enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">메시지 용어의 환경. &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt; enif_alloc_env&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;NULL&lt;/code&gt; 로 할당 된 프로세스 독립 환경 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdd010a7cf9f07e2e5e5be6548225fb6c23b8fd6" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Can be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">메시지 용어의 환경. &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;NULL&lt;/code&gt; 로 할당 된 프로세스 독립적 환경 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b7b8c22351117abf032d5f79babc11a6b4db57f" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="translated">메시지 용어의 환경. &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 또는 NULL로 할당 된 프로세스 독립 환경이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="3da50f98e6b47c2b008dfdf790cd4b0c2b6bf64d" translate="yes" xml:space="preserve">
          <source>The environment of the message term. Must be a process-independent environment allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; or NULL.</source>
          <target state="translated">메시지 용어의 환경. &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt;enif_alloc_env&lt;/a&gt;&lt;/code&gt; 또는 NULL로 할당 된 프로세스 독립적 환경이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2fa8fc26b6ef033d7a364376d908df5f6b781167" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; can be used to indicate which logical cluster a C-node belongs to.</source>
          <target state="translated">환경 변수 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; 를 사용하여 C 노드가 속하는 논리 클러스터를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e087dc753b87601d38d03f83c1f1759586e203d5" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; can be used to configure the heart time-outs; it can be set in the operating system shell before Erlang is started or be specified at the command line:</source>
          <target state="translated">환경 변수 &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; 을 사용하여 하트 타임 아웃을 구성 할 수 있습니다. Erlang을 시작하기 전에 운영 체제 쉘에서 설정하거나 명령 행에서 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dd0dd179f2f7ae89d1e41f5898aa9a98a1d1adc" translate="yes" xml:space="preserve">
          <source>The environment variables can also be used to detect that we are running as a service and make port programs react correctly to the control events generated on logout (see the next section).</source>
          <target state="translated">또한 환경 변수를 사용하여 서비스로 실행 중임을 감지하고 포트 프로그램이 로그 아웃시 생성 된 제어 이벤트에 올바르게 반응하도록 할 수 있습니다 (다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="0155a47d2e3d28b9149121cf101f2c0d304723b6" translate="yes" xml:space="preserve">
          <source>The erl scheme is designed to mimic plain CGI, but without the extra overhead. An URL that calls an Erlang &lt;code&gt;erl&lt;/code&gt; function has the following syntax (regular expression):</source>
          <target state="translated">erl 체계는 일반 CGI를 모방하도록 설계되었지만 추가 오버 헤드는 없습니다. Erlang &lt;code&gt;erl&lt;/code&gt; 함수 를 호출하는 URL의 구문은 다음과 같습니다 (정규 표현식).</target>
        </trans-unit>
        <trans-unit id="9f146c11c8615922912cc793d4380f3827809366" translate="yes" xml:space="preserve">
          <source>The erlang connection process spawned by connect/2, will open a port to a c-process that handles the communication with the database through Microsoft's ODBC API. The erlang port will be kept open for exit signal propagation, if something goes wrong in the c-process and it exits we want know as mush as possible about the reason. The main communication with the c-process is done through sockets. The C-process consists of two threads, the supervisor thread and the database handler thread. The supervisor thread checks for shutdown messages on the supervisor socket and the database handler thread receives requests and sends answers on the database socket. If the database thread seems to hang on some database call, the erlang control process will send a shutdown message on the supervisor socket, in this case the c-process will exit. If the c-process crashes/exits it will bring the erlang-process down too and vice versa i.e. the connection is terminated.</source>
          <target state="translated">connect / 2에 의해 생성 된 erlang 연결 프로세스는 Microsoft의 ODBC API를 통해 데이터베이스와의 통신을 처리하는 c-process에 대한 포트를 엽니 다. c- 프로세스에서 문제가 발생하고 종료되면 erlang 포트는 종료 신호 전파를 위해 열린 상태로 유지됩니다. c-process와의 주요 통신은 소켓을 통해 수행됩니다. C- 프로세스는 감독자 스레드와 데이터베이스 핸들러 스레드의 두 스레드로 구성됩니다. 수퍼바이저 스레드는 수퍼바이저 소켓에서 종료 메시지를 확인하고 데이터베이스 핸들러 스레드는 요청을 수신하고 데이터베이스 소켓에서 응답을 보냅니다. 데이터베이스 스레드가 일부 데이터베이스 호출에서 정지 된 것으로 보이면 erlang 제어 프로세스는 수퍼바이저 소켓에서 종료 메시지를 보내며이 경우 c- 프로세스가 종료됩니다.c- 프로세스가 충돌 / 종료되면 erlang-process도 다운되고 그 반대도 마찬가지입니다. 즉 연결이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="df7997d41de6ac2a1785cee171c352d42d04f93c" translate="yes" xml:space="preserve">
          <source>The error behavior differs, see below.</source>
          <target state="translated">오류 동작이 다릅니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="011b09627444a05b2b15d34028f40a28dfdddfe0" translate="yes" xml:space="preserve">
          <source>The error descriptor defaults to &lt;code&gt;DefaultED&lt;/code&gt;, but can be overridden with an alternate one by returning &lt;code&gt;{reply,ED}&lt;/code&gt; or &lt;code&gt;{no_reply,ED}&lt;/code&gt; instead of &lt;code&gt;reply&lt;/code&gt; and &lt;code&gt;no_reply&lt;/code&gt; respectively.</source>
          <target state="translated">오류 디스크립터의 기본값은 &lt;code&gt;DefaultED&lt;/code&gt; 이지만 &lt;code&gt;{reply,ED}&lt;/code&gt; &lt;code&gt;reply&lt;/code&gt; 및 &lt;code&gt;no_reply&lt;/code&gt; 대신 각각 {reply, ED} 또는 &lt;code&gt;{no_reply,ED}&lt;/code&gt; 를 리턴하여 대체 디스크립터 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="461fac531aaf141393d180babf97f72d93ada5dc" translate="yes" xml:space="preserve">
          <source>The error handling strategy and possible errors sources are described in the Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">오류 처리 전략 및 가능한 오류 소스는 Erlang ODBC &lt;code&gt;&lt;a href=&quot;error_handling&quot;&gt;User's Guide.&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d405471c43706742d66ca4dd53edcd35e7ff6cb" translate="yes" xml:space="preserve">
          <source>The error information is handled by Logger, which is part of the Kernel application.</source>
          <target state="translated">오류 정보는 커널 응용 프로그램의 일부인 로거에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9eb4cd48329bca9a99f8dc4cb317a0559bc9784e" translate="yes" xml:space="preserve">
          <source>The error message will look like this:</source>
          <target state="translated">오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3061a1ab3e6a1d434208df5bfeb44852fc476d18" translate="yes" xml:space="preserve">
          <source>The error report module is configured using the directive &lt;code&gt;error_report_mod&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오류 보고서 모듈은 &lt;code&gt;error_report_mod&lt;/code&gt; 지시문을 사용하여 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="69f328c65ecacb1785a10bfaee95a3f42966f16c" translate="yes" xml:space="preserve">
          <source>The error return in the Erlang client (The text as data type 1 and exit_status 255):</source>
          <target state="translated">Erlang 클라이언트의 오류 반환 (데이터 유형 1 및 exit_status 255의 텍스트) :</target>
        </trans-unit>
        <trans-unit id="36a00c6827ff6af3c91907db56029def4bf079b7" translate="yes" xml:space="preserve">
          <source>The errors and warnings are listed in the order in which they are encountered in the forms. The errors from one file can therefore be split into different entries in the list of errors.</source>
          <target state="translated">오류 및 경고는 양식에서 발생하는 순서대로 나열됩니다. 따라서 한 파일의 오류는 오류 목록에서 다른 항목으로 분할 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3460fc594164d8bbf96577fb24868bb714be37" translate="yes" xml:space="preserve">
          <source>The errors detected include:</source>
          <target state="translated">감지 된 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b62e06cf6a78a94894293a2f2fefb7491e659ccc" translate="yes" xml:space="preserve">
          <source>The escape \o must be followed by a sequence of octal digits, enclosed in braces. An error occurs if this is not the case. This escape is a recent addition to Perl; it provides way of specifying character code points as octal numbers greater than 0777, and it also allows octal numbers and back references to be unambiguously specified.</source>
          <target state="translated">이스케이프 \ o 뒤에는 중괄호로 묶인 일련의 8 진 숫자가 와야합니다. 그렇지 않은 경우 오류가 발생합니다. 이 탈출은 최근 Perl에 추가 된 것입니다. 문자 코드 포인트를 0777보다 큰 8 진수로 지정하는 방법을 제공하며, 8 진수와 역 참조를 명확하게 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e09cca6482e14cefd7789aca27e688d2b8fc2ae0" translate="yes" xml:space="preserve">
          <source>The escape sequence \K causes any previously matched characters not to be included in the final matched sequence. For example, the following pattern matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;:</source>
          <target state="translated">이스케이프 시퀀스 \ K를 사용하면 이전에 일치 한 문자가 최종 일치 시퀀스에 포함되지 않습니다. 예를 들어 다음 패턴은 &quot;foobar&quot;와 일치하지만 &quot;bar&quot;와 일치한다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="1fdcd1532b972da832570c4e46f8a01588e3f319" translate="yes" xml:space="preserve">
          <source>The escape sequence \N behaves like a dot, except that it is not affected by option &lt;code&gt;PCRE_DOTALL&lt;/code&gt;. That is, it matches any character except one that signifies the end of a line. Perl also uses \N to match characters by name but PCRE does not support this.</source>
          <target state="translated">이스케이프 시퀀스 \ N은 &lt;code&gt;PCRE_DOTALL&lt;/code&gt; 옵션의 영향을받지 않는 점을 제외하고 점처럼 동작 합니다. 즉, 행의 끝을 나타내는 문자를 제외한 모든 문자와 일치합니다. Perl은 \ N을 사용하여 이름별로 문자를 일치 시키지만 PCRE는이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ac8458115fbc9af33358e4aea3bbde3c0be1319" translate="yes" xml:space="preserve">
          <source>The escape sequences allowed are the same as for Erlang strings:</source>
          <target state="translated">허용되는 이스케이프 시퀀스는 Erlang 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="32812c856e631f3ed1dcd90e3601c5c2b3077c8f" translate="yes" xml:space="preserve">
          <source>The eval scheme can seriously threaten the integrity of the Erlang node housing a web server, for example:</source>
          <target state="translated">평가 체계는 웹 서버를 수용하는 Erlang 노드의 무결성을 심각하게 위협 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21baa0e66c42986302a436c2cc18ea33ca352672" translate="yes" xml:space="preserve">
          <source>The eval scheme is straight-forward and does not mimic the behavior of plain CGI. An URL that calls an Erlang &lt;code&gt;eval&lt;/code&gt; function has the following syntax:</source>
          <target state="translated">평가 체계는 간단하며 일반 CGI의 동작을 모방하지 않습니다. Erlang &lt;code&gt;eval&lt;/code&gt; 함수 를 호출하는 URL의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10a18f07017de460e02711d1cf0600325f33b7fb" translate="yes" xml:space="preserve">
          <source>The evaluation of the query fails if the &lt;code&gt;qlc&lt;/code&gt; module cannot carry out the chosen join method. Defaults to &lt;code&gt;any&lt;/code&gt;, which means that some fast join method is used if possible.</source>
          <target state="translated">&lt;code&gt;qlc&lt;/code&gt; 모듈이 선택된 결합 방법을 수행 할 수없는 경우 쿼리 평가에 실패합니다 . 기본값은 &lt;code&gt;any&lt;/code&gt; 로 , 가능하면 일부 빠른 조인 방법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa8e9b7cfecc247f7bff705d3a3988485befc88c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed (user) type application expression.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 &lt;code&gt;syntax_error&lt;/code&gt; 형식의 사용자 유형 애플리케이션 표현식을 나타내지 않으면 평가에서 syntax_error가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4921b565820162e2c60edc6bea683451b957b890" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed &lt;code&gt;file&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 &lt;code&gt;file&lt;/code&gt; 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="618ce4cbe8b9ff30f535342ccae4d3cf10b313ea" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed application expression.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 애플리케이션 표현식을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="dc7fabf51da4bb4e7f1257e9d4dede7a0e536748" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed export attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 내보내기 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="0f66579024f348d7bb0f390e794429a5be199446" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function definition.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 함수 정의를 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5406ed8fb8fc38e89372ce85d6f56374209215a4" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed function name.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 함수 이름을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="30e8edf0d9aca5a1873eb5bed65e4d0bd6633e76" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed implicit fun.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 암시 적 재미를 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="9cbc54914d2a7b46a8529bdd08a5e3617825c157" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed import attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 가져 오기 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1ce44851dc662379c8d2493f03d24234da3c175f" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed module attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바르게 구성된 모듈 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e9d8a2fbebf4113ef3337fce36bf9fbf369a6379" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record declaration attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 레코드 선언 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bf9e76769c09ba06d5b9bf9c1944e2acfb2dfc1a" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed record field specifier.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 레코드 필드 지정자를 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ea05ee075bf7f2350e2fc6059b34cff5cb33b78c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed type name.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 형식의 이름을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="363e188710c96a0d0d2f45cbb80bd88dddfe084d" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; does not represent a well-formed wild attribute.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 올바른 와일드 속성을 나타내지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="223a63e0ec00c2810aadc750354eca2f59b6acb8" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; is not well-formed.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 제대로 구성되지 않으면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="527c092490ea3417d05959de64ac4673c4e2242c" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if &lt;code&gt;Node&lt;/code&gt; represents a record expression that is not well-formed.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 가 &lt;code&gt;syntax_error&lt;/code&gt; 이 올바르지 않은 레코드 표현식을 나타내는 경우 평가에서 syntax_error 가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="78caee1b9d51c269ecfa277516c192bac800da86" translate="yes" xml:space="preserve">
          <source>The evaluation throws &lt;code&gt;syntax_error&lt;/code&gt; if an ill-formed Erlang construct is encountered.</source>
          <target state="translated">잘못 구성된 Erlang 구문이 발견되면 평가에서 &lt;code&gt;syntax_error&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e360281a65b675290b77c855abb3396feae48026" translate="yes" xml:space="preserve">
          <source>The event &lt;code&gt;user_unblock&lt;/code&gt; is not triggered when a user is removed from the block list explicitly using the &lt;code&gt;unblock_user&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;unblock_user&lt;/code&gt; 함수를 사용하여 명시 적으로 사용자를 차단 목록에서 제거하면 &lt;code&gt;user_unblock&lt;/code&gt; 이벤트 가 트리거되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e9adf6f3e6bc9d678bcfcbf56c75783efdc79bfe" translate="yes" xml:space="preserve">
          <source>The event handler must be able to handle the events in this module, see section &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러는이 모듈에서 이벤트를 처리 할 수 ​​있어야합니다 ( &lt;code&gt;&lt;a href=&quot;#events&quot;&gt;Events&lt;/a&gt;&lt;/code&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="07fadfa5cd3629d9138971bd824a14ddd43b2990" translate="yes" xml:space="preserve">
          <source>The event handler return values are defined in the description of &lt;code&gt;Module:StateName/3&lt;/code&gt; in the &lt;code&gt;gen_statem&lt;/code&gt; manual page, but here is a more readable list:</source>
          <target state="translated">이벤트 핸들러 리턴 값은 &lt;code&gt;gen_statem&lt;/code&gt; 매뉴얼 페이지 의 &lt;code&gt;Module:StateName/3&lt;/code&gt; 에 대한 설명에 정의되어 있지만 다음은 더 읽기 쉬운 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9b5aab32f54b078cb1c0faaf00cf7eb4a19eec31" translate="yes" xml:space="preserve">
          <source>The event handler terminates abnormally and &lt;code&gt;gen_event&lt;/code&gt; logs an error. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;terminate&lt;/code&gt; for this case.</source>
          <target state="translated">이벤트 핸들러가 비정상적으로 종료되고 &lt;code&gt;gen_event&lt;/code&gt; 가 오류를 기록합니다. 이 경우에는 &lt;code&gt;Opt&lt;/code&gt; 가 원자 &lt;code&gt;terminate&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7f89716df5f45b5490450ec2ac15b0b43b462e0" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler.</source>
          <target state="translated">이벤트는 기본 로거 핸들러에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2545cd2dda316056d2647ebcf0c0876379df39a7" translate="yes" xml:space="preserve">
          <source>The event is handled by the default Logger handler. The log level can be changed to error or info, see &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트는 기본 로거 핸들러에 의해 처리됩니다. 로그 레벨을 error 또는 info로 변경할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#warning_map-0&quot;&gt;warning_map/0&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="836db6626acc8d2b63d4479e731dd11320410d43" translate="yes" xml:space="preserve">
          <source>The event is handled by:</source>
          <target state="translated">이벤트는 다음에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="670f3a97ec79b1617d1253c86abd242fbfe96cb8" translate="yes" xml:space="preserve">
          <source>The event is made into a message and sent to the event manager. When the event is received, the event manager calls &lt;code&gt;handle_event(Event, State)&lt;/code&gt; for each installed event handler, in the same order as they were added. The function is expected to return a tuple &lt;code&gt;{ok,State1}&lt;/code&gt;, where &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the event handler.</source>
          <target state="translated">이벤트는 메시지로 작성되어 이벤트 관리자에게 전송됩니다. 이벤트가 수신되면, 이벤트 관리자는 설치된 각 이벤트 핸들러에 대해 &lt;code&gt;handle_event(Event, State)&lt;/code&gt; 를 추가 된 순서대로 호출합니다 . 이 함수는 튜플 &lt;code&gt;{ok,State1}&lt;/code&gt; 을 리턴 할 것으로 예상되며 , 여기서 &lt;code&gt;State1&lt;/code&gt; 은 이벤트 핸들러 상태의 새 값입니다.</target>
        </trans-unit>
        <trans-unit id="b73ba2f2d96d9d903429f26f68141cab3925fb1c" translate="yes" xml:space="preserve">
          <source>The event is sent to the &lt;code&gt;gen_statem&lt;/code&gt;. When the event is received, the &lt;code&gt;gen_statem&lt;/code&gt; calls &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt;, or &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt;. &lt;code&gt;StateName&lt;/code&gt; is the name of the current state and &lt;code&gt;NewStateName&lt;/code&gt; is the name of the next state to go to. &lt;code&gt;NewData&lt;/code&gt; is a new value for the server data of the &lt;code&gt;gen_statem&lt;/code&gt;, and &lt;code&gt;Actions&lt;/code&gt; is a list of actions to be performed by the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">이벤트는 &lt;code&gt;gen_statem&lt;/code&gt; 으로 전송됩니다 . 이벤트가 수신되면 &lt;code&gt;gen_statem&lt;/code&gt; 은 &lt;code&gt;StateName(cast, Event, Data)&lt;/code&gt; 호출 하여 튜플 &lt;code&gt;{next_state, NewStateName, NewData}&lt;/code&gt; 또는 &lt;code&gt;{next_state, NewStateName, NewData, Actions}&lt;/code&gt; 을 리턴 할 것으로 예상됩니다 . &lt;code&gt;StateName&lt;/code&gt; 은 현재 상태 의 이름 이고 &lt;code&gt;NewStateName&lt;/code&gt; 은 다음에 갈 상태의 이름입니다. &lt;code&gt;NewData&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 의 서버 데이터에 대한 새로운 값 이며, &lt;code&gt;Actions&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 엔진 이 수행 할 조치 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="cfd753f364308c6d8a412367394b65eb5bb6c7da" translate="yes" xml:space="preserve">
          <source>The event manager calls &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt; Module:handle_call/2&lt;/a&gt;&lt;/code&gt; to handle the request.</source>
          <target state="translated">이벤트 관리자는 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-2&quot;&gt; Module:handle_call/2&lt;/a&gt;&lt;/code&gt; 를 호출 하여 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="482c8d79933fe33bda06c58901ec825b1db485ea" translate="yes" xml:space="preserve">
          <source>The event manager essentially maintains a list of &lt;code&gt;{Module, State}&lt;/code&gt; pairs, where each &lt;code&gt;Module&lt;/code&gt; is an event handler, and &lt;code&gt;State&lt;/code&gt; is the internal state of that event handler.</source>
          <target state="translated">이벤트 관리자는 기본적으로 &lt;code&gt;{Module, State}&lt;/code&gt; 쌍 의 목록을 유지 보수합니다 . 여기서 각 &lt;code&gt;Module&lt;/code&gt; 은 이벤트 핸들러이고 &lt;code&gt;State&lt;/code&gt; 는 해당 이벤트 핸들러의 내부 상태입니다.</target>
        </trans-unit>
        <trans-unit id="76d57c410515c44cc8bc28a8d09b64ef1f2639aa" translate="yes" xml:space="preserve">
          <source>The event manager terminates if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is &lt;strong&gt;not&lt;/strong&gt; part of a supervision tree, it terminates if it receives an &lt;code&gt;'EXIT'&lt;/code&gt; message from its parent.</source>
          <target state="translated">이벤트 관리자가 감독 트리의 일부인 경우 이벤트 관리자가 종료되며 감독자에 의해 종료되도록 명령됩니다. 감독 트리의 일부 가 &lt;strong&gt;아니더라도&lt;/strong&gt; 상위 트리에서 &lt;code&gt;'EXIT'&lt;/code&gt; 메시지를 받으면 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2ce4c38c0aa823b9e5e74e4d8bcd2d1c4f1111f" translate="yes" xml:space="preserve">
          <source>The event tracer framework is made up of four modules:</source>
          <target state="translated">이벤트 추적 프로그램 프레임 워크는 다음 네 가지 모듈로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f7cae16de84ad2c9c39b99cb4c031af931d1d5" translate="yes" xml:space="preserve">
          <source>The event types are described in the next sections.</source>
          <target state="translated">이벤트 유형은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f1782c63eb3688ca0c9af0612dd19da36a393122" translate="yes" xml:space="preserve">
          <source>The events are also documented in &lt;code&gt;ct_event.erl&lt;/code&gt;. This module can serve as an example of what an event handler for the &lt;code&gt;Common Test&lt;/code&gt; event manager can look like.</source>
          <target state="translated">이벤트는 &lt;code&gt;ct_event.erl&lt;/code&gt; 에도 문서화되어 있습니다 . 이 모듈은 &lt;code&gt;Common Test&lt;/code&gt; 이벤트 관리자에 대한 이벤트 핸들러의 모양에 대한 예를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c24f138a33faf79d167906d2c594eb6f61632b5" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt; handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트는 이벤트를 생성 한 프로세스 ( &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt; handle_debug/4)&lt;/a&gt;&lt;/code&gt; 호출)에 의해 정의 된 함수로 형식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa54bda16841cabde0c2e6fc00114e179e4c8c7f" translate="yes" xml:space="preserve">
          <source>The events are formatted with a function that is defined by the process that generated the event (with a call to &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트는 이벤트를 생성 한 프로세스에 의해 정의 된 함수 ( &lt;code&gt;&lt;a href=&quot;#handle_debug-4&quot;&gt;handle_debug/4)&lt;/a&gt;&lt;/code&gt; 호출)로 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed5fedd80749f48dc22eb2ae97b4b16538b4c269" translate="yes" xml:space="preserve">
          <source>The exact error message depends on the actual callback module. The Error message makes the connection to fail, and is returned from e.g ssh:connect/3.</source>
          <target state="translated">정확한 오류 메시지는 실제 콜백 모듈에 따라 다릅니다. 오류 메시지는 연결을 실패하게 만들고 예를 들어 ssh : connect / 3에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="efa1279652840651c701347ac0d11ff90fe9b0b8" translate="yes" xml:space="preserve">
          <source>The exact set of options and there syntax &lt;strong&gt;may&lt;/strong&gt; be changed without prior notice.</source>
          <target state="translated">정확한 옵션 및 구문 &lt;strong&gt;은&lt;/strong&gt; 사전 통지없이 변경 &lt;strong&gt;될 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d4c6263423994284ba2b9c6d7623abbea04412" translate="yes" xml:space="preserve">
          <source>The example &lt;code&gt;Subject&lt;/code&gt; field has one C, two CN and one O part. It is only the CN (Common Name) that is used by hostname verification. The two other (C and O) is not used here even when they contain a domain name like the O part. The C and O parts are defined elsewhere and meaningful only for other functions.</source>
          <target state="translated">예제 &lt;code&gt;Subject&lt;/code&gt; 필드에는 C 1 개, CN 2 개, O 파트 1 개가 있습니다. 호스트 이름 확인에 사용되는 것은 CN (일반 이름)뿐입니다. 다른 두 부분 (C 및 O)은 O 부분과 같은 도메인 이름을 포함하더라도 여기에서 사용되지 않습니다. C 및 O 부분은 다른 곳에서 정의되며 다른 기능에 대해서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53789d2e92c1fda46d0fae07ec08f87e98bdd01d" translate="yes" xml:space="preserve">
          <source>The example I/O server stores characters in an ETS table, making up a fairly crude RAM file.</source>
          <target state="translated">예제 I / O 서버는 문자를 ETS 테이블에 저장하여 상당히 조잡한 RAM 파일을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="3a18dec0331c54c7d131f7f05a54cda624c44be5" translate="yes" xml:space="preserve">
          <source>The example below sets up trace on the exported functions (default) of module &lt;code&gt;snmp_generic&lt;/code&gt; and all functions of module &lt;code&gt;snmp_generic_mnesia&lt;/code&gt;. With return values (which is default) and timestamps in both cases (which is also default):</source>
          <target state="translated">모듈의 내보내기 기능 (기본값)에 대한 추적 설정 아래의 예를 &lt;code&gt;snmp_generic&lt;/code&gt; 및 모듈의 모든 기능 &lt;code&gt;snmp_generic_mnesia&lt;/code&gt; . 반환 값 (기본값)과 두 경우 모두 타임 스탬프 (기본) :</target>
        </trans-unit>
        <trans-unit id="40ec67cee0f09e7e1f38061d74546bfcd1432fac" translate="yes" xml:space="preserve">
          <source>The example manager, &lt;code&gt;snmp_ex2_manager&lt;/code&gt;, is a simple example of how to implement an snmp manager using the manager component of the SNMP Development Toolkit.</source>
          <target state="translated">&lt;code&gt;snmp_ex2_manager&lt;/code&gt; 예제 관리자 는 SNMP Development Toolkit의 관리자 구성 요소를 사용하여 snmp 관리자를 구현하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="bfa0e44fefc9103dfe63a4cd1030807bc049d616" translate="yes" xml:space="preserve">
          <source>The example servers so far in this chapter print the full internal state in the error log, for example, when killed by an exit signal or because of an internal error. This state contains both the code lock code and which digits that remain to unlock.</source>
          <target state="translated">이 장의 지금까지 예제 서버는 종료 신호에 의해 종료되거나 내부 오류로 인해 오류 로그에 전체 내부 상태를 인쇄합니다. 이 상태에는 코드 잠금 코드와 잠금 해제 상태로 남아있는 숫자가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="266205b844f4f6e3267e956b4430b205e05dad6e" translate="yes" xml:space="preserve">
          <source>The example showed the background work that the shell performs just to interpret the first command line. Most work is done by &lt;code&gt;erl_eval&lt;/code&gt; and &lt;code&gt;orddict&lt;/code&gt;.</source>
          <target state="translated">이 예는 쉘이 첫 번째 명령 행을 해석하기 위해 수행하는 백그라운드 작업을 보여줍니다. 대부분의 작업은 &lt;code&gt;erl_eval&lt;/code&gt; 및 &lt;code&gt;orddict&lt;/code&gt; 에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f7ad9497d8d5ee7ec068f8bbaf412b434e2689f" translate="yes" xml:space="preserve">
          <source>The example shown can be found in the toolkit distribution.</source>
          <target state="translated">표시된 예제는 툴킷 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="396a52ee352a84ef61ae01c6d40809962c1134e8" translate="yes" xml:space="preserve">
          <source>The example shown, &lt;strong&gt;ex2&lt;/strong&gt;, can be found in the toolkit distribution.</source>
          <target state="translated">&lt;strong&gt;ex2&lt;/strong&gt; 예제 는 툴킷 배포에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7c4a3f89e04c623143e7c4c121106db17b0068" translate="yes" xml:space="preserve">
          <source>The example shows some details of how &lt;code&gt;lists:sort/1&lt;/code&gt; works. It used 6047 function calls in the module &lt;code&gt;lists_sort&lt;/code&gt; to complete the work.</source>
          <target state="translated">이 예는 &lt;code&gt;lists:sort/1&lt;/code&gt; 작동 방식 에 대한 세부 정보를 보여줍니다 . &lt;code&gt;lists_sort&lt;/code&gt; 모듈에서 6047 함수 호출을 사용 하여 작업을 완료했습니다.</target>
        </trans-unit>
        <trans-unit id="361c007ea7390ae514b7d7274e3225478c75cf81" translate="yes" xml:space="preserve">
          <source>The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly.</source>
          <target state="translated">이 예에서는 암호에 대해 두 방향 (client2server 및 server2client)으로 서로 다른 알고리즘을 지정하지만, 양방향으로 mac 및 압축에 대해 동일한 알고리즘을 지정합니다. kex (키 교환)는 암시 적이지만 public_key는 명시 적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c97ac9647ab00e65e37eca74aa7e20c8819a73a3" translate="yes" xml:space="preserve">
          <source>The example specifies that:</source>
          <target state="translated">예제는 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="839951ee6733677e5315d3af4eb38dc5514df04f" translate="yes" xml:space="preserve">
          <source>The example specifies the following:</source>
          <target state="translated">예제는 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5e9468869847362818e3653dadf86b7f55f088d1" translate="yes" xml:space="preserve">
          <source>The example tells us that &quot;Aktiebolaget LM Ericsson &amp;amp; Co&quot; was registered on a Monday (since the return value of the first command is 1), and that the &lt;code&gt;calendar&lt;/code&gt; module needed 9 function calls to calculate that.</source>
          <target state="translated">이 예에서는 월요일에 &quot;Aktiebolaget LM Ericsson &amp;amp; Co&quot;가 등록되었고 (첫 번째 명령의 반환 값이 1이므로) &lt;code&gt;calendar&lt;/code&gt; 모듈이이를 계산하기 위해 9 개의 함수 호출이 필요했음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="d3af375b76125b97a165b743095415faf44c0ea3" translate="yes" xml:space="preserve">
          <source>The exception &lt;code&gt;error:badarg&lt;/code&gt; signifies that one or more arguments are of wrong data type, or are otherwise badly formed.</source>
          <target state="translated">예외 &lt;code&gt;error:badarg&lt;/code&gt; 는 하나 이상의 인수가 잘못된 데이터 유형이거나 형식이 잘못되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="82dc2e396d1267b7791f7b989a0eeae2a1d692a5" translate="yes" xml:space="preserve">
          <source>The exception &lt;code&gt;error:notsup&lt;/code&gt; signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that.</source>
          <target state="translated">예외 &lt;code&gt;error:notsup&lt;/code&gt; 은 알고리즘이 알려져 있지만 현재 기본 libcrypto에서 지원하지 않거나 빌드 할 때 명시 적으로 비활성화되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="609a6bc75d839746103bc7db1aad099d08bdaa32" translate="yes" xml:space="preserve">
          <source>The exception is:</source>
          <target state="translated">예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8702ec4ef9d4d3401c7835a54a81bebc8bc6902d" translate="yes" xml:space="preserve">
          <source>The exception tags are:</source>
          <target state="translated">예외 태그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ffa934118cebf3f90cde4787faaae21bba8d06a" translate="yes" xml:space="preserve">
          <source>The exec-option fun is called with the same number of parameters as the arity of the fun, and the result is returned to the client.</source>
          <target state="translated">exec 옵션 fun은 fun의 arity와 동일한 수의 매개 변수로 호출되며 결과는 클라이언트로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b071e577cae1eeba87f1871188878bd3a2873b58" translate="yes" xml:space="preserve">
          <source>The exec-option has existed for a long time but has not previously been documented. The old definition and behaviour are retained but obey the rules 1-4 above if conflicting. The old and undocumented style should not be used in new programs.</source>
          <target state="translated">exec 옵션은 오랫동안 존재했지만 이전에 문서화되지 않았습니다. 이전 정의와 동작은 유지되지만 충돌하는 경우 위의 1-4 규칙을 준수하십시오. 구식 및 문서화되지 않은 스타일은 새 프로그램에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b1895955082bfa77ca24a94c48e11688ebe85d9a" translate="yes" xml:space="preserve">
          <source>The exec-request is not evaluated and an error message is returned to the client.</source>
          <target state="translated">실행 요청이 평가되지 않고 클라이언트에 오류 메시지가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bdc6ba747c512b08f42f53fa0f4d202112779ea7" translate="yes" xml:space="preserve">
          <source>The exec-request is not evaluated and an error message is returned to the client. Shell-requests are executed according to the value of the &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">exec-request는 평가되지 않고 오류 메시지가 클라이언트에 반환됩니다. 쉘 요청은 &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell_spec&lt;/a&gt;&lt;/code&gt; 의 값에 따라 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c24b69b74e8713f113ddc4cb4727d97ca1bd44b" translate="yes" xml:space="preserve">
          <source>The executable name (also known as &lt;code&gt;argv[0]&lt;/code&gt;) is not to be specified in this list. The proper executable name is automatically used as &lt;code&gt;argv[0]&lt;/code&gt;, where applicable.</source>
          <target state="translated">실행 파일 이름 ( &lt;code&gt;argv[0]&lt;/code&gt; 이라고도 함 )은이 목록에 지정되지 않습니다. 해당되는 경우 적절한 실행 파일 이름이 &lt;code&gt;argv[0]&lt;/code&gt; 으로 자동 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7703497b2d1d6d7ae666f5086932193209c602a9" translate="yes" xml:space="preserve">
          <source>The execution of the match expression, when the runtime system decides whether a trace message is to be sent, is as follows:</source>
          <target state="translated">런타임 시스템이 추적 메시지를 보낼지 여부를 결정할 때 일치 표현식의 실행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2a8e42abde3dd1496d089519cf10c81e1be53df" translate="yes" xml:space="preserve">
          <source>The execution time of the functions of this module is dominated by the time it takes to sort lists. When no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the input arguments and the returned value. A few functions execute in constant time: &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈의 기능 실행 시간은 목록을 정렬하는 데 걸리는 시간에 의해 결정됩니다. 정렬이 필요하지 않은 경우 실행 시간은 최악의 경우 입력 인수의 크기와 반환 된 값의 합계에 비례합니다. &lt;code&gt;&lt;a href=&quot;#from_external-2&quot;&gt;from_external/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#is_empty_set-1&quot;&gt;is_empty_set/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#is_set-1&quot;&gt;is_set/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#is_sofs_set-1&quot;&gt;is_sofs_set/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#to_external-1&quot;&gt;to_external/1&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 과 같은 몇 가지 함수가 일정한 시간에 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa9c12dd4680e897bd4368ab039f91ae858c158b" translate="yes" xml:space="preserve">
          <source>The execution time of this function is affected by the &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; table option when the second argument of the function is &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;memory&lt;/code&gt;. The execution time is much longer when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt; than when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수의 실행 시간은 함수 의 두 번째 인수가 &lt;code&gt;size&lt;/code&gt; 또는 &lt;code&gt;memory&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; 테이블 옵션의 영향을받습니다 . &lt;code&gt;decentralized_counters&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 &lt;code&gt;decentralized_counters&lt;/code&gt; 옵션이 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 보다 실행 시간이 훨씬 더 깁니다 .</target>
        </trans-unit>
        <trans-unit id="d23cabee7bc15b3bbb53bab32c996479b57bf352" translate="yes" xml:space="preserve">
          <source>The execution time of this function is affected by the &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; table option. The execution time is much longer when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt; than when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수의 실행 시간은 &lt;code&gt;&lt;a href=&quot;#new_2_decentralized_counters&quot;&gt; decentralized_counters&lt;/a&gt;&lt;/code&gt; 테이블 옵션의 영향을받습니다 . &lt;code&gt;decentralized_counters&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 &lt;code&gt;decentralized_counters&lt;/code&gt; 옵션이 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 보다 실행 시간이 훨씬 더 깁니다 .</target>
        </trans-unit>
        <trans-unit id="420632c27cadb89b2f399b84682c82a68f0a0d31" translate="yes" xml:space="preserve">
          <source>The existing association argument &lt;code&gt;Assoc&lt;/code&gt; can be either a &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; record as returned from, for example, &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt;, or from a listening socket in active mode. It can also be just the field &lt;code&gt;assoc_id&lt;/code&gt; integer from such a record.</source>
          <target state="translated">기존 연관 인수 &lt;code&gt;Assoc&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#connect-5&quot;&gt;connect/*&lt;/a&gt;&lt;/code&gt; 와 같이 또는 활성 모드의 청취 소켓에서 리턴 된 &lt;code&gt;&lt;a href=&quot;#record-sctp_assoc_change&quot;&gt;#sctp_assoc_change{}&lt;/a&gt;&lt;/code&gt; 레코드 일 수 있습니다 . 또한 그러한 레코드에서 필드 &lt;code&gt;assoc_id&lt;/code&gt; 정수일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e5a5b15744513cdcf17a46b1eef747c1795c4cb" translate="yes" xml:space="preserve">
          <source>The exit reasons (such as &lt;code&gt;badarg&lt;/code&gt;) used by the runtime system are described in &lt;code&gt; Errors and Error Handling&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템에서 사용하는 종료 이유 (예 : &lt;code&gt;badarg&lt;/code&gt; )는 &lt;code&gt; Errors and Error Handling&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f8f6f791625c1c8fdb334b26d42632cd9d6c18" translate="yes" xml:space="preserve">
          <source>The exit reasons (such as &lt;code&gt;badarg&lt;/code&gt;) used by the runtime system are described in &lt;code&gt;Errors and Error Handling&lt;/code&gt;.</source>
          <target state="translated">런타임 시스템에서 사용되는 종료 이유 (예 : &lt;code&gt;badarg&lt;/code&gt; )는 &lt;code&gt;Errors and Error Handling&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="307cc83b0061e1f27d08d717f7f91193792a0bb2" translate="yes" xml:space="preserve">
          <source>The exit value can later be retrieved by another thread through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종료 값은 나중에 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt; erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 을 통해 다른 스레드에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5ae7040a803e376f91e7e700a11833b4ef1676c" translate="yes" xml:space="preserve">
          <source>The exit value can later be retrieved by another thread through &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종료 값은 나중에 &lt;code&gt;&lt;a href=&quot;#erl_drv_thread_join&quot;&gt;erl_drv_thread_join&lt;/a&gt;&lt;/code&gt; 을 통해 다른 스레드에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb2edd7ed5ff8d8687d3a39c97903bcaca3e2655" translate="yes" xml:space="preserve">
          <source>The expanded code for &lt;code&gt;move_deallocate_return&lt;/code&gt; will look this:</source>
          <target state="translated">&lt;code&gt;move_deallocate_return&lt;/code&gt; 에 대한 확장 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fde359ee385d3e78714231ab869d10ea4d9e799" translate="yes" xml:space="preserve">
          <source>The exported function &lt;code&gt;f/1&lt;/code&gt; is deprecated. Nothing is said whether &lt;code&gt;f/1&lt;/code&gt; will be removed or not.</source>
          <target state="translated">내 보낸 함수 &lt;code&gt;f/1&lt;/code&gt; 은 더 이상 사용되지 않습니다. &lt;code&gt;f/1&lt;/code&gt; 이 제거 될지 여부는 알려지지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="47e6598c7dcf7a2b613f4f2e9c2f96997e697806" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;Expr&lt;/code&gt; is evaluated and the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result. If a match succeeds and the optional guard sequence &lt;code&gt;GuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;Body&lt;/code&gt; is evaluated.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 표현식 이 평가되고 패턴 &lt;code&gt;Pattern&lt;/code&gt; 이 결과와 순차적으로 일치합니다. 일치하고 가드 시퀀스 &lt;code&gt;GuardSeq&lt;/code&gt; 옵션 이 true이면 해당 &lt;code&gt;Body&lt;/code&gt; 이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="eb08adeb4f1b661f39b36975cfaf70cfc2a2ac3a" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; is the list of all elements in &lt;code&gt;T&lt;/code&gt; that are less than &lt;code&gt;Pivot&lt;/code&gt;.</source>
          <target state="translated">표현 &lt;code&gt;[X || X &amp;lt;- T, X &amp;lt; Pivot]&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;Pivot&lt;/code&gt; 보다 작은 모든 요소의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="a1e90b9cd13dd08f75832cad1c6cf3f69ae835ff" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;record_info(fields, record_name)&lt;/code&gt; is processed by the Erlang preprocessor and returns a list of the record field names. With the record definition &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt;, the expression &lt;code&gt;record_info(fields,foo)&lt;/code&gt; is expanded to the list &lt;code&gt;[x,y,z]&lt;/code&gt;. It is therefore possible for you to provide the attribute names or to use the &lt;code&gt;record_info/2&lt;/code&gt; notation.</source>
          <target state="translated">&lt;code&gt;record_info(fields, record_name)&lt;/code&gt; 표현식 은 Erlang 전처리 기에 의해 처리되며 레코드 필드 이름 목록을 리턴합니다. 레코드 정의 &lt;code&gt;-record(foo, {x,y,z}).&lt;/code&gt; &lt;code&gt;record_info(fields,foo)&lt;/code&gt; 표현식 이 &lt;code&gt;[x,y,z]&lt;/code&gt; 목록으로 확장되었습니다 . 따라서 속성 이름을 제공하거나 &lt;code&gt;record_info/2&lt;/code&gt; 표기법 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3552b8886e514fbbee153703d027b2f37ce6a492" translate="yes" xml:space="preserve">
          <source>The extended encodings are only supported on disk files (opened by function &lt;code&gt; file:open/2&lt;/code&gt;).</source>
          <target state="translated">확장 인코딩은 디스크 파일에서만 지원됩니다 ( &lt;code&gt; file:open/2&lt;/code&gt; 함수로 열림 ).</target>
        </trans-unit>
        <trans-unit id="46c25aa4f264a013c217a6e6c0cd1f11966c0297" translate="yes" xml:space="preserve">
          <source>The extended encodings are only supported on disk files (opened by function &lt;code&gt;file:open/2&lt;/code&gt;).</source>
          <target state="translated">확장 인코딩은 디스크 파일 (기능 &lt;code&gt;file:open/2&lt;/code&gt; ) 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="414c6b2e2b9fdb04bcc3300cfb9c6af4411d70f4" translate="yes" xml:space="preserve">
          <source>The extended information written in the file footer to allow stronger verification during table loading from file, as specified to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt; tab2file/3&lt;/a&gt;&lt;/code&gt;. Notice that this function only tells &lt;strong&gt;which&lt;/strong&gt; information is present, not the values in the file footer. The value is a list containing one or more of the atoms &lt;code&gt;object_count&lt;/code&gt; and &lt;code&gt;md5sum&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt; tab2file/3&lt;/a&gt;&lt;/code&gt; 에 지정된대로 파일에서 테이블을로드하는 동안 더 강력한 검증을 허용하기 위해 파일 바닥 글에 기록 된 확장 정보 . 이 함수 는 파일 바닥 글의 값이 아니라 &lt;strong&gt;어떤&lt;/strong&gt; 정보가 &lt;strong&gt;있는지&lt;/strong&gt; 만 알려줍니다 . 값은 하나 이상의 원자 &lt;code&gt;object_count&lt;/code&gt; 및 &lt;code&gt;md5sum&lt;/code&gt; 을 포함하는 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="2a6444a6ceb013adde9ead96d92efa55f0f4c658" translate="yes" xml:space="preserve">
          <source>The extended information written in the file footer to allow stronger verification during table loading from file, as specified to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;. Notice that this function only tells &lt;strong&gt;which&lt;/strong&gt; information is present, not the values in the file footer. The value is a list containing one or more of the atoms &lt;code&gt;object_count&lt;/code&gt; and &lt;code&gt;md5sum&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 에 지정된대로 파일에서 테이블을로드하는 동안 더 강력한 검증을 허용하기 위해 파일 바닥 글에 작성된 확장 정보입니다 . 이 함수 는 파일 바닥 글의 값이 아니라 &lt;strong&gt;어떤&lt;/strong&gt; 정보가 &lt;strong&gt;있는지&lt;/strong&gt; 알려줍니다 . 값은 원자 &lt;code&gt;object_count&lt;/code&gt; 및 &lt;code&gt;md5sum&lt;/code&gt; 중 하나 이상을 포함하는 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="7699dc7022a8a1b6e975d2c9f7052dbc61739221" translate="yes" xml:space="preserve">
          <source>The extensible agent in this toolkit understands the SNMPv1, SNMPv2c and SNMPv3. Recall that SNMP consists of two separate parts, the MIB definition language (SMI), and the protocol. On the protocol level, the agent can be configured to speak v1, v2c, v3 or any combination of them at the same time, i.e. a v1 request gets an v1 reply, a v2c request gets a v2c reply, and a v3 request gets a v3 reply. On the MIB level, the MIB compiler can compile both SMIv1 and SMIv2 MIBs. Once compiled, any of the formats can be loaded into the agent, regardless of which protocol version the agent is configured to use. This means that the agent translates from v2 notifications to v1 traps, and vice versa. For example, v2 MIBs can be loaded into an agent that speaks v1 only. The procedures for the translation between the two protocols are described in RFC 1908 and RFC 2089.</source>
          <target state="translated">이 툴킷의 확장 가능 에이전트는 SNMPv1, SNMPv2c 및 SNMPv3을 이해합니다. SNMP는 MIB 정의 언어 (SMI)와 프로토콜의 두 부분으로 구성됩니다. 프로토콜 수준에서 에이전트는 v1, v2c, v3 또는 이들의 조합을 동시에 말하도록 구성 할 수 있습니다. 즉, v1 요청은 v1 응답을 받고 v2c 요청은 v2c 응답을 받고 v3 요청은 v3 답장. MIB 레벨에서 MIB 컴파일러는 SMIv1 및 SMIv2 MIB를 모두 컴파일 할 수 있습니다. 컴파일 된 후에는 에이전트가 사용하도록 구성된 프로토콜 버전에 관계없이 모든 형식을 에이전트에로드 할 수 있습니다. 이는 에이전트가 v2 알림에서 v1 트랩으로 또는 그 반대로 변환 함을 의미합니다. 예를 들어, v2 MIB는 v1 만 말하는 에이전트에로드 할 수 있습니다.두 프로토콜 간의 변환 절차는 RFC 1908 및 RFC 2089에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57de3f33cd01d18ece5f1f8bac4a92c384bb136f" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process than the Erlang runtime system. In some cases this is not acceptable. Consider, for example, drivers with very hard time requirements. It is therefore possible to write a program in C according to certain principles, and dynamically link it to the Erlang runtime system. This is called a &lt;strong&gt;linked-in driver&lt;/strong&gt;.</source>
          <target state="translated">외부 프로그램은 Erlang 런타임 시스템 이외의 다른 OS 프로세스에 있습니다. 어떤 경우에는 허용되지 않습니다. 예를 들어 매우 힘든 시간이 필요한 드라이버를 고려하십시오. 따라서 특정 원칙에 따라 C로 프로그램을 작성하고이를 Erlang 런타임 시스템에 동적으로 링크 할 수 있습니다. 이것을 &lt;strong&gt;링크드 드라이버&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="483a7ce8598855903aaac7d43e33a8b6a176d6b3" translate="yes" xml:space="preserve">
          <source>The external program resides in another OS process. By default, it reads from standard input (file descriptor 0) and writes to standard output (file descriptor 1). The external program is to terminate when the port is closed.</source>
          <target state="translated">외부 프로그램은 다른 OS 프로세스에 있습니다. 기본적으로 표준 입력 (파일 설명자 0)에서 읽고 표준 출력 (파일 설명자 1)에 씁니다. 외부 프로그램은 포트가 닫힐 때 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="222a1e19175406b6aa7a82dcd2394935006c713e" translate="yes" xml:space="preserve">
          <source>The external term format is mainly used in the distribution mechanism of Erlang.</source>
          <target state="translated">외부 용어 형식은 주로 Erlang의 배포 메커니즘에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="474968dd4f560dffd7389aa9ca6143617036ffea" translate="yes" xml:space="preserve">
          <source>The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">(* PRUNE : NAME)이 이름을 기억한다는 사실은 이름을 검색 할 수 없으므로 Erlang 프로그래머에게는 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e08d6e43db0948fdcb04ad39ee35684175d7b088" translate="yes" xml:space="preserve">
          <source>The fact that (*THEN:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved.</source>
          <target state="translated">(* THEN : NAME)이 이름을 기억한다는 사실은 이름을 검색 할 수 없으므로 Erlang 프로그래머에게는 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a45ac2df0b9d463c5e0e5db641eebadc3836e7a0" translate="yes" xml:space="preserve">
          <source>The factor when calculating the new timer time (&lt;code&gt;wait_for&lt;/code&gt;).</source>
          <target state="translated">새 타이머 시간을 계산할 때의 요인 ( &lt;code&gt;wait_for&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b32182822028d3d94853cdaecf2932942b85c07" translate="yes" xml:space="preserve">
          <source>The fastest selective decode is when the decoded type is a primitive type and not so deep in the structure of the top type. &lt;code&gt;selected_decode_Window2&lt;/code&gt; decodes a high constructed value, which explains why this operation is relatively slow.</source>
          <target state="translated">가장 빠른 선택적 디코딩은 디코딩 된 유형이 기본 유형이고 최상위 유형의 구조에 그다지 깊지 않은 경우입니다. &lt;code&gt;selected_decode_Window2&lt;/code&gt; 는 높은 구성 값을 디코딩하여이 작업이 상대적으로 느린 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e539ae850e97a5a9057ff2bb6d6c8fcc08bab73d" translate="yes" xml:space="preserve">
          <source>The feature was added in Erlang 5.7.5/OTP R13B04.</source>
          <target state="translated">이 기능은 Erlang 5.7.5 / OTP R13B04에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a7d9b7c2c0bd1f2fc3f2c7d85835796c435f8f44" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;data&lt;/code&gt; in &lt;code&gt;ModData&lt;/code&gt; is a list. This list is the list returned from the last call to &lt;code&gt;do/1&lt;/code&gt;.</source>
          <target state="translated">필드 &lt;code&gt;data&lt;/code&gt; 에 &lt;code&gt;ModData&lt;/code&gt; 은 목록입니다. 이 목록은 &lt;code&gt;do/1&lt;/code&gt; 에 대한 마지막 호출에서 리턴 된 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="6456be6965c0349e34f864167682f7b31ae172c8" translate="yes" xml:space="preserve">
          <source>The field width specifies the maximum line length. It defaults to 80. The precision specifies the initial indentation of the term. It defaults to the number of characters printed on this line in the &lt;strong&gt;same&lt;/strong&gt; call to &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt;. For example, using &lt;code&gt;T&lt;/code&gt; above:</source>
          <target state="translated">필드 너비는 최대 줄 길이를 지정합니다. 기본값은 80입니다. 정밀도는 항의 초기 들여 쓰기를 지정합니다. &lt;code&gt;&lt;a href=&quot;#write-1&quot;&gt;write/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#format-1&quot;&gt;format/1,2,3&lt;/a&gt;&lt;/code&gt; 호출 &lt;strong&gt;과 동일한&lt;/strong&gt; 호출 로이 행에 인쇄 된 문자 수를 기본값으로합니다 . 예를 들어, 위의 &lt;code&gt;T&lt;/code&gt; 를 사용 하면 :</target>
        </trans-unit>
        <trans-unit id="45f234045151c357743a7016e59e80ebbcce1cad" translate="yes" xml:space="preserve">
          <source>The fields can be in any order, not necessarily the same order as in the record definition, and fields can be omitted. Omitted fields get their respective default value instead.</source>
          <target state="translated">필드는 레코드 정의에서와 반드시 같은 순서 일 필요는 없으며 임의의 순서 일 수 있으며 필드는 생략 할 수 있습니다. 생략 된 필드는 대신 각각의 기본값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="08c771e3c02df1bde386f66f03b2e079f068c16e" translate="yes" xml:space="preserve">
          <source>The fields in the structure are as follows:</source>
          <target state="translated">구조의 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4eaa6a16da05e6ff18f84c1ebcd0b7aefc5111a7" translate="yes" xml:space="preserve">
          <source>The fields of record &lt;code&gt;mod&lt;/code&gt; have the following meaning:</source>
          <target state="translated">레코드 &lt;code&gt;mod&lt;/code&gt; 의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e9f5d2712650575f495813aa5945d3da6ac26a56" translate="yes" xml:space="preserve">
          <source>The fields referred to in the pattern can be given in any order.</source>
          <target state="translated">패턴에서 참조되는 필드는 임의의 순서로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08db3122b6c1da4a657ae8cba808796dd5cb6b86" translate="yes" xml:space="preserve">
          <source>The fifth argument is the magic cookie.</source>
          <target state="translated">다섯 번째 주장은 마술 쿠키입니다.</target>
        </trans-unit>
        <trans-unit id="9f962ab964ce6cd051f2dbc6e617195062eacc4f" translate="yes" xml:space="preserve">
          <source>The figures in this section illustrate the steps involved in the development of an SNMP agent.</source>
          <target state="translated">이 섹션의 그림은 SNMP 에이전트 개발과 관련된 단계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4cbdd4fa4fa7eb06d2c2cd3f4fc02cfd3c4c58d8" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;FileName&lt;/code&gt; is to be a plain text file and can contain comments and command-line arguments. A comment begins with a &lt;code&gt;#&lt;/code&gt; character and continues until the next end of line character. Backslash (\\) is used as quoting character. All command-line arguments accepted by &lt;code&gt;erl&lt;/code&gt; are allowed, also flag &lt;code&gt;-args_file FileName&lt;/code&gt;. Be careful not to cause circular dependencies between files containing flag &lt;code&gt;-args_file&lt;/code&gt;, though.</source>
          <target state="translated">&lt;code&gt;FileName&lt;/code&gt; 파일 은 일반 텍스트 파일이어야하며 주석과 명령 줄 인수를 포함 할 수 있습니다. 주석은 &lt;code&gt;#&lt;/code&gt; 문자로 시작 하고 다음 행 문자 끝까지 계속됩니다. 백 슬래시 (\\)는 인용 문자로 사용됩니다. 수락 모든 명령 줄 인수 &lt;code&gt;erl&lt;/code&gt; 플래그 또한, 허용되는 &lt;code&gt;-args_file FileName&lt;/code&gt; . 플래그 &lt;code&gt;-args_file&lt;/code&gt; 을 포함하는 파일간에 순환 종속성이 발생하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef2a4ab9b2cbfd5981924e055242be9d6523c2f1" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;appl.erl&lt;/code&gt; is transferred from the remote to the local host. When the session is opened, the current directory at the remote host is &lt;code&gt;/home/guest&lt;/code&gt;, and &lt;code&gt;/home/fred&lt;/code&gt; at the local host. Before transferring the file, the current local directory is changed to &lt;code&gt;/home/eproj/examples&lt;/code&gt;, and the remote directory is set to &lt;code&gt;/home/guest/appl/examples&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;appl.erl&lt;/code&gt; 파일 이 원격에서 로컬 호스트로 전송됩니다. 세션이 열리면 원격 호스트의 현재 디렉토리는 &lt;code&gt;/home/guest&lt;/code&gt; 이고 &lt;code&gt;/home/fred&lt;/code&gt; 는 로컬 호스트입니다. 파일을 전송하기 전에 현재 로컬 디렉토리가 &lt;code&gt;/home/eproj/examples&lt;/code&gt; 로 변경되고 원격 디렉토리가 &lt;code&gt;/home/guest/appl/examples&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="5712e30f3c91d1fa3a6c8c851828ea49909dab0b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;ch_app.appup&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ch_app.appup&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="ed1f252a17bd502cae6f65b494d7abad29887093" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;foo.DCD&lt;/code&gt; has been created. This file will eventually store all data that is written into the &lt;code&gt;foo&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;foo.DCD&lt;/code&gt; 파일 이 생성되었습니다. 이 파일은 결국 &lt;code&gt;foo&lt;/code&gt; 테이블에 기록 된 모든 데이터를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="763e1026cb9b967ac60a197e4f7623ff7204342f" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;macros.tab&lt;/code&gt; contains many useful macros. When implementing new instructions it is good practice to look through &lt;code&gt;macros.tab&lt;/code&gt; to see if any of existing macros can be used rather than re-inventing the wheel.</source>
          <target state="translated">&lt;code&gt;macros.tab&lt;/code&gt; 파일 에는 많은 유용한 매크로가 포함되어 있습니다. 새로운 지침을 구현할 때 &lt;code&gt;macros.tab&lt;/code&gt; 을 살펴보고 휠을 다시 발명하는 대신 기존 매크로를 사용할 수 있는지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cef24f2335b5ba7f0dd2cc5fad1d52fb9d3d09b4" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; is a copy of our &lt;code&gt;mysystem.boot&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;releases/FIRST/start.boot&lt;/code&gt; 파일 은 &lt;code&gt;mysystem.boot&lt;/code&gt; 의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="2b8b8152527aa20a7d4a0566192d86d3094913d9" translate="yes" xml:space="preserve">
          <source>The file cannot be found in any of the directories in &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 의 디렉토리에서 파일을 찾을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fc7fabdf332059e44e2eb17eeef692885d373bdb" translate="yes" xml:space="preserve">
          <source>The file cannot be opened.</source>
          <target state="translated">파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c7f52d78cf6ae35996fa80363be9f75b4e0bd15" translate="yes" xml:space="preserve">
          <source>The file descriptor &lt;strong&gt;has&lt;/strong&gt; to be a real file descriptor. That is, no other operation should be able to get the same file descriptor until it has been released by the &lt;code&gt;close()&lt;/code&gt; callback.</source>
          <target state="translated">파일 기술자 &lt;strong&gt;가&lt;/strong&gt; 실제 파일 기술자가 될 수 있습니다. 즉, &lt;code&gt;close()&lt;/code&gt; 콜백에 의해 해제 될 때까지 다른 작업이 동일한 파일 설명자를 가져올 수 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a9a0257416ae53879f4ba75c38e4782504676962" translate="yes" xml:space="preserve">
          <source>The file descriptor of the socket associated with the port.</source>
          <target state="translated">포트와 연관된 소켓의 파일 디스크립터.</target>
        </trans-unit>
        <trans-unit id="8273bc28b08e309fc9dd43621c30c7519263c61b" translate="yes" xml:space="preserve">
          <source>The file does not exist.</source>
          <target state="translated">파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56db91f9bccb5529a0d13172d3cd82f3fa8e8d12" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the local host.</source>
          <target state="translated">파일은 로컬 호스트에서 동일한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="116b44d8dffe981177c481cc8f3dc87f0f7f4c3e" translate="yes" xml:space="preserve">
          <source>The file gets the same name on the remote host.</source>
          <target state="translated">파일은 원격 호스트에서 동일한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="51b34af4a175f2b4aa90381774d3f18723da3b3d" translate="yes" xml:space="preserve">
          <source>The file includes both version 1, 2 and version 3 messages.</source>
          <target state="translated">파일에는 버전 1, 2 및 버전 3 메시지가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9625a98d2c47b406a8f7769a6753258132546c" translate="yes" xml:space="preserve">
          <source>The file is a directory and the user is not superuser.</source>
          <target state="translated">파일이 디렉토리이고 사용자가 수퍼 유저가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b21cd2436d24bafe2e40702865abc3fbecc09148" translate="yes" xml:space="preserve">
          <source>The file is in both these cases then best processed using the &lt;code&gt;io&lt;/code&gt; module, as the functions in that module can handle code points beyond the ISO Latin-1 range.</source>
          <target state="translated">이 두 가지 경우 모두 파일은 &lt;code&gt;io&lt;/code&gt; 모듈을 사용하여 가장 잘 처리 됩니다. 해당 모듈의 함수는 ISO Latin-1 범위를 벗어난 코드 포인트를 처리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b2eb2fd7e69007e3b27fc3504af5f6bbd478142a" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;LocalFile&lt;/code&gt; on the local host.</source>
          <target state="translated">파일의 이름 은 로컬 호스트에서 &lt;code&gt;LocalFile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1df462cd01acebe1ec004334e0f1a8efe5b7e5b1" translate="yes" xml:space="preserve">
          <source>The file is named &lt;code&gt;RemoteFile&lt;/code&gt; on the remote host.</source>
          <target state="translated">파일 이름 은 원격 호스트에서 &lt;code&gt;RemoteFile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03b686e18d29e8b42dc1dbee506d16c2eb2c5609" translate="yes" xml:space="preserve">
          <source>The file is not opened for reading.</source>
          <target state="translated">읽을 파일이 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0285680290f8aeb50ca6b7cbc6c042e3ad3dd657" translate="yes" xml:space="preserve">
          <source>The file is not opened for writing.</source>
          <target state="translated">파일이 쓰기 위해 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4982f438e094effbe19f49bddea5cc4009fdfdb" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. Every write operation to a file opened with &lt;code&gt;append&lt;/code&gt; takes place at the end of the file.</source>
          <target state="translated">파일이 쓰기 위해 열립니다. 존재하지 않는 경우 작성됩니다. &lt;code&gt;append&lt;/code&gt; 열린 파일에 대한 모든 쓰기 작업은 파일 끝에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d726a268237e91f14236fd6ff2803260e2e1532" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists and &lt;code&gt;write&lt;/code&gt; is not combined with &lt;code&gt;read&lt;/code&gt;, the file is truncated.</source>
          <target state="translated">파일이 쓰기 위해 열립니다. 존재하지 않는 경우 작성됩니다. 파일이 존재하고 &lt;code&gt;write&lt;/code&gt; 가 &lt;code&gt;read&lt;/code&gt; 와 결합되지 않으면 파일이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="a197a2f03b6e053838765608c827205470531e6d" translate="yes" xml:space="preserve">
          <source>The file is opened for writing. It is created if it does not exist. If the file exists, &lt;code&gt;{error, eexist}&lt;/code&gt; is returned.</source>
          <target state="translated">파일이 쓰기 위해 열립니다. 존재하지 않는 경우 작성됩니다. 파일이 존재하면 &lt;code&gt;{error, eexist}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1abdf85470ebe2b741440d62063d01b5682aba19" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file and &lt;code&gt;FullName&lt;/code&gt; is the full name of the file.</source>
          <target state="translated">요청 된 모드에서 파일이 열립니다. &lt;code&gt;IoDevice&lt;/code&gt; 는 파일에 대한 참조이며 &lt;code&gt;FullName&lt;/code&gt; 은 파일 의 전체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7acf8ec21fa42c861a4f88f31a1e3b43a849b057" translate="yes" xml:space="preserve">
          <source>The file is opened in the requested mode. &lt;code&gt;IoDevice&lt;/code&gt; is a reference to the file.</source>
          <target state="translated">요청 된 모드에서 파일이 열립니다. &lt;code&gt;IoDevice&lt;/code&gt; 는 파일에 대한 참조입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
