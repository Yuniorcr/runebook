<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="3435c3c7e119d453781030831229b00d2aae4308" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;seq_trigger_ms(all)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seq_trigger_ms(all)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="12125f862bd88ba67965933061b1e8ffb497058a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stop([])&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;stop([])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35fdfb7f45f55a2469fead73d0b0f2671d97aa22" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;tab2file(Tab, Filename,[])&lt;/code&gt;</source>
          <target state="translated">등가 &lt;code&gt;tab2file(Tab, Filename,[])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b1fd8e3324385e0025a248348ad69eb198a41c5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;to_comment(Tree, Prefix, F)&lt;/code&gt; for a default formatting function &lt;code&gt;F&lt;/code&gt;. The default &lt;code&gt;F&lt;/code&gt; simply calls &lt;code&gt;erl_prettypr:format/1&lt;/code&gt;.</source>
          <target state="translated">기본 형식 지정 함수 &lt;code&gt;F&lt;/code&gt; 의 경우 &lt;code&gt;to_comment(Tree, Prefix, F)&lt;/code&gt; 와 같습니다 . 기본 &lt;code&gt;F&lt;/code&gt; 는 단순히 &lt;code&gt;erl_prettypr:format/1&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="eae2ce8662958c07749c55c574f853292bfec24b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;trace_port_control(Nodename,flush)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace_port_control(Nodename,flush)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d7578f48790610f3c44dbae5fef894577661b5e8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;trace_port_control(node(),Operation)&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;trace_port_control(node(),Operation)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d377ab9696754c5e53d4550bc8ccdd97d5702b7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;tracer(Nodes,[])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tracer(Nodes,[])&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="51dffba3fc75e4144074621aa4d06793ca23672c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;tracer(node())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tracer(node())&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5c92a73c7b7a3415ff776f26258300b95c1f3363" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;write_config(ConfigFile,Config,[])&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;write_config(ConfigFile,Config,[])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26a44d24ef15f8e4aadea7c524d8bd844c799c7a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;{dpr, []}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{dpr, []}&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f2e24525b720a66a0f4cff0fad463acab81e68a5" translate="yes" xml:space="preserve">
          <source>Equivalent to application:start(crypto).</source>
          <target state="translated">application : start (crypto)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="af72cbb19cb1ea6aed8b8fafa57bc55f3386bd44" translate="yes" xml:space="preserve">
          <source>Equivalent to application:stop(crypto).</source>
          <target state="translated">application : stop (crypto)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="a189385c50fd1586960cbb94f70e0e55e00a2f0e" translate="yes" xml:space="preserve">
          <source>Equivalent to calling</source>
          <target state="translated">부름에 해당</target>
        </trans-unit>
        <trans-unit id="50ff0ff33ea3806bd3418b7385cc22ceda26c315" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; repeatedly on all dependencies that are not yet started for an application that is not yet started.</source>
          <target state="translated">아직 시작되지 않은 애플리케이션에 대해 아직 시작되지 않은 모든 종속성에 대해 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; 를 반복적 으로 호출 하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f01934dff95ed0df2af4b1190b1ed1b23bd3d4f" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; repeatedly on all dependencies that are not yet started for an application.</source>
          <target state="translated">아직 애플리케이션에 대해 시작되지 않은 모든 종속성에 대해 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; 를 반복적으로 호출 하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1c95de46e7f37381b50f0f067501b205e4ec058" translate="yes" xml:space="preserve">
          <source>Equivalent to not having configured the callback.</source>
          <target state="translated">콜백을 구성하지 않은 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="309b2ce75ed346c41b0f7688b01e1b9964e51029" translate="yes" xml:space="preserve">
          <source>Equivalent to returning &lt;code&gt;3010&lt;/code&gt;, DIAMETER_UNKNOWN_PEER.</source>
          <target state="translated">DIAMETER_UNKNOWN_PEER &lt;code&gt;3010&lt;/code&gt; 을 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8564df778b76368fd2684cc3f4148709d4d2914e" translate="yes" xml:space="preserve">
          <source>Equivalent to the call &lt;code&gt;&lt;a href=&quot;#crypto_init-4&quot;&gt;crypto_init(Cipher, Key, &amp;lt;&amp;lt;&amp;gt;&amp;gt;, FlagOrOptions)&lt;/a&gt;&lt;/code&gt;. It is intended for ciphers without an IV (nounce).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#crypto_init-4&quot;&gt;crypto_init(Cipher, Key, &amp;lt;&amp;lt;&amp;gt;&amp;gt;, FlagOrOptions)&lt;/a&gt;&lt;/code&gt; 호출과 동일합니다 . IV (nounce)가없는 암호를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b7dccc36149146faa2047d801514181d5f9cac7" translate="yes" xml:space="preserve">
          <source>Equivalent to {0,1}</source>
          <target state="translated">{0,1}과 동일</target>
        </trans-unit>
        <trans-unit id="43cdb03bb51b870ef04d25eaa356f6c9b28794a9" translate="yes" xml:space="preserve">
          <source>Equivalent to {0,}</source>
          <target state="translated">{0,}과 동일</target>
        </trans-unit>
        <trans-unit id="1ad44885e8ba849ee1218be9acaf48c60756d49a" translate="yes" xml:space="preserve">
          <source>Equivalent to {1,}</source>
          <target state="translated">{1,}과 동일</target>
        </trans-unit>
        <trans-unit id="7ff30f443573384e0d479f04dc2df0cb57021fd6" translate="yes" xml:space="preserve">
          <source>Erase the name for the persistent term with key &lt;code&gt;Key&lt;/code&gt;. The return value will be &lt;code&gt;true&lt;/code&gt; if there was a persistent term with the key &lt;code&gt;Key&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if there was no persistent term associated with the key.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 로 영구 용어의 이름을 지 웁니다 . 반환 값은 &lt;code&gt;Key&lt;/code&gt; 에 영구 용어가있는 경우 &lt;code&gt;true&lt;/code&gt; 이고 키 와 연결된 영구 용어가 없으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67472ae3b9ab0c8dab5081fc0a7a9c2a28b9c3e6" translate="yes" xml:space="preserve">
          <source>Erases all items with a given key from a dictionary.</source>
          <target state="translated">사전에서 주어진 키를 가진 모든 항목을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="2389d6e66e1a178c050d5866f28fd99d620e9a07" translate="yes" xml:space="preserve">
          <source>Erases all items with a specified key from a dictionary.</source>
          <target state="translated">사전에서 지정된 키가있는 모든 항목을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="fd14539a55fcb71355bd4e9e655edff6c93ab401" translate="yes" xml:space="preserve">
          <source>Erl_Interface</source>
          <target state="translated">Erl_Interface</target>
        </trans-unit>
        <trans-unit id="73005778a4f4d967ddcff2ebbccae0f463990331" translate="yes" xml:space="preserve">
          <source>Erlang</source>
          <target state="translated">Erlang</target>
        </trans-unit>
        <trans-unit id="d468f8a6d1662b0ace9ee5869e60d86eac8f7f20" translate="yes" xml:space="preserve">
          <source>Erlang Compiler</source>
          <target state="translated">얼랭 컴파일러</target>
        </trans-unit>
        <trans-unit id="07e78ae258d0fee88dd13927dab4e096b0ed5647" translate="yes" xml:space="preserve">
          <source>Erlang Data Type</source>
          <target state="translated">얼랭 데이터 타입</target>
        </trans-unit>
        <trans-unit id="42974f2bb9d18a74ea429f6e95309b53d51adf8d" translate="yes" xml:space="preserve">
          <source>Erlang Debugger for debugging and testing of Erlang programs.</source>
          <target state="translated">Erlang 프로그램의 디버깅 및 테스트를위한 Erlang Debugger.</target>
        </trans-unit>
        <trans-unit id="8f2d761cd21e540e8b0e3336b9b92b81c26e09f3" translate="yes" xml:space="preserve">
          <source>Erlang Debugger.</source>
          <target state="translated">얼랭 디버거.</target>
        </trans-unit>
        <trans-unit id="8d3286fe51409f0b4f2583b6797c1f7db3fee195" translate="yes" xml:space="preserve">
          <source>Erlang Monotonic Time</source>
          <target state="translated">얼랑 단조로운 시간</target>
        </trans-unit>
        <trans-unit id="9c55c16bf805dad66b9e9bfaa7fd0b73d96feb2a" translate="yes" xml:space="preserve">
          <source>Erlang ODBC application</source>
          <target state="translated">Erlang ODBC 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="c359a9304be13082be208b3d09fdb16a104ad53b" translate="yes" xml:space="preserve">
          <source>Erlang Port Mapper Daemon</source>
          <target state="translated">얼랭 포트 매퍼 데몬</target>
        </trans-unit>
        <trans-unit id="51487311d5683bce6222db94d0837e7af2b422c8" translate="yes" xml:space="preserve">
          <source>Erlang Scripting Interface (ESI)</source>
          <target state="translated">Erlang 스크립팅 인터페이스 (ESI)</target>
        </trans-unit>
        <trans-unit id="3f7cddcb48745ba54daa50369446d68368ed182f" translate="yes" xml:space="preserve">
          <source>Erlang Server Interface</source>
          <target state="translated">얼랭 서버 인터페이스</target>
        </trans-unit>
        <trans-unit id="f56c72a2516dcc9b248eaf7b2d27312cd3a95974" translate="yes" xml:space="preserve">
          <source>Erlang Server Interface (ESI) functions provide a tight and efficient interface to the execution of Erlang functions. This interface, on the other hand, is &lt;code&gt;Inets&lt;/code&gt; specific.</source>
          <target state="translated">Erlang 서버 인터페이스 (ESI) 기능은 Erlang 기능 실행을위한 강력하고 효율적인 인터페이스를 제공합니다. 반면 &lt;code&gt;Inets&lt;/code&gt; 인터페이스는 Inets 전용입니다.</target>
        </trans-unit>
        <trans-unit id="0bba9cc20749d74fe42699272a7007ef30cb1510" translate="yes" xml:space="preserve">
          <source>Erlang System Time</source>
          <target state="translated">얼랭 시스템 시간</target>
        </trans-unit>
        <trans-unit id="a3a844688808d03cad721cc5dff89792d0f7e174" translate="yes" xml:space="preserve">
          <source>Erlang Top</source>
          <target state="translated">얼랭 탑</target>
        </trans-unit>
        <trans-unit id="1b6617db302d2231ecda1838479a85b3fc8ddbc5" translate="yes" xml:space="preserve">
          <source>Erlang Top is a tool for presenting information about Erlang processes similar to the information presented by &quot;top&quot; in UNIX.</source>
          <target state="translated">Erlang Top은 UNIX에서 &quot;top&quot;으로 표시되는 정보와 유사한 Erlang 프로세스에 대한 정보를 제공하는 도구입니다.</target>
        </trans-unit>
        <trans-unit id="187ed2e2dd100a53b1edf9eb7daca74ec4d62361" translate="yes" xml:space="preserve">
          <source>Erlang Top, &lt;code&gt;etop&lt;/code&gt;, is a tool for presenting information about Erlang processes similar to the information presented by &lt;code&gt;top&lt;/code&gt; in UNIX.</source>
          <target state="translated">&lt;code&gt;etop&lt;/code&gt; 인 Erlang Top 은 UNIX에서 &lt;code&gt;top&lt;/code&gt; 이 제공하는 정보와 유사한 Erlang 프로세스에 대한 정보를 제공하는 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="cdc0797038958d6766acff3fe7dd54d7bdc38d68" translate="yes" xml:space="preserve">
          <source>Erlang alternate representation of PKIX certificate, also referred to as &lt;code&gt;otp&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;otp&lt;/code&gt; 유형 이라고도하는 PKIX 인증서의 얼랭 대체 표현</target>
        </trans-unit>
        <trans-unit id="6bb00551b7c8a13bac98d39fc44b7d468d8e58e6" translate="yes" xml:space="preserve">
          <source>Erlang archive files can contain entire Erlang applications or parts of applications. The structure in an archive file is the same as the directory structure for an application. If you, for example, create an archive of &lt;code&gt;mnesia-4.4.7&lt;/code&gt;, the archive file must be named &lt;code&gt;mnesia-4.4.7.ez&lt;/code&gt; and it must contain a top directory named &lt;code&gt;mnesia-4.4.7&lt;/code&gt;. If the version part of the name is omitted, it must also be omitted in the archive. That is, a &lt;code&gt;mnesia.ez&lt;/code&gt; archive must contain a &lt;code&gt;mnesia&lt;/code&gt; top directory.</source>
          <target state="translated">Erlang 아카이브 파일에는 전체 Erlang 응용 프로그램 또는 응용 프로그램의 일부가 포함될 수 있습니다. 아카이브 파일의 구조는 응용 프로그램의 디렉토리 구조와 동일합니다. 예를 들어, &lt;code&gt;mnesia-4.4.7&lt;/code&gt; 의 아카이브를 작성하는 경우 아카이브 파일의 이름은 &lt;code&gt;mnesia-4.4.7.ez&lt;/code&gt; 여야하고 &lt;code&gt;mnesia-4.4.7&lt;/code&gt; 이라는 최상위 디렉토리를 포함해야합니다 . 이름의 버전 부분을 생략하면 아카이브에서도 생략해야합니다. 즉, &lt;code&gt;mnesia.ez&lt;/code&gt; 아카이브는 &lt;code&gt;mnesia&lt;/code&gt; 최상위 디렉토리를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d19420b4f26bc25d3f2b589c3db03baaba26b7a" translate="yes" xml:space="preserve">
          <source>Erlang assembler source code. It generates a &lt;code&gt;.beam&lt;/code&gt; file.</source>
          <target state="translated">얼랭 어셈블러 소스 코드. &lt;code&gt;.beam&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2b8e5109d4052fa7d4dbe33fd696c214d943ce0c" translate="yes" xml:space="preserve">
          <source>Erlang code is divided into &lt;strong&gt;modules&lt;/strong&gt;. A module consists of a sequence of attributes and function declarations, each terminated by period (.).</source>
          <target state="translated">Erlang 코드는 &lt;strong&gt;모듈&lt;/strong&gt; 로 나뉩니다 . 모듈은 일련의 속성과 함수 선언으로 구성되며 각각은 마침표 (.)로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="e3580f7edee6c63255527cb40cf39998af0eb91c" translate="yes" xml:space="preserve">
          <source>Erlang code server.</source>
          <target state="translated">얼랭 코드 서버.</target>
        </trans-unit>
        <trans-unit id="a8b6ae591b2da2cd08772f799d4fead6ed20372d" translate="yes" xml:space="preserve">
          <source>Erlang core source code. It generates a &lt;code&gt;.beam&lt;/code&gt; file.</source>
          <target state="translated">Erlang 핵심 소스 코드. &lt;code&gt;.beam&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="16513f82d634670fc9605c2661f8b142d4a02889" translate="yes" xml:space="preserve">
          <source>Erlang does not have a string data type. Instead, strings can be represented by lists of Unicode characters. This implies for example that the list &lt;code&gt;[97,98,99]&lt;/code&gt; is equivalent to &quot;abc&quot;. The Erlang shell is &quot;clever&quot; and guesses what list you mean and outputs it in what it thinks is the most appropriate form, for example:</source>
          <target state="translated">Erlang에는 문자열 데이터 유형이 없습니다. 대신, 문자열은 유니 코드 문자 목록으로 표시 될 수 있습니다. 예를 들어 목록 &lt;code&gt;[97,98,99]&lt;/code&gt; 는 &quot;abc&quot;와 같습니다. Erlang 쉘은 &quot;영리한&quot;이며 의미하는 목록을 추측하여 가장 적합한 형식으로 생각합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e644faa020a368af8ed4f13a6fd7ee4f1d44e74" translate="yes" xml:space="preserve">
          <source>Erlang drivers and NIF-shared objects still cannot be named with names containing code points &amp;gt; 127. This limitation will be removed in a future release. However, Erlang modules can, but it is definitely not a good idea and is still considered experimental.</source>
          <target state="translated">Erlang 드라이버와 NIF 공유 객체는 여전히 코드 포인트&amp;gt; 127를 포함하는 이름으로 이름을 지정할 수 없습니다.이 제한은 다음 릴리스에서 제거 될 것입니다. 그러나 Erlang 모듈은 가능하지만 좋은 생각은 아니며 여전히 실험적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a9687abee379f1b2fda3153a94bdccbeb5044d34" translate="yes" xml:space="preserve">
          <source>Erlang error logger.</source>
          <target state="translated">Erlang 오류 로거.</target>
        </trans-unit>
        <trans-unit id="ce6e28755c8636a9c1a78be038968d61ca25b8ec" translate="yes" xml:space="preserve">
          <source>Erlang has a built-in feature for error handling between processes. Terminating processes emit exit signals to all linked processes, which can terminate as well or handle the exit in some way. This feature can be used to build hierarchical program structures where some processes are supervising other processes, for example, restarting them if they terminate abnormally.</source>
          <target state="translated">Erlang에는 프로세스 간 오류 처리를위한 기능이 내장되어 있습니다. 종료 프로세스는 종료 된 신호를 링크 된 모든 프로세스로 방출합니다.이 프로세스는 종료되거나 어떤 식 으로든 종료를 처리 할 수 ​​있습니다. 이 기능은 일부 프로세스가 다른 프로세스를 감독하는 계층 적 프로그램 구조를 구축하는 데 사용할 수 있습니다 (예 : 비정상적으로 종료 된 경우 다시 시작).</target>
        </trans-unit>
        <trans-unit id="d2f1997af9697075030acd004bcc111b8be8ff81" translate="yes" xml:space="preserve">
          <source>Erlang has a copying semi-space garbage collector. This means that when doing a garbage collection, the terms are copied from one distinct area, called the &lt;strong&gt;from space&lt;/strong&gt;, to a new clean area, called the &lt;strong&gt;to space&lt;/strong&gt;. The collector starts by &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1980&quot;&gt;scanning the root-set&lt;/a&gt;&lt;/code&gt; (stack, registers, etc).</source>
          <target state="translated">Erlang에는 복사 세미 스페이스 가비지 수집기가 있습니다. 이것은 가비지 콜렉션을 수행 할 때 용어가 &lt;strong&gt;from space&lt;/strong&gt; 라는 별개의 영역 에서 &lt;strong&gt;to space&lt;/strong&gt; 라는 새로운 깨끗한 영역 으로 복사됨을 의미합니다 . 수집기는 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1980&quot;&gt;scanning the root-set&lt;/a&gt;&lt;/code&gt; (스택, 레지스터 등) 를 스캔하여 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="0ebc560c3bfda11ba0b7129d9ef5900027353cef" translate="yes" xml:space="preserve">
          <source>Erlang has many standard modules to help you do things. For example, the module &lt;code&gt;io&lt;/code&gt; contains many functions that help in doing formatted input/output. To look up information about standard modules, the command &lt;code&gt;erl -man&lt;/code&gt; can be used at the operating shell or command prompt (the same place as you started &lt;code&gt;erl&lt;/code&gt;). Try the operating system shell command:</source>
          <target state="translated">Erlang에는 작업 수행에 도움이되는 많은 표준 모듈이 있습니다. 예를 들어, 모듈 &lt;code&gt;io&lt;/code&gt; 에는 형식화 된 입력 / 출력을 수행하는 데 도움이되는 많은 기능이 있습니다. 표준 모듈에 대한 정보를 찾으려면 &lt;code&gt;erl -man&lt;/code&gt; 명령을 운영 쉘 또는 명령 프롬프트에서 사용할 수 있습니다 ( &lt;code&gt;erl&lt;/code&gt; 을 시작한 곳과 동일 ). 운영 체제 쉘 명령을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="5108e42bb50a05f01c9a9144f64dfb14695b92d1" translate="yes" xml:space="preserve">
          <source>Erlang has similarities to XSLT since both languages have a functional programming approach.</source>
          <target state="translated">Erlang은 두 언어 모두 기능적인 프로그래밍 방식을 가지고 있기 때문에 XSLT와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="54da91f3063c85844ca2da712c147bc53ed995f2" translate="yes" xml:space="preserve">
          <source>Erlang has similarities to XSLT since both languages have a functional programming approach. Using &lt;code&gt;xmerl_xpath&lt;/code&gt; it is possible to write XSLT like transforms in Erlang.</source>
          <target state="translated">Erlang은 두 언어 모두 기능적인 프로그래밍 방식을 가지고 있기 때문에 XSLT와 유사합니다. &lt;code&gt;xmerl_xpath&lt;/code&gt; 를 사용하면 Erlang에서 XSLT와 같은 변환을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64af78c4b1b41cbbf7a74b3dce63a615349c373a" translate="yes" xml:space="preserve">
          <source>Erlang http server service start/stop</source>
          <target state="translated">Erlang http 서버 서비스 시작 / 중지</target>
        </trans-unit>
        <trans-unit id="765bdb0001f58fd4e091acc6a98e058df60ec1d0" translate="yes" xml:space="preserve">
          <source>Erlang interface towards epmd</source>
          <target state="translated">epmd를 향한 Erlang 인터페이스</target>
        </trans-unit>
        <trans-unit id="3689b2e7d9d045e61ec0c9d2ec01ad9fd859b5d2" translate="yes" xml:space="preserve">
          <source>Erlang is a dynamically typed language. Still, it comes with a notation for declaring sets of Erlang terms to form a particular type. This effectively forms specific subtypes of the set of all Erlang terms.</source>
          <target state="translated">Erlang은 동적으로 유형이 지정된 언어입니다. 그러나 특정 유형을 형성하기 위해 Erlang 용어 세트를 선언하는 표기법이 제공됩니다. 이를 통해 모든 Erlang 용어 집합의 특정 하위 유형이 효과적으로 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="44d2d5a61dc6457e1bdbd30ffd05f99721b445df" translate="yes" xml:space="preserve">
          <source>Erlang is designed for massive concurrency. Erlang processes are lightweight (grow and shrink dynamically) with small memory footprint, fast to create and terminate, and the scheduling overhead is low.</source>
          <target state="translated">Erlang은 대규모 동시성을 위해 설계되었습니다. Erlang 프로세스는 메모리 사용량이 적고 작성 및 종료가 빠르며 가벼우 며 (동적 확장 및 축소) 스케줄링 오버 헤드가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="bc5bee2abda059985daa5adfd52b696f8c537b55" translate="yes" xml:space="preserve">
          <source>Erlang is started with &lt;code&gt;ex2.config&lt;/code&gt; as configuration and we check the default set of algorithms before starting ssh:</source>
          <target state="translated">Erlang은 구성 으로 &lt;code&gt;ex2.config&lt;/code&gt; 로 시작되며 ssh를 시작하기 전에 기본 알고리즘 집합을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c6840288d1fb39fbdf54c46257efa463f93fa5b7" translate="yes" xml:space="preserve">
          <source>Erlang libraries (for example, file handling).</source>
          <target state="translated">Erlang 라이브러리 (예 : 파일 처리)</target>
        </trans-unit>
        <trans-unit id="a71829eb95cf63e3985cd27a8c6a2a813caca043" translate="yes" xml:space="preserve">
          <source>Erlang manages dynamic memory with a &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tracing_garbage_collection&quot;&gt;tracing garbage collector&lt;/a&gt;&lt;/code&gt;. More precisely a per process generational semi-space copying collector using Cheney's copy collection algorithm together with a global large object space. (See C. J. Cheney in &lt;code&gt;&lt;a href=&quot;#References&quot;&gt;References&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Erlang은 &lt;code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tracing_garbage_collection&quot;&gt;tracing garbage collector&lt;/a&gt;&lt;/code&gt; 동적 메모리를 관리합니다 . 보다 정확하게는 Cheney의 복사 수집 알고리즘을 전역 대형 객체 공간과 함께 사용하는 프로세스 별 세대 별 세미 공간 복사 수집기입니다. (참고 문헌의 CJ Cheney를 &lt;code&gt;&lt;a href=&quot;#References&quot;&gt;References&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="fcf0f0cf0019dc2c84ba4e7fff6df4fc0d3a3352" translate="yes" xml:space="preserve">
          <source>Erlang mode for Emacs</source>
          <target state="translated">이맥스에 대한 얼랭 모드</target>
        </trans-unit>
        <trans-unit id="e08c0abcaf6055f73df5bed0a508f68c997e28c6" translate="yes" xml:space="preserve">
          <source>Erlang monotonic time as such is new as from ERTS 7.0. It is introduced to detach time measurements, such as elapsed time from calendar time. In many use cases there is a need to measure elapsed time or specify a time relative to another point in time without the need to know the involved times in UTC or any other globally defined time scale. By introducing a time scale with a local definition of where it starts, time that do not concern calendar time can be managed on that time scale. Erlang monotonic time uses such a time scale with a locally defined start.</source>
          <target state="translated">얼랭 단조 시간은 ERTS 7.0부터 새로운 기능입니다. 달력 시간에서 경과 시간과 같은 시간 측정을 분리하기 위해 도입되었습니다. 많은 사용 사례에서 경과 시간을 측정하거나 UTC 또는 기타 세계적으로 정의 된 다른 시간 척도로 관련 시간을 알 필요없이 다른 특정 시점에 상대적인 시간을 지정해야합니다. 시작 시간에 대한 로컬 정의가있는 시간 척도를 도입하면 달력 시간과 관련이없는 시간을 해당 시간 척도에서 관리 할 수 ​​있습니다. 얼랭 단조 시간은 현지에서 정의 된 시작과 같은 시간 척도를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3d7c91bd498cf4f960de9d850e22a4c729687a73" translate="yes" xml:space="preserve">
          <source>Erlang network authentication server.</source>
          <target state="translated">Erlang 네트워크 인증 서버.</target>
        </trans-unit>
        <trans-unit id="29517dc6e2f8e2e0a4ff1233ee7c1466861445b4" translate="yes" xml:space="preserve">
          <source>Erlang networking kernel.</source>
          <target state="translated">얼랭 네트워킹 커널.</target>
        </trans-unit>
        <trans-unit id="62e719f2ccde088494394ba096cbfcf921b94352" translate="yes" xml:space="preserve">
          <source>Erlang nodes can communicate across at least two preceding and two subsequent releases.</source>
          <target state="translated">Erlang 노드는 최소한 두 개의 이전 릴리스와 두 개의 후속 릴리스에서 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e1ad4149d3076204cf6d8721d6a7b0e6aedb3e7" translate="yes" xml:space="preserve">
          <source>Erlang ports conceptually are very similar to Erlang processes. Erlang processes execute Erlang code in the virtual machine, while an Erlang port execute native code typically used for communication with the outside world. For example, when an Erlang process wants to communicate using TCP over the network, it communicates via an Erlang port implementing the TCP socket interface in native code. Both Erlang Processes and Ports communicate using asynchronous signaling. The native code executed by an Erlang port is a collection of callback functions, called a driver. Each callback more or less implements the code of a signal to, or from the port.</source>
          <target state="translated">Erlang 포트는 개념적으로 Erlang 프로세스와 매우 유사합니다. Erlang 프로세스는 가상 머신에서 Erlang 코드를 실행하는 반면 Erlang 포트는 일반적으로 외부 세계와의 통신에 사용되는 네이티브 코드를 실행합니다. 예를 들어, Erlang 프로세스가 네트워크를 통해 TCP를 사용하여 통신하려는 경우 원시 코드에서 TCP 소켓 인터페이스를 구현하는 Erlang 포트를 통해 통신합니다. Erlang 프로세스와 포트는 모두 비동기 신호를 사용하여 통신합니다. Erlang 포트에 의해 실행되는 네이티브 코드는 드라이버라고하는 콜백 함수 모음입니다. 각 콜백은 포트에서 또는 포트에서 보내는 신호 코드를 어느 정도 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c182e6ec8e232fd8d468621cfed562e80c94232b" translate="yes" xml:space="preserve">
          <source>Erlang process</source>
          <target state="translated">얼랭 프로세스</target>
        </trans-unit>
        <trans-unit id="e87b1cdc2bee4003f12076e20d8786d64b08abdc" translate="yes" xml:space="preserve">
          <source>Erlang programs must be &lt;strong&gt;compiled&lt;/strong&gt; to object code. The compiler can generate a new file that contains the object code. The current abstract machine, which runs the object code, is called BEAM, therefore the object files get the suffix &lt;code&gt;.beam&lt;/code&gt;. The compiler can also generate a binary which can be loaded directly.</source>
          <target state="translated">Erlang 프로그램은 객체 코드 로 &lt;strong&gt;컴파일&lt;/strong&gt; 해야합니다 . 컴파일러는 객체 코드가 포함 된 새 파일을 생성 할 수 있습니다. 객체 코드를 실행하는 현재 추상 시스템을 BEAM이라고하며 객체 파일의 접미어는 &lt;code&gt;.beam&lt;/code&gt; 입니다. 컴파일러는 직접로드 할 수있는 바이너리를 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8327cd2cd6abd4152e444c64366c2297e16ac1e9" translate="yes" xml:space="preserve">
          <source>Erlang provides a number of data types, which are listed in this section.</source>
          <target state="translated">Erlang은이 섹션에 나열된 여러 데이터 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="60affb0517ad2f1e7a6e468d34c6cf5a5d797985" translate="yes" xml:space="preserve">
          <source>Erlang records the following data in a local database if found in system &lt;code&gt;inet&lt;/code&gt; configuration files (or system registry):</source>
          <target state="translated">Erlang은 시스템 &lt;code&gt;inet&lt;/code&gt; 구성 파일 (또는 시스템 레지스트리) 에있는 경우 다음 데이터를 로컬 데이터베이스에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="1291d12522a9a2448a438bb6ce42d1e9cd92828f" translate="yes" xml:space="preserve">
          <source>Erlang representation of &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3447.txt&quot;&gt; Rivest-Shamir-Adleman cryptosystem (RSA)&lt;/a&gt;&lt;/code&gt; keys follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3447.txt&quot;&gt; Rivest-Shamir-Adleman cryptosystem (RSA)&lt;/a&gt;&lt;/code&gt; 키 의 Erlang 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a76284d96d97fb63bf3fb9bc0a624b9d6415224e" translate="yes" xml:space="preserve">
          <source>Erlang representation of &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc6979.txt&quot;&gt;Digital Signature Algorithm (DSA)&lt;/a&gt;&lt;/code&gt; keys</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc6979.txt&quot;&gt;Digital Signature Algorithm (DSA)&lt;/a&gt;&lt;/code&gt; 키 의 얼랭 표현</target>
        </trans-unit>
        <trans-unit id="94414c346ee46d48c4cf5bab52d492c3b501407a" translate="yes" xml:space="preserve">
          <source>Erlang representation of &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc6979.txt&quot;&gt;Elliptic Curve Digital Signature Algorithm (ECDSA)&lt;/a&gt;&lt;/code&gt; keys follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc6979.txt&quot;&gt;Elliptic Curve Digital Signature Algorithm (ECDSA)&lt;/a&gt;&lt;/code&gt; 키 의 얼랭 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15d2a8b937fdd18453b5bd06e5c5ba28f1d01b2b" translate="yes" xml:space="preserve">
          <source>Erlang representation of &lt;code&gt;Asn1Type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Asn1Type&lt;/code&gt; 의 얼랭 표현</target>
        </trans-unit>
        <trans-unit id="b0155a7a701bcba47e3587c70dd05599e2474e91" translate="yes" xml:space="preserve">
          <source>Erlang representation of &lt;code&gt;Asn1Type&lt;/code&gt;. If &lt;code&gt;Asn1Type&lt;/code&gt; is 'SubjectPublicKeyInfo', &lt;code&gt;Entity&lt;/code&gt; must be either an &lt;code&gt;rsa_public_key()&lt;/code&gt;, &lt;code&gt;dsa_public_key()&lt;/code&gt; or an &lt;code&gt;ec_public_key()&lt;/code&gt; and this function creates the appropriate 'SubjectPublicKeyInfo' entry.</source>
          <target state="translated">&lt;code&gt;Asn1Type&lt;/code&gt; 의 얼랭 표현 . 경우 &lt;code&gt;Asn1Type&lt;/code&gt; 가 'SubjectPublicKeyInfo로'이며, &lt;code&gt;Entity&lt;/code&gt; 의 어느 쪽인가이어야 &lt;code&gt;rsa_public_key()&lt;/code&gt; , &lt;code&gt;dsa_public_key()&lt;/code&gt; 또는 &lt;code&gt;ec_public_key()&lt;/code&gt; ,이 함수는 해당 'SubjectPublicKeyInfo로'항목을 생성한다.</target>
        </trans-unit>
        <trans-unit id="cc60c93e27f6c8b3751a0b9be2aef0b7c9ee6585" translate="yes" xml:space="preserve">
          <source>Erlang representation of CRL and CRL extensions profile derived from ASN.1 specifications and RFC 5280 are as follows:</source>
          <target state="translated">ASN.1 사양 및 RFC 5280에서 파생 된 CRL 및 CRL 확장 프로파일의 Erlang 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e7a74773d5822d3f5d9f95c718279c0a8e5cadf" translate="yes" xml:space="preserve">
          <source>Erlang representation of PKIX certificates derived from ASN.1 specifications see also &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;X509 certificates (RFC 5280)&lt;/a&gt;&lt;/code&gt;, also referred to as &lt;code&gt;plain&lt;/code&gt; type, are as follows:</source>
          <target state="translated">ASN.1 사양에서 파생 된 PKIX 인증서의 Erlang 표현은 &lt;code&gt;plain&lt;/code&gt; 유형 이라고도하는 &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;X509 certificates (RFC 5280)&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49096fc777911b9b7aae166d989d964697ae34bf" translate="yes" xml:space="preserve">
          <source>Erlang representation of a PKCS#10 certification request derived from ASN.1 specifications and RFC 5280 are as follows:</source>
          <target state="translated">ASN.1 사양 및 RFC 5280에서 파생 된 PKCS # 10 인증 요청의 Erlang 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85c25f9ae8fa9d9d39662ad16e02609d37617181" translate="yes" xml:space="preserve">
          <source>Erlang scripting support</source>
          <target state="translated">Erlang 스크립팅 지원</target>
        </trans-unit>
        <trans-unit id="68d6ef608f1df29338cbe204521ef8e485792adf" translate="yes" xml:space="preserve">
          <source>Erlang shell</source>
          <target state="translated">얼랭 껍질</target>
        </trans-unit>
        <trans-unit id="3ec6f33c2c87d2614a5f14675e151dcb88d2f6d2" translate="yes" xml:space="preserve">
          <source>Erlang source code. It generates a &lt;code&gt;.beam&lt;/code&gt; file.</source>
          <target state="translated">얼랭 소스 코드. &lt;code&gt;.beam&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="394f59990698b35f3acf15e5b4733929802b64a2" translate="yes" xml:space="preserve">
          <source>Erlang ssl application is able to use private keys provided by OpenSSL engines using the following mechanism:</source>
          <target state="translated">Erlang ssl 애플리케이션은 다음 메커니즘을 사용하여 OpenSSL 엔진에서 제공하는 개인 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="864cda352b2b7242047a4bdfcdd2ac33213d752a" translate="yes" xml:space="preserve">
          <source>Erlang strings in ISO Latin-1 are a subset of Unicode strings.</source>
          <target state="translated">ISO Latin-1의 Erlang 문자열은 유니 코드 문자열의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="65e5587caf81453e386959f97bcab82d41c225ab" translate="yes" xml:space="preserve">
          <source>Erlang style &lt;code&gt;comments&lt;/code&gt;, starting with a &lt;code&gt;'%'&lt;/code&gt;, are allowed in grammar files.</source>
          <target state="translated">문법 파일 에는 &lt;code&gt;'%'&lt;/code&gt; 로 시작하는 얼랭 스타일 &lt;code&gt;comments&lt;/code&gt; 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="aac9baf56b360fdfc2b9cc3c5cbc1d06e716f4d2" translate="yes" xml:space="preserve">
          <source>Erlang style comments starting with a &lt;code&gt;%&lt;/code&gt; are allowed in scanner files. A definition file has the following format:</source>
          <target state="translated">스캐너 파일 에는 &lt;code&gt;%&lt;/code&gt; 로 시작하는 얼랭 스타일 주석 이 허용됩니다. 정의 파일의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba2ee1db7cfb83a9a28a4d5fc176d79a34ec95de" translate="yes" xml:space="preserve">
          <source>Erlang supports change of code in a running system. Code replacement is done on module level.</source>
          <target state="translated">Erlang은 실행중인 시스템에서 코드 변경을 지원합니다. 코드 교체는 모듈 수준에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8d4d4b448e1b670d768db4e0a92608c3a95454" translate="yes" xml:space="preserve">
          <source>Erlang terms are encoded with a 1 byte tag that identifies the type of object, a 2- or 4-byte length field, and then the data itself. Specifically:</source>
          <target state="translated">Erlang 용어는 객체 유형, 2 바이트 또는 4 바이트 길이 필드를 식별 한 다음 데이터 자체를 식별하는 1 바이트 태그로 인코딩됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="95649cce77176d28bea4f7f9813a087c9d5bff06" translate="yes" xml:space="preserve">
          <source>Erlang test suite - skeleton for a callback module for the erlang test server.</source>
          <target state="translated">Erlang 테스트 스위트-Erlang 테스트 서버를위한 콜백 모듈의 골격.</target>
        </trans-unit>
        <trans-unit id="dc86f979a787632108431c41a594f7100fff02e9" translate="yes" xml:space="preserve">
          <source>Erlang tracer behavior.</source>
          <target state="translated">얼랭 추적기 동작.</target>
        </trans-unit>
        <trans-unit id="52a8e38416f8a3016af48ad3490b37ffcfecba30" translate="yes" xml:space="preserve">
          <source>Erlang tracing is a seething pile of pain that involves reasonably complex knowledge of clever ports, tracing return formats, and specialized tracing &lt;code&gt;MatchSpecs&lt;/code&gt; (which are really their own special kind of hell). The tracing mechanism is very powerful indeed, but it can be hard to grasp.</source>
          <target state="translated">Erlang 추적은 영리한 포트, 추적 반환 형식 및 특수 추적 &lt;code&gt;MatchSpecs&lt;/code&gt; (실제로 자신의 특별한 종류)에 대한 합리적으로 복잡한 지식이 포함 된 끔찍한 고통 입니다. 추적 메커니즘은 실제로 매우 강력하지만 파악하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddceda35765ee0227c5090e371d8fdc61546e8f1" translate="yes" xml:space="preserve">
          <source>Erlang web server api callback functions</source>
          <target state="translated">Erlang 웹 서버 API 콜백 함수</target>
        </trans-unit>
        <trans-unit id="608a17c106581ea476e7483075a6103aecf265ea" translate="yes" xml:space="preserve">
          <source>Erlang web server api data types</source>
          <target state="translated">Erlang 웹 서버 API 데이터 유형</target>
        </trans-unit>
        <trans-unit id="2b3867adf6f8205f09a3bd49e01fbcbdbf9da4fb" translate="yes" xml:space="preserve">
          <source>Erlang web server api help functions</source>
          <target state="translated">Erlang 웹 서버 API 도움말 기능</target>
        </trans-unit>
        <trans-unit id="e977ff78a62ba0710c1b49f898ec553c8ecf5674" translate="yes" xml:space="preserve">
          <source>Erlang web server internal API for handling of, for example, interaction data exported by module &lt;code&gt;mod_alias&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;mod_alias&lt;/code&gt; 에 의해 반출 된 상호 작용 데이터를 처리하기위한 Erlang 웹 서버 내부 API .</target>
        </trans-unit>
        <trans-unit id="9a307b26f697b741dfa644bc3ed165306ce52304" translate="yes" xml:space="preserve">
          <source>Erlang's selective receive statement is often used to describe simple state machine examples in straightforward Erlang code. The following is a possible implementation of the first example:</source>
          <target state="translated">Erlang의 선택적 receive 문은 간단한 상태 머신 예제를 간단한 Erlang 코드로 설명하는 데 종종 사용됩니다. 다음은 첫 번째 예의 가능한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="33ba7d54e0f96d8437a94bb12fde30675b3aea12" translate="yes" xml:space="preserve">
          <source>Erlang, like most modern functional programming languages, has higher-order functions. Here is an example using the shell:</source>
          <target state="translated">대부분의 최신 기능 프로그래밍 언어와 마찬가지로 Erlang은 고차 기능을 가지고 있습니다. 다음은 쉘을 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="724caea7c7c627b75c378f119b8867f452d18c46" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 21.0</source>
          <target state="translated">얼랭 / OTP 21.0</target>
        </trans-unit>
        <trans-unit id="a37aa0b2d81504b1c55927908b1946024faaaea8" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 21.0 provides a standard API for logging through &lt;code&gt;Logger&lt;/code&gt;, which is part of the Kernel application. Logger consists of the API for issuing log events, and a customizable backend where log handlers, filters and formatters can be plugged in.</source>
          <target state="translated">Erlang / OTP 21.0은 커널 애플리케이션의 일부인 &lt;code&gt;Logger&lt;/code&gt; 를 통한 로깅을위한 표준 API를 제공합니다 . 로거는 로그 이벤트를 발행하기위한 API와 로그 핸들러, 필터 및 포맷터를 연결할 수있는 사용자 정의 가능한 백엔드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0370d36afb3ca9b24b17404852fd441ad337e632" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 23.2</source>
          <target state="translated">얼랭 / OTP 23.2</target>
        </trans-unit>
        <trans-unit id="4201df51d957ddf617682f4a2c5fb78010bb6804" translate="yes" xml:space="preserve">
          <source>Erlang/OTP R14B01 added support for Unicode filenames, but it was not complete and was by default disabled on platforms where no guarantee was given for the filename encoding.</source>
          <target state="translated">Erlang / OTP R14B01은 유니 코드 파일 이름에 대한 지원을 추가했지만 파일 이름 인코딩에 대해 보증이 제공되지 않은 플랫폼에서는 완전하지 않으며 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="81b7aeec5d6a5cc979cd67b4207b7f88c8c95d10" translate="yes" xml:space="preserve">
          <source>Erlang/OTP R7B and later versions have provision for asynchronous function calls, using a thread pool provided by Erlang. There is also a select call, which can be used for asynchronous drivers.</source>
          <target state="translated">Erlang / OTP R7B 이상 버전은 Erlang이 제공하는 스레드 풀을 사용하여 비동기 함수 호출을 제공합니다. 비동기 드라이버에 사용할 수있는 선택 호출도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ff106d6880e027ac3e49797ee7acb3586fabd6f" translate="yes" xml:space="preserve">
          <source>Erlang/OTP adds a either padding of zeroes or padding with random bytes.</source>
          <target state="translated">Erlang / OTP는 0의 패딩 또는 임의의 바이트로 패딩을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c0713309ba690b66cdaebc859af475a2f049b598" translate="yes" xml:space="preserve">
          <source>Erlang/OTP comes with a number of components, each implementing some specific functionality. Components are with Erlang/OTP terminology called &lt;strong&gt;applications&lt;/strong&gt;. Examples of Erlang/OTP applications are Mnesia, which has everything needed for programming database services, and Debugger, which is used to debug Erlang programs. The minimal system based on Erlang/OTP consists of the following two applications:</source>
          <target state="translated">Erlang / OTP에는 여러 가지 구성 요소가 있으며 각각 특정 기능을 구현합니다. 구성 요소에는 &lt;strong&gt;응용 프로그램&lt;/strong&gt; 이라는 Erlang / OTP 용어가 있습니다. Erlang / OTP 어플리케이션의 예로는 데이터베이스 서비스 프로그래밍에 필요한 모든 것이있는 Mnesia와 Erlang 프로그램을 디버그하는 데 사용되는 디버거가 있습니다. Erlang / OTP 기반의 최소 시스템은 다음 두 가지 애플리케이션으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="abc2ca56e7a524de500413e513bdee4913c85b3e" translate="yes" xml:space="preserve">
          <source>Erlang/OTP comes with these boot scripts:</source>
          <target state="translated">Erlang / OTP는 다음 부팅 스크립트와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cf8121d23c3e906780a36e5718d7e3f386d37baa" translate="yes" xml:space="preserve">
          <source>Erlang/OTP contains several tools to help finding bottlenecks:</source>
          <target state="translated">Erlang / OTP에는 병목 현상을 찾는 데 도움이되는 몇 가지 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd1ed92f97b5afe6df18bf3120dc1851420ed9d8" translate="yes" xml:space="preserve">
          <source>Erlang/OTP has two operators for testing term equality: &lt;code&gt;==/2&lt;/code&gt; and &lt;code&gt;=:=/2&lt;/code&gt;. The difference is all about the integers that can be represented by floats. For example, &lt;code&gt;2 == 2.0&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt; while &lt;code&gt;2 =:= 2.0&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;. Normally this is a minor issue, but the &lt;code&gt;qlc&lt;/code&gt; module cannot ignore the difference, which affects the user's choice of operators in QLCs.</source>
          <target state="translated">Erlang / OTP에는 항등 성을 테스트하기위한 두 개의 연산자가 있습니다 : &lt;code&gt;==/2&lt;/code&gt; 및 &lt;code&gt;=:=/2&lt;/code&gt; . 차이점은 부동 소수점으로 나타낼 수있는 정수에 관한 것입니다. 예를 들어 &lt;code&gt;2 == 2.0&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 로 평가 되고 &lt;code&gt;2 =:= 2.0&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 로 평가됩니다 . 일반적으로 이것은 사소한 문제이지만 &lt;code&gt;qlc&lt;/code&gt; 모듈은 차이를 무시할 수 없으므로 QLC에서 사용자의 운영자 선택에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a238d21f86456ced8fadcb5e34be74b0e08d60ed" translate="yes" xml:space="preserve">
          <source>Erlang/OTP is divided into a number of OTP applications. An application normally contains Erlang modules. Some OTP applications, such as the C interface &lt;em&gt;erl_interface&lt;/em&gt;, are written in other languages and have no Erlang modules.</source>
          <target state="translated">Erlang / OTP는 여러 OTP 응용 프로그램으로 나뉩니다. 응용 프로그램에는 일반적으로 Erlang 모듈이 포함되어 있습니다. C 인터페이스 &lt;em&gt;erl_interface&lt;/em&gt; 와 같은 일부 OTP 애플리케이션 은 다른 언어로 작성되며 Erlang 모듈이 없습니다.</target>
        </trans-unit>
        <trans-unit id="26162178bace97f7fcf849f4c1571479f8bb59d9" translate="yes" xml:space="preserve">
          <source>Erlang/OTP is not installed on the remote host.</source>
          <target state="translated">Erlang / OTP가 원격 호스트에 설치되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e4edf668c9d05d04fe084e0a31ec6b936a6bcd3" translate="yes" xml:space="preserve">
          <source>Erlang/OTP itself provides implementations of native atomic memory operations that can be used when compiling with a &lt;code&gt;gcc&lt;/code&gt; compatible compiler for 32/64-bit x86, 32/64-bit SPARC V9, 32-bit PowerPC, or 32-bit Tile. When compiling with a &lt;code&gt;gcc&lt;/code&gt; compatible compiler for other architectures, the VM may be able to make use of native atomic operations using the &lt;code&gt;__atomic_*&lt;/code&gt; builtins (may be available when using a &lt;code&gt;gcc&lt;/code&gt; of at least version 4.7) and/or using the &lt;code&gt;__sync_*&lt;/code&gt; builtins (may be available when using a &lt;code&gt;gcc&lt;/code&gt; of at least version 4.1). If only the &lt;code&gt;gcc&lt;/code&gt;'s &lt;code&gt;__sync_*&lt;/code&gt; builtins are available, the performance will suffer. Such a configuration should only be used as a last resort. When compiling on Windows using a MicroSoft Visual C++ compiler native atomic memory operations are provided by Windows APIs.</source>
          <target state="translated">Erlang / OTP 자체는 32/64 비트 x86, 32/64 비트 SPARC V9, 32 비트 PowerPC 또는 32 비트 타일 용 &lt;code&gt;gcc&lt;/code&gt; 호환 컴파일러로 컴파일 할 때 사용할 수있는 기본 원자 메모리 연산 구현을 제공합니다 . 로 컴파일 할 때 &lt;code&gt;gcc&lt;/code&gt; 가 다른 아키텍처와 호환 컴파일러는 VM이 사용하는 기본 원자 작업을 사용 할 수 있습니다 &lt;code&gt;__atomic_*&lt;/code&gt; (A 사용하는 경우 사용할 수 있습니다 내장 명령을 &lt;code&gt;gcc&lt;/code&gt; 및 / 또는 사용 적어도 버전 4.7)를 &lt;code&gt;__sync_*&lt;/code&gt; 내장 명령 ( 버전 4.1 이상의 &lt;code&gt;gcc&lt;/code&gt; 를 사용할 때 사용 가능할 수 있음 ). 단지의 경우 &lt;code&gt;gcc&lt;/code&gt; 의 &lt;code&gt;__sync_*&lt;/code&gt; 내장을 사용할 수 있으며 성능이 저하됩니다. 이러한 구성은 최후의 수단으로 만 사용해야합니다. Windows에서 MicroSoft Visual C ++ 컴파일러를 사용하여 Windows에서 컴파일 할 때 기본 원자 메모리 조작이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="88359713fcd187262d19eaa372ae57551f27bfc9" translate="yes" xml:space="preserve">
          <source>Erlang/OTP, version R13B01 or later.</source>
          <target state="translated">Erlang / OTP, 버전 R13B01 이상.</target>
        </trans-unit>
        <trans-unit id="00f13ff419cbefda4c6c03f79ee9281c4cf709dd" translate="yes" xml:space="preserve">
          <source>Error Bit</source>
          <target state="translated">에러 비트</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="eba935f75ab2141800c78b960ea4ba301639db3b" translate="yes" xml:space="preserve">
          <source>Error Handling Between Processes</source>
          <target state="translated">프로세스 간 오류 처리</target>
        </trans-unit>
        <trans-unit id="cdca065cbff5a828b04d0e4e49d1dcd5d7786c66" translate="yes" xml:space="preserve">
          <source>Error Handling Within Processes</source>
          <target state="translated">프로세스 내 오류 처리</target>
        </trans-unit>
        <trans-unit id="b9327ae340ba5e93e3a8ec3e3644f86f25a0245a" translate="yes" xml:space="preserve">
          <source>Error Information</source>
          <target state="translated">오류 정보</target>
        </trans-unit>
        <trans-unit id="a8d5b0c8bf1ebd0f07d81f6875b4394f8135c380" translate="yes" xml:space="preserve">
          <source>Error cause</source>
          <target state="translated">오류 원인</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="9841f72db77d7dfc5d8fbb51c62aad7af9f607bd" translate="yes" xml:space="preserve">
          <source>Error handling is to be added here, for example, checking that the socket is still open, but this is only a simple example.</source>
          <target state="translated">소켓이 여전히 열려 있는지 확인하는 등의 오류 처리가 여기에 추가되지만 이는 단순한 예일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="b3c84d111f976acfbfdf69a2f3abdbf1e0500d30" translate="yes" xml:space="preserve">
          <source>Error in compiled code, &lt;code&gt;beam&lt;/code&gt; file damaged, or error in the compiler.</source>
          <target state="translated">컴파일 된 코드 오류, &lt;code&gt;beam&lt;/code&gt; 파일 손상 또는 컴파일러 오류</target>
        </trans-unit>
        <trans-unit id="496993d2f19645c9091ecc3aa210dbe3356845b1" translate="yes" xml:space="preserve">
          <source>Error information from the runtime system, that is, information about a process terminating because of an uncaught error exception, is by default written to terminal (tty):</source>
          <target state="translated">런타임 시스템의 오류 정보, 즉 catch되지 않은 오류 예외로 인해 종료되는 프로세스에 대한 정보는 기본적으로 터미널 (tty)에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="639e8ce426bc737468b74dc7c7bfaa46dc241c4b" translate="yes" xml:space="preserve">
          <source>Error logger also adds a &lt;code&gt;domain&lt;/code&gt; field with value &lt;code&gt;[Type]&lt;/code&gt; to this event's metadata, causing the filters of the default Logger handler to discard the event. A different Logger handler, or an error logger event handler, must be added to handle this event.</source>
          <target state="translated">또한 오류 로거는 이 이벤트의 메타 데이터에 &lt;code&gt;[Type]&lt;/code&gt; 값을 가진 &lt;code&gt;domain&lt;/code&gt; 필드를 추가 하여 기본 로거 핸들러의 필터가 이벤트를 버리도록합니다. 이 이벤트를 처리하려면 다른 로거 핸들러 또는 오류 로거 이벤트 핸들러를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9977542e45ff52428157c2369ca0bc9dccc2b506" translate="yes" xml:space="preserve">
          <source>Error logger forwards the event to Logger, including metadata that allows backwards compatibility with legacy error logger event handlers.</source>
          <target state="translated">오류 로거는 레거시 오류 로거 이벤트 핸들러와의 하위 호환성을 허용하는 메타 데이터를 포함하여 이벤트를 로거에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a77bbf54ef645a291af8493dbb1d5fc073efc973" translate="yes" xml:space="preserve">
          <source>Error logger is no longer started by default, but is automatically started when an event handler is added with &lt;code&gt;&lt;a href=&quot;#add_report_handler-1&quot;&gt; add_report_handler/1,2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error_logger&lt;/code&gt; module is then also added as a handler to the new logger, causing log events to be forwarded from logger to error logger, and consequently to all installed error logger event handlers.</source>
          <target state="translated">오류 로거는 더 이상 기본적으로 시작되지 않지만 이벤트 핸들러가 &lt;code&gt;&lt;a href=&quot;#add_report_handler-1&quot;&gt; add_report_handler/1,2&lt;/a&gt;&lt;/code&gt; 로 추가되면 자동으로 시작됩니다 . &lt;code&gt;error_logger&lt;/code&gt; 의 모듈은 다음 또한 로그 이벤트는 오류 로거 로거에서 전달되는 원인이 새로운 로거에 대한 처리기로 추가되고, 결과적으로 설치된 모든 오류 로거 이벤트 핸들러.</target>
        </trans-unit>
        <trans-unit id="bc63651aa2a97a276609497fbbd0346eefff84ec" translate="yes" xml:space="preserve">
          <source>Error logger is no longer started by default, but is automatically started when an event handler is added with &lt;code&gt;&lt;a href=&quot;#add_report_handler-1&quot;&gt;add_report_handler/1,2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error_logger&lt;/code&gt; module is then also added as a handler to the new logger, causing log events to be forwarded from logger to error logger, and consequently to all installed error logger event handlers.</source>
          <target state="translated">오류 로거는 더 이상 기본적으로 시작되지 않지만 &lt;code&gt;&lt;a href=&quot;#add_report_handler-1&quot;&gt;add_report_handler/1,2&lt;/a&gt;&lt;/code&gt; 로 이벤트 핸들러를 추가하면 자동으로 시작됩니다 . &lt;code&gt;error_logger&lt;/code&gt; 의 모듈은 다음 또한 로그 이벤트는 오류 로거 로거에서 전달되는 원인이 새로운 로거에 대한 처리기로 추가되고, 결과적으로 설치된 모든 오류 로거 이벤트 핸들러.</target>
        </trans-unit>
        <trans-unit id="f590673e3f81ff0de939209e8c1411495d888f75" translate="yes" xml:space="preserve">
          <source>Error logging</source>
          <target state="translated">오류 기록</target>
        </trans-unit>
        <trans-unit id="39fd0fff48bcdc526e470bce9996f806cffba66e" translate="yes" xml:space="preserve">
          <source>Error message &lt;code&gt;no_such_log&lt;/code&gt; means that the specified disk log is not open. Nothing is said about whether the disk log files exist or not.</source>
          <target state="translated">오류 메시지 &lt;code&gt;no_such_log&lt;/code&gt; 는 지정된 디스크 로그가 열려 있지 않음을 의미합니다. 디스크 로그 파일의 존재 여부에 대해서는 아무 것도 언급되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c16c465d099c60331de2e4b62e170e774878a5f" translate="yes" xml:space="preserve">
          <source>Error print routines.</source>
          <target state="translated">인쇄 루틴 오류.</target>
        </trans-unit>
        <trans-unit id="175d732720bb2b9ce4139516e31e0e7de404f821" translate="yes" xml:space="preserve">
          <source>Error responses from phase one will not affect the current encryption state of the connection. Those responses are:</source>
          <target state="translated">1 단계의 오류 응답은 연결의 현재 암호화 상태에 영향을 미치지 않습니다. 그 답변은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc407ac87a50f6f1cb8813ded47a2237216209a5" translate="yes" xml:space="preserve">
          <source>Error texts are returned on channel-type 1 which usually is piped to &lt;code&gt;stderr&lt;/code&gt; on e.g Linux systems. Texts from a successful execution are returned on channel-type 0 and will in similar manner be piped to &lt;code&gt;stdout&lt;/code&gt;. The exit-status code is set to 0 for success and 255 for errors. The exact results presented on the client side depends on the client and the client's operating system.</source>
          <target state="translated">오류 텍스트는 일반적으로 Linux 시스템 에서 &lt;code&gt;stderr&lt;/code&gt; 로 파이프되는 채널 유형 1에서 리턴됩니다 . 성공적인 실행의 텍스트는 채널 유형 0에서 반환되며 유사한 방식으로 &lt;code&gt;stdout&lt;/code&gt; 로 파이프됩니다 . 종료 상태 코드는 성공의 경우 0으로, 오류의 경우 255로 설정됩니다. 클라이언트 측에 표시되는 정확한 결과는 클라이언트와 클라이언트의 운영 체제에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="248a0c0dec551ac1544ee55c87419da834b070bd" translate="yes" xml:space="preserve">
          <source>Error texts are returned on channel-type 1 which usually is piped to &lt;code&gt;stderr&lt;/code&gt; on e.g Linux systems. Texts from a successful execution will in similar manner be piped to &lt;code&gt;stdout&lt;/code&gt;. The exit-status code is set to 0 for success and -1 for errors. The exact results presented on the client side depends on the client and the client's operating system.</source>
          <target state="translated">Linux 시스템과 같이 &lt;code&gt;stderr&lt;/code&gt; 로 파이프되는 채널 유형 1에 오류 텍스트가 리턴됩니다 . 성공적인 실행의 텍스트는 비슷한 방식으로 &lt;code&gt;stdout&lt;/code&gt; 으로 파이프됩니다 . 종료 상태 코드는 성공으로 0, 오류로 -1로 설정됩니다. 클라이언트 측에 표시되는 정확한 결과는 클라이언트와 클라이언트 운영 체제에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c5162f960eaa3903c9aa79d1009292052fe0d91d" translate="yes" xml:space="preserve">
          <source>Error tuple indicating the type of error. Possible values of the second component:</source>
          <target state="translated">오류 유형을 나타내는 오류 튜플. 두 번째 구성 요소의 가능한 값 :</target>
        </trans-unit>
        <trans-unit id="791a69f19a69a95d78745770545e8504ba8e369a" translate="yes" xml:space="preserve">
          <source>Error types</source>
          <target state="translated">오류 유형</target>
        </trans-unit>
        <trans-unit id="c0badf4d3cb54e5993b49d582242405e5f94e8ad" translate="yes" xml:space="preserve">
          <source>Error with error code in &lt;code&gt;errno&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 의 오류 코드 오류</target>
        </trans-unit>
        <trans-unit id="78b085a1df80396e71f3adf0641d42f27e66adf9" translate="yes" xml:space="preserve">
          <source>Error, &lt;code&gt;badarg&lt;/code&gt;</source>
          <target state="translated">오류, &lt;code&gt;badarg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7784e7ae6084691f1646dc4a8244e866d12d88e5" translate="yes" xml:space="preserve">
          <source>Error-Message AVP</source>
          <target state="translated">오류 메시지 AVP</target>
        </trans-unit>
        <trans-unit id="36f0eba0495b4acdb4f3510131bb067a1134370c" translate="yes" xml:space="preserve">
          <source>Error-Reporting-Host AVP</source>
          <target state="translated">오류보고 호스트 AVP</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="cf7c257161b6f7846270c6cdc8d3241e43fc4f5f" translate="yes" xml:space="preserve">
          <source>Errors and exceptions occur as in &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt; characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but the second element in tuple &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;incomplete&lt;/code&gt; is a &lt;code&gt;binary()&lt;/code&gt; and not a &lt;code&gt;list()&lt;/code&gt;.</source>
          <target state="translated">오류 및 예외는 &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt; characters_to_list/2&lt;/a&gt;&lt;/code&gt; 에서와 같이 발생 하지만 튜플 &lt;code&gt;error&lt;/code&gt; 또는 &lt;code&gt;incomplete&lt;/code&gt; 두 번째 요소 는 &lt;code&gt;list()&lt;/code&gt; 가 아니라 &lt;code&gt;binary()&lt;/code&gt; () 입니다.</target>
        </trans-unit>
        <trans-unit id="45c5077316970972e1b57db18c00ca9dcce84b89" translate="yes" xml:space="preserve">
          <source>Errors and exceptions occur as in &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but the second element in tuple &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;incomplete&lt;/code&gt; is a &lt;code&gt;binary()&lt;/code&gt; and not a &lt;code&gt;list()&lt;/code&gt;.</source>
          <target state="translated">오류와 예외가 발생할 같이 &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt; 이지만 튜플의 두 번째 요소 &lt;code&gt;error&lt;/code&gt; 또는 &lt;code&gt;incomplete&lt;/code&gt; A는 &lt;code&gt;binary()&lt;/code&gt; 가 아니라 &lt;code&gt;list()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ea4e0cabd7710ec1eeb5a59e0efc86816c8ac2" translate="yes" xml:space="preserve">
          <source>Errors are reported differently for asynchronous log attempts and other uses of the &lt;code&gt;disk_log&lt;/code&gt; module. When used synchronously, this module replies with an error message, but when called asynchronously, this module does not know where to send the error message. Instead, owners subscribing to notifications receive an &lt;code&gt;error_status&lt;/code&gt; message.</source>
          <target state="translated">비동기 로그 시도 및 기타 &lt;code&gt;disk_log&lt;/code&gt; 모듈 사용에 대해 오류가 다르게보고 됩니다. 동 기적으로 사용될 때이 모듈은 오류 메시지로 응답하지만 비동기 적으로 호출 될 때 오류 메시지를 보낼 위치를 모릅니다. 대신 알림을 구독하는 소유자는 &lt;code&gt;error_status&lt;/code&gt; 메시지를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="f53a647e231f03245b04c614f9cd71627c52be9d" translate="yes" xml:space="preserve">
          <source>Errors can occur for various reasons, including the following:</source>
          <target state="translated">다음과 같은 여러 가지 이유로 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3996c425aad218b73071a74049a8c0b13e440c8e" translate="yes" xml:space="preserve">
          <source>Errors can roughly be divided into four different types:</source>
          <target state="translated">오류는 크게 네 가지 유형으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d90643c78f3e3b8be248597bc645ab1ae89ee4" translate="yes" xml:space="preserve">
          <source>Errors detected at compile-time are displayed on the screen together with line numbers indicating where in the source file the respective error was detected. If no errors are found, an Erlang ASN.1 module is created.</source>
          <target state="translated">컴파일 타임에 감지 된 오류는 소스 파일에서 해당 오류가 감지 된 위치를 나타내는 행 번호와 함께 화면에 표시됩니다. 오류가 없으면 Erlang ASN.1 모듈이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="31c61a29f2eabfdc1dd9e720efb9d7d06e09ced5" translate="yes" xml:space="preserve">
          <source>Errors detected at decode of an incoming message, as identified by a corresponding 5xxx series Result-Code (Permanent Failures). For an incoming request, these should be used to formulate an appropriate answer as documented for the &lt;code&gt;handle_request/3&lt;/code&gt; callback in &lt;code&gt;diameter_app(3)&lt;/code&gt;. For an incoming answer, the &lt;code&gt;&lt;a href=&quot;diameter#application_opt&quot;&gt;diameter:application_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;answer_errors&lt;/code&gt; determines the behaviour.</source>
          <target state="translated">해당 5xxx 시리즈 결과 코드 (영구 실패)로 식별되는 수신 메시지의 디코딩시 오류가 감지되었습니다. 들어오는 요청의 경우 이들을 사용하여 &lt;code&gt;diameter_app(3)&lt;/code&gt; 의 &lt;code&gt;handle_request/3&lt;/code&gt; 콜백에 대해 문서화 된 적절한 응답을 공식화해야합니다 . 들어오는 답변의 경우 &lt;code&gt;&lt;a href=&quot;diameter#application_opt&quot;&gt;diameter:application_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;answer_errors&lt;/code&gt; 가 동작을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="010ed185a2d162465cc0ce0b4b8aa2a3fd96c350" translate="yes" xml:space="preserve">
          <source>Errors discovered by the ODBC driver - If calls to the ODBC-driver fails due to circumstances that can not be controlled by the Erlang ODBC application programmer, an error string will be dug up from the driver. This string will be the &lt;code&gt;Reason&lt;/code&gt; in the &lt;code&gt;{error, Reason}&lt;/code&gt; return value. How good this error message is will of course be driver dependent. Examples of such circumstances are trying to insert the same key twice, invalid SQL-queries and that the database has gone off line.</source>
          <target state="translated">ODBC 드라이버가 발견 한 오류-Erlang ODBC 응용 프로그램 프로그래머가 제어 할 수없는 상황으로 인해 ODBC 드라이버 호출에 실패하면 드라이버에서 오류 문자열이 파기됩니다. 이 문자열은 될 것입니다 &lt;code&gt;Reason&lt;/code&gt; 에서 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 값. 이 오류 메시지가 얼마나 좋은지는 물론 드라이버에 따라 다릅니다. 이러한 상황의 예는 동일한 키를 두 번 삽입하고 유효하지 않은 SQL 쿼리를 시도했으며 데이터베이스가 오프라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="5d626c84b97772a6774cb12c20d20611b4bf6b2f" translate="yes" xml:space="preserve">
          <source>Errors discovered by the ODBC driver - If calls to the ODBC-driver fails due to circumstances that cannot be controlled by the Erlang ODBC application programmer, an error string will be dug up from the driver. This string will be the &lt;code&gt;Reason&lt;/code&gt; in the &lt;code&gt;{error, Reason}&lt;/code&gt; return value. How good this error message is will of course be driver dependent. Examples of such circumstances are trying to insert the same key twice, invalid SQL-queries and that the database has gone off line.</source>
          <target state="translated">ODBC 드라이버에서 발견 된 오류-Erlang ODBC 응용 프로그램 프로그래머가 제어 할 수없는 상황으로 인해 ODBC 드라이버 호출이 실패하면 드라이버에서 오류 문자열이 검색됩니다. 이 문자열은 될 것입니다 &lt;code&gt;Reason&lt;/code&gt; 에서 &lt;code&gt;{error, Reason}&lt;/code&gt; 반환 값. 물론이 오류 메시지가 얼마나 좋은지는 운전자에 따라 다릅니다. 이러한 상황의 예로는 동일한 키를 두 번 삽입하려고 시도하고 잘못된 SQL 쿼리를 시도하고 데이터베이스가 오프라인 상태가되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f0f1f5888854ffc35c09cc9193ab7f680c3f6cd" translate="yes" xml:space="preserve">
          <source>Errors in the second phase will however end the connection:</source>
          <target state="translated">그러나 두 번째 단계의 오류는 연결을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="9c0f5bdd035851c9a2609fc02b643227fd96cb56" translate="yes" xml:space="preserve">
          <source>Errors occur for the following reasons:</source>
          <target state="translated">다음과 같은 이유로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="333ab74cacfd43c2053abbfca396c78273891243" translate="yes" xml:space="preserve">
          <source>Errors when loading the callback module is handled in different ways depending on how the restricted shell is activated:</source>
          <target state="translated">콜백 모듈을로드 할 때 발생하는 오류는 제한된 쉘이 활성화되는 방법에 따라 다른 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b67ac26ee09de27a753d6d1cddc8caee5a47e6fc" translate="yes" xml:space="preserve">
          <source>Erts specific configuration. See application level options below.</source>
          <target state="translated">특정 구성을 시작합니다. 아래의 응용 프로그램 수준 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="a01558f834c010dceb8bf9e5bbb6298a94594c3d" translate="yes" xml:space="preserve">
          <source>Escape (hex 1B)</source>
          <target state="translated">탈출 (16 진수 1B)</target>
        </trans-unit>
        <trans-unit id="67425f3fc09d5ba38f92d36a3d5af7553c1b88a0" translate="yes" xml:space="preserve">
          <source>Escape.</source>
          <target state="translated">Escape.</target>
        </trans-unit>
        <trans-unit id="79d974e085d4ddcf78e187e4a378b9fe39f97aea" translate="yes" xml:space="preserve">
          <source>Escript files can be added, edited or deleted. This is done by selecting the line where the path to an escript file is displayed and clicking the right mouse button. Choose add, edit or delete in the menu that pops up. New escripts can also be added by selecting the line &lt;code&gt;Escript files&lt;/code&gt; and clicking the right mouse button. Choose add in the menu that pops up.</source>
          <target state="translated">스크립트 파일을 추가, 편집 또는 삭제할 수 있습니다. escript 파일의 경로가 표시되는 행을 선택하고 마우스 오른쪽 버튼을 클릭하면됩니다. 팝업 메뉴에서 추가, 편집 또는 삭제를 선택하십시오. 줄 &lt;code&gt;Escript files&lt;/code&gt; 을 선택하고 마우스 오른쪽 버튼을 클릭하여 새 escript를 추가 할 수도 있습니다 . 팝업 메뉴에서 추가를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="1529f77453dd8025f2dc5c866ce1b0237ae561b5" translate="yes" xml:space="preserve">
          <source>Escript specific configuration. An escript has a mandatory file name and escript level options that are described below.</source>
          <target state="translated">스크립트 별 구성. escript에는 아래 설명 된 필수 파일 이름 및 escript 레벨 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="02d8fbbe4bb9d16643ea1b274f4a27c88dbdc47e" translate="yes" xml:space="preserve">
          <source>Especially if &lt;code&gt;read_line/1&lt;/code&gt; is to be used on a &lt;code&gt;raw&lt;/code&gt; file, it is recommended to combine this option with option &lt;code&gt;{read_ahead, Size}&lt;/code&gt; as line-oriented I/O is inefficient without buffering.</source>
          <target state="translated">특히 &lt;code&gt;read_line/1&lt;/code&gt; 이 &lt;code&gt;raw&lt;/code&gt; 파일에서 사용되는 경우 , 행 지향 I / O가 버퍼링없이 비효율적이기 때문에이 옵션을 &lt;code&gt;{read_ahead, Size}&lt;/code&gt; 옵션과 결합하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a97f1993f795aad7d958e8c30ce30957ba32ad45" translate="yes" xml:space="preserve">
          <source>Essentially those &lt;code&gt;.tab&lt;/code&gt; files define:</source>
          <target state="translated">기본적으로 이러한 &lt;code&gt;.tab&lt;/code&gt; 파일은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1fe378495971b1da6fa994754332b783d8bd92cd" translate="yes" xml:space="preserve">
          <source>Establish a &quot;virtual&quot; connection</source>
          <target state="translated">&quot;가상&quot;연결 설정</target>
        </trans-unit>
        <trans-unit id="fcb93f5e646ee0b5e426c8887d88c062fa9c7e80" translate="yes" xml:space="preserve">
          <source>Established Automata Theory does not deal much with how a &lt;strong&gt;state transition&lt;/strong&gt; is triggered, but assumes that the output is a function of the input (and the state) and that they are some kind of values.</source>
          <target state="translated">Established Automata Theory는 &lt;strong&gt;상태 전환&lt;/strong&gt; 이 트리거되는 방식을 많이 다루지 않지만 출력이 입력 (및 상태)의 함수이고 일종의 값이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ad07376a44e1ad875e3b1dc0e6c9b97f9f2cae85" translate="yes" xml:space="preserve">
          <source>Established Automata Theory does not deal much with how a state transition is triggered, but assumes that the output is a function of the input (and the state) and that they are some kind of values.</source>
          <target state="translated">확립 된 Automata Theory는 상태 전이가 트리거되는 방식을 많이 다루지 않지만 출력은 입력 (및 상태)의 함수이며 어떤 종류의 값이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cb0854bbf324d9cf45d6a1f72d7b27b62be601e1" translate="yes" xml:space="preserve">
          <source>Establishes a connection to &lt;code&gt;Node&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if a connection was established or was already established or if &lt;code&gt;Node&lt;/code&gt; is the local node itself. Returns &lt;code&gt;false&lt;/code&gt; if the connection attempt failed, and &lt;code&gt;ignored&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 에 대한 연결을 설정합니다 . 연결이 설정되었거나 이미 설정되었거나 &lt;code&gt;Node&lt;/code&gt; 가 로컬 노드 자체 인 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 연결 시도가 실패하면 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 로컬 노드가 활성 상태가 아니면 &lt;code&gt;ignored&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="30d59ec1427585ded92ecb580ddfcf1f8baf5e0c" translate="yes" xml:space="preserve">
          <source>Establishes a connection to &lt;code&gt;Node&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; if not, and &lt;code&gt;ignored&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 에 대한 연결을 설정합니다 . 반환 &lt;code&gt;true&lt;/code&gt; 성공하는 경우, &lt;code&gt;false&lt;/code&gt; 이 아니라면, 그리고 &lt;code&gt;ignored&lt;/code&gt; 로컬 노드가 살아 있지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="c3ec2861ccfadb381a463232dcf6f321848b34a4" translate="yes" xml:space="preserve">
          <source>Establishes a new association for socket &lt;code&gt;Socket&lt;/code&gt;, with the peer (SCTP server socket) specified by &lt;code&gt;Addr&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt;, is expressed in milliseconds. A socket can be associated with multiple peers.</source>
          <target state="translated">&lt;code&gt;Addr&lt;/code&gt; 및 &lt;code&gt;Port&lt;/code&gt; 로 지정된 피어 (SCTP 서버 소켓)를 사용하여 소켓 &lt;code&gt;Socket&lt;/code&gt; 에 대한 새로운 연관을 설정합니다 . &lt;code&gt;Timeout&lt;/code&gt; 은 밀리 초로 표시됩니다. 소켓은 여러 피어와 연관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00db4029ecd811c05343cf8c7a310ae8a67ce3ec" translate="yes" xml:space="preserve">
          <source>Establishing a connection (ssh:connect et al) or starting a daemon (ssh:daemon)</source>
          <target state="translated">연결 설정 (ssh : connect 등) 또는 데몬 시작 (ssh : daemon)</target>
        </trans-unit>
        <trans-unit id="4dc2b41f9f62ae24f4ee1bdb98221a2c0df13e48" translate="yes" xml:space="preserve">
          <source>Ethiopic</source>
          <target state="translated">Ethiopic</target>
        </trans-unit>
        <trans-unit id="90fdae5c8a9bb06da32fa2f7b95792f9f1b0e769" translate="yes" xml:space="preserve">
          <source>Ets table</source>
          <target state="translated">ETS 테이블</target>
        </trans-unit>
        <trans-unit id="2f60a0607f41a772b32626fcd9af95377e60dffa" translate="yes" xml:space="preserve">
          <source>Evaluate any expressions before starting the test.</source>
          <target state="translated">테스트를 시작하기 전에 모든 표현식을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="eb8ea7896b33d449e264919d9bcd631090b1fdd3" translate="yes" xml:space="preserve">
          <source>Evaluate each &lt;code&gt;ActionTerm&lt;/code&gt; in the same way as the &lt;code&gt;MatchConditions&lt;/code&gt;, but ignore the return values. Regardless of what happens in this part, the match has succeeded.</source>
          <target state="translated">&lt;code&gt;MatchConditions&lt;/code&gt; 와 동일한 방식으로 각 &lt;code&gt;ActionTerm&lt;/code&gt; 을 평가 하지만 반환 값은 무시하십시오. 이 부분에서 일어나는 일에 관계없이 경기는 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="3a5ea62563bab660614ffd1fad208c7a58ff1100" translate="yes" xml:space="preserve">
          <source>Evaluate each &lt;code&gt;MatchCondition&lt;/code&gt; (where only &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; variables previously bound in the &lt;code&gt;MatchHead&lt;/code&gt; part can occur) and expect it to return the atom &lt;code&gt;true&lt;/code&gt;. When a condition does not evaluate to &lt;code&gt;true&lt;/code&gt;, the match fails. If any BIF call generates an exception, the match also fails.</source>
          <target state="translated">각 &lt;code&gt;MatchCondition&lt;/code&gt; ( &lt;code&gt;MatchHead&lt;/code&gt; 파트 에 이전에 바인딩 된 &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; 변수 만 발생할 수 있음)을 평가하고 atom &lt;code&gt;true&lt;/code&gt; 를 리턴 할 것으로 예상하십시오 . 조건이 &lt;code&gt;true&lt;/code&gt; 로 평가되지 않으면 일치가 실패합니다. BIF 호출이 예외를 생성하면 일치도 실패합니다.</target>
        </trans-unit>
        <trans-unit id="aac8f6b10ed12a4c561d3f9dd94e7c5c7b163cc7" translate="yes" xml:space="preserve">
          <source>Evaluate the expressions in order and return the value of the last expression (typically there is only one expression in this context).</source>
          <target state="translated">순서대로 표현식을 평가하고 마지막 표현식의 값을 리턴하십시오 (일반적으로이 컨텍스트에는 하나의 표현식 만 있음).</target>
        </trans-unit>
        <trans-unit id="320a98f40b213cd2e550ffe03d7477c1d54038d0" translate="yes" xml:space="preserve">
          <source>Evaluate the following lines only if &lt;code&gt;Macro&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;Macro&lt;/code&gt; 가 정의 된 경우에만 다음 줄을 평가하십시오 .</target>
        </trans-unit>
        <trans-unit id="15d3d37a1174660d21728e9897f6f8adebc66260" translate="yes" xml:space="preserve">
          <source>Evaluate the following lines only if &lt;code&gt;Macro&lt;/code&gt; is not defined.</source>
          <target state="translated">&lt;code&gt;Macro&lt;/code&gt; 가 정의되지 않은 경우에만 다음 줄을 평가하십시오 .</target>
        </trans-unit>
        <trans-unit id="31974ecd27e63ca9472a0ef2140076495bf64b20" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Expr&lt;/code&gt; and matches the result against &lt;code&gt;GuardedPattern&lt;/code&gt;, if testing is enabled. If the match fails, an informative exception will be generated; see the &lt;code&gt;assert&lt;/code&gt; macro for further details. &lt;code&gt;GuardedPattern&lt;/code&gt; can be anything that you can write on the left hand side of the &lt;code&gt;-&amp;gt;&lt;/code&gt; symbol in a case-clause, except that it cannot contain comma-separated guard tests.</source>
          <target state="translated">테스트가 활성화 된 경우 &lt;code&gt;Expr&lt;/code&gt; 을 평가 하고 &lt;code&gt;GuardedPattern&lt;/code&gt; 에 대해 결과를 일치시킵니다 . 일치하지 않으면 유익한 예외가 생성됩니다. 자세한 내용은 &lt;code&gt;assert&lt;/code&gt; 매크로를 참조하십시오. &lt;code&gt;GuardedPattern&lt;/code&gt; 은 쉼표로 구분 된 가드 테스트를 포함 할 수 없다는 점을 제외하고는 케이스 절에서 &lt;code&gt;-&amp;gt;&lt;/code&gt; 기호 의 왼쪽에 쓸 수있는 모든 것일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="186d1d12038f51f269dca6fecb6562d5fb223ff2" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Expr&lt;/code&gt;, catching any exception and testing that it matches the expected &lt;code&gt;ClassPattern:TermPattern&lt;/code&gt;. If the match fails, or if no exception is thrown by &lt;code&gt;Expr&lt;/code&gt;, an informative exception will be generated; see the &lt;code&gt;assert&lt;/code&gt; macro for further details. The &lt;code&gt;assertError&lt;/code&gt;, &lt;code&gt;assertExit&lt;/code&gt;, and &lt;code&gt;assertThrow&lt;/code&gt; macros, are equivalent to using &lt;code&gt;assertException&lt;/code&gt; with a &lt;code&gt;ClassPattern&lt;/code&gt; of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, or &lt;code&gt;throw&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;Expr&lt;/code&gt; 을 평가 하여 예외를 포착하고 예상되는 &lt;code&gt;ClassPattern:TermPattern&lt;/code&gt; 과 일치하는지 테스트합니다 . 일치하지 않거나 &lt;code&gt;Expr&lt;/code&gt; 에서 예외가 발생하지 않으면 유익한 예외가 생성됩니다. 자세한 내용은 &lt;code&gt;assert&lt;/code&gt; 매크로를 참조하십시오. &lt;code&gt;assertError&lt;/code&gt; , &lt;code&gt;assertExit&lt;/code&gt; 및 &lt;code&gt;assertThrow&lt;/code&gt; 의 매크로는, 사용하는 것과 동일하다 &lt;code&gt;assertException&lt;/code&gt; 을 로 &lt;code&gt;ClassPattern&lt;/code&gt; 의 &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; , 또는 &lt;code&gt;throw&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="34c8cffaf67a90bfdc80a24acff0bae4a32b64c6" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Expression&lt;/code&gt; with the set of bindings &lt;code&gt;Bindings&lt;/code&gt;. &lt;code&gt;Expression&lt;/code&gt; is an expression in abstract syntax. For an explanation of when and how to use arguments &lt;code&gt;LocalFunctionHandler&lt;/code&gt; and &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt;, see sections &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt; Local Function Handler&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt; Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; in this module.</source>
          <target state="translated">바인딩 집합을 사용하여 &lt;code&gt;Expression&lt;/code&gt; 을 평가 &lt;code&gt;Bindings&lt;/code&gt; . Bindings . &lt;code&gt;Expression&lt;/code&gt; 은 추상 구문의 표현식입니다. &lt;code&gt;LocalFunctionHandler&lt;/code&gt; 및 &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; 인수를 사용하는시기와 방법에 대한 설명은 이 모듈의 &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt; Local Function Handler&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt; Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; 로컬 함수 처리기 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0885bf046c38a399b1d97365e2c513324eb197cc" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Expression&lt;/code&gt; with the set of bindings &lt;code&gt;Bindings&lt;/code&gt;. &lt;code&gt;Expression&lt;/code&gt; is an expression in abstract syntax. For an explanation of when and how to use arguments &lt;code&gt;LocalFunctionHandler&lt;/code&gt; and &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt;, see sections &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt;Local Function Handler&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt;Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; in this module.</source>
          <target state="translated">바인딩 세트를 사용하여 &lt;code&gt;Expression&lt;/code&gt; 을 평가 &lt;code&gt;Bindings&lt;/code&gt; . &lt;code&gt;Expression&lt;/code&gt; 은 추상 구문의 표현식입니다. &lt;code&gt;LocalFunctionHandler&lt;/code&gt; 및 &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; 인수를 사용하는시기 및 방법에 대한 설명은 이 모듈의 &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt;Local Function Handler&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt;Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; 함수 핸들러 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b6c7e9e116e0851dc956b6950abb8622dd97b63" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Expressions&lt;/code&gt; with the set of bindings &lt;code&gt;Bindings&lt;/code&gt;, where &lt;code&gt;Expressions&lt;/code&gt; is a sequence of expressions (in abstract syntax) of a type that can be returned by &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt; io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;. For an explanation of when and how to use arguments &lt;code&gt;LocalFunctionHandler&lt;/code&gt; and &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt;, see sections &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt; Local Function Handler&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt; Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; in this module.</source>
          <target state="translated">바인딩 집합 &lt;code&gt;Bindings&lt;/code&gt; 로 &lt;code&gt;Expressions&lt;/code&gt; 을 평가 합니다 . 여기서 &lt;code&gt;Expressions&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt; io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; 에서 반환 할 수있는 형식의 식 시퀀스 (추상 구문)입니다 . &lt;code&gt;LocalFunctionHandler&lt;/code&gt; 및 &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; 인수를 사용하는시기와 방법에 대한 설명은 이 모듈의 &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt; Local Function Handler&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt; Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; 로컬 함수 처리기 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="718a6a4c93730553e14409052cb19a533719a70b" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Expressions&lt;/code&gt; with the set of bindings &lt;code&gt;Bindings&lt;/code&gt;, where &lt;code&gt;Expressions&lt;/code&gt; is a sequence of expressions (in abstract syntax) of a type that can be returned by &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;. For an explanation of when and how to use arguments &lt;code&gt;LocalFunctionHandler&lt;/code&gt; and &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt;, see sections &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt;Local Function Handler&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt;Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; in this module.</source>
          <target state="translated">바인딩 세트를 사용하여 &lt;code&gt;Expressions&lt;/code&gt; 을 평가 &lt;code&gt;Bindings&lt;/code&gt; . 여기서 &lt;code&gt;Expressions&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 될 수있는 유형의 표현식 시퀀스 (추상 구문)입니다 . &lt;code&gt;LocalFunctionHandler&lt;/code&gt; 및 &lt;code&gt;NonLocalFunctionHandler&lt;/code&gt; 인수를 사용하는시기 및 방법에 대한 설명은 이 모듈의 &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt;Local Function Handler&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#non_local_function_handler&quot;&gt;Non-Local Function Handler&lt;/a&gt;&lt;/code&gt; 함수 핸들러 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f94b1089562ec2fdd21410eb823656a3d2e2ff7e" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Fun()&lt;/code&gt;. Otherwise the same as &lt;code&gt;tc/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Fun()&lt;/code&gt; 평가합니다 . 그렇지 않으면 &lt;code&gt;tc/2&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="525cce5537518016cdc2db7a3354e589328d9233" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Pid ! Message&lt;/code&gt; after &lt;code&gt;Time&lt;/code&gt; milliseconds. (&lt;code&gt;Pid&lt;/code&gt; can also be an atom of a registered name.)</source>
          <target state="translated">&lt;code&gt;Pid ! Message&lt;/code&gt; 평가합니다 ! &lt;code&gt;Time&lt;/code&gt; milliseconds 이후의 메시지 ( &lt;code&gt;Pid&lt;/code&gt; 또한 등록 된 이름의 원자 일 수있다.)</target>
        </trans-unit>
        <trans-unit id="84b37e1cf5abcde77821b9a70f52ec837e7d14b9" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;Pid ! Message&lt;/code&gt; repeatedly after &lt;code&gt;Time&lt;/code&gt; milliseconds. (&lt;code&gt;Pid&lt;/code&gt; can also be an atom of a registered name.)</source>
          <target state="translated">&lt;code&gt;Pid ! Message&lt;/code&gt; 평가합니다 ! &lt;code&gt;Time&lt;/code&gt; 밀리 초)이 지난 후 반복되는 메시지 입니다. ( &lt;code&gt;Pid&lt;/code&gt; 또한 등록 된 이름의 원자 일 수있다.)</target>
        </trans-unit>
        <trans-unit id="ad8c2ad7dec3069e70faa46184428742db08a0ff" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;TrueCase&lt;/code&gt; if &lt;code&gt;Cond&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, or otherwise evaluates &lt;code&gt;FalseCase&lt;/code&gt; if &lt;code&gt;Cond&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;. (This is the same as &lt;code&gt;(case (Cond) of true-&amp;gt;(TrueCase); false-&amp;gt;(FalseCase) end)&lt;/code&gt;.) Note that it is an error if &lt;code&gt;Cond&lt;/code&gt; does not yield a boolean value.</source>
          <target state="translated">를 평가합니다 &lt;code&gt;TrueCase&lt;/code&gt; 는 경우 &lt;code&gt;Cond&lt;/code&gt; 평가 &lt;code&gt;true&lt;/code&gt; , 또는 다른 평가 &lt;code&gt;FalseCase&lt;/code&gt; 을 경우 &lt;code&gt;Cond&lt;/code&gt; 평가 &lt;code&gt;false&lt;/code&gt; . ( &lt;code&gt;(case (Cond) of true-&amp;gt;(TrueCase); false-&amp;gt;(FalseCase) end)&lt;/code&gt; 와 동일 ) 입니다. &lt;code&gt;Cond&lt;/code&gt; 가 부울 값을 생성하지 않으면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="55df0f16abae4c065cfc03185075aa68796a3ea4" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Fun, Arguments)&lt;/code&gt;. Otherwise the same as &lt;code&gt;tc/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply(Fun, Arguments)&lt;/code&gt; 평가 합니다 . 그렇지 않으면 &lt;code&gt;tc/3&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4dcb2977bf62009bb2b5b07e88abed08c47b5a0f" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(M, F, A)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply(M, F, A)&lt;/code&gt; 평가 합니다 .</target>
        </trans-unit>
        <trans-unit id="3d4fac350f9859d200574cc2ce85393db9383eba" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt; and returns the corresponding value &lt;code&gt;Res&lt;/code&gt;, or &lt;code&gt;{badrpc, Reason}&lt;/code&gt; if the call fails.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 하고 호출이 실패하면 해당 값 &lt;code&gt;Res&lt;/code&gt; 또는 &lt;code&gt;{badrpc, Reason}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="05b453c4da4a47452aea8024a74992a40f89fd84" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt; and returns the corresponding value &lt;code&gt;Res&lt;/code&gt;, or &lt;code&gt;{badrpc, Reason}&lt;/code&gt; if the call fails. &lt;code&gt;Timeout&lt;/code&gt; is a time-out value in milliseconds. If the call times out, &lt;code&gt;Reason&lt;/code&gt; is &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 하고 호출이 실패하면 해당 값 &lt;code&gt;Res&lt;/code&gt; 또는 &lt;code&gt;{badrpc, Reason}&lt;/code&gt; 리턴 합니다. &lt;code&gt;Timeout&lt;/code&gt; 는 시간 초과 값 (밀리 초)입니다. 호출 시간 이 &lt;code&gt;timeout&lt;/code&gt; 되면 &lt;code&gt;Reason&lt;/code&gt; 는 시간 초과 입니다.</target>
        </trans-unit>
        <trans-unit id="a58ba5fbf4d06592176f043dfeccb47f91ece3b8" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt; and returns the corresponding value &lt;code&gt;Res&lt;/code&gt;, or &lt;code&gt;{badrpc, Reason}&lt;/code&gt; if the call fails. The same as calling &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;rpc:call(Node, Module, Function, Args, infinity)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 노드 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 하고 해당 값 &lt;code&gt;Res&lt;/code&gt; 또는 호출이 실패하면 &lt;code&gt;{badrpc, Reason}&lt;/code&gt; 반환합니다. &lt;code&gt;&lt;a href=&quot;#call-5&quot;&gt;rpc:call(Node, Module, Function, Args, infinity)&lt;/a&gt;&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="04e2f8225da4c956b51a080980d4fd19ddaadc57" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt; and returns the corresponding value &lt;code&gt;Result&lt;/code&gt;. &lt;code&gt;Timeout&lt;/code&gt; is an integer representing the timeout in milliseconds or the atom &lt;code&gt;infinity&lt;/code&gt; which prevents the operation from ever timing out.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 노드 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 하고 해당 값 &lt;code&gt;Result&lt;/code&gt; 를 반환합니다 . &lt;code&gt;Timeout&lt;/code&gt; 는 시간 초과를 밀리 초 단위로 나타내는 정수 또는 작업 시간 초과 를 방지하는 원자 &lt;code&gt;infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6163eb01c7d25b83c0125499be3734f5410e312d" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;. No response is delivered and the calling process is not suspended until the evaluation is complete, as is the case with &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4,5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 합니다 . &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4,5&lt;/a&gt;&lt;/code&gt; 의 경우와 같이 평가가 완료 될 때까지 응답이 전달되지 않고 호출 프로세스가 일시 중단되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5293e5bf1ea6f4745218802a9beed4c981091c2f" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;. No response is delivered to the calling process. &lt;code&gt;erpc:cast()&lt;/code&gt; returns immediately after the cast request has been sent. Any failures beside bad arguments are silently ignored.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 노드 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 합니다 . 호출 프로세스에 응답이 전달되지 않습니다. &lt;code&gt;erpc:cast()&lt;/code&gt; 는 캐스트 요청이 전송 된 직후에 반환됩니다. 잘못된 인수 이외의 모든 실패는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a4fa1540613a1c89c457f127276ed85ffd327ab" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the node &lt;code&gt;Node&lt;/code&gt;. No response is delivered and the process that makes the call is not suspended until the evaluation is completed as in the case of &lt;code&gt;call/3,4&lt;/code&gt;. If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;{Fun, FunArgs}&lt;/code&gt;, applying &lt;code&gt;Fun&lt;/code&gt; to &lt;code&gt;FunArgs&lt;/code&gt; is to return a node name.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 합니다 . &lt;code&gt;call/3,4&lt;/code&gt; 의 경우와 같이 평가가 완료 될 때까지 응답이 전달되지 않고 호출하는 프로세스가 일시 중단되지 않습니다 . 경우 &lt;code&gt;Node&lt;/code&gt; 있다 &lt;code&gt;{Fun, FunArgs}&lt;/code&gt; , 적용 &lt;code&gt;Fun&lt;/code&gt; 에 &lt;code&gt;FunArgs&lt;/code&gt; 하는 노드 이름을 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d2b64f22b86a4ebae9378df454694cf4b2d8e74" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the node &lt;code&gt;Node&lt;/code&gt;. Returns either whatever &lt;code&gt;Function&lt;/code&gt; returns, or &lt;code&gt;{badrpc, Reason}&lt;/code&gt; if the remote procedure call fails. If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;{Fun, FunArgs}&lt;/code&gt;, applying &lt;code&gt;Fun&lt;/code&gt; to &lt;code&gt;FunArgs&lt;/code&gt; is to return a node name.</source>
          <target state="translated">노드 &lt;code&gt;Node&lt;/code&gt; 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 합니다 . 원격 프로 시저 호출이 실패하면 &lt;code&gt;Function&lt;/code&gt; 가 리턴하는 모든 것을 리턴하거나 &lt;code&gt;{badrpc, Reason}&lt;/code&gt; 리턴 합니다. 경우 &lt;code&gt;Node&lt;/code&gt; 있다 &lt;code&gt;{Fun, FunArgs}&lt;/code&gt; , 적용 &lt;code&gt;Fun&lt;/code&gt; 에 &lt;code&gt;FunArgs&lt;/code&gt; 하는 노드 이름을 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a890a2754fee2f65938a113b86ce5d0784d39805" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the nodes &lt;code&gt;Nodes&lt;/code&gt;. No response is delivered to the calling process. &lt;code&gt;erpc:multicast()&lt;/code&gt; returns immediately after the cast requests have been sent. Any failures beside bad arguments are silently ignored.</source>
          <target state="translated">&lt;code&gt;Nodes&lt;/code&gt; 노드 에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 합니다 . 호출 프로세스에 응답이 전달되지 않습니다. &lt;code&gt;erpc:multicast()&lt;/code&gt; 는 캐스트 요청이 전송 된 직후에 반환됩니다. 잘못된 인수 이외의 모든 실패는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="35443a5c50dc842d35a2bf954702893e927421f5" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on the specified nodes. No answers are collected.</source>
          <target state="translated">지정된 노드에서 &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 를 평가 합니다 . 답변이 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aebb38b539b4b655f1010af603e51c027fc66659" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; after &lt;code&gt;Time&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 밀리 초 후에 &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; 평가 합니다 .</target>
        </trans-unit>
        <trans-unit id="e3df08321cff6582142c40f6af62b1df5af8fc6b" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; and measures the elapsed real time as reported by &lt;code&gt; erlang:monotonic_time/0&lt;/code&gt;.</source>
          <target state="translated">평가하여이 &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; 및 측정에 의해보고 된 실시간 경과 &lt;code&gt; erlang:monotonic_time/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0abfd902f3cd50089673d52523c410577272d587" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; and measures the elapsed real time as reported by &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt;.</source>
          <target state="translated">평가하여이 &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; 및 측정에 의해보고 된 실시간 경과 &lt;code&gt;erlang:monotonic_time/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8d6c33f34f27043a94550849ea0daa51f209638" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; repeatedly at intervals of &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 간격으로 반복적으로 &lt;code&gt;apply(Module, Function, Arguments)&lt;/code&gt; 평가 합니다 .</target>
        </trans-unit>
        <trans-unit id="00422cbf37158e86b6514c4e556ae0be92b0f4e4" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;apply(Module, Function, [Elem|ExtraArgs])&lt;/code&gt; for every element &lt;code&gt;Elem&lt;/code&gt; in &lt;code&gt;List1&lt;/code&gt;, in parallel. Returns the list of return values, in the same order as in &lt;code&gt;List1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List1&lt;/code&gt; 의 모든 요소 &lt;code&gt;Elem&lt;/code&gt; 에 대해 병렬로 &lt;code&gt;apply(Module, Function, [Elem|ExtraArgs])&lt;/code&gt; 를 평가 합니다 . &lt;code&gt;List1&lt;/code&gt; 과 동일한 순서로 반환 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5e349f57e9e0c3b6266cd97f8fd0880686a4ed8" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;shell_default:c(Mod)&lt;/code&gt;. This compiles and loads the module &lt;code&gt;Mod&lt;/code&gt; and purges old versions of the code, if necessary. &lt;code&gt;Mod&lt;/code&gt; can be either a module name or a a source file path, with or without &lt;code&gt;.erl&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;shell_default:c(Mod)&lt;/code&gt; 평가합니다 . 이렇게하면 모듈 &lt;code&gt;Mod&lt;/code&gt; 를 컴파일하고로드하고 필요한 경우 이전 버전의 코드를 제거합니다. &lt;code&gt;Mod&lt;/code&gt; 는 모듈 이름이거나 &lt;code&gt;.erl&lt;/code&gt; 확장자 가 있거나없는 소스 파일 경로 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a588f2b8c010920996b01b795f0cfedfcfd5686" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;shell_default:help()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shell_default:help()&lt;/code&gt; 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="552b71dbc141ce9268baf0c0616e35bedcb40da3" translate="yes" xml:space="preserve">
          <source>Evaluates a &lt;code&gt;&lt;a href=&quot;#query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; in the context of an &lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt;, and returns the value of the last statement. The syntax of the value depends on the expression:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#xref_server&quot;&gt;Xref server&lt;/a&gt;&lt;/code&gt; 의 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;#query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; 를 평가 하고 마지막 문의 값을 반환합니다. 값의 구문은 다음 표현식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="759ed7b8fb983f2b5c7237afc5c69f1444f05946" translate="yes" xml:space="preserve">
          <source>Evaluates a list of expressions in parallel, using the same initial bindings for each expression. Attempts are made to merge the bindings returned from each evaluation. This function is useful in &lt;code&gt;LocalFunctionHandler&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt; Local Function Handler&lt;/a&gt;&lt;/code&gt; in this module.</source>
          <target state="translated">각 식에 대해 동일한 초기 바인딩을 사용하여 식 목록을 병렬로 평가합니다. 각 평가에서 반환 된 바인딩을 병합하려고 시도합니다. 이 함수는 &lt;code&gt;LocalFunctionHandler&lt;/code&gt; 에서 유용 합니다.이 모듈의 &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt; Local Function Handler&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0295036ecab0fa78c9441c600527984547937e01" translate="yes" xml:space="preserve">
          <source>Evaluates a list of expressions in parallel, using the same initial bindings for each expression. Attempts are made to merge the bindings returned from each evaluation. This function is useful in &lt;code&gt;LocalFunctionHandler&lt;/code&gt;, see section &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt;Local Function Handler&lt;/a&gt;&lt;/code&gt; in this module.</source>
          <target state="translated">각 표현식에 대해 동일한 초기 바인딩을 사용하여 표현식 목록을 병렬로 평가합니다. 각 평가에서 리턴 된 바인딩을 병합하려고 시도합니다. 이 함수는 &lt;code&gt;LocalFunctionHandler&lt;/code&gt; 에 유용 합니다.이 모듈의 &lt;code&gt;&lt;a href=&quot;#local_function_handler&quot;&gt;Local Function Handler&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="299206cdd99ef4eff0c5a8338168e3d80a700c44" translate="yes" xml:space="preserve">
          <source>Evaluates a predefined analysis. Returns a sorted list without duplicates of &lt;code id=&quot;analyze&quot;&gt;call()&lt;/code&gt; or &lt;code&gt;constant()&lt;/code&gt;, depending on the chosen analysis. The predefined analyses, which operate on all &lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed modules&lt;/a&gt;&lt;/code&gt;, are (analyses marked with (*) are available in &lt;code&gt;functions&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; only):</source>
          <target state="translated">사전 정의 된 분석을 평가합니다. 선택한 분석에 따라 &lt;code id=&quot;analyze&quot;&gt;call()&lt;/code&gt; 또는 &lt;code&gt;constant()&lt;/code&gt; 중복없이 정렬 된 목록을 반환합니다 . 모든 &lt;code&gt;&lt;a href=&quot;#analyzed_module&quot;&gt;analyzed modules&lt;/a&gt;&lt;/code&gt; 에서 작동하는 사전 정의 된 분석 은 다음과 같습니다 ((*)로 표시된 분석은 &lt;code&gt;functions&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="761059e344997a0cff5e70f5e10840cf6a39a442" translate="yes" xml:space="preserve">
          <source>Evaluates a query handle in the calling process and collects all answers in a list.</source>
          <target state="translated">호출 프로세스에서 쿼리 핸들을 평가하고 목록에서 모든 답변을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="0264706c5cd0c4d08bc0417d537ce893d131636d" translate="yes" xml:space="preserve">
          <source>Evaluates all instructions that occur before the &lt;code&gt;point_of_no_return&lt;/code&gt; instruction in the release upgrade script.</source>
          <target state="translated">릴리스 업그레이드 스크립트에서 &lt;code&gt;point_of_no_return&lt;/code&gt; 명령 이전에 발생하는 모든 명령을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="71788d41b547ff6e0b386fd7309236a36a585ba6" translate="yes" xml:space="preserve">
          <source>Evaluates an application upgrade or downgrade script &lt;code&gt;Script&lt;/code&gt;, the result from calling &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt;, exactly in the same way as &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 와 정확히 동일한 방식으로 &lt;code&gt;&lt;a href=&quot;#upgrade_script-2&quot;&gt;upgrade_script/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#downgrade_script-3&quot;&gt;downgrade_script/3&lt;/a&gt;&lt;/code&gt; 를 호출 한 결과 로 애플리케이션 업그레이드 또는 다운 그레이드 스크립트 &lt;code&gt;Script&lt;/code&gt; 를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="4d5eb160d86c2abca190393b9f040e9e0d7211ef" translate="yes" xml:space="preserve">
          <source>Evaluates the expression &lt;code&gt;BoolExpr&lt;/code&gt;, if testing is enabled. Unless the result is &lt;code&gt;true&lt;/code&gt;, an informative exception will be generated. If there is no exception, the result of the macro expression is the atom &lt;code&gt;ok&lt;/code&gt;, and the value of &lt;code&gt;BoolExpr&lt;/code&gt; is discarded. If testing is disabled, the macro will not generate any code except the atom &lt;code&gt;ok&lt;/code&gt;, and &lt;code&gt;BoolExpr&lt;/code&gt; will not be evaluated.</source>
          <target state="translated">테스트가 사용 가능한 경우 &lt;code&gt;BoolExpr&lt;/code&gt; 표현식을 평가합니다 . 결과가 &lt;code&gt;true&lt;/code&gt; 가 아니면 유익한 예외가 생성됩니다. 예외가없는 경우 매크로 표현식의 결과는 atom &lt;code&gt;ok&lt;/code&gt; 이며 &lt;code&gt;BoolExpr&lt;/code&gt; 값 은 삭제됩니다. 테스트가 비활성화 된 경우, 매크로는 원자를 제외한 모든 코드를 생성하지 않습니다 &lt;code&gt;ok&lt;/code&gt; 하고, &lt;code&gt;BoolExpr&lt;/code&gt; 은 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d6751618399ac3188a3a1ecfee1b03c688bfdf2" translate="yes" xml:space="preserve">
          <source>Evaluates the expression &lt;code&gt;apply(Mod, Fun, Args)&lt;/code&gt; with the trace flags in &lt;code&gt;Flags&lt;/code&gt; set. This is a convenient way to trace processes from the Erlang shell.</source>
          <target state="translated">&lt;code&gt;Flags&lt;/code&gt; 세트 의 추적 플래그를 사용하여 &lt;code&gt;apply(Mod, Fun, Args)&lt;/code&gt; 표현식을 평가합니다 . 이것은 Erlang 쉘에서 프로세스를 추적하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a4028294563978d899f8f51e917fa472ec1835de" translate="yes" xml:space="preserve">
          <source>Evaluates the expressions &lt;code&gt;Expect&lt;/code&gt; and &lt;code&gt;Expr&lt;/code&gt; and compares the results for equality, if testing is enabled. If the values are not equal, an informative exception will be generated; see the &lt;code&gt;assert&lt;/code&gt; macro for further details.</source>
          <target state="translated">테스트가 사용 가능한 경우 &lt;code&gt;Expect&lt;/code&gt; 및 &lt;code&gt;Expr&lt;/code&gt; 표현식을 평가하고 결과가 동일한 지 비교합니다. 값이 같지 않으면 유익한 예외가 생성됩니다. 자세한 내용은 &lt;code&gt;assert&lt;/code&gt; 매크로를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="394af50da1736d0811b4e0353c50f53bf9ca0c4c" translate="yes" xml:space="preserve">
          <source>Evaluates the following lines only if &lt;code&gt;Condition&lt;/code&gt; evaluates to true.</source>
          <target state="translated">&lt;code&gt;Condition&lt;/code&gt; 이 true로 평가되는 경우에만 다음 줄을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="92b564d165307bce2c74a78a154d6e802182a1a6" translate="yes" xml:space="preserve">
          <source>Evaluates the specified function call during system initialization. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as atoms. If an exception is raised, Erlang stops with an error message.</source>
          <target state="translated">시스템 초기화 중 지정된 함수 호출을 평가합니다. 기본적으로 &lt;code&gt;Func&lt;/code&gt; 가 &lt;code&gt;start&lt;/code&gt; 됩니다. 인수가 제공되지 않으면 함수는 arity 0 인 것으로 가정합니다. 그렇지 않으면 목록 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 를 인수로 사용 하여 arity 1 인 것으로 가정합니다 . 모든 인수는 원자로 전달됩니다. 예외가 발생하면 Erlang은 오류 메시지와 함께 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="5299e33fab3f3a3a931b1151cca86a3355a0fc6a" translate="yes" xml:space="preserve">
          <source>Evaluates the specified function call during system initialization. &lt;code&gt;Func&lt;/code&gt; defaults to &lt;code&gt;start&lt;/code&gt;. If no arguments are provided, the function is assumed to be of arity 0. Otherwise it is assumed to be of arity 1, taking the list &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; as argument. All arguments are passed as strings. If an exception is raised, Erlang stops with an error message.</source>
          <target state="translated">시스템 초기화 중 지정된 함수 호출을 평가합니다. 기본적으로 &lt;code&gt;Func&lt;/code&gt; 가 &lt;code&gt;start&lt;/code&gt; 됩니다. 인수가 제공되지 않으면 함수는 arity 0 인 것으로 가정합니다. 그렇지 않으면 목록 &lt;code&gt;[Arg1,Arg2,...]&lt;/code&gt; 를 인수로 사용 하여 arity 1 인 것으로 가정합니다 . 모든 인수는 문자열로 전달됩니다. 예외가 발생하면 Erlang은 오류 메시지와 함께 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="45716b79c2b111e351cc11c2b95f015fc023bb5d" translate="yes" xml:space="preserve">
          <source>Evaluates, for every tuple in &lt;code&gt;FuncCalls&lt;/code&gt;, &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on some node in the network. Returns the list of return values, in the same order as in &lt;code&gt;FuncCalls&lt;/code&gt;.</source>
          <target state="translated">평가하여이 모든 튜플에 대한 &lt;code&gt;FuncCalls&lt;/code&gt; , &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; 네트워크의 일부 노드에서. &lt;code&gt;FuncCalls&lt;/code&gt; 와 동일한 순서로 반환 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="72787ed6a5a8d4c62182fbbe7280c959360f8476" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;select&lt;/code&gt; gives the following result:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 를 평가 하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="594ba4d05eb1c3c63ddacc267d972f04ed3b36fe" translate="yes" xml:space="preserve">
          <source>Evaluation exits with reason &lt;code&gt;{bad_position, Pos}&lt;/code&gt; if the associated position information &lt;code&gt;Pos&lt;/code&gt; of some subtree in the input does not have a recognizable format, or with reason &lt;code&gt;{bad_tree, L, C}&lt;/code&gt; if insertion of a comment at line &lt;code&gt;L&lt;/code&gt;, column &lt;code&gt;C&lt;/code&gt;, fails because the tree structure is ill-formed.</source>
          <target state="translated">입력에서 일부 서브 트리 의 연관된 위치 정보 &lt;code&gt;Pos&lt;/code&gt; 에 인식 가능한 형식이없는 경우 이유 &lt;code&gt;{bad_position, Pos}&lt;/code&gt; 평가가 종료되고 , 라인 &lt;code&gt;L&lt;/code&gt; , 열 &lt;code&gt;C&lt;/code&gt; 에 주석을 삽입하는 경우 이유 &lt;code&gt;{bad_tree, L, C}&lt;/code&gt; 됩니다 . 트리 구조가 잘못되어 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d321bedd851843e36859f0f7b4ea6334ba853951" translate="yes" xml:space="preserve">
          <source>Evaluation exits with reason &lt;code&gt;{read, Reason}&lt;/code&gt; if a read error occurred, where &lt;code&gt;Reason&lt;/code&gt; is an atom corresponding to a Posix error code; see the module &lt;code&gt;file(3)&lt;/code&gt; for details.</source>
          <target state="translated">읽기 오류가 발생한 경우 이유 &lt;code&gt;{read, Reason}&lt;/code&gt; 평가가 종료됩니다 . 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 Posix 오류 코드에 해당하는 원자입니다. 자세한 내용은 모듈 &lt;code&gt;file(3)&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bfcaca03a471a2ff8e9e73bb13da09aa62995d8" translate="yes" xml:space="preserve">
          <source>Evaluation has succeed and &lt;code&gt;m:fact(1)&lt;/code&gt; returns 1.</source>
          <target state="translated">평가에 성공했으며 &lt;code&gt;m:fact(1)&lt;/code&gt; 은 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be6d492a53abe8537b302ab0603b1f80a31c239e" translate="yes" xml:space="preserve">
          <source>Evaluation of a match expression failed. The value &lt;code&gt;V&lt;/code&gt; did not match.</source>
          <target state="translated">일치 표현식 평가에 실패했습니다. 값 &lt;code&gt;V&lt;/code&gt; 가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2aa4b338758201aab140a13095a1391abff39c28" translate="yes" xml:space="preserve">
          <source>Evaluation starts at the first clause. The pattern &lt;code&gt;N&lt;/code&gt; is matched against argument 1. The matching succeeds and the guard (&lt;code&gt;N&amp;gt;0&lt;/code&gt;) is true, thus &lt;code&gt;N&lt;/code&gt; is bound to 1, and the corresponding body is evaluated:</source>
          <target state="translated">평가는 첫 번째 절에서 시작합니다. 패턴 &lt;code&gt;N&lt;/code&gt; 은 인수 1과 일치합니다. 일치는 성공하고 보호 ( &lt;code&gt;N&amp;gt;0&lt;/code&gt; )는 true이므로 &lt;code&gt;N&lt;/code&gt; 은 1에 바인딩되고 해당 본문이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="725047dadb8168b15c5eafc0e14a7c8b49bd7809" translate="yes" xml:space="preserve">
          <source>Evan McGinnis and David Perkins (1997), &quot;Understanding SNMP MIBs&quot;, Prentice-Hall</source>
          <target state="translated">Evan McGinnis와 David Perkins (1997), &quot;Prentice-Hall&quot; &quot;SNMP MIB 이해&quot;</target>
        </trans-unit>
        <trans-unit id="d24154971ec1999471c06222b0fd99c1ad8a0f60" translate="yes" xml:space="preserve">
          <source>Even experienced software developers often guess wrong about where the performance bottlenecks are in their programs. Therefore, profile your program to see where the performance bottlenecks are and concentrate on optimizing them.</source>
          <target state="translated">숙련 된 소프트웨어 개발자조차도 종종 프로그램에서 성능 병목 현상이 발생하는 위치에 대해 잘못 추측합니다. 따라서 프로그램을 프로파일 링하여 성능 병목 현상의 위치를 ​​파악하고 최적화에 집중하십시오.</target>
        </trans-unit>
        <trans-unit id="a157d4036066195c1becda297706abb12364bfb8" translate="yes" xml:space="preserve">
          <source>Even if all functions of a module are NIFs, an Erlang module is still needed for two reasons:</source>
          <target state="translated">모듈의 모든 기능이 NIF 인 경우에도 다음 두 가지 이유로 Erlang 모듈이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b6b124560bc78d785ea8b4ff1c056e6184c2e39e" translate="yes" xml:space="preserve">
          <source>Even if an exception occurs during evaluation of &lt;code&gt;Body&lt;/code&gt; or &lt;code&gt;ExceptionBody&lt;/code&gt;, &lt;code&gt;AfterBody&lt;/code&gt; is evaluated. In this case the exception is passed on after &lt;code&gt;AfterBody&lt;/code&gt; has been evaluated, so the exception from the &lt;code&gt;try&lt;/code&gt; expression is the same with an &lt;code&gt;after&lt;/code&gt; section as without.</source>
          <target state="translated">예외가 평가하는 동안 발생하더라도 &lt;code&gt;Body&lt;/code&gt; 또는 &lt;code&gt;ExceptionBody&lt;/code&gt; , &lt;code&gt;AfterBody&lt;/code&gt; 는 평가된다. 이 경우 &lt;code&gt;AfterBody&lt;/code&gt; 가 평가 된 후 예외가 전달 되므로 &lt;code&gt;try&lt;/code&gt; 표현식 의 예외 는 &lt;code&gt;after&lt;/code&gt; 섹션의 without 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="8528b9253b183573229e9ad3a8562a65d7d9161a" translate="yes" xml:space="preserve">
          <source>Even if some information about an item exists, there can be empty fields if the dump originates from an old OTP release.</source>
          <target state="translated">항목에 대한 일부 정보가 존재하더라도 덤프가 이전 OTP 릴리스에서 시작된 경우 빈 필드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2871294647be6ab634cc08d7fa7c613e55d2ea5f" translate="yes" xml:space="preserve">
          <source>Even if the &lt;code&gt;gen_server&lt;/code&gt; process is &lt;strong&gt;not&lt;/strong&gt; part of a supervision tree, this function is called if it receives an &lt;code&gt;'EXIT'&lt;/code&gt; message from its parent. &lt;code&gt;Reason&lt;/code&gt; is the same as in the &lt;code&gt;'EXIT'&lt;/code&gt; message.</source>
          <target state="translated">짝수 경우 &lt;code&gt;gen_server&lt;/code&gt; 의 처리는 &lt;strong&gt;하지&lt;/strong&gt; 감독 트리의 일부 그것이 수신하는 경우,이 함수가 호출되어 &lt;code&gt;'EXIT'&lt;/code&gt; 부모로부터 메시지를. &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;'EXIT'&lt;/code&gt; 메시지 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1a59bd256ce000b0c0ca7626b5f70a4dad526a52" translate="yes" xml:space="preserve">
          <source>Even if the &lt;code&gt;gen_statem&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; part of a supervision tree, this function is called if it receives an &lt;code&gt;'EXIT'&lt;/code&gt; message from its parent. &lt;code&gt;Reason&lt;/code&gt; is the same as in the &lt;code&gt;'EXIT'&lt;/code&gt; message.</source>
          <target state="translated">짝수 경우 &lt;code&gt;gen_statem&lt;/code&gt; 가 있다 &lt;strong&gt;하지&lt;/strong&gt; 감독 트리의 일부 그것이 수신하는 경우,이 함수가 호출되어 &lt;code&gt;'EXIT'&lt;/code&gt; 부모로부터 메시지를. &lt;code&gt;Reason&lt;/code&gt; 는 &lt;code&gt;'EXIT'&lt;/code&gt; 메시지 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="828aa5e634ef4dca54637e853ec5ff52a33a73b9" translate="yes" xml:space="preserve">
          <source>Even if user interaction is allowed it can be suppressed by other options, such as &lt;code&gt;silently_accept_hosts&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt;. However, those options are not always desirable to use from a security point of view.</source>
          <target state="translated">사용자 상호 작용이 허용 되더라도 &lt;code&gt;silently_accept_hosts&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 와 같은 다른 옵션으로이를 억제 할 수 있습니다 . 그러나 이러한 옵션이 항상 보안 관점에서 사용되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="756e62650be27b6a4f50c8c1adf6eb8a453a36cb" translate="yes" xml:space="preserve">
          <source>Even if you are operating without Unicode file naming translation automatically done by the VM, you can access and create files with names in UTF-8 encoding by using raw filenames encoded as UTF-8. Enforcing the UTF-8 encoding regardless of the mode the Erlang VM is started in can in some circumstances be a good idea, as the convention of using UTF-8 filenames is spreading.</source>
          <target state="translated">VM에서 자동으로 유니 코드 파일 이름 변환을 수행하지 않고 작업하더라도 UTF-8로 인코딩 된 원시 파일 이름을 사용하여 UTF-8 인코딩으로 이름을 가진 파일에 액세스하고 작성할 수 있습니다. Erlang VM이 시작되는 모드에 관계없이 UTF-8 인코딩을 적용하면 UTF-8 파일 이름 사용 규칙이 널리 퍼져 있기 때문에 어떤 상황에서는 좋은 아이디어가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2968dd27a91c20a70b11050bf3acf695afd1310" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;&amp;lt;&amp;lt;&quot;cd&quot;&amp;gt;&amp;gt;&lt;/code&gt; ends before &lt;code&gt;&amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt;&lt;/code&gt; begins first and is therefore the first match. If two overlapping matches begin at the same position, the longest is returned.</source>
          <target state="translated">비록 &lt;code&gt;&amp;lt;&amp;lt;&quot;cd&quot;&amp;gt;&amp;gt;&lt;/code&gt; 끝나기 전에 &lt;code&gt;&amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&quot;bcde&quot;&amp;gt;&amp;gt;&lt;/code&gt; 제 시작 따라서 최초로 일치한다. 동일한 위치에서 두 개의 겹치는 일치 항목이 시작되면 가장 긴 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55ac8610f6b9e916e4653311ba761cc1229f858f" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;trace_pattern&lt;/code&gt; use the same technique as the non-blocking code loading with replicated generations of data structures and an atomic switch, the implementations are quite separate from each other. One initial idea was to use the existing mechanism of code loading to do a dummy load operation that would make a copy of the affected modules. That copy could then be instrumented with breakpoints before making it reachable with the same atomic switch as done for code loading. This approach seems straight forward but has a number of shortcomings, one being the large memory footprint when many modules are instrumented. Another problem is how execution will reach the new instrumented code. Normally loaded code can only be reached through external functions calls. Trace settings must be activated instantaneously without the need of external function calls.</source>
          <target state="translated">비록 &lt;code&gt;trace_pattern&lt;/code&gt; 복제 된 세대의 데이터 구조와 원자 스위치를 사용하는 비 차단 코드 로딩과 동일한 기술을 사용하면 구현이 서로 상당히 분리되어 있습니다. 초기 아이디어 중 하나는 기존 코드로드 메커니즘을 사용하여 영향을받는 모듈의 복사본을 만드는 더미로드 작업을 수행하는 것이 었습니다. 그런 다음 해당 복사본은 코드로드를 위해 수행 된 것과 동일한 원자 적 스위치로 도달 할 수 있도록 만들기 전에 중단 점으로 계측 될 수 있습니다. 이 접근 방식은 간단 해 보이지만 여러 가지 단점이 있습니다. 하나는 많은 모듈이 계측 될 때 큰 메모리 풋 프린트입니다. 또 다른 문제는 실행이 새로운 계측 코드에 도달하는 방법입니다. 일반적으로로드 된 코드는 외부 함수 호출을 통해서만 도달 할 수 있습니다. 추적 설정은 외부 함수 호출없이 즉시 활성화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b6f454bc32749555ed88b79417ff36687c1d9758" translate="yes" xml:space="preserve">
          <source>Even though it is highly efficient to write test suites with the &lt;code&gt;Common Test&lt;/code&gt; framework, mistakes can be made, mainly because of illegal dependencies. Some of the more frequent mistakes from our own experience with running the Erlang/OTP test suites follows:</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 프레임 워크를 사용하여 테스트 스위트를 작성하는 것이 매우 효율적이지만 , 주로 불법적 인 종속성으로 인해 실수가 발생할 수 있습니다. Erlang / OTP 테스트 스위트를 실행 한 경험에서 자주 발생하는 몇 가지 실수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="061a9ec170598340079688897e326df927fc762f" translate="yes" xml:space="preserve">
          <source>Even though processes and ports conceptually always have been very similar, the implementations have been very different. Originally, more or less all port signals were handled synchronously at the time they occurred. Very early in the development of the SMP support for the runtime system we recognized that this was a huge problem for signals between ports and the outside world. That is, I/O events to and from the outside world, or I/O signals. This was one of the first things that had to be rewritten in order to be able to do I/O in parallel at all. The solution was to implement scheduling of these signals. I/O signals corresponding to different ports could then be executed in parallel on different scheduler threads. Signals from processes to ports was not as big of a problem as the I/O signals, and the implementation of those was left as they were.</source>
          <target state="translated">개념적으로 프로세스와 포트는 항상 매우 유사했지만 구현은 매우 달랐습니다. 원래는 거의 모든 포트 신호가 발생 시점에 동시에 처리되었습니다. 런타임 시스템에 대한 SMP 지원 개발 초기에 우리는 이것이 포트와 외부 세계 간의 신호에 대해 큰 문제라는 것을 인식했습니다. 즉, 외부 세계와의 I / O 이벤트 또는 I / O 신호입니다. 이것은 I / O를 병렬로 수행하기 위해 다시 작성해야하는 첫 번째 작업 중 하나였습니다. 해결책은 이러한 신호의 스케줄링을 구현하는 것이 었습니다. 다른 포트에 해당하는 I / O 신호는 다른 스케줄러 스레드에서 병렬로 실행될 수 있습니다. 프로세스에서 포트로의 신호는 I / O 신호만큼 큰 문제는 아니 었습니다.그리고 그것들의 구현은 그대로 남겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="581ac68d6b0bd423a6847fc21f0bf670de01124e" translate="yes" xml:space="preserve">
          <source>Even though the access of a single object is always guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;, each traversal through a table to find the next key is not done with such guarantees. This is often not a problem, but may cause rare subtle &quot;unexpected&quot; effects if a concurrent process inserts objects during a traversal. For example, consider one process doing</source>
          <target state="translated">단일 객체에 대한 액세스는 항상 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; 것으로 보장되지만 다음 키를 찾기 위해 테이블을 통과 할 때마다 이러한 보장이 수행되지는 않습니다. 이것은 종종 문제가되지 않지만 동시 프로세스가 순회 중에 객체를 삽입하는 경우 드물게 미묘한 &quot;예기치 않은&quot;효과를 유발할 수 있습니다. 예를 들어, 한 프로세스가</target>
        </trans-unit>
        <trans-unit id="c5eebf65b04d5ee6473648862805d07be8c7eddd" translate="yes" xml:space="preserve">
          <source>Even though the following example shows one way to transform data from XML to HTML it also applies to transformations to other formats.</source>
          <target state="translated">다음 예제는 XML에서 HTML로 데이터를 변환하는 한 가지 방법을 보여 주지만 다른 형식으로의 변환에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="726faff0b96645aa4a47e5812a22604ba91baa69" translate="yes" xml:space="preserve">
          <source>Even with multi-threaded set to &lt;code&gt;extended&lt;/code&gt; there is still a risk for 'reorder' when sending inform-requsts, which require a response (and may therefor require resending).</source>
          <target state="translated">다중 스레드가 &lt;code&gt;extended&lt;/code&gt; 설정된 경우에도 정보 요청을 보낼 때 '재주문'할 위험이 있습니다.이 경우 응답이 필요합니다 (다시 전송이 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="8956c2a53170e98ab442a8ae115c9727c0a96836" translate="yes" xml:space="preserve">
          <source>Event handler &lt;code&gt;my_evh1&lt;/code&gt; is started with &lt;code&gt;[]&lt;/code&gt; as argument to the init function. Event handler &lt;code&gt;my_evh2&lt;/code&gt; is started with the name of the current node in the init argument list.</source>
          <target state="translated">이벤트 핸들러 &lt;code&gt;my_evh1&lt;/code&gt; 은 init 함수의 인수로 &lt;code&gt;[]&lt;/code&gt; 로 시작됩니다 . 이벤트 핸들러 &lt;code&gt;my_evh2&lt;/code&gt; 는 init 인수 목록에서 현재 노드의 이름으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="fd0a747770ffd37220ea7011e1dd286beea94778" translate="yes" xml:space="preserve">
          <source>Event handlers can also be plugged in using one of the following &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specification&lt;/a&gt;&lt;/code&gt; terms:</source>
          <target state="translated">이벤트 핸들러는 다음 &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specification&lt;/a&gt;&lt;/code&gt; 용어 중 하나를 사용하여 플러그인 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaae365de13b3365af4a53ef404441254081697c" translate="yes" xml:space="preserve">
          <source>Event handlers can be installed by an &lt;code&gt;event_handler&lt;/code&gt; start flag (&lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;) or option &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, where the argument specifies the names of one or more event handler modules.</source>
          <target state="translated">이벤트 핸들러는 &lt;code&gt;event_handler&lt;/code&gt; 시작 플래그 ( &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; ) 또는 옵션 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 로 설치 될 수 있습니다 . 여기서 인수는 하나 이상의 이벤트 핸들러 모듈의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="eabc790d00812b33da77b202701e348d39479228" translate="yes" xml:space="preserve">
          <source>Event handling</source>
          <target state="translated">이벤트 처리</target>
        </trans-unit>
        <trans-unit id="57d0a9b4bb919f5ebea8ca7ad8aaf82293d64de9" translate="yes" xml:space="preserve">
          <source>Event notification messages sent as a result of calls to &lt;code&gt;&lt;a href=&quot;#create_subscription-2&quot;&gt;create_subscription/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#create_subscription-2&quot;&gt;create_subscription/2,3&lt;/a&gt;&lt;/code&gt; 에 대한 호출의 결과로 전송 된 이벤트 알림 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="26a93f947e954bbcd99f1efe0bea5871a3c244d3" translate="yes" xml:space="preserve">
          <source>Event postponing</source>
          <target state="translated">이벤트 연기</target>
        </trans-unit>
        <trans-unit id="857ef522c704ef1c6115a69b01f24e2e3dd8f469" translate="yes" xml:space="preserve">
          <source>Event traces can be viewed in a generic message sequence chart tool, &lt;code&gt;et&lt;/code&gt;, or as standard output (events are written to stdio).</source>
          <target state="translated">이벤트 트레이스는 일반적인 메시지 시퀀스 차트 도구에서 볼 수있는 &lt;code&gt;et&lt;/code&gt; , 또는 표준 출력으로 (이벤트는 표준 입출력에 기록됩니다).</target>
        </trans-unit>
        <trans-unit id="25c6c0e62c4a3f1be54b28d7858c4ad4673095ce" translate="yes" xml:space="preserve">
          <source>Event-Timestamp AVP</source>
          <target state="translated">이벤트 타임 스탬프 AVP</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="9e56a09597470fd22e7fac6179093d49169582c0" translate="yes" xml:space="preserve">
          <source>Events are categorized in different &lt;code&gt;&lt;strong&gt;event types&lt;/strong&gt;&lt;/code&gt;. Events of all types are for a given state handled in the same callback function, and that function gets &lt;code&gt;EventType&lt;/code&gt; and &lt;code&gt;EventContent&lt;/code&gt; as arguments. The meaning of the &lt;code&gt;EventContent&lt;/code&gt; depends on the &lt;code&gt;EventType&lt;/code&gt;.</source>
          <target state="translated">이벤트는 다양한 &lt;code&gt;&lt;strong&gt;event types&lt;/strong&gt;&lt;/code&gt; 으로 분류됩니다 . 모든 유형의 이벤트는 동일한 콜백 함수에서 처리되는 지정된 상태에 대한 것이며 해당 함수는 &lt;code&gt;EventType&lt;/code&gt; 및 &lt;code&gt;EventContent&lt;/code&gt; 를 인수로 가져옵니다 . &lt;code&gt;EventContent&lt;/code&gt; 의 의미 는 &lt;code&gt;EventType&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7847d251c9660fc6d96dabda7ed27b680ad398c1" translate="yes" xml:space="preserve">
          <source>Events are categorized in different &lt;code&gt;event types&lt;/code&gt;. Events of all types are for a given state handled in the same callback function, and that function gets &lt;code&gt;EventType&lt;/code&gt; and &lt;code&gt;EventContent&lt;/code&gt; as arguments.</source>
          <target state="translated">이벤트는 다른 &lt;code&gt;event types&lt;/code&gt; 으로 분류됩니다 . 모든 유형의 이벤트는 동일한 콜백 함수에서 처리 된 주어진 상태에 대한 것이며 해당 함수는 &lt;code&gt;EventType&lt;/code&gt; 및 &lt;code&gt;EventContent&lt;/code&gt; 를 인수로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="165331d3b21b2eecb28815ac933dc3752823c675" translate="yes" xml:space="preserve">
          <source>Events are handled by one callback function per state.</source>
          <target state="translated">이벤트는 상태 당 하나의 콜백 함수에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="45b4437bedf142adc160d31fd44923015b2f1648" translate="yes" xml:space="preserve">
          <source>Events are handled by one single callback function.</source>
          <target state="translated">이벤트는 하나의 단일 콜백 함수에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="71fad69818049f257b3ce053cda1b27535bab8fa" translate="yes" xml:space="preserve">
          <source>Events are of different &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;types&lt;/a&gt;&lt;/code&gt;, so the callback functions can know the origin of an event and how to respond.</source>
          <target state="translated">이벤트는 &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;types&lt;/a&gt;&lt;/code&gt; 이 다르 므로 콜백 함수는 이벤트의 출처와 응답 방법을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c62995c5001a4954ef586dc0d3e585c2eea79f3" translate="yes" xml:space="preserve">
          <source>Events are reported to the collector directly with the report function or indirectly via one or more trace clients. All reported events are first filtered thru the collector filter before they are stored by the collector. By replacing the default collector filter with a customized dito it is possible to allow any trace data as input. The collector filter is a dictionary entry with the predefined key {filter, collector} and the value is a fun of arity 1. See et_selector:make_event/1 for interface details, such as which erlang:trace/1 tuples that are accepted.</source>
          <target state="translated">이벤트는 보고서 기능을 사용하여 수집기에 직접 또는 하나 이상의 추적 클라이언트를 통해 간접적으로보고됩니다. 보고 된 모든 이벤트는 수집기에서 저장하기 전에 수집기 필터를 통해 먼저 필터링됩니다. 기본 콜렉터 필터를 사용자 정의 된 dito로 바꾸면 모든 추적 데이터를 입력으로 허용 할 수 있습니다. 콜렉터 필터는 사전 정의 된 키 {filter, collector}가있는 사전 항목이며 값은 arity 1의 재미입니다. erlang : trace / 1 튜플과 같은 인터페이스 세부 사항은 et_selector : make_event / 1을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a9c736a11774dca76a58d3eb1d49de20b4881ef3" translate="yes" xml:space="preserve">
          <source>Events that include a &lt;code&gt;WantReply&lt;/code&gt; expect the event handling process to call &lt;code&gt;&lt;a href=&quot;ssh_connection#reply_request-4&quot;&gt;ssh_connection:reply_request/4&lt;/a&gt;&lt;/code&gt; with the boolean value of &lt;code&gt;WantReply&lt;/code&gt; as the second argument.</source>
          <target state="translated">&lt;code&gt;WantReply&lt;/code&gt; 를 포함하는 이벤트는 이벤트 처리 프로세스가 부울 값 &lt;code&gt;WantReply&lt;/code&gt; 의 두 번째 인수로 &lt;code&gt;&lt;a href=&quot;ssh_connection#reply_request-4&quot;&gt;ssh_connection:reply_request/4&lt;/a&gt;&lt;/code&gt; 를 호출 할 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="c77837dc77a2f8d9e868b2ce0c78db1ef18e1a8c" translate="yes" xml:space="preserve">
          <source>Every SSH server presents a public key - the</source>
          <target state="translated">모든 SSH 서버는 공개 키를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb80ed10e8bdc1055fae48fa100d04d8a65eb7ee" translate="yes" xml:space="preserve">
          <source>Every abstract syntax tree has a &lt;strong&gt;type&lt;/strong&gt;, given by the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;. In addition, each syntax tree has a list of &lt;strong&gt;user annotations&lt;/strong&gt; (cf. &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt;), which are included in the Core Erlang syntax.</source>
          <target state="translated">모든 추상 구문 트리가이 &lt;strong&gt;유형의&lt;/strong&gt; 함수로 주어진 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; . 또한 각 구문 트리에는 Core Erlang 구문에 포함 된 &lt;strong&gt;사용자 주석&lt;/strong&gt; 목록 (참조 : &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt; )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db09d6e95601464c273e6d5a1621d9b7526c090" translate="yes" xml:space="preserve">
          <source>Every abstract syntax tree node has a &lt;strong&gt;type&lt;/strong&gt;, given by the function &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt;. Each node also has associated &lt;strong&gt;attributes&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; for details. The functions &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; are generic constructor/decomposition functions for abstract syntax trees. The functions &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#concrete-1&quot;&gt;concrete/1&lt;/a&gt;&lt;/code&gt; convert between constant Erlang terms and their syntactic representations. The set of syntax tree nodes is extensible through the &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">모든 추상 구문 트리 노드에는 &lt;code&gt;&lt;a href=&quot;#type-1&quot;&gt;type/1&lt;/a&gt;&lt;/code&gt; 함수 가 제공하는 &lt;strong&gt;유형이&lt;/strong&gt; 있습니다. 각 노드에는 관련 &lt;strong&gt;속성이 있습니다&lt;/strong&gt; . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오. 기능은 &lt;code&gt;&lt;a href=&quot;#make_tree-2&quot;&gt;make_tree/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#subtrees-1&quot;&gt;subtrees/1&lt;/a&gt;&lt;/code&gt; 추상 구문 나무에 대한 일반적인 생성자 / 분해 기능입니다. &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#concrete-1&quot;&gt;concrete/1&lt;/a&gt;&lt;/code&gt; 함수 는 상수 Erlang 항과 구문 표현간에 변환됩니다. 구문 트리 노드 세트는 &lt;code&gt;&lt;a href=&quot;#tree-2&quot;&gt;tree/2&lt;/a&gt;&lt;/code&gt; 함수를 통해 확장 가능 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7dd58f86011ba4a1b6cef27d0e0dba439b5153e5" translate="yes" xml:space="preserve">
          <source>Every data item is initialized, so that no problems arise when a newly created port is closed (without there being any corresponding socket). This routine is called when &lt;code&gt;open_port({spawn, &quot;uds_drv&quot;},[])&lt;/code&gt; is called from Erlang.</source>
          <target state="translated">모든 데이터 항목이 초기화되므로 새로 작성된 포트가 닫힐 때 (해당 소켓이없는 경우) 문제가 발생하지 않습니다. 이 루틴은 &lt;code&gt;open_port({spawn, &quot;uds_drv&quot;},[])&lt;/code&gt; 호출 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf159265ffc329d6f87d5f1f3acf869fdc230697" translate="yes" xml:space="preserve">
          <source>Every driver instance has an associated queue. This queue is a &lt;code&gt;SysIOVec&lt;/code&gt;, which works as a buffer. It is mostly used for the driver to buffer data that is to be written to a device, it is a byte stream. If the port owner process closes the driver, and the queue is not empty, the driver is not closed. This enables the driver to flush its buffers before closing.</source>
          <target state="translated">모든 드라이버 인스턴스에는 관련 대기열이 있습니다. 이 큐는 &lt;code&gt;SysIOVec&lt;/code&gt; 이며 버퍼로 작동합니다. 드라이버가 장치에 쓸 데이터를 버퍼링하는 데 주로 사용되며 바이트 스트림입니다. 포트 소유자 프로세스가 드라이버를 닫고 큐가 비어 있지 않으면 드라이버가 닫히지 않습니다. 이를 통해 드라이버는 닫기 전에 버퍼를 플러시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe006e1d3501395c1f8302dec32bffa876b02599" translate="yes" xml:space="preserve">
          <source>Every example using Ets has a corresponding example in Mnesia. In general, all Ets examples also apply to Dets tables.</source>
          <target state="translated">Ets를 사용하는 모든 예제에는 Mnesia에서 해당 예제가 있습니다. 일반적으로 모든 Ets 예제는 Dets 테이블에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f98b751bedf90709a631ac9f5af2c36ba06f1b60" translate="yes" xml:space="preserve">
          <source>Every message in the handshake starts with a 16-bit big-endian integer, which contains the message length (not counting the two initial bytes). In Erlang this corresponds to option &lt;code&gt;{packet, 2}&lt;/code&gt; in &lt;code&gt;gen_tcp(3)&lt;/code&gt;. Notice that after the handshake, the distribution switches to 4 byte packet headers.</source>
          <target state="translated">핸드 셰이크의 모든 메시지는 16 비트 빅 엔디안 정수로 시작하며 여기에는 메시지 길이가 포함됩니다 (두 개의 초기 바이트는 제외). 얼랑이 대응 옵션 &lt;code&gt;{packet, 2}&lt;/code&gt; 에서 &lt;code&gt;gen_tcp(3)&lt;/code&gt; . 핸드 셰이크 후 분배는 4 바이트 패킷 헤더로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d18488ccd5e8ec925e053a5841a60789f8af7c" translate="yes" xml:space="preserve">
          <source>Every occurrence of &lt;code&gt;?server_node&lt;/code&gt; in &lt;code&gt;mess_server.erl&lt;/code&gt; is now replaced by &lt;code&gt;messenger@super&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mess_server.erl&lt;/code&gt; 에서 모든 &lt;code&gt;?server_node&lt;/code&gt; 가 이제 &lt;code&gt;messenger@super&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="22006f1bcd18f6440b909a3770c9fb3d13758168" translate="yes" xml:space="preserve">
          <source>Every option can be specified without parameters, the default value is then applied. Values to the options are supplied &lt;strong&gt;only&lt;/strong&gt; when the default is not to be used. For example, &lt;code&gt;erlsrv set myservice -prio -arg&lt;/code&gt; sets the default priority and removes all arguments.</source>
          <target state="translated">모든 옵션은 매개 변수없이 지정할 수 있으며 기본값이 적용됩니다. 옵션 값 은 기본값을 사용하지 않을 경우 &lt;strong&gt;에만&lt;/strong&gt; 제공 됩니다. 예를 들어, &lt;code&gt;erlsrv set myservice -prio -arg&lt;/code&gt; 는 기본 우선 순위를 설정하고 모든 인수를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="badc67251af42d5f0d638c18181eea29b7067b0a" translate="yes" xml:space="preserve">
          <source>Every process is a member of some process group and all groups have a &lt;strong&gt;group leader&lt;/strong&gt;. All I/O from the group is channeled to the group leader. When a new process is spawned, it gets the same group leader as the spawning process. Initially, at system startup, &lt;code&gt;init&lt;/code&gt; is both its own group leader and the group leader of all processes.</source>
          <target state="translated">모든 프로세스는 일부 프로세스 그룹의 구성원이며 모든 그룹에는 &lt;strong&gt;그룹 리더가&lt;/strong&gt; 있습니다. 그룹의 모든 I / O는 그룹 리더에게 전달됩니다. 새로운 프로세스가 생성되면 생성 프로세스와 동일한 그룹 리더가 생성됩니다. 처음에 시스템 시작시 &lt;code&gt;init&lt;/code&gt; 는 자체 그룹 리더이자 모든 프로세스의 그룹 리더입니다.</target>
        </trans-unit>
        <trans-unit id="43c3a91d6b4ea7a02719788c26f7335b409720d6" translate="yes" xml:space="preserve">
          <source>Every term object we can reach is copied to the &lt;strong&gt;to space&lt;/strong&gt; and stored on top off the &lt;strong&gt;scan stop&lt;/strong&gt; line, and then the scan stop is moved to the end of the last object.</source>
          <target state="translated">우리가 도달 할 수있는 모든 용어 객체는 &lt;strong&gt;공간에&lt;/strong&gt; 복사되고 &lt;strong&gt;스캔 정지선의&lt;/strong&gt; 맨 위에 저장되고 스캔 정지는 마지막 객체의 끝으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="640d27e25498fb0f2f92c0b0862b959aec5e5da9" translate="yes" xml:space="preserve">
          <source>Every time a chunk of bytes is transferred the following call is made:</source>
          <target state="translated">바이트 청크가 전송 될 때마다 다음 호출이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c5357adfd99b22af4351c1d88ef0a99dd140b6fa" translate="yes" xml:space="preserve">
          <source>Every time a daemon &lt;code&gt;&lt;a href=&quot;#running-an-erlang-ssh-daemon&quot;&gt;is started&lt;/a&gt;&lt;/code&gt;, it enables one-time execution of commands as described in the &lt;code&gt;&lt;a href=&quot;#simple-client-example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; unless explicitly disabled.</source>
          <target state="translated">데몬 &lt;code&gt;&lt;a href=&quot;#running-an-erlang-ssh-daemon&quot;&gt;is started&lt;/a&gt;&lt;/code&gt; 때마다 명시 적으로 비활성화하지 않는 한 &lt;code&gt;&lt;a href=&quot;#simple-client-example&quot;&gt;previous section&lt;/a&gt;&lt;/code&gt; 에서 설명한대로 명령을 한 번만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="300d68a2f054e9edab4217e7742c82912ef03b64" translate="yes" xml:space="preserve">
          <source>Every time a random number is requested, a state is used to calculate it and a new state is produced. The state can either be implicit or be an explicit argument and return value.</source>
          <target state="translated">난수가 요청 될 때마다 상태가 계산에 사용되어 새로운 상태가 생성됩니다. 상태는 암시 적이거나 명시적인 인수 및 반환 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b10cda9999da6d5b101f56f3f30001473abe8ca" translate="yes" xml:space="preserve">
          <source>Every time a random number is requested, a state is used to calculate it, and a new state is produced. The state can either be implicit (kept in the process dictionary) or be an explicit argument and return value. In this implementation, the state (the type &lt;code&gt;ran()&lt;/code&gt;) consists of a tuple of three integers.</source>
          <target state="translated">난수가 요청 될 때마다 상태가 계산에 사용되어 새로운 상태가 생성됩니다. 상태는 암시 적이거나 (프로세스 사전에 유지됨) 명시 적 인수 및 반환 값일 수 있습니다. 이 구현에서 상태 ( &lt;code&gt;ran()&lt;/code&gt; 유형 )는 3 개의 정수로 구성된 튜플로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1d72125a0c8f02c7a0e8ecbae2be3404d4787cc4" translate="yes" xml:space="preserve">
          <source>Everything following &lt;code&gt;--&lt;/code&gt; up to the next flag (&lt;code&gt;-flag&lt;/code&gt; or &lt;code&gt;+flag&lt;/code&gt;) is considered plain arguments and can be retrieved using &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt;.</source>
          <target state="translated">모든 다음 &lt;code&gt;--&lt;/code&gt; 최대 다음 플래그 ( &lt;code&gt;-flag&lt;/code&gt; 또는 &lt;code&gt;+flag&lt;/code&gt; ) 일반 인수 간주되며 사용하여 검색 할 수 있습니다 &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d95dd812bd3d238de2a55a6a4023e060a98b88e6" translate="yes" xml:space="preserve">
          <source>Everything following &lt;code&gt;--&lt;/code&gt; up to the next flag is considered plain arguments and can be retrieved using &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt; get_plain_arguments/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모두의 다음 &lt;code&gt;--&lt;/code&gt; 다음 플래그까지 일반 인수로 간주되며 사용하여 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt; get_plain_arguments/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05a72a6b72c1a94decb7dbf00a0ed42ed8037983" translate="yes" xml:space="preserve">
          <source>Everything following &lt;code&gt;--&lt;/code&gt; up to the next flag is considered plain arguments and can be retrieved using &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt;get_plain_arguments/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모두의 다음 &lt;code&gt;--&lt;/code&gt; 다음 플래그까지 일반 인수로 간주되며 사용하여 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt;get_plain_arguments/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15ece633b6db7b6e6411aedb27fcb438934f6610" translate="yes" xml:space="preserve">
          <source>Everything following &lt;code&gt;-extra&lt;/code&gt; is considered plain arguments and can be retrieved using &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt; get_plain_arguments/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 다음 &lt;code&gt;-extra&lt;/code&gt; 일반 인자로 간주되며 사용하여 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt; get_plain_arguments/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15dc2091ac56caf50d53f7d394787b6e1d601a01" translate="yes" xml:space="preserve">
          <source>Everything following &lt;code&gt;-extra&lt;/code&gt; is considered plain arguments and can be retrieved using &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt;get_plain_arguments/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모든 다음 &lt;code&gt;-extra&lt;/code&gt; 일반 인자로 간주되며 사용하여 검색 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;#get_plain_arguments-0&quot;&gt;get_plain_arguments/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e18a20a8f88b47c5d6740bd605c3c315ac0e9a15" translate="yes" xml:space="preserve">
          <source>Everything following &lt;code&gt;-extra&lt;/code&gt; is considered plain arguments and can be retrieved using &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt;.</source>
          <target state="translated">모든 다음 &lt;code&gt;-extra&lt;/code&gt; 일반 인자로 간주되며 사용하여 검색 할 수 있습니다 &lt;code&gt;init:get_plain_arguments/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5b2d53da87bdb661a8a780b52c6879c89fb595d" translate="yes" xml:space="preserve">
          <source>Everything that &lt;code&gt;Common Test&lt;/code&gt; normally prints in the test case logs, are in the interactive mode written to a log named &lt;code&gt;ctlog.html&lt;/code&gt; in directory &lt;code&gt;ct_run.&amp;lt;timestamp&amp;gt;&lt;/code&gt;. A link to this file is available in the file named &lt;code&gt;last_interactive.html&lt;/code&gt; in the directory from which you execute &lt;code&gt;ct_run&lt;/code&gt;. Specifying a different root directory for the logs than the current working directory is not supported.</source>
          <target state="translated">모든 것을 &lt;code&gt;Common Test&lt;/code&gt; 일반적으로 테스트 케이스 로그에 인쇄, 로그라는 이름에 기록 된 대화 형 모드에 &lt;code&gt;ctlog.html&lt;/code&gt; 디렉토리에 &lt;code&gt;ct_run.&amp;lt;timestamp&amp;gt;&lt;/code&gt; . 이 파일에 대한 링크라는 이름의 파일에서 사용할 수 &lt;code&gt;last_interactive.html&lt;/code&gt; 당신이 실행되는 디렉토리에 &lt;code&gt;ct_run&lt;/code&gt; 을 . 현재 작업 디렉토리와 다른 로그 디렉토리를 지정하는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc7d94692ef50a30f1f29540dc86e6c8c0dd9c08" translate="yes" xml:space="preserve">
          <source>Everything that is written as a function call is translated into a match specification call to a built-in function, so that the call &lt;code&gt;is_list(X)&lt;/code&gt; is translated to &lt;code&gt;{'is_list', '$1'}&lt;/code&gt; (&lt;code&gt;'$1'&lt;/code&gt; is only an example, the numbering can vary). If one tries to call a function that is not a match specification built-in, it causes an error.</source>
          <target state="translated">함수 호출로 작성된 모든 것은 내장 함수에 대한 일치 스펙 호출로 변환되므로 &lt;code&gt;is_list(X)&lt;/code&gt; 호출 은 &lt;code&gt;{'is_list', '$1'}&lt;/code&gt; ( &lt;code&gt;'$1'&lt;/code&gt; 은 예일뿐입니다) 번호 매기기는 다를 수 있습니다). 내장 된 일치 스펙이 아닌 함수를 호출하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aebb4f61c05e9fe7cd21d9f4c985e211fc4010be" translate="yes" xml:space="preserve">
          <source>Everything up to and including the call to the handler callbacks is executed on the client process, that is, the process where the log event was issued. It is up to the handler implementation if other processes are involved or not.</source>
          <target state="translated">핸들러 콜백에 대한 호출을 포함하여 모든 것을 클라이언트 프로세스, 즉 로그 이벤트가 발행 된 프로세스에서 실행합니다. 다른 프로세스가 관련되어 있는지 여부는 핸들러 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bd1b78f202fd8c93b4609c3c0d3da13ed54bafa" translate="yes" xml:space="preserve">
          <source>Everything written to &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; is logged in &lt;code&gt;log_dir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 및 &lt;code&gt;stdout&lt;/code&gt; 에 기록 된 모든 것은 &lt;code&gt;log_dir&lt;/code&gt; 에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="56ea7b40a09edbdba2f39e8646b36c087ec023fb" translate="yes" xml:space="preserve">
          <source>Exact_Reductions_Since_Last_Call}</source>
          <target state="translated">Exact_Reductions_Since_Last_Call}</target>
        </trans-unit>
        <trans-unit id="9ab8e78e980fe707ae8c80e17edf332f42ac0a84" translate="yes" xml:space="preserve">
          <source>Exactly equal to</source>
          <target state="translated">정확히 같은</target>
        </trans-unit>
        <trans-unit id="814fd19cd915eb595cb9b5182a380533aba869ab" translate="yes" xml:space="preserve">
          <source>Exactly not equal to</source>
          <target state="translated">정확히 같지 않음</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="1a24428b6d1c88d4eb72b8f12702d80b49a1d77a" translate="yes" xml:space="preserve">
          <source>Example (continued from the previous sections)</source>
          <target state="translated">예 (이전 섹션에서 계속됨)</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">예 1</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">예 2</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">예제 3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">예 4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">예제 5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">예제 6</target>
        </trans-unit>
        <trans-unit id="5da743f6856f59f85c81f30e766731f5631a39c2" translate="yes" xml:space="preserve">
          <source>Example 7</source>
          <target state="translated">예제 7</target>
        </trans-unit>
        <trans-unit id="bfa099b8439b91f3e877995de0b2196b1de1bcf9" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;{ok, PemBin} = file:read_file(&quot;cert.pem&quot;). PemEntries = public_key:pem_decode(PemBin).&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;{ok, PemBin} = file:read_file(&quot;cert.pem&quot;). PemEntries = public_key:pem_decode(PemBin).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba2d7fa8ce21db441399ed03cb09095a03b028bc" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;{ok, SshBin} = file:read_file(&quot;known_hosts&quot;)&lt;/code&gt;.  If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;public_key&lt;/code&gt; the binary can be either an RFC4716 public key or an OpenSSH public key.</source>
          <target state="translated">예 &lt;code&gt;{ok, SshBin} = file:read_file(&quot;known_hosts&quot;)&lt;/code&gt; . 경우 &lt;code&gt;Type&lt;/code&gt; 입니다 &lt;code&gt;public_key&lt;/code&gt; 바이너리는 RFC4716 공개 키 또는 OpenSSH의 공개 키가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc0baf4a8904cd2f39b8584a9758f9b555e1a6e" translate="yes" xml:space="preserve">
          <source>Example AVP with a Grouped Data Type</source>
          <target state="translated">그룹화 된 데이터 유형의 AVP 예</target>
        </trans-unit>
        <trans-unit id="a16d51d95de1ddfa7c6f576aa0ae5013e3226291" translate="yes" xml:space="preserve">
          <source>Example log entry:</source>
          <target state="translated">로그 항목 예 :</target>
        </trans-unit>
        <trans-unit id="cd7a90921a7718cc39b25f7cf95e96e90a9567e9" translate="yes" xml:space="preserve">
          <source>Example of Receiving Messages</source>
          <target state="translated">메시지 수신 예</target>
        </trans-unit>
        <trans-unit id="3e3428b47848dd7a6b86a04fc8ff8e144e7cf2f4" translate="yes" xml:space="preserve">
          <source>Example of Sending Messages</source>
          <target state="translated">메시지 전송 예</target>
        </trans-unit>
        <trans-unit id="c033f4cb1a39077831e4d18ec562f46497f70870" translate="yes" xml:space="preserve">
          <source>Example of Use</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="259e82c03c6d72a1534c5a285ed0a1db7171c095" translate="yes" xml:space="preserve">
          <source>Example of a simple client:</source>
          <target state="translated">간단한 클라이언트의 예 :</target>
        </trans-unit>
        <trans-unit id="92f4ee548532cd5f51debcfffc43bb04c687772e" translate="yes" xml:space="preserve">
          <source>Example of adding a disk_log handler:</source>
          <target state="translated">disk_log 핸들러 추가 예 :</target>
        </trans-unit>
        <trans-unit id="257937feb84c0e6400b75ebee327d1d5777a1942" translate="yes" xml:space="preserve">
          <source>Example of adding a standard handler:</source>
          <target state="translated">표준 핸들러를 추가하는 예 :</target>
        </trans-unit>
        <trans-unit id="e61b0fec33e2bc15076eaa9e67698b83b16ba6fa" translate="yes" xml:space="preserve">
          <source>Example of an Erlang SCTP client interacting with the above server. Notice that in this example the client creates an association with the server with 5 outbound streams. Therefore, sending of &lt;code&gt;&quot;Test 0&quot;&lt;/code&gt; over stream 0 succeeds, but sending of &lt;code&gt;&quot;Test 5&quot;&lt;/code&gt; over stream 5 fails. The client then &lt;code&gt;abort&lt;/code&gt;s the association, which results in that the corresponding event is received on the server side.</source>
          <target state="translated">위 서버와 상호 작용하는 Erlang SCTP 클라이언트의 예 이 예제에서 클라이언트는 5 개의 아웃 바운드 스트림으로 서버와의 연관을 작성합니다. 따라서 스트림 0을 통한 &lt;code&gt;&quot;Test 0&quot;&lt;/code&gt; 전송은 성공하지만 스트림 5를 통한 &lt;code&gt;&quot;Test 5&quot;&lt;/code&gt; 전송은 실패합니다. 그런 다음 클라이언트 는 연결 을 &lt;code&gt;abort&lt;/code&gt; 하여 해당 이벤트가 서버 측에서 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd6e11a8bb0797932289d1cfbe298d6e0bf1187" translate="yes" xml:space="preserve">
          <source>Example of an Erlang SCTP server that receives SCTP messages and prints them on the standard output:</source>
          <target state="translated">SCTP 메시지를 수신하여 표준 출력에 인쇄하는 Erlang SCTP 서버의 예 :</target>
        </trans-unit>
        <trans-unit id="c892c47c216acb35b2b73747d814f80a00aef608" translate="yes" xml:space="preserve">
          <source>Example of an application callback module for packaging the supervision tree from &lt;code&gt;&lt;a href=&quot;sup_princ#ex&quot;&gt;Supervisor Behaviour&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sup_princ#ex&quot;&gt;Supervisor Behaviour&lt;/a&gt;&lt;/code&gt; 에서 감독 트리를 패키징하기위한 응용 프로그램 콜백 모듈의 예 :</target>
        </trans-unit>
        <trans-unit id="a5de6a649cc26a8a393636ddbbbe886cd7ead9a5" translate="yes" xml:space="preserve">
          <source>Example of binary sharing:</source>
          <target state="translated">이진 공유의 예 :</target>
        </trans-unit>
        <trans-unit id="2ed9364b6b6eda2982219aeedbe9334d5db4a40b" translate="yes" xml:space="preserve">
          <source>Example of code formatting a string in format &quot;DD Mon YYYY HH:MM:SS.mmmmmm&quot;, where DD is the day of month, Mon is the textual month name, YYYY is the year, HH:MM:SS is the time, and mmmmmm is the microseconds in six positions:</source>
          <target state="translated">&quot;DD Mon YYYY HH : MM : SS.mmmmmm&quot;형식으로 문자열을 형식화하는 코드 예제 (여기서 DD는 월, Mon은 텍스트 월 이름, YYYY는 연도, HH : MM : SS는 시간, mmmmmm은 6 개의 위치에서 마이크로 초입니다.</target>
        </trans-unit>
        <trans-unit id="0247a3b1500c047105261cd1995debe4a9e51e84" translate="yes" xml:space="preserve">
          <source>Example of crypto_one_time/5</source>
          <target state="translated">crypto_one_time / 5의 예</target>
        </trans-unit>
        <trans-unit id="3989d5d63755f1628f5bdb305669cc612eb70348" translate="yes" xml:space="preserve">
          <source>Example of crypto_one_time_aead/6</source>
          <target state="translated">crypto_one_time_aead / 6의 예</target>
        </trans-unit>
        <trans-unit id="6ff82e78129f4624e6e01b48fadeda10f23ed3f1" translate="yes" xml:space="preserve">
          <source>Example of explicit inlining:</source>
          <target state="translated">명시 적 인라이닝의 예 :</target>
        </trans-unit>
        <trans-unit id="41239b64ed24527303ab88a73628c1b79d9ccf46" translate="yes" xml:space="preserve">
          <source>Example of implicit inlining:</source>
          <target state="translated">암시 적 인라이닝의 예 :</target>
        </trans-unit>
        <trans-unit id="7761fdb7a43463d391b2cbd277d752ec9d80303c" translate="yes" xml:space="preserve">
          <source>Example of mac_init mac_update and mac_final</source>
          <target state="translated">mac_init mac_update 및 mac_final의 예</target>
        </trans-unit>
        <trans-unit id="455ac420f5ccac25a8eff8f4bd83568d3ba54d9e" translate="yes" xml:space="preserve">
          <source>Example of modify_algorithms handling</source>
          <target state="translated">modify_algorithms 처리의 예</target>
        </trans-unit>
        <trans-unit id="69c15f54f6b590ab9d5aa5d54ff663033104b7e4" translate="yes" xml:space="preserve">
          <source>Example of the difference between a scope and taking the binary apart before splitting:</source>
          <target state="translated">스코프와 분리하기 전에 바이너리를 분리하는 것의 차이점 예 :</target>
        </trans-unit>
        <trans-unit id="d3ed33f631d347621c783c9afb4661ccb7def68b" translate="yes" xml:space="preserve">
          <source>Example of use of parameterization:</source>
          <target state="translated">매개 변수화 사용 예 :</target>
        </trans-unit>
        <trans-unit id="e3d123bd678798098b5c565abc608f2e839f2796" translate="yes" xml:space="preserve">
          <source>Example of writing and then reading a tar file follows:</source>
          <target state="translated">tar 파일을 작성하고 읽는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f9b077b61bd8601d8f795dfc56887f0249c0476" translate="yes" xml:space="preserve">
          <source>Example on how the simple debugging functions in the &lt;code&gt;sys&lt;/code&gt; module can also be used for &lt;code&gt;ch4&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; 모듈 의 간단한 디버깅 기능 을 &lt;code&gt;ch4&lt;/code&gt; 에 사용 하는 방법에 대한 예제 :</target>
        </trans-unit>
        <trans-unit id="66faa77852fffe84221ab71b0648ab3d81646cf6" translate="yes" xml:space="preserve">
          <source>Example where the BER encoder is able to omit encoding of the default values:</source>
          <target state="translated">BER 인코더가 기본값의 인코딩을 생략 할 수있는 예 :</target>
        </trans-unit>
        <trans-unit id="21d42770ccbe68c107da172aeb7c01ef2572447c" translate="yes" xml:space="preserve">
          <source>Example with a named &lt;code&gt;BIT STRING&lt;/code&gt; where the BER encoder does not omit the encoding:</source>
          <target state="translated">BER 인코더가 인코딩을 생략하지 않은 &lt;code&gt;BIT STRING&lt;/code&gt; 이라는 이름의 예제 :</target>
        </trans-unit>
        <trans-unit id="2e0e79bf70def092ed8def36eddd985bb90f55e1" translate="yes" xml:space="preserve">
          <source>Example with dbg</source>
          <target state="translated">dbg를 사용한 예</target>
        </trans-unit>
        <trans-unit id="f5b63d928048e9c9faf6383eb6026e9de3c6953f" translate="yes" xml:space="preserve">
          <source>Example with encryption</source>
          <target state="translated">암호화를 사용한 예</target>
        </trans-unit>
        <trans-unit id="071bf1611219ab8d85fa01f40dea82854fdc5a91" translate="yes" xml:space="preserve">
          <source>Example {ok, PemBin} = file:read_file(&quot;cert.pem&quot;).</source>
          <target state="translated">예 {ok, PemBin} = 파일 : read_file ( &quot;cert.pem&quot;).</target>
        </trans-unit>
        <trans-unit id="0b596e219254e23717a6ee1ae566c501aed8e376" translate="yes" xml:space="preserve">
          <source>Example, format string and arguments:</source>
          <target state="translated">예를 들어, 형식 문자열 및 인수 :</target>
        </trans-unit>
        <trans-unit id="c7f3119075091db20fbaaa4b03e30bf30907b234" translate="yes" xml:space="preserve">
          <source>Example, original XSLT:</source>
          <target state="translated">예, 원래 XSLT :</target>
        </trans-unit>
        <trans-unit id="d2e1e9e85b4575594ca4919d15b945195fc1eabc" translate="yes" xml:space="preserve">
          <source>Example, report, and metadata with report callback:</source>
          <target state="translated">보고서 콜백이 포함 된 예, 보고서 및 메타 데이터 :</target>
        </trans-unit>
        <trans-unit id="b1772662009d00d418a5d08f50fc932734f65274" translate="yes" xml:space="preserve">
          <source>Example, string:</source>
          <target state="translated">예를 들어, 문자열 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2c85c5048a0fd6f2ad8a665b845c95aba030b32e" translate="yes" xml:space="preserve">
          <source>Example: &quot;*.ericsson.se&quot;</source>
          <target state="translated">예 : &quot;* .ericsson.se&quot;</target>
        </trans-unit>
        <trans-unit id="b2ae51b4e97e5170ba3750d09dc6e2c5ace7a162" translate="yes" xml:space="preserve">
          <source>Example: &quot;134.138&quot; or &quot;[FEDC:BA98&quot; (all IP addresses starting with 134.138 or FEDC:BA98), &quot;66.35.250.150&quot; or &quot;[2010:836B:4179::836B:4179]&quot; (a complete IP address). &lt;code&gt;proxy&lt;/code&gt; defaults to &lt;code&gt;{undefined, []}&lt;/code&gt;, that is, no proxy is configured and &lt;code&gt;https_proxy&lt;/code&gt; defaults to the value of &lt;code&gt;proxy&lt;/code&gt;.  Maximum number of persistent connections to a host. Default is &lt;code&gt;2&lt;/code&gt;.  Maximum number of outstanding requests on the same connection to a host. Default is &lt;code&gt;5&lt;/code&gt;.  If a persistent connection is idle longer than the &lt;code&gt;keep_alive_timeout&lt;/code&gt; in milliseconds, the client closes the connection. The server can also have such a time-out but do not take that for granted. Default is &lt;code&gt;120000&lt;/code&gt; (= 2 min).  Maximum number of outstanding requests on a pipelined connection to a host. Default is &lt;code&gt;2&lt;/code&gt;.  If a persistent connection is idle longer than the &lt;code&gt;pipeline_timeout&lt;/code&gt; in milliseconds, the client closes the connection. Default is &lt;code&gt;0&lt;/code&gt;, which results in pipelining not being used.  If cookies are enabled, all valid cookies are automatically saved in the cookie database of the client manager. If option &lt;code&gt;verify&lt;/code&gt; is used, function &lt;code&gt;store_cookies/2&lt;/code&gt; has to be called for the cookies to be saved. Default is &lt;code&gt;disabled&lt;/code&gt;.  Default is &lt;code&gt;inet&lt;/code&gt;.  If the host has several network interfaces, this option specifies which one to use. See &lt;code&gt;gen_tcp:connect/3,4&lt;/code&gt; for details.  Local port number to use. See &lt;code&gt;gen_tcp:connect/3,4&lt;/code&gt; for details.  The options are appended to the socket options used by the client. These are the default values when a new request handler is started (for the initial connect). They are passed directly to the underlying transport (&lt;code&gt;gen_tcp&lt;/code&gt; or &lt;code&gt;SSL&lt;/code&gt;) &lt;strong&gt;without&lt;/strong&gt; verification.  Default is &lt;code&gt;false&lt;/code&gt;. This option is used to switch on (or off) different levels of Erlang trace on the client. It is a debug feature.  When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can be used.   Experimental option for sending HTTP requests over a unix domain socket. The value of &lt;code&gt;unix_socket&lt;/code&gt; shall be the full path to a unix domain socket file with read/write permissions for the erlang process. Default is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">예 : &quot;134.138&quot;또는 &quot;[FEDC : BA98&quot;(134.138 또는 FEDC : BA98로 시작하는 모든 IP 주소), &quot;66.35.250.150&quot;또는 &quot;[2010 : 836B : 4179 :: 836B : 4179]&quot;(전체 IP 주소 ). &lt;code&gt;proxy&lt;/code&gt; 의 기본값은 &lt;code&gt;{undefined, []}&lt;/code&gt; . 즉, 프록시가 구성되지 않으며 &lt;code&gt;https_proxy&lt;/code&gt; 의 기본값은 &lt;code&gt;proxy&lt;/code&gt; 값입니다 . 호스트에 대한 최대 영구 연결 수 기본값은 &lt;code&gt;2&lt;/code&gt; 입니다. 호스트와 동일한 연결에서 처리되지 않은 최대 요청 수 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다. 영구 연결이 &lt;code&gt;keep_alive_timeout&lt;/code&gt; (밀리 초) 보다 오래 유휴 상태 이면 클라이언트가 연결을 닫습니다. 서버는 또한 그러한 시간 제한을 가질 수 있지만 당연한 것으로 간주하지는 않습니다.기본값은 &lt;code&gt;120000&lt;/code&gt; 입니다(= 2 분). 호스트에 대한 파이프 라인 연결에서 처리되지 않은 최대 요청 수입니다. 기본값은 &lt;code&gt;2&lt;/code&gt; 입니다. 지속적 연결이 &lt;code&gt;pipeline_timeout&lt;/code&gt; (밀리 초) 보다 오래 유휴 상태 이면 클라이언트가 연결을 닫습니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 이므로 파이프 라이닝이 사용되지 않습니다. 쿠키가 활성화되면 유효한 모든 쿠키가 클라이언트 관리자의 쿠키 데이터베이스에 자동 저장됩니다. 옵션 &lt;code&gt;verify&lt;/code&gt; 을 사용 하는 경우 쿠키를 저장하려면 함수 &lt;code&gt;store_cookies/2&lt;/code&gt; 를 호출해야합니다. 기본값은 &lt;code&gt;disabled&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;inet&lt;/code&gt; 입니다. 호스트에 여러 개의 네트워크 인터페이스가있는 경우이 옵션은 사용할 인터페이스를 지정합니다. 참조 &lt;code&gt;gen_tcp:connect/3,4&lt;/code&gt; 자세한 내용은. 사용할 로컬 포트 ​​번호. 자세한 내용은 &lt;code&gt;gen_tcp:connect/3,4&lt;/code&gt; 를 참조하십시오. 옵션은 클라이언트가 사용하는 소켓 옵션에 추가됩니다. 새 요청 핸들러가 시작될 때의 기본값입니다 (초기 연결의 경우). 검증 &lt;strong&gt;없이&lt;/strong&gt; 기본 전송 ( &lt;code&gt;gen_tcp&lt;/code&gt; 또는 &lt;code&gt;SSL&lt;/code&gt; )으로 직접 전달됩니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이 옵션은 클라이언트에서 다른 레벨의 Erlang 추적을 켜거나 끄는 데 사용됩니다. 디버그 기능입니다. &lt;code&gt;stand_alone&lt;/code&gt; 을 시작 하면 pid 만 사용할 수 있습니다. 유닉스 도메인 소켓을 통해 HTTP 요청을 보내기위한 실험적인 옵션. &lt;code&gt;unix_socket&lt;/code&gt; 의 값&lt;strong&gt;&lt;/strong&gt;erlang 프로세스에 대한 읽기 / 쓰기 권한이있는 유닉스 도메인 소켓 파일의 전체 경로입니다. 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b3175948f95c9236a95514c9d3ce6d7dd382459" translate="yes" xml:space="preserve">
          <source>Example: &quot;localhost&quot; or &quot;foo.bar.se&quot;</source>
          <target state="translated">예 : &quot;localhost&quot;또는 &quot;foo.bar.se&quot;</target>
        </trans-unit>
        <trans-unit id="1cbe235094a7eaf3982330da84d2f14f623438f6" translate="yes" xml:space="preserve">
          <source>Example: 8080</source>
          <target state="translated">예 : 8080</target>
        </trans-unit>
        <trans-unit id="9a831d667d70b70073d5aeb535e6c977f70c4cef" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;foo/bar, ../src&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;foo/bar, ../src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd8760bbb5b7eae747250f32afc437ca7e4f743f" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;ttb:format(Dir, [{handler, ttb:get_et_handler()}])&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;ttb:format(Dir, [{handler, ttb:get_et_handler()}])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75991fdff1875f6b31175141a766d22172489d1c" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;{ok, SshBin} = file:read_file(&quot;known_hosts&quot;)&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;{ok, SshBin} = file:read_file(&quot;known_hosts&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7565f88b0cf269abb97f97f13ea8991917de3281" translate="yes" xml:space="preserve">
          <source>Example: A child specification to start another supervisor:</source>
          <target state="translated">예 : 다른 감독자를 시작하기위한 하위 사양 :</target>
        </trans-unit>
        <trans-unit id="43c8ff0fb5ae1694c8b3e3346c964f04ec161404" translate="yes" xml:space="preserve">
          <source>Example: A child specification to start the event manager from the chapter about &lt;code&gt;&lt;a href=&quot;events#mgr&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">예 : &lt;code&gt;&lt;a href=&quot;events#mgr&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; 관련 장에서 이벤트 관리자를 시작하기위한 하위 스펙 :</target>
        </trans-unit>
        <trans-unit id="a54abdb1cdbb3c9abb4ef5ebd2e8fccc5eeaee84" translate="yes" xml:space="preserve">
          <source>Example: Assuming the version of &lt;code&gt;Inets&lt;/code&gt; is 5.8.1, the server header string can look as follows for the different values of server-tokens:</source>
          <target state="translated">예 : &lt;code&gt;Inets&lt;/code&gt; 버전 이 5.8.1 이라고 가정하면 서버 헤더 문자열은 다른 서버 토큰 값을 다음과 같이 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04c6ad730af6ea5627d583f0288c57ab5396e115" translate="yes" xml:space="preserve">
          <source>Example: Generate XML result file in the current directory:</source>
          <target state="translated">예 : 현재 디렉토리에 XML 결과 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ad841c501682e1a5e233e774ce900d32a3035590" translate="yes" xml:space="preserve">
          <source>Example: Process &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;Tracee&lt;/code&gt;, port &lt;code&gt;B&lt;/code&gt; is tracer, and process &lt;code&gt;C&lt;/code&gt; is the port owner of &lt;code&gt;B&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; wants to close &lt;code&gt;B&lt;/code&gt; when &lt;code&gt;A&lt;/code&gt; exits. To ensure that the trace is not truncated, &lt;code&gt;C&lt;/code&gt; can call &lt;code&gt;erlang:trace_delivered(A)&lt;/code&gt; when &lt;code&gt;A&lt;/code&gt; exits, and wait for message &lt;code&gt;{trace_delivered, A, Ref}&lt;/code&gt; before closing &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">예 : 프로세스 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Tracee&lt;/code&gt; 이고 포트 &lt;code&gt;B&lt;/code&gt; 는 추적 프로그램이며 프로세스 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;B&lt;/code&gt; 의 포트 소유자입니다 . &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 가 종료 될 때 &lt;code&gt;B&lt;/code&gt; 를 닫으려고 합니다. 추적이 잘리지 않도록 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 가 종료 될 때 &lt;code&gt;erlang:trace_delivered(A)&lt;/code&gt; 호출 하고 &lt;code&gt;B&lt;/code&gt; 를 닫기 전에 &lt;code&gt;{trace_delivered, A, Ref}&lt;/code&gt; 메시지를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ff092315e07341393e0f1ec7ed4811f357fab8" translate="yes" xml:space="preserve">
          <source>Example: http, https</source>
          <target state="translated">예 : http, https</target>
        </trans-unit>
        <trans-unit id="a5fa274e21e33227f05790f6bde4a1cb52330ebc" translate="yes" xml:space="preserve">
          <source>Example: only allow debug level log events</source>
          <target state="translated">예 : 디버그 레벨 로그 이벤트 만 허용</target>
        </trans-unit>
        <trans-unit id="20847720f513dab04a46ec7d45837973040fae8b" translate="yes" xml:space="preserve">
          <source>Example: stop all events with domain &lt;code&gt;[otp, sasl | _]&lt;/code&gt;</source>
          <target state="translated">예 : 도메인 &lt;code&gt;[otp, sasl | _]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="7cb35ec28680e86766ad9c7b78a73d27a9a3396d" translate="yes" xml:space="preserve">
          <source>Examples of SetFuns:</source>
          <target state="translated">SetFuns의 예 :</target>
        </trans-unit>
        <trans-unit id="134544bca135389228bc4e2d2db5e971d7ae00b6" translate="yes" xml:space="preserve">
          <source>Examples of algorithms are aes, chacha20 and des. The keysize is the number of bits and examples of the mode are cbc, ctr and gcm. The mode may be followed by a number depending on the mode. An example is the ccm mode which has a variant called ccm8 where the so called tag has a length of eight bits.</source>
          <target state="translated">알고리즘의 예로는 aes, chacha20 및 des가 있습니다. keysize는 비트 수이며 모드의 예는 cbc, ctr 및 gcm입니다. 모드는 모드에 따라 숫자가 올 수 있습니다. 예를 들어 ccm8이라는 변형이있는 ccm 모드가 있습니다. 여기서 이른바 태그의 길이는 8 비트입니다.</target>
        </trans-unit>
        <trans-unit id="57b3113305345ea57409b2f56cb685edd560c14b" translate="yes" xml:space="preserve">
          <source>Examples of command-line flags used for distributed programming (for more information, see the &lt;code&gt;erl(1) &lt;/code&gt; manual page in ERTS:</source>
          <target state="translated">분산 프로그래밍에 사용되는 명령 줄 플래그의 예 (자세한 내용 은 ERTS 의 &lt;code&gt;erl(1) &lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1badc1ec0fc0b730bf23f5399aa9cf68a043cf4" translate="yes" xml:space="preserve">
          <source>Examples of command-line flags used for distributed programming (for more information, see the &lt;code&gt;erl(1)&lt;/code&gt; manual page in ERTS:</source>
          <target state="translated">분산 프로그래밍에 사용되는 명령 행 플래그 예 (자세한 내용 은 ERTS 의 &lt;code&gt;erl(1)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b5173e6aa497770043b334811e44d9c05598971" translate="yes" xml:space="preserve">
          <source>Examples of constants are: &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;kernel-&amp;gt;stdlib&lt;/code&gt;, &lt;code&gt;[kernel, sasl]&lt;/code&gt;, &lt;code&gt;[pg -&amp;gt; mnesia, {tv, mnesia}] : Mod&lt;/code&gt;. It is an error if an instance of &lt;code&gt;Const&lt;/code&gt; does not match any vertex of any graph. If there are more than one vertex matching an untyped instance of &lt;code&gt;AtomConst&lt;/code&gt;, then the one of the most general type is chosen. A list of constants is interpreted as a set of constants, all of the same type. A tuple of constants constitute a chain of calls (which may, but does not have to, correspond to an actual chain of calls of some graph). Assigning a type to a list or tuple of &lt;code&gt;Constant&lt;/code&gt; is equivalent to assigning the type to each &lt;code&gt;Constant&lt;/code&gt;.</source>
          <target state="translated">상수의 예는 다음과 같습니다 : &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;kernel-&amp;gt;stdlib&lt;/code&gt; , &lt;code&gt;[kernel, sasl]&lt;/code&gt; , &lt;code&gt;[pg -&amp;gt; mnesia, {tv, mnesia}] : Mod&lt;/code&gt; . &lt;code&gt;Const&lt;/code&gt; 인스턴스가 그래프의 꼭짓점과 일치하지 않으면 오류 입니다. 형식화되지 않은 &lt;code&gt;AtomConst&lt;/code&gt; 인스턴스와 일치하는 정점이 둘 이상 있으면 가장 일반적인 형식 중 하나가 선택됩니다. 상수 목록은 상수 유형으로 해석되며 모두 동일한 유형입니다. 상수의 튜플은 호출 체인을 구성합니다 (일부 그래프의 실제 호출 체인에 해당 할 수도 있지만 반드시 그런 것은 아닙니다). &lt;code&gt;Constant&lt;/code&gt; 의 목록 또는 튜플에 유형을 할당하는 것은 각 &lt;code&gt;Constant&lt;/code&gt; 유형을 할당하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d8586462aa52f15b3de4a4e3527fbc4f359471a9" translate="yes" xml:space="preserve">
          <source>Examples of crypto_init/4 and crypto_update/2</source>
          <target state="translated">crypto_init / 4 및 crypto_update / 2의 예</target>
        </trans-unit>
        <trans-unit id="4ced682e29b4a5d14fcb7d3570f707816e29c137" translate="yes" xml:space="preserve">
          <source>Examples of how to use ports and port drivers are provided in &lt;code&gt; Interoperability Tutorial&lt;/code&gt;. For information about the BIFs mentioned, see the &lt;code&gt;erlang(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">포트 및 포트 드라이버 사용 방법의 예는 &lt;code&gt; Interoperability Tutorial&lt;/code&gt; 제공됩니다 . 언급 된 BIF에 대한 정보 는 ERTS 의 &lt;code&gt;erlang(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1b77ce0775b29f1ab9f94e7bccd248c49f3880a" translate="yes" xml:space="preserve">
          <source>Examples of how to use ports and port drivers are provided in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;. For information about the BIFs mentioned, see the &lt;code&gt;erlang(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">포트 및 포트 드라이버 사용 방법의 예는 &lt;code&gt;Interoperability Tutorial&lt;/code&gt; 제공됩니다 . 언급 된 BIF에 대한 자세한 내용은 ERTS 의 &lt;code&gt;erlang(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10920cdcf5f72c6f65a01097947f1ccc92293ded" translate="yes" xml:space="preserve">
          <source>Examples of major implementation changes:</source>
          <target state="translated">주요 구현 변경 예 :</target>
        </trans-unit>
        <trans-unit id="c37c7abc8abde091516cd99236738d5779d77aff" translate="yes" xml:space="preserve">
          <source>Examples of modules useful for distributed programming:</source>
          <target state="translated">분산 프로그래밍에 유용한 모듈의 예 :</target>
        </trans-unit>
        <trans-unit id="1574314a80bbb34762d52ba35aded63df5e16aaa" translate="yes" xml:space="preserve">
          <source>Examples of operator declarations:</source>
          <target state="translated">연산자 선언의 예 :</target>
        </trans-unit>
        <trans-unit id="65ff440fda324e1bc5a759b8541e472c74da0ecc" translate="yes" xml:space="preserve">
          <source>Examples of the two ways to configure the exec evaluator:</source>
          <target state="translated">실행 평가자를 구성하는 두 가지 방법의 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="b22f1170131d7c377523b5a417e571674b601b1c" translate="yes" xml:space="preserve">
          <source>Exceeded storage allocation (for current directory or dataset) [552].</source>
          <target state="translated">스토리지 할당 초과 (현재 디렉토리 또는 데이터 세트) [552].</target>
        </trans-unit>
        <trans-unit id="057189a0abbff4fddcb1d8828627f2916b93faf9" translate="yes" xml:space="preserve">
          <source>Except for the &lt;code&gt;write&lt;/code&gt; atom, the following atoms can be added to &lt;code&gt;OpenModeList&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 원자를 제외하고 다음 원자를 &lt;code&gt;OpenModeList&lt;/code&gt; 에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad3a5af3d1d2354def5cd4f1a41fd6d5c99da884" translate="yes" xml:space="preserve">
          <source>Except for the process information, everything in the trace information file is passed on to the handler function when formatting. Parameter &lt;code&gt;TI&lt;/code&gt; is a list of &lt;code&gt;{Key,ValueList}&lt;/code&gt; tuples. The keys &lt;code&gt;flags&lt;/code&gt;, &lt;code&gt;handler&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;node&lt;/code&gt; are used for information written directly by &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">프로세스 정보를 제외하고 추적 정보 파일의 모든 것은 형식화시 핸들러 함수로 전달됩니다. 매개 변수 &lt;code&gt;TI&lt;/code&gt; 는 &lt;code&gt;{Key,ValueList}&lt;/code&gt; 튜플 의 목록입니다 . 키 &lt;code&gt;flags&lt;/code&gt; , &lt;code&gt;handler&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;node&lt;/code&gt; 는 &lt;code&gt;ttb&lt;/code&gt; 가 직접 작성한 정보에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ba1497eeccb53065b740dfe3efb3c41fa0d6f4e" translate="yes" xml:space="preserve">
          <source>Except where explicitly stated, using EUnit macros will never introduce run-time dependencies on the EUnit library code, regardless of whether your code is compiled with testing enabled or disabled.</source>
          <target state="translated">명시 적으로 언급 된 경우를 제외하고 EUnit 매크로를 사용하면 코드가 테스트를 사용하여 컴파일 또는 비활성화되었는지 여부에 관계없이 EUnit 라이브러리 코드에 런타임 종속성이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e71fab40c2c841bfad28dfde0c11c8cd0da23d63" translate="yes" xml:space="preserve">
          <source>Exception reason:</source>
          <target state="translated">예외 사유 :</target>
        </trans-unit>
        <trans-unit id="5c5967f5b2ce06f4ccd67ab0f5f71722e821b59b" translate="yes" xml:space="preserve">
          <source>Exceptions are calls to &lt;code&gt;erlang:apply/2,3&lt;/code&gt;; neither of the function handlers are called for such calls. The argument can have the following formats:</source>
          <target state="translated">예외는 &lt;code&gt;erlang:apply/2,3&lt;/code&gt; ; 이러한 호출에 대해 함수 핸들러 중 어느 것도 호출되지 않습니다. 인수는 다음 형식을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="050aacdca35417853d02285e213bc3bc1b1aba17" translate="yes" xml:space="preserve">
          <source>Exceptions are run-time errors or generated errors and are of three different classes, with different origins. The &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; expression can distinguish between the different classes, whereas the &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; expression cannot. They are described in &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예외는 런타임 오류 또는 생성 된 오류이며 출처가 다른 세 가지 클래스입니다. &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 표현 반면, 다른 클래스를 구별 할 수 &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 표현 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions &lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56ced67455f13a96efe231a70019f6213cd62354" translate="yes" xml:space="preserve">
          <source>Exceptions are run-time errors or generated errors and are of three different classes, with different origins. The &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; expression can distinguish between the different classes, whereas the &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; expression cannot. They are described in &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예외는 런타임 오류 또는 생성 된 오류이며 원점이 다른 세 가지 클래스입니다. &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 표현 반면, 다른 클래스를 구별 할 수 &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 표현 할 수 없습니다. 그것들은 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="067869d4a45b070396125d0d90d80f63e7364a08" translate="yes" xml:space="preserve">
          <source>Exchanges &lt;code&gt;hello&lt;/code&gt; messages with the server.</source>
          <target state="translated">서버와 &lt;code&gt;hello&lt;/code&gt; 메시지를 교환 합니다.</target>
        </trans-unit>
        <trans-unit id="9e4666e2512d21b33048b7568f49831b88225aea" translate="yes" xml:space="preserve">
          <source>Exchanges &lt;code&gt;hello&lt;/code&gt; messages with the server. Returns when the server hello has been received or after the specified timeout.</source>
          <target state="translated">서버와 &lt;code&gt;hello&lt;/code&gt; 메시지를 교환 합니다. 서버 hello가 수신되거나 지정된 시간 초과 이후에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b6e23dcc4996af99cbf3517491282f2928b38371" translate="yes" xml:space="preserve">
          <source>Exclusive decode followed by &lt;code&gt;decode_part&lt;/code&gt; decodes is attractive if the parts are sent to different servers for decoding, or if you in some cases are not interested in all parts.</source>
          <target state="translated">해독을 위해 다른 서버로 부품을 보내거나 일부 경우에 모든 부품에 관심이없는 경우 배타적 디코딩 다음에 &lt;code&gt;decode_part&lt;/code&gt; 디코딩이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3970e0afd3925164ce333770cc51fbb9a52c794" translate="yes" xml:space="preserve">
          <source>Exec requests are executed by the default shell, but shell-requests are not executed.</source>
          <target state="translated">실행 요청은 기본 셸에서 실행되지만 셸 요청은 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9176f55ce49754a3db5517afccf322ad39b3f18" translate="yes" xml:space="preserve">
          <source>Executable Lines</source>
          <target state="translated">실행 가능한 라인</target>
        </trans-unit>
        <trans-unit id="8ccff560a031352a65ef95fe5f7cd2c0a87ec272" translate="yes" xml:space="preserve">
          <source>Execute an entry from the history buffer:</source>
          <target state="translated">히스토리 버퍼에서 항목을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f13f711eea30792db77a0fa6bd8ae2c24d36800b" translate="yes" xml:space="preserve">
          <source>Execute permission: group</source>
          <target state="translated">실행 권한 : 그룹</target>
        </trans-unit>
        <trans-unit id="6c00bf858ad16c0fce251b0d9fb9da5a30cfa1c3" translate="yes" xml:space="preserve">
          <source>Execute permission: other</source>
          <target state="translated">실행 권한 : 기타</target>
        </trans-unit>
        <trans-unit id="12940c2edb1f8ce9f4440c14b153196f63886ea3" translate="yes" xml:space="preserve">
          <source>Execute permission: owner</source>
          <target state="translated">실행 권한 : owner</target>
        </trans-unit>
        <trans-unit id="7cfbfb0ab7c27da1e9d10a7a57bdd6e1b1d13c1d" translate="yes" xml:space="preserve">
          <source>Execute the test case step-by-step and/or set execution breakpoints.</source>
          <target state="translated">테스트 케이스를 단계별로 실행하거나 실행 중단 점을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2856048c5ac2e34188928138747788ea399dfeda" translate="yes" xml:space="preserve">
          <source>Executes &lt;code&gt;Command&lt;/code&gt; in a command shell of the target OS, captures the standard output of the command, and returns this result as a string.</source>
          <target state="translated">대상 OS의 명령 셸에서 &lt;code&gt;Command&lt;/code&gt; 를 실행 하고 명령의 표준 출력을 캡처하여이 결과를 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4410bc3252e52411c710f6c5e378d946aacf6a5b" translate="yes" xml:space="preserve">
          <source>Executes a SQL SELECT query and associates the result set with the connection. A cursor is positioned before the first row in the result set and the tuple &lt;code&gt;{ok, NrRows}&lt;/code&gt; is returned.</source>
          <target state="translated">SQL SELECT 쿼리를 실행하고 결과 집합을 연결과 연결합니다. 커서는 결과 세트의 첫 번째 행 앞에 위치하며 튜플 &lt;code&gt;{ok, NrRows}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bc039f7a758965a574e87f6b9db173f910615316" translate="yes" xml:space="preserve">
          <source>Executes a SQL query or a batch of SQL queries. If it is a SELECT query the result set is returned, on the format &lt;code&gt;{selected, ColNames, Rows}&lt;/code&gt;. For other query types the tuple &lt;code&gt;{updated, NRows}&lt;/code&gt; is returned, and for batched queries, if the driver supports them, this function can also return a list of result tuples.</source>
          <target state="translated">SQL 쿼리 또는 일련의 SQL 쿼리를 실행합니다. SELECT 조회 인 경우 결과 세트는 &lt;code&gt;{selected, ColNames, Rows}&lt;/code&gt; 형식으로 리턴 됩니다. 다른 쿼리 유형의 경우 튜플 &lt;code&gt;{updated, NRows}&lt;/code&gt; 가 반환되고, 일괄 쿼리의 경우 드라이버가 지원하는 경우이 함수는 결과 튜플 목록을 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="97dd8551a740b8672495ad72222d926f68a833f2" translate="yes" xml:space="preserve">
          <source>Executes a parameterized SQL query. For an example see the &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; in the Erlang ODBC User's Guide.</source>
          <target state="translated">매개 변수화 된 SQL 쿼리를 실행합니다. 예를 들어 Erlang ODBC 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;getting_started#param_query&quot;&gt;&quot;Using the Erlang API&quot;&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb0f0c2b4b4b3349a1419a4ae2a544c852392bd0" translate="yes" xml:space="preserve">
          <source>Executes a regular expression matching, and returns &lt;code&gt;match/{match, Captured}&lt;/code&gt; or &lt;code&gt;nomatch&lt;/code&gt;. The regular expression can be specified either as &lt;code&gt;iodata()&lt;/code&gt; in which case it is automatically compiled (as by &lt;code&gt;compile/2&lt;/code&gt;) and executed, or as a precompiled &lt;code&gt;mp()&lt;/code&gt; in which case it is executed against the subject directly.</source>
          <target state="translated">정규식 일치를 실행하고 &lt;code&gt;match/{match, Captured}&lt;/code&gt; 또는 &lt;code&gt;nomatch&lt;/code&gt; 를 반환 합니다. 정규식은 &lt;code&gt;iodata()&lt;/code&gt; 로 지정 될 수 있으며 ,이 경우 자동으로 컴파일되고 ( &lt;code&gt;compile/2&lt;/code&gt; 에 의해 ) 실행되거나 사전 컴파일 된 &lt;code&gt;mp()&lt;/code&gt; 로서 대상에 대해 직접 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2aaa21aea670dcf3d60e12ad5fc7c21b85a05ef" translate="yes" xml:space="preserve">
          <source>Executes all configuration functions in the path to the specified group.</source>
          <target state="translated">지정된 그룹에 대한 경로의 모든 구성 기능을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8581821ec585ac1a3e683f5e0d529885a1bc9bbc" translate="yes" xml:space="preserve">
          <source>Executes all entries in the specified configuration file. Notice that the history of the last trace is always available in file &lt;code&gt;ttb_last_config&lt;/code&gt;.</source>
          <target state="translated">지정된 구성 파일의 모든 항목을 실행합니다. 마지막 추적 히스토리는 항상 &lt;code&gt;ttb_last_config&lt;/code&gt; 파일에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="34a1cd57176a4b0db96fcb2157e1e26a86ce0f2b" translate="yes" xml:space="preserve">
          <source>Executes all, or all matching, test cases in all subgroups of the group.&quot;</source>
          <target state="translated">그룹의 모든 하위 그룹에서 전체 또는 일치하는 모든 테스트 사례를 실행합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="55fe9fd565c7bd5c61110be70a042843ce83e689" translate="yes" xml:space="preserve">
          <source>Executes all, or all matching, test cases in this group.</source>
          <target state="translated">이 그룹에서 모든 또는 일치하는 모든 테스트 사례를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="099030a81433c9479293d4bb55f86ed9eb1cd493" translate="yes" xml:space="preserve">
          <source>Executes an action. If the return type is void, &lt;code&gt;ok&lt;/code&gt; is returned instead of &lt;code&gt;{ok,[simple_xml()]}&lt;/code&gt;.</source>
          <target state="translated">동작을 실행합니다. 리턴 유형이 void이면 &lt;code&gt;{ok,[simple_xml()]}&lt;/code&gt; 대신 &lt;code&gt;ok&lt;/code&gt; 가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="66766aaa201697b0fb4e48e59099bc45c38ef0df" translate="yes" xml:space="preserve">
          <source>Executes selected entries from the specified configuration file. &lt;code&gt;NumList&lt;/code&gt; is a list of integers pointing out the entries to be executed.</source>
          <target state="translated">지정된 구성 파일에서 선택한 항목을 실행합니다. &lt;code&gt;NumList&lt;/code&gt; 는 실행될 항목을 가리키는 정수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="454eb9ba1e45b404982e0b599e8604dcd76a21fa" translate="yes" xml:space="preserve">
          <source>Executes the current code line and stop at the next line.</source>
          <target state="translated">현재 코드 줄을 실행하고 다음 줄에서 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="a35c6f61298f6a8322e44b79596d70c152cde8c4" translate="yes" xml:space="preserve">
          <source>Executes the current code line, stepping into any (interpreted) function calls.</source>
          <target state="translated">현재 코드 라인을 실행하여 (해석 된) 함수 호출로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="bc5f62b22b5cb9608c21caec5067c32246f5a6f0" translate="yes" xml:space="preserve">
          <source>Executes the functional object &lt;code&gt;Fun&lt;/code&gt; with argument &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Args&lt;/code&gt; 인수를 사용 하여 함수형 오브젝트 &lt;code&gt;Fun&lt;/code&gt; 을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="1edddb03fbdb778c4a9dcf28f6ce54eb8b359f55" translate="yes" xml:space="preserve">
          <source>Executes the functional object &lt;code&gt;Fun&lt;/code&gt; with arguments &lt;code&gt;Args&lt;/code&gt; as a transaction.</source>
          <target state="translated">인수 &lt;code&gt;Args&lt;/code&gt; 를 사용 하여 함수형 오브젝트 &lt;code&gt;Fun&lt;/code&gt; 을 트랜잭션으로 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="8f114608d27a52f3f81355b37cfbcd66bc671be8" translate="yes" xml:space="preserve">
          <source>Executes the matching specified in a compiled &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; on a list of terms. Term &lt;code&gt;CompiledMatchSpec&lt;/code&gt; is to be the result of a call to &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt; match_spec_compile/1&lt;/a&gt;&lt;/code&gt; and is hence the internal representation of the match specification one wants to use.</source>
          <target state="translated">용어 목록의 컴파일 된 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 에 지정된 일치를 실행합니다 . 용어 &lt;code&gt;CompiledMatchSpec&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt; match_spec_compile/1&lt;/a&gt;&lt;/code&gt; 에 대한 호출의 결과 이므로 사용하려는 일치 사양의 내부 표현입니다.</target>
        </trans-unit>
        <trans-unit id="ab1b2f25a707b333e3118fd343298723469a9bab" translate="yes" xml:space="preserve">
          <source>Executes the matching specified in a compiled &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; on a list of terms. Term &lt;code&gt;CompiledMatchSpec&lt;/code&gt; is to be the result of a call to &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt;match_spec_compile/1&lt;/a&gt;&lt;/code&gt; and is hence the internal representation of the match specification one wants to use.</source>
          <target state="translated">용어 목록에서 컴파일 된 &lt;code&gt;&lt;a href=&quot;#match_spec&quot;&gt;match specification&lt;/a&gt;&lt;/code&gt; 에 지정된 일치를 실행합니다 . 용어 &lt;code&gt;CompiledMatchSpec&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#match_spec_compile-1&quot;&gt;match_spec_compile/1&lt;/a&gt;&lt;/code&gt; 에 대한 호출의 결과 이므로 사용하려는 일치 스펙의 내부 표현입니다.</target>
        </trans-unit>
        <trans-unit id="5a237b8a02c80f8fd8b6f2de1f0a55a142290e64" translate="yes" xml:space="preserve">
          <source>Executes the specified entry or entries from the history list. To list history, use &lt;code&gt;list_history/0&lt;/code&gt;.</source>
          <target state="translated">내역 목록에서 지정된 항목을 실행합니다. 히스토리를 나열하려면 &lt;code&gt;list_history/0&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b68c3cb384e0feff36349cec8c45b67d0bba0ccd" translate="yes" xml:space="preserve">
          <source>Executing &lt;code&gt;ct_run&lt;/code&gt; without start flags is equal to the command: &lt;code&gt;ct_run -dir ./&lt;/code&gt;</source>
          <target state="translated">시작 플래그없이 &lt;code&gt;ct_run&lt;/code&gt; 을 실행 하는 것은 다음 명령과 같습니다. &lt;code&gt;ct_run -dir ./&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a403828c3d10703e70bdc43a8a75ea7b3cbd30f" translate="yes" xml:space="preserve">
          <source>Executing BIFs, or any other runtime handling</source>
          <target state="translated">BIF 또는 기타 런타임 처리 실행</target>
        </trans-unit>
        <trans-unit id="14a8f46932951d050e5742c68b3ab1a318085395" translate="yes" xml:space="preserve">
          <source>Executing code in kernel mode.</source>
          <target state="translated">커널 모드에서 코드 실행</target>
        </trans-unit>
        <trans-unit id="fdf7cb24af490d954b302cb1dee97b67748a299f" translate="yes" xml:space="preserve">
          <source>Executing code in low priority (nice) user mode. This state is currently only identified on Linux.</source>
          <target state="translated">우선 순위가 낮은 (좋은) 사용자 모드에서 코드를 실행합니다. 이 상태는 현재 Linux에서만 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="14a9b6a90d62804010bc91938dc23c3cb795e5a2" translate="yes" xml:space="preserve">
          <source>Executing code in user mode.</source>
          <target state="translated">사용자 모드에서 코드 실행</target>
        </trans-unit>
        <trans-unit id="a408325a213990ef13b5c07d16672e812ebc8358" translate="yes" xml:space="preserve">
          <source>Executing linked-in driver or NIF code</source>
          <target state="translated">링크드 드라이버 또는 NIF 코드 실행</target>
        </trans-unit>
        <trans-unit id="7f48d6939c052808c7f286b69486a97e3bdfb416" translate="yes" xml:space="preserve">
          <source>Executing process code</source>
          <target state="translated">프로세스 코드 실행</target>
        </trans-unit>
        <trans-unit id="56ca38d0433fc0ad1a4cd65b67697c3812357f15" translate="yes" xml:space="preserve">
          <source>Execution of code in Cover compiled modules is slower and more memory consuming than for regularly compiled modules. As the Cover database contains information about each executable line in each Cover compiled module, performance decreases proportionally to the size and number of the Cover compiled modules.</source>
          <target state="translated">Cover 컴파일 된 모듈에서 코드 실행은 정기적으로 컴파일 된 모듈보다 느리고 메모리 소모가 많습니다. Cover 데이터베이스에는 각 Cover 컴파일 된 모듈의 각 실행 라인에 대한 정보가 포함되므로 성능은 Cover 컴파일 된 모듈의 크기와 수에 비례하여 감소합니다.</target>
        </trans-unit>
        <trans-unit id="82a37d9cbdc7bdd3cb72048a51d5df5ac360f924" translate="yes" xml:space="preserve">
          <source>Execution of interpreted code is naturally slower than for regularly compiled modules. Using Debugger also increases the number of processes in the system, as for each debugged process another process (the meta process) is created.</source>
          <target state="translated">해석 된 코드의 실행은 자연스럽게 정기적으로 컴파일 된 모듈보다 느립니다. 디버거를 사용하면 디버깅 된 각 프로세스마다 다른 프로세스 (메타 프로세스)가 생성되므로 시스템의 프로세스 수가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="33b0a6b5ecbc66872d35925904e04ee3999b6571" translate="yes" xml:space="preserve">
          <source>Execution of interpreted code is slower than compiled code. If much of the execution takes place in interpreted code, it can be worthwhile to compile it, although the compilation itself takes a little while. Also, &lt;code&gt;native&lt;/code&gt; can be supplied instead of &lt;code&gt;compile&lt;/code&gt;. This compiles the script using the native flag and may or may not be worthwhile depending on the escript characteristics.</source>
          <target state="translated">해석 된 코드의 실행이 컴파일 된 코드보다 느립니다. 많은 실행이 해석 된 코드에서 발생하는 경우 컴파일 자체가 약간의 시간이 걸리더라도 컴파일하는 것이 좋습니다. 또한 &lt;code&gt;compile&lt;/code&gt; 대신 &lt;code&gt;native&lt;/code&gt; 를 제공 할 수 있습니다 . 이것은 네이티브 플래그를 사용하여 스크립트를 컴파일하며 escript 특성에 따라 가치가 있거나 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4871bfc2d489f7006211641731ebe61530f90091" translate="yes" xml:space="preserve">
          <source>Execution of processes on priority &lt;code&gt;normal&lt;/code&gt; and &lt;code&gt;low&lt;/code&gt; are interleaved. Processes on priority &lt;code&gt;low&lt;/code&gt; are selected for execution less frequently than processes on priority &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">우선 순위가 &lt;code&gt;normal&lt;/code&gt; 인 프로세스 와 &lt;code&gt;low&lt;/code&gt; 프로세스의 실행 이 인터리브됩니다. 우선 순위가 &lt;code&gt;low&lt;/code&gt; 프로세스는 우선 순위가 &lt;code&gt;normal&lt;/code&gt; 프로세스보다 실행 빈도가 낮습니다 .</target>
        </trans-unit>
        <trans-unit id="84c3994ca896404946abce07ad67cec1f552c808" translate="yes" xml:space="preserve">
          <source>Execution of test cases is handled as follows:</source>
          <target state="translated">테스트 케이스의 실행은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3e63775e93e1530ffe3e4a868c708bf7a1aa5801" translate="yes" xml:space="preserve">
          <source>Execution of user functions after a slave node is started. Functions can be specified as a list of &lt;code&gt;{Module, Function, Arguments}&lt;/code&gt; tuples.</source>
          <target state="translated">슬레이브 노드가 시작된 후 사용자 기능 실행. 함수는 &lt;code&gt;{Module, Function, Arguments}&lt;/code&gt; 튜플 의 목록으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="680c39fd3e2cd2bb654d0e505725498ce7d879de" translate="yes" xml:space="preserve">
          <source>Execution properties with a group tuple in &lt;code&gt;all/0&lt;/code&gt;: &lt;code&gt;{group,GroupName,Properties}&lt;/code&gt; can also be specified. These properties override those specified in the group definition (see &lt;code&gt;groups/0&lt;/code&gt; earlier). This way, the same set of tests can be run, but with different properties, without having to make copies of the group definition in question.</source>
          <target state="translated">&lt;code&gt;all/0&lt;/code&gt; 에 그룹 튜플이있는 실행 특성 : &lt;code&gt;{group,GroupName,Properties}&lt;/code&gt; 도 지정할 수 있습니다. 이러한 특성은 그룹 정의에 지정된 특성을 대체합니다 (앞의 &lt;code&gt;groups/0&lt;/code&gt; 참조 ). 이런 식으로, 동일한 그룹의 테스트를 실행할 수 있지만 해당 그룹 정의의 사본을 만들지 않고도 다른 속성으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe21c7cb35b2f0fc9b89a945f4bfb0726a108ff0" translate="yes" xml:space="preserve">
          <source>Existing event handlers provided by STDLIB and SASL are still available, but are no longer used by OTP.</source>
          <target state="translated">STDLIB 및 SASL에서 제공하는 기존 이벤트 핸들러는 계속 사용할 수 있지만 더 이상 OTP에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e87fdcc00c2f01223efb3db284b58f3809d51ee8" translate="yes" xml:space="preserve">
          <source>Exists only if &lt;code&gt;Function&lt;/code&gt; can be used with different clocks. &lt;code&gt;ClockId&lt;/code&gt; corresponds to the clock identifier used when calling &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Function&lt;/code&gt; 을 다른 시계와 함께 사용할 수있는 경우에만 존재합니다 . &lt;code&gt;ClockId&lt;/code&gt; 는 &lt;code&gt;Function&lt;/code&gt; 호출시 사용되는 시계 식별자에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f9cf69cbe7afbd4a110543a47415697a57a30784" translate="yes" xml:space="preserve">
          <source>Exit by entering the command &lt;code&gt;halt()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;halt()&lt;/code&gt; 명령을 입력하여 종료하십시오 .</target>
        </trans-unit>
        <trans-unit id="105ec316e78b2e21f4200658aebb690c6bfce1c8" translate="yes" xml:space="preserve">
          <source>Exit status</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="74f4feca416d0f38ee6c27d43bbe97ebe96761bf" translate="yes" xml:space="preserve">
          <source>Exit status is set before the program ends. Value &lt;code&gt;0&lt;/code&gt; indicates a successful test result, &lt;code&gt;1&lt;/code&gt; indicates one or more failed or auto-skipped test cases, and &lt;code&gt;2&lt;/code&gt; indicates test execution failure.</source>
          <target state="translated">프로그램이 종료되기 전에 종료 상태가 설정됩니다. 값 &lt;code&gt;0&lt;/code&gt; 은 테스트 결과가 성공했음을 나타내고 &lt;code&gt;1&lt;/code&gt; 은 하나 이상의 실패 또는 자동 건너 뛴 테스트 사례를 나타내고 &lt;code&gt;2&lt;/code&gt; 는 테스트 실행 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f123e96265c1d6d0f52a428e14efbb1d4c1f296" translate="yes" xml:space="preserve">
          <source>Exits a normal shell and starts a restricted shell. &lt;code&gt;Module&lt;/code&gt; specifies the callback module for the functions &lt;code&gt;local_allowed/3&lt;/code&gt; and &lt;code&gt;non_local_allowed/3&lt;/code&gt;. The function is meant to be called from the shell.</source>
          <target state="translated">일반 쉘을 종료하고 제한된 쉘을 시작합니다. &lt;code&gt;Module&lt;/code&gt; 은 &lt;code&gt;local_allowed/3&lt;/code&gt; 및 &lt;code&gt;non_local_allowed/3&lt;/code&gt; 함수에 대한 콜백 모듈을 지정합니다 . 이 함수는 쉘에서 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cc56d5b35d2040da569465e6723fe200f5898624" translate="yes" xml:space="preserve">
          <source>Exits a restricted shell and starts a normal shell. The function is meant to be called from the shell.</source>
          <target state="translated">제한된 쉘을 종료하고 일반 쉘을 시작합니다. 이 함수는 쉘에서 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f54898118242f94307cbafbf87d29680c0eb752" translate="yes" xml:space="preserve">
          <source>Exits the interactive mode.</source>
          <target state="translated">대화식 모드를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="1032820209a3487f302772fc3f6a6f4a914ef5c9" translate="yes" xml:space="preserve">
          <source>Expands a string containing environment variables between percent characters. Anything between two &lt;code&gt;%&lt;/code&gt; is taken for an environment variable, and is replaced by the value. Two consecutive &lt;code&gt;%&lt;/code&gt; are replaced by one &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">퍼센트 문자 사이의 환경 변수를 포함하는 문자열을 확장합니다. 환경 변수에 대해 두 &lt;code&gt;%&lt;/code&gt; 사이 의 값이 사용되며 값으로 대체됩니다. 두 개의 연속 &lt;code&gt;%&lt;/code&gt; 가 하나의 &lt;code&gt;%&lt;/code&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="58cf917bbeeddf7b26d3232197d693d61f9bb206" translate="yes" xml:space="preserve">
          <source>Expands all records in a module to use explicit tuple operations and adds explicit module names to calls to BIFs and imported functions. The returned module has no references to records, attributes, or code.</source>
          <target state="translated">명시 적 튜플 조작을 사용하도록 모듈의 모든 레코드를 확장하고 BIF 및 가져온 함수 호출에 명시 적 모듈 이름을 추가합니다. 리턴 된 모듈에는 레코드, 속성 또는 코드에 대한 참조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="272413c5242838c5162e04158e2df8033b015b64" translate="yes" xml:space="preserve">
          <source>Expands an abstract list skeleton to its most explicit form. If &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt;&quot;, the result represents &quot;&lt;code&gt;[E1 | ... [En | Tail1] ... ]&lt;/code&gt;&quot;, where &lt;code&gt;Tail1&lt;/code&gt; is the result of &lt;code&gt;normalize_list(Tail)&lt;/code&gt;. If &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;[E1, ..., En]&lt;/code&gt;&quot;, the result simply represents &quot;&lt;code&gt;[E1 | ... [En | []] ... ]&lt;/code&gt;&quot;. If &lt;code&gt;Node&lt;/code&gt; does not represent a list skeleton, &lt;code&gt;Node&lt;/code&gt; itself is returned.</source>
          <target state="translated">추상 목록 스켈레톤을 가장 명시적인 형식으로 확장합니다. 경우 &lt;code&gt;Node&lt;/code&gt; 나타내는 &quot; &lt;code&gt;[E1, ..., En | Tail]&lt;/code&gt; &quot;결과 &quot;대표 &lt;code&gt;[E1 | ... [En | Tail1] ... ]&lt;/code&gt; , 여기서&quot; &lt;code&gt;Tail1&lt;/code&gt; 이 결과이다 &lt;code&gt;normalize_list(Tail)&lt;/code&gt; . 경우 &lt;code&gt;Node&lt;/code&gt; 나타내는 &quot; &lt;code&gt;[E1, ..., En]&lt;/code&gt; &quot; &quot;결과는 단순히 나타낸다 &lt;code&gt;[E1 | ... [En | []] ... ]&lt;/code&gt; &quot;. 경우 &lt;code&gt;Node&lt;/code&gt; 목록 골격을 나타내지 않는, &lt;code&gt;Node&lt;/code&gt; 자체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3360fce21e71106b586365c7542d07f8167af167" translate="yes" xml:space="preserve">
          <source>Expands particular properties to corresponding sets of properties (or other terms). For each pair &lt;code&gt;{Property, Expansion}&lt;/code&gt; in &lt;code&gt;Expansions&lt;/code&gt;: if &lt;code&gt;E&lt;/code&gt; is the first entry in &lt;code&gt;ListIn&lt;/code&gt; with the same key as &lt;code&gt;Property&lt;/code&gt;, and &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;Property&lt;/code&gt; have equivalent normal forms, then &lt;code&gt;E&lt;/code&gt; is replaced with the terms in &lt;code&gt;Expansion&lt;/code&gt;, and any following entries with the same key are deleted from &lt;code&gt;ListIn&lt;/code&gt;.</source>
          <target state="translated">특정 속성을 해당 속성 집합 (또는 다른 용어)으로 확장합니다. 각 쌍 &lt;code&gt;{Property, Expansion}&lt;/code&gt; 의 &lt;code&gt;Expansions&lt;/code&gt; : 경우 &lt;code&gt;E&lt;/code&gt; 는 첫 번째 항목이다 &lt;code&gt;ListIn&lt;/code&gt; 같은 키 &lt;code&gt;Property&lt;/code&gt; 및 &lt;code&gt;E&lt;/code&gt; 및 &lt;code&gt;Property&lt;/code&gt; 동등한 정상적인 모양을 가지고, 그 다음 &lt;code&gt;E&lt;/code&gt; 는 의 조건으로 치환 &lt;code&gt;Expansion&lt;/code&gt; , 및 다음 항목으로 동일한 키가 &lt;code&gt;ListIn&lt;/code&gt; 에서 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a66951bd36f0c5fdf0af6befea4f43532cc639b" translate="yes" xml:space="preserve">
          <source>Expands records in a module.</source>
          <target state="translated">모듈에서 레코드를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="70681060959ccc70e51752de8b0d3c9b00688d4e" translate="yes" xml:space="preserve">
          <source>Expect a command-line window to pop up with an output looking something like this:</source>
          <target state="translated">다음과 같은 출력이 표시되는 명령 행 창이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="61366f2558235a4cca37f0664d40eec6f4fd2980" translate="yes" xml:space="preserve">
          <source>Experience with the Unicode support in Erlang has made it clear that understanding Unicode characters and encodings is not as easy as one would expect. The complexity of the field and the implications of the standard require thorough understanding of concepts rarely before thought of.</source>
          <target state="translated">Erlang의 유니 코드 지원 경험을 통해 유니 코드 문자 및 인코딩을 이해하는 것이 기대하는 것만 큼 쉽지 않다는 것이 분명해졌습니다. 필드의 복잡성과 표준의 의미는 생각하기 전에 개념을 철저히 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="0dd77176636a57d058c034e08e3b71ccb8577cfd" translate="yes" xml:space="preserve">
          <source>Experienced Erlang programmers would write as follows:</source>
          <target state="translated">숙련 된 Erlang 프로그래머는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1b22b4b21d1bbc1b132e79fcbe8a5f2b95edc4c6" translate="yes" xml:space="preserve">
          <source>Experimental-Result AVP</source>
          <target state="translated">실험 결과 AVP</target>
        </trans-unit>
        <trans-unit id="b3321f75b55990de1ee876791b32d9b4270fe0bc" translate="yes" xml:space="preserve">
          <source>Experimental-Result-Code AVP</source>
          <target state="translated">실험 결과 코드 AVP</target>
        </trans-unit>
        <trans-unit id="d62252c1ac11d9093891729d36abc7fc085ceba6" translate="yes" xml:space="preserve">
          <source>Experiments with Perl suggest that it too has similar optimizations, sometimes leading to anomalous results.</source>
          <target state="translated">Perl을 사용한 실험에서도 비슷한 최적화가 이루어졌으며 때로는 비정상적인 결과가 나올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="c2afac37abccd850b732183ce0de424cf11118ee" translate="yes" xml:space="preserve">
          <source>Explicit batches</source>
          <target state="translated">명시 적 배치</target>
        </trans-unit>
        <trans-unit id="da951366acbfd0fb0aa590f0d7767456d6128af6" translate="yes" xml:space="preserve">
          <source>Explicit batches an procedures described below will result in multiple results being returned from sql_query/[2,3]. while with parameterized queries only one result will be returned from param_query/[2,3].</source>
          <target state="translated">아래에 설명 된 절차를 명시 적으로 일괄 처리하면 sql_query / [2,3]에서 여러 결과가 반환됩니다. 매개 변수화 된 쿼리의 경우 param_query / [2,3]에서 하나의 결과 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0562afa4f29033a4c48be8866998932a982b7102" translate="yes" xml:space="preserve">
          <source>Explicit version</source>
          <target state="translated">명시 적 버전</target>
        </trans-unit>
        <trans-unit id="a02d741d3e01f379d49f626fe7fa4e84c830b0fa" translate="yes" xml:space="preserve">
          <source>Explicitly by the process itself, through a call to &lt;code&gt;seq_trace:set_token/1,2&lt;/code&gt;</source>
          <target state="translated">프로세스 자체에서 &lt;code&gt;seq_trace:set_token/1,2&lt;/code&gt; 호출을 통해 명시 적으로</target>
        </trans-unit>
        <trans-unit id="3d586803ee5b3b1701927feac52b670c916bcfca" translate="yes" xml:space="preserve">
          <source>Explicitly instruct the manager to handle this USM user. Note that there is an alternate way to do the same thing: Add the usm user to the manager config files (see &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#usm_user&quot;&gt;usm.conf&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">관리자에게이 USM 사용자를 처리하도록 명시 적으로 지시하십시오. 동일한 작업을 수행하는 다른 방법이 있습니다. usm 사용자를 관리자 구성 파일에 추가하십시오 ( &lt;code&gt;&lt;a href=&quot;snmp_manager_config_files#usm_user&quot;&gt;usm.conf&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f99d3000387a303b1ad0f58390b85c8025436718" translate="yes" xml:space="preserve">
          <source>Explicitly instruct the manager to handle this agent, with &lt;code&gt;UserId&lt;/code&gt; as the responsible user.</source>
          <target state="translated">관리자에게 &lt;code&gt;UserId&lt;/code&gt; 를 담당 사용자로 하여이 에이전트를 처리하도록 명시 적으로 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="e44446ef6d172511be09e9797321be8dd9ee1e99" translate="yes" xml:space="preserve">
          <source>Explicitly instructs the manager to handle this USM user. Corresponds to making an entry in &lt;code&gt;usm.conf&lt;/code&gt;.</source>
          <target state="translated">관리자에게이 USM 사용자를 처리하도록 명시 적으로 지시합니다. &lt;code&gt;usm.conf&lt;/code&gt; 에 항목을 작성하는 것에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="046547ada5d0fdeff8744b21b0c161b60934aa92" translate="yes" xml:space="preserve">
          <source>Explicitly instructs the manager to handle this agent. Corresponds to making an entry in &lt;code&gt;agents.conf&lt;/code&gt;.</source>
          <target state="translated">관리자에게이 에이전트를 처리하도록 명시 적으로 지시합니다. &lt;code&gt;agents.conf&lt;/code&gt; 에 항목을 작성하는 것에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="c838fc3b102436d86eb4fb0ac7bc4df5779541b4" translate="yes" xml:space="preserve">
          <source>Explicitly set the actual protocol version in the megaco_receive_handle.</source>
          <target state="translated">megaco_receive_handle에서 실제 프로토콜 버전을 명시 적으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c3d40bd480471a0edfc44e68a8f4d92762b3fb14" translate="yes" xml:space="preserve">
          <source>Explicitly. This is necessary only when a generic instruction does not have any corresponding specific instruction.</source>
          <target state="translated">명시 적으로. 이것은 일반 명령어에 해당하는 특정 명령어가없는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="368cb593ed8144f112260be7db1b6c21746fd2b7" translate="yes" xml:space="preserve">
          <source>Export cipher suites are not supported as the U.S. lifted its export restrictions in early 2000.</source>
          <target state="translated">미국이 2000 년 초에 수출 제한을 해제 했으므로 수출 암호 그룹은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95990f81db58d8b8d896055c20b9ee29047d96e1" translate="yes" xml:space="preserve">
          <source>Export table. One entry for every exported function.</source>
          <target state="translated">테이블 내보내기. 내 보낸 모든 함수에 대해 하나의 항목.</target>
        </trans-unit>
        <trans-unit id="9be573704e1f54cb6bd4162ef130dbeefe8c80fc" translate="yes" xml:space="preserve">
          <source>Export the messages in the &lt;code&gt;MessagePackage&lt;/code&gt; (default is &lt;code&gt;time_test&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;MessagePackage&lt;/code&gt; 에서 메시지를 내보내십시오 (기본값은 &lt;code&gt;time_test&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa18b9e4e76ab54d64606045aa4ee7f2f5a79d57" translate="yes" xml:space="preserve">
          <source>Exported Functions. All exported functions of analyzed modules and all used exported functions of library modules.</source>
          <target state="translated">내 보낸 기능. 분석 모듈의 모든 내 보낸 기능 및 라이브러리 모듈의 모든 내 보낸 기능</target>
        </trans-unit>
        <trans-unit id="6dacbd5b09f2902da4cc8122e61cd3e469deac80" translate="yes" xml:space="preserve">
          <source>Exported functions. Specifies which of the functions, defined within the module, that are visible from outside the module.</source>
          <target state="translated">내 보낸 기능. 모듈 내에 정의되어 모듈 외부에서 볼 수있는 기능을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0e16537914a0163e01ecd7e0945bc56c50eb3849" translate="yes" xml:space="preserve">
          <source>Exports</source>
          <target state="translated">Exports</target>
        </trans-unit>
        <trans-unit id="02caa1dd3e593e45252685d5d3c9f6436c944320" translate="yes" xml:space="preserve">
          <source>Exports &quot;simple-form&quot; XML content, using the specified callback-module.</source>
          <target state="translated">지정된 콜백 모듈을 사용하여 &quot;간단한 형식&quot;XML 컨텐츠를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1660ee0c8536b4382a0b38edd1d7df44c43597d7" translate="yes" xml:space="preserve">
          <source>Exports a normal XML element directly, without further context.</source>
          <target state="translated">추가 컨텍스트없이 일반 XML 요소를 직접 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d9a878ddd2bf9342d35539a556b12164fd300769" translate="yes" xml:space="preserve">
          <source>Exports a simple XML element directly, without further context.</source>
          <target state="translated">추가 컨텍스트없이 간단한 XML 요소를 직접 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ecc51082c5cea4b6d58955c29a11415a7a81b582" translate="yes" xml:space="preserve">
          <source>Exports normal XML content directly, without further context.</source>
          <target state="translated">추가 컨텍스트없이 일반 XML 컨텐츠를 직접 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8d1384f4e40ab996f10f281328007536bcbf5091" translate="yes" xml:space="preserve">
          <source>Exports normal, well-formed XML content, using the specified callback-module.</source>
          <target state="translated">지정된 콜백 모듈을 사용하여 올바른 형식의 일반 XML 컨텐츠를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="22191cbcaa5de40a48cc520af737587909c49284" translate="yes" xml:space="preserve">
          <source>Exports simple XML content directly, without further context.</source>
          <target state="translated">추가 컨텍스트없이 간단한 XML 컨텐츠를 직접 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8133b6c3cc9eb768f8210de697b9f15ba0c94181" translate="yes" xml:space="preserve">
          <source>Exports the current coverage data for &lt;code&gt;Module&lt;/code&gt; to the file &lt;code&gt;ExportFile&lt;/code&gt;. It is recommended to name the &lt;code&gt;ExportFile&lt;/code&gt; with the extension &lt;code&gt;.coverdata&lt;/code&gt;, since other filenames can not be read by the web based interface to cover.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 현재 적용 범위 데이터를 &lt;code&gt;ExportFile&lt;/code&gt; 파일로 내 보냅니다 . 다른 파일 이름은 웹 기반 인터페이스에서 읽을 수 없으므로 확장자가 &lt;code&gt;.coverdata&lt;/code&gt; 인 &lt;code&gt;ExportFile&lt;/code&gt; 의 이름을 지정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1e62d1a4f45f69ecb6bff42b6c384a79e584d3a1" translate="yes" xml:space="preserve">
          <source>Exports the current coverage data for &lt;code&gt;Module&lt;/code&gt; to the file &lt;code&gt;ExportFile&lt;/code&gt;. It is recommended to name the &lt;code&gt;ExportFile&lt;/code&gt; with the extension &lt;code&gt;.coverdata&lt;/code&gt;, since other filenames cannot be read by the web based interface to cover.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 의 현재 커버리지 데이터를 &lt;code&gt;ExportFile&lt;/code&gt; 파일로 내 보냅니다 . 웹 기반 인터페이스에서 다른 파일 이름을 읽을 수 없으므로 확장자가 &lt;code&gt;.coverdata&lt;/code&gt; 인 &lt;code&gt;ExportFile&lt;/code&gt; 의 이름을 지정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3ae61f2e92c3d90036fb83e9a1dc1c593ac0f549" translate="yes" xml:space="preserve">
          <source>Exports the following Erlang Web Server API interaction data, if possible:</source>
          <target state="translated">가능한 경우 다음 Erlang 웹 서버 API 상호 작용 데이터를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="35119743538b0a1138a1f17ebd68a12a0813f12e" translate="yes" xml:space="preserve">
          <source>Exports the following Erlang Web Server API interaction data:</source>
          <target state="translated">다음 Erlang 웹 서버 API 상호 작용 데이터를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d52f99749dd7bb710052730ab080e796489eb412" translate="yes" xml:space="preserve">
          <source>Exports the following Erlang web server API interaction data:</source>
          <target state="translated">다음 Erlang 웹 서버 API 상호 작용 데이터를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f24c92e4537680603c0273dabf8cded3fa6b1644" translate="yes" xml:space="preserve">
          <source>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | &lt;code&gt;'$_'&lt;/code&gt; | &lt;code&gt;'$$'&lt;/code&gt;</source>
          <target state="translated">ExprMatchVariable :: = MatchVariable (MatchHead에 바인딩 됨) | &lt;code&gt;'$_'&lt;/code&gt; | &lt;code&gt;'$$'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f5eadb984da9ea8a315c53a713a326ef7f45498" translate="yes" xml:space="preserve">
          <source>Expression ::= &lt;code&gt;(&lt;/code&gt; Expression &lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">식 :: = &lt;code&gt;(&lt;/code&gt; 식 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="addbb8e52b6d52535f3fc36c84596510e5968114" translate="yes" xml:space="preserve">
          <source>Expression ::= &lt;code&gt;(&lt;/code&gt; LineOp&lt;code&gt;)&lt;/code&gt; Expression</source>
          <target state="translated">식 :: = &lt;code&gt;(&lt;/code&gt; LineOp &lt;code&gt;)&lt;/code&gt; 식</target>
        </trans-unit>
        <trans-unit id="6854eed889bdcb715b3709fe91c0cab8d178eebe" translate="yes" xml:space="preserve">
          <source>Expression ::= &lt;code&gt;(&lt;/code&gt; Type &lt;code&gt;)&lt;/code&gt; Expression</source>
          <target state="translated">식 :: = &lt;code&gt;(&lt;/code&gt; 유형 &lt;code&gt;)&lt;/code&gt; 식</target>
        </trans-unit>
        <trans-unit id="9138649cd667c41cb747ddeed1bb4960f24911f4" translate="yes" xml:space="preserve">
          <source>Expression ::= &lt;code&gt;(&lt;/code&gt; XLineOp&lt;code&gt;)&lt;/code&gt; Expression</source>
          <target state="translated">식 :: = &lt;code&gt;(&lt;/code&gt; XLineOp &lt;code&gt;)&lt;/code&gt; 식</target>
        </trans-unit>
        <trans-unit id="98c145886602ec6b6738774db3f3f5e1e78d2a8f" translate="yes" xml:space="preserve">
          <source>Expression ::= ClosureOp Expression</source>
          <target state="translated">식 :: = ClosureOp 식</target>
        </trans-unit>
        <trans-unit id="2fcaf78097d07e98f7885fb0f41d04479fa9edeb" translate="yes" xml:space="preserve">
          <source>Expression ::= Constants</source>
          <target state="translated">식 :: = 상수</target>
        </trans-unit>
        <trans-unit id="3958c541b51093e3e5731e5a772219a3f6c7d46f" translate="yes" xml:space="preserve">
          <source>Expression ::= CountOp Expression</source>
          <target state="translated">식 :: = CountOp 식</target>
        </trans-unit>
        <trans-unit id="4f2ed1d429ac041e1da45ffb8e30358b49dfdb4c" translate="yes" xml:space="preserve">
          <source>Expression ::= Expression BinaryGraphOp Expression</source>
          <target state="translated">식 :: = 식 BinaryGraphOp 식</target>
        </trans-unit>
        <trans-unit id="3e1f9f375aeddbcf09cbaa758ceaa7f9f3d0b627" translate="yes" xml:space="preserve">
          <source>Expression ::= Expression BinarySetOp Expression</source>
          <target state="translated">식 :: = 식 BinarySetOp 식</target>
        </trans-unit>
        <trans-unit id="48081deaf20f580895caa16c82705df8520c69f5" translate="yes" xml:space="preserve">
          <source>Expression ::= Expression RestrOp Expression</source>
          <target state="translated">식 :: = 식 RestrOp 식</target>
        </trans-unit>
        <trans-unit id="3fb910532dc57f421d9bb1a6f16ad06188f34675" translate="yes" xml:space="preserve">
          <source>Expression ::= UnaryGraphOp Expression</source>
          <target state="translated">식 :: = UnaryGraphOp 식</target>
        </trans-unit>
        <trans-unit id="c7f8e3e42259fae86cbb04e08dc5882e5e69d4f1" translate="yes" xml:space="preserve">
          <source>Expression ::= UnarySetOp Expression</source>
          <target state="translated">식 :: = UnarySetOp 식</target>
        </trans-unit>
        <trans-unit id="7186eedc6b9b139b5c92a1e1986721fabf723c19" translate="yes" xml:space="preserve">
          <source>Expression ::= Variable</source>
          <target state="translated">식 :: = 변수</target>
        </trans-unit>
        <trans-unit id="514d16679bae990d5b3a90c9251b4df733d58974" translate="yes" xml:space="preserve">
          <source>Expressions in Patterns</source>
          <target state="translated">패턴의 표현</target>
        </trans-unit>
        <trans-unit id="410ed2c6c88a60abc59543fb3bce3a7992e3bed0" translate="yes" xml:space="preserve">
          <source>Expressions that construct atoms, integer, floats, lists, tuples, records, binaries, and maps</source>
          <target state="translated">원자, 정수, 부동 소수점, 목록, 튜플, 레코드, 이진 및 맵을 구성하는 표현식</target>
        </trans-unit>
        <trans-unit id="0bfece3f6f297352b30c69be5119d56dbb996b72" translate="yes" xml:space="preserve">
          <source>Expressions that update a map</source>
          <target state="translated">지도를 업데이트하는 표현식</target>
        </trans-unit>
        <trans-unit id="f6d5b459bed57db121c8e780c1fb44610af3e9ec" translate="yes" xml:space="preserve">
          <source>Extend an existing configuration:</source>
          <target state="translated">기존 구성을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="e03bf9ed7d7c461a0fd672724f98c8abbef6cad6" translate="yes" xml:space="preserve">
          <source>Extended API</source>
          <target state="translated">확장 API</target>
        </trans-unit>
        <trans-unit id="cfdd1285dd4e167898adf793eccf586f0f9bb5f6" translate="yes" xml:space="preserve">
          <source>Extending the Mnesia Table</source>
          <target state="translated">기억 상실 표 확장</target>
        </trans-unit>
        <trans-unit id="551f67028c9496c2a9e43aecb97e31fc3321bcce" translate="yes" xml:space="preserve">
          <source>Extending the command line gives the following:</source>
          <target state="translated">명령 행을 확장하면 다음이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="dae2d0b450546f227bb86a8895fd22f264be8d2d" translate="yes" xml:space="preserve">
          <source>Extending the search mechanism</source>
          <target state="translated">검색 메커니즘 확장</target>
        </trans-unit>
        <trans-unit id="e84d35946af53d80b6d807681846783d5ecae8f2" translate="yes" xml:space="preserve">
          <source>Extending, restructuring, and maintaining test suites with test case dependencies is difficult.</source>
          <target state="translated">테스트 사례에 따라 테스트 스위트를 확장, 재구성 및 유지 관리하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="908bd73823d2a762ae1ac9b6a1dc240b1abdfd70" translate="yes" xml:space="preserve">
          <source>Extends &lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;timetrap time-out&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;write_test_chapter#timetraps&quot;&gt;timetrap time-out&lt;/a&gt;&lt;/code&gt; 값을 연장 합니다.</target>
        </trans-unit>
        <trans-unit id="376e7c5dbd73b2fd53fedf4bb27c6d8817a0e200" translate="yes" xml:space="preserve">
          <source>Extends the meaning of (, also 0 or 1 quantifier, also quantifier minimizer</source>
          <target state="translated">(또는 0 또는 1 수량 자, 수량 자 최소화 기의 의미를 확장합니다.)</target>
        </trans-unit>
        <trans-unit id="b285c62fbf4bef733e32c37f4eb5392d09953972" translate="yes" xml:space="preserve">
          <source>Extensibility for SEQUENCE and SET</source>
          <target state="translated">SEQUENCE 및 SET의 확장 성</target>
        </trans-unit>
        <trans-unit id="1a935fd1e8e951bdb4c9324544889f10e7735fcc" translate="yes" xml:space="preserve">
          <source>Extensible CHOICE</source>
          <target state="translated">확장 가능한 선택</target>
        </trans-unit>
        <trans-unit id="46921c8938be90a60a5c9f38175addf111add586" translate="yes" xml:space="preserve">
          <source>Extensions of Existing Functions</source>
          <target state="translated">기존 기능의 확장</target>
        </trans-unit>
        <trans-unit id="882fc7968647fa2e905cb46fe2c42823925e7841" translate="yes" xml:space="preserve">
          <source>Extensions to include in the certificate.</source>
          <target state="translated">인증서에 포함 할 확장명.</target>
        </trans-unit>
        <trans-unit id="5d699fdd6e198d27b96ab42e8923343d94b9caac" translate="yes" xml:space="preserve">
          <source>External Calls (*).</source>
          <target state="translated">외부 통화 (*).</target>
        </trans-unit>
        <trans-unit id="76f32a5120631b73ab85cf2a34ee2880957bb1fb" translate="yes" xml:space="preserve">
          <source>External Configuration Data and Logging</source>
          <target state="translated">외부 구성 데이터 및 로깅</target>
        </trans-unit>
        <trans-unit id="a8108f93e2436ab415be7a15fb1200506ef33347" translate="yes" xml:space="preserve">
          <source>External calls within some module.</source>
          <target state="translated">일부 모듈 내의 외부 호출</target>
        </trans-unit>
        <trans-unit id="e69d9092c5e963be777f31d1f4e2210d63e7b838" translate="yes" xml:space="preserve">
          <source>External events are of 3 types: &lt;code&gt;{call,From}&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, or &lt;code&gt;info&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;Calls&lt;/a&gt;&lt;/code&gt; (synchronous) and &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;casts&lt;/a&gt;&lt;/code&gt; originate from the corresponding API functions. For calls, the event contains whom to reply to. Type &lt;code&gt;info&lt;/code&gt; originates from regular process messages sent to the &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">외부 이벤트는 &lt;code&gt;{call,From}&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; 또는 &lt;code&gt;info&lt;/code&gt; 의 3 가지 유형 입니다. &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;Calls&lt;/a&gt;&lt;/code&gt; (동기식) 및 &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;casts&lt;/a&gt;&lt;/code&gt; 는 해당 API 함수에서 시작됩니다. 전화의 경우, 이벤트에는 응답 할 사람이 포함됩니다. 유형 &lt;code&gt;info&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 으로 전송 된 일반 프로세스 메시지에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="82f09b3f7ef9941bc4d69e25e05d373371d2fefb" translate="yes" xml:space="preserve">
          <source>External events are of 3 types: &lt;code&gt;{call,From}&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, or &lt;code&gt;info&lt;/code&gt;. Type &lt;code&gt;call&lt;/code&gt; originates from the API functions &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt;. For calls, the event contains whom to reply to. Type &lt;code&gt;cast&lt;/code&gt; originates from the API function &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;cast/2&lt;/a&gt;&lt;/code&gt;. Type &lt;code&gt;info&lt;/code&gt; originates from regular process messages sent to the &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">외부 이벤트에는 &lt;code&gt;{call,From}&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; 또는 &lt;code&gt;info&lt;/code&gt; 의 3 가지 유형이 있습니다 . 유형 &lt;code&gt;call&lt;/code&gt; 은 API 함수 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#send_request-2&quot;&gt;send_request/2&lt;/a&gt;&lt;/code&gt; 에서 시작 됩니다. 통화의 경우 이벤트에 응답 할 사람이 포함됩니다. 유형 &lt;code&gt;cast&lt;/code&gt; 는 API 함수 &lt;code&gt;&lt;a href=&quot;#cast-2&quot;&gt;cast/2&lt;/a&gt;&lt;/code&gt; 에서 시작 됩니다. 유형 &lt;code&gt;info&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 에 전송 된 일반 프로세스 메시지에서 비롯 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4588d4f580caf2e1d0aa5345191898eb4a30cbc" translate="yes" xml:space="preserve">
          <source>External generic BEAM instructions are known to both the compiler and the runtime system. They remain stable between releases. A new major release may add more external generic instructions, but must not change the semantics for a previously defined instruction.</source>
          <target state="translated">외부 일반 BEAM 명령어는 컴파일러와 런타임 시스템 모두에 알려져 있습니다. 릴리스 간에는 안정적입니다. 새로운 주요 릴리스는 더 많은 외부 일반 명령어를 추가 할 수 있지만 이전에 정의 된 명령어의 의미를 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a67c0ff06e68b75c5859a47a5e836301668f6e" translate="yes" xml:space="preserve">
          <source>External generic BEAM instructions. They are the instructions that are known to both the compiler and the runtime system. Generic instructions are stable between releases. New generic instructions with high numbers than previous instructions can be added in major releases. The OTP 20 release has 159 external generic instructions.</source>
          <target state="translated">외부 일반 BEAM 지침. 컴파일러와 런타임 시스템 모두에 알려진 명령어입니다. 일반 지침은 릴리스간에 안정적입니다. 이전 명령어보다 많은 수의 새로운 일반 명령어를 주요 릴리스에 추가 할 수 있습니다. OTP 20 릴리스에는 159 개의 외부 일반 명령어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="22307bf79de9067a9ce26d7af6a39faa6a7d4f8a" translate="yes" xml:space="preserve">
          <source>External unordered sets are represented as sorted lists. So, creating the image of a set under a relation R can traverse all elements of R (to that comes the sorting of results, the image). In &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;image/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;BinRel&lt;/code&gt; is traversed once for each element of &lt;code&gt;SetOfSets&lt;/code&gt;, which can take too long. The following efficient function can be used instead under the assumption that the image of each element of &lt;code&gt;SetOfSets&lt;/code&gt; under &lt;code&gt;BinRel&lt;/code&gt; is non-empty:</source>
          <target state="translated">순서가없는 외부 세트는 정렬 된 목록으로 표시됩니다. 따라서 관계 R에서 세트의 이미지를 작성하면 R의 모든 요소를 ​​탐색 할 수 있습니다 (결과 정렬, 이미지). 에서는 &lt;code&gt;&lt;a href=&quot;#image-2&quot;&gt;image/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;BinRel&lt;/code&gt; 는 각 요소의 일단 이송된다 &lt;code&gt;SetOfSets&lt;/code&gt; 너무 오래 걸릴 수있다. &lt;code&gt;SetOfSets&lt;/code&gt; 아래 &lt;code&gt;BinRel&lt;/code&gt; 의 각 요소 이미지가 비어 있지 않다는 가정하에 다음과 같은 효율적인 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="702f6004e5b0649a561e34b9923038a5fe581813" translate="yes" xml:space="preserve">
          <source>Externally Used Functions. Functions of all modules - including local functions - that have been used in some external call.</source>
          <target state="translated">외부 적으로 사용되는 기능. 일부 외부 호출에 사용 된 로컬 기능을 포함한 모든 모듈의 기능.</target>
        </trans-unit>
        <trans-unit id="9dc41b56ffb870aa8667296ee85faf8526c78e2d" translate="yes" xml:space="preserve">
          <source>Extra arguments to append to callbacks to the callback module in question. These are appended to any extra arguments configured on the callback itself. Multiple options append to the argument list.</source>
          <target state="translated">해당 콜백 모듈에 대한 콜백에 추가 할 추가 인수입니다. 콜백 자체에 구성된 추가 인수에 추가됩니다. 인수 목록에 여러 옵션이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="24857f5df323016703cb6fdbfde355cc9374cd07" translate="yes" xml:space="preserve">
          <source>Extra arguments to the Erlang emulator. Avoid &lt;code&gt;-noinput&lt;/code&gt;, &lt;code&gt;-noshell&lt;/code&gt;, and &lt;code&gt;-sname&lt;/code&gt;/&lt;code&gt;-name&lt;/code&gt;. Default is no extra arguments. Remember that the services cookie file is not necessarily the same as the interactive users. The service runs as the local administrator. Specify all arguments together in one string, use double quotes (&quot;) to specify an argument string containing spaces, and use quoted quotes (\&quot;) to specify a quote within the argument string if necessary.</source>
          <target state="translated">Erlang 에뮬레이터에 대한 추가 인수. &lt;code&gt;-noinput&lt;/code&gt; , &lt;code&gt;-noshell&lt;/code&gt; 및 &lt;code&gt;-sname&lt;/code&gt; / &lt;code&gt;-name&lt;/code&gt; 을 피하십시오 . 기본값은 추가 인수가 아닙니다. 서비스 쿠키 파일은 대화식 사용자와 반드시 같을 필요는 없습니다. 서비스는 로컬 관리자로 실행됩니다. 모든 인수를 하나의 문자열로 함께 지정하고 큰 따옴표 ( &quot;)를 사용하여 공백이 포함 된 인수 문자열을 지정하고 따옴표 (\&quot;)를 사용하여 필요한 경우 인수 문자열 내에 따옴표를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1a5ed847a392a0a62263f179dd2fc24c2f3db284" translate="yes" xml:space="preserve">
          <source>Extra field of &lt;code&gt;Elen&lt;/code&gt; bytes.</source>
          <target state="translated">&lt;code&gt;Elen&lt;/code&gt; 바이트 의 추가 필드 .</target>
        </trans-unit>
        <trans-unit id="21fdf9672534e5b3289575836da1260c05091d37" translate="yes" xml:space="preserve">
          <source>Extract from &lt;code&gt;fact.erl&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fact.erl&lt;/code&gt; 에서 추출 :</target>
        </trans-unit>
        <trans-unit id="76499b81f508c818fc8ede2f6857319a78f6b78c" translate="yes" xml:space="preserve">
          <source>Extract the html archive in the installation directory.</source>
          <target state="translated">설치 디렉토리에서 html 아카이브를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="b1255a61e7dfddc61222eeed560c46780e362532" translate="yes" xml:space="preserve">
          <source>Extracts a specified element from an Erlang tuple.</source>
          <target state="translated">Erlang 튜플에서 지정된 요소를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="2de52555eab2d85bd549c7c335845c6f805b8dc7" translate="yes" xml:space="preserve">
          <source>Extracts all files from a tar archive.</source>
          <target state="translated">tar 아카이브에서 모든 파일을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1e36ee460b66be04ca04bbcdacbb3b4fea7ec8e5" translate="yes" xml:space="preserve">
          <source>Extracts comments from a string containing Erlang source code. Except for reading directly from a string, the behaviour is the same as for &lt;code&gt;&lt;a href=&quot;#file-1&quot;&gt;file/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 소스 코드가 포함 된 문자열에서 주석을 추출합니다. 문자열에서 직접 읽는 것을 제외하고는 동작은 &lt;code&gt;&lt;a href=&quot;#file-1&quot;&gt;file/1&lt;/a&gt;&lt;/code&gt; 과 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="e76ccbc0a9e27f91b1b488b109f8599dfdb46906" translate="yes" xml:space="preserve">
          <source>Extracts comments from an Erlang source code file. Returns a list of entries representing &lt;strong&gt;multi-line&lt;/strong&gt; comments, listed in order of increasing line-numbers. For each entry, &lt;code&gt;Text&lt;/code&gt; is a list of strings representing the consecutive comment lines in top-down order; the strings contain &lt;strong&gt;all&lt;/strong&gt; characters following (but not including) the first comment-introducing &lt;code&gt;%&lt;/code&gt; character on the line, up to (but not including) the line-terminating newline.</source>
          <target state="translated">Erlang 소스 코드 파일에서 주석을 추출합니다. 줄 번호가 증가하는 순서대로 나열된 &lt;strong&gt;여러 줄&lt;/strong&gt; 주석을 나타내는 항목 목록을 반환 합니다. 각 항목에 대해 &lt;code&gt;Text&lt;/code&gt; 는 연속 된 주석 행을 위에서 아래로 나타내는 문자열 목록입니다. 문자열에는 줄 에서 첫 번째 주석을 소개하는 &lt;code&gt;%&lt;/code&gt; 문자 다음에 오는 &lt;strong&gt;모든&lt;/strong&gt; 문자가 포함 됩니다 (줄을 포함하지 않는).</target>
        </trans-unit>
        <trans-unit id="56c5582329f83a654a52e6745e87c2ac598a8711" translate="yes" xml:space="preserve">
          <source>Extracts distribution points from the certificates extensions.</source>
          <target state="translated">인증서 확장에서 배포 지점을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c27cd1b3613ae91223b4fc3f3ff7f52631b2bd7e" translate="yes" xml:space="preserve">
          <source>Extracts files from a tar archive.</source>
          <target state="translated">tar 아카이브에서 파일을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="fb1b3810288e1f952296f446cd12717a4d4c6389" translate="yes" xml:space="preserve">
          <source>Extracts individual comment lines from a source code string. Returns a list of comment lines found in the text, listed in order of &lt;strong&gt;decreasing&lt;/strong&gt; line-numbers, i.e., the last comment line in the input is first in the resulting list. &lt;code&gt;Text&lt;/code&gt; is a single string, containing all characters following (but not including) the first comment-introducing &lt;code&gt;%&lt;/code&gt; character on the line, up to (but not including) the line-terminating newline. For details on &lt;code&gt;Line&lt;/code&gt;, &lt;code&gt;Column&lt;/code&gt; and &lt;code&gt;Indent&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#file-1&quot;&gt;file/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">소스 코드 문자열에서 개별 주석 행을 추출합니다. 줄 번호 를 &lt;strong&gt;내림차순으로&lt;/strong&gt; 나열한 텍스트에서 찾은 주석 행 목록을 리턴합니다 . 즉, 입력의 마지막 주석 행이 결과 목록에서 첫 번째입니다. &lt;code&gt;Text&lt;/code&gt; 는 줄로 끝나는 줄 바꿈까지 줄에 첫 번째 주석을 표시하는 &lt;code&gt;%&lt;/code&gt; 문자 다음을 포함하지만 포함하지 않는 모든 문자를 포함하는 단일 문자열 입니다. &lt;code&gt;Line&lt;/code&gt; , &lt;code&gt;Column&lt;/code&gt; 및 &lt;code&gt;Indent&lt;/code&gt; 에 대한 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;#file-1&quot;&gt;file/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="655f37a384e7ab195c12d1a0e8c241b01afdcd35" translate="yes" xml:space="preserve">
          <source>Extracts one or all files from an open archive.</source>
          <target state="translated">열린 아카이브에서 하나 또는 모든 파일을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="d955a7dca57b26304e4145b2d6808fe84fd62226" translate="yes" xml:space="preserve">
          <source>Extracts the first element from a list.</source>
          <target state="translated">목록에서 첫 번째 요소를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5ab632a1ddfea5f5f6247df3a3cb6f843b3d2739" translate="yes" xml:space="preserve">
          <source>Extracts the initial call of a process that was started using one of the spawn or start functions in this module. &lt;code&gt;Process&lt;/code&gt; can either be a pid, an integer tuple (from which a pid can be created), or the process information of a process &lt;code&gt;Pid&lt;/code&gt; fetched through an &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; function call.</source>
          <target state="translated">이 모듈에서 생성 또는 시작 기능 중 하나를 사용하여 시작된 프로세스의 초기 호출을 추출합니다. &lt;code&gt;Process&lt;/code&gt; 는 pid, 정수 튜플 (pid를 작성할 수 있음) 또는 &lt;code&gt;erlang:process_info(Pid)&lt;/code&gt; 함수 호출을 통해 페치 된 프로세스 &lt;code&gt;Pid&lt;/code&gt; 의 프로세스 정보 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0baa839a87a55a95e088d0af02451cdc7f90de47" translate="yes" xml:space="preserve">
          <source>Extracts the nodes from the parsed XML tree according to XPath. xmlObj is a record with fields type and value, where type is boolean | number | string</source>
          <target state="translated">XPath에 따라 구문 분석 된 XML 트리에서 노드를 추출합니다. xmlObj는 type 및 value 필드가있는 레코드입니다. 여기서 type은 boolean | 번호 | 끈</target>
        </trans-unit>
        <trans-unit id="86e3eb4e92bc7affbd29d377357bc195216cee8c" translate="yes" xml:space="preserve">
          <source>Extracts the nodes from the xml tree according to XPath.</source>
          <target state="translated">XPath에 따라 xml 트리에서 노드를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5799c76f5fc9581a7297dbbe3dacd7de3f584359" translate="yes" xml:space="preserve">
          <source>Extracts the part of binary &lt;code&gt;Subject&lt;/code&gt; described by &lt;code&gt;PosLen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PosLen&lt;/code&gt; 으로 기술 된 바이너리 &lt;code&gt;Subject&lt;/code&gt; 의 일부를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="dee314395029509dffa3665108322556c55c7005" translate="yes" xml:space="preserve">
          <source>Extracts the part of the binary described by &lt;code&gt;PosLen&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PosLen&lt;/code&gt; 에 의해 기술 된 바이너리 부분을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="5a4d0ecc3f40b06c8cc3ade0e107ab17bda0568f" translate="yes" xml:space="preserve">
          <source>Extracts the tail from a list.</source>
          <target state="translated">목록에서 꼬리를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1f7e43e4399fb814514df1c0648f488ad523e8e2" translate="yes" xml:space="preserve">
          <source>Extracts the tar file &lt;code&gt;mysystem.tar.gz&lt;/code&gt; into the target directory &lt;code&gt;/usr/local/erl-target&lt;/code&gt;.</source>
          <target state="translated">tar 파일 &lt;code&gt;mysystem.tar.gz&lt;/code&gt; 를 대상 디렉토리 &lt;code&gt;/usr/local/erl-target&lt;/code&gt; 에 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="2b302481602929aa88594ecc1d4d80277d0fef09" translate="yes" xml:space="preserve">
          <source>Extraneous certificates in chain</source>
          <target state="translated">체인의 외부 인증서</target>
        </trans-unit>
        <trans-unit id="17958dd1df3f442d0bf6de03deb5a8db6f06e65a" translate="yes" xml:space="preserve">
          <source>Extremely fast real-time data searches.</source>
          <target state="translated">매우 빠른 실시간 데이터 검색.</target>
        </trans-unit>
        <trans-unit id="f16c1001bcfd4875b664e58e36606c52c10b04af" translate="yes" xml:space="preserve">
          <source>FAIL(Fail)</source>
          <target state="translated">FAIL(Fail)</target>
        </trans-unit>
        <trans-unit id="7787ae36042d9794e38bd318cfd51df43ade016f" translate="yes" xml:space="preserve">
          <source>FLOAT (precision)</source>
          <target state="translated">플로트 (정밀도)</target>
        </trans-unit>
        <trans-unit id="cccffd6f431246c8672fe367c4387e016ca363d5" translate="yes" xml:space="preserve">
          <source>FTP client module (based on the &lt;code&gt;ftp&lt;/code&gt; application).</source>
          <target state="translated">FTP 클라이언트 모듈 ( &lt;code&gt;ftp&lt;/code&gt; 응용 프로그램 기반 ).</target>
        </trans-unit>
        <trans-unit id="e93194f544a2aa989e9a7dedd8f4ebf23ad50271" translate="yes" xml:space="preserve">
          <source>FTP client module (based on the FTP application).</source>
          <target state="translated">FTP 클라이언트 모듈 (FTP 응용 프로그램 기반).</target>
        </trans-unit>
        <trans-unit id="49eef6c2a80675ed6b65e3a2e947698dcd57c2e8" translate="yes" xml:space="preserve">
          <source>FTP clients are considered to be rather temporary. Thus, they are only started and stopped during runtime and cannot be started at application startup. The FTP client API is designed to allow some functions to return intermediate results. This implies that only the process that started the FTP client can access it with preserved sane semantics. If the process that started the FTP session dies, the FTP client process terminates.</source>
          <target state="translated">FTP 클라이언트는 일시적인 것으로 간주됩니다. 따라서 런타임 중에 만 시작 및 중지되며 응용 프로그램 시작시 시작할 수 없습니다. FTP 클라이언트 API는 일부 함수가 중간 결과를 리턴 할 수 있도록 설계되었습니다. 이는 FTP 클라이언트를 시작한 프로세스 만 보존 된 의미 체계를 사용하여 액세스 할 수 있음을 의미합니다. FTP 세션을 시작한 프로세스가 종료되면 FTP 클라이언트 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e09096abf3a825f1915427ea0978eb99bbf1d70b" translate="yes" xml:space="preserve">
          <source>FTP commands requiring a data connection cannot be successfully issued with this function.</source>
          <target state="translated">이 기능으로 데이터 연결이 필요한 FTP 명령을 발행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64e1e50a3956ea778cbd570cd0588159a0418a9b" translate="yes" xml:space="preserve">
          <source>Failed to get current process</source>
          <target state="translated">현재 프로세스를 가져 오지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="a337ed06b924b4213c3c839d5ba7078c91160fd2" translate="yes" xml:space="preserve">
          <source>Failed to send net tick over the connection.</source>
          <target state="translated">연결을 통해 네트 틱을 보내지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="f86557eca299464becfc8aa34f0c6d3b35119ce2" translate="yes" xml:space="preserve">
          <source>Failed to set a monitor on a process</source>
          <target state="translated">프로세스에서 모니터를 설정하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="77091a62aab2060ffe78a81fbae2e79ec826cff0" translate="yes" xml:space="preserve">
          <source>Failed-AVP AVP</source>
          <target state="translated">실패한 AVP AVP</target>
        </trans-unit>
        <trans-unit id="f974abb530126dfc013636c690395e99df1fb5ce" translate="yes" xml:space="preserve">
          <source>Failover and Failback Procedures</source>
          <target state="translated">장애 조치 및 장애 복구 절차</target>
        </trans-unit>
        <trans-unit id="48556fbfca36a85342bd3d2e21587a62a8196977" translate="yes" xml:space="preserve">
          <source>Fails by raising an error exception with an error reason of:</source>
          <target state="translated">다음 오류 이유와 함께 오류 예외를 발생시켜 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e302a1938e77f83802f4ce4513e659bb2dd90e36" translate="yes" xml:space="preserve">
          <source>Fails with an exception if &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;SubDir&lt;/code&gt; has the wrong type.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 또는 &lt;code&gt;SubDir&lt;/code&gt; 의 유형이 잘못된 경우 예외로 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="bbfd5debbf2e23b39610483b4d4e87230b8082c4" translate="yes" xml:space="preserve">
          <source>Fails with reason &lt;code&gt;empty&lt;/code&gt; if &lt;code&gt;Q1&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;Q1&lt;/code&gt; 이 비어 있으면 이유가 &lt;code&gt;empty&lt;/code&gt; 있으면 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="7303367360950544963d4dcad809bafef4cce750" translate="yes" xml:space="preserve">
          <source>Fails with reason &lt;code&gt;empty&lt;/code&gt; if &lt;code&gt;Q&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;Q&lt;/code&gt; 가 비어 있으면 이유가 &lt;code&gt;empty&lt;/code&gt; 있으면 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="e62b5bba29ee3acff62d3674bfa3e7dc7f31f9da" translate="yes" xml:space="preserve">
          <source>Failure to crash or exit when things go wrong:</source>
          <target state="translated">문제가 발생했을 때 충돌 또는 종료 실패 :</target>
        </trans-unit>
        <trans-unit id="1607e68ad706a0a791e6e1d8d001f14ec655a724" translate="yes" xml:space="preserve">
          <source>Failure to set up a connection to the node identified by &lt;code&gt;Node&lt;/code&gt; or the connection to that node was lost during the spawn operation. In the case the connection was lost, a process may or may not have been created.</source>
          <target state="translated">노드로 식별 된 &lt;code&gt;Node&lt;/code&gt; 대한 연결 설정에 실패 했거나 생성 작업 중에 해당 노드에 대한 연결이 끊어졌습니다. 연결이 끊어진 경우 프로세스가 생성되거나 생성되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05bd383494044ce1abf4223e78c2b896367a3872" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt; error_handler:undefined_function/3&lt;/code&gt; is called if the applied function is not exported. The error handler can be redefined (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;error_handler&lt;/code&gt; is undefined, or if the user has redefined the default &lt;code&gt;error_handler&lt;/code&gt; so the replacement module is undefined, an error with reason &lt;code&gt;undef&lt;/code&gt; is generated.</source>
          <target state="translated">실패 : 적용된 함수를 내 보내지 않으면 &lt;code&gt; error_handler:undefined_function/3&lt;/code&gt; 이 호출됩니다. 오류 처리기는 재정의 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; 참조 ). 경우 &lt;code&gt;error_handler&lt;/code&gt; 가 정의되어 있지 사용자가 기본 재정의 경우, 또는 &lt;code&gt;error_handler&lt;/code&gt; 교체 모듈이 정의되지 않도록를 이유에 오류 &lt;code&gt;undef&lt;/code&gt; 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="838f983e143a183d4eccfec825edc11e3ecb0776" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Binary&lt;/code&gt; contains a bad representation of a float.</source>
          <target state="translated">실패 : &lt;code&gt;Binary&lt;/code&gt; 에 잘못된 부동 소수점 표현이 포함 된 경우 &lt;code&gt;badarg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c0895353c7a2ff06778a1193333513af4b5f8ef" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Binary&lt;/code&gt; contains a bad representation of an integer.</source>
          <target state="translated">실패 : &lt;code&gt;Binary&lt;/code&gt; 에 잘못된 정수 표현이 포함 된 경우 &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb2ecb406b75378837950207b77862b175a51709" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;List&lt;/code&gt; is the empty list &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">실패 : &lt;code&gt;List&lt;/code&gt; 가 빈 목록 인 경우 &lt;code&gt;badarg&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5fce060e72df96f370bf1af3657a2845adb392d" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Localtime&lt;/code&gt; denotes an invalid date and time.</source>
          <target state="translated">실패 : &lt;code&gt;badarg&lt;/code&gt; 시간이 유효하지 않은 날짜 및 시간을 나타내는 경우 &lt;code&gt;Localtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c61e75de2774f2ae96a873b7a336685f1f3bbb1" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">실패 : &lt;code&gt;Pid&lt;/code&gt; 가 로컬 프로세스가 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87a8727d434414896baf192cf2beb197aee1b528" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Port&lt;/code&gt; is not a local port identifier, or an atom.</source>
          <target state="translated">실패 : &lt;code&gt;Port&lt;/code&gt; 가 로컬 포트 ​​식별자 또는 원자가 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c68a90d7c956995be93c41aa1c10781a4b9f39c3" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">실패 : &lt;code&gt;Port&lt;/code&gt; 가 열린 포트의 식별자 또는 열린 포트의 등록 된 이름이 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; . 호출 프로세스가 이전에 &lt;code&gt;Port&lt;/code&gt; 로 식별 된 닫힌 포트에 링크 된 경우, 이 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생 하기 전에 포트의 종료 신호가 전달되도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="de1ead34bb8ff2b5a5a7948ab0e7ea21e4174fe0" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary.</source>
          <target state="translated">실패 : &lt;code&gt;badarg&lt;/code&gt; 이 어떤 식 으로든 바이너리 외부를 참조 하면 &lt;code&gt;PosLen&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0540ed92cc918dfe5f4e8c28b3105018029c739" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;RegName&lt;/code&gt; is not a registered name.</source>
          <target state="translated">실패 : &lt;code&gt;RegName&lt;/code&gt; 이 등록 된 이름이 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fe7b44d5dcc866abe30eb67bf3af1c1360618493" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;String&lt;/code&gt; contains a bad representation of a float.</source>
          <target state="translated">실패 : &lt;code&gt;String&lt;/code&gt; 에 잘못된 부동 소수점 표현이 포함 된 경우 &lt;code&gt;badarg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="089aaaaa8ea023713f5c70397e832162902543cb" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;String&lt;/code&gt; contains a bad representation of a port identifier.</source>
          <target state="translated">실패 : &lt;code&gt;String&lt;/code&gt; 에 포트 식별자의 잘못된 표현이 포함 된 경우 &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8090be3c26db3c86345e466fdca683ee89a8233f" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;String&lt;/code&gt; contains a bad representation of a process identifier.</source>
          <target state="translated">실패 : &lt;code&gt;String&lt;/code&gt; 에 잘못된 프로세스 식별자 표현이 포함 된 경우 &lt;code&gt;badarg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9aacae05feb0a1ff4ce0fdc1f08fcca988f90d6" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;String&lt;/code&gt; contains a bad representation of a reference.</source>
          <target state="translated">실패 : &lt;code&gt;String&lt;/code&gt; 에 잘못된 참조 표현이 포함 된 경우 &lt;code&gt;badarg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9ef355ef31ce1db3f66b399d0f6960b9e0f780f" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;String&lt;/code&gt; contains a bad representation of an integer.</source>
          <target state="translated">실패 : &lt;code&gt;String&lt;/code&gt; 에 잘못된 정수 표현이 포함 된 경우 &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0505d22101a46d9b1d54d1c91f0834df3bcbe4" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Tracee&lt;/code&gt; does not refer to a process (dead or alive) on the same node as the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; resides on.</source>
          <target state="translated">실패 : &lt;code&gt;badarg&lt;/code&gt; 경우 &lt;code&gt;Tracee&lt;/code&gt; 가 의 호출자와 동일한 노드에 (죽은이나 살아) 프로세스를 참조하지 않습니다 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; 에 상주합니다.</target>
        </trans-unit>
        <trans-unit id="1098e64869f436927709dd2ed0dbab08019fe364" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;Universaltime&lt;/code&gt; denotes an invalid date and time.</source>
          <target state="translated">실패 : &lt;code&gt;Universaltime&lt;/code&gt; 이 유효하지 않은 날짜 및 시간을 나타내는 경우 &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c912dc44d7ba65423ed00143de810a75a90cae0" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;safe&lt;/code&gt; is specified and unsafe data is decoded.</source>
          <target state="translated">실패 : &lt;code&gt;safe&lt;/code&gt; 이 지정되고 안전하지 않은 데이터가 디코딩 되면 &lt;code&gt;badarg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b317dfdbe7d838ae9ec457962a563bf41ac27ef" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if the arguments do not satisfy the requirements specified here.</source>
          <target state="translated">실패 : 인수가 여기에 지정된 요구 사항을 충족하지 않으면 &lt;code&gt;badarg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="770f60b3feed2d25c64b492b9e4fe8f2fdc4357e" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if the atom does not exist.</source>
          <target state="translated">실패 : 원자가 존재하지 않으면 &lt;code&gt;badarg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0fd30f9c1ba7b7eae53cce0e87b57d1742b7a77" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if the local node is not alive or the option list is malformed.</source>
          <target state="translated">실패 : 로컬 노드가 &lt;code&gt;badarg&lt;/code&gt; 상태가 아니거나 옵션 목록이 잘못된 경우 badarg .</target>
        </trans-unit>
        <trans-unit id="450d1e71a72c071bdaf82394784c12257b0d55c6" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">실패 : 로컬 노드가 &lt;code&gt;badarg&lt;/code&gt; 상태가 아닌 경우 badarg .</target>
        </trans-unit>
        <trans-unit id="df957d462e64a1a37c23ec4931c7e00791112a01" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if the specified arguments are not supported. For example, &lt;code&gt;cpu_timestamp&lt;/code&gt; is not supported on all platforms.</source>
          <target state="translated">실패 : 지정된 인수가 지원되지 않으면 &lt;code&gt;badarg&lt;/code&gt; 입니다. 예를 들어 &lt;code&gt;cpu_timestamp&lt;/code&gt; 가 모든 플랫폼에서 지원되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d979419a05acdf971da35d1b994aa4c0bd693c89" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if there already is an old version of &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">실패 : &lt;code&gt;badarg&lt;/code&gt; 이미 이전 버전이있는 경우 &lt;code&gt;Module&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f0447ae5d142122e4d1d78ea60485bd56098381" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if there does not already exist an atom whose text representation is &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">실패 : &lt;code&gt;badarg&lt;/code&gt; 이미 그 텍스트 표현입니다 원자가 존재하지 않는 경우 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="441ce77452ae922bbcb33f6103e1a26e58c2c1ca" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;badarg&lt;/code&gt; if there is no old code for &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">실패 : &lt;code&gt;Module&lt;/code&gt; 에 대한 이전 코드가없는 경우 &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad356c787a460ef5fe6597776b0c6bcdb7c07b1" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;error_handler:undefined_function/3&lt;/code&gt; is called if the applied function is not exported. The error handler can be redefined (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;error_handler&lt;/code&gt; is undefined, or if the user has redefined the default &lt;code&gt;error_handler&lt;/code&gt; so the replacement module is undefined, an error with reason &lt;code&gt;undef&lt;/code&gt; is generated.</source>
          <target state="translated">실패 : 적용된 함수를 내 보내지 않으면 &lt;code&gt;error_handler:undefined_function/3&lt;/code&gt; 이 호출됩니다. 오류 처리기를 재정의 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; 참조 ). 경우 &lt;code&gt;error_handler&lt;/code&gt; 가 정의되어 있지 사용자가 기본 재정의 경우, 또는 &lt;code&gt;error_handler&lt;/code&gt; 교체 모듈이 정의되지 않도록를 이유에 오류 &lt;code&gt;undef&lt;/code&gt; 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b86e360a41346fc97050fd061ffe0b427b733e46" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;function_clause&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">실패 : 로컬 노드가 활성 상태가 아닌 경우 &lt;code&gt;function_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c55dd03271169d21f0a864cb148e9cd3d53a4aef" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;nocatch&lt;/code&gt; if not evaluated within a catch.</source>
          <target state="translated">실패 : 캐치 내에서 평가되지 않으면 &lt;code&gt;nocatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="735e9b3e3bba0cabb519251b9c2dd008d4c5f5a9" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;notsup&lt;/code&gt; if an &lt;code&gt;erts_alloc(3)&lt;/code&gt; allocator has been disabled.</source>
          <target state="translated">실패 : &lt;code&gt;notsup&lt;/code&gt; &lt;code&gt;erts_alloc(3)&lt;/code&gt; 할당자가 비활성화 된 경우 notsup .</target>
        </trans-unit>
        <trans-unit id="12970f9c7fbf5c14bb65820c019426184ea24d49" translate="yes" xml:space="preserve">
          <source>Failure: &lt;code&gt;{badarg, Info}}&lt;/code&gt; if &lt;code&gt;Pid&lt;/code&gt; is not an existing local pid.</source>
          <target state="translated">실패 : &lt;code&gt;Pid&lt;/code&gt; 가 기존 로컬 pid가 아닌 경우 &lt;code&gt;{badarg, Info}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b29a9a5c785430d46dfd7d91d2f027c8599626e" translate="yes" xml:space="preserve">
          <source>Failure: If a script cannot be found, the function fails with an appropriate error reason.</source>
          <target state="translated">실패 : 스크립트를 찾을 수없는 경우, 적절한 오류 이유로 기능이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="539682bc04de316047e0c399e44365ec02883bf5" translate="yes" xml:space="preserve">
          <source>Failure: It is an error if &lt;code&gt;MonitorRef&lt;/code&gt; refers to a monitoring started by another process. Not all such cases are cheap to check. If checking is cheap, the call fails with &lt;code&gt;badarg&lt;/code&gt;, for example if &lt;code&gt;MonitorRef&lt;/code&gt; is a remote reference.</source>
          <target state="translated">실패 : &lt;code&gt;MonitorRef&lt;/code&gt; 가 다른 프로세스에서 시작한 모니터링을 나타내는 경우 오류 입니다. 그러한 모든 경우를 확인하는 것이 저렴하지는 않습니다. 검사가 저렴하면 예를 들어 &lt;code&gt;MonitorRef&lt;/code&gt; 가 원격 참조 인 경우 &lt;code&gt;badarg&lt;/code&gt; 로 호출에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="a351ea42a7c08c75760cf4eb0f75aea4dfcfd460" translate="yes" xml:space="preserve">
          <source>Failure: if the port cannot be opened, the exit reason is &lt;code&gt;badarg&lt;/code&gt;, &lt;code&gt;system_limit&lt;/code&gt;, or the POSIX error code that most closely describes the error, or &lt;code&gt;einval&lt;/code&gt; if no POSIX code is appropriate:</source>
          <target state="translated">실패 : 포트를 열 수없는 경우 종료 이유는 오류를 가장 자세히 설명하는 &lt;code&gt;badarg&lt;/code&gt; , &lt;code&gt;system_limit&lt;/code&gt; 또는 POSIX 오류 코드이거나 POSIX 코드가 적절하지 않은 경우 &lt;code&gt;einval&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13928441cadbafa94796d982f5eebcc7f19f43dc" translate="yes" xml:space="preserve">
          <source>Failures:</source>
          <target state="translated">Failures:</target>
        </trans-unit>
        <trans-unit id="b4a100ebc4c1820c605bd96d9dd279ff888640e2" translate="yes" xml:space="preserve">
          <source>Fallback</source>
          <target state="translated">Fallback</target>
        </trans-unit>
        <trans-unit id="827eff11b49bf55437574b601a10ff45b4ad4006" translate="yes" xml:space="preserve">
          <source>False events can occur. That is, calls to &lt;code&gt;ready_input&lt;/code&gt; or &lt;code&gt;ready_output&lt;/code&gt; although no real events are signaled. In reality, it is rare (and OS-dependant), but a robust driver must nevertheless be able to handle such cases.</source>
          <target state="translated">잘못된 이벤트가 발생할 수 있습니다. 즉, 실제 이벤트는 신호가 없지만 &lt;code&gt;ready_input&lt;/code&gt; 또는 &lt;code&gt;ready_output&lt;/code&gt; 을 호출합니다 . 실제로는 드물고 (OS에 따라 다름) 강력한 드라이버가 이러한 경우를 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="daa330c60371ee04d9f830af0c60804749aaf37f" translate="yes" xml:space="preserve">
          <source>Fast real-time key/value lookup</source>
          <target state="translated">빠른 실시간 키 / 값 조회</target>
        </trans-unit>
        <trans-unit id="f27447e885962d8e87201bc9c386dfce87684f91" translate="yes" xml:space="preserve">
          <source>Fast real-time operations</source>
          <target state="translated">빠른 실시간 운영</target>
        </trans-unit>
        <trans-unit id="e71cf0ced263da3bb91198344e4f14003d54cce7" translate="yes" xml:space="preserve">
          <source>Fatal communication error and reconnection attempts are always printed, even if logging has been suppressed for the connection type in question. However, operations such as sending and receiving data are performed silently.</source>
          <target state="translated">해당 연결 유형에 대해 로깅이 억제 된 경우에도 치명적인 통신 오류 및 재 연결 시도가 항상 인쇄됩니다. 그러나 데이터 송수신과 같은 작업은 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d71befc2691cc5c0a427a5a5793c6c1bc118d74d" translate="yes" xml:space="preserve">
          <source>Fault Resilience</source>
          <target state="translated">장애 복구</target>
        </trans-unit>
        <trans-unit id="c06ebb7f2aaf5855c9aa5c6b48767553f3f68e00" translate="yes" xml:space="preserve">
          <source>Fault tolerance</source>
          <target state="translated">결함 허용</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="e328294bfd7e14656d3352b02e669c5db8bcede3" translate="yes" xml:space="preserve">
          <source>Features that are disabled include (but are not limited to) the following:</source>
          <target state="translated">비활성화 된 기능에는 다음이 포함되지만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddd988908e71dee969b21f00ec95d7e6279d57be" translate="yes" xml:space="preserve">
          <source>Fedora 16 is known to contain UTRACE, for most other Linux distributions a custom build kernel will be required. Check Fedora's SystemTap documentation for additional required packages (e.g. Kernel Debug Symbols)</source>
          <target state="translated">Fedora 16은 UTRACE를 포함하는 것으로 알려져 있으며, 대부분의 다른 Linux 배포판에는 사용자 지정 빌드 커널이 필요합니다. 추가 필수 패키지 (예 : 커널 디버그 기호)는 Fedora의 SystemTap 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ac1e43987e33c2c73a2e8cf09e4b1960e31cbed3" translate="yes" xml:space="preserve">
          <source>Feed digit map collector with events and return the result</source>
          <target state="translated">이벤트가있는 숫자 맵 콜렉터에 피드하고 결과를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="da9de34c74533fb176868fea819d65cc5f43c3f9" translate="yes" xml:space="preserve">
          <source>Fetch a file with the Erlang SFTP client:</source>
          <target state="translated">Erlang SFTP 클라이언트로 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="aac01a03bbd346596aa6b86624e6db4a65dc1ec7" translate="yes" xml:space="preserve">
          <source>Fetch all data in the table employee</source>
          <target state="translated">테이블 직원의 모든 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2cb82a9eed1ea63d1489c4f488187b59bd00647b" translate="yes" xml:space="preserve">
          <source>Fetch data from the Cover database on the remote nodes and stored on the main node.</source>
          <target state="translated">원격 노드의 Cover 데이터베이스에서 데이터를 가져오고 기본 노드에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="caf42d872afb89dda4a08a7bdabc01d1aa1c1922" translate="yes" xml:space="preserve">
          <source>Fetch default cipher suite list for a TLS/DTLS version. Change default to all to get all possible cipher suites.</source>
          <target state="translated">TLS / DTLS 버전에 대한 기본 암호 그룹 목록을 가져옵니다. 가능한 모든 암호 그룹을 얻으려면 기본값을 all로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="fccae3437be3f4f73def3bdb3e65541780aed908" translate="yes" xml:space="preserve">
          <source>Fetch default cipher suite list for an TLS/DTLS version. Change default to all to get all possible cipher suites.</source>
          <target state="translated">TLS / DTLS 버전의 기본 암호 스위트 목록을 가져옵니다. 가능한 모든 암호 스위트를 얻으려면 기본값을 all로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9315f871fd952912e116beff03bac310c73d2116" translate="yes" xml:space="preserve">
          <source>Fetch next line from the history buffer</source>
          <target state="translated">히스토리 버퍼에서 다음 라인을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e41b6e9ccfe6823dd8105ed9572880bb6a6f9b3c" translate="yes" xml:space="preserve">
          <source>Fetch previous line from the history buffer</source>
          <target state="translated">히스토리 버퍼에서 이전 라인을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="75c1a9f02f5cbfb91f1918f73db959ccc0eb5e9e" translate="yes" xml:space="preserve">
          <source>Fetch the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees</source>
          <target state="translated">모든 여성 직원의 &lt;code&gt;FIRSTNAME&lt;/code&gt; 및 &lt;code&gt;NR&lt;/code&gt; 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2e575236e557bbd037fba4ee4c0c99916345307a" translate="yes" xml:space="preserve">
          <source>Fetch the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees and sort them on the field &lt;code&gt;FIRSTNAME&lt;/code&gt;.</source>
          <target state="translated">모든 여성 직원의 &lt;code&gt;FIRSTNAME&lt;/code&gt; 및 &lt;code&gt;NR&lt;/code&gt; 필드를 가져 와서 &lt;code&gt;FIRSTNAME&lt;/code&gt; 필드에서 정렬하십시오 .</target>
        </trans-unit>
        <trans-unit id="f96bb86cc755f42ee5b17c63da3d96b67920ce0d" translate="yes" xml:space="preserve">
          <source>Fetches a file over FTP.</source>
          <target state="translated">FTP를 통해 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2e6ab2cb54f4245d58b27caaa6e98de4b9207f2c" translate="yes" xml:space="preserve">
          <source>Fetches a file using the low-level loader. &lt;code&gt;Filename&lt;/code&gt; is either an absolute filename or only the name of the file, for example, &lt;code&gt;&quot;lists.beam&quot;&lt;/code&gt;. If an internal path is set to the loader, this path is used to find the file. &lt;code&gt;FullName&lt;/code&gt; is the complete name of the fetched file. &lt;code&gt;Bin&lt;/code&gt; is the contents of the file as a binary.</source>
          <target state="translated">로우 레벨 로더를 사용하여 파일을 가져옵니다. &lt;code&gt;Filename&lt;/code&gt; 은 절대 파일 이름이거나 파일 이름 &lt;code&gt;&quot;lists.beam&quot;&lt;/code&gt; 입니다 (예 : &quot;lists.beam&quot;) . 내부 경로가 로더로 설정된 경우이 경로는 파일을 찾는 데 사용됩니다. &lt;code&gt;FullName&lt;/code&gt; 은 가져온 파일의 전체 이름입니다. &lt;code&gt;Bin&lt;/code&gt; 은 파일 내용을 바이너리로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d22550ab548c26f6ee2ea248382f629aa957419" translate="yes" xml:space="preserve">
          <source>Fetches information about the HTTP server. When called with only &lt;code&gt;Address&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;, all properties are fetched. When called with a list of specific properties, they are fetched. The available properties are the same as the start options of the server.</source>
          <target state="translated">HTTP 서버에 대한 정보를 가져옵니다. &lt;code&gt;Address&lt;/code&gt; 및 &lt;code&gt;Port&lt;/code&gt; 만 사용하여 호출하면 모든 특성이 페치됩니다. 특정 속성 목록과 함께 호출되면 가져옵니다. 사용 가능한 특성은 서버의 시작 옵션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9ac5237f1c5642668986a4437070f24b8205596d" translate="yes" xml:space="preserve">
          <source>Fetches information about the HTTP server. When called with only the pid, all properties are fetched. When called with a list of specific properties, they are fetched. The available properties are the same as the start options of the server.</source>
          <target state="translated">HTTP 서버에 대한 정보를 가져옵니다. pid로만 호출하면 모든 속성을 가져옵니다. 특정 속성 목록과 함께 호출되면 가져옵니다. 사용 가능한 특성은 서버의 시작 옵션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ae323219de63b51515bafa21c8b7c1ab4ddb3695" translate="yes" xml:space="preserve">
          <source>Fetches the corresponding public key from a private key stored in an Engine. The key must be of the type indicated by the Type parameter.</source>
          <target state="translated">엔진에 저장된 개인 키에서 해당 공개 키를 가져옵니다. 키는 Type 매개 변수로 표시된 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="71f993bb41b3e63e6c35261ddb44f81039c80cdc" translate="yes" xml:space="preserve">
          <source>Fetches the private key of the host.</source>
          <target state="translated">호스트의 개인 키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3ec7885b0c1597d5985a3ed2b3fda853f40d8d02" translate="yes" xml:space="preserve">
          <source>Fetches the users &lt;strong&gt;public key&lt;/strong&gt; matching the &lt;code&gt;Algorithm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Algorithm&lt;/code&gt; 에 일치하는 사용자 &lt;strong&gt;공개 키를 가져&lt;/strong&gt; 옵니다 .</target>
        </trans-unit>
        <trans-unit id="2bee13557c7c74ba8204199e37e131aad2f40b8b" translate="yes" xml:space="preserve">
          <source>Fetches the users &lt;strong&gt;public key&lt;/strong&gt; matching the &lt;code&gt;Algorithm&lt;/code&gt;. Some key callback modules may return &lt;code&gt;{ssh2_pubkey, PubKeyBlob :: binary()}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Algorithm&lt;/code&gt; 과 일치하는 사용자 &lt;strong&gt;공개 키를 가져&lt;/strong&gt; 옵니다 . 일부 키 콜백 모듈은 &lt;code&gt;{ssh2_pubkey, PubKeyBlob :: binary()}&lt;/code&gt; 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">데이터를 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="449e1d2da9aba2320f6e3a26f2fdf363d8f9762d" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;error&lt;/code&gt; can provide more detailed diagnostics.</source>
          <target state="translated">필드 &lt;code&gt;error&lt;/code&gt; 는보다 자세한 진단을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e8b3cde508b4ee35c4f0034eb670b99d060969" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;error&lt;/code&gt; can provide more detailed diagnostics. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">필드 &lt;code&gt;error&lt;/code&gt; 는 더 자세한 진단을 제공 할 수 있습니다. &lt;code&gt;error&lt;/code&gt; 필드 값을 사용하여 문자열로 변환 할 수있다 &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7364b9ce001d6cae41e6800636cd884898fede" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;size&lt;/code&gt; indicates the number of hash positions in the registry. This is the number you provided when you created or last resized the registry, rounded up to the nearest prime number.</source>
          <target state="translated">필드 &lt;code&gt;size&lt;/code&gt; 는 레지스트리의 해시 위치 수를 나타냅니다. 이 값은 레지스트리를 만들거나 마지막으로 크기를 조정할 때 제공 한 번호이며 가장 가까운 소수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d416b63535334e26bc4110217a450aaea2d0fc" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;size&lt;/code&gt; indicates the size in bytes required to store &lt;code&gt;EI_STR&lt;/code&gt; (including the terminating &lt;code&gt;0&lt;/code&gt;) and &lt;code&gt;EI_BIN&lt;/code&gt; objects, or &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;EI_INT&lt;/code&gt; and &lt;code&gt;EI_FLT&lt;/code&gt;.</source>
          <target state="translated">필드 &lt;code&gt;size&lt;/code&gt; 는 &lt;code&gt;EI_STR&lt;/code&gt; (종료 &lt;code&gt;0&lt;/code&gt; 포함 ) 및 &lt;code&gt;EI_BIN&lt;/code&gt; 객체 를 저장하는 데 필요한 크기 (바이트 )를 나타내 거나 &lt;code&gt;EI_INT&lt;/code&gt; 및 &lt;code&gt;EI_FLT&lt;/code&gt; 의 경우 &lt;code&gt;0&lt;/code&gt; 을 나타 냅니다 .</target>
        </trans-unit>
        <trans-unit id="3f7eafa431967809286bd8430754ffa47af6ddc1" translate="yes" xml:space="preserve">
          <source>Fields have the following types.</source>
          <target state="translated">필드는 다음과 같은 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d50a523ff47e5164c174ec2a3f209fc4591ec58" translate="yes" xml:space="preserve">
          <source>Figure 1.1: SSH Protocol Architecture</source>
          <target state="translated">그림 1.1 : SSH 프로토콜 아키텍처</target>
        </trans-unit>
        <trans-unit id="523ebe3ba06aeb9422bef0fd87f129b29d7066ad" translate="yes" xml:space="preserve">
          <source>Figure 1.1: Supervision Tree</source>
          <target state="translated">그림 1.1 : 감독 트리</target>
        </trans-unit>
        <trans-unit id="08736394941c36612a1000fcd4f82e3aeb8c695e" translate="yes" xml:space="preserve">
          <source>Figure 1.1: Terminology</source>
          <target state="translated">그림 1.1 : 용어</target>
        </trans-unit>
        <trans-unit id="2d4c6dc6ef332b27b86506ca049d2ef56102c2d3" translate="yes" xml:space="preserve">
          <source>Figure 1.2: Request to An Agent by a Manager</source>
          <target state="translated">그림 1.2 : 관리자가 에이전트에게 요청</target>
        </trans-unit>
        <trans-unit id="3630531c7c6a3f163c1aca75bfd8f8e80594274e" translate="yes" xml:space="preserve">
          <source>Figure 1.3: Structure of a System Managed with SNMP and HTTP</source>
          <target state="translated">그림 1.3 : SNMP 및 HTTP로 관리되는 시스템 구조</target>
        </trans-unit>
        <trans-unit id="ed4eac121bb9b20da4bf8ba42d19de7f6390d69c" translate="yes" xml:space="preserve">
          <source>Figure 1.4: Notification Handling</source>
          <target state="translated">그림 1.4 : 알림 처리</target>
        </trans-unit>
        <trans-unit id="a67a6c3cabef7ffcc85375e5dc0fc78a6e7cb7f0" translate="yes" xml:space="preserve">
          <source>Figure 10.1: Contents of my_table</source>
          <target state="translated">그림 10.1 : my_table의 내용</target>
        </trans-unit>
        <trans-unit id="980abfa0310223c30c1ced7778712b520a30a0f6" translate="yes" xml:space="preserve">
          <source>Figure 10.2: GetNext from [3,1,1] and [5,1,1].</source>
          <target state="translated">그림 10.2 : [3,1,1] 및 [5,1,1]에서 GetNext.</target>
        </trans-unit>
        <trans-unit id="512a9cc41180ea486a59bbebfab51a7e41e4f6e2" translate="yes" xml:space="preserve">
          <source>Figure 10.3: GetNext from [3,2,1] and [5,2,1].</source>
          <target state="translated">그림 10.3 : [3,2,1] 및 [5,2,1]에서 GetNext.</target>
        </trans-unit>
        <trans-unit id="0411bfce14335e76e0ecf5fafb916644f43ab854" translate="yes" xml:space="preserve">
          <source>Figure 10.4: GetNext from [3,1,2] and [4,1,2].</source>
          <target state="translated">그림 10.4 : [3,1,2] 및 [4,1,2]에서 GetNext.</target>
        </trans-unit>
        <trans-unit id="579a44635c14e47e7f2a3756286ed8ed45b9a313" translate="yes" xml:space="preserve">
          <source>Figure 12.1: The Purpose of Agent Net if</source>
          <target state="translated">그림 12.1 : 에이전트 넷의 목적</target>
        </trans-unit>
        <trans-unit id="b94326c9eff5af4b2945c5a3eb031a94f0188479" translate="yes" xml:space="preserve">
          <source>Figure 13.1: Summary of EPMD Requests</source>
          <target state="translated">그림 13.1 : EPMD 요청 요약</target>
        </trans-unit>
        <trans-unit id="36ec74a7eb7d4a1f4a40c49ada2d898095de88cf" translate="yes" xml:space="preserve">
          <source>Figure 13.1: The Purpose of Manager Net if</source>
          <target state="translated">그림 13.1 : Manager Net의 목적</target>
        </trans-unit>
        <trans-unit id="9ce57b391c82ca75320f190c448dff803fc70661" translate="yes" xml:space="preserve">
          <source>Figure 2.1: Client-Server Model</source>
          <target state="translated">그림 2.1 : 클라이언트-서버 모델</target>
        </trans-unit>
        <trans-unit id="0d1b41c85b8033b42251180c502a802939a7d08a" translate="yes" xml:space="preserve">
          <source>Figure 2.1: Conceptual Overview</source>
          <target state="translated">그림 2.1 : 개념적 개요</target>
        </trans-unit>
        <trans-unit id="669cea85c5d62990166377535dee928d0e27d3d7" translate="yes" xml:space="preserve">
          <source>Figure 2.1: Line Break Dialog Window</source>
          <target state="translated">그림 2.1 : 줄 바꿈 대화 상자</target>
        </trans-unit>
        <trans-unit id="f417f4f3d31b3733b906fd7b58c4dcbd6df135cd" translate="yes" xml:space="preserve">
          <source>Figure 2.1: MIB Compiler Principles</source>
          <target state="translated">그림 2.1 : MIB 컴파일러 원리</target>
        </trans-unit>
        <trans-unit id="8d83478d2cd3dd666fc5c585b931a8754f9a2318" translate="yes" xml:space="preserve">
          <source>Figure 2.1: Network architecture</source>
          <target state="translated">그림 2.1 : 네트워크 아키텍처</target>
        </trans-unit>
        <trans-unit id="ae305086b11036b190156e8f09e02feb832b459a" translate="yes" xml:space="preserve">
          <source>Figure 2.1: Screenshot of the Viewer window</source>
          <target state="translated">그림 2.1 : 뷰어 창의 스크린 샷</target>
        </trans-unit>
        <trans-unit id="0c5a6ceb297cb01443a0034db62cf4d075ffd08e" translate="yes" xml:space="preserve">
          <source>Figure 2.2: Conditional Break Dialog Window</source>
          <target state="translated">그림 2.2 : 조건부 나누기 대화 상자 창</target>
        </trans-unit>
        <trans-unit id="7eb268a938b8f690123fc5d39f7e702ccf029c20" translate="yes" xml:space="preserve">
          <source>Figure 2.2: Screenshot of the Viewer window</source>
          <target state="translated">그림 2.2 : 뷰어 창의 스크린 샷</target>
        </trans-unit>
        <trans-unit id="d2c24c199c8ab29a2a03b69ae217d631fd6651dd" translate="yes" xml:space="preserve">
          <source>Figure 2.2: Single node config</source>
          <target state="translated">그림 2.2 : 단일 노드 구성</target>
        </trans-unit>
        <trans-unit id="0b173235b50e6384b5cce003bd84f3a2b97855d8" translate="yes" xml:space="preserve">
          <source>Figure 2.2: Starting the Agent</source>
          <target state="translated">그림 2.2 : 에이전트 시작</target>
        </trans-unit>
        <trans-unit id="8faeafcb187ac66ad8fd17afbce8dbda161a7153" translate="yes" xml:space="preserve">
          <source>Figure 2.3: Architecture</source>
          <target state="translated">그림 2.3 : 아키텍처</target>
        </trans-unit>
        <trans-unit id="d273337d81a465662ca9a0068d6a3f6992bcd738" translate="yes" xml:space="preserve">
          <source>Figure 2.3: Distributes node config</source>
          <target state="translated">그림 2.3 : 배포 노드 구성</target>
        </trans-unit>
        <trans-unit id="363ff7df7bb8d318e8a16500fe7c4123cb741da5" translate="yes" xml:space="preserve">
          <source>Figure 2.3: Function Break Dialog Window</source>
          <target state="translated">그림 2.3 : 기능 중단 대화 상자 창</target>
        </trans-unit>
        <trans-unit id="dc5ba5cb631645fa4e837e669695ff3eb990d27f" translate="yes" xml:space="preserve">
          <source>Figure 2.4: Message Call Flow (originating side)</source>
          <target state="translated">그림 2.4 : 메시지 호출 흐름 (발신 측)</target>
        </trans-unit>
        <trans-unit id="906737bfaf120953431ac24adf65c27ce903f54f" translate="yes" xml:space="preserve">
          <source>Figure 2.4: Monitor Window</source>
          <target state="translated">그림 2.4 : 모니터 창</target>
        </trans-unit>
        <trans-unit id="953f4c0da75c385e874c96ac2334fd68246d1ccd" translate="yes" xml:space="preserve">
          <source>Figure 2.4: Overview of the mechanism of MIB selection</source>
          <target state="translated">그림 2.4 : MIB 선택 메커니즘 개요</target>
        </trans-unit>
        <trans-unit id="a0412955a59693d89b170f303bb1981baf54cc90" translate="yes" xml:space="preserve">
          <source>Figure 2.5: Interpret Modules Window</source>
          <target state="translated">그림 2.5 : 모듈 해석 창</target>
        </trans-unit>
        <trans-unit id="28810c9785e99154bc4d93f80d2be3fa5f25f7c8" translate="yes" xml:space="preserve">
          <source>Figure 2.5: Message Call Flow (destination side)</source>
          <target state="translated">그림 2.5 : 메시지 통화 흐름 (대상 쪽)</target>
        </trans-unit>
        <trans-unit id="a4b78f67a7dbb24830fbf32cddc6f7ded985c806" translate="yes" xml:space="preserve">
          <source>Figure 2.6: Attach Process Window</source>
          <target state="translated">그림 2.6 : 프로세스 연결 창</target>
        </trans-unit>
        <trans-unit id="745b1afb72f1ea5fc815b54f2e30aace16684501" translate="yes" xml:space="preserve">
          <source>Figure 2.7: View Module Window</source>
          <target state="translated">그림 2.7 : 모듈보기 창</target>
        </trans-unit>
        <trans-unit id="548f4535c787c39e21d3d02180ef27aa893adfb2" translate="yes" xml:space="preserve">
          <source>Figure 3.1: A simulated Mnesia transaction which writes one record</source>
          <target state="translated">그림 3.1 : 하나의 레코드를 작성하는 시뮬레이션 된 Mnesia 트랜잭션</target>
        </trans-unit>
        <trans-unit id="0866306a0a1ffee34edac9dff51bdbb10d690768" translate="yes" xml:space="preserve">
          <source>Figure 3.1: Code Lock State Diagram</source>
          <target state="translated">그림 3.1 : 코드 잠금 상태 다이어그램</target>
        </trans-unit>
        <trans-unit id="3e92e5fb1831eafebe86563997e776ce07daa348" translate="yes" xml:space="preserve">
          <source>Figure 3.1: Company Entity-Relation Diagram</source>
          <target state="translated">도표 3.1 : 회사 실체 관계 도표</target>
        </trans-unit>
        <trans-unit id="8854c1706d80ff4ef783be1b4a55bc7776485816" translate="yes" xml:space="preserve">
          <source>Figure 3.1: Conceptual Overview</source>
          <target state="translated">그림 3.1 : 개념적 개요</target>
        </trans-unit>
        <trans-unit id="2bc69c26cff87ef3783a9c45b49d2327ce43316f" translate="yes" xml:space="preserve">
          <source>Figure 3.1: Filter: &quot;processes&quot;</source>
          <target state="translated">그림 3.1 : 필터 : &quot;프로세스&quot;</target>
        </trans-unit>
        <trans-unit id="960bdd3e7b477330a8b1803fc80d453ade00fa08" translate="yes" xml:space="preserve">
          <source>Figure 3.1: MGC Startup Call Flow</source>
          <target state="translated">그림 3.1 : MGC 시작 통화 흐름</target>
        </trans-unit>
        <trans-unit id="d10e9ca96c305483ac19414a1867fc81b9b3941f" translate="yes" xml:space="preserve">
          <source>Figure 3.1: Successful and Unsuccessful Test Case Execution</source>
          <target state="translated">그림 3.1 : 성공 및 실패한 테스트 사례 실행</target>
        </trans-unit>
        <trans-unit id="2b3b14fe8aa765756ed2b973d3f64144d85612b6" translate="yes" xml:space="preserve">
          <source>Figure 3.2: Code Lock State Diagram Revisited</source>
          <target state="translated">그림 3.2 : 코드 잠금 상태 다이어그램 재검토</target>
        </trans-unit>
        <trans-unit id="7ba7300463bae99f2d77f099fafc4e42263be881" translate="yes" xml:space="preserve">
          <source>Figure 3.2: Configuration Data Flow in a Suite</source>
          <target state="translated">그림 3.2 : Suite의 구성 데이터 흐름</target>
        </trans-unit>
        <trans-unit id="1ec756a8c48e16f26383c4056a784980e168e445" translate="yes" xml:space="preserve">
          <source>Figure 3.2: Filter: &quot;mods_and_procs&quot;</source>
          <target state="translated">그림 3.2 : 필터 : &quot;mods_and_procs&quot;</target>
        </trans-unit>
        <trans-unit id="65d6bb0b3c63004d5424b8954c3f7c199d2b068c" translate="yes" xml:space="preserve">
          <source>Figure 3.2: MG Startup Call Flow</source>
          <target state="translated">그림 3.2 : MG 시작 호출 흐름</target>
        </trans-unit>
        <trans-unit id="6337c3a560f6384e9983e40d19f39ed28a87003e" translate="yes" xml:space="preserve">
          <source>Figure 3.2: Two actors has switched places</source>
          <target state="translated">그림 3.2 : 두 명의 배우가 장소를 바꿨습니다</target>
        </trans-unit>
        <trans-unit id="3af5ef148cf98c60847b7547b3d06bc677720f38" translate="yes" xml:space="preserve">
          <source>Figure 3.3: Details of a write lock message</source>
          <target state="translated">그림 3.3 : 쓰기 잠금 메시지의 세부 사항</target>
        </trans-unit>
        <trans-unit id="ca141f5df9fa34dc67ffeb53997feff7bd9ad4dc" translate="yes" xml:space="preserve">
          <source>Figure 3.3: HTML Log File Structure</source>
          <target state="translated">그림 3.3 : HTML 로그 파일 구조</target>
        </trans-unit>
        <trans-unit id="00c89ea0e57363355095334bdfb766f9ed2882ae" translate="yes" xml:space="preserve">
          <source>Figure 3.3: MG Startup Call Flow (no MID)</source>
          <target state="translated">그림 3.3 : MG 시작 호출 흐름 (MID 없음)</target>
        </trans-unit>
        <trans-unit id="06019fd83329891fca487e724e3043acd4e2a0de" translate="yes" xml:space="preserve">
          <source>Figure 3.4: The same trace data in a different view</source>
          <target state="translated">그림 3.4 : 다른보기에서 동일한 추적 데이터</target>
        </trans-unit>
        <trans-unit id="aaf78b767875fb6158ecb6bf800e662d5d29bbb4" translate="yes" xml:space="preserve">
          <source>Figure 3.5: The trace Event in the mgr_actors view</source>
          <target state="translated">그림 3.5 : mgr_actors보기의 추적 이벤트</target>
        </trans-unit>
        <trans-unit id="c412c1557d8b09a77341e6c2ae93864dd5a78025" translate="yes" xml:space="preserve">
          <source>Figure 3.6: The same trace Event in the collectors view</source>
          <target state="translated">그림 3.6 : 수집기보기에서 동일한 추적 이벤트</target>
        </trans-unit>
        <trans-unit id="8e2129c26241e3fb24b61e7e049c36f78d6e0fe5" translate="yes" xml:space="preserve">
          <source>Figure 4.1: Architecture of the Erlang odbc application</source>
          <target state="translated">그림 4.1 : Erlang odbc 애플리케이션의 아키텍처</target>
        </trans-unit>
        <trans-unit id="5ba43129efdb5812855b9839248bb336b07adb7b" translate="yes" xml:space="preserve">
          <source>Figure 4.1: Bytes of a Window:status Message</source>
          <target state="translated">그림 4.1 : 창 : 상태 메시지의 바이트</target>
        </trans-unit>
        <trans-unit id="ca912d988f6b2bbcf1df9c0c3693d448e7b3a4d3" translate="yes" xml:space="preserve">
          <source>Figure 4.1: Port Communication</source>
          <target state="translated">그림 4.1 : 포트 통신</target>
        </trans-unit>
        <trans-unit id="d43ee41e313c4bc9fe0e7d3700620c89d3ddf25c" translate="yes" xml:space="preserve">
          <source>Figure 4.2: Elements Specified in Configuration File for Selective Decode of a Subvalue in a Window Message</source>
          <target state="translated">그림 4.2 : 창 메시지에서 하위 값의 선택적 디코딩을 위해 구성 파일에 지정된 요소</target>
        </trans-unit>
        <trans-unit id="5ddb6f53e7f89ff124a54080a1d81c750c542c40" translate="yes" xml:space="preserve">
          <source>Figure 4.3: Bytes of a Window:status Message</source>
          <target state="translated">그림 4.3 : 창의 바이트 : 상태 메시지</target>
        </trans-unit>
        <trans-unit id="45d5a2eb9a7dc1564369b400d59e8aea1282d9b5" translate="yes" xml:space="preserve">
          <source>Figure 5.1: One_For_One Supervision</source>
          <target state="translated">그림 5.1 : One_For_One 감독</target>
        </trans-unit>
        <trans-unit id="0eab58150b6fb22b3684514047a2c7f297a925bc" translate="yes" xml:space="preserve">
          <source>Figure 5.2: One_For_All Supervision</source>
          <target state="translated">그림 5.2 : One_For_All 감독</target>
        </trans-unit>
        <trans-unit id="061b435065555f8d08be64f6094952e58a988271" translate="yes" xml:space="preserve">
          <source>Figure 6.1: Definition and use of functions</source>
          <target state="translated">그림 6.1 : 함수 정의 및 사용</target>
        </trans-unit>
        <trans-unit id="7ed58d435eddda1ece08ea1ce24d9f44c8903453" translate="yes" xml:space="preserve">
          <source>Figure 6.1: Port Driver Communication</source>
          <target state="translated">그림 6.1 : 포트 드라이버 통신</target>
        </trans-unit>
        <trans-unit id="d0c8bf359ff8dda24997383e4d7c49437afc3ffe" translate="yes" xml:space="preserve">
          <source>Figure 6.2: Some predefined analyses as subsets of all functions</source>
          <target state="translated">그림 6.2 : 모든 기능의 하위 집합으로 일부 사전 정의 된 분석</target>
        </trans-unit>
        <trans-unit id="1c552d2cf0674f4d578f0d21a1bff5085a533498" translate="yes" xml:space="preserve">
          <source>Figure 8.1:</source>
          <target state="translated">그림 8.1 :</target>
        </trans-unit>
        <trans-unit id="563353b9112d150d7eed671af92a8fff98b60b1f" translate="yes" xml:space="preserve">
          <source>Figure 8.1: MStone1 with mstone1.sh -d flex -s 4</source>
          <target state="translated">그림 8.1 : mstone1.sh가있는 MStone1 -d flex -s 4</target>
        </trans-unit>
        <trans-unit id="8f5be86a06cd9d5a9c049e72c48c6e8424314b44" translate="yes" xml:space="preserve">
          <source>Figure 8.1: Primary Application and Included Applications</source>
          <target state="translated">그림 8.1 : 기본 응용 프로그램 및 포함 된 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="d98b6922c42c6490c1ab05ae19baa9d95d993882" translate="yes" xml:space="preserve">
          <source>Figure 8.2:</source>
          <target state="translated">그림 8.2 :</target>
        </trans-unit>
        <trans-unit id="d0b4b6f72691a955e8d71cc31687b018cc32e13a" translate="yes" xml:space="preserve">
          <source>Figure 8.3:</source>
          <target state="translated">그림 8.3 :</target>
        </trans-unit>
        <trans-unit id="332c12fa550f868eab78a9a37cc8a77525e921d6" translate="yes" xml:space="preserve">
          <source>Figure 8.4:</source>
          <target state="translated">그림 8.4 :</target>
        </trans-unit>
        <trans-unit id="9b2b29f77753c5e02976d1fc1fbd937724cf2668" translate="yes" xml:space="preserve">
          <source>Figure 8.5:</source>
          <target state="translated">그림 8.5 :</target>
        </trans-unit>
        <trans-unit id="c4cd60391cb2e06580fe30e512d3a1e65fff9ad7" translate="yes" xml:space="preserve">
          <source>Figure 8.6:</source>
          <target state="translated">그림 8.6 :</target>
        </trans-unit>
        <trans-unit id="9e5656466c9977074d04d4ad636c38acfe8afe19" translate="yes" xml:space="preserve">
          <source>Figure 9.1: Application myapp - Situation 1</source>
          <target state="translated">그림 9.1 : 애플리케이션 myapp-상황 1</target>
        </trans-unit>
        <trans-unit id="0eb88cbf840596e7d918fe7a2d8caa94efa65c27" translate="yes" xml:space="preserve">
          <source>Figure 9.2: Application myapp - Situation 2</source>
          <target state="translated">그림 9.2 : 응용 프로그램 myapp-상황 2</target>
        </trans-unit>
        <trans-unit id="18c041bf7044aeec8628e40c4d277ffbfa8f3111" translate="yes" xml:space="preserve">
          <source>Figure 9.3: Application myapp - Situation 3</source>
          <target state="translated">그림 9.3 : 애플리케이션 myapp-상황 3</target>
        </trans-unit>
        <trans-unit id="31013550bee8c7853eb99345677de31ebf15cff1" translate="yes" xml:space="preserve">
          <source>Figure 9.4: Application myapp - Situation 4</source>
          <target state="translated">그림 9.4 : 애플리케이션 myapp-상황 4</target>
        </trans-unit>
        <trans-unit id="4221e66948c648a9488a1b65f47df132883a094f" translate="yes" xml:space="preserve">
          <source>Figure 9.5: Application myapp - Situation 5</source>
          <target state="translated">그림 9.5 : 애플리케이션 myapp-상황 5</target>
        </trans-unit>
        <trans-unit id="05d67c57a226cefdab351a860e975d8eb32bcc71" translate="yes" xml:space="preserve">
          <source>Figure space</source>
          <target state="translated">그림 공간</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="4b5505a448c25f5ece7091295fa2ae8c43b423f3" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.config&lt;/code&gt; contains a single Erlang term and has the following syntax:</source>
          <target state="translated">&lt;code&gt;.config&lt;/code&gt; 파일 에는 단일 Erlang 용어가 포함되어 있으며 다음 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fbfaa5abd4b9f7bc58a38040cc38f9b29843d6e" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.erlang.crypt&lt;/code&gt; is to contain a single list of tuples:</source>
          <target state="translated">&lt;code&gt;.erlang.crypt&lt;/code&gt; 파일 은 단일 튜플 목록을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f70b471b5012c54dc6384c852318714311fea9b2" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.hosts.erlang&lt;/code&gt; consists of a number of host names written as Erlang terms. It is looked for in the current work directory, the user's home directory, and &lt;code&gt;$OTP_ROOT&lt;/code&gt; (the root directory of Erlang/OTP), in that order.</source>
          <target state="translated">&lt;code&gt;.hosts.erlang&lt;/code&gt; 파일 은 Erlang 용어로 작성된 여러 호스트 이름으로 구성됩니다. 현재 작업 디렉토리, 사용자의 홈 디렉토리 및 &lt;code&gt;$OTP_ROOT&lt;/code&gt; (Erlang / OTP의 루트 디렉토리)에서 순서대로 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="671c961c2f0f366457ec49f8374f6de4a088da86" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.ti&lt;/code&gt; contains &lt;code&gt;{Key,ValueList}&lt;/code&gt; tuples. This function adds &lt;code&gt;Data&lt;/code&gt; to the &lt;code&gt;ValueList&lt;/code&gt; associated with &lt;code&gt;Key&lt;/code&gt;. All information written with this function is included in the call to the format handler.</source>
          <target state="translated">&lt;code&gt;.ti&lt;/code&gt; 파일 은 &lt;code&gt;{Key,ValueList}&lt;/code&gt; 튜플을 포함합니다. 이 함수는 &lt;code&gt;Key&lt;/code&gt; 와 연관된 &lt;code&gt;ValueList&lt;/code&gt; 에 &lt;code&gt;Data&lt;/code&gt; 를 추가합니다 . 이 함수로 작성된 모든 정보는 형식 핸들러 호출에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="64dec856e0ada55502697235a5b298eba7337843" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;/export/home/otpuser/otp/bin/start&lt;/code&gt; referred to in the above script is precisely the &lt;code&gt;start&lt;/code&gt; script described in &lt;strong&gt;Starting Erlang&lt;/strong&gt;. The script variable &lt;code&gt;OTP_ROOT&lt;/code&gt; in that &lt;code&gt;start&lt;/code&gt; script corresponds to the following example path used in this section:</source>
          <target state="translated">위 스크립트에서 언급 된 &lt;code&gt;/export/home/otpuser/otp/bin/start&lt;/code&gt; 파일 은 &lt;strong&gt;Erlang 시작&lt;/strong&gt; 에서 설명한 &lt;code&gt;start&lt;/code&gt; 스크립트 입니다. 해당 &lt;code&gt;start&lt;/code&gt; 스크립트 의 스크립트 변수 &lt;code&gt;OTP_ROOT&lt;/code&gt; 는이 섹션에서 사용 된 다음 예제 경로에 해당합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5681b35a9fab557fa7d01957b08b83fefec93b5" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;messenger.erl&lt;/code&gt;:</source>
          <target state="translated">파일 &lt;code&gt;messenger.erl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="68c0e0a465215b1a5424fcd23f7ea0de4e17f5ee" translate="yes" xml:space="preserve">
          <source>File Menu</source>
          <target state="translated">파일 메뉴</target>
        </trans-unit>
        <trans-unit id="b144c5da627d4fcd0433d9d07032c24b1a35e8b4" translate="yes" xml:space="preserve">
          <source>File Summary</source>
          <target state="translated">파일 요약</target>
        </trans-unit>
        <trans-unit id="e998362a328008ec68870225e6e393a8e7ada587" translate="yes" xml:space="preserve">
          <source>File Syntax</source>
          <target state="translated">파일 구문</target>
        </trans-unit>
        <trans-unit id="e3744ce3ff6628582b9e9f0ed24e796bf95c10cd" translate="yes" xml:space="preserve">
          <source>File and Edit Menus</source>
          <target state="translated">파일 및 편집 메뉴</target>
        </trans-unit>
        <trans-unit id="8989bc8592b54990f118873a1ed5d421392254fb" translate="yes" xml:space="preserve">
          <source>File containing an Erlang property list, followed by a full stop, describing the HTTP server configuration.</source>
          <target state="translated">Erlang 등록 정보 목록과 HTTP 서버 구성을 설명하는 전체 중지가 포함 된 파일입니다.</target>
        </trans-unit>
        <trans-unit id="b7a8f560c389b01b425c7f1430303ef4d3b380b6" translate="yes" xml:space="preserve">
          <source>File descriptor of the destination file &lt;code&gt;Out&lt;/code&gt;.  The trace message. For details, see the Reference Manual for module &lt;code&gt;erlang&lt;/code&gt;.  Includes the keys &lt;code&gt;flags&lt;/code&gt;, &lt;code&gt;client&lt;/code&gt;, and &lt;code&gt;node&lt;/code&gt;. If &lt;code&gt;handler&lt;/code&gt; is specified as option to the tracer function, this is also included. Also, all information written with function &lt;code&gt;write_trace_info/2&lt;/code&gt; is included.</source>
          <target state="translated">대상 파일의 파일 기술자 &lt;code&gt;Out&lt;/code&gt; . 추적 메시지 자세한 내용은 &lt;code&gt;erlang&lt;/code&gt; 모듈의 참조 매뉴얼을 참조하십시오 . 키 &lt;code&gt;flags&lt;/code&gt; , &lt;code&gt;client&lt;/code&gt; 및 &lt;code&gt;node&lt;/code&gt; . &lt;code&gt;handler&lt;/code&gt; 가 추적 프로그램 기능에 대한 옵션으로 지정된 경우 에도 포함됩니다. 또한 &lt;code&gt;write_trace_info/2&lt;/code&gt; 함수로 작성된 모든 정보 가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="361a82465491c9161713f597566a3f42e5734e1b" translate="yes" xml:space="preserve">
          <source>File format</source>
          <target state="translated">파일 형식</target>
        </trans-unit>
        <trans-unit id="83cd93580a4207dd0937a4457cdba2eaca5af484" translate="yes" xml:space="preserve">
          <source>File handling is not done by the Public Key application.</source>
          <target state="translated">공개 키 응용 프로그램에서 파일 처리를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28d4332b9248121ca825fe26ca7303649b79848d" translate="yes" xml:space="preserve">
          <source>File information as in &lt;code&gt; file:read_file_info/1&lt;/code&gt; in Kernel</source>
          <target state="translated">커널의 &lt;code&gt; file:read_file_info/1&lt;/code&gt; 에 있는 파일 정보</target>
        </trans-unit>
        <trans-unit id="87e03c8b46f66df04e7376658ec09a622178e8d3" translate="yes" xml:space="preserve">
          <source>File information as in &lt;code&gt;file:read_file_info/1&lt;/code&gt; in Kernel</source>
          <target state="translated">커널의 &lt;code&gt;file:read_file_info/1&lt;/code&gt; 파일에있는 파일 정보</target>
        </trans-unit>
        <trans-unit id="05cc20c44397b03ee1d2a31a9c9eee04f05fc75d" translate="yes" xml:space="preserve">
          <source>File interface module.</source>
          <target state="translated">파일 인터페이스 모듈.</target>
        </trans-unit>
        <trans-unit id="f887ba04f84f87da0ccb5533f54bb7e2d3cb48f8" translate="yes" xml:space="preserve">
          <source>File menu</source>
          <target state="translated">파일 메뉴</target>
        </trans-unit>
        <trans-unit id="8c26de449d0b6a2f6a2d0456de0b11d4c0058119" translate="yes" xml:space="preserve">
          <source>File menu:</source>
          <target state="translated">파일 메뉴 :</target>
        </trans-unit>
        <trans-unit id="ad6fd2b790ed7bb6620e7477fe2d403cdb8cb745" translate="yes" xml:space="preserve">
          <source>File operations are only guaranteed to appear atomic when going through the same file server. A NIF or other OS process may observe intermediate steps on certain operations on some operating systems, eg. renaming an existing file on Windows, or &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2 &lt;/a&gt;&lt;/code&gt; on any OS at the time of writing.</source>
          <target state="translated">파일 작업은 동일한 파일 서버를 통과 할 때만 원자 적으로 표시됩니다. NIF 또는 기타 OS 프로세스는 일부 운영 체제에서 특정 작업에 대한 중간 단계를 관찰 할 수 있습니다. Windows에서 기존 파일의 이름을 변경하거나 작성 시점에 모든 OS에서 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2 &lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57c5b354434bbbfc8df2a3dc53a60f082317d0b3" translate="yes" xml:space="preserve">
          <source>File operations are only guaranteed to appear atomic when going through the same file server. A NIF or other OS process may observe intermediate steps on certain operations on some operating systems, eg. renaming an existing file on Windows, or &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; on any OS at the time of writing.</source>
          <target state="translated">파일 작업은 동일한 파일 서버를 통과 할 때만 원자로 표시됩니다. NIF 또는 다른 OS 프로세스는 일부 운영 체제의 특정 작업에서 중간 단계를 관찰 할 수 있습니다 (예 : Windows에서 기존 파일의 이름을 바꾸거나 작성 당시의 모든 OS에서 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c79c159347736532bbcb134d7fd8cb0146b16b16" translate="yes" xml:space="preserve">
          <source>File operations used to accept filenames containing null characters (integer value zero). This caused the name to be truncated and in some cases arguments to primitive operations to be mixed up. Filenames containing null characters inside the filename are now &lt;strong&gt;rejected&lt;/strong&gt; and will cause primitive file operations fail.</source>
          <target state="translated">널 문자를 포함하는 파일 이름을 허용하는 데 사용되는 파일 조작 (정수 값 0). 이로 인해 이름이 잘리고 일부 경우 원시 작업에 대한 인수가 혼합되었습니다. 파일 이름 안에 널 문자를 포함하는 파일 이름은 이제 &lt;strong&gt;거부&lt;/strong&gt; 되며 기본 파일 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6b57f688f0dcf623bc2238b6861c04782ba5e78f" translate="yes" xml:space="preserve">
          <source>File operations used to accept filenames containing null characters (integer value zero). This caused the name to be truncated and in some cases arguments to primitive operations to be mixed up. Filenames containing null characters inside the filename are now &lt;strong&gt;rejected&lt;/strong&gt; and will cause primitive file operations to fail.</source>
          <target state="translated">널 문자를 포함하는 파일 이름을 허용하는 데 사용되는 파일 조작 (정수 값 0). 이로 인해 이름이 잘리고 일부 경우 원시 작업에 대한 인수가 혼합되었습니다. 파일 이름 안에 널 문자가 포함 된 파일 이름은 이제 &lt;strong&gt;거부&lt;/strong&gt; 되며 기본 파일 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="993985df3c150bf6146adb117f97880af959d00d" translate="yes" xml:space="preserve">
          <source>File sorter.</source>
          <target state="translated">파일 분류기.</target>
        </trans-unit>
        <trans-unit id="adb79fe86d1eee4f2cd161b61c30ffbd182e4dfd" translate="yes" xml:space="preserve">
          <source>File utilities, such as wildcard matching of filenames.</source>
          <target state="translated">파일 이름의 와일드 카드 일치와 같은 파일 유틸리티</target>
        </trans-unit>
        <trans-unit id="913e1c80a3ded5de35659b0874ffd6d0af9d084a" translate="yes" xml:space="preserve">
          <source>FileList :: filelist(),</source>
          <target state="translated">FileList :: filelist(),</target>
        </trans-unit>
        <trans-unit id="bc9ba3417eea6c2f81da0d2cb32153ea5b8631f5" translate="yes" xml:space="preserve">
          <source>Filename manipulation functions.</source>
          <target state="translated">파일명 조작 기능.</target>
        </trans-unit>
        <trans-unit id="aae37a65105c226310696cdc6572d20c19695d83" translate="yes" xml:space="preserve">
          <source>Filename not allowed [553].</source>
          <target state="translated">파일 이름이 허용되지 않습니다 [553].</target>
        </trans-unit>
        <trans-unit id="48a6e17cb7d6e4079d3b880980b3a5c34618857d" translate="yes" xml:space="preserve">
          <source>Filenames can be stored as Unicode strings in different ways depending on the underlying operating system and file system. This can be handled fairly easy by a program. The problems arise when the file system is inconsistent in its encodings. For example, Linux allows files to be named with any sequence of bytes, leaving to each program to interpret those bytes. On systems where these &quot;transparent&quot; filenames are used, Erlang must be informed about the filename encoding by a startup flag. The default is bytewise interpretation, which is usually wrong, but allows for interpretation of &lt;strong&gt;all&lt;/strong&gt; filenames.</source>
          <target state="translated">파일 이름은 기본 운영 체제 및 파일 시스템에 따라 다른 방식으로 유니 코드 문자열로 저장 될 수 있습니다. 이것은 프로그램에 의해 상당히 쉽게 처리 될 수 있습니다. 파일 시스템의 인코딩이 일치하지 않으면 문제가 발생합니다. 예를 들어, Linux에서는 파일을 임의의 바이트 순서로 이름을 지정할 수 있으므로 각 프로그램에서 해당 바이트를 해석합니다. 이러한 &quot;투명한&quot;파일 이름을 사용하는 시스템에서 Erlang은 시작 플래그로 파일 이름 인코딩에 대해 알려야합니다. 기본값은 바이트 단위 해석이며 일반적으로 잘못되지만 &lt;strong&gt;모든&lt;/strong&gt; 파일 이름 을 해석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="135d7b6689481e38f2c8e45e1871d2d236ada090" translate="yes" xml:space="preserve">
          <source>Files are compressed using the DEFLATE compression, as described in the &quot;Appnote.txt&quot; file. However, files are stored without compression if they are already compressed. &lt;code&gt;zip/2&lt;/code&gt; and &lt;code&gt;zip/3&lt;/code&gt; check the file extension to determine if the file is to be stored without compression. Files with the following extensions are not compressed: &lt;code&gt;.Z&lt;/code&gt;, &lt;code&gt;.zip&lt;/code&gt;, &lt;code&gt;.zoo&lt;/code&gt;, &lt;code&gt;.arc&lt;/code&gt;, &lt;code&gt;.lzh&lt;/code&gt;, &lt;code&gt;.arj&lt;/code&gt;.</source>
          <target state="translated">&quot;Appnote.txt&quot;파일에 설명 된대로 파일은 DEFLATE 압축을 사용하여 압축됩니다. 그러나 파일이 이미 압축 된 경우 압축없이 저장됩니다. &lt;code&gt;zip/2&lt;/code&gt; 및 &lt;code&gt;zip/3&lt;/code&gt; 는 파일 확장자를 확인하여 파일을 압축하지 않고 저장할 것인지 판별합니다. 다음과 같은 확장자를 가진 파일은 압축되지 않습니다 &lt;code&gt;.Z&lt;/code&gt; , &lt;code&gt;.zip&lt;/code&gt; , &lt;code&gt;.zoo&lt;/code&gt; , &lt;code&gt;.arc&lt;/code&gt; , &lt;code&gt;.lzh&lt;/code&gt; , &lt;code&gt;.arj&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="38c42597688edba01d1328297dbd55ee1f6c3035" translate="yes" xml:space="preserve">
          <source>Files can also be set in &lt;code&gt;{encoding, unicode}&lt;/code&gt;, meaning that data is written and read as UTF-8. More encodings are possible for files, see below.</source>
          <target state="translated">&lt;code&gt;{encoding, unicode}&lt;/code&gt; 파일을 설정할 수도 있습니다 . 즉, 데이터를 UTF-8로 쓰고 읽습니다. 파일에 대해 더 많은 인코딩이 가능합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c74c8c982534d73919da670ead9a749d9281c28e" translate="yes" xml:space="preserve">
          <source>Files with relative filenames are by default extracted to the current working directory. With this option, files are instead extracted into directory &lt;code&gt;Cwd&lt;/code&gt;.</source>
          <target state="translated">상대 파일 이름을 가진 파일은 기본적으로 현재 작업 디렉토리로 추출됩니다. 이 옵션을 사용하면 파일이 &lt;code&gt;Cwd&lt;/code&gt; 디렉토리로 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="d63f0c4854bf4f400b21ae332a18809d623ede15" translate="yes" xml:space="preserve">
          <source>Files with these extensions are uncompressed.</source>
          <target state="translated">이러한 확장자를 가진 파일은 압축되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddc79442f61fb42b601dbf8816a8b5ac8d030751" translate="yes" xml:space="preserve">
          <source>Files, directories and who uses them</source>
          <target state="translated">파일, 디렉토리 및 사용자</target>
        </trans-unit>
        <trans-unit id="8aa27f440cdc0f6cb30d87d689988febf5799c9b" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;iovec&lt;/code&gt; with the list of binaries provided in &lt;code&gt;iovec_term&lt;/code&gt;. The number of elements handled in the call is limited to &lt;code&gt;max_elements&lt;/code&gt;, and &lt;code&gt;tail&lt;/code&gt; is set to the remainder of the list. Note that the output may be longer than &lt;code&gt;max_elements&lt;/code&gt; on some platforms.</source>
          <target state="translated">채우기는 &lt;code&gt;iovec&lt;/code&gt; 에서 제공하는 바이너리의 목록 &lt;code&gt;iovec_term&lt;/code&gt; . 호출에서 처리되는 요소의 수는 &lt;code&gt;max_elements&lt;/code&gt; 로 제한 되고 &lt;code&gt;tail&lt;/code&gt; 은 나머지 목록으로 설정됩니다. 일부 플랫폼 에서는 출력이 &lt;code&gt;max_elements&lt;/code&gt; 보다 길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60ce0dded971cf682c1ea9544000a55687711cb3" translate="yes" xml:space="preserve">
          <source>Fills an already created ETS table with the objects in the already opened Dets table &lt;code&gt;DetsTab&lt;/code&gt;. Existing objects in the ETS table are kept unless overwritten.</source>
          <target state="translated">이미 작성된 ETS 테이블을 이미 열린 Dets 테이블 &lt;code&gt;DetsTab&lt;/code&gt; 의 오브젝트로 채 웁니다 . ETS 테이블의 기존 객체는 덮어 쓰지 않는 한 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="fa5e1215c7a4c5db71364b061c4f3e89bb0f74f1" translate="yes" xml:space="preserve">
          <source>Fills an already created/opened Dets table with the objects in the already opened ETS table named &lt;code&gt;Tab&lt;/code&gt;. The Dets table is emptied before the objects are inserted.</source>
          <target state="translated">이미 작성된 / 열린 Dets 테이블을 이미 열린 ETS 테이블의 이름이 &lt;code&gt;Tab&lt;/code&gt; 인 오브젝트로 채 웁니다 . 개체가 삽입되기 전에 Dets 테이블이 비워집니다.</target>
        </trans-unit>
        <trans-unit id="8666be4e9955d4a11e029f2505d6a37b78a3b2a1" translate="yes" xml:space="preserve">
          <source>Filter and possible alter HTTP request headers before they are processed by the server.</source>
          <target state="translated">서버에서 처리하기 전에 HTTP 요청 헤더를 필터링하고 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58cb64daddd0c075a64b518a845b550b54c29c81" translate="yes" xml:space="preserve">
          <source>Filter and possible alter HTTP response headers before they are sent to the client.</source>
          <target state="translated">클라이언트로 전송되기 전에 HTTP 응답 헤더를 필터링하고 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be109752b8b954940984339ff3493358b4481be" translate="yes" xml:space="preserve">
          <source>Filter functions can be used for more sophisticated filtering than the log level check provides. A filter function can stop or pass a log event, based on any of the event's contents. It can also modify all parts of the log event. See section &lt;code&gt;&lt;a href=&quot;#filters&quot;&gt;Filters&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">필터 기능은 로그 수준 검사가 제공하는 것보다 더 정교한 필터링에 사용할 수 있습니다. 필터 기능은 이벤트의 내용에 따라 로그 이벤트를 중지하거나 전달할 수 있습니다. 또한 로그 이벤트의 모든 부분을 수정할 수도 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#filters&quot;&gt;Filters&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="98e4ca69ac45a4e4ac3cd0268bb15c3cfa785895" translate="yes" xml:space="preserve">
          <source>Filter functions can be used for more sophisticated filtering than the log level check provides. A filter function can stop or pass a log event, based on any of the event's contents. It can also modify all parts of the log event. See see section &lt;code&gt;&lt;a href=&quot;#filters&quot;&gt;Filters&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">로그 수준 검사가 제공하는 것보다 더 정교한 필터링에 필터 기능을 사용할 수 있습니다. 필터 기능은 이벤트 내용을 기반으로 로그 이벤트를 중지하거나 전달할 수 있습니다. 로그 이벤트의 모든 부분을 수정할 수도 있습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#filters&quot;&gt;Filters&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="419f51ded5053ff5ebf4bedf68cbb8ad02590368" translate="yes" xml:space="preserve">
          <source>Filter passed to &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; in order to select candidate peers for a &lt;code&gt;pick_peer/4&lt;/code&gt; callback. Has one of the following types.</source>
          <target state="translated">&lt;code&gt;pick_peer/4&lt;/code&gt; 콜백에 대한 후보 피어를 선택하기 위해 필터가 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; 로 전달되었습니다 . 다음 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="87793d9b082d15c5c3f7207e0d19ef8ea24d6d04" translate="yes" xml:space="preserve">
          <source>Filter to apply to the list of available peers before passing it to the &lt;code&gt;pick_peer/4&lt;/code&gt; callback for the application in question. Multiple options are equivalent a single &lt;code&gt;all&lt;/code&gt; filter on the corresponding list of filters. Defaults to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">해당 애플리케이션 의 &lt;code&gt;pick_peer/4&lt;/code&gt; 콜백에 전달하기 전에 사용 가능한 피어 목록에 적용하도록 필터링하십시오 . 여러 옵션은 해당 필터 목록의 &lt;code&gt;all&lt;/code&gt; 단일 필터 와 같습니다 . 기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1c0fb8ec0bb02ac44b8c6fb4b0b445d690670782" translate="yes" xml:space="preserve">
          <source>Filter type &lt;code&gt;xpath&lt;/code&gt; can be used only if the server supports &lt;code&gt;:xpath&lt;/code&gt;.</source>
          <target state="translated">필터 유형 &lt;code&gt;xpath&lt;/code&gt; 는 서버가 &lt;code&gt;:xpath&lt;/code&gt; 를 지원하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fadd25a497ceed3db514d6c0e592e1e20d037d5" translate="yes" xml:space="preserve">
          <source>Filter,</source>
          <target state="translated">Filter,</target>
        </trans-unit>
        <trans-unit id="de222516dbd45eb5bdd961151d054741ace84d2e" translate="yes" xml:space="preserve">
          <source>FilterDefault) -&amp;gt;</source>
          <target state="translated">FilterDefault) -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c5965553aaf1be455c704d626efc4a417689e365" translate="yes" xml:space="preserve">
          <source>Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better. The effect of &lt;code&gt;filtered&lt;/code&gt; is to force more Huffman coding and less string matching; it is somewhat intermediate between &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;huffman_only&lt;/code&gt;. &lt;code&gt;rle&lt;/code&gt; is designed to be almost as fast as &lt;code&gt;huffman_only&lt;/code&gt;, but gives better compression for PNG image data.</source>
          <target state="translated">필터링 된 데이터는 주로 임의의 분포가 작은 작은 값으로 구성됩니다. 이 경우 압축 알고리즘이 더 잘 압축되도록 조정됩니다. &lt;code&gt;filtered&lt;/code&gt; 의 효과는 더 많은 허프만 코딩과 더 적은 문자열 매칭을 강제하는 것입니다. &lt;code&gt;default&lt;/code&gt; 와 &lt;code&gt;huffman_only&lt;/code&gt; 중간에 있습니다. &lt;code&gt;rle&lt;/code&gt; 은 &lt;code&gt;huffman_only&lt;/code&gt; 만큼 빠르도록 설계 되었지만 PNG 이미지 데이터의 압축률이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="44c70ab2c550874c6b83cd64f44945d2191d5fba" translate="yes" xml:space="preserve">
          <source>Filtering thresholds. Anything values above the threshold value are passed through.</source>
          <target state="translated">필터링 임계 값. 임계 값을 초과하는 모든 값이 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="e63e42ac559f604c2b9a7e51e8d51b6e74c5c078" translate="yes" xml:space="preserve">
          <source>Filters and scaling menu:</source>
          <target state="translated">필터 및 스케일링 메뉴 :</target>
        </trans-unit>
        <trans-unit id="438bb8882a451009187f14c4b05eaa8a55556859" translate="yes" xml:space="preserve">
          <source>Filters are removed with &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt; logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">필터는 &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt; logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 로 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="77b261b990351426d63c9de88ecb67bc55f6221e" translate="yes" xml:space="preserve">
          <source>Filters are removed with &lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;logger#remove_primary_filter-1&quot;&gt;logger:remove_primary_filter/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; 로 필터가 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc19bb1144c5545747a16382e69f83acf9cf2b6e" translate="yes" xml:space="preserve">
          <source>Filters are used to remove or change log events before they reach the handlers.</source>
          <target state="translated">필터는 핸들러에 도달하기 전에 로그 이벤트를 제거하거나 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="53eb06202ec69e3a14f6ce5212c4973bb1b05ab3" translate="yes" xml:space="preserve">
          <source>Filters can be primary, or attached to a specific handler. Logger calls the primary filters first, and if they all pass, it calls the handler filters for each handler. Logger calls the handler callback only if all filters attached to the handler in question also pass.</source>
          <target state="translated">필터는 기본이거나 특정 처리기에 연결될 수 있습니다. 로거는 기본 필터를 먼저 호출하고, 모두 통과하면 각 처리기의 처리기 필터를 호출합니다. 로거는 해당 처리기에 연결된 모든 필터도 통과하는 경우에만 처리기 콜백을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="929cf67061a7fdae0a67d2c443458c37da769ac7" translate="yes" xml:space="preserve">
          <source>Filters elements in &lt;code&gt;Ordset1&lt;/code&gt; with boolean function &lt;code&gt;Pred&lt;/code&gt;.</source>
          <target state="translated">부울 함수 &lt;code&gt;Pred&lt;/code&gt; 로 &lt;code&gt;Ordset1&lt;/code&gt; 의 요소를 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="e1e9cfa6f5c1f45c2d29b912c5a283995f5613cb" translate="yes" xml:space="preserve">
          <source>Filters elements in &lt;code&gt;Set1&lt;/code&gt; using predicate function &lt;code&gt;Pred&lt;/code&gt;.</source>
          <target state="translated">술어 함수 &lt;code&gt;Pred&lt;/code&gt; 를 사용하여 &lt;code&gt;Set1&lt;/code&gt; 의 요소를 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="9b107fcf28c50758a21fcaa73c30f2c5f6d0a348" translate="yes" xml:space="preserve">
          <source>Filters elements in &lt;code&gt;Set1&lt;/code&gt; with boolean function &lt;code&gt;Pred&lt;/code&gt;.</source>
          <target state="translated">부울 함수 &lt;code&gt;Pred&lt;/code&gt; 로 &lt;code&gt;Set1&lt;/code&gt; 의 요소를 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="fc2bbf0b2f45aa013340755d9a9883d9fbe02e9d" translate="yes" xml:space="preserve">
          <source>Filters menu:</source>
          <target state="translated">필터 메뉴 :</target>
        </trans-unit>
        <trans-unit id="b359d8ef0c9d6516b3ed5329cab35d70d08cce5f" translate="yes" xml:space="preserve">
          <source>Filters that do not return &lt;code&gt;boolean()&lt;/code&gt; but fail are handled differently depending on their syntax: if the filter is a guard, it returns &lt;code&gt;false&lt;/code&gt;, otherwise the query evaluation fails. This behavior makes it possible for the &lt;code&gt;qlc&lt;/code&gt; module to do some optimizations without affecting the meaning of a query. For example, when testing some position of a table and one or more constants for equality, only the objects with equal values are candidates for further evaluation. The other objects are guaranteed to make the filter return &lt;code&gt;false&lt;/code&gt;, but never fail. The (small) set of candidate objects can often be found by looking up some key values of the table or by traversing the table using a match specification. It is necessary to place the guard filters immediately after the table generator, otherwise the candidate objects are not restricted to a small set. The reason is that objects that could make the query evaluation fail must not be excluded by looking up a key or running a match specification.</source>
          <target state="translated">&lt;code&gt;boolean()&lt;/code&gt; 반환하지 않지만 실패한 필터는 구문에 따라 다르게 처리됩니다. 필터가 보호 인 경우 &lt;code&gt;false&lt;/code&gt; 를 반환하고 그렇지 않으면 쿼리 평가에 실패합니다. 이 동작으로 인해 &lt;code&gt;qlc&lt;/code&gt; 모듈이 쿼리의 의미에 영향을주지 않고 일부 최적화를 수행 할 수 있습니다. 예를 들어, 테이블의 일부 위치와 하나 이상의 상수가 동일한 지 테스트 할 때 값이 같은 개체 만 추가 평가의 후보입니다. 다른 객체는 필터가 &lt;code&gt;false&lt;/code&gt; 를 반환하도록 보장그러나 결코 실패하지 마십시오. (작은) 후보 오브젝트 세트는 종종 테이블의 일부 주요 값을 찾거나 일치 스펙을 사용하여 테이블을 순회하여 찾을 수 있습니다. 테이블 생성기 바로 뒤에 가드 필터를 배치해야합니다. 그렇지 않으면 후보 오브젝트가 작은 세트로 제한되지 않습니다. 그 이유는 키를 찾거나 일치 스펙을 실행하여 쿼리 평가에 실패 할 수있는 오브젝트를 제외하지 않아야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d8273802f92ee02c18f5a56f149001b6d413a4e5" translate="yes" xml:space="preserve">
          <source>Filters to use with Logger.</source>
          <target state="translated">로거와 함께 사용할 필터.</target>
        </trans-unit>
        <trans-unit id="5a52c8b95c60cd642e9615177be329a585894504" translate="yes" xml:space="preserve">
          <source>Final Remarks</source>
          <target state="translated">마지막 비고</target>
        </trans-unit>
        <trans-unit id="15f8a7d12abc0ffa39020921abfbad8a484e39f6" translate="yes" xml:space="preserve">
          <source>Final punctuation</source>
          <target state="translated">구두점</target>
        </trans-unit>
        <trans-unit id="f625e090aff5c6e2793852ea547c61e4a2b56edc" translate="yes" xml:space="preserve">
          <source>Finalizes a series of encryptions or decryptions and delivers the final bytes of the final block. The data returned from this function may be empty if no padding was enabled in &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일련의 암호화 또는 암호 해독을 마무리하고 최종 블록의 최종 바이트를 전달합니다. &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3,4&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt; 에서 패딩이 활성화되지 않은 경우이 함수에서 반환 된 데이터는 비어있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a623b4776d23e2664e3f138ed9827f0c6ae6e48" translate="yes" xml:space="preserve">
          <source>Finalizes the &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; is used. If another time warp mode is used, the time offset state is left unchanged.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time_correction#Single_Time_Warp_Mode&quot;&gt;single time warp mode&lt;/a&gt;&lt;/code&gt; 가 사용될 때 &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;time offset&lt;/a&gt;&lt;/code&gt; 마무리합니다 . 다른 시간 왜곡 모드가 사용되면 시간 오프셋 상태는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7be6a9c8fb73009ddee747b4cee8162da35c862" translate="yes" xml:space="preserve">
          <source>Finalizes the HMAC operation referenced by &lt;code&gt;Context&lt;/code&gt;. &lt;code&gt;HashLen&lt;/code&gt; must be greater than zero. &lt;code&gt;Mac&lt;/code&gt; will be a binary with at most &lt;code&gt;HashLen&lt;/code&gt; bytes. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than &lt;code&gt;HashLen&lt;/code&gt; bytes.</source>
          <target state="translated">&lt;code&gt;Context&lt;/code&gt; 가 참조하는 HMAC 작업을 마무리합니다 . &lt;code&gt;HashLen&lt;/code&gt; 은 0보다 커야합니다. &lt;code&gt;Mac&lt;/code&gt; 은 최대 &lt;code&gt;HashLen&lt;/code&gt; 바이트 의 바이너리입니다 . HashLen이 기본 해시에서 반환 된 실제 바이트 수보다 &lt;code&gt;HashLen&lt;/code&gt; 반환 된 해시는 HashLen 바이트 보다 적습니다 .</target>
        </trans-unit>
        <trans-unit id="65ef78392f0874f3113b63866cde4b3879b0e7f2" translate="yes" xml:space="preserve">
          <source>Finalizes the HMAC operation referenced by &lt;code&gt;Context&lt;/code&gt;. The size of the resultant MAC is determined by the type of hash function used to generate it.</source>
          <target state="translated">&lt;code&gt;Context&lt;/code&gt; 가 참조하는 HMAC 작업을 마무리합니다 . 결과 MAC의 크기는 MAC 생성에 사용되는 해시 함수의 유형에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="5c249e5868c7f4bf1b1bab2b0588f406a4895541" translate="yes" xml:space="preserve">
          <source>Finalizes the MAC operation referenced by &lt;code&gt;State&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 에서 참조하는 MAC 작업을 마무리합니다 .</target>
        </trans-unit>
        <trans-unit id="09519d0cf800592d78d0b7fff89540d957188f61" translate="yes" xml:space="preserve">
          <source>Finalizes the MAC operation referenced by &lt;code&gt;State&lt;/code&gt;. The &lt;code&gt;Mac&lt;/code&gt; result will have a default length depending on the &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;SubType&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#mac_init-3&quot;&gt;mac_init/2,3&lt;/a&gt;&lt;/code&gt; call. To set a shorter length, use &lt;code&gt;&lt;a href=&quot;#mac_finalN-2&quot;&gt;mac_finalN/2&lt;/a&gt;&lt;/code&gt; instead. The default length is documented in &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 에서 참조하는 MAC 작업을 마무리합니다 . &lt;code&gt;Mac&lt;/code&gt; 결과에 따라 기본 길이를해야합니다 &lt;code&gt;Type&lt;/code&gt; 및 &lt;code&gt;SubType&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;#mac_init-3&quot;&gt;mac_init/2,3&lt;/a&gt;&lt;/code&gt; 전화. 더 짧은 길이를 설정하려면 대신 &lt;code&gt;&lt;a href=&quot;#mac_finalN-2&quot;&gt;mac_finalN/2&lt;/a&gt;&lt;/code&gt; 를 사용하십시오. 기본 길이는 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;algorithm_details#message-authentication-codes--macs-&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e81885f58794458968f00203e5876b164fa2c28b" translate="yes" xml:space="preserve">
          <source>Finalizes the hash operation referenced by &lt;code&gt;Context&lt;/code&gt; returned from a previous call to &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt;. The size of &lt;code&gt;Digest&lt;/code&gt; is determined by the type of hash function used to generate it.</source>
          <target state="translated">이전의 &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt; 호출에서 반환 된 &lt;code&gt;Context&lt;/code&gt; 가 참조하는 해시 작업 을 마무리 합니다. &lt;code&gt;Digest&lt;/code&gt; 의 크기는 이를 생성하는 데 사용되는 해시 함수의 유형에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d5d14c724430e1a3c0243d843406a7b51ba7ab25" translate="yes" xml:space="preserve">
          <source>Finally create an informative table dumped on the console with &lt;code&gt;fprof:analyse()&lt;/code&gt;, or on file with &lt;code&gt;fprof:analyse(dest, [])&lt;/code&gt;, or perhaps even &lt;code&gt;fprof:analyse([{dest, &quot;my_fprof.analysis&quot;}, {cols, 120}])&lt;/code&gt; for a wider listing on non-default filename.</source>
          <target state="translated">마지막으로 콘솔에 &lt;code&gt;fprof:analyse()&lt;/code&gt; 또는 &lt;code&gt;fprof:analyse(dest, [])&lt;/code&gt; 또는 &lt;code&gt;fprof:analyse([{dest, &quot;my_fprof.analysis&quot;}, {cols, 120}])&lt;/code&gt; 파일로 덤프 된 정보 테이블을 작성하십시오 . 기본 이름이 아닌 파일 이름의 더 넓은 목록을 보려면 , 120}]) .</target>
        </trans-unit>
        <trans-unit id="3315842147c0699f9adcd6ca4a1d438c177f06a3" translate="yes" xml:space="preserve">
          <source>Finally single modules and entire applications may be read from Escripts.</source>
          <target state="translated">마지막으로 Escripts에서 단일 모듈과 전체 응용 프로그램을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92661f0b869fd14d1ed0ab5c480286262565b533" translate="yes" xml:space="preserve">
          <source>Finally the target &lt;code&gt;releases/RELEASES&lt;/code&gt; file is created from data in the file &lt;code&gt;releases/mysystem.rel&lt;/code&gt;.</source>
          <target state="translated">마지막으로 대상 &lt;code&gt;releases/RELEASES&lt;/code&gt; 파일은 &lt;code&gt;releases/mysystem.rel&lt;/code&gt; 파일의 데이터에서 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="087d7a2e906b99786f46767fd11522868e5d6570" translate="yes" xml:space="preserve">
          <source>Finally, if the analysis is made on line level, the result is given as a list of tuples &lt;code&gt;{Line,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of times each line has been executed:</source>
          <target state="translated">마지막으로, 라인 레벨에서 분석을 수행하면 결과는 튜플 &lt;code&gt;{Line,Calls}&lt;/code&gt; 목록으로 제공됩니다 . 여기에서 &lt;code&gt;Calls&lt;/code&gt; 는 각 줄이 실행 된 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="5b9dd7454a651caca5e5ef6172e38b5dcfc770cf" translate="yes" xml:space="preserve">
          <source>Finally, if the analysis is made on line level, the result is given as a list of tuples &lt;code&gt;{Line,{Cov,NotCov}}&lt;/code&gt;, one for each executable line in the source code. A line is specified by its module name and line number.</source>
          <target state="translated">마지막으로, 라인 레벨에서 분석을 수행하면 결과는 소스 코드의 각 실행 가능 라인마다 하나씩 튜플 &lt;code&gt;{Line,{Cov,NotCov}}&lt;/code&gt; 목록으로 제공됩니다 . 줄은 모듈 이름과 줄 번호로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4229ddaf438f162fbfab1daa97ee43ed5e47043d" translate="yes" xml:space="preserve">
          <source>Finally, if the name without any prefixes or lift/glob markers begins with an uppercase character, as in &lt;code&gt;_@Foo&lt;/code&gt; or &lt;code&gt;_@_@Foo&lt;/code&gt;, it will become a variable on the Erlang level, and can be used to easily deconstruct and construct syntax trees:</source>
          <target state="translated">마지막으로 접두사 또는 리프트 / 글로브 마커가없는 이름이 &lt;code&gt;_@Foo&lt;/code&gt; 또는 &lt;code&gt;_@_@Foo&lt;/code&gt; 와 같이 대문자로 시작 하면 Erlang 수준의 변수가되고 쉽게 해체하고 구성하는 데 사용할 수 있습니다 구문 트리 :</target>
        </trans-unit>
        <trans-unit id="9db00c53b153eacb13bfb4430153b7193db7bcff" translate="yes" xml:space="preserve">
          <source>Finally, if the provided public key is found, the signature provided by the client is checked with the public key.</source>
          <target state="translated">마지막으로 제공된 공개 키가 발견되면 클라이언트가 제공 한 서명을 공개 키로 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2bb7a056457d186e75f685f33527dee8627c1242" translate="yes" xml:space="preserve">
          <source>Finally, let us return the resulting color in &lt;code&gt;blend/3&lt;/code&gt;:</source>
          <target state="translated">마지막으로 &lt;code&gt;blend/3&lt;/code&gt; 의 결과 색상을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="4fd9a0eb31ce9e0e26400a53b63f254adac09b5e" translate="yes" xml:space="preserve">
          <source>Finally, the code for the C node client:</source>
          <target state="translated">마지막으로 C 노드 클라이언트의 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="521306d2143148ff01a484212c6a16c74577f38c" translate="yes" xml:space="preserve">
          <source>Finally, the memory allocated by the &lt;code&gt;ETERM&lt;/code&gt; creating functions (including &lt;code&gt;erl_receive_msg()&lt;/code&gt; must be freed:</source>
          <target state="translated">마지막으로 &lt;code&gt;ETERM&lt;/code&gt; 작성 함수 ( &lt;code&gt;erl_receive_msg()&lt;/code&gt; 포함 ) 가 할당 한 메모리를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d822c5ef1c061771ab665473b83cedef9d44990" translate="yes" xml:space="preserve">
          <source>Finally, the memory allocated by the &lt;code&gt;ETERM&lt;/code&gt; creating functions must be freed:</source>
          <target state="translated">마지막으로 &lt;code&gt;ETERM&lt;/code&gt; 작성 기능에 의해 할당 된 메모리를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8e2b97d3a90fe0284007a8c0d7f8d81ebbb8540" translate="yes" xml:space="preserve">
          <source>Finally, to prepare the upgrade, we must put the new release package in the &lt;code&gt;releases&lt;/code&gt; directory of the first target system:</source>
          <target state="translated">마지막으로 업그레이드를 준비 하려면 첫 번째 대상 시스템 의 &lt;code&gt;releases&lt;/code&gt; 디렉토리에 새 릴리스 패키지를 넣어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c53623e28db074293258fb3bb4f2b79e6f79ea31" translate="yes" xml:space="preserve">
          <source>Find Tag (&lt;code&gt;erlang-find-tag&lt;/code&gt;) - Like the Elisp-function `find-tag'. Capable of retrieving Erlang modules. Tags can be given on the forms `tag', `module:', `module:tag'.</source>
          <target state="translated">태그 찾기 ( &lt;code&gt;erlang-find-tag&lt;/code&gt; )-Elisp 함수`find-tag '와 유사합니다. Erlang 모듈을 검색 할 수 있습니다. 태그는`tag ',`module :',`module : tag '형식으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b34a58f0b0440dc6ae16662304b9e768574d2fc7" translate="yes" xml:space="preserve">
          <source>Find an arbitrary &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; v[1], v[2], ..., v[k] from &lt;code&gt;V1&lt;/code&gt; to &lt;code&gt;V2&lt;/code&gt; in &lt;code&gt;G&lt;/code&gt;.</source>
          <target state="translated">임의 찾기 &lt;code&gt;&lt;a href=&quot;#simple_path&quot;&gt;simple path&lt;/a&gt;&lt;/code&gt; V [1], 절 [2], ...에서, V [K] &lt;code&gt;V1&lt;/code&gt; 에 &lt;code&gt;V2&lt;/code&gt; 의 &lt;code&gt;G&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="607510fcec153a3ea8d617c75859b756b5806031" translate="yes" xml:space="preserve">
          <source>Find the list of inherited callback modules for a given module.</source>
          <target state="translated">주어진 모듈에 대해 상속 된 콜백 모듈 목록을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6e5e5d9606a11a3ec57b3139a243fb3bbaf682d5" translate="yes" xml:space="preserve">
          <source>Find the mib-entry corresponding to the &lt;code&gt;Oid&lt;/code&gt;. If it is a variable, the &lt;code&gt;Oid&lt;/code&gt; must be &amp;lt;Oid for var&amp;gt;.0 and if it is a table, &lt;code&gt;Oid&lt;/code&gt; must be &amp;lt;table&amp;gt;.&amp;lt;entry&amp;gt;.&amp;lt;col&amp;gt;.&amp;lt;any&amp;gt;.</source>
          <target state="translated">&lt;code&gt;Oid&lt;/code&gt; 에 해당하는 mib-entry를 찾으십시오 . 변수 인 경우 &lt;code&gt;Oid&lt;/code&gt; 는 &amp;lt;var의 경우 Oid&amp;gt; .0 이어야 하고 테이블 인 경우 &lt;code&gt;Oid&lt;/code&gt; 는 &amp;lt;table&amp;gt;. &amp;lt;entry&amp;gt;. &amp;lt;col&amp;gt;. &amp;lt;any&amp;gt; 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7d749a8167ac1e1b5818df9d225ddaea608641f0" translate="yes" xml:space="preserve">
          <source>Finds the indices of the next row in the table. &lt;code&gt;RestOid&lt;/code&gt; does not have to specify an existing row.</source>
          <target state="translated">테이블에서 다음 행의 인덱스를 찾습니다. &lt;code&gt;RestOid&lt;/code&gt; 는 기존 행을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="854d2a3b825fbb1805e84a83c0bc976ed8dab61f" translate="yes" xml:space="preserve">
          <source>Finds the lexicographically next oid.</source>
          <target state="translated">사전 식으로 다음 음표를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f0efb500660b8850e6f03d3cc264106146d38ada" translate="yes" xml:space="preserve">
          <source>Finds the mib corresponding to the &lt;code&gt;Oid&lt;/code&gt;. If it is a variable, the Oid must be &amp;lt;Oid for var&amp;gt;.0 and if it is a table, Oid must be &amp;lt;table&amp;gt;.&amp;lt;entry&amp;gt;.&amp;lt;col&amp;gt;.&amp;lt;any&amp;gt;</source>
          <target state="translated">&lt;code&gt;Oid&lt;/code&gt; 에 해당하는 mib을 찾습니다 . 변수 인 경우 Oid는 &amp;lt;var의 경우 Oid&amp;gt; .0이어야하고 테이블 인 경우 Oid는 &amp;lt;table&amp;gt;. &amp;lt;entry&amp;gt;. &amp;lt;col&amp;gt;. &amp;lt;any&amp;gt; 여야합니다.</target>
        </trans-unit>
        <trans-unit id="961787759d2b6794e726ebd5bfa829f55f665a69" translate="yes" xml:space="preserve">
          <source>Finds the mib entry corresponding to the &lt;code&gt;Oid&lt;/code&gt;. If it is a variable, the Oid must be &amp;lt;Oid for var&amp;gt;.0 and if it is a table, Oid must be &amp;lt;table&amp;gt;.&amp;lt;entry&amp;gt;.&amp;lt;col&amp;gt;.&amp;lt;any&amp;gt;</source>
          <target state="translated">&lt;code&gt;Oid&lt;/code&gt; 에 해당하는 mib 항목을 찾습니다 . 변수 인 경우 Oid는 &amp;lt;var의 경우 Oid&amp;gt; .0이어야하고 테이블 인 경우 Oid는 &amp;lt;table&amp;gt;. &amp;lt;entry&amp;gt;. &amp;lt;col&amp;gt;. &amp;lt;any&amp;gt; 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2ead6e026d6cfaeaf0dadb418395e45affe8f757" translate="yes" xml:space="preserve">
          <source>Finds the source filename and compiler options for a module. The result can be fed to &lt;code&gt; compile:file/2&lt;/code&gt; to compile the file again.</source>
          <target state="translated">모듈에 대한 소스 파일 이름 및 컴파일러 옵션을 찾습니다. 결과는 &lt;code&gt; compile:file/2&lt;/code&gt; 에 공급되어 파일을 다시 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd26a101e7f8349a3b9eabf85d3c9e2b88fe9d74" translate="yes" xml:space="preserve">
          <source>Finds the source filename and compiler options for a module. The result can be fed to &lt;code&gt;compile:file/2&lt;/code&gt; to compile the file again.</source>
          <target state="translated">모듈의 소스 파일 이름 및 컴파일러 옵션을 찾습니다. 결과는 &lt;code&gt;compile:file/2&lt;/code&gt; 로 공급되어 파일을 다시 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56049872c97f05a4eb69b7cd9cf9f3115199ab27" translate="yes" xml:space="preserve">
          <source>Finds undefined functions, unused functions, and calls to deprecated functions in a module by calling &lt;code&gt;xref:m/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xref:m/1&lt;/code&gt; 을 호출하여 정의되지 않은 함수, 사용되지 않은 함수 및 모듈에서 더 이상 사용되지 않는 함수를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="4c1f6a04fbd618db88d923399ff700fad86ec5e5" translate="yes" xml:space="preserve">
          <source>Finishes the update of an MD5 &lt;code&gt;Context&lt;/code&gt; and returns the computed &lt;code&gt;MD5&lt;/code&gt; message digest.</source>
          <target state="translated">MD5 &lt;code&gt;Context&lt;/code&gt; 업데이트를 완료하고 계산 된 &lt;code&gt;MD5&lt;/code&gt; 메시지 요약을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a4b3f3698c0c781ab854ffac38f7d4a9742e7fe" translate="yes" xml:space="preserve">
          <source>Finite state machine</source>
          <target state="translated">유한 상태 머신</target>
        </trans-unit>
        <trans-unit id="871f259a87938d87e44a6ae4e2b676fee33ee876" translate="yes" xml:space="preserve">
          <source>Firmware-Revision AVP</source>
          <target state="translated">펌웨어 수정 AVP</target>
        </trans-unit>
        <trans-unit id="aae4edfdb68cd41e660204f375029a430163ca5e" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;pand&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;pand&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dcc52ad67a71e6efc7ff37aea8528443dac76725" translate="yes" xml:space="preserve">
          <source>First a macro &lt;code&gt;is_channel&lt;/code&gt; is defined to help with the guard tests. This is only here for convenience and to reduce syntax cluttering. For more information about macros, see &lt;code&gt; The Preprocessor&lt;/code&gt;.</source>
          <target state="translated">먼저 가드 테스트를 돕기 위해 매크로 &lt;code&gt;is_channel&lt;/code&gt; 이 정의됩니다. 이것은 편의와 구문 혼란을 줄이기위한 것입니다. 매크로에 대한 자세한 내용은 &lt;code&gt; The Preprocessor&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="826f55e631b0eb90c79dc98fcf8ca69529b4d561" translate="yes" xml:space="preserve">
          <source>First a macro &lt;code&gt;is_channel&lt;/code&gt; is defined to help with the guard tests. This is only here for convenience and to reduce syntax cluttering. For more information about macros, see &lt;code&gt;The Preprocessor&lt;/code&gt;.</source>
          <target state="translated">먼저 가드 테스트를 돕기 위해 매크로 &lt;code&gt;is_channel&lt;/code&gt; 이 정의됩니다. 편의상 구문 혼란을 줄이기 위해 여기에만 있습니다. 매크로에 대한 자세한 내용은 &lt;code&gt;The Preprocessor&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dc1523d30389e649eaad9e0547b5fb0f51d863a" translate="yes" xml:space="preserve">
          <source>First a size, as close as possible to SuggestedSize, is selected. Then one group with that key size is randomly selected from the specified set of groups. If no size within the limits of &lt;code&gt;MinSize&lt;/code&gt; and &lt;code&gt;MaxSize&lt;/code&gt; is available, &lt;code&gt;{error,no_group_found}&lt;/code&gt; is returned.</source>
          <target state="translated">먼저 가능한 한 SuggestedSize에 가까운 크기가 선택됩니다. 그런 다음 해당 키 크기를 가진 하나의 그룹이 지정된 그룹 세트에서 무작위로 선택됩니다. 사용 가능한 &lt;code&gt;MinSize&lt;/code&gt; 및 &lt;code&gt;MaxSize&lt;/code&gt; 범위 내의 크기가 없으면 &lt;code&gt;{error,no_group_found}&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1cba34bdd572f011a821961db602576b15bfda82" translate="yes" xml:space="preserve">
          <source>First it matches an opening parenthesis. Then it matches any number of substrings, which can either be a sequence of non-parentheses or a recursive match of the pattern itself (that is, a correctly parenthesized substring). Finally there is a closing parenthesis. Notice the use of a possessive quantifier to avoid backtracking into sequences of non-parentheses.</source>
          <target state="translated">먼저 여는 괄호와 일치합니다. 그런 다음 임의의 수의 하위 문자열과 일치합니다. 이는 일련의 비 괄호 또는 패턴 자체의 재귀 적 일치 (즉, 올바르게 괄호로 묶인 하위 문자열) 일 수 있습니다. 마지막으로 닫는 괄호가 있습니다. 비 괄호 시퀀스로의 역 추적을 피하기 위해 소유 정량자를 사용하는 것에 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="afd800199d45c2aa85aa04aeabc10ec9921944e4" translate="yes" xml:space="preserve">
          <source>First let us look at some of the new concepts that have been introduced.</source>
          <target state="translated">먼저 소개 된 몇 가지 새로운 개념을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="be568e309600c7ae745b47d478b96067b9e3bdb7" translate="yes" xml:space="preserve">
          <source>First notice that two functions have the same name, &lt;code&gt;list_max&lt;/code&gt;. However, each of these takes a different number of arguments (parameters). In Erlang these are regarded as completely different functions. Where you need to distinguish between these functions, you write Name/Arity, where Name is the function name and Arity is the number of arguments, in this case &lt;code&gt;list_max/1&lt;/code&gt; and &lt;code&gt;list_max/2&lt;/code&gt;.</source>
          <target state="translated">먼저 두 함수의 이름이 &lt;code&gt;list_max&lt;/code&gt; 입니다. 그러나 이들 각각은 다른 수의 인수 (매개 변수)를 사용합니다. Erlang에서는 이것들이 완전히 다른 기능으로 간주됩니다. 이러한 함수를 구별해야하는 경우 Name / Arity를 ​​작성합니다. 여기서 Name은 함수 이름이고 Arity는 인수 수입니다 (이 경우 &lt;code&gt;list_max/1&lt;/code&gt; 및 &lt;code&gt;list_max/2&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="96d6bd9c6a5496d3c40a44a0010b9e0e5691afa4" translate="yes" xml:space="preserve">
          <source>First of all, Cover must be started. This spawns a process which owns the Cover database where all coverage data will be stored.</source>
          <target state="translated">우선 표지를 시작해야합니다. 이것은 모든 커버리지 데이터가 저장 될 Cover 데이터베이스를 소유하는 프로세스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="861333dda4065fae7a2362b848cb2eae4954e72b" translate="yes" xml:space="preserve">
          <source>First of all, build the OTP source tree at &lt;code&gt;$ERL_TOP&lt;/code&gt; containing the updated applications.</source>
          <target state="translated">우선 , 업데이트 된 애플리케이션이 포함 된 &lt;code&gt;$ERL_TOP&lt;/code&gt; OTP 소스 트리를 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b4b93091c06ea36f866735e533f26aea6d70eb1" translate="yes" xml:space="preserve">
          <source>First sends &lt;code&gt;hbuf&lt;/code&gt; (length in &lt;code&gt;hlen&lt;/code&gt;) data as a list, regardless of port settings. Then sends &lt;code&gt;buf&lt;/code&gt; as a binary or list. For example, if &lt;code&gt;hlen&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt;, the port owner process receives &lt;code&gt;[H1, H2, H3 | T]&lt;/code&gt;.</source>
          <target state="translated">먼저 포트 설정에 관계없이 &lt;code&gt;hbuf&lt;/code&gt; (길이 &lt;code&gt;hlen&lt;/code&gt; ) 데이터를 목록으로 보냅니다 . 그런 다음 &lt;code&gt;buf&lt;/code&gt; 를 이진 또는 목록으로 보냅니다 . 예를 들어, &lt;code&gt;hlen&lt;/code&gt; 이 &lt;code&gt;3&lt;/code&gt; 인 경우 포트 소유자 프로세스는 &lt;code&gt;[H1, H2, H3 | T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="141a9bf26500eaac1e5dea48990666897b26cc97" translate="yes" xml:space="preserve">
          <source>First the change to upper case:</source>
          <target state="translated">먼저 대문자로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="f21eef584755ba1c14df1d0573d5072695c88c77" translate="yes" xml:space="preserve">
          <source>First the loader will search for a specific operation where the types for all operands match the type for the generic instruction. The first matching instruction will be selected. &lt;strong&gt;beam_makeops&lt;/strong&gt; has ordered the specific instructions so that instructions with more specific operands comes before instructions with less specific operands. For example, &lt;code&gt;move_nx&lt;/code&gt; is more specific than &lt;code&gt;move_cx&lt;/code&gt;. If the first operand is &lt;code&gt;[]&lt;/code&gt; (NIL), &lt;code&gt;move_nx&lt;/code&gt; will be selected.</source>
          <target state="translated">먼저 로더는 모든 피연산자의 유형이 일반 명령어의 유형과 일치하는 특정 연산을 검색합니다. 첫 번째 일치 명령이 선택됩니다. &lt;strong&gt;beam_makeops&lt;/strong&gt; 는보다 구체적인 피연산자가있는 명령어가 덜 구체적인 피연산자가있는 명령어보다 먼저 &lt;strong&gt;오도록&lt;/strong&gt; 특정 명령어를 주문했습니다. 예를 들어, &lt;code&gt;move_nx&lt;/code&gt; 는 보다 더 구체적이다 &lt;code&gt;move_cx&lt;/code&gt; . 첫 번째 피연산자가 &lt;code&gt;[]&lt;/code&gt; (NIL)이면 &lt;code&gt;move_nx&lt;/code&gt; 가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="8a389b5b9353f0d1ba4fa2c4821e059a8293230b" translate="yes" xml:space="preserve">
          <source>First the old event handler &lt;code&gt;Handler1&lt;/code&gt; is deleted. The event manager calls &lt;code&gt;Module1:terminate(Args1, ...)&lt;/code&gt;, where &lt;code&gt;Module1&lt;/code&gt; is the callback module of &lt;code&gt;Handler1&lt;/code&gt;, and collects the return value.</source>
          <target state="translated">먼저 이전 이벤트 핸들러 &lt;code&gt;Handler1&lt;/code&gt; 이 삭제됩니다. 이벤트 관리자는 &lt;code&gt;Module1:terminate(Args1, ...)&lt;/code&gt; 호출합니다. 여기서 &lt;code&gt;Module1&lt;/code&gt; 은 &lt;code&gt;Handler1&lt;/code&gt; 의 콜백 모듈이며 리턴 값을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="d56c44fe867ba3185b946a40d9d145cb133363c4" translate="yes" xml:space="preserve">
          <source>First the record definitions are entered into a text file named &lt;code&gt;company.hrl&lt;/code&gt;. This file defines the following structure for the example database:</source>
          <target state="translated">먼저 레코드 정의는 &lt;code&gt;company.hrl&lt;/code&gt; 이라는 텍스트 파일에 입력됩니다 . 이 파일은 예제 데이터베이스에 대해 다음 구조를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bd8fdf9739d448b9e4a4bb984f8a7a6a8b775ff5" translate="yes" xml:space="preserve">
          <source>First the server at messenger@super is started up:</source>
          <target state="translated">먼저 messenger @ super의 서버가 시작됩니다 :</target>
        </trans-unit>
        <trans-unit id="3cb50aeec91cc6daf6404f50ef9e869344d8d4ed" translate="yes" xml:space="preserve">
          <source>First this tries to match &lt;code&gt;&quot;ABC&quot;&lt;/code&gt;, and then &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt;, but if &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; appears, the function returns &lt;code&gt;{error,{nnn,[&quot;NNN&quot;]}}&lt;/code&gt;. If both &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; and &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; are matched, the function returns &lt;code&gt;{ok,[AbcMatch,XyzMatch]}&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; 를 일치 시킨 다음 &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; 를 일치 시키려고 하지만 &lt;code&gt;&quot;NNN&quot;&lt;/code&gt; 이 나타나면 &lt;code&gt;{error,{nnn,[&quot;NNN&quot;]}}&lt;/code&gt; 이 반환 됩니다. 두 경우 &lt;code&gt;&quot;ABC&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;XYZ&quot;&lt;/code&gt; 가 일치 함수 리턴 &lt;code&gt;{ok,[AbcMatch,XyzMatch]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fecc0f3a53c948327dcd86cdc522369d246c863d" translate="yes" xml:space="preserve">
          <source>First trans id.</source>
          <target state="translated">첫 번째 트랜스 아이디</target>
        </trans-unit>
        <trans-unit id="6148327bc522a99e9e81c9d9c482ed47a643282f" translate="yes" xml:space="preserve">
          <source>First, &lt;strong&gt;unpack&lt;/strong&gt; the release package. The files are then extracted from the package:</source>
          <target state="translated">먼저 릴리스 패키지의 &lt;strong&gt;포장을 풉니 다&lt;/strong&gt; . 그런 다음 패키지에서 파일이 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4d8885fd1f162016ec24f4f3b28478090292099" translate="yes" xml:space="preserve">
          <source>First, set the log level of the default handler to &lt;code&gt;notice&lt;/code&gt;, preventing it from printing info events to the terminal:</source>
          <target state="translated">먼저 기본 핸들러의 로그 레벨을 &lt;code&gt;notice&lt;/code&gt; 로 설정하여 정보 이벤트를 터미널에 인쇄하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="503ca6da48d6707739639f1a65005382e4c2b0a8" translate="yes" xml:space="preserve">
          <source>First, some definitions:</source>
          <target state="translated">먼저 일부 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0a517e7bf384937ceea909a0d45bba4d04794e7" translate="yes" xml:space="preserve">
          <source>First, some words about the xmerl_xs functionality:</source>
          <target state="translated">먼저 xmerl_xs 기능에 대한 몇 가지 단어 :</target>
        </trans-unit>
        <trans-unit id="42831f5a040975e85f0f5211423cb45e8ffb2b36" translate="yes" xml:space="preserve">
          <source>First, the SASL application parameters are checked, then the command-line flags are checked, and finally, the default value is chosen.</source>
          <target state="translated">먼저 SASL 응용 프로그램 매개 변수를 확인한 다음 명령 줄 플래그를 확인하고 마지막으로 기본값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4a287715fbf002065bfda77e14f8669a4fd048f6" translate="yes" xml:space="preserve">
          <source>First, the input value is compared to &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;two&lt;/code&gt;, and &lt;code&gt;three&lt;/code&gt; (using a single instruction that does a binary search; thus, quite efficient even if there are many values) to select which one of the first three clauses to execute (if any).</source>
          <target state="translated">먼저 입력 값을 &lt;code&gt;one&lt;/code&gt; , &lt;code&gt;two&lt;/code&gt; , &lt;code&gt;three&lt;/code&gt; (이진 검색을 수행하는 단일 명령을 사용하므로 많은 값이 있어도 매우 효율적 임)과 비교하여 처음 세 절 중 하나를 실행할 항목을 선택합니다 (있는 경우) ).</target>
        </trans-unit>
        <trans-unit id="7ff27878c38088d37636212bb636643d1457c1d2" translate="yes" xml:space="preserve">
          <source>First, the intensity decides how big bursts of restarts you want to tolerate. For example, you might want to accept a burst of at most 5 or 10 attempts, even within the same second, if it results in a successful restart.</source>
          <target state="translated">첫째, 강도는 얼마나 큰 재시작 횟수를 허용 할 것인지 결정합니다. 예를 들어, 재시작에 성공한 경우에도 동일한 초 내에 최대 5 번 또는 10 번의 버스트를 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e01cb6a003e1a4db093f3279e204b488adfc1f" translate="yes" xml:space="preserve">
          <source>First, the memory use by the loaded code is summarized:</source>
          <target state="translated">먼저로드 된 코드의 메모리 사용이 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="86c3e1dfade8ce19bfbe0cda85f888b0c62d94ac" translate="yes" xml:space="preserve">
          <source>First, the new version of the callback module must be loaded, both in the case of upgrade and downgrade. Then the new return value of &lt;code&gt;init/1&lt;/code&gt; can be checked and the internal state be changed accordingly.</source>
          <target state="translated">먼저, 업그레이드 및 다운 그레이드 모두에서 새 버전의 콜백 모듈을로드해야합니다. 그런 다음 &lt;code&gt;init/1&lt;/code&gt; 의 새로운 반환 값을 확인하고 그에 따라 내부 상태를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50fffaf6770426a16f1a3b60dc7b70d4a1d37aa" translate="yes" xml:space="preserve">
          <source>First, the protocol must be available to the Erlang machine, which involves writing an Erlang driver. A port program cannot be used, an Erlang driver is required. Erlang drivers can be:</source>
          <target state="translated">먼저 Erlang 드라이버를 작성할 수있는 Erlang 시스템에서 프로토콜을 사용할 수 있어야합니다. 포트 프로그램을 사용할 수 없으며 Erlang 드라이버가 필요합니다. Erlang 드라이버는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fab4db4145634905a6bbc1d724fc7f3ed2c38181" translate="yes" xml:space="preserve">
          <source>First, we examine the reply function:</source>
          <target state="translated">먼저 응답 기능을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="988e19fa329fc64d4ed2be313e7df9b9e217c2e2" translate="yes" xml:space="preserve">
          <source>Firstly, its possible to effect the global default value when building OTP from source with the two configure options:</source>
          <target state="translated">첫째, 두 가지 구성 옵션을 사용하여 소스에서 OTP를 빌드 할 때 전역 기본값에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0abaf6efbc66dd086221ffc93e7f7f7b2e0566" translate="yes" xml:space="preserve">
          <source>Fixed Balancing Information</source>
          <target state="translated">고정 균형 정보</target>
        </trans-unit>
        <trans-unit id="084f54fd1bbfb321fb1dcfaff2b90a8b2b81d485" translate="yes" xml:space="preserve">
          <source>Fixed Path MTU, if automatic discovery is disabled (see &lt;code&gt;flags&lt;/code&gt; below)</source>
          <target state="translated">자동 검색이 비활성화 된 경우 고정 경로 MTU (아래 &lt;code&gt;flags&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="97e7e19e341587c271357db5bf33234c3e376e99" translate="yes" xml:space="preserve">
          <source>Fixes a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt; safe traversal&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; &amp;amp; &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;&lt;a href=&quot;#traversal&quot;&gt; safe traversal&lt;/a&gt;&lt;/code&gt; 를 위해 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="c84c1d136fc5d3a44eaf58de39dd9228d45a89aa" translate="yes" xml:space="preserve">
          <source>Fixes a table of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, or &lt;code&gt;duplicate_bag&lt;/code&gt; for safe traversal.</source>
          <target state="translated">안전한 순회를 위해 &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;bag&lt;/code&gt; 또는 &lt;code&gt;duplicate_bag&lt;/code&gt; 유형의 테이블을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="5b7664cd64d460ab893bbddb8f00633c580bc908" translate="yes" xml:space="preserve">
          <source>Fixes the array size. This prevents it from growing automatically upon insertion.</source>
          <target state="translated">배열 크기를 수정합니다. 삽입시 자동으로 커지는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="4723c5aa925950e4bd36f4c54f3676d51e62a045" translate="yes" xml:space="preserve">
          <source>Flag &lt;code&gt;-extra&lt;/code&gt; is treated in a special way. Its scope ends at the end of the environment variable content. Arguments following an &lt;code&gt;-extra&lt;/code&gt; flag are moved on the command line into section &lt;code&gt;-extra&lt;/code&gt;, that is, the end of the command line following an &lt;code&gt;-extra&lt;/code&gt; flag.</source>
          <target state="translated">플래그 &lt;code&gt;-extra&lt;/code&gt; 는 특별한 방식으로 처리됩니다. 범위는 환경 변수 컨텐츠의 끝에서 끝납니다. &lt;code&gt;-extra&lt;/code&gt; 플래그 다음의 인수 는 명령 행에서 &lt;code&gt;-extra&lt;/code&gt; 섹션으로 , 즉 &lt;code&gt;-extra&lt;/code&gt; 플래그 다음의 명령 행 끝으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="8bb67231cdcf22509e8ef18194400f272b044e65" translate="yes" xml:space="preserve">
          <source>Flag for automated use of option &lt;code&gt;tsize&lt;/code&gt;. With this set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;write_file/3&lt;/code&gt; client determines the filesize and sends it to the server as the standardized &lt;code&gt;tsize&lt;/code&gt; option. A &lt;code&gt;read_file/3&lt;/code&gt; client acquires only a filesize from the server by sending a zero &lt;code&gt;tsize&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;tsize&lt;/code&gt; 의 자동 사용을위한 플래그입니다 . 이 값을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 &lt;code&gt;write_file/3&lt;/code&gt; 클라이언트는 파일 크기를 결정하고이를 표준화 된 &lt;code&gt;tsize&lt;/code&gt; 옵션 으로 서버에 보냅니다 . &lt;code&gt;read_file/3&lt;/code&gt; 클라이언트는 제로 전송하여 서버에서 만 파일 크기를 획득 &lt;code&gt;tsize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b981ac7080263b949f2d1d82a6d792d6762d1b" translate="yes" xml:space="preserve">
          <source>Flag that tells the parser if it's parsing a DTD or a normal XML file (default normal).</source>
          <target state="translated">구문 분석기가 DTD 또는 일반 XML 파일을 구문 분석 중인지 여부를 알리는 플래그입니다 (기본 표준).</target>
        </trans-unit>
        <trans-unit id="c9750765e0d3534c79392974771889da2e9473d6" translate="yes" xml:space="preserve">
          <source>Flags for Configuration of Allocators Based on alloc_util</source>
          <target state="translated">alloc_util을 기반으로 할당 자 구성을위한 플래그</target>
        </trans-unit>
        <trans-unit id="ccac28851cae372d71b8bd937c9e6d7be6dbaf14" translate="yes" xml:space="preserve">
          <source>Flags for Configuration of alloc_util</source>
          <target state="translated">alloc_util 구성을위한 플래그</target>
        </trans-unit>
        <trans-unit id="e685c10161bcfb5d845592e4b8eb689e72310259" translate="yes" xml:space="preserve">
          <source>Flags for Configuration of mseg_alloc</source>
          <target state="translated">mseg_alloc 구성을위한 플래그</target>
        </trans-unit>
        <trans-unit id="7485fda0d817c22340066397dc18fad274d1664b" translate="yes" xml:space="preserve">
          <source>Flags for Configuration of sys_alloc</source>
          <target state="translated">sys_alloc 구성을위한 플래그</target>
        </trans-unit>
        <trans-unit id="87bc90787a67d058c8dfdbb4a960d1f06bf39392" translate="yes" xml:space="preserve">
          <source>Flags informing &lt;code&gt;ei&lt;/code&gt; about the behaviour of the callbacks. Flags should be bitwise or:ed together. If no flag, is set, the &lt;code&gt;flags&lt;/code&gt; field should contain &lt;code&gt;0&lt;/code&gt;. Currently, supported flags:</source>
          <target state="translated">콜백의 동작에 대해 &lt;code&gt;ei&lt;/code&gt; 에 알리는 플래그 . 플래그는 비트 단위 또는 함께 연결되어야합니다. 플래그가 설정되지 않은 경우 &lt;code&gt;flags&lt;/code&gt; 필드에 &lt;code&gt;0&lt;/code&gt; 이 포함되어야합니다 . 현재 지원되는 플래그 :</target>
        </trans-unit>
        <trans-unit id="8cfa9cba16ee68a710d88bffe41a906865ddeda5" translate="yes" xml:space="preserve">
          <source>Flattens sublists of a &lt;code&gt;form_list&lt;/code&gt; node. Returns &lt;code&gt;Node&lt;/code&gt; with all subtrees of type &lt;code&gt;form_list&lt;/code&gt; recursively expanded, yielding a single &quot;flat&quot; abstract form sequence.</source>
          <target state="translated">&lt;code&gt;form_list&lt;/code&gt; 노드의 하위 목록을 병합 합니다. &lt;code&gt;form_list&lt;/code&gt; 유형의 모든 하위 트리가 재귀 적으로 확장되어 단일 &quot;평면&quot;추상 양식 시퀀스를 생성하는 &lt;code&gt;Node&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="e2380e9350a55e73133dd09a91562598b49e3cc4" translate="yes" xml:space="preserve">
          <source>Floating point division</source>
          <target state="translated">부동 소수점 나누기</target>
        </trans-unit>
        <trans-unit id="39e68b24ba47a1f890e127374f7a602849382003" translate="yes" xml:space="preserve">
          <source>Floats are encoded using a textual representation. This option is useful to ensure that releases before Erlang/OTP R11B-4 can decode resulting binary.</source>
          <target state="translated">부동은 텍스트 표현을 사용하여 인코딩됩니다. 이 옵션은 Erlang / OTP R11B-4 이전 릴리스가 이진 결과를 디코딩 할 수 있도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d7143a2aecb8a362aec30776acebfb355af8b829" translate="yes" xml:space="preserve">
          <source>Flushes any messages sent to the shell.</source>
          <target state="translated">쉘로 전송 된 모든 메시지를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="3ed10d6d5a038506e68924d5de19ea0282539638" translate="yes" xml:space="preserve">
          <source>Folds &lt;code&gt;Function&lt;/code&gt; over every element in &lt;code&gt;Ordset&lt;/code&gt; and returns the final value of the accumulator.</source>
          <target state="translated">폴드 &lt;code&gt;Function&lt;/code&gt; 의 모든 요소를 통해 &lt;code&gt;Ordset&lt;/code&gt; 과 축적의 마지막 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20c0775347187363f923b7082f0701f0300ea32f" translate="yes" xml:space="preserve">
          <source>Folds &lt;code&gt;Function&lt;/code&gt; over every element in &lt;code&gt;Set&lt;/code&gt; and returns the final value of the accumulator. The evaluation order is undefined.</source>
          <target state="translated">접기 &lt;code&gt;Set&lt;/code&gt; 의 모든 요소에 대해 &lt;code&gt;Function&lt;/code&gt; 를 수행하고 누산기의 최종 값을 반환합니다. 평가 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a46a6a662e70242e55f3b9c440feabea707c5062" translate="yes" xml:space="preserve">
          <source>Folds &lt;code&gt;Function&lt;/code&gt; over every element in &lt;code&gt;Set&lt;/code&gt; returning the final value of the accumulator.</source>
          <target state="translated">누산기의 최종 값을 반환하는 &lt;code&gt;Set&lt;/code&gt; 의 모든 요소에 대해 &lt;code&gt;Function&lt;/code&gt; 를 접습니다 .</target>
        </trans-unit>
        <trans-unit id="e17bd1d344dbb01f9f7fe9bf4a614876c7ef609d" translate="yes" xml:space="preserve">
          <source>Folds a function over all nodes of a syntax tree. The result is the value of &lt;code&gt;Function(X1, Function(X2, ... Function(Xn, Start) ... ))&lt;/code&gt;, where &lt;code&gt;[X1, X2, ..., Xn]&lt;/code&gt; are the nodes of &lt;code&gt;Tree&lt;/code&gt; in a post-order traversal.</source>
          <target state="translated">구문 트리의 모든 노드에 함수를 접습니다. 결과는 &lt;code&gt;Function(X1, Function(X2, ... Function(Xn, Start) ... ))&lt;/code&gt; . 여기서 &lt;code&gt;[X1, X2, ..., Xn]&lt;/code&gt; 은 포스트 의 &lt;code&gt;Tree&lt;/code&gt; 노드입니다. 순회 주문.</target>
        </trans-unit>
        <trans-unit id="ad489c38588e0d153289af6e63ad4c531441d39a" translate="yes" xml:space="preserve">
          <source>Folds a function over the immediate subtrees of a syntax tree. This is similar to &lt;code&gt;fold/3&lt;/code&gt;, but only on the immediate subtrees of &lt;code&gt;Tree&lt;/code&gt;, in left-to-right order; it does not include the root node of &lt;code&gt;Tree&lt;/code&gt;.</source>
          <target state="translated">구문 트리의 직계 하위 트리에 함수를 접습니다. 이것은 &lt;code&gt;fold/3&lt;/code&gt; 과 비슷 하지만 &lt;code&gt;Tree&lt;/code&gt; 의 직계 하위 트리에서만 왼쪽에서 오른쪽으로; &lt;code&gt;Tree&lt;/code&gt; 의 루트 노드는 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cde10e635a7c26a100b0cc5c7b436c521f45b4be" translate="yes" xml:space="preserve">
          <source>Folds function &lt;code&gt;Fun&lt;/code&gt; over all (regular) files &lt;code&gt;F&lt;/code&gt; in directory &lt;code&gt;Dir&lt;/code&gt; that match the regular expression &lt;code&gt;RegExp&lt;/code&gt; (for a description of the allowed regular expressions, see the &lt;code&gt;&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; module). If &lt;code&gt;Recursive&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, all subdirectories to &lt;code&gt;Dir&lt;/code&gt; are processed. The regular expression matching is only done on the filename without the directory part.</source>
          <target state="translated">접기 기능 정규식 &lt;code&gt;RegExp&lt;/code&gt; 와 일치하는 디렉토리 &lt;code&gt;Dir&lt;/code&gt; 의 모든 (정규) 파일 &lt;code&gt;F&lt;/code&gt; 에 대해 &lt;code&gt;Fun&lt;/code&gt; 을 사용합니다 ( 허용 된 정규식에 대한 설명은 &lt;code&gt;&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; 모듈 참조 ). &lt;code&gt;Recursive&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;Dir&lt;/code&gt; 에 대한 모든 하위 디렉토리 가 처리됩니다. 정규식 일치는 디렉토리 부분이없는 파일 이름에서만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="34696df76dcd0e6f0e38f48e35529e37dc89aea7" translate="yes" xml:space="preserve">
          <source>Folds the array elements right-to-left using the specified function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the highest index to the lowest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수와 초기 누산기 값을 사용하여 배열 요소를 오른쪽에서 왼쪽으로 접고 기본값은 입력하지 않습니다. 요소는 가장 높은 인덱스에서 가장 낮은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="b922e4cb2297e1f48705b6c3d30e948f3f25da73" translate="yes" xml:space="preserve">
          <source>Folds the array elements right-to-left using the specified function and initial accumulator value. The elements are visited in order from the highest index to the lowest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수와 초기 누산기 값을 사용하여 배열 요소를 오른쪽에서 왼쪽으로 접습니다. 요소는 가장 높은 인덱스에서 가장 낮은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="d90bd6b0bf08b4953d9563c756b81c25d2b3ac0c" translate="yes" xml:space="preserve">
          <source>Folds the array elements using the specified function and initial accumulator value, skipping default-valued entries. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수와 초기 누산기 값을 사용하여 배열 요소를 접고 기본 값 항목은 건너 뜁니다. 요소는 가장 낮은 인덱스에서 가장 높은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="51a05de854f0e5d68fa02c6d17b5224e9c4fa04b" translate="yes" xml:space="preserve">
          <source>Folds the array elements using the specified function and initial accumulator value. The elements are visited in order from the lowest index to the highest. If &lt;code&gt;Function&lt;/code&gt; is not a function, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">지정된 함수와 초기 누산기 값을 사용하여 배열 요소를 접습니다. 요소는 가장 낮은 인덱스에서 가장 높은 순서대로 방문합니다. &lt;code&gt;Function&lt;/code&gt; 이 함수 가 아닌 경우 reason &lt;code&gt;badarg&lt;/code&gt; 로 호출이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="3bf150bdf605ce53c5f7fd57e5849ed193bca889" translate="yes" xml:space="preserve">
          <source>Followed by &lt;code&gt;ArgList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgList&lt;/code&gt; 가 뒤 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="7717c6070633700f06c185a14309920e6572a716" translate="yes" xml:space="preserve">
          <source>Followed by &lt;code&gt;Message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 다음에 .</target>
        </trans-unit>
        <trans-unit id="0d5603edfeddb92dfa432e8abb290956b8e40e64" translate="yes" xml:space="preserve">
          <source>Followed by &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Reason&lt;/code&gt; 뒤 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f73f4fc37da57263ddf39b7d23e1e53168eaa0a0" translate="yes" xml:space="preserve">
          <source>Following a &lt;code&gt;next&lt;/code&gt; or a &lt;code&gt;prev&lt;/code&gt; pointer will take you to either an element in the pool, or an element that used to be in the pool.</source>
          <target state="translated">후속 &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;prev&lt;/code&gt; 포인터가 풀의 요소, 또는 풀에 있어야하는 데 사용되는 요소 중 하나에 당신을 데려 갈 것이다.</target>
        </trans-unit>
        <trans-unit id="4bf9bb4d4e4c3ef83760e69ac50d25c92575e18f" translate="yes" xml:space="preserve">
          <source>Following the prefix, one or more &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; characters may be used to indicate &quot;lifting&quot; of the variable one or more levels, and after that, a &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;9&lt;/code&gt; character indicates a glob metavariable (matching zero or more elements in a sequence) rather than a normal metavariable. For example:</source>
          <target state="translated">접두사 다음에 하나 이상의 &lt;code&gt;_&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 문자를 사용하여 변수 하나 이상의 레벨의 &quot;리프팅&quot;을 나타낼 수 있으며, 그 후 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;9&lt;/code&gt; 문자는 glob 메타 변수를 나타냅니다 (시퀀스에서 0 개 이상의 요소와 일치) 일반적인 메타 변수보다는 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3f8e8335463ed8ea44053ca41a68cc219c83dee" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;'receive'&lt;/code&gt;, the matching is done on the list &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt;. &lt;code&gt;Node&lt;/code&gt; is the node name of the sender. &lt;code&gt;Sender&lt;/code&gt; is the process or port identity of the sender, or the atom &lt;code&gt;undefined&lt;/code&gt; if the sender is not known (which may be the case for remote senders). &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the receiving process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;code&gt;'receive'&lt;/code&gt; , 매칭리스트에서 이루어진다 &lt;code&gt;[Node, Sender, Msg]&lt;/code&gt; . &lt;code&gt;Node&lt;/code&gt; 는 발신자의 노드 이름입니다. &lt;code&gt;Sender&lt;/code&gt; 은 보낸 사람 의 프로세스 또는 포트 ID이거나 , 보낸 사람을 알 수없는 경우 &lt;code&gt;undefined&lt;/code&gt; 원자 입니다 (원격 보낸 사람의 경우 일 수 있음). &lt;code&gt;Msg&lt;/code&gt; 메시지 용어입니다. 수신 프로세스의 pid는 보호 기능 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="480e0922ee88128ee86738ef7261d590a0e8c190" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;SSL&lt;/code&gt; configuration options, see &lt;code&gt;ssl:listen/2&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;SSL&lt;/code&gt; 의 구성 옵션을 참조 &lt;code&gt;ssl:listen/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="837fe05b580800e8ef9f8355486b9e94f3908a70" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;SnmpInfo&lt;/code&gt; see handle_agent below.</source>
          <target state="translated">들어 &lt;code&gt;SnmpInfo&lt;/code&gt; 아래 handle_agent를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4a8a5b7d1966b785796d897b3021817bd10b658" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;SnmpInfo&lt;/code&gt;, see the user callback function &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_report&quot;&gt;handle_report&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;SnmpInfo&lt;/code&gt; , 사용자 콜백 함수 참조 &lt;code&gt;&lt;a href=&quot;snmpm_user#handle_report&quot;&gt;handle_report&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d9b7b01d3061c729af0c86684d89c756c7e6ae2c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Timeout &amp;lt; infinity&lt;/code&gt;, to avoid getting a late reply in the caller's inbox if the caller should catch exceptions, this function spawns a proxy process that does the call. A late reply gets delivered to the dead proxy process, hence gets discarded. This is less efficient than using &lt;code&gt;Timeout == infinity&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;Timeout &amp;lt; infinity&lt;/code&gt; 호출자가이 기능이 급부상 호출을하는 프록시 처리 예외를 포착해야하는 경우, 호출자의받은 편지함에 늦은 답장을 받고 방지 할 수 있습니다. 지연된 응답은 사용 불능 프록시 프로세스에 전달되므로 폐기됩니다. &lt;code&gt;Timeout == infinity&lt;/code&gt; 사용하는 것보다 덜 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="306f3a31becdaed0dfb6a27e1f9d860d62d24346" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;binary&lt;/code&gt; and &lt;code&gt;bitstring&lt;/code&gt; it is the whole binary or bit string.</source>
          <target state="translated">들어 &lt;code&gt;binary&lt;/code&gt; 및 &lt;code&gt;bitstring&lt;/code&gt; 은 전체 바이너리 또는 비트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f82a5da13eae2b8a78771b0a37cc29126e2e31b6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;caseless&lt;/code&gt;</source>
          <target state="translated">의 경우 &lt;code&gt;caseless&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc2e192562eb900cd97c5a52ea052b56056e9430" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that 14 lines in the module are covered but one line is not covered.</source>
          <target state="translated">들면 &lt;code&gt;channel&lt;/code&gt; , 결과 프로그램은 모듈 (14 개) 라인은 피복되어 있지만, 하나 개의 라인을 포함하지 않는다.</target>
        </trans-unit>
        <trans-unit id="dbc8cd875be8ee9c431a057031268a3639090cfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that &lt;code&gt;handle_call/3&lt;/code&gt; is the most called function in the module (three calls). All other functions have been called once.</source>
          <target state="translated">들면 &lt;code&gt;channel&lt;/code&gt; , 결과 프로그램 것을 &lt;code&gt;handle_call/3&lt;/code&gt; 모듈 (세 호출)에서 가장라는 함수이다. 다른 모든 기능은 한 번 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f4a448021f5730dc183eb8b38c78c9aa300e542" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that a total of twelve calls have been made to functions in the module.</source>
          <target state="translated">들면 &lt;code&gt;channel&lt;/code&gt; , 호출 열두 개의 모듈로 함수에 적용된 결과 나타낸다.</target>
        </trans-unit>
        <trans-unit id="ce8291600cfdb667a10bccca5cf4199590245e5c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that all clauses have been called once, except the second clause of &lt;code&gt;channel:alloc/1&lt;/code&gt; which has not been called at all.</source>
          <target state="translated">들어 &lt;code&gt;channel&lt;/code&gt; , 모든 조항은 한 번만 호출되고, 그 결과 쇼의 두 번째 except 절 &lt;code&gt;channel:alloc/1&lt;/code&gt; 모두에서 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1879b3d60244127e7246bb041953aa192aca26a7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that all lines have been executed once, except line number 49 which has not been executed at all.</source>
          <target state="translated">들면 &lt;code&gt;channel&lt;/code&gt; , 프로그램 결과 모든 라인을 전혀 실행되지 않은 행 번호 (49)를 제외하고, 한 번 실행 한 것을.</target>
        </trans-unit>
        <trans-unit id="913adfb90cda7f161150b60d01fdf3e90d19a7f9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that the uncovered line is in the function &lt;code&gt;channel:alloc/1&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;code&gt;channel&lt;/code&gt; , 피복 라인 함수의 결과임을 보여주는 &lt;code&gt;channel:alloc/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78d03f5adfa666b78c6cac3170efcb9783caa47f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that the uncovered line is in the second clause of &lt;code&gt;channel:alloc/1&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;code&gt;channel&lt;/code&gt; , 피복 라인의 제 절의 결과임을 보여준다 &lt;code&gt;channel:alloc/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a4c9aacb30b85ffa3c2fc8dbe58b3d6d3491b4b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;channel&lt;/code&gt;, the result shows that the uncovered line is line number 49.</source>
          <target state="translated">들면 &lt;code&gt;channel&lt;/code&gt; , 노출 된 광고는 광고 번호 49 결과임을 보여준다.</target>
        </trans-unit>
        <trans-unit id="a66b71488233e32be079939e87c3d32f05d964a2" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;cmac&lt;/code&gt; it is a cipher suitable for cmac, see &lt;code&gt;&lt;a href=&quot;algorithm_details#cmac&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">&lt;code&gt;cmac&lt;/code&gt; 의 경우 cmac에 적합한 암호 입니다. 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;algorithm_details#cmac&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76d856ada4f3988937024e7694b319689a98ffe4" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;dotall&lt;/code&gt;</source>
          <target state="translated">대한 &lt;code&gt;dotall&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa4dcc97e3756da63f2e21365ec4fc6f05eca132" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;erl -man &amp;lt;page&amp;gt;&lt;/code&gt; to work the Unix manual pages have to be installed in the same way, i.e.</source>
          <target state="translated">들어 &lt;code&gt;erl -man &amp;lt;page&amp;gt;&lt;/code&gt; 유닉스 매뉴얼 페이지, 즉 같은 방식으로 설치해야 작동합니다</target>
        </trans-unit>
        <trans-unit id="fec6b7769e6e2beeb499cd6dde436c5e206e86c6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;extended&lt;/code&gt;</source>
          <target state="translated">들어 &lt;code&gt;extended&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d75563e57c449294a3a68bb646f816312c751d6b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;file_logger&lt;/code&gt;, the file descriptor opened in &lt;code&gt;init&lt;/code&gt; must be closed:</source>
          <target state="translated">들어 &lt;code&gt;file_logger&lt;/code&gt; 에서 열린 파일 기술자 &lt;code&gt;init&lt;/code&gt; 닫아야합니다 :</target>
        </trans-unit>
        <trans-unit id="4a3c22404b7331d34de67643c1087336d5e76b3a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;float&lt;/code&gt; it is 64.</source>
          <target state="translated">들어 &lt;code&gt;float&lt;/code&gt; 는 64입니다.</target>
        </trans-unit>
        <trans-unit id="a01e1be8a276994d6884e4946a051462746e6284" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;gen_statem&lt;/code&gt; the &lt;code&gt;Msg&lt;/code&gt; term is an &lt;code&gt;{EventType,EventContent}&lt;/code&gt; tuple.</source>
          <target state="translated">들어 &lt;code&gt;gen_statem&lt;/code&gt; &lt;code&gt;Msg&lt;/code&gt; 용어는이다 &lt;code&gt;{EventType,EventContent}&lt;/code&gt; 튜플.</target>
        </trans-unit>
        <trans-unit id="b180e4e513d7f06b9413e20ddc2960a34c4e662d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hmac&lt;/code&gt; it is a hash algorithm, see &lt;code&gt;&lt;a href=&quot;algorithm_details#hmac&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">들어 &lt;code&gt;hmac&lt;/code&gt; 는 해시 알고리즘을 참조 &lt;code&gt;&lt;a href=&quot;algorithm_details#hmac&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; 사용자 가이드에.</target>
        </trans-unit>
        <trans-unit id="af73751b583ba9751b04c55bad09cc50964fde6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;inet:ip4_address()&lt;/code&gt;, &lt;code&gt;inet:ip6_address()&lt;/code&gt; and &lt;code&gt;inet:port_number()&lt;/code&gt;, see also &lt;code&gt; inet:ip_address()&lt;/code&gt;</source>
          <target state="translated">들어 &lt;code&gt;inet:ip4_address()&lt;/code&gt; , &lt;code&gt;inet:ip6_address()&lt;/code&gt; 와 &lt;code&gt;inet:port_number()&lt;/code&gt; 도 참조 &lt;code&gt; inet:ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8bacf5c4fc87126ea054d4fac271c4015334896" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;inet:ip4_address()&lt;/code&gt;, &lt;code&gt;inet:ip6_address()&lt;/code&gt; and &lt;code&gt;inet:port_number()&lt;/code&gt;, see also &lt;code&gt;inet:ip_address()&lt;/code&gt;</source>
          <target state="translated">들어 &lt;code&gt;inet:ip4_address()&lt;/code&gt; , &lt;code&gt;inet:ip6_address()&lt;/code&gt; 와 &lt;code&gt;inet:port_number()&lt;/code&gt; 도 참조 &lt;code&gt;inet:ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cae4b47e5a9f150f229a27bfbd0ea46a1d64770" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;integer&lt;/code&gt; it is 8.</source>
          <target state="translated">들어 &lt;code&gt;integer&lt;/code&gt; 는 8입니다.</target>
        </trans-unit>
        <trans-unit id="e99a30917f5cd8c00509326c2075b011ce728d06" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;ip_comm&lt;/code&gt; configuration options, see &lt;code&gt;gen_tcp:listen/2&lt;/code&gt;, some options that are used internally by httpd can not be set.</source>
          <target state="translated">들어 &lt;code&gt;ip_comm&lt;/code&gt; 의 구성 옵션을 참조하십시오 &lt;code&gt;gen_tcp:listen/2&lt;/code&gt; 설정할 수 없습니다 아파치에 의해 내부적으로 사용되는 일부 옵션.</target>
        </trans-unit>
        <trans-unit id="b14a0d9f49866583abcf65e2354ff6ed5729dd7c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;ip_comm&lt;/code&gt; configuration options, see &lt;code&gt;gen_tcp:listen/2&lt;/code&gt;, some options that are used internally by httpd cannot be set.</source>
          <target state="translated">들어 &lt;code&gt;ip_comm&lt;/code&gt; 의 구성 옵션을 참조하십시오 &lt;code&gt;gen_tcp:listen/2&lt;/code&gt; 설정할 수 없습니다 아파치에 의해 내부적으로 사용되는 일부 옵션.</target>
        </trans-unit>
        <trans-unit id="6afeacaec668c7a523a45d6c1cae420e3d622d0b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;multiline&lt;/code&gt;</source>
          <target state="translated">대한 &lt;code&gt;multiline&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c6240b90fde4b9431d98d1ca191ed039b35525c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;net_kernel&lt;/code&gt; to find out which distribution module to use, command-line argument &lt;code&gt;-proto_dist&lt;/code&gt; is used. It is followed by one or more distribution module names, with suffix &quot;_dist&quot; removed, that is, &lt;code&gt;uds_dist&lt;/code&gt; as a distribution module is specified as &lt;code&gt;-proto_dist uds&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;net_kernel&lt;/code&gt; 은 사용에 분배 모듈을 찾기 위해, 명령 줄 인수 &lt;code&gt;-proto_dist&lt;/code&gt; 이 사용됩니다. 그 뒤에 접미 부 &quot;_dist&quot;가 제거 된 하나 이상의 분배 모듈 이름 &lt;code&gt;uds_dist&lt;/code&gt; 즉, 분배 모듈 인 &lt;code&gt;-proto_dist uds&lt;/code&gt; 는 -proto_dist uds 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="71c597bf7b21f66ff26913f93a38296ce2c8406a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;net_kernel&lt;/code&gt; to find out which distribution module to use, the &lt;code&gt;erl&lt;/code&gt; command-line argument &lt;code&gt;-proto_dist&lt;/code&gt; is used. It is followed by one or more distribution module names, with suffix &quot;_dist&quot; removed. That is, &lt;code&gt;gen_tcp_dist&lt;/code&gt; as a distribution module is specified as &lt;code&gt;-proto_dist gen_tcp&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;net_kernel&lt;/code&gt; 은 사용에 분배 모듈을 찾으려면 &lt;code&gt;erl&lt;/code&gt; 명령 줄 인수 &lt;code&gt;-proto_dist&lt;/code&gt; 이 사용됩니다. 그 뒤에 접미 부 &quot;_dist&quot;가 제거 된 하나 이상의 분배 모듈 이름이옵니다. 즉, &lt;code&gt;gen_tcp_dist&lt;/code&gt; 분배 모듈과 같이 지정 &lt;code&gt;-proto_dist gen_tcp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db4059cc07cc64c072ec8d00b2a0d1d61f21b0a3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;poly1305&lt;/code&gt; it should be set to &lt;code&gt;undefined&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;#mac_init-2&quot;&gt;mac/2&lt;/a&gt;&lt;/code&gt; function could be used instead, see &lt;code&gt;&lt;a href=&quot;algorithm_details#poly1305&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">들어 &lt;code&gt;poly1305&lt;/code&gt; 그것은으로 설정해야합니다 &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#mac_init-2&quot;&gt;mac/2&lt;/a&gt;&lt;/code&gt; 기능은 참조 대신 사용할 수있는 &lt;code&gt;&lt;a href=&quot;algorithm_details#poly1305&quot;&gt;Algorithm Details&lt;/a&gt;&lt;/code&gt; 사용자 가이드에.</target>
        </trans-unit>
        <trans-unit id="b5285ec29bfa76f83a95e98a613af85b60f686d8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;prompt_regexp()&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;prompt_regexp()&lt;/code&gt; 를 참조 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4d8c585b7d1c650c07d665bc708cc16f7916fdbb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;send&lt;/code&gt;, the matching is done on the list &lt;code&gt;[Receiver, Msg]&lt;/code&gt;. &lt;code&gt;Receiver&lt;/code&gt; is the process or port identity of the receiver and &lt;code&gt;Msg&lt;/code&gt; is the message term. The pid of the sending process can be accessed with the guard function &lt;code&gt;self/0&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;code&gt;send&lt;/code&gt; 의 매칭리스트에 행해진 &lt;code&gt;[Receiver, Msg]&lt;/code&gt; . &lt;code&gt;Receiver&lt;/code&gt; 는 수신자 의 프로세스 또는 포트 ID이고 &lt;code&gt;Msg&lt;/code&gt; 는 메시지 용어입니다. 전송 프로세스의 pid는 보호 기능 &lt;code&gt;self/0&lt;/code&gt; 으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca5d08722e51210d2a23bd9d3b80c38d65909424" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;target_name()&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;. For &lt;code&gt;handle()&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;target_name()&lt;/code&gt; 를 참조 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; . 대한 &lt;code&gt;handle()&lt;/code&gt; 를 참조 &lt;code&gt;&lt;a href=&quot;ct_telnet&quot;&gt;ct_telnet&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="86690ad9d971e62c89ca7d8d10401a34891657e4" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;target_name()&lt;/code&gt;, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;code&gt;target_name()&lt;/code&gt; 모듈 참조 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d86b548e2b913c296d63565f1af70f0610098381" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;target_name&lt;/code&gt;, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;code&gt;target_name&lt;/code&gt; , 모듈 참조 &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="753fd166f9b141a235a4d48782b2f5f7cf3ebb2b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;terminal_logger&lt;/code&gt;, no cleaning up is necessary:</source>
          <target state="translated">들어 &lt;code&gt;terminal_logger&lt;/code&gt; , 더 청소하는 것은 필요하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="20cefb4e36d1d738712b524c40516e4ba291b8fd" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;Value&lt;/code&gt; is encoded in 2 or 4 bytes.</source>
          <target state="translated">들면 &lt;code&gt;utf16&lt;/code&gt; , &lt;code&gt;Value&lt;/code&gt; 2 또는 4 바이트로 부호화된다.</target>
        </trans-unit>
        <trans-unit id="c3352ad85305a4bfcb85b2ce08d70c1e2abea690" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;utf32&lt;/code&gt;, &lt;code&gt;Value&lt;/code&gt; is always be encoded in 4 bytes.</source>
          <target state="translated">들어 &lt;code&gt;utf32&lt;/code&gt; , &lt;code&gt;Value&lt;/code&gt; 항상 4 바이트로 인코딩 할 수있다.</target>
        </trans-unit>
        <trans-unit id="d0c67167aaa7bb85f5b7dade38ab231c99564395" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;Value&lt;/code&gt; is encoded in 1-4 bytes.</source>
          <target state="translated">들어 &lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;Value&lt;/code&gt; 1 ~ 4 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2468fe8756bfdbd798388e4895d345f5618b8bce" translate="yes" xml:space="preserve">
          <source>For DER encoding, the compiler does not check the validity of the time values. The DER requirements upon those strings are regarded as a matter for the application to fulfill.</source>
          <target state="translated">DER 인코딩의 경우 컴파일러는 시간 값의 유효성을 검사하지 않습니다. 해당 문자열에 대한 DER 요구 사항은 응용 프로그램의 요구 사항으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c7fd8ac886a14638875730be53a8a71b6b9ec449" translate="yes" xml:space="preserve">
          <source>For LTTng to work properly with Erlang/OTP you need the following packages installed:</source>
          <target state="translated">LTTng가 Erlang / OTP와 제대로 작동하려면 다음 패키지가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a90cf45bc624d84de38bfa81d99a114cca1de885" translate="yes" xml:space="preserve">
          <source>For MSYS2 you use the same &lt;code&gt;C_DRV&lt;/code&gt; and PATH as for MSYS, only update the &lt;code&gt;MINGW_BIN&lt;/code&gt;:</source>
          <target state="translated">MSYS2를 들어 동일한 사용 &lt;code&gt;C_DRV&lt;/code&gt; MSYS에 같은과 경로를 만 업데이트 &lt;code&gt;MINGW_BIN&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="8457be7233cc6e3c4c643ffac41d0673bc19eb73" translate="yes" xml:space="preserve">
          <source>For OpenSSL, see the &lt;code&gt;&lt;a href=&quot;http:www.openssl.org&quot;&gt;OpenSSL documentation&lt;/a&gt;&lt;/code&gt;. and find &lt;code&gt;EVP_CIPHER_CTX_set_padding()&lt;/code&gt; in cryptolib for your linked version.</source>
          <target state="translated">OpenSSL의 경우 &lt;code&gt;&lt;a href=&quot;http:www.openssl.org&quot;&gt;OpenSSL documentation&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 연결된 버전의 cryptolib에서 &lt;code&gt;EVP_CIPHER_CTX_set_padding()&lt;/code&gt; 을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="dc29f18b6d3940946b57d1e535a352d967073546" translate="yes" xml:space="preserve">
          <source>For Pre-Shared Key (PSK) cipher suites, the lookup fun is called by the client and server to determine the shared secret. When called by the client, &lt;code&gt;PSKIdentity&lt;/code&gt; is set to the hint presented by the server or to undefined. When called by the server, &lt;code&gt;PSKIdentity&lt;/code&gt; is the identity presented by the client.</source>
          <target state="translated">PSK (Pre-Shared Key) 암호 제품군의 경우 클라이언트와 서버가 조회 암호를 호출하여 공유 암호를 결정합니다. 클라이언트가 호출하면 &lt;code&gt;PSKIdentity&lt;/code&gt; 는 서버에서 제공 한 힌트로 설정되거나 정의되지 않습니다. 서버가 호출하면 &lt;code&gt;PSKIdentity&lt;/code&gt; 는 클라이언트가 제공 한 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2062ec9baa35bcec6a05bc4e985f4412901c400a" translate="yes" xml:space="preserve">
          <source>For SSL/TLS to work, at least a public key and a certificate must be specified for the server side. In the following example, the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="translated">SSL / TLS가 작동하려면 서버 측에 최소한 공개 키와 인증서를 지정해야합니다. 다음 예에서 PEM 파일 &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; 에는 서버 인증서와 개인 키가 모두 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb7a87de5a408d6086ac689a25bcfcdb9b159107" translate="yes" xml:space="preserve">
          <source>For Secure Remote Password (SRP), the fun is only used by the server to obtain parameters that it uses to generate its session keys. &lt;code&gt;DerivedKey&lt;/code&gt; is to be derived according to &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2945#section-3&quot;&gt; RFC 2945&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc5054#section-2.4&quot;&gt; RFC 5054&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;crypto:sha([Salt, crypto:sha([Username, &amp;lt;&amp;lt;$:&amp;gt;&amp;gt;, Password])])&lt;/code&gt;</source>
          <target state="translated">SRP (Secure Remote Password)의 경우 서버에서 세션 키를 생성하는 데 사용하는 매개 변수를 얻는 데만 재미가 사용됩니다. &lt;code&gt;DerivedKey&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2945#section-3&quot;&gt; RFC 2945&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc5054#section-2.4&quot;&gt; RFC 5054&lt;/a&gt;&lt;/code&gt; 에 따라 파생됩니다 . &lt;code&gt;crypto:sha([Salt, crypto:sha([Username, &amp;lt;&amp;lt;$:&amp;gt;&amp;gt;, Password])])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f74fdc60e34c903bbdf61fd0573dc7b2726963cc" translate="yes" xml:space="preserve">
          <source>For Secure Remote Password (SRP), the fun is only used by the server to obtain parameters that it uses to generate its session keys. &lt;code&gt;DerivedKey&lt;/code&gt; is to be derived according to &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2945#section/3&quot;&gt; RFC 2945&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc5054#section-2.4&quot;&gt; RFC 5054&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;crypto:sha([Salt, crypto:sha([Username, &amp;lt;&amp;lt;$:&amp;gt;&amp;gt;, Password])])&lt;/code&gt;</source>
          <target state="translated">SRP (Secure Remote Password)의 경우 재미는 서버가 세션 키를 생성하는 데 사용하는 매개 변수를 얻는 데만 사용됩니다. &lt;code&gt;DerivedKey&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2945#section/3&quot;&gt; RFC 2945&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc5054#section-2.4&quot;&gt; RFC 5054&lt;/a&gt;&lt;/code&gt; 에 따라 파생됩니다 . &lt;code&gt;crypto:sha([Salt, crypto:sha([Username, &amp;lt;&amp;lt;$:&amp;gt;&amp;gt;, Password])])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2df7f065d5ad35101fcfb7ca6fdf7bd0b7b240a" translate="yes" xml:space="preserve">
          <source>For Solaris running on VME boards from Force Computers, the onboard hardware watchdog can be activated, provided a VME bus driver is added to the operating system (see also Installation Problems).</source>
          <target state="translated">Force Computers의 VME 보드에서 실행중인 Solaris의 경우 운영 체제에 VME 버스 드라이버가 추가 된 경우 온보드 하드웨어 워치 독을 활성화 할 수 있습니다 (설치 문제 참조).</target>
        </trans-unit>
        <trans-unit id="213b2715addaeb7d25bb265d702cd90b9f9da1cc" translate="yes" xml:space="preserve">
          <source>For TLS connections where client certificates are used this will be an ASN.1 DER-encoded X509-certificate as an Erlang binary. If client certificates are not used the value will be &lt;code&gt;no_peercert&lt;/code&gt;, and if TLS is not used (HTTP or connection is lost due to network failure) the value will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">클라이언트 인증서가 사용되는 TLS 연결의 경우 Erlang 바이너리로 ASN.1 DER로 인코딩 된 X509 인증서가됩니다. 클라이언트 인증서를 사용하지 않으면 값은 &lt;code&gt;no_peercert&lt;/code&gt; 이고 TLS를 사용하지 않으면 (네트워크 장애로 인해 HTTP 또는 연결이 끊어짐) 값이 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e026f48848480c85f1428c672c1d36a4faab1b2c" translate="yes" xml:space="preserve">
          <source>For TLS to work, at least a public key and a certificate must be specified for the server side. In the following example, the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="translated">TLS가 작동하려면 서버 측에 대해 최소한 공개 키와 인증서를 지정해야합니다. 다음 예에서 PEM 파일 &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; 에는 서버 인증서와 개인 키가 모두 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bddc5adbfd3e042b35af62e5a620cee5e83c4707" translate="yes" xml:space="preserve">
          <source>For UDP queries, resolver options &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;retry&lt;/code&gt; control retransmission. Each name server in the &lt;code&gt;nameservers&lt;/code&gt; list is tried with a time-out of &lt;code&gt;timeout&lt;/code&gt;/&lt;code&gt;retry&lt;/code&gt;. Then all name servers are tried again, doubling the time-out, for a total of &lt;code&gt;retry&lt;/code&gt; times.</source>
          <target state="translated">UDP 쿼리의 경우 확인자 옵션 &lt;code&gt;timeout&lt;/code&gt; 및 &lt;code&gt;retry&lt;/code&gt; 제어 재전송. 의 각 네임 서버 &lt;code&gt;nameservers&lt;/code&gt; 목록의 타임 아웃으로 시도되는 &lt;code&gt;timeout&lt;/code&gt; / &lt;code&gt;retry&lt;/code&gt; . 그런 다음 모든 이름 서버가 다시 시도되어 시간이 두 배가되어 총 &lt;code&gt;retry&lt;/code&gt; 시간 이 걸립니다 .</target>
        </trans-unit>
        <trans-unit id="daa6b275bed633d91e59851dec0490f3f8639737" translate="yes" xml:space="preserve">
          <source>For Windows NT running on standard PCs with ISA and/or PCI bus, an extension card with a hardware watchdog can be installed.</source>
          <target state="translated">ISA 및 / 또는 PCI 버스가있는 표준 PC에서 실행되는 Windows NT의 경우 하드웨어 감시 장치가있는 확장 카드를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa4ad80dc4dd7367f2ce6a7e23a488861cdfe40" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; process, &lt;code&gt;State&lt;/code&gt; is a list of tuples, where each tuple corresponds to an event handler registered in the process and contains &lt;code&gt;{Module, Id, HandlerState}&lt;/code&gt;, as follows:</source>
          <target state="translated">A에 대한 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; 프로세스 &lt;code&gt;State&lt;/code&gt; 이벤트 핸들러 각 튜플 대응 프로세스에 등록 포함 튜플들의 목록이다 &lt;code&gt;{Module, Id, HandlerState}&lt;/code&gt; 같은 따른다 :</target>
        </trans-unit>
        <trans-unit id="68a3de7d09707f7530bf77047e594ba957594152" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; process, &lt;code&gt;State&lt;/code&gt; is the tuple &lt;code&gt;{Module, Id, HandlerState}&lt;/code&gt; as follows:</source>
          <target state="translated">A의 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; 과정, &lt;code&gt;State&lt;/code&gt; 튜플이다 &lt;code&gt;{Module, Id, HandlerState}&lt;/code&gt; 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="1e11514fb1210ec8a13b39e187446d0f855cfe50" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; process, &lt;code&gt;State&lt;/code&gt; is the state of the callback module and &lt;code&gt;NewState&lt;/code&gt; is a new instance of that state.</source>
          <target state="translated">A에 대한 &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; 의 과정, &lt;code&gt;State&lt;/code&gt; 콜백 모듈의 상태 및 &lt;code&gt;NewState&lt;/code&gt; 는 그 상태의 새로운 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="ee667887f657795967b516568a5588f71ef7dbb1" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; process, the returned &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="translated">A에 대한 &lt;code&gt;&lt;a href=&quot;gen_server&quot;&gt;gen_server&lt;/a&gt;&lt;/code&gt; 의 과정, 반환 된 &lt;code&gt;State&lt;/code&gt; 콜백 모듈의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="ebf13c53f5ba819c65c1ef27ea673837724a64fe" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; process, &lt;code&gt;State&lt;/code&gt; is the tuple &lt;code&gt;{CurrentState,CurrentData}&lt;/code&gt;, and &lt;code&gt;NewState&lt;/code&gt; is a similar tuple, which can contain a new current state, new state data, or both.</source>
          <target state="translated">A에 대한 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 의 과정, &lt;code&gt;State&lt;/code&gt; 튜플이다 &lt;code&gt;{CurrentState,CurrentData}&lt;/code&gt; 및 &lt;code&gt;NewState&lt;/code&gt; 는 새로운 현재 상태, 새로운 상태 데이터, 또는 둘 모두를 포함 할 수있는 유사한 튜플이다.</target>
        </trans-unit>
        <trans-unit id="44cd6815c9e0e97b4a85fd5bdf8e6b3796b629ae" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; process, &lt;code&gt;State&lt;/code&gt; is the tuple &lt;code&gt;{CurrentState,CurrentData}&lt;/code&gt;.</source>
          <target state="translated">A에 대한 &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; 의 과정, &lt;code&gt;State&lt;/code&gt; 튜플이다 &lt;code&gt;{CurrentState,CurrentData}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1348dba6d54a83a9152e4914382188ef991652bb" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;negations&lt;/code&gt; operation, &lt;code&gt;substitute_negations/2&lt;/code&gt; is applied using the specified negation list.</source>
          <target state="translated">A에 대한 &lt;code&gt;negations&lt;/code&gt; 동작 &lt;code&gt;substitute_negations/2&lt;/code&gt; 지정된 무효화리스트를 사용하여 적용된다.</target>
        </trans-unit>
        <trans-unit id="05ac5f3a37177c36456ef3599ab122e2f7a03944" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;record_expr&lt;/code&gt; node, &lt;code&gt;Info&lt;/code&gt; represents the record name and the list of descriptors for the involved fields, listed in the order they appear. A field descriptor is a pair &lt;code&gt;{Label, Value}&lt;/code&gt;, if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;Label = &amp;lt;em&amp;gt;Value&amp;lt;/em&amp;gt;&lt;/code&gt;&quot;. For a &lt;code&gt;record_access&lt;/code&gt; node, &lt;code&gt;Info&lt;/code&gt; represents the record name and the field name. For a &lt;code&gt;record_index_expr&lt;/code&gt; node, &lt;code&gt;Info&lt;/code&gt; represents the record name and the name field name.</source>
          <target state="translated">A에 대한 &lt;code&gt;record_expr&lt;/code&gt; 의 노드 &lt;code&gt;Info&lt;/code&gt; 기록 이름과 그들이 나타나는 순서대로 나열된 관련 분야에 대한 설명의 목록을 나타냅니다. &lt;code&gt;Node&lt;/code&gt; 가 &quot; &lt;code&gt;Label = &amp;lt;em&amp;gt;Value&amp;lt;/em&amp;gt;&lt;/code&gt; &quot;를 나타내는 경우 필드 디스크립터는 &lt;code&gt;{Label, Value}&lt;/code&gt; 쌍 입니다. A에 대한 &lt;code&gt;record_access&lt;/code&gt; 의 노드 &lt;code&gt;Info&lt;/code&gt; 레코드 이름과 필드 이름을 나타냅니다. A에 대한 &lt;code&gt;record_index_expr&lt;/code&gt; 의 노드 &lt;code&gt;Info&lt;/code&gt; 기록 이름과 이름 필드의 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="05b15523ad283b7823b5f85b98edeec8cc75bb7e" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor, the child specification defined in &lt;code&gt;Module:init/1&lt;/code&gt; is used, and &lt;code&gt;ChildSpec&lt;/code&gt; must instead be an arbitrary list of terms &lt;code&gt;List&lt;/code&gt;. The child process is then started by appending &lt;code&gt;List&lt;/code&gt; to the existing start function arguments, that is, by calling &lt;code&gt;apply(M, F, A++List)&lt;/code&gt;, where &lt;code&gt;{M,F,A}&lt;/code&gt; is the start function defined in the child specification.</source>
          <target state="translated">A에 대한 &lt;code&gt;simple_one_for_one&lt;/code&gt; 의 관리자, 아이 스펙에 정의 된 &lt;code&gt;Module:init/1&lt;/code&gt; 사용되며, &lt;code&gt;ChildSpec&lt;/code&gt; 는 대신 용어의 임의의 목록이어야합니다 &lt;code&gt;List&lt;/code&gt; . 그런 다음 자식 프로세스는 기존 시작 함수 인수에 &lt;code&gt;List&lt;/code&gt; 를 추가하여 , 즉 &lt;code&gt;apply(M, F, A++List)&lt;/code&gt; 를 호출 하여 시작됩니다. 여기서 &lt;code&gt;{M,F,A}&lt;/code&gt; 는 자식 스펙에 정의 된 시작 함수입니다. .</target>
        </trans-unit>
        <trans-unit id="e270983e8335179100d9fe3c596f856db2dac6e7" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor, when a child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the functions returns &lt;code&gt;{ok,undefined}&lt;/code&gt; and no child is added to the supervisor.</source>
          <target state="translated">A에 대한 &lt;code&gt;simple_one_for_one&lt;/code&gt; 의 자식 프로세스의 시작 함수가 리턴 할 때 관리자, &lt;code&gt;ignore&lt;/code&gt; , 기능 반환 &lt;code&gt;{ok,undefined}&lt;/code&gt; 와 자식은 관리자에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ab42467cd15c337816dce46f68ae5fa0526b7a1" translate="yes" xml:space="preserve">
          <source>For a complete description of &lt;code&gt;erlc&lt;/code&gt;, see ERTS Reference Manual.</source>
          <target state="translated">&lt;code&gt;erlc&lt;/code&gt; 에 대한 자세한 설명 은 ERTS 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cfb13f0cad02138ad2b995c017356309c3fb172" translate="yes" xml:space="preserve">
          <source>For a complete description of &lt;code&gt;select&lt;/code&gt;, see the &lt;code&gt;ERTS&lt;/code&gt; User's Guide and the &lt;code&gt;ets&lt;/code&gt; manual page in STDLIB.</source>
          <target state="translated">에 대한 자세한 설명은 &lt;code&gt;select&lt;/code&gt; 의 참조 &lt;code&gt;ERTS&lt;/code&gt; 의 사용 설명서와 &lt;code&gt;ets&lt;/code&gt; STDLIB의 매뉴얼 페이지를.</target>
        </trans-unit>
        <trans-unit id="d4b29807f5108ee246627d87dc631fd94fef1892" translate="yes" xml:space="preserve">
          <source>For a complete description of the different format directives, see the &lt;code&gt;&lt;a href=&quot;erl_format&quot;&gt;erl_format&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">다른 형식 지시문에 대한 자세한 설명은 &lt;code&gt;&lt;a href=&quot;erl_format&quot;&gt;erl_format&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="306e8d93b3094a4b0f6ef343b46a328b9a9a6a89" translate="yes" xml:space="preserve">
          <source>For a complete description of the different format directives, see the the &lt;code&gt;&lt;a href=&quot;ei#ei_x_format_wo_ver&quot;&gt;ei_x_format_wo_ver&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">다양한 형식 지시문에 대한 전체 설명은 &lt;code&gt;&lt;a href=&quot;ei#ei_x_format_wo_ver&quot;&gt;ei_x_format_wo_ver&lt;/a&gt;&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6e656123c9eb744a58014f9f51962adfbfc53c6" translate="yes" xml:space="preserve">
          <source>For a complete description, see the &lt;code&gt;&lt;a href=&quot;ei&quot;&gt;ei&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">자세한 설명은 &lt;code&gt;&lt;a href=&quot;ei&quot;&gt;ei&lt;/a&gt;&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d02401677ec9fdd73c5cc9895475609266601522" translate="yes" xml:space="preserve">
          <source>For a complete description, see the following modules:</source>
          <target state="translated">자세한 설명은 다음 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2296648869178ab00c551a675766a922862800d8" translate="yes" xml:space="preserve">
          <source>For a complete list of BIFs, their arguments and return values, see &lt;code&gt;erlang(3)&lt;/code&gt; manual page in ERTS.</source>
          <target state="translated">BIF, 인수 및 리턴 값의 전체 목록은 ERTS의 &lt;code&gt;erlang(3)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b96f9c5fc0fa8fe1d9f6339dc15a2d5f9fb472a" translate="yes" xml:space="preserve">
          <source>For a connecting transport, the RFC 6733 Tc timer, in milliseconds. This timer determines the frequency with which a transport attempts to establish an initial connection with its peer following transport configuration. Once an initial connection has been established, &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; determines the frequency of reconnection attempts, as required by RFC 3539.</source>
          <target state="translated">연결 전송의 경우 RFC 6733 Tc 타이머 (밀리 초)입니다. 이 타이머는 전송이 전송 구성에 따라 피어와 초기 연결을 시도하는 빈도를 결정합니다. 초기 연결이 설정되면 &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; 는 RFC 3539에 필요한 재 연결 빈도를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2ac741d1f7ac505dae5ea4596ab971a0359b710e" translate="yes" xml:space="preserve">
          <source>For a definition of valid regular expressions and options, see the &lt;code&gt;re&lt;/code&gt; module in STDLIB and in particular function &lt;code&gt;re:run/3&lt;/code&gt;.</source>
          <target state="translated">유효한 정규 표현식 및 옵션의 정의는 STDLIB 의 &lt;code&gt;re&lt;/code&gt; 모듈 및 특히 &lt;code&gt;re:run/3&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1778d91027288e89fb9f378857f0ab18d8b8254" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;EventMgrRef&lt;/code&gt; and &lt;code&gt;Handler&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EventMgrRef&lt;/code&gt; 및 &lt;code&gt;Handler&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab206fd61e2b9fddc5eafc5fc27d1c15a0c8fad2" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;EventMgrRef&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EventMgrRef&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61b9134ab4d9675f20b8e73cc84fde0dfc684f51" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;Pattern&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#compile_pattern-1&quot;&gt;compile_pattern/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#compile_pattern-1&quot;&gt;compile_pattern/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96cefa5fc6c0be89204e4398ffcd7b6e931bcbc7" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;Pattern&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#compile_pattern-1&quot;&gt;compile_pattern/1&lt;/a&gt;&lt;/code&gt;. For a description of available options, see &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#compile_pattern-1&quot;&gt;compile_pattern/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 사용 가능한 옵션에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="490301d361c897e86bb808406dd04f853292db16" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;Pattern&lt;/code&gt;, see function &lt;code&gt;&lt;a href=&quot;#compile_pattern-1&quot;&gt;compile_pattern/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#compile_pattern-1&quot;&gt;compile_pattern/1&lt;/a&gt;&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a575b08f9d7b4ad4d20d737daccceca9585ee829" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;PrePurge&lt;/code&gt; and &lt;code&gt;PostPurge&lt;/code&gt;, see &lt;code&gt;update&lt;/code&gt; above.</source>
          <target state="translated">&lt;code&gt;PrePurge&lt;/code&gt; 및 &lt;code&gt;PostPurge&lt;/code&gt; 에 대한 설명은 위의 &lt;code&gt;update&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a65c4f68025c3ad1dd6315d55707a52bb482efc" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;ServerRef&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ServerRef&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2,3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69e223561cb9063324fd12ef476a6b7e069a5ed2" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;StartType&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#Module:start-2&quot;&gt;Module:start/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StartType&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#Module:start-2&quot;&gt;Module:start/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe1c30168853014829ac98827419201235616034" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;StartType&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#start_type&quot;&gt;Module:start/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StartType&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#start_type&quot;&gt;Module:start/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5def873d87cd980e931392839b5cf6d17842f538" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;StartType&lt;/code&gt;, see &lt;code&gt;Module:start/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StartType&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;Module:start/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02838b7512a47b4887b136d17f1d8e29d0d6c42a" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;State&lt;/code&gt; and possible return values, see &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt; Module:handle_event/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 및 가능한 반환 값에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt; Module:handle_event/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7af5f0c5a703d05ffb3c28deb45bb383f51975e7" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;State&lt;/code&gt; and possible return values, see &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 및 가능한 반환 값에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#Module:handle_event-2&quot;&gt;Module:handle_event/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b7a9480404a774f2e01c502c092dc97fed34b5c" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;SupRef&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#SupRef&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SupRef&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#SupRef&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbb94f820b1ff3aee729f5fbaecbcc295c79001a" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;Timeout&lt;/code&gt; and &lt;code&gt;hibernate&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Timeout&lt;/code&gt; 및 &lt;code&gt;hibernate&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21c3e1f1906955603f566457e63cdaa98a428468" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;Type&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="607ab8601660e33550a0e7aea5d949075b3313a3" translate="yes" xml:space="preserve">
          <source>For a description of &lt;code&gt;select&lt;/code&gt; and its syntax, see &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 및 구문에 대한 설명 은 &lt;code&gt;&lt;a href=&quot;mnesia_chap4#matching&quot;&gt;Pattern Matching&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="972aacd0a31b572c0e72a100331a00176bde225a" translate="yes" xml:space="preserve">
          <source>For a description of arguments and return values, see &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 및 리턴 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#start-1&quot;&gt;start/1,2,3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77a1fca3021cb71786aaf6bcae62ca1f3e1b7f33" translate="yes" xml:space="preserve">
          <source>For a description of arguments and return values, see &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 및 리턴 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54f2591ddbc9212139ebbd4e717d510bbe033597" translate="yes" xml:space="preserve">
          <source>For a description of arguments and return values, see &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt;. Note that the return value on successful start differs from &lt;code&gt;start_link/3,4&lt;/code&gt;. &lt;code&gt;start_monitor/3,4&lt;/code&gt; will return &lt;code&gt;{ok,{Pid,Mon}}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the process, and &lt;code&gt;Mon&lt;/code&gt; is a reference to the monitor set up to monitor the process. If the start is not successful, the caller will be blocked until the &lt;code&gt;DOWN&lt;/code&gt; message has been received and removed from the message queue.</source>
          <target state="translated">인수 및 반환 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 성공적인 시작의 반환 값은 &lt;code&gt;start_link/3,4&lt;/code&gt; 와 다릅니다 . &lt;code&gt;start_monitor/3,4&lt;/code&gt; 는 &lt;code&gt;{ok,{Pid,Mon}}&lt;/code&gt; 을 반환합니다. 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 프로세스의 프로세스 식별자이고 &lt;code&gt;Mon&lt;/code&gt; 은 프로세스를 모니터링하도록 설정된 모니터에 대한 참조입니다. 시작에 실패하면 &lt;code&gt;DOWN&lt;/code&gt; 메시지가 수신되어 메시지 대기열에서 제거 될 때까지 발신자가 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="a65de61060f95b87ae5448f9dac49e1374ce925b" translate="yes" xml:space="preserve">
          <source>For a description of arguments and return values, see &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt;. Note that the return value on successful start differs from &lt;code&gt;start_link/3,4&lt;/code&gt;. &lt;code&gt;start_monitor/3,4&lt;/code&gt; will return &lt;code&gt;{ok,{Pid,Mon}}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the server, and &lt;code&gt;Mon&lt;/code&gt; is a reference to the monitor set up to monitor the server. If the start is not successful, the caller will be blocked until the &lt;code&gt;DOWN&lt;/code&gt; message has been received and removed from the message queue.</source>
          <target state="translated">인수 및 반환 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 . 성공적인 시작의 반환 값은 &lt;code&gt;start_link/3,4&lt;/code&gt; 와 다릅니다 . &lt;code&gt;start_monitor/3,4&lt;/code&gt; 는 &lt;code&gt;{ok,{Pid,Mon}}&lt;/code&gt; 을 반환합니다. 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 서버의 프로세스 식별자이고 &lt;code&gt;Mon&lt;/code&gt; 은 서버를 모니터링하도록 설정된 모니터에 대한 참조입니다. 시작에 실패하면 &lt;code&gt;DOWN&lt;/code&gt; 메시지가 수신되어 메시지 대기열에서 제거 될 때까지 발신자가 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="e36c35175840d023a6cf460ade2c4f7beb8f53f1" translate="yes" xml:space="preserve">
          <source>For a description of function declarations, see &lt;code&gt;&lt;a href=&quot;functions&quot;&gt;Function Declaration Syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">함수 선언에 대한 설명은 함수 선언 &lt;code&gt;&lt;a href=&quot;functions&quot;&gt;Function Declaration Syntax&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="880055b3cf6a0908c98848c97c73622b9210c667" translate="yes" xml:space="preserve">
          <source>For a description of match specifications, see section &lt;code&gt; Match Specification in Erlang&lt;/code&gt; in ERTS User's Guide.</source>
          <target state="translated">일치 사양에 대한 설명은 ERTS 사용자 가이드의 &lt;code&gt; Match Specification in Erlang&lt;/code&gt; 에서 일치 사양 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d7cec709f4329f7673af15c7c4c2a2a6bb46704" translate="yes" xml:space="preserve">
          <source>For a description of match specifications, see section &lt;code&gt;Match Specification in Erlang&lt;/code&gt; in ERTS User's Guide.</source>
          <target state="translated">일치 사양에 대한 설명은 ERTS 사용 설명서의 &lt;code&gt;Match Specification in Erlang&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9769bda1585e895e9d31f5c92f3fe2c06aebf820" translate="yes" xml:space="preserve">
          <source>For a description of patterns, see &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">패턴에 대한 설명은 &lt;code&gt;&lt;a href=&quot;ets#match-2&quot;&gt;ets:match/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0eb276490a2f309e043ffe87e763b33c3a8466d" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;match_spec()&lt;/code&gt; syntax, please turn to the &lt;strong&gt;User's guide&lt;/strong&gt; part of the online documentation for the runtime system (&lt;strong&gt;erts&lt;/strong&gt;). The chapter &lt;code&gt;&lt;strong&gt;Match Specifications in Erlang&lt;/strong&gt;&lt;/code&gt; explains the general match specification &quot;language&quot;.</source>
          <target state="translated">&lt;code&gt;match_spec()&lt;/code&gt; 구문에 대한 설명은 런타임 시스템 ( &lt;strong&gt;erts&lt;/strong&gt; ) 온라인 &lt;strong&gt;설명서&lt;/strong&gt; 의 &lt;strong&gt;사용자 안내서&lt;/strong&gt; 부분을 ​​참조하십시오 . &lt;code&gt;&lt;strong&gt;Match Specifications in Erlang&lt;/strong&gt;&lt;/code&gt; 장에서는 일반적인 일치 사양 &quot;언어&quot;에 대해 설명합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7703173998c17ea83511dfa5283d14f4d69fe0c5" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;match_spec()&lt;/code&gt; syntax, please turn to the &lt;strong&gt;User's guide&lt;/strong&gt; part of the online documentation for the runtime system (&lt;strong&gt;erts&lt;/strong&gt;). The chapter &lt;code&gt;&lt;strong&gt;Match Specifications in Erlang&lt;/strong&gt;&lt;/code&gt; explains the general match specification &quot;language&quot;. The most common generic match specifications used can be found as &lt;code&gt;Built-inAlias&lt;/code&gt;', see &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; below for details.</source>
          <target state="translated">&lt;code&gt;match_spec()&lt;/code&gt; 구문에 대한 설명은 런타임 시스템 ( &lt;strong&gt;erts&lt;/strong&gt; ) 온라인 &lt;strong&gt;설명서&lt;/strong&gt; 의 &lt;strong&gt;사용자 안내서&lt;/strong&gt; 부분을 ​​참조하십시오 . &lt;code&gt;&lt;strong&gt;Match Specifications in Erlang&lt;/strong&gt;&lt;/code&gt; 장에서는 일반적인 일치 사양 &quot;언어&quot;에 대해 설명합니다. 사용되는 가장 일반적인 일반 일치 사양은 &lt;code&gt;Built-inAlias&lt;/code&gt; ' 로 찾을 수 있습니다 . 자세한 내용은 아래 &lt;code&gt;&lt;a href=&quot;#ltp-0&quot;&gt;ltp/0&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef4bddbc34a3831351a2641d9658cdebad17c2b8" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;match_spec()&lt;/code&gt; syntax, see section &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; in ERTS, which explains the general match specification &quot;language&quot;.</source>
          <target state="translated">의 설명은 &lt;code&gt;match_spec()&lt;/code&gt; 구문 섹션을 참조 &lt;code&gt;Match Specifications in Erlang&lt;/code&gt; 일반 일치 사양 &quot;언어&quot;를 설명 ERTS에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a4152e6278bbf99749c38b17f7fbc9597385ea1" translate="yes" xml:space="preserve">
          <source>For a description of the I/O protocols, see section &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">I / O 프로토콜에 대한 설명은 사용자 안내서 &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2025b3914c458688da295d428749c8c46542feb5" translate="yes" xml:space="preserve">
          <source>For a description of the arguments and possible return values, see &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 및 가능한 반환 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07949123961391c2673de11e4076e2d60eced05c" translate="yes" xml:space="preserve">
          <source>For a description of the arguments and possible return values, see &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 및 가능한 리턴 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="896f509d9ccaf0cce925a58ea47de82220089a35" translate="yes" xml:space="preserve">
          <source>For a description of the arguments and return values, see &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 및 리턴 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e988f83f81897f6b908cee83257a2be0f550e7ef" translate="yes" xml:space="preserve">
          <source>For a description of the arguments and return values, see &lt;code&gt;&lt;a href=&quot;#start_link-0&quot;&gt;start_link/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 및 리턴 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#start_link-0&quot;&gt;start_link/0,1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6abe4eb3dd1816ae9b28aa6b361027b5c5ebec80" translate="yes" xml:space="preserve">
          <source>For a description of the arguments and return values, see &lt;code&gt;&lt;a href=&quot;#start_link-0&quot;&gt;start_link/0,1&lt;/a&gt;&lt;/code&gt;. Note that the return value on successful start differs from &lt;code&gt;start_link/3,4&lt;/code&gt;. &lt;code&gt;start_monitor/3,4&lt;/code&gt; will return &lt;code&gt;{ok,{Pid,Mon}}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the process, and &lt;code&gt;Mon&lt;/code&gt; is a reference to the monitor set up to monitor the process. If the start is not successful, the caller will be blocked until the &lt;code&gt;DOWN&lt;/code&gt; message has been received and removed from the message queue.</source>
          <target state="translated">인수 및 반환 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#start_link-0&quot;&gt;start_link/0,1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 성공적인 시작의 반환 값은 &lt;code&gt;start_link/3,4&lt;/code&gt; 와 다릅니다 . &lt;code&gt;start_monitor/3,4&lt;/code&gt; 는 &lt;code&gt;{ok,{Pid,Mon}}&lt;/code&gt; 을 반환합니다. 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 프로세스의 프로세스 식별자이고 &lt;code&gt;Mon&lt;/code&gt; 은 프로세스를 모니터링하도록 설정된 모니터에 대한 참조입니다. 시작에 실패하면 &lt;code&gt;DOWN&lt;/code&gt; 메시지가 수신되어 메시지 대기열에서 제거 될 때까지 발신자가 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="8fac05683ef2609d5029a0a282d6ee27b3ebc206" translate="yes" xml:space="preserve">
          <source>For a description of the arguments and return values, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 및 리턴 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62815d91e2c677755f354f11587d1bad01d8fe59" translate="yes" xml:space="preserve">
          <source>For a description of the arguments, see &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97370f5d5dec45b9c04d099eb22590151d2dac21" translate="yes" xml:space="preserve">
          <source>For a description of the arguments, see &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#multi_call-2&quot;&gt;multi_call/2,3,4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0dd5ebe7e70167c0dac796ad7a71ee15f6ab2e3" translate="yes" xml:space="preserve">
          <source>For a description of the options, see &lt;code&gt;&lt;a href=&quot;#string-3&quot;&gt;string/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#string-3&quot;&gt;string/3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe71815d4a82343fc19a1dc26d416bd852b070ef" translate="yes" xml:space="preserve">
          <source>For a description of the options, see &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82fba08ca1d36f58f8a668532aa3bde0a2c58961" translate="yes" xml:space="preserve">
          <source>For a description of the options, see &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01cdab56d71f771d8b6aea711da892d3a1cdab24" translate="yes" xml:space="preserve">
          <source>For a description of the other arguments and possible return values, see &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 인수 및 가능한 반환 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt; Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a38cab08ea388ea4ff5f4107faa8cfc6f6bc618" translate="yes" xml:space="preserve">
          <source>For a description of the other arguments and possible return values, see &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 인수 및 가능한 반환 값에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#Module:handle_call-3&quot;&gt;Module:handle_call/3&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf80ebecef8b5d265aeaf5990098c7c291e8b9fd" translate="yes" xml:space="preserve">
          <source>For a descriptions of options only affecting the compilation step, see &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컴파일 단계에만 영향을 미치는 옵션에 대한 설명은 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55898fdd413ae4d5b8d090755b3edd98ed573b98" translate="yes" xml:space="preserve">
          <source>For a detailed description of each value, see &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">각 값에 대한 자세한 설명은 &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bbac230b9c5ed374fb96bffe873ff96a1cc7a4d" translate="yes" xml:space="preserve">
          <source>For a detailed description of the socket concept, refer to a suitable book about network programming. A suggestion is &lt;strong&gt;UNIX Network Programming, Volume 1: Networking APIs - Sockets and XTI&lt;/strong&gt; by W. Richard Stevens, ISBN: 013490012X.</source>
          <target state="translated">소켓 개념에 대한 자세한 설명은 네트워크 프로그래밍에 대한 적절한 책을 참조하십시오. 제안은 &lt;strong&gt;UNIX 네트워크 프로그래밍, 제 1 권 : 네트워킹 API - 소켓 및 XTI&lt;/strong&gt; W. 리처드 스티븐스, ISBN의 : 013490012X.</target>
        </trans-unit>
        <trans-unit id="844b24c946259dad373327e8abcce2b8c9f7a56f" translate="yes" xml:space="preserve">
          <source>For a detailed description of the syntax and contents of the boot script, see the &lt;code&gt;script(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">부팅 스크립트의 구문과 내용에 대한 자세한 설명은 SASL 의 &lt;code&gt;script(4)&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c3a2ec1b41b2886a58c2dac9a1dc1fff6b51340" translate="yes" xml:space="preserve">
          <source>For a different way to partition a list, see &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목록을 분할하는 다른 방법은 &lt;code&gt;&lt;a href=&quot;#partition-2&quot;&gt;partition/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="720327204417f93293a4c16e172e1d77d48d7e8d" translate="yes" xml:space="preserve">
          <source>For a different way to partition a list, see &lt;code&gt;&lt;a href=&quot;#splitwith-2&quot;&gt;splitwith/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목록을 분할하는 다른 방법은 &lt;code&gt;&lt;a href=&quot;#splitwith-2&quot;&gt;splitwith/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84a9170ca3d20cb888339d1d64eb47f269c521e2" translate="yes" xml:space="preserve">
          <source>For a disk log process to close its file properly and terminate, it must be closed by its owners and once by some non-owner process for each time the log was used anonymously. The users are counted and there must not be any users left when the disk log process terminates.</source>
          <target state="translated">디스크 로그 프로세스가 파일을 올바르게 닫고 종료하려면 로그를 익명으로 사용할 때마다 소유자가 비 소유자 프로세스로 한 번 닫아야합니다. 사용자가 계산되고 디스크 로그 프로세스가 종료 될 때 남아있는 사용자가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="d82511680a1722261769bc6b102aa6073a9d0792" translate="yes" xml:space="preserve">
          <source>For a given hash value, this module finds all consecutive &lt;code&gt;.r*&lt;/code&gt; files starting from zero, and those files taken together make up the revocation list. CRL files whose &lt;code&gt;nextUpdate&lt;/code&gt; fields are in the past, or that are issued by a different CA that happens to have the same name hash, are excluded.</source>
          <target state="translated">지정된 해시 값의 경우이 모듈은 0부터 시작하여 모든 연속 &lt;code&gt;.r*&lt;/code&gt; 파일을 찾고 함께 수집 된 파일은 해지 목록을 구성합니다. &lt;code&gt;nextUpdate&lt;/code&gt; 필드가 과거에 있거나 이름 해시가 동일한 다른 CA에서 발행 한 CRL 파일 은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="13e6867ea0feea22eb209cd61b4c7cf73e7dc73a" translate="yes" xml:space="preserve">
          <source>For a given notification, the variables, which are referred to in the notification specification, must be implemented by the agent that has the MIB loaded, or by some parent to this agent. If not, the application must provide values for the unknown variables. The application must also provide values for all elements in tables.</source>
          <target state="translated">지정된 알림의 경우 알림 사양에서 참조되는 변수는 MIB가로드 된 에이전트 또는이 에이전트의 일부 상위에 의해 구현되어야합니다. 그렇지 않은 경우 응용 프로그램은 알 수없는 변수에 대한 값을 제공해야합니다. 응용 프로그램은 또한 테이블의 모든 요소에 대한 값을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa6d7029778221af0b6b051348c91d7d4a1ea8e5" translate="yes" xml:space="preserve">
          <source>For a large system, it can be interesting to run profiling on a simulated and limited scenario to start with. But bottlenecks have a tendency to appear or cause problems only when many things are going on at the same time, and when many nodes are involved. Therefore, it is also desirable to run profiling in a system test plant on a real target system.</source>
          <target state="translated">대규모 시스템의 경우, 시뮬레이트되고 제한된 시나리오에서 프로파일 링을 실행하는 것이 흥미로울 수 있습니다. 그러나 병목 현상은 많은 일이 동시에 진행되는 경우와 많은 노드가 관련된 경우에만 나타나거나 문제를 일으키는 경향이 있습니다. 따라서 실제 대상 시스템의 시스템 테스트 시스템에서 프로파일 링을 실행하는 것도 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="d49a8a95bc0737d649b2fbd2bd4b9d035a5443d7" translate="yes" xml:space="preserve">
          <source>For a large system, you do not want to run the profiling tools on the whole system. Instead you want to concentrate on central processes and modules, which contribute for a big part of the execution.</source>
          <target state="translated">대규모 시스템의 경우 전체 시스템에서 프로파일 링 도구를 실행하지 않으려 고합니다. 대신 중앙 프로세스 및 모듈에 집중하여 실행의 큰 부분을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="fdc10c07e284d442bea3ecd019955848f9d24a37" translate="yes" xml:space="preserve">
          <source>For a list of supported algorithms, see &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지원되는 알고리즘 목록은 &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports/0&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca81146dd7c61602cc41b80aeaf6d64b40a8421" translate="yes" xml:space="preserve">
          <source>For a list of supported cipher algorithms, see &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지원되는 암호 알고리즘 목록은 &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports/0&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78e02450b6b6baa3722bb81c00b1b5b9b8fb05d2" translate="yes" xml:space="preserve">
          <source>For a list of supported hash algorithms, see &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지원되는 해시 알고리즘 목록은 &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports/0&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="714a3eaa378f818eb6703af10da760265164f5b3" translate="yes" xml:space="preserve">
          <source>For a listening transport, the timer specifies the time after which a previously connected peer will be forgotten: a connection after this time is regarded as an initial connection rather than reestablishment, causing the RFC 3539 state machine to pass to state OKAY rather than REOPEN. Note that these semantics are not governed by the RFC and that a listening transport's &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; should be greater than its peer's Tw plus jitter.</source>
          <target state="translated">수신 전송의 경우 타이머는 이전에 연결된 피어를 잊어 버린 시간을 지정합니다.이 시간 이후의 연결은 재설정이 아닌 초기 연결로 간주되어 RFC 3539 상태 시스템이 REOPEN이 아닌 OKAY 상태로 전달됩니다. 이러한 시맨틱은 RFC에 의해 관리되지 않으며 수신 전송의 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; 는 피어의 Tw + 지터보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="e2f930f2bafc05d5efc3129ac198c5a95bbf17ec" translate="yes" xml:space="preserve">
          <source>For a local &lt;code&gt;{Date1, Time1}&lt;/code&gt; during the period that is repeated when switching &lt;strong&gt;from&lt;/strong&gt; daylight saving time, two corresponding UTCs exist; one for the first instance of the period when daylight saving time is still active, and one for the second instance.</source>
          <target state="translated">일광 절약 시간제 &lt;strong&gt;에서&lt;/strong&gt; 전환 할 때 반복되는 기간 동안 로컬 &lt;code&gt;{Date1, Time1}&lt;/code&gt; 경우 두 개의 해당 UTC가 있습니다. 일광 절약 시간 제가 아직 활성 상태 인 기간의 첫 번째 인스턴스에 대한 하나와 두 번째 인스턴스에 대한 하나입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f5c9a40a6d0b1abd670f673641a58092a5e01f3" translate="yes" xml:space="preserve">
          <source>For a local &lt;code&gt;{Date1, Time1}&lt;/code&gt; during the period that is skipped when switching &lt;strong&gt;to&lt;/strong&gt; daylight saving time, there is no corresponding UTC, as the local time is illegal (it has never occured).</source>
          <target state="translated">일광 절약 시간 제로 전환 &lt;strong&gt;할&lt;/strong&gt; 때 건너 뛴 기간 동안 로컬 &lt;code&gt;{Date1, Time1}&lt;/code&gt; 경우 현지 시간이 잘못되었으므로 해당 UTC가 없습니다 (발생한 적이 없음).&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5900b948715e847445a40b1e46335c73dfd2bc1" translate="yes" xml:space="preserve">
          <source>For a local fun, &lt;code&gt;Item&lt;/code&gt; can also be any of the atoms &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;new_index&lt;/code&gt;, &lt;code&gt;new_uniq&lt;/code&gt;, &lt;code&gt;uniq&lt;/code&gt;, and &lt;code&gt;pid&lt;/code&gt;. For an external fun, the value of any of these items is always the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">로컬 재미를 위해 &lt;code&gt;Item&lt;/code&gt; 은 atoms &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;new_index&lt;/code&gt; , &lt;code&gt;new_uniq&lt;/code&gt; , &lt;code&gt;uniq&lt;/code&gt; 및 &lt;code&gt;pid&lt;/code&gt; 중 하나 일 수 있습니다. 외부 재미의 경우, 이러한 항목 중 하나의 값은 항상 원자 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59175d553d5ac9f663c073d3457b0f82f1a14e36" translate="yes" xml:space="preserve">
          <source>For a minimal example of a CTH, see section &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#example&quot;&gt;Example CTH&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">CTH의 최소 예 는 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#example&quot;&gt;Example CTH&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5585f675767206207308577a771cbf4e880f72a4" translate="yes" xml:space="preserve">
          <source>For a more complete problem statement regarding the URIs check the &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruby-url-problem-01&quot;&gt;URL Problem Statement and Directions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">URI에 대한보다 완전한 문제 설명은 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruby-url-problem-01&quot;&gt;URL Problem Statement and Directions&lt;/a&gt;&lt;/code&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="508a1c392b487cf9efc079e769ab1469c2d35cd4" translate="yes" xml:space="preserve">
          <source>For a more thorough discussion about tail and body recursion, see &lt;code&gt;&lt;a href=&quot;http://ferd.ca/erlang-s-tail-recursion-is-not-a-silver-bullet.html&quot;&gt;Erlang's Tail Recursion is Not a Silver Bullet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테일 및 바디 재귀에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;http://ferd.ca/erlang-s-tail-recursion-is-not-a-silver-bullet.html&quot;&gt;Erlang's Tail Recursion is Not a Silver Bullet&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9b63bb15258354b69beaeb88cbfaea97e07f895" translate="yes" xml:space="preserve">
          <source>For a node &lt;code&gt;Node1&lt;/code&gt; with magic cookie &lt;code&gt;Cookie&lt;/code&gt; to be able to connect to, or accept a connection from, another node &lt;code&gt;Node2&lt;/code&gt; with a different cookie &lt;code&gt;DiffCookie&lt;/code&gt;, the function &lt;code&gt;erlang:set_cookie(Node2, DiffCookie)&lt;/code&gt; must first be called at &lt;code&gt;Node1&lt;/code&gt;. Distributed systems with multiple user IDs can be handled in this way.</source>
          <target state="translated">노드에 대한 &lt;code&gt;Node1&lt;/code&gt; 의 마법 쿠키와 &lt;code&gt;Cookie&lt;/code&gt; 에 연결하거나의 연결, 다른 노드 수용 할 수있는 &lt;code&gt;Node2&lt;/code&gt; 다른 쿠키와 &lt;code&gt;DiffCookie&lt;/code&gt; , 함수 &lt;code&gt;erlang:set_cookie(Node2, DiffCookie)&lt;/code&gt; 처음 호출해야 &lt;code&gt;Node1&lt;/code&gt; . 여러 사용자 ID가있는 분산 시스템을이 방식으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a0a5458d9b5f593066a94861701589b5365d3c63" translate="yes" xml:space="preserve">
          <source>For a process implemented using an OTP behaviour, the behaviour module is the residence module for that process. The callback module is a functional module.</source>
          <target state="translated">OTP 동작을 사용하여 구현 된 프로세스의 경우 동작 모듈은 해당 프로세스의 상주 모듈입니다. 콜백 모듈은 기능 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="6994e723b6ac8455473acb09217de4e1771ef454" translate="yes" xml:space="preserve">
          <source>For a short demonstration of parsing and pretty-printing, simply compile the included module &lt;code&gt;demo.erl&lt;/code&gt;, and execute &lt;code&gt;demo:run()&lt;/code&gt; from the Erlang shell. It will compile the remaining modules and give you further instructions.</source>
          <target state="translated">구문 분석 및 꽤 - 인쇄의 짧은 데모를 들어, 단순히 포함 된 모듈 컴파일 &lt;code&gt;demo.erl&lt;/code&gt; 을 및 실행 &lt;code&gt;demo:run()&lt;/code&gt; 얼랭 셸에서입니다. 나머지 모듈을 컴파일하고 추가 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="77ef8f7ce8a23a6ffa821ec5eea74f8f32b8bf77" translate="yes" xml:space="preserve">
          <source>For a simple example of an FTP session, see &lt;code&gt;&lt;a href=&quot;ftp_client&quot;&gt;FTP User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FTP 세션의 간단한 예는 &lt;code&gt;&lt;a href=&quot;ftp_client&quot;&gt;FTP User's Guide&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e40382adf0258f7ee25b19fc64547696bb518803" translate="yes" xml:space="preserve">
          <source>For a specified error returned by any function in this module, this function returns a descriptive string of the error in English. For file errors, function &lt;code&gt;file:format_error(Posix)&lt;/code&gt; is to be called.</source>
          <target state="translated">이 모듈의 함수가 반환 한 지정된 오류의 경우이 함수는 오류의 설명 문자열을 영어로 반환합니다. 파일 오류의 경우 함수 &lt;code&gt;file:format_error(Posix)&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0592b86931ce428f467579270fb03a409e53a596" translate="yes" xml:space="preserve">
          <source>For a succesful initialization, &lt;code&gt;State&lt;/code&gt; is the initial &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; the initial server &lt;code&gt;&lt;a href=&quot;#type-data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;gen_statem&lt;/code&gt;.</source>
          <target state="translated">성공적인 초기화의 경우 &lt;code&gt;State&lt;/code&gt; 는 초기 &lt;code&gt;&lt;a href=&quot;#type-state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 이고 &lt;code&gt;Data&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 의 초기 서버 &lt;code&gt;&lt;a href=&quot;#type-data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="f4764a0fdb2a7a233cc9fc1526a0311e2a392d00" translate="yes" xml:space="preserve">
          <source>For a table &lt;code&gt;Tab&lt;/code&gt; of type &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;ordered_set&lt;/code&gt;, the function returns the &lt;code&gt;Pos&lt;/code&gt;:th element of the object with key &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;ordered_set&lt;/code&gt; 유형 의 테이블 &lt;code&gt;Tab&lt;/code&gt; 의 경우이 함수는 &lt;code&gt;Key&lt;/code&gt; 키를 사용하여 오브젝트 의 &lt;code&gt;Pos&lt;/code&gt; : th 요소를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="77a7d5095d8b2a32c7db55d348db8fd529dc24c2" translate="yes" xml:space="preserve">
          <source>For a wrap log, both the size and the number of files can always be increased, as long as the number of files does not exceed 65000. If the maximum number of files is decreased, the change is not valid until the current file is full and the log wraps to the next file. The redundant files are removed the next time the log wraps around, that is, starts to log to file number 1.</source>
          <target state="translated">랩 로그의 경우 파일 수가 65000을 초과하지 않는 한 파일 크기와 파일 수를 항상 늘릴 수 있습니다. 최대 파일 수를 줄이면 현재 파일이 가득 찰 때까지 변경 사항이 유효하지 않습니다. 로그가 다음 파일로 줄 바꿈됩니다. 다음에 로그를 감쌀 때 즉, 파일 번호 1에 로그를 시작하면 중복 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f51ff20f17c1a36f5a582229120660a7039e260a" translate="yes" xml:space="preserve">
          <source>For accessing individual attributes, see &lt;code&gt;&lt;a href=&quot;#get_pos-1&quot;&gt;get_pos/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#get_precomments-1&quot;&gt;get_precomments/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_postcomments-1&quot;&gt;get_postcomments/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">개별 속성에 액세스하려면 &lt;code&gt;&lt;a href=&quot;#get_pos-1&quot;&gt;get_pos/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#get_ann-1&quot;&gt;get_ann/1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#get_precomments-1&quot;&gt;get_precomments/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#get_postcomments-1&quot;&gt;get_postcomments/1&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75b8dd1f30ea0f0135327cf538ef37349ea2caf3" translate="yes" xml:space="preserve">
          <source>For all 2-tuples with a list in second position, add atom &lt;code&gt;'marker'&lt;/code&gt; first in the list:</source>
          <target state="translated">두 번째 위치에 목록이있는 모든 2 개의 튜플에 대해 목록에서 먼저 원자 &lt;code&gt;'marker'&lt;/code&gt; 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="5c1ae2321382cf8ef9bdb6fad30d2f45ee293afb" translate="yes" xml:space="preserve">
          <source>For all OAM components, SNMP adaptations are provided. Other adaptations might be defined in the future.</source>
          <target state="translated">모든 OAM 구성 요소에 대해 SNMP 적응이 제공됩니다. 다른 적응은 향후에 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5882391bad4058944412eec531e59f1f05d7f423" translate="yes" xml:space="preserve">
          <source>For all other employees, return &lt;code&gt;{newbie, &amp;lt;employee number&amp;gt;}&lt;/code&gt;, except for those named &lt;code&gt;Smith&lt;/code&gt; as they would be affronted by anything other than the tag &lt;code&gt;guru&lt;/code&gt; and that is also what is returned for their numbers: &lt;code&gt;{guru, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">다른 모든 직원의 경우 태그 &lt;code&gt;guru&lt;/code&gt; 이외의 다른 사람이 직면하고 해당 번호에 대해 반환 되는 &lt;code&gt;Smith&lt;/code&gt; 라는 이름을 제외하고 &lt;code&gt;{newbie, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 반환하십시오. &lt;code&gt;{guru, &amp;lt;employee number&amp;gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f60cd921fc7b5654e104794b14acebabcd91a23" translate="yes" xml:space="preserve">
          <source>For all other local times only one corresponding UTC exists.</source>
          <target state="translated">다른 모든 현지 시간에는 해당 UTC가 하나만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="f473bbb9d26d1a082e9ad8ad3bf78394942ee789" translate="yes" xml:space="preserve">
          <source>For all other values of &lt;code&gt;HandlerId&lt;/code&gt;, this entry adds a new handler, equivalent to calling</source>
          <target state="translated">&lt;code&gt;HandlerId&lt;/code&gt; 의 다른 모든 값에 대해이 항목은 호출하는 것과 동등한 새 핸들러를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e6df2b280a704823a1dc706fc0e1a405b877c277" translate="yes" xml:space="preserve">
          <source>For all these generators except &lt;code&gt;exro928ss&lt;/code&gt; and &lt;code&gt;exsss&lt;/code&gt; the lowest bit(s) has got a slightly less random behaviour than all other bits. 1 bit for &lt;code&gt;exrop&lt;/code&gt; (and &lt;code&gt;exsp&lt;/code&gt;), and 3 bits for &lt;code&gt;exs1024s&lt;/code&gt;. See for example the explanation in the &lt;code&gt;&lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt; Xoroshiro128+ &lt;/a&gt;&lt;/code&gt; generator source code:</source>
          <target state="translated">&lt;code&gt;exro928ss&lt;/code&gt; 및 &lt;code&gt;exsss&lt;/code&gt; 를 제외한 모든 생성기 에서 가장 낮은 비트는 다른 모든 비트보다 약간 덜 임의적 인 동작 을가 집니다. 1 비트 &lt;code&gt;exrop&lt;/code&gt; (및 &lt;code&gt;exsp&lt;/code&gt; ) 및 3 비트 &lt;code&gt;exs1024s&lt;/code&gt; . 예를 들어 &lt;code&gt;&lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt; Xoroshiro128+ &lt;/a&gt;&lt;/code&gt; 생성기 소스 코드 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="366217efd377ef7f12b1d12edb859398720ebe56" translate="yes" xml:space="preserve">
          <source>For all these generators the lowest bit(s) has got a slightly less random behaviour than all other bits. 1 bit for &lt;code&gt;exrop&lt;/code&gt; (and &lt;code&gt;exsp&lt;/code&gt;), and 3 bits for &lt;code&gt;exs1024s&lt;/code&gt;. See for example the explanation in the &lt;code&gt;&lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt; Xoroshiro128+ &lt;/a&gt;&lt;/code&gt; generator source code:</source>
          <target state="translated">이러한 모든 생성기에서 가장 낮은 비트는 다른 모든 비트보다 약간 덜 무작위 적입니다. 1 비트 &lt;code&gt;exrop&lt;/code&gt; (및 &lt;code&gt;exsp&lt;/code&gt; ) 및 3 비트 &lt;code&gt;exs1024s&lt;/code&gt; . 예를 들어 &lt;code&gt;&lt;a href=&quot;http://xoroshiro.di.unimi.it/xoroshiro128plus.c&quot;&gt; Xoroshiro128+ &lt;/a&gt;&lt;/code&gt; 생성기 소스 코드 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b4ace9d1ca2981a9cd18df10d87d29953a8e657" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;expand&lt;/code&gt; operation, function &lt;code&gt;&lt;a href=&quot;#expand-2&quot;&gt;expand/2&lt;/a&gt;&lt;/code&gt; is applied using the specified list of expansions.</source>
          <target state="translated">들어 &lt;code&gt;expand&lt;/code&gt; 동작, 기능 &lt;code&gt;&lt;a href=&quot;#expand-2&quot;&gt;expand/2&lt;/a&gt;&lt;/code&gt; 확장 지정된 목록을 사용하여 적용된다.</target>
        </trans-unit>
        <trans-unit id="d1056b60ca7562b1e4a108dcb68d59293982f277" translate="yes" xml:space="preserve">
          <source>For an Event-Driven State Machine, the input is an event that triggers a &lt;strong&gt;state transition&lt;/strong&gt; and the output is actions executed during the &lt;strong&gt;state transition&lt;/strong&gt;. Analogously to the mathematical model of a Finite State Machine, it can be described as a set of relations of the following form:</source>
          <target state="translated">이벤트 기반 상태 머신의 경우 입력은 &lt;strong&gt;상태 전환&lt;/strong&gt; 을 트리거하는 이벤트 이고 출력은 &lt;strong&gt;상태 전환&lt;/strong&gt; 중에 실행되는 작업 입니다. 유한 상태 기계의 수학적 모델과 유사하게 다음 형식의 관계 집합으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f082714253155e9e4b9c287e894c6d37047edc6" translate="yes" xml:space="preserve">
          <source>For an Event-Driven State Machine, the input is an event that triggers a state transition and the output is actions executed during the state transition. It can analogously to the mathematical model of a Finite-State Machine be described as a set of relations of the following form:</source>
          <target state="translated">이벤트 주도 상태 머신의 경우 입력은 상태 전이를 트리거하는 이벤트이며 출력은 상태 전이 동안 실행되는 조치입니다. 유한 상태 머신의 수학적 모델과 유사하게 다음 형식의 관계 집합으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f6690bd9624d886cabaea6bbcd06b6000537e0" translate="yes" xml:space="preserve">
          <source>For an agent, the &lt;code&gt;contextEngineID&lt;/code&gt; identified by a received message, is always equal to the &lt;code&gt;snmpEngineID&lt;/code&gt; of the agent. Otherwise, the message was not intended for the agent. If the agent is configured with more than one context, the instrumentation code must be able to figure out for which context the request was intended. There is a function &lt;code&gt;snmpa:current_context/0&lt;/code&gt; provided for this purpose.</source>
          <target state="translated">에이전트의 경우 수신 된 메시지로 식별 된 &lt;code&gt;contextEngineID&lt;/code&gt; 는 항상 에이전트 의 &lt;code&gt;snmpEngineID&lt;/code&gt; 와 같습니다 . 그렇지 않으면 메시지가 에이전트를위한 것이 아닙니다. 에이전트가 둘 이상의 컨텍스트로 구성된 경우 계측 코드는 요청이 의도 된 컨텍스트를 파악할 수 있어야합니다. 이를 위해 &lt;code&gt;snmpa:current_context/0&lt;/code&gt; 함수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f3bc2b7de21e05f7d405b9e6a6fb885b43fd40ef" translate="yes" xml:space="preserve">
          <source>For an embedded type of type &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt; in a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, the record name is extended with an underscore and the component name. If the embedded structure is deeper with the &lt;code&gt;SEQUENCE&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, or &lt;code&gt;CHOICE&lt;/code&gt; types in the line, each component name/alternative name is added to the record name.</source>
          <target state="translated">임베디드 타입의 유형의 &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; A의 &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; , 레코드 이름은 밑줄 및 구성 요소 이름으로 확장됩니다. 임베디드 구조가 행에서 &lt;code&gt;SEQUENCE&lt;/code&gt; , &lt;code&gt;SET&lt;/code&gt; 또는 &lt;code&gt;CHOICE&lt;/code&gt; 유형으로 더 깊으 면 각 구성 요소 이름 / 대체 이름이 레코드 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="db9b914a50ea213eeaadf7abbf256885b0534520" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;code&gt;&lt;a href=&quot;using_public_key#hostname_extraction&quot;&gt;Hostname extraction&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">예를 들어, 사용 설명서의 &lt;code&gt;&lt;a href=&quot;using_public_key#hostname_extraction&quot;&gt;Hostname extraction&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9f26ee9e370b307d43358104c78a349a182c793" translate="yes" xml:space="preserve">
          <source>For an example, see section &lt;code&gt;&lt;a href=&quot;ei_users_guide#building_terms_and_patterns&quot;&gt;Building Terms and Patterns&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">예를 들어, 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;ei_users_guide#building_terms_and_patterns&quot;&gt;Building Terms and Patterns&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e73be3dbd6a651b582070d2f47a87461d0211b0c" translate="yes" xml:space="preserve">
          <source>For an inbound message from a transport process, a &lt;code&gt;&lt;a href=&quot;diameter_codec#packet&quot;&gt;diameter_codec:packet()&lt;/a&gt;&lt;/code&gt; must contain the received message in its &lt;code&gt;bin&lt;/code&gt; field. In the case of an inbound request, any value set in the &lt;code&gt;transport_data&lt;/code&gt; field will passed back to the transport module in the corresponding answer message, unless the sender supplies another value.</source>
          <target state="translated">전송 프로세스의 인바운드 메시지의 경우 &lt;code&gt;&lt;a href=&quot;diameter_codec#packet&quot;&gt;diameter_codec:packet()&lt;/a&gt;&lt;/code&gt; 은 수신 된 메시지를 &lt;code&gt;bin&lt;/code&gt; 필드 에 포함해야합니다 . 인바운드 요청의 경우 , 전송자가 다른 값을 제공하지 않으면 &lt;code&gt;transport_data&lt;/code&gt; 필드에 설정된 값 이 해당 응답 메시지의 전송 모듈로 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d90013faa2fae344a51e123e0b2ceb88a7231695" translate="yes" xml:space="preserve">
          <source>For an outbound message to a transport process, a &lt;code&gt;&lt;a href=&quot;diameter_codec#packet&quot;&gt;diameter_codec:packet()&lt;/a&gt;&lt;/code&gt; has a value other than &lt;code&gt;undefined&lt;/code&gt; in its &lt;code&gt;transport_data&lt;/code&gt; field and has the binary() to send in its &lt;code&gt;bin&lt;/code&gt; field.</source>
          <target state="translated">반송 프로세스에 발신 메시지를 들면, &lt;code&gt;&lt;a href=&quot;diameter_codec#packet&quot;&gt;diameter_codec:packet()&lt;/a&gt;&lt;/code&gt; 이 아닌 값 갖는다 &lt;code&gt;undefined&lt;/code&gt; 의로 &lt;code&gt;transport_data&lt;/code&gt; 의 필드와 보내도록 이진 () 보유 &lt;code&gt;bin&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="9eb877ebc99bd1d46e3d1419f5e9e84b1039b246" translate="yes" xml:space="preserve">
          <source>For an unsuccesful initialization, &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt; should be used; see &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">초기화에 실패하면 &lt;code&gt;{stop,Reason}&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 를 사용해야합니다. &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start_link/3,4&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05e3b642659d0707266516623692c824f1087717" translate="yes" xml:space="preserve">
          <source>For an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and for a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the Beam file.</source>
          <target state="translated">업그레이드의 경우 &lt;code&gt;OldVsn&lt;/code&gt; 은 &lt;code&gt;Vsn&lt;/code&gt; 이고 다운 그레이드의 경우 &lt;code&gt;OldVsn&lt;/code&gt; 은 &lt;code&gt;{down,Vsn}&lt;/code&gt; 입니다. &lt;code&gt;Vsn&lt;/code&gt; 은 이전 버전의 콜백 모듈 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;vsn&lt;/code&gt; 속성으로 정의됩니다 . 그러한 속성이 정의되어 있지 않으면 버전은 Beam 파일의 체크섬입니다.</target>
        </trans-unit>
        <trans-unit id="df78f85e8f5b913c9d946f7e5ed39f8ec980c09a" translate="yes" xml:space="preserve">
          <source>For any fun, &lt;code&gt;Item&lt;/code&gt; can be any of the atoms &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;arity&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">재미를 위해 &lt;code&gt;Item&lt;/code&gt; 은 atom &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;arity&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; 또는 &lt;code&gt;type&lt;/code&gt; 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7413767989a803baaf4f577dc5831fc7b5d5d52a" translate="yes" xml:space="preserve">
          <source>For auto-imported BIFs added in Erlang/OTP R14A and thereafter, overriding the name with a local function or explicit import is always allowed. However, if the &lt;code&gt;-compile({no_auto_import,[F/A])&lt;/code&gt; directive is not used, the compiler issues a warning whenever the function is called in the module using the implicitly qualified function name.</source>
          <target state="translated">Erlang / OTP R14A에 추가 된 이후 자동 가져 오기 BIF의 경우 로컬 함수 또는 명시 적 가져 오기로 이름을 대체 할 수 있습니다. 그러나 &lt;code&gt;-compile({no_auto_import,[F/A])&lt;/code&gt; 지시문을 사용하지 않으면 내재적으로 규정 된 함수 이름을 사용하여 함수가 모듈에서 호출 될 때마다 컴파일러에서 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="8ea74c138e3739dc00ed9db86f1e66db5ff4786a" translate="yes" xml:space="preserve">
          <source>For available options see &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;#pkix_test_data-1&quot;&gt;pkix_test_data/1&lt;/a&gt;&lt;/code&gt;.    A root certificate and key. The &lt;code&gt;Key&lt;/code&gt; is generated by &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 옵션은 &lt;code&gt;&lt;a href=&quot;#pkix_test_data-1&quot;&gt;pkix_test_data/1&lt;/a&gt;&lt;/code&gt; 아래의 cert_opt &lt;code&gt;&lt;a href=&quot;#cert_opt&quot;&gt;cert_opt()&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 루트 인증서 및 키 &lt;code&gt;Key&lt;/code&gt; 에 의해 생성되는 &lt;code&gt;&lt;a href=&quot;#generate_key-1&quot;&gt;generate_key/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4e1d64e3d4cecd57f95679cb154ce8f95c46160" translate="yes" xml:space="preserve">
          <source>For background and more examples see the &lt;code&gt;&lt;a href=&quot;configure_algos#introduction&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배경 및 기타 예는 사용 &lt;code&gt;&lt;a href=&quot;configure_algos#introduction&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a65da47a406741061fb683aede365c2f1b59abf" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;Name&lt;/code&gt; is also allowed to be a string. That will probably change in a future release.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;Name&lt;/code&gt; 도 문자열이 될 수 있습니다. 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
