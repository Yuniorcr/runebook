<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="1adf89e8e92228a60dd07895fb1499d746d2f997" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,ANNO,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">T가지도 유형 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 이고 각 &lt;code&gt;A_i&lt;/code&gt; 가 연관 유형이면 Rep (T) = &lt;code&gt;{type,ANNO,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Rep (A)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6a030c9807953845560f8db0809d5cae00b3b69" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">T가 맵 유형 &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;A_i&lt;/code&gt; 는 연관 유형 인 경우 Rep (T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . 담당자 (A)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3d2ad35675d5afe54ca0bd9c3179fed7255c00e" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,map,any}&lt;/code&gt;.</source>
          <target state="translated">T가지도 유형 &lt;code&gt;map()&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,ANNO,map,any}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b831583f902b7b1e825485ae91283de7c5ae12d8" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt;.</source>
          <target state="translated">T가 맵 유형 &lt;code&gt;map()&lt;/code&gt; 인 경우 Rep (T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="393b51301cf31a12b2c86b8f1d9bbdef7251ed54" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 미리 정의 된 (또는 내장 된) 유형 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e65f43c9b04c981a0f08dbd4e0efeaf97f33b27e" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 사전 정의 된 (또는 내장 된) 유형 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; 인 경우 Rep (T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca56d7b0dd371abffc166a298e3aa5c771e44b2d" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,ANNO,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="translated">T가 레코드 유형 &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt; 이고 여기서 각 &lt;code&gt;F_i&lt;/code&gt; 는 레코드 필드 유형 인 경우 Rep (T) = &lt;code&gt;{type,ANNO,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt; . Rep (F)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="81796f903baaa46af3b80b5d8688ebe92b7c0403" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="translated">T가 레코드 유형 &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt; 인 경우, 각 &lt;code&gt;F_i&lt;/code&gt; 는 레코드 필드 유형 인 경우 Rep (T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt; 입니다. 담당자 (F)에 대해서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3222c4ffd098914385913646a36a5eb933808ff6" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,ANNO,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="translated">T가 원격 유형 &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{remote_type,ANNO,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee8d572503b5c61f934efe1a703bfabdb6fef560" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="translated">T가 원격 유형 &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8647f8866bf0895e0a5b40a325be9d138c2a1081" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,tuple,any}&lt;/code&gt;.</source>
          <target state="translated">T가 튜플 유형 &lt;code&gt;tuple()&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,ANNO,tuple,any}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68b1161c8a498bf9c973de5bfb81d671743d9c3d" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt;.</source>
          <target state="translated">T가 튜플 유형 &lt;code&gt;tuple()&lt;/code&gt; 인 경우 Rep (T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="207c50704c87beebe7a6e20ca5b5d3c04f6d1d99" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 튜플 유형 &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,ANNO,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1e4f6cf136dfa1b7d4b66063686fadb91908818" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 튜플 유형 &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a938cb6958277c0935e0d57bb6651a672684a8d4" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 유형 공용체 인 경우 &lt;code&gt;T_1 | ... | T_k&lt;/code&gt; , Rep (T) = &lt;code&gt;{type,ANNO,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39f7c924bddde4fb82ebc04d0dc2ef68e7d3ec80" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 유형 공용체 인 경우 &lt;code&gt;T_1 | ... | T_k&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da23467e91ab40f667601ddef52da4d45d5feefe" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">T가 유형 변수 &lt;code&gt;V&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 인쇄 이름을 가진 원자입니다 . 유형 변수는 밑줄 ( &lt;code&gt;_&lt;/code&gt; )을 제외한 모든 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="04b9ae17be7ca13037caad5b425aea5153523426" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">T가 유형 변수 &lt;code&gt;V&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;A&lt;/code&gt; 는 인쇄 이름이 &lt;code&gt;V&lt;/code&gt; 와 동일한 문자로 구성된 원자입니다 . 유형 변수는 밑줄 ( &lt;code&gt;_&lt;/code&gt; )을 제외한 모든 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="9009a6974b8dc4d03f245e007c8f49b5b6d34b52" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 사용자 정의 유형 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{user_type,ANNO,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11ece75db2c93e58198cc536b47ac3b68361a0ca" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">T가 사용자 정의 유형 &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f07bf781162482afd2013d4024c6c725654680a1" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,ANNO,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">T가 주석이 추가 된 유형 &lt;code&gt;A :: T_0&lt;/code&gt; 이고 여기서 &lt;code&gt;A&lt;/code&gt; 는 변수이면 Rep (T) = &lt;code&gt;{ann_type,ANNO,[Rep(A),Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="308a5eeab7204b0380423b04a4f96b78a2bb9a71" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">T가 주석이 달린 유형 &lt;code&gt;A :: T_0&lt;/code&gt; 이면 &lt;code&gt;A&lt;/code&gt; 는 변수이고 Rep (T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a9ca5d4370f68ffd4aacee2420b758f185ae7c5" translate="yes" xml:space="preserve">
          <source>If T is an atom or integer literal L, then Rep(T) = Rep(L).</source>
          <target state="translated">T가 원자 또는 정수 리터럴 L이면 Rep (T) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="88da671c68682a76fd63acbbd82cd33cfc329377" translate="yes" xml:space="preserve">
          <source>If T is an atom, a character, or an integer literal L, then Rep(T) = Rep(L).</source>
          <target state="translated">T가 원자, 문자 또는 정수 리터럴 L이면 Rep (T) = Rep (L)입니다.</target>
        </trans-unit>
        <trans-unit id="1c0240293ad37bae225227647e0e3b7e2bac07ec" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,ANNO,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="translated">T가 정수 범위 유형 &lt;code&gt;L .. H&lt;/code&gt; 이고 여기서 &lt;code&gt;L&lt;/code&gt; 및 &lt;code&gt;H&lt;/code&gt; 는 단일 정수 유형이면 Rep (T) = &lt;code&gt;{type,ANNO,range,[Rep(L),Rep(H)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ad797cc1858fce32e5e441213921861198714eb2" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="translated">T가 정수 범위 타입 &lt;code&gt;L .. H&lt;/code&gt; 인 경우, &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;H&lt;/code&gt; 는 싱글 톤 정수 타입이면 Rep (T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fc03bf3c127d2db614b6ef5e1997a93c0412bfa2" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,ANNO,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="translated">T가 연산자 유형 &lt;code&gt;Op T_0&lt;/code&gt; 이고 여기서 &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 (컴파일시 정수로 평가 될 수있는 표현식의 발생)이면 Rep (T) = &lt;code&gt;{op,ANNO,Op,Rep(T_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb40c0e15c57779039c33cac1f747c5810dbf6ac" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="translated">T가 연산자 유형 &lt;code&gt;Op T_0&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 단항 연산자 (컴파일시 정수로 평가 될 수있는 표현식의 발생) 인 경우 Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ccf953cec087c4f37edbb5474ed7922f3550a3" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,ANNO,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="translated">T가 연산자 유형 &lt;code&gt;T_1 Op T_2&lt;/code&gt; 이고 여기서 &lt;code&gt;Op&lt;/code&gt; 는 이항 연산자 (컴파일시 정수로 평가 될 수있는 표현식의 발생)이면 Rep (T) = &lt;code&gt;{op,ANNO,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8ff3216bb70a3e5574e4f729d37b4404373ced" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="translated">T가 연산자 유형 &lt;code&gt;T_1 Op T_2&lt;/code&gt; 인 경우, &lt;code&gt;Op&lt;/code&gt; 는 2 진 연산자 (컴파일시 정수로 평가 될 수있는 표현식의 발생) 인 경우 Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0cf8513a746893009eda27d45a4780f2cc888dc" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,ANNO,nil,[]}&lt;/code&gt;, that is, the empty list type &lt;code&gt;[]&lt;/code&gt; cannot be distinguished from the predefined type &lt;code&gt;nil()&lt;/code&gt;.</source>
          <target state="translated">T가 빈 목록 유형 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,ANNO,nil,[]}&lt;/code&gt; , 즉 빈 목록 유형 &lt;code&gt;[]&lt;/code&gt; 은 미리 정의 된 유형 &lt;code&gt;nil()&lt;/code&gt; 과 구별 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="50ad15b3d0471bd3faa5be48d2ae0de7d86566a4" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt;.</source>
          <target state="translated">T가 빈 목록 유형 &lt;code&gt;[]&lt;/code&gt; 이면 Rep (T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a4fd606c5ec8d6d6bb3851df48abcb81b06d7a38" translate="yes" xml:space="preserve">
          <source>If TLS is requested (&lt;code&gt;Bool=true&lt;/code&gt;) then a connecting process should initiate a TLS handshake with the peer and an accepting process should prepare to accept a handshake. A successful handshake should be followed by a &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; message to the parent process. A failed handshake should cause the process to exit.</source>
          <target state="translated">TLS가 요청되면 ( &lt;code&gt;Bool=true&lt;/code&gt; ) 연결 프로세스는 피어와 TLS 핸드 셰이크를 시작해야하며 수락 프로세스는 핸드 셰이크 수락을 준비해야합니다. 성공적인 핸드 셰이크 다음에 상위 프로세스 에 대한 &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 메시지 가 와야 합니다. 핸드 셰이크에 실패하면 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc7d15812f21bafb9f2d4f973c0a1f450ecf989" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A:Value&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom and &lt;code&gt;Value&lt;/code&gt; is an integer, then Rep(TS) = &lt;code&gt;{A,Value}&lt;/code&gt;.</source>
          <target state="translated">TS가 유형 지정자 &lt;code&gt;A:Value&lt;/code&gt; 이며 여기서 &lt;code&gt;A&lt;/code&gt; 는 원자이고 &lt;code&gt;Value&lt;/code&gt; 는 정수이면 Rep (TS) = &lt;code&gt;{A,Value}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0e7b2ba399cca51e247046ccdbff7d00ba5b8ab" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(TS) = &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">TS가 유형 지정자 &lt;code&gt;A&lt;/code&gt; 이고 여기서 &lt;code&gt;A&lt;/code&gt; 가 원자 인 경우 Rep (TS) = &lt;code&gt;A&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cffa66b34c2d2e22ea4103aaa24ab719e89c2fec" translate="yes" xml:space="preserve">
          <source>If Trace Tool Builder is to be used against a remote node, it is highly recommended to start the trace control node as &lt;strong&gt;hidden&lt;/strong&gt;. This way it can connect to the traced node without being &quot;seen&quot; by it, that is, if the &lt;code&gt;nodes()&lt;/code&gt; BIF is called on the traced node, the trace control node does not show. To start a hidden node, add option &lt;code&gt;-hidden&lt;/code&gt; to the &lt;code&gt;erl&lt;/code&gt; command, for example:</source>
          <target state="translated">Trace Tool Builder를 원격 노드에 사용하려면 추적 제어 노드를 &lt;strong&gt;hidden&lt;/strong&gt; 으로 시작하는 것이 좋습니다 . 이렇게하면 추적 된 노드에서 &quot;보이지&quot;않고 추적 된 노드에 연결할 수 있습니다. 즉, 추적 된 노드에서 &lt;code&gt;nodes()&lt;/code&gt; BIF가 호출되면 추적 제어 노드가 표시되지 않습니다. 숨겨진 노드를 시작하려면 &lt;code&gt;-hidden&lt;/code&gt; 과 같이 &lt;code&gt;erl&lt;/code&gt; 명령에 -hidden 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f981e82f10b1b120a81d1801123ff119c9dd5647" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 적용되는 경우 ( &lt;code&gt;erl manual page&lt;/code&gt; ) &lt;code&gt;VarName&lt;/code&gt; 문자열 은 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57716f17031652959455a3f19555742110bf4198" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 적용되는 경우 ( &lt;code&gt;erl manual page&lt;/code&gt; ), 문자열 &lt;code&gt;VarName&lt;/code&gt; 및 &lt;code&gt;Value&lt;/code&gt; 는 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc97ec63a0f0a73856ddcd04133122fc9570583f" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erl manual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 적용되는 경우 ( &lt;code&gt;erl manual page&lt;/code&gt; ) 문자열은 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ab68d3d8a84e8ac67ee4631fedf30ccfba50dcc" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 유효한 경우 ( &lt;code&gt;erlmanual page&lt;/code&gt; ) 문자열 &lt;code&gt;VarName&lt;/code&gt; 은 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="349a1b5c23c6400e11f34baaeede22206381d4e8" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 유효한 경우 ( &lt;code&gt;erlmanual page&lt;/code&gt; ) 문자열 &lt;code&gt;VarName&lt;/code&gt; 및 &lt;code&gt;Value&lt;/code&gt; 는 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8063f0dff7c5946dc972277dda605fd528422b32" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">유니 코드 파일 이름 인코딩이 유효한 경우 ( &lt;code&gt;erlmanual page&lt;/code&gt; ) 문자열에는 코드 포인트가 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50def98f37f2942e5e50a32fd6672fe00221e237" translate="yes" xml:space="preserve">
          <source>If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the &lt;code&gt;fun()&lt;/code&gt; must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &amp;gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8).</source>
          <target state="translated">유니 코드 파일 이름 변환이 적용되고 파일 시스템이 투명하면 유니 코드로 해석 할 수없는 파일 이름이 발생할 수 있습니다.이 경우 원시 파일 이름 (즉, 이진)을 처리 할 수 ​​있도록 &lt;code&gt;fun()&lt;/code&gt; 을 준비해야합니다. 정규식에 코드 포인트&amp;gt; 255가 포함 된 경우 예상 문자 인코딩을 준수하지 않는 (즉, 유효한 UTF-8로 인코딩되지 않은) 파일 이름과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27d8be04dca27e76e1518b6381c78e6ba0f1228a" translate="yes" xml:space="preserve">
          <source>If Unicode filenames are enabled, the calls to &lt;code&gt;os:getenv/0,1&lt;/code&gt;, &lt;code&gt;os:putenv/2&lt;/code&gt;, and &lt;code&gt;os:unsetenv/1&lt;/code&gt; handle Unicode strings. On Unix-like platforms, the built-in functions translate environment variables in UTF-8 to/from Unicode strings, possibly with code points &amp;gt; 255. On Windows, the Unicode versions of the environment system API are used, and code points &amp;gt; 255 are allowed.</source>
          <target state="translated">유니 코드 파일 이름이 활성화되어 있으면 &lt;code&gt;os:getenv/0,1&lt;/code&gt; , &lt;code&gt;os:putenv/2&lt;/code&gt; 및 &lt;code&gt;os:unsetenv/1&lt;/code&gt; 에 대한 호출은 유니 코드 문자열을 처리합니다. Unix와 같은 플랫폼에서 내장 함수는 UTF-8 환경 변수를 코드 포인트가 255보다 큰 유니 코드 문자열로 또는 그로부터 변환합니다. Windows에서는 환경 시스템 API의 유니 코드 버전이 사용되며 코드 포인트&amp;gt; 255 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd5167b3902c5e1022270db7b7037a7e5ba7572" translate="yes" xml:space="preserve">
          <source>If Unicode translation is in effect (&lt;code&gt;~ts&lt;/code&gt;), characters &amp;gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &amp;gt; 255:</source>
          <target state="translated">유니 코드 변환이 유효한 경우 ( &lt;code&gt;~ts&lt;/code&gt; ), 255보다 큰 문자가 허용됩니다. 변환 수정자를 사용하면 반환 된 목록에 정수&amp;gt; 255가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e9eb4fb01bd12ad300a0a96c219b150663189ba" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A :: T&lt;/code&gt; 이고 여기서 &lt;code&gt;T&lt;/code&gt; 는 유형이면 Rep (V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A)},Rep(T)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8109397071948c43826e0713ed25b859b8a44c79" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A :: T&lt;/code&gt; 인 경우, 여기서 &lt;code&gt;T&lt;/code&gt; 는 유형 인 경우 Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb6fe32cd5968d212727cb82bd15e47cc5d23b10" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A = E :: T&lt;/code&gt; 이고 &lt;code&gt;E&lt;/code&gt; 는 표현식이고 &lt;code&gt;T&lt;/code&gt; 는 유형이면 Rep (V) = &lt;code&gt;{typed_record_field,{record_field,ANNO,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7f32a52c794ffe7684b6b2810c41e4682238d59" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A = E :: T&lt;/code&gt; 이며 여기서 &lt;code&gt;E&lt;/code&gt; 는 표현식이고 &lt;code&gt;T&lt;/code&gt; 는 유형 인 경우 Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc17addad3b18cec2f98a0aa96fe46ca497758bf" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,ANNO,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A = E&lt;/code&gt; 이고 &lt;code&gt;E&lt;/code&gt; 는 표현식이면 Rep (V) = &lt;code&gt;{record_field,ANNO,Rep(A),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f396f938bddcba478f3de3dee1d32cdd215e7c9" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A = E&lt;/code&gt; 인 경우 &lt;code&gt;E&lt;/code&gt; 는 표현식 인 경우 Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="530b26a08f1369a0dde3ebbcc4e657abbc43c708" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,ANNO,Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A&lt;/code&gt; 이면 Rep (V) = &lt;code&gt;{record_field,ANNO,Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="46feb36a0599dccd153195f0bebe327e41e1d422" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">V가 &lt;code&gt;A&lt;/code&gt; 이면 Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be88adeac37e6ad073f87c039fc9ee408a3d9604" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, &lt;code&gt;string()&lt;/code&gt; and &lt;code&gt;char()&lt;/code&gt; are allowed to be &amp;gt; 255. See also the documentation of the &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">VM이 유니 코드 파일 이름 모드 인 경우 &lt;code&gt;string()&lt;/code&gt; 및 &lt;code&gt;char()&lt;/code&gt; 는&amp;gt; 255가 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; 유형 의 설명서도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf04572355facf77510f6eb707d8bddd39905f32" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, characters are allowed to be &amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; is a filename not subject to Unicode translation, meaning that it can contain characters not conforming to the Unicode encoding expected from the file system (that is, non-UTF-8 characters although the VM is started in Unicode filename mode). Null characters (integer value zero) are &lt;strong&gt;not&lt;/strong&gt; allowed in filenames (not even at the end).</source>
          <target state="translated">VM이 유니 코드 파일 이름 모드 인 경우 문자는&amp;gt; 255를 &lt;code&gt;RawFilename&lt;/code&gt; 할 수 없습니다 . RawFilename 은 유니 코드 변환이 적용되지 않는 파일 이름입니다 . 즉 파일 시스템에서 예상되는 유니 코드 인코딩을 준수하지 않는 문자 (UTF가 아닌 문자)를 포함 할 수 있습니다. VM이 유니 코드 파일 이름 모드로 시작되었지만 -8 자). 파일 이름 에는 널 문자 (정수 값 0)를 &lt;strong&gt;사용할&lt;/strong&gt; 수 없습니다 (끝까지도).</target>
        </trans-unit>
        <trans-unit id="c6fa19e3c49a3ba084dbfa57062e1a1ae9c3810d" translate="yes" xml:space="preserve">
          <source>If X = Y, then R is called a relation &lt;strong&gt;in&lt;/strong&gt; X.</source>
          <target state="translated">X = Y이면 R &lt;strong&gt;을&lt;/strong&gt; X 에서 관계라고합니다.</target>
        </trans-unit>
        <trans-unit id="00c65a44486df5482c6dc2dd5875d8d6aaf46534" translate="yes" xml:space="preserve">
          <source>If a &quot;traditional&quot; transport is specified (without explicit &lt;code&gt;Kind&lt;/code&gt;, handling both requests and traps) for a transport domain, its &lt;strong&gt;not&lt;/strong&gt; possible to also specify a transport (for that domain) with a specific &lt;code&gt;Kind&lt;/code&gt;. This is for example &lt;strong&gt;not&lt;/strong&gt; allowed:</source>
          <target state="translated">전송 도메인에 대해 &quot;전통적인&quot;전송이 지정된 경우 (명시적인 &lt;code&gt;Kind&lt;/code&gt; 없이 요청과 트랩 모두 처리 ) 특정 &lt;code&gt;Kind&lt;/code&gt; 로 전송 (해당 도메인에 대한)을 지정할 수도 &lt;strong&gt;없습니다&lt;/strong&gt; . 예를 들어 허용 &lt;strong&gt;되지&lt;/strong&gt; 않습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5da42cb98de8f66497fcf02d854f52ee32aab90" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; of length two or more exists through vertex &lt;code&gt;V&lt;/code&gt;, the cycle is returned as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices. If a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; exists, the loop is returned as a list &lt;code&gt;[V]&lt;/code&gt;. If no cycles through &lt;code&gt;V&lt;/code&gt; exist, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; 길이 둘 이상의 버텍스를 통해 존재 &lt;code&gt;V&lt;/code&gt; 사이클이리스트로서 반환한다 &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; 정점. 경우 &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;V&lt;/code&gt; 가 존재 루프리스트로서 반환한다 &lt;code&gt;[V]&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 를 통한 사이클 이 존재 하지 않으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f4c540f1bcb01b8107384c4ecb40a93c9ff68733" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Dir&lt;/code&gt; already exists in the code path, it is removed from the old position.</source>
          <target state="translated">코드 경로에 &lt;code&gt;Dir&lt;/code&gt; 이 이미 있으면 이전 위치에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="74a148d16947689b4aa97fa5371e271e751763f1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function crashes or throws an exception, the original state of the process is unchanged for &lt;code&gt;gen_server&lt;/code&gt;, and &lt;code&gt;gen_statem&lt;/code&gt; processes. For &lt;code&gt;gen_event&lt;/code&gt; processes, a crashing or failing &lt;code&gt;StateFun&lt;/code&gt; function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same &lt;code&gt;gen_event&lt;/code&gt; process.</source>
          <target state="translated">경우 &lt;code&gt;StateFun&lt;/code&gt; 의 기능 충돌 또는 예외를 발생 프로세스의 기존 상태에 대한 변경되지 &lt;code&gt;gen_server&lt;/code&gt; 및 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스. 용 &lt;code&gt;gen_event&lt;/code&gt; 처리하는 충돌 또는 실패 &lt;code&gt;StateFun&lt;/code&gt; 의 기능 수단이 그것이 실패하거나 변하지 충돌시에 작동하고, 특정의 이벤트 핸들러의 상태; 동일한 &lt;code&gt;gen_event&lt;/code&gt; 프로세스에 등록 된 다른 이벤트 핸들러의 상태를 변경하는 데 여전히 성공할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f16194ae42169305df9c2ac40e5f3bc5d8ab5294" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function decides not to effect any change in process state, then regardless of process type, it can return its &lt;code&gt;State&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;StateFun&lt;/code&gt; 함수가 프로세스 상태의 변경에 영향을 미치지 않기로 결정 하면 프로세스 유형에 관계없이 &lt;code&gt;State&lt;/code&gt; 인수를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f3a01e0c748edc694108fe2d71299f36d697f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is specified, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;Tag&lt;/code&gt; 지정된, 반환 된 &lt;code&gt;Match&lt;/code&gt; 또한 일치 포함 &lt;code&gt;Tag&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;RxMatch&lt;/code&gt; 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="71a0319e49e50710f02ee82c0914b94ac22dbba1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is speciifed, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;Tag&lt;/code&gt; speciifed되고, 반환 된 &lt;code&gt;Match&lt;/code&gt; 또한 일치 포함 &lt;code&gt;Tag&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;RxMatch&lt;/code&gt; 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7555617310e8eeba0e7553e2392a16068784c6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Threshold&lt;/code&gt; is specified, the counter is reset to value &lt;code&gt;SetValue&lt;/code&gt; if the following conditions occur:</source>
          <target state="translated">경우 &lt;code&gt;Threshold&lt;/code&gt; 지정되고, 카운터 값이 리셋된다 &lt;code&gt;SetValue&lt;/code&gt; 는 다음의 조건이 발생할 경우 :</target>
        </trans-unit>
        <trans-unit id="a5a595a63e0041392424b473cbdb427fc8601eee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pid()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt;, &lt;code&gt;{in, Location}&lt;/code&gt;, and &lt;code&gt;{out, Location}&lt;/code&gt; are present, where &lt;code&gt;Location&lt;/code&gt; is either an MFA (&lt;code&gt;{Module, Function, Arity}&lt;/code&gt;) describing the function where the process was scheduled in/out, or the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pid()&lt;/code&gt; 은 튜플 &lt;code&gt;{timeout, Millis}&lt;/code&gt; , &lt;code&gt;{in, Location}&lt;/code&gt; , 및 &lt;code&gt;{out, Location}&lt;/code&gt; 존재, &lt;code&gt;Location&lt;/code&gt; (어느 쪽 MFA 인 &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; 기능을 설명) 여기서 프로세스 in / out으로 예약되었거나 원자 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68177e2c897ada3a2210fd2fd1b8bee05a073d3a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;port()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt; and &lt;code&gt;{port_op,Op}&lt;/code&gt; are present. &lt;code&gt;Op&lt;/code&gt; is one of &lt;code&gt;proc_sig&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;event&lt;/code&gt;, or &lt;code&gt;dist_cmd&lt;/code&gt;, depending on which driver callback was executing.</source>
          <target state="translated">경우 &lt;code&gt;port()&lt;/code&gt; 은 튜플 &lt;code&gt;{timeout, Millis}&lt;/code&gt; 및 &lt;code&gt;{port_op,Op}&lt;/code&gt; 이 존재한다. &lt;code&gt;Op&lt;/code&gt; 는 실행중인 드라이버 콜백에 따라 &lt;code&gt;proc_sig&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;output&lt;/code&gt; , &lt;code&gt;event&lt;/code&gt; 또는 &lt;code&gt;dist_cmd&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="793f68726c5cebcf04eed2e69bb996595dba56b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;property_parm()&lt;/code&gt; is found as part of the input (&lt;code&gt;SDP&lt;/code&gt;) then it is left unchanged.</source>
          <target state="translated">경우 &lt;code&gt;property_parm()&lt;/code&gt; 입력 (일부로 발견 &lt;code&gt;SDP&lt;/code&gt; 그럼 그대로 남아).</target>
        </trans-unit>
        <trans-unit id="85b487c95345f7250096baeb7f6ceb5385465d9a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pwdfun&lt;/code&gt; is defined, that one is called and the returned boolean is the authentication result.</source>
          <target state="translated">경우 &lt;code&gt;pwdfun&lt;/code&gt; 가 정의되어 하나가 호출되고 반환 된 부울는 인증 결과입니다.</target>
        </trans-unit>
        <trans-unit id="64a1cdf79545c23e02941821b867906efcc046dd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;relup&lt;/code&gt; file and/or a system configuration file called &lt;code&gt;sys.config&lt;/code&gt;, or a &lt;code&gt;sys.config.src&lt;/code&gt;, is found, these files are also included in the release package. See &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;relup&lt;/code&gt; 의 파일 및 / 또는이라는 시스템 구성 파일 &lt;code&gt;sys.config&lt;/code&gt; , 또는 &lt;code&gt;sys.config.src&lt;/code&gt; 이 발견되어,이 파일은 릴리스 패키지에 포함되어 있습니다. &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90bab5222409642ed3e9b025afcf25e28ff5080e" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; and no message is placed in the buffer. Also, &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EAGAIN&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;strong&gt;틱이&lt;/strong&gt; 발생, 즉, 연결의 다른 쪽 끝에있는 얼랑 노드가 아직 살아 있는지를보기 위해 노드를 폴링하고있다, 함수는 반환 &lt;code&gt;ERL_TICK&lt;/code&gt; 어떠한 메시지 버퍼에 저장되지 않습니다. 또한 &lt;code&gt;erl_errno&lt;/code&gt; 는 &lt;code&gt;EAGAIN&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="20a48a4a5f7af813214b4a1f7a53e0d6d083deb2" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; indicating that the tick has been received and responded to, but no message is placed in the buffer. In this case you are to call &lt;code&gt;erl_receive_msg()&lt;/code&gt; again.</source>
          <target state="translated">&lt;strong&gt;틱이&lt;/strong&gt; 발생 하는 경우, 즉 연결의 다른 쪽 끝에있는 Erlang 노드가이 노드를 폴링하여 여전히 &lt;code&gt;ERL_TICK&lt;/code&gt; 인지 확인한 경우, 틱이 수신되어 응답했지만 메시지가 배치되지 않았 음을 나타내는 ERL_TICK을 리턴합니다. 버퍼에. 이 경우 &lt;code&gt;erl_receive_msg()&lt;/code&gt; 다시 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="688f42cde6aa17e471ac615786a4c6b4015e0179" translate="yes" xml:space="preserve">
          <source>If a URI component has a character that is not allowed, it will be percent-encoded when the URI is produced:</source>
          <target state="translated">URI 구성 요소에 허용되지 않는 문자가있는 경우 URI가 생성 될 때 백분율로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="f4364cbd8c0d3d620c728241f3c91ca9a0df5663" translate="yes" xml:space="preserve">
          <source>If a binary is sent as a message to a process or port, the binary will be shrunk and any further append operation will copy the binary data into a new binary. For example, in the following code fragment &lt;code&gt;Bin1&lt;/code&gt; will be copied in the third line:</source>
          <target state="translated">바이너리가 프로세스 또는 포트에 메시지로 전송되면 바이너리는 축소되고 추가 작업을 수행하면 바이너리 데이터가 새로운 바이너리로 복사됩니다. 예를 들어 다음 코드 조각에서 &lt;code&gt;Bin1&lt;/code&gt; 은 세 번째 줄에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="5090ad34e0febaa291c69020c02b54e9b3cafd88" translate="yes" xml:space="preserve">
          <source>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt;. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</source>
          <target state="translated">이진이 더 큰 이진을 참조하는 경우 (종종 이진이라고도 함) 참조 된 이진의 크기를 얻는 것이 유용 할 수 있습니다. 이 기능은 프로그램에서 &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; 사용을 트리거하는 데 사용할 수 있습니다 . 이진을 복사함으로써, 작은 이진이 참조하는 원래, 아마도 큰 이진을 역 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcde4e46ca8a493fcb199170b76f962a5fc5534f" translate="yes" xml:space="preserve">
          <source>If a call is added to this function, say in module &lt;code&gt;m1&lt;/code&gt;, a runtime error could can occur during release upgrade if the new version of &lt;code&gt;m1&lt;/code&gt; is loaded first and calls &lt;code&gt;ch3:available/0&lt;/code&gt; before the new version of &lt;code&gt;ch3&lt;/code&gt; is loaded.</source>
          <target state="translated">통화가이 기능에 추가되어있는 경우, 모듈에 말 &lt;code&gt;m1&lt;/code&gt; 의 새로운 버전의 경우, 런타임 오류가 릴리스 업그레이드하는 동안 발생할 수있는 수 &lt;code&gt;m1&lt;/code&gt; 처음로드 및 호출이됩니다 &lt;code&gt;ch3:available/0&lt;/code&gt; 의 새 버전 전에 &lt;code&gt;ch3&lt;/code&gt; 로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d672e9be794bb20d13fca259b638d9872ca48c52" translate="yes" xml:space="preserve">
          <source>If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</source>
          <target state="translated">TFTP 서버에서 파일 액세스를 수행하는 콜백이 너무 오래 걸리면 (더블 TFTP 시간 초과) 서버가 연결을 중단하고 클라이언트에 오류 응답을 보냅니다. 이는 서버가 이전보다 더 빠르게 연결에 연결된 리소스를 해제 함을 의미합니다. 서버는 단순히 클라이언트가 포기했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b5299cdbeb0a91fc95e90dba08d8ca1a2663ba62" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_server&lt;/code&gt; process terminates.</source>
          <target state="translated">콜백 함수가 실패하거나 잘못된 값을 반환하면 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e4e015fa7495e24f93ba1b6d6271a425520bd035" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_statem&lt;/code&gt; terminates, unless otherwise stated. However, an exception of class &lt;code&gt;throw&lt;/code&gt; is not regarded as an error but as a valid return from all callback functions.</source>
          <target state="translated">콜백 함수가 실패하거나 잘못된 값을 반환하면 별도로 명시하지 않는 한 &lt;code&gt;gen_statem&lt;/code&gt; 이 종료됩니다. 그러나 클래스 &lt;code&gt;throw&lt;/code&gt; 예외 는 오류로 간주되지 않고 모든 콜백 함수의 유효한 반환으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6c6d4e44bcb4f44a78613ffcfcc49d8fc1ed0e" translate="yes" xml:space="preserve">
          <source>If a carrier employed by a foreign allocator becomes empty, it will be passed back to the owner for deallocation using the delayed dealloc functionality.</source>
          <target state="translated">외부 할당자가 사용하는 캐리어가 비어 있으면 지연된 할당 해제 기능을 사용하여 할당 해제를 위해 소유자에게 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4900c7b9d94d3b64a0cfc23cc79861beaa9067fc" translate="yes" xml:space="preserve">
          <source>If a carrier in the pool becomes empty, it will be withdrawn from the pool and be deallocated by the owner which already employs it.</source>
          <target state="translated">풀의 캐리어가 비게되면 풀에서 인출되고 이미 사용하고있는 소유자가 할당을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="d2220ee07a02652209f14bbc36c9099d4b6fe0ac" translate="yes" xml:space="preserve">
          <source>If a child process terminates, all other child processes are terminated, and then all child processes, including the terminated one, are restarted.</source>
          <target state="translated">하위 프로세스가 종료되면 다른 모든 하위 프로세스가 종료 된 후 종료 된 프로세스를 포함하여 모든 하위 프로세스가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c437f353a175442240ea2029595a8633f65dff" translate="yes" xml:space="preserve">
          <source>If a child process terminates, only that process is restarted.</source>
          <target state="translated">하위 프로세스가 종료되면 해당 프로세스 만 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7507b23dc1b78f0736fa82a074e0d7da39372d83" translate="yes" xml:space="preserve">
          <source>If a child process terminates, the rest of the child processes (that is, the child processes after the terminated process in start order) are terminated. Then the terminated child process and the rest of the child processes are restarted.</source>
          <target state="translated">하위 프로세스가 종료되면 나머지 하위 프로세스 (즉, 종료 된 프로세스 이후의 하위 프로세스가 시작 순서로 종료 됨)가 종료됩니다. 그런 다음 종료 된 하위 프로세스 및 나머지 하위 프로세스가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d930d204b5a28f5ad0b963925f58f75368275cfb" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to a TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="translated">클라이언트와 서버가 RFC 2817에 정의 된 것과 같은 업그레이드 메커니즘을 사용하여 일반 TCP / IP 연결을 TLS 연결로 업그레이드하려는 경우 이는 Erlang SSL 애플리케이션 API에서 지원됩니다. 예를 들어 동일한 포트에서 HTTP 및 HTTPS를 지원하고 가상 호스팅을 구현하는 데 유용 할 수 있습니다. 이것은 TLS 기능 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="30f0124339350cc4e352e860e84fd95007fc0287" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="translated">클라이언트와 서버가 RFC 2817에서 정의한 업그레이드 메커니즘을 사용하여 일반 TCP / IP 연결을 TLS 연결로 업그레이드하려는 경우 Erlang SSL 응용 프로그램 API에서 지원됩니다. 예를 들어 동일한 포트에서 HTTP 및 HTTPS를 지원하고 가상 호스팅을 구현하는 데 유용 할 수 있습니다. 이것은 TLS 기능 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="6fb7903555258379fa86ef3cac0cdacd6a86b7aa" translate="yes" xml:space="preserve">
          <source>If a client is started (ssh:connect et al), the environment variable &lt;code&gt;client_options&lt;/code&gt; is used. Similarly for a daemon the &lt;code&gt;server_options&lt;/code&gt; variable is handled.</source>
          <target state="translated">클라이언트가 시작되면 (ssh : connect 등) 환경 변수 &lt;code&gt;client_options&lt;/code&gt; 가 사용됩니다. 마찬가지로 데몬의 경우 &lt;code&gt;server_options&lt;/code&gt; 변수가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf674d6f811a6898fedc16a08be96658f66f44f" translate="yes" xml:space="preserve">
          <source>If a client sends more than one of the header fields that restricts the servers right to respond, the standard does not specify how this is to be handled. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; controls each field in the following order and if one of the fields does not match the current state, the request is rejected with a proper response:</source>
          <target state="translated">클라이언트가 서버의 응답 권한을 제한하는 헤더 필드 중 하나 이상을 전송하는 경우 표준에서는이를 처리하는 방법을 지정하지 않습니다. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; 는 다음 순서로 각 필드를 제어하며 필드 중 하나가 현재 상태와 일치하지 않으면 적절한 응답으로 요청이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="e27ccd3f361e3a3fbab2cff1701eede9199b66b3" translate="yes" xml:space="preserve">
          <source>If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module &lt;code&gt;user_default&lt;/code&gt;, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module &lt;code&gt;shell_default&lt;/code&gt;. Module &lt;code&gt;user_default&lt;/code&gt; must be explicitly loaded.</source>
          <target state="translated">쉘이 명령 (로컬 함수 호출)을 인식하지 못하면 먼저 &lt;code&gt;user_default&lt;/code&gt; 모듈에서 함수를 찾으려고 시도하며 , 여기서 사용자 정의 된 로컬 명령을 배치 할 수 있습니다. 발견되면 함수가 평가되고, 그렇지 않으면 &lt;code&gt;shell_default&lt;/code&gt; 모듈의 함수를 평가하려고 시도 합니다. &lt;code&gt;user_default&lt;/code&gt; 모듈을 명시 적으로로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="c36c504c5a55c7d3e1004baa209d8df31f96a326" translate="yes" xml:space="preserve">
          <source>If a comment selecting the &lt;code&gt;encoding&lt;/code&gt; exists, it can be located on the second line.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; 선택하는 주석이 있으면 두 번째 줄에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81cca8ba4d8e6db9b3078f3494bdf4b64a21625a" translate="yes" xml:space="preserve">
          <source>If a complete system consists of disk-less and/or read-only client nodes, a &lt;code&gt;clients&lt;/code&gt; directory is to be added to the &lt;code&gt;$ROOT&lt;/code&gt; directory. A read-only node is a node with a read-only file system.</source>
          <target state="translated">완전한 시스템이 디스크없는 및 / 또는 읽기 전용 클라이언트 노드로 구성된 경우, &lt;code&gt;clients&lt;/code&gt; 디렉토리가 &lt;code&gt;$ROOT&lt;/code&gt; 디렉토리에 추가됩니다 . 읽기 전용 노드는 읽기 전용 파일 시스템이있는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="114507e06ec8251c1f8b58a05d6e95c9f0294db1" translate="yes" xml:space="preserve">
          <source>If a compressed stream with a larger window size is specified as input, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; throws the &lt;code&gt;data_error&lt;/code&gt; exception.</source>
          <target state="translated">창 크기가 더 큰 압축 스트림이 입력으로 지정되면 &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;data_error&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d5d1665dab7973da2ee300d7146a8bea80f54e0b" translate="yes" xml:space="preserve">
          <source>If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched.</source>
          <target state="translated">일치하는 하위 패턴에 대한 조건 테스트가 고유하지 않은 숫자를 참조하는 경우 해당 숫자의 하위 패턴이 일치하면 테스트가 참입니다.</target>
        </trans-unit>
        <trans-unit id="54dcbb12cbe33c06847716fee8fa5d710e5db085" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files and you want to access all possible values, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; and specify &lt;code&gt;all&lt;/code&gt; in the options list. The values are then returned in a list and the order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">구성 변수가 여러 파일에 정의되어 있고 가능한 모든 값에 액세스하려는 경우 함수 &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; 를 사용 하고 옵션 목록에서 &lt;code&gt;all&lt;/code&gt; 를 지정 하십시오. 그런 다음 값이 목록으로 리턴되고 요소 순서는 시작시 구성 파일이 지정된 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0feca975d542bb0cc969b217767e215cd1ff5ce8" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files, use option &lt;code&gt;all&lt;/code&gt; to access all possible values. The values are returned in a list. The order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">구성 변수가 여러 파일에 정의 된 경우 &lt;code&gt;all&lt;/code&gt; 옵션 을 사용하여 가능한 모든 값에 액세스하십시오. 값이 목록으로 반환됩니다. 요소의 순서는 시작시 구성 파일이 지정된 순서에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="1b9661fe7033eba3fb41e53ee1dcb7e1bb7fe5b9" translate="yes" xml:space="preserve">
          <source>If a configuration variable key has been associated with a name (by &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement), the name can be used instead of the key to read the value:</source>
          <target state="translated">구성 변수 키가 이름과 연관된 경우 ( &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 문으로) 키 대신 이름을 사용하여 값을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3f8db667e8bd436b47dbf9ca11fe7bcf52f5e1" translate="yes" xml:space="preserve">
          <source>If a connection attempt fails, the following can be checked:</source>
          <target state="translated">연결 시도가 실패하면 다음을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f616a997808c9474daa0409579dbb91fef959e" translate="yes" xml:space="preserve">
          <source>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all &lt;code&gt;load_object_code&lt;/code&gt; instructions.</source>
          <target state="translated">이 명령 후에 충돌이 발생하면 시스템을 복구 할 수 없으며 이전 릴리스 버전에서 다시 시작됩니다. 명령은 스크립트에서 한 번만 발생해야합니다. 모든 &lt;code&gt;load_object_code&lt;/code&gt; 명령 뒤에 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="a2df1e7bdcf4b38219e76db42a7407ed6f3a44c6" translate="yes" xml:space="preserve">
          <source>If a crash occurs, an &lt;code&gt;erl_crash.dump&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; written unless environment variable &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is set:</source>
          <target state="translated">충돌이 발생하면 환경 변수 &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; 가 설정 되지 않으면 &lt;code&gt;erl_crash.dump&lt;/code&gt; 가 작성되지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="990352c71d728a05d2ecb284bad93c6958f6c7e3" translate="yes" xml:space="preserve">
          <source>If a custom CLI is installed (see the option &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt;) the rules above are replaced by thoose implied by the custom CLI.</source>
          <target state="translated">사용자 정의 CLI가 설치된 경우 (옵션 &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt; 참조 ) 위의 규칙은 사용자 정의 CLI에 의해 암시 된 것으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="a77a173e95ad2269f4f246fd4ce1b5864fc76ada" translate="yes" xml:space="preserve">
          <source>If a default object &lt;code&gt;Default&lt;/code&gt; is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them.</source>
          <target state="translated">기본 개체 &lt;code&gt;Default&lt;/code&gt; 가 지정되면 키가 테이블에서 누락 된 경우 업데이트 할 개체로 사용됩니다. 키 대신 값이 무시되고 적절한 키 값으로 대체됩니다. 리턴 값은 기본 오브젝트가 사용되지 않은 것처럼 (즉, 단일 업데이트 된 요소 또는 해당 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="fedf7b02f05498afd04860368d31fbddefe371d5" translate="yes" xml:space="preserve">
          <source>If a directory is limited both by authentication directives in the HTTP server configuration file and by the &lt;code&gt;htaccess&lt;/code&gt; files, the user must be allowed to get access to the file by both methods for the request to succeed.</source>
          <target state="translated">HTTP 서버 구성 파일의 인증 지시문과 &lt;code&gt;htaccess&lt;/code&gt; 파일 모두에 의해 디렉토리가 제한되는 경우 , 사용자는 요청이 성공하기 위해 두 가지 방법으로 파일에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="06b77a14a9631e3efe172824e4438ea9844c1c57" translate="yes" xml:space="preserve">
          <source>If a disaster occurs and the &lt;code&gt;Mnesia&lt;/code&gt; database is corrupted, it can be reconstructed from a backup. Regard this as a last resort, as the backup contains old data. The data is hopefully consistent, but data is definitely lost when an old backup is used to restore the database.</source>
          <target state="translated">재해가 발생하고 &lt;code&gt;Mnesia&lt;/code&gt; 데이터베이스가 손상된 경우 백업에서 재구성 할 수 있습니다. 백업에 오래된 데이터가 포함되어 있으므로이를 최후의 수단으로 간주하십시오. 데이터는 일관성있게 유지되지만 이전 백업을 사용하여 데이터베이스를 복원하면 데이터가 확실히 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3cf29891ec99694dc2c7c6253ad367ac7a3461" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node is about to start, file &lt;code&gt;start_erl.data&lt;/code&gt; is located in the client directory at the master node. Thus, the &lt;code&gt;START_ERL_DATA&lt;/code&gt; line is to look like:</source>
          <target state="translated">디스크없는 및 / 또는 읽기 전용 클라이언트 노드가 시작 &lt;code&gt;start_erl.data&lt;/code&gt; 파일 이 마스터 노드의 클라이언트 디렉토리에 있습니다. 따라서 &lt;code&gt;START_ERL_DATA&lt;/code&gt; 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82a0e287fdd1e5f6d5eb37393a55caeaa8bd420e" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node with the SASL configuration parameter &lt;code&gt;static_emulator&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is about to start, the &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; flags must be changed.</source>
          <target state="translated">SASL 구성 매개 변수 &lt;code&gt;static_emulator&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 디스크없는 및 / 또는 읽기 전용 클라이언트 노드가 시작 되려는 경우 &lt;code&gt;-boot&lt;/code&gt; 및 &lt;code&gt;-config&lt;/code&gt; 플래그를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="727df7ab6749918e93887b82b12046b24dcb7655" translate="yes" xml:space="preserve">
          <source>If a driver is used in a functional way (that is, holds no state, but only does some heavy calculation and returns a result), several ports with registered names can be opened beforehand, and the port to be used can be chosen based on the scheduler ID as follows:</source>
          <target state="translated">드라이버가 기능적인 방식으로 사용되는 경우 (즉, 상태를 유지하지 않지만 일부 계산 만 수행하고 결과를 반환하는 경우) 등록 된 이름을 가진 여러 포트를 미리 열어서 사용할 포트를 기반으로 선택할 수 있습니다 스케줄러 ID는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f6d6f3cd21444705a34e8bba2dffb954001faed" translate="yes" xml:space="preserve">
          <source>If a feature has been added in R13A or later, this is mentioned in the text.</source>
          <target state="translated">기능이 R13A 이상에 추가 된 경우 텍스트에 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="34f202d62579e4feee1dfdcda9ab5acaef776ff3" translate="yes" xml:space="preserve">
          <source>If a filename is specified as argument, Debugger tries to load its settings from this file. For details about settings, see the User's Guide.</source>
          <target state="translated">파일 이름이 인수로 지정된 경우 디버거는이 파일에서 해당 설정을로드하려고합니다. 설정에 대한 자세한 내용은 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea25cbb8b26670068e8ad47b07d6ef15d55f99f4" translate="yes" xml:space="preserve">
          <source>If a filter or handler still crashes, Logger will remove the filter or handler in question from the configuration, and print a short error message to the terminal. A debug event containing the crash reason and other details is also issued.</source>
          <target state="translated">필터 또는 처리기가 여전히 충돌하는 경우 Logger는 해당 필터 또는 처리기를 구성에서 제거하고 짧은 오류 메시지를 터미널에 인쇄합니다. 충돌 이유 및 기타 세부 사항이 포함 된 디버그 이벤트도 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="cceb2b6f7ec210d1178bfcad319491366c2280e9" translate="yes" xml:space="preserve">
          <source>If a fun is already registered when attempting to register a fun, &lt;code&gt;{error, exists}&lt;/code&gt; is returned.</source>
          <target state="translated">재미 등록을 시도 할 때 이미 재미가 등록 된 경우 &lt;code&gt;{error, exists}&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="369b66436bacc61b5a02e5467b68ce2d193e98ed" translate="yes" xml:space="preserve">
          <source>If a function is specified as input and the last input function returns &lt;code&gt;{end_of_input, Value}&lt;/code&gt;, the function specified as output is called with argument &lt;code&gt;{value, Value}&lt;/code&gt;. This makes it easy to initiate the sequence of output functions with a value calculated by the input functions.</source>
          <target state="translated">함수가 입력으로 지정되고 마지막 입력 함수가 &lt;code&gt;{end_of_input, Value}&lt;/code&gt; 리턴 하면, 출력으로 지정된 함수는 &lt;code&gt;{value, Value}&lt;/code&gt; 인수와 함께 호출됩니다 . 이를 통해 입력 기능으로 계산 된 값으로 일련의 출력 기능을 쉽게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ebc3e92f35620a8a503c6277f4b94fd5dcf6d25" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system results in the allocated size of a heap being at least &lt;code&gt;Size&lt;/code&gt; words, a message &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; and &lt;code&gt;Info&lt;/code&gt; are the same as for &lt;code&gt;long_gc&lt;/code&gt; earlier, except that the tuple tagged with &lt;code&gt;timeout&lt;/code&gt; is not present.</source>
          <target state="translated">시스템의 가비지 콜렉션으로 인해 힙의 할당 된 크기가 최소 &lt;code&gt;Size&lt;/code&gt; 단어 인 경우 &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;GcPid&lt;/code&gt; 및 &lt;code&gt;Info&lt;/code&gt; 는 &lt;code&gt;timeout&lt;/code&gt; 태그가 지정된 튜플 이 존재하지 않는다는 점을 제외하면 &lt;code&gt;long_gc&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="0fa572748a61109872681b645add693c92c91ac0" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system takes at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; is the pid that was garbage collected. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the result of the garbage collection.</source>
          <target state="translated">시스템의 가비지 콜렉션이 최소 &lt;code&gt;Time&lt;/code&gt; 벽시계 밀리 초를 소요하면 &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;GcPid&lt;/code&gt; 는 가비지 수집 된 pid입니다. &lt;code&gt;Info&lt;/code&gt; 는 가비지 콜렉션의 결과를 설명하는 2 요소 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9fc0db6a6ffa20f6ce91fac40d2bed50efc41760" translate="yes" xml:space="preserve">
          <source>If a given module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈이 Cover 컴파일되지 않은 경우 오류 이유 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="1fd4da11cbcec24fe617e2cfb21bda9700c3ceef" translate="yes" xml:space="preserve">
          <source>If a group contains subgroups, the execution properties for these can also be specified in the group tuple: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; Where, &lt;code&gt;SubGroups&lt;/code&gt; is a list of tuples, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; or &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; representing the subgroups. Any subgroups defined in &lt;code&gt;group/0&lt;/code&gt; for a group, that are not specified in the &lt;code&gt;SubGroups&lt;/code&gt; list, executes with their predefined properties.</source>
          <target state="translated">그룹에 하위 그룹이 포함 된 경우 이들 그룹의 실행 속성을 그룹 튜플에 지정할 수도 있습니다. &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; 여기서 &lt;code&gt;SubGroups&lt;/code&gt; 는 튜플 목록, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; 또는 &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; 부분 군을 나타냅니다. &lt;code&gt;SubGroups&lt;/code&gt; 목록에 지정되지 않은 그룹에 대해 &lt;code&gt;group/0&lt;/code&gt; 에 정의 된 모든 하위 그룹 은 사전 정의 된 속성으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2666a5da5f12edc23c65da1ead81b4fae39f0c6b" translate="yes" xml:space="preserve">
          <source>If a group has a parallel property, its test cases are spawned simultaneously and get executed in parallel. However, a test case is not allowed to execute in parallel with &lt;code&gt;end_per_group/2&lt;/code&gt;, which means that the time to execute a parallel group is equal to the execution time of the slowest test case in the group. A negative side effect of running test cases in parallel is that the HTML summary pages are not updated with links to the individual test case logs until function &lt;code&gt;end_per_group/2&lt;/code&gt; for the group has finished.</source>
          <target state="translated">그룹에 병렬 속성이있는 경우 테스트 사례가 동시에 생성되고 병렬로 실행됩니다. 그러나 테스트 케이스는 &lt;code&gt;end_per_group/2&lt;/code&gt; 와 병렬로 실행할 수 없습니다. 즉, 병렬 그룹을 실행하는 시간이 그룹에서 가장 느린 테스트 케이스의 실행 시간과 같습니다. 테스트 케이스를 병렬로 실행하면 부정적인 결과는 HTML 요약 페이지가 그룹의 &lt;code&gt;end_per_group/2&lt;/code&gt; 함수 가 완료 될 때까지 개별 테스트 케이스 로그에 대한 링크로 업데이트되지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8bb7010fa14d24ee8209de3626a77d1e0f85e457" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, and the key is known by Logger, the default value is used. If it is a custom key, then it is up to the handler implementation if the value is removed or a default value is inserted.</source>
          <target state="translated">현재 구성과 비교하여 키가 제거되고 키가 로거에 의해 알려진 경우 기본값이 사용됩니다. 사용자 정의 키인 경우 값이 제거되거나 기본값이 삽입되면 핸들러 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="11708959f85882a0251af3731723c98e8ebf01ea" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, the default value is used.</source>
          <target state="translated">현재 구성과 비교하여 키가 제거되면 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5dfcb13b302f0d14decac13131536de1d6f9c84b" translate="yes" xml:space="preserve">
          <source>If a list of &lt;code&gt;ModFiles&lt;/code&gt; is given as input, a list of &lt;code&gt;Result&lt;/code&gt; will be returned. The order of the returned list is undefined.</source>
          <target state="translated">&lt;code&gt;ModFiles&lt;/code&gt; 목록이 입력으로 제공되면 &lt;code&gt;Result&lt;/code&gt; 목록 이 리턴됩니다. 반환 된 목록의 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8890c3d642a5caba2f616485052ab5bd181a9ec" translate="yes" xml:space="preserve">
          <source>If a list of identifiers is used in an &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt; 에서 식별자 목록이 사용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="69f7917cc57f0edf963801bba057a225f78af5d2" translate="yes" xml:space="preserve">
          <source>If a local function has the same name as an auto-imported BIF, the semantics is that implicitly qualified function calls are directed to the locally defined function, not to the BIF. To avoid confusion, there is a compiler directive available, &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt;, that makes a BIF not being auto-imported. In certain situations, such a compile-directive is mandatory.</source>
          <target state="translated">로컬 함수가 자동 반입 된 BIF와 동일한 이름을 갖는 경우, 의미는 내재적으로 규정 된 함수 호출이 BIF가 아닌 로컬로 정의 된 함수로 보내진다는 의미입니다. 혼동을 피하기 위해 BIF를 자동으로 가져 오지 않도록 하는 컴파일러 지시문 인 &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt; 있습니다. 특정 상황에서 이러한 컴파일 지시문은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="6f9bef85716e3a896ddd92ef48c5bf0c2c758aee" translate="yes" xml:space="preserve">
          <source>If a log event passes through all primary filters and all handler filters for a specific handler, Logger forwards the event to the &lt;strong&gt;handler callback&lt;/strong&gt;. The handler formats and prints the event to its destination. See section &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">로그 이벤트가 특정 핸들러에 대한 모든 기본 필터 및 모든 핸들러 필터를 통과하면 로거는 이벤트를 &lt;strong&gt;핸들러 콜백으로&lt;/strong&gt; 전달합니다 . 핸들러는 이벤트를 대상으로 형식화하고 인쇄합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e96f947dd13a984704288142af512a8f72e3acc3" translate="yes" xml:space="preserve">
          <source>If a log is configured to be distributed, it is possible that all items are not logged on all nodes. &lt;code&gt;wrap_log_reader&lt;/code&gt; only reads the log on the called node; it is up to the user to be sure that all items are read.</source>
          <target state="translated">로그가 분배되도록 구성된 경우 모든 항목이 모든 노드에 기록되지 않을 수 있습니다. &lt;code&gt;wrap_log_reader&lt;/code&gt; 는 호출 된 노드의 로그 만 읽습니다. 모든 항목을 읽었는지 확인하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="5666e4e832cec3f259cd26eabc4f7091a56c83aa" translate="yes" xml:space="preserve">
          <source>If a log with a specified name is local on some node, and one tries to open the log distributed on the same node, the tuple &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; is returned. The same tuple is returned if the log is distributed on some node, and one tries to open the log locally on the same node. Opening individual distributed disk logs for the first time adds those logs to a (possibly empty) distributed disk log. The supplied option values are used on all nodes mentioned by option &lt;code&gt;distributed&lt;/code&gt;. Individual distributed logs know nothing about each other's option values, so each node can be given unique option values by creating a distributed log with many calls to &lt;code&gt;open/1&lt;/code&gt;.</source>
          <target state="translated">지정된 이름의 로그가 일부 노드에서 로컬이고 동일한 노드에 분산 된 로그를 열려고하면 튜플 &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; 이 반환됩니다. 로그가 일부 노드에 분배되고 동일한 노드에서 로컬로 로그를 열려고하면 동일한 튜플이 리턴됩니다. 개별 분산 디스크 로그를 처음 열면 해당 로그가 (비어있을 수있는) 분산 디스크 로그에 추가됩니다. 제공된 옵션 값은 옵션 &lt;code&gt;distributed&lt;/code&gt; 의해 언급 된 모든 노드에서 사용됩니다 . 개별 분산 로그는 서로의 옵션 값에 대해 아무것도 모르므로 &lt;code&gt;open/1&lt;/code&gt; 을 여러 번 호출하여 분산 로그를 만들어 각 노드에 고유 한 옵션 값을 부여 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b469c9bb8a16915f90eba775ff31e5fe6d62248d" translate="yes" xml:space="preserve">
          <source>If a macro is used in several modules, it is recommended that the macro definition is placed in an include file.</source>
          <target state="translated">매크로가 여러 모듈에서 사용되는 경우 매크로 정의를 포함 파일에 배치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0bac8e18db1d29ae2b7dd77be807faeccb09df3e" translate="yes" xml:space="preserve">
          <source>If a match specification (applicable only for &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;'receive'&lt;/code&gt; tracing) contains a &lt;code&gt;{message}&lt;/code&gt; action function with a non-boolean value, that value is added as an extra element to the message tuple either in the last position or before the timestamp (if it is present).</source>
          <target state="translated">일치 스펙 ( &lt;code&gt;call&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;'receive'&lt;/code&gt; 추적 에만 적용 가능 )에 부울 값이 아닌 &lt;code&gt;{message}&lt;/code&gt; 조치 함수가 포함되어있는 경우 해당 값은 마지막 위치 또는 이전에 메시지 튜플에 추가 요소로 추가됩니다. 타임 스탬프 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="0a0e324c5eb502ceba59e0414f16795091f6741d" translate="yes" xml:space="preserve">
          <source>If a match specification passed as argument has excessive nesting which causes scheduler stack exhaustion for the scheduler that the calling process is executing on. &lt;code&gt;Scheduler stack size&lt;/code&gt; can be configured when starting the runtime system.</source>
          <target state="translated">인수로 전달 된 일치 사양에 과도한 중첩이있어 호출 프로세스가 실행중인 스케줄러에 대해 스케줄러 스택이 소진되는 경우. &lt;code&gt;Scheduler stack size&lt;/code&gt; 는 런타임 시스템을 시작할 때 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f532881cad197bff88db03f3d5191a830d7bf595" translate="yes" xml:space="preserve">
          <source>If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for example of a web browser where you choose to accept an outdated certificate. This option enables implementation of such a function. This &lt;code&gt;fun/1&lt;/code&gt; is called when no &lt;code&gt;ReferenceID&lt;/code&gt; matches. The return value of the fun (a &lt;code&gt;boolean()&lt;/code&gt;) decides the outcome. If &lt;code&gt;true&lt;/code&gt; the the certificate is accepted otherwise it is rejected. See &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">일치하지 않으면 인증서를 수락해야하는 상황이있을 수 있습니다. 예를 들어 오래된 인증서를 수락하도록 선택한 웹 브라우저를 생각해보십시오. 이 옵션을 사용하면 이러한 기능을 구현할 수 있습니다. 이 &lt;code&gt;fun/1&lt;/code&gt; 은 일치하는 &lt;code&gt;ReferenceID&lt;/code&gt; 가 없을 때 호출됩니다 . fun의 반환 값 ( &lt;code&gt;boolean()&lt;/code&gt; )이 결과를 결정합니다. 만약 &lt;code&gt;true&lt;/code&gt; 하여 인증서가 그렇지 않은 경우 접수가 거부됩니다. 사용 설명서의 &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4aba75283b25dadf865010d69b6030de96baf1b7" translate="yes" xml:space="preserve">
          <source>If a member terminates, it is automatically removed from the group.</source>
          <target state="translated">멤버가 종료되면 그룹에서 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1162149be57c33d9e6fc9573f2f1305c9430528f" translate="yes" xml:space="preserve">
          <source>If a message is received before the &quot;virtual&quot; connection has been established, the connection will be setup automatically. An MGC may be real open minded and dynamically decide which encoding and transport service to use depending on how the transport layer contact is performed. For IP transports two ports are standardized, one for textual encoding and one for binary encoding. If for example an UDP packet was received on the text port it would be possible to decide encoding and transport on the fly.</source>
          <target state="translated">&quot;가상&quot;연결이 설정되기 전에 메시지가 수신되면 연결이 자동으로 설정됩니다. MGC는 실제로 개방적이며 전송 계층 접촉이 수행되는 방식에 따라 사용할 인코딩 및 전송 서비스를 동적으로 결정할 수 있습니다. IP 전송의 경우 두 개의 포트가 표준화되어 있습니다. 하나는 텍스트 인코딩 용이고 다른 하나는 이진 인코딩 용입니다. 예를 들어 UDP 패킷이 텍스트 포트에서 수신 된 경우 인코딩 및 전송을 즉시 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b24fb0bcd517815519471545f5c58487dce8e63f" translate="yes" xml:space="preserve">
          <source>If a module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">모듈이 Cover 컴파일되지 않은 경우 오류 이유 &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="7967640d362f8afe4a91bac33b7793d78de475b7" translate="yes" xml:space="preserve">
          <source>If a module was cover compiled from the &lt;code&gt;.beam&lt;/code&gt; file, i.e. using &lt;code&gt;compile_beam/1&lt;/code&gt; or &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt;, it is assumed that the source code can be found in the same directory as the &lt;code&gt;.beam&lt;/code&gt; file, in &lt;code&gt;../src&lt;/code&gt; relative to that directory, or using the source path in &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. When using the latter, two paths are examined: first the one constructed by joining &lt;code&gt;../src&lt;/code&gt; and the tail of the compiled path below a trailing &lt;code&gt;src&lt;/code&gt; component, then the compiled path itself. If no source code is found, this is indicated by the error reason &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt;.</source>
          <target state="translated">모듈이 커버로부터 컴파일 된 경우 &lt;code&gt;.beam&lt;/code&gt; 의 사용, 즉 파일 &lt;code&gt;compile_beam/1&lt;/code&gt; 또는 &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt; 소스 코드가 동일한 디렉토리에서 발견 될 수 있다는 것이 가정된다 &lt;code&gt;.beam&lt;/code&gt; 의 파일에 &lt;code&gt;../src&lt;/code&gt; 상대적 해당 디렉토리로 또는 &lt;code&gt;Module:module_info(compile)&lt;/code&gt; 의 소스 경로를 사용하십시오 . 후자를 사용할 때 두 가지 경로가 검사됩니다. 먼저 &lt;code&gt;../src&lt;/code&gt; 를 결합하여 구성되는 경로와 후행 &lt;code&gt;src&lt;/code&gt; 구성 요소 아래의 컴파일 된 경로의 꼬리와 컴파일 된 경로 자체입니다. 소스 코드가 없으면 오류 이유 &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="22f56a79590fe78f12a072ad074e3e889605db4d" translate="yes" xml:space="preserve">
          <source>If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages enlarge the process message queue and probably make the problem worse.</source>
          <target state="translated">가비지 수집시 모니터링 프로세스가 너무 커서 시스템 모니터 메시지를 발생시키기 시작하면 메시지가 프로세스 메시지 큐를 확대하여 문제점을 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f2d8b6af86eed1a143439cc301064ec94ca2bef" translate="yes" xml:space="preserve">
          <source>If a more complex change has been made, for example, a change to the format of the internal state of a &lt;code&gt;gen_server&lt;/code&gt;, simple code replacement is not sufficient. Instead, it is necessary to:</source>
          <target state="translated">예를 들어 &lt;code&gt;gen_server&lt;/code&gt; 의 내부 상태 형식 변경과 같이보다 복잡한 변경이 이루어진 경우 간단한 코드 교체로는 충분하지 않습니다. 대신 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9709ba0c2dc81a1b8284809a6f8a81abf726c6a5" translate="yes" xml:space="preserve">
          <source>If a name collision occurs, the compiler reports a &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; message that tells if a definition was renamed, and the new name that must be used to encode/decode data.</source>
          <target state="translated">이름 충돌이 발생하면 컴파일러는 &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; 메시지를 보고 정의 이름이 바뀌 었는지 여부와 데이터를 인코딩 / 디코딩하는 데 사용해야하는 새 이름을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="cd783a31aebc8e052e7a2e8a344df67638bdfe57" translate="yes" xml:space="preserve">
          <source>If a name in &lt;code&gt;Files&lt;/code&gt; is not the name of an existing file, Igor assumes it represents a module name, and tries to locate and read the corresponding source file. The parsed files are appended to &lt;code&gt;Sources&lt;/code&gt; and passed on to &lt;code&gt;merge_sources/3&lt;/code&gt;, i.e., entries in &lt;code&gt;Sources&lt;/code&gt; are listed before entries read from files.</source>
          <target state="translated">에 이름 경우 &lt;code&gt;Files&lt;/code&gt; 기존 파일의 이름이 아닌, 이고르는 모듈의 이름을 나타내며, 위치 및 해당 소스 파일을 읽으려고 가정합니다. 파싱 ​​된 파일은 &lt;code&gt;Sources&lt;/code&gt; 에 추가되고 &lt;code&gt;merge_sources/3&lt;/code&gt; 에 전달됩니다 . 즉, &lt;code&gt;Sources&lt;/code&gt; 항목은 파일에서 항목을 읽기 전에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3d40f62d554584090ae4d71b42895c212400c3" translate="yes" xml:space="preserve">
          <source>If a name is given by a single atom, it should either be a &quot;simple&quot; atom which does not need to be single-quoted in Erlang, or otherwise its print name should correspond to a proper Erlang variable, i.e., begin with an uppercase character or an underscore. Names on the form &lt;code&gt;{A, N}&lt;/code&gt; represent function name variables &quot;&lt;code&gt;A/N&lt;/code&gt;&quot;; these are special variables which may be bound only in the function definitions of a module or a &lt;code&gt;letrec&lt;/code&gt;. They may not be bound in &lt;code&gt;let&lt;/code&gt; expressions and cannot occur in clause patterns. The atom &lt;code&gt;A&lt;/code&gt; in a function name may be any atom; the integer &lt;code&gt;N&lt;/code&gt; must be nonnegative. The functions &lt;code&gt;c_fname/2&lt;/code&gt; etc. are utilities for handling function name variables.</source>
          <target state="translated">이름이 단일 원자로 제공되는 경우 Erlang에서 작은 따옴표로 묶일 필요가없는 &quot;단순한&quot;원자 여야합니다. 그렇지 않으면 인쇄 이름이 적절한 Erlang 변수에 해당해야합니다. 즉, 대문자로 시작해야합니다. 문자 또는 밑줄. &lt;code&gt;{A, N}&lt;/code&gt; 형식의 이름은 함수 이름 변수 &quot; &lt;code&gt;A/N&lt;/code&gt; &quot;을 나타냅니다 . 이들은 모듈 또는 &lt;code&gt;letrec&lt;/code&gt; 의 함수 정의에서만 바인딩 될 수있는 특수 변수입니다 . &lt;code&gt;let&lt;/code&gt; 식에 바인딩 되지 않을 수 있으며 절 패턴에서 발생할 수 없습니다. 함수 이름 의 원자 &lt;code&gt;A&lt;/code&gt; 는 임의의 원자 일 수 있습니다. 정수 &lt;code&gt;N&lt;/code&gt; 은 음수가 아니어야합니다. &lt;code&gt;c_fname/2&lt;/code&gt; 함수 등은 함수 이름 변수를 처리하기위한 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="dfb3773364e26824edee6292b7366b7013d08419" translate="yes" xml:space="preserve">
          <source>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type &lt;code&gt;bag&lt;/code&gt;, each key can map to several records. All records in type &lt;code&gt;bag&lt;/code&gt; tables are unique, only the keys can be duplicated.</source>
          <target state="translated">기존 레코드와 동일한 키를 사용하여 새 항목을 삽입하면 이전 레코드를 덮어 씁니다. 그러나 테이블이 &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 각 키는 여러 레코드에 맵핑 될 수 있습니다. &lt;code&gt;bag&lt;/code&gt; 유형 테이블의 모든 레코드 는 고유하며 키만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="105d061d00a8d9f92d43b213988e0acb45e2f7f6" translate="yes" xml:space="preserve">
          <source>If a new module is introduced, the following instruction is used:</source>
          <target state="translated">새 모듈이 도입되면 다음 지침이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f35aad99efc30cb9fc4c6453834ff14def063cf" translate="yes" xml:space="preserve">
          <source>If a node goes down in the middle of a dirty operation, the table load mechanism ensures that the update is performed on all replicas, or none. Both asynchronous dirty updates and synchronous dirty updates use the same recovery principle as lightweight transactions.</source>
          <target state="translated">더티 작업 중에 노드가 중단되면 테이블로드 메커니즘을 통해 모든 복제본에 대해 업데이트가 수행되거나 전혀 수행되지 않습니다. 비동기 더티 업데이트와 동기 더티 업데이트는 모두 경량 트랜잭션과 동일한 복구 원칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="327048d2049523b0f127e33e21231e0e526e41f3" translate="yes" xml:space="preserve">
          <source>If a node goes down, all connections to that node are removed. Calling &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; forces disconnection of a node.</source>
          <target state="translated">노드가 다운되면 해당 노드에 대한 모든 연결이 제거됩니다. &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; 호출 하면 노드가 강제로 연결 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b4217b58d768f80a1045777fccb8ca8bcb03c9aa" translate="yes" xml:space="preserve">
          <source>If a node is started, which has higher priority according to &lt;code&gt;distributed&lt;/code&gt; than the node where a distributed application is running, the application is restarted at the new node and stopped at the old node. This is called a &lt;strong&gt;takeover&lt;/strong&gt;.</source>
          <target state="translated">분산 응용 프로그램이 실행중인 노드보다 &lt;code&gt;distributed&lt;/code&gt; 에 따라 우선 순위가 높은 노드가 시작되면 응용 프로그램은 새 노드에서 다시 시작되고 이전 노드에서 중지됩니다. 이것을 &lt;strong&gt;인계&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="bc63ca0578b8d746c309ca79e6507b21130aadd5" translate="yes" xml:space="preserve">
          <source>If a particular clause can be selected, the function returns &lt;code&gt;{true, {Clause, Bindings}}&lt;/code&gt;, where &lt;code&gt;Clause&lt;/code&gt; is the selected clause and &lt;code&gt;Bindings&lt;/code&gt; is a list of pairs &lt;code&gt;{Var, SubExpr}&lt;/code&gt; associating the variables occurring in the patterns of &lt;code&gt;Clause&lt;/code&gt; with the corresponding subexpressions in &lt;code&gt;Exprs&lt;/code&gt;. The list of bindings is given in innermost-first order; see the &lt;code&gt;match/2&lt;/code&gt; function for details.</source>
          <target state="translated">특정 절 선택할 수있는 경우, 함수 복귀 &lt;code&gt;{true, {Clause, Bindings}}&lt;/code&gt; , &lt;code&gt;Clause&lt;/code&gt; 선택된 절이고 &lt;code&gt;Bindings&lt;/code&gt; 쌍의 목록이다 &lt;code&gt;{Var, SubExpr}&lt;/code&gt; 의 패턴에 발생하는 변수 연관 &lt;code&gt;Clause&lt;/code&gt; 으로는 &lt;code&gt;Exprs&lt;/code&gt; 의 해당 하위 표현식 . 바인딩 목록은 가장 안쪽부터 순서대로 제공됩니다. 자세한 내용은 &lt;code&gt;match/2&lt;/code&gt; 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f888cd8bd0f80a569dfdaa82a2f031133a869106" translate="yes" xml:space="preserve">
          <source>If a pattern is compiled with option &lt;code&gt;extended&lt;/code&gt;, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</source>
          <target state="translated">옵션이 &lt;code&gt;extended&lt;/code&gt; 옵션으로 패턴을 컴파일 하면 (문자 클래스 이외의) 패턴의 공백과 문자 클래스 외부의 #과 다음 줄 바꾸기 사이의 문자는 무시됩니다. 이스케이프 백 슬래시는 패턴의 일부로 공백 또는 # 문자를 포함하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8b4db27222acc7892ee1eda43334910e96e198" translate="yes" xml:space="preserve">
          <source>If a pattern starts with .* or .{0,} and option &lt;code&gt;dotall&lt;/code&gt; (equivalent to Perl option &lt;code&gt;/s&lt;/code&gt;) is set, thus allowing the dot to match newlines, the pattern is implicitly anchored, because whatever follows is tried against every character position in the subject string. So, there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as if it was preceded by \A.</source>
          <target state="translated">패턴이. * 또는. {0,}으로 시작하고 &lt;code&gt;dotall&lt;/code&gt; 옵션 (Perl 옵션 &lt;code&gt;/s&lt;/code&gt; 와 동일 )이 설정되어 점이 개행과 일치하도록 허용하면 패턴이 암시 적으로 고정됩니다. 다음 문자가 모든 문자 위치에 대해 시도되기 때문입니다. 제목 문자열에. 따라서 첫 번째 이후의 모든 위치에서 전체 경기를 재시도 할 필요가 없습니다. PCRE는 일반적으로 \ A가 앞에 오는 것처럼 이러한 패턴을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b87ae6dafb0124e6e46c837d4958c2fa1f2a81db" translate="yes" xml:space="preserve">
          <source>If a pattern starts with &lt;code&gt;(*NO_START_OPT)&lt;/code&gt;, it has the same effect as setting option &lt;code&gt;no_start_optimize&lt;/code&gt; at compile time.</source>
          <target state="translated">패턴이 &lt;code&gt;(*NO_START_OPT)&lt;/code&gt; 로 시작하면 컴파일시 옵션 &lt;code&gt;no_start_optimize&lt;/code&gt; 를 설정하는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9510cfbb42b2f63e8d24764760322df07deba921" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">영구 응용 프로그램이 종료되면 다른 모든 응용 프로그램과 전체 Erlang 노드도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ae39c8a4064e4c9103a84535d6791f3c2355574b" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the runtime system are also terminated.</source>
          <target state="translated">영구 응용 프로그램이 종료되면 다른 모든 응용 프로그램 및 런타임 시스템도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7d39ec2ef37ef98a358722319b34017d061d33a4" translate="yes" xml:space="preserve">
          <source>If a port is put into or removed from the run queue, a message, &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">실행 큐에 포트를 넣거나 제거하면 &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt; 메시지가 &lt;code&gt;ProfilerPid&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0081080fd8645d025c38129c1f724e4dbeb1f5a" translate="yes" xml:space="preserve">
          <source>If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change.</source>
          <target state="translated">하나 이상의 캡처 하위 패턴을 포함하는 포지티브 어설 션이 성공하지만 나중에 패턴과 일치하지 않으면이 어설 션을 역 추적 할 수 있으며, 더 높은 번호의 캡처가 설정되어 있지 않은 경우에만 어설 션 내의 캡처가 재설정됩니다. 불행히도 이것은 현재 구현의 근본적인 한계이며 PCRE1은 현재 유지 보수 전용 상태이므로 변경되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9cb8ee97edf59cd0007ed1238bc9ac0388e87e9d" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">추가 압축 해제를 위해 사전 설정 사전이 필요한 경우이 함수는 &lt;code&gt;need_dictionary&lt;/code&gt; 튜플을 반환합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt; inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; )를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="93a3a5bfdb59e73fc8a0334b43ff4eba1a20ef35" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">추가 압축 해제에 사전 설정 사전이 필요한 경우이 함수는 &lt;code&gt;need_dictionary&lt;/code&gt; 튜플을 반환합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="83f7f43de6aead79d3e988b3241d9856a34d875b" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; is called automatically.</source>
          <target state="translated">프로세스가 시드를 먼저 설정하지 않고 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; 을 호출 하면 &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; 이 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a36c70330162b05d5a32dea8c99f296dd07fa13f" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; is called automatically with the default algorithm and creates a non-constant seed.</source>
          <target state="translated">프로세스가 시드를 먼저 설정하지 않고 &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; 을 호출하면 기본 알고리즘을 사용하여 &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; 이 자동으로 호출되고 일정하지 않은 시드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ee2bd61bda12e84b2a6d621165135cd3817f20fe" translate="yes" xml:space="preserve">
          <source>If a process having the driver loaded dies, it has the same effect as if unloading is done.</source>
          <target state="translated">드라이버가로드 된 프로세스가 죽으면 언로드가 수행되는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="15014d5a4ff0f8066241b0151c8891a216ed87df" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a busy port, a message &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending to &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">사용중인 포트로 전송하여 시스템의 프로세스가 일시 중단되면 &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;SusPid&lt;/code&gt; 는 &lt;code&gt;Port&lt;/code&gt; 로 보낼 때 일시 중지 된 pid입니다 .</target>
        </trans-unit>
        <trans-unit id="4d68a1d07888243eae02b4e13f79a1936bb61d64" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending through the inter-node communication port &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">사용중인 포트가 노드 간 통신을 처리 한 원격 노드의 프로세스로 전송하여 시스템의 프로세스가 일시 중단되면 &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;SusPid&lt;/code&gt; 는 노드 간 통신 포트 &lt;code&gt;Port&lt;/code&gt; 를 통해 보낼 때 일시 중단 된 pid입니다 .</target>
        </trans-unit>
        <trans-unit id="c045c61e4349e5f89593c090cba3d3de09bd27de" translate="yes" xml:space="preserve">
          <source>If a process is put into or removed from the run queue, a message, &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;. Running processes that are reinserted into the run queue after having been pre-empted do not trigger this message.</source>
          <target state="translated">프로세스가 실행 큐에 넣거나 제거되면 &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt; 메시지가 &lt;code&gt;ProfilerPid&lt;/code&gt; 로 전송됩니다 . 선점 된 후 실행 큐에 다시 삽입 된 실행 프로세스는이 메시지를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4105e92988b9e0273b2afe1380f53a0c26000be5" translate="yes" xml:space="preserve">
          <source>If a process or port in the system runs uninterrupted for at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;PidOrPort&lt;/code&gt; is the process or port that was running. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the event.</source>
          <target state="translated">시스템의 프로세스 또는 포트가 최소 &lt;code&gt;Time&lt;/code&gt; 벽시계 밀리 초 동안 중단없이 실행 되면 &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; 메시지가 &lt;code&gt;MonitorPid&lt;/code&gt; 로 전송됩니다 . &lt;code&gt;PidOrPort&lt;/code&gt; 는 실행중인 프로세스 또는 포트입니다. &lt;code&gt;Info&lt;/code&gt; 는 이벤트를 설명하는 2 요소 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4369b22f5f2ff0b202004df9cfaa90a8b5c4a981" translate="yes" xml:space="preserve">
          <source>If a process simply keeps binaries (either in &quot;loop data&quot; or in the process dictionary), the garbage collector can eventually shrink the binaries. If only one such binary is kept, it will not be shrunk. If the process later appends to a binary that has been shrunk, the binary object will be reallocated to make place for the data to be appended.</source>
          <target state="translated">프로세스가 단순히 바이너리를 유지하는 경우 ( &quot;루프 데이터&quot;또는 프로세스 사전에) 가비지 수집기는 결국 바이너리를 축소 할 수 있습니다. 이러한 바이너리가 하나만 유지되면 축소되지 않습니다. 프로세스가 나중에 축소 된 이진에 추가하는 경우 이진 개체는 데이터가 추가 될 위치를 위해 재 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f775d4e54bbee2d9dbda35be5042e4e186972f7c" translate="yes" xml:space="preserve">
          <source>If a process that holds a lock dies, or the node goes down, the locks held by the process are deleted.</source>
          <target state="translated">잠금을 보유한 프로세스가 종료되거나 노드가 작동 중지되면 프로세스가 보유한 잠금이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="349bb33896dc8851d34347287725d343380e07fb" translate="yes" xml:space="preserve">
          <source>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</source>
          <target state="translated">등록 된 이름을 가진 프로세스가 종료되거나 노드가 작동 중지되면 모든 노드에서 이름이 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="17f27468045dfd75afeb4d681d13f4dbea90b34b" translate="yes" xml:space="preserve">
          <source>If a process, &lt;code&gt;P&lt;/code&gt;, is spawned during execution of, for example, &lt;code&gt;init_per_suite/1&lt;/code&gt;, it inherits the group leader of the &lt;code&gt;init_per_suite&lt;/code&gt; process. This group leader is the central I/O server process mentioned earlier. If, at a later time, &lt;strong&gt;during parallel test case execution&lt;/strong&gt;, some event triggers process &lt;code&gt;P&lt;/code&gt; to call &lt;code&gt;io:format/1/2&lt;/code&gt;, that call never returns (as the group leader is in a non-responsive state) and causes &lt;code&gt;P&lt;/code&gt; to hang.</source>
          <target state="translated">예를 들어 &lt;code&gt;init_per_suite/1&lt;/code&gt; 의 실행 중에 프로세스 &lt;code&gt;P&lt;/code&gt; 가 생성 되면 &lt;code&gt;init_per_suite&lt;/code&gt; 프로세스 의 그룹 리더를 상속합니다 . 이 그룹 리더는 앞에서 언급 한 중앙 I / O 서버 프로세스입니다. 나중에 &lt;strong&gt;병렬 테스트 케이스 실행&lt;/strong&gt; 중 일부 이벤트가 &lt;code&gt;P&lt;/code&gt; 를 처리 하여 &lt;code&gt;io:format/1/2&lt;/code&gt; 를 호출하면 해당 그룹 호출이 리턴되지 않으며 (그룹 리더가 응답하지 않는 상태이므로) &lt;code&gt;P&lt;/code&gt; 가 정지됩니다. .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bf8390a7e5daa53c1c72aaa18283abc83275ce3" translate="yes" xml:space="preserve">
          <source>If a public key is used for logging in, there is normally no checking of the user name. It could be enabled by setting the option &lt;code&gt;&lt;a href=&quot;ssh#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. In that case the pwdfun will get the atom &lt;code&gt;pubkey&lt;/code&gt; in the password argument.</source>
          <target state="translated">로그인에 공개 키를 사용하는 경우 일반적으로 사용자 이름을 확인하지 않습니다. &lt;code&gt;&lt;a href=&quot;ssh#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; 옵션 을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 . 이 경우 pwdfun은 암호 인수에 원자 &lt;code&gt;pubkey&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ff1cac2bbd83699ad97f93b747512a76b2a8a979" translate="yes" xml:space="preserve">
          <source>If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\xc8-\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values &amp;gt; 255 only when it is compiled with Unicode property support.</source>
          <target state="translated">대소 문자가 일치하지 않을 때 문자를 포함하는 범위를 사용하면 두 경우 모두 문자와 일치합니다. 예를 들어, [Wc]는 [] [\\ ^ _`wxyzabc]와 동일하며 대소 문자를 구분하지 않습니다. 비 UTF 모드에서 프랑스어 로케일의 문자표를 사용중인 경우 두 경우 모두 [\ xc8- \ xcb]가 강조된 E 문자와 일치합니다. UTF 모드에서 PCRE는 유니 코드 속성 지원으로 컴파일 된 경우에만 255보다 큰 값을 가진 문자에 대한 대소 문자 개념을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cefcc947210800042f579f6706da18141c734c3a" translate="yes" xml:space="preserve">
          <source>If a received message contains several transaction requests, this option indicates whether the requests should be handled sequentially in the same process (&lt;code&gt;false&lt;/code&gt;), or if each request should be handled by its own process (&lt;code&gt;true&lt;/code&gt; i.e. a separate process is spawned for each request).</source>
          <target state="translated">수신 된 메시지가 여러 트랜잭션 요청이 포함되어있는 경우,이 옵션은 요청이 동일한 프로세스 (순차적으로 처리해야하는지 여부를 나타내는 &lt;code&gt;false&lt;/code&gt; ) 또는 각 요청이 자체 프로세스에 의해 처리 할 필요가있는 경우 ( &lt;code&gt;true&lt;/code&gt; 즉, 별도의 프로세스는 각 요청에 대해 만들어지는) .</target>
        </trans-unit>
        <trans-unit id="b2fc74a5a7f43f310bc65da23c24d79b44a52f9d" translate="yes" xml:space="preserve">
          <source>If a record is stuck at node &lt;code&gt;N1&lt;/code&gt; and you try to set a sticky lock for the record on node &lt;code&gt;N2&lt;/code&gt;, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue &lt;code&gt;s_write/1&lt;/code&gt; requests at &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">레코드가 노드 &lt;code&gt;N1&lt;/code&gt; 에 멈춰 있고 노드 &lt;code&gt;N2&lt;/code&gt; 의 레코드에 대해 고정 잠금을 설정하려고 하면 레코드가 해제되어 있어야합니다. 이 작업은 비용이 많이 들고 성능이 저하됩니다. &lt;code&gt;N2&lt;/code&gt; 에서 &lt;code&gt;s_write/1&lt;/code&gt; 요청 을 발행하면 고정 해제가 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7bbe2237d0bda60b504f73886161206ea6b2f204" translate="yes" xml:space="preserve">
          <source>If a record is used in several modules, it is recommended that the record definition is placed in an include file.</source>
          <target state="translated">레코드가 여러 모듈에서 사용되는 경우 레코드 정의를 포함 파일에 배치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e2be8cb7a69f1955706c91f4c83ac23caeea40af" translate="yes" xml:space="preserve">
          <source>If a recoverable error occurs, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; and the original application specifications are restored. If a non-recoverable error occurs, the system is restarted.</source>
          <target state="translated">복구 가능한 오류가 발생하면 함수는 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴 하고 원래 응용 프로그램 스펙이 복원됩니다. 복구 할 수없는 오류가 발생하면 시스템이 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="22cf54ba81d8faabf766e624c3e7d1674171bb89" translate="yes" xml:space="preserve">
          <source>If a regular core dump is wanted, let &lt;code&gt;heart&lt;/code&gt; know by setting the kill signal to abort using environment variable &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt;. If unset, or not set to &lt;code&gt;SIGABRT&lt;/code&gt;, the default behavior is a kill signal using &lt;code&gt;SIGKILL&lt;/code&gt;:</source>
          <target state="translated">일반 코어 덤프가 원하는 경우,하자 &lt;code&gt;heart&lt;/code&gt; 환경 변수 사용 중단에 킬 (kill) 신호를 설정하여 노하우를 &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt; 를 . 설정되지 않거나 &lt;code&gt;SIGABRT&lt;/code&gt; 로 설정되지 않은 경우 기본 동작은 &lt;code&gt;SIGKILL&lt;/code&gt; 을 사용하는 종료 신호입니다 .</target>
        </trans-unit>
        <trans-unit id="cc4cda006faf8c5c4a357b487a51055ca7991742" translate="yes" xml:space="preserve">
          <source>If a regular directory called &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Name-Vsn&lt;/code&gt; exists in the code path with an &lt;code&gt;ebin&lt;/code&gt; subdirectory, the path to this directory is returned (not the &lt;code&gt;ebin&lt;/code&gt; directory).</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 또는 &lt;code&gt;Name-Vsn&lt;/code&gt; &lt;code&gt;ebin&lt;/code&gt; 이라는 일반 디렉토리 가 ebin 서브 디렉토리 가있는 코드 경로에 존재 하면이 디렉토리의 경로가 리턴됩니다 ( &lt;code&gt;ebin&lt;/code&gt; 디렉토리가 아님).</target>
        </trans-unit>
        <trans-unit id="5d41dbfbe2ec7024dcb9b99c3ee2932c5b54d378" translate="yes" xml:space="preserve">
          <source>If a reply to a request is not received in time, the megaco stack removes all info about the request from its tables. If a reply should arrive after this has been done the app has no way of knowing where to send this message. The message is delivered to the &quot;user&quot; by calling this function on the local node (the node which has the link).</source>
          <target state="translated">요청에 대한 응답이 제 시간에 수신되지 않으면 megaco 스택은 해당 테이블에서 요청에 대한 모든 정보를 제거합니다. 이 작업이 완료된 후 회신이 도착하면 앱에서이 메시지를 보낼 위치를 알 수 없습니다. 메시지는 로컬 노드 (링크가있는 노드)에서이 기능을 호출하여 &quot;사용자&quot;에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="98d501fda955c0480d302e83623ef7940c95c989" translate="yes" xml:space="preserve">
          <source>If a row is created, we always set the internal column to &lt;code&gt;&quot;internal&quot;&lt;/code&gt;.</source>
          <target state="translated">행이 생성되면 항상 내부 열을 &lt;code&gt;&quot;internal&quot;&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6bcc6cd834e1b61a016a579e0ab9636b50732f34" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 바인드에 실패하면 유효한 논리 프로세서 식별자를 항상 확인할 수있는 것은 아니므로 이는 종종 자동으로 무시됩니다. 오류가보고되면 오류 이벤트가 기록됩니다. 스케줄러가 요청한대로 바인딩되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ebc1546b581fe9ec3e1aa902afae9065bac8290" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 바인드에 실패하면 올바른 논리 프로세서 ID를 항상 확인할 수있는 것은 아니기 때문에 자동 무시됩니다. 오류가보고되면 오류 이벤트가 기록됩니다. 스케줄러가 요청한대로 바인드되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a0818c4665c47cbb9e80ed0764a80aff0ec1b7a" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 바인드에 실패하면 유효한 논리 프로세서 식별자를 항상 확인할 수있는 것은 아니므로 이는 종종 자동으로 무시됩니다. 오류가보고되면 &lt;code&gt;error_logger&lt;/code&gt; 에보고됩니다 . 스케줄러가 요청 된대로 바인딩되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="95196719288c8a4037a8712bcbf85254190e9568" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 바인드에 실패하면 올바른 논리 프로세서 ID를 항상 확인할 수있는 것은 아니기 때문에 자동 무시됩니다. 오류가보고되면 &lt;code&gt;error_logger&lt;/code&gt; 에보고됩니다 . 스케줄러가 요청한대로 바인드되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="70c51b792a482c1acceec2498ed07a15eeff4e4d" translate="yes" xml:space="preserve">
          <source>If a scheduler is put to sleep or awoken, a message, &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">스케줄러가 절전 모드 또는 해제 상태가되면 &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt; 메시지가 &lt;code&gt;ProfilerPid&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="c83d78ce9bb009d70f32a1197570bf9131a81777" translate="yes" xml:space="preserve">
          <source>If a scheduler thread create a new reference each nano second, references will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">스케줄러 스레드가 나노초마다 새로운 참조를 생성하면 584 년이 지난 후에 참조가 가장 빨리 재사용됩니다. 즉, 가까운 미래에 그것들은 충분히 독특합니다.</target>
        </trans-unit>
        <trans-unit id="4907dacbb20e81759e0cdf9eb1879f2ddefb0697" translate="yes" xml:space="preserve">
          <source>If a script is found, the first thing that happens is that the application specifications are updated according to the &lt;code&gt;.app&lt;/code&gt; files and &lt;code&gt;sys.config&lt;/code&gt; belonging to the release version &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">스크립트가 발견되면 가장 먼저 발생하는 것은 응용 프로그램 사양이 릴리스 버전 &lt;code&gt;Vsn&lt;/code&gt; 에 속하는 &lt;code&gt;.app&lt;/code&gt; 파일 및 &lt;code&gt;sys.config&lt;/code&gt; 에 따라 업데이트되는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="332eeb8191104a7c5c740b708710a7e691d869fa" translate="yes" xml:space="preserve">
          <source>If a shell service request arrives to the server, an</source>
          <target state="translated">쉘 서비스 요청이 서버에 도착하면</target>
        </trans-unit>
        <trans-unit id="84d4a6395eb04a368d97e3a781384bca1f8ac150" translate="yes" xml:space="preserve">
          <source>If a shuffled test case group is repeated, the seed is not reset between turns.</source>
          <target state="translated">셔플 된 테스트 케이스 그룹이 반복되면 시드가 회전간에 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f211a4f0b3b5f8149bc67ba0e458b150aec8e31c" translate="yes" xml:space="preserve">
          <source>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called &lt;strong&gt;simple code replacement&lt;/strong&gt; and for this the following instruction is used:</source>
          <target state="translated">기능 모듈을 간단하게 확장 한 경우 새 버전의 모듈을 시스템에로드하고 이전 버전을 제거하면 충분합니다. 이것을 &lt;strong&gt;간단한 코드 교체&lt;/strong&gt; 라고 &lt;strong&gt;하며&lt;/strong&gt; 이를 위해 다음 명령어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="820e1f62550d2d1dc4b7d5110225b45b02793e4e" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it.</source>
          <target state="translated">&lt;code&gt;gen_tcp&lt;/code&gt; 를 사용 하지 않고 소켓이 연결된 경우이 옵션을 사용하여 파일 디스크립터를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="bf685931edb5e2ee94fb5c82e823cca317fe8b98" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;{ip, Address}&lt;/code&gt; and/or &lt;code&gt;{port, port_number()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port before connecting. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">&lt;code&gt;gen_tcp&lt;/code&gt; 를 사용 하지 않고 소켓이 연결된 경우이 옵션을 사용하여 파일 디스크립터를 전달하십시오. 경우 &lt;code&gt;{ip, Address}&lt;/code&gt; 및 / 또는 &lt;code&gt;{port, port_number()}&lt;/code&gt; 이 옵션과 결합되면, &lt;code&gt;fd&lt;/code&gt; 연결하기 전에 지정된 인터페이스와 포트에 바인딩됩니다. 이러한 옵션을 지정하지 않으면 &lt;code&gt;fd&lt;/code&gt; 가 이미 적절하게 바인딩되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="88d20f7afcab3c9941388d26759eb43e0f494eda" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been opened without using &lt;code&gt;gen_udp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;Port&lt;/code&gt; is not set to &lt;code&gt;0&lt;/code&gt; and/or &lt;code&gt;{ip, ip_address()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port after it is being opened. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">&lt;code&gt;gen_udp&lt;/code&gt; 를 사용 하지 않고 소켓이 열린 경우이 옵션을 사용하여 파일 디스크립터를 전달하십시오. &lt;code&gt;Port&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 설정되지 않은 경우 및 / 또는 &lt;code&gt;{ip, ip_address()}&lt;/code&gt; 가이 옵션과 결합되면 &lt;code&gt;fd&lt;/code&gt; 는 지정된 인터페이스 및 포트가 열린 후 바인딩됩니다. 이러한 옵션을 지정하지 않으면 &lt;code&gt;fd&lt;/code&gt; 가 이미 적절하게 바인딩되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c3d4cd539d93fb17b915657f42699b04d0414500" translate="yes" xml:space="preserve">
          <source>If a socket is connected already, option &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; can be used to pass the open file descriptor to &lt;code&gt;gen_udp&lt;/code&gt;. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by &lt;code&gt;setuid_socket_wrap&lt;/code&gt;, the command-line argument &quot;-tftpd_69 22&quot; triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; is automatically added. See &lt;code&gt;init:get_argument/&lt;/code&gt; about command-line arguments and &lt;code&gt;gen_udp:open/2&lt;/code&gt; about UDP options.</source>
          <target state="translated">소켓이 이미 연결되어 있으면 &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; 을 사용하여 열린 파일 디스크립터를 &lt;code&gt;gen_udp&lt;/code&gt; 로 전달할 수 있습니다 . 프리 바운드 파일 디스크립터 번호를 나타내는 명령 행 인수를 사용하여 자동화 할 수 있습니다. 예를 들어, 포트가 69이고 파일 디스크립터 22가 &lt;code&gt;setuid_socket_wrap&lt;/code&gt; 에 의해 열린 경우, 명령 행 인수 &quot;-tftpd_69 22&quot;는 포트 69를 여는 대신 프리 바운드 파일 디스크립터 22를 사용하도록 트리거합니다. UDP 옵션 &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; 가 자동으로 추가됩니다. 명령 행 인수에 대해서는 &lt;code&gt;init:get_argument/&lt;/code&gt; 및 UDP 옵션에 대해서는 &lt;code&gt;gen_udp:open/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8adda14107128cbabef9332c232b6afdafabc519" translate="yes" xml:space="preserve">
          <source>If a subgroup is specified in a group with a &lt;code&gt;shuffle&lt;/code&gt; property, the execution order of this subgroup in relation to the test cases (and other subgroups) in the group, is random. The order of the test cases in the subgroup is however not random (unless the subgroup has a &lt;code&gt;shuffle&lt;/code&gt; property).</source>
          <target state="translated">&lt;code&gt;shuffle&lt;/code&gt; 속성이 있는 그룹에 하위 그룹이 지정된 경우 그룹 의 테스트 사례 (및 기타 하위 그룹)와 관련하여이 하위 그룹의 실행 순서는 임의적입니다. 그러나 하위 그룹의 테스트 사례 순서는 임의적이지 않습니다 (하위 그룹에 &lt;code&gt;shuffle&lt;/code&gt; 속성 이없는 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="f8f9318070c1a0b76966d2350817b608770dbd93" translate="yes" xml:space="preserve">
          <source>If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port. The calling process is notified as &lt;code&gt;inactive&lt;/code&gt;, and later &lt;code&gt;active&lt;/code&gt; when the port callback returns.</source>
          <target state="translated">프로세스에서 포트에 대한 동기 호출이 수행되면 호출 런타임은 포트에 대한 호출 런타임 동안 실행할 수없는 것으로 간주됩니다. 호출 프로세스는 &lt;code&gt;inactive&lt;/code&gt; 로 통지 되고 나중에 포트 콜백이 리턴되면 &lt;code&gt;active&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="03163668ea38b2448adbb495833cb5c9d2fb18c2" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;bag&lt;/code&gt;, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function &lt;code&gt;delete_object/3&lt;/code&gt;. A complete record must be supplied to this function.</source>
          <target state="translated">테이블이 &lt;code&gt;bag&lt;/code&gt; 유형 인 경우 특정 키가있는 일부 레코드 만 삭제해야하는 경우가 있습니다. &lt;code&gt;delete_object/3&lt;/code&gt; 함수를 사용하여 수행 할 수 있습니다 . 이 기능에는 완전한 레코드가 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6399fd24f009cc3e3ffb42705ab75b017db16fb" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;set&lt;/code&gt;, each key leads to either one or zero records.</source>
          <target state="translated">테이블이 &lt;code&gt;set&lt;/code&gt; 유형 인 경우 각 키는 하나 또는 0 개의 레코드로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="cc60ddbc56bced221eb285cedf24eccba7391477" translate="yes" xml:space="preserve">
          <source>If a temporary application terminates, this is reported but no other applications are terminated.</source>
          <target state="translated">임시 응용 프로그램이 종료되면보고되지만 다른 응용 프로그램은 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c78c30e29b702d609a635a08cca518cae737159" translate="yes" xml:space="preserve">
          <source>If a terminal symbol is the only member of a category, and the symbol name is identical to the category name, the token format may be &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt;.</source>
          <target state="translated">터미널 기호가 범주의 유일한 멤버이고 기호 이름이 범주 이름과 동일한 경우 토큰 형식은 &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39831a6256c96762c2da58783be93b30bfb60bf0" translate="yes" xml:space="preserve">
          <source>If a test case belonging to a group (according to the group definition) is executed without a group specification, that is, simply by (using the command line):</source>
          <target state="translated">그룹 정의에 따라 그룹에 속하는 테스트 케이스가 그룹 스펙없이 실행되는 경우, 즉 (명령 행 사용)</target>
        </trans-unit>
        <trans-unit id="502798b518aba9797ae119aec810b4ce5b5d0729" translate="yes" xml:space="preserve">
          <source>If a test case fails, this funcion is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 사례가 실패하면이 기능은 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 이후에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="335080793d3bf721193087f47f63eafaac01cbbd" translate="yes" xml:space="preserve">
          <source>If a test case is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">테스트 케이스를 건너 뛰면 &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; 다음에이 함수가 호출 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6a471993c391b1bd64637c48e80cd9c14d7854c" translate="yes" xml:space="preserve">
          <source>If a test case needs to suspend itself for a time that also gets multipled by &lt;code&gt;multiply_timetraps&lt;/code&gt; (and possibly also scaled up if &lt;code&gt;scale_timetraps&lt;/code&gt; is enabled), the function &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; can be used (instead of, for example, &lt;code&gt;timer:sleep/1&lt;/code&gt;).</source>
          <target state="translated">테스트 케이스가 &lt;code&gt;multiply_timetraps&lt;/code&gt; 에 의해 다중화되고 ( &lt;code&gt;scale_timetraps&lt;/code&gt; 가 활성화 된 경우 스케일 업될 수 있는 시간 동안) 일시 중단 해야하는 경우 , &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 (예 &lt;code&gt;timer:sleep/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5226c324f9ac4409e33361c519af1aca1d4d0288" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it are terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">모듈의 세 번째 인스턴스가로드되면 코드 서버는 이전 코드를 제거 (퍼지)하고 그 안에있는 모든 프로세스가 종료됩니다. 그런 다음 세 번째 인스턴스는 '현재'가되고 이전의 현재 코드는 '이전'이됩니다.</target>
        </trans-unit>
        <trans-unit id="4b71ff8bf7808e50acef36bf51fec54b753b169f" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it is terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">모듈의 세 번째 인스턴스가로드되면 코드 서버는 이전 코드를 제거 (퍼지)하고 그 안에있는 모든 프로세스가 종료됩니다. 그런 다음 세 번째 인스턴스는 '현재'가되고 이전의 현재 코드는 '이전'이됩니다.</target>
        </trans-unit>
        <trans-unit id="9b209316ada835a355f0bceb58d85107e4df7fa7" translate="yes" xml:space="preserve">
          <source>If a thread is already working, the calls are queued up and executed in order. Using the same thread for each driver instance ensures that the calls are made in sequence.</source>
          <target state="translated">스레드가 이미 작동중인 경우 통화가 대기되고 순서대로 실행됩니다. 각 드라이버 인스턴스에 대해 동일한 스레드를 사용하면 호출이 순서대로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="f81497c9931883554b1a22b52663496f9755cc27" translate="yes" xml:space="preserve">
          <source>If a thread pool is available, a thread is used. If argument &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the threads from the pool are used in a round-robin way, each call to &lt;code&gt;driver_async&lt;/code&gt; uses the next thread in the pool. With argument &lt;code&gt;key&lt;/code&gt; set, this behavior is changed. The two same values of &lt;code&gt;*key&lt;/code&gt; always get the same thread.</source>
          <target state="translated">스레드 풀이 사용 가능한 경우 스레드가 사용됩니다. 인수 &lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 풀의 스레드는 라운드 로빈 방식으로 사용 되며 &lt;code&gt;driver_async&lt;/code&gt; 에 대한 각 호출 은 풀의 다음 스레드를 사용합니다. 인수 &lt;code&gt;key&lt;/code&gt; 설정되면이 동작이 변경됩니다. 두 개의 동일한 &lt;code&gt;*key&lt;/code&gt; 값은 항상 동일한 스레드를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="2ae4841a41da1bafc39b445eb14fcf5adc83b911" translate="yes" xml:space="preserve">
          <source>If a time-out is started with the time &lt;code&gt;0&lt;/code&gt; it will actually not be started. Instead the time-out event will immediately be inserted to be processed after any events already enqueued, and before any not yet received external events. Note that some time-outs are automatically cancelled so if you for example combine &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponing&lt;/a&gt;&lt;/code&gt; an event in a &lt;strong&gt;state change&lt;/strong&gt; with starting an &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;event time-out&lt;/a&gt;&lt;/code&gt; with time &lt;code&gt;0&lt;/code&gt; there will be no time-out event inserted since the event time-out is cancelled by the postponed event that is delivered due to the state change.</source>
          <target state="translated">시간 제한이 시간 &lt;code&gt;0&lt;/code&gt; 으로 시작되면 실제로 시작되지 않습니다. 대신 시간 초과 이벤트는 이미 대기열에 추가 된 이벤트와 아직 수신되지 않은 외부 이벤트 이전에 처리되도록 즉시 삽입됩니다. 일부 시간 제한은 자동으로 취소되므로 예를 들어 &lt;strong&gt;상태 변경&lt;/strong&gt; 의 이벤트 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponing&lt;/a&gt;&lt;/code&gt; 와 시간 &lt;code&gt;0&lt;/code&gt; 으로 &lt;code&gt;&lt;a href=&quot;#Event%20Time-Outs&quot;&gt;event time-out&lt;/a&gt;&lt;/code&gt; 시작을 결합하면 이벤트 시간 제한이 다음에서 취소되므로 시간 제한 이벤트가 삽입되지 않습니다. 상태 변경으로 인해 전달되는 연기 된 이벤트.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ed3fc97d55d4fa64719146d29086a7ad193da5e" translate="yes" xml:space="preserve">
          <source>If a time-out is started with the time &lt;code&gt;infinity&lt;/code&gt; it will never time out, in fact it will not even be started, and any running time-out with the same tag will be cancelled. The &lt;code&gt;EventContent&lt;/code&gt; will in this case be ignored, so why not set it to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">시간 제한이 &lt;code&gt;infinity&lt;/code&gt; 시작 되면 시간이 초과되지 않으며 실제로 시작되지도 않으며 동일한 태그를 사용하는 모든 실행 시간 제한이 취소됩니다. &lt;code&gt;EventContent&lt;/code&gt; 의 이 경우의 뜻은 무시 왜으로 설정되지 않을 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f35f3c6d4b31e8b5610fe46bbb2c396d6dec610" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes can not be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">추적 포트 ( &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 참조 )가 로컬 노드에서 실행중인 경우 추적 프로그램 프로세스로 원격 노드를 추적 할 수 없습니다. 오류 이유 &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; 가 리턴됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 기능 을 사용하여 원격 노드에서 추적 포트를 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be4166c81b6aa45a3706a93a3be13529c5b52b9c" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes cannot be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">추적 포트 ( &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; 참조 )가 로컬 노드에서 실행중인 경우 원격 노드는 추적 프로그램 프로세스로 추적 할 수 없습니다. &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; 오류 이유 가 리턴됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; 기능 을 사용하여 원격 노드에서 추적 포트를 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="763b6ed1f9356f6927dce6575fc162a00e017c98" translate="yes" xml:space="preserve">
          <source>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</source>
          <target state="translated">추적 프로그램이 두 목록 모두에 지정된 경우 사용 목록의 추적 프로그램이 우선합니다. 추적 프로그램이 지정되지 않으면 일치 스펙을 실행하는 프로세스와 동일한 추적 프로그램 (메타 추적 프로그램이 아님)이 사용됩니다. 해당 프로세스에 추적 프로그램이 없으면 추적 플래그가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b082e683a06ac559acb1ef17f3dfa0a3a24bd825" translate="yes" xml:space="preserve">
          <source>If a transaction involves updates of asymmetrically replicated tables or updates of the schema table, a heavyweight commit protocol is used. This protocol can finish the transaction regardless of how the tables are replicated. The typical use of a heavyweight transaction is when a replica is to be moved from one node to another. Then ensure that the replica either is entirely moved or left as it was. Do never end up in a situation with replicas on both nodes, or on no node at all. Even if a node crashes in the middle of the commit protocol, the transaction must be guaranteed to be atomic. The heavyweight commit protocol involves more messages between the transaction coordinator and its participants than a lightweight protocol, and it performs recovery work at startup to finish the terminating or commit work.</source>
          <target state="translated">트랜잭션에 비대칭 복제 된 테이블의 업데이트 또는 스키마 테이블의 업데이트가 포함 된 경우 헤비급 커밋 프로토콜이 사용됩니다. 이 프로토콜은 테이블 복제 방법에 관계없이 트랜잭션을 완료 할 수 있습니다. 헤비급 트랜잭션의 일반적인 용도는 복제본이 한 노드에서 다른 노드로 이동하는 경우입니다. 그런 다음 복제본이 완전히 이동했거나 그대로 남아 있는지 확인하십시오. 두 노드 모두에 복제본이 있거나 전혀 노드가없는 상황에서는 절대로 끝나지 마십시오. 커밋 프로토콜의 중간에 노드가 충돌하더라도 트랜잭션은 원 자성이어야합니다. 헤비급 커밋 프로토콜은 간단한 프로토콜보다 트랜잭션 조정자와 참여자간에 더 많은 메시지를 포함하며 시작시 복구 작업을 수행하여 종료 또는 커밋 작업을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="be9ed32b4b23ddaaa7542c4292ca46e3b1d16e3a" translate="yes" xml:space="preserve">
          <source>If a transaction terminates abnormally, &lt;code&gt;Mnesia&lt;/code&gt; automatically releases the locks held by the transaction.</source>
          <target state="translated">트랜잭션이 비정상적 으로 종료되면 &lt;code&gt;Mnesia&lt;/code&gt; 는 해당 트랜잭션이 보유한 잠금을 자동으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ddb095e9f47a7e392a2d545f1d0433b6aff3499a" translate="yes" xml:space="preserve">
          <source>If a transformation rule matched, the loader applies the transformation rules again.</source>
          <target state="translated">변환 규칙이 일치하면 로더가 변환 규칙을 다시 적용합니다.</target>
        </trans-unit>
        <trans-unit id="d768f6b886e49430d7bcd0e5e091ee1cc5e44534" translate="yes" xml:space="preserve">
          <source>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">임시 애플리케이션이 비정상적으로 종료되면 다른 모든 애플리케이션과 전체 Erlang 노드도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1b042eac1f57ab6a81bbf8b7e159e1151ec77d9d" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with &lt;code&gt;Reason == normal&lt;/code&gt;, this is reported but no other applications are terminated.</source>
          <target state="translated">임시 애플리케이션이 &lt;code&gt;Reason == normal&lt;/code&gt; 종료되면 보고되지만 다른 애플리케이션은 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d851ba83013456de4862df5a0550756dd9ddcb5" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with reason &lt;code&gt;normal&lt;/code&gt;, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than &lt;code&gt;normal&lt;/code&gt;, all other applications and the runtime system are also terminated.</source>
          <target state="translated">일시적인 응용 프로그램이 reason &lt;code&gt;normal&lt;/code&gt; 로 종료되면 보고되지만 다른 응용 프로그램은 종료되지 않습니다. 임시 애플리케이션이 비정상적으로 종료 된 경우 (즉, &lt;code&gt;normal&lt;/code&gt; 이외의 다른 이유로) 다른 모든 애플리케이션 및 런타임 시스템도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2a6dabddba08d7663fc55e59a178732b34a37ab9" translate="yes" xml:space="preserve">
          <source>If a unique integer is created each nano second, unique integers will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">나노초마다 고유 한 정수가 생성되면 584 년이 지난 후에 고유 한 정수가 가장 빨리 재사용됩니다. 즉, 가까운 미래에 그것들은 충분히 독특합니다.</target>
        </trans-unit>
        <trans-unit id="8212ea9be32c0602ffe0b39d535c8ff1c3704caf" translate="yes" xml:space="preserve">
          <source>If a user wants to run only a subset of a test suite, there is no way one test case could successfully depend on another.</source>
          <target state="translated">사용자가 테스트 스위트의 서브 세트 만 실행하려는 경우 한 테스트 케이스가 다른 테스트 케이스에 성공적으로 의존 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a2111f1ccabd04661a065f18bb26413e12a43cc" translate="yes" xml:space="preserve">
          <source>If a value for an object is not given to the &lt;code&gt;send_notification&lt;/code&gt; function, the sub-agent will perform a get-operation to retrieve it. If the object is not implemented in this sub-agent, its parent agent tries to perform a get-operation to retrieve it. If the object is not implemented in this agent either, it forwards the object to its parent, and so on. Eventually the Master Agent is reached and at this point all unknown object values must be resolved. If some object is unknown even to the Master Agent, this is regarded as an error and is reported with a call to &lt;code&gt;user_err/2&lt;/code&gt; of the error report module. No notifications are sent in this case.</source>
          <target state="translated">오브젝트 값이 &lt;code&gt;send_notification&lt;/code&gt; 함수에 제공되지 않으면 서브 에이전트는 get-operation을 수행 하여 오브젝트 를 검색합니다. 이 서브 에이전트에서 오브젝트가 구현되지 않은 경우, 상위 에이전트는 get-operation을 수행하여 오브젝트를 검색하려고 시도합니다. 이 에이전트에서 오브젝트가 구현되지 않은 경우 오브젝트를 상위로 전달하는 식입니다. 결국 마스터 에이전트에 도달하고이 시점에서 알 수없는 모든 개체 값을 해결해야합니다. 마스터 에이전트조차 알 수없는 일부 개체는 오류로 간주되며 오류 보고서 모듈의 &lt;code&gt;user_err/2&lt;/code&gt; 에 대한 호출과 함께보고됩니다 . 이 경우 알림이 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f05ffe858a8cb96ed8902253d604666829ad99b" translate="yes" xml:space="preserve">
          <source>If a variable in the notification is a table element, the &lt;code&gt;RowIndex&lt;/code&gt; for the element must be given in the &lt;code&gt;Varbinds&lt;/code&gt; list. In this case, the OBJECT IDENTIFIER sent in the notification is the OBJECT IDENTIFIER that identifies this element. This OBJECT IDENTIFIER could be used in a get operation later.</source>
          <target state="translated">알림의 변수가 테이블 요소 인 경우 요소의 &lt;code&gt;RowIndex&lt;/code&gt; 를 &lt;code&gt;Varbinds&lt;/code&gt; 목록에 제공해야 합니다. 이 경우 알림에 전송 된 객체 식별자는이 요소를 식별하는 객체 식별자입니다. 이 객체 식별자는 나중에 가져 오기 작업에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa23222c6a2a3e5338c7520ab1388a99a7dfcaa" translate="yes" xml:space="preserve">
          <source>If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions.</source>
          <target state="translated">긍정적 인 주장에 이름이있는 동사가 발견되면 마지막으로 발견 된 경우 이름이 기록되고 다시 전달됩니다. 부정적 주장이나 긍정적 인 주장에 실패하는 경우에는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c078e743c8ad3031e0b9776799a11e94ca09596" translate="yes" xml:space="preserve">
          <source>If a word is a keyword in any of SMIv1 or SMIv2, it is a keyword in the compiler (deviates from SMIv1 only).</source>
          <target state="translated">단어가 SMIv1 또는 SMIv2의 키워드 인 경우, 컴파일러의 키워드입니다 (SMIv1에서만 벗어남).</target>
        </trans-unit>
        <trans-unit id="626f4bf2cfcfd59884034c767d316b8382a2cf65" translate="yes" xml:space="preserve">
          <source>If all above checks passed both &lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt; Bloom filters are checked to detect if binder was already seen. Being a probabilistic data structure, false positives can occur and they trigger a full handshake.</source>
          <target state="translated">위의 모든 검사가 통과되면 &lt;strong&gt;현재&lt;/strong&gt; 및 &lt;strong&gt;이전&lt;/strong&gt; Bloom 필터를 모두 검사하여 바인더가 이미 표시되었는지 감지합니다. 확률 적 데이터 구조이기 때문에 오탐이 발생할 수 있으며 완전한 핸드 셰이크를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="1149a0ac86645906ae73725e9fb076d1a22fe0f5" translate="yes" xml:space="preserve">
          <source>If all is going well, &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; is returned, where &lt;code&gt;ResultOfFun&lt;/code&gt; is the value of the last expression in &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">모든 것이 잘 진행되면 &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; 이 리턴됩니다. 여기서 &lt;code&gt;ResultOfFun&lt;/code&gt; 은 &lt;code&gt;Fun&lt;/code&gt; 의 마지막 표현식 값입니다 .</target>
        </trans-unit>
        <trans-unit id="b01530d249514addedfdbdbbd983e4e8a11a58ae" translate="yes" xml:space="preserve">
          <source>If all the alternatives of a pattern begin with \G, the expression is anchored to the starting match position, and the &quot;anchored&quot; flag is set in the compiled regular expression.</source>
          <target state="translated">패턴의 모든 대안이 \ G로 시작하면 표현식이 시작 일치 위치에 고정되고 &quot;anchored&quot;플래그가 컴파일 된 정규식에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e1594cd6a4b2cab6cb92767668a0eff338a52692" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;.erlang&lt;/code&gt; file is found, it is assumed to contain valid Erlang expressions. These expressions are evaluated as if they were input to the shell.</source>
          <target state="translated">는 IF &lt;code&gt;.erlang&lt;/code&gt; 파일이 발견, 유효한 얼랑 표현식을 포함하는 것으로 가정한다. 이러한 표현식은 마치 쉘에 입력 된 것처럼 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="af472d7bbaa2fc6a0ea1097c69c14756e497ac62" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocator has been disabled.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; 할당은 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="09d966cba699040070b071c5c784aefbdf8752e2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout, connection loss, or an improper &lt;code&gt;Nodes&lt;/code&gt; list), the caller will not receive any further information about the result if/when the applied function completes. If the applied function communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="translated">는 IF &lt;code&gt;erpc&lt;/code&gt; 의 조작이 실패하지만, 기능 / 적용될 경우가 알려지지 않은 (즉, 타임 아웃, 접속 손실 또는 잘못된 &lt;code&gt;Nodes&lt;/code&gt; 리스트), 호출자는 그 결과에 대한 정보를 수신하지 않을 때 / IF 적용된 기능이 완료됩니다. 적용된 함수가 호출 프로세스와 통신하는 경우 이러한 통신은 물론 호출 프로세스에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0fe7f6a7a0b539b5749a7e1d2f251c0f18f21ac" translate="yes" xml:space="preserve">
          <source>If an I/O device is set in binary mode, functions &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8.</source>
          <target state="translated">I / O 장치가 2 진 모드로 설정된 경우 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 함수 는 목록 대신 2 진을 리턴 할 수 있습니다. 바이너리는 Erlang / OTP R13A에서와 같이 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="950a5eee2a6c7e7d5ca333de354cd42eaef1ad34" translate="yes" xml:space="preserve">
          <source>If an I/O server encounters a request that it does not recognize (that is, the &lt;code&gt;io_request&lt;/code&gt; tuple has the expected format, but the &lt;code&gt;Request&lt;/code&gt; is unknown), the I/O server is to send a valid reply with the error tuple:</source>
          <target state="translated">는 I / O 서버가 인식하지 못하는 요청이 발생하는 경우이다 (그의 &lt;code&gt;io_request&lt;/code&gt; 튜플이 예상되는 형식을 가지고 있지만, &lt;code&gt;Request&lt;/code&gt; 의 I / O 서버는 오류 튜플있는 유효한 응답을 보내는 것입니다 알 수없는) :</target>
        </trans-unit>
        <trans-unit id="a4f36f7aa69d8f80d8d7146716c4e8049b3bf51a" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry.</source>
          <target state="translated">MIB 객체 인스턴스가 정확히 하나의 하위 트리에 속하는 경우 해당 항목의 유형에 따라 인스턴스가 관련 MIB보기에 포함되거나 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="a99df1ec1c1a80894724865e2ce569291af72e66" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used.</source>
          <target state="translated">MIB 오브젝트 인스턴스가 둘 이상의 서브 트리에 속하는 경우, 가장 많은 수의 서브 식별자를 포함하고 사 전적으로 가장 큰 서브 트리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6bdb8ad60adae512c56f4674456a5be529864a3" translate="yes" xml:space="preserve">
          <source>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view.</source>
          <target state="translated">MIB 객체 인스턴스가 관련 하위 트리에 속하지 않으면 인스턴스가 MIB보기에 없습니다.</target>
        </trans-unit>
        <trans-unit id="705cdb188be71ada04fc74b872d92dbacc75dd7e" translate="yes" xml:space="preserve">
          <source>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</source>
          <target state="translated">algs_list ()에서 alg_entry ()가 누락되면 해당 항목에 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c83f6426a048bc4d7852aaa3ae581e49a373491" translate="yes" xml:space="preserve">
          <source>If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time.</source>
          <target state="translated">알고리즘 이름이 목록에서 두 번 이상 나타나면 동작이 정의되지 않은 것입니다. 속성 목록의 태그도 최대 한 번 발생한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ce7071090130d498a0f2639cfbfd5be9f3e8c347" translate="yes" xml:space="preserve">
          <source>If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either &lt;code&gt;{error,encode}&lt;/code&gt; or &lt;code&gt;{error,failure}&lt;/code&gt; is returned depending on whether or not there has been an attempt to send the request over the transport.</source>
          <target state="translated">요청 처리에서 작성된 애플리케이션 콜백이 실패하면 (pick_peer, 준비 _ 요청, 준비 _ 전송, handle_answer 또는 handle_error) 요청을 보내려는 시도가 있는지 여부에 따라 &lt;code&gt;{error,encode}&lt;/code&gt; 또는 &lt;code&gt;{error,failure}&lt;/code&gt; 가 리턴됩니다. 수송을 통해.</target>
        </trans-unit>
        <trans-unit id="9bc38fb01d5bf31a73055c19a3816c95b41bcc62" translate="yes" xml:space="preserve">
          <source>If an application is given more than once or if an application has the same key given more than once, the behaviour is undefined and a warning message will be logged. In future releases, an error will be raised.</source>
          <target state="translated">애플리케이션이 두 번 이상 제공되거나 애플리케이션에 동일한 키가 두 번 이상 제공되는 경우 동작이 정의되지 않고 경고 메시지가 기록됩니다. 향후 릴리스에서는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39738be45b65649837e2fb936bf724db2dc8cf3a" translate="yes" xml:space="preserve">
          <source>If an argument is invalid.</source>
          <target state="translated">인수가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="8620de6a5aec3c030672b28f6a7fdb90f2fa4d64" translate="yes" xml:space="preserve">
          <source>If an arithmetic expression, a Boolean expression, a short-circuit expression, or a call to a guard BIF fails (because of invalid arguments), the entire guard fails. If the guard was part of a guard sequence, the next guard in the sequence (that is, the guard following the next semicolon) is evaluated.</source>
          <target state="translated">산술 표현식, 부울 표현식, 단락 표현식 또는 가드 BIF 호출이 실패하면 (잘못된 인수로 인해) 전체 가드가 실패합니다. 가드가 가드 시퀀스의 일부인 경우 시퀀스의 다음 가드 (즉, 다음 세미콜론 다음의 가드)가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ee90b274af3aff2cc9d248f74e9b5167e0839059" translate="yes" xml:space="preserve">
          <source>If an attempt to open a log file for the first time fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt;. The function returns &lt;code&gt;{error, Reason}&lt;/code&gt; for all other errors.</source>
          <target state="translated">로그 파일을 처음으로 열려는 시도가 실패하면 EXIT 메시지 &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt; 과 함께 디스크 로그 프로세스가 종료됩니다 . 이 함수는 다른 모든 오류에 대해 &lt;code&gt;{error, Reason}&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6c78e44d2f2d9461d5a0cc6159a7d3b1775f8cf6" translate="yes" xml:space="preserve">
          <source>If an attempt to reopen or truncate a log fails (see &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt;) the disk log process terminates immediately. Before the process terminates, links to owners and blocking processes (see &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt;) are removed. The effect is that the links work in one direction only. Any process using a disk log must check for error message &lt;code&gt;no_such_log&lt;/code&gt; if some other process truncates or reopens the log simultaneously.</source>
          <target state="translated">로그를 다시 열거 나 자르려는 시도가 실패하면 ( &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt; 참조 ) 디스크 로그 프로세스가 즉시 종료됩니다. 프로세스가 종료되기 전에 소유자에 대한 링크 및 차단 프로세스 ( &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt; 참조 )가 제거됩니다. 결과적으로 링크는 한 방향으로 만 작동합니다. 다른 프로세스가 동시에 로그를 자르거나 다시 여는 경우 디스크 로그를 사용하는 프로세스는 오류 메시지 &lt;code&gt;no_such_log&lt;/code&gt; 를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="efa1a720322487c68ded0dc02a8c51e5dc94fcf9" translate="yes" xml:space="preserve">
          <source>If an edge is emanating from v and incident on w, then w is said to be an  &lt;strong id=&quot;out_neighbour&quot;&gt;out-neighbor&lt;/strong&gt; of v, and v is said to be an &lt;strong id=&quot;in_neighbour&quot;&gt;in-neighbor&lt;/strong&gt; of w.</source>
          <target state="translated">에지가 v에서 &lt;strong id=&quot;out_neighbour&quot;&gt;나오고&lt;/strong&gt; w에 입사하면 w 는 v 의 &lt;strong id=&quot;out_neighbour&quot;&gt;외부 이웃&lt;/strong&gt; 이라고하며 v는 w의 내부 &lt;strong id=&quot;in_neighbour&quot;&gt;이웃&lt;/strong&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a481b829b72ba85ee7ff861e87909f902fa230b7" translate="yes" xml:space="preserve">
          <source>If an employee started 1997 or later, but before 2001, return &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">직원이 1997 년 이후에 시작했지만 2001 년 이전에 &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="267d94e1e64e36b71e95d1e768da8da0ab4dabd6" translate="yes" xml:space="preserve">
          <source>If an employee started before 1997, return the tuple &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">직원이 1997 년 이전에 시작한 경우 튜플 &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b9b3a599385dc1e77b6effb7fdcc0ba87017325" translate="yes" xml:space="preserve">
          <source>If an emulator restart is necessary and no upgrade instructions are needed, that is, if the restart itself is enough for the upgraded applications to start running the new versions, a simple &lt;code&gt;relup&lt;/code&gt; file can be created manually:</source>
          <target state="translated">에뮬레이터를 다시 시작해야하고 업그레이드 지침이 필요하지 않은 경우, 다시 시작 자체가 업그레이드 된 응용 프로그램이 새 버전을 실행하기에 충분하면 간단한 &lt;code&gt;relup&lt;/code&gt; 파일을 수동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be98b96fbc89792dcc19067b12124fdf6e59e27" translate="yes" xml:space="preserve">
          <source>If an encode error takes place during retransmission then the request process fails and &lt;code&gt;{error,failure}&lt;/code&gt; is returned.</source>
          <target state="translated">재전송 중 인코딩 오류가 발생하면 요청 프로세스가 실패하고 &lt;code&gt;{error,failure}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4d90f4b09c609d55842d57250ea621c86bccd2a5" translate="yes" xml:space="preserve">
          <source>If an entire packet is contained in &lt;code&gt;Bin&lt;/code&gt;, it is returned together with the remainder of the binary as &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt;.</source>
          <target state="translated">전체 패킷이 &lt;code&gt;Bin&lt;/code&gt; 에 포함되어 있으면 나머지 바이너리와 함께 &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="811984ae5951261acbbb238684d0b7c77bf502d9" translate="yes" xml:space="preserve">
          <source>If an error code is returned, the port is not started.</source>
          <target state="translated">오류 코드가 리턴되면 포트가 시작되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="da4e739db10805f14ff747b7b4e80017ae2c1b09" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류 보고서 모듈의 &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 오류 가보고 되고 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="9669e70dbc35431ddeb5cae9c621269171a463e4" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the , and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견되면의 &lt;code&gt;config_err/2&lt;/code&gt; 함수를 사용하여 오류가보고 되고 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="16106449fe5fc75aadfe943e285574d04cf0155a" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류 보고서 모듈의 &lt;code&gt;config_err/2&lt;/code&gt; 기능을 사용하여보고되며, &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="3f27e177a4e1612c45d2451a4b610d2b6a6e50b1" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류 보고서 모듈의 &lt;code&gt;config_err/2&lt;/code&gt; 함수를 사용 하여 오류 가보고 되고 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="32a6f97b5644649bdcac70889144dbc30cbf50c8" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error, report module and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">구성 파일에서 오류가 발견 되면 오류, 보고서 모듈의 &lt;code&gt;config_err/2&lt;/code&gt; 함수를 사용하여보고되며 &lt;code&gt;configuration_error&lt;/code&gt; 이유와 함께 함수가 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="a6bbaf85823709f47c63afa4741f86471e008208" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can be due to errors in compilation of the match specification. Such errors are presented as a list of tuples &lt;code&gt;{error, string()}&lt;/code&gt; where the string is a textual explanation of the compilation error. An example:</source>
          <target state="translated">오류가 리턴되면 일치 스펙 컴파일 오류가 원인 일 수 있습니다. 이러한 오류는 문자열이 컴파일 오류에 대한 텍스트 설명 인 튜플 &lt;code&gt;{error, string()}&lt;/code&gt; 의 목록으로 표시됩니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4a4d238b84b9d8f7ce4275d02e1e061ea04cf76d" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can either be due to a tracer server already running (&lt;code&gt;{error,already_started}&lt;/code&gt;) or due to the &lt;code&gt;HandlerFun&lt;/code&gt; throwing an exception.</source>
          <target state="translated">오류가 리턴되면 추적 프로그램 서버가 이미 실행 중이 거나 ( &lt;code&gt;{error,already_started}&lt;/code&gt; ) &lt;code&gt;HandlerFun&lt;/code&gt; 에서 예외가 발생 했기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9dbcebd3f214207a33235b48bfaaf49bf5e244" translate="yes" xml:space="preserve">
          <source>If an error occurred, this function is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function is called. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;is_set_ok&lt;/code&gt; 함수가 호출 된 후이 함수가 호출됩니다. 경우 &lt;code&gt;set&lt;/code&gt; 이 객체에 대해 호출, &lt;code&gt;undo&lt;/code&gt; 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ffdf980152bda82758e93fa5363e955a51a162e" translate="yes" xml:space="preserve">
          <source>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</source>
          <target state="translated">설치 중 오류가 발생하면 시스템은 이전 버전의 릴리스를 사용하여 재부팅됩니다. 설치에 성공하면 새 버전의 릴리스를 사용하여 시스템이 나중에 작동하지만 문제가 발생하여 시스템이 재부팅되면 이전 버전을 다시 사용하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e3b9183a591452f1c5ebde1eae8e316833b13a50" translate="yes" xml:space="preserve">
          <source>If an error occurs on the socket, the following message is delivered (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">소켓에서 오류가 발생하면 다음 메시지가 전달됩니다 ( &lt;code&gt;{active, false}&lt;/code&gt; 가 소켓의 옵션 목록에 지정되어 있지 않은 경우 &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 패킷이 검색되는 경우 제외).</target>
        </trans-unit>
        <trans-unit id="ee097c045f410ae6ef1682702f02130e44879ffb" translate="yes" xml:space="preserve">
          <source>If an error occurs when accessing an open file with module &lt;code&gt;io&lt;/code&gt;, the process handling the file exits. The dead file process can hang if a process tries to access it later. This will be fixed in a future release.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; 모듈로 열린 파일에 액세스 할 때 오류가 발생하면 파일 처리 프로세스가 종료됩니다. 프로세스가 나중에 액세스하려고하면 사용 불능 파일 프로세스가 중단 될 수 있습니다. 향후 릴리스에서 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="1e80b8f25b6627161bccd2087c0375b81e9072e8" translate="yes" xml:space="preserve">
          <source>If an error occurs, The function &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">오류가 발생 하면 &lt;code&gt;is_set_ok&lt;/code&gt; 함수 다음에 함수 &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; 가 호출 됩니다. 경우 &lt;code&gt;set&lt;/code&gt; 이 객체에 대해 호출, &lt;code&gt;undo&lt;/code&gt; 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae997c53a260dda31bdd5632662979a9e41a9ab0" translate="yes" xml:space="preserve">
          <source>If an error occurs, either in the &lt;code&gt;is_set_ok&lt;/code&gt; phase, or in the &lt;code&gt;set&lt;/code&gt; phase, all functions which were called with &lt;code&gt;is_set_ok&lt;/code&gt; but not &lt;code&gt;set&lt;/code&gt;, are called with &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하는 경우 중 하나에 &lt;code&gt;is_set_ok&lt;/code&gt; 단계, 또는에서 &lt;code&gt;set&lt;/code&gt; 상, 호출 된 모든 기능 &lt;code&gt;is_set_ok&lt;/code&gt; 하지만 &lt;code&gt;set&lt;/code&gt; , 호출되어 &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276746b794853efb127f75c7e5ec07717c8d976f" translate="yes" xml:space="preserve">
          <source>If an error occurs, the applications started by the function are stopped to bring the set of running applications back to its initial state.</source>
          <target state="translated">오류가 발생하면 기능에 의해 시작된 응용 프로그램이 중지되어 실행중인 응용 프로그램 세트를 초기 상태로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="5c1a2d5fdbf25c48c2a0e3dd8bc47d65a9c912ff" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하면 오류 튜플 &lt;code&gt;{error, Reason}&lt;/code&gt; 과 함께 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="198b396c8242aa281ca2808a3e1fe29feecf86f5" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;. The error tuple is not returned, as it cannot be distinguished from a key.</source>
          <target state="translated">오류가 발생하면 오류 튜플 &lt;code&gt;{error, Reason}&lt;/code&gt; 과 함께 프로세스가 종료됩니다 . 오류 튜플은 키와 구별 할 수 없으므로 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9366b8a06735f2ef6c5bd64e2d4894f28c5e9fd9" translate="yes" xml:space="preserve">
          <source>If an error occurs, the stack trace becomes empty in this case.</source>
          <target state="translated">오류가 발생하면이 경우 스택 추적이 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="5334f6f487ef5e94e1d3f8d91a903cad1c7ae4ca" translate="yes" xml:space="preserve">
          <source>If an error occurs, there is no output. Example:</source>
          <target state="translated">오류가 발생하면 출력이 없습니다. 예:</target>
        </trans-unit>
        <trans-unit id="eaf4f64d81bc2ecc63f1691d3a8ab14648012ce3" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;AfterBody&lt;/code&gt; itself, it is not caught. So if &lt;code&gt;AfterBody&lt;/code&gt; is evaluated after an exception in &lt;code&gt;Exprs&lt;/code&gt;, &lt;code&gt;Body&lt;/code&gt;, or &lt;code&gt;ExceptionBody&lt;/code&gt;, that exception is lost and masked by the exception in &lt;code&gt;AfterBody&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AfterBody&lt;/code&gt; 자체를 평가하는 동안 예외가 발생하면 포착되지 않습니다. 따라서 &lt;code&gt;Exprs&lt;/code&gt; , &lt;code&gt;Body&lt;/code&gt; 또는 &lt;code&gt;ExceptionBody&lt;/code&gt; 에서 예외 후에 &lt;code&gt;AfterBody&lt;/code&gt; 가 평가 되면 해당 예외는 손실되고 &lt;code&gt;AfterBody&lt;/code&gt; 의 예외에 의해 마스크됩니다 .</target>
        </trans-unit>
        <trans-unit id="73b3692cd35fbb24365c57783d388c12c52b16ba" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;ExceptionBody&lt;/code&gt;, it is not caught.</source>
          <target state="translated">&lt;code&gt;ExceptionBody&lt;/code&gt; 평가 중에 예외가 발생하면 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15e21c88415fba00ea3b007d2430e70dde7b38c0" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;Exprs&lt;/code&gt; but there is no matching &lt;code&gt;ExceptionPattern&lt;/code&gt; of the right &lt;code&gt;Class&lt;/code&gt; with a true guard sequence, the exception is passed on as if &lt;code&gt;Exprs&lt;/code&gt; had not been enclosed in a &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;Exprs&lt;/code&gt; 를 평가하는 동안 예외가 발생 하지만 실제 가드 시퀀스 가있는 올바른 &lt;code&gt;Class&lt;/code&gt; 의 일치하는 &lt;code&gt;ExceptionPattern&lt;/code&gt; 이 없으면 &lt;code&gt;Exprs&lt;/code&gt; 가 &lt;code&gt;try&lt;/code&gt; 표현식 으로 묶이지 않은 것처럼 예외가 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d16bf5cd6125b26b68df1e48e19c1d35055d07b" translate="yes" xml:space="preserve">
          <source>If an exit signal is received as above, the tuple &lt;code&gt;{From,Name}&lt;/code&gt; is deleted from the servers &lt;code&gt;User_List&lt;/code&gt; using the &lt;code&gt;server_logoff&lt;/code&gt; function. If the node on which the server runs goes down, an exit signal (automatically generated by the system) is sent to all of the client processes: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; causing all the client processes to terminate.</source>
          <target state="translated">위와 같이 종료 신호가 수신되면 튜플 &lt;code&gt;{From,Name}&lt;/code&gt; 이 &lt;code&gt;server_logoff&lt;/code&gt; 함수를 사용하여 서버 &lt;code&gt;User_List&lt;/code&gt; 에서 삭제됩니다 . 서버가 실행되는 노드가 작동 중지되면 종료 신호 (시스템에 의해 자동으로 생성됨)가 모든 클라이언트 프로세스 ( &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; )로 전송되어 모든 클라이언트 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e0ea0cc95b3d589060e057229e831ff5a8ff4e" translate="yes" xml:space="preserve">
          <source>If an instrumentation function in the association file for a variable &lt;code&gt;myVar&lt;/code&gt; does not have a name when compiling an MIB, the compiler generates an entry.</source>
          <target state="translated">MIB를 컴파일 할 때 변수 &lt;code&gt;myVar&lt;/code&gt; 에 대한 연관 파일의 인스 트루먼 테이션 함수에 이름이없는 경우 컴파일러는 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b4e274b3831003e60f76d89037c8e16f5e3d04d9" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt; Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="translated">정수 제한 시간 값이 제공되면 &lt;code&gt;Timeout&lt;/code&gt; 밀리 초 내에 요청이나 메시지가 수신되지 않으면 제한 시간이 발생합니다 . 시간 &lt;code&gt;timeout&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt; Module:handle_info/2&lt;/a&gt;&lt;/code&gt; 콜백 함수에 의해 처리되는 atom timeout으로 표시됩니다 . 원자 &lt;code&gt;infinity&lt;/code&gt; 를 사용하여 무기한 대기 할 수 있으며 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4901f204507135ee6a79147a0e0e1064225a4fc4" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="translated">정수 시간 종료 값이 제공되면 시간 &lt;code&gt;Timeout&lt;/code&gt; 밀리 초 내에 요청 또는 메시지가 수신되지 않으면 시간 종료가 발생합니다 . 시간 &lt;code&gt;timeout&lt;/code&gt; 는 atom timeout으로 표시되며 이는 &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; 콜백 함수에 의해 처리됩니다 . 원자 &lt;code&gt;infinity&lt;/code&gt; 는 무한정 대기하는 데 사용할 수 있으며 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f34784d34b261e41d724f171d45d4c2db9bc38eb" translate="yes" xml:space="preserve">
          <source>If an option is set in more than one way, what happens?</source>
          <target state="translated">옵션이 여러 가지 방법으로 설정되면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="c317bf8995de9827a88e47cfa9f960f031966c21" translate="yes" xml:space="preserve">
          <source>If an owner attempts to open a log as owner once again, it is acknowledged with the return value &lt;code&gt;{ok, Log}&lt;/code&gt;, but the state of the disk log is not affected.</source>
          <target state="translated">소유자가 로그를 다시 소유자로 열려고 시도하면 리턴 값 &lt;code&gt;{ok, Log}&lt;/code&gt; 로 승인 되지만 디스크 로그의 상태는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d1c8f7e5679322dcbb64d8108251b9319c084c5" translate="yes" xml:space="preserve">
          <source>If an unrecognized type option &lt;code&gt;T&lt;/code&gt; is specified or &lt;code&gt;Type&lt;/code&gt; is not a proper list, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">인식 할 수없는 유형 옵션 &lt;code&gt;T&lt;/code&gt; 가 지정되었거나 &lt;code&gt;Type&lt;/code&gt; 이 올바른 목록이 아닌 경우 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5edd7e14ee514521a82d9d312927e864fd8b6b43" translate="yes" xml:space="preserve">
          <source>If an unsupported algorithm is in the &lt;code&gt;modify_algs_list()&lt;/code&gt;, it will be silently ignored</source>
          <target state="translated">지원되지 않는 알고리즘이 &lt;code&gt;modify_algs_list()&lt;/code&gt; 에 있으면 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ac90fe515c674df1b687955496c9be8fee6118f2" translate="yes" xml:space="preserve">
          <source>If an upgrade includes a change from an emulator earlier than OTP R15 to OTP R15 or later, the warning &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; is issued. For more information about this, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">업그레이드에 OTP R15 이전의 에뮬레이터에서 OTP R15 이상으로의 변경이 포함 된 경우, &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; 경고 가 발행됩니다. 이에 대한 자세한 내용은 &lt;strong&gt;시스템 설명서의 &lt;/strong&gt; &lt;code&gt;Design Principles&lt;/code&gt; 을 참조하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2bc5a0b1d5c34b06e7086cddd297167569f7462" translate="yes" xml:space="preserve">
          <source>If and how to compress the message. Examples are &lt;code&gt;none&lt;/code&gt;, that is, no compression and &lt;code&gt;zlib&lt;/code&gt;.</source>
          <target state="translated">메시지를 압축하는 경우 및 방법 예는 &lt;code&gt;none&lt;/code&gt; , 즉 compression 및 &lt;code&gt;zlib&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e7a133c6b3bee84f3bf4462f30e02bb30fa3e98" translate="yes" xml:space="preserve">
          <source>If and only if the Unicode translation modifier is used in the format string (that is, &lt;code&gt;~ts&lt;/code&gt; or &lt;code&gt;~tc&lt;/code&gt;), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &amp;gt; 255). If so, the result is still an ordinary Erlang &lt;code&gt;string()&lt;/code&gt;, and can well be used in any context where Unicode data is allowed.</source>
          <target state="translated">유니 코드 변환 수정자가 형식 문자열 ( &lt;code&gt;~ts&lt;/code&gt; 또는 &lt;code&gt;~tc&lt;/code&gt; )에 사용되는 경우에만 결과 목록에 ISO Latin-1 문자 범위를 벗어난 문자 (숫자&amp;gt; 255)가 포함될 수 있습니다. 그렇다면 결과는 여전히 일반적인 Erlang &lt;code&gt;string()&lt;/code&gt; 이며 유니 코드 데이터가 허용되는 모든 컨텍스트에서 잘 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c687f2de4701a7ffef4cc4c42ee7473077335c1" translate="yes" xml:space="preserve">
          <source>If and when you would like to start and manipulate &lt;code&gt;Mnesia&lt;/code&gt;, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. &lt;code&gt;Mnesia&lt;/code&gt; can be initialized with data read from a text file. The following two functions can be used to work with text files.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; 를 시작하고 조작 하려면 정의와 데이터를 일반 텍스트 파일에 작성하는 것이 더 쉬운 경우가 많습니다. 처음에는 테이블과 데이터가 없거나 필요한 테이블이 없습니다. 프로토 타이핑의 초기 단계에서는 모든 데이터를 하나의 파일에 기록하고 해당 파일을 처리하며 파일의 데이터를 데이터베이스에 삽입하는 것이 좋습니다. &lt;code&gt;Mnesia&lt;/code&gt; 는 텍스트 파일에서 읽은 데이터로 초기화 할 수 있습니다. 다음 두 가지 기능을 사용하여 텍스트 파일을 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80417b144fe2bc5c20d55da668bc56d430c25c36" translate="yes" xml:space="preserve">
          <source>If another implementation of any of these variables is needed, e.g. to store the persistent variables in a Mnesia database, an own implementation of the variables must be made. That MIB will be compiled and loaded instead of the default MIB. The new compiled MIB must have the same name as the original MIB (i.e. STANDARD-MIB or SNMPv2-MIB), and be located in the SNMP configuration directory (see &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Mnesia 데이터베이스에 영속 변수를 저장하기 위해 이러한 변수 중 하나를 다시 구현해야하는 경우 변수를 자체적으로 구현해야합니다. 해당 MIB는 기본 MIB 대신 컴파일되고로드됩니다. 새로 컴파일 된 MIB는 원래 MIB와 이름이 동일해야하며 (예 : STANDARD-MIB 또는 SNMPv2-MIB) SNMP 구성 디렉토리에 있어야합니다 ( &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a2491a0f8f402474246f9fb8f195513ec14b76dd" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; is present, the one with the highest level is used, that is, the &lt;code&gt;Option&lt;/code&gt; list parameter has the highest priority. Then the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; on all levels in order starting with level 0 are applied.</source>
          <target state="translated">어떤 경우 &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; 가 존재하는 가장 높은 수준을 가진 사람이 사용하는, 즉, &lt;code&gt;Option&lt;/code&gt; 목록 매개 변수는 가장 높은 우선 순위를가집니다. 그런 다음 레벨 0부터 시작하는 모든 레벨 의 &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; 가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="80ee411849a587dd3deef8de9d6f9689dcf9ebe0" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Dir&lt;/code&gt; is not a directory name</source>
          <target state="translated">&lt;code&gt;Dir&lt;/code&gt; 이 디렉토리 이름이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="7226b47ac607cfe4ee033cbac112e9d47878f35b" translate="yes" xml:space="preserve">
          <source>If any Erlang process &lt;code&gt;Pid&lt;/code&gt; in the system has allocated more than a certain amount of total system memory, the alarm &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; is set.</source>
          <target state="translated">시스템의 Erlang 프로세스 &lt;code&gt;Pid&lt;/code&gt; 가 일정량 이상의 총 시스템 메모리를 할당 한 경우, 알람 &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="56bae9cc860914f3d89871e3baff9cb1dcabb640" translate="yes" xml:space="preserve">
          <source>If any HTTP header fields are added by the script, they must be in the first call to &lt;code&gt;deliver/2&lt;/code&gt;, and the data in the call must be a string. Calls after the headers are complete can contain binary data to reduce copying overhead. Do not assume anything about the data type of &lt;code&gt;SessionID&lt;/code&gt;. &lt;code&gt;SessionID&lt;/code&gt; must be the value given as input to the ESI callback function that you implemented.</source>
          <target state="translated">스크립트가 HTTP 헤더 필드를 추가 한 경우, 그것들은 &lt;code&gt;deliver/2&lt;/code&gt; 를 처음 호출해야하고 호출의 데이터는 문자열이어야합니다. 헤더가 완료된 후의 호출에는 복사 오버 헤드를 줄이기 위해 이진 데이터가 포함될 수 있습니다. &lt;code&gt;SessionID&lt;/code&gt; 의 데이터 유형에 대해서는 아무 것도 가정하지 마십시오 . &lt;code&gt;SessionID&lt;/code&gt; 는 구현 한 ESI 콜백 함수에 대한 입력으로 제공된 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5adb78f4f1efbc66139e964187c434397d354611" translate="yes" xml:space="preserve">
          <source>If any argument has the wrong format.</source>
          <target state="translated">인수의 형식이 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="b0b51878bfcad40bdb7c8e819fd02580c5711eff" translate="yes" xml:space="preserve">
          <source>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason &lt;code&gt;shutdown&lt;/code&gt; and then terminate itself and returns &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 시작 기능이 실패하거나 오류 튜플 또는 잘못된 값을 리턴하는 경우, 수퍼바이저는 먼저 이유 &lt;code&gt;shutdown&lt;/code&gt; 와 함께 이미 시작된 모든 하위 프로세스를 종료 한 후 자체 종료 하고 &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ebd2be4d8ca214fa53676834f412514083348fde" translate="yes" xml:space="preserve">
          <source>If any functions (for example, Telnet or FTP) using &quot;required configuration data&quot; are to be called from the Erlang shell, configuration data must first be required with &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang 쉘에서 &quot;필수 구성 데이터&quot;를 사용하는 기능 (예 : Telnet 또는 FTP)을 호출하려면 먼저 &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; 와 함께 구성 데이터가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="784d2fd65e27ddf88a5b740f50b285e092cfde1d" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt; ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;필수 구성 데이터&quot;(예 : 함수 &lt;code&gt;ct_telnet&lt;/code&gt; 또는 &lt;code&gt;ct_ftp&lt;/code&gt; )를 사용하는 함수 가 Erlang 쉘에서 호출되는 경우 먼저 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt; ct:require/1,2&lt;/a&gt;&lt;/code&gt; 를 사용 하여 구성 데이터가 필요합니다 . 이는 &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;require&lt;/code&gt; 문과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e7f4af54f6decb45db597b9e963b792ae46e26cb" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;필수 구성 데이터&quot;를 사용하는 기능 (예 : 기능 &lt;code&gt;ct_telnet&lt;/code&gt; 또는 &lt;code&gt;ct_ftp&lt;/code&gt; )을 Erlang 쉘에서 호출하려면 먼저 &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; 의 구성 데이터가 필요합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;require&lt;/code&gt; 문과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="50c6245e20c77d69a688a02f4c540697d905913f" translate="yes" xml:space="preserve">
          <source>If any of the arguments are invalid, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">인수 중 하나라도 유효하지 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b3295c7085224a5c975d29da6224a233ad1e1a01" translate="yes" xml:space="preserve">
          <source>If any of the socket &lt;code&gt;&lt;a href=&quot;#type-option&quot;&gt;options&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; are active, the &lt;code&gt;RecvData&lt;/code&gt; tuple contains an &lt;code&gt;AncData&lt;/code&gt; field, otherwise it does not.</source>
          <target state="translated">소켓 &lt;code&gt;&lt;a href=&quot;#type-option&quot;&gt;options&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;inet#option-recvtos&quot;&gt;recvtos&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;inet#option-recvtclass&quot;&gt;recvtclass&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;inet#option-recvttl&quot;&gt;recvttl&lt;/a&gt;&lt;/code&gt; 이 활성화 된 경우 &lt;code&gt;RecvData&lt;/code&gt; 튜플에 &lt;code&gt;AncData&lt;/code&gt; 필드가 포함되고 그렇지 않으면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="692ed4da2eebf1c4f217366a6369dae2f3d80d78" translate="yes" xml:space="preserve">
          <source>If any of the tables does not exist or the Dets table is not open, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">테이블이 없거나 Dets 테이블이 열리지 않으면 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="570be644a648abf241c9b8dd2548fe13d19dd232" translate="yes" xml:space="preserve">
          <source>If any of these errors occur when &lt;code&gt;+sbt&lt;/code&gt; has been passed, the runtime system prints an error message, and refuses to start. If any of these errors occur when &lt;code&gt;+stbt&lt;/code&gt; has been passed, the runtime system silently ignores the error, and start up using unbound schedulers.</source>
          <target state="translated">&lt;code&gt;+sbt&lt;/code&gt; 가 전달 될 때 이러한 오류가 발생하면 런타임 시스템은 오류 메시지를 인쇄하고 시작을 거부합니다. &lt;code&gt;+stbt&lt;/code&gt; 가 전달 될 때 이러한 오류가 발생하면 런타임 시스템은 자동으로 오류를 무시하고 바인딩되지 않은 스케줄러를 사용하여 시작합니다.</target>
        </trans-unit>
        <trans-unit id="eaa7aa976033707bd386e9983d12159b899132bc" translate="yes" xml:space="preserve">
          <source>If any one of these are true:</source>
          <target state="translated">다음 중 하나에 해당하는 경우 :</target>
        </trans-unit>
        <trans-unit id="96761e0bc247ac872393ae1bb5eb9df6c975a841" translate="yes" xml:space="preserve">
          <source>If any position specified in &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; size of the replacement binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">대체 바이너리의 &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; 크기에 지정된 위치가 있으면 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3ad0f81da4a204750014fc62764a9cd40b26ee9" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;-daemon&lt;/code&gt; is not specified, &lt;code&gt;epmd&lt;/code&gt; runs as a normal program with the controlling terminal of the shell in which it is started. Normally, it is to be run as a daemon.</source>
          <target state="translated">&lt;code&gt;-daemon&lt;/code&gt; 인수를 지정하지 않으면 &lt;code&gt;epmd&lt;/code&gt; 는 시작된 쉘의 제어 터미널과 함께 일반 프로그램으로 실행됩니다. 일반적으로 데몬으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dca95539f85ceb7c7fbb3f3a95acdd29f703f0c8" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Archive&lt;/code&gt; is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename.</source>
          <target state="translated">&lt;code&gt;Archive&lt;/code&gt; 인수 가 2 진으로 지정된 경우 2 진의 컨텐츠는 zip 아카이브로 간주되고 그렇지 않으면 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4234f7b924c77e169e97fc3a3a0a5fff439177f4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;MFA&lt;/code&gt; is the atom &lt;code&gt;on_load&lt;/code&gt;, the match specification and flag list are used on all modules that are newly loaded.</source>
          <target state="translated">인수 &lt;code&gt;MFA&lt;/code&gt; 가 원자 &lt;code&gt;on_load&lt;/code&gt; 인 경우 일치 스펙 및 플래그 목록은 새로로드 된 모든 모듈에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5218de8ae45e50ce943a78eed5b9597b86f9e98a" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{binary,Binary}&lt;/code&gt;, the contents of the binary is assumed to be a tar archive.</source>
          <target state="translated">인수 &lt;code&gt;Name&lt;/code&gt; 이 &lt;code&gt;{binary,Binary}&lt;/code&gt; 로 지정 되면 2 진의 컨텐츠는 tar 아카이브 인 것으로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="2a16809777595118890feda8207e9529558557f0" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{file,Fd}&lt;/code&gt;, &lt;code&gt;Fd&lt;/code&gt; is assumed to be a file descriptor returned from function &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;Name&lt;/code&gt; 이 &lt;code&gt;{file,Fd}&lt;/code&gt; 로 지정 되면 &lt;code&gt;Fd&lt;/code&gt; 는 함수 &lt;code&gt;file:open/2&lt;/code&gt; 에서 리턴 된 파일 디스크립터 인 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8eca364f037b451eb12fd01d43884ccc2a4bd5d4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;type&lt;/code&gt; is specified, all loaded reports of this type are displayed. If an integer argument is specified, the report with this reference number is displayed. If no argument is specified, all reports are displayed.</source>
          <target state="translated">인수 &lt;code&gt;type&lt;/code&gt; 을 지정하면이 유형의로드 된 모든 보고서가 표시됩니다. 정수 인수가 지정되면이 참조 번호가있는 보고서가 표시됩니다. 인수를 지정하지 않으면 모든 보고서가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d9ccdcf897aa5e543e57f74baa9344de03cc64a" translate="yes" xml:space="preserve">
          <source>If atom &lt;code&gt;start&lt;/code&gt; is specified as continuation, a disk log to read terms from is chosen. A local or distributed disk log on the current node is preferred to an individual distributed log on some other node.</source>
          <target state="translated">원자 &lt;code&gt;start&lt;/code&gt; 이 연속으로 지정된 경우 용어를 읽을 디스크 로그가 선택됩니다. 현재 노드의 로컬 또는 분산 디스크 로그는 다른 노드의 개별 분산 로그보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c06078653d000d4834d7b538bf165c25d0318c" translate="yes" xml:space="preserve">
          <source>If atomic grouping is used for the previous example, the matcher gives up immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of special parenthesis, starting with &lt;code&gt;(?&amp;gt;&lt;/code&gt; as in the following example:</source>
          <target state="translated">이전 예에서 원자 그룹화를 사용하는 경우, 매처는 &quot;foo&quot;와 처음 일치하지 않으면 즉시 포기합니다. 이 표기법은 다음 예 와 같이 &lt;code&gt;(?&amp;gt;&lt;/code&gt; 로 시작하는 일종의 특수 괄호입니다 .</target>
        </trans-unit>
        <trans-unit id="6a9902259e3c589622f30bf01a90d5b7ffcb0cc1" translate="yes" xml:space="preserve">
          <source>If attribute &lt;code&gt;{local_content, true}&lt;/code&gt; is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</source>
          <target state="translated">테이블을 작성할 때 속성 &lt;code&gt;{local_content, true}&lt;/code&gt; 가 지정되면 테이블은 존재하도록 테이블을 지정하는 노드에 상주하지만 테이블에 대한 쓰기 조작은 로컬 사본에서만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd8d24d8a76114c5ed2e0d95e53c4aab5d47e75" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application.</source>
          <target state="translated">인증 또는 암호화가 사용되는 경우 (SNMPv3 만 해당) &lt;code&gt;crypto&lt;/code&gt; 응용 프로그램을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="b32ca34021019e0bb153a3955d0b724a94e48269" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application. If this step is forgotten, the agent will not start, but report a &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; error.</source>
          <target state="translated">인증 또는 암호화가 사용되는 경우 (SNMPv3 만 해당) &lt;code&gt;crypto&lt;/code&gt; 응용 프로그램을 시작하십시오 . 이 단계를 잊어 버린 경우 에이전트는 시작되지 않지만 &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a84fea11161ee2b8221ded08279d7f5da6e7793e" translate="yes" xml:space="preserve">
          <source>If auto-skipped test cases do not affect the exit status. The default behavior can be changed using start flag:</source>
          <target state="translated">자동 건너 뛴 테스트 사례가 종료 상태에 영향을 미치지 않는 경우. 기본 동작은 시작 플래그를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54c92e18be4a676b9c1c2d1749ff8f920d1f0f1" translate="yes" xml:space="preserve">
          <source>If automatic commit mode is turned on, each query will be considered as an individual transaction and will be automatically committed after it has been executed. If you want more than one query to be part of the same transaction the automatic commit mode should be turned off. Then you will have to call commit/3 explicitly to end a transaction.</source>
          <target state="translated">자동 커밋 모드가 설정되어 있으면 각 쿼리는 개별 트랜잭션으로 간주되며 실행 후 자동 커밋됩니다. 둘 이상의 조회가 동일한 트랜잭션의 일부가되도록하려면 자동 확약 모드를 해제해야합니다. 그런 다음 commit / 3을 명시 적으로 호출하여 트랜잭션을 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe29c622b52d7e166afb8b3558351d082aa789d3" translate="yes" xml:space="preserve">
          <source>If available in the dump, this is the total number of atoms in the atom table. If the size of the atom table is unavailable, the number of atoms visible in the dump is displayed.</source>
          <target state="translated">덤프에서 사용 가능한 경우 이는 원자 테이블의 총 원자 수입니다. 원자 테이블의 크기를 사용할 수없는 경우 덤프에 표시되는 원자 수가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1614181d9da9b94aedfb64164481447f45935dca" translate="yes" xml:space="preserve">
          <source>If binaries that are no longer used are to be thrown away as soon as possible. (Set &lt;code&gt;Number&lt;/code&gt; to zero.)</source>
          <target state="translated">더 이상 사용되지 않는 바이너리는 가능한 빨리 버려야합니다. ( &lt;code&gt;Number&lt;/code&gt; 를 0으로 설정하십시오 .)</target>
        </trans-unit>
        <trans-unit id="88996aec0b15ab1d16ddf824ee8cf7cd32e2a161" translate="yes" xml:space="preserve">
          <source>If binding of schedulers is not supported.</source>
          <target state="translated">스케줄러 바인딩이 지원되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="90d98aa8f41f34030c7bdee94cac730737033718" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Destination&lt;/code&gt; refer to filenames, the files are opened with &lt;code&gt;[read, binary]&lt;/code&gt; and &lt;code&gt;[write, binary]&lt;/code&gt; prepended to their mode lists, respectively, to optimize the copy.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 와 &lt;code&gt;Destination&lt;/code&gt; 이 모두 파일 이름을 참조하는 경우 파일을 복사하기 위해 &lt;code&gt;[read, binary]&lt;/code&gt; 및 &lt;code&gt;[write, binary]&lt;/code&gt; 각각 모드 목록 앞에 추가되어 열립니다 .</target>
        </trans-unit>
        <trans-unit id="2c3e1b70d92e6d563bb5e9d6c3cd26f59813a13f" translate="yes" xml:space="preserve">
          <source>If call count tracing is started while already running, the count is restarted from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">이미 실행중인 동안 통화 카운트 추적이 시작되면 카운트는 0에서 다시 시작됩니다. 실행 카운터를 일시 중지하려면 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 사용 하십시오 . 일시 정지 및 실행 카운터는 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 0부터 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ddb54b87a2d744f4668c0309f8b603f7cbd2a39" translate="yes" xml:space="preserve">
          <source>If call counters are still running while &lt;code&gt;analyse/0..2&lt;/code&gt; is executing, you might get an inconsistent result. This happens if the process executing &lt;code&gt;analyse/0..2&lt;/code&gt; gets scheduled out so some other process can increment the counters that are being analysed, Calling &lt;code&gt;pause()&lt;/code&gt; before analysing takes care of the problem.</source>
          <target state="translated">&lt;code&gt;analyse/0..2&lt;/code&gt; 가 실행 되는 동안 콜 카운터가 여전히 실행 중이면 결과가 일치하지 않을 수 있습니다. 이는 &lt;code&gt;analyse/0..2&lt;/code&gt; 실행하는 프로세스 가 예약되어 다른 프로세스가 분석중인 카운터를 증가시킬 수 있는 경우에 발생합니다. 분석하기 전에 &lt;code&gt;pause()&lt;/code&gt; 를 호출 하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="ad4325523bd9822e6e53cf121c4e7f2d415527ec" translate="yes" xml:space="preserve">
          <source>If call time tracing is started while already running, the count and time restart from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">통화 시간 추적이 이미 실행되는 동안 시작되면 카운트와 시간이 0에서 다시 시작됩니다. 실행 카운터를 일시 중지하려면 &lt;code&gt;MatchSpec == pause&lt;/code&gt; 사용 하십시오 . 일시 정지 및 실행 카운터는 &lt;code&gt;MatchSpec == restart&lt;/code&gt; 0부터 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8441a1f4ebffc73cdc2dc005353bc55ee1751fa1" translate="yes" xml:space="preserve">
          <source>If called several times, only the last comment is printed. The test case return value &lt;code&gt;{comment,Comment}&lt;/code&gt; overwrites the string set by this function.</source>
          <target state="translated">여러 번 호출하면 마지막 주석 만 인쇄됩니다. 테스트 케이스 리턴 값 &lt;code&gt;{comment,Comment}&lt;/code&gt; 는이 함수로 설정된 문자열을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="ada9d2aefe42bda67c41d0801c3618aeb38428b7" translate="yes" xml:space="preserve">
          <source>If called with an extension unknown to the user application, return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">사용자 애플리케이션에 알려지지 않은 확장자로 호출 된 경우, 리턴 값 &lt;code&gt;{unknown, UserState}&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="610648cf712693e340f20ab9aac63c6b94c019dc" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;FormatFun&lt;/code&gt; with an argument including &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; fails, &lt;code&gt;FormatFun&lt;/code&gt; is called once again with an argument excluding &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; (&lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;NElements&lt;/code&gt; 및 &lt;code&gt;DepthFun&lt;/code&gt; 을 포함하는 인수로 &lt;code&gt;FormatFun&lt;/code&gt; 을 호출 하는 데 실패하면 &lt;code&gt;NElements&lt;/code&gt; 및 &lt;code&gt;DepthFun&lt;/code&gt; 을 제외한 인수 ( &lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; 또는 &lt;code&gt;all&lt;/code&gt; )를 사용하여 &lt;code&gt;FormatFun&lt;/code&gt; 이 다시 한 번 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="77f72ab6f85f6c9d8cbda669ebba998dc661fc5e" translate="yes" xml:space="preserve">
          <source>If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, although the original capturing subpattern is matched caselessly:</source>
          <target state="translated">역 참조시 대 / 소문자 일치가 적용되는 경우 문자 대 / 소문자가 적합합니다. 예를 들어, 원래 캡처 서브 패턴이 대소 문자없이 일치하더라도 다음은 &quot;rah rah&quot;및 &quot;RAH RAH&quot;와 일치하지만 &quot;RAH rah&quot;와는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e13d741efb191e9fa7c1727072c2302000c01f26" translate="yes" xml:space="preserve">
          <source>If certain port-specific data must be accessed from other threads than those calling the driver callbacks, a port data lock can be used to synchronize the operations on the data. Currently, the only port-specific data that the emulator associates with the port data lock is the driver queue.</source>
          <target state="translated">드라이버 콜백을 호출하는 스레드가 아닌 다른 스레드에서 특정 포트 특정 데이터에 액세스해야하는 경우 포트 데이터 잠금을 사용하여 데이터 작업을 동기화 할 수 있습니다. 현재 에뮬레이터가 포트 데이터 잠금과 연결하는 유일한 포트 별 데이터는 드라이버 큐입니다.</target>
        </trans-unit>
        <trans-unit id="cd4b4afe54513271fef096e7c304b9cfa2e00765" translate="yes" xml:space="preserve">
          <source>If command line option +MMscrpm (Reserve Physical Memory) is set to false, only virtual space is allocated for the super carrier from start. The super carrier then acts as an &quot;alternative mmap&quot; implementation without changing the consumption of physical memory pages. Physical pages will be reserved on demand when an allocation is done from the super carrier and be unreserved when the memory is released back to the super carrier.</source>
          <target state="translated">명령 줄 옵션 + MMscrpm (물리적 메모리 예약)이 false로 설정되면 처음부터 슈퍼 캐리어에 가상 공간 만 할당됩니다. 그러면 슈퍼 캐리어는 물리적 메모리 페이지의 소비를 변경하지 않고 &quot;대체 mmap&quot;구현으로 작동합니다. 물리적 페이지는 슈퍼 캐리어에서 할당이 수행 될 때 요청시 예약되고 메모리가 슈퍼 캐리어로 다시 해제 될 때 예약 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f54d5e9e6d2fd31d6eabb83cccb9c261c4f828a5" translate="yes" xml:space="preserve">
          <source>If compilation fails for one or more suites, the compilation errors are printed to tty and the operator is asked if the test run is to proceed without the missing suites, or be aborted. If the operator chooses to proceed, the tests having missing suites are noted in the HTML log. If &lt;code&gt;Common Test&lt;/code&gt; is unable to prompt the user after compilation failure (if &lt;code&gt;Common Test&lt;/code&gt; does not control &lt;code&gt;stdin&lt;/code&gt;), the test run proceeds automatically without the missing suites. This behavior can however be modified with the &lt;code&gt;ct_run&lt;/code&gt; flag &lt;code&gt;-abort_if_missing_suites&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; option &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt;. If &lt;code&gt;abort_if_missing_suites&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the test run stops immediately if some suites fail to compile.</source>
          <target state="translated">하나 이상의 스위트에 대해 컴파일이 실패하면 컴파일 오류가 tty에 인쇄되고 운영자는 누락 된 스위트없이 테스트 실행을 진행해야하는지 아니면 중단되어야하는지 묻습니다. 운영자가 진행하기로 선택하면 스위트가 누락 된 테스트가 HTML 로그에 표시됩니다. 경우 &lt;code&gt;Common Test&lt;/code&gt; (경우 컴파일 실패 후 사용자에게 메시지를 표시 할 수없는 &lt;code&gt;Common Test&lt;/code&gt; 제어하지 않습니다 &lt;code&gt;stdin&lt;/code&gt; ), 테스트 실행이 누락 된 스위트 룸없이 자동으로 진행된다. 그러나이 동작은 &lt;code&gt;ct_run&lt;/code&gt; 플래그 &lt;code&gt;-abort_if_missing_suites&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 옵션 &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt; 로 수정할 수 있습니다. &lt;code&gt;abort_if_missing_suites&lt;/code&gt; 인 경우로 설정되어 &lt;code&gt;true&lt;/code&gt; , 테스트 실행은 일부 스위트 룸 컴파일에 실패하면 즉시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="ddef6fb238c70a7447c7b61165fd491bf02611b6" translate="yes" xml:space="preserve">
          <source>If compiling a NIF for static inclusion through &lt;code&gt;--enable-static-nifs&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; before the &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;--enable-static-nifs&lt;/code&gt; 를 통해 정적 포함을 위해 NIF를 컴파일하는 경우 &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; 선언 전에 &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9cca373adf442d693560ee904763df365fc27eee" translate="yes" xml:space="preserve">
          <source>If compiling a driver for static inclusion through &lt;code&gt;--enable-static-drivers&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; before the &lt;code&gt;DRIVER_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;--enable-static-drivers&lt;/code&gt; 를 통해 정적 포함을 위해 드라이버를 컴파일하는 경우 &lt;code&gt;DRIVER_INIT&lt;/code&gt; 선언 전에 &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f7c1f0b07bbf198171947df86c5f80f0e8b91bec" translate="yes" xml:space="preserve">
          <source>If configuration elements (key-value tuples) are to be returned as result instead of values, use option &lt;code&gt;element&lt;/code&gt;. The returned elements are then on the form &lt;code&gt;{Required,Value}&lt;/code&gt;.</source>
          <target state="translated">구성 요소 (키-값 튜플)를 값 대신 결과로 리턴하려면 option &lt;code&gt;element&lt;/code&gt; 를 사용하십시오 . 리턴 된 요소는 &lt;code&gt;{Required,Value}&lt;/code&gt; 양식 입니다.</target>
        </trans-unit>
        <trans-unit id="9e21b434342c495e7cd41bb3f46d93a5eba516c9" translate="yes" xml:space="preserve">
          <source>If containing a &quot;supported_groups&quot; extension, it MUST also contain a &quot;key_share&quot; extension, and vice versa. An empty KeyShare.client_shares vector is permitted.</source>
          <target state="translated">&quot;supported_groups&quot;확장을 포함하는 경우 &quot;key_share&quot;확장도 포함해야하며 그 반대의 경우도 마찬가지입니다. 빈 KeyShare.client_shares 벡터가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f827f0de33d203f9e3d3e27b4a69d02e3a754313" translate="yes" xml:space="preserve">
          <source>If cross cover analysis is performed, and there are accumulated coverage results for the current test, the link &quot;Coverdata collected over all tests&quot; takes you to these results.</source>
          <target state="translated">교차 커버 분석이 수행되고 현재 테스트에 대해 누적 된 커버리지 결과가있는 경우 &quot;모든 테스트에서 수집 된 표지 데이터&quot;링크가이 결과로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5d96e5091e8d9707ed005b18c015f0afc06954f5" translate="yes" xml:space="preserve">
          <source>If data is sent to an &lt;code&gt;io_device()&lt;/code&gt; in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file is closed.</source>
          <target state="translated">지정된 인코딩으로 변환 할 수없는 형식으로 데이터를 &lt;code&gt;io_device()&lt;/code&gt; 로 보내 거나 데이터의 문자 범위를 처리 할 수없는 형식으로 데이터를 반환하는 함수에서 데이터를 읽으면 오류가 발생하고 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="432e1b16af8182ee4323fbba32056a19e755694b" translate="yes" xml:space="preserve">
          <source>If defined, disables input and output flow control for the pty opend by &lt;code&gt;run_erl&lt;/code&gt;. Useful if you want to remove any risk of accidentally blocking the flow control by using Ctrl-S (instead of Ctrl-D to detach), which can result in blocking of the entire Beam process, and in the case of running heart as supervisor even the heart process becomes blocked when writing log message to terminal, leaving the heart process unable to do its work.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;run_erl&lt;/code&gt; 에 의해 열린 pty에 대한 입력 및 출력 흐름 제어를 비활성화합니다 . Ctrl-D 대신 분리하여 Ctrl-S를 사용하여 실수로 흐름 제어를 차단하여 빔 프로세스 전체를 차단할 수 있으며 감독자로서 심장을 움직이는 경우에도 유용합니다. 터미널에 로그 메시지를 쓸 때 심장 프로세스가 차단되어 심장 프로세스가 작업을 수행 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="51ec3e002de949fe36acc63a13c907879ad3bcd0" translate="yes" xml:space="preserve">
          <source>If differentiation between empty matches and non-existing subpatterns is necessary, use the &lt;code&gt;type&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; and do the conversion to the final type in Erlang code.</source>
          <target state="translated">빈 일치 항목과 존재하지 않는 하위 패턴을 구별해야하는 경우 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;index&lt;/code&gt; 사용하고 Erlang 코드에서 최종 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="49295520e0b6d8a184569401922957d15009d327" translate="yes" xml:space="preserve">
          <source>If doing encryption, the &lt;code&gt;final_fun()&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; is applied to the last piece of data. The &lt;code&gt;final_fun()&lt;/code&gt; is responsible for padding (if needed) and encryption of that last piece.</source>
          <target state="translated">암호화를 수행하는 경우, &lt;code&gt;final_fun()&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#type-tar_crypto_spec&quot;&gt;tar_crypto_spec&lt;/a&gt;&lt;/code&gt; 는 데이터의 마지막 부분에 적용된다. &lt;code&gt;final_fun()&lt;/code&gt; 마지막 부분의 패딩 (필요한 경우) 및 암호화에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e301f5120b552d4bf6f7613573c8dff6a6c32f8f" translate="yes" xml:space="preserve">
          <source>If empty, the scheduler was doing some work. If not empty, the scheduler is either in some state of sleep, or suspended. This entry is only present in an SMP-enabled emulator.</source>
          <target state="translated">비어 있으면 스케줄러가 작업을 수행 한 것입니다. 비어 있지 않으면 스케줄러가 일부 절전 상태이거나 일시 중단 된 것입니다. 이 항목은 SMP 가능 에뮬레이터에만 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afa77778077164a71f88c72fb4b32ad3297d31d" translate="yes" xml:space="preserve">
          <source>If enabled and available, shows the process SASL log entries.</source>
          <target state="translated">사용 가능하고 사용 가능한 경우 프로세스 SASL 로그 항목을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7f6edf3b58ff2519bb720cd88ea08b2b0a6a0946" translate="yes" xml:space="preserve">
          <source>If enabled, a signal will be sent to each scheduler to check its responsiveness. The system check occurs before any heartbeat sent to the port program. If any scheduler is not responsive enough the heart program will not receive its heartbeat and thus eventually terminate the node.</source>
          <target state="translated">활성화 된 경우 각 스케줄러에 신호가 전송되어 응답 성을 확인합니다. 시스템 점검은 하트 비트가 포트 프로그램으로 전송되기 전에 발생합니다. 스케줄러가 충분히 응답하지 않으면 심장 프로그램은 해당 하트 비트를 수신하지 않으므로 결국 노드를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="148b1ea2e5a9c15263dc8ca4149113489de1e307" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function can add possible default values or internal state values to the configuration, and return the adjusted map in &lt;code&gt;{ok,Config2}&lt;/code&gt;.</source>
          <target state="translated">모든 것이 성공하면 콜백 함수는 가능한 기본값 또는 내부 상태 값을 구성에 추가하고 조정 된 맵을 &lt;code&gt;{ok,Config2}&lt;/code&gt; 에 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df38b6fefb42b5ad05d2e66a0fe9a0579def5bda" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config3}&lt;/code&gt;.</source>
          <target state="translated">모든 것이 성공하면 콜백 함수는 &lt;code&gt;{ok,Config3}&lt;/code&gt; 에서 조정 가능한 구성을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fa1005e80fa8c58a4740b29710f28976ae1bc25" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config}&lt;/code&gt;.</source>
          <target state="translated">모든 것이 성공하면 콜백 함수는 &lt;code&gt;{ok,Config}&lt;/code&gt; 에 조정 된 구성을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="364e140fe39154a26dff03af44ca4298c8c2ac50" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;-loader&lt;/code&gt; is omitted, it defaults to &lt;code&gt;efile&lt;/code&gt;.</source>
          <target state="translated">flag &lt;code&gt;-loader&lt;/code&gt; 를 생략하면 기본값은 &lt;code&gt;efile&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1454b961b40da8803e24e93858c630e5ff3bb457" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, or &lt;code&gt;monotonic_timestamp&lt;/code&gt; is specified, the first tuple element is &lt;code&gt;trace_ts&lt;/code&gt; instead, and the time stamp is added as an extra element last in the message tuple. If multiple time stamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All time stamp flags are remembered, so if two are passed and the one with highest precedence later is disabled, the other one becomes active.</source>
          <target state="translated">플래그 &lt;code&gt;timestamp&lt;/code&gt; , &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 또는 &lt;code&gt;monotonic_timestamp&lt;/code&gt; 가 지정되면 첫 번째 튜플 요소는 대신 &lt;code&gt;trace_ts&lt;/code&gt; 이며 타임 스탬프는 메시지 튜플에서 마지막으로 추가 요소로 추가됩니다. 여러 타임 스탬프 플래그가 전달되면 &lt;code&gt;timestamp&lt;/code&gt; 는 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 보다 우선하며, &lt;code&gt;monotonic_timestamp&lt;/code&gt; 보다 우선 합니다. 모든 타임 스탬프 플래그가 기억되므로 두 개가 전달되고 우선 순위가 가장 높은 것이 비활성화 된 경우 다른 하나가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5b82748f9af0c18d76e825667a1416cb4f5744" translate="yes" xml:space="preserve">
          <source>If flags &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt; are specified in the &lt;code&gt;Common Test&lt;/code&gt; group of options (preceding &lt;code&gt;-erl_args&lt;/code&gt;), relative directories are converted to absolute and reinserted into the code path by &lt;code&gt;Common Test&lt;/code&gt;. This is to avoid problems loading user modules when &lt;code&gt;Common Test&lt;/code&gt; changes working directory during test runs. However, &lt;code&gt;Common Test&lt;/code&gt; ignores flags &lt;code&gt;-pa&lt;/code&gt; and &lt;code&gt;-pz&lt;/code&gt; following &lt;code&gt;-erl_args&lt;/code&gt; on the command line. These directories are added to the code path normally (that is, on specified form).</source>
          <target state="translated">플래그 &lt;code&gt;-pa&lt;/code&gt; 또는 &lt;code&gt;-pz&lt;/code&gt; 가 &lt;code&gt;Common Test&lt;/code&gt; 그룹 옵션 (앞에 &lt;code&gt;-erl_args&lt;/code&gt; )에 지정된 경우 상대 디렉토리는 절대로 변환되고 &lt;code&gt;Common Test&lt;/code&gt; 의해 코드 경로에 다시 삽입됩니다 . 이는 &lt;code&gt;Common Test&lt;/code&gt; 가 테스트 실행 중 작업 디렉토리를 변경할 때 사용자 모듈을로드하는 데 문제가 발생하지 않도록하기위한 것 입니다. 그러나 &lt;code&gt;Common Test&lt;/code&gt; 는 명령 행에서 &lt;code&gt;-pz&lt;/code&gt; 다음에 &lt;code&gt;-erl_args&lt;/code&gt; 플래그 &lt;code&gt;-pa&lt;/code&gt; 및 -pz를 무시합니다 . 이러한 디렉토리는 코드 경로에 정상적으로 (즉, 지정된 형식으로) 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1e378e106e4077ae24d5e6f29ec376f6a4bd3b26" translate="yes" xml:space="preserve">
          <source>If for some reason megaco is unable to deliver the reply, the reason for this will be passed to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;, unless &lt;code&gt;ack_action() = discard_ack&lt;/code&gt;.</source>
          <target state="translated">어떤 이유로 megaco가 응답을 전달할 수없는 경우, &lt;code&gt;ack_action() = discard_ack&lt;/code&gt; 아닌 한 콜백 함수 &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; 에 대한 호출을 통해 해당 이유가 사용자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="17a3144d24e90d3f080c638b20288fd31695b9f8" translate="yes" xml:space="preserve">
          <source>If found, this file is automatically included when a release package is created.</source>
          <target state="translated">발견되면이 파일은 릴리스 패키지가 작성 될 때 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="88a8d1bcc6dc202674f35ee136d67e69ecbf0dcd" translate="yes" xml:space="preserve">
          <source>If function &lt;code&gt;start_link/3,4,5&lt;/code&gt; is used and the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;{error, Reason}&lt;/code&gt; is returned if the calling process traps exits.</source>
          <target state="translated">기능의 경우 &lt;code&gt;start_link/3,4,5&lt;/code&gt; 이 호출되기 전에 사용되는 프로세스가 충돌 &lt;code&gt;init_ack/1,2&lt;/code&gt; , &lt;code&gt;{error, Reason}&lt;/code&gt; 호출 프로세스 트랩 종료하는 경우 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc69364c0ae557a1dbe6b4d9aa1b146e1216ffbd" translate="yes" xml:space="preserve">
          <source>If function calls are traced, trace patterns must be added by clicking button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt;. Select a module, function(s), and a match specification. If no functions are selected, all functions in the module are traced.</source>
          <target state="translated">함수 호출이 추적되면 추적 패턴 추가 단추를 클릭하여 &lt;strong&gt;추적 패턴을 추가&lt;/strong&gt; 해야합니다 . 모듈, 기능 및 일치 사양을 선택하십시오. 기능을 선택하지 않으면 모듈의 모든 기능이 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="1f07e18dbc5f57c6c6717a768b0ed4eaba425e5a" translate="yes" xml:space="preserve">
          <source>If given, sets a minimum of bytes per second value for connections.</source>
          <target state="translated">주어진 경우 연결에 대한 최소 바이트 / 초 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b172d1229983e5a1a9ff5fbcf190541819d75da7" translate="yes" xml:space="preserve">
          <source>If header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is not included, the fun is not translated, which can result in a &lt;strong&gt;runtime error&lt;/strong&gt; (depending on whether the fun is valid in a pure Erlang context).</source>
          <target state="translated">헤더 파일 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 이 포함되어 있지 않으면 fun이 변환되지 않으므로 &lt;strong&gt;런타임 오류가&lt;/strong&gt; 발생할 수 있습니다 (fun이 순수한 Erlang 컨텍스트에서 유효한지 여부에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="16995098726e7577905f8e4783d07b32252efedf" translate="yes" xml:space="preserve">
          <source>If heart should &lt;strong&gt;not&lt;/strong&gt; kill the Erlang runtime system, this can be indicated using the environment variable &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt;. This can be useful if the command executed by heart takes care of this, for example as part of a specific cleanup sequence. If unset, or not set to &lt;code&gt;TRUE&lt;/code&gt;, the default behaviour will be to kill as described above.</source>
          <target state="translated">심장이 Erlang 런타임 시스템을 종료 &lt;strong&gt;하지&lt;/strong&gt; 않아야 하는 경우 환경 변수 &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt; 를 사용하여이를 표시 할 수 있습니다 . 이는 예를 들어 특정 정리 시퀀스의 일부로 마음으로 실행되는 명령이이를 처리하는 경우 유용 할 수 있습니다. 설정하지 않거나 &lt;code&gt;TRUE&lt;/code&gt; 로 설정하지 않으면 기본 동작은 위에서 설명한대로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b95d064b6fe476b33228869a58d35631e292ffa4" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;ch3&lt;/code&gt; belong to the same application, the &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">대신 &lt;code&gt;m1&lt;/code&gt; 과 &lt;code&gt;ch3&lt;/code&gt; 이 동일한 응용 프로그램에 속하는 경우 &lt;code&gt;.appup&lt;/code&gt; 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc6d61b4492f1c7e6142a54cbe978ede62016351" translate="yes" xml:space="preserve">
          <source>If instead the cover specification for &lt;code&gt;s2&lt;/code&gt; is like the following:</source>
          <target state="translated">대신 &lt;code&gt;s2&lt;/code&gt; 의 커버 사양 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a7e93ff7cf25c1c8178af08584a9eabcf3e9a0a" translate="yes" xml:space="preserve">
          <source>If instead the following pattern is used, it matches &quot;sense and responsibility&quot; and the other two strings:</source>
          <target state="translated">대신 다음 패턴이 사용되면 &quot;센스와 책임&quot;및 다른 두 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2cc8cc207fcbebe26bafa392de36c0b0727d0b02" translate="yes" xml:space="preserve">
          <source>If it is determined during execution of &lt;code&gt;end_per_testcase&lt;/code&gt; that the status of a successful test case is to be changed to failed, &lt;code&gt;end_per_testcase&lt;/code&gt; can return the tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; (where &lt;code&gt;Reason&lt;/code&gt; describes why the test case fails).</source>
          <target state="translated">&lt;code&gt;end_per_testcase&lt;/code&gt; 를 실행하는 동안 성공한 테스트 케이스의 상태가 실패로 변경되는 것으로 &lt;code&gt;end_per_testcase&lt;/code&gt; 되면 end_per_testcase 는 튜플 &lt;code&gt;{fail,Reason}&lt;/code&gt; ( 이유는 테스트 케이스가 실패한 &lt;code&gt;Reason&lt;/code&gt; 설명 함) 을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff18467b22f0114a8805a4726fb2dcc0392ce69" translate="yes" xml:space="preserve">
          <source>If it is important to get similar indentation and newlines as in the original document you have to add #xmlText{} records with space and newline values in appropriate places. It may also be necessary to keep the original prolog where the DTD is referenced. If so, it is possible to pass a RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; to &lt;code&gt;export_simple/3&lt;/code&gt;. The following example code fixes those changes in the previous example:</source>
          <target state="translated">원본 문서와 비슷한 들여 쓰기와 줄 바꿈을 얻는 것이 중요한 경우 적절한 위치에 공백과 줄 바꿈 값이있는 #xmlText {} 레코드를 추가해야합니다. DTD가 참조되는 원래 프롤로그를 유지해야 할 수도 있습니다. 그렇다면 RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; 를 &lt;code&gt;export_simple/3&lt;/code&gt; 에 전달할 수 있습니다 . 다음 예제 코드는 이전 예제의 변경 사항을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0edefb6e50405687abd870a868c1bcff5bf5189f" translate="yes" xml:space="preserve">
          <source>If it is important to minimize the time that an application is inactive while changing code, use &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;atomic_load/1&lt;/code&gt;. Here is an example:</source>
          <target state="translated">이 코드를 사용 변경하는 동안 응용 프로그램이 비활성화되는 시간을 최소화하는 것이 중요 경우 &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;atomic_load/1&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04b581ca359dbb5b4e61555833c3a8149c91dfc0" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_server&lt;/code&gt; must be set to trap exit signals in function &lt;code&gt;init&lt;/code&gt;. When ordered to shutdown, the &lt;code&gt;gen_server&lt;/code&gt; then calls the callback function &lt;code&gt;terminate(shutdown, State)&lt;/code&gt;:</source>
          <target state="translated">종료 전에 정리해야하는 경우 종료 전략은 시간 종료 값 이어야 하고 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;init&lt;/code&gt; 함수에서 종료 신호를 트랩하도록 설정해야합니다 . 종료 명령을 &lt;code&gt;gen_server&lt;/code&gt; 는 콜백 함수 &lt;code&gt;terminate(shutdown, State)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e79bb817b263e5ddf9ba4cef4ae14edfb7ff9782" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_statem&lt;/code&gt; must in function &lt;code&gt;init/1&lt;/code&gt; set itself to trap exit signals by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;:</source>
          <target state="translated">종료 전에 정리해야하는 경우 종료 전략은 시간 종료 값 이어야 하고 &lt;code&gt;gen_statem&lt;/code&gt; 은 &lt;code&gt;init/1&lt;/code&gt; 함수로 &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; 호출하여 종료 신호를 트랩하도록 자체 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c10551de78ce4c13b76bdcb633906a358226cfc9" translate="yes" xml:space="preserve">
          <source>If it is needed to compile a set of &lt;code&gt;ASN.1&lt;/code&gt; modules into an Erlang file with encode/decode functions, ensure to list all involved files in a configuration file. This configuration file must have a double extension &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; (&lt;code&gt;&quot;.asn&quot;&lt;/code&gt; can alternatively be &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; or &lt;code&gt;&quot;.py&quot;&lt;/code&gt;). List the input file names within quotation marks (&quot;&quot;), one at each row in the file. If the input files are &lt;code&gt;File1.asn&lt;/code&gt;, &lt;code&gt;File2.asn&lt;/code&gt;, and &lt;code&gt;File3.asn&lt;/code&gt;, the configuration file must look as follows:</source>
          <target state="translated">인코딩 / 디코딩 기능을 사용하여 &lt;code&gt;ASN.1&lt;/code&gt; 모듈 세트를 Erlang 파일로 컴파일해야하는 경우 구성 파일에 모든 관련 파일을 나열하십시오. 이 구성 파일은 이중 확장자 &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; 을 가져야합니다 ( &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;.py&quot;&lt;/code&gt; 일 수 있음 ). 파일의 각 행마다 하나씩 입력 파일 이름을 따옴표 ( &quot;&quot;)로 나열하십시오. 입력 파일이 &lt;code&gt;File1.asn&lt;/code&gt; , &lt;code&gt;File2.asn&lt;/code&gt; 및 &lt;code&gt;File3.asn&lt;/code&gt; 인 경우 구성 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="ac7e64fc378f2a5b91895bad1f8c83d469b481c8" translate="yes" xml:space="preserve">
          <source>If it is not specified it will use a default list ([x25519, x448, secp256r1, secp384r1]) that is filtered based on the installed crypto library version.</source>
          <target state="translated">지정되지 않은 경우 설치된 암호화 라이브러리 버전을 기반으로 필터링 된 기본 목록 ([x25519, x448, secp256r1, secp384r1])을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d51fd241eafb95c913d685374e5a264641108ee" translate="yes" xml:space="preserve">
          <source>If it is possible for a manager to create or delete rows in the table, there must be a &lt;code&gt;RowStatus&lt;/code&gt; column for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;undo&lt;/code&gt; to work properly.</source>
          <target state="translated">관리자가 테이블에서 행을 작성하거나 삭제할 수있는 경우 &lt;code&gt;is_set_ok&lt;/code&gt; 에 대한 &lt;code&gt;RowStatus&lt;/code&gt; 열 이 있어야하며 , &lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;undo&lt;/code&gt; 가 제대로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="78796728bcb7c7764f0d079115e6608598e07dda" translate="yes" xml:space="preserve">
          <source>If it is possible to load &lt;code&gt;Module&lt;/code&gt; and function &lt;code&gt;Function/N&lt;/code&gt; is exported, it is called.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 을로드 할 수 있고 &lt;code&gt;Function/N&lt;/code&gt; 기능을 내 보내면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="34f89c49da4f3e679accd5b84c8be09ec8b3341c" translate="yes" xml:space="preserve">
          <source>If it is required that Mnesia must build and maintain an extra index table on attribute &lt;code&gt;address&lt;/code&gt; of all the &lt;code&gt;person&lt;/code&gt; records that are inserted in the table, the following code would be issued:</source>
          <target state="translated">Mnesia가 테이블에 삽입 된 모든 &lt;code&gt;person&lt;/code&gt; 레코드 의 속성 &lt;code&gt;address&lt;/code&gt; 에 추가 인덱스 테이블을 빌드하고 유지 보수해야하는 경우 다음 코드가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="d545f3dffae84feb539a9a4a2658199f48d1fd1a" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;code&gt;auto&lt;/code&gt;, the client automatically handles received tickets and tries to use them when making new TLS connections (session resumption with pre-shared keys).</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 로 설정 되면 클라이언트는 수신 된 티켓을 자동으로 처리하고 새 TLS 연결을 만들 때이를 사용하려고합니다 (사전 공유 키를 사용한 세션 재개).</target>
        </trans-unit>
        <trans-unit id="a8576255de740a4f910003bb08212e24357ef1fd" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;code&gt;stateful&lt;/code&gt; or &lt;code&gt;stateless&lt;/code&gt;, session resumption with pre-shared keys is enabled and the server will send stateful or stateless session tickets to the client after successful connections.</source>
          <target state="translated">&lt;code&gt;stateful&lt;/code&gt; 또는 &lt;code&gt;stateless&lt;/code&gt; 로 설정된 경우 사전 공유 키를 사용한 세션 재개가 활성화되고 서버는 성공적인 연결 후 클라이언트에 Stateful 또는 Stateless 세션 티켓을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5cea858b85f406ece423faeb209b445f4f52401b" translate="yes" xml:space="preserve">
          <source>If it takes two arguments, the first is the report, and the second is a map containing extra data that allows direct coversion to a string:</source>
          <target state="translated">두 개의 인수를 사용하는 경우 첫 번째는 보고서이고 두 번째는 문자열을 직접 커버 할 수있는 추가 데이터가 포함 된 맵입니다.</target>
        </trans-unit>
        <trans-unit id="88bfd8938101283cd461120f722bba92f5d433c5" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing key in the map, a new association is created from key &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">키 &lt;code&gt;K&lt;/code&gt; 가 맵의 기존 키와 일치하지 않으면 키 &lt;code&gt;K&lt;/code&gt; 에서 값 &lt;code&gt;V&lt;/code&gt; 에 대한 새로운 연관이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="361674b6db4757a45860f6c0ff467ce229682848" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing keys in map &lt;code&gt;M&lt;/code&gt;, an exception of type &lt;code&gt;badarg&lt;/code&gt; is triggered at runtime. If a matching key &lt;code&gt;K&lt;/code&gt; is present in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;, and the evaluated map expression returns a new map.</source>
          <target state="translated">키 &lt;code&gt;K&lt;/code&gt; 가 맵 &lt;code&gt;M&lt;/code&gt; 의 기존 키와 일치하지 않으면 런타임에 &lt;code&gt;badarg&lt;/code&gt; 유형의 예외 가 트리거됩니다. 일치하는 키 &lt;code&gt;K&lt;/code&gt; 가 맵 &lt;code&gt;M&lt;/code&gt; 에 있으면 연관된 값이 새 값 &lt;code&gt;V&lt;/code&gt; 로 대체되고 평가 된 맵 표현식은 새 맵을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c0a6ddca5224e31c09a05fdd6034a788ec478e89" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; matches an existing key in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;. In both cases, the evaluated map expression returns a new map.</source>
          <target state="translated">키 &lt;code&gt;K&lt;/code&gt; 가 맵 &lt;code&gt;M&lt;/code&gt; 의 기존 키와 일치하면 연관된 값이 새 값 &lt;code&gt;V&lt;/code&gt; 로 대체됩니다 . 두 경우 모두 평가 된 맵 표현식은 새 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42a830a40777cba9136dab78e83126fb44890b72" translate="yes" xml:space="preserve">
          <source>If later &lt;code&gt;Pid&lt;/code&gt; terminates with a reason &lt;code&gt;Reason&lt;/code&gt;, the supervisor bridge terminates with reason &lt;code&gt;Reason&lt;/code&gt; as well. If later the supervisor bridge is stopped by its supervisor with reason &lt;code&gt;Reason&lt;/code&gt;, it calls &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; to terminate.</source>
          <target state="translated">나중에 만약 &lt;code&gt;Pid&lt;/code&gt; 사유로 종료 &lt;code&gt;Reason&lt;/code&gt; , 이유와 감독자 브리지 종료 &lt;code&gt;Reason&lt;/code&gt; 뿐만 아니라. 나중에 &lt;code&gt;Reason&lt;/code&gt; 이유로 수퍼바이저가 수퍼바이저 브릿지를 중지 한 경우 &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; 를 호출 하여 종료합니다.</target>
        </trans-unit>
        <trans-unit id="3a49b5785a5ebb3a3e817628501985a6f158407e" translate="yes" xml:space="preserve">
          <source>If long node node names are used, initiation is done by calling &lt;code&gt;erl_connect_xinit()&lt;/code&gt;:</source>
          <target state="translated">긴 노드 노드 이름이 사용되는 경우 &lt;code&gt;erl_connect_xinit()&lt;/code&gt; 를 호출하여 초기화를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="0a0fdc2466475ba354acc0c8a05ce784a5bde5f7" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table.</source>
          <target state="translated">많은 프로세스가 테이블을 수정하면 모든 프로세스가 테이블을 해제 (또는 종료) 할 때까지 테이블은 고정 된 상태로 유지됩니다. 참조 카운터는 프로세스별로 유지되며 N 개의 연속 수정에는 테이블을 해제하기 위해 N 개의 릴리스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0c297e380855cf1730e1b5795f833b28141150c8" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</source>
          <target state="translated">많은 프로세스가 테이블을 수정하면 모든 프로세스가 테이블을 해제하거나 종료 할 때까지 테이블은 고정 된 상태로 유지됩니다. 참조 카운터는 프로세스별로 유지되며 N 개의 연속 수정 프로그램에서는 테이블을 해제하려면 N 개의 릴리스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="53435afc4e831537f2a17e9899dbdd4cb79d80ed" translate="yes" xml:space="preserve">
          <source>If map &lt;code&gt;map_in&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, this function makes a copy of &lt;code&gt;map_in&lt;/code&gt; in &lt;code&gt;*map_out&lt;/code&gt;, and removes &lt;code&gt;key&lt;/code&gt; and the associated value. If map &lt;code&gt;map_in&lt;/code&gt; does not contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;*map_out&lt;/code&gt; is set to &lt;code&gt;map_in&lt;/code&gt;.</source>
          <target state="translated">지도의 경우 &lt;code&gt;map_in&lt;/code&gt; 가 포함 &lt;code&gt;key&lt;/code&gt; ,이 기능의 사본하게 &lt;code&gt;map_in&lt;/code&gt; 에서 &lt;code&gt;*map_out&lt;/code&gt; 을 하고, 제거 &lt;code&gt;key&lt;/code&gt; 와 관련된 값입니다. 지도의 경우 &lt;code&gt;map_in&lt;/code&gt; 이 포함되지 않은 &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;*map_out&lt;/code&gt; 이 설정되어 &lt;code&gt;map_in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6edf0f9b76d8b501d4e816cd9d78be0eb60417a0" translate="yes" xml:space="preserve">
          <source>If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and the reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing requests are allowed to complete before the reload is done.</source>
          <target state="translated">모드가 방해를 받으면 서버가 강제로 차단되고 진행중인 모든 요청이 종료되고 다시로드가 즉시 시작됩니다. 모드가 방해받지 않는 경우 새 연결이 허용되지 않지만 재로드가 완료되기 전에 진행중인 요청을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e360c70f0d772545e95505fb9d2d98d4f6aab9bb" translate="yes" xml:space="preserve">
          <source>If modules are compiled with inlining, spurious warnings can be emitted. In the &lt;strong&gt;Options&lt;/strong&gt; menu you can choose to ignore inline-compiled modules when analyzing byte code. When starting from source code, this is not a problem because inlining is explicitly turned off by Dialyzer. The option causes Dialyzer to suppress all warnings from inline-compiled modules, as there is currently no way for Dialyzer to find what parts of the code have been produced by inlining.</source>
          <target state="translated">모듈이 인라인으로 컴파일되면 가짜 경고가 발생할 수 있습니다. 에서 &lt;strong&gt;옵션&lt;/strong&gt; 메뉴는 바이트 코드를 분석 할 때 인라인 컴파일 된 모듈을 무시하도록 선택할 수 있습니다. 소스 코드에서 시작할 때 Dialyzer에서 인라인을 명시 적으로 해제하므로 문제가되지 않습니다. Dialyzer는 현재 인라인 컴파일 된 코드 부분을 찾을 수있는 방법이 없기 때문에이 옵션을 사용하면 인라인 컴파일 된 모듈의 모든 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae716d5d8a33ea589343e3a0fd8de6a8cb8c320e" translate="yes" xml:space="preserve">
          <source>If more complex filtering is needed, use &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; and specify the exact filter according to &quot;XML Schema for Event Notifications&quot; in RFC 5277.</source>
          <target state="translated">더 복잡한 필터링이 필요한 경우 &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; 을 사용하고 RFC 5277의 &quot;이벤트 알림에 대한 XML 스키마&quot;에 따라 정확한 필터를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="36a1865d02dfc0df8a1f4e482a94e12100776ba1" translate="yes" xml:space="preserve">
          <source>If more than &lt;code&gt;MaxR&lt;/code&gt; number of restarts occur in the last &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all the child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">마지막 &lt;code&gt;MaxT&lt;/code&gt; 초 동안 &lt;code&gt;MaxR&lt;/code&gt; 이상의 재시작이 발생 하면 수퍼바이저가 모든 하위 프로세스를 종료 한 다음 자체적으로 종료합니다. 이 경우 수퍼바이저 자체의 종료 이유는 &lt;code&gt;shutdown&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4518103e529715a70474c2780a5c3ec980b88617" translate="yes" xml:space="preserve">
          <source>If more than a certain amount of available system memory is allocated, as reported by the underlying operating system, the alarm &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; is set.</source>
          <target state="translated">기본 운영 체제에서보고 한대로 사용 가능한 시스템 메모리가 일정량 이상 할당되면 알람 &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d231020eccfbc66c22211e22df6c7cecb22eb6a5" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point.</source>
          <target state="translated">패턴에 둘 이상의 역 추적 동사가 존재하는 경우, (* COMMIT) 뒤에 오는 다른 동사가 먼저 트리거 될 수 있으므로 일치하는 동안 (* COMMIT)을 전달한다고해서 항상 일치하는 것이이 시작점에 있어야하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3508e8e529ddb74814eed659592c5affc8d5bd2a" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments:</source>
          <target state="translated">하나 이상의 역 추동 동사가 패턴으로 존재하는 경우, 역 추적 동사가 첫 번째 동작으로 동작합니다. 예를 들어, A, B 등이 복잡한 패턴 조각 인 다음 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aeb08026d08e982ee4c93506a7932708091433e1" translate="yes" xml:space="preserve">
          <source>If more than one process tries to load an already loaded driver with the same &lt;code&gt;Path&lt;/code&gt;, or if the same process tries to load it many times, the function returns &lt;code&gt;ok&lt;/code&gt;. The emulator keeps track of the &lt;code&gt;load/2&lt;/code&gt; calls, so that a corresponding number of &lt;code&gt;unload/2&lt;/code&gt; calls must be done from the same process before the driver gets unloaded. It is therefore safe for an application to load a driver that is shared between processes or applications when needed. It can safely be unloaded without causing trouble for other parts of the system.</source>
          <target state="translated">둘 이상의 프로세스가 동일한 &lt;code&gt;Path&lt;/code&gt; 로 이미로드 된 드라이버 를로드하려고 시도하거나 동일한 프로세스가 여러 번로드를 시도하면 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 에뮬레이터는 &lt;code&gt;load/2&lt;/code&gt; 호출을 추적 하므로 드라이버가 언로드되기 전에 동일한 프로세스에서 해당 수의 &lt;code&gt;unload/2&lt;/code&gt; 호출을 수행해야합니다. 따라서 응용 프로그램이 필요할 때 프로세스 또는 응용 프로그램간에 공유되는 드라이버를로드하는 것이 안전합니다. 시스템의 다른 부분에 문제를 일으키지 않고 안전하게 언로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2967b6a58919e3d3f7de7bef014b85f80942bbf1" translate="yes" xml:space="preserve">
          <source>If multi-scheduling is enabled, more than one scheduler thread is used by the emulator. Multi-scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or all &lt;strong&gt;normal&lt;/strong&gt; schedulers but one is blocked. When only normal schedulers are blocked, dirty schedulers are free to continue to schedule processes.</source>
          <target state="translated">다중 예약이 활성화 된 경우 에뮬레이터에서 둘 이상의 스케줄러 스레드가 사용됩니다. 다중 예약은 두 가지 방법으로 차단할 수 있습니다. 하나를 제외한 모든 스케줄러가 차단되었거나 하나를 제외한 모든 &lt;strong&gt;일반&lt;/strong&gt; 스케줄러가 차단되었습니다. 일반 스케줄러 만 차단되면 더티 스케줄러는 프로세스를 계속 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e264c2c185809d37a3371b5c09778551bfdd2307" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;-eval&lt;/code&gt; expressions are specified, they are evaluated sequentially in the order specified. &lt;code&gt;-eval&lt;/code&gt; expressions are evaluated sequentially with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt; function calls (this also in the order specified). As with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt;, an evaluation that does not terminate blocks the system initialization process.</source>
          <target state="translated">여러 &lt;code&gt;-eval&lt;/code&gt; 표현식이 지정된 경우 지정된 순서대로 순차적으로 평가됩니다. &lt;code&gt;-eval&lt;/code&gt; 표현식은 &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-run&lt;/code&gt; 함수 호출 (이는 지정된 순서대로)을 사용하여 순차적으로 평가됩니다 . &lt;code&gt;-s&lt;/code&gt; 및 &lt;code&gt;-run&lt;/code&gt; 과 마찬가지로 종료되지 않은 평가는 시스템 초기화 프로세스를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="97280216c73ddbe9bd1cfe50f8b9e6e9ba9af2e9" translate="yes" xml:space="preserve">
          <source>If multiple timestamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All timestamp flags are remembered, so if two are passed and the one with highest precedence later is disabled the other one will become active.</source>
          <target state="translated">여러 타임 스탬프 플래그가 전달되면 &lt;code&gt;timestamp&lt;/code&gt; 는 &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; 보다 우선하며, &lt;code&gt;monotonic_timestamp&lt;/code&gt; 보다 우선 합니다. 모든 타임 스탬프 플래그가 기억되므로 두 개가 전달되고 우선 순위가 가장 높은 것이 비활성화 된 경우 다른 하나가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="15446137a98bae984b924e92fba150a1dcc2db3c" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_server&lt;/code&gt; process calls the callback function &lt;code&gt;ch3:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt;. In this case, the state is the available channels.</source>
          <target state="translated">이름 등록이 성공하면 새 &lt;code&gt;gen_server&lt;/code&gt; 프로세스는 콜백 함수 &lt;code&gt;ch3:init([])&lt;/code&gt; 호출합니다 . &lt;code&gt;init&lt;/code&gt; 는 &lt;code&gt;{ok, State}&lt;/code&gt; 를 리턴 할 것으로 예상되며 , 여기서 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 의 내부 상태입니다 . 이 경우 상태는 사용 가능한 채널입니다.</target>
        </trans-unit>
        <trans-unit id="2fbbe04e09f325bd4aa00a3af49946b86a67830b" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_statem&lt;/code&gt; process calls callback function &lt;code&gt;code_lock:init(Code)&lt;/code&gt;. This function is expected to return &lt;code&gt;{ok, State, Data}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial state of the &lt;code&gt;gen_statem&lt;/code&gt;, in this case &lt;code&gt;locked&lt;/code&gt;; assuming that the door is locked to begin with. &lt;code&gt;Data&lt;/code&gt; is the internal server data of the &lt;code&gt;gen_statem&lt;/code&gt;. Here the server data is a &lt;code&gt;map&lt;/code&gt; with key &lt;code&gt;code&lt;/code&gt; that stores the correct button sequence, key &lt;code&gt;length&lt;/code&gt; store its length, and key &lt;code&gt;buttons&lt;/code&gt; that stores the collected buttons up to the same length.</source>
          <target state="translated">이름 등록이 성공하면 새 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스는 콜백 함수 &lt;code&gt;code_lock:init(Code)&lt;/code&gt; 호출합니다 . 이 함수는 &lt;code&gt;{ok, State, Data}&lt;/code&gt; 를 반환 할 것으로 예상되는데 , 여기서 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 의 초기 상태입니다 ( 이 경우 &lt;code&gt;locked&lt;/code&gt; . 문이 잠겨 있다고 가정합니다. &lt;code&gt;Data&lt;/code&gt; 는 &lt;code&gt;gen_statem&lt;/code&gt; 의 내부 서버 데이터입니다 . 여기서 서버 데이터는 올바른 버튼 시퀀스를 저장하는 키 &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;length&lt;/code&gt; 저장하는 키 길이 및 수집 된 버튼을 같은 길이까지 저장하는 키 &lt;code&gt;buttons&lt;/code&gt; 이있는 &lt;code&gt;map&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7e65163ad8d72d6ee5d80daa0e098b4aadff312b" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;-minimal&lt;/code&gt;, nor &lt;code&gt;-sasl&lt;/code&gt; is passed as argument you will be prompted.</source>
          <target state="translated">어느 경우 &lt;code&gt;-minimal&lt;/code&gt; ,도 &lt;code&gt;-sasl&lt;/code&gt; 가 인수로 전달하면 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5532948dc2571760fbfaa0cdce397fe861e00347" translate="yes" xml:space="preserve">
          <source>If neither endpoint is desired you can test and re-try like this:</source>
          <target state="translated">엔드 포인트를 원하지 않으면 다음과 같이 테스트하고 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed5063391f45e25222dbefda8015e8ee48fbb82" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt; is given the node will be started using &lt;code&gt;-sname undefined&lt;/code&gt;. If &lt;code&gt;Node&lt;/code&gt; does not contain a hostname, one is automatically taken from &lt;code&gt;-name&lt;/code&gt; or &lt;code&gt;-sname&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;-name&lt;/code&gt; 또는 &lt;code&gt;-sname&lt;/code&gt; 이 제공 되지 않으면 노드는 &lt;code&gt;-sname undefined&lt;/code&gt; 를 사용하여 시작됩니다 . 경우 &lt;code&gt;Node&lt;/code&gt; 호스트 이름을 포함하지 않는 한 자동에서 가져 &lt;code&gt;-name&lt;/code&gt; 또는 &lt;code&gt;-sname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73bad7222a27717f2f7fdcb509b4a128ed0ea2cf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContextName&lt;/code&gt; is specified, the default &lt;code&gt;&quot;&quot;&lt;/code&gt; context is used.</source>
          <target state="translated">&lt;code&gt;ContextName&lt;/code&gt; 을 지정 하지 않으면 기본 &lt;code&gt;&quot;&quot;&lt;/code&gt; 컨텍스트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f8fa538da1412a2b10a3518391e831a5459dc85" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NotifyName&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets (&lt;code&gt;Addresses&lt;/code&gt; below).</source>
          <target state="translated">&lt;code&gt;NotifyName&lt;/code&gt; 이 지정 되지 않은 경우 (또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이면 ) 모든 관리 대상 ( 아래 &lt;code&gt;Addresses&lt;/code&gt; )으로 알림이 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="80ccb4b7a89fa0c5a71d360eba8cfe0f8b2d5620" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Type&lt;/code&gt; is specified, all reports are listed.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 을 지정 하지 않으면 모든 보고서가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ac9629aacf5a541205c4ec779ff11edb1576409e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;context&lt;/code&gt; is specified, the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;, is used.</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 가 지정 되지 않으면 기본 컨텍스트 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed97555002c32aa9440a97e73ca69137e2f1b0fe" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;epmd&lt;/code&gt; (TCP port mapper daemon) is used, also command-line option &lt;code&gt;-no_epmd&lt;/code&gt; is to be specified, which makes Erlang skip the &lt;code&gt;epmd&lt;/code&gt; startup, both as an OS process and as an Erlang ditto.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; (TCP 포트 매퍼 데몬)를 사용 하지 않으면 명령 행 옵션 &lt;code&gt;-no_epmd&lt;/code&gt; 도 지정해야하므로 Erlang 은 OS 프로세스 및 Erlang ditto로 &lt;code&gt;epmd&lt;/code&gt; 시작을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="a8006619350a5226e5dc4b2683c9eea3a8bdbda4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;extended_info&lt;/code&gt; is present in the file and &lt;code&gt;{verify,true}&lt;/code&gt; is specified, the number of objects written is compared to the size of the original table when the dump was started. This can make verification fail if the table was &lt;code&gt;public&lt;/code&gt; and objects were added or removed while the table was dumped to file. To avoid this problem, either do not verify files dumped while updated simultaneously or use option &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt;, which extends the information in the file with the number of objects written.</source>
          <target state="translated">파일에 &lt;code&gt;extended_info&lt;/code&gt; 가 없고 &lt;code&gt;{verify,true}&lt;/code&gt; 가 지정된 경우, 작성된 오브젝트 수는 덤프가 시작될 때 원래 테이블의 크기와 비교됩니다. 테이블이 &lt;code&gt;public&lt;/code&gt; 되고 테이블이 파일로 덤프되는 동안 오브젝트가 추가 또는 제거 된 경우 확인에 실패 할 수 있습니다 . 이 문제점을 방지하려면 동시에 업데이트되는 동안 덤프 된 파일을 확인하지 않거나 &lt;code&gt;{extended_info, [object_count]}&lt;/code&gt; 옵션 을 &lt;code&gt;&lt;a href=&quot;#tab2file-3&quot;&gt;tab2file/3&lt;/a&gt;&lt;/code&gt; 으로 사용 하십시오. 이렇게하면 파일의 정보가 작성된 오브젝트 수로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="8a45ca5e05cc70fae2783d55cbff20b1f8725403" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;name&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이 지정 되지 않은 경우 (또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이면 ) 모든 관리 대상으로 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="32886c8cd8eda5943ea7814b65ec8cd639317821" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;tracer&lt;/code&gt; is specified, the calling process receives all the trace messages.</source>
          <target state="translated">&lt;code&gt;tracer&lt;/code&gt; 이 지정 되지 않으면 호출 프로세스는 모든 추적 메시지를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="8acb8279a4661a4f996c3af79ec9be1db1d63648" translate="yes" xml:space="preserve">
          <source>If no BEAM file contains debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">BEAM 파일에 디버그 정보가 없으면 튜플 목록이 반환됩니다. 각 튜플의 첫 번째 요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="44e5f3c4af2c18aaf89a34918cf838e205862cec" translate="yes" xml:space="preserve">
          <source>If no BOM is found, the function returns &lt;code&gt;{latin1,0}&lt;/code&gt;.</source>
          <target state="translated">BOM이 없으면 함수는 &lt;code&gt;{latin1,0}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e07f0cc9e55f8b5cf0585baaee7cd300085bb99c" translate="yes" xml:space="preserve">
          <source>If no CPU topology is available when flag &lt;code&gt;+sbt&lt;/code&gt; is processed and &lt;code&gt;BindType&lt;/code&gt; is any other type than &lt;code&gt;u&lt;/code&gt;, the runtime system fails to start. CPU topology can be defined using flag &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt;. Notice that flag &lt;code&gt;+sct&lt;/code&gt; can have to be passed before flag &lt;code&gt;+sbt&lt;/code&gt; on the command line (if no CPU topology has been automatically detected).</source>
          <target state="translated">플래그 &lt;code&gt;+sbt&lt;/code&gt; 가 처리되고 &lt;code&gt;BindType&lt;/code&gt; 이 &lt;code&gt;u&lt;/code&gt; 이외의 유형일 때 사용 가능한 CPU 토폴로지가 없으면 런타임 시스템이 시작되지 않습니다. CPU 토폴로지는 flag &lt;code&gt;&lt;a href=&quot;#+sct&quot;&gt;+sct&lt;/a&gt;&lt;/code&gt; 를 사용하여 정의 할 수 있습니다 . CPU 토폴로지가 자동으로 감지되지 않은 경우 명령 줄에서 플래그 &lt;code&gt;+sbt&lt;/code&gt; 전에 플래그 &lt;code&gt;+sct&lt;/code&gt; 를 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dccd7290f5c52ab540d1d1066d43a3aaf228c19a" translate="yes" xml:space="preserve">
          <source>If no argument is provided, Debugger starts in global mode.</source>
          <target state="translated">인수가 제공되지 않으면 디버거가 전역 모드에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="622b281cf52c77f356f35ba9cbbad1c260bbd03f" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt; Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부팅 스크립트가 지정되지 않은 경우 기본값은 &lt;code&gt;ROOT/bin/start&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt; Default Boot Scripts&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fe7b07f514dd69941a31088b490f38f80374e4c" translate="yes" xml:space="preserve">
          <source>If no boot script is specified, it defaults to &lt;code&gt;ROOT/bin/start&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부팅 스크립트가 지정되지 않은 경우 기본값은 &lt;code&gt;ROOT/bin/start&lt;/code&gt; 입니다 ( &lt;code&gt;&lt;a href=&quot;#default_boot_scripts&quot;&gt;Default Boot Scripts&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="1a8687c3d2fddc8ffec405bf127b2012f252abb2" translate="yes" xml:space="preserve">
          <source>If no carrier in &lt;code&gt;pooled_tree&lt;/code&gt; had a large enough free block, we search it again to find any carrier that may act as an entry point into the shared list of all pooled carriers. This in order to, if possible, avoid starting at the sentinel and thereby ease the &quot;bad clustering&quot; problem.</source>
          <target state="translated">&lt;code&gt;pooled_tree&lt;/code&gt; 의 캐리어에 충분한 여유 블록이없는 경우 다시 검색하여 모든 풀링 된 캐리어의 공유 목록에 대한 진입 점 역할을 할 수있는 캐리어를 찾습니다. 이것은 가능한 경우 센티넬에서 시작하는 것을 피하여 &quot;나쁜 클러스터링&quot;문제를 완화하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="221abc0dca23710976162240a2b9fb59a1bb2e0e" translate="yes" xml:space="preserve">
          <source>If no clause could be definitely selected, the function returns &lt;code&gt;{false, NewClauses}&lt;/code&gt;, where &lt;code&gt;NewClauses&lt;/code&gt; is the list of entries in &lt;code&gt;Clauses&lt;/code&gt; that remain after eliminating unselectable clauses, preserving the relative order.</source>
          <target state="translated">어떤 절을 확실히 선택하지 수 있다면, 함수가 반환 &lt;code&gt;{false, NewClauses}&lt;/code&gt; , &lt;code&gt;NewClauses&lt;/code&gt; 는 항목의 목록입니다 &lt;code&gt;Clauses&lt;/code&gt; 상대적인 순서를 보존하거나 선택되지 절을 제거 후 남아있다.</target>
        </trans-unit>
        <trans-unit id="b11dd24d2508db0b969937d6f16c64e7e9a757da" translate="yes" xml:space="preserve">
          <source>If no command-line flag is entered, the &lt;code&gt;Mnesia&lt;/code&gt; directory becomes the current working directory on the node where the Erlang shell is started.</source>
          <target state="translated">명령 행 플래그를 입력하지 않으면 &lt;code&gt;Mnesia&lt;/code&gt; 디렉토리가 Erlang 쉘이 시작된 노드의 현재 작업 디렉토리가됩니다.</target>
        </trans-unit>
        <trans-unit id="19b61bf39702f61088362c4f3caf5fec39790a79" translate="yes" xml:space="preserve">
          <source>If no configuration exists for a server, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead, and specify all necessary options in the &lt;code&gt;Options&lt;/code&gt; parameter.</source>
          <target state="translated">서버에 대한 구성이없는 경우 &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; 을 대신 사용하고 &lt;code&gt;Options&lt;/code&gt; 매개 변수 에 필요한 모든 옵션을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0a2525519fce3b84f0628d21fec24d0d54a30b8" translate="yes" xml:space="preserve">
          <source>If no configuration file is specified with command &lt;code&gt;ct_run&lt;/code&gt;, a warning is displayed. If &lt;code&gt;Common Test&lt;/code&gt; has been run from the same directory earlier, the same configuration file(s) are used again. If &lt;code&gt;Common Test&lt;/code&gt; has not been run from this directory before, no configuration files are available.</source>
          <target state="translated">&lt;code&gt;ct_run&lt;/code&gt; 명령으로 구성 파일을 지정하지 않으면 경고가 표시됩니다. 경우 &lt;code&gt;Common Test&lt;/code&gt; 같은 디렉토리 이전에서 실행 된 같은 구성 파일 (들)을 다시 사용된다. 이전에이 디렉토리에서 &lt;code&gt;Common Test&lt;/code&gt; 를 실행하지 않은 경우 사용 가능한 구성 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="905acdf151b0fff2093942d03e8fda7ba4d6ef97" translate="yes" xml:space="preserve">
          <source>If no connection reference is provided, a connection is set up, and the new connection is returned. An SSH channel process is started to handle the communication with the SFTP server. The returned &lt;code&gt;pid&lt;/code&gt; for this process is to be used as input to all other API functions in this module.</source>
          <target state="translated">연결 참조가 제공되지 않으면 연결이 설정되고 새 연결이 반환됩니다. SFTP 서버와의 통신을 처리하기 위해 SSH 채널 프로세스가 시작되었습니다. 이 프로세스에 대해 리턴 된 &lt;code&gt;pid&lt;/code&gt; 는이 모듈의 다른 모든 API 함수에 대한 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a012950e61dc5d03cdb78960de0564c38b5541f9" translate="yes" xml:space="preserve">
          <source>If no encoder module is given, the default is used (which is pretty).</source>
          <target state="translated">엔코더 모듈이 제공되지 않으면 기본값이 사용됩니다 (꽤).</target>
        </trans-unit>
        <trans-unit id="9348a769518853e44d89b99ac342c57ff1b5e15b" translate="yes" xml:space="preserve">
          <source>If no error occurs, the second phase is performed. This phase calls the user defined &lt;code&gt;set&lt;/code&gt; function for all variables.</source>
          <target state="translated">오류가 발생하지 않으면 두 번째 단계가 수행됩니다. 이 단계 에서는 모든 변수에 대해 사용자 정의 &lt;code&gt;set&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3b135a2849366f4513f0e061b53465a7e3a779a4" translate="yes" xml:space="preserve">
          <source>If no exports are listed by an &lt;code&gt;export&lt;/code&gt; option (see &lt;code&gt;merge_sources/3&lt;/code&gt; for details), then if &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, that module will be exported; otherwise, the first listed module will be exported. Cf. the examples under &lt;code&gt;merge/3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 옵션 으로 내보내기 가 나열되지 않은 경우 (자세한 내용은 &lt;code&gt;merge_sources/3&lt;/code&gt; 참조) &lt;code&gt;Name&lt;/code&gt; 이 입력 모듈 중 하나의 이름 인 경우 해당 모듈이 내보내집니다. 그렇지 않으면 첫 번째로 나열된 모듈이 내보내집니다. Cf. 아래의 예는 &lt;code&gt;merge/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="186696412f510e31ad8ed3a38fb86c31cd6ca5ca" translate="yes" xml:space="preserve">
          <source>If no extra options are specified with flag/option &lt;code&gt;step&lt;/code&gt;, breakpoints are set automatically on the test cases that are to be executed by &lt;code&gt;Common Test&lt;/code&gt;, and those functions only. If step option &lt;code&gt;config&lt;/code&gt; is specified, breakpoints are also initially set on the configuration functions in the suite, that is, &lt;code&gt;init_per_suite/1&lt;/code&gt;, &lt;code&gt;end_per_suite/1&lt;/code&gt;, &lt;code&gt;init_per_group/2&lt;/code&gt;, &lt;code&gt;end_per_group/2&lt;/code&gt;, &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2&lt;/code&gt;.</source>
          <target state="translated">flag / option &lt;code&gt;step&lt;/code&gt; 으로 추가 옵션을 지정하지 않으면 &lt;code&gt;Common Test&lt;/code&gt; 가 실행하는 테스트 케이스 및 해당 기능에서만 브레이크 포인트가 자동으로 설정됩니다 . 단계 옵션 &lt;code&gt;config&lt;/code&gt; 가 지정되면 중단 점도 스위트의 구성 기능, 즉 &lt;code&gt;init_per_suite/1&lt;/code&gt; , &lt;code&gt;end_per_suite/1&lt;/code&gt; , &lt;code&gt;init_per_group/2&lt;/code&gt; , &lt;code&gt;end_per_group/2&lt;/code&gt; , &lt;code&gt;init_per_testcase/2&lt;/code&gt; 및 &lt;code&gt;end_per_testcase/2&lt;/code&gt; 에 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="49e1803a2624ccbd4e21f90db6095850fb9331a7" translate="yes" xml:space="preserve">
          <source>If no formatter information is specified for a handler, Logger uses &lt;code&gt;logger_formatter&lt;/code&gt; as default. See the &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; manual page for more information about this module.</source>
          <target state="translated">핸들러에 지정된 포맷터 정보가 없으면 로거는 기본값으로 &lt;code&gt;logger_formatter&lt;/code&gt; 를 사용합니다 . 참고 항목 &lt;code&gt;&lt;a href=&quot;logger_formatter&quot;&gt;logger_formatter(3)&lt;/a&gt;&lt;/code&gt; 이 모듈에 대한 자세한 내용은 설명서 페이지를.</target>
        </trans-unit>
        <trans-unit id="41b05b11e2a531a16c3ad32baf03f74559983750" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt; digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그래프 유형이 지정되지 않은 경우 &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt; digraph:new/0&lt;/a&gt;&lt;/code&gt; 이 유 방향 그래프를 생성하는 데 사용되며, 그렇지 않으면 &lt;code&gt;GraphType&lt;/code&gt; 인수가 &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="534f259af2115bebe106710668093e3ef6ffd155" translate="yes" xml:space="preserve">
          <source>If no graph type is specified, &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; is used for creating the directed graph, otherwise argument &lt;code&gt;GraphType&lt;/code&gt; is passed on as second argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그래프 유형을 지정하지 않으면 &lt;code&gt;&lt;a href=&quot;digraph#new-0&quot;&gt;digraph:new/0&lt;/a&gt;&lt;/code&gt; 이 지정 그래프 를 작성하는 데 사용되며, 그렇지 않으면 &lt;code&gt;GraphType&lt;/code&gt; 인수가 &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eb03e181763fc340f89dd2fee8a41ea21ee5c23" translate="yes" xml:space="preserve">
          <source>If no guard sequence is evaluated as true, an &lt;code&gt;if_clause&lt;/code&gt; run-time error occurs. If necessary, the guard expression &lt;code&gt;true&lt;/code&gt; can be used in the last branch, as that guard sequence is always true.</source>
          <target state="translated">가드 시퀀스가 ​​true로 평가되지 않으면 &lt;code&gt;if_clause&lt;/code&gt; 런타임 오류가 발생합니다. 필요한 경우 가드 시퀀스가 ​​항상 true이므로 가드 표현식 &lt;code&gt;true&lt;/code&gt; 를 마지막 분기에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9f6b9adc1152f1b0fd0e1ed73ad8eec4e1f624e" translate="yes" xml:space="preserve">
          <source>If no log with the specified name exist on the specified node, &lt;code&gt;no_such_log&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 이름의 로그가 지정된 노드에 존재하지 않으면 &lt;code&gt;no_such_log&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8f6ab79d1d5e9e2cd8b43d5f286fe816764eabff" translate="yes" xml:space="preserve">
          <source>If no match is found for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Result&lt;/code&gt; will be the empty string (&lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">일치하는 항목이에 대한 발견되지 않으면 &lt;code&gt;Tag&lt;/code&gt; , &lt;code&gt;Result&lt;/code&gt; 빈 문자열입니다 ( &lt;code&gt;[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="668861363db131d12510c671297ba7af08f41273" translate="yes" xml:space="preserve">
          <source>If no more event handlers exist after the deletion, &lt;code&gt;error_logger&lt;/code&gt; is removed as a Logger handler, and the &lt;code&gt;error_logger&lt;/code&gt; process is stopped.</source>
          <target state="translated">삭제 후 이벤트 핸들러가 더 이상 존재하지 않으면 &lt;code&gt;error_logger&lt;/code&gt; 가 로거 핸들러로 제거되고 &lt;code&gt;error_logger&lt;/code&gt; 프로세스가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="97bba64e22bb5e3d712c27f199cd41bb5ed00da4" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor bridge is not registered.</source>
          <target state="translated">이름이 제공되지 않으면 감독자 브리지가 등록되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="145b04378100b2af31635cfab7037e102fc50e14" translate="yes" xml:space="preserve">
          <source>If no name is provided, the supervisor is not registered.</source>
          <target state="translated">이름이 제공되지 않으면 수퍼바이저가 등록되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="7209e6d7e59cd86554bad77c729bc91b2aac2993" translate="yes" xml:space="preserve">
          <source>If no new memory blocks are inserted into the list, it should eventually be emptied. All pointers to the list however expect to always point to something. This is solved by inserting an empty &quot;marker&quot; element, which only has to purpose of being there in the absense of other elements. That is when the list is empty it only contains this &quot;marker&quot; element.</source>
          <target state="translated">목록에 새 메모리 블록을 삽입하지 않으면 결국 비워 져야합니다. 그러나 목록에 대한 모든 포인터는 항상 무언가를 가리킬 것으로 예상합니다. 이것은 다른 요소가없는 경우에만 존재하는 목적으로 만 사용되는 빈 &quot;마커&quot;요소를 삽입하여 해결됩니다. 즉, 목록이 비어있는 경우이 &quot;마커&quot;요소 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="962cccbaba0fe2900b8b208ab74fd43b13540b3f" translate="yes" xml:space="preserve">
          <source>If no object with key &lt;code&gt;Key&lt;/code&gt; exists, the function exits with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Key&lt;/code&gt; 키 가있는 객체가 없으면 &lt;code&gt;badarg&lt;/code&gt; 이유와 함께 함수가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3ace922192dd1a66ce93d65f216be69e6bdcfa0" translate="yes" xml:space="preserve">
          <source>If no options are specified, a read lock is acquired, 100 results are returned in each chunk, and &lt;code&gt;select&lt;/code&gt; is used to traverse the table, that is:</source>
          <target state="translated">옵션을 지정하지 않으면 읽기 잠금이 획득되고 각 청크에 100 개의 결과가 반환되며 &lt;code&gt;select&lt;/code&gt; 는 테이블을 탐색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="be43c0999b074d475f47490047515316aff57a56" translate="yes" xml:space="preserve">
          <source>If no or an unknown version is given, the &lt;strong&gt;best&lt;/strong&gt; version is used (which is v3).</source>
          <target state="translated">알 수 없거나 알 수없는 버전이 제공되면 &lt;strong&gt;최상의&lt;/strong&gt; 버전 (v3)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc0db3920bc02374e1ab1e1eb3ced79753b79531" translate="yes" xml:space="preserve">
          <source>If no output comes from the Erlang shell, but the Erlang machine still seems to be alive, an &quot;ALIVE&quot; message is written to the log; it is a time stamp and is written, by default, after 15 minutes of inactivity. Also, if output from Erlang is logged, but more than 5 minutes (default) has passed since last time we got anything from Erlang, a time stamp is written in the log. The &quot;ALIVE&quot; messages look as follows:</source>
          <target state="translated">Erlang 쉘에서 출력이 나오지 않지만 Erlang 시스템이 여전히 활성 상태 인 것 같으면 &quot;ALIVE&quot;메시지가 로그에 기록됩니다. 타임 스탬프이며 기본적으로 15 분 동안 활동이 없으면 기록됩니다. 또한 Erlang의 출력이 기록되었지만 마지막으로 Erlang에서 가져온 것을 5 분 이상 지나면 (타임) 스탬프가 로그에 기록됩니다. &quot;ALIVE&quot;메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2dda439a8b57752f5158a6910e3f618737cb035" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt; set_process_metadata/1 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스 메타 데이터가없는 경우 함수는 &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt; set_process_metadata/1 &lt;/a&gt;&lt;/code&gt; 로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="609daf9d4941227cdd07f7a145c9f4b97a9dd23d" translate="yes" xml:space="preserve">
          <source>If no process metadata exists, the function behaves as &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스 메타 데이터가 없으면 함수는 &lt;code&gt;&lt;a href=&quot;#set_process_metadata-1&quot;&gt;set_process_metadata/1&lt;/a&gt;&lt;/code&gt; 로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="2bcf9e8cbdaa54440e55a1604d7759707d84c686" translate="yes" xml:space="preserve">
          <source>If no response is received before &lt;code&gt;WaitTime&lt;/code&gt; milliseconds, the atom &lt;code&gt;no_response&lt;/code&gt; is returned. It is valid to continue waiting for a response as many times as needed up until a response has been received and completed by &lt;code&gt;erpc:check_response()&lt;/code&gt;, &lt;code&gt;erpc:receive_response()&lt;/code&gt;, or &lt;code&gt;erpc:wait_response()&lt;/code&gt;. If a response is received, the &lt;code&gt;call&lt;/code&gt; operation is completed and either the result is returned as &lt;code&gt;{response, Result}&lt;/code&gt; where &lt;code&gt;Result&lt;/code&gt; corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt;. That is, no &lt;code&gt;{erpc, timeout}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception can be raised. &lt;code&gt;erpc:wait_response()&lt;/code&gt; will fail with an &lt;code&gt;{erpc, badarg}&lt;/code&gt; exception if/when an invalid &lt;code&gt;RequestId&lt;/code&gt; is detected or if an invalid &lt;code&gt;WaitTime&lt;/code&gt; is passed.</source>
          <target state="translated">&lt;code&gt;WaitTime&lt;/code&gt; 밀리 초 전에 응답이 수신되지 않으면 원자 &lt;code&gt;no_response&lt;/code&gt; 가 리턴됩니다. &lt;code&gt;erpc:check_response()&lt;/code&gt; , &lt;code&gt;erpc:receive_response()&lt;/code&gt; 또는 &lt;code&gt;erpc:wait_response()&lt;/code&gt; 의해 응답이 수신 및 완료 될 때까지 필요한만큼 응답을 계속 기다리는 것이 유효합니다 . 응답이 수신되면 &lt;code&gt;call&lt;/code&gt; 작업이 완료되고 결과는 &lt;code&gt;{response, Result}&lt;/code&gt; 로 반환됩니다. 여기서 &lt;code&gt;Result&lt;/code&gt; 는 적용된 함수에서 반환 된 값에 해당하거나 예외가 발생합니다. 발생할 수있는 예외는 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt; 에 의해 발생할 수있는 것과 동일한 예외에 해당합니다.. 즉, &lt;code&gt;{erpc, timeout}&lt;/code&gt; &lt;code&gt;error&lt;/code&gt; 예외가 발생할 수 없습니다. &lt;code&gt;erpc:wait_response()&lt;/code&gt; 는 유효하지 않은 &lt;code&gt;RequestId&lt;/code&gt; 가 감지되거나 유효하지 않은 &lt;code&gt;WaitTime&lt;/code&gt; 이 전달 되면 &lt;code&gt;{erpc, badarg}&lt;/code&gt; 예외 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="129f0fba3cda34f511f81ef498c5983a08b6fef4" translate="yes" xml:space="preserve">
          <source>If no service name is specified, a brief listing of all Erlang services is presented. If a service name is supplied, all options for that service are presented.</source>
          <target state="translated">서비스 이름을 지정하지 않으면 모든 Erlang 서비스의 간단한 목록이 표시됩니다. 서비스 이름이 제공되면 해당 서비스에 대한 모든 옵션이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f74a0bc86a24e556d294700bf2367dba448274f4" translate="yes" xml:space="preserve">
          <source>If no specific browser start command is specified, Firefox is the default browser on Unix platforms, and Internet Explorer on Windows. If &lt;code&gt;Common Test&lt;/code&gt; fails to start a browser automatically, or &lt;code&gt;none&lt;/code&gt; is specified as the value for &lt;code&gt;-browser&lt;/code&gt; (that is, &lt;code&gt;-browser none&lt;/code&gt;), start your favourite browser manually and type the URL that &lt;code&gt;Common Test&lt;/code&gt; displays in the shell.</source>
          <target state="translated">특정 브라우저 시작 명령을 지정하지 않으면 Firefox는 Unix 플랫폼의 기본 브라우저이고 Windows의 Internet Explorer입니다. 경우 &lt;code&gt;Common Test&lt;/code&gt; 자동으로 브라우저를 시작하는 데 실패, 또는 &lt;code&gt;none&lt;/code&gt; 의 값으로 지정되지 않은 &lt;code&gt;-browser&lt;/code&gt; (이다, &lt;code&gt;-browser none&lt;/code&gt; ), 당신의 마음에 드는 브라우저를 수동으로 시작하고 URL을 입력하는 &lt;code&gt;Common Test&lt;/code&gt; 셸에서 표시.</target>
        </trans-unit>
        <trans-unit id="3bd56a176fb29e1e8248ad526f6f69316f9b58af" translate="yes" xml:space="preserve">
          <source>If no such fun is registered, &lt;code&gt;beam_lib&lt;/code&gt; instead searches for an &lt;code&gt;.erlang.crypt&lt;/code&gt; file, see the next section.</source>
          <target state="translated">그러한 재미가 등록되어 있지 않으면 &lt;code&gt;beam_lib&lt;/code&gt; 는 대신 &lt;code&gt;.erlang.crypt&lt;/code&gt; 파일을 검색합니다 . 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="287f2765f0e3b66bca8a3294ba1f1a9c4a144428" translate="yes" xml:space="preserve">
          <source>If no support is found for any tool, this function returns &lt;code&gt;{skip, Explanation}&lt;/code&gt;.</source>
          <target state="translated">도구에 대한 지원이없는 경우이 함수는 &lt;code&gt;{skip, Explanation}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="40469f7012f9c99e344b26a6dfa3a4f344430f04" translate="yes" xml:space="preserve">
          <source>If no time-out of the same type is active instead insert the time-out event just like when starting a time-out with relative &lt;code&gt;Time = 0&lt;/code&gt;.</source>
          <target state="translated">동일한 유형의 시간 제한이 활성화되지 않은 경우에는 상대 &lt;code&gt;Time = 0&lt;/code&gt; 으로 시간 제한을 시작할 때와 마찬가지로 시간 제한 이벤트를 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b73a3ec1f7134600f89a051364f83c286cb4411" translate="yes" xml:space="preserve">
          <source>If no transformation rule match, the loader will begin rewriting the first of generic instructions to a specific instruction.</source>
          <target state="translated">일치하는 변환 규칙이 없으면 로더는 일반 명령어의 첫 번째 명령어를 특정 명령어로 다시 쓰기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d1d762df86c391a1b492c91b19c8e6c06437bbda" translate="yes" xml:space="preserve">
          <source>If no user configuration file is specified and Erlang is started in non-distributed or short name distributed mode, Erlang uses default configuration settings and a native lookup method that works correctly under most circumstances. Erlang reads no information from system &lt;code&gt;inet&lt;/code&gt; configuration files (such as &lt;code&gt;/etc/host.conf&lt;/code&gt; and &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;) in these modes, except for &lt;code&gt;/etc/resolv.conf&lt;/code&gt; and &lt;code&gt;/etc/hosts&lt;/code&gt; that is read and monitored for changes on Unix platforms for the internal DNS client &lt;code&gt;inet_res(3)&lt;/code&gt;.</source>
          <target state="translated">사용자 구성 파일이 지정되지 않고 Erlang이 비 분배 또는 짧은 이름 분산 모드로 시작된 경우 Erlang은 기본 구성 설정과 대부분의 상황에서 올바르게 작동하는 기본 조회 방법을 사용합니다. Erlang은 이러한 모드 에서 시스템 &lt;code&gt;inet&lt;/code&gt; 구성 파일 (예 : &lt;code&gt;/etc/host.conf&lt;/code&gt; 및 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; )에서 정보를 읽지 않으며 변경 사항을 읽고 모니터링하는 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 및 &lt;code&gt;/etc/hosts&lt;/code&gt; 를 제외하고 내부 DNS 클라이언트에 대한 유닉스 플랫폼에서 &lt;code&gt;inet_res(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13936c5aba4f403aada92256e268f1fefbc0b6d4" translate="yes" xml:space="preserve">
          <source>If no value for &lt;code&gt;Retries&lt;/code&gt; is specified, &lt;code&gt;infinity&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Retries&lt;/code&gt; 도 값 이 지정 되지 않으면 &lt;code&gt;infinity&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="205ea9177e47ff562742443567460c481c26083e" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;delayed_write&lt;/code&gt; or &lt;code&gt;{delayed_write,Size,Delay}&lt;/code&gt; is found in the list, &lt;code&gt;delayed_write&lt;/code&gt; is added.</source>
          <target state="translated">목록에 &lt;code&gt;delayed_write&lt;/code&gt; 또는 &lt;code&gt;{delayed_write,Size,Delay}&lt;/code&gt; 가 없으면 &lt;code&gt;delayed_write&lt;/code&gt; 가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4b55a7b8716a559ffcad32612bbf10761dc5678f" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt; or &lt;code&gt;exclusive&lt;/code&gt; is found in the list, &lt;code&gt;append&lt;/code&gt; is added.</source>
          <target state="translated">목록 에 &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;append&lt;/code&gt; 또는 &lt;code&gt;exclusive&lt;/code&gt; 가 없으면 &lt;code&gt;append&lt;/code&gt; 가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="94c3223fb92528e085bdc89d88a03ccfd3c590d9" translate="yes" xml:space="preserve">
          <source>If none of the above are available for your architecture/compiler, you are recommended to build and install &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; before building Erlang/OTP. The &lt;code&gt;libatomic_ops&lt;/code&gt; library provides native atomic memory operations for a variety of architectures and compilers. When building Erlang/OTP you need to inform the build system of where the &lt;code&gt;libatomic_ops&lt;/code&gt; library is installed using the &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt;&lt;code&gt;configure&lt;/code&gt; switch.</source>
          <target state="translated">아키텍처 / 컴파일러에 대해 위의 사항을 사용할 수없는 경우 Erlang / OTP 를 빌드 하기 전에 &lt;code&gt;&lt;a href=&quot;https://github.com/ivmai/libatomic_ops/&quot;&gt;libatomic_ops&lt;/a&gt;&lt;/code&gt; 를 빌드하고 설치하는 것이 좋습니다 . &lt;code&gt;libatomic_ops&lt;/code&gt; 라이브러리는 아키텍처와 컴파일러의 다양한 원시 원자 메모리 작업을 제공합니다. Erlang / OTP를 빌드 할 때 &lt;code&gt;--with-libatomic_ops=PATH&lt;/code&gt; &lt;code&gt;configure&lt;/code&gt; 스위치를 사용하여 &lt;code&gt;libatomic_ops&lt;/code&gt; 라이브러리가 설치된 위치를 빌드 시스템에 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="9440ff5a97925b9c13d62c177e03518391502a24" translate="yes" xml:space="preserve">
          <source>If none of the first three clauses match, the fourth clause match as a variable always matches.</source>
          <target state="translated">처음 세 개의 절 중 어느 것도 일치하지 않으면 네 번째 절은 변수가 항상 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f62e5b4dade736a66aa048e49499435f1f4d7fdc" translate="yes" xml:space="preserve">
          <source>If none of the strings in &lt;code&gt;Pattern&lt;/code&gt; is found, the atom &lt;code&gt;nomatch&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 문자열이 없으면 원자 &lt;code&gt;nomatch&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="aeb11b61b9cc24cd2031d9dda015e2462ccc0499" translate="yes" xml:space="preserve">
          <source>If none of the strings in a pattern is found, an empty list is returned.</source>
          <target state="translated">패턴의 문자열이 없으면 빈 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c826d8a5c30fbaafd8ba535e4315b2bb2ea4206a" translate="yes" xml:space="preserve">
          <source>If not containing a &quot;pre_shared_key&quot; extension, it MUST contain both a &quot;signature_algorithms&quot; extension and a &quot;supported_groups&quot; extension.</source>
          <target state="translated">&quot;pre_shared_key&quot;확장을 포함하지 않는 경우 &quot;signature_algorithms&quot;확장과 &quot;supported_groups&quot;확장을 모두 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="652472f45cf3561f5b3dd17763a17700dfcd88cc" translate="yes" xml:space="preserve">
          <source>If not empty, a scheduler internal auxiliary work is scheduled to be done.</source>
          <target state="translated">비어 있지 않으면 스케줄러 내부 보조 작업이 수행되도록 스케줄됩니다.</target>
        </trans-unit>
        <trans-unit id="9937b44a2ec57528d4de1534b4257202ba316ad9" translate="yes" xml:space="preserve">
          <source>If not implemented, the CTH acts as if this function returned a call to &lt;code&gt;make_ref/0&lt;/code&gt;.</source>
          <target state="translated">구현되지 않은 경우 CTH는이 함수가 &lt;code&gt;make_ref/0&lt;/code&gt; 에 대한 호출을 리턴 한 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="c288cca9f0fb59e5fd99ac4b40424bd7ecc21978" translate="yes" xml:space="preserve">
          <source>If not present, audit trail logging is not used.</source>
          <target state="translated">존재하지 않으면 감사 추적 로깅이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dcb002efb7975058562ec638f68a0e701480231" translate="yes" xml:space="preserve">
          <source>If not set, &lt;code&gt;ei&lt;/code&gt; will implement the timeout using &lt;code&gt;select()&lt;/code&gt; in order to determine when to call the callbacks and when to time out. The &lt;code&gt;tmo&lt;/code&gt; arguments of the &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;writev()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;read()&lt;/code&gt; callbacks should be ignored. The callbacks may be called in non-blocking mode. The callbacks are not allowed to change between blocking and non-blocking mode. In order for this to work, &lt;code&gt;select()&lt;/code&gt; needs to interact with the socket primitives used the same way as it interacts with the ordinary socket primitives. If this is not the case, the callbacks &lt;strong&gt;need&lt;/strong&gt; to implement timeouts and this flag should be set.</source>
          <target state="translated">설정하지 않으면 &lt;code&gt;ei&lt;/code&gt; 는 콜백 호출시기와 시간 초과시기를 결정하기 위해 &lt;code&gt;select()&lt;/code&gt; 를 사용하여 시간 제한을 구현합니다 . &lt;code&gt;accept()&lt;/code&gt; , &lt;code&gt;connect()&lt;/code&gt; , &lt;code&gt;writev()&lt;/code&gt; , &lt;code&gt;write()&lt;/code&gt; 및 &lt;code&gt;read()&lt;/code&gt; 콜백 의 &lt;code&gt;tmo&lt;/code&gt; 인수는 무시해야합니다. 콜백은 비 차단 모드에서 호출 될 수 있습니다. 콜백은 차단 모드와 비 차단 모드간에 변경할 수 없습니다. 이것이 작동 &lt;code&gt;select()&lt;/code&gt; 는 일반 소켓 프리미티브와 상호 작용하는 것과 같은 방식으로 사용되는 소켓 프리미티브와 상호 작용해야합니다. 그렇지 않은 경우, 콜백은 &lt;strong&gt;필요&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt; 시간 초과를 구현하려면이 플래그를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e3b7ad4aa64090ecee7bb02c7f143402ada38cd" translate="yes" xml:space="preserve">
          <source>If not, the &lt;code&gt;&lt;a href=&quot;#type-reason&quot;&gt;reason()&lt;/a&gt;&lt;/code&gt; indicates what went wrong:</source>
          <target state="translated">그렇지 않은 경우 &lt;code&gt;&lt;a href=&quot;#type-reason&quot;&gt;reason()&lt;/a&gt;&lt;/code&gt; 은 무엇이 잘못되었는지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29e29374c41854c469f97e992cbb29625d1d3ef4" translate="yes" xml:space="preserve">
          <source>If not, this is the atom &lt;code&gt;all&lt;/code&gt; which implies that the &lt;code&gt;UtilDesc&lt;/code&gt; contains information about all CPUs.</source>
          <target state="translated">그렇지 않으면,이 원자는 &lt;code&gt;all&lt;/code&gt; 것을 의미하는 &lt;code&gt;UtilDesc&lt;/code&gt; 은 모든 CPU에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f15293549ba601ce95a5307be4274cf3a235ee45" translate="yes" xml:space="preserve">
          <source>If not, this is the sum of the percentage shares of the CPU cycles spent in all states identified as busy.</source>
          <target state="translated">그렇지 않은 경우, 이는 사용 중으로 식별 된 모든 상태에서 소비 된 CPU주기의 백분율 공유의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="a5425f5051ad47a7b173e5435c9b894080331b92" translate="yes" xml:space="preserve">
          <source>If nothing else is stated, it is presumed that the &lt;code&gt;otptest&lt;/code&gt; user has an entry in the &lt;strong&gt;authorized_keys&lt;/strong&gt; file of &lt;strong&gt;tarlop&lt;/strong&gt; (allowed to log in over &lt;code&gt;ssh&lt;/code&gt; without entering a password). Also, &lt;strong&gt;tarlop&lt;/strong&gt; is a known host in the &lt;code&gt;known_hosts&lt;/code&gt; file of the user &lt;code&gt;otptest&lt;/code&gt;. This means that host-verification can be done without user-interaction.</source>
          <target state="translated">다른 아무것도 언급하지 않으면, 것으로 추정된다 &lt;code&gt;otptest&lt;/code&gt; 사용자가있는 항목이 &lt;strong&gt;의 authorized_keys&lt;/strong&gt; 의 파일 &lt;strong&gt;tarlop을&lt;/strong&gt; (를 통해 로그인 할 수 &lt;code&gt;ssh&lt;/code&gt; 암호를 입력하지 않고). 또한 &lt;strong&gt;tarlop&lt;/strong&gt; 은 &lt;code&gt;otptest&lt;/code&gt; 사용자 의 &lt;code&gt;known_hosts&lt;/code&gt; 파일에 있는 알려진 호스트입니다 . 즉, 사용자 확인없이 호스트 확인을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b52863c7b73a113224224b8a0c4d01a407b7d9" translate="yes" xml:space="preserve">
          <source>If objects have been added while the table was fixed, the hash list starts to grow when the table is released, which significantly slows down access to the table for a period of time.</source>
          <target state="translated">테이블을 수정하는 동안 개체가 추가 된 경우 테이블을 놓을 때 해시 목록이 커지기 시작하여 일정 시간 동안 테이블에 대한 액세스 속도가 크게 느려집니다.</target>
        </trans-unit>
        <trans-unit id="828acc15f06ea3d0ebf75bc3294946979fd85c6d" translate="yes" xml:space="preserve">
          <source>If on the other hand the Version argument is an integer, it means that this is the expected version of the message and the decoder for that version should be used.</source>
          <target state="translated">반면에 Version 인수가 정수인 경우 이는 메시지의 예상 버전이며 해당 버전의 디코더를 사용해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7ee7ad00a53993074166a752357e3a491c2d6eb1" translate="yes" xml:space="preserve">
          <source>If one &lt;strong&gt;really&lt;/strong&gt; wants to monitor when the driver gets unloaded, this message distorts the picture, because no unloading was done. Option &lt;code&gt;unloaded_only&lt;/code&gt; creates a monitor similar to an &lt;code&gt;unloaded&lt;/code&gt; monitor, but never results in this message.</source>
          <target state="translated">드라이버가 언로드 될 때 &lt;strong&gt;실제로&lt;/strong&gt; 모니터링하려는 경우 언로드가 수행되지 않았기 때문에이 메시지는 그림을 왜곡시킵니다. 옵션 &lt;code&gt;unloaded_only&lt;/code&gt; 유사한 모니터 생성 &lt;code&gt;unloaded&lt;/code&gt; 모니터를하지만,이 메시지가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5ebea37f196f871b2a70d380f83941fc18ead49" translate="yes" xml:space="preserve">
          <source>If one UTF character is split over two consecutive binaries in the &lt;code&gt;Data&lt;/code&gt;, the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is specified as input without errors occurring.</source>
          <target state="translated">하나의 UTF 문자가 &lt;code&gt;Data&lt;/code&gt; 에서 두 개의 연속 바이너리에 분할 되면 변환이 성공합니다. 이는 전체 범위가 오류없이 입력으로 지정되는 한 이진 범위에서 문자를 디코딩 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="90ed92af5805bd230adc121faf96993bce08b918" translate="yes" xml:space="preserve">
          <source>If one of the &lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; flags is set, and the runtime system has no support for dirty schedulers, the runtime system refuses to load the NIF library.</source>
          <target state="translated">&lt;code&gt;ERL_NIF_DIRTY_JOB_*_BOUND&lt;/code&gt; 플래그 중 하나 가 설정되고 런타임 시스템이 더티 스케줄러를 지원하지 않으면 런타임 시스템은 NIF 라이브러리로드를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="da2865f4d243741aece7d05e455898a782a870b4" translate="yes" xml:space="preserve">
          <source>If one of the nodes cannot process monitors, for example, C or Java nodes, and the &lt;code&gt;gen_server&lt;/code&gt; process is not started when the requests are sent, but starts within 2 seconds, this function waits the whole &lt;code&gt;Timeout&lt;/code&gt;, which may be infinity.</source>
          <target state="translated">노드 중 하나가 모니터를 처리 할 수없는 경우 (예 : C 또는 Java 노드) &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 요청이 전송 될 때 시작되지 않고 2 초 내에 시작되면이 함수는 전체 &lt;code&gt;Timeout&lt;/code&gt; 기다립니다 . 이는 무한대 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ff50154efe11e68e30a0801c8327e55b0714e5d" translate="yes" xml:space="preserve">
          <source>If one or more carriers could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">시스템의 응답 성을 손상시키지 않고 하나 이상의 반송파를 완전히 스캔 할 수없는 경우 &lt;code&gt;UnscannedSize&lt;/code&gt; 는 건너 뛰어야하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="9b3b6b44750cd929fb5194f2e7f17a52f91bfeb2" translate="yes" xml:space="preserve">
          <source>If only one access file exists, setting this parameter to &lt;code&gt;none&lt;/code&gt; can ease the burden on the server as the server then stops looking for access files.</source>
          <target state="translated">하나의 액세스 파일 만 존재하는 경우이 매개 변수를 &lt;code&gt;none&lt;/code&gt; 으로 설정 하면 서버가 액세스 파일 찾기를 중지 할 때 서버의 부담을 덜 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78efdbd37020ca2e2d25f04642dce2c0495aa809" translate="yes" xml:space="preserve">
          <source>If only one letter is specified with \p or \P, it includes all the general category properties that start with that letter. In this case, in the absence of negation, the curly brackets in the escape sequence are optional. The following two examples have the same effect:</source>
          <target state="translated">\ p 또는 \ P로 하나의 문자 만 지정하면 해당 문자로 시작하는 모든 일반 범주 속성이 포함됩니다. 이 경우, 부정이 없으면 이스케이프 시퀀스의 중괄호는 선택 사항입니다. 다음 두 예제는 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d1f740d3ae5b1c6572bd4172c4f16e8373ec6b45" translate="yes" xml:space="preserve">
          <source>If only one value is present, it is the current value. &lt;code&gt;fix_alloc&lt;/code&gt; memory block types are presented by two values. The first value is the memory pool size and the second value is the used memory size.</source>
          <target state="translated">값이 하나만 있으면 현재 값입니다. &lt;code&gt;fix_alloc&lt;/code&gt; 메모리 블록 유형은 두 가지 값으로 표시됩니다. 첫 번째 값은 메모리 풀 크기이고 두 번째 값은 사용 된 메모리 크기입니다.</target>
        </trans-unit>
        <trans-unit id="c5da55d1092af23b098acf7d69c8679113b881cd" translate="yes" xml:space="preserve">
          <source>If only the module name (i.e. not the full name of the &lt;code&gt;.beam&lt;/code&gt; file) is given to this function, the &lt;code&gt;.beam&lt;/code&gt; file is found by calling &lt;code&gt;code:which(Module)&lt;/code&gt;. If no &lt;code&gt;.beam&lt;/code&gt; file is found, the error reason &lt;code&gt;non_existing&lt;/code&gt; is returned. If the module is already cover compiled with &lt;code&gt;compile_beam/1&lt;/code&gt;, the &lt;code&gt;.beam&lt;/code&gt; file will be picked from the same location as the first time it was compiled. If the module is already cover compiled with &lt;code&gt;compile/1,2&lt;/code&gt;, there is no way to find the correct &lt;code&gt;.beam&lt;/code&gt; file, so the error reason &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; is returned.</source>
          <target state="translated">이 함수에 모듈 이름 (예 : &lt;code&gt;.beam&lt;/code&gt; 파일 의 전체 이름이 아님 ) 만 지정하면 &lt;code&gt;code:which(Module)&lt;/code&gt; 을 호출 하여 &lt;code&gt;.beam&lt;/code&gt; 파일을 찾습니다 . &lt;code&gt;.beam&lt;/code&gt; 파일이 없으면 &lt;code&gt;non_existing&lt;/code&gt; 오류 원인 이 반환됩니다. 모듈이 이미 &lt;code&gt;compile_beam/1&lt;/code&gt; 로 컴파일 된 경우 &lt;code&gt;.beam&lt;/code&gt; 파일은 처음 컴파일 할 때와 동일한 위치에서 선택됩니다. 모듈이 이미 &lt;code&gt;compile/1,2&lt;/code&gt; 로 컴파일 된 경우 올바른 &lt;code&gt;.beam&lt;/code&gt; 파일 을 찾을 수있는 방법이 없으므로 오류 이유 &lt;code&gt;{already_cover_compiled,no_beam_found,Module}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="84bdcab65ed9e153d52722d8ccf698faa98c0614" translate="yes" xml:space="preserve">
          <source>If only undefined options are requested the resulting list can be empty.</source>
          <target state="translated">정의되지 않은 옵션 만 요청하면 결과 목록이 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3d6b0c4be9ac174bfcec9988c3498fdbe5d2f55" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="translated">옵션 &lt;code&gt;&lt;a href=&quot;#type-debug_opt&quot;&gt;{debug,Dbgs}&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;Opts&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; 통한 디버깅 이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="0d1d165321c33bcdb22f8f6a5267e4f891a4d819" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {debug,Dbgs} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, debugging through &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; is activated.</source>
          <target state="translated">&lt;code&gt;Opts&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {debug,Dbgs} &lt;/a&gt;&lt;/code&gt; 옵션 이 있으면 &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys&lt;/a&gt;&lt;/code&gt; 를 통한 디버깅 이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="16ab9ca1d15e67f3dd0537fe7133aa59008f55d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after,HibernateAfterTimeout} &lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-enter_loop_opt&quot;&gt; {hibernate_after,HibernateAfterTimeout} &lt;/a&gt;&lt;/code&gt; 옵션 이 있으면 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스는 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 밀리 초 동안 모든 메시지를 기다립니다. 메시지가 수신되지 않으면 프로세스가 자동으로 최대 절전 모드로 전환됩니다 ( &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 호출 ).</target>
        </trans-unit>
        <trans-unit id="ed3aa68b73e10a456d4b0d56c548ffefa2777a94" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {spawn_opt,SpawnOpts} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="translated">선택하면 &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {spawn_opt,SpawnOpts} &lt;/a&gt;&lt;/code&gt; 의 내에 존재 &lt;code&gt;Opts&lt;/code&gt; , &lt;code&gt;SpawnOpts&lt;/code&gt; 은 행 선택리스트로 전달 &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; 상기 스폰 사용 &lt;code&gt;gen_statem&lt;/code&gt; 의 프로세스.</target>
        </trans-unit>
        <trans-unit id="cba326e78241846819e3473e15898cf1eb3e7fec" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {timeout,Time} &lt;/a&gt;&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;&lt;a href=&quot;#type-start_opt&quot;&gt; {timeout,Time} &lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;Opts&lt;/code&gt; 에있는 경우 &lt;code&gt;gen_statem&lt;/code&gt; 은 초기화 하는 데 &lt;code&gt;Time&lt;/code&gt; 밀리 초) 을 소비 하거나 종료되고 시작 함수는 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="769611976869b84c5779bcf180081ddcd9ad1bfa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;c&lt;/code&gt; is used with &lt;code&gt;oldshell&lt;/code&gt; on Unix, &lt;code&gt;Ctrl-C&lt;/code&gt; will restart the shell process rather than interrupt it.</source>
          <target state="translated">옵션 &lt;code&gt;c&lt;/code&gt; 가 유닉스에서 &lt;code&gt;oldshell&lt;/code&gt; 과 함께 사용 되면 &lt;code&gt;Ctrl-C&lt;/code&gt; 는 쉘 프로세스를 중단하지 않고 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="096a0eaa955fff41e809fc817940102bc82e3b7a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compact&lt;/code&gt; is specified, the trailing zeros at the end of the list are truncated. This option is only meaningful together with option &lt;code&gt;decimals&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;compact&lt;/code&gt; 가 지정되면 목록 끝의 후행 0이 잘립니다. 이 옵션은 옵션 10 &lt;code&gt;decimals&lt;/code&gt; 와 함께 만 의미가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e006a20906cf19e410666b42e37a9c3e19a3e41a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;compressed&lt;/code&gt; is provided, the external term format is compressed. The compressed format is automatically recognized by &lt;code&gt;binary_to_term/1&lt;/code&gt; as from Erlang/OTP R7B.</source>
          <target state="translated">&lt;code&gt;compressed&lt;/code&gt; 옵션 이 제공되면 외부 용어 형식이 압축됩니다. 압축 형식은 &lt;code&gt;binary_to_term/1&lt;/code&gt; 에 의해 Erlang / OTP R7B에서 자동으로 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="5de3ee850f4f14cadbc9c1e776ec192b168f5ad1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;decimals&lt;/code&gt; is specified, the returned value contains at most &lt;code&gt;Decimals&lt;/code&gt; number of digits past the decimal point. If the number does not fit in the internal static buffer of 256 bytes, the function throws &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">옵션 10 &lt;code&gt;decimals&lt;/code&gt; 를 지정하면 반환 된 값에 &lt;code&gt;Decimals&lt;/code&gt; 지난 최대 10 진수 자릿수가 포함됩니다. 숫자가 256 바이트의 내부 정적 버퍼에 맞지 않으면 함수는 &lt;code&gt;badarg&lt;/code&gt; 를 던집니다 .</target>
        </trans-unit>
        <trans-unit id="4d32ea21453f7c1a1069cac8907bb379c47719c1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;eof&lt;/code&gt; is specified also, the messages &lt;code&gt;eof&lt;/code&gt; and &lt;code&gt;exit_status&lt;/code&gt; appear in an unspecified order.</source>
          <target state="translated">옵션 &lt;code&gt;eof&lt;/code&gt; 도 지정되면 메시지 &lt;code&gt;eof&lt;/code&gt; 및 &lt;code&gt;exit_status&lt;/code&gt; 가 지정되지 않은 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="32ae7856c177425822832835b7fef1768d20a52e" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;force&lt;/code&gt; has been passed, but the driver of the port does not allow forcing through a busy port.</source>
          <target state="translated">옵션 &lt;code&gt;force&lt;/code&gt; 가 통과되었지만 포트 드라이버가 사용중인 포트를 강제로 허용하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="441c9bb025fc2889c41f42aea8b90d9817c38b34" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the formatting is automatically done when stopping &lt;code&gt;ttb&lt;/code&gt;.</source>
          <target state="translated">옵션의 경우 &lt;code&gt;format&lt;/code&gt; 으로 지정 &lt;code&gt;ttb:stop/1&lt;/code&gt; 정지 할 때 서식이 자동으로 수행됩니다 &lt;code&gt;ttb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d2376aceac49d07a344ae2362a017172221e3a6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;format&lt;/code&gt; is specified to &lt;code&gt;ttb:stop/1&lt;/code&gt;, the trace logs are automatically formatted after tracing is stopped.</source>
          <target state="translated">옵션 &lt;code&gt;format&lt;/code&gt; 이 &lt;code&gt;ttb:stop/1&lt;/code&gt; 로 지정 되면 추적이 중지 된 후 추적 로그가 자동으로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="06c4d5d9e31e528aa6774014ad6ec78d401b5e9f" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;info&lt;/code&gt; is combined with option &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is returned if a flush was needed, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">옵션의 경우 &lt;code&gt;info&lt;/code&gt; 옵션과 결합 &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 플러시가 필요한 경우, 그렇지 않으면 반환됩니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6534bbbe7210a2a4f9c6ad85ccdb4879fb04d3" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;kill_ports&lt;/code&gt; is used, monitor trigging is crucial, as the ports are not guaranteed to be killed until the driver is unloaded. Thus, a monitor must be triggered for at least the &lt;code&gt;pending_driver&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;kill_ports&lt;/code&gt; 옵션을 사용하면 드라이버가 언로드 될 때까지 포트가 강제 종료 되지 않으므로 모니터 트리 깅이 중요합니다. 따라서 최소한 &lt;code&gt;pending_driver&lt;/code&gt; 케이스 에 대해 모니터를 트리거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6aa1db8f0800b8eada993c86c8a59c1d17dfb52c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, all other options return &lt;code&gt;linked_in_driver&lt;/code&gt; or &lt;code&gt;permanent&lt;/code&gt;, respectively.</source>
          <target state="translated">옵션의 경우 &lt;code&gt;linked_in_driver&lt;/code&gt; 또는 &lt;code&gt;permanent&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 다른 모든 옵션은 반환 &lt;code&gt;linked_in_driver&lt;/code&gt; 또는 &lt;code&gt;permanent&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="c57ff6b7c6782f60fe59ca940f65912e4d479346" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;monitor&lt;/code&gt; is specified, the newly created process is monitored, and both the pid and reference for the monitor are returned.</source>
          <target state="translated">옵션 &lt;code&gt;monitor&lt;/code&gt; 가 지정되면 새로 작성된 프로세스가 모니터되고 모니터의 pid 및 참조가 모두 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="04d4436e947c7fe2bfe4be7b9ccd10a7ac2337af" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;no_dot_erlang&lt;/code&gt; is specified, the instruction to load the &lt;code&gt;.erlang&lt;/code&gt; file during boot is &lt;strong&gt;not&lt;/strong&gt; included.</source>
          <target state="translated">&lt;code&gt;no_dot_erlang&lt;/code&gt; 옵션을 지정하면 부팅 중에 &lt;code&gt;.erlang&lt;/code&gt; 파일 을로드하는 명령 이 포함 &lt;strong&gt;되지&lt;/strong&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd0a5200f0c674efc5a1ca9a83309cd9b7fe26b6" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;noexec&lt;/code&gt; is specified, the function returns the same values as for &lt;code&gt;silent&lt;/code&gt; but no &lt;code&gt;relup&lt;/code&gt; file is created.</source>
          <target state="translated">&lt;code&gt;noexec&lt;/code&gt; 옵션을 지정하면이 함수는 &lt;code&gt;silent&lt;/code&gt; 과 동일한 값을 반환 하지만 &lt;code&gt;relup&lt;/code&gt; 파일은 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c2f80ddb4accdf1246a3219780f43c13b4e27f2" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;purge&lt;/code&gt; is specified, all old code that can be soft-purged is purged after all other checks are successfully completed. This can be useful to reduce the time needed by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;purge&lt;/code&gt; 가 지정되면 소프트 제거 할 수있는 모든 이전 코드가 다른 모든 검사가 성공적으로 완료된 후 제거됩니다. &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1&lt;/a&gt;&lt;/code&gt; 에 필요한 시간을 줄이는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f207e9cbf62b31891d035fb3346f08b4121c927b" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;restart_emulator&lt;/code&gt; is specified, a low-level instruction to restart the emulator is appended to the &lt;code&gt;relup&lt;/code&gt; file. This ensures that a complete reboot of the system is done when the system is upgraded or downgraded.</source>
          <target state="translated">&lt;code&gt;restart_emulator&lt;/code&gt; 옵션을 지정하면 에뮬레이터를 다시 시작하기위한 하위 수준의 명령이 &lt;code&gt;relup&lt;/code&gt; 파일에 추가 됩니다. 이를 통해 시스템을 업그레이드하거나 다운 그레이드 할 때 시스템을 완전히 재부팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef31277dfcdd9b3fea33e70696e85cc6a58e6495" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;scientific&lt;/code&gt; is specified, the float is formatted using scientific notation with &lt;code&gt;Decimals&lt;/code&gt; digits of precision.</source>
          <target state="translated">&lt;code&gt;scientific&lt;/code&gt; 옵션 이 지정된 경우 부동 소수점은 &lt;code&gt;Decimals&lt;/code&gt; 자릿수의 공학 표기법을 사용하여 형식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="68354b12f57b501c10eb39d65b11549593ad808d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;src_tests&lt;/code&gt; is specified, a warning is issued if the source code for a module is missing or is newer than the object code.</source>
          <target state="translated">&lt;code&gt;src_tests&lt;/code&gt; 옵션을 지정하면 모듈의 소스 코드가 없거나 오브젝트 코드보다 최신 인 경우 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="3b698628086185a232f3b1c8c64f2b5821c29478" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;sync&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it ensures that the content of the file is written to the disk before &lt;code&gt;tab2file&lt;/code&gt; returns. Defaults to &lt;code&gt;{sync, false}&lt;/code&gt;.</source>
          <target state="translated">옵션의 경우 &lt;code&gt;sync&lt;/code&gt; 설정되어 &lt;code&gt;true&lt;/code&gt; , 파일의 내용이하기 전에 디스크에 기록되는 것을 보장 &lt;code&gt;tab2file&lt;/code&gt; 에 돌아갑니다. 기본값은 &lt;code&gt;{sync, false}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="16c1274c0980810787faf4c8323f084b49c5a2fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;ungreedy&lt;/code&gt; is set (an option that is not available in Perl), the quantifiers are not greedy by default, but individual ones can be made greedy by following them with a question mark. That is, it inverts the default behavior.</source>
          <target state="translated">옵션 &lt;code&gt;ungreedy&lt;/code&gt; 이 설정되면 (Perl에서 사용할 수없는 옵션) 수량자는 기본적으로 욕심이 없지만 물음표를 따라 개별 욕심을 만들 수 있습니다. 즉, 기본 동작을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="6ebecfa9ef794349da407c48663db38e0205dfc1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;url_base&lt;/code&gt; is set, an extra attribute named &lt;code&gt;url&lt;/code&gt; is added to each &lt;code&gt;testsuite&lt;/code&gt; and &lt;code&gt;testcase&lt;/code&gt; XML element. The value is constructed from &lt;code&gt;url_base&lt;/code&gt; and a relative path to the test suite or test case log, respectively, for example:</source>
          <target state="translated">&lt;code&gt;url_base&lt;/code&gt; 옵션 이 설정되면 &lt;code&gt;url&lt;/code&gt; 이라는 추가 속성 이 각 &lt;code&gt;testsuite&lt;/code&gt; 및 &lt;code&gt;testcase&lt;/code&gt; XML 요소에 추가됩니다 . 이 값은 &lt;code&gt;url_base&lt;/code&gt; 및 테스트 스위트 또는 테스트 케이스 로그에 대한 상대 경로로 각각 구성됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="7a53503422cb0ac19329aceb31af878b5ec300e5" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;warnings_as_errors&lt;/code&gt; is specified, warnings are treated as errors.</source>
          <target state="translated">&lt;code&gt;warnings_as_errors&lt;/code&gt; 옵션 이 지정되면 경고는 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="41ac36f3b8b38269747bee1634966538895f2ee4" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{debug,Dbgs}&lt;/code&gt; is present, the corresponding &lt;code&gt;sys&lt;/code&gt; function is called for each item in &lt;code&gt;Dbgs&lt;/code&gt;; see &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;{debug,Dbgs}&lt;/code&gt; 가 있으면 &lt;code&gt;Dbgs&lt;/code&gt; 의 각 항목에 해당하는 &lt;code&gt;sys&lt;/code&gt; 함수가 호출됩니다 . &lt;code&gt;&lt;a href=&quot;sys&quot;&gt;sys(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65c08f8f94d4db76f6cc364152658be9a80df8fa" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{handshake, hello}&lt;/code&gt; 옵션 이 지정되면 클라이언트 hello 메시지를 수신 한 후 핸드 셰이크가 일시 중지되고 성공 응답은 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 대신 {ok, SslSocket, Ext &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 입니다. 그 후 &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 핸드 셰이크를 계속하거나 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="e804aab039286890448ffee48895432a1b352c17" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{handshake, hello}&lt;/code&gt; is specified the handshake is paused after receiving the client hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{handshake, hello}&lt;/code&gt; 옵션을 지정하면 클라이언트 hello 메시지를 수신 한 후 핸드 쉐이크가 일시 중단되며 성공 응답은 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 대신 {ok, SslSocket, Ext &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 입니다. 그런 다음 handshake_continue &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 핸드 셰이크가 계속되거나 취소됩니다 .</target>
        </trans-unit>
        <trans-unit id="9802b121f3f842baa16ccec18f6827e8efefe976" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_event&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; 옵션 이 존재하면 &lt;code&gt;gen_event&lt;/code&gt; 프로세스는 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 밀리 초 동안 메시지를 대기 하고 메시지가 수신되지 않으면 프로세스는 자동으로 최대 절전 모드로 전환됩니다 ( &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 호출 ).</target>
        </trans-unit>
        <trans-unit id="80d6ad9348d486b54eb01008ea70fa22ab22a998" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;{hibernate_after,HibernateAfterTimeout}&lt;/code&gt; 옵션 이 존재하면 &lt;code&gt;gen_server&lt;/code&gt; 프로세스는 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 밀리 초 동안 메시지를 대기 하고 메시지가 수신되지 않으면 프로세스는 자동으로 최대 절전 모드로 전환됩니다 ( &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 호출 ).</target>
        </trans-unit>
        <trans-unit id="1afccf80e87b972a02a03ba25b3fcfd4c6d492f1" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. A directory in the path can be specified with a wildcard &lt;code&gt;*&lt;/code&gt;, this is expanded to all matching directories. Example: &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{path,[Dir]}&lt;/code&gt; 옵션을 지정하면이 경로가 현재 경로에 추가됩니다. 경로의 디렉토리는 와일드 카드 &lt;code&gt;*&lt;/code&gt; 로 지정할 수 있으며 일치하는 모든 디렉토리로 확장됩니다. 예 : &lt;code&gt;&quot;lib/*/ebin&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="521a357383f837ccbed508cea165f5ba1a72a4ba" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{path,[Dir]}&lt;/code&gt; is specified, this path is appended to the current path. Wildcard &lt;code&gt;*&lt;/code&gt; is expanded to all matching directories, for example, &lt;code&gt;lib/*/ebin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{path,[Dir]}&lt;/code&gt; 옵션을 지정하면이 경로가 현재 경로에 추가됩니다. 와일드 카드 &lt;code&gt;*&lt;/code&gt; 는 일치하는 모든 디렉토리 (예 : &lt;code&gt;lib/*/ebin&lt;/code&gt; )로 확장 됩니다.</target>
        </trans-unit>
        <trans-unit id="5a5e0fc842c3e7f86267427d3814bd82d53e295a" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt; spawn_opt/2&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; 가 있으면 &lt;code&gt;SOpts&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 를 생성하는 데 사용되는 &lt;code&gt;spawn_opt&lt;/code&gt; BIF에 옵션 목록으로 전달됩니다 . &lt;code&gt; spawn_opt/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="319e803f0c4dc5797ff076e88abf3ae72c4731f8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; is present, &lt;code&gt;SOpts&lt;/code&gt; is passed as option list to the &lt;code&gt;spawn_opt&lt;/code&gt; BIF, which is used to spawn the &lt;code&gt;gen_server&lt;/code&gt; process; see &lt;code&gt;spawn_opt/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn_opt,SOpts}&lt;/code&gt; 옵션 이 존재하면 &lt;code&gt;SOpts&lt;/code&gt; 는 옵션 목록으로 &lt;code&gt;spawn_opt&lt;/code&gt; BIF에 전달되며 , 이는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 를 생성하는 데 사용됩니다 . &lt;code&gt;spawn_opt/2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f134a5284d4d1605e5d535d5f02614e7f9564b83" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, &lt;code&gt;SpawnOpts&lt;/code&gt; is passed as option list to &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt;, which is used to spawn the &lt;code&gt;gen_statem&lt;/code&gt; process.</source>
          <target state="translated">옵션 &lt;code&gt;{spawn_opt,SpawnOpts}&lt;/code&gt; 가 &lt;code&gt;Opts&lt;/code&gt; 에 존재 하면 &lt;code&gt;SpawnOpts&lt;/code&gt; 가 옵션 목록으로 &lt;code&gt;erlang:spawn_opt/2&lt;/code&gt; 에 전달되어 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c971670358afb5846db5d77c2b0b19aad5a3c579" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present in &lt;code&gt;Opts&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it terminates and the start function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;{timeout,Time}&lt;/code&gt; 이 &lt;code&gt;Opts&lt;/code&gt; 에 존재 하면 &lt;code&gt;gen_statem&lt;/code&gt; 은 초기화 하는 데 &lt;code&gt;Time&lt;/code&gt; 밀리 초) 을 소비 하거나 종료되며 시작 함수는 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,timeout}&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="341a32ddba103c08ae86b78ec53524b7702998b8" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{timeout,Time}&lt;/code&gt; is present, the &lt;code&gt;gen_server&lt;/code&gt; process is allowed to spend &lt;code&gt;Time&lt;/code&gt; milliseconds initializing or it is terminated and the start function returns &lt;code&gt;{error,timeout}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{timeout,Time}&lt;/code&gt; 옵션 이 존재하면 &lt;code&gt;gen_server&lt;/code&gt; 프로세스가 초기화 하는 데 &lt;code&gt;Time&lt;/code&gt; 밀리 초) 을 소비 하거나 종료되고 시작 함수는 &lt;code&gt;{error,timeout}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a928786d0e9ca7308ebc039e35ade6afdfb8bc1d" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;{tls, tls_options()}&lt;/code&gt; is present, the FTP session is transported over &lt;code&gt;tls&lt;/code&gt; (&lt;code&gt;ftps&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt;). The list &lt;code&gt;tls_options()&lt;/code&gt; can be empty. The function &lt;code&gt;ssl:connect/3&lt;/code&gt; is used for securing both the control connection and the data sessions.</source>
          <target state="translated">&lt;code&gt;{tls, tls_options()}&lt;/code&gt; 옵션 이 존재하면 FTP 세션이 &lt;code&gt;tls&lt;/code&gt; 를 통해 전송됩니다 ( &lt;code&gt;ftps&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4217.txt&quot;&gt;RFC 4217&lt;/a&gt;&lt;/code&gt; 참조 ). &lt;code&gt;tls_options()&lt;/code&gt; 목록 은 비어있을 수 있습니다. &lt;code&gt;ssl:connect/3&lt;/code&gt; 기능 은 제어 연결과 데이터 세션을 모두 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20a3a531905a20d30fd9f374cce827942989f5e9" translate="yes" xml:space="preserve">
          <source>If option&lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; is present, the &lt;code&gt;gen_statem&lt;/code&gt; process awaits any message for &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; milliseconds and if no message is received, the process goes into hibernation automatically (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#type-hibernate_after_opt&quot;&gt;{hibernate_after,HibernateAfterTimeout}&lt;/a&gt;&lt;/code&gt; 옵션 이 존재하면 &lt;code&gt;gen_statem&lt;/code&gt; 프로세스는 &lt;code&gt;HibernateAfterTimeout&lt;/code&gt; 밀리 초 동안 메시지를 기다립니다. 메시지가 수신되지 않으면 프로세스는 자동으로 최대 절전 모드로 전환됩니다 ( &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; 호출 ).</target>
        </trans-unit>
        <trans-unit id="2fd0a104622064a3e02a4f4c3eca0f47d309b91b" translate="yes" xml:space="preserve">
          <source>If or when &lt;code&gt;monitor/2&lt;/code&gt; is extended, other possible values for &lt;code&gt;Tag&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;Info&lt;/code&gt; in the monitor message will be introduced.</source>
          <target state="translated">만약하거나 &lt;code&gt;monitor/2&lt;/code&gt; 확장되어, 다른 가능한 값 &lt;code&gt;Tag&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; 및 &lt;code&gt;Info&lt;/code&gt; 모니터 메시지에 소개한다.</target>
        </trans-unit>
        <trans-unit id="a47b00202aed4c182ff58ce236e280bf55db7d71" translate="yes" xml:space="preserve">
          <source>If other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have the driver loaded, this option has no effect.</source>
          <target state="translated">다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; 가 드라이버를로드 한 경우이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="597bab21aef8fd8fbc55474998e0dbac33663b0f" translate="yes" xml:space="preserve">
          <source>If padding is &lt;code&gt;{padding,none}&lt;/code&gt; or not specifed and the total data from all subsequent &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_updates&lt;/a&gt;&lt;/code&gt; does not fill the last block fully, that last data is lost. In case of &lt;code&gt;{padding,none}&lt;/code&gt; there will be an error in this case. If padding is not specified, the bytes of the unfilled block is silently discarded.</source>
          <target state="translated">패딩이 &lt;code&gt;{padding,none}&lt;/code&gt; 이거나 지정되지 않았고 모든 후속 &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_updates&lt;/a&gt;&lt;/code&gt; 의 총 데이터 가 마지막 블록을 완전히 채우지 않으면 마지막 데이터가 손실됩니다. 경우 &lt;code&gt;{padding,none}&lt;/code&gt; 이 경우에 오류가있을 것이다. 패딩을 지정하지 않으면 채워지지 않은 블록의 바이트가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1578eb3698cf666fa7f690b04c9f11cc163c2d2b" translate="yes" xml:space="preserve">
          <source>If padding was not enabled, the call to &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; may be excluded.</source>
          <target state="translated">패딩이 활성화되지 않은 경우 &lt;code&gt;&lt;a href=&quot;crypto#crypto_final-1&quot;&gt;crypto_final/1&lt;/a&gt;&lt;/code&gt; 에 대한 호출 이 제외 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b3ce2063e2924ca7e8faa87611f5b6c2819567" translate="yes" xml:space="preserve">
          <source>If parameter &lt;code&gt;Dates&lt;/code&gt; is specified, the reports are filtered according to the date when they occurred. If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateFrom, from}&lt;/code&gt;, reports that occurred after &lt;code&gt;DateFrom&lt;/code&gt; are displayed.</source>
          <target state="translated">매개 변수 &lt;code&gt;Dates&lt;/code&gt; 를 지정하면 보고서는 발생한 날짜에 따라 필터링됩니다. 경우 &lt;code&gt;Dates&lt;/code&gt; 형태가 &lt;code&gt;{DateFrom, from}&lt;/code&gt; , 이후에 발생 보고서 &lt;code&gt;DateFrom&lt;/code&gt; 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6511239690521e295477c51f44e7169510af0e54" translate="yes" xml:space="preserve">
          <source>If possible, avoid writing or deleting records in the same transaction before iterating over the table.</source>
          <target state="translated">가능하면 테이블을 반복하기 전에 동일한 트랜잭션에서 레코드를 쓰거나 삭제하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3eb1eeddf032eb186133fc7df8919fb2d11d384d" translate="yes" xml:space="preserve">
          <source>If possible, the client keeps its connections alive and uses persistent connections with or without pipeline depending on configuration and current circumstances. The HTTP/1.1 specification does not provide a guideline for how many requests that are ideal to be sent on a persistent connection. This depends much on the application.</source>
          <target state="translated">가능하면 클라이언트는 연결을 유지하고 구성 및 현재 환경에 따라 파이프 라인을 포함하거나 포함하지 않는 지속적인 연결을 사용합니다. HTTP / 1.1 사양은 지속적인 연결로 전송하기에 이상적인 요청 수에 대한 지침을 제공하지 않습니다. 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6eb80024b1f8a5a58791d40e0d60ce7a9e24c7b7" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved before any preceding separator characters on the same line. E.g.:</source>
          <target state="translated">가능한 경우 주석은 동일한 행에서 선행 분리 문자 앞에 이동해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="11f459fa45ff86ea26d4123b486b2667eb195a88" translate="yes" xml:space="preserve">
          <source>If possible, the comment should be moved past any following separator characters on the same line, rather than placing the separators on the following line. E.g.:</source>
          <target state="translated">가능하면 주석을 다음 행에 배치하지 말고 같은 행에서 다음 구분 문자를 지나서 주석을 이동해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="0e22a764d95b33db30751234a49a657e83e7510e" translate="yes" xml:space="preserve">
          <source>If possible, use the &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; module to extract the compiler options and the abstract code format from the Beam file and compile that instead.</source>
          <target state="translated">가능한 경우 &lt;code&gt;&lt;a href=&quot;beam_lib&quot;&gt;beam_lib(3)&lt;/a&gt;&lt;/code&gt; 모듈을 사용하여 Beam 파일에서 컴파일러 옵션 및 추상 코드 형식을 추출하고 대신 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="aede57d6ae41eb953c1c470da89fb0e057e8b902" translate="yes" xml:space="preserve">
          <source>If precedence is client, the negotiated protocol is the first protocol to be shown on the client preference list, which is also on the server advertised list.</source>
          <target state="translated">우선 순위가 클라이언트 인 경우 협상 된 프로토콜은 클라이언트 환경 설정 목록에 표시되는 첫 번째 프로토콜이며 서버 보급 목록에도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ff54d9c737f36da2074bfa07dabdd6029e6f8a" translate="yes" xml:space="preserve">
          <source>If precedence is server, the negotiated protocol is the first protocol to be shown on the server advertised list, which is also on the client preference list.</source>
          <target state="translated">우선 순위가 서버 인 경우 협상 된 프로토콜은 서버 보급 목록에 표시되는 첫 번째 프로토콜이며 클라이언트 기본 설정 목록에도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6739d735ae41522a99fdf3833670c2cb63d21a98" translate="yes" xml:space="preserve">
          <source>If present, this option specifies the options for the &lt;strong&gt;audit trail logging&lt;/strong&gt;. The &lt;code&gt;disk_log&lt;/code&gt; module is used to maintain a wrap log. If present, the &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; options are mandatory.</source>
          <target state="translated">있는 경우이 옵션은 &lt;strong&gt;감사 추적 로깅&lt;/strong&gt; 옵션을 지정합니다 . &lt;code&gt;disk_log&lt;/code&gt; 모듈은 랩 로그를 유지하는 데 사용됩니다. 있는 경우 &lt;code&gt;dir&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 옵션은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="c374078c3ce837fa7c145904897f0747ce0fa052" translate="yes" xml:space="preserve">
          <source>If process metadata exists for the current process, this function behaves as if it was implemented as follows:</source>
          <target state="translated">현재 프로세스에 대한 프로세스 메타 데이터가 존재하면이 함수는 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6453efa6a699c594656266a7d0d5934c8aa65586" translate="yes" xml:space="preserve">
          <source>If pseudo function triggering the translation is &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single tuple. If the pseudo function is &lt;code&gt;dbg:fun2ms/1&lt;/code&gt;, the head of the fun must contain a single variable or a single list.</source>
          <target state="translated">변환을 트리거하는 의사 함수가 &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 인 경우, 재미의 머리 부분에는 단일 변수 또는 단일 튜플이 포함되어야합니다. 의사 함수가 &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 인 경우, 재미의 머리에는 단일 변수 또는 단일 목록이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3bbf5cb920ce0732e8a77fc0ab511fa8e53d27bc" translate="yes" xml:space="preserve">
          <source>If quantifier is {0,n}, where n &amp;gt; 0, it is treated as if it was {0,1}. At runtime, the remaining pattern match is tried with and without the assertion, the order depends on the greediness of the quantifier.</source>
          <target state="translated">수량자가 {0, n} (여기서 n&amp;gt; 0)이면 {0,1} 인 것처럼 처리됩니다. 런타임시, 나머지 패턴 일치는 어설 션이 있거나없는 상태에서 시도되며, 순서는 수량 자의 탐욕에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e6534fccad96b9c365841e907e49b7cde2c28d" translate="yes" xml:space="preserve">
          <source>If records are written and deleted during the traversal, use the function &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;write&lt;/code&gt; lock. Or the function &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; when using &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">레코드가 통과하는 동안 작성하고 삭제하는 경우, 함수 사용 &lt;code&gt;&lt;a href=&quot;mnesia#foldl&quot;&gt;mnesia:foldl/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mnesia#foldr&quot;&gt;mnesia:foldr/3&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;write&lt;/code&gt; 잠금. 또는 &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 를 사용할 때 &lt;code&gt;&lt;a href=&quot;mnesia#write_lock_table-1&quot;&gt;mnesia:write_lock_table/1&lt;/a&gt;&lt;/code&gt; 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="169c4bd14dbb4d6e16657fce0c0a61cc8e3f8798" translate="yes" xml:space="preserve">
          <source>If reloading is not requested, it can still be useful to specify option &lt;code&gt;monitor&lt;/code&gt;, as forced unloads (driver option &lt;code&gt;kill_ports&lt;/code&gt; or option &lt;code&gt;kill_ports&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt;) trigger a transient state where driver loading cannot be performed until all closing ports are closed. Thus, as &lt;code&gt;try_unload&lt;/code&gt; can, in almost all situations, return &lt;code&gt;{ok, pending_driver}&lt;/code&gt;, always specify at least &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; in production code (see the monitor discussion earlier).</source>
          <target state="translated">재로드가 요청되지 않은 경우 강제 언로드 (드라이버 옵션 &lt;code&gt;kill_ports&lt;/code&gt; 또는 옵션 &lt;code&gt;kill_ports&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#try_unload-2&quot;&gt;try_unload/2&lt;/a&gt;&lt;/code&gt; )가 모든 닫는 포트가 닫힐 때까지 드라이버로드를 수행 할 수없는 일시적인 상태를 트리거하므로 옵션 &lt;code&gt;monitor&lt;/code&gt; 를 지정하는 것이 여전히 유용 할 수 있습니다. 따라서 &lt;code&gt;try_unload&lt;/code&gt; 가 거의 모든 상황에서 &lt;code&gt;{ok, pending_driver}&lt;/code&gt; 리턴 할 수 있으므로 항상 프로덕션 코드에서 &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; 이상을 지정 하십시오 ( 앞 의 모니터 설명 참조).</target>
        </trans-unit>
        <trans-unit id="55c076ea86b99a552c3ee63a0beaa5dfb25c1e33" translate="yes" xml:space="preserve">
          <source>If resolver option &lt;code&gt;inet6&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, an IPv6 address is looked up.</source>
          <target state="translated">리졸버 옵션 &lt;code&gt;inet6&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 IPv6 주소가 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="71218f752e39cbf302806385e7e620598fcd4560" translate="yes" xml:space="preserve">
          <source>If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode.</source>
          <target state="translated">특정 노드에서 제한 모드가 활성화 된 경우이 노드에 연결된 원격 셸도 제한 모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="81be79c2e31a4efcff85293a46775d5d0aa9c619" translate="yes" xml:space="preserve">
          <source>If run with option &lt;code&gt;caseless&lt;/code&gt;, this pattern matches phrases such as &quot;A man, a plan, a canal: Panama!&quot; and it works well in both PCRE and Perl. Notice the use of the possessive quantifier *+ to avoid backtracking into sequences of non-word characters. Without this, PCRE takes much longer (10 times or more) to match typical phrases, and Perl takes so long that you think it has gone into a loop.</source>
          <target state="translated">&lt;code&gt;caseless&lt;/code&gt; 옵션으로 실행하면 이 패턴은 &quot;사람, 계획, 운하 : 파나마!&quot;와 같은 문구와 일치합니다. PCRE와 Perl 모두에서 잘 작동합니다. 단어가 아닌 문자 시퀀스로의 역 추적을 피하려면 소유 수량 자 * +를 사용하십시오. 이것이 없으면 PCRE가 일반적인 문구와 일치하는 데 훨씬 더 오래 걸리거나 (10 배 이상) Perl이 너무 오래 걸리기 때문에 루프에 빠졌다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="56762a0f1f42178490b0db9862f2814f477e1842" translate="yes" xml:space="preserve">
          <source>If set before start, the &lt;code&gt;epmd&lt;/code&gt; daemon behaves as if option &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified at startup. Consequently, if this option is set before starting the Erlang virtual machine, the automatically started &lt;code&gt;epmd&lt;/code&gt; accepts the &lt;code&gt;-kill&lt;/code&gt; and &lt;code&gt;-stop&lt;/code&gt; commands without restrictions.</source>
          <target state="translated">시작하기 전에 설정하면 &lt;code&gt;epmd&lt;/code&gt; 데몬은 시작시 옵션 &lt;code&gt;-relaxed_command_check&lt;/code&gt; 가 지정된 것처럼 작동 합니다. 따라서 Erlang 가상 머신을 시작하기 전에이 옵션을 설정하면 자동으로 시작된 &lt;code&gt;epmd&lt;/code&gt; 가 제한없이 &lt;code&gt;-kill&lt;/code&gt; 및 &lt;code&gt;-stop&lt;/code&gt; 명령을 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="9f59dad82faaa4c2914703b6f2eec0c0bd7bf03c" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">세트가 최대 절전 모드로하면 &lt;code&gt;gen_statem&lt;/code&gt; 을 , 섹션 처리 &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="997d2e694bf42fce758c366fad9b952364db63dd" translate="yes" xml:space="preserve">
          <source>If set hibernate the &lt;code&gt;gen_statem&lt;/code&gt;, treated in section &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">세트가 최대 절전 모드로하면 &lt;code&gt;gen_statem&lt;/code&gt; 을 , 섹션 처리 &lt;code&gt;&lt;a href=&quot;#Hibernation&quot;&gt;Hibernation&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60eef1c452cfc1dd1bd601c01baa121d5df8c903" translate="yes" xml:space="preserve">
          <source>If set in binary mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;{binary, true}&lt;/code&gt;), the I/O server sends binary data (encoded in UTF-8) as answers to the &lt;code&gt;get_line&lt;/code&gt;, &lt;code&gt;get_chars&lt;/code&gt;, and, if possible, &lt;code&gt;get_until&lt;/code&gt; requests (for details, see section &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt;) in the User's Guide). The immediate effect is that &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; return UTF-8 binaries instead of lists of characters for the affected I/O device.</source>
          <target state="translated">이진 모드 ( &lt;code&gt;binary&lt;/code&gt; 또는 &lt;code&gt;{binary, true}&lt;/code&gt; )로 설정된 경우 I / O 서버는 이진 데이터 (UTF-8로 인코딩 됨)를 &lt;code&gt;get_line&lt;/code&gt; , &lt;code&gt;get_chars&lt;/code&gt; 및 가능한 경우 &lt;code&gt;get_until&lt;/code&gt; 요청에 대한 응답으로 이진 데이터를 보냅니다 (자세한 내용은 참조). 사용 설명서 &lt;code&gt;&lt;a href=&quot;io_protocol&quot;&gt;The Erlang I/O Protocol&lt;/a&gt;&lt;/code&gt; ) 섹션을 참조하십시오. 즉각적인 효과는 &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; 가 영향을받는 I / O 장치의 문자 목록 대신 UTF-8 바이너리를 반환한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="60e11f2d401fbb6a7bc13e95b2d0df9464865aea" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">현재 이벤트 연기를 설정 한 경우 이벤트 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfee0bffb0c9371226233925794bed564e96b2bf" translate="yes" xml:space="preserve">
          <source>If set postpone the current event, see section &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 이벤트 연기를 설정하면 이벤트 &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;Postponing Events&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff2642f766dbab3720562602e51b82a07e9e8906" translate="yes" xml:space="preserve">
          <source>If set the scheduler id is to be included by the tracer.</source>
          <target state="translated">설정된 경우 스케줄러 ID가 추적 프로그램에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="913831f334573f274f7a4b77334d9d4e872f104b" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">설정된 경우 추적 점에 추적 이벤트에 대한 추가 데이터가 포함됩니다. 추가 데이터는 어떤 &lt;code&gt;TraceTag&lt;/code&gt; 가 트리거되었는지에 따라 다릅니다 . &lt;code&gt;extra&lt;/code&gt; 추적 튜플의 5 요소로 추적 데이터에 대응에 설명 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt; erlang:trace/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b36ae2f0946222aa466ec9f357bec978063329ec" translate="yes" xml:space="preserve">
          <source>If set the tracepoint has included additional data about the trace event. What the additional data is depends on which &lt;code&gt;TraceTag&lt;/code&gt; has been triggered. The &lt;code&gt;extra&lt;/code&gt; trace data corresponds to the fifth element in the trace tuples described in &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추적 점이 설정되면 추적 이벤트에 대한 추가 데이터가 포함됩니다. 추가 데이터는 트리거 된 &lt;code&gt;TraceTag&lt;/code&gt; 에 따라 다릅니다 . &lt;code&gt;extra&lt;/code&gt; 추적 튜플의 5 요소로 추적 데이터에 대응에 설명 &lt;code&gt;&lt;a href=&quot;erlang#trace_3_trace_messages&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="537421ac5bc876e1157770197d20f5be1d7bdfa8" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include a time stamp.</source>
          <target state="translated">설정된 경우 추적 프로그램에 타임 스탬프를 포함하도록 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="ebb92b7f506965bd75353ec4f02388501a5389c5" translate="yes" xml:space="preserve">
          <source>If set the tracer has been requested to include the output of a match specification that was run.</source>
          <target state="translated">설정된 경우 추적 프로그램이 실행 된 일치 스펙의 출력을 포함하도록 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="655f54de5d5fcd636afc8c5192a0cd83bf1d3634" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, TLS/DTLS Alert reports are not displayed. Deprecated in OTP 22, use {log_level, &lt;code&gt;&lt;a href=&quot;#type-logging_level&quot;&gt;logging_level()&lt;/a&gt;&lt;/code&gt;} instead.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정하면 TLS / DTLS 경보 보고서가 표시되지 않습니다. OTP 22에서 더 이상 사용되지 않습니다 . 대신 {log_level, &lt;code&gt;&lt;a href=&quot;#type-logging_level&quot;&gt;logging_level()&lt;/a&gt;&lt;/code&gt; }을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c658f8f2f205584d1fb8b1c5da7c1178ed36dd48" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, error reports are not displayed.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정하면 오류 보고서가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c4759d1764534d362731027d076405776344611" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on_heap&lt;/code&gt;, the sending process will first attempt to allocate the space for the message directly on the young heap block of the receiving process. This is not always possible as it requires taking the &lt;strong&gt;main lock&lt;/strong&gt; of the receiving process. The main lock is also held when the process is executing. The possibility for a lock conflict is thus likely in an intensely collaborating system. If the sending process cannot acquire the main lock, a heap fragment is instead created for the message and the message payload is copied onto that. With the &lt;code&gt;off_heap&lt;/code&gt; option the sender process always creates heap fragments for messages sent to that process.</source>
          <target state="translated">&lt;code&gt;on_heap&lt;/code&gt; 로 설정 되면 전송 프로세스는 먼저 수신 프로세스의 젊은 힙 블록에 직접 메시지 공간을 할당하려고 시도합니다. 수신 프로세스 의 &lt;strong&gt;주 잠금&lt;/strong&gt; 을 가져와야하므로 항상 가능한 것은 아닙니다 . 프로세스가 실행 중일 때에도 기본 잠금이 유지됩니다. 따라서 강력한 협업 시스템에서는 잠금 충돌 가능성이 있습니다. 보내는 프로세스가 기본 잠금을 획득 할 수없는 경우 메시지에 대한 힙 조각이 대신 생성되고 메시지 페이로드가 여기에 복사됩니다. 으로 &lt;code&gt;off_heap&lt;/code&gt; 옵션을 보낸 프로세스는 항상 프로세스에 보낸 메시지에 대한 힙 조각을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="310d96f77be1e1791ce6fea41e63aca706ddcee9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; a header field is added to logger_formatter's part of &lt;code&gt;Metadata&lt;/code&gt;. The value of this field is a string similar to the header created by the old &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; event handlers. It can be included in the log event by adding the list &lt;code&gt;[logger_formatter,header]&lt;/code&gt; to the template. See the description of the &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; type for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 헤더 필드가 logger_formatter의 &lt;code&gt;Metadata&lt;/code&gt; 부분에 추가됩니다 . 이 필드의 값은 이전 &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러에 의해 작성된 헤더와 유사한 문자열 입니다. &lt;code&gt;[logger_formatter,header]&lt;/code&gt; 목록 을 템플리트 에 추가하여 로그 이벤트에 포함시킬 수 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#type-template&quot;&gt;template()&lt;/a&gt;&lt;/code&gt; 유형에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd8fb908e24bb62be623e19143f8ea77156d0120" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TCLASS&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; option &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; or &lt;code&gt;IPV6_2292RECVTCLASS&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{tclass,TCLASS}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IPV6_TCLASS&lt;/code&gt; or an &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; CMSG value.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 소켓에 대해 &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; 옵션 &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; 또는 &lt;code&gt;IPV6_2292RECVTCLASS&lt;/code&gt; 프로토콜을 구현하는 플랫폼 에서 수신 된 &lt;code&gt;TCLASS&lt;/code&gt; 값을 반환하는 활성화됩니다 . 이 값은 플랫폼이 &lt;code&gt;IPV6_TCLASS&lt;/code&gt; 또는 &lt;code&gt;IPV6_RECVTCLASS&lt;/code&gt; CMSG 값을 반환하는지 여부에 관계없이 &lt;code&gt;{tclass,TCLASS}&lt;/code&gt; 튜플로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="c1327e3fb152f87bc84a12b83acd5ce3c1ed9810" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TOS&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IP&lt;/code&gt; option &lt;code&gt;IP_RECVTOS&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{tos,TOS}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IP_TOS&lt;/code&gt; or an &lt;code&gt;IP_RECVTOS&lt;/code&gt; CMSG value.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 소켓에 대해 &lt;code&gt;IPPROTO_IP&lt;/code&gt; 옵션 &lt;code&gt;IP_RECVTOS&lt;/code&gt; 프로토콜을 구현하는 플랫폼 에서 수신 된 &lt;code&gt;TOS&lt;/code&gt; 값을 반환하는 활성화됩니다 . 이 값은 플랫폼이 &lt;code&gt;IP_TOS&lt;/code&gt; 또는 &lt;code&gt;IP_RECVTOS&lt;/code&gt; CMSG 값을 반환하는지 여부에 관계없이 &lt;code&gt;{tos,TOS}&lt;/code&gt; 튜플로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="25ca95fc90cd615829fa6bcc45ce252e70ac9443" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt; activates returning the received &lt;code&gt;TTL&lt;/code&gt; value on platforms that implements the protocol &lt;code&gt;IPPROTO_IP&lt;/code&gt; option &lt;code&gt;IP_RECVTTL&lt;/code&gt; for the socket. The value is returned as a &lt;code&gt;{ttl,TTL}&lt;/code&gt; tuple regardless of if the platform returns an &lt;code&gt;IP_TTL&lt;/code&gt; or an &lt;code&gt;IP_RECVTTL&lt;/code&gt; CMSG value.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 소켓에 대해 &lt;code&gt;IPPROTO_IP&lt;/code&gt; 옵션 &lt;code&gt;IP_RECVTTL&lt;/code&gt; 프로토콜을 구현하는 플랫폼 에서 수신 된 &lt;code&gt;TTL&lt;/code&gt; 값을 반환하는 활성화됩니다 . 이 값은 플랫폼이 &lt;code&gt;IP_TTL&lt;/code&gt; 또는 &lt;code&gt;IP_RECVTTL&lt;/code&gt; CMSG 값을 반환하는지 여부에 관계없이 &lt;code&gt;{ttl,TTL}&lt;/code&gt; 튜플로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="4ce4e9a3ec15985becd6d1fc4438e42ee9f02d87" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, all newlines in the message are replaced with &lt;code&gt;&quot;, &quot;&lt;/code&gt;, and white spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 메시지의 모든 줄 바꿈이 줄 바꿈이 제거 된 직후의 &lt;code&gt;&quot;, &quot;&lt;/code&gt; 및 공백 으로 바뀝니다 . &lt;code&gt;template&lt;/code&gt; 매개 변수로 추가 된 줄 바꿈 은 바뀌지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdbfcee3def687520000625ed9063759bcd7fdfe" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, each log event is printed as a single line. To achieve this, &lt;code&gt;logger_formatter&lt;/code&gt; sets the field width to &lt;code&gt;0&lt;/code&gt; for all &lt;code&gt;~p&lt;/code&gt; and &lt;code&gt;~P&lt;/code&gt; control sequences in the format a string (see &lt;code&gt; io:format/2&lt;/code&gt;), and replaces all newlines in the message with &lt;code&gt;&quot;, &quot;&lt;/code&gt;. White spaces following directly after newlines are removed. Notice that newlines added by the &lt;code&gt;template&lt;/code&gt; parameter are not replaced.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정하면 각 로그 이벤트가 한 줄로 인쇄됩니다. 이를 위해 &lt;code&gt;logger_formatter&lt;/code&gt; 는 문자열 형식의 모든 &lt;code&gt;~p&lt;/code&gt; 및 &lt;code&gt;~P&lt;/code&gt; 제어 시퀀스에 대해 필드 너비를 &lt;code&gt;0&lt;/code&gt; 으로 설정하고 ( &lt;code&gt; io:format/2&lt;/code&gt; 참조 ) 메시지의 모든 줄 바꿈을 &lt;code&gt;&quot;, &quot;&lt;/code&gt; 바꿉니다 . 줄 바꿈 바로 뒤의 공백은 제거됩니다. &lt;code&gt;template&lt;/code&gt; 매개 변수 에 의해 추가 된 줄 바꿈 은 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7bc2e449028a1b238287b1e7e1da57633ce0aa2" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;ct_master logs&lt;/code&gt; are written on a primitive HTML format, not using the &lt;code&gt;Common Test&lt;/code&gt; CSS style sheet.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 되면 &lt;code&gt;ct_master logs&lt;/code&gt; 는 &lt;code&gt;Common Test&lt;/code&gt; CSS 스타일 시트를 사용하지 않고 기본 HTML 형식으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c67db27336a237041f3f770706b8f2027a618516" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; try to repair the source code as it seems fit, in certain cases where parsing would otherwise fail. Currently, it inserts &lt;code&gt;++&lt;/code&gt;-operators between string literals and macros where it looks like concatenation was intended. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">로 설정하면 &lt;code&gt;true&lt;/code&gt; ,이 차종 &lt;code&gt;epp_dodger&lt;/code&gt; 는 적합한 것으로 분석하는 경우 어떤 경우에는, 소스 코드를 복구하려고 그렇지 않으면 실패합니다. 현재 문자열 리터럴과 매크로 사이에 &lt;code&gt;++&lt;/code&gt; 연산자를 삽입 하여 연결이 의도 된 것처럼 보입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="553412c0540657c6dfbc0cf5ff30e8dae32d51db" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, use the server preference for cipher selection. If set to &lt;code&gt;false&lt;/code&gt; (the default), use the client preference.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정된 경우 암호 선택에 서버 환경 설정을 사용하십시오. 로 설정하면 &lt;code&gt;false&lt;/code&gt; (기본), 클라이언트 기본 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="845d16e801c4d035d7da73e779db3b12f92e8193" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, workarounds for known server deviations from the HTTP-standard are enabled.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 HTTP 표준에서 알려진 서버 편차에 대한 해결 방법이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4e5151c0c30a4e7bb11fe24669fcb768cff8dff0" translate="yes" xml:space="preserve">
          <source>If set to anything else than &lt;code&gt;0&lt;/code&gt;, it makes all times displayed by &lt;code&gt;run_erl&lt;/code&gt; to be in UTC (GMT, CET, MET, without Daylight Saving Time), rather than in local time. This does not affect data coming from Erlang, only the logs output directly by &lt;code&gt;run_erl&lt;/code&gt;. Application SASL can be modified accordingly by setting the Erlang application variable &lt;code&gt;utc_log&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정하면 &lt;code&gt;run_erl&lt;/code&gt; 에 의해 표시된 모든 시간 이 현지 시간이 아닌 UTC ( CMT , CET, MET, 일광 절약 시간 없음)로 표시됩니다. 이것은 Erlang에서 오는 데이터에는 영향을 미치지 않으며 &lt;code&gt;run_erl&lt;/code&gt; 에 의해 직접 출력되는 로그에만 영향을 미칩니다 . Erlang 애플리케이션 변수 &lt;code&gt;utc_log&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 애플리케이션 SASL을 적절히 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54ecba8897a2d3cf6ca4714afe4059ed1a0bc69c" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, an unlimited number of login attempts are allowed simultaneously.</source>
          <target state="translated">false (기본값)로 설정하면 한 번에 하나의 로그인 만 처리됩니다. true로 설정하면 무제한의 로그인 시도가 동시에 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a47f9a94c76c57c796417eab15c787a00acacf" translate="yes" xml:space="preserve">
          <source>If set to false (the default value), only one login is handled at a time. If set to true, the number of simultaneous login attempts are limited by the value of &lt;code&gt;&lt;a href=&quot;ssh#hardening_daemon_options--max_sessions&quot;&gt;max_sessions&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">false (기본값)로 설정하면 한 번에 하나의 로그인 만 처리됩니다. true로 설정하면 동시 로그인 시도 횟수가 &lt;code&gt;&lt;a href=&quot;ssh#hardening_daemon_options--max_sessions&quot;&gt;max_sessions&lt;/a&gt;&lt;/code&gt; 옵션 값으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7e5e755a8f0aa4316d9b9f5d9dcea02be971e72" translate="yes" xml:space="preserve">
          <source>If set to other than &quot;NoPassword&quot;, the password is required for all API calls. If the password is set to &quot;DummyPassword&quot;, the password must be changed before any other API calls. To secure the authenticating data, the password must be changed after the web server is started. Otherwise it is written in clear text in the configuration file.</source>
          <target state="translated">&quot;NoPassword&quot;이외로 설정하면 모든 API 호출에 비밀번호가 필요합니다. 비밀번호가 &quot;DummyPassword&quot;로 설정된 경우 다른 API 호출 전에 비밀번호를 변경해야합니다. 인증 데이터를 보호하려면 웹 서버가 시작된 후 비밀번호를 변경해야합니다. 그렇지 않으면 구성 파일에 일반 텍스트로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9508965c72b0132e5a02e474dd8d5307005afa10" translate="yes" xml:space="preserve">
          <source>If set, the &lt;code&gt;accept()&lt;/code&gt;, &lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;writev()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;read()&lt;/code&gt; callbacks implements timeouts. The timeout is passed in the &lt;code&gt;tmo&lt;/code&gt; argument and is given in milli seconds. Note that the &lt;code&gt;tmo&lt;/code&gt; argument to these callbacks differ from the timeout arguments in the &lt;code&gt;ei&lt;/code&gt; API. Zero means a zero timeout. That is, poll and timeout immediately unless the operation is successful. &lt;code&gt;EI_SCLBK_INF_TMO&lt;/code&gt; (max &lt;code&gt;unsigned&lt;/code&gt;) means infinite timeout. The file descriptor is in blocking mode when a callback is called, and it must be in blocking mode when the callback returns.</source>
          <target state="translated">설정된 경우 &lt;code&gt;accept()&lt;/code&gt; , &lt;code&gt;connect()&lt;/code&gt; , &lt;code&gt;writev()&lt;/code&gt; , &lt;code&gt;write()&lt;/code&gt; 및 &lt;code&gt;read()&lt;/code&gt; 콜백은 시간 제한을 구현합니다. 제한 시간은 &lt;code&gt;tmo&lt;/code&gt; 인수 로 전달 되며 밀리 초 단위로 제공됩니다. 이러한 콜백에 대한 &lt;code&gt;tmo&lt;/code&gt; 인수는 &lt;code&gt;ei&lt;/code&gt; API 의 시간 초과 인수와 다릅니다 . 0은 시간 제한이 없음을 의미합니다. 즉, 작업이 성공하지 않는 한 즉시 폴링 및 타임 아웃됩니다. &lt;code&gt;EI_SCLBK_INF_TMO&lt;/code&gt; (최대 &lt;code&gt;unsigned&lt;/code&gt; )는 무한 시간 초과를 의미합니다. 파일 설명자는 콜백이 호출 될 때 차단 모드에 있고 콜백이 반환 될 때 차단 모드에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="cbc8baf201837b9902d99d9c6ceeaafc45b233fd" translate="yes" xml:space="preserve">
          <source>If several fields are to be assigned the same value, the following construction can be used:</source>
          <target state="translated">여러 필드에 동일한 값을 할당하려면 다음 구성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ef3b935d35dcc97954564f91b02dc29963a181" translate="yes" xml:space="preserve">
          <source>If so, or if possibly needed in future versions, then you should consider using &lt;code&gt;gen_statem&lt;/code&gt; over &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">그렇다면 향후 버전에서 필요할 경우 &lt;code&gt;gen_statem&lt;/code&gt; 보다 &lt;code&gt;gen_server&lt;/code&gt; 사용 을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f43fb2b2715e85b137bcfdf2730b0beccbdd0c4b" translate="yes" xml:space="preserve">
          <source>If so, the user is authorized.</source>
          <target state="translated">그렇다면 사용자에게 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="33f2cb0ac87e42cdbdf8827c536efd85bb8b5ca2" translate="yes" xml:space="preserve">
          <source>If some of the found BEAM files contain &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then those modules are checked and a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">발견 된 BEAM 파일 중 일부에 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; 포함 된 경우 해당 모듈을 검사하고 튜플 목록이 리턴됩니다. 각 튜플의 첫 번째 요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="6a5a8a25ced47d4519279df0ad60d300b9fdd3ac" translate="yes" xml:space="preserve">
          <source>If some variables were present in the configuration, but are not loaded using this function, they are removed from the configuration table together with their aliases.</source>
          <target state="translated">구성에 일부 변수가 있지만이 기능을 사용하여로드되지 않은 경우, 별명과 함께 구성 테이블에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="908c252e088323e888f147ff16d100c7706161d0" translate="yes" xml:space="preserve">
          <source>If something goes wrong, the function can also return an error tuple &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">문제가 발생하면이 함수는 오류 튜플 &lt;code&gt;{error,Error}&lt;/code&gt; 도 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70476ad38abe74628a91e231b10da869d250c572" translate="yes" xml:space="preserve">
          <source>If specified by its filename, the filename can include a path and the &lt;code&gt;.erl&lt;/code&gt; extension can be omitted. The object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for first in the same directory as the source code, then in an &lt;code&gt;ebin&lt;/code&gt; directory next to it, and then in the current path.</source>
          <target state="translated">파일 이름으로 지정된 경우 파일 이름에 경로가 포함될 수 있으며 &lt;code&gt;.erl&lt;/code&gt; 확장자는 생략 할 수 있습니다. 먼저 소스 코드와 동일한 디렉토리에서 오브젝트 코드 &lt;code&gt;Module.beam&lt;/code&gt; 을 검색 한 다음 옆 에있는 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에서 현재 경로를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="50b19f1c8b9a65cb742065615e51dec1da364a91" translate="yes" xml:space="preserve">
          <source>If specified by its module name, the object code &lt;code&gt;Module.beam&lt;/code&gt; is searched for in the current path. The source code &lt;code&gt;Module.erl&lt;/code&gt; is searched for first in the same directory as the object code, then in an &lt;code&gt;src&lt;/code&gt; directory next to it.</source>
          <target state="translated">모듈 이름으로 지정된 경우 현재 경로에서 객체 코드 &lt;code&gt;Module.beam&lt;/code&gt; 을 검색합니다. 소스 코드 &lt;code&gt;Module.erl&lt;/code&gt; 은 먼저 오브젝트 코드와 동일한 디렉토리에서 검색된 후 그 옆 의 &lt;code&gt;src&lt;/code&gt; 디렉토리에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d0b6cf013a5c0d8770719696ef065b65aefbe7" translate="yes" xml:space="preserve">
          <source>If starting the test with a general verbosity level of 50 (&lt;code&gt;?STD_VERBOSITY&lt;/code&gt;):</source>
          <target state="translated">일반 상세 레벨 50 ( &lt;code&gt;?STD_VERBOSITY&lt;/code&gt; ) 으로 테스트를 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="bff20119788e7f9fcb0386bb0ba5f7207f1771ed" translate="yes" xml:space="preserve">
          <source>If starting the test with:</source>
          <target state="translated">다음으로 테스트를 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="26a65a58a274c5e83de124292f3254f1ac090467" translate="yes" xml:space="preserve">
          <source>If status was &lt;code&gt;alive&lt;/code&gt;, node &lt;code&gt;A&lt;/code&gt; answers with another status message containing either &lt;code&gt;true&lt;/code&gt;, which means that the connection is to continue (the old connection from this node is broken), or &lt;code&gt;false&lt;/code&gt;, which means that the connection is to be closed (the connection attempt was a mistake.</source>
          <target state="translated">status가 &lt;code&gt;alive&lt;/code&gt; 상태 인 경우 노드 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 포함하는 다른 상태 메시지로 응답 합니다 . 이는 연결이 계속됨 (이 노드의 이전 연결이 끊어 졌음 을 의미 함 ) 또는 연결을 닫을 것임을 의미하는 &lt;code&gt;false&lt;/code&gt; 입니다 (연결 시도는 실수였다.</target>
        </trans-unit>
        <trans-unit id="7b9b70b7cbd405f4ef48bddbc33725b6c4cf3c30" translate="yes" xml:space="preserve">
          <source>If sticky locks are used, the code must first be changed as follows:</source>
          <target state="translated">고정 잠금 장치를 사용하는 경우 먼저 코드를 다음과 같이 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7eb71447bfe22582a45b3625c21c45102fb30a5" translate="yes" xml:space="preserve">
          <source>If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:</source>
          <target state="translated">하위 표현식이 정규 표현식에 지정된 경우 일치하는 하위 표현식도 결과 목록에 리턴됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b8ddaa042ba6e6a6e6f3aa8c56ca060f0b33630" translate="yes" xml:space="preserve">
          <source>If successful</source>
          <target state="translated">성공하면</target>
        </trans-unit>
        <trans-unit id="211664819a4310bd77112b972f6e1afd6ef67b18" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state in an &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; 튜플 에서 업데이트 된 내부 상태를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4e8c6ee9fde6d55757690d169dc69ff0e99e718e" translate="yes" xml:space="preserve">
          <source>If successful, the function must return the updated internal state.</source>
          <target state="translated">성공하면 함수는 업데이트 된 내부 상태를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="932989b7c1361152a0b0809cc73761645d677b31" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; exists but the corresponding child process is running or is about to be restarted, the function returns &lt;code&gt;{error,running}&lt;/code&gt; or &lt;code&gt;{error,restarting}&lt;/code&gt;, respectively. If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . &lt;code&gt;Id&lt;/code&gt; 로 식별 된 하위 스펙 이 존재하지만 해당 하위 프로세스가 실행 중이거나 다시 시작될 예정인 경우, 함수는 각각 &lt;code&gt;{error,running}&lt;/code&gt; 또는 &lt;code&gt;{error,restarting}&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;Id&lt;/code&gt; 로 식별 된 하위 스펙 이 존재하지 않으면 함수는 &lt;code&gt;{error,not_found}&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a7459c85147eae0af4289577e8d8cb1033070c0" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;ok&lt;/code&gt;. If there is no child specification with the specified &lt;code&gt;Id&lt;/code&gt;, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환합니다 . 지정된 &lt;code&gt;Id&lt;/code&gt; 의 하위 스펙이없는 경우 함수는 &lt;code&gt;{error,not_found}&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6c554336fd49d3d6148f3873055df50396396c91" translate="yes" xml:space="preserve">
          <source>If successful, the function returns &lt;code&gt;{ok,State}&lt;/code&gt; or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial internal state of the event handler.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;{ok,State}&lt;/code&gt; 또는 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;State&lt;/code&gt; 는 이벤트 핸들러의 초기 내부 상태입니다.</target>
        </trans-unit>
        <trans-unit id="2203259483f235e1b092ade2119d4c07d6241b2e" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map or if it does not contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;*map_out&lt;/code&gt; 을 새 맵으로 설정하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 반환 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;map_in&lt;/code&gt; 가 그것을 포함하지 않는 경우지도가 아니거나 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba18cbb490e9c8d2f3b6ef180516f04715f3defa" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;map_in&lt;/code&gt; is not a map.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;*map_out&lt;/code&gt; 을 새 맵으로 설정하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . &lt;code&gt;map_in&lt;/code&gt; 이지도 가 아닌 경우 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c57bdf287994755b6e44fdfc60facab5a9f11a53" translate="yes" xml:space="preserve">
          <source>If successful, this function sets &lt;code&gt;*map_out&lt;/code&gt; to the new map and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; there are any duplicate keys.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;*map_out&lt;/code&gt; 을 새 맵으로 설정하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 중복 키가 있으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="235077c5f09d774b9f3db45cd19ec2e827847cd9" translate="yes" xml:space="preserve">
          <source>If such a clause cannot be found, a &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">이러한 절을 찾을 수 없으면 &lt;code&gt;function_clause&lt;/code&gt; 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="283f86d98b5d92d6ad1ce6bfc63055da78218576" translate="yes" xml:space="preserve">
          <source>If such a clause is found, the corresponding clause body is evaluated. That is, the expressions in the body are evaluated sequentially and the value of the last expression is returned.</source>
          <target state="translated">그러한 절이 발견되면 해당 절 본문이 평가됩니다. 즉, 본문의 표현식이 순차적으로 평가되고 마지막 표현식의 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b28412a4d9f9549fe2f357ee3ab836136e195e5c" translate="yes" xml:space="preserve">
          <source>If support is found, the option &lt;code&gt;{property_test_tool,ToolModule}&lt;/code&gt; with the selected tool main module name (&lt;code&gt;eqc&lt;/code&gt;, &lt;code&gt;proper&lt;/code&gt; or &lt;code&gt;triq&lt;/code&gt;) is added to the list &lt;code&gt;Config&lt;/code&gt; which then is returned.</source>
          <target state="translated">지원이 발견되면 선택한 도구 기본 모듈 이름 ( &lt;code&gt;eqc&lt;/code&gt; , &lt;code&gt;proper&lt;/code&gt; 또는 &lt;code&gt;triq&lt;/code&gt; ) 과 함께 &lt;code&gt;{property_test_tool,ToolModule}&lt;/code&gt; 옵션 이 &lt;code&gt;Config&lt;/code&gt; 목록에 추가 된 다음 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fcf16676aca666b69b183aa34b448a75829f94" translate="yes" xml:space="preserve">
          <source>If synchronization is not possible, an error report is sent to the error logger (see also &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동기화가 불가능하면 오류 보고서가 오류 로거로 전송됩니다 ( &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger(3)&lt;/a&gt;&lt;/code&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="36f347d7b778b3a4f6fb90496e2acb23c2a7a864" translate="yes" xml:space="preserve">
          <source>If syntax errors are discovered in these files they are reported with the function &lt;code&gt;config_err/2&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; at start-up.</source>
          <target state="translated">이러한 파일에서 구문 오류가 발견되면 시작시 &lt;code&gt;&lt;a href=&quot;snmpa_error_report&quot;&gt;error report module&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;config_err/2&lt;/code&gt; 기능으로보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="e5db19b0c235be5b01f2325198c01dc60d89585f" translate="yes" xml:space="preserve">
          <source>If tagged allocations are not enabled on any of the specified allocator types, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">지정된 할당 자 유형에서 태그 지정된 할당을 사용하지 않으면 &lt;code&gt;{error, not_enabled}&lt;/code&gt; 호출이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="430e9485ed1c99e4dac7dca3da3dfa4aa8c39ab8" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; cannot be compiled (does not represent a valid match specification), a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">용어 &lt;code&gt;MatchSpec&lt;/code&gt; 을 컴파일 할 수 없으면 (유효한 일치 스펙을 나타내지 않음) &lt;code&gt;badarg&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="763ff93c3062ce44172fb309cebb5a06079fead9" translate="yes" xml:space="preserve">
          <source>If term &lt;code&gt;MatchSpec&lt;/code&gt; does not represent a valid match specification, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">용어 &lt;code&gt;MatchSpec&lt;/code&gt; 이 유효한 일치 사양을 나타내지 않으면 &lt;code&gt;badarg&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b34a1091c99e6fe485396a9633ee9cf35b5e6022" translate="yes" xml:space="preserve">
          <source>If test suites or help modules include header files stored in other locations than the test directory, these include directories can be specified by using flag &lt;code&gt;-include&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt;, or option &lt;code&gt;include&lt;/code&gt; with &lt;code&gt;ct:run_test/1&lt;/code&gt;. Also, an include path can be specified with an OS environment variable, &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt;.</source>
          <target state="translated">테스트 스위트 또는 도움말 모듈 테스트 디렉토리가 아닌 다른 위치에 저장된 헤더 파일을 포함하는 경우,이 플래그를 사용하여 지정할 수 있습니다 디렉토리 포함 &lt;code&gt;-include&lt;/code&gt; 을 함께 &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; , 또는 옵션 &lt;code&gt;include&lt;/code&gt; 으로 &lt;code&gt;ct:run_test/1&lt;/code&gt; . 또한 OS 환경 변수 &lt;code&gt;CT_INCLUDE_PATH&lt;/code&gt; 로 포함 경로를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e790d3acc547bf4dd4b0058bee91f205e4b15cf" translate="yes" xml:space="preserve">
          <source>If the &quot;certificate_authorities&quot; extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.</source>
          <target state="translated">CertificateRequest 메시지에 &quot;certificate_authorities&quot;확장이있는 경우 인증서 체인에있는 인증서 중 하나 이상은 나열된 CA 중 하나에서 발급해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="c4c1965cf3b85e5ae91bfc7f462d56b4e302c996" translate="yes" xml:space="preserve">
          <source>If the 'main' worker is busy, a temporary process is spawned to handle that 'get-request'.</source>
          <target state="translated">'주'작업자가 사용 중이면 해당 'get-request'를 처리하기 위해 임시 프로세스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ece8268eb3bcace140f99c6e854d866eed3ef694" translate="yes" xml:space="preserve">
          <source>If the 'main' worker is busy, a temporary process is spawned to handle that job ('get-request' or notification).</source>
          <target state="translated">'주'작업자가 사용 중이면 해당 작업을 처리하기 위해 임시 프로세스가 생성됩니다 ( 'get-request'또는 알림).</target>
        </trans-unit>
        <trans-unit id="c9279b9016abb718b19436b545788de84fa2134f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, BEAM files that contain no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; are ignored.</source>
          <target state="translated">외부 참조 서버 의 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;functions&lt;/code&gt; 인 경우 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; 가 없는 BEAM 파일 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c813a10d16024092b88cb717d0c880a3632b14a1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of the Xref server is &lt;code&gt;functions&lt;/code&gt;, and the BEAM file contains no &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, the error message &lt;code&gt;no_debug_info&lt;/code&gt; is returned.</source>
          <target state="translated">외부 참조 서버 의 &lt;code&gt;&lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;functions&lt;/code&gt; 이고 BEAM 파일에 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; 가 없으면 오류 메시지 &lt;code&gt;no_debug_info&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ef80d1f8c11747796d02d57345e648de2094089e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;handle_event_function&lt;/code&gt; , 상태는 어떤 용어가 될 수 있습니다. 후 &lt;strong&gt;상태 변화&lt;/strong&gt; ( &lt;code&gt;NextState =/= State&lt;/code&gt; ), 모든 연기 이벤트가 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="0b9197e338e3401c234d140df6601d7f0bd0de9f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;handle_event_function&lt;/code&gt; , 상태는 어떤 용어가 될 수 있습니다. 상태 변경 ( &lt;code&gt;NextState =/= State&lt;/code&gt; ) 후에 연기 된 모든 이벤트가 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="77912caa4ee948d9b6eee0f54f2cb39e15b274ee" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom. After a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried. Note that the state &lt;code&gt;terminate&lt;/code&gt; is not possible to use since it would collide with the optional callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;state_functions&lt;/code&gt; 를 , 상태는 원자해야합니다. 후 &lt;strong&gt;상태 변화&lt;/strong&gt; ( &lt;code&gt;NextState =/= State&lt;/code&gt; ), 모든 연기 이벤트가 시도됩니다. &lt;code&gt;terminate&lt;/code&gt; 상태 는 선택적 콜백 함수 &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; 과 충돌하므로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="74c7a5f40b37419e0dfdb9c000a09ebaefa7ede7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be of this type. After a state change (&lt;code&gt;NextState =/= State&lt;/code&gt;), all postponed events are retried.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;state_functions&lt;/code&gt; , 상태는이 유형이어야합니다. 상태 변경 ( &lt;code&gt;NextState =/= State&lt;/code&gt; ) 후에 연기 된 모든 이벤트가 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="693335b3ceb4c3438c26542cdb03f54e066d8540" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt; erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="translated">경우] &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 가 에 설정된 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 데이터를 통해 운전자에 강제 할 수 &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt; erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; 드라이버가 중임 시그널링 되더라도.</target>
        </trans-unit>
        <trans-unit id="720d616c478f9b1d1e0e376e567468c7cbccb10c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; has been set in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt;, data can be forced into the driver through &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; even if the driver has signaled that it is busy.</source>
          <target state="translated">경우] &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 가 에 설정된 &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; 데이터를 통해 운전자에 강제 할 수 &lt;code&gt;&lt;a href=&quot;erlang#port_command-3&quot;&gt;erlang:port_command(Port, Data, [force])&lt;/a&gt;&lt;/code&gt; 드라이버가 중임 시그널링 되더라도.</target>
        </trans-unit>
        <trans-unit id="24fb3b31f2e1a1b36aa86e0260daf033dbd388cc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;snmp_config#manager_irb&quot;&gt;inform request behaviour&lt;/a&gt;&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="translated">경우] &lt;code&gt;&lt;a href=&quot;snmp_config#manager_irb&quot;&gt;inform request behaviour&lt;/a&gt;&lt;/code&gt; 설정 옵션이 설정되어 &lt;code&gt;user&lt;/code&gt; 또는 &lt;code&gt;{user, integer()}&lt;/code&gt; 이 통보 요청에 대한 응답 (확인 응답)이 때 함수 리턴 전송한다.</target>
        </trans-unit>
        <trans-unit id="436abcfe6ccf26003670b7e8f6ead1ae9566d2af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior is used to implement the channel process, these messages are handled by &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 동작이 채널 프로세스를 구현하는 데 사용되는 경우 이러한 메시지는 &lt;code&gt;&lt;a href=&quot;ssh_client_channel#Module:handle_ssh_msg-2&quot;&gt;handle_ssh_msg/2&lt;/a&gt;&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5b8a260b0935e82c1c23c647ce2490c52e709f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_control/3&lt;/code&gt; is a binary, the driver will be passed a pointer to the contents of the binary and the binary will not be copied. If the &lt;code&gt;Data&lt;/code&gt; argument is an iolist (list of binaries and lists), all binaries in the iolist will be copied.</source>
          <target state="translated">&lt;code&gt;port_control/3&lt;/code&gt; 의 &lt;code&gt;Data&lt;/code&gt; 인수 가 2 진이면 드라이버는 2 진의 내용에 대한 포인터를 전달 받으며 2 진은 복사되지 않습니다. 경우 &lt;code&gt;Data&lt;/code&gt; 인수가 iolist (바이너리와리스트의 목록이)되면, iolist의 모든 바이너리가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="22cf2f621c573393bcc21b524ec1f8b2f0eb496f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;EI_SCLBK_FLG_FULL_IMPL&lt;/code&gt; flag has been set, &lt;code&gt;tmo&lt;/code&gt; contains timeout time in milliseconds.</source>
          <target state="translated">는 IF &lt;code&gt;EI_SCLBK_FLG_FULL_IMPL&lt;/code&gt; 의 플래그가 설정되어, &lt;code&gt;tmo&lt;/code&gt; 밀리 초 타임 아웃 시간이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f73654015166f98aadbf7b3b123e17e68232e9b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;HEART_COMMAND&lt;/code&gt; environment variable is to be set in the &lt;code&gt;start&lt;/code&gt; script in &lt;strong&gt;Starting Erlang&lt;/strong&gt;, and if the value is to be set to the path of the Solaris &lt;code&gt;reboot&lt;/code&gt; command, that is:</source>
          <target state="translated">는 IF &lt;code&gt;HEART_COMMAND&lt;/code&gt; 의 환경 변수에 설정되는 &lt;code&gt;start&lt;/code&gt; 에 스크립트 &lt;strong&gt;얼랑을 시작&lt;/strong&gt; 하고, 값이 솔라리스의 경로로 설정하는 경우 &lt;code&gt;reboot&lt;/code&gt; 명령, 즉 :</target>
        </trans-unit>
        <trans-unit id="944e73a76d9846f1844b61fadd1ef6be5fa46f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Item&lt;/code&gt; is a string &quot;&amp;lt;X.Y.Z&amp;gt;&quot; as returned from &lt;code&gt;pid_to_list/1&lt;/code&gt;, the process &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; is traced.</source>
          <target state="translated">경우] &lt;code&gt;Item&lt;/code&gt; 에서 반환 스트링 &quot;&amp;lt;XYZ&amp;gt;&quot;이다 &lt;code&gt;pid_to_list/1&lt;/code&gt; , 프로세스 &lt;code&gt;&amp;lt;X.Y.Z&amp;gt;&lt;/code&gt; 추적된다.</target>
        </trans-unit>
        <trans-unit id="61eca5d5aa872cbcbe9a56199f7268cf843102ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Mod&lt;/code&gt; argument is given, the result contains a &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for module &lt;code&gt;Mod&lt;/code&gt; only, otherwise the result contains one &lt;code&gt;ModAnalysis&lt;/code&gt; tuple for all modules returned from &lt;code&gt;code:all_loaded()&lt;/code&gt; except &lt;code&gt;cprof&lt;/code&gt; itself.</source>
          <target state="translated">는 IF &lt;code&gt;Mod&lt;/code&gt; 인수가 주어, 그 결과는 포함 &lt;code&gt;ModAnalysis&lt;/code&gt; 의 모듈에 대한 튜플 &lt;code&gt;Mod&lt;/code&gt; , 만, 그렇지 않으면 결과는 하나 포함 &lt;code&gt;ModAnalysis&lt;/code&gt; 의 에서 반환 된 모든 모듈에 대한 튜플 &lt;code&gt;code:all_loaded()&lt;/code&gt; 을 제외하고 &lt;code&gt;cprof&lt;/code&gt; 자체.</target>
        </trans-unit>
        <trans-unit id="692d7ddeb29364bd451d87d06edbd7eec80bea02" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has been set, a &lt;code&gt;NewAtomCacheRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">는 IF &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 다음에 대한 &lt;code&gt;AtomCacheRef&lt;/code&gt; 이 설정되어하는 &lt;code&gt;NewAtomCacheRef&lt;/code&gt; 다음과 같은 형식에는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="04c0254fa6d70d431ad5a486ddf123ee44618a15" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; for the next &lt;code&gt;AtomCacheRef&lt;/code&gt; has not been set, a &lt;code&gt;CachedAtomRef&lt;/code&gt; on the following format follows:</source>
          <target state="translated">는 IF &lt;code&gt;NewCacheEntryFlag&lt;/code&gt; 다음에 대한 &lt;code&gt;AtomCacheRef&lt;/code&gt; 이 설정되어 있지 않은하는 &lt;code&gt;CachedAtomRef&lt;/code&gt; 다음과 같은 형식에는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="8c90300fd144cf66a22b387cf8df2ba0e1883646" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ssh2_pubkey&lt;/code&gt;, the &lt;code&gt;InData&lt;/code&gt; shall be &lt;code&gt;InData_ssh2_pubkey&lt;/code&gt;. Otherwise it shall be &lt;code&gt;OtherInData&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;ssh2_pubkey&lt;/code&gt; 의 &lt;code&gt;InData&lt;/code&gt; 되어야한다 &lt;code&gt;InData_ssh2_pubkey&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;OtherInData&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="5892c57f59a62e642afcb7987d330a6a6bddcb6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ssh2_pubkey&lt;/code&gt;, the result will be &lt;code&gt;Decoded_ssh2_pubkey&lt;/code&gt;. Otherwise it will be &lt;code&gt;Decoded_OtherType&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;Type&lt;/code&gt; 이다 &lt;code&gt;ssh2_pubkey&lt;/code&gt; , 결과가 될 것입니다 &lt;code&gt;Decoded_ssh2_pubkey&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;Decoded_OtherType&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="5abbbca51e0d96970bfc6e932a6073fa6c1b8d91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WrapSize&lt;/code&gt; is specified as &lt;code&gt;{time, WrapTime}&lt;/code&gt;, the current file is closed when it has been open more than &lt;code&gt;WrapTime&lt;/code&gt; milliseconds, regardless of it being empty or not.</source>
          <target state="translated">경우 &lt;code&gt;WrapSize&lt;/code&gt; 가 로 지정된 &lt;code&gt;{time, WrapTime}&lt;/code&gt; 더 이상 열려 경우, 현재 파일이 닫히고 &lt;code&gt;WrapTime&lt;/code&gt; 의 밀리 초에 관계없이 그것의 빈 여부 것.</target>
        </trans-unit>
        <trans-unit id="3bce9200cd49c0302061751c509bff17706e1d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;collector_pid&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; a new &lt;code&gt;et_collector&lt;/code&gt; will be started with the following parameter settings: &lt;code&gt;parent_pid&lt;/code&gt;, &lt;code&gt;event_order&lt;/code&gt;, &lt;code&gt;trace_global&lt;/code&gt;, &lt;code&gt;trace_pattern&lt;/code&gt;, &lt;code&gt;trace_port&lt;/code&gt;, &lt;code&gt;trace_max_queue&lt;/code&gt;, &lt;code&gt;trace_client&lt;/code&gt;, &lt;code&gt;dict_insert&lt;/code&gt; and &lt;code&gt;dict_delete&lt;/code&gt;. The new &lt;code&gt;et_viewer&lt;/code&gt; will register itself as an &lt;code&gt;et_collector&lt;/code&gt; subscriber.</source>
          <target state="translated">&lt;code&gt;collector_pid&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 경우 &lt;code&gt;parent_pid&lt;/code&gt; , &lt;code&gt;event_order&lt;/code&gt; , &lt;code&gt;trace_global&lt;/code&gt; , &lt;code&gt;trace_pattern&lt;/code&gt; , &lt;code&gt;trace_port&lt;/code&gt; , &lt;code&gt;trace_max_queue&lt;/code&gt; , &lt;code&gt;trace_client&lt;/code&gt; , &lt;code&gt;dict_insert&lt;/code&gt; 및 &lt;code&gt;dict_delete&lt;/code&gt; 매개 변수 설정 으로 새 &lt;code&gt;et_collector&lt;/code&gt; 가 시작됩니다 . 새로운 &lt;code&gt;et_viewer&lt;/code&gt; 는 자신을 &lt;code&gt;et_collector&lt;/code&gt; 가입자 로 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="3ef49ec23c42d8c8e08d0e1a55605acb0e8d5ac7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;crypto_fun()&lt;/code&gt; reurns a &lt;code&gt;chunk_size()&lt;/code&gt;, that value is as block size for further blocks in calls to &lt;code&gt;crypto_fun()&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;crypto_fun()&lt;/code&gt; reurns &lt;code&gt;chunk_size()&lt;/code&gt; , 그 값이 호출에서 상기 블록에 대한 블록 크기 같다 &lt;code&gt;crypto_fun()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1705267e03ee01724d59b40bc5f0214567319c46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; and/or &lt;code&gt;per_cpu&lt;/code&gt; option is given, this is the CPU number, or a list of the CPU numbers.</source>
          <target state="translated">는 IF &lt;code&gt;detailed&lt;/code&gt; 및 / 또는 &lt;code&gt;per_cpu&lt;/code&gt; 의 옵션이 주어, 이것은 CPU 번호, 또는 CPU 번호의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e77d603a3001a1e9c1762cdeaacfe7bfa22a3f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;detailed&lt;/code&gt; option is given, this is a list of &lt;code&gt;{State, Share}&lt;/code&gt; tuples, where each tuple contains information about a processor state that has been identified as a busy processor state (see below). The atom &lt;code&gt;State&lt;/code&gt; is the name of the state, and the float &lt;code&gt;Share&lt;/code&gt; represents the percentage share of the CPU cycles spent in this state since the last call to &lt;code&gt;util/0&lt;/code&gt; or &lt;code&gt;util/1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;detailed&lt;/code&gt; 옵션이 주어,이 목록입니다 &lt;code&gt;{State, Share}&lt;/code&gt; 각 튜플은 바쁜 프로세서 상태로 확인 된 프로세서 상태에 대한 정보를 포함 튜플 (아래 참조). atom &lt;code&gt;State&lt;/code&gt; 는 상태 의 이름이며 float &lt;code&gt;Share&lt;/code&gt; 는 &lt;code&gt;util/0&lt;/code&gt; 또는 &lt;code&gt;util/1&lt;/code&gt; 에 대한 마지막 호출 이후이 상태에서 소비 된 CPU주기의 백분율을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ceeca0dd799d0c2b30a43e745da4464b5bf6bdd0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="translated">경우] &lt;code&gt;erpc&lt;/code&gt; 의 조작이 실패하지만, 기능 / 적용될 경우가 알려지지 않은 (즉, 접속 손실), 발신자는 결과 / IF인가 기능 완료에 대한 정보를 수신하지 않을 것이다. 적용된 함수가 호출 프로세스와 명시 적으로 통신하는 경우 이러한 통신은 물론 호출 프로세스에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e75076deae26fb176f6e6643de28792f0d16c28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="translated">경우] &lt;code&gt;erpc&lt;/code&gt; 의 조작이 실패하지만, 기능 / 적용될 경우가 알려지지 않은 (즉, 타임 아웃 또는 접속 손실)은 호출자 결과 / IF인가 기능 완료에 대한 정보를 수신하지 않을 것이다. 적용된 함수가 호출 프로세스와 명시 적으로 통신하는 경우 이러한 통신은 물론 호출 프로세스에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c62b99585baeb954cbb0731a4ba30894bb10a1da" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a timeout, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="translated">경우] &lt;code&gt;erpc&lt;/code&gt; 의 조작이 실패하지만, 기능 / 적용될 경우가 알려지지 않은 (즉, 타임 아웃, 또는 접속 손실)은 호출자 결과 / IF인가 기능 완료에 대한 정보를 수신하지 않을 것이다. 적용된 함수가 호출 프로세스와 명시 적으로 통신하는 경우 이러한 통신은 물론 호출 프로세스에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a3a64fa23b1c369a1e49078a7eef230d3e65da" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;erpc&lt;/code&gt; operation fails, but it is unknown if the function is/will be applied (that is, a too large wait time value, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process.</source>
          <target state="translated">경우] &lt;code&gt;erpc&lt;/code&gt; 의 조작이 실패하지만, 기능 / 적용될 경우가 알려지지 않은 (즉, 너무 큰 대기 시간 값, 또는 접속 손실)은, 호출자는 그 결과에 대한 정보를 수신하지 않을 때 / IF 적용된 기능이 완료됩니다. 적용된 함수가 호출 프로세스와 명시 적으로 통신하는 경우 이러한 통신은 물론 호출 프로세스에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01f6b148b35fa3a772ed4cf02b8f14d1a3fb663b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;excl_lib&lt;/code&gt; option is set to &lt;code&gt;otp_root&lt;/code&gt; then reltool will not copy anything from the Erlang/OTP installation ($OTP_ROOT) into the target structure. The goal is to create a &quot;slim&quot; release which can be used together with an existing Erlang/OTP installation. The target structure will therefore only contain a &lt;code&gt;lib&lt;/code&gt; directory with the applications that were found outside of $OTP_ROOT (typically your own applications), and a &lt;code&gt;releases&lt;/code&gt; directory with the generated &lt;code&gt;.rel,&lt;/code&gt;&lt;code&gt;.script&lt;/code&gt; and &lt;code&gt;.boot&lt;/code&gt; files.</source>
          <target state="translated">는 IF &lt;code&gt;excl_lib&lt;/code&gt; 의 옵션이 설정되어 &lt;code&gt;otp_root&lt;/code&gt; 다음 reltool 대상 구조로 얼랑 / OTP 설치 ($ OTP_ROOT)에서 아무것도를 복사하지 않습니다. 목표는 기존 Erlang / OTP 설치와 함께 사용할 수있는 &quot;슬림&quot;릴리스를 작성하는 것입니다. 따라서 대상 구조에는 $ OTP_ROOT 외부에있는 응용 프로그램 (일반적으로 자체 응용 프로그램)이 있는 &lt;code&gt;lib&lt;/code&gt; 디렉토리와 생성 된 &lt;code&gt;.rel,&lt;/code&gt; &lt;code&gt;.script&lt;/code&gt; 및 &lt;code&gt;.boot&lt;/code&gt; 파일이 있는 &lt;code&gt;releases&lt;/code&gt; 디렉토리 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="be47c608e84207db441f123dc3b022c3bdfe3832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fprof&lt;/code&gt; server is not running, this function returns immediately with the same return value.</source>
          <target state="translated">는 IF &lt;code&gt;fprof&lt;/code&gt; 의 서버가 실행되지 않고,이 기능은 같은 반환 값을 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cfc64c80cf0754288971ed2f55082185d9efbaf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_event&lt;/code&gt; is to be able to receive other messages than events, the callback function &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_event&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">는 IF &lt;code&gt;gen_event&lt;/code&gt; 이 이벤트가 아닌 다른 메시지를 수신 할 수있게하는 것입니다, 콜백 함수의 &lt;code&gt;handle_info(Info, StateName, StateData)&lt;/code&gt; 이를 처리하기 위해 구현해야합니다. &lt;code&gt;gen_event&lt;/code&gt; 가 다른 프로세스 (감독자보다)에 연결되고 종료 신호를 트래핑하는 경우 다른 메시지의 예는 종료 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="5aad944a4a47c5bc78a9273e949274df0e9ed557" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is not part of a supervision tree, a stop function can be useful, for example:</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 가 감독 트리의 일부가 아닌 경우 중지 기능이 유용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4832a13c9684cb02c06fa828f9150cd6ab481d33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_server&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; 가 감독 트리의 일부인 경우 중지 기능이 필요하지 않습니다. &lt;code&gt;gen_server&lt;/code&gt; 은 자동으로 관리자에 의해 종료됩니다. 정확하게이 작업을 수행하는 방법 은 수퍼바이저에 설정된 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b4cc7e563bc4ab43d392728008910f94dfb10ae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; is to be able to receive other messages than requests, the callback function &lt;code&gt;handle_info(Info, State)&lt;/code&gt; must be implemented to handle them. Examples of other messages are exit messages, if the &lt;code&gt;gen_server&lt;/code&gt; is linked to other processes (than the supervisor) and trapping exit signals.</source>
          <target state="translated">는 IF &lt;code&gt;gen_server&lt;/code&gt; 가 요청 이외의 메시지를 수신 할 수있게하는 것입니다, 콜백 함수의 &lt;code&gt;handle_info(Info, State)&lt;/code&gt; 를 처리하기 위해 구현해야합니다. &lt;code&gt;gen_server&lt;/code&gt; 가 다른 프로세스 (감독자보다)에 연결되고 종료 신호를 트래핑하는 경우 다른 메시지의 예는 종료 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="2f9738619fd7812022c1fdbad1b01a2e041bfacc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason=shutdown&lt;/code&gt; if the following conditions apply:</source>
          <target state="translated">는 IF &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스가 감독 트리의 일부이며, 종료의 감독자의 지시되고,이 함수로 호출 &lt;code&gt;Reason=shutdown&lt;/code&gt; 다음과 같은 조건이 적용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="deb0cd9df07520473713789c264957ed22e0fd37" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process is successfully created and initialized, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the &lt;code&gt;gen_server&lt;/code&gt; process. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">는 IF &lt;code&gt;gen_server&lt;/code&gt; 의 과정이 성공적으로 생성 및 초기화, 함수가 반환 &lt;code&gt;{ok,Pid}&lt;/code&gt; 여기서 &lt;code&gt;Pid&lt;/code&gt; 의 PID를이다 &lt;code&gt;gen_server&lt;/code&gt; 의 과정. 지정된 &lt;code&gt;ServerName&lt;/code&gt; 을 가진 프로세스 가 이미 존재하면 함수는 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 해당 프로세스의 pid입니다.</target>
        </trans-unit>
        <trans-unit id="7b56e5a9d7d5389ddf0dc35b8aa333d9d01bbefc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_server&lt;/code&gt; process needs to perform an action immediately after initialization or to break the execution of a callback into multiple steps, it can return &lt;code&gt;{continue,Continue}&lt;/code&gt; in place of the time-out or hibernation value, which will immediately invoke the &lt;code&gt;handle_continue/2&lt;/code&gt; callback.</source>
          <target state="translated">는 IF &lt;code&gt;gen_server&lt;/code&gt; 의 프로세스가 즉시 초기화 후 또는 여러 단계로 콜백의 실행을 중단하는 작업을 수행 할 필요가, 그것을 반환 할 수 있습니다 &lt;code&gt;{continue,Continue}&lt;/code&gt; 하는 것입니다 즉시 호출 시간 제한 또는 최대 절전 모드 값 대신에 &lt;code&gt;handle_continue/2&lt;/code&gt; 콜백 2 개</target>
        </trans-unit>
        <trans-unit id="490e75ed674d410c271a45a56872f3c49ab0b58b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is not part of a supervision tree, it can be stopped using &lt;code&gt;gen_statem:stop&lt;/code&gt;, preferably through an API function:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 이 감독 트리의 일부가 아닌 경우 &lt;code&gt;gen_statem:stop&lt;/code&gt; 을 사용하여 , 바람직하게는 API 함수를 통해 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36f4edf0379e907c933af357c419f98ac2861c66" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with &lt;code&gt;Reason = shutdown&lt;/code&gt; if both the following conditions apply:</source>
          <target state="translated">는 IF &lt;code&gt;gen_statem&lt;/code&gt; 이 감독 트리의 일부이며, 종료의 감독자의 지시되고,이 함수로 호출 &lt;code&gt;Reason = shutdown&lt;/code&gt; 다음 조건 모두에 적용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="ac199e9236c5ed4f285d3986ed2287bb9a4c55ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is part of a supervision tree, no stop function is needed. The &lt;code&gt;gen_statem&lt;/code&gt; is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; 이 감독 트리의 일부인 경우 중지 기능이 필요하지 않습니다. &lt;code&gt;gen_statem&lt;/code&gt; 은 자동으로 관리자에 의해 종료됩니다. 정확하게이 작업을 수행하는 방법 은 수퍼바이저에 설정된 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="622dc023e6ca738739a4198b61e3fabf701c009b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; is successfully created and initialized, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of the &lt;code&gt;gen_statem&lt;/code&gt;. If a process with the specified &lt;code&gt;ServerName&lt;/code&gt; exists already, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the &lt;code&gt;pid()&lt;/code&gt; of that process.</source>
          <target state="translated">경우 &lt;code&gt;gen_statem&lt;/code&gt; 가 성공적으로 생성 및 초기화,이 함수가 반환 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{ok,Pid}&lt;/a&gt;&lt;/code&gt; 여기서 &lt;code&gt;Pid&lt;/code&gt; 이다 &lt;code&gt;pid()&lt;/code&gt; 의 &lt;code&gt;gen_statem&lt;/code&gt; . 지정된 &lt;code&gt;ServerName&lt;/code&gt; 을 가진 프로세스 가 이미 존재하면이 함수는 &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,{already_started,Pid}}&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 해당 프로세스 의 &lt;code&gt;pid()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6640f29cc42fa72e56c964d772278b2e50af15d6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, the &lt;strong&gt;state enter call&lt;/strong&gt; is repeated, see type &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt;, other than that &lt;code&gt;repeat_state&lt;/code&gt; is the same as &lt;code&gt;keep_state&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;gen_statem&lt;/code&gt; 의 와 실행 &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; 의 &lt;strong&gt;상태가 호출 입력&lt;/strong&gt; 을 참조 반복 유형 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; 이외, &lt;code&gt;repeat_state&lt;/code&gt; 하는 것은 동일하다 &lt;code&gt;keep_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d4b7b9947ceb2e1f75b847cb2c2cefc610ce87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inform request behaviour&lt;/code&gt; configuration option is set to &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;{user, integer()}&lt;/code&gt;, the response (acknowledgment) to this inform-request will be sent when this function returns.</source>
          <target state="translated">경우] &lt;code&gt;inform request behaviour&lt;/code&gt; 설정 옵션이 설정되어 &lt;code&gt;user&lt;/code&gt; 또는 &lt;code&gt;{user, integer()}&lt;/code&gt; 이 통보 요청에 대한 응답 (확인 응답)이 때 함수 리턴 전송한다.</target>
        </trans-unit>
        <trans-unit id="f12a4aa7db27654fb06f0356ee419770a3c5990d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;main/1&lt;/code&gt; function in the script returns successfully, the exit status for the script is &lt;code&gt;0&lt;/code&gt;. If an exception is generated during execution, a short message is printed and the script terminates with exit status &lt;code&gt;127&lt;/code&gt;.</source>
          <target state="translated">스크립트 의 &lt;code&gt;main/1&lt;/code&gt; 함수가 성공적으로 리턴되면 스크립트의 종료 상태는 &lt;code&gt;0&lt;/code&gt; 입니다. 실행 중에 예외가 발생하면 짧은 메시지가 인쇄되고 스크립트는 종료 상태 &lt;code&gt;127&lt;/code&gt; 로 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="6df86c1718762f44b04c0cb308484d1d6c310a34" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;max_sessions&lt;/code&gt; option is set to &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;parallel_login&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the maximum number of simultaneous login attempts at any time is limited to &lt;code&gt;N-K&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; is the number of authenticated connections present at this daemon.</source>
          <target state="translated">는 IF &lt;code&gt;max_sessions&lt;/code&gt; 의 옵션이 설정되어 &lt;code&gt;N&lt;/code&gt; 과 &lt;code&gt;parallel_login&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , 언제든지 동시 로그인 시도의 최대 수는 제한됩니다 &lt;code&gt;N-K&lt;/code&gt; , &lt;code&gt;K&lt;/code&gt; 는 이 데몬에서 현재 인증 된 연결의 수입니다.</target>
        </trans-unit>
        <trans-unit id="279c740df4997832935268858ff97ba56a5fb972" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;parse_transform&lt;/code&gt; is not applied to a module that calls this pseudo function, the call fails in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The &lt;code&gt;ets&lt;/code&gt; module exports a function with this name, but it is never to be called except when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including header file &lt;code&gt;ms_transform.hrl&lt;/code&gt;, compiled code never calls the function, but the function call is replaced by a literal match specification.</source>
          <target state="translated">경우] &lt;code&gt;parse_transform&lt;/code&gt; 은 이 의사 함수를 호출하는 모듈에 적용되지 않고, 호출은 (a와 런타임 실패 &lt;code&gt;badarg&lt;/code&gt; ). &lt;code&gt;ets&lt;/code&gt; 모듈은이 이름을 가진 함수를 수출하지만 쉘의 기능을 사용하는 경우를 제외하고 호출 할 수 결코. 경우 &lt;code&gt;parse_transform&lt;/code&gt; 가 제대로 헤더 파일을 포함하여 적용 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 을 , 컴파일 된 코드는 함수를 호출하지 않지만 함수 호출은 문자 그대로 일치 사양으로 대체됩니다 않았다.</target>
        </trans-unit>
        <trans-unit id="91c8b62af5511bc181fbe7c0815f7318805644f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;per_cpu&lt;/code&gt; is not given, the value(s) presented are the average of all CPUs.</source>
          <target state="translated">경우 &lt;code&gt;per_cpu&lt;/code&gt; 가 주어지지 제시 값 (들) 모든 CPU의 평균입니다.</target>
        </trans-unit>
        <trans-unit id="2c4b5f09b562c0e8df5ab61a0939a3cca6eab6e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;qlc&lt;/code&gt; module at compile time can determine that some constant is free of integers, it does not matter which one of &lt;code&gt;==/2&lt;/code&gt; or &lt;code&gt;=:=/2&lt;/code&gt; is used:</source>
          <target state="translated">컴파일시 &lt;code&gt;qlc&lt;/code&gt; 모듈이 일부 상수에 정수가없는 것으로 판별 할 수 있으면 &lt;code&gt;==/2&lt;/code&gt; 또는 &lt;code&gt;=:=/2&lt;/code&gt; 중 어느 것이 사용되는지는 중요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9ebaa062ac28936382e2d57abb7b4e12d177d78c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It is only to contain low-level instructions.</source>
          <target state="translated">는 IF &lt;code&gt;relup&lt;/code&gt; 의 파일이 비교적 간단, 수동으로 만들 수 있습니다. 저수준 명령어 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="345d6310f85895e6842a34eabfe92151229e6b95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;relup&lt;/code&gt; file is relatively simple, it can be created manually. It it only to contain low-level instructions.</source>
          <target state="translated">는 IF &lt;code&gt;relup&lt;/code&gt; 의 파일이 비교적 간단, 수동으로 만들 수 있습니다. 저수준 명령 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c30c579f26aae9f62a722f68b38557366dc19832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;restart_new_emulator&lt;/code&gt; 의 명령은 스크립트에서 발견된다 &lt;code&gt;&lt;a href=&quot;#eval_appup_script-4&quot;&gt;eval_appup_script/4&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; . 이는 &lt;code&gt;restart_new_emulator&lt;/code&gt; 에서 나머지 업그레이드 명령을 실행하기 전에 새 버전의 에뮬레이터를 시작해야하기 때문에 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3734548d24c8fafceb3c3b7a48423c44c0a982c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;restart_new_emulator&lt;/code&gt; instruction is found in the script, &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt;. This because &lt;code&gt;restart_new_emulator&lt;/code&gt; requires a new version of the emulator to be started before the rest of the upgrade instructions can be executed, and this can only be done by &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;restart_new_emulator&lt;/code&gt; 의 명령은 스크립트에서 발견된다 &lt;code&gt;&lt;a href=&quot;#upgrade_app-2&quot;&gt;upgrade_app/2&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;{error,restart_new_emulator}&lt;/code&gt; . 이는 &lt;code&gt;restart_new_emulator&lt;/code&gt; 에서 나머지 업그레이드 명령을 실행하기 전에 새 버전의 에뮬레이터를 시작해야하기 때문에 &lt;code&gt;&lt;a href=&quot;#install_release-1&quot;&gt;install_release/1,2&lt;/a&gt;&lt;/code&gt; 만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52741bb5942e459f72dab152ca12b8b26eff70c9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/3,4&lt;/code&gt; function is used, all management targets are selected, as defined in RFC2273. The &lt;code&gt;Receiver&lt;/code&gt; parameter defines where the agent should send information about the delivery of inform requests.</source>
          <target state="translated">경우] &lt;code&gt;send_notification/3,4&lt;/code&gt; - 기능을 사용하는 RFC2273에 정의 된 것처럼, 모든 관리 대상이 선택된다. &lt;code&gt;Receiver&lt;/code&gt; 에이전트의 전달에 대한 정보를 전송해야 매개 변수의 정의는 요청을 알립니다.</target>
        </trans-unit>
        <trans-unit id="4e603d462637bea7ebad3ed1b02ae3e6befcd5e2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;send_notification/5&lt;/code&gt; function is used, an &lt;code&gt;NotifyName&lt;/code&gt; must be provided. This parameter is used as an index in the &lt;code&gt;snmpNotifyTable&lt;/code&gt;, and the management targets defined by that single entry is used.</source>
          <target state="translated">경우] &lt;code&gt;send_notification/5&lt;/code&gt; 기능을 사용, &lt;code&gt;NotifyName&lt;/code&gt; 가 제공되어야한다. 이 매개 변수는 &lt;code&gt;snmpNotifyTable&lt;/code&gt; 에서 색인으로 사용 되며 해당 단일 항목으로 정의 된 관리 대상이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dde37de921a26a59041af8e4c9013eabdc7311af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system_logger&lt;/code&gt; process dies, this flag will be reset to &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;system_logger&lt;/code&gt; 의 프로세스가 죽으면,이 플래그를 재설정됩니다 &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13bd2cdf7f65d1258410067e1dbfa02e06ec92b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt;, enable it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path\to\pgm&amp;gt;\wxMSW-3.0.3\include\wx\msw\setup.h&lt;/code&gt; 에서 &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; 가 활성화되어 있지 않으면 활성화 하십시오.</target>
        </trans-unit>
        <trans-unit id="d160ec14cdba130b3a52eed8160428fd608a596b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; isn't enabled in &lt;code&gt;c:/opt/local64/pgm/wxWidgets-3.1.3/include/wx/msw/setup.h&lt;/code&gt;, enable it.</source>
          <target state="translated">&lt;code&gt;wxUSE_POSTSCRIPT&lt;/code&gt; 가 &lt;code&gt;c:/opt/local64/pgm/wxWidgets-3.1.3/include/wx/msw/setup.h&lt;/code&gt; 에서 활성화 되지 않은 경우 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="99871da2f295c0790df21d324a78c1b82d11e8b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;{extra_files, ExtraFiles}&lt;/code&gt; option is given then the &lt;code&gt;ExtraFiles&lt;/code&gt; are added to the tarball after everything else to be included has been added. The &lt;code&gt;ExtraFiles&lt;/code&gt; list is a list of files or directories in the same format as the &lt;code&gt;add_type()&lt;/code&gt; tuple for &lt;code&gt;erl_tar:add/3,4&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;code&gt;{extra_files, ExtraFiles}&lt;/code&gt; 옵션이 다음 주어진 &lt;code&gt;ExtraFiles&lt;/code&gt; 은 다른 모든 것을 포함 할 추가 한 후 타르에 추가됩니다. &lt;code&gt;ExtraFiles&lt;/code&gt; 의 목록은 같은 형식의 파일이나 디렉토리의 목록입니다 &lt;code&gt;add_type()&lt;/code&gt; 에 대한 튜플 &lt;code&gt;erl_tar:add/3,4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="275e62491f49fb1a70d7127de6210ff8d9a19127" translate="yes" xml:space="preserve">
          <source>If the ASN.1 module has been compiled with option &lt;code&gt;maps&lt;/code&gt;, the types &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; are represented as maps.</source>
          <target state="translated">ASN.1 모듈이 옵션 &lt;code&gt;maps&lt;/code&gt; 으로 컴파일 된 경우 &lt;code&gt;SEQUENCE&lt;/code&gt; 및 &lt;code&gt;SET&lt;/code&gt; 유형 이 맵으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="722c5c772253cfa0375f5705288b0321c521aa8d" translate="yes" xml:space="preserve">
          <source>If the AckStatus is ok, it is indicating that this is a true acknowledgement of the transaction reply.</source>
          <target state="translated">AckStatus가 정상이면 이것이 트랜잭션 응답에 대한 진정한 승인임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d0f84b01e010783659e66100fe954814d18e563f" translate="yes" xml:space="preserve">
          <source>If the AckStatus is {error, Reason}, it is an indication that the acknowledgement or even the reply (for which this is an acknowledgement) was not delivered, but there is no point in waiting any longer for it to arrive. This happens when:</source>
          <target state="translated">AckStatus가 {error, Reason} 인 경우, 승인 또는 응답 (이것이 승인 인 경우)이 전달되지 않았 음을 나타내지 만 더 이상 도착하기를 기다리는 시점은 없습니다. 다음과 같은 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88faac2c33abe1fdc3fc1b10f5136c262bb64e7a" translate="yes" xml:space="preserve">
          <source>If the BEAM file contains &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt;, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">BEAM 파일에 &lt;code&gt;&lt;a href=&quot;#debug_info&quot;&gt;debug information&lt;/a&gt;&lt;/code&gt; 가 포함 된 경우 튜플 목록이 반환됩니다. 각 튜플의 첫 번째 요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="52ebbcd03e14972b092b8f0cc1bbe4c3dd868b59" translate="yes" xml:space="preserve">
          <source>If the BEAM file does not contain debug information, then a list of tuples is returned. The first element of each tuple is one of:</source>
          <target state="translated">BEAM 파일에 디버그 정보가 없으면 튜플 목록이 반환됩니다. 각 튜플의 첫 번째 요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="5e318cbbe5a1c0ec48c8b2b2021ac1f10131570e" translate="yes" xml:space="preserve">
          <source>If the C node acts as a server, it must first create a socket (call &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt;) listening to a certain port number &lt;code&gt;port&lt;/code&gt;. It then publishes its name and port number with &lt;code&gt;epmd&lt;/code&gt;, the Erlang port mapper daemon. For details, see the &lt;code&gt;epmd&lt;/code&gt; manual page in ERTS:</source>
          <target state="translated">C 노드가 서버 역할을하는 경우 먼저 특정 포트 번호 &lt;code&gt;port&lt;/code&gt; 를 &lt;code&gt;listen()&lt;/code&gt; 하는 소켓 (call &lt;code&gt;bind()&lt;/code&gt; 및 listen () )을 작성해야합니다 . 그런 다음 Erlang 포트 매퍼 데몬 인 &lt;code&gt;epmd&lt;/code&gt; 를 사용 하여 이름과 포트 번호를 게시합니다 . 자세한 내용 은 ERTS 의 &lt;code&gt;epmd&lt;/code&gt; 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82d38ec527a550307461604062c03b211a833f6c" translate="yes" xml:space="preserve">
          <source>If the COND1 pattern matches, FOO is tried (and possibly further items after the end of the group if FOO succeeds). On failure, the matcher skips to the second alternative and tries COND2, without backtracking into COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails, there are no more alternatives, so there is a backtrack to whatever came before the entire group. If (*THEN) is not inside an alternation, it acts like (*PRUNE).</source>
          <target state="translated">COND1 패턴이 일치하면 FOO가 시도됩니다 (FOO가 성공하면 그룹이 끝난 후 추가 항목이 가능함). 실패시, 매처는 두 번째 대안으로 건너 뛰고 COND1로 역 추적하지 않고 COND2를 시도합니다. 성공하고 BAR이 실패하면 COND3이 시도됩니다. BAZ가 실패하면 더 이상 대안이 없으므로 전체 그룹 이전에 발생한 내용에 대한 역 추적이 있습니다. (* THEN)이 대체 내부가 아닌 경우 (* PRUNE)처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ac5eaef6ff1820888de0ffa5ad9b4186d0234433" translate="yes" xml:space="preserve">
          <source>If the CPU information has changed since the last time it was read, the atom &lt;code&gt;changed&lt;/code&gt; is returned, otherwise the atom &lt;code&gt;unchanged&lt;/code&gt;. If the CPU information has changed, you probably want to &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt;. You typically want to have as many schedulers online as &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정보는 CPU가 판독 된 마지막 시간 이후로 변경된 경우, 원자 &lt;code&gt;changed&lt;/code&gt; 달리 원자 반환 &lt;code&gt;unchanged&lt;/code&gt; . CPU 정보가 변경된 경우 &lt;code&gt;&lt;a href=&quot;#system_flag_schedulers_online&quot;&gt;adjust the number of schedulers online&lt;/a&gt;&lt;/code&gt; 를 조정 하려고합니다 . 일반적으로 &lt;code&gt;&lt;a href=&quot;#system_info_logical_processors_available&quot;&gt;logical processors available&lt;/a&gt;&lt;/code&gt; 만큼 많은 스케줄러를 온라인 상태로 유지하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="a41da23020d6b98e8307d0411d62373331fcee35" translate="yes" xml:space="preserve">
          <source>If the CertificateRequest message contained a non-empty &quot;oid_filters&quot; extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client</source>
          <target state="translated">CertificateRequest 메시지에 비어 있지 않은 &quot;oid_filters&quot;확장이 포함 된 경우 최종 엔티티 인증서는 클라이언트가 인식하는 확장 OID와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="674a0c6bf29cc8c8f0b253946e997318f6046675" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the group database is maintained by Dets and must not be edited by hand. Use the API for module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the group database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that the &lt;code&gt;auth_group_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">Dets 저장 방법을 사용하는 경우 그룹 데이터베이스는 Dets에서 유지 관리하며 직접 편집해서는 안됩니다. &lt;code&gt;mod_auth&lt;/code&gt; 모듈의 API를 사용하여 그룹 데이터베이스를 작성 / 편집하십시오. Mnesia 저장 방법을 사용하는 경우이 지시문은 무시됩니다. 보안상의 이유로 &lt;code&gt;auth_group_file&lt;/code&gt; 이 웹 서버의 문서 트리 외부에 저장되어 있는지 확인하십시오 . 보호되는 디렉토리에 있으면 클라이언트가 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2690e1607b444fbdfb4354a7fc5e69fab4fc5a65" translate="yes" xml:space="preserve">
          <source>If the Dets storage method is used, the user database is maintained by Dets and must not be edited by hand. Use the API functions in module &lt;code&gt;mod_auth&lt;/code&gt; to create/edit the user database. This directive is ignored if the Mnesia storage method is used. For security reasons, ensure that &lt;code&gt;auth_user_file&lt;/code&gt; is stored outside the document tree of the web server. If it is placed in the directory that it protects, clients can download it.</source>
          <target state="translated">Dets 저장 방법을 사용하는 경우 사용자 데이터베이스는 Dets에 의해 유지 관리되며 직접 편집해서는 안됩니다. &lt;code&gt;mod_auth&lt;/code&gt; 모듈의 API 함수를 사용하여 사용자 데이터베이스를 작성 / 편집하십시오. Mnesia 저장 방법을 사용하는 경우이 지시문은 무시됩니다. 보안상의 이유로 &lt;code&gt;auth_user_file&lt;/code&gt; 이 웹 서버의 문서 트리 외부에 저장되어 있는지 확인 하십시오. 보호되는 디렉토리에 있으면 클라이언트가 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d6f0952016312ac237e99b15d9161adf55f700d" translate="yes" xml:space="preserve">
          <source>If the Erlang node was alive, that is, set up for communicating with other nodes, this section lists the connections that were active. The following fields can exist:</source>
          <target state="translated">Erlang 노드가 활성 상태 인 경우, 즉 다른 노드와 통신하도록 설정된 경우이 섹션에는 활성 상태 인 연결이 나열됩니다. 다음과 같은 필드가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18daf2db870215dd47d6849bc420623f1e0d4030" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only OS process binding threads to logical processors, this improves the performance of the runtime system. However, if other OS processes (for example, another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. Sometimes this performance penalty can be severe. If so, it is recommended to not bind the schedulers.</source>
          <target state="translated">Erlang 런타임 시스템이 논리 프로세서에 스레드를 바인딩하는 유일한 OS 프로세스 인 경우 런타임 시스템의 성능이 향상됩니다. 그러나 다른 OS 프로세스 (예 : 다른 Erlang 런타임 시스템)도 스레드를 논리 프로세서에 바인드하면 대신 성능이 저하 될 수 있습니다. 때때로이 성능 저하가 심각 할 수 있습니다. 그렇다면 스케줄러를 바인드하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3549c6b8d3c0426e098c164e7bd7160b6e4be362" translate="yes" xml:space="preserve">
          <source>If the Erlang runtime system is the only operating system process that binds threads to logical processors, this improves the performance of the runtime system. However, if other operating system processes (for example another Erlang runtime system) also bind threads to logical processors, there can be a performance penalty instead. This performance penalty can sometimes be severe. If so, you are advised not to bind the schedulers.</source>
          <target state="translated">Erlang 런타임 시스템이 스레드를 논리 프로세서에 바인드하는 유일한 운영 체제 프로세스 인 경우 런타임 시스템의 성능이 향상됩니다. 그러나 다른 운영 체제 프로세스 (예 : 다른 Erlang 런타임 시스템)도 스레드를 논리 프로세서에 바인드하면 성능이 저하 될 수 있습니다. 이 성능 저하는 때때로 심각 할 수 있습니다. 그렇다면 스케줄러를 바인드하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="78b8e3a5a6a0636736a794de9e5a1415d4c36fbf" translate="yes" xml:space="preserve">
          <source>If the Erlang shell buffer would be killed the command line history is saved to a file. The command line history is automatically retrieved when a new Erlang shell is started.</source>
          <target state="translated">Erlang 쉘 버퍼가 종료되면 명령 행 히스토리가 파일에 저장됩니다. 새 Erlang 쉘이 시작되면 명령 행 히스토리가 자동으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad331d93d63bf83b44ef888cb4e43e94ea364bb" translate="yes" xml:space="preserve">
          <source>If the INDEX column is of type INTEGER, or derived from INTEGER, the corresponding type should be &lt;code&gt;integer&lt;/code&gt;. If it is a variable length type (e.g. OBJECT IDENTIFIER, OCTET STRING), the corresponding type should be &lt;code&gt;string&lt;/code&gt;. Finally, if the type is of variable length, but with a fixed size restriction (e.g. IpAddress), the corresponding type should be &lt;code&gt;fix_string&lt;/code&gt;.</source>
          <target state="translated">INDEX 컬럼이 INTEGER 유형이거나 INTEGER에서 파생 된 경우 해당 유형은 &lt;code&gt;integer&lt;/code&gt; 이어야합니다 . 가변 길이 유형 인 경우 (예 : OBJECT IDENTIFIER, OCTET STRING) 해당 유형은 &lt;code&gt;string&lt;/code&gt; 이어야 합니다 . 마지막으로, 유형이 가변 길이이지만 고정 크기 제한 (예 : IpAddress)이있는 경우 해당 유형은 &lt;code&gt;fix_string&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="27815f723f23d4e4cf3d912f3476eb64c838477e" translate="yes" xml:space="preserve">
          <source>If the MG cannot be provisioned with the MID of the MGC, the MG can use the atom 'preliminary_mid' as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">MGC의 MID로 MG를 프로비저닝 할 수없는 경우 MG는 원자 'preliminary_mid'를 RemoteMid 매개 변수로 megaco : connect / 4에 사용할 수 있으며 호출 플로우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="291d17d4be116cb44759c41864d170474773407f" translate="yes" xml:space="preserve">
          <source>If the MG has been provisioned with the MID of the MGC it can be given as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</source>
          <target state="translated">MGC의 MID로 MG가 프로비저닝 된 경우 megaco : connect / 4에 RemoteMid 매개 변수로 제공 될 수 있으며 호출 플로우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d3ec8b1bad21c29a9fcf6552b6d84ffcf7600b8" translate="yes" xml:space="preserve">
          <source>If the Mnesia database is used, this function calls &lt;code&gt;mnesia:write&lt;/code&gt; to store the values. This means that this function must be called from within a transaction (&lt;code&gt;mnesia:transaction/1&lt;/code&gt; or &lt;code&gt;mnesia:dirty/1&lt;/code&gt;).</source>
          <target state="translated">Mnesia 데이터베이스를 사용하는 경우이 함수는 &lt;code&gt;mnesia:write&lt;/code&gt; 를 호출 하여 값을 저장합니다. 이것은이 함수가 트랜잭션 내에서 호출되어야 함을 의미합니다 ( &lt;code&gt;mnesia:transaction/1&lt;/code&gt; 또는 &lt;code&gt;mnesia:dirty/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="40a56f15bd541bd82f926eed2c112eaac90f9e71" translate="yes" xml:space="preserve">
          <source>If the NIF call is too lengthy, this must be handled in one of the following ways to avoid degraded responsiveness, scheduler load balancing problems, and other strange behaviors:</source>
          <target state="translated">NIF 호출이 너무 길면 응답 속도 저하, 스케줄러로드 밸런싱 문제 및 기타 이상한 동작을 피하기 위해 다음 방법 중 하나로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="436a83604c57a3e3475d1d2d6359ca37e137b110" translate="yes" xml:space="preserve">
          <source>If the OBJECT IDENTIFIER is longer than an OBJECT IDENTIFIER of an object type in the MIB, it refers to object instances. Because of this, it is possible to control whether or not particular rows in a table shall be visible.</source>
          <target state="translated">OBJECT IDENTIFIER가 MIB에서 오브젝트 유형의 OBJECT IDENTIFIER보다 길면 오브젝트 인스턴스를 참조합니다. 이 때문에 테이블의 특정 행을 표시할지 여부를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b26d2a72fe7f32dcd9c24e2f00608157279f71" translate="yes" xml:space="preserve">
          <source>If the OS used does not support non-blocking &lt;code&gt;sendfile&lt;/code&gt;, an Erlang fallback using &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">사용 된 OS가 비 차단 &lt;code&gt;sendfile&lt;/code&gt; 을 지원하지 않으면 &lt;code&gt;&lt;a href=&quot;#read-2&quot;&gt;read/2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;gen_tcp#send-2&quot;&gt;gen_tcp:send/2&lt;/a&gt;&lt;/code&gt; 를 사용 하는 Erlang 폴 백이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="b3598222fc1bb53b9989c1f5e6bfd02eed50487d" translate="yes" xml:space="preserve">
          <source>If the SNMP agent needs to interact with sub-agents constructed in another package, a special sub-agent should be used, which communicates through a protocol specified by the other package.</source>
          <target state="translated">SNMP 에이전트가 다른 패키지에 구성된 하위 에이전트와 상호 작용해야하는 경우 다른 하위 패키지에서 지정한 프로토콜을 통해 통신하는 특수 하위 에이전트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c500f599c51107a79c77a136f03f46d05fafc58" translate="yes" xml:space="preserve">
          <source>If the SNMP table has more than one INDEX column, the corresponding Mnesia row is a tuple, where the first element is a tuple with the INDEX columns. Generally, if the SNMP table has &lt;strong&gt;N&lt;/strong&gt; INDEX columns and &lt;strong&gt;C&lt;/strong&gt; data columns, the Mnesia table is of arity &lt;strong&gt;(C-N)+1&lt;/strong&gt;, where the key is a tuple of arity &lt;strong&gt;N&lt;/strong&gt; if &lt;strong&gt;N &amp;gt; 1&lt;/strong&gt;, or a single term if &lt;strong&gt;N = 1&lt;/strong&gt;.</source>
          <target state="translated">SNMP 테이블에 둘 이상의 INDEX 열이있는 경우 해당 Mnesia 행은 튜플이며 첫 번째 요소는 INDEX 열이있는 튜플입니다. 일반적으로 SNMP 테이블에 &lt;strong&gt;N&lt;/strong&gt; INDEX 열과 &lt;strong&gt;C&lt;/strong&gt; 데이터 열이있는 경우 Mnesia 테이블은 arity &lt;strong&gt;(CN) +1&lt;/strong&gt; 이며, 여기서 키는 &lt;strong&gt;N&amp;gt; 1&lt;/strong&gt; 이면 arity &lt;strong&gt;N&lt;/strong&gt; 튜플 이거나 &lt;strong&gt;N = 1&lt;/strong&gt; 이면 단일 &lt;strong&gt;항&lt;/strong&gt; 입니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c217a2396ebcee146469f461600abdf337e010c" translate="yes" xml:space="preserve">
          <source>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it ignores the new request if the request is equal to the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server consumes less resources.</source>
          <target state="translated">TFTP 서버가 클라이언트에 이미 연결되어있는 동안 동일한 클라이언트 (같은 호스트 및 포트)로부터 또 다른 요청을받는 경우 요청이 첫 번째 요청 (동일한 파일 이름 및 옵션)과 동일한 경우 새 요청을 무시합니다. 이것은 (새로운) 클라이언트가 서버 측에서 이미 진행중인 연결에 의해 서비스 될 것임을 의미합니다. 다른 연결을 설정하지 않으면 진행중인 연결과 병행하여 서버가 더 적은 리소스를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="89cbc4f7538c3f8a055eafb734ab8d43e17f7e9a" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is in effect, the integer argument can be any number representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to 255, otherwise it is masked with 16#FF:</source>
          <target state="translated">유니 코드 변환 수정 자 ( &lt;code&gt;t&lt;/code&gt; )가 유효한 경우 정수 인수는 유효한 유니 코드 코드 포인트를 나타내는 임의의 숫자 일 수 있습니다. 그렇지 않으면 255 이하의 정수 여야합니다. 그렇지 않으면 16 # FF로 마스킹됩니다.</target>
        </trans-unit>
        <trans-unit id="cc5c86359b9d2f999369876543233d4ea822c7b0" translate="yes" xml:space="preserve">
          <source>If the Unicode translation modifier (&lt;code&gt;t&lt;/code&gt;) is used in the format string, all event handlers must ensure that the formatted output is correctly encoded for the I/O device.</source>
          <target state="translated">유니 코드 변환 수정 자 ( &lt;code&gt;t&lt;/code&gt; )가 형식 문자열에 사용되면 모든 이벤트 핸들러는 형식화 된 출력이 I / O 장치에 대해 올바르게 인코딩되었는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a64305e88f74d03f63e30e4aff9344ad3928f49" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function clause:</source>
          <target state="translated">절 레벨에서 분석이 수행되면 결과는 튜플 &lt;code&gt;{Clause,Calls}&lt;/code&gt; 목록으로 제공됩니다 . 여기에서 &lt;code&gt;Calls&lt;/code&gt; 은 각 함수 절에 대한 호출 수입니다.</target>
        </trans-unit>
        <trans-unit id="7bb518d0fd97d3152a60a637270e37af04b13222" translate="yes" xml:space="preserve">
          <source>If the analysis is made on clause level, the result is given as a list of tuples &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt;, one for each function clause in the module. A clause is specified by its module name, function name, arity and position within the function definition:</source>
          <target state="translated">절 레벨에서 분석을 수행하면 결과는 모듈의 각 함수 절에 대해 하나씩 튜플 &lt;code&gt;{Clause,{Cov,NotCov}}&lt;/code&gt; 목록으로 제공됩니다 . 절은 함수 정의 내에서 모듈 이름, 함수 이름, 특성 및 위치로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2478a8c8617596c655cc3da82b5c379b47e51b09" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the number of calls to each function:</source>
          <target state="translated">함수 레벨에서 분석을 수행하면 결과는 튜플 &lt;code&gt;{Function,Calls}&lt;/code&gt; 목록으로 제공됩니다 . 여기에서 &lt;code&gt;Calls&lt;/code&gt; 은 각 기능에 대한 호출 수입니다.</target>
        </trans-unit>
        <trans-unit id="55b7df1c13246cf49b1f19e127c65003b3a10d37" translate="yes" xml:space="preserve">
          <source>If the analysis is made on function level, the result is given as a list of tuples &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt;, one for each function in the module. A function is specified by its module name, function name and arity:</source>
          <target state="translated">함수 레벨에서 분석이 수행되면 결과는 모듈의 각 함수마다 하나씩 튜플 &lt;code&gt;{Function,{Cov,NotCov}}&lt;/code&gt; 목록으로 제공됩니다 . 함수는 모듈 이름, 함수 이름 및 arity로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="77e592dc92d7ea0f9403bfb4d1e1860bc8a3fe5a" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given as a tuple &lt;code&gt;{Module,Calls}&lt;/code&gt;. Here &lt;code&gt;Calls&lt;/code&gt; is the total number of calls to functions in the module:</source>
          <target state="translated">모듈 레벨에서 분석을 수행하면 결과는 튜플 &lt;code&gt;{Module,Calls}&lt;/code&gt; 로 제공 됩니다. 여기에서 &lt;code&gt;Calls&lt;/code&gt; 은 모듈의 함수에 대한 총 호출 수입니다.</target>
        </trans-unit>
        <trans-unit id="5cba27c146502c3ec8e1044a59eca78a126f8832" translate="yes" xml:space="preserve">
          <source>If the analysis is made on module level, the result is given for the entire module as a tuple &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt;:</source>
          <target state="translated">모듈 레벨에서 분석을 수행하면 전체 모듈에 대한 결과가 튜플 &lt;code&gt;{Module,{Cov,NotCov}}&lt;/code&gt; 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b39d0ccaa857b9f0a8f4a5ffffbdf43a68463d85" translate="yes" xml:space="preserve">
          <source>If the application SSH &lt;strong&gt;is&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt;, the command &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; delvers the list of algorithms after application of level 0 and level 1 configurations.</source>
          <target state="translated">애플리케이션 SSH &lt;strong&gt;가 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt; 되면 &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 명령 은 레벨 0 및 레벨 1 구성을 적용한 후 알고리즘 목록을 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="e53045943992891c562424981e5024fb26dfffc6" translate="yes" xml:space="preserve">
          <source>If the application SSH is &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt;, the command &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; delivers the list of default (hardcoded) algorithms with respect to the support in the current cryptolib.</source>
          <target state="translated">애플리케이션 SSH가 &lt;code&gt;&lt;a href=&quot;ssh#start-0&quot;&gt;started&lt;/a&gt;&lt;/code&gt; &lt;strong&gt; 되지 않은&lt;/strong&gt; 경우 &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; 명령 은 현재 cryptolib의 지원과 관련된 기본 (하드 코딩 된) 알고리즘 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cde9769f09668ea79529ce6edefab85a0899d6da" translate="yes" xml:space="preserve">
          <source>If the application detects a communication failure (in a potentially partitioned network) that can have caused an inconsistent database, it can use the function &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; to define from which nodes each table is to be loaded. At startup, the Mnesia normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of when and if Mnesia terminated on other nodes. &lt;code&gt;MasterNodes&lt;/code&gt; can only contain nodes where the table has a replica. If the &lt;code&gt;MasterNodes&lt;/code&gt; list is empty, the master node recovery mechanism for the particular table is reset, and the normal load mechanism is used at the next restart.</source>
          <target state="translated">응용 프로그램이 불일치 한 데이터베이스를 야기 할 수있는 통신 실패 (잠재적으로 파티션 된 네트워크에서)를 감지하면 &lt;code&gt;mnesia:set_master_nodes(Tab, MasterNodes)&lt;/code&gt; 함수를 사용하여 각 테이블을로드 할 노드를 정의 할 수 있습니다. 시작시 Mnesia 정상 테이블로드 알고리즘은 무시되고 Mnesia가 다른 노드에서 종료 된시기 및 여부에 관계없이 테이블에 대해 정의 된 마스터 노드 중 하나에서 테이블이로드됩니다. &lt;code&gt;MasterNodes&lt;/code&gt; 노드는 테이블에 복제본이있는 노드 만 포함 할 수 있습니다. 는 IF &lt;code&gt;MasterNodes&lt;/code&gt; 의 목록이 비어, 특정 테이블에 대한 마스터 노드 복구 메커니즘이 재설정되고 정상적인 부하 메커니즘은 다음에 다시 시작할에서 사용된다.</target>
        </trans-unit>
        <trans-unit id="130ab90516f90ac945b3ebb327eb04a5eb66e021" translate="yes" xml:space="preserve">
          <source>If the application detects that there has been a communication failure that can have caused an inconsistent database, it can use the function &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; to pinpoint from which nodes each table can be loaded.</source>
          <target state="translated">응용 프로그램이 불일치 한 데이터베이스를 야기 할 수있는 통신 실패가 있음을 감지하면 &lt;code&gt;&lt;a href=&quot;mnesia#set_master_nodes-2&quot;&gt;mnesia:set_master_nodes(Tab, Nodes)&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 각 테이블을로드 할 수있는 노드를 정확히 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc60992fdf5138ada7ac0487b61ff57acf63af0" translate="yes" xml:space="preserve">
          <source>If the application is distributed, setting the permission to &lt;code&gt;false&lt;/code&gt; means that the application will be started at, or moved to, another node according to how its distribution is configured (see &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">애플리케이션이 분배 된 경우, 권한을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 분배 구성 방법에 따라 애플리케이션이 다른 노드에서 시작되거나 다른 노드로 이동 함을 의미합니다 ( &lt;code&gt;&lt;a href=&quot;#load-2&quot;&gt;load/2&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ff80acb30d9dab81e0a46a50c51388e4dd17f7a3" translate="yes" xml:space="preserve">
          <source>If the application is not already loaded, the application controller first loads it using &lt;code&gt;application:load/1&lt;/code&gt;. It checks the value of the &lt;code&gt;applications&lt;/code&gt; key, to ensure that all applications that are to be started before this application are running.</source>
          <target state="translated">애플리케이션이 아직로드되지 않은 경우 애플리케이션 컨트롤러는 먼저 &lt;code&gt;application:load/1&lt;/code&gt; 을 사용하여로드합니다 . 이 키 는 &lt;code&gt;applications&lt;/code&gt; 키 의 값 을 확인하여이 응용 프로그램이 실행되기 전에 시작될 모든 응용 프로그램을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="04b974d958e0b100d3e2e5b38644fd0a6abff6f9" translate="yes" xml:space="preserve">
          <source>If the application needs to include a generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="translated">애플리케이션이 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 포함 해야하는 경우 Erlang 컴파일러에 &lt;code&gt;-include_lib&lt;/code&gt; 지시문을 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="60e7f4b69d5dbe87fef4344be83c638457c7eec7" translate="yes" xml:space="preserve">
          <source>If the application needs to include the generated &lt;code&gt;.hrl&lt;/code&gt; file, it is to use the &lt;code&gt;-include_lib&lt;/code&gt; directive to the Erlang compiler:</source>
          <target state="translated">응용 프로그램에서 생성 된 &lt;code&gt;.hrl&lt;/code&gt; 파일 을 포함 해야하는 경우 Erlang 컴파일러에 &lt;code&gt;-include_lib&lt;/code&gt; 지시문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="683ef606c81dc1c47b5d3b9c095a4243030bc6f8" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;Func&lt;/code&gt;, the timetrap is triggered when this function returns. &lt;code&gt;Func&lt;/code&gt; can also return a new &lt;code&gt;Time&lt;/code&gt; value, which in that case is the value for the new timetrap.</source>
          <target state="translated">인수가 &lt;code&gt;Func&lt;/code&gt; 인 경우이 함수가 반환 될 때 타임 트랩이 트리거됩니다. 또한 &lt;code&gt;Func&lt;/code&gt; 은 새로운 &lt;code&gt;Time&lt;/code&gt; 값을 반환 할 수 있으며 ,이 경우 새로운 Timetrap의 값입니다.</target>
        </trans-unit>
        <trans-unit id="0044e9d649274cc90388ee08844dd19dea89fffe" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;false&lt;/code&gt;, the call trace message mode for the current process is set to normal (non-silent) for this call and all later calls.</source>
          <target state="translated">인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 현재 프로세스의 통화 추적 메시지 모드는이 통화 및 이후의 모든 통화에 대해 정상 (무음)으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="580f4ef0ac5467ad7d400143bdf178fbf747f519" translate="yes" xml:space="preserve">
          <source>If the argument is invalid</source>
          <target state="translated">인수가 유효하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="c3def1ea3a84c13010f731140dbb829f22745007" translate="yes" xml:space="preserve">
          <source>If the argument is not &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, the call trace message mode is unaffected.</source>
          <target state="translated">인수가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 가 아닌 경우 , 호출 추적 메시지 모드는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="259c1b3a1fe7d6190505c0293c344282223212ec" translate="yes" xml:space="preserve">
          <source>If the arguments or options are malformed, the function throws a &lt;code&gt;badarg&lt;/code&gt; exception.</source>
          <target state="translated">인수 또는 옵션이 잘못된 경우, 함수는 발생 &lt;code&gt;badarg&lt;/code&gt; 의 예외.</target>
        </trans-unit>
        <trans-unit id="6b60aa2a26e0a24944e43c25dc549ab30b52857b" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, and &lt;code&gt;I&lt;/code&gt; is greater than &lt;code&gt;size(Array)-1&lt;/code&gt;, the array grows to size &lt;code&gt;I+1&lt;/code&gt;.</source>
          <target state="translated">배열의 크기가 고정되어 있지 않고 &lt;code&gt;I&lt;/code&gt; 가 &lt;code&gt;size(Array)-1&lt;/code&gt; 보다 크면 배열의 크기가 &lt;code&gt;I+1&lt;/code&gt; 로 커집니다 .</target>
        </trans-unit>
        <trans-unit id="e97eb155a25d26096ef78fc2b67cf5447071cfc9" translate="yes" xml:space="preserve">
          <source>If the array does not have fixed size, the default value for any index &lt;code&gt;I&lt;/code&gt; greater than &lt;code&gt;size(Array)-1&lt;/code&gt; is returned.</source>
          <target state="translated">배열의 크기가 고정되어 있지 않으면 &lt;code&gt;size(Array)-1&lt;/code&gt; 보다 큰 인덱스 &lt;code&gt;I&lt;/code&gt; 의 기본값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5552e65bff8e7b19a94e0b983a0ae9846e97b32b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;len&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">아톰이 이미 존재하면이 함수는 용어를 &lt;code&gt;*atom&lt;/code&gt; 에 저장하고 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . 또한 리턴 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;len&lt;/code&gt; 원자 (255 개 문자)에 허용 된 최대 길이를 초과한다.</target>
        </trans-unit>
        <trans-unit id="0d657f088165dffa1fac0e9bbe37e81e0983227b" translate="yes" xml:space="preserve">
          <source>If the atom already exists, this function stores the term in &lt;code&gt;*atom&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. Also returns &lt;code&gt;false&lt;/code&gt; if the length of &lt;code&gt;name&lt;/code&gt; exceeds the maximum length allowed for an atom (255 characters).</source>
          <target state="translated">아톰이 이미 존재하면이 함수는 용어를 &lt;code&gt;*atom&lt;/code&gt; 에 저장하고 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;name&lt;/code&gt; 의 길이가 원자에 허용 된 최대 길이 (255 자)를 초과하면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a4fe1851aab21eaf10695f8609bb67b63980301" translate="yes" xml:space="preserve">
          <source>If the atomic compare and swap described above failed, the last pointer didn't point to the last element. In this case we need to insert the new element somewhere between the element that the last pointer pointed to and the actual last element. If we do it this way the last pointer will eventually end up at the last element when threads stop adding new elements. When trying to insert somewhere near the end and failing to do so, the inserting thread sometimes moves to the next element and sometimes tries with the same element again. This in order to spread the inserted elements during heavy contention. That is, we try to spread the modifications of memory to different locations instead of letting all threads continue to try to modify the same location in memory.</source>
          <target state="translated">위에서 설명한 원자 비교 및 ​​스왑이 실패하면 마지막 포인터가 마지막 요소를 가리 키지 않습니다. 이 경우 마지막 포인터가 가리키는 요소와 실제 마지막 요소 사이에 새 요소를 삽입해야합니다. 이렇게하면 스레드가 새 요소 추가를 중지 할 때 마지막 포인터가 결국 마지막 요소에서 끝납니다. 끝 근처에 삽입하려고하는데 실패하면 삽입 스레드가 때때로 다음 요소로 이동하고 때로는 동일한 요소로 다시 시도합니다. 이것은 심한 경합 중에 삽입 된 요소를 확산하기위한 것입니다. 즉, 모든 스레드가 메모리에서 동일한 위치를 계속 수정하도록하는 대신 메모리 수정 사항을 다른 위치로 확산 시키려고합니다.</target>
        </trans-unit>
        <trans-unit id="cbc8e0e10b7bf47bd128f48e3648baa81fc6271d" translate="yes" xml:space="preserve">
          <source>If the attempt to truncate the log fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt;. Other processes having requests queued receive the message &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt;.</source>
          <target state="translated">로그 자르기 시도가 실패하면 디스크 로그 프로세스가 종료 메시지 &lt;code&gt;{{failed,Reason},[{disk_log,Fun,Arity}]}&lt;/code&gt; 와 함께 종료됩니다 . 요청이 대기중인 다른 프로세스는 &lt;code&gt;{disk_log, Node, {error, disk_log_stopped}}&lt;/code&gt; 메시지를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="88a48f973bcaa36e009e8c2234922f730ca71334" translate="yes" xml:space="preserve">
          <source>If the binder is not seen, the binder is validated. If the binder is valid, the server proceeds with the 0-RTT handshake.</source>
          <target state="translated">바인더가 보이지 않으면 바인더의 유효성이 확인 된 것입니다. 바인더가 유효하면 서버는 0-RTT 핸드 셰이크를 진행합니다.</target>
        </trans-unit>
        <trans-unit id="d7ec818fc01c7aa387cc6cab61ea5c97ff0c8f49" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt; systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="translated">부트 스크립트에 &lt;code&gt;$ROOT&lt;/code&gt; 이외 의 경로 변수 &lt;code&gt;Var&lt;/code&gt; 이 포함되어 있으면 이 변수는 &lt;code&gt;Dir&lt;/code&gt; 로 확장됩니다 . &lt;code&gt;$ROOT/lib&lt;/code&gt; 아닌 다른 디렉토리에 응용 프로그램을 설치할 때 사용됩니다 . SASL의 &lt;code&gt; systools:make_script/1,2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7576e0423d861bfb48c83bfa3b5b0c281c96ce4" translate="yes" xml:space="preserve">
          <source>If the boot script contains a path variable &lt;code&gt;Var&lt;/code&gt; other than &lt;code&gt;$ROOT&lt;/code&gt;, this variable is expanded to &lt;code&gt;Dir&lt;/code&gt;. Used when applications are installed in another directory than &lt;code&gt;$ROOT/lib&lt;/code&gt;; see &lt;code&gt;systools:make_script/1,2&lt;/code&gt; in SASL.</source>
          <target state="translated">부트 스크립트에 &lt;code&gt;$ROOT&lt;/code&gt; 이외 의 경로 변수 &lt;code&gt;Var&lt;/code&gt; 이 포함 된 경우이 변수는 &lt;code&gt;Dir&lt;/code&gt; 로 확장됩니다 . &lt;code&gt;$ROOT/lib&lt;/code&gt; 이외의 다른 디렉토리에 응용 프로그램을 설치할 때 사용됩니다 . SASL의 &lt;code&gt;systools:make_script/1,2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc4746e92bb60b88599fe7a3e474a68b05603534" translate="yes" xml:space="preserve">
          <source>If the call times out, a &lt;code&gt;timeout&lt;/code&gt; exception is raised.</source>
          <target state="translated">호출 시간이 초과되면 &lt;code&gt;timeout&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55cc2b4bba08ca73afe9b3ccf29541b97304c864" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;erlang:load_nif/2&lt;/code&gt; fails, the module is unloaded and a warning report is sent to the error loader.</source>
          <target state="translated">&lt;code&gt;erlang:load_nif/2&lt;/code&gt; 에 대한 호출이 실패하면 모듈이 언로드되고 경고 보고서가 오류 로더로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="4b48d532db57aebd987ac6820de7ad7436dd64ed" translate="yes" xml:space="preserve">
          <source>If the callback module cannot be loaded, an error tuple is returned. The &lt;code&gt;Reason&lt;/code&gt; in the error tuple is the one returned by the code loader when trying to load the code of the callback module.</source>
          <target state="translated">콜백 모듈을로드 할 수 없으면 오류 튜플이 반환됩니다. 오류 튜플 의 &lt;code&gt;Reason&lt;/code&gt; 는 콜백 모듈의 코드를로드하려고 할 때 코드 로더가 리턴 한 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="8bf050fe2cb79b5d36a88eaed63edd7eed898889" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_get_state/1&lt;/code&gt; function, &lt;code&gt;get_state/1,2&lt;/code&gt; assumes that the &lt;code&gt;Misc&lt;/code&gt; value is the state of the callback module and returns it directly instead.</source>
          <target state="translated">콜백 모듈이 &lt;code&gt;system_get_state/1&lt;/code&gt; 함수를 내 보내지 않으면 &lt;code&gt;get_state/1,2&lt;/code&gt; 는 &lt;code&gt;Misc&lt;/code&gt; 값이 콜백 모듈의 상태 라고 가정하고 대신 직접 반환합니다.</target>
        </trans-unit>
        <trans-unit id="883a1351f7fb38c93f27abac246b139ddf314ded" translate="yes" xml:space="preserve">
          <source>If the callback module does not export a &lt;code&gt;system_replace_state/2&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; assumes that &lt;code&gt;Misc&lt;/code&gt; is the state of the callback module, passes it to &lt;code&gt;StateFun&lt;/code&gt; and uses the return value as both the new state and as the new value of &lt;code&gt;Misc&lt;/code&gt;.</source>
          <target state="translated">콜백 모듈이 &lt;code&gt;system_replace_state/2&lt;/code&gt; 함수를 내 보내지 않으면 &lt;code&gt;&lt;a href=&quot;#replace_state-2&quot;&gt;replace_state/2,3&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;Misc&lt;/code&gt; 가 콜백 모듈의 상태 라고 가정하고 이를 &lt;code&gt;StateFun&lt;/code&gt; 에 전달 하고 반환 값을 새로운 상태 및 새로운 &lt;code&gt;Misc&lt;/code&gt; 값으로 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="79079b06e33e739dcb437556ed9482e9eedc90a9" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt; system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="translated">콜백 모듈이 &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt; system_replace_state/2&lt;/a&gt;&lt;/code&gt; 함수를 내 &lt;code&gt;StateFun&lt;/code&gt; 대상 프로세스에서 호출되어 StateFun을 사용하여 상태를 바꿉니다 . 두 인수는 &lt;code&gt;StateFun&lt;/code&gt; 및 &lt;code&gt;Misc&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;Misc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 가 반환 한 &lt;code&gt;Misc&lt;/code&gt; 값 과 동일합니다 . &lt;code&gt;system_replace_state/2&lt;/code&gt; 함수 복귀 예상된다 &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt; , &lt;code&gt;NewState&lt;/code&gt; 를 호출하여 얻은 콜백 모듈의 새로운 상태 &lt;code&gt;StateFun&lt;/code&gt; 을 하고 &lt;code&gt;NewMisc&lt;/code&gt; 는 원래 대체 할 가능성이 새로운 값 &lt;code&gt;Misc&lt;/code&gt; (AS 필요 &lt;code&gt;Misc&lt;/code&gt; 는 종종 그 안에 콜백 모듈의 상태를 포함합니다).</target>
        </trans-unit>
        <trans-unit id="6b0469d22f2398ad4902a9f0274d691cde96d200" translate="yes" xml:space="preserve">
          <source>If the callback module exports a &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; function, it is called in the target process to replace its state using &lt;code&gt;StateFun&lt;/code&gt;. Its two arguments are &lt;code&gt;StateFun&lt;/code&gt; and &lt;code&gt;Misc&lt;/code&gt;, where &lt;code&gt;Misc&lt;/code&gt; is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;. A &lt;code&gt;system_replace_state/2&lt;/code&gt; function is expected to return &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt;, where &lt;code&gt;NewState&lt;/code&gt; is the new state of the callback module, obtained by calling &lt;code&gt;StateFun&lt;/code&gt;, and &lt;code&gt;NewMisc&lt;/code&gt; is a possibly new value used to replace the original &lt;code&gt;Misc&lt;/code&gt; (required as &lt;code&gt;Misc&lt;/code&gt; often contains the state of the callback module within it).</source>
          <target state="translated">콜백 모듈이 &lt;code&gt;&lt;a href=&quot;#Module:system_replace_state-2&quot;&gt;system_replace_state/2&lt;/a&gt;&lt;/code&gt; 함수를 내 &lt;code&gt;StateFun&lt;/code&gt; 대상 프로세스에서 StateFun을 사용하여 상태를 바꾸기 위해 호출 됩니다. 두 개의 인수는 &lt;code&gt;StateFun&lt;/code&gt; 과 &lt;code&gt;Misc&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;Misc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 가 반환 한 &lt;code&gt;Misc&lt;/code&gt; 값 과 동일합니다 . &lt;code&gt;system_replace_state/2&lt;/code&gt; 함수 복귀 예상된다 &lt;code&gt;{ok, NewState, NewMisc}&lt;/code&gt; , &lt;code&gt;NewState&lt;/code&gt; 를 호출하여 얻은 콜백 모듈의 새로운 상태 &lt;code&gt;StateFun&lt;/code&gt; 을 하고 &lt;code&gt;NewMisc&lt;/code&gt; 는 원래 대체 할 가능성이 새로운 값 &lt;code&gt;Misc&lt;/code&gt; (AS 필요 &lt;code&gt;Misc&lt;/code&gt; 에는 종종 콜백 모듈의 상태가 포함됩니다).</target>
        </trans-unit>
        <trans-unit id="cdcc08df51274710d006dbff0355880927f9ffef" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt; Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="translated">콜백 모듈이 &lt;code&gt;system_get_state/1&lt;/code&gt; 함수를 내 보내면 해당 상태를 가져 오기 위해 대상 프로세스에서 호출됩니다. 인수는 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 에서 반환 된 &lt;code&gt;Misc&lt;/code&gt; 값 과 동일하며 &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt; Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; 함수 는 콜백 모듈의 상태를 추출 할 것으로 예상됩니다. &lt;code&gt;system_get_state/1&lt;/code&gt; 함수 는 &lt;code&gt;{ok, State}&lt;/code&gt; 반환해야합니다 . 여기서 &lt;code&gt;State&lt;/code&gt; 는 콜백 모듈의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="22c3eecf9345190c4251d4199b67e06fe9f176a1" translate="yes" xml:space="preserve">
          <source>If the callback module exports a function &lt;code&gt;system_get_state/1&lt;/code&gt;, it is called in the target process to get its state. Its argument is the same as the &lt;code&gt;Misc&lt;/code&gt; value returned by &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt;, and function &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; is expected to extract the state of the callback module from it. Function &lt;code&gt;system_get_state/1&lt;/code&gt; must return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the state of the callback module.</source>
          <target state="translated">콜백 모듈이 &lt;code&gt;system_get_state/1&lt;/code&gt; 함수를 내 보내면 대상 프로세스에서 상태를 가져 오기 위해 호출됩니다. 인수는 &lt;code&gt;&lt;a href=&quot;#get_status-1&quot;&gt;get_status/1,2&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 &lt;code&gt;Misc&lt;/code&gt; 값 과 동일하며, &lt;code&gt;&lt;a href=&quot;#Module:system_get_state-1&quot;&gt;Module:system_get_state/1&lt;/a&gt;&lt;/code&gt; 함수 는 콜백 모듈의 상태를 추출 할 것으로 예상됩니다. &lt;code&gt;system_get_state/1&lt;/code&gt; 함수 는 &lt;code&gt;{ok, State}&lt;/code&gt; 리턴해야합니다 . 여기서 &lt;code&gt;State&lt;/code&gt; 는 콜백 모듈의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="01c2d9fbdbf4902fbd9ed598640b451a617bf5cc" translate="yes" xml:space="preserve">
          <source>If the callback module's &lt;code&gt;system_get_state/1&lt;/code&gt; function crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception.</source>
          <target state="translated">콜백 모듈의 &lt;code&gt;system_get_state/1&lt;/code&gt; 함수가 충돌하거나 예외를 throw하면 호출자는 오류 &lt;code&gt;{callback_failed, {Module, system_get_state}, {Class, Reason}}&lt;/code&gt; 과 함께 종료됩니다 . 여기서 &lt;code&gt;Module&lt;/code&gt; 은 콜백 모듈의 이름이고 &lt;code&gt;Class&lt;/code&gt; 및 &lt;code&gt;Reason&lt;/code&gt; 는 세부 사항을 나타냅니다. 예외의.</target>
        </trans-unit>
        <trans-unit id="7986fc8d38f019b96fd636349aa5cfd63d9efc6a" translate="yes" xml:space="preserve">
          <source>If the callback module's function &lt;code&gt;system_replace_state/2&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt;, where &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Reason&lt;/code&gt; indicate details of the exception. If the callback module does not provide a &lt;code&gt;system_replace_state/2&lt;/code&gt; function and &lt;code&gt;StateFun&lt;/code&gt; crashes or throws an exception, the caller exits with error &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt;.</source>
          <target state="translated">콜백 모듈의 함수 &lt;code&gt;system_replace_state/2&lt;/code&gt; 가 충돌하거나 예외를 throw하면 호출자는 오류 &lt;code&gt;{callback_failed, {Module, system_replace_state}, {Class, Reason}}&lt;/code&gt; 과 함께 종료됩니다 . 여기서 &lt;code&gt;Module&lt;/code&gt; 은 콜백 모듈의 이름이고 &lt;code&gt;Class&lt;/code&gt; 및 &lt;code&gt;Reason&lt;/code&gt; 는 세부 사항을 나타냅니다. 예외의. 콜백 모듈이 &lt;code&gt;system_replace_state/2&lt;/code&gt; 함수를 제공하지 않고 &lt;code&gt;StateFun&lt;/code&gt; 이 충돌하거나 예외를 발생시키는 경우 호출자는 오류 &lt;code&gt;{callback_failed, StateFun, {Class, Reason}}&lt;/code&gt; 과 함께 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="f20f590333f587ce4f158c6bd3d9e3042df378fe" translate="yes" xml:space="preserve">
          <source>If the caller of the function wants to know whether or not acknowledgments are received for a certain notification (provided it is sent as an inform), the &lt;code&gt;Receiver&lt;/code&gt; parameter can be specified as &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; (refer to the Reference Manual, section snmp, module &lt;code&gt;snmp&lt;/code&gt; for more details). In this case, the agent send a message &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; or &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; for each management target.</source>
          <target state="translated">함수 호출자가 특정 알림에 대해 수신 확인을 수신했는지 여부를 알리고 자하는 경우 (알림으로 전송 된 경우) &lt;code&gt;Receiver&lt;/code&gt; 매개 변수를 &lt;code&gt;{Tag, ProcessName}&lt;/code&gt; ( 지정 매뉴얼, 섹션 snmp 참조) 으로 지정할 수 있습니다. 자세한 내용은 모듈 &lt;code&gt;snmp&lt;/code&gt; 를 참조하십시오. 이 경우 에이전트 는 각 관리 대상에 대해 &lt;code&gt;{snmp_notification, Tag, {got_response, ManagerAddr}}&lt;/code&gt; 또는 &lt;code&gt;{snmp_notification, Tag, {no_response, ManagerAddr}}&lt;/code&gt; 를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="b596624aa0902d380836d0a8912ab2326ff5b443" translate="yes" xml:space="preserve">
          <source>If the calling process holds on to the value of the persistent term and the persistent term is deleted in the future, the term will be copied to the process.</source>
          <target state="translated">호출 프로세스가 영구 기간의 값을 유지하고 영구 기간이 향후 삭제되면 해당 기간이 프로세스에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="74d99e3904aef3995d136af596a2f043101aa1f9" translate="yes" xml:space="preserve">
          <source>If the calling process is not trapping exits, and checking &lt;code&gt;PidOrPort&lt;/code&gt; is cheap (that is, if &lt;code&gt;PidOrPort&lt;/code&gt; is local), &lt;code&gt;link/1&lt;/code&gt; fails with reason &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">호출 프로세스가 종료되지 않고 &lt;code&gt;PidOrPort&lt;/code&gt; 를 검사 하는 것이 저렴한 경우 (즉, &lt;code&gt;PidOrPort&lt;/code&gt; 가 로컬 인 경우 ) &lt;code&gt;link/1&lt;/code&gt; 은 &lt;code&gt;noproc&lt;/code&gt; 이유와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="51149d8666bb19147118b83bb274dae83a5f60ca" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="translated">나중에 호출 프로세스가 &lt;code&gt;Reason&lt;/code&gt; 으로 종료 되면 이벤트 관리자 는 &lt;code&gt;{stop,Reason}&lt;/code&gt; 을 인수로 사용 하여 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt; Module:terminate/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 이벤트 처리기를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="49a8b4f21577fe3cc5ca8d0fd53bd3ee9424f7f7" translate="yes" xml:space="preserve">
          <source>If the calling process later terminates with &lt;code&gt;Reason&lt;/code&gt;, the event manager deletes the event handler by calling &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;{stop,Reason}&lt;/code&gt; as argument.</source>
          <target state="translated">호출 프로세스가 나중에 &lt;code&gt;Reason&lt;/code&gt; 으로 종료 되면, 이벤트 관리자 는 &lt;code&gt;{stop,Reason}&lt;/code&gt; 을 인수로 사용 하여 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; 를 호출하여 이벤트 핸들러를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="f41eb527b8f8f2ec9a45659469012def9325921e" translate="yes" xml:space="preserve">
          <source>If the capture options describe that no substring capturing is to be done (&lt;code&gt;{capture, none}&lt;/code&gt;), the function returns the single atom &lt;code&gt;match&lt;/code&gt; upon successful matching, otherwise the tuple &lt;code&gt;{match, ValueList}&lt;/code&gt;. Disabling capturing can be done either by specifying &lt;code&gt;none&lt;/code&gt; or an empty list as &lt;code&gt;ValueSpec&lt;/code&gt;.</source>
          <target state="translated">캡처 옵션이 하위 문자열 캡처가 수행되지 않음을 설명하면 ( &lt;code&gt;{capture, none}&lt;/code&gt; ), 성공적인 일치시 단일 아톰 &lt;code&gt;match&lt;/code&gt; 를 리턴하고 그렇지 않으면 튜플 &lt;code&gt;{match, ValueList}&lt;/code&gt; 리턴합니다 . &lt;code&gt;none&lt;/code&gt; 또는 빈 목록을 &lt;code&gt;ValueSpec&lt;/code&gt; 로 지정하여 캡처 사용 안함을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8dfe9740232e522c9dccf1bcdb49e9bacfa76b87" translate="yes" xml:space="preserve">
          <source>If the carrier could not be scanned in full without harming the responsiveness of the system, &lt;code&gt;UnscannedSize&lt;/code&gt; is the number of bytes that had to be skipped.</source>
          <target state="translated">시스템의 응답 성을 손상시키지 않고 반송파를 완전히 스캔 할 수없는 경우 &lt;code&gt;UnscannedSize&lt;/code&gt; 는 건너 뛰어야하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b3d882b62bc462be24a22c4ebd1a0b80e4bbf23e" translate="yes" xml:space="preserve">
          <source>If the character escaping feature needs to be disabled (typically for backwards compatibility reasons), use the &lt;code&gt;ct_run&lt;/code&gt; start flag &lt;code&gt;-no_esc_chars&lt;/code&gt;, or the &lt;code&gt;ct:run_test/1&lt;/code&gt; start option &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; (this start option is also supported in test specifications).</source>
          <target state="translated">문자 이스케이프 기능을 비활성화해야하는 경우 (일반적으로 이전 버전과의 호환성을 위해) &lt;code&gt;ct_run&lt;/code&gt; 시작 플래그 &lt;code&gt;-no_esc_chars&lt;/code&gt; 또는 &lt;code&gt;ct:run_test/1&lt;/code&gt; 시작 옵션 &lt;code&gt;{esc_chars,Bool}&lt;/code&gt; 을 사용하십시오 (이 시작 옵션은 테스트 사양에서도 지원됨) .</target>
        </trans-unit>
        <trans-unit id="93733502359d2306f277753fcf5f39262e0db10b" translate="yes" xml:space="preserve">
          <source>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that &lt;code&gt;delete_child/2&lt;/code&gt; has no meaning and &lt;code&gt;restart_child/2&lt;/code&gt; cannot be used for these children.</source>
          <target state="translated">자식이 일시적인 경우 프로세스가 종료 되 자마자 자식 사양이 삭제됩니다. 즉, &lt;code&gt;delete_child/2&lt;/code&gt; 에는 의미가 없으며이 하위에는 &lt;code&gt;restart_child/2&lt;/code&gt; 를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43bb63cf5661d4a237a06093eced5cd149d67b35" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="translated">하위 프로세스가 다른 수퍼바이저 인 경우 하위 트리를 종료 할 수있는 충분한 시간을주기 위해 &lt;code&gt;infinity&lt;/code&gt; 으로 설정해야 합니다. 하위 프로세스가 작업자 인 경우 &lt;code&gt;infinity&lt;/code&gt; 로 설정할 수도 있습니다 . 아래 경고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d5e42700559025ed548daef3157e2a83d1175a5d" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, it must be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree enough time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker. See the warning below:</source>
          <target state="translated">하위 프로세스가 다른 감독자 인 경우 하위 트리에 종료 할 충분한 시간을 제공하려면 &lt;code&gt;infinity&lt;/code&gt; 로 설정해야합니다 . 하위 프로세스가 작업자 인 경우 &lt;code&gt;infinity&lt;/code&gt; 로 설정할 수도 있습니다 . 아래 경고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="04ca616fb018a5f7ed9b1457ccf717eb545a0d6c" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time is to be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down. It is also allowed to set it to &lt;code&gt;infinity&lt;/code&gt;, if the child process is a worker.</source>
          <target state="translated">하위 프로세스가 다른 수퍼바이저 인 경우, 종료 시간을 &lt;code&gt;infinity&lt;/code&gt; 으로 설정 하여 서브 트리가 종료 할 시간을 충분히 제공해야합니다. 하위 프로세스가 작업자 인 경우 &lt;code&gt;infinity&lt;/code&gt; 로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65acda7f63f750f753fdf6f71ac3163eb7c73a09" translate="yes" xml:space="preserve">
          <source>If the child process is another supervisor, the shutdown time must be set to &lt;code&gt;infinity&lt;/code&gt; to give the subtree ample time to shut down.</source>
          <target state="translated">하위 프로세스가 다른 수퍼바이저 인 경우 하위 트리가 종료 할 충분한 시간을 제공하려면 종료 시간을 &lt;code&gt;infinity&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f6c8d2313d1867bff7ceabb992796a9dc2cb660e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the child specification is added to the supervisor (unless the supervisor is a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor, see below), the pid is set to &lt;code&gt;undefined&lt;/code&gt;, and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;ignore&lt;/code&gt; 를 리턴 하면 하위 스펙이 수퍼바이저에 추가됩니다 (감독자가 &lt;code&gt;simple_one_for_one&lt;/code&gt; 수퍼바이저 가 아닌 경우 아래 참조), pid는 &lt;code&gt;undefined&lt;/code&gt; 로 설정되고 함수는 &lt;code&gt;{ok,undefined}&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5ef5502f7b080e1244d616694cf24b3ea2478505" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;ignore&lt;/code&gt;, the pid remains set to &lt;code&gt;undefined&lt;/code&gt; and the function returns &lt;code&gt;{ok,undefined}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;ignore&lt;/code&gt; 를 리턴 하면 pid는 &lt;code&gt;undefined&lt;/code&gt; 상태로 유지 되고 함수는 &lt;code&gt;{ok,undefined}&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2f7a47396e2013d77055f46cf69011c8dbc710aa" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the child specification and pid are added to the supervisor and the function returns the same value.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;{ok,Child}&lt;/code&gt; 또는 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 를 리턴하면 하위 스펙 및 pid가 수퍼바이저에 추가되고 함수는 동일한 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="48c5d696f2b0fd45c1b44f5e625a2accf1b0ea21" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{ok,Child}&lt;/code&gt; or &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, the pid is added to the supervisor and the function returns the same value.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;{ok,Child}&lt;/code&gt; 또는 &lt;code&gt;{ok,Child,Info}&lt;/code&gt; 를 리턴하면 pid가 수퍼바이저에 추가되고 함수는 동일한 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6d773deb857a328ed14a9080339dfab940c8161a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">하위 프로세스 시작 함수가 오류 튜플 또는 잘못된 값을 리턴하거나 실패하면 하위 스펙을 버리고 &lt;code&gt;{error,Error}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Error&lt;/code&gt; 는 오류 및 하위 스펙에 대한 정보를 포함하는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="1b122e474c03f3cefc84e42bbf3408fd35e5bb5e" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term containing information about the error.</source>
          <target state="translated">하위 프로세스 시작 함수가 오류 튜플 또는 잘못된 값을 리턴하거나 실패하면 &lt;code&gt;{error,Error}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Error&lt;/code&gt; 는 오류 에 대한 정보를 포함하는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="4b1288099957500451c193cb8d9ad26569f30036" translate="yes" xml:space="preserve">
          <source>If the child specification identified by &lt;code&gt;Id&lt;/code&gt; does not exist, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification exists but the corresponding process is already running, the function returns &lt;code&gt;{error,running}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Id&lt;/code&gt; 로 식별 된 하위 스펙 이 존재하지 않으면 함수는 &lt;code&gt;{error,not_found}&lt;/code&gt; 를 리턴합니다 . 하위 스펙이 존재하지만 해당 프로세스가 이미 실행중인 경우 함수는 &lt;code&gt;{error,running}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cdb0f0cbc98dc7d94d6b59162ff7e5e589d60364" translate="yes" xml:space="preserve">
          <source>If the client does not support any of the server advertised protocols or the server does not advertise any protocols, the client falls back to the first protocol in its list or to the default protocol (if a default is supplied). If the server does not support Next Protocol Negotiation, the connection terminates if no default protocol is supplied.</source>
          <target state="translated">클라이언트가 서버 보급 프로토콜을 지원하지 않거나 서버가 프로토콜을 보급하지 않으면 클라이언트는 목록의 첫 번째 프로토콜 또는 기본 프로토콜 (기본값이 제공된 경우)로 폴백합니다. 서버가 Next Protocol Negotiation을 지원하지 않으면 기본 프로토콜이 제공되지 않으면 연결이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1eacb16ee64844ecf9771b5e95710813db228ddf" translate="yes" xml:space="preserve">
          <source>If the client earlier has acquired a lock through &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt;, this operation releases the associated lock. To access another target than &lt;code&gt;running&lt;/code&gt;, the server must support &lt;code&gt;:candidate&lt;/code&gt; and/or &lt;code&gt;:startup&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 이전에 &lt;code&gt;&lt;a href=&quot;#lock-2&quot;&gt;lock/2,3&lt;/a&gt;&lt;/code&gt; 을 통해 잠금을 획득 한 경우이 조작은 연관된 잠금을 해제합니다. &lt;code&gt;running&lt;/code&gt; 이외의 다른 대상에 액세스하려면 서버가 &lt;code&gt;:candidate&lt;/code&gt; 및 / 또는 &lt;code&gt;:startup&lt;/code&gt; 을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35cb61822f1edfb65ab7f8cb515f968decf80d92" translate="yes" xml:space="preserve">
          <source>If the client fails to send the first ssh message after a tcp connection setup within this time (in milliseconds), the connection is closed. The default value is 30 seconds. This is actualy a generous time, so it can lowered to make the daemon less prone to DoS attacks.</source>
          <target state="translated">클라이언트가이 시간 (밀리 초) 내에 tcp 연결 설정 후 첫 번째 ssh 메시지를 보내지 못하면 연결이 닫힙니다. 기본값은 30 초입니다. 이것은 실제로 관대 한 시간이므로 데몬이 DoS 공격에 덜 취약하도록 낮출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1ef493c0d6b60856faddf62e5c3f0669465abe" translate="yes" xml:space="preserve">
          <source>If the code cannot be structured as in the &lt;code&gt;multiple_setelement/1&lt;/code&gt; example, the best way to modify multiple elements in a large tuple is to convert the tuple to a list, modify the list, and convert it back to a tuple.</source>
          <target state="translated">&lt;code&gt;multiple_setelement/1&lt;/code&gt; 예제 에서와 같이 코드를 구성 할 수없는 경우 큰 튜플에서 여러 요소를 수정하는 가장 좋은 방법은 튜플을 목록으로 변환하고 목록을 수정 한 다음 다시 튜플로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="929332aa79f38c1ef62558eac8beb42b63e4173b" translate="yes" xml:space="preserve">
          <source>If the common &lt;strong&gt;state callback&lt;/strong&gt; needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="translated">공통 &lt;strong&gt;상태 콜백&lt;/strong&gt; 이 현재 상태를 알아야하는 경우 대신 &lt;code&gt;handle_common/4&lt;/code&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b7ca0808d04f400f34111028c04d20133e9b2d" translate="yes" xml:space="preserve">
          <source>If the common event handler needs to know the current state a function &lt;code&gt;handle_common/4&lt;/code&gt; can be used instead:</source>
          <target state="translated">공통 이벤트 핸들러가 현재 상태를 알아야하는 경우 &lt;code&gt;handle_common/4&lt;/code&gt; 함수를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5b1741be466acda153b10a36fc7487f2ca70d6" translate="yes" xml:space="preserve">
          <source>If the compiler is to warn for missing callback functions, as it does for the OTP behaviours, add &lt;code&gt;-callback&lt;/code&gt; attributes in the behaviour module to describe the expected callbacks:</source>
          <target state="translated">컴파일러가 누락 된 콜백 함수에 대해 경고 &lt;code&gt;-callback&lt;/code&gt; 경우 OTP 동작과 마찬가지로 동작 모듈에 -callback 속성을 추가 하여 예상되는 콜백을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="523bb4f391597ed38f62115f28e3a49961855867" translate="yes" xml:space="preserve">
          <source>If the complete history is to be stored in the configuration file, &lt;code&gt;Config&lt;/code&gt; must be &lt;code&gt;all&lt;/code&gt;. If only a selected number of entries from the history are to be stored, &lt;code&gt;Config&lt;/code&gt; must be a list of integers pointing out the entries to be stored.</source>
          <target state="translated">전체 히스토리가 구성 파일에 저장되는 경우 &lt;code&gt;Config&lt;/code&gt; 는 &lt;code&gt;all&lt;/code&gt; 이어야 합니다 . 히스토리에서 선택된 수의 항목 만 저장 하려면 &lt;code&gt;Config&lt;/code&gt; 는 저장할 항목을 가리키는 정수 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="21e0716b03f7aa9ffd13782b0d420ef9a664a3d2" translate="yes" xml:space="preserve">
          <source>If the condition is not in any of the above formats, it must be an assertion. This can be a positive or negative lookahead or lookbehind assertion. Consider the following pattern, containing non-significant whitespace, and with the two alternatives on the second line:</source>
          <target state="translated">조건이 위의 형식 중 하나가 아닌 경우 어설 션이어야합니다. 이것은 긍정적이거나 부정적인 전망 일 수도 있고이면 주장 일 수도 있습니다. 중요하지 않은 공백을 포함하고 두 번째 줄에 두 가지 대안이있는 다음 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8a2fdb8b039278dbbab74f5b7bfb97af967770cd" translate="yes" xml:space="preserve">
          <source>If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern (if present). If more than two alternatives exist in the subpattern, a compile-time error occurs. Each of the two alternatives can itself contain nested subpatterns of any form, including conditional subpatterns; the restriction to two alternatives applies only at the level of the condition. The following pattern fragment is an example where the alternatives are complex:</source>
          <target state="translated">조건이 충족되면 예 패턴이 사용되고 그렇지 않으면 비 패턴이있는 경우 패턴이 사용됩니다. 하위 패턴에 두 개 이상의 대안이 존재하면 컴파일 타임 오류가 발생합니다. 두 가지 대안 각각은 조건부 하위 패턴을 포함하여 모든 형태의 중첩 하위 패턴을 포함 할 수 있습니다. 두 대안에 대한 제한은 조건 수준에서만 적용됩니다. 다음 패턴 조각은 대안이 복잡한 예입니다.</target>
        </trans-unit>
        <trans-unit id="fa304219623acf477a2744ed1bbab72da379738b" translate="yes" xml:space="preserve">
          <source>If the condition is the string (DEFINE), and there is no subpattern with the name DEFINE, the condition is always false. In this case, there can be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern. The idea of DEFINE is that it can be used to define &quot;subroutines&quot; that can be referenced from elsewhere. (The use of subroutines is described below.) For example, a pattern to match an IPv4 address, such as &quot;192.168.23.245&quot;, can be written like this (ignore whitespace and line breaks):</source>
          <target state="translated">조건이 문자열 (DEFINE)이고 이름이 DEFINE 인 하위 패턴이없는 경우 조건은 항상 false입니다. 이 경우 서브 패턴에는 하나의 대안 만있을 수 있습니다. 제어가 패턴에서이 지점에 도달하면 항상 건너 뜁니다. DEFINE의 아이디어는 다른 곳에서 참조 할 수있는 &quot;서브 루틴&quot;을 정의하는 데 사용될 수 있다는 것입니다. (서브 루틴 사용은 아래에 설명되어 있습니다.) 예를 들어 &quot;192.168.23.245&quot;와 같은 IPv4 주소와 일치하는 패턴은 다음과 같이 쓸 수 있습니다 (공백 및 줄 바꿈 무시).</target>
        </trans-unit>
        <trans-unit id="8e3f4e65a85b857108a35b24009e6fe7e2ac2084" translate="yes" xml:space="preserve">
          <source>If the condition is the string (R), and there is no subpattern with the name R, the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R, for example:</source>
          <target state="translated">조건이 문자열 (R)이고 이름이 R 인 서브 패턴이없는 경우, 전체 패턴 또는 서브 패턴을 재귀 적으로 호출 한 경우 조건이 참입니다. 숫자 나 이름 앞에 앰 퍼가 있고 문자 R 뒤에 오는 경우, 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95c431a360008991bb1b7759c9f06391d6e75043" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, or if the initiation fails, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">구성에 결함이 있거나 초기화에 실패하면 콜백 함수는 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="18a294113eb6042d9ad2a36514917a6dc077c344" translate="yes" xml:space="preserve">
          <source>If the configuration is faulty, the callback function must return &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">구성에 결함이있는 경우 콜백 함수는 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6a82e12e149afd95e3ddf1bb75d52a9982f828ca" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the same arguments as when &lt;code&gt;enable/2&lt;/code&gt; was called.</source>
          <target state="translated">구성 매개 변수 &lt;code&gt;os_sup_enable&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우, &lt;code&gt;enable/2&lt;/code&gt; 가 호출 될 때와 동일한 인수를 사용하여 &lt;code&gt;os_sup&lt;/code&gt; 에 의해이 함수가 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="aedee7601f2ce3a18dc9a8c63054f54ca3093e3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, this function is called automatically by &lt;code&gt;os_sup&lt;/code&gt;, using the values of &lt;code&gt;os_sup_own&lt;/code&gt; and &lt;code&gt;os_sup_syslogconf&lt;/code&gt; as arguments.</source>
          <target state="translated">구성 매개 변수 &lt;code&gt;os_sup_enable&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우 , &lt;code&gt;os_sup_own&lt;/code&gt; 및 &lt;code&gt;os_sup_syslogconf&lt;/code&gt; 의 값을 인수로 사용하여 &lt;code&gt;os_sup&lt;/code&gt; 에 의해이 함수가 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2ffcf1c22e3ce76143a4b07b440007a5df05ea7" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;code&gt;relocatable&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt; there is no need to install the target system with &lt;code&gt;reltool:install/2&lt;/code&gt; before it can be started. In that case the file tree containing the target system can be moved without re-installation.</source>
          <target state="translated">&lt;code&gt;relocatable&lt;/code&gt; 구성 매개 변수 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 , 대상 시스템을 시작하기 전에 &lt;code&gt;reltool:install/2&lt;/code&gt; 로 대상 시스템을 설치할 필요가 없습니다 . 이 경우 대상 시스템이 포함 된 파일 트리를 다시 설치하지 않고 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9be9f192141862f112332246e5a8f6499cf62cb" translate="yes" xml:space="preserve">
          <source>If the connection between the nodes involved in the spawn operation is lost during the spawn operation, the spawn operation will fail with an error reason of &lt;code&gt;noconnection&lt;/code&gt;. A new process may or may not have been created.</source>
          <target state="translated">생성 작업에 포함 된 노드 간의 연결이 생성 작업 중에 끊어 &lt;code&gt;noconnection&lt;/code&gt; 오류 이유와 함께 생성 작업이 실패 합니다. 새 프로세스가 생성되거나 생성되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a9759af159af887f4fafa82c8992b674a1e93e4" translate="yes" xml:space="preserve">
          <source>If the connection between the nodes involved in the spawn operation is lost during the spawn operation, the spawn operation will fail with an error reason of &lt;code&gt;noconnection&lt;/code&gt;. A new process may or may not have been created. If it has been created, it will be delivered an exit signal with an exit reason of &lt;code&gt;noconnection&lt;/code&gt;.</source>
          <target state="translated">생성 작업에 포함 된 노드 간의 연결이 생성 작업 중에 끊어 &lt;code&gt;noconnection&lt;/code&gt; 오류 이유와 함께 생성 작업이 실패 합니다. 새 프로세스가 생성되거나 생성되지 않았을 수 있습니다. 생성 된 경우 종료 이유가 &lt;code&gt;noconnection&lt;/code&gt; 인 종료 신호가 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="90f42cb19285f317fb015c9fad2016cce36110ed" translate="yes" xml:space="preserve">
          <source>If the connection timeout option &lt;code&gt;connect_timeout&lt;/code&gt; is set, that value is used also for the negotiation timeout and this option (&lt;code&gt;timeout&lt;/code&gt;) is ignored.</source>
          <target state="translated">연결 시간 종료 옵션 &lt;code&gt;connect_timeout&lt;/code&gt; 이 설정되면 해당 값은 협상 시간 종료에도 사용 되며이 옵션 ( &lt;code&gt;timeout&lt;/code&gt; )은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="860a4598c1d1ec6a83570120e591b858d6e8f890" translate="yes" xml:space="preserve">
          <source>If the connection to a remote node goes down, the main node will mark it as lost. If the node comes back it will be added again. If the remote node was alive during the disconnected periode, cover data from before and during this periode will be included in the analysis.</source>
          <target state="translated">원격 노드와의 연결이 끊어지면 주 노드는 연결이 끊어진 것으로 표시합니다. 노드가 다시 오면 다시 추가됩니다. 연결이 끊어진 기간 동안 원격 노드가 활성 상태 인 경우이 기간 이전 및이 기간 동안의 커버 데이터가 분석에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a99ee1cb6fcf81c8bae71874c193979ebe43ebab" translate="yes" xml:space="preserve">
          <source>If the constraints described so far is not enough, additional constraints can be written in C in &lt;code&gt;beam_load.c&lt;/code&gt; and be called as a guard function on the left side of the transformation. If the guard function returns a non-zero value, the matching of the rule will continue, otherwise the match will fail. For example:</source>
          <target state="translated">지금까지 설명한 제약 조건이 충분하지 않은 경우 추가 제약 조건을 &lt;code&gt;beam_load.c&lt;/code&gt; 에 C로 작성 하고 변환의 왼쪽에 보호 함수로 호출 할 수 있습니다 . 가드 함수가 0이 아닌 값을 반환하면 규칙 일치가 계속되고 그렇지 않으면 일치가 실패합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c3b7535bf38d5e1053e0dcfad4dfa786c040f2e7" translate="yes" xml:space="preserve">
          <source>If the contents of &lt;code&gt;.erlang&lt;/code&gt; are changed and a private version of &lt;code&gt;user_default&lt;/code&gt; is defined, the Erlang/OTP environment can be customized. More powerful changes can be made by supplying command-line arguments in the startup script &lt;code&gt;erl&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.erlang&lt;/code&gt; 의 내용 이 변경되고 개인 버전의 &lt;code&gt;user_default&lt;/code&gt; 가 정의 된 경우 Erlang / OTP 환경을 사용자 정의 할 수 있습니다. 시작 스크립트 &lt;code&gt;erl&lt;/code&gt; 에 명령 행 인수를 제공하여보다 강력한 변경을 수행 할 수 있습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init(3)&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6279554b0d57c5f26b8ffa794daeaf8c67036750" translate="yes" xml:space="preserve">
          <source>If the context requires an integer rather than a variable, an atom, or a string, you cannot use the uppercase convention to mark an automatic metavariable. Instead, if the integer (without the &lt;code&gt;909&lt;/code&gt;-prefix and lift/glob markers) ends in a &lt;code&gt;9&lt;/code&gt;, the integer will become an Erlang-level variable prefixed with &lt;code&gt;Q&lt;/code&gt;, and if it ends with &lt;code&gt;99&lt;/code&gt; it will also be automatically abstracted. For example, the following will increment the arity of the exported function f:</source>
          <target state="translated">컨텍스트에 변수, 원자 또는 문자열이 아닌 정수가 필요한 경우 대문자 규칙을 사용하여 자동 메타 변수를 표시 할 수 없습니다. 대신, 정수 ( &lt;code&gt;909&lt;/code&gt; - 접두사 및 리프트 / 글로브 마커가없는)가 &lt;code&gt;9&lt;/code&gt; 로 끝나는 경우 정수는 &lt;code&gt;Q&lt;/code&gt; 로 시작하는 Erlang 수준 변수 가되고 &lt;code&gt;99&lt;/code&gt; 로 끝나는 경우 자동으로 추상화됩니다. 예를 들어, 다음은 내 보낸 함수 f의 arity를 ​​증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e14244783ffadbf99f1d872c65ba8477af77375e" translate="yes" xml:space="preserve">
          <source>If the converse of a function F is a function F', then F' is called the &lt;strong id=&quot;inverse&quot;&gt;inverse&lt;/strong&gt; of F.</source>
          <target state="translated">함수 F의 반대가 함수 F '이면 F'를 F의 &lt;strong id=&quot;inverse&quot;&gt;반대&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="04e1722c7eed1557956908ac595866c524c53815" translate="yes" xml:space="preserve">
          <source>If the cross compilation tools are prefixed by &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; you probably do not need to set these variables (where &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; is what has been passed as &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; argument to &lt;code&gt;configure&lt;/code&gt;).</source>
          <target state="translated">크로스 컴파일 도구 앞에 &lt;code&gt;&amp;lt;HOST&amp;gt;-&lt;/code&gt; 가 붙는 경우 이러한 변수를 설정하지 않아도됩니다 (여기서 &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; 는 &lt;code&gt;configure&lt;/code&gt; 하기 위해 &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; 인수 로 전달 된 것임 ).</target>
        </trans-unit>
        <trans-unit id="97604b617615c0b88c829c8abf48415d16d68d04" translate="yes" xml:space="preserve">
          <source>If the current working directory for &lt;code&gt;erlc&lt;/code&gt; is different from the working directory active when the compile server was started, &lt;strong&gt;and&lt;/strong&gt; if the compile server has active jobs, it will be restarted as soon as those jobs have finished. (Build systems that build files randomly across multiple directories in parallel will probably not benefit from the compile server.)</source>
          <target state="translated">현재 작업 디렉토리 경우 &lt;code&gt;erlc&lt;/code&gt; 은 컴파일 서버가 시작되었을 때 작업 디렉토리에서 활성 다른, &lt;strong&gt;그리고&lt;/strong&gt; 컴파일 서버가 활성 작업이있는 경우, 그것은 그 작업이 완료 자마자 다시 시작됩니다. (병렬로 여러 디렉토리에서 무작위로 파일을 빌드하는 빌드 시스템은 컴파일 서버의 이점을 얻지 못할 것입니다.)</target>
        </trans-unit>
        <trans-unit id="693638c468a0a688aceae31ef9d5b589f67e3d3d" translate="yes" xml:space="preserve">
          <source>If the data cannot be converted, either because of illegal Unicode/ISO Latin-1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag &lt;code&gt;error&lt;/code&gt;, a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging, as it still constitutes a possibly deep or mixed list, or both, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is returned &quot;as is&quot;.</source>
          <target state="translated">목록의 잘못된 유니 코드 / ISO 라틴 -1 문자 또는 이진의 잘못된 UTF 인코딩으로 인해 데이터를 변환 할 수없는 경우 오류 튜플이 반환됩니다. 오류 튜플 태그가 포함되어 &lt;code&gt;error&lt;/code&gt; , 오류가 발생하기 전에 변환 할 수있는 문자를 포함하고 기분을 상하게 정수 후 문자의 표현을 나타내는 목록 / 바이트. 마지막 부분은 원본 데이터와 깊이가 같지 않아도 깊거나 혼합 된 목록 또는 둘 다를 구성하기 때문에 주로 디버깅에 사용됩니다. 목록을 탐색 할 때 오류가 발생하고 디코딩 할 항목이 &quot;있는 그대로&quot;반환됩니다.</target>
        </trans-unit>
        <trans-unit id="830c19e2812b5ad638344d6692b4a5d1c14189d2" translate="yes" xml:space="preserve">
          <source>If the data in the table is to be accessed so that the order of the keys in the table is significant, the table type &lt;code&gt;ordered_set&lt;/code&gt; can be used instead of the more usual &lt;code&gt;set&lt;/code&gt; table type. An &lt;code&gt;ordered_set&lt;/code&gt; is always traversed in Erlang term order regarding the key field so that the return values from functions such as &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;match_object&lt;/code&gt;, and &lt;code&gt;foldl&lt;/code&gt; are ordered by the key values. Traversing an &lt;code&gt;ordered_set&lt;/code&gt; with the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; operations also returns the keys ordered.</source>
          <target state="translated">테이블의 키 순서가 중요하도록 테이블의 데이터에 액세스 &lt;code&gt;ordered_set&lt;/code&gt; 경우 더 일반적인 &lt;code&gt;set&lt;/code&gt; 테이블 유형 대신 ordered_set 테이블 유형을 사용할 수 있습니다 . &lt;code&gt;ordered_set&lt;/code&gt; 항상 같은 기능의 반환 값 있도록 키 필드에 대한 얼랑 용어의 순서로 통과되어 &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;match_object&lt;/code&gt; 이 , 그리고 &lt;code&gt;foldl&lt;/code&gt; 이 키 값에 의해 정렬됩니다. &lt;code&gt;first&lt;/code&gt; 작업 과 &lt;code&gt;next&lt;/code&gt; 작업으로 &lt;code&gt;ordered_set&lt;/code&gt; 을 순회하면 순서가 지정된 키도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cef7dde804ec38da41a38a959068e58669e710" translate="yes" xml:space="preserve">
          <source>If the data is to be sent from the driver to the port owner process, it is faster to use &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">드라이버에서 포트 소유자 프로세스로 데이터를 보내려면 &lt;code&gt;&lt;a href=&quot;#driver_outputv&quot;&gt;driver_outputv&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="d69f0718531a0dc4b5192097fe34a9a400874115" translate="yes" xml:space="preserve">
          <source>If the database is huge, it it not always possible to restore it online. In such cases, restore the old database by installing a fallback and then restart.</source>
          <target state="translated">데이터베이스가 큰 경우 항상 온라인으로 복원 할 수있는 것은 아닙니다. 이러한 경우 대체를 설치하여 이전 데이터베이스를 복원 한 후 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="1a465de33f0929289f4ba867f52979d6f1b60be6" translate="yes" xml:space="preserve">
          <source>If the decoded message happens to be received before the connection is established, a new &quot;virtual&quot; connection is established. This is typically the case for the Media Gateway Controller (MGC) upon the first Service Change. When this occurs the following callback function will be invoked:</source>
          <target state="translated">연결이 설정되기 전에 디코딩 된 메시지가 수신되면 새로운 &quot;가상&quot;연결이 설정됩니다. 일반적으로 첫 번째 서비스 변경시 MCC (Media Gateway Controller)의 경우입니다. 이 경우 다음과 같은 콜백 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fbdce8830ddb42e0e285519e4fb52411ce2090fe" translate="yes" xml:space="preserve">
          <source>If the decoded message instead of transactions contains a message error, the following callback function will be invoked:</source>
          <target state="translated">트랜잭션 대신 디코딩 된 메시지에 메시지 오류가 포함 된 경우 다음 콜백 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6be7e8b5958c0936e75a2ab6e68f6fdfd8645d72" translate="yes" xml:space="preserve">
          <source>If the default value is not suitable, the type letter can be followed by &lt;code&gt;=&lt;/code&gt; and a value. Most types take an integer value. The value for an atom is written the same way as in the C source code. For example, the atom &lt;code&gt;false&lt;/code&gt; is written as &lt;code&gt;am_false&lt;/code&gt;. The atom must be listed in &lt;code&gt;atom.names&lt;/code&gt;.</source>
          <target state="translated">기본값이 적합하지 않은 경우 문자 유형 뒤에 &lt;code&gt;=&lt;/code&gt; 및 값이 올 수 있습니다. 대부분의 유형은 정수 값을 사용합니다. 원자의 값은 C 소스 코드에서와 같은 방식으로 작성됩니다. 예를 들어, 원자 &lt;code&gt;false&lt;/code&gt; 는 &lt;code&gt;am_false&lt;/code&gt; 로 기록됩니다 . 원자는 &lt;code&gt;atom.names&lt;/code&gt; 에 나열되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e05877711912cb7abc7753f9ce969b4440e6bb55" translate="yes" xml:space="preserve">
          <source>If the definitions are identical, the output module keeps only one definition with the original name.</source>
          <target state="translated">정의가 동일하면 출력 모듈은 원래 이름을 가진 하나의 정의 만 유지합니다.</target>
        </trans-unit>
        <trans-unit id="709eb064721592f0145e0c9870df4b79e36f2fb2" translate="yes" xml:space="preserve">
          <source>If the definitions have the same name and differs in the definition, they are renamed. The new names are the definition name and the original module name concatenated.</source>
          <target state="translated">정의의 이름이 같고 정의가 다른 경우 이름이 바뀝니다. 새로운 이름은 정의 이름과 원래 모듈 이름이 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3055c07c7bca6e36c452534d5a6de3daec9136a" translate="yes" xml:space="preserve">
          <source>If the deleted entry is a registered subscriber, it will imply that the subscriber process gets is unregistered as subscriber as well as it gets it final message.</source>
          <target state="translated">삭제 된 항목이 등록 된 구독자 인 경우 구독자 프로세스가 구독자로 등록되지 않고 최종 메시지를받는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b7794972861adba2b5114706df92a0c8a22b1b7d" translate="yes" xml:space="preserve">
          <source>If the deleted term (or any part of it) is still used by a process, that process will do a major (fullsweep) garbage collection and copy the term into the process. However, at most two processes at a time will be scheduled to do that kind of garbage collection.</source>
          <target state="translated">삭제 된 용어 (또는 그 일부)가 여전히 프로세스에서 사용되는 경우 해당 프로세스는 주요 (전체 스윕) 가비지 수집을 수행하고 해당 용어를 프로세스에 복사합니다. 그러나 한 번에 최대 두 개의 프로세스가 이러한 종류의 가비지 수집을 수행하도록 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="818e5bafa76101bf732fc51de14593ea48da629f" translate="yes" xml:space="preserve">
          <source>If the destination node would have to be auto-connected to do the send, &lt;code&gt;noconnect&lt;/code&gt; is returned instead.</source>
          <target state="translated">송신을 수행하기 위해 목적지 노드가 자동 연결되어야하는 경우, 대신 &lt;code&gt;noconnect&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="fa49b96a6e23a80a21210ac903528ecee8169a93" translate="yes" xml:space="preserve">
          <source>If the directory for the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is &lt;code&gt;/etc&lt;/code&gt;, the line in &lt;code&gt;syslog.conf.OTP&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;syslog.conf.ORIG&lt;/code&gt; 및 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 파일의 디렉토리 가 &lt;code&gt;/etc&lt;/code&gt; 인 경우 &lt;code&gt;syslog.conf.OTP&lt;/code&gt; 의 행 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cfa13bd96270a398f97e146ebd653c8f1622e36" translate="yes" xml:space="preserve">
          <source>If the directory is not found</source>
          <target state="translated">디렉토리를 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="ee9c7c20028055c752f1006405fb6ac3dd62c654" translate="yes" xml:space="preserve">
          <source>If the directory refers to a directory in an archive, the archive name is stripped away before the path is returned. For example, if directory &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; is in the path, &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; is returned. This means that the library directory for an application is the same, regardless if the application resides in an archive or not.</source>
          <target state="translated">디렉토리가 아카이브의 디렉토리를 참조하는 경우 경로가 리턴되기 전에 아카이브 이름이 제거됩니다. 예를 들어, &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2.ez/mnesia-4.2.2/ebin&lt;/code&gt; 디렉토리 가 경로에 있으면 &lt;code&gt;/usr/local/otp/lib/mnesia-4.2.2/ebin&lt;/code&gt; 반환됩니다. 이는 애플리케이션이 아카이브에 있는지 여부에 관계없이 애플리케이션의 라이브러리 디렉토리가 동일 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f85643a441c622fdd2576beffc4873deda4e4256" translate="yes" xml:space="preserve">
          <source>If the dirty NIF is expected to be CPU-bound, its &lt;code&gt;flags&lt;/code&gt; field is to be set to &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; or &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt;.</source>
          <target state="translated">더티 NIF가 CPU에 바인드 될 것으로 예상되는 경우, &lt;code&gt;flags&lt;/code&gt; 필드는 &lt;code&gt;ERL_NIF_DIRTY_JOB_CPU_BOUND&lt;/code&gt; 또는 &lt;code&gt;ERL_NIF_DIRTY_JOB_IO_BOUND&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="23d292909c9d32167cfb8c2e96fc30eeaf637bf8" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt; stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="translated">드라이버가 어떤 이유로 드라이버 바이너리를 유지하려는 경우 (예 : 정적 변수) 참조 횟수가 증가하고 나중에 &lt;code&gt;driver_free_binary&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt; stop&lt;/a&gt;&lt;/code&gt; 콜백 에서 바이너리를 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c2ddfd812a9a461d82c50bcdf565e3ca018a4da" translate="yes" xml:space="preserve">
          <source>If the driver for some reason wants to keep a driver binary around, for example in a static variable, the reference count is to be incremented, and the binary can later be freed in the &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; callback, with &lt;code&gt;driver_free_binary&lt;/code&gt;.</source>
          <target state="translated">어떤 이유로 드라이버가 정적 변수에 예를 들어, 주변 드라이버 바이너리를 유지하고자하는 경우, 참조 카운트가 증가 할 수 있으며, 이진은 이후에 해제 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;driver_entry#stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 로, 콜백 &lt;code&gt;driver_free_binary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12df4e4fa0309d2f4f4f74b51f81225f4bdeeaf" translate="yes" xml:space="preserve">
          <source>If the driver has option &lt;code&gt;kill_ports&lt;/code&gt; set, or if &lt;code&gt;kill_ports&lt;/code&gt; is specified as an option to this function, all pending ports using this driver are killed when unloading is done by the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. If no port-killing is involved and there are open ports, the unloading is delayed until no more open ports use the driver. If, in this case, another &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (or even this user) loads the driver again before the driver is unloaded, the unloading never takes place.</source>
          <target state="translated">드라이버에 &lt;code&gt;kill_ports&lt;/code&gt; 옵션이 설정되어 있거나 &lt;code&gt;kill_ports&lt;/code&gt; 가이 기능에 대한 옵션으로 지정된 경우 , 마지막 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 가 언로드 할 때이 드라이버를 사용하는 모든 보류중인 포트가 종료됩니다 . 포트 킬링이없고 열린 포트가있는 경우 더 이상 열린 포트가 드라이버를 사용하지 않을 때까지 언로드가 지연됩니다. 이 경우 다른 &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; (또는이 사용자)가 드라이버를 언로드하기 전에 드라이버를 다시로드하면 언로드가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcf785a336b2c213c45577e83eb09e396c7e3eab" translate="yes" xml:space="preserve">
          <source>If the driver is unloaded (not present in the system), error code &lt;code&gt;not_loaded&lt;/code&gt; is returned. Option &lt;code&gt;reload&lt;/code&gt; is intended for when the user has already loaded the driver in advance.</source>
          <target state="translated">드라이버가 언로드되면 (시스템에 없음) 오류 코드 &lt;code&gt;not_loaded&lt;/code&gt; 가 반환됩니다. 옵션 &lt;code&gt;reload&lt;/code&gt; 는 사용자가 이미 드라이버를 미리로드 한 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d39f81561d0eb5e9555b68509516e98553687c4" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt; erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">드라이버가 데이터를 반환하려면 &lt;code&gt;rbuf&lt;/code&gt; 에서 반환해야합니다 . 되면 &lt;code&gt;control&lt;/code&gt; , 호출 &lt;code&gt;*rbuf&lt;/code&gt; 의 디폴트 버퍼 포인트 &lt;code&gt;rlen&lt;/code&gt; 데이터를 반환하는 데 사용될 수있는 바이트. 데이터는 포트 제어 플래그 ( &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt; erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt; 로 설정된 플래그)에 따라 다르게 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="af3e2b2e4d5d486f038ae4047d709485c51ebafd" translate="yes" xml:space="preserve">
          <source>If the driver wants to return data, it is to return it in &lt;code&gt;rbuf&lt;/code&gt;. When &lt;code&gt;control&lt;/code&gt; is called, &lt;code&gt;*rbuf&lt;/code&gt; points to a default buffer of &lt;code&gt;rlen&lt;/code&gt; bytes, which can be used to return data. Data is returned differently depending on the port control flags (those that are set with &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">드라이버가 데이터를 반환하려면 &lt;code&gt;rbuf&lt;/code&gt; 로 반환해야합니다 . 되면 &lt;code&gt;control&lt;/code&gt; , 호출 &lt;code&gt;*rbuf&lt;/code&gt; 의 디폴트 버퍼 포인트 &lt;code&gt;rlen&lt;/code&gt; 데이터를 반환하는 데 사용될 수있는 바이트. 포트 제어 플래그 ( &lt;code&gt;&lt;a href=&quot;erl_driver#set_port_control_flags&quot;&gt;erl_driver:set_port_control_flags&lt;/a&gt;&lt;/code&gt; 로 설정된 플래그)에 따라 데이터가 다르게 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="f299a698f91b18144d2db6873d22e3355371e343" translate="yes" xml:space="preserve">
          <source>If the driver was previously unloaded, but is still present because of open ports to it, a call to &lt;code&gt;load/2&lt;/code&gt; stops the unloading and keeps the driver (as long as &lt;code&gt;Path&lt;/code&gt; is the same), and &lt;code&gt;ok&lt;/code&gt; is returned. If you really want the object code to be reloaded, use &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; or the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; instead. See also the description of &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; for loading/unloading in the introduction.</source>
          <target state="translated">드라이버가 이전에 언로드되었지만 열린 포트로 인해 여전히 존재하는 경우 &lt;code&gt;load/2&lt;/code&gt; 를 호출 하면 언로드가 중지되고 드라이버가 유지됩니다 ( &lt;code&gt;Path&lt;/code&gt; 가 동일한 경우). 그러면 &lt;code&gt;ok&lt;/code&gt; 가 반환됩니다. 객체 코드를 실제로 다시로드하려면 &lt;code&gt;&lt;a href=&quot;#reload-2&quot;&gt;reload/2&lt;/a&gt;&lt;/code&gt; 또는 저수준 인터페이스 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; 를 대신 사용하십시오. 소개에서로드 / 언로드에 대한 &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;different scenarios&lt;/a&gt;&lt;/code&gt; 대한 설명도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73cd90e7e567fcfaa60abf0aba49564831915adf" translate="yes" xml:space="preserve">
          <source>If the edge would create a cycle in an &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; is returned. If &lt;code&gt;G&lt;/code&gt; already has an edge with value &lt;code&gt;E&lt;/code&gt; connecting a different pair of vertices, &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; is returned. If either of &lt;code&gt;V1&lt;/code&gt; or &lt;code&gt;V2&lt;/code&gt; is not a vertex of digraph &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt;V&lt;code&gt;}}&lt;/code&gt; is returned, V = &lt;code&gt;V1&lt;/code&gt; or V = &lt;code&gt;V2&lt;/code&gt;.</source>
          <target state="translated">가장자리가의 사이클을 만들 것입니다 경우 &lt;code&gt;&lt;a href=&quot;#acyclic_digraph&quot;&gt;acyclic digraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;Path}}&lt;/code&gt; 반환됩니다. &lt;code&gt;G&lt;/code&gt; 에 다른 정점 쌍을 연결하는 &lt;code&gt;E&lt;/code&gt; 값을 가진 모서리가 이미 있으면 &lt;code&gt;{error,&amp;nbsp;{bad_edge,&amp;nbsp;[V1,&amp;nbsp;V2]}}&lt;/code&gt; 가 반환됩니다. &lt;code&gt;V1&lt;/code&gt; 또는 &lt;code&gt;V2&lt;/code&gt; 중 하나가 &lt;code&gt;{error,&amp;nbsp;{bad_vertex,&amp;nbsp;&lt;/code&gt; 그래프 &lt;code&gt;G&lt;/code&gt; 의 정점이 아닌 경우 , {error, {bad_vertex,&amp;nbsp; V &lt;code&gt;}}&lt;/code&gt; 가 반환되고 V = &lt;code&gt;V1&lt;/code&gt; 또는 V = &lt;code&gt;V2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88548b0769c08599153c91bedffecba4076939a2" translate="yes" xml:space="preserve">
          <source>If the emulator detects an internal error (or runs out of memory), it, by default, generates both a crash dump and a core dump. The core dump is, however, not very useful as the content of process heaps is destroyed by the crash dump generation.</source>
          <target state="translated">에뮬레이터에서 내부 오류를 감지하거나 메모리가 부족하면 기본적으로 크래시 덤프와 코어 덤프가 모두 생성됩니다. 그러나 프로세스 덤프의 내용이 크래시 덤프 생성에 의해 파괴되므로 코어 덤프는 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c268e0a4f924dc7fcacea261eaf98d33a0b39dd" translate="yes" xml:space="preserve">
          <source>If the emulator needs to be restarted after upgrading or downgrading, that is, if the ERTS version differs between &lt;code&gt;Name.rel&lt;/code&gt; and &lt;code&gt;Name2.rel&lt;/code&gt;</source>
          <target state="translated">업그레이드 또는 다운 그레이드 후 에뮬레이터를 다시 시작해야하는 경우, 즉 ERTS 버전이 &lt;code&gt;Name.rel&lt;/code&gt; 과 &lt;code&gt;Name2.rel&lt;/code&gt; 간에 다른 경우</target>
        </trans-unit>
        <trans-unit id="0e5cf3cf162417b51e0a5af24e5040b612349b1b" translate="yes" xml:space="preserve">
          <source>If the emulator needs to write a crash dump, the value of this variable is the filename of the crash dump file. If the variable is not set, the name of the crash dump file is &lt;code&gt;erl_crash.dump&lt;/code&gt; in the current directory.</source>
          <target state="translated">에뮬레이터에서 크래시 덤프를 작성해야하는 경우이 변수의 값은 크래시 덤프 파일의 파일 이름입니다. 변수가 설정되지 않은 경우 충돌 덤프 파일의 이름은 현재 디렉토리에서 &lt;code&gt;erl_crash.dump&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2eec4c147205e5216572281566e1e6a996fb672c" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt; dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">에뮬레이터가 &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt; dirty schedulers&lt;/a&gt;&lt;/code&gt; 를 지원하도록 빌드 된 경우 온라인 스케줄러 수를 변경하면 온라인 더티 CPU 스케줄러 수도 변경할 수 있습니다. 예를 들어, 12 개의 스케줄러와 6 개의 더티 CPU 스케줄러가 온라인 상태이고 &lt;code&gt;system_flag/2&lt;/code&gt; 를 사용하여 온라인 스케줄러의 수를 6으로 설정하면 더티 CPU 스케줄러의 온라인 수도 자동으로 절반으로 감소하여 3으로 감소합니다. 마찬가지로 온라인 더티 CPU 스케줄러의 수는 온라인 스케줄러 수의 증가에 비례하여 증가합니다.</target>
        </trans-unit>
        <trans-unit id="40c61683ad15fa177c304fbdf476f8b2479cdc64" translate="yes" xml:space="preserve">
          <source>If the emulator was built with support for &lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt;, changing the number of schedulers online can also change the number of dirty CPU schedulers online. For example, if 12 schedulers and 6 dirty CPU schedulers are online, and &lt;code&gt;system_flag/2&lt;/code&gt; is used to set the number of schedulers online to 6, then the number of dirty CPU schedulers online is automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to increases in the number of schedulers online.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#system_flag_dirty_cpu_schedulers_online&quot;&gt;dirty schedulers&lt;/a&gt;&lt;/code&gt; 를 지원하도록 에뮬레이터를 빌드 한 경우 온라인으로 스케줄러 수를 변경하면 더티 CPU 스케줄러가 온라인으로 변경 될 수도 있습니다. 예를 들어, 12 개의 스케줄러와 6 개의 더티 CPU 스케줄러가 온라인이고 &lt;code&gt;system_flag/2&lt;/code&gt; 를 사용하여 스케줄러의 온라인 수를 6으로 설정하면 더티 CPU 스케줄러의 온라인 수는 자동으로 절반으로 3으로 줄어 듭니다. 마찬가지로 온라인 더티 CPU 스케줄러 수는 온라인 스케줄러 수 증가에 비례하여 증가합니다.</target>
        </trans-unit>
        <trans-unit id="53196a3c7142e79d1e176b567fb18778d22d10f3" translate="yes" xml:space="preserve">
          <source>If the encoding rule option is omitted, &lt;code&gt;ber&lt;/code&gt; is the default.</source>
          <target state="translated">인코딩 규칙 옵션이 생략되면 &lt;code&gt;ber&lt;/code&gt; 가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b9353bd702a35793ac18305b8482171f21007231" translate="yes" xml:space="preserve">
          <source>If the end of the pattern is reached, the match succeeds and you can retrieve the contents of the variable.</source>
          <target state="translated">패턴의 끝에 도달하면 일치가 성공하고 변수의 내용을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec86b8e10359d9eb0c69eab5270c60f057cce319" translate="yes" xml:space="preserve">
          <source>If the engine is located in the OpenSSL/LibreSSL installation &lt;code&gt;engines&lt;/code&gt; directory.</source>
          <target state="translated">엔진이 OpenSSL / LibreSSL 설치 &lt;code&gt;engines&lt;/code&gt; 디렉토리에있는 경우</target>
        </trans-unit>
        <trans-unit id="46c40e2b5cd9693ace2f62de74c9f71bc27ab4c5" translate="yes" xml:space="preserve">
          <source>If the entire log is successfully converted, the function will return &lt;code&gt;ok&lt;/code&gt;. If one of more entries fail to convert, the function will instead return &lt;code&gt;{ok, {NumOK, NumERR}}&lt;/code&gt;, where the counters indicate how many valid and erroneous entries where found. If instead &lt;code&gt;{error, Reason}&lt;/code&gt; is returned, the conversion encountered a fatal error and where either never done of aborted midway.</source>
          <target state="translated">전체 로그가 성공적으로 변환되면 함수는 &lt;code&gt;ok&lt;/code&gt; 를 반환 합니다. 하나 이상의 항목이 변환에 실패하면 함수는 대신 &lt;code&gt;{ok, {NumOK, NumERR}}&lt;/code&gt; 반환합니다 . 여기서 카운터는 발견 된 유효하고 오류가있는 항목의 수를 나타냅니다. 대신 &lt;code&gt;{error, Reason}&lt;/code&gt; 이 반환되면 변환에 치명적인 오류가 발생하고 중간에 중단되지 않은 경우입니다.</target>
        </trans-unit>
        <trans-unit id="17edef4a35e3cca0ca8935fe0f2de48f9e5dfe47" translate="yes" xml:space="preserve">
          <source>If the entry is a new subscriber, it will imply that the new subscriber process first will get one message for each already stored dictionary entry, before it and all old subscribers will get this particular entry. The collector process links to and then supervises the subscriber process. If the subscriber process dies it will imply that it gets unregistered as with a normal dict_delete/2.</source>
          <target state="translated">항목이 새로운 가입자 인 경우, 새로운 가입자 프로세스는 먼저 이미 저장된 각 사전 항목에 대해 하나의 메시지를 수신하고 모든 기존 가입자는이 특정 항목을 가져옵니다. 수집기 프로세스는 구독자 프로세스에 연결 한 다음이를 감독합니다. 구독자 프로세스가 종료되면 일반 dict_delete / 2와 같이 등록이 취소되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4d245a9827d109c394220e412fd90299a8b7ff0f" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs instead of a &lt;code&gt;case_clause&lt;/code&gt;.</source>
          <target state="translated">평가하면 &lt;code&gt;Exprs&lt;/code&gt; 는 예외없이 성공할 무늬 &lt;code&gt;Pattern&lt;/code&gt; 순차적와 동일한 방식으로 한 결과에 대해 일치하는 &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; 일치가 실패하면 것 이외에는, 식 &lt;code&gt;try_clause&lt;/code&gt; 런타임 에러 대신 인해 발생 &lt;code&gt;case_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a094e54489c949e55e10b1bfd099675a9945d8d2" translate="yes" xml:space="preserve">
          <source>If the evaluation of &lt;code&gt;Exprs&lt;/code&gt; succeeds without an exception, the patterns &lt;code&gt;Pattern&lt;/code&gt; are sequentially matched against the result in the same way as for a &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; expression, except that if the matching fails, a &lt;code&gt;try_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">평가하면 &lt;code&gt;Exprs&lt;/code&gt; 는 예외없이 성공할 무늬 &lt;code&gt;Pattern&lt;/code&gt; 순차적와 동일한 방식으로 한 결과에 대해 일치하는 &lt;code&gt;&lt;a href=&quot;#case&quot;&gt;case&lt;/a&gt;&lt;/code&gt; 일치가 실패하면 것 이외에는, 식 &lt;code&gt;try_clause&lt;/code&gt; 런타임 에러가 발생한다.</target>
        </trans-unit>
        <trans-unit id="1729265d2a1b2d02d46f2b13db7a6628cfce7401" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt; add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="translated">이벤트 핸들러 때문에에 대한 호출의 추가하면 &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt; add_sup_handler/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;InitArgs&lt;/code&gt; 은 IS &lt;code&gt;Args&lt;/code&gt; 이러한 기능의 인수입니다.</target>
        </trans-unit>
        <trans-unit id="631031b9e342940aba31e2236569e617b51e7128" translate="yes" xml:space="preserve">
          <source>If the event handler is added because of a call to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;InitArgs&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of these functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#add_sup_handler-3&quot;&gt;add_sup_handler/3&lt;/a&gt;&lt;/code&gt; 호출로 인해 이벤트 핸들러가 추가 되면 &lt;code&gt;InitArgs&lt;/code&gt; 는 이 함수 의 &lt;code&gt;Args&lt;/code&gt; 인수입니다.</target>
        </trans-unit>
        <trans-unit id="72f67e0f506eeca69ed3305947843432edc7a69d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="translated">이벤트 핸들러 때문에에 전화로 삭제 된 경우 &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;Arg&lt;/code&gt; 은 IS &lt;code&gt;Args&lt;/code&gt; 이 함수 호출의 인수입니다.</target>
        </trans-unit>
        <trans-unit id="3160cb662d43645579ff66ccf206017473a57cb3" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted because of a call to &lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;Arg&lt;/code&gt; is the &lt;code&gt;Args&lt;/code&gt; argument of this function call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#delete_handler-3&quot;&gt;delete_handler/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 에 대한 호출로 인해 이벤트 핸들러가 삭제 되면 &lt;code&gt;Arg&lt;/code&gt; 는 이 함수 호출 의 &lt;code&gt;Args&lt;/code&gt; 인수입니다.</target>
        </trans-unit>
        <trans-unit id="89ab1aecc97fe6f0f9ffea8f0aa54544b441d79d" translate="yes" xml:space="preserve">
          <source>If the event handler is deleted later, the event manager sends a message &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; to the calling process. &lt;code&gt;Reason&lt;/code&gt; is one of the following:</source>
          <target state="translated">이벤트 핸들러가 나중에 삭제되면, 이벤트 관리자는 &lt;code&gt;{gen_event_EXIT,Handler,Reason}&lt;/code&gt; 메시지 를 호출 프로세스로 보냅니다 . &lt;code&gt;Reason&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="b5a39103796e2c04d1e2ceb8b092ca0d507d8cca" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러가 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt; swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 에 대한 호출 또는 다른 콜백 함수 중 하나의 &lt;code&gt;swap&lt;/code&gt; 반환 튜플 때문에 다른 이벤트 핸들러를 대체하는 경우 &lt;code&gt;InitArgs&lt;/code&gt; 는 튜플 &lt;code&gt;{Args,Term}&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;Args&lt;/code&gt; 는 함수 호출 / 반환 튜플에 제공된 인수 및 &lt;code&gt;Term&lt;/code&gt; 은 이전 이벤트 처리기를 종료 한 결과입니다 . &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6a4d7864917b404d52d14fae5596ac8786e5389" translate="yes" xml:space="preserve">
          <source>If the event handler replaces another event handler because of a call to &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt;, or because of a &lt;code&gt;swap&lt;/code&gt; return tuple from one of the other callback functions, &lt;code&gt;InitArgs&lt;/code&gt; is a tuple &lt;code&gt;{Args,Term}&lt;/code&gt;, where &lt;code&gt;Args&lt;/code&gt; is the argument provided in the function call/return tuple and &lt;code&gt;Term&lt;/code&gt; is the result of terminating the old event handler, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러가 &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#swap_sup_handler-3&quot;&gt;swap_sup_handler/3&lt;/a&gt;&lt;/code&gt; 에 대한 호출 또는 다른 콜백 함수 중 하나의 &lt;code&gt;swap&lt;/code&gt; 리턴 튜플로 인해 다른 이벤트 핸들러를 대체하는 경우 &lt;code&gt;InitArgs&lt;/code&gt; 는 튜플 &lt;code&gt;{Args,Term}&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;Args&lt;/code&gt; 는 함수 호출 / 반환 튜플에 제공된 인수 및 &lt;code&gt;Term&lt;/code&gt; 은 이전 이벤트 핸들러를 종료 한 결과입니다 ( &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3ce21bfa638e6a6dac050034a055b97270608155" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. However, it detects this state and loses no records that are not overwritten.</source>
          <target state="translated">이벤트 로그가 자동으로 래핑되도록 구성된 경우 로그에 도착하여 &lt;code&gt;nteventlog&lt;/code&gt; 가 실행 중이 아닐 때 덮어 쓴 레코드 가 손실됩니다. 그러나이 상태를 감지하고 덮어 쓰지 않은 레코드는 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd74a922c6e5b981bbc80b4da38fda2c75c0b1ea" translate="yes" xml:space="preserve">
          <source>If the event log is configured to wrap around automatically, records that have arrived to the log and been overwritten when &lt;code&gt;nteventlog&lt;/code&gt; was not running are lost. It however detects this state and loses no records that are not overwritten.</source>
          <target state="translated">이벤트 로그가 자동으로 랩핑되도록 구성된 경우, 로그에 도착하여 &lt;code&gt;nteventlog&lt;/code&gt; 가 실행 중이 지 않을 때 겹쳐 쓴 레코드 는 손실됩니다. 그러나이 상태를 감지하고 덮어 쓰지 않은 레코드는 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1781a9137364e9b0633c2b37fb076419c90678b9" translate="yes" xml:space="preserve">
          <source>If the event manager is part of a supervision tree, no stop function is needed. The event manager is automatically terminated by its supervisor. Exactly how this is done is defined by a &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; set in the supervisor.</source>
          <target state="translated">이벤트 관리자가 감독 트리의 일부인 경우 중지 기능이 필요하지 않습니다. 이벤트 관리자는 감독자에 의해 자동으로 종료됩니다. 정확하게이 작업을 수행하는 방법 은 수퍼바이저에 설정된 &lt;code&gt;&lt;a href=&quot;sup_princ#shutdown&quot;&gt;shutdown strategy&lt;/a&gt;&lt;/code&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="23a26a698f7576e3a5781ee1ace5ea565efded8a" translate="yes" xml:space="preserve">
          <source>If the event manager is successfully created, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the event manager. If a process with the specified &lt;code&gt;EventMgrName&lt;/code&gt; exists already, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">이벤트 관리자가 작성되면 함수는 &lt;code&gt;{ok,Pid}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 이벤트 관리자의 pid입니다. 지정된 &lt;code&gt;EventMgrName&lt;/code&gt; 을 가진 프로세스 가 이미 존재하는 경우 함수는 &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Pid&lt;/code&gt; 는 해당 프로세스의 pid입니다.</target>
        </trans-unit>
        <trans-unit id="85c7349696150a1895889e8faf7c4713894d022f" translate="yes" xml:space="preserve">
          <source>If the exclusive decode function has, for example, the name &lt;code&gt;decode_exclusive&lt;/code&gt; and an ASN.1 encoded message &lt;code&gt;Bin&lt;/code&gt; is to be exclusive decoded, the call is as follows:</source>
          <target state="translated">배타적 디코딩 기능이 예를 들어, 이름 &lt;code&gt;decode_exclusive&lt;/code&gt; 및 ASN.1로 인코딩 된 메시지 &lt;code&gt;Bin&lt;/code&gt; 이 배타적 디코딩되는 경우, 호출은 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="03f0f3b2eabafa60c9e9c721aa1cad9fcc5b78a3" translate="yes" xml:space="preserve">
          <source>If the failed test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">실패한 테스트 케이스가 테스트 케이스 그룹에 속하는 경우 첫 번째 인수는 튜플 &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; 이고 그렇지 않은 경우 함수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ae5596ad95475cf2f268aa093acd0a50a12f5551" translate="yes" xml:space="preserve">
          <source>If the file contains source code (as in the example above), it is processed by the &lt;code&gt;epp&lt;/code&gt; preprocessor. This means that you, for example, can use predefined macros (such as &lt;code&gt;?MODULE&lt;/code&gt;) and include directives like the &lt;code&gt;-include_lib&lt;/code&gt; directive. For example, use</source>
          <target state="translated">파일에 소스 코드가 포함 된 경우 (위의 예와 같이) &lt;code&gt;epp&lt;/code&gt; 전처리 기에 의해 처리됩니다 . 예를 들어 &lt;code&gt;?MODULE&lt;/code&gt; 과 같은 사전 정의 된 매크로를 사용 하고 &lt;code&gt;-include_lib&lt;/code&gt; 지시문 과 같은 지시문을 포함 할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="09f7b5f0081b8333cb37ae76ae1513548332cd8c" translate="yes" xml:space="preserve">
          <source>If the file is opened in binary mode, the read bytes are returned in a binary, otherwise in a list.</source>
          <target state="translated">파일이 이진 모드로 열린 경우 읽기 바이트는 이진으로, 그렇지 않으면 목록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d43d376c036cd6704fab6602e0a821d2fca0f536" translate="yes" xml:space="preserve">
          <source>If the file is opened with &lt;code&gt;encoding&lt;/code&gt; set to something else than &lt;code&gt;latin1&lt;/code&gt;, each byte written can result in many bytes being written to the file, as the byte range 0..255 can represent anything between one and four bytes depending on value and UTF encoding type.</source>
          <target state="translated">파일이 &lt;code&gt;latin1&lt;/code&gt; 이외의 다른 &lt;code&gt;encoding&lt;/code&gt; 설정된 상태 에서 파일을 열면 바이트 범위 0..255는 값과 UTF 인코딩에 따라 1에서 4 바이트 사이를 나타낼 수 있으므로 각 바이트는 파일에 많은 바이트를 쓸 수 있습니다. 유형.</target>
        </trans-unit>
        <trans-unit id="3ff2942f4038fb71563badd19ea96ee04bc36590" translate="yes" xml:space="preserve">
          <source>If the file is read past &lt;code&gt;eof&lt;/code&gt;, only the remaining bytes are read and returned. If no bytes are read, &lt;code&gt;eof&lt;/code&gt; is returned.</source>
          <target state="translated">파일을 &lt;code&gt;eof&lt;/code&gt; 지나서 읽은 경우 나머지 바이트 만 읽고 리턴합니다. 읽은 바이트가 없으면 &lt;code&gt;eof&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0301143503899c06f595e73d4da8e12a605f082d" translate="yes" xml:space="preserve">
          <source>If the file is specified as an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;, no file is read or monitored in the future. This emulates the old behavior of not configuring the DNS client when the node is started in short name distributed mode.</source>
          <target state="translated">파일이 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 지정 되면 나중에 파일을 읽거나 모니터하지 않습니다. 이것은 짧은 이름 분산 모드에서 노드가 시작될 때 DNS 클라이언트를 구성하지 않는 이전 동작을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="f524572ea2342154f69f71b644500e15cc9901dc" translate="yes" xml:space="preserve">
          <source>If the file server of this node is not a slave, the file was opened by the file server of this node (this implies that &lt;code&gt;Pid&lt;/code&gt; must be a local pid) and the file is not closed. &lt;code&gt;Filename&lt;/code&gt; is the filename in flat string format.</source>
          <target state="translated">이 노드의 파일 서버가 슬레이브가 아닌 경우,이 노드의 파일 서버가 파일을 열어서 ( &lt;code&gt;Pid&lt;/code&gt; 가 로컬 pid 여야 함을 나타냄) 파일이 닫히지 않습니다. &lt;code&gt;Filename&lt;/code&gt; 은 플랫 문자열 형식의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="19dad8b9ff6393c913546c9bff544a5e8d858493" translate="yes" xml:space="preserve">
          <source>If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a list. The list or binary is shorter than the number of bytes requested if end of file was reached.</source>
          <target state="translated">파일이 이진 모드로 열린 경우 읽기 바이트는 이진으로, 그렇지 않으면 목록으로 반환됩니다. 파일 끝에 도달 한 경우 요청 된 바이트 수보다 목록 또는 이진이 짧습니다.</target>
        </trans-unit>
        <trans-unit id="ead416d9e5e17b9f14938d13eb799b54c7ee7032" translate="yes" xml:space="preserve">
          <source>If the file write fails (for example, &lt;code&gt;enospc&lt;/code&gt;), the command is aborted and &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; is returned. However, the file is &lt;strong&gt;not&lt;/strong&gt; removed.</source>
          <target state="translated">파일 쓰기에 실패하면 (예 : &lt;code&gt;enospc&lt;/code&gt; ) 명령이 중단되고 &lt;code&gt;{error, file_write_error_reason()}&lt;/code&gt; 이 리턴됩니다. 그러나 파일은 제거 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0c09a69dc8ebf1e91578b9796f029369abc850" translate="yes" xml:space="preserve">
          <source>If the filename &lt;code&gt;File&lt;/code&gt; is absolute (possibly after variable substitution), the include file with that name is included. Otherwise, the specified file is searched for in the following directories, and in this order:</source>
          <target state="translated">파일 이름 &lt;code&gt;File&lt;/code&gt; 이 절대 변수 인 경우 (변수 대체 후) 해당 이름의 포함 파일이 포함됩니다. 그렇지 않으면, 지정된 파일이 다음 디렉토리에서 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="f6fdb5791718e9cf14d2a9c0a809646872e636fd" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, decide if the event is allowed or not.</source>
          <target state="translated">필터가 일치하지 않으면 다른 필터 또는 구성 매개 변수 &lt;code&gt;filter_default&lt;/code&gt; 의 값이 이벤트를 허용하는지 여부를 결정하는 &lt;code&gt;ignore&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="298fc01aae2302d31a30ab2828690b737a94df8b" translate="yes" xml:space="preserve">
          <source>If the filter does not match, it returns &lt;code&gt;ignore&lt;/code&gt;, meaning that other filters, or the value of the configuration parameter &lt;code&gt;filter_default&lt;/code&gt;, will decide if the event is allowed or not.</source>
          <target state="translated">필터가 일치하지 않으면 &lt;code&gt;ignore&lt;/code&gt; 를 반환합니다 . 즉, 다른 필터 또는 구성 매개 변수 &lt;code&gt;filter_default&lt;/code&gt; 의 값이 이벤트 허용 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3e713bc836d6d924cbd200c2e55ce5f9136754b5" translate="yes" xml:space="preserve">
          <source>If the filter function returns &lt;code&gt;ignore&lt;/code&gt;, it means that it did not recognize the log event, and thus leaves to other filters to decide the event's destiny.</source>
          <target state="translated">필터 함수가 &lt;code&gt;ignore&lt;/code&gt; 를 반환 하면 로그 이벤트를 인식하지 못 했으므로 다른 필터를 사용하여 이벤트의 운명을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="957041343c23aa2d4654805ac48c48dc4fb915f8" translate="yes" xml:space="preserve">
          <source>If the filter has the form &lt;code&gt;{Key, RegExp, re}&lt;/code&gt;, the report must contain an element with key equal to &lt;code&gt;Key&lt;/code&gt; and the value must match the regular expression &lt;code&gt;RegExp&lt;/code&gt;.</source>
          <target state="translated">필터의 형식이 &lt;code&gt;{Key, RegExp, re}&lt;/code&gt; 인 경우 보고서에는 &lt;code&gt;Key&lt;/code&gt; 와 Key가 같은 요소가 포함 되어야하며 값은 정규식 &lt;code&gt;RegExp&lt;/code&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e1184361ce4e087a6b4dd8211b45d80ed4f9e48" translate="yes" xml:space="preserve">
          <source>If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the log event is allowed. If the filter matches and &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the log event is stopped.</source>
          <target state="translated">필터가 일치하고 &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt; 인 경우 로그 이벤트가 허용됩니다. 필터가 일치하고 &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt; 인 경우 로그 이벤트가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="32e9da768719e8b90b1faba156fc380cf35dffea" translate="yes" xml:space="preserve">
          <source>If the final string is too long, it is truncated according to the value of configuration parameter &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최종 문자열이 너무 길면 구성 매개 변수 &lt;code&gt;&lt;a href=&quot;#max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt; 의 값에 따라 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="42b76af1133577086d028a4fb0a1a30d07e3d9f8" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt; erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="translated">플래그가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 데이터가 정수 목록으로 반환됩니다. 기본 버퍼를 사용하거나 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt; erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt; 로 할당 된 더 큰 버퍼를 가리 키도록 &lt;code&gt;*rbuf&lt;/code&gt; 를 설정하십시오 . &lt;code&gt;control&lt;/code&gt; 가 반환 된 후 버퍼가 자동으로 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6ebf0a745164970b389f3300cbccd27f4b3b5d3" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;0&lt;/code&gt;, data is returned as a list of integers. Either use the default buffer or set &lt;code&gt;*rbuf&lt;/code&gt; to point to a larger buffer allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt;. The buffer is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned.</source>
          <target state="translated">플래그가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 데이터는 정수 목록으로 리턴됩니다. 기본 버퍼를 사용하거나 &lt;code&gt;*rbuf&lt;/code&gt; 를 설정 하여 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc&quot;&gt;erl_driver:driver_alloc&lt;/a&gt;&lt;/code&gt; 과 함께 할당 된 더 큰 버퍼를 가리 킵니다 . &lt;code&gt;control&lt;/code&gt; 가 리턴 된 후 버퍼가 자동으로 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c08f7138ffb7c0800eaee0ee64686780f8678ed" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt; erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt; erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt; erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">플래그가 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; 로 설정 되면 바이너리가 반환됩니다. 원시 데이터를 기본 버퍼에 기록하여 작은 바이너리를 반환 할 수 있습니다. 바이너리는 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt; erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 로 할당 된 바이너리를 가리 키도록 &lt;code&gt;*rbuf&lt;/code&gt; 를 설정하여 반환 할 수도 있습니다 . 이 바이너리는 &lt;code&gt;control&lt;/code&gt; 가 반환 된 후 자동으로 해제됩니다 . 드라이버의 바이너리 유지할 수 &lt;strong&gt;읽기 전용&lt;/strong&gt; 으로 액세스 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt; erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; 나중에 해제 할 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt; erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt; 를 . &lt;code&gt;control&lt;/code&gt; 이 반환 된 후에는 바이너리를 변경할 수 없습니다 . &lt;code&gt;*rbuf&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 로 설정된 경우&lt;strong&gt;&lt;/strong&gt;, 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3fdf06cbeca702cf9635bd5a2282dbe52c9f9489" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt;, a binary is returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting &lt;code&gt;*rbuf&lt;/code&gt; to point to a binary allocated with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt;. This binary is freed automatically after &lt;code&gt;control&lt;/code&gt; has returned. The driver can retain the binary for &lt;strong&gt;read only&lt;/strong&gt; access with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; to be freed later with &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt;. It is never allowed to change the binary after &lt;code&gt;control&lt;/code&gt; has returned. If &lt;code&gt;*rbuf&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">플래그가 &lt;code&gt;PORT_CONTROL_FLAG_BINARY&lt;/code&gt; 로 설정 되면 이진이 반환됩니다. 원시 데이터를 기본 버퍼에 기록하여 작은 이진 파일을 반환 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;erl_driver#driver_alloc_binary&quot;&gt;erl_driver:driver_alloc_binary&lt;/a&gt;&lt;/code&gt; 로 할당 된 이진을 가리 키도록 &lt;code&gt;*rbuf&lt;/code&gt; 를 설정 하여 이진을 반환 할 수도 있습니다 . 이 바이너리는 &lt;code&gt;control&lt;/code&gt; 이 반환 된 후 자동으로 해제됩니다 . 드라이버는 나중에 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_free_binary&quot;&gt;erl_driver:driver_free_binary&lt;/a&gt;&lt;/code&gt; 로 해제되도록 &lt;code&gt;&lt;a href=&quot;erl_driver#driver_binary_inc_refc&quot;&gt;erl_driver:driver_binary_inc_refc&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;strong&gt;읽기 전용&lt;/strong&gt; 액세스를 위해 바이너리를 유지할 수 있습니다 . &lt;code&gt;control&lt;/code&gt; 가 리턴 된 후에는 2 진을 변경할 수 없습니다 . &lt;code&gt;*rbuf&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 로 설정된 경우&lt;strong&gt;&lt;/strong&gt;빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba4d8831063581aeb6c792a1b032f97e23a799b0" translate="yes" xml:space="preserve">
          <source>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject:</source>
          <target state="translated">&quot;a&quot;또는 &quot;b&quot;로 시작하지 않는 문자열에 다음 패턴이 적용되면 일반적으로 제목의 시작 부분에있는 빈 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f145ecc5627d0896817e500b5d377db659310775" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt; check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="translated">포맷터 모듈이 선택적 콜백 함수 &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt; check_config(FConfig)&lt;/a&gt;&lt;/code&gt; 로거는 포맷터 정보가 설정되거나 수정 될 때이 함수를 호출하여 포맷터 구성의 유효성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2009a1faa40085a7c2fd996ec540bc12d65d8f07" translate="yes" xml:space="preserve">
          <source>If the formatter module exports the optional callback function &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt;, Logger calls this function when the formatter information is set or modified, to verify the validity of the formatter configuration.</source>
          <target state="translated">포맷터 모듈이 선택적 콜백 함수 &lt;code&gt;&lt;a href=&quot;logger#FModule:check_config-1&quot;&gt;check_config(FConfig)&lt;/a&gt;&lt;/code&gt; 로거는 포맷터 정보가 설정되거나 수정 될 때이 함수를 호출하여 포맷터 구성의 유효성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="05f7a6a810b002e4a0681949501258c2a927f78c" translate="yes" xml:space="preserve">
          <source>If the fragment option is &lt;code&gt;true&lt;/code&gt;, the URI fragment is returned as part of the parsing result, otherwise it is ignored.</source>
          <target state="translated">fragment 옵션이 &lt;code&gt;true&lt;/code&gt; 의 경우, URI fragment는 해석 결과의 일부로서 돌려 주어집니다. 그렇지 않은 경우는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f39219b3544f3ad6a57e7c4b45e2e83b08a49c" translate="yes" xml:space="preserve">
          <source>If the fully connected network is not set up properly, try first to increase the value of &lt;code&gt;net_setuptime&lt;/code&gt;.</source>
          <target state="translated">완전히 연결된 네트워크가 올바르게 설정되지 않은 경우 먼저 &lt;code&gt;net_setuptime&lt;/code&gt; 값을 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="e9be0c3ab255377067e7c9ca15639a8fa64c8dbb" translate="yes" xml:space="preserve">
          <source>If the fun/3 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="translated">fun / 3가 사용되는 경우 실제 인증이 발생할 때 호출되므로 시간, 원격 IP 등과 같은 동적 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6e0071d7a3ba398410b3a04cc87132cfab9e23" translate="yes" xml:space="preserve">
          <source>If the fun/3 or fun/4 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</source>
          <target state="translated">fun / 3 또는 fun / 4를 사용하는 경우 실제 인증이 발생할 때 호출되므로 시간, 원격 IP 등과 같은 동적 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a10d9917bf561ed6546055b4ad6ae668ede9a486" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;mnesia:table_info/2&lt;/code&gt; is started in the activity context of module &lt;code&gt;mnesia_frag&lt;/code&gt;, information of several new items can be obtained:</source>
          <target state="translated">함수 경우 &lt;code&gt;mnesia:table_info/2&lt;/code&gt; 모듈의 활성 컨텍스트에서 시작 &lt;code&gt;mnesia_frag&lt;/code&gt; 여러 새로운 항목 정보를 얻을 수있다 :</target>
        </trans-unit>
        <trans-unit id="b7b2e6d233f123be817d60a836703d289792c0af" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;print_name/1&lt;/code&gt;, and so on, had been interface functions, the situation would have been different, as you do not want the user of the interface to know about the internal data representation.</source>
          <target state="translated">&lt;code&gt;print_name/1&lt;/code&gt; 등 의 함수 가 인터페이스 함수 인 경우 인터페이스 사용자가 내부 데이터 표현에 대해 알지 못하게되므로 상황이 달라졌을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac91618962c7d06d3c9f00caac895bd89a410ca3" translate="yes" xml:space="preserve">
          <source>If the function is called, it will be called again with &lt;code&gt;undo&lt;/code&gt;, or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">함수가 호출되면 &lt;code&gt;undo&lt;/code&gt; 또는 첫 번째 인수 로 &lt;code&gt;set&lt;/code&gt; 하여 다시 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="40c262c2c2a844d0cf26a7433449f15feea3fd0e" translate="yes" xml:space="preserve">
          <source>If the function is found, the function clauses are scanned sequentially until a clause is found that fulfills both of the following two conditions:</source>
          <target state="translated">함수가 발견되면 다음 두 조건을 모두 충족하는 절이 발견 될 때까지 함수 절이 순차적으로 스캔됩니다.</target>
        </trans-unit>
        <trans-unit id="c5c83cab902e2b61262a72c526eeaa77228c4460" translate="yes" xml:space="preserve">
          <source>If the function is rewritten as follows, the compiler is free to rearrange the clauses:</source>
          <target state="translated">함수가 다음과 같이 다시 작성되면 컴파일러는 절을 자유롭게 재 배열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b63119293c0f8660be248a19b2479210b58e3c5a" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;ignore&lt;/code&gt;, then it is assumed that either:</source>
          <target state="translated">함수가 &lt;code&gt;ignore&lt;/code&gt; 를 반환 하면 다음 중 하나를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d3d840a1e8e533a047b65414d5bcef0d60c4bcbd" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{cancel, Reason}&lt;/code&gt;, this means the transport module decided not to send the message. This is &lt;strong&gt;not&lt;/strong&gt; an error. No error messages will be issued and no error counters incremented. What actions this will result in depends on what kind of message was sent.</source>
          <target state="translated">함수가 &lt;code&gt;{cancel, Reason}&lt;/code&gt; 리턴 하면 이는 전송 모듈이 메시지를 보내지 않기로 결정했음을 의미합니다. 이것은 오류 가 &lt;strong&gt;아닙니다&lt;/strong&gt; . 오류 메시지가 발행되지 않으며 오류 카운터가 증가하지 않습니다. 어떤 결과가 발생했는지는 어떤 종류의 메시지가 전송되었는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7fa5ac3ae4df99fa5b9b2dd8db96506aecf3fefc" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release.</source>
          <target state="translated">함수가 &lt;code&gt;{error,Reason}&lt;/code&gt; 을 리턴 하면 진행중인 업그레이드가 실패하고 이전 릴리스로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="cace8ed5fbcae8411e61d141c38b3af395942b38" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; can not be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="translated">함수가 실패 &lt;code&gt;Reason&lt;/code&gt; 리턴 하면 진행중인 업그레이드가 실패하고 이전 릴리스로 롤백됩니다. 참고 그 &lt;code&gt;Reason&lt;/code&gt; 수없는 &lt;code&gt;{ok,_,_}&lt;/code&gt; 이 보낸 튜플은 간주한다 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; 튜플 및 튜플 일치가 &lt;code&gt;{ok,_}&lt;/code&gt; 무효 실패 인 &lt;code&gt;Reason&lt;/code&gt; . 원자 는 &lt;code&gt;{error,Reason}&lt;/code&gt; 튜플에 싸여 있기 때문에 &lt;code&gt;Reason&lt;/code&gt; 으로 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c37aef2f6cca5a5ce8aa9a711a7c69aab7ee274a" translate="yes" xml:space="preserve">
          <source>If the function returns a failure &lt;code&gt;Reason&lt;/code&gt;, the ongoing upgrade fails and rolls back to the old release. Note that &lt;code&gt;Reason&lt;/code&gt; cannot be an &lt;code&gt;{ok,_,_}&lt;/code&gt; tuple since that will be regarded as a &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; tuple, and that a tuple matching &lt;code&gt;{ok,_}&lt;/code&gt; is an also invalid failure &lt;code&gt;Reason&lt;/code&gt;. It is recommended to use an atom as &lt;code&gt;Reason&lt;/code&gt; since it will be wrapped in an &lt;code&gt;{error,Reason}&lt;/code&gt; tuple.</source>
          <target state="translated">함수가 failure &lt;code&gt;Reason&lt;/code&gt; 을 반환 하면 진행중인 업그레이드가 실패하고 이전 릴리스로 롤백됩니다. 참고 그 &lt;code&gt;Reason&lt;/code&gt; 수없는 &lt;code&gt;{ok,_,_}&lt;/code&gt; 이 보낸 튜플은 간주한다 &lt;code&gt;{ok,NewState,NewData}&lt;/code&gt; 튜플 및 튜플 일치가 &lt;code&gt;{ok,_}&lt;/code&gt; 무효 실패 인 &lt;code&gt;Reason&lt;/code&gt; . 원자 는 &lt;code&gt;{error,Reason}&lt;/code&gt; 튜플에 래핑 되므로 &lt;code&gt;Reason&lt;/code&gt; 으로 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="23b279a0456aa090aac1cc8d9973e0efdd61b891" translate="yes" xml:space="preserve">
          <source>If the function returns anything else, the test case is considered successful. The return value always gets printed in the test case log file.</source>
          <target state="translated">함수가 다른 것을 반환하면 테스트 사례가 성공한 것으로 간주됩니다. 리턴 값은 항상 테스트 케이스 로그 파일에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f7a01fb7804d1dc8b9d59f7e2487cb33130c4689" translate="yes" xml:space="preserve">
          <source>If the functionality of a long-running NIF can be split so that its work can be achieved through a series of shorter NIF calls, the application has two options:</source>
          <target state="translated">장기간 실행되는 NIF의 기능을 분할하여 일련의 더 짧은 NIF 호출을 통해 작업을 수행 할 수있는 경우, 응용 프로그램에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5aec2652bfb4fd0698f0092b5faec8c5e7749c" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;ebin&lt;/code&gt;, modules (BEAM files) are searched for in that directory, otherwise modules are searched for in the given directory.</source>
          <target state="translated">지정된 디렉토리에 &lt;code&gt;ebin&lt;/code&gt; 이라는 서브 디렉토리가 있으면 해당 디렉토리 에서 모듈 (BEAM 파일)을 검색하고, 그렇지 않으면 지정된 디렉토리에서 모듈을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="206b9b6e0e97d510493a5ac088ad8e22427aae29" translate="yes" xml:space="preserve">
          <source>If the given directory has a subdirectory named &lt;code&gt;lib&lt;/code&gt;, the directories in that directory are assumed to be application directories, otherwise all subdirectories of the given directory are assumed to be application directories. If there are several versions of some application, the one with the highest version is chosen.</source>
          <target state="translated">지정된 디렉토리에 &lt;code&gt;lib&lt;/code&gt; 라는 서브 디렉토리가있는 경우 해당 디렉토리의 디렉토리는 응용 프로그램 디렉토리로 간주되며, 그렇지 않으면 주어진 디렉토리의 모든 서브 디렉토리는 응용 프로그램 디렉토리로 간주됩니다. 일부 응용 프로그램의 여러 버전이있는 경우 가장 높은 버전의 응용 프로그램이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="33fb4bc732c4bac52e2f3ecc8dc02b6458e5f64a" translate="yes" xml:space="preserve">
          <source>If the global name server fails to connect nodes (&lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N3&lt;/code&gt; in the example), a warning event is sent to the error logger. The presence of such an event does not exclude the nodes to connect later (you can, for example, try command &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; in the Erlang shell), but it indicates a network problem.</source>
          <target state="translated">글로벌 이름 서버가 노드 연결에 실패하면 ( 예 : &lt;code&gt;N1&lt;/code&gt; 및 &lt;code&gt;N3&lt;/code&gt; ) 경고 이벤트가 오류 로거로 전송됩니다. 이러한 이벤트가 &lt;code&gt;rpc:call(N1, net_adm, ping, [N2])&lt;/code&gt; 나중에 연결할 노드를 제외하지는 않습니다 (예를 들어 Erlang 쉘에서 rpc : call (N1, net_adm, ping, [N2] 명령을 시도 할 수 있음). 네트워크 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="90420c92850a1634589e73fa3152ae2df519947e" translate="yes" xml:space="preserve">
          <source>If the guard test &lt;code&gt;is_integer(Int)&lt;/code&gt; succeeds, the fourth clause is executed.</source>
          <target state="translated">가드 테스트 &lt;code&gt;is_integer(Int)&lt;/code&gt; 가 성공하면 네 번째 절이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="51156ed0f0b60bdec0db2a3c5c342e77e9337761" translate="yes" xml:space="preserve">
          <source>If the guard test fails, the input value is compared to &lt;code&gt;four&lt;/code&gt;, &lt;code&gt;five&lt;/code&gt;, and &lt;code&gt;six&lt;/code&gt;, and the appropriate clause is selected. (There is a &lt;code&gt;function_clause&lt;/code&gt; exception if none of the values matched.)</source>
          <target state="translated">가드 테스트가 실패하면 입력 값이 &lt;code&gt;four&lt;/code&gt; , &lt;code&gt;five&lt;/code&gt; 및 &lt;code&gt;six&lt;/code&gt; 과 비교되고 적절한 절이 선택됩니다. ( 값이 일치하지 않으면 &lt;code&gt;function_clause&lt;/code&gt; 예외 가 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="042ae23e884f62c0355d18895948d09799091a5c" translate="yes" xml:space="preserve">
          <source>If the handler is meant to replace the default handler, the Kernel's default handler have to be disabled before the new handler is added. A &lt;code&gt;sys.config&lt;/code&gt; file that disables the Kernel handler and adds a custom handler could look like this:</source>
          <target state="translated">핸들러가 기본 핸들러를 대체하려는 경우 새 핸들러를 추가하기 전에 커널의 기본 핸들러를 비활성화해야합니다. &lt;code&gt;sys.config&lt;/code&gt; 커널 핸들러를 비활성화하고 같이 할 수있는 사용자 정의 핸들러를 추가 파일 :</target>
        </trans-unit>
        <trans-unit id="65f1827df55837b13a3b7ed59d4d8ea4a1983d32" translate="yes" xml:space="preserve">
          <source>If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value &lt;code&gt;infinity&lt;/code&gt; prevents restarts.</source>
          <target state="translated">핸들러가 종료되면 밀리 초 단위로 지정된 지연 후에 자동으로 다시 시작됩니다. &lt;code&gt;infinity&lt;/code&gt; 값은 재시작을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="b7ef0ec4d5b98a48302f9d89b544d31dce7e98f5" translate="yes" xml:space="preserve">
          <source>If the handler process is terminated because of overload, it prints information about it in the log. It also prints information about when a restart has taken place, and the handler is back in action.</source>
          <target state="translated">과부하로 인해 처리기 프로세스가 종료되면 로그에 처리기 정보를 인쇄합니다. 또한 재시작이 발생한 시점에 대한 정보를 인쇄하고 핸들러가 다시 작동합니다.</target>
        </trans-unit>
        <trans-unit id="71ca4e1b2a57423c539bf11275ee92c1598c8e04" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to listen on.</source>
          <target state="translated">호스트에 많은 네트워크 인터페이스가있는 경우이 옵션은 수신 할 네트워크 인터페이스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5938c2bcb45adfa6db096780d07c1f69ca15570f" translate="yes" xml:space="preserve">
          <source>If the host has many network interfaces, this option specifies which one to use.</source>
          <target state="translated">호스트에 많은 네트워크 인터페이스가있는 경우이 옵션은 사용할 인터페이스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7a3654ae9fae9da43a3b1501da91842a28524e6b" translate="yes" xml:space="preserve">
          <source>If the included application itself contains included applications, instead the &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; option must be included.</source>
          <target state="translated">포함 된 응용 프로그램 자체에 포함 된 응용 프로그램이 포함 된 경우 &lt;code&gt;{mod, {application_starter, [Module,StartArgs]}}&lt;/code&gt; 옵션을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="93280124390abf78f821c80eb86f0bf50631ec9d" translate="yes" xml:space="preserve">
          <source>If the initial call is to one of the system-defined behaviors such as &lt;code&gt;gen_server&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;, it is translated to more useful information. If a &lt;code&gt;gen_server&lt;/code&gt; is spawned, the returned &lt;code&gt;Module&lt;/code&gt; is the name of the callback module and &lt;code&gt;Function&lt;/code&gt; is &lt;code&gt;init&lt;/code&gt; (the function that initiates the new server).</source>
          <target state="translated">초기 호출이 &lt;code&gt;gen_server&lt;/code&gt; 또는 &lt;code&gt;gen_event&lt;/code&gt; 와 같은 시스템 정의 동작 중 하나에 대한 호출 인 경우 더 유용한 정보로 변환됩니다. 경우 &lt;code&gt;gen_server&lt;/code&gt; 는 스폰되어, 반환 &lt;code&gt;Module&lt;/code&gt; 콜백 모듈의 이름과 &lt;code&gt;Function&lt;/code&gt; 있다 &lt;code&gt;init&lt;/code&gt; (기능이 시작하는 새로운 서버).</target>
        </trans-unit>
        <trans-unit id="e36a8cae40a2ccda598cbf83afe268a5c720aa0e" translate="yes" xml:space="preserve">
          <source>If the initial encode of the outgoing request fails, then the request process fails and &lt;code&gt;{error,encode}&lt;/code&gt; is returned.</source>
          <target state="translated">발신 요청의 초기 인코딩이 실패하면 요청 프로세스가 실패하고 &lt;code&gt;{error,encode}&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="512a1cbc51d5459f85caaea2fd4bfade04f37668" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{error,Error}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">초기화에 실패하면 함수는 &lt;code&gt;{error,Error}&lt;/code&gt; 를 리턴 하며 여기서 &lt;code&gt;Error&lt;/code&gt; 는 임의의 용어이거나 &lt;code&gt;ignore&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4efffcc1b527bd1b225e810cb600a2ae77401619" translate="yes" xml:space="preserve">
          <source>If the initialization fails, the function is to return &lt;code&gt;{stop,Reason}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is any term, or &lt;code&gt;ignore&lt;/code&gt;.</source>
          <target state="translated">초기화에 실패하면 함수는 &lt;code&gt;{stop,Reason}&lt;/code&gt; 을 리턴 하며, 여기서 &lt;code&gt;Reason&lt;/code&gt; 은 임의의 용어이거나 &lt;code&gt;ignore&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9346621e797dd1360944a672ab82ead28612c984" translate="yes" xml:space="preserve">
          <source>If the initialization is successful, the function is to return &lt;code&gt;{ok,State}&lt;/code&gt;, &lt;code&gt;{ok,State,Timeout}&lt;/code&gt;, or &lt;code&gt;{ok,State,hibernate}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt; process.</source>
          <target state="translated">초기화에 성공하면 함수는 &lt;code&gt;{ok,State}&lt;/code&gt; , &lt;code&gt;{ok,State,Timeout}&lt;/code&gt; 또는 &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; 를 리턴 하며 여기서 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;gen_server&lt;/code&gt; 프로세스 의 내부 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="fc28d6116f22c2a3f33906970ce46ac4053da35d" translate="yes" xml:space="preserve">
          <source>If the input encoding is not UTF-8, an error tuple is returned.</source>
          <target state="translated">입력 인코딩이 UTF-8이 아닌 경우 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eddc615bd88d8608ab31b9841323633dc12870aa" translate="yes" xml:space="preserve">
          <source>If the installation fails, the system can be rebooted. The old release version is then automatically used.</source>
          <target state="translated">설치가 실패하면 시스템을 재부팅 할 수 있습니다. 그러면 이전 릴리스 버전이 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e9d4940ae270a2841d572606f563a099b85e09" translate="yes" xml:space="preserve">
          <source>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</source>
          <target state="translated">설치가 성공하면 새 버전이 기본 버전이되며 시스템 재부팅이있을 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="08dbb0e86d47275a0a4e636be8892780b15448e3" translate="yes" xml:space="preserve">
          <source>If the instruction appears after instruction &lt;code&gt;point_of_no_return&lt;/code&gt; and the function call fails, the system is restarted.</source>
          <target state="translated">명령 &lt;code&gt;point_of_no_return&lt;/code&gt; 뒤에 명령이 나타나고 함수 호출이 실패하면 시스템이 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="efab2c6cbaff99e6149cda9413164011c49b633d" translate="yes" xml:space="preserve">
          <source>If the instruction appears before instruction &lt;code&gt;point_of_no_return&lt;/code&gt;, a failure is caught. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; then returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt;, unless &lt;code&gt;{error,Error}&lt;/code&gt; is thrown or returned. Then it returns &lt;code&gt;{error,Error}&lt;/code&gt;.</source>
          <target state="translated">명령이 &lt;code&gt;point_of_no_return&lt;/code&gt; 명령 앞에 나타나면 실패가 포착됩니다. &lt;code&gt;&lt;a href=&quot;release_handler#install_release-1&quot;&gt;release_handler:install_release/1&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;{error,Error}&lt;/code&gt; 가 발생하거나 리턴 되지 않는 한 {error, &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; 리턴합니다. 그런 다음 &lt;code&gt;{error,Error}&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6accd78db997b4f0cc8c3eb17cc0cfe9969dd581" translate="yes" xml:space="preserve">
          <source>If the instrumentation functions communicate with UNIX processes, it might be a good idea to use a special sub-agent. This sub-agent sends the SNMP request to the other process in one packet in order to minimize context switches. For example, if a whole MIB is implemented on the C level in UNIX, but you still want to use the Erlang SNMP tool, then you may have one special sub-agent, which sends the variables in the request as a single operation down to C.</source>
          <target state="translated">인스 트루먼 테이션 기능이 UNIX 프로세스와 통신하는 경우 특수 서브 에이전트를 사용하는 것이 좋습니다. 이 서브 에이전트는 컨텍스트 전환을 최소화하기 위해 한 패킷의 다른 프로세스에 SNMP 요청을 보냅니다. 예를 들어, 전체 MIB가 UNIX의 C 레벨에서 구현되었지만 여전히 Erlang SNMP 도구를 사용하려는 경우 요청에 변수를 단일 조작으로 전송하는 하나의 특수 서브 에이전트가있을 수 있습니다. 씨.</target>
        </trans-unit>
        <trans-unit id="6073ddc2f6ff51455fef10943643ff33d4a41b31" translate="yes" xml:space="preserve">
          <source>If the key attribute is bound in a pattern, the match operation is efficient. However, if the key attribute in a pattern is given as &lt;code&gt;'_'&lt;/code&gt; or &lt;code&gt;'$1'&lt;/code&gt;, the whole &lt;code&gt;employee&lt;/code&gt; table must be searched for records that match. Hence if the table is large, this can become a time-consuming operation, but it can be remedied with indexes (see &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt;) if the function &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">키 속성이 패턴으로 바인드 된 경우 일치 조작이 효율적입니다. 그러나 패턴의 키 속성이 &lt;code&gt;'_'&lt;/code&gt; 또는 &lt;code&gt;'$1'&lt;/code&gt; 이면 전체 &lt;code&gt;employee&lt;/code&gt; 테이블에서 일치하는 레코드를 검색해야합니다. 따라서 테이블이 크면 시간이 많이 걸리는 작업이 될 수 있지만 &lt;code&gt;&lt;a href=&quot;mnesia#match_object-1&quot;&gt;mnesia:match_object&lt;/a&gt;&lt;/code&gt; 함수 가 사용되는 경우 인덱스 ( &lt;code&gt;&lt;a href=&quot;mnesia_chap5#indexing&quot;&gt;Indexing&lt;/a&gt;&lt;/code&gt; 참조 ) 로 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="702da889833ee1dc6797c2ff9a6559f2d21f93ff" translate="yes" xml:space="preserve">
          <source>If the key is specified in the pattern, the match is very efficient. If the key is not specified, that is, if it is a variable or an underscore, the entire table must be searched. The search time can be substantial if the table is very large.</source>
          <target state="translated">키가 패턴에 지정되면 일치가 매우 효율적입니다. 키가 지정되지 않은 경우, 즉 변수 또는 밑줄 인 경우 전체 테이블을 검색해야합니다. 테이블이 매우 큰 경우 검색 시간이 상당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="006f97d543b8ad5e428fa64fac1606142a9e3339" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to all objects of the table with the correct key(s). If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always handled at the same time, which implies that the match specification can be applied to more than N objects.</source>
          <target state="translated">의 keypos'th 요소 경우 &lt;code&gt;MatchSpec&lt;/code&gt; 가 결합되어, 경기 사양은 정확한 키 (들) 테이블의 모든 객체에 적용됩니다. keypos'th 소자의 경우 &lt;code&gt;MatchSpec&lt;/code&gt; 가 언 바운드, 매치 사양은 테이블의 모든 물체에 적용되며, &lt;code&gt;N&lt;/code&gt; 은 적어도 하나의 오브젝트가 일치 테이블의 끝에 도달 할 때까지 한 번에 개체. 제공하여 표시된 기본, &lt;code&gt;N&lt;/code&gt; 에게 값의 &lt;code&gt;default&lt;/code&gt; , 객체의 수는 개체의 크기에 따라 달라집니다 수 있도록하는 것입니다. 동일한 키를 가진 모든 객체는 항상 동시에 처리되므로 일치 사양을 N 개 이상의 객체에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b16233e004fe373963364905dc9a2ad762556f0" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">의 keypos'th 요소 경우 &lt;code&gt;MatchSpec&lt;/code&gt; 가 결합되어, 경기 사양은 정확한 키 (들)을 가진 개체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f90ff4fedc7cf136ced2894c42e307fbd5a5c73b" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;MatchSpec&lt;/code&gt; is unbound, the match specification is applied to all objects of the table. If the keypos'th element is bound, the match specification is applied to the objects with the correct key(s) only.</source>
          <target state="translated">의 keypos'th 요소 경우 &lt;code&gt;MatchSpec&lt;/code&gt; 는 언 바운드, 경기 사양은 테이블의 모든 객체에 적용됩니다. keypos'th 요소가 바인드되면 일치 스펙이 올바른 키를 가진 오브젝트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c802fc2a3fde97f62fdbabfc7b66189e18b5dfc7" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All matching objects with the same key are always returned in the same reply, which implies that more than N objects can sometimes be returned.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 의 키 포스 요소 가 바인드 된 경우 모든 테이블 오브젝트가 일치합니다. keypos'th 요소가 바인드되지 않은 경우, 하나 이상의 오브젝트가 일치하거나 테이블의 끝에 도달 할 때까지 한 번에 &lt;code&gt;N&lt;/code&gt; 개의 오브젝트가 모두 일치합니다. 제공하여 표시된 기본, &lt;code&gt;N&lt;/code&gt; 에게 값의 &lt;code&gt;default&lt;/code&gt; , 객체의 수는 개체의 크기에 따라 달라집니다 수 있도록하는 것입니다. 동일한 키를 가진 일치하는 모든 객체는 항상 동일한 응답으로 반환되므로 N 개 이상의 객체가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8399b71f2614d1c169eead97f1d70700fb4b6e" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, all table objects are matched. If the keypos'th element is unbound, all table objects are matched, &lt;code&gt;N&lt;/code&gt; objects at a time, until at least one object matches or the end of the table is reached. The default, indicated by giving &lt;code&gt;N&lt;/code&gt; the value &lt;code&gt;default&lt;/code&gt;, is to let the number of objects vary depending on the sizes of the objects. All objects with the same key are always matched at the same time, which implies that more than N objects can sometimes be matched.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 의 키 포스 요소 가 바인드 된 경우 모든 테이블 오브젝트가 일치합니다. keypos'th 요소가 바인드되지 않은 경우, 하나 이상의 오브젝트가 일치하거나 테이블의 끝에 도달 할 때까지 한 번에 &lt;code&gt;N&lt;/code&gt; 개의 오브젝트가 모두 일치합니다. 제공하여 표시된 기본, &lt;code&gt;N&lt;/code&gt; 에게 값의 &lt;code&gt;default&lt;/code&gt; , 객체의 수는 개체의 크기에 따라 달라집니다 수 있도록하는 것입니다. 동일한 키를 가진 모든 객체는 항상 동시에 일치하므로 N 개 이상의 객체를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81cd44a63c897e4a4fbbf303d633ae129d55b04f" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 의 keypos'th 요소 가 바인드되면 올바른 키를 가진 오브젝트 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="519fdb3cbbeb8df2c304203d27f11912d501b21d" translate="yes" xml:space="preserve">
          <source>If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is unbound, all table objects are matched. If the keypos'th element of &lt;code&gt;Pattern&lt;/code&gt; is bound, only the objects with the correct key are matched.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 의 키 포스 요소 가 바인드되지 않은 경우 모든 테이블 오브젝트가 일치합니다. &lt;code&gt;Pattern&lt;/code&gt; 의 keypos'th 요소 가 바인드되면 올바른 키를 가진 오브젝트 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="56e84a693998be360a017f2de3532689d94a7f87" translate="yes" xml:space="preserve">
          <source>If the last expression of a function body is a function call, a &lt;strong&gt;tail recursive&lt;/strong&gt; call is done. This is to ensure that no system resources, for example, call stack, are consumed. This means that an infinite loop can be done if it uses tail-recursive calls.</source>
          <target state="translated">함수 본문의 마지막 표현식이 함수 호출이면 &lt;strong&gt;꼬리 재귀&lt;/strong&gt; 호출이 수행됩니다. 이것은 호출 스택과 같은 시스템 자원이 소비되지 않도록하기위한 것입니다. 이는 꼬리 재귀 호출을 사용하는 경우 무한 루프를 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9ae06ba70f228c8b154f39f0df23503609bcb3bd" translate="yes" xml:space="preserve">
          <source>If the length of the message queue grows larger than this threshold, a flush (delete) operation takes place. To flush events, the handler discards the messages in the message queue by receiving them in a loop without logging. Client processes waiting for a response from a synchronous log request receive a reply from the handler indicating that the request is dropped. The handler process increases its priority during the flush loop to make sure that no new events are received during the operation. Notice that after the flush operation is performed, the handler prints information in the log about how many events have been deleted.</source>
          <target state="translated">메시지 큐 길이가이 임계 값보다 커지면 플러시 (삭제) 작업이 수행됩니다. 이벤트를 플러시하기 위해 핸들러는 로깅없이 루프에서 메시지를 수신하여 메시지 큐에서 메시지를 버립니다. 동기식 로그 요청의 응답을 기다리는 클라이언트 프로세스는 요청이 삭제되었음을 나타내는 응답을 핸들러로부터 수신합니다. 처리 중에 새 이벤트가 수신되지 않도록 플러시 루프 동안 처리기 프로세스의 우선 순위가 높아집니다. 플러시 작업이 수행 된 후 처리기는 삭제 된 이벤트 수에 대한 정보를 로그에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d10dfdc12d1915667ccceb0a8869e7352174a1a5" translate="yes" xml:space="preserve">
          <source>If the level for &lt;code&gt;mymodule&lt;/code&gt; is now set to &lt;code&gt;debug&lt;/code&gt;, then debug events from this module will be logged by the handler &lt;code&gt;h2&lt;/code&gt;, but not by handler &lt;code&gt;h1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mymodule&lt;/code&gt; 의 레벨 이 이제 &lt;code&gt;debug&lt;/code&gt; 로 설정되면 이 모듈의 디버그 이벤트는 핸들러 &lt;code&gt;h1&lt;/code&gt; 이 아닌 핸들러 &lt;code&gt;h2&lt;/code&gt; 에 의해 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="57aa00c976a435bf8bda5a05ad6230ef4e15342c" translate="yes" xml:space="preserve">
          <source>If the library path is set to &lt;code&gt;code_path&lt;/code&gt;, the set of library modules is not determined, and the &lt;code&gt;info&lt;/code&gt; functions will return empty lists of library modules.</source>
          <target state="translated">라이브러리 경로가 &lt;code&gt;code_path&lt;/code&gt; 로 설정되면 라이브러리 모듈 세트가 결정되지 않고 &lt;code&gt;info&lt;/code&gt; 함수는 빈 라이브러리 모듈 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5a12290de86cdc8197c1cbb41227356d8ad7a7f4" translate="yes" xml:space="preserve">
          <source>If the list contains more than one object with &lt;strong&gt;matching&lt;/strong&gt; keys and the table type is &lt;code&gt;set&lt;/code&gt;, one is inserted, which one is not defined. The same holds for table type &lt;code&gt;ordered_set&lt;/code&gt; if the keys &lt;strong&gt;compare equal&lt;/strong&gt;.</source>
          <target state="translated">리스트에 &lt;strong&gt;일치하는&lt;/strong&gt; 키 가있는 둘 이상의 오브젝트가 있고 테이블 유형이 &lt;code&gt;set&lt;/code&gt; 되면 하나가 삽입되고 정의되지 않은 하나가 삽입됩니다. 키가 &lt;strong&gt;equal 비교하는&lt;/strong&gt; 경우 &lt;code&gt;ordered_set&lt;/code&gt; 테이블 유형도 마찬가지 입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="306fdef74e5ed0763cd6967950f14b6cd849bc3e" translate="yes" xml:space="preserve">
          <source>If the list of applications contains core applications, i.e &lt;code&gt;erts&lt;/code&gt;, &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;stdlib&lt;/code&gt; or &lt;code&gt;sasl&lt;/code&gt;, the &lt;code&gt;Install&lt;/code&gt; script in the patched Erlang/OTP installation must be rerun.</source>
          <target state="translated">응용 프로그램 목록에 핵심 응용 프로그램 (예 : &lt;code&gt;erts&lt;/code&gt; , &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;stdlib&lt;/code&gt; 또는 &lt;code&gt;sasl&lt;/code&gt; )이 포함 된 경우 패치 된 Erlang / OTP 설치 의 &lt;code&gt;Install&lt;/code&gt; 스크립트를 다시 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5dc7d4fb91d3eb052a864414f12051609f1bc34" translate="yes" xml:space="preserve">
          <source>If the local implementation of Erlang defines &lt;code&gt;char()&lt;/code&gt; as a subset of &lt;code&gt;integer()&lt;/code&gt;, then &lt;code&gt;is_c_int(Node)&lt;/code&gt; will also yield &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Erlang의 로컬 구현이 &lt;code&gt;char()&lt;/code&gt; 을 &lt;code&gt;integer()&lt;/code&gt; 의 하위 집합으로 정의 하면 &lt;code&gt;is_c_int(Node)&lt;/code&gt; 도 &lt;code&gt;true&lt;/code&gt; 를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="8acd485e36998d865f417532aa218ed4f2b0d80e" translate="yes" xml:space="preserve">
          <source>If the local node is part of a global group, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;synced&lt;/code&gt;. If no global groups are defined, &lt;code&gt;State&lt;/code&gt; is equal to &lt;code&gt;no_conf&lt;/code&gt;.</source>
          <target state="translated">로컬 노드가 글로벌 그룹의 일부인 경우, &lt;code&gt;State&lt;/code&gt; 동일 &lt;code&gt;synced&lt;/code&gt; . 글로벌 그룹이 정의되지 않은 경우 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;no_conf&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b3dc78cf933189665aca88d0f65ce3644c34d9ac" translate="yes" xml:space="preserve">
          <source>If the log event is returned, the next filter function is called with the returned value as the first argument. That is, if a filter function modifies the log event, the next filter function receives the modified event. The value returned from the last filter function is the value that the handler callback receives.</source>
          <target state="translated">로그 이벤트가 반환되면 반환 된 값을 첫 번째 인수로 사용하여 다음 필터 함수가 호출됩니다. 즉, 필터 함수가 로그 이벤트를 수정하면 다음 필터 함수는 수정 된 이벤트를 수신합니다. 마지막 필터 함수에서 반환 된 값은 핸들러 콜백이받는 값입니다.</target>
        </trans-unit>
        <trans-unit id="d41baef54ef4b512298e69bbec24ae875c8c68a0" translate="yes" xml:space="preserve">
          <source>If the log is blocked by the closing process, the log is also unblocked.</source>
          <target state="translated">닫기 프로세스에 의해 로그가 차단되면 로그도 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="8605585ed728deb58354312d2da402db9d75ef1c" translate="yes" xml:space="preserve">
          <source>If the log is local on the current node, &lt;code&gt;Dist&lt;/code&gt; has the value &lt;code&gt;local&lt;/code&gt;, otherwise all nodes where the log is distributed are returned as a list.</source>
          <target state="translated">로그가 현재 노드에서 &lt;code&gt;local&lt;/code&gt; 인 경우 &lt;code&gt;Dist&lt;/code&gt; 값은 local 이며, 그렇지 않으면 로그가 분배 된 모든 노드가 목록으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b9bd861272d3ff7a5522d24a3e8060f05d2cf0e7" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments, or directly to a string. See the type definition of &lt;code&gt;&lt;a href=&quot;#type-report_cb&quot;&gt;report_cb()&lt;/a&gt;&lt;/code&gt;, and section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="translated">로그 메시지가 &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt; 로 지정된 경우 &lt;code&gt;report_cb&lt;/code&gt; 키는 보고서를 형식 문자열 및 인수로 또는 직접 문자열로 변환하는 fun (보고서 콜백)과 연결될 수 있습니다. 보고서 콜백에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#type-report_cb&quot;&gt;report_cb()&lt;/a&gt;&lt;/code&gt; 의 유형 정의 와 사용자 가이드의 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 섹션 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="dafa7b7f2609edae55f58fdb8dad531885491f7e" translate="yes" xml:space="preserve">
          <source>If the log message is specified as a &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;report_cb&lt;/code&gt; key can be associated with a fun (report callback) that converts the report to a format string and arguments. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the User's Guide for more information about report callbacks.</source>
          <target state="translated">로그 메시지가 &lt;code&gt;&lt;a href=&quot;#type-report&quot;&gt;report()&lt;/a&gt;&lt;/code&gt; 로 지정된 경우 &lt;code&gt;report_cb&lt;/code&gt; 키는 보고서를 형식 문자열 및 인수로 변환하는 fun (보고서 콜백)과 연관 될 수 있습니다. 보고서 콜백에 대한 자세한 내용은 사용자 안내서의 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de16ab6d2dd843eaf98a56613e46e210c0e2c90f" translate="yes" xml:space="preserve">
          <source>If the log size is decreased, for example, to save space, function &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; can be used to force the log to wrap.</source>
          <target state="translated">공간을 절약하기 위해 로그 크기를 줄이면 &lt;code&gt;&lt;a href=&quot;#inc_wrap_file-1&quot;&gt;inc_wrap_file/1&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 로그를 강제로 감쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="720cb0ae706744e4ee9df32b00d37adc564581fe" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined before the &lt;code&gt;merl.hrl&lt;/code&gt; header file is included, the parse transform used by Merl will be disabled, and in that case, the match expressions &lt;code&gt;?Q(...) = ...&lt;/code&gt;, case switches using &lt;code&gt;?Q(...)&lt;/code&gt; patterns, and automatic metavariables like &lt;code&gt;_@Tuple&lt;/code&gt; cannot be used in your code, but the Merl macros and functions still work. To do metavariable substitution, you need to use the &lt;code&gt;?Q(Text, Map)&lt;/code&gt; macro, e.g.:</source>
          <target state="translated">&lt;code&gt;merl.hrl&lt;/code&gt; 헤더 파일이 포함 되기 전에 매크로 &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; 이 정의 되면 Merl에 의해 사용되는 구문 분석 변환이 사용 불가능하게되고,이 경우 일치 표현식 &lt;code&gt;?Q(...) = ...&lt;/code&gt; 은 &lt;code&gt;?Q(...)&lt;/code&gt; 패턴 및 &lt;code&gt;_@Tuple&lt;/code&gt; 과 같은 자동 메타 변수는 코드에서 사용할 수 없지만 Merl 매크로 및 함수는 여전히 작동합니다. 메타 변수 대체를 수행하려면 &lt;code&gt;?Q(Text, Map)&lt;/code&gt; 매크로 를 사용해야합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="2f7a0ebf63b23efbe71cc89202b72b358a0f129b" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NOASSERT&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect when testing is also disabled; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">EUnit 헤더 파일이 포함되기 전에 &lt;code&gt;NOASSERT&lt;/code&gt; 매크로 가 정의 된 경우 이러한 매크로는 테스트가 비활성화 된 경우에도 영향을 미치지 않습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="146cb0ce4e92421175ea3746cf274e2455137df9" translate="yes" xml:space="preserve">
          <source>If the macro &lt;code&gt;NODEBUG&lt;/code&gt; is defined before the EUnit header file is included, these macros have no effect; see &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">EUnit 헤더 파일이 포함되기 전에 매크로 &lt;code&gt;NODEBUG&lt;/code&gt; 가 정의 된 경우 이러한 매크로는 효과가 없습니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;#Compilation_control_macros&quot;&gt;Compilation control macros&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b5a901ceceb4e69c701bf0dc03c50b6bae11f7b" translate="yes" xml:space="preserve">
          <source>If the manager is not configured to use any particular transport domain, the behaviour &lt;code&gt;handle_agent/4&lt;/code&gt; will for backwards copmpatibility reasons be called with the old &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments</source>
          <target state="translated">관리자가 특정 전송 도메인을 사용하도록 구성되지 않은 경우, 이전의 &lt;code&gt;IpAddr&lt;/code&gt; 및 &lt;code&gt;PortNumber&lt;/code&gt; 인수를 사용하여 거꾸로 copmpatibility을 위해 &lt;code&gt;handle_agent/4&lt;/code&gt; 동작 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f6efb33521a71965325da2bbd03e23ab8ae58659" translate="yes" xml:space="preserve">
          <source>If the manager tries to set the same variable many times in the same PDU, the agent is free to improvise. There is no definition which determines if the instrumentation will be called once or twice. If called once only, there is no definition that determines which of the new values is going to be supplied.</source>
          <target state="translated">관리자가 동일한 PDU에서 동일한 변수를 여러 번 설정하려고하면 에이전트가 즉흥적으로 처리 할 수 ​​있습니다. 계측이 한두 번 호출되는지 여부를 결정하는 정의는 없습니다. 한 번만 호출하면 어떤 값을 제공할지 결정하는 정의가 없습니다.</target>
        </trans-unit>
        <trans-unit id="74415b1346dd0ddc93d29cb9c0389734be028243" translate="yes" xml:space="preserve">
          <source>If the master node fails, the entire pool exits.</source>
          <target state="translated">마스터 노드가 실패하면 전체 풀이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ada210019d5db3434b3a98372ed4ed0f124b6d6b" translate="yes" xml:space="preserve">
          <source>If the match specification contains errors, tuple &lt;code&gt;{error, Errors}&lt;/code&gt; is returned, where &lt;code&gt;Errors&lt;/code&gt; is a list of natural language descriptions of what was wrong with the match specification.</source>
          <target state="translated">일치 스펙에 오류가 포함 된 경우 튜플 &lt;code&gt;{error, Errors}&lt;/code&gt; 가 리턴됩니다. 여기서 &lt;code&gt;Errors&lt;/code&gt; 는 일치 스펙의 문제점에 대한 자연어 설명 목록입니다.</target>
        </trans-unit>
        <trans-unit id="73520de0bbd30344138b28e89ae6e3ad45ab6a3d" translate="yes" xml:space="preserve">
          <source>If the match specification is executed when selecting objects from an ETS table:</source>
          <target state="translated">ETS 테이블에서 오브젝트를 선택할 때 일치 스펙이 실행되는 경우 :</target>
        </trans-unit>
        <trans-unit id="c4b956c127ba515516d186daa8a6509787e44051" translate="yes" xml:space="preserve">
          <source>If the match specification is executing when tracing:</source>
          <target state="translated">추적시 일치 스펙이 실행중인 경우 :</target>
        </trans-unit>
        <trans-unit id="8673441fb53d8c53d833ea8413d411b45f3c363b" translate="yes" xml:space="preserve">
          <source>If the match specification is syntactically correct, the function either returns &lt;code&gt;{ok,Result}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match object &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">일치 스펙이 구문 상 올바른 경우, 함수는 &lt;code&gt;{ok,Result}&lt;/code&gt; 를 리턴합니다 . 여기서 &lt;code&gt;Result&lt;/code&gt; 는 실제 &lt;code&gt;select/2&lt;/code&gt; 호출 의 결과 일 수 있습니다 . 일치 스펙이 오브젝트 &lt;code&gt;Tuple&lt;/code&gt; 과 일치하지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="760d740968a06c49ac007f36a245af2196bd1b34" translate="yes" xml:space="preserve">
          <source>If the matching conditions are not met, the match fails, either with:</source>
          <target state="translated">일치 조건이 충족되지 않으면 다음 중 하나를 사용하여 일치에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1935f33d435bd33bb34072fa05214583d09d6dc0" translate="yes" xml:space="preserve">
          <source>If the matching fails, a &lt;code&gt;badmatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">일치하지 않으면 &lt;code&gt;badmatch&lt;/code&gt; 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e6c9dcffff87aa8aa658e5eae30b4366a1b2bb3" translate="yes" xml:space="preserve">
          <source>If the matching subpart of &lt;code&gt;Subject&lt;/code&gt; giving raise to the replacement is to be inserted in the result, option &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; inserts the matching part into &lt;code&gt;Replacement&lt;/code&gt; at the specified position (or positions) before inserting &lt;code&gt;Replacement&lt;/code&gt; into &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">대체를 발생시키는 &lt;code&gt;Subject&lt;/code&gt; 의 일치하는 &lt;code&gt;{insert_replaced, InsPos}&lt;/code&gt; 가 결과에 삽입되는 경우, {insert_replaced, InsPos} 옵션 은 &lt;code&gt;Replacement&lt;/code&gt; 를 &lt;code&gt;Subject&lt;/code&gt; 에 삽입하기 전에 지정된 위치 (또는 위치)에서 일치하는 파트를 &lt;code&gt;Replacement&lt;/code&gt; 에 삽입 합니다.</target>
        </trans-unit>
        <trans-unit id="fdd041679c28a1dfb5c5129e21e191da62b2500c" translate="yes" xml:space="preserve">
          <source>If the matching succeeds, any unbound variable in the pattern becomes bound and the value of &lt;code&gt;Expr2&lt;/code&gt; is returned.</source>
          <target state="translated">일치하면 패턴의 바인딩되지 않은 변수가 바인딩되고 &lt;code&gt;Expr2&lt;/code&gt; 의 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5059fa619d98d60a3d0f2e7f4484d57de08a27f3" translate="yes" xml:space="preserve">
          <source>If the maximum depth is reached, it cannot be read in the resultant output. Also, the &lt;code&gt;,...&lt;/code&gt; form in a tuple denotes that there are more elements in the tuple but these are below the print depth.</source>
          <target state="translated">최대 깊이에 도달하면 결과 출력에서 ​​읽을 수 없습니다. 또한 튜플 의 &lt;code&gt;,...&lt;/code&gt; 형식은 튜플에 더 많은 요소가 있지만 인쇄 깊이 아래에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6c939753050268aea10f52760cad514608911137" translate="yes" xml:space="preserve">
          <source>If the message cannot be decoded the following callback function will be invoked:</source>
          <target state="translated">메시지를 디코딩 할 수없는 경우 다음 콜백 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fa13ca2255dfd047e4217a3af88a01b044ce4d8d" translate="yes" xml:space="preserve">
          <source>If the message is on report form, it is converted to &lt;code&gt;{Format,Args}&lt;/code&gt; by calling the report callback. See section &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; in the Kernel User's Guide for more information about report callbacks and valid forms of log messages.</source>
          <target state="translated">메시지가 보고서 양식 인 경우 보고서 콜백을 호출하여 &lt;code&gt;{Format,Args}&lt;/code&gt; 로 변환됩니다 . 보고서 콜백 및 유효한 형식의 로그 메시지에 대한 자세한 내용은 커널 사용 설명서의 &lt;code&gt;&lt;a href=&quot;logger_chapter#log_message&quot;&gt;Log Message&lt;/a&gt;&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5713a5c2133c11304f85627e2ccde367a7ac635" translate="yes" xml:space="preserve">
          <source>If the minimum repetition is &amp;gt; 0, the quantifier is ignored. The assertion is obeyed only once when encountered during matching.</source>
          <target state="translated">최소 반복이&amp;gt; 0이면 수량자는 무시됩니다. 어설 션은 일치하는 동안 발생할 때 한 번만 준수됩니다.</target>
        </trans-unit>
        <trans-unit id="5f724a3bd58fe6f9ce42fc406728de7f89ce0ad1" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;m1&lt;/code&gt; is introduced in version &quot;2&quot; of &lt;code&gt;ch_app&lt;/code&gt;, it must also be loaded when upgrading and deleted when downgrading:</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 모듈 이 &lt;code&gt;ch_app&lt;/code&gt; 의 &quot;2&quot;버전에 도입 된 경우, 업그레이드 할 때로드하고 다운 그레이드 할 때 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="7aff411ea6299d7bca7ad227ec0e1bc26a882a00" translate="yes" xml:space="preserve">
          <source>If the module cannot be found, &lt;code&gt;non_existing&lt;/code&gt; is returned.</source>
          <target state="translated">모듈을 찾을 수 없으면 &lt;code&gt;non_existing&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5745afeece7b41ec1bfc061d3b5f18d8e8d1dfba" translate="yes" xml:space="preserve">
          <source>If the module is Cover-compiled, &lt;code&gt;cover_compiled&lt;/code&gt; is returned.</source>
          <target state="translated">모듈이 Cover-compiled이면 &lt;code&gt;cover_compiled&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52f516f712d9242bfd152b08a6fd0f4a2793c3fd" translate="yes" xml:space="preserve">
          <source>If the module is loaded, it returns the name of the file containing the loaded object code.</source>
          <target state="translated">모듈이로드되면로드 된 오브젝트 코드가 포함 된 파일 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="46dba590f6c1f6f800702e68508881918dc97bf9" translate="yes" xml:space="preserve">
          <source>If the module is not loaded, this function searches the code path for the first file containing object code for &lt;code&gt;Module&lt;/code&gt; and returns the absolute filename.</source>
          <target state="translated">모듈이로드되지 않은 경우이 함수는 &lt;code&gt;Module&lt;/code&gt; 객체 코드가 포함 된 첫 번째 파일의 코드 경로를 검색 하여 절대 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="229acd9737c1671ac97dd505de45081f475b5a4e" translate="yes" xml:space="preserve">
          <source>If the module is preloaded, &lt;code&gt;preloaded&lt;/code&gt; is returned.</source>
          <target state="translated">모듈이 사전로드되면 &lt;code&gt;preloaded&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ea6cb550bcdaadfe5116319b2dd6e7b241b066a1" translate="yes" xml:space="preserve">
          <source>If the module is successfully Cover compiled, the function returns &lt;code&gt;{ok,Module}&lt;/code&gt;. Otherwise the function returns &lt;code&gt;{error,File}&lt;/code&gt;. Errors and warnings are printed as they occur.</source>
          <target state="translated">모듈이 성공적으로 Cover 컴파일되면, 함수는 &lt;code&gt;{ok,Module}&lt;/code&gt; 을 반환합니다 . 그렇지 않으면 함수는 &lt;code&gt;{error,File}&lt;/code&gt; 을 리턴합니다 . 오류 및 경고가 발생하면 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0a91a6b9e2e2cfbc8f28ae6d3d48928ca8ba21" translate="yes" xml:space="preserve">
          <source>If the modules used to implement the process change dynamically during runtime, the process must understand one more message. An example is the &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; processes. The message is &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt;. The reply to this message is &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt;, where &lt;code&gt;Modules&lt;/code&gt; is a list of the currently active modules in the process.</source>
          <target state="translated">프로세스를 구현하는 데 사용 된 모듈이 런타임 중에 동적으로 변경되면 프로세스는 하나 이상의 메시지를 이해해야합니다. 예는 &lt;code&gt;&lt;a href=&quot;gen_event&quot;&gt;gen_event&lt;/a&gt;&lt;/code&gt; 프로세스입니다. 메시지는 &lt;code&gt;{_Label, {From, Ref}, get_modules}&lt;/code&gt; 입니다. 이 메시지에 대한 회신은 보낸 사람입니다 &lt;code&gt;From ! {Ref, Modules}&lt;/code&gt; . 여기서 &lt;code&gt;Modules&lt;/code&gt; 는 프로세스에서 현재 활성화 된 모듈의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="df61dd8b4c6d4d214b129a5077aaee5f7910b304" translate="yes" xml:space="preserve">
          <source>If the name after the prefix and any lift and glob markers is &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, the variable is treated as an anonymous catch-all pattern in matches. For example, &lt;code&gt;_@_&lt;/code&gt;, &lt;code&gt;_@@_&lt;/code&gt;, &lt;code&gt;_@__&lt;/code&gt;, or even &lt;code&gt;_@__@_&lt;/code&gt;.</source>
          <target state="translated">접두어 뒤의 이름과 리프트 및 글로브 마커가 &lt;code&gt;_&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 인 경우 변수는 일치하는 익명의 포괄 패턴으로 취급됩니다. 예를 들어, &lt;code&gt;_@_&lt;/code&gt; , &lt;code&gt;_@@_&lt;/code&gt; , &lt;code&gt;_@__&lt;/code&gt; 또는 &lt;code&gt;_@__@_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c34344ea584c9364120e1acb56d82e908a1af1b" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_server&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the &lt;code&gt;gen_server&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">이름을 생략하면 &lt;code&gt;gen_server&lt;/code&gt; 가 등록되지 않습니다. 대신 pid를 사용해야합니다. 이름은 &lt;code&gt;{global, Name}&lt;/code&gt; 으로 지정할 수도 있습니다 .이 경우 &lt;code&gt;gen_server&lt;/code&gt; 는 &lt;code&gt;global:register_name/2&lt;/code&gt; 를 사용하여 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="5f90545e460868142094a7469ef7c519e7a99526" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the &lt;code&gt;gen_statem&lt;/code&gt; is not registered. Instead its pid must be used. The name can also be specified as &lt;code&gt;{global,Name}&lt;/code&gt;, then the &lt;code&gt;gen_statem&lt;/code&gt; is registered using &lt;code&gt;global:register_name/2&lt;/code&gt; in Kernel.</source>
          <target state="translated">이름을 생략하면 &lt;code&gt;gen_statem&lt;/code&gt; 이 등록되지 않습니다. 대신 pid를 사용해야합니다. 이름은 &lt;code&gt;{global,Name}&lt;/code&gt; 으로 지정할 수 있으며 &lt;code&gt;gen_statem&lt;/code&gt; 은 커널에서 &lt;code&gt;global:register_name/2&lt;/code&gt; 를 사용하여 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="bce770e9e17197a693d6f9ec8afdca775fdac582" translate="yes" xml:space="preserve">
          <source>If the name is omitted, the event manager is not registered. Instead its pid must be used. The name can also be given as &lt;code&gt;{global, Name}&lt;/code&gt;, in which case the event manager is registered using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">이름을 생략하면 이벤트 관리자가 등록되지 않습니다. 대신 pid를 사용해야합니다. 이름은 &lt;code&gt;{global, Name}&lt;/code&gt; 으로 지정할 수도 있으며 ,이 경우 이벤트 관리자는 &lt;code&gt;global:register_name/2&lt;/code&gt; 를 사용하여 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="980ec5f2e4cbb3a6bcddf606d02e3f399d751b31" translate="yes" xml:space="preserve">
          <source>If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them has matched.</source>
          <target state="translated">이러한 종류의 조건에 사용 된 이름이 중복 인 경우 테스트는 동일한 이름의 모든 하위 패턴에 적용되며, 둘 중 하나라도 일치하면 참입니다.</target>
        </trans-unit>
        <trans-unit id="15ab8218177de1094fcd225608c4c1ed9bb318cc" translate="yes" xml:space="preserve">
          <source>If the node identified by &lt;code&gt;Node&lt;/code&gt; does not support distributed &lt;code&gt;spawn_monitor()&lt;/code&gt;, the call will fail with a &lt;code&gt;notsup&lt;/code&gt; exception.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 로 식별 된 노드 가 분산 &lt;code&gt;spawn_monitor()&lt;/code&gt; 지원하지 않으면 &lt;code&gt;notsup&lt;/code&gt; 예외 와 함께 호출이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="49bffa909b81c50ee39e3329bfdea53c42d35846" translate="yes" xml:space="preserve">
          <source>If the node is distributed, all referenced nodes are visible. Column &lt;strong&gt;Connection type&lt;/strong&gt; shows if the node is visible, hidden, or not connected. Visible nodes are alive nodes with a living connection to the originating node. Hidden nodes are the same as visible nodes, except they are started with flag &lt;code&gt;-hidden&lt;/code&gt;. Not connected nodes are nodes that are not connected to the originating node anymore, but references (that is, process or port identifiers) exist.</source>
          <target state="translated">노드가 분배되면 모든 참조 된 노드가 표시됩니다. 열 &lt;strong&gt;연결 유형&lt;/strong&gt; 은 노드가 표시되는지, 숨겨져 있는지 또는 연결되어 있지 않은지를 보여줍니다. 표시 가능한 노드는 원래 노드와 연결되어있는 활성 노드입니다. 숨겨진 노드는 표시되는 노드와 동일하지만 플래그 &lt;code&gt;-hidden&lt;/code&gt; 으로 시작 한다는 점이 다릅니다 . 연결되지 않은 노드는 더 이상 원래 노드에 연결되어 있지 않지만 참조 (즉, 프로세스 또는 포트 식별자)가 존재하는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="9c56f0553bb17f48448269d8c3f6b6f7e5b7e66d" translate="yes" xml:space="preserve">
          <source>If the node is started with command-line flag &lt;code&gt;-sname&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the short name of the host (not the fully qualified domain name). If started with flag &lt;code&gt;-name&lt;/code&gt;, the node name is &lt;code&gt;foobar@Host&lt;/code&gt;, where &lt;code&gt;Host&lt;/code&gt; is the fully qualified domain name. For more information, see &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">노드가 명령 행 플래그 &lt;code&gt;-sname&lt;/code&gt; 으로 시작된 경우 노드 이름은 &lt;code&gt;foobar@Host&lt;/code&gt; . 여기서 &lt;code&gt;Host&lt;/code&gt; 는 호스트 의 짧은 이름 (정규화 된 도메인 이름이 아님)입니다. flag &lt;code&gt;-name&lt;/code&gt; 으로 시작 하면 노드 이름은 &lt;code&gt;foobar@Host&lt;/code&gt; 이며 여기서 &lt;code&gt;Host&lt;/code&gt; 는 정규화 된 도메인 이름입니다. 자세한 정보는 &lt;code&gt;erl&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95b56bcd18c923019bf4643e2b58f9471a6acfb9" translate="yes" xml:space="preserve">
          <source>If the node was not distributed.</source>
          <target state="translated">노드가 분배되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="aedd11aac41ef6bf71a8b2c8d09b6e7316fb0ef3" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, &lt;code&gt;0&lt;/code&gt; is returned, otherwise &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">노드가 EPMD에서 등록 해제 된 경우 &lt;code&gt;0&lt;/code&gt; 이 리턴되고, 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;EIO&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9460cf94d8c06eac24b50547fafb0d6e9b4fd6e1" translate="yes" xml:space="preserve">
          <source>If the node was successfully unregistered from EPMD, the function returns &lt;code&gt;0&lt;/code&gt;. Otherwise, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">노드가 EPMD에서 등록 해제 된 경우 함수는 &lt;code&gt;0&lt;/code&gt; 을 리턴합니다 . 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;erl_errno&lt;/code&gt; 가 &lt;code&gt;EIO&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d5ac939fb10f304c0c8f3c91721403a64646c5e" translate="yes" xml:space="preserve">
          <source>If the node where the application is running goes down, the application is restarted (after the specified time-out) at the first operational node that is listed in the list of nodes in the &lt;code&gt;distributed&lt;/code&gt; configuration parameter. This is called a &lt;strong&gt;failover&lt;/strong&gt;.</source>
          <target state="translated">응용 프로그램이 실행중인 노드가 작동 중지되면, &lt;code&gt;distributed&lt;/code&gt; 구성 매개 변수 의 노드 목록에 나열된 첫 번째 작동 노드에서 응용 프로그램이 (지정된 시간 종료 후) 다시 시작 됩니다. 이것을 &lt;strong&gt;장애 조치&lt;/strong&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="a5d2b0ad4edfef4bb3e88a7ddeeff16d1de18813" translate="yes" xml:space="preserve">
          <source>If the number of arguments are known at compile time, the call is better written as &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt;.</source>
          <target state="translated">컴파일 타임에 인수 수를 알고 있으면 호출이 &lt;code&gt;Module:Function(Arg1, Arg2, ..., ArgN)&lt;/code&gt; 작성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="37c7a476d1b0b827d6493e10ef324cd201488a29" translate="yes" xml:space="preserve">
          <source>If the number of elements in the arguments are known at compile time, the call is better written as &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt;.</source>
          <target state="translated">인수에서 인수의 요소 수가 컴파일 타임에 알려진 경우 호출은 &lt;code&gt;Fun(Arg1, Arg2, ... ArgN)&lt;/code&gt; 작성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ed56e6304627b8d6f8ad0ab5b8d27fa5330578a8" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt; logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="translated">이전 동작을 선호하는 경우 커널 구성 매개 변수 &lt;code&gt; logger_sasl_compatible&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . &lt;code&gt;SASL configuration parameters&lt;/code&gt; 그 이전과 같이 사용될 수 있고 SASL 응용 프로그램이 실행되면 SASL 리포트은 제 로그 핸들러라는 통해 인쇄 될 &lt;code&gt;sasl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1678d016c144fe15d956c065fed8204d1f4e8c" translate="yes" xml:space="preserve">
          <source>If the old behaviour is preferred, the Kernel configuration parameter &lt;code&gt;logger_sasl_compatible&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;SASL configuration parameters&lt;/code&gt; can then be used as before, and the SASL reports will only be printed if the SASL application is running, through a second log handler named &lt;code&gt;sasl&lt;/code&gt;.</source>
          <target state="translated">이전 동작을 선호하는 경우 커널 구성 매개 변수 &lt;code&gt;logger_sasl_compatible&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . &lt;code&gt;SASL configuration parameters&lt;/code&gt; 그 이전과 같이 사용될 수 있고 SASL 응용 프로그램이 실행되면 SASL 리포트은 제 로그 핸들러라는 통해 인쇄 될 &lt;code&gt;sasl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5231cf8edc57a7fbd05d3b31ba66fb76e90acd0" translate="yes" xml:space="preserve">
          <source>If the operation fails, a bad match error occurs that terminates the test case.</source>
          <target state="translated">작업이 실패하면 테스트 케이스를 종료하는 잘못된 일치 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="279228e8ee1eea55ae3919811a086bb57153efdc" translate="yes" xml:space="preserve">
          <source>If the operation is aborted for whatever reason (e.g. if the socket is closed &quot;by someone else&quot;). The &lt;code&gt;Info&lt;/code&gt; part contains the abort reason (in this case that the socket has been closed &lt;code&gt;Info = {SelectRef, closed}&lt;/code&gt;).</source>
          <target state="translated">어떤 이유로 든 작업이 중단 된 경우 (예 : 소켓이 &quot;다른 사람에 의해&quot;닫힌 경우). &lt;code&gt;Info&lt;/code&gt; 일부가 중단 사유 포함 (소켓이 폐쇄되었음을이 경우 &lt;code&gt;Info = {SelectRef, closed}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="76c8fb74e6d95469ef49c5c6891c58f75c46dd19" translate="yes" xml:space="preserve">
          <source>If the operation is denied because of table access rights (&lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">테이블 액세스 권한 ( &lt;code&gt;&lt;a href=&quot;#protected&quot;&gt;protected&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#private&quot;&gt;private&lt;/a&gt;&lt;/code&gt; )으로 인해 작업이 거부 된 경우 .</target>
        </trans-unit>
        <trans-unit id="1eb00786bd693115a31f9e1bae9c1bd9187b7cb1" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;active&lt;/code&gt; is set to &lt;code&gt;once&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or an integer value, the process owning the sslsocket will receive messages of type &lt;code&gt;&lt;a href=&quot;#type-active_msgs&quot;&gt; active_msgs() &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;active&lt;/code&gt; 옵션 이 &lt;code&gt;once&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 또는 정수 값으로 설정된 경우 sslsocket을 소유 한 프로세스는 &lt;code&gt;&lt;a href=&quot;#type-active_msgs&quot;&gt; active_msgs() &lt;/a&gt;&lt;/code&gt; 유형의 메시지를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="660ac0936f3ad9df7f0818b651fbd055b3e48bf8" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;anti_replay&lt;/code&gt; is defined in the server, a pair of Bloom filters (&lt;strong&gt;current&lt;/strong&gt; and &lt;strong&gt;old&lt;/strong&gt;) are used to record incoming ClientHello messages (it is the unique binder value that is actually stored). The &lt;strong&gt;current&lt;/strong&gt; Bloom filter is used for &lt;code&gt;WindowSize&lt;/code&gt; seconds to store new elements. At the end of the time window the Bloom filters are rotated (the &lt;strong&gt;current&lt;/strong&gt; Bloom filter becomes the &lt;strong&gt;old&lt;/strong&gt; and an empty Bloom filter is set as &lt;strong&gt;current&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;anti_replay&lt;/code&gt; 옵션 이 서버에 정의되어 있으면 Bloom 필터 쌍 ( &lt;strong&gt;current&lt;/strong&gt; 및 &lt;strong&gt;old&lt;/strong&gt; )을 사용하여 들어오는 ClientHello 메시지를 기록합니다 (실제로 저장되는 고유 바인더 값). &lt;strong&gt;현재&lt;/strong&gt; 블룸 필터가 사용된다 &lt;code&gt;WindowSize&lt;/code&gt; 의 새로운 요소를 저장하는 초. 시간 창의 끝에서 Bloom 필터가 회전됩니다 ( &lt;strong&gt;현재&lt;/strong&gt; Bloom 필터는 &lt;strong&gt;이전&lt;/strong&gt; 필터가되고 빈 Bloom 필터는 &lt;strong&gt;current&lt;/strong&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="965b40d04fea8544035ae2adb0a45bfab2ddc16f" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 옵션 이 설정되면 파일 서버가 호출되지 않고 로컬 파일에 대한 정보 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4e75c5ca6851d3d1260e2334b0fd3550965b29e5" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 옵션 이 설정되면 파일 서버가 호출되지 않고 로컬 파일에 대한 정보 만 반환됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt; 에 대한 동시 호출과 경쟁 할 수 있으므로이 모듈의 원 자성 보장을 깨뜨립니다.</target>
        </trans-unit>
        <trans-unit id="b1f856775e657213352223a21e03401b4aa2a209" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 옵션 이 설정되면 파일 서버가 호출되지 않고 로컬 파일에 대한 정보 만 반환됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2 &lt;/a&gt;&lt;/code&gt; 에 대한 동시 호출과 경쟁 할 수 있으므로이 모듈의 원 자성 보장을 깨뜨립니다 .</target>
        </trans-unit>
        <trans-unit id="5e127046f0102151c6ef18467d6c0abf9dd2f077" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;raw&lt;/code&gt; is set, the file server is not called and only information about local files is returned. Note that this will break this module's atomicity guarantees as it can race with a concurrent call to &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 옵션 이 설정되면 파일 서버가 호출되지 않고 로컬 파일에 대한 정보 만 리턴됩니다. &lt;code&gt;&lt;a href=&quot;#write_file_info-2&quot;&gt;write_file_info/1,2&lt;/a&gt;&lt;/code&gt; 에 대한 동시 호출과 경쟁 할 수 있으므로이 모듈의 원 자성 보증을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="400845971be3dd0decd026d5b02cf869e6e7945b" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;user_dir_fun&lt;/code&gt; is defined, that fun is called and the returned directory is used,</source>
          <target state="translated">&lt;code&gt;user_dir_fun&lt;/code&gt; 옵션 이 정의 된 경우 해당 fun이 호출되고 반환 된 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d027da67948b3928fcb8c40cf4bee29a349c9ad" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is proably not what you want.</source>
          <target state="translated">옵션이있는 경우 &lt;code&gt;verify&lt;/code&gt; 로 설정 &lt;code&gt;verify_peer&lt;/code&gt; 옵션 &lt;code&gt;server_name_indication&lt;/code&gt; 가 더 서버 이름 표시 확장이 전송되지 않습니다 아니며, 경우도 규정되어야한다 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 로 연결의 IP 주소로 호출됩니다 &lt;code&gt;ReferenceID&lt;/code&gt; , 어떤 아마 당신이 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8ee4266e447f2d44213209bd3f7598d7638964ff" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the option &lt;code&gt;server_name_indication&lt;/code&gt; shall also be specified, if it is not no Server Name Indication extension will be sent, and &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be called with the IP-address of the connection as &lt;code&gt;ReferenceID&lt;/code&gt;, which is probably not what you want.</source>
          <target state="translated">옵션이있는 경우 &lt;code&gt;verify&lt;/code&gt; 로 설정 &lt;code&gt;verify_peer&lt;/code&gt; 옵션 &lt;code&gt;server_name_indication&lt;/code&gt; 가 더 서버 이름 표시 확장이 전송되지 않습니다 아니며, 경우도 규정되어야한다 &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; 로 연결의 IP 주소로 호출됩니다 &lt;code&gt;ReferenceID&lt;/code&gt; , 어떤 아마도 당신이 원하는 것이 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="70f682b6a405b33cd20dc6b87dfbd76f644b7558" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{handshake, hello}&lt;/code&gt; 옵션을 사용하면 서버 hello 메시지를 수신 한 후 핸드 셰이크가 일시 중지되고 성공 응답은 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 대신 {ok, SslSocket, Ext &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 입니다. 그 후 &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt; handshake_continue/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 핸드 셰이크를 계속하거나 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="c3a18e0b35e87dbcf1a9dcdd4db312f82e11bde7" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;{handshake, hello}&lt;/code&gt; is used the handshake is paused after receiving the server hello message and the success response is &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; instead of &lt;code&gt;{ok, SslSocket}&lt;/code&gt;. Thereafter the handshake is continued or canceled by calling &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{handshake, hello}&lt;/code&gt; 옵션 이 사용되면 서버 hello 메시지를 수신 한 후 데이터 &lt;code&gt;{ok, SslSocket, Ext}&lt;/code&gt; 이 일시 중지되며 성공 응답은 {ok, SslSocket} 대신 {ok, SslSocket, Ext &lt;code&gt;{ok, SslSocket}&lt;/code&gt; 입니다. 그런 다음 handshake_continue &lt;code&gt;&lt;a href=&quot;#handshake_continue-3&quot;&gt;handshake_continue/3&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#handshake_cancel-1&quot;&gt;handshake_cancel/1&lt;/a&gt;&lt;/code&gt; 을 호출하여 핸드 셰이크가 계속되거나 취소됩니다 .</target>
        </trans-unit>
        <trans-unit id="a077df380f70545e70cd306e5e5521ae67d9f379" translate="yes" xml:space="preserve">
          <source>If the option is enabled, and no &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; is present, the user name must present in the &lt;code&gt;&lt;a href=&quot;#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; for the check to succeed but the value of the password is not checked.</source>
          <target state="translated">옵션이 활성화, 어떤 경우 &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; 이 존재하지 않는 사용자 이름은에 제시해야합니다 &lt;code&gt;&lt;a href=&quot;#option-user_passwords&quot;&gt;user_passwords&lt;/a&gt;&lt;/code&gt; 성공하기 위해 검사뿐만 암호의 값은 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="948c45ffdeba267366402b1a519f264bb85a2b52" translate="yes" xml:space="preserve">
          <source>If the option is intended only for a server or for a client, it may be set in this way:</source>
          <target state="translated">옵션이 서버 또는 클라이언트 전용 인 경우 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f7f3873edec45c49aeb8ad204a603fa73eff84" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;allow deny&lt;/code&gt;, the users network address is first controlled to be in the allow subset. If the user network address is not in the allowed subset, the user is denied to get the asset. If the network address is in the allowed subset, a second control is performed. That is, the user network address is not in the subset of network addresses to be denied as specified by parameter &lt;code&gt;deny&lt;/code&gt;.</source>
          <target state="translated">순서가 &lt;code&gt;allow deny&lt;/code&gt; 로 설정 되면 사용자 네트워크 주소가 먼저 허용 하위 집합에 있도록 제어됩니다. 사용자 네트워크 주소가 허용 된 서브 세트에 없으면 사용자가 자산을 가져 오는 것이 거부됩니다. 네트워크 주소가 허용 된 하위 집합에 있으면 두 번째 제어가 수행됩니다. 즉, 사용자 네트워크 주소가 &lt;code&gt;deny&lt;/code&gt; 매개 변수에 의해 지정된대로 거부 될 네트워크 주소의 서브 세트에 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="48d8a47c543c2d39d92d2c1d202bacab80c1642d" translate="yes" xml:space="preserve">
          <source>If the order is set to &lt;code&gt;deny allow&lt;/code&gt;, only users from networks specified to be in the allowed subset succeeds to request assets in the limited area.</source>
          <target state="translated">주문이 &lt;code&gt;deny allow&lt;/code&gt; 로 설정된 경우 허용 된 서브 세트에 지정된 네트워크의 사용자 만 제한된 영역에서 자산을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="5413791d17ed0b4814f8fb694ad1efb815f76c05" translate="yes" xml:space="preserve">
          <source>If the order of the answers is not important, there is an alternative to the &lt;code&gt;unique&lt;/code&gt; option, namely to sort the answers uniquely:</source>
          <target state="translated">답변의 순서가 중요하지 않은 경우, &lt;code&gt;unique&lt;/code&gt; 옵션에 대한 대안 , 즉 답변을 고유하게 정렬 하는 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b054305581b7663ed91514b307669add31ca5b5b" translate="yes" xml:space="preserve">
          <source>If the packet does not conform to the protocol format, &lt;code&gt;{error,Reason}&lt;/code&gt; is returned.</source>
          <target state="translated">패킷이 프로토콜 형식을 준수하지 않으면 &lt;code&gt;{error,Reason}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a2c9f15b9a918cfc529cc22dc69ae62a00c732a6" translate="yes" xml:space="preserve">
          <source>If the page is empty, it means either of the following:</source>
          <target state="translated">페이지가 비어 있으면 다음 중 하나를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f52fa558245396ce59f0c16eb282e09760e84891" translate="yes" xml:space="preserve">
          <source>If the parse_transform is not applied to a module which calls this pseudo function, the call will fail in runtime (with a &lt;code&gt;badarg&lt;/code&gt;). The module &lt;code&gt;dbg&lt;/code&gt; actually exports a function with this name, but it should never really be called except for when using the function in the shell. If the &lt;code&gt;parse_transform&lt;/code&gt; is properly applied by including the &lt;code&gt;ms_transform.hrl&lt;/code&gt; header file, compiled code will never call the function, but the function call is replaced by a literal match_spec.</source>
          <target state="translated">parse_transform이이 의사 함수를 호출하는 모듈에 적용되지 않으면 런타임에 호출이 실패합니다 ( &lt;code&gt;badarg&lt;/code&gt; 사용 ). 모듈 &lt;code&gt;dbg&lt;/code&gt; 는 실제로이 이름의 함수를 내보내 지만, 쉘에서 함수를 사용할 때를 제외하고는 실제로 호출해서는 안됩니다. 는 IF &lt;code&gt;parse_transform&lt;/code&gt; 이 제대로 포함하여 적용 &lt;code&gt;ms_transform.hrl&lt;/code&gt; 의 헤더 파일을 컴파일 된 코드는 함수를 호출하지 않습니다 만, 함수 호출은 문자 match_spec로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="7c4c35e1fed61f85f87d7154c2244f967d2936c6" translate="yes" xml:space="preserve">
          <source>If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next starting character then occurs. Backtracking can occur as usual to the left of (*PRUNE), before it is reached, or when matching to the right of (*PRUNE), but if there is no match to the right, backtracking cannot cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an alternative to an atomic group or possessive quantifier, but there are some uses of (*PRUNE) that cannot be expressed in any other way. In an anchored pattern, (*PRUNE) has the same effect as (*COMMIT).</source>
          <target state="translated">패턴이 고정되어 있지 않으면 정상적인 &quot;bumpalong&quot;이 다음 시작 문자로 진행됩니다. 역 추적은 (* PRUNE) 왼쪽에 평소와 같이 도달하기 전에 또는 (* PRUNE) 오른쪽에 일치 할 때 발생할 수 있지만 오른쪽과 일치하지 않으면 역 추적을 교차 할 수 없습니다 (* PRUNE). 간단한 경우, (* PRUNE)의 사용은 원자 그룹 또는 소유 수량화의 대안 일 뿐이지 만 다른 방식으로는 표현할 수없는 (* PRUNE)의 일부 사용이 있습니다. 고정 패턴에서 (* PRUNE)은 (* COMMIT)과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="caf53e7076db6e332a206c64cff8afbb0ab34c47" translate="yes" xml:space="preserve">
          <source>If the permission of a loaded, but not started, application is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; but the application is not started until the permission is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">로드되었지만 시작되지 않은 권한이 응용 프로그램은 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 &lt;code&gt;start&lt;/code&gt; 는 &lt;code&gt;ok&lt;/code&gt; 를 반환 하지만 권한이 &lt;code&gt;true&lt;/code&gt; 로 설정 될 때까지 응용 프로그램은 시작되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb5424927d13c1c2f8655ecb9fa4aea52eaa565c" translate="yes" xml:space="preserve">
          <source>If the permission of a running application is set to &lt;code&gt;false&lt;/code&gt;, the application is stopped. If the permission later is set to &lt;code&gt;true&lt;/code&gt;, it is restarted.</source>
          <target state="translated">실행중인 애플리케이션의 권한이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 애플리케이션이 중지됩니다. 나중에 권한이 &lt;code&gt;true&lt;/code&gt; 로 설정되면 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1f18562fd499738cfc53fedde95228c6abb3a3c9" translate="yes" xml:space="preserve">
          <source>If the platform implements the IPv4 option &lt;code&gt;IP_PKTOPTIONS&lt;/code&gt;, or the IPv6 option &lt;code&gt;IPV6_PKTOPTIONS&lt;/code&gt; or &lt;code&gt;IPV6_2292PKTOPTIONS&lt;/code&gt; for the socket this value is returned from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; when called with the option name &lt;code&gt;&lt;a href=&quot;#type-option_name&quot;&gt;pktoptions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">플랫폼이 IPv4 옵션 &lt;code&gt;IP_PKTOPTIONS&lt;/code&gt; , 또는 소켓에 대한 IPv6 옵션 &lt;code&gt;IPV6_PKTOPTIONS&lt;/code&gt; 또는 &lt;code&gt;IPV6_2292PKTOPTIONS&lt;/code&gt; 를 구현하는 경우이 값은 &lt;code&gt;&lt;a href=&quot;#type-option_name&quot;&gt;pktoptions&lt;/a&gt;&lt;/code&gt; 옵션 이름으로 호출 될 때 &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts/2&lt;/a&gt;&lt;/code&gt; 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4dfea1ce63878f9ba8f72e4692fc1e8aa917a62" translate="yes" xml:space="preserve">
          <source>If the port command is aborted, &lt;code&gt;false&lt;/code&gt; is returned, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">포트 명령이 중단되면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="c1c15fb5c83bfc2a91269d248f12f67e81fee63b" translate="yes" xml:space="preserve">
          <source>If the port driver does not support synchronous control operations.</source>
          <target state="translated">포트 드라이버가 동기 제어 조작을 지원하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="0d0817e3d68cbd798c7a2e44b1c69c87bcdb5eaf" translate="yes" xml:space="preserve">
          <source>If the port driver so decides for any reason (probably something wrong with &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt;).</source>
          <target state="translated">포트 드라이버가 어떤 이유로 든 결정한 경우 (아마도 &lt;code&gt;Operation&lt;/code&gt; 또는 &lt;code&gt;Data&lt;/code&gt; 에 문제가 있음 )</target>
        </trans-unit>
        <trans-unit id="6d151f89de14a3a981ce006759dc3e5172e69a5a" translate="yes" xml:space="preserve">
          <source>If the port has terminated for some reason.</source>
          <target state="translated">어떤 이유로 포트가 종료 된 경우.</target>
        </trans-unit>
        <trans-unit id="478c30ae507a35c9772a0df1cd3d96a72d57ca57" translate="yes" xml:space="preserve">
          <source>If the port identified by &lt;code&gt;Port&lt;/code&gt; is not open, &lt;code&gt;undefined&lt;/code&gt; is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_info/2&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Port&lt;/code&gt; 로 식별 된 포트 가 열려 &lt;code&gt;undefined&lt;/code&gt; 않으면 undefined 가 반환됩니다. 포트가 닫히고 호출 프로세스가 이전에 포트에 링크 된 경우 &lt;code&gt;port_info/2&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 를 리턴 하기 전에 포트의 종료 신호가 전달되도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="853a76f0837b416b340a6bf46f68d0b7ffc26aa7" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy any more.</source>
          <target state="translated">포트가 사용중인 경우 포트가 더 이상 사용되지 않을 때까지 호출 프로세스가 일시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="8e93ad76f9dc1354beffe48343ad7231e136396f" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy anymore.</source>
          <target state="translated">포트가 사용중인 경우 포트가 더 이상 사용되지 않을 때까지 호출 프로세스가 일시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="6e75c78d0feb81a1196647eabb58d38723b98522" translate="yes" xml:space="preserve">
          <source>If the port program closes its &lt;code&gt;stdout&lt;/code&gt; without exiting, option &lt;code&gt;exit_status&lt;/code&gt; does not work.</source>
          <target state="translated">포트 프로그램이 종료 하지 않고 &lt;code&gt;stdout&lt;/code&gt; 을 닫으면 &lt;code&gt;exit_status&lt;/code&gt; 옵션 이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db113293208f7fe3c23990353c9eaabbd0d53db0" translate="yes" xml:space="preserve">
          <source>If the port program is to be updated, the code for the &lt;code&gt;gen_server&lt;/code&gt; can be extended with a &lt;code&gt;code_change&lt;/code&gt; function, which closes the old port and opens a new port. (If necessary, the &lt;code&gt;gen_server&lt;/code&gt; can first request data that must be saved from the port program and pass this data to the new port):</source>
          <target state="translated">포트 프로그램을 업데이트하려는 경우 &lt;code&gt;gen_server&lt;/code&gt; 코드를 &lt;code&gt;code_change&lt;/code&gt; 함수 로 확장 하여 이전 포트를 닫고 새 포트를 열 수 있습니다. (필요한 경우 &lt;code&gt;gen_server&lt;/code&gt; 는 먼저 포트 프로그램에서 저장해야하는 데이터를 요청하고이 데이터를 새 포트로 전달할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="38a0c5b075f7274afd3c7af203177b865a7ca3d6" translate="yes" xml:space="preserve">
          <source>If the process calling &lt;code&gt;erlang:resume_process/1&lt;/code&gt; had not previously increased the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:resume_process/1&lt;/code&gt; 을 호출하는 프로세스 가 이전에 &lt;code&gt;Suspendee&lt;/code&gt; 로 식별 된 프로세스에서 일시 중단 수를 늘리지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="9584990023c5a96bcc22ea4479bca2d11aee6db9" translate="yes" xml:space="preserve">
          <source>If the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;Ret = {error, Reason}&lt;/code&gt; will be returned if the calling process traps exits.</source>
          <target state="translated">가 호출되기 전에 프로세스가 충돌하는 경우 &lt;code&gt;init_ack/1,2&lt;/code&gt; , &lt;code&gt;Ret = {error, Reason}&lt;/code&gt; 호출 프로세스 트랩 종료하는 경우 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7dde4932a93f8e946ee90206f0656471a4679385" translate="yes" xml:space="preserve">
          <source>If the process does not exist, a &lt;code&gt;noproc&lt;/code&gt; exception is raised.</source>
          <target state="translated">프로세스가 존재하지 않으면 &lt;code&gt;noproc&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="20b1fa7364ea436067720e9fd90a1b6ba70feb9e" translate="yes" xml:space="preserve">
          <source>If the process executing the call does not belong to any application, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">호출을 실행하는 프로세스가 응용 프로그램에 속하지 않으면 함수는 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="581efb60de5599bb6f030da89d279c27e9892d5a" translate="yes" xml:space="preserve">
          <source>If the process has any message in its message queue, the process is awakened immediately in the same way as described earlier.</source>
          <target state="translated">프로세스가 메시지 큐에 메시지를 가지고 있으면 프로세스는 앞에서 설명한 것과 같은 방식으로 즉시 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="084bfd0c081f4fee78443d764a32418d4196357e" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; has a registered name, also an &lt;code&gt;InfoTuple&lt;/code&gt; with item &lt;code&gt;registered_name&lt;/code&gt; is included.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스 에 등록 된 이름이 &lt;code&gt;InfoTuple&lt;/code&gt; 항목이 &lt;code&gt;registered_name&lt;/code&gt; 인 InfoTuple 도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b81261e08e1610fbb4a750870cfa04d7610f65e5" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local process.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; 로 식별 된 프로세스 가 기존 로컬 프로세스가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="6f56d002efe6106da3a84a3e2016c451482b68c7" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &amp;gt; 2,000,000,000 suspends and will never be lower.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스가 현재 사용중인 내부 데이터 구조로 표시 될 수있는 것보다 호출 프로세스에 의해 여러 번 일시 중단 된 경우 시스템 한도는 2,000,000,000 개 이상이며 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="036dbfabe540cf1c1a2eb6e8693ac0992c59c911" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is greater than 2,000,000,000 suspends and will never be lower.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 에 의해 식별 된 프로세스가 현재 사용되는 내부 데이터 구조로 나타낼 수있는 것보다 호출 프로세스에 의해 더 많이 일시 중단 된 경우. 시스템 한도는 일시 중단 횟수가 2,000,000,000 회를 초과하며 결코 낮아지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e6414a88b13aa6c8a9b8f6f5c8c66d946440583" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is not alive.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스 가 아직 유효하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="641aca5b56bf74307b3adf498b7c5e8e5c4b1259" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is the same process as the process calling &lt;code&gt;erlang:suspend_process/2&lt;/code&gt;.</source>
          <target state="translated">로 식별되는 과정 경우 &lt;code&gt;Suspendee&lt;/code&gt; 는 프로세스 호출과 같은 과정 &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651c23453333c69005cd277bbe1fcf8cf3b85f49" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; resides on another node.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; 가 식별 한 프로세스 가 다른 노드에있는 경우</target>
        </trans-unit>
        <trans-unit id="e4ca7dc0b151bb1f9cd8a2a4aff6bffd4a0444e4" translate="yes" xml:space="preserve">
          <source>If the process is alive and a single &lt;code&gt;Item&lt;/code&gt; is specified, the returned value is the corresponding &lt;code&gt;InfoTuple&lt;/code&gt;, unless &lt;code&gt;Item =:= registered_name&lt;/code&gt; and the process has no registered name. In this case, &lt;code&gt;[]&lt;/code&gt; is returned. This strange behavior is because of historical reasons, and is kept for backward compatibility.</source>
          <target state="translated">프로세스가 &lt;code&gt;InfoTuple&lt;/code&gt; 이고 단일 &lt;code&gt;Item&lt;/code&gt; 이 지정된 경우, &lt;code&gt;Item =:= registered_name&lt;/code&gt; 이고 프로세스에 등록 된 이름이 없으면 리턴 된 값은 해당 InfoTuple 입니다. 이 경우 &lt;code&gt;[]&lt;/code&gt; 가 반환됩니다. 이 이상한 동작은 역사적인 이유 때문이며 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1a9a0fee2f5bd85201e0094b8e33070b42b45236" translate="yes" xml:space="preserve">
          <source>If the process is to replace its state using the fun &lt;code&gt;StateFun&lt;/code&gt;, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">프로세스가 fun &lt;code&gt;StateFun&lt;/code&gt; 을 사용하여 상태를 바꾸는 경우 &lt;code&gt;handle_system_msg&lt;/code&gt; 는 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3df3174e4f4f8d76818b78c9db43318524d54225" translate="yes" xml:space="preserve">
          <source>If the process is to return its state, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">프로세스가 상태를 리턴하는 경우 &lt;code&gt;handle_system_msg&lt;/code&gt; 는 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="54575a5d04700d078536008be3d7a71568b2f2f0" translate="yes" xml:space="preserve">
          <source>If the process or port is already registered (already has a name).</source>
          <target state="translated">프로세스 또는 포트가 이미 등록되어있는 경우 (이미 이름이 있음)</target>
        </trans-unit>
        <trans-unit id="72499bc5509543fc3c3a1dc36c89e29a09a5bee5" translate="yes" xml:space="preserve">
          <source>If the process potentially can get many messages in its queue, you are advised to set the flag to &lt;code&gt;off_heap&lt;/code&gt;. This because a garbage collection with many messages placed on the heap can become extremely expensive and the process can consume large amounts of memory. Performance of the actual message passing is however generally better when not using flag &lt;code&gt;off_heap&lt;/code&gt;.</source>
          <target state="translated">프로세스가 큐에 많은 메시지를 가져올 수있는 경우 플래그를 &lt;code&gt;off_heap&lt;/code&gt; 으로 설정하는 것이 좋습니다 . 이는 많은 메시지가 힙에 배치 된 가비지 콜렉션이 매우 비싸고 프로세스가 대량의 메모리를 소비 할 수 있기 때문입니다. 그러나 실제 메시지 전달 성능은 일반적으로 플래그 &lt;code&gt;off_heap&lt;/code&gt; 을 사용하지 않을 때 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2977b37e3f3fa2bacc4a55c85d9c30b69a4999c8" translate="yes" xml:space="preserve">
          <source>If the process terminates with another reason than &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;shutdown&lt;/code&gt;, a crash report is generated. For more information about the crash report, see the SASL User's Guide.</source>
          <target state="translated">프로세스가 &lt;code&gt;normal&lt;/code&gt; 또는 &lt;code&gt;shutdown&lt;/code&gt; 이외의 다른 이유로 종료 되면 충돌 보고서가 생성됩니다. 충돌 보고서에 대한 자세한 내용은 SASL 사용 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="24d7be87e875bc81d2fad8f3b3e621f25756c364" translate="yes" xml:space="preserve">
          <source>If the process was spawned using a fun, &lt;code&gt;initial_call/1&lt;/code&gt; no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (meaning that the fun was created in function &lt;code&gt;some_module:work/3&lt;/code&gt;). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.</source>
          <target state="translated">fun을 사용하여 프로세스가 생성 된 경우 &lt;code&gt;initial_call/1&lt;/code&gt; 은 더 이상 fun을 반환하지 않고 모듈, fun을 구현하는 로컬 함수에 대한 함수 및 &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (재미가 &lt;code&gt;some_module:work/3&lt;/code&gt; 함수에서 생성되었음을 의미 ). 그 이유는 재미를 유지하면 모듈의 코드 업그레이드가 방해되고 많은 양의 메모리가 낭비 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e063f0c97bd3b9f2ca10490b0726825eb1a13207" translate="yes" xml:space="preserve">
          <source>If the program is too large to be profiled by &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;, &lt;code&gt;cprof&lt;/code&gt; can be used to locate code parts that are to be more thoroughly profiled using &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;.</source>
          <target state="translated">프로그램이 너무 커서 &lt;code&gt;fprof&lt;/code&gt; 또는 &lt;code&gt;eprof&lt;/code&gt; 로 프로파일 링 할 수 없는 경우 &lt;code&gt;cprof&lt;/code&gt; 를 사용하여 &lt;code&gt;fprof&lt;/code&gt; 또는 &lt;code&gt;eprof&lt;/code&gt; 를 사용하여보다 철저하게 프로파일 링 할 코드 부분을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c014cbf0073f75ddbbd2b83b405b67fe36da992" translate="yes" xml:space="preserve">
          <source>If the provided public key is not found, the authentication fails.</source>
          <target state="translated">제공된 공개 키를 찾을 수 없으면 인증이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f62378f1f957382ee8a052b1c61d99645a009e49" translate="yes" xml:space="preserve">
          <source>If the pure encode/decode performance really is a serious issue, our erl_dist encoder could be used, as the encoding/decoding of the erlang distribution format is much faster than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">순수한 인코딩 / 디코딩 성능이 실제로 심각한 문제라면, erlang 배포 형식의 인코딩 / 디코딩이 다른 모든 대안보다 훨씬 빠르기 때문에 erl_dist 인코더를 사용할 수 있습니다. 주요 단점은 유효한 Megaco / H.248 메시지 인코딩으로 승인되지 않았다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4deb3a5f5f018b337b5754c6b3743ec42918472" translate="yes" xml:space="preserve">
          <source>If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism.</source>
          <target state="translated">수량자가 {0}이면 일치하는 동안 어설 션이 준수되지 않습니다. 그러나 서브 루틴 메커니즘을 통해 다른 곳에서 호출되는 내부 캡처 괄호로 묶은 그룹을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a112cbde0806d4bd82db516d60932759dd1e88" translate="yes" xml:space="preserve">
          <source>If the regular expression contains capturing subpatterns, like in:</source>
          <target state="translated">정규식에 다음과 같이 캡처 하위 패턴이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="53c05be9c33eb1a96dab74d00ca7378c333d60b5" translate="yes" xml:space="preserve">
          <source>If the regular expression is previously compiled, the option list can only contain the following options:</source>
          <target state="translated">정규식이 이전에 컴파일 된 경우 옵션 목록은 다음 옵션 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22619338e12940ef34ae589b0ca2c131b656f3a0" translate="yes" xml:space="preserve">
          <source>If the regular expression was previously compiled with option &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;Subject&lt;/code&gt; is to be provided as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise any &lt;code&gt;iodata()&lt;/code&gt; will do. If compilation is involved and option &lt;code&gt;unicode&lt;/code&gt; is specified, both &lt;code&gt;Subject&lt;/code&gt; and the regular expression are to be specified as valid Unicode &lt;code&gt;charlists()&lt;/code&gt;.</source>
          <target state="translated">정규식이 이전에 옵션 &lt;code&gt;unicode&lt;/code&gt; 로 컴파일 된 경우 &lt;code&gt;Subject&lt;/code&gt; 는 유효한 유니 코드 &lt;code&gt;charlist()&lt;/code&gt; 로 제공됩니다. 그렇지 않으면 &lt;code&gt;iodata()&lt;/code&gt; 가 수행됩니다. 컴파일이 포함되고 옵션 &lt;code&gt;unicode&lt;/code&gt; 가 지정된 경우 &lt;code&gt;Subject&lt;/code&gt; 및 정규식 모두 유효한 유니 코드 &lt;code&gt;charlists()&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="95cb6c73038fea5d38c77487c266df25c09c2a93" translate="yes" xml:space="preserve">
          <source>If the release is to be upgraded, it must also include the SASL application.</source>
          <target state="translated">릴리스를 업그레이드하려면 SASL 응용 프로그램도 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="209b3e073d6604d9f31c31d6ea0d348f2a50c0c5" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;.</source>
          <target state="translated">릴리스 패키지가 새로운 Erlang 런타임 시스템을 포함하는 경우 지정된 런타임 시스템 &lt;code&gt;{erts,Dir}&lt;/code&gt; 의 &lt;code&gt;bin&lt;/code&gt; 디렉토리가 &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; 에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="363cb8688a551cced7d3018ac246f3d6efe48af3" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;. Some erts executables are not copied by default, if you want to include all executables you can give the &lt;code&gt;erts_all&lt;/code&gt; option.</source>
          <target state="translated">릴리스 패키지는 새로운 얼랑 런타임 시스템을 포함 할 경우, &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; 지정된 런타임 시스템의 디렉토리 &lt;code&gt;{erts,Dir}&lt;/code&gt; 복사됩니다 &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; . 일부 erts 실행 파일은 기본적으로 복사되지 않습니다. 모든 실행 파일을 포함하려면 &lt;code&gt;erts_all&lt;/code&gt; 옵션을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f636f7002f64f569ae3d458b76d340d2355447e2" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue, as this function spawns off a middleman process to act as (a void) destination for such an orphan reply. This feature also makes this function more expensive than &lt;code&gt;call/4&lt;/code&gt; at the caller's end.</source>
          <target state="translated">호출 시간이 초과 된 후 응답이 도착하면이 기능은 중개자 프로세스에서 생성되어 고아 응답의 (빈 공간) 대상으로 작동하므로 발신자의 메시지 큐를 오염시키는 메시지가 없습니다. 또한이 기능을 사용 하면 발신자 쪽의 &lt;code&gt;call/4&lt;/code&gt; 보다이 기능이 더 비쌉니다 .</target>
        </trans-unit>
        <trans-unit id="97bf926e93bf111383afef246646bb072493b10d" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue.</source>
          <target state="translated">통화 시간이 초과 된 후 응답이 도착하면 메시지가 발신자의 메시지 대기열을 오염시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72de28ff26e478c709ccef28f5ec9b72f45a4e23" translate="yes" xml:space="preserve">
          <source>If the report browser is used offline, the reports can be copied to another directory specified when starting the browser. If no such directory is specified, the browser reads reports from the SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt;.</source>
          <target state="translated">보고서 브라우저를 오프라인으로 사용하면 브라우저를 시작할 때 지정된 다른 디렉토리로 보고서를 복사 할 수 있습니다. 이러한 디렉토리를 지정하지 않으면 브라우저는 SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt; 에서 보고서를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d403abf04385b59be919058fa57d3e12c76fe7b9" translate="yes" xml:space="preserve">
          <source>If the request functions for the SFTP channel return &lt;code&gt;{error, timeout}&lt;/code&gt;, no answer was received from the server within the expected time.</source>
          <target state="translated">SFTP 채널에 대한 요청 기능이 &lt;code&gt;{error, timeout}&lt;/code&gt; 리턴 하면 예상 시간 내에 서버로부터 응답을받지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="68fcf1aa779848125b39efeaf9b8566022844620" translate="yes" xml:space="preserve">
          <source>If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, &lt;code&gt;httpd&lt;/code&gt; saves the absolute URI in this field. An Example of an absolute URI is &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</source>
          <target state="translated">요청이 HTTP / 1.1 요청 인 경우 URI는 절대 URI 형식 일 수 있습니다. 이 경우 &lt;code&gt;httpd&lt;/code&gt; 는이 필드에 절대 URI를 저장합니다. 절대 URI의 예는 &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf8c6e0e4e32eeefc924406bd2971a4ed6ef9777" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the answer times out then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = timeout&lt;/code&gt;.</source>
          <target state="translated">요청이 성공적으로 인코딩되어 전송되었지만 응답 시간이 &lt;code&gt;Reason = timeout&lt;/code&gt; 되면 Reason = timeout 으로 &lt;code&gt;handle_error/4&lt;/code&gt; 콜백이 발생 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
