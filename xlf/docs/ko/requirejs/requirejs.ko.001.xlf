<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="requirejs">
    <body>
      <group id="requirejs">
        <trans-unit id="814fdfdfe0abc73fb5e44e5bb62fa796ea1bc9e0" translate="yes" xml:space="preserve">
          <source>&amp;copy; jQuery Foundation and other contributors</source>
          <target state="translated">&amp;copy; jQuery Foundation 및 기타 기고자</target>
        </trans-unit>
        <trans-unit id="116e2c1fd2ece058c5a0364364bae279336cc7e2" translate="yes" xml:space="preserve">
          <source>(If you are familiar with or are using CommonJS modules, then please also see &lt;a href=&quot;commonjs&quot;&gt;CommonJS Notes&lt;/a&gt; for information on how the RequireJS module format maps to CommonJS modules).</source>
          <target state="translated">CommonJS 모듈에 익숙하거나 사용중인 경우 RequireJS 모듈 형식이 CommonJS 모듈에 맵핑되는 방법에 대한 정보는 &lt;a href=&quot;commonjs&quot;&gt;CommonJS 참고 사항&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82a7890eefbb42f66ffb0b96e79f6fd89b2c9340" translate="yes" xml:space="preserve">
          <source>1) You can download the tool on &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;the download page&lt;/a&gt;.</source>
          <target state="translated">1) &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 도구를 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1eb492f8580ac62cf180d901b6d8d9ab286301" translate="yes" xml:space="preserve">
          <source>2) If you are using Node with NPM, you can install r.js globally as part of the &quot;requirejs&quot; package in NPM:</source>
          <target state="translated">2) NPM과 함께 Node를 사용하는 경우 NPM의 &quot;requirejs&quot;패키지의 일부로 r.js를 전체적으로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="223001ca9c5d92a15b5242e49eab360fc3a6ab3d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7</source>
          <target state="translated">&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;도조&lt;/a&gt; 1.7</target>
        </trans-unit>
        <trans-unit id="185e9a68b4bd25da9cafad697c5012278e9b03b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7+</source>
          <target state="translated">&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;도조&lt;/a&gt; 1.7+</target>
        </trans-unit>
        <trans-unit id="29b5095018a8842d228b2cf94f9f94d1950bd084" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; 는 JavaScript로 일부 서비스를 호출하는 방법입니다. 여러 도메인에서 작동하며 스크립트 태그를 통해 HTTP GET 만 있으면되는 서비스 호출에 대한 기존 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="7bed7dfdba5bcd46587bab55a31fdd8625cb4cb7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://enderjs.com/&quot;&gt;Ender&lt;/a&gt;-associated modules like &lt;a href=&quot;https://github.com/ded/bonzo&quot;&gt;bonzo&lt;/a&gt;, &lt;a href=&quot;https://github.com/ded/qwery&quot;&gt;qwery&lt;/a&gt;, &lt;a href=&quot;https://github.com/fat/bean&quot;&gt;bean&lt;/a&gt; and &lt;a href=&quot;https://github.com/ded/domready&quot;&gt;domready&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://enderjs.com/&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/ded/bonzo&quot;&gt;bonzo&lt;/a&gt; , &lt;a href=&quot;https://github.com/ded/qwery&quot;&gt;qwery&lt;/a&gt; , &lt;a href=&quot;https://github.com/fat/bean&quot;&gt;bean&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/ded/domready&quot;&gt;domready&lt;/a&gt; 와 같은 엔더 관련 모듈</target>
        </trans-unit>
        <trans-unit id="df0d4377cf36918105d53b70e20a99e1ebeb6fa6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</target>
        </trans-unit>
        <trans-unit id="d6339a4aaa1eb888ae1c20dc485879c790507768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.commonjs.org/&quot;&gt;CommonJS&lt;/a&gt; defines &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;a module format&lt;/a&gt;. Unfortunately, it was defined without giving browsers equal footing to other JavaScript environments. Because of that, there are CommonJS spec proposals for &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;Transport formats&lt;/a&gt; and an &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Async/A&quot;&gt;asynchronous require&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.commonjs.org/&quot;&gt;CommonJS&lt;/a&gt; 는 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;모듈 형식을&lt;/a&gt; 정의 합니다 . 불행히도, 브라우저를 다른 JavaScript 환경과 동일하게 사용하지 않고 정의되었습니다. 따라서 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;전송 형식에&lt;/a&gt; 대한 CommonJS 스펙 제안 과 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Async/A&quot;&gt;비동기 요구가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="169caf5485a51e42978bcea9564913573efbfa82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d4af46f9ebdadab5fefa4632360a2278fffd09" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74294756b9d6920b0915c8538a76d59ebe267ac3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2374aadda0e5d5c377cdbfce99e8a569d63134ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/phiggins42/has.js&quot;&gt;has.js&lt;/a&gt; is a great tool to that adds easy feature detection for your project. There is some optimizer support for optimizing code paths for has.js tests.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/phiggins42/has.js&quot;&gt;has.js&lt;/a&gt; 는 프로젝트에 기능을 쉽게 감지 할 수있는 훌륭한 도구입니다. has.js 테스트를 위해 코드 경로를 최적화하기위한 최적화 프로그램 지원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3b8ef35a670bbe9cdf3e050dd3299ce78d4cba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/requirejs/example-multipage&quot;&gt;requirejs/example-multipage&lt;/a&gt; is an example of a project that has multiple pages, but shares a common configuration and a common optimized build layer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/requirejs/example-multipage&quot;&gt;requirejs / example-multipage&lt;/a&gt; 는 여러 페이지가 있지만 공통 구성과 최적화 된 빌드 계층을 공유하는 프로젝트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="197f40cae363a637d221e795d930e25e35b4402d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Optionally call define()&lt;/a&gt; if it is available. The nice thing is you can still code your library without relying on AMD, just participate if it is available. This allows consumers of your modules to:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;&lt;/a&gt;가능한 경우 define ()을 호출하십시오 . 좋은 점은 AMD에 의존하지 않고 라이브러리를 코딩 할 수 있다는 것입니다. 사용 가능한 경우 참여하십시오. 이를 통해 모듈 소비자는 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d837c5645dc6d885d6f5f17697f12c5bf3eae3a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03d6178a0b3f875875c504ed71a5ca8ab1663e0" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;loadBuildInfo&quot;&gt;Build considerations&lt;/b&gt;: The optimizer traces dependencies &lt;b&gt;synchronously&lt;/b&gt; to simplify the optimization logic. This is different from how require.js in the browser works, and it means that only plugins that can satisfy their dependencies synchronously should participate in the optimization steps that allow inlining of loader plugin values. Otherwise, the plugin should just call load() immediately if &lt;code&gt;config.isBuild&lt;/code&gt; is true:</source>
          <target state="translated">&lt;b id=&quot;loadBuildInfo&quot;&gt;빌드 고려 사항&lt;/b&gt; : 옵티마이 저는 최적화 로직을 단순화하기 위해 종속성을 &lt;b&gt;동 기적&lt;/b&gt; 으로 추적 합니다. 이는 브라우저에서 require.js가 작동하는 방식과 다릅니다. 따라서 종속성을 동 기적으로 만족시킬 수있는 플러그인 만 로더 플러그인 값을 인라인 할 수있는 최적화 단계에 참여해야합니다. 그렇지 않으면 &lt;code&gt;config.isBuild&lt;/code&gt; 가 true 인 경우 플러그인은 즉시 load ()를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="506bd15924c41f4004b36be9eb39edff02ffe729" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apiload&quot;&gt;load&lt;/a&gt;&lt;/b&gt;: A function that is called to load a resource. This is the only mandatory API method that needs to be implemented for the plugin to be useful.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apiload&quot;&gt;load&lt;/a&gt;&lt;/b&gt; : 리소스를로드하기 위해 호출되는 함수입니다. 이것은 플러그인이 유용하도록 구현되어야하는 유일한 필수 API 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="5c05204e40494673270518722d3577d844352a0f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apinormalize&quot;&gt;normalize&lt;/a&gt;&lt;/b&gt;: A function to normalize the resource name. This is useful in providing optimal caching and optimization, but only needed if the resource name is not a module name.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apinormalize&quot;&gt;normalize&lt;/a&gt;&lt;/b&gt; : 리소스 이름을 정규화하는 함수입니다. 이는 최적의 캐싱 및 최적화를 제공하는 데 유용하지만 자원 이름이 모듈 이름이 아닌 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="67620f32dc794387af4268db0a195d2c0bec7533" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apipluginbuilder&quot;&gt;pluginBuilder&lt;/a&gt;&lt;/b&gt;: A module name string for a module that should be used in the optimizer to do optimization work. That module is used instead of the plugin module when the optimizer runs.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apipluginbuilder&quot;&gt;pluginBuilder&lt;/a&gt;&lt;/b&gt; : 최적화 작업을 수행하기 위해 최적화 프로그램에서 사용해야하는 모듈의 모듈 이름 문자열입니다. 최적화 프로그램이 실행될 때 플러그인 모듈 대신 해당 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="05c890f5aa6072a9d2a6646bd5b851f257e269fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt;&lt;/b&gt;: used by the optimizer to indicate when the plugin should write out a representation of the resource in the optimized file.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt;&lt;/b&gt; : 최적화 프로그램이 플러그인이 최적화 된 파일에서 리소스의 표현을 작성해야하는 시점을 나타 내기 위해 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a2110dc4f9c4fa811fea913d44cc4b46b8d448f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;However&lt;/b&gt;, it will not remove the module from other modules that are already defined and got a handle on that module as a dependency when they executed. So it is really only useful to use in error situations when no other modules have gotten a handle on a module value, or as part of any future module loading that may use that module. See the &lt;a href=&quot;#errbacks&quot;&gt;errback section&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;b&gt;그러나&lt;/b&gt; 이미 정의되어 있고 해당 모듈을 실행할 때 해당 모듈에 대한 핸들을 가진 다른 모듈에서 모듈을 제거하지는 않습니다. 따라서 다른 모듈이 모듈 값을 처리하지 않았거나 해당 모듈을 사용할 수있는 향후 모듈로드의 일부로 오류 상황에서 사용하는 것이 실제로 유용합니다. 예제 는 &lt;a href=&quot;#errbacks&quot;&gt;errback 섹션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd0efe11af170b5b34fae3a5768842f92021a2f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important notes for &quot;shim&quot; config:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&quot;shim&quot;구성에 대한 중요 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e6d7e23c20b9c92a38f7ebaf9c629b50c1c46ea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important optimizer notes for &quot;shim&quot; config&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;&quot;shim&quot;구성에 대한 중요한 최적화 참고 사항&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="5452f95ab3f5431d3e0d9ea5bc5eb65ed9d54dbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOTE&lt;/b&gt;: If you do set enforceDefine: true, and you use data-main=&quot;&quot; to load your main JS module, then that main JS module &lt;b&gt;must call define()&lt;/b&gt; instead of require() to load the code it needs. The main JS module can still call require/requirejs to set config values, but for loading modules it should use define().</source>
          <target state="translated">&lt;b&gt;참고&lt;/b&gt; : enforceDefine : true를 설정하고 data-main = &quot;&quot;을 사용하여 기본 JS 모듈을로드하는 경우 해당 기본 JS 모듈 은 require () 대신 &lt;b&gt;define ()을 호출&lt;/b&gt; 하여 필요한 코드를로드해야합니다. 기본 JS 모듈은 여전히 ​​require / requirejs를 호출하여 구성 값을 설정할 수 있지만 모듈을로드하려면 define ()을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5013e4ed689d2a3ffaaa1dc5f688b4fa1c3b1c08" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS &quot;timeout&quot; error. If this is a problem either increase the &lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt; configuration, or just use domReady as a module and call domReady() inside the require() callback.</source>
          <target state="translated">&lt;b&gt;참고 :&lt;/b&gt; 문서를로드하는 데 시간이 오래 걸리는 경우 (매우 큰 문서이거나 DOM 완료를 차단하는 큰 JS 파일을로드하는 HTML 스크립트 태그가있는 HTML 스크립트 태그가있는 경우) 로더 플러그인으로 domReady를 사용하면 RequireJS &quot; timeout &quot;error. 이것이 문제라면 &lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt; 구성을 늘리 거나 domReady를 모듈로 사용하고 require () 콜백 내에서 domReady ()를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="df71ff1e089733f190c702e16b09f3771f6c4081" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; It is best to use &lt;code&gt;var require = {}&lt;/code&gt; and do not use &lt;code&gt;window.require = {}&lt;/code&gt;, it will not behave correctly in IE.</source>
          <target state="translated">&lt;b&gt;참고 : &lt;/b&gt; &lt;code&gt;var require = {}&lt;/code&gt; 을 사용하는 것이 가장 좋으며 &lt;code&gt;window.require = {}&lt;/code&gt; 사용하지 않으면 IE에서 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4470cd3f81024ca53c77a075e808184e3d5f48ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: errbacks only work with callback-style require calls, not define() calls. define() is only for declaring modules.</source>
          <target state="translated">&lt;b&gt;참고&lt;/b&gt; : errback은 define () 호출이 아닌 콜백 스타일 요구 호출에서만 작동합니다. define ()은 모듈 선언 전용입니다.</target>
        </trans-unit>
        <trans-unit id="1658d751a5e1864b6645a9132816926270ff006e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: paths fallbacks only work for exact module ID matches. This is different from normal paths config which can apply to any part of a module ID prefix segment. Fallbacks are targeted more for unusual error recovery, not a generic path search path solution, since those are inefficient in the browser.</source>
          <target state="translated">&lt;b&gt;참고&lt;/b&gt; : 경로 폴백은 정확한 모듈 ID 일치에 대해서만 작동합니다. 이는 모듈 ID 접두사 세그먼트의 모든 부분에 적용 할 수있는 일반 경로 구성과 다릅니다. 폴백은 브라우저에서 비효율적이므로 일반적인 경로 검색 경로 솔루션이 아닌 비정상적인 오류 복구에 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="2213308d4ce3eb444b284f69d04a49e1e39fe908" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: the plugin and its dependencies should be able to run in non-browser environments like Node and Nashorn. If they cannot, you should use an alternate &lt;a href=&quot;#apipluginbuilder&quot;&gt;plugin builder&lt;/a&gt; module that can run in those environments so that they can participate in optimization builds.</source>
          <target state="translated">&lt;b&gt;참고&lt;/b&gt; : 플러그인 및 해당 종속성은 Node 및 Nashorn과 같은 브라우저가 아닌 환경에서 실행될 수 있어야합니다. 이들이 불가능한 경우, 해당 환경에서 실행할 수 있는 대체 &lt;a href=&quot;#apipluginbuilder&quot;&gt;플러그인 빌더&lt;/a&gt; 모듈을 사용하여 최적화 빌드에 참여할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1562ca8e4b27fe43c636be687ba000c82b1a7e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;config&lt;/b&gt;: Object. A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. The i18n! plugin uses this to get the current locale, if the web app wants to force a specific locale. The optimizer will set an &lt;b&gt;isBuild&lt;/b&gt; property in the config to true if this plugin (or pluginBuilder) is being called as part of an optimizer build.</source>
          <target state="translated">&lt;b&gt;config&lt;/b&gt; : 객체. 구성 객체. 최적화 프로그램과 웹 앱이 구성 정보를 플러그인에 전달하는 방법입니다. i18n! 웹 앱에서 특정 로캘을 적용하려는 경우 플러그인은 현재 로캘을 가져옵니다. 이 플러그인 (또는 pluginBuilder)이 옵티 마이저 빌드의 일부로 호출되는 경우 옵티마이 저는 구성 의 &lt;b&gt;isBuild&lt;/b&gt; 특성을 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0633fd52ca339aa36fe803e1e7c1e235a965582c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data&lt;/b&gt;: Object. Information about the layer. Only has two properties:</source>
          <target state="translated">&lt;b&gt;data&lt;/b&gt; : 객체. 레이어에 대한 정보. 두 가지 속성 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ae9f09e83410324efa2c5c493968846e5a710b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;fileName&lt;/b&gt;: String. The name of the file to write. You can use parentRequire.toUrl() with a relative path to generate a file name that will be inside the build output directory.</source>
          <target state="translated">&lt;b&gt;fileName&lt;/b&gt; : 문자열. 쓸 파일의 이름입니다. parentRequire.toUrl ()을 상대 경로와 함께 사용하여 빌드 출력 디렉토리 내에있을 파일 이름을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d42af54c2cce4f8e3c824aa7095ba8adac48e63" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;moduleName&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; resource name.</source>
          <target state="translated">&lt;b&gt;moduleName&lt;/b&gt; : 문자열. &lt;b&gt;정규화 된&lt;/b&gt; 자원 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f4fa4b373e19cffd64c341b383157951022e7fb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; resource name.</source>
          <target state="translated">&lt;b&gt;이름&lt;/b&gt; : 문자열. &lt;b&gt;정규화 된&lt;/b&gt; 자원 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c9b575c2614edbef93cb7cf9187a273ac90b40ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The name of the resource to load. This is the part after the ! separator in the name. So, if a module asks for 'foo!something/for/foo', the foo module's load function will receive 'something/for/foo' as the name.</source>
          <target state="translated">&lt;b&gt;이름&lt;/b&gt; : 문자열. 로드 할 리소스의 이름입니다. 이것은 다음 부분입니다! 이름의 구분 기호. 따라서 모듈이 'foo! something / for / foo'를 요청하면 foo 모듈의로드 함수는 이름으로 'something / for / foo'를받습니다.</target>
        </trans-unit>
        <trans-unit id="a7e430f692ddd0f1696c7bf9d5e7600c2702e144" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The resource name to normalize.</source>
          <target state="translated">&lt;b&gt;이름&lt;/b&gt; : 문자열. 정규화 할 리소스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1de1ad4fff586a6f009688331bf3dac19f43a9e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: the module name of the layer. May be undefined.</source>
          <target state="translated">&lt;b&gt;name&lt;/b&gt; : 레이어의 모듈 이름. 정의되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8637b053ea38a61892113ae66f0bdad8cc69085" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;normalize&lt;/b&gt; is called to normalize the name used to identify a resource. Some resources could use relative paths, and need to be normalized to the full path. normalize is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;자원을 식별하는 데 사용되는 이름을 정규화하기 위해 &lt;b&gt;normalize&lt;/b&gt; 가 호출됩니다. 일부 리소스는 상대 경로를 사용할 수 있으므로 전체 경로로 정규화해야합니다. 다음과 같은 인수로 normalize가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9c155f866c3dfbd6ddcaf1a21d533bc69c8f253f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;normalize&lt;/b&gt;: Function. A function that can be called to normalize a regular module name.</source>
          <target state="translated">&lt;b&gt;정규화&lt;/b&gt; : 기능. 일반 모듈 이름을 정규화하기 위해 호출 할 수있는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="518ae45a2c4e092a30ef6d374445ebbbc375d6cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;onLayerEnd&lt;/b&gt; is only used by the optimizer, and is only supported in 2.1.0 or later of the optimizer. It is called after the modules for the layer have been written to the layer. It is useful to use if you need some code that should go at the end of the layer, or if the plugin needs to reset some internal state.</source>
          <target state="translated">&lt;b&gt;onLayerEnd&lt;/b&gt; 는 옵티 마이저에서만 사용되며 옵티 마이저 2.1.0 이상에서만 지원됩니다. 계층에 대한 모듈이 계층에 작성된 후에 호출됩니다. 레이어의 끝에 가야 할 코드가 필요하거나 플러그인이 일부 내부 상태를 재설정해야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="624c08fd16b69bcc3349bb27e754504d9e657892" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;onload&lt;/b&gt;: Function. A function to call with the value for name. This tells the loader that the plugin is done loading the resource. &lt;b&gt;onload.error()&lt;/b&gt; can be called, passing an error object to it, if the plugin detects an error condition that means the resource will fail to load correctly.</source>
          <target state="translated">&lt;b&gt;onload&lt;/b&gt; : 기능. name 값으로 호출하는 함수입니다. 이것은 로더에게 리소스로드가 완료되었음을 알려줍니다. 플러그인이 오류 상태를 감지하여 자원이 올바르게로드되지 않는 경우 오류 오브젝트를 전달하여 &lt;b&gt;onload.error ()&lt;/b&gt; 를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f84b038f0ab819e5b8274b7f2ce93bdce6a23e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.defined(moduleName)&lt;/b&gt;: Returns true if the module has already been loaded and defined. Used to be called require.isDefined before RequireJS 0.25.0.</source>
          <target state="translated">&lt;b&gt;parentRequire.defined (moduleName)&lt;/b&gt; : 모듈이 이미로드되어 정의 된 경우 true를 리턴합니다. RequireJS 0.25.0 이전에 require.isDefined라고 불렀습니다.</target>
        </trans-unit>
        <trans-unit id="015e07ffad07b4f74fe69ffc5fd5e560ba778a7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.specified(moduleName)&lt;/b&gt;: Returns true if the module has already been requested or is in the process of loading and should be available at some point.</source>
          <target state="translated">&lt;b&gt;parentRequire.specified (moduleName)&lt;/b&gt; : 모듈이 이미 요청되었거나로드 중이며 특정 시점에 사용 가능해야하는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ba9bfc72098ec06b30b3641b2ed5add4ee4d4b6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.toUrl(moduleResource)&lt;/b&gt;:where moduleResource is a module name plus an extension. For instance &quot;view/templates/main.html&quot;. It will return a full path to the resource, obeying any RequireJS configuration.</source>
          <target state="translated">&lt;b&gt;parentRequire.toUrl (moduleResource)&lt;/b&gt; : 여기서 moduleResource는 모듈 이름과 확장자입니다. 예를 들어 &quot;view / templates / main.html&quot;입니다. RequireJS 구성에 따라 리소스의 전체 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="622d5743c01e802124c82780fd2ca472a7445f78" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire&lt;/b&gt;: Function. A local &quot;require&quot; function to use to load other modules. This function will resolve relative module names relative to the module name that asked for this plugin resource. If the loader plugin wants to &lt;code&gt;require()&lt;/code&gt; something relative to its own ID, it can ask for a &lt;code&gt;require&lt;/code&gt; in its own &lt;code&gt;define&lt;/code&gt; call. This require function has some utilities on it:</source>
          <target state="translated">&lt;b&gt;parentRequire&lt;/b&gt; : 함수. 다른 모듈을로드하는 데 사용할 로컬 &quot;필수&quot;기능. 이 함수는이 플러그인 리소스를 요청한 모듈 이름을 기준으로 상대 모듈 이름을 확인합니다. 로더 플러그인이 자신의 ID와 관련된 뭔가 를 &lt;code&gt;require()&lt;/code&gt; 하려는 경우 자체 &lt;code&gt;define&lt;/code&gt; 호출 에서 &lt;code&gt;require&lt;/code&gt; 수 있습니다 . 이 기능에는 일부 유틸리티가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1d2aac6b06f25bcc6a08613d6ff429b73be408fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire&lt;/b&gt;: Function. A local &quot;require&quot; function. The main use of this in writeFile is for calling parentRequire.toUrl() to generate file paths that are inside the build directory.</source>
          <target state="translated">&lt;b&gt;parentRequire&lt;/b&gt; : 함수. 로컬 &quot;필수&quot;기능. writeFile에서 이것을 주로 사용하는 것은 빌드 디렉토리 내에있는 파일 경로를 생성하기 위해 parentRequire.toUrl ()을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0134a16548c6c6645647a4752ed2ea5efb6a857" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;path&lt;/b&gt;: the file path of the layer. May be undefined, particularly if the output is just to a string that is consumed by another script.</source>
          <target state="translated">&lt;b&gt;path&lt;/b&gt; : 레이어의 파일 경로입니다. 특히 출력이 다른 스크립트에서 사용하는 문자열에 대한 경우 정의되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a02d39c2198b5eb062ebbbd692afeb0af5f4b077" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;pluginBuilder&lt;/b&gt; can be a string that points to another module to use instead of the current plugin when the plugin is used as part of an optimizer build.</source>
          <target state="translated">&lt;b&gt;pluginBuilder&lt;/b&gt; 는 플러그인이 최적화 프로그램 빌드의 일부로 사용될 때 현재 플러그인 대신 사용할 다른 모듈을 가리키는 문자열 &lt;b&gt;일&lt;/b&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bccfaebe5d20d93dbb92eac6c4e4c2755184488" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;pluginName&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; name for the plugin. Most plugins will not be authored with a name (they will be anonymous plugins) so it is useful to know the normalized name for the plugin module for use in the optimized file.</source>
          <target state="translated">&lt;b&gt;pluginName&lt;/b&gt; : 문자열. 플러그인 의 &lt;b&gt;정규화 된&lt;/b&gt; 이름입니다. 대부분의 플러그인은 이름으로 작성되지 않으므로 (익명 플러그인 임) 최적화 된 파일에서 사용하기 위해 플러그인 모듈의 정규화 된 이름을 아는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="806f2c5413bd1f88dda933d6d9bf4ca71182ed30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;text&lt;/b&gt;: String. The contents of the file. Must be UTF-8 encoded.</source>
          <target state="translated">&lt;b&gt;text&lt;/b&gt; : 문자열. 파일의 내용 UTF-8로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2b37b8befddf87d1488ad007823a5c1cb02a63b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;text&lt;/b&gt;: String. The string of JavaScript to evaluate.</source>
          <target state="translated">&lt;b&gt;text&lt;/b&gt; : 문자열. 평가할 JavaScript 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2cb55635b083fecb23646b281888e2d3a8e8e1af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt; is only used by the optimizer, and it only needs to be implemented if the plugin can output something that would belong in an optimized layer. It is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;write&lt;/b&gt; 는 옵티 마이저에서만 사용하며 플러그인이 최적화 된 레이어에 속하는 것을 출력 할 수있는 경우에만 구현하면됩니다. 다음과 같은 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5685d5466354ace13f25dd4ff5fa42d06b2d956d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with a string of output to write to the optimized file. This function also contains a property function, &lt;b&gt;write.asModule(moduleName, text)&lt;/b&gt;. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(&quot;&quot;) dependencies that need to be pulled out for the optimized file. asModule is useful for text transform plugins, like a CoffeeScript plugin.</source>
          <target state="translated">&lt;b&gt;쓰기&lt;/b&gt; : 기능. 최적화 된 파일에 쓰기 위해 출력 문자열로 호출 할 함수입니다. 이 함수에는 속성 함수 &lt;b&gt;write.asModule (moduleName, text)&lt;/b&gt; 도 포함되어 있습니다 . asModule은 이름 삽입이 필요하거나 최적화 된 파일을 위해 꺼내야하는 암시 적 require ( &quot;&quot;) 종속성을 포함하는 익명 정의 호출이있는 모듈을 작성하는 데 사용될 수 있습니다. asModule은 CoffeeScript 플러그인과 같은 텍스트 변환 플러그인에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cddc0bc3ed4ecb0a91508e3c705f0c73d4bc5f66" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with a string of output to write to the optimized layer. &lt;b&gt;Modules should not be written out&lt;/b&gt; in this call. They will not be normalized correctly for coexistence with other define() calls already in the file. It is useful only for writing out non-define() code.</source>
          <target state="translated">&lt;b&gt;쓰기&lt;/b&gt; : 기능. 최적화 된 레이어에 쓰기 위해 출력 문자열로 호출 할 함수입니다. 이 호출에서 &lt;b&gt;모듈을 작성해서는 안됩니다&lt;/b&gt; . 파일에 이미있는 다른 define () 호출과 공존하기 위해 올바르게 정규화되지 않습니다. 비정의 () 코드를 작성하는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="21d71fbeac0c9a9225a98971c14d9b7642d2ce1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with two arguments:</source>
          <target state="translated">&lt;b&gt;쓰기&lt;/b&gt; : 기능. 두 개의 인수로 호출 할 함수 :</target>
        </trans-unit>
        <trans-unit id="e1d47299b04571e05be6b9f2db9c64d7f599202c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;writeFile&lt;/b&gt; is only used by the optimizer, and it only needs to be implemented if the plugin needs to write out an alternate version of a dependency that is handled by the plugin. It is a bit expensive to scan all modules in a project to look for all plugin dependencies, so this writeFile method will only be called if &lt;b&gt;optimizeAllPluginResources: true&lt;/b&gt; is in the build profile for the RequireJS optimizer. writeFile is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;writeFile&lt;/b&gt; 은 옵티 마이저에서만 사용하며, 플러그인이 처리하는 종속성의 대체 버전을 플러그인에서 작성해야하는 경우에만 구현해야합니다. 모든 플러그인 종속성을 찾기 위해 프로젝트의 모든 모듈을 스캔하는 것은 약간 비싸므로,이 writeFile 메소드는 &lt;b&gt;optimizeAllPluginResources : true&lt;/b&gt; 가 RequireJS 최적화 프로그램의 빌드 프로파일에있는 경우에만 호출됩니다 . writeFile은 다음 인수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7a9de7b1060504a09fced2340f4cefe3979e7d78" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;commandargs&quot;&gt;Command line arguments are interchangeable with a build profile properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;commandargs&quot;&gt;명령 행 인수는 빌드 프로파일 특성과 호환 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63567fbc5013d2bad98217cd761076a9914f3555" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;mainConfigFile&quot;&gt;Config settings in your main JS module that is loaded in the browser at runtime &lt;strong&gt;are not read by default&lt;/strong&gt; by the optimizer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;mainConfigFile&quot;&gt;런타임시 브라우저에로드되는 기본 JS 모듈의 구성 설정은 &lt;strong&gt;기본적&lt;/strong&gt; 으로 옵티 마이저에서 &lt;strong&gt;읽지 않습니다.&lt;/strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd6a6e70e53ade44e72789a459c1f511a24523b4" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;optionpaths&quot;&gt;Relative path resolution rules:&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong id=&quot;optionpaths&quot;&gt;상대 경로 해결 규칙 :&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="688e93c7f23b0016b30ae1c02fe374c99ad602c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;&lt;/strong&gt;: the root path to use for all module lookups. So in the above example, &quot;my/module&quot;'s script tag will have a src=&quot;/another/path/my/module.js&quot;. baseUrl is &lt;strong&gt;not&lt;/strong&gt; used when loading plain .js files (indicated by a dependency string &lt;a href=&quot;#jsfiles&quot;&gt;starting with a slash, has a protocol, or ends in .js&lt;/a&gt;), those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;&lt;/strong&gt; : 모든 모듈 조회에 사용할 루트 경로입니다. 위의 예에서 &quot;my / module&quot;의 스크립트 태그는 src = &quot;/ another / path / my / module.js&quot;를 갖습니다. 일반 .js 파일 (&lt;a href=&quot;#jsfiles&quot;&gt; 슬래쉬로 시작하거나 프로토콜이 있거나 .js로 끝나는&lt;/a&gt; 종속성 문자열로 표시)을로드 할 때는baseUrl이사용&lt;strong&gt; 되지 않으며&lt;/strong&gt; , 해당 문자열은 그대로 사용되므로 a.js와 b.js는 위 스 니펫이 포함 된 HTML 페이지와 동일한 디렉토리에서로드됩니다.</target>
        </trans-unit>
        <trans-unit id="1acd662f148a50d547ed8ad4f98e479065a4f997" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-bundles&quot;&gt;bundles&lt;/a&gt;&lt;/strong&gt;: Introduced in RequireJS 2.1.10: allows configuring multiple module IDs to be found in another script. Example:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-bundles&quot;&gt;번들&lt;/a&gt;&lt;/strong&gt; : RequireJS 2.1.10에 도입 : 다른 스크립트에서 여러 모듈 ID를 찾을 수 있도록 구성 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="085af28d539841cfe94239340a377b5e8edb553b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-callback&quot;&gt;callback&lt;/a&gt;&lt;/strong&gt;: A function to execute after &lt;strong&gt;deps&lt;/strong&gt; have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's &lt;strong&gt;deps&lt;/strong&gt; array has been loaded.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-callback&quot;&gt;콜백&lt;/a&gt;&lt;/strong&gt; :&lt;strong&gt; 뎁스&lt;/strong&gt; 가로드 된후 실행할 함수입니다. require.js가로드되기 전에 require가 구성 객체로 정의되어 있고 구성의&lt;strong&gt; deps&lt;/strong&gt; 배열이로드 된후 필요한 함수를 지정하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="326db44e3cbe2964c4c00e3827eaeb99ed4c2e9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-context&quot;&gt;context&lt;/a&gt;&lt;/strong&gt;: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the &lt;a href=&quot;#multiversion&quot;&gt;Multiversion Support&lt;/a&gt; section.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-context&quot;&gt;context&lt;/a&gt;&lt;/strong&gt; : 로딩 컨텍스트에 부여 할 이름. 이렇게하면 각 최상위 요구 호출이 고유 한 컨텍스트 문자열을 지정하는 한 require.js가 페이지에 여러 버전의 모듈을로드 할 수 있습니다. 올바르게 사용하려면&lt;a href=&quot;#multiversion&quot;&gt; 멀티 버전 지원&lt;/a&gt; 섹션을참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca0d7afdccb360dffa934a77db230250e50afaf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-deps&quot;&gt;deps&lt;/a&gt;&lt;/strong&gt;: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a &lt;code&gt;require([])&lt;/code&gt; call, but done as soon as the loader has processed the configuration. &lt;strong&gt;It does not block&lt;/strong&gt; any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-deps&quot;&gt;deps&lt;/a&gt;&lt;/strong&gt; :로드 할 종속성의 배열입니다. require.js가로드되기 전에 require가 구성 객체로 정의되고 require ()가 정의되는 즉시로드 할 종속성을 지정하려는 경우에 유용합니다. deps를 사용하는 것은 &lt;code&gt;require([])&lt;/code&gt; 호출을하는 것과 같지만 로더가 구성을 처리하자마자 수행됩니다. 다른 require () 호출이 모듈에 대한 요청을 시작하는&lt;strong&gt; 것을 차단하지 않으며&lt;/strong&gt; 구성 블록의 일부로 비동기식으로로드 할 일부 모듈을 지정하는 방법 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="0d247940698d8e6f686c0bb77049d6c8da63c7da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;&lt;/strong&gt;: If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See &lt;a href=&quot;#ieloadfail&quot;&gt;Catching load failures in IE&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;&lt;/strong&gt; : true로 설정하면 define ()을 호출하지 않거나 shim에서 확인할 수있는 문자열 내보내기 문자열 값이있는 스크립트가로드되면 오류가 발생합니다. 자세한 내용&lt;a href=&quot;#ieloadfail&quot;&gt; 은 IE에서로드 실패 잡기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6138f55b500825f984e6dbb333dcd329837caa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-map&quot;&gt;map&lt;/a&gt;&lt;/strong&gt;: For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-map&quot;&gt;map&lt;/a&gt;&lt;/strong&gt; : 주어진 모듈 접두사에 대해 주어진 ID로 모듈을로드하는 대신 다른 모듈 ID로 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="95681aafd1c488d7f8f14732850e7d8b209998c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-moduleconfig&quot;&gt;config&lt;/a&gt;&lt;/strong&gt;: There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the &lt;b&gt;config&lt;/b&gt; option for requirejs.config(). Modules can then read that info by asking for the special dependency &quot;module&quot; and calling &lt;b&gt;module.config()&lt;/b&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-moduleconfig&quot;&gt;config&lt;/a&gt;&lt;/strong&gt; : 구성 정보를 모듈에 전달해야하는 공통점이 있습니다. 이 구성 정보는 일반적으로 응용 프로그램의 일부로 알려져 있으며 모듈에 전달할 수있는 방법이 필요합니다. RequireJS에서는 requirejs.config()에 대한&lt;b&gt; 구성&lt;/b&gt; 옵션을사용하여 수행됩니다. 그런 다음 모듈은 특수 종속성 &quot;module&quot;을 요청하고&lt;b&gt; module.config ()를&lt;/b&gt; 호출하여 해당 정보를 읽을 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="ac39bdc204ad820f4dd2e31dd8517ff27d56c927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-nodeIdCompat&quot;&gt;nodeIdCompat&lt;/a&gt;&lt;/strong&gt;: Node treats module ID &lt;code&gt;example.js&lt;/code&gt; and &lt;code&gt;example&lt;/code&gt; the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to &lt;code&gt;true&lt;/code&gt; to avoid resolution issues. This option only applies to treating the &quot;.js&quot; suffix differently, it does not do any other node resolution and evaluation matching such as .json file handling (JSON handling needs a 'json!' loader plugin anyway). Available in 2.1.10 and greater.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-nodeIdCompat&quot;&gt;nodeIdCompat&lt;/a&gt;&lt;/strong&gt; : Node는 모듈 ID &lt;code&gt;example.js&lt;/code&gt; 와 &lt;code&gt;example&lt;/code&gt; 를 동일하게취급합니다. 기본적으로 이들은 RequireJS에서 서로 다른 두 개의 ID입니다. npm에서 설치된 모듈을 사용하게되면해결 문제를 피하기위해이 구성 값을 &lt;code&gt;true&lt;/code&gt; 로설정해야합니다. 이 옵션은 &quot;.js&quot;접미사를 다르게 취급하는 경우에만 적용되며 .json 파일 처리 (JSON 처리에는 'json!'로더 플러그인이 필요합니다)와 같은 다른 노드 확인 및 평가 일치를 수행하지 않습니다. 2.1.10 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="99510d1860c925d6763db57dff66af25efccbf3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-packages&quot;&gt;packages&lt;/a&gt;&lt;/strong&gt;: configures loading modules from CommonJS packages. See the &lt;a href=&quot;#packages&quot;&gt;packages topic&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-packages&quot;&gt;패키지&lt;/a&gt;&lt;/strong&gt; : CommonJS 패키지에서로드 모듈을 구성합니다. 자세한 정보는&lt;a href=&quot;#packages&quot;&gt; 패키지 주제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06ed9a797e36865b0f29ed4687132d5027a3f359" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-paths&quot;&gt;paths&lt;/a&gt;&lt;/strong&gt;: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a &quot;/&quot; or has a URL protocol in it (&quot;like http:&quot;). Using the above sample config, &quot;some/module&quot;'s script tag will be src=&quot;/another/path/some/v1.0/module.js&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-paths&quot;&gt;paths&lt;/a&gt;&lt;/strong&gt; : baseUrl에서 직접 찾을 수없는 모듈 이름의 경로 맵핑. 경로 설정이 &quot;/&quot;로 시작하거나 URL 프로토콜이없는 경우 ( &quot;http :&quot;와 같이) 경로 설정은 baseUrl에 상대적인 것으로 간주됩니다. 위의 샘플 설정을 사용하면 &quot;some / module&quot;의 스크립트 태그는 src = &quot;/ another / path / some / v1.0 / module.js&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="cc259753f530f4d5d7cbdb6355d3a8dab3314d7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-scriptType&quot;&gt;scriptType&lt;/a&gt;&lt;/strong&gt;: Specify the value for the type=&quot;&quot; attribute used for script tags inserted into the document by RequireJS. Default is &quot;text/javascript&quot;. To use Firefox's JavaScript 1.8 features, use &quot;text/javascript;version=1.8&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-scriptType&quot;&gt;scriptType&lt;/a&gt;&lt;/strong&gt; :&lt;strong&gt; RequireJS&lt;/strong&gt; 가 문서에 삽입 한 스크립트 태그에 사용되는 type = &quot;&quot;속성의 값을 지정하십시오. 기본값은 &quot;text / javascript&quot;입니다. Firefox의 JavaScript 1.8 기능을 사용하려면 &quot;text / javascript; version = 1.8&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="371b64def2675a68c091d43c2a65d306af3cb9b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt;&lt;/strong&gt;: Configure the dependencies, exports, and custom initialization for older, traditional &quot;browser globals&quot; scripts that do not use define() to declare the dependencies and set a module value.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt;&lt;/strong&gt; : define ()을 사용하여 종속성을 선언하고 모듈 값을 설정하지 않는 기존의 &quot;브라우저 글로벌&quot;스크립트에 대한 종속성, 내보내기 및 사용자 정의 초기화를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="5ae95b324cd867a143c0b42db1f26232e9890ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-skipDataMain&quot;&gt;skipDataMain&lt;/a&gt;&lt;/strong&gt;: Introduced in RequireJS 2.1.9: If set to &lt;code&gt;true&lt;/code&gt;, skips the &lt;a href=&quot;#data-main&quot;&gt;data-main attribute scanning&lt;/a&gt; done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-skipDataMain&quot;&gt;skipDataMain&lt;/a&gt;&lt;/strong&gt; : RequireJS 2.1.9에 도입 : &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 ,모듈 로딩을 시작하기 위해 수행 된&lt;a href=&quot;#data-main&quot;&gt; data-main 속성 스캐닝을&lt;/a&gt; 건너 뜁니다. 페이지의 다른 RequireJS 라이브러리와 상호 작용할 수있는 유틸리티 라이브러리에 RequireJS가 포함되어 있고 임베드 된 버전이 데이터 기본로드를 수행하지 않아야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ca72d7e0434fdb9fead21c9434f101648dcbd013" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-urlArgs&quot;&gt;urlArgs&lt;/a&gt;&lt;/strong&gt;: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-urlArgs&quot;&gt;urlArgs&lt;/a&gt;&lt;/strong&gt; : RequireJS가 자원을 페치하기 위해 사용하는 URL에 추가 된 추가 쿼리 문자열 인수. 브라우저 나 서버가 올바르게 구성되지 않은 경우 버스트 캐시에 가장 유용합니다. urlArgs에 대한 캐시 버스트 설정 예 :</target>
        </trans-unit>
        <trans-unit id="8edef7869b3aeadbaede9416bcfe954daf6b604d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt;&lt;/strong&gt;: The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt;&lt;/strong&gt; : 스크립트로드를 포기하기 전에 대기하는 시간 (초)입니다. 0으로 설정하면 시간 초과가 비활성화됩니다. 기본값은 7 초입니다.</target>
        </trans-unit>
        <trans-unit id="b9f67b72412ffa73c5ba387b645c9c5325fe18bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-xhtml&quot;&gt;xhtml&lt;/a&gt;&lt;/strong&gt;: If set to true, document.createElementNS() will be used to create script elements.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-xhtml&quot;&gt;xhtml&lt;/a&gt;&lt;/strong&gt; : true로 설정된 경우 document.createElementNS ()를 사용하여 스크립트 요소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="31f7abf9c4912797d9daf10910ecf7f88272e44b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;plugins&quot;&gt;Loader plugins&lt;/a&gt;&lt;/strong&gt; are incredibly useful. It helps avoid the nested brace indenting common in callback-based programming.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;plugins&quot;&gt;로더 플러그인&lt;/a&gt;&lt;/strong&gt; 은 매우 유용합니다. 콜백 기반 프로그래밍에서 일반적인 중첩 중괄호 들여 쓰기를 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ed6dad16503b3126795253aa8af8de2838d36717" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid optimization names that are outside the baseUrl&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;baseUrl 외부에있는 최적화 이름을 피하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab1ba893f507bf37759ad63a03f08e7621aa0f0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice&lt;/strong&gt;: Use npm to install Node-only packages/modules into the projects &lt;strong&gt;node_modules&lt;/strong&gt; directory, but do not configure RequireJS to look inside the node_modules directory. Also avoid using relative module IDs to reference modules that are Node-only modules. So, &lt;strong&gt;do not&lt;/strong&gt; do something like &lt;strong&gt;require(&quot;./node_modules/foo/foo&quot;)&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;모범 사례&lt;/strong&gt; : npm을 사용하여 노드 전용 패키지 / 모듈을 프로젝트 &lt;strong&gt;node_modules&lt;/strong&gt; 디렉토리에 설치하지만 &lt;strong&gt;RequireJS가 node_modules&lt;/strong&gt; 디렉토리를 찾도록 구성하지 마십시오. 또한 노드 전용 모듈 인 모듈을 참조하기 위해 상대 모듈 ID를 사용하지 마십시오. 따라서 &lt;strong&gt;require ( &quot;./ node_modules / foo / foo&quot;)&lt;/strong&gt; 와 같은 &lt;strong&gt;작업을 수행하지&lt;/strong&gt; 마십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be29faed16f9fe8a4c388fa7277c7a67d769cd29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser:&lt;/strong&gt; as of 2.1.2, the optimizer can run in a web browser that has &lt;a href=&quot;http://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;array extras&lt;/a&gt;. While the optimizer options are the same as shown below, it is called via JavaScript instead of command line options. It is also only good for generating optimized single files, not a directory optimization. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;the browser example&lt;/a&gt;. This option is really only useful for providing web-based custom builds of your library.</source>
          <target state="translated">&lt;strong&gt;브라우저 :&lt;/strong&gt; 2.1.2부터 옵티마이 저는 &lt;a href=&quot;http://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;array extras&lt;/a&gt; 가있는 웹 브라우저에서 실행할 수 있습니다 . 옵티 마이저 옵션은 아래에 표시된 것과 동일하지만 명령 행 옵션 대신 JavaScript를 통해 호출됩니다. 또한 디렉토리 최적화가 아닌 최적화 된 단일 파일 생성에만 좋습니다. &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;브라우저 예를&lt;/a&gt; 참조하십시오 . 이 옵션은 라이브러리의 웹 기반 사용자 정의 빌드를 제공 할 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f16ee22e3883332888fc6fc8e00e88c6977796fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser:&lt;/strong&gt; as of 2.1.2, the optimizer can run in a web browser that has &lt;a href=&quot;https://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;array extras&lt;/a&gt;. While the optimizer options are the same as shown below, it is called via JavaScript instead of command line options. It is also only good for generating optimized single files, not a directory optimization. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;the browser example&lt;/a&gt;. This option is really only useful for providing web-based custom builds of your library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f5e7e58829260a983728d562bc82651be3abf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Console debugging&lt;/strong&gt;: If you need to work with a module you already loaded via a &lt;code&gt;require([&quot;module/name&quot;], function(){})&lt;/code&gt; call in the JavaScript console, then you can use the require() form that just uses the string name of the module to fetch it:</source>
          <target state="translated">&lt;strong&gt;콘솔 디버깅&lt;/strong&gt; : JavaScript 콘솔에서 &lt;code&gt;require([&quot;module/name&quot;], function(){})&lt;/code&gt; 호출을 통해 이미로드 한 모듈로 작업해야하는 경우 , 그냥 사용하는 require () 양식을 사용할 수 있습니다 가져올 모듈의 문자열 이름 :</target>
        </trans-unit>
        <trans-unit id="8df639b0d629d79075271634c2a5642b4af733b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Definition&lt;/strong&gt;: how to encapsulate a piece of code into a useful unit, and how to register its capability/export a value for the module.</source>
          <target state="translated">&lt;strong&gt;정의&lt;/strong&gt; : 코드를 유용한 단위로 캡슐화하는 방법과 기능을 등록하고 모듈의 값을 내보내는 방법.</target>
        </trans-unit>
        <trans-unit id="e52f813a7533d3a816bf2bc5cc17f40154357c7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency References&lt;/strong&gt;: how to refer to other units of code.</source>
          <target state="translated">&lt;strong&gt;종속성 참조&lt;/strong&gt; : 다른 코드 단위를 참조하는 방법.</target>
        </trans-unit>
        <trans-unit id="76f910f2e7544ed69b4f3f77df13ab34a0a941a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not specify the output directory to within the source area for your JavaScript&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScript의 소스 영역 내에 출력 디렉토리를 지정하지 마십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15219d6fbf857eb4de9f2b5152e2cabd11fe6c3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dynamic code loading&lt;/strong&gt; (done in AMD systems via &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;require([], function (){})&lt;/a&gt;) is a basic requirement. CJS talked about it, had some proposals, but it was not fully embraced. Node does not have any support for this need, instead relying on the synchronous behavior of require(''), which is not portable to the web.</source>
          <target state="translated">&lt;strong&gt;동적 코드 로딩&lt;/strong&gt; ( &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;require ([], function () {})을&lt;/a&gt; 통해 AMD 시스템에서 완료 )은 기본 요구 사항입니다. CJS는 그것에 대해 이야기하고 몇 가지 제안이 있었지만 완전히 수용되지 않았습니다. 노드는 이러한 요구를 지원하지 않고 웹에 이식 할 수없는 require ( '')의 동기 동작에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="ccfc6e9f2a4e66e6e924a9d6243c5590996ab0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generate URLs relative to module&lt;/strong&gt;: You may need to generate an URL that is relative to a module. To do so, ask for &quot;require&quot; as a dependency and then use require.toUrl() to generate the URL:</source>
          <target state="translated">&lt;strong&gt;모듈&lt;/strong&gt; 과 &lt;strong&gt;관련된 URL 생성&lt;/strong&gt; : &lt;strong&gt;모듈&lt;/strong&gt; 과 &lt;strong&gt;관련된 URL&lt;/strong&gt; 을 생성해야 할 수도 있습니다. 이렇게하려면 종속성으로 &quot;require&quot;를 요청한 다음 require.toUrl ()을 사용하여 URL을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ce7c6f510ef7b7a0a096cba1750438eff21c1680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT NOTES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중요 사항&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="20972c6512a123816c889472eeaa7736b05ba276" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;: The function arguments should always be listed as &lt;strong&gt;require, exports, module&lt;/strong&gt;, with those exact names and in that exact order, otherwise chaos will ensue. You can leave off exports and module from the list, but if they are needed, they need to be specified in the exact order illustrated here.</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; : 함수 인수는 항상 정확한 이름과 정확한 순서 로 &lt;strong&gt;require, exports, module&lt;/strong&gt; 로 나열되어야 합니다. 그렇지 않으면 혼돈이 발생합니다. 내보내기 및 모듈을 목록에서 제외 할 수 있지만 필요한 경우 여기에 설명 된 순서대로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6252e4d16b5ac8019cf35465c36d0d40ca17d8f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you are a script/library author&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;스크립트 / 라이브러리 작성자 인 경우&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4bc23c4166c7b23082f0e2749ca3e82ba7a59bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you write applications:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;응용 프로그램을 작성하는 경우 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2bf07821d29e12c974210b6ab52ee6b3ae192f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you write code loaders/engines/environments for JavaScript:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScript 용 코드 로더 / 엔진 / 환경을 작성하는 경우 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="356892b8284923e6d2f5cc7f4d0a01e0ba3bdede" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the RequreJS 1.0.x releases&lt;/strong&gt;, there &lt;a href=&quot;https://github.com/requirejs/requirejs/issues/265&quot;&gt;is a bug&lt;/a&gt; with having a space between the require and parens in WebKit browsers when using the simplified CommonJS wrapping (no dependency array):</source>
          <target state="translated">&lt;strong&gt;RequreJS 1.0.x는 릴리스&lt;/strong&gt; 거기 &lt;a href=&quot;https://github.com/requirejs/requirejs/issues/265&quot;&gt;버그&lt;/a&gt; (가)와 요구 사이의 공간을 갖는 단순화 된 CommonJS 포장 (종속 어레이)를 사용하여 브라우저에서, 플러그인 괄호 :</target>
        </trans-unit>
        <trans-unit id="e1ca9b023143e72afa4253fd458b6c0e03df2271" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java:&lt;/strong&gt;&lt;a href=&quot;http://java.com/&quot;&gt;Java 1.6&lt;/a&gt; or later.</source>
          <target state="translated">&lt;strong&gt;Java : &lt;/strong&gt;&lt;a href=&quot;http://java.com/&quot;&gt;Java 1.6&lt;/a&gt; 이상</target>
        </trans-unit>
        <trans-unit id="095354ee186c6d03ba39e984bc04ef3890ecaa9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java:&lt;/strong&gt;&lt;a href=&quot;https://java.com/&quot;&gt;Java 1.6&lt;/a&gt; or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19035fd62e2796fc9e71500430ed2729bd25794b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node:&lt;/strong&gt; (preferred) &lt;a href=&quot;http://nodejs.org&quot;&gt;Node&lt;/a&gt; 0.4.0 or later.</source>
          <target state="translated">&lt;strong&gt;노드 :&lt;/strong&gt; (권장) &lt;a href=&quot;http://nodejs.org&quot;&gt;노드&lt;/a&gt; 0.4.0 이상.</target>
        </trans-unit>
        <trans-unit id="0b4588887e6e03b3d61220053afd37fca3ad7b38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node:&lt;/strong&gt; (preferred) &lt;a href=&quot;https://nodejs.org&quot;&gt;Node&lt;/a&gt; 0.4.0 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0731eb1335fb5dce4ac6b95537018a342d2bb8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note the build limitations of shim config.&lt;/strong&gt; In particular, you cannot load dependencies for shimmed libraries from a CDN. See the &lt;a href=&quot;api#config-shim&quot;&gt;shim config section&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;shim config의 빌드 제한 사항에 유의하십시오. &lt;/strong&gt;특히 CDN에서 shimmed 라이브러리에 대한 종속성을로드 할 수 없습니다. 자세한 내용은 &lt;a href=&quot;api#config-shim&quot;&gt;shim 구성 섹션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="333ae88975c3caac92e92e986a1a903f145fdd9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when doing builds with map config, the map config needs to be fed to the optimizer, and the build output must still contain a requirejs config call that sets up the map config. The optimizer does not do ID renaming during the build, because some dependency references in a project could depend on runtime variable state. So the optimizer does not invalidate the need for a map config after the build.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; map config를 사용하여 빌드를 수행하는 경우 맵 구성을 옵티 마이저에 공급해야하며 빌드 출력에는 여전히 맵 구성을 설정하는 requirejs 구성 호출이 포함되어 있어야합니다. 프로젝트에서 일부 종속성 참조는 런타임 변수 상태에 따라 달라질 수 있으므로 최적화 프로그램은 빌드 중에 ID 이름 바꾸기를 수행하지 않습니다. 따라서 최적화 프로그램은 빌드 후 맵 구성의 필요성을 무효화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab9355b9cfcc01a8de70426e43051f8e16d1ea97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;requirejs([], function() {})&lt;/code&gt; will call the function callback asynchronously in RequireJS 2.1+ (for earlier versions it was synchronously called). However, when running in Node, module loading will be loaded using sync IO calls, and loader plugins should resolve calls to their load method synchronously. This allows sync uses of the requirejs module in node to work via requirejs('stringValue') calls:</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;requirejs([], function() {})&lt;/code&gt; 는 RequireJS 2.1 이상에서 함수 콜백을 비동기식으로 호출합니다 (이전 버전에서는 동기식으로 호출 됨). 그러나 노드에서 실행될 때 동기화 IO 호출을 사용하여 모듈로드가로드되며 로더 플러그인은로드 메소드에 대한 호출을 동 기적으로 해결해야합니다. 이를 통해 requirejs ( 'stringValue') 호출을 통해 노드에서 requirejs 모듈을 동기화하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4d9ab191ead6e7068952ee09f25ad5ec231469d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; RequireJS 항상 국제화 번들 디스크에있는 디렉토리와 파일을 모두 소문자 로케일을 사용해야하므로, 사례 문제를 방지하기 위해, 로케일의 소문자 버전을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ccc1238154db0c7afccdfc9988192b6769a2544" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One module per file.&lt;/strong&gt;: Only one module should be defined per JavaScript file, given the nature of the module name-to-file-path lookup algorithm. You shoud only use the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt; to group multiple modules into optimized files.</source>
          <target state="translated">&lt;strong&gt;파일 당 하나의 모듈. &lt;/strong&gt;: 모듈 이름-파일 경로 검색 알고리즘의 특성상 JavaScript 파일 당 하나의 모듈 만 정의해야합니다. &lt;a href=&quot;optimization&quot;&gt;최적화 도구&lt;/a&gt; 만 사용하여 여러 모듈을 최적화 된 파일로 그룹화해야합니다.</target>
        </trans-unit>
        <trans-unit id="d956212a5ca554b5c7226464fd11b8fe3d92afc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only JSONP return values that are JSON objects are supported&lt;/strong&gt;. A JSONP response that is an array, a string or a number will not work.</source>
          <target state="translated">&lt;strong&gt;JSON 객체 인 JSONP 반환 값만 지원됩니다&lt;/strong&gt; . 배열, 문자열 또는 숫자 인 JSONP 응답이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49a7d502c051d7f90a9322365968054abdce7daa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relative module names are relative to other names, not paths&lt;/strong&gt;: The loader stores modules by their name and not by their path internally. So for relative name references, those are resolved relative to the module name making the reference, then that module name, or ID, is converted to a path if needs to be loaded. Example code for a 'compute' package that has a 'main' and 'extras' modules in it:</source>
          <target state="translated">&lt;strong&gt;상대 모듈 이름은 경로가 아닌 다른 이름과 관련&lt;/strong&gt; 이 있습니다. 로더는 내부적으로 경로가 아닌 이름으로 모듈을 저장합니다. 따라서 상대 이름 참조의 경우 참조를 만드는 모듈 이름과 관련하여 해결 된 다음 해당 모듈 이름 또는 ID가로드되어야하는 경우 경로로 변환됩니다. 'main'및 'extras'모듈이 포함 된 'compute'패키지의 예제 코드 :</target>
        </trans-unit>
        <trans-unit id="11a170cfd674f6e39dc87345715cd0fbe306ab78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relative module names inside define()&lt;/strong&gt;: For require(&quot;./relative/name&quot;) calls that can happen inside a define() function call, be sure to ask for &quot;require&quot; as a dependency, so that the relative name is resolved correctly:</source>
          <target state="translated">&lt;strong&gt;define () 내부의 상대 모듈 이름&lt;/strong&gt; : define () 함수 호출 내에서 발생할 수있는 require ( &quot;./ relative / name&quot;) 호출의 경우 상대 이름으로 해석되도록 &quot;require&quot;를 종속성으로 요청해야합니다. 바르게:</target>
        </trans-unit>
        <trans-unit id="2ba09f23bfed021b25b590445886e93396c6841a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a function as the module value&lt;/strong&gt;, particularly a constructor function, leads to better API design. Node has module.exports to allow this, but being able to use &quot;return function (){}&quot; is much cleaner. It means not having to get a handle on &quot;module&quot; to do module.exports, and it is a clearer code expression.</source>
          <target state="translated">&lt;strong&gt;함수를 모듈 값&lt;/strong&gt; , 특히 생성자 함수 &lt;strong&gt;로 반환하면&lt;/strong&gt; API 디자인이 향상됩니다. Node는이를 허용하기 위해 module.exports를 가지고 있지만 &quot;return function () {}&quot;을 사용할 수있는 것이 훨씬 더 깨끗합니다. 이는 module.exports를 수행하기 위해 &quot;module&quot;에 대한 핸들을 얻지 않아도됨을 의미하며보다 명확한 코드 표현입니다.</target>
        </trans-unit>
        <trans-unit id="d7f39288e5c973499ca8c5f2d0687e7cd917ff92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selectively mapping one module&lt;/strong&gt; to load from another location makes it easy to provide mock objects for testing.</source>
          <target state="translated">&lt;strong&gt;선택적으로 하나의 모듈&lt;/strong&gt; 을 다른 위치에서로드하도록 &lt;strong&gt;매핑&lt;/strong&gt; 하면 테스트를위한 모의 객체를 쉽게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e61d06563cca67b22b9eb8c2024e68101de86ae3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;location&lt;/strong&gt;: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</source>
          <target state="translated">&lt;strong&gt;location&lt;/strong&gt; : 디스크상의 위치. 위치는 프로토콜을 포함하거나 슬래시 (/)로 시작하지 않는 한 baseUrl 구성 값에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="d76ab03895b36d6cde2b56b5d8e63691bc784ca7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main&lt;/strong&gt;: The name of the module inside the package that should be used when someone does a require for &quot;packageName&quot;. The default value is &quot;main&quot;, so only specify it if it differs from the default. The value is relative to the package folder.</source>
          <target state="translated">&lt;strong&gt;main&lt;/strong&gt; : 누군가가 &quot;packageName&quot;을 요구할 때 사용되어야하는 패키지 내부의 모듈 이름. 기본값은 &quot;main&quot;이므로 기본값과 다른 경우에만 지정하십시오. 값은 패키지 폴더를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="e9a96de3b237de28b3418486a2dfc515daa753cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt;: The name of the package (used for the module name/prefix mapping)</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; : 패키지 이름 (모듈 이름 / 접두사 매핑에 사용)</target>
        </trans-unit>
        <trans-unit id="e6c02a1abf8f5e3c3ca5c9b099c109ed745a20bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;project.html&lt;/strong&gt; will have a script tag like this:</source>
          <target state="translated">&lt;strong&gt;project.html&lt;/strong&gt; 에는 다음과 같은 스크립트 태그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c789276d7d4257fd905839da9ee26e33460a9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requireModules&lt;/strong&gt;: an array of module names/URLs that timed out.</source>
          <target state="translated">&lt;strong&gt;requireModules&lt;/strong&gt; : 시간이 초과 된 모듈 이름 / URL의 배열.</target>
        </trans-unit>
        <trans-unit id="b3a393e55d1a8e898134ecc9aee2b2dd26cb033b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requireType&lt;/strong&gt;: A string value with a general classification, like &quot;timeout&quot;, &quot;nodefine&quot;, &quot;scripterror&quot;.</source>
          <target state="translated">&lt;strong&gt;requireType&lt;/strong&gt; : &quot;timeout&quot;, &quot;nodefine&quot;, &quot;scripterror&quot;와 같은 일반적인 분류의 문자열 값.</target>
        </trans-unit>
        <trans-unit id="f81c83895ae3b9f711da071c21815fc034381a2b" translate="yes" xml:space="preserve">
          <source>A common use case for this is to use a CDN-hosted version of a library, but if that fails, switch to loading the file locally:</source>
          <target state="translated">이에 대한 일반적인 사용 사례는 CDN 호스트 버전의 라이브러리를 사용하는 것이지만 실패 할 경우 파일을 로컬로로드하도록 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="aecc92efc37038c626a9898853eacec5623d807b" translate="yes" xml:space="preserve">
          <source>A module is different from a traditional script file in that it defines a well-scoped object that avoids polluting the global namespace. It can explicitly list its dependencies and get a handle on those dependencies without needing to refer to global objects, but instead receive the dependencies as arguments to the function that defines the module. Modules in RequireJS are an extension of the &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;Module Pattern&lt;/a&gt;, with the benefit of not needing globals to refer to other modules.</source>
          <target state="translated">모듈은 전역 네임 스페이스를 오염시키지 않는 범위가 지정된 개체를 정의한다는 점에서 기존 스크립트 파일과 다릅니다. 전역 객체를 참조 할 필요없이 해당 종속성을 명시 적으로 나열하고 해당 종속성을 처리 할 수 ​​있지만 대신 모듈을 정의하는 함수에 대한 인수로 종속성을받습니다. RequireJS의 &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;모듈&lt;/a&gt; 은 모듈 패턴 의 확장으로, 다른 모듈을 참조하기 위해 전역이 필요 없다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c775660143554c4a49c1424ff91639fea08f923" translate="yes" xml:space="preserve">
          <source>A package can be associated with a module name/prefix.</source>
          <target state="translated">패키지는 모듈 이름 / 접두사와 연관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afcd892649c51aa04e79a2542db76913e80781c9" translate="yes" xml:space="preserve">
          <source>A plugin could have very specific logic that depends on a certain environment, like the browser. However, when run inside the optimizer, the environment is very different, and the plugin may have a &lt;b&gt;write&lt;/b&gt; plugin API implementation that it does not want to deliver as part of the normal plugin that is loaded in the browser. In those cases, specifying a pluginBuilder is useful.</source>
          <target state="translated">플러그인은 브라우저와 같은 특정 환경에 따라 매우 특정한 논리를 가질 수 있습니다. 그러나 옵티 마이저 내에서 실행될 때 환경은 매우 다르며 플러그인에는 브라우저에로드되는 일반 플러그인의 일부로 제공하지 않으려 는 &lt;b&gt;쓰기&lt;/b&gt; 플러그인 API 구현이있을 수 있습니다. 이 경우 pluginBuilder를 지정하면 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4755581e13a8cfa7fccfd118cd85844167f076f6" translate="yes" xml:space="preserve">
          <source>A require of &quot;cart&quot; means that it will be loaded from &lt;strong&gt;scripts/cart/main.js&lt;/strong&gt;, since &quot;main&quot; is the default main module setting supported by RequireJS. A require of &quot;store/util&quot; will be loaded from &lt;strong&gt;scripts/store/util.js&lt;/strong&gt;.</source>
          <target state="translated">&quot;cart&quot;이 필요하다는 것은 &quot;main&quot;이 RequireJS에서 지원하는 기본 기본 모듈 설정이므로 &lt;strong&gt;scripts / cart / main.js&lt;/strong&gt; 에서로드됨을 의미합니다 . &quot;store / util&quot;이 &lt;strong&gt;scripts / store / util.js&lt;/strong&gt; 에서로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc1b9b4bb07d1464277843f034100c63208665b6" translate="yes" xml:space="preserve">
          <source>AMD</source>
          <target state="translated">AMD</target>
        </trans-unit>
        <trans-unit id="cd5cf5473243e1d45d7719af8f41414a0e858e3d" translate="yes" xml:space="preserve">
          <source>AMD Used Today</source>
          <target state="translated">오늘날 사용되는 AMD</target>
        </trans-unit>
        <trans-unit id="7756663774fb63eb9c802ee39b2964fe49d1000d" translate="yes" xml:space="preserve">
          <source>AMD addresses these issues by:</source>
          <target state="translated">AMD는 다음을 통해 이러한 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="2fbb6d8aa7490cd0fb9b3c2680eaeeb53140cf79" translate="yes" xml:space="preserve">
          <source>AMD and its related APIs, have helped show the following for any future JS module system:</source>
          <target state="translated">AMD와 관련 API는 향후 JS 모듈 시스템에 대해 다음을 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="ad652546dd574e8e72a3108f5d47d4b2288b681a" translate="yes" xml:space="preserve">
          <source>AMD modules require less tooling, there are fewer edge case issues, and better debugging support.</source>
          <target state="translated">AMD 모듈은 툴링이 적고, 엣지 케이스 문제가 적으며, 디버깅 지원이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="1461f8efdc9427af7da00c09555d68f10f4a74dd" translate="yes" xml:space="preserve">
          <source>Ability to load nested dependencies</source>
          <target state="translated">중첩 된 종속성을로드하는 기능</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">고급 사용법</target>
        </trans-unit>
        <trans-unit id="c858288df721516bc4030ba55bfa6335a7f04d3c" translate="yes" xml:space="preserve">
          <source>All configuration options</source>
          <target state="translated">모든 구성 옵션</target>
        </trans-unit>
        <trans-unit id="9f40cf04b3528dd358ff4509828b611ee71bca1f" translate="yes" xml:space="preserve">
          <source>All of them map to loading some/path/some/module.js. Ideally we could choose the CommonJS syntax, since it is likely to get more common over time, and we want to reuse code.</source>
          <target state="translated">그들 모두는 some / path / some / module.js를로드하는 데 매핑됩니다. 이상적으로 우리는 CommonJS 구문을 선택할 수 있습니다. 시간이 지남에 따라 더 많이 사용되며 코드를 재사용하기를 원하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d76cac34f72024eab757bb7877d36d4a84783e5f" translate="yes" xml:space="preserve">
          <source>All the example commands in this page assume Node usage, and running on a Linux/OS X command line. See the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js README&lt;/a&gt; for how to run it in Java.</source>
          <target state="translated">이 페이지의 모든 예제 명령은 노드 사용을 가정하고 Linux / OS X 명령 행에서 실행됩니다. Java로 실행하는 방법 은 &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js README&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7add3732819f23846380c080edcf146c4d1b13a" translate="yes" xml:space="preserve">
          <source>Allows setting a function as the return value. This is really useful for constructor functions. In CommonJS this is more awkward, always having to set a property on the exports object. Node supports module.exports = function () {}, but that is not part of a CommonJS spec.</source>
          <target state="translated">함수를 반환 값으로 설정할 수 있습니다. 이것은 생성자 함수에 실제로 유용합니다. CommonJS에서 이것은 더 어색합니다. 항상 exports 객체에 속성을 설정해야합니다. 노드는 module.exports = function () {}을 지원하지만 CommonJS 스펙의 일부는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5c0b4dca99dd221c07f2823dbfc63078e8a6ae51" translate="yes" xml:space="preserve">
          <source>Also support &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader plugins&lt;/a&gt;. Loader plugins are a great way to reduce the nested callback syndrome that can be common in callback/async-style code.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;콜백 요구&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;로더 플러그인&lt;/a&gt; 도 지원 합니다. 로더 플러그인은 콜백 / 비동기 스타일 코드에서 일반적 일 수있는 중첩 콜백 증후군을 줄이는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e2430ebce59431b0f6de636d393909781098343b" translate="yes" xml:space="preserve">
          <source>Also, document.write() does not work after page load. A great way to get perceived performance for your site is loading code on demand, as the user needs it for their next action.</source>
          <target state="translated">또한 페이지를로드 한 후 document.write ()가 작동하지 않습니다. 사용자가 다음 작업을 위해 코드를 필요로하므로 사이트 성능을 높이는 가장 좋은 방법은 요청시 코드를로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a15f74e2813a0e5e3d61a221d689634817920be6" translate="yes" xml:space="preserve">
          <source>Also, you can define the config object as the global variable &lt;code&gt;require&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; require.js is loaded, and have the values applied automatically. This example specifies some dependencies to load as soon as require.js defines require():</source>
          <target state="translated">또한 require.js가로드 &lt;strong&gt;되기 전에&lt;/strong&gt; 전역 변수에 &lt;code&gt;require&lt;/code&gt; 대로 구성 객체를 정의 하고 값이 자동으로 적용되도록 할 수 있습니다. 이 예제는 require.js가 require ()를 정의하자마자로드 할 일부 종속성을 지정합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5180f71902ee087330414f177079b5a4dd04dc5e" translate="yes" xml:space="preserve">
          <source>Alternative Syntax</source>
          <target state="translated">대체 구문</target>
        </trans-unit>
        <trans-unit id="e8b3e3a9af7aa6f439fd569409a7504a25bbf037" translate="yes" xml:space="preserve">
          <source>An error occured when the define() function was called for the module given in the error message. It is an error with the code logic inside the define function. The error could happen inside a require callback.</source>
          <target state="translated">오류 메시지에 제공된 모듈에 대해 define () 함수를 호출 할 때 오류가 발생했습니다. define 함수 내부의 코드 로직에 오류가 있습니다. 콜백이 필요하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98ed11116a42389468f7dc53908918bc380fc101" translate="yes" xml:space="preserve">
          <source>An example plugin that does not do anything interesting, just does a normal require to load a JS module:</source>
          <target state="translated">흥미로운 일을하지 않는 플러그인 예제, 보통 JS 모듈을로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="0538812e80ae1405069dd76f452c8a132050945b" translate="yes" xml:space="preserve">
          <source>An example plugin's load function that uses onload.fromText():</source>
          <target state="translated">onload.fromText ()를 사용하는 예제 플러그인의로드 함수 :</target>
        </trans-unit>
        <trans-unit id="b4a866eb59039f47e37643f1a1f3ce8fc67b0a81" translate="yes" xml:space="preserve">
          <source>An example: suppose there is an &lt;b&gt;index!&lt;/b&gt; plugin that will load a module name given an index. This is a contrived example, just to illustrate the concept. A module may reference an index! resource like so:</source>
          <target state="translated">예를 들어 : &lt;b&gt;색인&lt;/b&gt; 이 있다고 가정하십시오 &lt;b&gt;! &lt;/b&gt;색인이 주어진 모듈 이름을로드하는 플러그인. 이것은 개념을 설명하기 위해 고안된 예입니다. 모듈은 색인을 참조 할 수 있습니다! 다음과 같은 리소스 :</target>
        </trans-unit>
        <trans-unit id="207a2adf208957c6bc485c22ac086554f8dec108" translate="yes" xml:space="preserve">
          <source>An object literal with a property of &quot;root&quot; defines this module. That is all you have to do to set the stage for later localization work.</source>
          <target state="translated">&quot;root&quot;속성을 가진 객체 리터럴이이 모듈을 정의합니다. 이것이 나중에 현지화 작업을위한 단계를 설정하기 위해해야 ​​할 전부입니다.</target>
        </trans-unit>
        <trans-unit id="099426cf6ef74281640e7d0c78dc622640eee3d9" translate="yes" xml:space="preserve">
          <source>And a &lt;code&gt;require(['compute'])&lt;/code&gt; is done, then lib/compute/main.js will have the module name of 'compute'. When it asks for './extras', that is resolved relative to 'compute', so 'compute/./extras', which normalizes to just 'extras'. Since there is no paths config for that module name, the path generated will be for 'lib/extras.js', which is incorrect.</source>
          <target state="translated">그리고 &lt;code&gt;require(['compute'])&lt;/code&gt; 가 완료되면 lib / compute / main.js의 모듈 이름은 'compute'입니다. './extras'를 요청하면 'compute'와 관련하여 해결되므로 'compute /./ extras'는 'extras'로 정규화됩니다. 해당 모듈 이름에 대한 경로 구성이 없으므로 생성 된 경로는 'lib / extras.js'에 대한 경로입니다.</target>
        </trans-unit>
        <trans-unit id="70ae90af3ca9f9d0ea4a9db7f8c6a12852cd8aed" translate="yes" xml:space="preserve">
          <source>And this is the syntax used by RequireJS. There is also a simplified syntax if you just want to load some plain JavaScript files that do not define modules:</source>
          <target state="translated">그리고 이것은 RequireJS가 사용하는 구문입니다. 모듈을 정의하지 않는 일반 JavaScript 파일을로드하려는 경우 단순화 된 구문도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4449f0268ad6ee8479ff9c7c4e2df6c1f1b9859d" translate="yes" xml:space="preserve">
          <source>Another option is to construct a module at lib/compute.js that is just &lt;code&gt;define(['./compute/main'], function(m) { return m; });&lt;/code&gt;, then there is no need for paths or packages config.</source>
          <target state="translated">또 다른 옵션은 lib / compute.js에서 그냥 &lt;code&gt;define(['./compute/main'], function(m) { return m; });&lt;/code&gt; 경로 또는 패키지 구성이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fee85b56ae8d4b331dadd0c023881690c91edd87" translate="yes" xml:space="preserve">
          <source>Arguments for onload.fromText() (RequireJS 2.1.0 and later):</source>
          <target state="translated">onload.fromText ()에 대한 인수 (RequireJS 2.1.0 이상) :</target>
        </trans-unit>
        <trans-unit id="5f9783b9a3d349980bcc48b99c893615afc66388" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#config&quot;&gt;Configuration Options&lt;/a&gt;, multiple versions of a module can be loaded in a page by using different &quot;context&quot; configuration options. require.config() returns a require function that will use the context configuration. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</source>
          <target state="translated">&lt;a href=&quot;#config&quot;&gt;구성 옵션&lt;/a&gt; 에서 언급했듯이 다른 &quot;컨텍스트&quot;구성 옵션을 사용하여 여러 버전의 모듈을 페이지에로드 할 수 있습니다. require.config ()는 컨텍스트 구성을 사용할 require 함수를 반환합니다. 다음은 두 가지 버전의 알파 및 베타 모듈을로드하는 예입니다 (이 예는 테스트 파일 중 하나에서 가져옴).</target>
        </trans-unit>
        <trans-unit id="ea7f9bd561b8a7ce517ee1f3cd30f4270f35e445" translate="yes" xml:space="preserve">
          <source>As of Dojo 1.8, Dojo has converted their modules to AMD modules. However, Dojo uses some loader plugins, and the loader plugin APIs are still in draft mode for AMD. So while some modules from Dojo can be used with RequireJS, it will be difficult to use all of Dojo. It is best to use Dojo's AMD loader until &lt;a href=&quot;http://bugs.dojotoolkit.org/ticket/15616&quot;&gt;ticket 15616&lt;/a&gt; has been resolved.</source>
          <target state="translated">Dojo 1.8에서 Dojo는 모듈을 AMD 모듈로 변환했습니다. 그러나 Dojo는 일부 로더 플러그인을 사용하며 로더 플러그인 API는 여전히 AMD의 드래프트 모드입니다. 따라서 Dojo의 일부 모듈은 RequireJS와 함께 사용할 수 있지만 모든 Dojo를 사용하기는 어렵습니다. &lt;a href=&quot;http://bugs.dojotoolkit.org/ticket/15616&quot;&gt;티켓 15616&lt;/a&gt; 이 해결 될 때까지 Dojo의 AMD 로더를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ea33aedaa4d7ea4deb903138644e1b39c3f252e9" translate="yes" xml:space="preserve">
          <source>As of Dojo 1.8, Dojo has converted their modules to AMD modules. However, Dojo uses some loader plugins, and the loader plugin APIs are still in draft mode for AMD. So while some modules from Dojo can be used with RequireJS, it will be difficult to use all of Dojo. It is best to use Dojo's AMD loader until &lt;a href=&quot;https://bugs.dojotoolkit.org/ticket/15616&quot;&gt;ticket 15616&lt;/a&gt; has been resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f956f6f4e007b657480bf449c13457e00bbb46a" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.1.16, RequireJS can be used in &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html&quot;&gt;Nashorn&lt;/a&gt;, Java 8+'s JavaScript engine, via the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js adapter&lt;/a&gt;. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;the r.js README&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS 2.1.16부터 RequireJS는 &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js 어댑터&lt;/a&gt; 를 통해 Java 8+ 의 JavaScript 엔진 인 &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html&quot;&gt;Nashorn&lt;/a&gt; 에서 사용할 수 있습니다 . 자세한 정보 &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;는 r.js README&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="60c4529d32d26fca43bdc4a391d37434329a4c47" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.2.0, the optimizer can generate the bundles config and insert it into the top level requirejs.config() call. See the &lt;a href=&quot;https://github.com/requirejs/r.js/blob/98a9949480d68a781c8d6fc4ce0a07c16a2c8a2a/build/example.build.js#L641&quot;&gt;bundlesConfigOutFile&lt;/a&gt; build config option for more details.</source>
          <target state="translated">RequireJS 2.2.0부터 옵티마이 저는 번들 구성을 생성하고이를 최상위 레벨 requirejs.config () 호출에 삽입 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/requirejs/r.js/blob/98a9949480d68a781c8d6fc4ce0a07c16a2c8a2a/build/example.build.js#L641&quot;&gt;bundlesConfigOutFile&lt;/a&gt; 빌드 구성 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1ac12d0c37c15f175b2b09c1a99a6ea4b0d1db20" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.2.0, urlArgs can be a function. If a function, it will receive the module ID and the URL as parameters, and it should return a string that will be added to the end of the URL. Return an empty string if no args. Be sure to take care of adding the '?' or '&amp;amp;' depending on the existing state of the URL. Example:</source>
          <target state="translated">RequireJS 2.2.0부터 urlArgs는 함수일 수 있습니다. 함수 인 경우 모듈 ID 및 URL을 매개 변수로 수신하고 URL 끝에 추가 될 문자열을 리턴해야합니다. 인수가 없으면 빈 문자열을 반환합니다. '?'를 추가해야합니다. 또는 URL의 기존 상태에 따라 '&amp;amp;' 예:</target>
        </trans-unit>
        <trans-unit id="e7485868f6989d6066fcc487315af6201517447b" translate="yes" xml:space="preserve">
          <source>As of mid-October 2011, AMD already has good adoption on the web:</source>
          <target state="translated">2011 년 10 월 중순부터 AMD는 이미 웹에서 잘 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="80555381aeb072f79005f4cc1445ebb0289e5ba6" translate="yes" xml:space="preserve">
          <source>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</source>
          <target state="translated">0.12 릴리스부터 웹 작업자 내에서 RequireJS를 실행할 수 있습니다. 웹 워커 내에서 importScripts ()를 사용하여 require.js (또는 require () 정의가 포함 된 JS 파일)를로드 한 다음 require를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="29459a7e5ab1b732a2e1cc31627dce05f38a47fa" translate="yes" xml:space="preserve">
          <source>As of version 2.1.2, there are some speed shortcuts the optimizer will take by default if &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;none&quot;&lt;/code&gt;. However, if you are using &lt;code&gt;&quot;none&quot;&lt;/code&gt; for &lt;strong&gt;optimize&lt;/strong&gt; and you are planning to minify the built files after the optimizer runs, then you should turn set &lt;strong&gt;normalizeDirDefines&lt;/strong&gt; to &lt;code&gt;&quot;all&quot;&lt;/code&gt; so that define() calls are normalized correctly to withstand minification. If you are doing minification via the &lt;strong&gt;optimize&lt;/strong&gt; option, then you do not need to worry about setting this option.</source>
          <target state="translated">버전 2.1.2부터, &lt;strong&gt;optimize&lt;/strong&gt; 가 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 으로 설정된 경우 &lt;strong&gt;옵티마이 저가&lt;/strong&gt; 기본적으로 사용하는 일부 단축 단축키가 있습니다 . 그러나 &lt;strong&gt;최적화에 &lt;/strong&gt; &lt;code&gt;&quot;none&quot;&lt;/code&gt; 을 사용 하고 &lt;strong&gt;옵티마이&lt;/strong&gt; 저가 실행 된 후 빌드 된 파일을 축소하려는 경우, &lt;strong&gt;normalizeDirDefines&lt;/strong&gt; 를 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 로 설정 하여 define () 호출이 최소화를 견딜 수 있도록 올바르게 정규화되도록해야합니다. &lt;strong&gt;최적화&lt;/strong&gt; 옵션을 통해 축소를 수행하는 경우이 옵션 설정에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9145a4861db481e2d9d34b18ece0513ecc45236b" translate="yes" xml:space="preserve">
          <source>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</source>
          <target state="translated">주석에서 알 수 있듯이 require ()가 비동기이면이 코드가 작동하지 않습니다. 그러나 브라우저에서 스크립트를 동기식으로로드하면 성능이 저하됩니다. 그래서 뭘 할건데?</target>
        </trans-unit>
        <trans-unit id="71cb8a746a0b21f126d1b3dc8bf16feb9f665d4a" translate="yes" xml:space="preserve">
          <source>Assembly gets harder</source>
          <target state="translated">조립이 어려워 짐</target>
        </trans-unit>
        <trans-unit id="03af7d03d9d2928a8a7513419105d33c5a27b3b5" translate="yes" xml:space="preserve">
          <source>Async vs Sync</source>
          <target state="translated">비동기 대 동기화</target>
        </trans-unit>
        <trans-unit id="ee31840f6d717751adeb5c5c527bd4f26f71567c" translate="yes" xml:space="preserve">
          <source>Asynchronously loading dependencies should use an array to list the dependencies:</source>
          <target state="translated">비동기 적으로로드되는 종속성은 배열을 사용하여 종속성을 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="cae1fefc0fed8a8035298bfca8fc8834c8f0ea50" translate="yes" xml:space="preserve">
          <source>Be sure that &lt;strong&gt;require('name')&lt;/strong&gt; only occurs inside a define() definition function or a require() callback function, never in the global space by its own.</source>
          <target state="translated">있는지 확인하십시오 &lt;strong&gt;( '이름')를 필요로하는 것은&lt;/strong&gt; 단지 결코 그 자체로 글로벌 공간에서하는 정의 () 정의 함수 또는 필요 () 콜백 함수 내에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="061f3af77c543d3a0a6689e17f716e283cf79710" translate="yes" xml:space="preserve">
          <source>Be sure to load all scripts that call define() via the RequireJS API. Do not manually code script tags in HTML to load scripts that have define() calls in them.</source>
          <target state="translated">RequireJS API를 통해 define ()을 호출하는 모든 스크립트를로드하십시오. define () 호출이있는 스크립트를로드하기 위해 HTML에서 스크립트 태그를 수동으로 코딩하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="647ec165a4f826f7e261c899585db87edb8c388d" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#2&quot;&gt;notes in section 2&lt;/a&gt; about configuring RequireJS so that it can load node-only modules installed via npm.</source>
          <target state="translated">npm을 통해 설치된 노드 전용 모듈을로드 할 수 있도록 RequireJS 구성에 대한 &lt;a href=&quot;#2&quot;&gt;섹션 2&lt;/a&gt; 의 참고 사항 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7083451a53803294578ca8c94dc5e67867059b3f" translate="yes" xml:space="preserve">
          <source>Before RequireJS 2.1.0, onload.fromText accepted a moduleName as the first argument: &lt;code&gt;onload.fromText(moduleName, text)&lt;/code&gt;, and the loader plugin had to manually call &lt;code&gt;require([moduleName], onload)&lt;/code&gt; after the onload.fromText() call.</source>
          <target state="translated">RequireJS 2.1.0 이전에 onload.fromText는 moduleName을 첫 번째 인수로 &lt;code&gt;onload.fromText(moduleName, text)&lt;/code&gt; 로 승인 했으며, 로더 플러그인은 onload.fromText () 호출 후 수동으로 &lt;code&gt;require([moduleName], onload)&lt;/code&gt; 를 호출해야했습니다. .</target>
        </trans-unit>
        <trans-unit id="d802c768c50f9cd38311161cb5506d85c95396c8" translate="yes" xml:space="preserve">
          <source>Building node modules with AMD or RequireJS</source>
          <target state="translated">AMD 또는 RequireJS로 노드 모듈 구축</target>
        </trans-unit>
        <trans-unit id="f4bb57495a42320cd55e2ef64aa962be5895b225" translate="yes" xml:space="preserve">
          <source>But here is the plain truth: the perceived extra typing and a level of indent to use AMD does not matter. Here is where your time goes when coding:</source>
          <target state="translated">그러나 여기에는 분명한 사실이 있습니다. 인식 된 추가 타이핑과 AMD 사용에 대한 들여 쓰기 수준은 중요하지 않습니다. 코딩 할 때 시간이 흘러갑니다.</target>
        </trans-unit>
        <trans-unit id="d224d8e44c2e917cdc11b554285947074959608b" translate="yes" xml:space="preserve">
          <source>By properly normalizing the resource name, it allows the loader to cache the value effectively, and to properly build an optimized build layer in the optimizer.</source>
          <target state="translated">자원 이름을 올바르게 정규화하면 로더가 값을 효과적으로 캐시하고 최적화 프로그램에서 최적화 된 빌드 계층을 올바르게 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5266679c4a1ae30bcf0a715ea74c102a8f5466" translate="yes" xml:space="preserve">
          <source>Can I use Node modules already written in the CommonJS module format?</source>
          <target state="translated">CommonJS 모듈 형식으로 이미 작성된 노드 모듈을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="603116a7697334dd761fc1e602d5cc446c9c6c52" translate="yes" xml:space="preserve">
          <source>Can I use server modules written in the CommonJS module format?</source>
          <target state="translated">CommonJS 모듈 형식으로 작성된 서버 모듈을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="443e9bde1a2ba8d69a35fe518f443310bf6d3b9c" translate="yes" xml:space="preserve">
          <source>Cannot use preserveLicenseComments and generateSourceMaps together</source>
          <target state="translated">preserveLicenseComments와 generateSourceMaps를 함께 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f4bce411019d5b31d73bb53b5b67559d1a3f5d72" translate="yes" xml:space="preserve">
          <source>Catching load failures in IE</source>
          <target state="translated">IE에서로드 실패 잡기</target>
        </trans-unit>
        <trans-unit id="f0d0a5b7548043f512ca9ac123eb4d0049ee5dbc" translate="yes" xml:space="preserve">
          <source>Circular Dependencies</source>
          <target state="translated">순환 종속성</target>
        </trans-unit>
        <trans-unit id="1e8e388c38825d78c8b73b0376db04a076ce7646" translate="yes" xml:space="preserve">
          <source>Clear path to defining the module value. Either use &quot;return value;&quot; or the CommonJS &quot;exports&quot; idiom, which can be useful for circular dependencies.</source>
          <target state="translated">모듈 값을 정의하는 명확한 경로입니다. &quot;반환 값;&quot;을 사용하십시오. 또는 순환 종속성에 유용 할 수있는 CommonJS &quot;내보내기&quot;관용구.</target>
        </trans-unit>
        <trans-unit id="680c117376f566afefa1f4b5c4233938c1c4a484" translate="yes" xml:space="preserve">
          <source>Code complexity grows as the site gets bigger</source>
          <target state="translated">사이트가 커질수록 코드 복잡성이 커짐</target>
        </trans-unit>
        <trans-unit id="d6d2ed617694b98c5bd0285a5f46f86c25d55847" translate="yes" xml:space="preserve">
          <source>Combines related scripts together into build layers and minifies them via &lt;a href=&quot;https://github.com/mishoo/UglifyJS&quot;&gt;UglifyJS&lt;/a&gt; (the default) or &lt;a href=&quot;https://developers.google.com/closure/compiler/&quot;&gt;Closure Compiler&lt;/a&gt; (an option when using Java).</source>
          <target state="translated">관련 스크립트를 빌드 계층으로 결합하고 UglifyJS (기본값) 또는 &lt;a href=&quot;https://developers.google.com/closure/compiler/&quot;&gt;Closure Compiler&lt;/a&gt; (Java 사용시 옵션 ) 를 통해 &lt;a href=&quot;https://github.com/mishoo/UglifyJS&quot;&gt;최소화&lt;/a&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="07d154b3af13e40e6878df72ed9863bab9fe1fcc" translate="yes" xml:space="preserve">
          <source>Command line arguments take precedence over build profile settings, and you can mix them together:</source>
          <target state="translated">명령 행 인수는 빌드 프로파일 설정보다 우선하며이를 함께 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbaca3e324c7fb124fc3c0ca9ea74430023f8397" translate="yes" xml:space="preserve">
          <source>Common Errors</source>
          <target state="translated">일반적인 오류</target>
        </trans-unit>
        <trans-unit id="3598d7d42bce6e5debb8491d044313a6d4391ec5" translate="yes" xml:space="preserve">
          <source>Common pitfalls</source>
          <target state="translated">일반적인 함정</target>
        </trans-unit>
        <trans-unit id="377dd01e05316c6519d98a0022d6976f8e76be87" translate="yes" xml:space="preserve">
          <source>CommonJS</source>
          <target state="translated">CommonJS</target>
        </trans-unit>
        <trans-unit id="3dbc94c2a704e3fb93f6eb447d7eed414ca23e94" translate="yes" xml:space="preserve">
          <source>CommonJS Compatibility</source>
          <target state="translated">CommonJS 호환성</target>
        </trans-unit>
        <trans-unit id="f20da1f3f4e4045b9fc11b097d1c1c9323eec094" translate="yes" xml:space="preserve">
          <source>CommonJS Notes</source>
          <target state="translated">CommonJS 노트</target>
        </trans-unit>
        <trans-unit id="608fa7dcad5c38dcc088238a4da1277a62a4b39a" translate="yes" xml:space="preserve">
          <source>CommonJS: require(&quot;some/module&quot;)</source>
          <target state="translated">CommonJS : require ( &quot;일부 / 모듈&quot;)</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">구성 옵션</target>
        </trans-unit>
        <trans-unit id="da75073ccf64da23fa438255a3fdd6e84daac437" translate="yes" xml:space="preserve">
          <source>Contains an URL protocol, like &quot;http:&quot; or &quot;https:&quot;.</source>
          <target state="translated">&quot;http :&quot;또는 &quot;https :&quot;와 같은 URL 프로토콜을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3167f245cbc8d215c6976960c2754d80546e1bdf" translate="yes" xml:space="preserve">
          <source>Conversion Tool</source>
          <target state="translated">변환 도구</target>
        </trans-unit>
        <trans-unit id="cd66685d9cd6b2b42c2db11d0eba3d65d5d8a791" translate="yes" xml:space="preserve">
          <source>Create a build profile, call it app.build.js, and put it in the &lt;strong&gt;scripts&lt;/strong&gt; directory. The app.build.js file can live anywhere, but just be sure to adjust the paths accordingly in the example below -- all paths will be relative to where the app.build.js is located. Example app.build.js:</source>
          <target state="translated">빌드 프로파일을 작성하고 app.build.js라고 부르고 &lt;strong&gt;scripts&lt;/strong&gt; 디렉토리 에 넣으십시오 . app.build.js 파일은 어디에나있을 수 있지만 아래 예제에서 경로를 조정해야합니다. 모든 경로는 app.build.js가있는 위치를 기준으로합니다. app.build.js 예제 :</target>
        </trans-unit>
        <trans-unit id="1a476a67e498299f27aae69b16e1128f1d91db0d" translate="yes" xml:space="preserve">
          <source>Define a Module</source>
          <target state="translated">모듈 정의</target>
        </trans-unit>
        <trans-unit id="189f4dfcede6fb3e70a016718942f39142659677" translate="yes" xml:space="preserve">
          <source>Define a Module as a Function</source>
          <target state="translated">모듈을 함수로 정의</target>
        </trans-unit>
        <trans-unit id="66ccb9e013158fbc3a0890cc84a9136c73c36e93" translate="yes" xml:space="preserve">
          <source>Define a Module with Simplified CommonJS Wrapper</source>
          <target state="translated">단순화 된 CommonJS 랩퍼로 모듈 정의</target>
        </trans-unit>
        <trans-unit id="78e56a3b87783e09008d96bc99a9b226632119a4" translate="yes" xml:space="preserve">
          <source>Define a Module with a Name</source>
          <target state="translated">이름을 가진 모듈 정의</target>
        </trans-unit>
        <trans-unit id="c64294aaf8b834dea9d34fbaf4321fc3a5b4f013" translate="yes" xml:space="preserve">
          <source>Define a Module with a name</source>
          <target state="translated">이름으로 모듈 정의</target>
        </trans-unit>
        <trans-unit id="8c8625f86972268a058a221c6d37f22a9e520f5b" translate="yes" xml:space="preserve">
          <source>Define an I18N Bundle</source>
          <target state="translated">I18N 번들 정의</target>
        </trans-unit>
        <trans-unit id="fa75a5475ca40562532f5ffdf64a6ce1181c51de" translate="yes" xml:space="preserve">
          <source>Defined via an immediately executed factory function.</source>
          <target state="translated">즉시 실행되는 팩토리 기능을 통해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="42997a499151458874dda0ecc25c9a1fcfa504a6" translate="yes" xml:space="preserve">
          <source>Defines a way to include multiple modules in one file. In CommonJS terms, the term for this is a &quot;transport format&quot;, and that group has not agreed on a transport format.</source>
          <target state="translated">하나의 파일에 여러 모듈을 포함시키는 방법을 정의합니다. CommonJS 용어에서이 용어는 &quot;전송 형식&quot;이며 해당 그룹은 전송 형식에 동의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdf3ec7d85deb7255fa2bef9b00a822a98bb25f3" translate="yes" xml:space="preserve">
          <source>Definition Functions</source>
          <target state="translated">정의 함수</target>
        </trans-unit>
        <trans-unit id="faf01da1eac83429ecc9c72c9146d7e09eb9a2f9" translate="yes" xml:space="preserve">
          <source>Definition Functions with Dependencies</source>
          <target state="translated">종속성이있는 정의 함수</target>
        </trans-unit>
        <trans-unit id="d8d24b4df469c65b7393a388ec6cf5108cf5cc1b" translate="yes" xml:space="preserve">
          <source>Deployment techniques</source>
          <target state="translated">배포 기술</target>
        </trans-unit>
        <trans-unit id="e73a7a403dde32f64dd64c0324b5e45fd6828b65" translate="yes" xml:space="preserve">
          <source>Deployment wants optimized code in just one or a few HTTP calls</source>
          <target state="translated">배포는 단 하나 또는 몇 개의 HTTP 호출에서 최적화 된 코드를 원합니다</target>
        </trans-unit>
        <trans-unit id="f146bd1e1b38bcbf234c5237e3addabe504d35c6" translate="yes" xml:space="preserve">
          <source>Developer wants discrete JS files/modules</source>
          <target state="translated">개발자가 개별 JS 파일 / 모듈을 원함</target>
        </trans-unit>
        <trans-unit id="a481992d7ccb15bb38685fcea241700faca3a3bf" translate="yes" xml:space="preserve">
          <source>Developers have been taught that eval() is bad.</source>
          <target state="translated">개발자들은 eval ()이 나쁘다는 것을 배웠다.</target>
        </trans-unit>
        <trans-unit id="219a0f230ec1049125aed42d415e5e8b978de144" translate="yes" xml:space="preserve">
          <source>Did not call define() to declare a module.</source>
          <target state="translated">모듈을 선언하기 위해 define ()을 호출하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="328d3aebd3a0aa42c86f5ab59c01d68aa18233bf" translate="yes" xml:space="preserve">
          <source>Do not mix CDN loading with shim config in a build. Example scenario: you load jQuery from the CDN but use the shim config to load something like the stock version of Backbone that depends on jQuery. When you do the build, be sure to inline jQuery in the built file and do not load it from the CDN. Otherwise, Backbone will be inlined in the built file and it will execute before the CDN-loaded jQuery will load. This is because the shim config just delays loading of the files until dependencies are loaded, but does not do any auto-wrapping of define. After a build, the dependencies are already inlined, the shim config cannot delay execution of the non-define()'d code until later. define()'d modules do work with CDN loaded code after a build because they properly wrap their source in define factory function that will not execute until dependencies are loaded. So the lesson: shim config is a stop-gap measure for non-modular code, legacy code. define()'d modules are better.</source>
          <target state="translated">빌드에서 CDN 로딩을 shim 구성과 혼합하지 마십시오. 시나리오 예 : CDN에서 jQuery를로드하지만 shim 구성을 사용하여 jQuery에 의존하는 Backbone의 스톡 버전과 같은 것을로드합니다. 빌드를 수행 할 때 빌드 된 파일에서 jQuery를 인라인하고 CDN에서로드하지 마십시오. 그렇지 않으면 빌드 된 파일에 백본이 인라인되고 CDN로드 jQuery가로드되기 전에 실행됩니다. 이는 shim 구성이 종속성이로드 될 때까지 파일로드를 지연 시키지만 define의 자동 랩핑을 수행하지 않기 때문입니다. 빌드 후에는 종속성이 이미 인라인되어 있으며 shim 구성은 나중에 정의되지 않은 () 코드의 실행을 지연시킬 수 없습니다. 밝히다()'d 모듈은 종속성이로드 될 때까지 실행되지 않는 팩토리 기능을 정의하여 소스를 올바르게 랩핑하므로 빌드 후 CDN로드 코드로 작업합니다. 교훈 : shim config는 비 모듈 식 코드, 레거시 코드에 대한 스톱 갭 측정입니다. define ()의 모듈이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="96b6222e1ddbeef44870965e7ae83e15408dd547" translate="yes" xml:space="preserve">
          <source>Do not use named modules for the plugin or the pluginBuilder. The pluginBuilder text contents are used instead of the contents of the plugin file, but that will only work if the files do not call define() with a name.</source>
          <target state="translated">플러그인 또는 pluginBuilder에 명명 된 모듈을 사용하지 마십시오. pluginBuilder 텍스트 컨텐츠는 플러그인 파일의 컨텐츠 대신 사용되지만 파일이 이름으로 define ()을 호출하지 않는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="939aac5818debe88f05652cab470ae8b364ea867" translate="yes" xml:space="preserve">
          <source>Doesn't Node already have a module loader?</source>
          <target state="translated">Node에 이미 모듈 로더가 없습니까?</target>
        </trans-unit>
        <trans-unit id="5461862cf2987931cc425d89eae23192e1a26a75" translate="yes" xml:space="preserve">
          <source>Dojo has used an XHR-based loader with eval() and, while it works, it has been a source of frustration for developers. Dojo has an xdomain loader but it requires the modules to be modified via a build step to use a function wrapper, so that script src=&quot;&quot; tags can be used to load the modules. There are many edge cases and moving parts that create a tax on the developer.</source>
          <target state="translated">Dojo는 eval ()과 함께 XHR 기반 로더를 사용했으며 작동하는 동안 개발자에게 좌절의 원인이되었습니다. Dojo에는 xdomain 로더가 있지만 함수 랩퍼를 사용하려면 빌드 단계를 통해 모듈을 수정해야하므로 스크립트 src = &quot;&quot;태그를 사용하여 모듈을로드 할 수 있습니다. 개발자에게 세금을 부과하는 많은 경우와 움직이는 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c37874e83716706a25248b1cc2caab10d065981" translate="yes" xml:space="preserve">
          <source>Dojo: dojo.require(&quot;some.module&quot;)</source>
          <target state="translated">Dojo : dojo.require ( &quot;some.module&quot;)</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="7f08ea8e56c0fdd9a56781f715142185194a5510" translate="yes" xml:space="preserve">
          <source>Download r.js</source>
          <target state="translated">r.js 다운로드</target>
        </trans-unit>
        <trans-unit id="772e282a4cefb734bdd20a55250e8c92a14780f7" translate="yes" xml:space="preserve">
          <source>Download r.js from the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;the download page&lt;/a&gt; and place it in your project.</source>
          <target state="translated">&lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 r.js를 다운로드 하여 프로젝트에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="1e2c8e900ec69791d402b60b6aaf717dc5250f0a" translate="yes" xml:space="preserve">
          <source>During development it can be useful to use this, however &lt;strong&gt;be sure&lt;/strong&gt; to remove it before deploying your code.</source>
          <target state="translated">개발하는 동안은 그러나, 이것을 사용하는 것이 유용 할 수 있습니다 &lt;strong&gt;확인&lt;/strong&gt; 코드를 배포하기 전에 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc0ea631ae7a283acdcc5aaa876bb753365d31e" translate="yes" xml:space="preserve">
          <source>Ease of use for developer but then backed by an optimization tool that helps deployment</source>
          <target state="translated">개발자의 사용 편의성 및 배포를 돕는 최적화 도구의 지원</target>
        </trans-unit>
        <trans-unit id="63b393cc9a4a0d5bf2d8a0ec0b4da8eff38350f3" translate="yes" xml:space="preserve">
          <source>Either use a server to translate CJS modules to something usable in the browser.</source>
          <target state="translated">서버를 사용하여 CJS 모듈을 브라우저에서 사용할 수있는 것으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="84e9b67a6f981cdb4872ac5dac561f7cf07cccd4" translate="yes" xml:space="preserve">
          <source>EmbedJS</source>
          <target state="translated">EmbedJS</target>
        </trans-unit>
        <trans-unit id="f1f761ede057b4e84e4906c723905d89eef44ed3" translate="yes" xml:space="preserve">
          <source>Encapsulates the module definition. Gives you the tools to avoid polluting the global namespace.</source>
          <target state="translated">모듈 정의를 캡슐화합니다. 글로벌 네임 스페이스를 오염시키지 않도록하는 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf740dd5d26c6fca83cd6c9187c2c8eab6ba10d1" translate="yes" xml:space="preserve">
          <source>Ends in &quot;.js&quot;.</source>
          <target state="translated">&quot;.js&quot;로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="ed11fe043f6b0340e5d82d2606fa460b6babef5a" translate="yes" xml:space="preserve">
          <source>Errbacks, when used with &lt;a href=&quot;#undef&quot;&gt;requirejs.undef()&lt;/a&gt;, will allow you to detect if a module fails to load, undefine that module, reset the config to a another location, then try again.</source>
          <target state="translated">Errbacks는 &lt;a href=&quot;#undef&quot;&gt;requirejs.undef ()&lt;/a&gt; 와 함께 사용 하면 모듈로드 실패를 감지하고 해당 모듈을 정의 해제하고 구성을 다른 위치로 재설정 한 다음 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eaff2b36bd5390e86b360d0c7b6f28ed86dd972" translate="yes" xml:space="preserve">
          <source>Error evaluating module ...</source>
          <target state="translated">모듈 평가 오류 ...</target>
        </trans-unit>
        <trans-unit id="70578c9a1e198f18d274db253ee3cafd1becb013" translate="yes" xml:space="preserve">
          <source>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override requirejs.onError() to get errors. There is more information in the &lt;a href=&quot;#errors&quot;&gt;Handling Errors&lt;/a&gt; section.</source>
          <target state="translated">스크립트 태그로드는 네트워크 문제에 대한 세부 정보를 제공하지 않기 때문에 JSONP 서비스를로드 할 때 발생하는 오류는 일반적으로 서비스 시간 초과를 통해 발생합니다. 오류를 감지하기 위해 requirejs.onError ()를 재정 의하여 오류를 얻을 수 있습니다. &lt;a href=&quot;#errors&quot;&gt;처리 오류&lt;/a&gt; 섹션 에 자세한 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68e28ee55464a1d1e034b9c2cdd48aa0465e3768" translate="yes" xml:space="preserve">
          <source>Even though this sugared form is referred to as the &quot;simplified CommonJS wrapping&quot;, it is not 100% compatible with CommonJS modules. However, the cases that are not supported would likely break in the browser anyway, since they generally assume synchronous loading of dependencies.</source>
          <target state="translated">이 설탕 형태를 &quot;간단한 CommonJS 랩핑&quot;이라고하지만 CommonJS 모듈과 100 % 호환되지는 않습니다. 그러나 지원되지 않는 경우는 일반적으로 종속성의 동기로드를 가정하므로 브라우저에서 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bdd3805ee03a8fc687719101da0553ac851e064" translate="yes" xml:space="preserve">
          <source>Example loading jquery from a CDN</source>
          <target state="translated">CDN에서 jquery를로드하는 예</target>
        </trans-unit>
        <trans-unit id="3efec32df92355a1ca633f6661b69247faea26e1" translate="yes" xml:space="preserve">
          <source>Example setup</source>
          <target state="translated">설정 예</target>
        </trans-unit>
        <trans-unit id="dc00f9209ed5fc486b962c6c879b21f1625ebcab" translate="yes" xml:space="preserve">
          <source>Example setup:</source>
          <target state="translated">설정 예 :</target>
        </trans-unit>
        <trans-unit id="224b367055058734b170711429534306a8ffc7a6" translate="yes" xml:space="preserve">
          <source>Example using jQuery from a CDN</source>
          <target state="translated">CDN에서 jQuery를 사용하는 예</target>
        </trans-unit>
        <trans-unit id="f4a368325467204d6eea61a556b25125bc35ae17" translate="yes" xml:space="preserve">
          <source>Example using jQuery with shim config</source>
          <target state="translated">shim 구성과 함께 jQuery를 사용하는 예</target>
        </trans-unit>
        <trans-unit id="6d4eadd1631e4c221838a04cf62b524bceedd734" translate="yes" xml:space="preserve">
          <source>Example using shim config</source>
          <target state="translated">shim 구성을 사용하는 예</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="23b239cd6f051075d94afab2b814784cfd6d8712" translate="yes" xml:space="preserve">
          <source>Examples of existing loader plugins are the &lt;a href=&quot;api#text&quot;&gt;text!&lt;/a&gt; and &lt;a href=&quot;api#i18n&quot;&gt;i18n!&lt;/a&gt; plugins. The text! plugin handles loading text, and the i18n plugin handles loading a JavaScript object that is made up from objects from a few different modules. The object contains localized strings.</source>
          <target state="translated">기존 로더 플러그인의 예는 &lt;a href=&quot;api#text&quot;&gt;텍스트입니다! &lt;/a&gt;그리고 &lt;a href=&quot;api#i18n&quot;&gt;i18n! &lt;/a&gt;플러그인. 텍스트! 플러그인은 텍스트로드를 처리하고 i18n 플러그인은 몇 가지 다른 모듈의 객체로 구성된 JavaScript 객체로드를 처리합니다. 개체에 지역화 된 문자열이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="998f21f8963945821d88b707dca0b2a0f29fdd6f" translate="yes" xml:space="preserve">
          <source>Finally, scripts loaded via document.write() will block page rendering. When looking at reaching the very best performance for your site, this is undesirable.</source>
          <target state="translated">마지막으로 document.write ()를 통해로드 된 스크립트는 페이지 렌더링을 차단합니다. 귀하의 사이트에서 최상의 성능을 달성 할 때 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="175c805bfb026f6dd1ae25e3a67e08f4c3661d04" translate="yes" xml:space="preserve">
          <source>First thing to sort out is a script loading API. Here are some candidates:</source>
          <target state="translated">먼저 정렬하는 것은 스크립트 로딩 API입니다. 다음은 몇 가지 후보입니다.</target>
        </trans-unit>
        <trans-unit id="a90b34ff72906618ca01c653f046b57a18681b11" translate="yes" xml:space="preserve">
          <source>For &quot;modules&quot; that are just jQuery or Backbone plugins that do not need to export any module value, the shim config can just be an array of dependencies:</source>
          <target state="translated">모듈 값을 내보낼 필요가없는 jQuery 또는 Backbone 플러그인 인 &quot;모듈&quot;의 경우 shim 구성은 종속성의 배열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ad7374cf0e0eba66583a00969ccff593147427" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;baseUrl&lt;/strong&gt;, it is relative to &lt;strong&gt;appDir&lt;/strong&gt;. If no appDir, then baseUrl is relative to the build.js file, or if just using command line arguments, the current working directory.</source>
          <target state="translated">들어 &lt;strong&gt;base을&lt;/strong&gt; , 그것은을 기준으로 &lt;strong&gt;APPDIR&lt;/strong&gt; . appDir이 없으면 baseUrl은 build.js 파일과 관련이 있거나 명령 행 인수를 사용하는 경우 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="90082fa061b7ff8b7cd0a448136b2609a1f99a73" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;paths&lt;/strong&gt; and &lt;strong&gt;packages&lt;/strong&gt;, they are relative to &lt;strong&gt;baseUrl&lt;/strong&gt;, just as they are for require.js.</source>
          <target state="translated">들어 &lt;strong&gt;경로&lt;/strong&gt; 와 &lt;strong&gt;패키지&lt;/strong&gt; , 그들은을 기준으로합니다 &lt;strong&gt;base을&lt;/strong&gt; 그들이 require.js위한 것처럼.</target>
        </trans-unit>
        <trans-unit id="b4888adc510c14f09052a4ead7056d06ab63e997" translate="yes" xml:space="preserve">
          <source>For a list of all options, see &lt;a href=&quot;#options&quot;&gt;all configuration options&lt;/a&gt;.</source>
          <target state="translated">모든 옵션 목록은 &lt;a href=&quot;#options&quot;&gt;모든 구성 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41fba1fa8ce86f1c3d45cbe5777638d9c6ca8bd4" translate="yes" xml:space="preserve">
          <source>For command line use, Node is the preferred execution environment. The optimizer runs &lt;strong&gt;much faster&lt;/strong&gt; with Node.</source>
          <target state="translated">명령 행 사용의 경우 Node가 선호되는 실행 환경입니다. 최적화 프로그램은 노드 에서 &lt;strong&gt;훨씬 빠르게&lt;/strong&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="46d18226ef9def86d3f91dfb4e33301be9de7112" translate="yes" xml:space="preserve">
          <source>For example, this arrangement will fail randomly when the require.config path for the 'foo' module has not been set prior to it being require()'d later:</source>
          <target state="translated">예를 들어,이 배열은 'foo'모듈의 require.config 경로가 나중에 require ()로 설정되기 전에 설정되지 않은 경우 무작위로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5a202a8b0743195728976863adc4266d26ad81f6" translate="yes" xml:space="preserve">
          <source>For instance, if your baseUrl is 'js' and your build output goes into 'js/build', there will likely be problems with extra, nested files generated on each optimization run. This guidance is only for optimizations that are not single file optimizations.</source>
          <target state="translated">예를 들어 baseUrl이 'js'이고 빌드 출력이 'js / build'로 들어가면 각 최적화 실행에서 생성 된 추가 중첩 파일에 문제가있을 수 있습니다. 이 지침은 단일 파일 최적화가 아닌 최적화에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="15a25512db354fba2b1c0f67a759cb1835854dc0" translate="yes" xml:space="preserve">
          <source>For instance, if your baseUrl is 'js', and your optimization targets:</source>
          <target state="translated">예를 들어 baseUrl이 'js'이고 최적화가 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="ad7ee220a39b0c9430dff0ce64564e3baf2c7f3a" translate="yes" xml:space="preserve">
          <source>For local, multi-file builds, the above CDN advice also applies. For any shimmed script, its dependencies &lt;strong&gt;must&lt;/strong&gt; be loaded before the shimmed script executes. This means either building its dependencies directly in the buid layer that includes the shimmed script, or loading its dependencies with a &lt;code&gt;require([], function (){})&lt;/code&gt; call, then doing a nested &lt;code&gt;require([])&lt;/code&gt; call for the build layer that has the shimmed script.</source>
          <target state="translated">로컬 다중 파일 빌드의 경우 위 CDN 조언도 적용됩니다. shimmed 스크립트의 경우 shimmed 스크립트가 실행되기 전에 해당 종속성 &lt;strong&gt;을&lt;/strong&gt; 로드 &lt;strong&gt;해야합니다&lt;/strong&gt; . 이는 shimed 스크립트가 포함 된 buid 레이어에 직접 종속성을 빌드하거나 &lt;code&gt;require([], function (){})&lt;/code&gt; 호출 로 종속성을로드 한 다음 빌드 레이어에 대해 중첩 된 &lt;code&gt;require([])&lt;/code&gt; 호출을 수행함을 의미합니다. 그것은 shimmed 스크립트를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf3894d920edb907a5af18ac327dfff2aab56c1c" translate="yes" xml:space="preserve">
          <source>For passing config to a &lt;a href=&quot;#packages&quot;&gt;package&lt;/a&gt;, target the main module in the package, not the package ID:</source>
          <target state="translated">&lt;a href=&quot;#packages&quot;&gt;패키지에&lt;/a&gt; 구성을 전달 하려면 패키지 ID가 아닌 패키지의 기본 모듈을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="63a67215832883c72eac42d92074a84ae8301eb1" translate="yes" xml:space="preserve">
          <source>For properties that are module IDs, they should be module IDs, and not file paths. Examples are &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;include&lt;/strong&gt;, &lt;strong&gt;exclude&lt;/strong&gt;, &lt;strong&gt;excludeShallow&lt;/strong&gt;, &lt;strong&gt;deps&lt;/strong&gt;.</source>
          <target state="translated">모듈 ID 인 속성의 경우 파일 경로가 아니라 모듈 ID 여야합니다. 예를 들어 &lt;strong&gt;name&lt;/strong&gt; , &lt;strong&gt;include&lt;/strong&gt; , &lt;strong&gt;exclude&lt;/strong&gt; , &lt;strong&gt;excludeShallow&lt;/strong&gt; , &lt;strong&gt;deps가&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="da2e5f2fc604cad6e80ee143dc25482cb3f5fb40" translate="yes" xml:space="preserve">
          <source>For this case, &lt;a href=&quot;#packages&quot;&gt;packages config&lt;/a&gt; is a better option, since it allows setting the main module up as 'compute', but internally the loader will store the module with the ID of 'compute/main' so that the relative reference for './extras' works.</source>
          <target state="translated">이 경우, &lt;a href=&quot;#packages&quot;&gt;패키지 설정&lt;/a&gt; 은 메인 모듈을 '계산'으로 설정할 수 있기 때문에 더 나은 옵션이지만 내부적으로 로더는 './'에 대한 상대 참조를 위해 '계산 / 메인'ID로 모듈을 저장합니다. 엑스트라의 작품.</target>
        </trans-unit>
        <trans-unit id="daf2b5474bd3235184beeccc554c1df2bdeea4c4" translate="yes" xml:space="preserve">
          <source>Front-end developers need a solution with:</source>
          <target state="translated">프론트 엔드 개발자는 다음과 같은 솔루션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="21caff7b3dd07a030f4af9d90202d8819054ac0e" translate="yes" xml:space="preserve">
          <source>Function Wrapping</source>
          <target state="translated">기능 랩핑</target>
        </trans-unit>
        <trans-unit id="9e47c58fdafb0242e1dee3bfbbe05dddb269aeb3" translate="yes" xml:space="preserve">
          <source>Function wrapping</source>
          <target state="translated">기능 포장</target>
        </trans-unit>
        <trans-unit id="f3a72ad6704d234f02a07df5cc8686bbb29dc1eb" translate="yes" xml:space="preserve">
          <source>Get the source from the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js repo&lt;/a&gt; and either generate the r.js via &quot;node dist.js&quot;, or grab a snapshot from the &lt;strong&gt;dist&lt;/strong&gt; directory.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js 저장소&lt;/a&gt; 에서 소스를 가져 와서 &quot;node dist.js&quot;를 통해 r.js를 생성하거나 &lt;strong&gt;dist&lt;/strong&gt; 디렉토리 에서 스냅 샷을 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="74e2a80eaf85ea086577d0cfa162676f02820f46" translate="yes" xml:space="preserve">
          <source>Give an AMD loader a try. You have some choices:</source>
          <target state="translated">AMD 로더를 사용해보십시오. 몇 가지 선택 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">글로벌 함수</target>
        </trans-unit>
        <trans-unit id="ce96da2fcb6160b73a5d26f7189c13b3152539b9" translate="yes" xml:space="preserve">
          <source>Global requirejs.onError function</source>
          <target state="translated">전역 requirejs.onError 함수</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="8997ec42b86be4e01e18491b00b453fd2e899587" translate="yes" xml:space="preserve">
          <source>Having a working, easy to debug module system that works in today's browsers means getting real world experience in making the best module system for JavaScript in the future.</source>
          <target state="translated">오늘날의 브라우저에서 작동하는 작동하기 쉽고 디버그하기 쉬운 모듈 시스템을 보유한다는 것은 향후 JavaScript를위한 최상의 모듈 시스템을 만드는 데있어 실제 경험을 얻는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="06408e9afad9005f462f690d3c05a26d7179cd63" translate="yes" xml:space="preserve">
          <source>Here is an example that calls a JSONP API endpoint. In this example, the JSONP callback parameter is called &quot;callback&quot;, so &quot;callback=define&quot; tells the API to wrap the JSON response in a &quot;define()&quot; wrapper:</source>
          <target state="translated">다음은 JSONP API 엔드 포인트를 호출하는 예제입니다. 이 예제에서 JSONP 콜백 매개 변수는 &quot;콜백&quot;이라고하며 &quot;callback = define&quot;은 API에 &quot;define ()&quot;랩퍼로 JSON 응답을 랩핑하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9e0c75f4aeccdb862eae83bcee4b7bc79aafb9f8" translate="yes" xml:space="preserve">
          <source>Here is an example. It requires RequireJS 2.1.0+, and assumes backbone.js, underscore.js and jquery.js have been installed in the baseUrl directory. If not, then you may need to set a paths config for them:</source>
          <target state="translated">다음은 예입니다. RequireJS 2.1.0 이상이 필요하며 backbone.js, underscore.js 및 jquery.js가 baseUrl 디렉토리에 설치되었다고 가정합니다. 그렇지 않은 경우 경로 구성을 설정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a46fea6d88fd1965dfa2a0c927c5aaa89170d7" translate="yes" xml:space="preserve">
          <source>Here is how the example directory layout looks with two packages, &lt;strong&gt;cart&lt;/strong&gt; and &lt;strong&gt;store&lt;/strong&gt;:</source>
          <target state="translated">다음은 예제 디렉토리 레이아웃이 &lt;strong&gt;cart&lt;/strong&gt; 와 &lt;strong&gt;store&lt;/strong&gt; 라는 두 패키지로 보이는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="3a88db88697c21ef8d1cb42f13b3c0fb0771f81f" translate="yes" xml:space="preserve">
          <source>How are pieces of JavaScript code defined today?</source>
          <target state="translated">오늘날 JavaScript 코드는 어떻게 정의됩니까?</target>
        </trans-unit>
        <trans-unit id="b05b322d83bfb47db730d9d1707bae561b692314" translate="yes" xml:space="preserve">
          <source>How do I use it?</source>
          <target state="translated">어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="736cbdabaf11b32da124d26c68a2525dfc0b63bc" translate="yes" xml:space="preserve">
          <source>How to use RequireJS with Dojo</source>
          <target state="translated">Dojo와 함께 RequireJS를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="99584e4621acdc9224936d99361a8939fa2c7f71" translate="yes" xml:space="preserve">
          <source>How to use RequireJS with jQuery</source>
          <target state="translated">jQuery와 함께 RequireJS를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="baa492ec7a0eb06bdf669c1f811a659737516a9d" translate="yes" xml:space="preserve">
          <source>However, for the minifier to accurately construct a source map, the minified source cannot be modified in any way, so &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; is incompatible with &lt;strong&gt;generateSourceMaps&lt;/strong&gt;. generateSourceMaps was introduced in version 2.1.2 of the optimizer.</source>
          <target state="translated">그러나 축소 기가 소스 맵을 정확하게 구성하기 위해 축소 된 소스를 어떤 식 으로든 수정할 수 없으므로 &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; 가 &lt;strong&gt;generateSourceMaps&lt;/strong&gt; 와 호환되지 않습니다 . generateSourceMaps는 옵티 마이저 버전 2.1.2에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="06764a60d7302cd5011c01b08065e6465af17bde" translate="yes" xml:space="preserve">
          <source>However, if you are in a project that you know uses define() to declare all of its modules, or it uses the &lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt; config to specify string exports for anything that does not use define(), then if you set the &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt; config value to true, the loader can confirm if a script load by checking for the define() call or the existence of the shim's exports global value.</source>
          <target state="translated">그러나 프로젝트에있는 경우 define ()을 사용하여 모든 모듈을 선언하거나 &lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt; 구성을 사용하여 define ()을 사용하지 않는 문자열 내보내기를 지정하는 경우, &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt; 구성 값 을 설정하면 로더는 define () 호출 또는 shim 내보내기 글로벌 값의 존재를 확인하여 스크립트가로드되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dec98a5a8a1a825635cf9d8999487f368e4da493" translate="yes" xml:space="preserve">
          <source>However, in the &lt;a href=&quot;#4&quot;&gt;Async vs Sync example&lt;/a&gt; we cannot just execute that script directly. Ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first. But we do not have access to the script before it is executed.</source>
          <target state="translated">그러나 &lt;a href=&quot;#4&quot;&gt;Async vs Sync 예제&lt;/a&gt; 에서는 해당 스크립트를 직접 실행할 수 없습니다. 이상적으로는 스크립트를 실행하기 전에 require () 종속성을 알고 해당 종속성을 먼저로드해야합니다. 그러나 스크립트가 실행되기 전에는 스크립트에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dfbdab0a1069903e763d697a837c846906f023f0" translate="yes" xml:space="preserve">
          <source>However, it is more likely that you do not want to include that resource in the build. If the script does not have any dependencies, or you do not want to include its dependencies or will be including them in another way, then you can use the special &lt;strong&gt;'empty:' scheme&lt;/strong&gt; in the paths config to just skip the file when doing an optimization.</source>
          <target state="translated">그러나 빌드에 해당 자원을 포함시키지 않을 가능성이 높습니다. 스크립트에 종속성이 없거나 종속성을 포함하지 않거나 다른 방법으로 포함하려는 경우 경로 구성에서 특수한 &lt;strong&gt;'empty :'체계&lt;/strong&gt; 를 사용하여 파일을 건너 뛸 수 있습니다. 최적화.</target>
        </trans-unit>
        <trans-unit id="d180421a35263e9cbc4e5f01cb5316f24e8911c5" translate="yes" xml:space="preserve">
          <source>However, it still has the &lt;a href=&quot;#4&quot;&gt;Async vs Sync example&lt;/a&gt; problem: ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first.</source>
          <target state="translated">그러나 여전히 &lt;a href=&quot;#4&quot;&gt;비동기 대 동기화 예제&lt;/a&gt; 문제가 있습니다. 이상적으로는 스크립트를 실행하기 전에 require () 종속성을 알고 해당 종속성을 먼저로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37ed8422dc4b848a82f406f48365216fdc2513aa" translate="yes" xml:space="preserve">
          <source>However, not all browsers in use support DOMContentLoaded. The domReady module implements a cross-browser method to determine when the DOM is ready. &lt;a href=&quot;http://requirejs.org/docs/download.html#domReady&quot;&gt;Download the module&lt;/a&gt; and use it in your project like so:</source>
          <target state="translated">그러나 사용중인 모든 브라우저가 DOMContentLoaded를 지원하는 것은 아닙니다. domReady 모듈은 크로스 브라우저 방법을 구현하여 DOM이 준비된 시점을 결정합니다. &lt;a href=&quot;http://requirejs.org/docs/download.html#domReady&quot;&gt;모듈을 다운로드&lt;/a&gt; 하여 프로젝트에서 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0251cde2be08202fcc02450703af91a17d8975c1" translate="yes" xml:space="preserve">
          <source>However, tools that combine multiple modules together for performance need a way to give names to each module in the optimized file. For that, AMD allows a string as the first argument to define():</source>
          <target state="translated">그러나 성능을 위해 여러 모듈을 결합한 도구에는 최적화 된 파일의 각 모듈에 이름을 지정할 수있는 방법이 필요합니다. 이를 위해 AMD는 문자열을 define ()의 첫 번째 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="487b1f01c66606179dbf2f41be406387d07ea6c5" translate="yes" xml:space="preserve">
          <source>However, we need something that works well in the browser. The CommonJS require() is a synchronous call, it is expected to return the module immediately. This does not work well in the browser.</source>
          <target state="translated">그러나 브라우저에서 잘 작동하는 것이 필요합니다. CommonJS require ()는 동기식 호출이며 모듈을 즉시 리턴 할 것으로 예상됩니다. 브라우저에서 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d820ffdc00059491579804e4bd96d555e261655" translate="yes" xml:space="preserve">
          <source>I believe it is important to not force the use of a runtime server process to transform code:</source>
          <target state="translated">런타임 서버 프로세스를 사용하여 코드를 변환하지 않는 것이 중요하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ff857cf4b37b9b4eaa5dda5da862a37bf0231191" translate="yes" xml:space="preserve">
          <source>IDs can be mapped to different paths. This allows swapping out implementation. This is great for creating mocks for unit testing. For the above code sample, the code just expects something that implements the jQuery API and behavior. It does not have to be jQuery.</source>
          <target state="translated">ID는 다른 경로에 매핑 될 수 있습니다. 이를 통해 구현을 교체 할 수 있습니다. 이것은 단위 테스트를위한 모의 객체를 만드는 데 좋습니다. 위 코드 샘플의 경우 코드는 jQuery API 및 동작을 구현하는 무언가를 기대합니다. jQuery 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ccf772d613332cb26f229f7f1c3711365b71cd6c" translate="yes" xml:space="preserve">
          <source>Ideally the scripts you load will be modules that are defined by calling &lt;a href=&quot;#define&quot;&gt;define()&lt;/a&gt;. However, you may need to use some traditional/legacy &quot;browser globals&quot; scripts that do not express their dependencies via define(). For those, you can use the &lt;a href=&quot;#config-shim&quot;&gt;shim config&lt;/a&gt;. To properly express their dependencies.</source>
          <target state="translated">이상적으로로드하는 스크립트는 &lt;a href=&quot;#define&quot;&gt;define ()&lt;/a&gt; 을 호출하여 정의 된 모듈입니다 . 그러나 define ()을 통해 의존성을 표현하지 않는 일부 전통적인 / 레거시 &quot;브라우저 글로벌&quot;스크립트를 사용해야 할 수도 있습니다. 이를 위해 &lt;a href=&quot;#config-shim&quot;&gt;shim config를&lt;/a&gt; 사용할 수 있습니다 . 그들의 의존성을 올바르게 표현하기 위해.</target>
        </trans-unit>
        <trans-unit id="8bc66eb67c7dbf88c0c91113e3a440efe63a9356" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;all of your modules&lt;/strong&gt; (including any third party jQuery plugins or library code that depend on jQuery) are AMD compatible and you want to avoid having $ or jQuery in the global namespace when they call &lt;code&gt;requirejs(['jquery'])&lt;/code&gt;, you can use the &lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt; to map the use of jQuery to a module that calls noConflict and returns that value of jQuery for the 'jquery' module ID.</source>
          <target state="translated">만약 &lt;strong&gt;당신의 모든 모듈&lt;/strong&gt; 호환 AMD이고, 당신은 그들이 전화를 전역 네임 스페이스에 $ 또는 jQuery를하지 않으려 (jQuery를에 의존하는 타사의 jQuery 플러그인이나 라이브러리 코드 포함) &lt;code&gt;requirejs(['jquery'])&lt;/code&gt; , 당신이 할 수있는 사용 &lt;a href=&quot;api#config-map&quot;&gt;맵 설정을&lt;/a&gt; noConflict하고 'JQuery와'모듈 ID에 대한 jQuery를 값이 반환을 호출하는 모듈에 jQuery를 사용을 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d09b91ed8f5ecda7ebb9c933cb5789a594eb6c1" translate="yes" xml:space="preserve">
          <source>If a JS module system cannot deliver on the above features, it is at a significant disadvantage when compared to AMD and its related APIs around &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;, &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader plugins&lt;/a&gt;, and paths-based module IDs.</source>
          <target state="translated">JS 모듈 시스템이 위의 기능을 제공 할 수없는 경우 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;콜백 요구 사항&lt;/a&gt; , &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;로더 플러그인&lt;/a&gt; 및 경로 기반 모듈 ID와 관련된 AMD 및 관련 API와 비교할 때 상당한 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="923ff2f6c2d2940aa6cfdc5a2817aaecc5e810e7" translate="yes" xml:space="preserve">
          <source>If a plugin does not implement normalize, then the loader will try to normalize the resource name using the normal module name rules.</source>
          <target state="translated">플러그인이 정규화를 구현하지 않으면 로더는 일반 모듈 이름 규칙을 사용하여 자원 이름을 정규화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="e73a84c56940c8d1218f3e2d895a4872504fde03" translate="yes" xml:space="preserve">
          <source>If doing a whole project optimization, but only want to minify the build layers specified in &lt;strong&gt;modules&lt;/strong&gt; options and not the rest of the JS files in the build output directory, you can set &lt;strong&gt;skipDirOptimize&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전체 프로젝트 최적화를 수행하지만 빌드 출력 디렉토리의 나머지 JS 파일이 아닌 &lt;strong&gt;모듈&lt;/strong&gt; 옵션에 지정된 빌드 계층 만 &lt;strong&gt;축소&lt;/strong&gt; 하려는 &lt;code&gt;true&lt;/code&gt; &lt;strong&gt;skipDirOptimize&lt;/strong&gt; 를 true로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70533f68a7c93619cec8126932c9830808b8e124" translate="yes" xml:space="preserve">
          <source>If in IE, check for an HTTP 404 error or a JavaScript sytnax error by using a script debugger.</source>
          <target state="translated">IE 인 경우 스크립트 디버거를 사용하여 HTTP 404 오류 또는 JavaScript sytnax 오류를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d06fb6574033aac10ae536e27b312a12a1437aa4" translate="yes" xml:space="preserve">
          <source>If it is not possible to upgrade the shimmed code to use AMD define() calls, as of RequireJS 2.1.11, the optimizer has a &lt;a href=&quot;https://github.com/requirejs/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68&quot;&gt;wrapShim build option&lt;/a&gt; that will try to automatically wrap the shimmed code in a define() for a build. This changes the scope of shimmed dependencies, so it is not guaranteed to always work, but, for example, for shimmed dependencies that depend on an AMD version of Backbone, it can be helpful.</source>
          <target state="translated">RequireJS 2.1.11에서 AMD define () 호출을 사용하도록 shimmed 코드를 업그레이드 할 수없는 경우 옵티 마이저에는 &lt;a href=&quot;https://github.com/requirejs/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68&quot;&gt;shimed&lt;/a&gt; 코드를 빌드의 define ()에 자동으로 랩핑 하는 wrapShim 빌드 옵션 이 있습니다. 이로 인해 shimed 종속성의 범위가 변경되므로 항상 작동하지는 않지만 AMD 버전의 Backbone에 의존하는 shimed 종속성의 경우 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbcb9f444492d4850b289deb7e4380b5fd3bb621" translate="yes" xml:space="preserve">
          <source>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a &lt;strong&gt;data-main&lt;/strong&gt; attribute is used, that path will become the baseUrl.</source>
          <target state="translated">구성에 baseUrl이 명시 적으로 설정되지 않은 경우 기본값은 require.js를로드하는 HTML 페이지의 위치입니다. 경우 &lt;strong&gt;데이터의 주요&lt;/strong&gt; 속성이 사용되며, 그 경로는 base을하게 될 것이다.</target>
        </trans-unit>
        <trans-unit id="6404b1494958d7d6e06d6a9ab163934604e724f9" translate="yes" xml:space="preserve">
          <source>If on Windows, you may need to type &lt;code&gt;r.js.cmd&lt;/code&gt; instead of &lt;code&gt;r.js&lt;/code&gt;. Or, you can use &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt;:</source>
          <target state="translated">Windows의 경우, 사용자가 입력해야 할 수도 있습니다 &lt;code&gt;r.js.cmd&lt;/code&gt; 대신 &lt;code&gt;r.js&lt;/code&gt; . 또는 &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0bdb3e25708d8f7e044c7d3710e40bb157c105e" translate="yes" xml:space="preserve">
          <source>If on Windows, you may need to type &lt;code&gt;r.js.cmd&lt;/code&gt; instead of &lt;code&gt;r.js&lt;/code&gt;. Or, you can use &lt;a href=&quot;https://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6e5ec8125377aee196b4157ae031deb5846f14" translate="yes" xml:space="preserve">
          <source>If part of a require() callback, all the dependencies need to be listed in the array:</source>
          <target state="translated">require () 콜백의 일부인 경우 모든 종속성이 배열에 나열되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5e11c69c8bd44c98ec1a92bd548444b902083a8f" translate="yes" xml:space="preserve">
          <source>If part of a shim config, make sure the shim config's exports check is correct.</source>
          <target state="translated">shim 구성의 일부인 경우 shim 구성의 내보내기 검사가 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0771fa68bc68f46c7cad59553f87fbed3015f4e1" translate="yes" xml:space="preserve">
          <source>If the &quot;store&quot; package did not follow the &quot;main.js&quot; convention, and looked more like this:</source>
          <target state="translated">&quot;store&quot;패키지가 &quot;main.js&quot;규칙을 따르지 않으면 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="726b8059a1d692c8212c0606dec6c706d075cc32" translate="yes" xml:space="preserve">
          <source>If the error message includes &lt;strong&gt;Use require([])&lt;/strong&gt;, then it was a top-level require call (not a require call inside a define() call) that should be using the async, callback version of require to load the code:</source>
          <target state="translated">오류 메시지에 &lt;strong&gt;use require ([])&lt;/strong&gt; 가 포함 된 경우, 코드를로드하기 위해 비동기 콜백 버전을 사용해야하는 최상위 레벨의 요구 호출 (define () 호출 내의 요구 호출이 아님)이었습니다.</target>
        </trans-unit>
        <trans-unit id="3da1558eec7d161ec9aeacf63f1947075ff1b3c4" translate="yes" xml:space="preserve">
          <source>If the module calls define(), make sure the define call was reached by debugging in a script debugger.</source>
          <target state="translated">모듈이 define ()을 호출하는 경우 스크립트 디버거에서 디버깅하여 define 호출에 도달했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d640768407ba7527782d61745268bcd8becf18d3" translate="yes" xml:space="preserve">
          <source>If the module does not have any dependencies, and it is just a collection of name/value pairs, then just pass an object literal to define():</source>
          <target state="translated">모듈에 종속성이없고 이름 / 값 쌍의 모음 일 경우 객체 리터럴을 define ()에 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c4bc89c20098e3d217c9feeee11e6aefa259ab00" translate="yes" xml:space="preserve">
          <source>If the module does not have dependencies, but needs to use a function to do some setup work, then define itself, pass a function to define():</source>
          <target state="translated">모듈에 의존성이 없지만 설정 작업을 수행하기 위해 함수를 사용해야하는 경우 자체 정의하고 define () 함수를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="dd2976ac338c8b322312501c44533eea743a2006" translate="yes" xml:space="preserve">
          <source>If the module has dependencies, the first argument should be an array of dependency names, and the second argument should be a definition function. The function will be called to define the module once all dependencies have loaded. The function should return an object that defines the module. The dependencies will be passed to the definition function as function arguments, listed in the same order as the order in the dependency array:</source>
          <target state="translated">모듈에 종속성이있는 경우 첫 번째 인수는 종속성 이름의 배열이어야하고 두 번째 인수는 정의 함수 여야합니다. 모든 종속성이로드되면 모듈을 정의하기 위해 함수가 호출됩니다. 함수는 모듈을 정의하는 객체를 반환해야합니다. 종속성은 종속성 배열의 순서와 동일한 순서로 나열된 함수 인수로 정의 함수에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="268886bdf3247e5fb6d83a42bdc3c1afdd1fc395" translate="yes" xml:space="preserve">
          <source>If the modules are laid out on disk like this:</source>
          <target state="translated">모듈이 다음과 같이 디스크에 배치 된 경우 :</target>
        </trans-unit>
        <trans-unit id="3c3a7a2d48579a3fd24b6373c3334acc93d4649e" translate="yes" xml:space="preserve">
          <source>If the problem is the &lt;code&gt;var define&lt;/code&gt; lint approach, use &lt;code&gt;/*global define */&lt;/code&gt; (no space before &quot;global&quot;) comment style instead.</source>
          <target state="translated">문제가 &lt;code&gt;var define&lt;/code&gt; lint 접근법 인 경우 &lt;code&gt;/*global define */&lt;/code&gt; ( &quot;global&quot;앞에 공백 없음) 주석 스타일을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe055917e1738e441340d4fd7a9ee5b263683ac9" translate="yes" xml:space="preserve">
          <source>If the problem is the use of loader plugins or anonymous modules but the RequireJS optimizer is not used for file bundling, use the RequireJS optimizer.</source>
          <target state="translated">로더 플러그인 또는 익명 모듈을 사용하는 데 문제가 있지만 RequireJS 최적화 프로그램이 파일 번들링에 사용되지 않는 경우 RequireJS 최적화 프로그램을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6afec34eee1181c090fdd3435b03454d82f91ced" translate="yes" xml:space="preserve">
          <source>If this was the paths config:</source>
          <target state="translated">이것이 경로 구성 인 경우 :</target>
        </trans-unit>
        <trans-unit id="3fe2042d352255fab2f771b63873d6c1d5d861d6" translate="yes" xml:space="preserve">
          <source>If we are creating a new script loader, we can do better.</source>
          <target state="translated">새 스크립트 로더를 작성하면 더 잘할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2471cbb8f701f4612ea9f0ec89dbe001ba98766" translate="yes" xml:space="preserve">
          <source>If you are familiar with CommonJS modules, you could instead use &lt;strong&gt;exports&lt;/strong&gt; to create an empty object for the module that is available immediately for reference by other modules. By doing this on both sides of a circular dependency, you can then safely hold on to the the other module. This only works if each module is exporting an object for the module value, not a function:</source>
          <target state="translated">CommonJS 모듈에 익숙한 경우 &lt;strong&gt;내보내기&lt;/strong&gt; 를 사용하여 다른 모듈에서 즉시 참조 할 수있는 모듈에 대한 빈 오브젝트를 작성할 수 있습니다. 순환 종속성의 양쪽에서이 작업을 수행하면 다른 모듈을 안전하게 유지할 수 있습니다. 이것은 각 모듈이 함수가 아닌 모듈 값에 대한 객체를 내보내는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e8ab978d23a4c5d930f4a73ffb4cdaedcb9db803" translate="yes" xml:space="preserve">
          <source>If you are having trouble with the examples below, here are some common pitfalls that might be the source of the problem:</source>
          <target state="translated">아래 예제에 문제가있는 경우 문제의 원인이 될 수있는 몇 가지 일반적인 함정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba0cad9bd089cab72f65d9b6da275ca2f8067cc2" translate="yes" xml:space="preserve">
          <source>If you are listing dependencies in the dependency array, make sure that &lt;strong&gt;require&lt;/strong&gt; and &lt;strong&gt;name&lt;/strong&gt; are in the dependency array:</source>
          <target state="translated">종속성 배열에 종속성을 나열하는 &lt;strong&gt;경우 require&lt;/strong&gt; 및 &lt;strong&gt;name&lt;/strong&gt; 이 종속성 배열에 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad022743a7df2ffdcd0557108ff5b38fd748951d" translate="yes" xml:space="preserve">
          <source>If you are using the simplified define wrapper, make sure you have &lt;strong&gt;require&lt;/strong&gt; as the first argument to the definition function:</source>
          <target state="translated">단순화 된 정의 랩퍼를 사용하는 경우 정의 함수에 대한 첫 번째 인수로 &lt;strong&gt;필요한지&lt;/strong&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e0ee4abad95938db6b89b46529ee3dc2e95d105" translate="yes" xml:space="preserve">
          <source>If you are using uglifyjs to minify the code, &lt;strong&gt;do not&lt;/strong&gt; set the uglify option &lt;code&gt;toplevel&lt;/code&gt; to true, or if using the command line &lt;strong&gt;do not&lt;/strong&gt; pass &lt;code&gt;-mt&lt;/code&gt;. That option mangles the global names that shim uses to find exports.</source>
          <target state="translated">uglifyjs를 사용하여 코드를 축소하는 경우 uglify 옵션 &lt;code&gt;toplevel&lt;/code&gt; 을 true로 설정 &lt;strong&gt;하지 않거나&lt;/strong&gt; 명령 행을 사용하여 &lt;code&gt;-mt&lt;/code&gt; 를 전달 &lt;strong&gt;하지 마십시오&lt;/strong&gt; . 이 옵션은 shim이 내보내기를 찾는 데 사용하는 전역 이름을 엉망으로 만듭니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="31e99de161473edbb5082258b810e3d2c3da191c" translate="yes" xml:space="preserve">
          <source>If you define a circular dependency (&quot;a&quot; needs &quot;b&quot; and &quot;b&quot; needs &quot;a&quot;), then in this case when &quot;b&quot;'s module function is called, it will get an undefined value for &quot;a&quot;. &quot;b&quot; can fetch &quot;a&quot; later after modules have been defined by using the require() method (be sure to specify require as a dependency so the right context is used to look up &quot;a&quot;):</source>
          <target state="translated">순환 종속성을 정의하면 ( &quot;a&quot;에는 &quot;b&quot;가 필요하고 &quot;b&quot;에는 &quot;a&quot;가 필요)이 경우 &quot;b&quot;의 모듈 함수가 호출되면 &quot;a&quot;에 대해 정의되지 않은 값이 표시됩니다. &quot;b&quot;는 require () 메소드를 사용하여 모듈을 정의한 후 나중에 &quot;a&quot;를 페치 할 수 있습니다 (요청을 종속성으로 지정하여 올바른 컨텍스트가 &quot;a&quot;를 찾는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="c60a6779241f198cb0b63a3cd7149ce07e1aae79" translate="yes" xml:space="preserve">
          <source>If you do not express the dependencies, you will likely get loading errors since RequireJS loads scripts asynchronously and out of order for speed.</source>
          <target state="translated">종속성을 표현하지 않으면 RequireJS가 스크립트를 비동기식으로로드하고 순서에 맞지 않아로드 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9663e162bea6d2fd2a76323abdb98db33154de78" translate="yes" xml:space="preserve">
          <source>If you do not want the main-build.js file minified, pass &lt;strong&gt;optimize=none&lt;/strong&gt; in the command above.</source>
          <target state="translated">main-build.js 파일을 축소하지 않으려면 위 명령에서 &lt;strong&gt;optimize = none&lt;/strong&gt; 을 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="001e6439bbf6aa885f14abd4880ee619763d737a" translate="yes" xml:space="preserve">
          <source>If you find you have a problem, and want to report it, use the &lt;a href=&quot;http://github.com/requirejs/r.js/issues&quot;&gt;r.js GitHub Issues page&lt;/a&gt;.</source>
          <target state="translated">문제가 있다고보고하고보고하려면 &lt;a href=&quot;http://github.com/requirejs/r.js/issues&quot;&gt;r.js GitHub 문제 페이지를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="84595edc012fcbdfa0cbccb569dfe1e9673c800c" translate="yes" xml:space="preserve">
          <source>If you find you have a problem, and want to report it, use the &lt;a href=&quot;https://github.com/requirejs/r.js/issues&quot;&gt;r.js GitHub Issues page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63d9b75d9f443bf6b7818c6648924354e9520f7" translate="yes" xml:space="preserve">
          <source>If you get an error with a requireModules, it probably means other modules that depend on the modules in that requireModules array are not defined.</source>
          <target state="translated">requireModules에 오류가 발생하면 requireModules 배열의 모듈에 의존하는 다른 모듈이 정의되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6de57f65ff4fa1cadce3b83f694a69d1b4133325" translate="yes" xml:space="preserve">
          <source>If you have many modules to convert, the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js project&lt;/a&gt; has a converter tool built into the r.js file. Give it the path to the directory you want to convert and an output directory:</source>
          <target state="translated">변환 할 모듈이 많은 경우 &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js 프로젝트&lt;/a&gt; 에는 r.js 파일에 변환기 도구가 내장되어 있습니다. 변환하려는 디렉토리의 경로와 출력 디렉토리를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="9620284a6bc32590c3169f3f4b48d289a07d4f27" translate="yes" xml:space="preserve">
          <source>If you have modules that are in the traditional CommonJS module format, then you can easily convert them to work with RequireJS. Not all modules will convert cleanly to the new format. Types of modules that may not convert well:</source>
          <target state="translated">일반적인 CommonJS 모듈 형식의 모듈이있는 경우 RequireJS에서 작동하도록 쉽게 변환 할 수 있습니다. 모든 모듈이 새로운 형식으로 완전히 변환되는 것은 아닙니다. 제대로 변환되지 않을 수있는 모듈 유형 :</target>
        </trans-unit>
        <trans-unit id="5a0f889c91ca5d1dd6ba34bf9e33e0c53924951a" translate="yes" xml:space="preserve">
          <source>If you just have a few modules to convert, then all you need to do is wrap the module in this code:</source>
          <target state="translated">변환 할 모듈이 몇 개인 경우 다음 코드로 모듈을 래핑하면됩니다.</target>
        </trans-unit>
        <trans-unit id="290bb6c87f9786e352e57820066a0d3e3282fb87" translate="yes" xml:space="preserve">
          <source>If you manually code a script tag in HTML to load a script that has a few named modules, but then try to load an anonymous module that ends up having the same name as one of the named modules in the script loaded by the manually coded script tag.</source>
          <target state="translated">이름이 지정된 몇 개의 모듈이있는 스크립트를로드하기 위해 HTML에서 스크립트 태그를 수동으로 코딩하지만 수동으로 코딩 된 스크립트에 의해로드 된 스크립트의 이름이 지정된 모듈 중 하나와 이름이 같은 익명 모듈을로드하려고 시도하는 경우 꼬리표.</target>
        </trans-unit>
        <trans-unit id="c79c7768de0828796b0344821b72ca7c31441ddb" translate="yes" xml:space="preserve">
          <source>If you manually code a script tag in HTML to load a script with an anonymous define() call, this error can occur.</source>
          <target state="translated">익명의 define () 호출로 스크립트를로드하기 위해 HTML로 스크립트 태그를 수동으로 코딩하면이 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e07cad218dbc58c61e09b42087ab5dc1921031f1" translate="yes" xml:space="preserve">
          <source>If you manually code an HTML script tag, be sure it only includes named modules, and that an anonymous module that will have the same name as one of the modules in that file is not loaded.</source>
          <target state="translated">HTML 스크립트 태그를 수동으로 코딩하는 경우 이름 지정된 모듈 만 포함하고 해당 파일의 모듈 중 하나와 이름이 같은 익명 모듈이로드되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="eec9ccbb226e68d2a8826329d0764fb9286f03a7" translate="yes" xml:space="preserve">
          <source>If you need to set a path like the &quot;core/jquery.tabs&quot; one, use a build.js file with the build options specified as a JavaScript object instead of using command line arguments.</source>
          <target state="translated">&quot;core / jquery.tabs&quot;와 같은 경로를 설정해야하는 경우 명령 행 인수 대신 JavaScript 오브젝트로 지정된 빌드 옵션과 함께 build.js 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe94189273fa0c665402c6a532f8ae2540a649a" translate="yes" xml:space="preserve">
          <source>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</source>
          <target state="translated">최상위 모듈에 루트 번들을 포함하지 않으려면 일반 로케일 번들과 같이 정의 할 수 있습니다. 이 경우 최상위 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea4e68f347851dad8c4c00882d4e80a08c8f8134" translate="yes" xml:space="preserve">
          <source>If you prefer to not use npm, you can get r.js directly:</source>
          <target state="translated">npm을 사용하지 않으려면 r.js를 직접 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f9d6c4000e170c67495235bbeaafa76bd8b494d" translate="yes" xml:space="preserve">
          <source>If you then also use &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;almond&lt;/a&gt; to build your code without require.js, be sure to use the &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L413&quot;&gt;insertRequire&lt;/a&gt; build setting to insert a require call for the main module -- that serves the same purpose of the initial require() call that data-main does.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;almond&lt;/a&gt; 를 사용하여 require.js없이 코드를 빌드하는 경우 &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L413&quot;&gt;insertRequire&lt;/a&gt; 빌드 설정 을 사용 하여 기본 모듈에 대한 요구 호출을 삽입하십시오. 이는 data-main의 초기 require () 호출과 동일한 목적을 제공합니다. 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="6d11834f478a454e47eae0e058c9489d1bdeb1ac" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;var define;&lt;/code&gt; at the top of your file for jshint/jslint purposes, this will cause a problem for the optimizer because it avoids parsing files that declare a &lt;code&gt;define&lt;/code&gt; variable, since that may indicate a script that was created by a concatenation of some scripts that use a local define.</source>
          <target state="translated">&lt;code&gt;var define;&lt;/code&gt; 을 사용하면 ; jshint / jslint 목적으로 파일의 맨 위에는 로컬 변수를 사용하는 일부 스크립트를 연결하여 작성된 스크립트를 나타낼 수 있으므로 &lt;code&gt;define&lt;/code&gt; 변수 를 선언하는 파일을 구문 분석하지 않기 때문에 최적화 프로그램에 문제가 발생합니다. 밝히다.</target>
        </trans-unit>
        <trans-unit id="ca847ebc0250cd99dec110fb3a5f58289151f4c3" translate="yes" xml:space="preserve">
          <source>If you use a similar project layout as specified in the &lt;a href=&quot;http://requirejs.org/docs/start.html&quot;&gt;Start Guide&lt;/a&gt;, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the &lt;strong&gt;scripts&lt;/strong&gt; directory as the top-level project directory):</source>
          <target state="translated">&lt;a href=&quot;http://requirejs.org/docs/start.html&quot;&gt;시작 안내서에&lt;/a&gt; 지정된 것과 유사한 프로젝트 레이아웃을 사용하는 경우 웹 프로젝트의 시작은 다음과 같습니다 (노드 / Rhino 기반 프로젝트는 유사합니다. &lt;strong&gt;스크립트&lt;/strong&gt; 디렉토리 의 내용을 최상위 프로젝트 디렉토리로 사용하십시오). ) :</target>
        </trans-unit>
        <trans-unit id="4c692604f116595f04f5b8bd5d70ca44b5c8af4b" translate="yes" xml:space="preserve">
          <source>If you use the loader plugins or anonymous modules (modules that call define() with no string ID) but do not use the RequireJS optimizer to combine files together, this error can occur. The optimizer knows how to name anonymous modules correctly so that they can be combined with other modules in an optimized file.</source>
          <target state="translated">로더 플러그인 또는 익명 모듈 (문자열 ID없이 define ()을 호출하는 모듈)을 사용하지만 RequireJS 최적화 프로그램을 사용하여 파일을 결합하지 않으면이 오류가 발생할 수 있습니다. 최적화 프로그램은 익명 모듈의 이름을 올바르게 지정하여 최적화 된 파일의 다른 모듈과 결합 할 수있는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb5637a3fb0c000cd062fa3f3d6df8b64fe1e07" translate="yes" xml:space="preserve">
          <source>If you want to &lt;b&gt;exclude&lt;/b&gt; that file from being included, and just need to map &quot;dependency&quot; for the build (otherwise it will not build), then use the special &quot;empty:&quot; paths config:</source>
          <target state="translated">당신이 원하는 경우 &lt;b&gt;제외&lt;/b&gt; 경로는 config (설정) :이 포함되는 파일 및 (그렇지 않으면 빌드하지 않습니다) 빌드은 &quot;의존성을&quot;지도하는 단지 필요, 다음 &quot;빈&quot;특별를 사용 :</target>
        </trans-unit>
        <trans-unit id="c4d84ae38cccd676fef602cccfe8d51ad757c1ac" translate="yes" xml:space="preserve">
          <source>If you want to code a module so that it works with RequireJS and in Node, without requiring users of your library in Node to use RequireJS, then you can use the &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; package to do this:</source>
          <target state="translated">Node의 라이브러리 사용자가 RequireJS를 사용하지 않아도 RequireJS 및 Node에서 작동하도록 모듈을 코딩하려면 &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; 패키지를 사용하여 다음을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af5b2645f618b5644bc791db1e0847039d902272" translate="yes" xml:space="preserve">
          <source>If you want to do &lt;code&gt;require()&lt;/code&gt; calls in the HTML page, then it is best to not use data-main. data-main is only intended for use when the page just has one main entry point, the data-main script. For pages that want to do inline &lt;code&gt;require()&lt;/code&gt; calls, it is best to nest those inside a &lt;code&gt;require()&lt;/code&gt; call for the configuration:</source>
          <target state="translated">HTML 페이지에서 &lt;code&gt;require()&lt;/code&gt; 호출 을 수행 하려면 data-main을 사용하지 않는 것이 가장 좋습니다. data-main은 페이지에 하나의 기본 진입 점 인 data-main 스크립트가있는 경우에만 사용하도록되어 있습니다. 인라인 &lt;code&gt;require()&lt;/code&gt; 호출 을 수행하려는 페이지의 경우 구성을 위해 &lt;code&gt;require()&lt;/code&gt; 호출 내에 페이지를 중첩시키는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e7664b7c0117630563d8b0ce1cf3190fcf1304bd" translate="yes" xml:space="preserve">
          <source>If you want to do more sophisticated dependency graph analysis for undefining work, the semi-private &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Internal-API:-onResourceLoad&quot;&gt;onResourceLoad API&lt;/a&gt; may be helpful.</source>
          <target state="translated">정의되지 않은 작업에 대해보다 정교한 종속성 그래프 분석을 수행하려는 경우 semi-private &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Internal-API:-onResourceLoad&quot;&gt;onResourceLoad API&lt;/a&gt; 가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="296789b3d29436db474fc5e4c49a54f6bfbe4190" translate="yes" xml:space="preserve">
          <source>If you want to include require.js with the main.js source, you can use this kind of command:</source>
          <target state="translated">main.js 소스에 require.js를 포함 시키려면 다음과 같은 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46ae1d084e30675108b6b0a3e880efee8585a650" translate="yes" xml:space="preserve">
          <source>If you want to include this dependency in the built/optimized file, download the JS file and in the build profile for the optimizer, put in a paths config that points to that local file.</source>
          <target state="translated">빌드 / 최적화 된 파일에이 종속성을 포함 시키려면 JS 파일과 옵티마이 저의 빌드 프로파일을 다운로드하여 해당 로컬 파일을 가리키는 경로 구성을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="3a65a8e36754343f29f91691e06b17764aa16a5d" translate="yes" xml:space="preserve">
          <source>If you want to install requirejs locally in a project as an npm package, instead of globally:</source>
          <target state="translated">글로벌이 아닌 npm 패키지로 프로젝트에 requirejs를 로컬로 설치하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="164b3d635a3f7c3d266ffda4373f5819b2582504" translate="yes" xml:space="preserve">
          <source>If you want to use AMD but still use the &lt;strong&gt;load one script at the bottom of the HTML page&lt;/strong&gt; approach:</source>
          <target state="translated">AMD를 사용하고 싶지만 &lt;strong&gt;HTML 페이지&lt;/strong&gt; 접근 방식 &lt;strong&gt;의 맨 아래에 하나의 스크립트로드&lt;/strong&gt; 를 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="977e480d5d183fc7ba40346f208e1b484206ed16" translate="yes" xml:space="preserve">
          <source>If you want to use RequireJS directly to code your module, and then export a module value to node so that it can be used in other Node programs without requiring that app to use RequireJS, you can use the approach listed in the next example.</source>
          <target state="translated">RequireJS를 사용하여 모듈을 직접 코딩 한 다음 해당 앱이 RequireJS를 사용하지 않아도 다른 Node 프로그램에서 사용할 수 있도록 모듈 값을 노드로 내보내려면 다음 예제에 나열된 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f7cb349eb5ac9e5b57bf37db65dc198540d53a6" translate="yes" xml:space="preserve">
          <source>If you want to use define() for your modules but still run them in Node without needing to run RequireJS on the server, see &lt;a href=&quot;#nodeModules&quot;&gt;the section below&lt;/a&gt; about using &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt;.</source>
          <target state="translated">당신이 당신의 모듈 ()를 정의 사용하지만 여전히 서버에 RequireJS를 실행하지 않고도 노드에서이를 실행하려면, 참조 &lt;a href=&quot;#nodeModules&quot;&gt;아래 섹션을&lt;/a&gt; 사용하는 방법에 대한 &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cedb40532461d188e89d12caa7374f46648787e1" translate="yes" xml:space="preserve">
          <source>If you want to wrap your built file so it can be used in pages that do not have an AMD loader like RequireJS, see the &lt;a href=&quot;http://requirejs.org/docs/faq-optimization.html&quot;&gt;Optimization FAQ&lt;/a&gt;.</source>
          <target state="translated">빌드 된 파일을 랩핑하여 RequireJS와 같은 AMD 로더가없는 페이지에서 사용할 수 있도록하려면 &lt;a href=&quot;http://requirejs.org/docs/faq-optimization.html&quot;&gt;최적화 FAQ를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f758dc21534ccb9894490766f0bb0a3354e675a0" translate="yes" xml:space="preserve">
          <source>If you wish to reuse some code that was written in the traditional &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;CommonJS module format&lt;/a&gt; it may be difficult to re-work to the array of dependencies used above, and you may prefer to have direct alignment of dependency name to the local variable used for that dependency. You can use the &lt;a href=&quot;commonjs&quot;&gt;simplified CommonJS wrapper&lt;/a&gt; for those cases:</source>
          <target state="translated">일반적인 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;CommonJS 모듈 형식&lt;/a&gt; 으로 작성된 일부 코드를 재사용하려면 위에서 사용 된 종속성 배열로 재 작업하기가 어려울 수 있으며 종속성 이름을 해당 로컬 변수에 직접 정렬하는 것이 좋습니다. 의존. 이러한 경우 &lt;a href=&quot;commonjs&quot;&gt;단순화 된 CommonJS 랩퍼&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bbc88d8b7d0dba0bef2316c81d3257b395c963e" translate="yes" xml:space="preserve">
          <source>If your build profile looked like so:</source>
          <target state="translated">빌드 프로파일이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="fa7030a64e81de81778033ae09c733651717e7a7" translate="yes" xml:space="preserve">
          <source>If your code uses tests like the following:</source>
          <target state="translated">코드에서 다음과 같은 테스트를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="33134584d1a1bacbf328e47b02d9ac4ab14c6c31" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;the AMD API&lt;/a&gt;. There is &lt;a href=&quot;https://groups.google.com/group/amd-implement&quot;&gt;a discussion list&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-tests&quot;&gt;compatibility tests&lt;/a&gt;. By implementing AMD, you will reduce multi-module system boilerplate and help prove out a workable JavaScript module system on the web. This can be fed back into the ECMAScript process to build better native module support.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD API를&lt;/a&gt; 구현 하십시오 . 이 &lt;a href=&quot;https://groups.google.com/group/amd-implement&quot;&gt;토론 목록&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/amdjs/amdjs-tests&quot;&gt;호환성 테스트&lt;/a&gt; . AMD를 구현하면 다중 모듈 시스템 상용구를 줄이고 웹에서 작동 가능한 JavaScript 모듈 시스템을 증명할 수 있습니다. 이는 더 나은 기본 모듈 지원을 구축하기 위해 ECMAScript 프로세스로 피드백 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="702c01eb821162396b5526b3e65d64751b303b3b" translate="yes" xml:space="preserve">
          <source>In Firefox and WebKit browsers, a line number and file name will be indicated in the error. It can be used to locate the source of the problem. Better isolation of the error can be done by using a debugger to place a breakpoint in the file that contains the error.</source>
          <target state="translated">Firefox 및 WebKit 브라우저에서 줄 번호와 파일 이름이 오류에 표시됩니다. 문제의 원인을 찾는 데 사용할 수 있습니다. 디버거를 사용하여 오류가 포함 된 파일에 중단 점을 배치하면 오류를보다 효과적으로 격리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ff0f55e14256af8eb245096429abdcc074495ed5" translate="yes" xml:space="preserve">
          <source>In RequireJS 2.0.*, the &quot;exports&quot; property in the shim config could have been a function instead of a string. In that case, it functioned the same as the &quot;init&quot; property as shown above. The &quot;init&quot; pattern is used in RequireJS 2.1.0+ so a string value for &lt;code&gt;exports&lt;/code&gt; can be used for &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;, but then allow functional work once the library is known to have loaded.</source>
          <target state="translated">RequireJS 2.0. *에서 shim 구성의 &quot;exports&quot;특성은 문자열 대신 함수일 수 있습니다. 이 경우 위에 표시된 &quot;init&quot;속성과 동일한 기능을 수행했습니다. 은 &quot;초기화하기&quot;패턴의 문자열 값 때문에 2.1.0 RequireJS에 사용되는 &lt;code&gt;exports&lt;/code&gt; 사용할 수 있습니다 &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt; ,하지만 라이브러리가로드 한 것으로 알려져 일단 기능적인 작업을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecc029984d4c8bb1667c1c77461dda09354dda68" translate="yes" xml:space="preserve">
          <source>In general though, it is best to use the baseUrl and &quot;paths&quot; config to set paths for module IDs. By doing so, it gives you more flexibility in renaming and configuring the paths to different locations for optimization builds.</source>
          <target state="translated">일반적으로 baseUrl 및 &quot;paths&quot;구성을 사용하여 모듈 ID의 경로를 설정하는 것이 가장 좋습니다. 이렇게하면 최적화 빌드를 위해 다른 위치로 경로 이름을 바꾸고 구성 할 때 유연성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="9a0fe9ee95c542b2027e2cf755a45d2afa25ff6e" translate="yes" xml:space="preserve">
          <source>In general, if it is a path, it is relative to the build.js file used to hold the build options, or if just using command line arguments, relative to the current working directory. Example of properties that are file paths: &lt;strong&gt;appDir&lt;/strong&gt;, &lt;strong&gt;dir&lt;/strong&gt;, &lt;strong&gt;mainConfigFile&lt;/strong&gt;, &lt;strong&gt;out&lt;/strong&gt;, &lt;strong&gt;wrap.startFile&lt;/strong&gt;, &lt;strong&gt;wrap.endFile&lt;/strong&gt;.</source>
          <target state="translated">일반적으로 경로 인 경우 빌드 옵션을 보유하는 데 사용되는 build.js 파일 또는 명령 행 인수를 사용하는 경우 현재 작업 디렉토리와 관련이 있습니다. : 파일 경로있는 속성의 예 &lt;strong&gt;APPDIR&lt;/strong&gt; , &lt;strong&gt;디렉토리&lt;/strong&gt; , &lt;strong&gt;mainConfigFile&lt;/strong&gt; , &lt;strong&gt;밖으로&lt;/strong&gt; , &lt;strong&gt;wrap.startFile&lt;/strong&gt; , &lt;strong&gt;wrap.endFile&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe96d7fff0f912ef23ce1a903bec59c1e061054" translate="yes" xml:space="preserve">
          <source>In particular, &lt;strong&gt;the following will not work&lt;/strong&gt;:</source>
          <target state="translated">특히 &lt;strong&gt;다음은 작동하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f35ef7f938973ce790f5493a620318e22603f51d" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;modules&lt;/strong&gt; array, specify the module names that you want to optimize, in the example, &quot;main&quot;. &quot;main&quot; will be mapped to &lt;strong&gt;appdirectory/scripts/main.js&lt;/strong&gt; in your project. The build system will then trace the dependencies for main.js and inject them into the &lt;strong&gt;appdirectory-build/scripts/main.js&lt;/strong&gt; file.</source>
          <target state="translated">에서 &lt;strong&gt;모듈&lt;/strong&gt; 배열, 당신은, &quot;주&quot;의 예에서, 최적화에 원하는 모듈 이름을 지정합니다. &quot;main&quot;은 프로젝트의 &lt;strong&gt;appdirectory / scripts / main.js&lt;/strong&gt; 에 매핑됩니다 . 그런 다음 빌드 시스템은 main.js의 종속성을 추적하여 &lt;strong&gt;appdirectory-build / scripts / main.js&lt;/strong&gt; 파일에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="104b91c1bd0b54f7e9b0f9f56f1480a81283afad" translate="yes" xml:space="preserve">
          <source>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</source>
          <target state="translated">나중에이 코드는 호스트 환경에 따라 올바른로드 동작을 얻기 위해 env에로드 할 수있는 선택적 모듈로 require / 디렉토리에 풀릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff2906dc76505cca03806c98590fb6c7fb3e8b67" translate="yes" xml:space="preserve">
          <source>In the r.js optimizer, &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; works as a pre- and post-processing step on a JS file. Various kinds of license comments are found, pulled out of the JS source, then that modified source is passed to the minifier. When the minifier is done, the comments are added to the top of the file by the r.js optimizer.</source>
          <target state="translated">r.js 최적화 프로그램에서 &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; 는 JS 파일에서 사전 처리 및 사후 처리 단계로 작동합니다. JS 소스에서 다양한 종류의 라이센스 주석이 발견되고 수정 된 소스가 축소기에 전달됩니다. 축소 기가 완료되면 주석이 r.js 최적화 프로그램에 의해 파일 맨 위에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd30abf3900baa5cd5ba9bf23def7c8f59c6f6c1" translate="yes" xml:space="preserve">
          <source>In this case, the normalized names the './a', './b', and './c' will be determined relative to the module asking for this resource. Since RequireJS does not know how to inspect the 'index!2?./a:./b:./c' to normalize the names for './a', './b', and './c', it needs to ask the plugin. This is the purpose of the normalize call.</source>
          <target state="translated">이 경우 정규화 된 이름 './a', './b'및 './c'는이 리소스를 요청하는 모듈에 따라 결정됩니다. RequireJS는 '.! / a', './b'및 './c'의 이름을 정규화하기 위해 'index! 2? ./ a : ./ b : ./ c'를 검사하는 방법을 모르기 때문에 플러그인을 요청해야합니다. 이것이 정규화 통화의 목적입니다.</target>
        </trans-unit>
        <trans-unit id="af3920b5a279ff0e144ef6675ba1d61fbdb25e91" translate="yes" xml:space="preserve">
          <source>In this example, a my/shirt module is created. It depends on my/cart and my/inventory. On disk, the files are structured like this:</source>
          <target state="translated">이 예에서는 my / shirt 모듈이 작성됩니다. 내 / 장바구니와 내 / 인벤토리에 따라 다릅니다. 디스크에서 파일은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="55e27a4c9226afbe32b577671abb7f2cbde38000" translate="yes" xml:space="preserve">
          <source>In version 1.0.5+ of the optimizer, the &lt;strong&gt;&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L27&quot;&gt;mainConfigFile&lt;/a&gt;&lt;/strong&gt; option can be used to specify the location of the runtime config. If specified with the path to your main JS file, the first &lt;code&gt;requirejs({}), requirejs.config({}), require({}), or require.config({})&lt;/code&gt; found in that file will be parsed out and used as part of the configuration options passed to the optimizer:</source>
          <target state="translated">옵티 마이저 버전 1.0.5 이상에서 &lt;strong&gt;&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L27&quot;&gt;mainConfigFile&lt;/a&gt;&lt;/strong&gt; 옵션을 사용하여 런타임 구성 위치를 지정할 수 있습니다. 기본 JS 파일의 경로로 지정된 경우 해당 파일에있는 첫 번째 &lt;code&gt;requirejs({}), requirejs.config({}), require({}), or require.config({})&lt;/code&gt; 가 구문 분석되고 옵티 마이저에 전달 된 구성 옵션의 일부로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="677c97dead3af89beaae180f2b05fb0885038810" translate="yes" xml:space="preserve">
          <source>In your main.js file, create a paths config that gives the script a module name. This can be done even if the script does not define a module via a call to define(). paths config are just used to map short module/script IDs to an URL. This allows you to use a different paths config for the optimization. In main.js:</source>
          <target state="translated">main.js 파일에서 스크립트에 모듈 이름을 제공하는 경로 구성을 작성하십시오. 스크립트가 define () 호출을 통해 모듈을 정의하지 않더라도이 작업을 수행 할 수 있습니다. paths 설정은 짧은 모듈 / 스크립트 ID를 URL에 매핑하는 데 사용됩니다. 이를 통해 최적화를 위해 다른 경로 구성을 사용할 수 있습니다. main.js에서 :</target>
        </trans-unit>
        <trans-unit id="a4f447bcdd3ea14912a0ab5851ae0c9a896b9bc5" translate="yes" xml:space="preserve">
          <source>Instead of using require() to get dependencies inside the function passed to define(), you can also specify them via a dependency array argument to define(). The order of the names in the dependency array match the order of arguments passed to the definition function passed to define(). So the above example that uses the module &lt;strong&gt;foo&lt;/strong&gt;:</source>
          <target state="translated">define ()에 전달 된 함수 내에서 require ()를 사용하여 의존성을 얻는 대신, dependencies 배열 인수를 통해 define ()에 의존성을 지정할 수도 있습니다. 종속성 배열의 이름 순서는 define ()에 전달 된 정의 함수에 전달 된 인수의 순서와 일치합니다. 따라서 &lt;strong&gt;foo&lt;/strong&gt; 모듈을 사용하는 위 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7fcc07e4da729e4b4e9fcc19ccbda6fd0e667335" translate="yes" xml:space="preserve">
          <source>Integration with has.js</source>
          <target state="translated">has.js와 통합</target>
        </trans-unit>
        <trans-unit id="1f8eb79c06f41e4c3eb114f2a67df248c0294380" translate="yes" xml:space="preserve">
          <source>Internet Explorer has a set of problems that make it difficult to detect load failures for errbacks/paths fallbacks:</source>
          <target state="translated">Internet Explorer에는 오류 / 경로 폴 백의로드 실패를 감지하기 어려운 일련의 문제점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="4ab560f11406cd0e8a158f69d8a4cedb4f432af2" translate="yes" xml:space="preserve">
          <source>Invalid require call</source>
          <target state="translated">잘못된 전화 요청</target>
        </trans-unit>
        <trans-unit id="37b0ca0680cdcc950b168ac80a44a59f649d995a" translate="yes" xml:space="preserve">
          <source>It also meant they placed more of a burden on web developers to implement the format, and the stop-gap measures meant debugging was worse. eval-based debugging or debugging multiple files that are concatenated into one file have practical weaknesses. Those weaknesses may be addressed in browser tooling at some point in the future, but the end result: using CommonJS modules in the most common of JS environments, the browser, is non-optimal today.</source>
          <target state="translated">또한 웹 개발자가 형식을 구현하는 데 더 많은 부담을 주었고, 갭 갭 측정은 디버깅이 더 나빴 음을 의미했습니다. 하나의 파일로 연결된 여러 파일을 eval 기반 디버깅 또는 디버깅하면 실질적인 약점이 있습니다. 이러한 취약점은 향후 어느 시점에서 브라우저 툴링에서 해결 될 수 있지만, 최종 결과 : 가장 일반적인 JS 환경에서 CommonJS 모듈을 사용하는 브라우저는 오늘날 최적이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="06871a3ab0f9615b1d6fab6eac51a26791195668" translate="yes" xml:space="preserve">
          <source>It differs from the normal CommonJS syntax out of necessity to work well in the browser. There have been suggestions that the normal CommonJS syntax could be used with head.appendChild(script) type of loading if a server process transforms the modules to a transport format that has a function wrapper.</source>
          <target state="translated">브라우저에서 제대로 작동해야한다는 점에서 일반적인 CommonJS 구문과 다릅니다. 서버 프로세스가 모듈을 함수 랩퍼가있는 전송 형식으로 변환하는 경우 일반 CommonJS 구문을 head.appendChild (script) 유형의로드와 함께 사용할 수 있다는 제안이있었습니다.</target>
        </trans-unit>
        <trans-unit id="5ffe27ee87a8206f32325462d1728096ff92ef70" translate="yes" xml:space="preserve">
          <source>It does not have strong cross browser support</source>
          <target state="translated">강력한 크로스 브라우저 지원이 없습니다.</target>
        </trans-unit>
        <trans-unit id="74a4bb6d4f0f076d77e09d55731eb64159c9e44d" translate="yes" xml:space="preserve">
          <source>It is a message-passing API, and the scripts likely want to interact with the DOM, so it means just using the worker to fetch the script text, but pass the text back to the main window then use eval/script with text body to execute the script. This has all of the problems as XHR mentioned above.</source>
          <target state="translated">그것은 메시지 전달 API이며 스크립트는 DOM과 상호 작용하기를 원할 것이므로 작업자를 사용하여 스크립트 텍스트를 가져 오지만 텍스트를 기본 창으로 다시 전달한 다음 텍스트 본문이있는 eval / script를 사용합니다. 스크립트를 실행하십시오. 이것은 위에서 언급 한 XHR과 같은 모든 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="933995d016ad7a4c199042da83eaec5d3cd9dac5" translate="yes" xml:space="preserve">
          <source>It is an improvement over CommonJS modules because:</source>
          <target state="translated">CommonJS 모듈에 비해 다음과 같은 이유로 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="730c4225b2d0d3fb0671ef8fe3e3739ed1d33110" translate="yes" xml:space="preserve">
          <source>It is an improvement over the web's current &quot;globals and script tags&quot; because:</source>
          <target state="translated">다음과 같은 이유로 웹의 현재 &quot;글로벌 및 스크립트 태그&quot;에 비해 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="e91de952b822a7b9e601878fa68d2f21c35e3658" translate="yes" xml:space="preserve">
          <source>It is best if there is an &lt;strong&gt;&quot;opt-in&quot; call&lt;/strong&gt; that can be done so that older JS code can participate in the new system.</source>
          <target state="translated">오래된 JS 코드가 새로운 시스템에 참여할 수 있도록 &lt;strong&gt;&quot;opt-in&quot;호출&lt;/strong&gt; 이있는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5366afdcae21e6c4f1d44ccd61b7c663f948c522" translate="yes" xml:space="preserve">
          <source>It is best to set the baseUrl specifically to the directory containing the module, so that it works properly when nested inside a node_modules heirarchy. Use the synchronous &lt;code&gt;requirejs('moduleId')&lt;/code&gt; to fetch the module using the config and rules in requirejs, then use Node's module.exports to export your module value:</source>
          <target state="translated">baseUrl을 구체적으로 모듈을 포함하는 디렉토리로 설정하는 것이 가장 좋으므로 node_modules 계층 구조 내에 중첩 될 때 제대로 작동합니다. 동기 &lt;code&gt;requirejs('moduleId')&lt;/code&gt; 를 사용하여 requirejs의 구성 및 규칙을 사용하여 모듈을 페치 한 후 Node의 module.exports를 사용하여 모듈 값을 내보내십시오.</target>
        </trans-unit>
        <trans-unit id="36bb237f110735ba5fbb00d5eb1f96f64c6d37d5" translate="yes" xml:space="preserve">
          <source>It is harder to debug. Firebug and WebKit's inspector have an //@ sourceURL= convention, which helps give a name to evaled text, but this support is not universal across browsers.</source>
          <target state="translated">디버깅하기가 더 어렵습니다. Firebug와 WebKit의 인스펙터는 // @ sourceURL = 규칙을 사용하여 텍스트에 이름을 지정하는 데 도움이되지만이 지원은 브라우저에서 보편적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c87d9d9b05b11c9ab9a66ebf5b60f1a510690bd" translate="yes" xml:space="preserve">
          <source>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</source>
          <target state="translated">스크립트에서 DOM 구조를 작성하는 대신 일반 HTML 태그를 사용하여 HTML을 작성하는 것이 좋습니다. 그러나 JavaScript 파일에 HTML을 포함시키는 좋은 방법은 없습니다. 가능한 최선의 방법은 HTML 문자열을 사용하는 것이지만 특히 여러 줄 HTML의 경우 관리하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d949986f91111b463d2e6c0b5b7a550aa5302d7b" translate="yes" xml:space="preserve">
          <source>It is possible when using RequireJS to load scripts quickly enough that they complete before the DOM is ready. Any work that tries to interact with the DOM should wait for the DOM to be ready. For modern browsers, this is done by waiting for the DOMContentLoaded event.</source>
          <target state="translated">RequireJS를 사용하여 DOM이 준비되기 전에 완료 할 수있을 정도로 빠르게 스크립트를로드 할 수 있습니다. DOM과 상호 작용하려는 모든 작업은 DOM이 준비 될 때까지 기다려야합니다. 최신 브라우저의 경우 DOMContentLoaded 이벤트를 기다리면됩니다.</target>
        </trans-unit>
        <trans-unit id="539c0da90c417fc4465e8833119b2d4679e2ab07" translate="yes" xml:space="preserve">
          <source>It is tempting to use XMLHttpRequest (XHR) to load the scripts. If XHR is used, then we can massage the text above -- we can do a regexp to find require() calls, make sure we load those scripts, then use eval() or script elements that have their body text set to the text of the script loaded via XHR.</source>
          <target state="translated">XMLHttpRequest (XHR)를 사용하여 스크립트를로드하려고합니다. XHR을 사용하는 경우 위의 텍스트를 마사지 할 수 있습니다. regexp를 수행하여 require () 호출을 찾아서 해당 스크립트를로드했는지 확인한 다음 본문을 텍스트로 설정 한 eval () 또는 스크립트 요소를 사용할 수 있습니다 XHR을 통해로드 된 스크립트</target>
        </trans-unit>
        <trans-unit id="a5b8151a598bcb30cf8bfca9d33d4425d2cd203c" translate="yes" xml:space="preserve">
          <source>It makes debugging weird, line numbers will be off vs. the source file since the server is injecting a function wrapper.</source>
          <target state="translated">서버가 함수 래퍼를 주입하고 있기 때문에 디버깅이 이상하고 라인 번호가 소스 파일과 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d0cde0ae490de0408250a7f5a89a70bf23c8332" translate="yes" xml:space="preserve">
          <source>It requires extra tooling to substitute a set of script tags into one tag for optimized deployment.</source>
          <target state="translated">최적화 된 배포를 위해 일련의 스크립트 태그를 하나의 태그로 대체하려면 추가 도구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="aaa2ddf75cd4a6f214f39c8e40c3d4e378c489b4" translate="yes" xml:space="preserve">
          <source>It requires more gear. Front-end development should be possible with static files.</source>
          <target state="translated">더 많은 장비가 필요합니다. 정적 파일을 사용하여 프런트 엔드 개발이 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="b532c07e09af6445d4a57ec51df56d53e00a8d20" translate="yes" xml:space="preserve">
          <source>It will also optimize any CSS files it finds inside &lt;strong&gt;appdirectory-build&lt;/strong&gt;.</source>
          <target state="translated">또한 &lt;strong&gt;appdirectory-build에서&lt;/strong&gt; 찾은 모든 CSS 파일을 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="1450cad84f11fb851a995a9dbe7cbd1a83b48017" translate="yes" xml:space="preserve">
          <source>It will not work, since jQuery registers itself with the name of 'jquery' and not 'lib/jquery'. In general, explicitly naming modules in the define() call are discouraged, but &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Updating-existing-libraries#anon&quot;&gt;jQuery has some special constraints&lt;/a&gt;.</source>
          <target state="translated">jQuery는 'lib / jquery'가 아닌 'jquery'라는 이름으로 자체 등록되므로 작동하지 않습니다. 일반적으로 define () 호출에서 명시 적으로 이름 지정 모듈을 사용하지 않는 것이 좋지만 &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Updating-existing-libraries#anon&quot;&gt;jQuery에는 몇 가지 특별한 제약이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f07795f631a52c810ff74f35c0a35b8c0ee082f" translate="yes" xml:space="preserve">
          <source>It works better in the browser, it has the least amount of gotchas. Other approaches have problems with debugging, cross-domain/CDN usage, file:// usage and the need for server-specific tooling.</source>
          <target state="translated">브라우저에서 더 잘 작동하며 문제가 가장 적습니다. 다른 접근 방식에는 디버깅, 도메인 간 / CDN 사용량, file : // 사용량 및 서버 별 툴링에 대한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f95e6bcde84bb0ea04bd5f126835d355217e942" translate="yes" xml:space="preserve">
          <source>LABjs: $LAB.script(&quot;some/module.js&quot;)</source>
          <target state="translated">LABjs : $ LAB.script ( &quot;some / module.js&quot;)</target>
        </trans-unit>
        <trans-unit id="ae0daafd2a22a2600ed4ab6dde4b770824eeb963" translate="yes" xml:space="preserve">
          <source>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</source>
          <target state="translated">나중에 파일에 특정 번역을 추가하려면 fr-fr 로케일과 같이 my / nls / colors를 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="a52b393d001eaf90fba4046093ec0e36ce9f892a" translate="yes" xml:space="preserve">
          <source>Latest Release: &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;2.3.5&lt;/a&gt;Open source: &lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/LICENSE&quot;&gt;new BSD or MIT licensed&lt;/a&gt;web design by &lt;a href=&quot;http://andychung.me/&quot;&gt;Andy Chung&lt;/a&gt; &amp;copy; 2011-2017</source>
          <target state="translated">최신 릴리스 : &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;2.3.5&lt;/a&gt; 오픈 소스 : &lt;a href=&quot;http://andychung.me/&quot;&gt;Andy Chung의 &lt;/a&gt;&lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/LICENSE&quot;&gt;새로운 BSD 또는 MIT 라이센스&lt;/a&gt; 웹 디자인 &amp;copy; 2011-2017</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="00849ea91859e8877efb5045590add6b11f850ad" translate="yes" xml:space="preserve">
          <source>Likely causes and fixes:</source>
          <target state="translated">가능한 원인 및 수정 사항 :</target>
        </trans-unit>
        <trans-unit id="f3c97333b24770acd81169479f77c402aa695485" translate="yes" xml:space="preserve">
          <source>Load JavaScript Files</source>
          <target state="translated">자바 스크립트 파일로드</target>
        </trans-unit>
        <trans-unit id="847b5a6fad771caed85029fc26f6dc8da0260706" translate="yes" xml:space="preserve">
          <source>Load timeout for modules: ...</source>
          <target state="translated">모듈의로드 타임 아웃 : ...</target>
        </trans-unit>
        <trans-unit id="f4ff6c36d65b86d4c62b59ce106dc00b3d1a41cb" translate="yes" xml:space="preserve">
          <source>Loader Plugins</source>
          <target state="translated">로더 플러그인</target>
        </trans-unit>
        <trans-unit id="b59783ddfeed5ace1aad0bc81fef1a12a200e068" translate="yes" xml:space="preserve">
          <source>Loader plugins are just another module, but they implement a specific API. Loader plugins can also participate in the optimizer optimizations, allowing the resources they load to be inlined in an optimized build.</source>
          <target state="translated">로더 플러그인은 다른 모듈 일 뿐이지 만 특정 API를 구현합니다. 로더 플러그인은 최적화 프로그램 최적화에 참여하여로드 된 자원을 최적화 된 빌드에 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb74610ba82fc6a40764893dfb647bab016b939f" translate="yes" xml:space="preserve">
          <source>Loading Code After Page Load</source>
          <target state="translated">페이지로드 후 코드로드</target>
        </trans-unit>
        <trans-unit id="97455076de06f78a61344dec31b7d67a23e3d804" translate="yes" xml:space="preserve">
          <source>Loading Modules from CommonJS Packages</source>
          <target state="translated">CommonJS 패키지에서 모듈로드</target>
        </trans-unit>
        <trans-unit id="41818361eaa130c5f3db544fd1f348f224b034fa" translate="yes" xml:space="preserve">
          <source>Loading Modules from Packages</source>
          <target state="translated">패키지에서 모듈로드</target>
        </trans-unit>
        <trans-unit id="cae51c36493d810a681b4c1e453b557e06e4c4c2" translate="yes" xml:space="preserve">
          <source>Make sure you reference the network dependency as a module name, not as a full URL, so that it can be mapped to a different during the build:</source>
          <target state="translated">네트워크 종속성을 전체 URL이 아닌 모듈 이름으로 참조하여 빌드 중에 다른 것으로 맵핑 될 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="72fdd266ec722bc44dd8a620ed1d7614b77d8c0f" translate="yes" xml:space="preserve">
          <source>Manual Conversion</source>
          <target state="translated">수동 변환</target>
        </trans-unit>
        <trans-unit id="fc64c3825f362079a2271f22c7bab206e4b4ae90" translate="yes" xml:space="preserve">
          <source>Mapping Modules to use noConflict</source>
          <target state="translated">noConflict를 사용하기위한 매핑 모듈</target>
        </trans-unit>
        <trans-unit id="dc8cade7e5207678dc6256df2ecc9deb710e940d" translate="yes" xml:space="preserve">
          <source>Means that for any module except &quot;some/oldmodule&quot;, when &quot;foo&quot; is wanted, use &quot;foo1.2&quot; instead. For &quot;some/oldmodule&quot; only, use &quot;foo1.0&quot; when it asks for &quot;foo&quot;.</source>
          <target state="translated">&quot;some / oldmodule&quot;을 제외한 모든 모듈에 대해 &quot;foo&quot;를 원할 경우 &quot;foo1.2&quot;를 대신 사용하십시오. &quot;일부 / 이전 모듈&quot;의 경우에만 &quot;foo&quot;를 요청할 때 &quot;foo1.0&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d4a20ddcf46cb8976dc06ca7169ae206a255437c" translate="yes" xml:space="preserve">
          <source>Mechanics</source>
          <target state="translated">Mechanics</target>
        </trans-unit>
        <trans-unit id="01de199a77285acc2ed16e687ed574c8aaa94327" translate="yes" xml:space="preserve">
          <source>Mismatched anonymous define() modules ...</source>
          <target state="translated">일치하지 않는 익명의 define () 모듈 ...</target>
        </trans-unit>
        <trans-unit id="5d61c868611adf27496376e30ad6452373f98872" translate="yes" xml:space="preserve">
          <source>Module Definition</source>
          <target state="translated">모듈 정의</target>
        </trans-unit>
        <trans-unit id="4228b7603e50200006c8e380e2c2979ffdb82200" translate="yes" xml:space="preserve">
          <source>Module Name</source>
          <target state="translated">모듈 이름</target>
        </trans-unit>
        <trans-unit id="b73dbb3306e34de2871a62a55e786bcc07ac414a" translate="yes" xml:space="preserve">
          <source>Module Purposes</source>
          <target state="translated">모듈 목적</target>
        </trans-unit>
        <trans-unit id="f809bcc9566a363f7ba0c49a6077c47d41c5354c" translate="yes" xml:space="preserve">
          <source>Module name ... has not been loaded yet for context: ...</source>
          <target state="translated">모듈 이름 ... 컨텍스트에 대해 아직로드되지 않았습니다 : ...</target>
        </trans-unit>
        <trans-unit id="1fceef3854242773f4046d420328f2e959bc28e6" translate="yes" xml:space="preserve">
          <source>Modules do not have to return objects. Any valid return value from a function is allowed. Here is a module that returns a function as its module definition:</source>
          <target state="translated">모듈은 객체를 반환 할 필요가 없습니다. 함수의 모든 유효한 반환 값이 허용됩니다. 다음은 함수를 모듈 정의로 반환하는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="d57cb3f463693d791c21a168e01d847f563c16b7" translate="yes" xml:space="preserve">
          <source>Modules in CommonJS packages can be loaded by RequireJS by setting up the RequireJS configuration to know about the location and package attributes. See the &lt;a href=&quot;api#packages&quot;&gt;packages API section&lt;/a&gt; for more information.</source>
          <target state="translated">CommonJS 패키지의 모듈은 위치 및 패키지 속성에 대해 알 수 있도록 RequireJS 구성을 설정하여 RequireJS에서로드 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;api#packages&quot;&gt;패키지 API 섹션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="320708dab0d8587885e54e25dc4ae497a36bacab" translate="yes" xml:space="preserve">
          <source>Modules that define globals are explicitly discouraged, so that multiple versions of a module can exist in a page at a time (see &lt;strong&gt;Advanced Usage&lt;/strong&gt;). Also, the order of the function arguments should match the order of the dependencies.</source>
          <target state="translated">전역을 정의하는 모듈은 명시 적으로 권장하지 않으므로 한 번에 한 페이지에 여러 버전의 모듈이 존재할 수 있습니다 ( &lt;strong&gt;고급 사용&lt;/strong&gt; 참조 ). 또한 함수 인수의 순서는 종속성의 순서와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="572cadc3a302f83a4dbd3c2a7cb42701a0b31b23" translate="yes" xml:space="preserve">
          <source>Modules that use conditional code to do a require call, like if(someCondition) require('a1') else require('a2');</source>
          <target state="translated">if (someCondition) require ( 'a1') else require ( 'a2')와 같이 조건부 코드를 사용하여 요구 호출을 수행하는 모듈</target>
        </trans-unit>
        <trans-unit id="e4fcd558836fffcd1fc66bb98d7e86b496b5b825" translate="yes" xml:space="preserve">
          <source>More details on the design forces and use cases for this function wrapping format, called Asynchronous Module Definition (AMD), can be found on the &lt;a href=&quot;whyamd&quot;&gt;Why AMD?&lt;/a&gt; page.</source>
          <target state="translated">AMD (Asynchronous Module Definition)라고하는이 함수 랩핑 형식의 설계 력 및 사용 사례에 대한 자세한 내용은 &lt;a href=&quot;whyamd&quot;&gt;AMD? &lt;/a&gt;페이지.</target>
        </trans-unit>
        <trans-unit id="c0d889e70d00bbeffd76cf22134b56f52ddb2126" translate="yes" xml:space="preserve">
          <source>More information is available on the &lt;a href=&quot;commonjs&quot;&gt;CommonJS page&lt;/a&gt;, and in the &lt;a href=&quot;whyamd#sugar&quot;&gt;&quot;Sugar&quot; section in the Why AMD page&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;commonjs&quot;&gt;CommonJS 페이지&lt;/a&gt; 와 &lt;a href=&quot;whyamd#sugar&quot;&gt;AMD 이유 페이지&lt;/a&gt; 의 &quot;설탕&quot;섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="db89c3e1579783898093f507ce3545538718b599" translate="yes" xml:space="preserve">
          <source>Most CJS modules, around 95% based on my (thoroughly unscientific) personal experience, are perfectly compatible with the simplified CommonJS wrapping.</source>
          <target state="translated">비과학적인 개인적인 경험을 바탕으로 약 95 %의 CJS 모듈은 단순화 된 CommonJS 래핑과 완벽하게 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2aa6e69266afb5745d704808b26d494d039aaad" translate="yes" xml:space="preserve">
          <source>Most web developers use a function wrapper anyway, to avoid polluting the page with globals. Seeing a function wrapped around functionality is a very common sight and does not add to the reading cost of a module.</source>
          <target state="translated">대부분의 웹 개발자는 어쨌든 함수 래퍼를 사용하여 전역으로 페이지를 오염시키지 않습니다. 기능을 둘러싼 기능을 보는 것은 매우 일반적인 일이며 모듈의 판독 비용에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90065a157b088d30c73a343e6ee438e960ff65f0" translate="yes" xml:space="preserve">
          <source>Multiversion Support</source>
          <target state="translated">멀티 버전 지원</target>
        </trans-unit>
        <trans-unit id="7ad300de5360e2dba7612bcbbdd15e356bb1266b" translate="yes" xml:space="preserve">
          <source>Named Modules</source>
          <target state="translated">명명 된 모듈</target>
        </trans-unit>
        <trans-unit id="41ec1d4b4042c78b4e5c776ec46fb5f1495c5fe4" translate="yes" xml:space="preserve">
          <source>Nashorn Support</source>
          <target state="translated">나손 지원</target>
        </trans-unit>
        <trans-unit id="865bc8f0637781f438fc8b01e57a8e62d66abea7" translate="yes" xml:space="preserve">
          <source>No define call for ...</source>
          <target state="translated">에 대한 호출을 정의하지 않습니다 ...</target>
        </trans-unit>
        <trans-unit id="e5a7a586589f9cf9aff0c28e1e027268d23cbfd9" translate="yes" xml:space="preserve">
          <source>No matching script interactive for ...</source>
          <target state="translated">대화식 스크립트가 없습니다 ...</target>
        </trans-unit>
        <trans-unit id="e4c78dc7ccbc3875ab2f45f7d9dc57629a5b721b" translate="yes" xml:space="preserve">
          <source>Normally each run of a whole project optimization will delete the output build directory specified by &lt;strong&gt;dir&lt;/strong&gt; for cleanliness. Some build options, like &lt;strong&gt;onBuildWrite&lt;/strong&gt;, will modify the output directory in a way that is hazardous to do twice over the same files. However, if you are doing simple builds with no extra file transforms besides build layer minification, then you can set &lt;strong&gt;keepBuildDir&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt; to keep the build directory between runs. Then, only files that have changed between build runs will be copied.</source>
          <target state="translated">일반적으로 전체 프로젝트 최적화를 실행할 때마다 청결을 위해 &lt;strong&gt;dir&lt;/strong&gt; 로 지정된 출력 빌드 디렉토리가 삭제됩니다 . &lt;strong&gt;onBuildWrite&lt;/strong&gt; 와 같은 일부 빌드 옵션 은 동일한 파일에 대해 두 번 위험한 방식으로 출력 디렉토리를 수정합니다. 그러나 빌드 계층 축소 외에 추가 파일 변환없이 간단한 빌드를 수행하는 경우 &lt;strong&gt;keepBuildDir&lt;/strong&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 실행간에 빌드 디렉토리를 유지할 수 있습니다 . 그런 다음 빌드 실행간에 변경된 파일 만 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="63637860d1b09a9a35884674fd6b92b4169d387b" translate="yes" xml:space="preserve">
          <source>Normally you should &lt;strong&gt;not&lt;/strong&gt; save optimized files with your pristine project source. Normally you would save them to a copy of your project, but to make this example easier it is saved with the source. Change the &lt;strong&gt;out=&lt;/strong&gt; option to any directory you like, that has a copy of your source. Then, you can change the main-built.js file name to just main.js so the HTML page will load the optimized version of the file.</source>
          <target state="translated">일반적으로 원시 프로젝트 소스와 함께 최적화 된 파일을 저장 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 일반적으로 프로젝트의 복사본에 저장하지만이 예제를보다 쉽게 ​​만들기 위해 소스와 함께 저장합니다. &lt;strong&gt;out =&lt;/strong&gt; 옵션을 소스 사본이있는 원하는 디렉토리로 변경하십시오 . 그런 다음 main-built.js 파일 이름을 main.js로 변경하면 HTML 페이지가 파일의 최적화 된 버전을로드합니다.</target>
        </trans-unit>
        <trans-unit id="5cd37647a9ff32456856beeb4b5a868e634c28ed" translate="yes" xml:space="preserve">
          <source>Normally you should not need to use require() to fetch a module, but instead rely on the module being passed in to the function as an argument. Circular dependencies are rare, and usually a sign that you might want to rethink the design. However, sometimes they are needed, and in that case, use require() as specified above.</source>
          <target state="translated">일반적으로 require ()를 사용하여 모듈을 가져올 필요는 없지만 함수로 인수로 전달되는 모듈에 의존해야합니다. 원형 종속성은 드물며 일반적으로 디자인을 다시 생각할 수 있다는 신호입니다. 그러나 때로는 필요한 경우도 있으므로 위와 같이 require ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55774be7c2eb30133e188a1e6f7e775499e3be75" translate="yes" xml:space="preserve">
          <source>Not all browsers give a usable Function.prototype.toString() results. As of October 2011, the PS 3 and older Opera Mobile browsers do not. Those browsers are more likely to need an optimized build of the modules for network/device limitations, so just do a build with an optimizer that knows how to convert these files to the normalized dependency array form, like the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt;.</source>
          <target state="translated">모든 브라우저가 유용한 Function.prototype.toString () 결과를 제공하는 것은 아닙니다. 2011 년 10 월 현재 PS 3 및 이전 Opera Mobile 브라우저는 그렇지 않습니다. 이러한 브라우저는 네트워크 / 장치 제한을 위해 최적화 된 모듈 빌드가 필요할 가능성이 높으므로 &lt;a href=&quot;optimization&quot;&gt;RequireJS 옵티 마이저&lt;/a&gt; 와 같이 이러한 파일을 정규화 된 종속성 배열 형식으로 변환하는 방법을 알고있는 옵티 마이저로 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="00fcbd7ebdfa5c953e00172733331cfbb354ef3c" translate="yes" xml:space="preserve">
          <source>Note however if you want to get 404 load detection in IE so that you can use paths fallbacks or errbacks, then a string exports value should be given so the loader can check if the scripts actually loaded (a return from init is &lt;strong&gt;not&lt;/strong&gt; used for &lt;code&gt;enforceDefine&lt;/code&gt; checking):</source>
          <target state="translated">그러나 경로 폴백 또는 오류를 사용할 수 있도록 IE에서 404로드 감지를 얻으려면 로더가 스크립트가 실제로로드되었는지 확인할 수 있도록 문자열 내보내기 값을 제공해야합니다 (init에서 반환 하는 것은 &lt;code&gt;enforceDefine&lt;/code&gt; 에 사용 &lt;strong&gt;되지 않습니다)&lt;/strong&gt; 확인 중):</target>
        </trans-unit>
        <trans-unit id="789188496a0ed139c37a18268d1d7e75613d29f9" translate="yes" xml:space="preserve">
          <source>Note that &quot;require&quot; is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If &quot;require&quot; is not specified as a dependency, then there will likely be an error.</source>
          <target state="translated">&quot;require&quot;는 모듈에 대한 종속성으로 지정됩니다. 이를 통해 함수 콜백에 전달 된 require () 함수가 올바른 컨텍스트를 사용하여 멀티 버전 지원을 위해 모듈을 올바르게로드 할 수 있습니다. &quot;require&quot;가 종속성으로 지정되지 않으면 오류가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a031cfd930d814fbea9159a6976e73d89cfd0031" translate="yes" xml:space="preserve">
          <source>Note this only works if &quot;module/name&quot; was previously loaded via the async version of require: &lt;code&gt;require([&quot;module/name&quot;])&lt;/code&gt;. If using a relative path, like './module/name', those only work inside define</source>
          <target state="translated">&quot;module / name&quot;이 &lt;code&gt;require([&quot;module/name&quot;])&lt;/code&gt; 의 비동기 버전을 통해 이전에로드 된 경우에만 작동합니다 . './module/name'과 같은 상대 경로를 사용하는 경우 내부에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="73d8d234ee45af790eb832ba8c7d6006b1416af0" translate="yes" xml:space="preserve">
          <source>Note: The url() path fixing will always fix the paths relative to the &lt;strong&gt;cssIn&lt;/strong&gt; build option path, not the &lt;strong&gt;out&lt;/strong&gt; build option.</source>
          <target state="translated">참고 : 항상 상대 경로 수정되는 URL () 경로 고정 &lt;strong&gt;cssIn의&lt;/strong&gt; 빌드 옵션 경로가 아닌 &lt;strong&gt;아웃&lt;/strong&gt; 빌드 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0c5badabbf2d099d71c93a7c71166c9738138220" translate="yes" xml:space="preserve">
          <source>Notice as part of that example, vendor libraries like jQuery did not have their version numbers in their file names. It is recommended to store that version info in a separate text file if you want to track it, or if you use a tool like &lt;a href=&quot;https://github.com/volojs/volo&quot;&gt;volo&lt;/a&gt;, it will stamp the package.json with the version information but keep the file on disk as &quot;jquery.js&quot;. This allows you to have the very minimal configuration instead of having to put an entry in the &quot;paths&quot; config for each library. For instance, configure &quot;jquery&quot; to be &quot;jquery-1.7.2&quot;.</source>
          <target state="translated">이 예제의 일부로 jQuery와 같은 공급 업체 라이브러리의 파일 이름에 버전 번호가 없습니다. 해당 버전 정보를 추적하려는 경우 별도의 텍스트 파일에 저장하거나 &lt;a href=&quot;https://github.com/volojs/volo&quot;&gt;volo&lt;/a&gt; 와 같은 도구를 사용하는 경우 package.json에 버전 정보가 찍히지 만 파일은 디스크에 &quot;jquery&quot;로 유지됩니다. js &quot;. 이를 통해 각 라이브러리의 &quot;경로&quot;구성에 항목을 넣지 않고 구성을 최소화 할 수 있습니다. 예를 들어 &quot;jquery&quot;를 &quot;jquery-1.7.2&quot;로 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="996ee768862a8be02370220efbb2ff9a6f2f8b5b" translate="yes" xml:space="preserve">
          <source>Notice that the above module does not declare a name for itself. This is what makes the module very portable. It allows a developer to place the module in a different path to give it a different ID/name. The AMD loader will give the module an ID based on how it is referenced by other scripts.</source>
          <target state="translated">위 모듈은 자체 이름을 선언하지 않습니다. 이것이 모듈을 매우 휴대하기 쉽게 만드는 것입니다. 개발자는 모듈을 다른 경로에 배치하여 다른 ID / 이름을 부여 할 수 있습니다. AMD 로더는 다른 스크립트에서 참조하는 방법에 따라 모듈에 ID를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="993f59cc8fa52c4ddad7b03ed5bbcf3714d49d77" translate="yes" xml:space="preserve">
          <source>Now, when this page is loaded, the require() for &quot;main&quot; will load the main-built.js file. Since excludeShallow told it just to exclude two.js, two.js will still be loaded as a separate file, allowing you to see it as a separate file in the browser's debugger, so you can set breakpoints and better track its individual changes.</source>
          <target state="translated">이제이 페이지가로드되면 &quot;main&quot;에 대한 require ()가 main-built.js 파일을로드합니다. excludeShallow가 two.js를 제외하도록 지시 했으므로 two.js는 여전히 별도의 파일로로드되므로 브라우저 디버거에서 별도의 파일로 볼 수 있으므로 중단 점을 설정하고 개별 변경 사항을보다 잘 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a357ac26fa398f234d0d159a9d93322c7b4cb85" translate="yes" xml:space="preserve">
          <source>Once that optimization is done, you can change the script tag to reference &quot;main-built.js&quot; instead of &quot;require.js&quot;, and your optimized project will only need to make one script request.</source>
          <target state="translated">최적화가 완료되면 &quot;require.js&quot;대신 &quot;main-built.js&quot;를 참조하도록 스크립트 태그를 변경할 수 있으며 최적화 된 프로젝트는 하나의 스크립트 요청 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2b0cafc31915283c6f140afefded86a6a94d85" translate="yes" xml:space="preserve">
          <source>Once the build is done, you can use &lt;strong&gt;appdirectory-build&lt;/strong&gt; as your optimized project, ready for deployment.</source>
          <target state="translated">빌드가 완료되면 &lt;strong&gt;appdirectory-build&lt;/strong&gt; 를 최적화 된 프로젝트로 사용하여 &lt;strong&gt;배포&lt;/strong&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="687a77b17737ebb7701c40d0de5ac221cc75854d" translate="yes" xml:space="preserve">
          <source>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</source>
          <target state="translated">웹 앱이 특정 크기와 인기를 얻으면 인터페이스에서 문자열을 현지화하고 다른 로케일 별 정보를 제공하는 것이 더 유용 해집니다. 그러나 여러 로케일을 지원하기 위해 잘 확장되는 구성표를 작성하는 것은 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f5e918f3dd72c7755fe673e8aeaf5ae2e4034a2" translate="yes" xml:space="preserve">
          <source>One example: a plugin that needs to write out some utility functions at the beginning of a layer, as part of the first &lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt; call, and the plugin needs to know when to reset the internal state to know when to write out the utilities for the next layer. If the plugin implements onLayerEnd, it can get notified when to reset its internal state.</source>
          <target state="translated">한 가지 예 : 첫 번째 &lt;a href=&quot;#apiwrite&quot;&gt;쓰기&lt;/a&gt; 호출의 일부로 계층 시작 부분에서 일부 유틸리티 함수를 작성 해야하는 플러그인이며, 플러그인은 내부 상태를 재설정 할시기를 알고 있어야합니다. 다음 층. 플러그인이 onLayerEnd를 구현하면 내부 상태를 재설정 할 때 알림을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136a30d6a64759ec55feda3ab1525a1a3b34d9e6" translate="yes" xml:space="preserve">
          <source>One of the criticisms of AMD, at least compared to CJS modules, is that it requires a level of indent and a function wrapping.</source>
          <target state="translated">적어도 CJS 모듈과 비교할 때 AMD의 비판 중 하나는 들여 쓰기 수준과 기능 줄 바꿈이 필요하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="425ce3199a0f68e5f26534c0cd5b7ecada23b956" translate="yes" xml:space="preserve">
          <source>Only execute the factory function once all the dependencies have been loaded and executed.</source>
          <target state="translated">모든 종속성이로드되고 실행 된 후에 만 ​​팩토리 기능을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f5b213795860798e7ca26c8b8fd156f9d8034004" translate="yes" xml:space="preserve">
          <source>Only one version of a package can be used in a project context at a time. You can use RequireJS &lt;a href=&quot;#multiversion&quot;&gt;multiversion support&lt;/a&gt; to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</source>
          <target state="translated">한 번에 하나의 패키지 버전 만 프로젝트 컨텍스트에서 사용할 수 있습니다. RequireJS &lt;a href=&quot;#multiversion&quot;&gt;멀티 버전 지원&lt;/a&gt; 을 사용 하여 두 개의 서로 다른 모듈 컨텍스트를로드 할 수 있지만 한 컨텍스트에서 패키지 A와 B를 사용하고 서로 다른 버전의 패키지 C에 의존하는 경우 문제가됩니다. 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03cab42295a0ef773cb4c58414926ae22c7f099" translate="yes" xml:space="preserve">
          <source>Only use other &quot;shim&quot; modules as dependencies for shimmed scripts, or AMD libraries that have no dependencies and call define() after they also create a global (like jQuery or lodash). Otherwise, if you use an AMD module as a dependency for a shim config module, after a build, that AMD module may not be evaluated until after the shimmed code in the build executes, and an error will occur. The ultimate fix is to upgrade all the shimmed code to have optional AMD define() calls.</source>
          <target state="translated">shimmed 스크립트에 대한 종속성으로 다른 &quot;shim&quot;모듈 또는 종속성이없는 AMD 라이브러리 만 사용하고 전역 (jQuery 또는 lodash와 같은)을 만든 후 define ()을 호출하십시오. 그렇지 않으면 AMD 모듈을 shim 구성 모듈의 종속성으로 사용하는 경우 빌드 후에 빌드에서 shimmed 코드가 실행될 때까지 AMD 모듈이 평가되지 않을 수 있으며 오류가 발생합니다. 궁극적 인 해결책은 모든 shimmed 코드를 업그레이드하여 옵션 AMD define () 호출을 갖도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e52f63056d18f367435ae7f42b9e0e1b5ba47c94" translate="yes" xml:space="preserve">
          <source>Optimization Tool</source>
          <target state="translated">최적화 도구</target>
        </trans-unit>
        <trans-unit id="e1bf3840bdf455e89a6ccb39ca4b5ef36c34af9a" translate="yes" xml:space="preserve">
          <source>Optimizes CSS by inlining CSS files referenced by @import and removing comments.</source>
          <target state="translated">@import가 참조하는 CSS 파일을 인라인하고 주석을 제거하여 CSS를 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="645afdfe1831be73caed431c4985960a8ed23da8" translate="yes" xml:space="preserve">
          <source>Optimizing a multi-page project</source>
          <target state="translated">여러 페이지 프로젝트 최적화</target>
        </trans-unit>
        <trans-unit id="94406643fcbc9130f67c3a7df6529a75a5308c56" translate="yes" xml:space="preserve">
          <source>Optimizing a whole project</source>
          <target state="translated">전체 프로젝트 최적화</target>
        </trans-unit>
        <trans-unit id="1b97e68f7e906d321f51c531c8135373f8051ae6" translate="yes" xml:space="preserve">
          <source>Optimizing one CSS file</source>
          <target state="translated">하나의 CSS 파일 최적화</target>
        </trans-unit>
        <trans-unit id="2020d5670f6972dff09b1dce4b6069fedaf819dd" translate="yes" xml:space="preserve">
          <source>Optimizing one JavaScript file</source>
          <target state="translated">하나의 JavaScript 파일 최적화</target>
        </trans-unit>
        <trans-unit id="a83a52c3fb590de0dc3104c9c47bccb368ae4538" translate="yes" xml:space="preserve">
          <source>Or better yet, use the shortened syntax that is available for use with &lt;a href=&quot;commonjs&quot;&gt;translating CommonJS&lt;/a&gt; modules:</source>
          <target state="translated">또는 &lt;a href=&quot;commonjs&quot;&gt;CommonJS&lt;/a&gt; 모듈 을 변환 하는 데 사용할 수있는 단축 구문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="439567bdbbd0efa69af61a769a5cca0a13682f69" translate="yes" xml:space="preserve">
          <source>Or there was a 404 error in IE where the script failed to load.</source>
          <target state="translated">또는 스크립트를로드하지 못한 IE에서 404 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="902a0c43077fddb8868418fb133f6ea532f9cf74" translate="yes" xml:space="preserve">
          <source>Or use XMLHttpRequest (XHR) to load the text of modules and do text transforms/parsing in browser.</source>
          <target state="translated">또는 XHR (XMLHttpRequest)을 사용하여 모듈의 텍스트를로드하고 브라우저에서 텍스트 변환 / 파싱을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0a8b90507f83c83d06c60ecc35f83f8e249ecaaf" translate="yes" xml:space="preserve">
          <source>Or was part of a &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; that did not set a string value for the &lt;code&gt;exports&lt;/code&gt; config option.</source>
          <target state="translated">또는 &lt;code&gt;exports&lt;/code&gt; 구성 옵션에 문자열 값을 설정하지 않은 &lt;a href=&quot;api#config-shim&quot;&gt;shim 구성의&lt;/a&gt; 일부였습니다 .</target>
        </trans-unit>
        <trans-unit id="49b8afea31aaecf8ff90dc1b9c1a2348f0ea7f7f" translate="yes" xml:space="preserve">
          <source>Or was part of a &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; that specified a string &lt;code&gt;exports&lt;/code&gt; property that can be checked to verify loading, and that check failed.</source>
          <target state="translated">또는 로드 확인을 위해 확인할 수 있는 문자열 &lt;code&gt;exports&lt;/code&gt; 속성을 지정 하고 해당 확인에 실패한 &lt;a href=&quot;api#config-shim&quot;&gt;shim 구성의&lt;/a&gt; 일부였습니다 .</target>
        </trans-unit>
        <trans-unit id="a720b152f92f2ac4f80f1d33c29f053ea00d9d62" translate="yes" xml:space="preserve">
          <source>Or, baseUrl can be set manually via the &lt;a href=&quot;#config&quot;&gt;RequireJS config&lt;/a&gt;. If there is no explicit config and data-main is not used, then the default baseUrl is the directory that contains the HTML page running RequireJS.</source>
          <target state="translated">또는 &lt;a href=&quot;#config&quot;&gt;RequireJS 구성을&lt;/a&gt; 통해 baseUrl을 수동으로 설정할 수 있습니다 . 명시 적 구성이없고 data-main이 사용되지 않은 경우 기본 baseUrl은 RequireJS를 실행하는 HTML 페이지가 포함 된 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="5e6e5c0ac606b77ee930fbf12aa3eaf2fba80c55" translate="yes" xml:space="preserve">
          <source>Or, do not set that paths or packages config and do the top level require call as &lt;code&gt;require(['compute/main'])&lt;/code&gt;.</source>
          <target state="translated">또는 경로 또는 패키지 구성을 설정하지 말고 최상위 수준의 require call ( &lt;code&gt;require(['compute/main'])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88494ce1c87ce2ac5b556e14476243360620b7de" translate="yes" xml:space="preserve">
          <source>Or, if it was inside a package or directory, say bar/foo.js:</source>
          <target state="translated">또는 패키지 또는 디렉토리에있는 경우 bar / foo.js라고 말하십시오.</target>
        </trans-unit>
        <trans-unit id="c8545835771037daaa58fff1b8277d3939e13f00" translate="yes" xml:space="preserve">
          <source>Or, if the error shows up only in IE and not in other browsers (which may generate a &lt;a href=&quot;#scripterror&quot;&gt;Script error&lt;/a&gt;, the script probably:</source>
          <target state="translated">또는 오류가 다른 브라우저에서는 나타나지 않고 다른 브라우저에서는 나타나지 않습니다 ( &lt;a href=&quot;#scripterror&quot;&gt;스크립트 오류가 발생할&lt;/a&gt; 수 있음) .</target>
        </trans-unit>
        <trans-unit id="29f29e827b24a3ffb1ab93d7db5bce55a6c4f1ce" translate="yes" xml:space="preserve">
          <source>Or, if you are using the dependency array approach, ask for the special &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic&quot;&gt;'exports' dependency:&lt;/a&gt;</source>
          <target state="translated">또는 종속성 배열 접근 방식을 사용하는 경우 특별한 &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic&quot;&gt;'내보내기'종속성을 요청하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d44801d0d5cf3036fef8c533c5129460949cb61c" translate="yes" xml:space="preserve">
          <source>Or, in a &lt;a href=&quot;#wholeproject&quot;&gt;build profile&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;#wholeproject&quot;&gt;빌드 프로파일에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dc0e1588bad559c25e336f4ce491e9bf9a9a02a1" translate="yes" xml:space="preserve">
          <source>Other Module Notes</source>
          <target state="translated">다른 모듈 노트</target>
        </trans-unit>
        <trans-unit id="827ce3954d41bf64bd605c6e720e058b609bd8b9" translate="yes" xml:space="preserve">
          <source>Other notes:</source>
          <target state="translated">기타 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="66dbf063bcea03a792a7891f658c840f4e2eb8a5" translate="yes" xml:space="preserve">
          <source>Page Load Event Support/DOM Ready</source>
          <target state="translated">페이지로드 이벤트 지원 / DOM 준비</target>
        </trans-unit>
        <trans-unit id="9346ea1a2567e24e1999e03d291dbda3abc51506" translate="yes" xml:space="preserve">
          <source>Pass dependencies as an array of string values, do not grab globals.</source>
          <target state="translated">문자열 값의 배열로 종속성을 전달하고 전역을 가져 가지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0172d30c7aa6ed692ec90cac0a23592350107890" translate="yes" xml:space="preserve">
          <source>Pass the dependent modules as arguments to the factory function.</source>
          <target state="translated">종속 모듈을 팩토리 함수에 인수로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0c6289bda156d08308bc76ef1a76402bbe7a9d41" translate="yes" xml:space="preserve">
          <source>Pass the main js file's &quot;require&quot; function in the configuration to requirejs.</source>
          <target state="translated">구성에서 기본 js 파일의 &quot;require&quot;기능을 requirejs로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="98e5d7b826f13bc081a5c843c115d8bf9fcada6d" translate="yes" xml:space="preserve">
          <source>Path is not supported: ...</source>
          <target state="translated">경로가 지원되지 않습니다 : ...</target>
        </trans-unit>
        <trans-unit id="5fcfa1bf3e6a3af7d674727ac67b76e351e748ac" translate="yes" xml:space="preserve">
          <source>Plugin Names</source>
          <target state="translated">플러그인 이름</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="76bd11a64888afb8cf5d2330679e774342f2f928" translate="yes" xml:space="preserve">
          <source>Plugins and pluginBuilders that run as part of the build process have a very limited environment. The optimizer runs in a few different JS environments. Be careful of the environment assumptions if you want the plugin to run as part of the optimizer.</source>
          <target state="translated">빌드 프로세스의 일부로 실행되는 플러그인 및 플러그인은 환경이 매우 제한되어 있습니다. 옵티마이 저는 몇 가지 다른 JS 환경에서 실행됩니다. 플러그인을 옵티마이 저의 일부로 실행하려면 환경 가정에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="a625e49b8ad0187e7c76b41bda6719cbf35d7410" translate="yes" xml:space="preserve">
          <source>Previously, we've been pointing to an example using a special require-jquery file, which consisted of require.js and jQuery concatenated. This is no longer the recommended way to use jQuery with require.js, but if you're looking for the (no longer maintained) example, &lt;a href=&quot;https://github.com/requirejs/require-jquery&quot;&gt;you can find require-jquery here&lt;/a&gt;.</source>
          <target state="translated">이전에는 require.js와 jQuery로 구성된 특수한 require-jquery 파일을 사용하는 예를 살펴 보았습니다. 이것은 더 이상 require.js와 함께 jQuery를 사용하는 권장 방법은 아니지만 (더 이상 유지되지 않는) 예제를 찾고 있다면 &lt;a href=&quot;https://github.com/requirejs/require-jquery&quot;&gt;여기에서 require-jquery를 찾을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad33aa36988abe76a127defcbb28205f85bbb59" translate="yes" xml:space="preserve">
          <source>Reading code.</source>
          <target state="translated">코드 읽기</target>
        </trans-unit>
        <trans-unit id="8b982016d5900e602617c0bc1c12154c4598f912" translate="yes" xml:space="preserve">
          <source>References to dependencies are done via global variable names that were loaded via an HTML script tag.</source>
          <target state="translated">종속성에 대한 참조는 HTML 스크립트 태그를 통해로드 된 전역 변수 이름을 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7bcd6090618479458d2c3f424394bc8a8a5e7003" translate="yes" xml:space="preserve">
          <source>Register the factory function by calling define(), instead of immediately executing it.</source>
          <target state="translated">팩토리 함수를 즉시 실행하는 대신 define ()을 호출하여 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="0c284da9459af724aa990a40f8450015eebf6856" translate="yes" xml:space="preserve">
          <source>Relative paths are really useful if you are creating a few modules inside a directory, so that you can share the directory with other people or other projects, and you want to be able to get a handle on the sibling modules in that directory without having to know the directory's name.</source>
          <target state="translated">상대 경로는 디렉토리 내에 몇 개의 모듈을 작성하여 다른 사람이나 다른 프로젝트와 디렉토리를 공유 할 수 있고 디렉토리에서 형제 모듈에 대한 핸들을 얻을 수 있기를 원할 때 실제로 유용합니다. 디렉토리 이름을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="94cf16b1d96cb308c10ddb10fa3d66e5787888fd" translate="yes" xml:space="preserve">
          <source>RequireJS</source>
          <target state="translated">RequireJS</target>
        </trans-unit>
        <trans-unit id="47ca39fabb6dc307dd72900d813b8a172134c35a" translate="yes" xml:space="preserve">
          <source>RequireJS API</source>
          <target state="translated">RequireJS API</target>
        </trans-unit>
        <trans-unit id="3aaf7cdebbaed3982494204c265ab9fb4280eca0" translate="yes" xml:space="preserve">
          <source>RequireJS Optimizer</source>
          <target state="translated">JS 최적화 프로그램 필요</target>
        </trans-unit>
        <trans-unit id="a00ba25e980ea1a174cd4c549d1dbf710ce875d4" translate="yes" xml:space="preserve">
          <source>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</source>
          <target state="translated">RequireJS를 사용하면 모든 로케일 별 정보를 미리 제공하지 않고도 현지화 된 정보가있는 기본 모듈을 설정할 수 있습니다. 시간이 지남에 따라 추가 할 수 있으며 로케일간에 변경되는 문자열 / 값만 로케일 특정 파일에서 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3408430dbcb8ac254a29b55d04664b14b6f1c6" translate="yes" xml:space="preserve">
          <source>RequireJS allows you to write loader plugins that can load different types of resources as dependencies, and even include the dependencies in optimized builds.</source>
          <target state="translated">RequireJS를 사용하면 다양한 유형의 리소스를 종속성으로로드하고 최적화 된 빌드에 종속성을 포함 할 수있는 로더 플러그인을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a94b06ecd72ce8db95c0857bd11078a76ac052" translate="yes" xml:space="preserve">
          <source>RequireJS also assumes by default that all dependencies are scripts, so it does not expect to see a trailing &quot;.js&quot; suffix on module IDs. RequireJS will automatically add it when translating the module ID to a path. With the &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt;, you can set up locations of a group of scripts. All of these capabilities allow you to use smaller strings for scripts as compared to traditional &amp;lt;script&amp;gt; tags.</source>
          <target state="translated">또한 RequireJS는 기본적으로 모든 종속성이 스크립트라고 가정하므로 모듈 ID에 후행 &quot;.js&quot;접미사가 표시되지 않습니다. RequireJS는 모듈 ID를 경로로 변환 할 때 자동으로 추가합니다. 으로 &lt;a href=&quot;#config-paths&quot;&gt;경로 설정&lt;/a&gt; , 당신은 스크립트의 그룹의 위치를 설정할 수 있습니다. 이러한 모든 기능을 통해 기존 &amp;lt;script&amp;gt; 태그와 비교하여 스크립트에 더 작은 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55e10b7ae48550ca2e079e5fb7385a105125bd42" translate="yes" xml:space="preserve">
          <source>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</source>
          <target state="translated">RequireJS는 번들을 함께 결합하므로, 예를 들어 프랑스 번들이 이와 같이 정의 된 경우 (빨간색 값 생략) :</target>
        </trans-unit>
        <trans-unit id="fccadba92d8e64d1c63a0ead823d420a25b4223b" translate="yes" xml:space="preserve">
          <source>RequireJS can be used in Rhino via the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js adapter&lt;/a&gt;. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;the r.js README&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS는 &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js 어댑터&lt;/a&gt; 를 통해 Rhino에서 사용할 수 있습니다 . 자세한 정보 &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;는 r.js README&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d54491027136cdb42cd2346edd319e96067f8363" translate="yes" xml:space="preserve">
          <source>RequireJS config options like map, packages, paths are only applied if RequireJS loads the module. If RequireJS needs to ask the node module system, the original ID is passed to Node. If you need a node module to work with a map config, inline define() calls work, as shown in &lt;a href=&quot;https://groups.google.com/forum/#!msg/requirejs/ur_UQLr04rc/sSpM8y87VNMJ&quot;&gt;this email list thread.&lt;/a&gt;</source>
          <target state="translated">맵, 패키지, 경로와 같은 RequireJS 구성 옵션은 RequireJS가 모듈을로드하는 경우에만 적용됩니다. RequireJS가 노드 모듈 시스템을 요청해야하는 경우 원래 ID가 노드로 전달됩니다. 맵 구성으로 작업하기 위해 노드 모듈이 필요한 &lt;a href=&quot;https://groups.google.com/forum/#!msg/requirejs/ur_UQLr04rc/sSpM8y87VNMJ&quot;&gt;경우이 전자 메일 목록 스레드에&lt;/a&gt; 표시된대로 인라인 define () 호출이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a431a4070e33492518f70bd423f5abfd334b6755" translate="yes" xml:space="preserve">
          <source>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. See the &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text.js README&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS에는이 문제를 해결하는 데 도움이되는 플러그인 text.js가 있습니다. 텍스트가 있으면 자동으로로드됩니다! 접두사는 종속성에 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text.js README&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5677da00d1c14ead1e4adea4966177511c24f3dc" translate="yes" xml:space="preserve">
          <source>RequireJS has an optimization tool that can combine module definitions together into optimized bundles for browser delivery. It works as a command-line tool that you use as part of code deployment. See the &lt;a href=&quot;optimization&quot;&gt;optimization docs&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS에는 브라우저 정의를 위해 모듈 정의를 최적화 된 번들로 결합 할 수있는 최적화 도구가 있습니다. 코드 배포의 일부로 사용하는 명령 줄 도구로 작동합니다. 자세한 내용은 &lt;a href=&quot;optimization&quot;&gt;최적화 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ebed6cc24d0f8ed2a4a2bbd37a3e3109937f099" translate="yes" xml:space="preserve">
          <source>RequireJS has an optimization tool that does the following</source>
          <target state="translated">RequireJS에는 다음을 수행하는 최적화 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2ae7c9c68ca1f789539282f1e0c6013fe1a4cab" translate="yes" xml:space="preserve">
          <source>RequireJS in Node</source>
          <target state="translated">노드의 RequireJS</target>
        </trans-unit>
        <trans-unit id="6c58998b40f6be8aaeb533c77012203955ebca3a" translate="yes" xml:space="preserve">
          <source>RequireJS in Node can only load modules that are on the local disk -- fetching modules across http, for instance, is not supported at this time.</source>
          <target state="translated">Node의 RequireJS는 로컬 디스크에있는 모듈 만로드 할 수 있습니다. 예를 들어 http를 통한 모듈 반입은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8789cfb66c2cb6baae8304b15d155ce3e4262022" translate="yes" xml:space="preserve">
          <source>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is &quot;en-us&quot;, then the &quot;root&quot; bundle will be used. If the locale is &quot;fr-fr-paris&quot; then the &quot;fr-fr&quot; bundle will be used.</source>
          <target state="translated">RequireJS는 또한 올바른 로케일 번들을 선택할 수있을 정도로 똑똑하며 my / nls / colors에서 제공하는 로케일과 가장 일치합니다. 예를 들어 로케일이 &quot;en-us&quot;인 경우 &quot;root&quot;번들이 사용됩니다. 로케일이 &quot;fr-fr-paris&quot;인 경우 &quot;fr-fr&quot;번들이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fb4604a5e20f298faa5c59ab7ab5a36c146a3d9" translate="yes" xml:space="preserve">
          <source>RequireJS loads all code relative to a &lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;. The baseUrl is normally set to the same directory as the script used in a data-main attribute for the top level script to load for a page. The &lt;a href=&quot;#data-main&quot;&gt;data-main attribute&lt;/a&gt; is a special attribute that require.js will check to start script loading. This example will end up with a baseUrl of &lt;strong&gt;scripts&lt;/strong&gt;:</source>
          <target state="translated">RequireJS는 &lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl에&lt;/a&gt; 상대적인 모든 코드를로드합니다 . baseUrl은 일반적으로 페이지에로드 할 최상위 레벨 스크립트의 data-main 속성에 사용 된 스크립트와 동일한 디렉토리로 설정됩니다. &lt;a href=&quot;#data-main&quot;&gt;데이터의 주요 속성은&lt;/a&gt; require.js 스크립트 로딩을 시작합니다 확인합니다있는 특별한 속성입니다. 이 예제는 baseUrl &lt;strong&gt;스크립트로&lt;/strong&gt; 끝납니다 :</target>
        </trans-unit>
        <trans-unit id="e9589541f36d742283d0c596376a86ca39ac9ec7" translate="yes" xml:space="preserve">
          <source>RequireJS loads each dependency as a script tag, using head.appendChild().</source>
          <target state="translated">RequireJS는 head.appendChild ()를 사용하여 각 종속성을 스크립트 태그로로드합니다.</target>
        </trans-unit>
        <trans-unit id="673463710a9bd2155fd9748361e294a2190a5632" translate="yes" xml:space="preserve">
          <source>RequireJS supports &lt;a href=&quot;plugins&quot;&gt;loader plugins&lt;/a&gt;. This is a way to support dependencies that are not plain JS files, but are still important for a script to have loaded before it can do its work. The RequireJS wiki has &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;a list of plugins&lt;/a&gt;. This section talks about some specific plugins that are maintained alongside RequireJS:</source>
          <target state="translated">RequireJS는 &lt;a href=&quot;plugins&quot;&gt;로더 플러그인을&lt;/a&gt; 지원합니다 . 이것은 일반 JS 파일이 아닌 종속성을 지원하는 방법이지만 스크립트가 작업을 수행하기 전에로드하는 데 여전히 중요합니다. RequireJS 위키에는 &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;플러그인 목록이 있습니다&lt;/a&gt; . 이 섹션에서는 RequireJS와 함께 유지 보수되는 특정 플러그인에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6d58ff33f7bd1e7a83c19b7daf98cfdcff0a35f8" translate="yes" xml:space="preserve">
          <source>RequireJS supports loading modules that are in a &lt;a href=&quot;http://wiki.commonjs.org/wiki/Packages/1.1&quot;&gt;CommonJS Packages&lt;/a&gt; directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</source>
          <target state="translated">RequireJS는 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Packages/1.1&quot;&gt;CommonJS 패키지&lt;/a&gt; 디렉토리 구조 에있는 모듈로드를 지원 하지만 작동하려면 일부 추가 구성을 지정해야합니다. 특히 다음 CommonJS 패키지 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b55dd4ac98c8bbc119acc87f176e4390a8c0ff91" translate="yes" xml:space="preserve">
          <source>RequireJS takes a different approach to script loading than traditional &amp;lt;script&amp;gt; tags. While it can also run fast and optimize well, the primary goal is to encourage modular code. As part of that, it encourages using &lt;strong&gt;module IDs&lt;/strong&gt; instead of URLs for script tags.</source>
          <target state="translated">RequireJS는 기존 &amp;lt;script&amp;gt; 태그와 다른 스크립트 로딩 방식을 사용합니다. 또한 빠르게 실행하고 최적화 할 수 있지만 기본 목표는 모듈 식 코드를 장려하는 것입니다. 이 과정 에서 스크립트 태그에 URL 대신 &lt;strong&gt;모듈 ID&lt;/strong&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6436c4e607871db5db8f8455a8e83d61e8df8f6a" translate="yes" xml:space="preserve">
          <source>RequireJS tries to keep with the spirit of CommonJS, with using string names to refer to dependencies, and to avoid modules defining global objects, but still allow coding a module format that works well natively in the browser. RequireJS implements the &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;Asynchronous Module Definition&lt;/a&gt; (formerly Transport/C) proposal.</source>
          <target state="translated">RequireJS는 문자열 이름을 사용하여 종속성을 참조하고 전역 객체를 정의하는 모듈을 피하면서 브라우저에서 기본적으로 잘 작동하는 모듈 형식을 코딩 할 수 있도록 CommonJS의 정신을 유지하려고합니다. RequireJS는 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;비동기 모듈 정의&lt;/a&gt; (이전의 Transport / C) 제안을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="8f29b8502f5345425b66e5f08837d689a07333d6" translate="yes" xml:space="preserve">
          <source>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions once the dependencies for those functions have been called. Note that the dependencies for a given module definition function could be called in any order, due to their sub-dependency relationships and network load order.</source>
          <target state="translated">RequireJS는 모든 종속성이로드되기를 기다렸다가 모듈을 정의하는 함수를 호출하는 올바른 순서를 파악한 다음 해당 함수에 대한 종속성이 호출되면 모듈 정의 함수를 호출합니다. 하위 종속성 관계 및 네트워크로드 순서로 인해 지정된 모듈 정의 함수의 종속성을 임의의 순서로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0dfe99c16d5f457a6040729f397e4386f8b570" translate="yes" xml:space="preserve">
          <source>RequireJS will load the plugin module first, then pass the rest of the dependency name to a load() method on the plugin. There are also some methods to help with module name normalization and for making use of the plugin as part of the &lt;a href=&quot;optimization&quot;&gt;optimizer&lt;/a&gt;.</source>
          <target state="translated">RequireJS는 먼저 플러그인 모듈을로드 한 다음 나머지 종속성 이름을 플러그인의 load () 메소드에 전달합니다. 모듈 이름 정규화를 지원하고 &lt;a href=&quot;optimization&quot;&gt;최적화 프로그램의&lt;/a&gt; 일부로 플러그인을 사용하는 데 도움이되는 몇 가지 방법도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a29bbde38e6f3231cde9d0379103efa2d21c69b" translate="yes" xml:space="preserve">
          <source>RequireJS will use &lt;strong&gt;baseUrl&lt;/strong&gt; to resolve the paths for any module names. The &lt;strong&gt;baseUrl&lt;/strong&gt; should be relative to &lt;strong&gt;appDir&lt;/strong&gt;.</source>
          <target state="translated">RequireJS는 &lt;strong&gt;baseUrl&lt;/strong&gt; 을 사용 하여 모든 모듈 이름의 경로를 분석합니다. &lt;strong&gt;base을이&lt;/strong&gt; 상대해야 &lt;strong&gt;APPDIR&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="688bb14e2599e744cb6ca3a0873b76582ff0f536" translate="yes" xml:space="preserve">
          <source>RequireJS will use its &lt;a href=&quot;api#config&quot;&gt;Configuration Options&lt;/a&gt; first to find modules. If RequireJS cannot find the module with its configuration, it is assumed to be a module that uses Node's type of modules and configuration. So, only configure module locations with RequireJS if they use the RequireJS API. For modules that expect Node's APIs and configuration/paths, just install them with a Node package manager, like &lt;a href=&quot;http://npmjs.org/&quot;&gt;npm&lt;/a&gt;, and do not configure their locations with RequireJS.</source>
          <target state="translated">RequireJS는 먼저 &lt;a href=&quot;api#config&quot;&gt;구성 옵션&lt;/a&gt; 을 사용하여 모듈을 찾습니다. RequireJS가 구성이있는 모듈을 찾을 수없는 경우, 노드의 모듈 유형 및 구성을 사용하는 모듈 인 것으로 가정합니다. 따라서 RequireJS API를 사용하는 경우 RequireJS로 모듈 위치 만 구성하십시오. 노드의 API 및 구성 / 경로가 필요한 모듈의 경우 &lt;a href=&quot;http://npmjs.org/&quot;&gt;npm&lt;/a&gt; 과 같은 노드 패키지 관리자로 설치하고 RequireJS로 해당 위치를 구성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="721bf008a2bc600d3c32a3b29e21d14cb20b6f23" translate="yes" xml:space="preserve">
          <source>RequireJS will use its &lt;a href=&quot;api#config&quot;&gt;Configuration Options&lt;/a&gt; first to find modules. If RequireJS cannot find the module with its configuration, it is assumed to be a module that uses Node's type of modules and configuration. So, only configure module locations with RequireJS if they use the RequireJS API. For modules that expect Node's APIs and configuration/paths, just install them with a Node package manager, like &lt;a href=&quot;https://npmjs.org/&quot;&gt;npm&lt;/a&gt;, and do not configure their locations with RequireJS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c839298d9c9623cb8e392c4497e969c4790ef6e" translate="yes" xml:space="preserve">
          <source>RequireJS will use the browser's navigator.languages, navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the &lt;a href=&quot;#config-moduleconfig&quot;&gt;module config&lt;/a&gt; to pass the locale to the plugin:</source>
          <target state="translated">RequireJS는 브라우저의 navigator.languages, navigator.language 또는 navigator.userLanguage 속성을 사용하여 my / nls / colors에 사용할 로캘 값을 결정하므로 앱을 변경할 필요가 없습니다. 로케일을 설정하려면 &lt;a href=&quot;#config-moduleconfig&quot;&gt;모듈 구성&lt;/a&gt; 을 사용 하여 로케일을 플러그인에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3f10ab66132d869b60a146832a0c5b877741a373" translate="yes" xml:space="preserve">
          <source>Rhino Support</source>
          <target state="translated">Rhino 지원</target>
        </trans-unit>
        <trans-unit id="5cdeacc3fcee5a3d0cc852f72b086b0c1d3b1b46" translate="yes" xml:space="preserve">
          <source>Script Loading APIs</source>
          <target state="translated">스크립트 로딩 API</target>
        </trans-unit>
        <trans-unit id="dd7fe2e96e7ebbf0541153c92fa3cd3835838976" translate="yes" xml:space="preserve">
          <source>Script Loading: Web Workers</source>
          <target state="translated">스크립트 로딩 : 웹 워커</target>
        </trans-unit>
        <trans-unit id="28c6a0f178110b7c5ee9c71b12d4ecc6644a0cba" translate="yes" xml:space="preserve">
          <source>Script Loading: XHR</source>
          <target state="translated">스크립트 로딩 : XHR</target>
        </trans-unit>
        <trans-unit id="806dde701e4839cc61a55b54f617f0476f1d3ee0" translate="yes" xml:space="preserve">
          <source>Script Loading: document.write()</source>
          <target state="translated">스크립트 로딩 : document.write ()</target>
        </trans-unit>
        <trans-unit id="60346569fcbd6bf8b72d2ad70cffec0d959f65b5" translate="yes" xml:space="preserve">
          <source>Script Loading: head.appendChild(script)</source>
          <target state="translated">스크립트 로딩 : head.appendChild (script)</target>
        </trans-unit>
        <trans-unit id="db54505af4dab7b72398b3e7754b587c923bd562" translate="yes" xml:space="preserve">
          <source>Script error</source>
          <target state="translated">스크립트 오류</target>
        </trans-unit>
        <trans-unit id="6875cba1ccf3cfd56f772e1129de1d0c7afb8560" translate="yes" xml:space="preserve">
          <source>Script loading APIs</source>
          <target state="translated">스크립트 로딩 API</target>
        </trans-unit>
        <trans-unit id="31f0eeca69d93e11dcc7ab2a4e310b48538b63b1" translate="yes" xml:space="preserve">
          <source>Script loading: Web Workers</source>
          <target state="translated">스크립트 로딩 : 웹 워커</target>
        </trans-unit>
        <trans-unit id="e9d88717ea3152125e41b249b9019556f13f241f" translate="yes" xml:space="preserve">
          <source>Script loading: XHR</source>
          <target state="translated">스크립트 로딩 : XHR</target>
        </trans-unit>
        <trans-unit id="59f54191b9255eb86b70dd4cc8c5871f655716d3" translate="yes" xml:space="preserve">
          <source>Script loading: document.write()</source>
          <target state="translated">스크립트 로딩 : document.write ()</target>
        </trans-unit>
        <trans-unit id="22646269707ddc713b377c7499e8bd2b5f3d4a7b" translate="yes" xml:space="preserve">
          <source>Script loading: head.appendchild(script)</source>
          <target state="translated">스크립트 로딩 : head.appendchild (script)</target>
        </trans-unit>
        <trans-unit id="61c2152b82f1ea69ef3fd9c78b7ef62b9bc77399" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text! plugin&lt;/a&gt; for an example of writeFile.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;텍스트를! &lt;/a&gt;writeFile 예제를위한 플러그인 .</target>
        </trans-unit>
        <trans-unit id="40d3cc95499cba07de8b5028ea38fbb5a6869a5b" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;index&quot;&gt;API docs&lt;/a&gt; for more information on that syntax.</source>
          <target state="translated">해당 구문에 대한 자세한 내용은 &lt;a href=&quot;index&quot;&gt;API 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e200d0bc7ac72dc2a3ed047bd78b5d5acaa6d8d" translate="yes" xml:space="preserve">
          <source>See the notes for the &lt;a href=&quot;#onejs&quot;&gt;Optimizing one JavaScript file&lt;/a&gt; about avoiding saving optimized files in your pristine source tree. It is only done here to make the example simpler.</source>
          <target state="translated">원시 소스 트리에 최적화 된 파일을 저장하지 않는 방법에 대해서는 &lt;a href=&quot;#onejs&quot;&gt;JavaScript 파일 최적화에&lt;/a&gt; 대한 참고 사항을 참조하십시오 . 여기서는 예제를 더 단순하게 만들기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c74306bac8e3a4dc448afdd8cae317b6caccd986" translate="yes" xml:space="preserve">
          <source>Setting Exported Value</source>
          <target state="translated">내 보낸 값 설정</target>
        </trans-unit>
        <trans-unit id="e65edca48b8f7a17979616fa3db4cf39e464286e" translate="yes" xml:space="preserve">
          <source>Shallow exclusions for fast development</source>
          <target state="translated">빠른 개발을위한 얕은 제외</target>
        </trans-unit>
        <trans-unit id="670595ae52d642feb7afce4692abba1e144a6acb" translate="yes" xml:space="preserve">
          <source>Shim config is not supported when running AMD modules in node via RequireJS (it works for optimizer use though). Depending on the module being shimmed, it may fail in Node because Node does not have the same global environment as browsers. As of RequireJS 2.1.7, it will warn you in the console that shim config is not supported, and it may or may not work. If you wish to suppress that message, you can pass &lt;code&gt;requirejs.config({ suppress: { nodeShim: true }});&lt;/code&gt;.</source>
          <target state="translated">RequireJS를 통해 노드에서 AMD 모듈을 실행할 때는 Shim 구성이 지원되지 않습니다 (최적화 사용을 위해 작동 함). shimm되는 모듈에 따라 Node와 브라우저의 전역 환경이 같지 않기 때문에 Node에서 실패 할 수 있습니다. RequireJS 2.1.7부터는 콘솔에서 shim config가 지원되지 않으며 작동하지 않을 수도 있음을 경고합니다. 해당 메시지를 표시하지 않으려면 &lt;code&gt;requirejs.config({ suppress: { nodeShim: true }});&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e449b95be2fea702382b47ae55a5f9733158675f" translate="yes" xml:space="preserve">
          <source>Similarly, to avoid a bunch of configuration, it is best to avoid deep folder hierarchies for scripts, and instead either keep all the scripts in baseUrl, or if you want to separate your library/vendor-supplied code from your app code, use a directory layout like this:</source>
          <target state="translated">마찬가지로 많은 구성을 피하려면 스크립트의 딥 폴더 계층 구조를 피하고 대신 모든 스크립트를 baseUrl에 유지하거나 라이브러리 / 공급 업체 제공 코드를 앱 코드와 분리하려면 다음과 같은 디렉토리 레이아웃 :</target>
        </trans-unit>
        <trans-unit id="0632c0bc11dc47cc43ee33aff39b70f96ab057b5" translate="yes" xml:space="preserve">
          <source>Simple Name/Value Pairs</source>
          <target state="translated">간단한 이름 / 값 쌍</target>
        </trans-unit>
        <trans-unit id="c430387334d60a570098cede5519da79215c2b16" translate="yes" xml:space="preserve">
          <source>Since &quot;require&quot; is a reserved dependency name, you create a &quot;requireLib&quot; dependency and map it to the require.js file.</source>
          <target state="translated">&quot;require&quot;는 예약 된 종속성 이름이므로 &quot;requireLib&quot;종속성을 작성하고 require.js 파일에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="dc83d3c0ed853600c8e42ef6d4d34068151435ec" translate="yes" xml:space="preserve">
          <source>Since DOM ready is a common application need, ideally the nested functions in the API above could be avoided. The domReady module also implements the &lt;a href=&quot;plugins&quot;&gt;Loader Plugin API&lt;/a&gt;, so you can use the loader plugin syntax (notice the &lt;b&gt;!&lt;/b&gt; in the domReady dependency) to force the require() callback function to wait for the DOM to be ready before executing.</source>
          <target state="translated">DOM ready는 일반적인 애플리케이션 요구이므로, 이상적으로 API의 중첩 함수는 피할 수 있습니다. domReady 모듈은 &lt;a href=&quot;plugins&quot;&gt;Loader Plugin API&lt;/a&gt; 도 구현 하므로 loader 플러그인 구문 ( domReady 종속성에서 &lt;b&gt;!&lt;/b&gt; 에 주목 )을 사용하여 require () 콜백 함수가 DOM이 실행되기 전에 준비 될 때까지 대기하도록 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c10d513247ddb5f7d6111dfbb3f09b80b710d8" translate="yes" xml:space="preserve">
          <source>Since the number of browsers that cannot support this toString() scanning is very small, it is safe to use this sugared form for all your modules, particularly if you like to line up the dependency names with the variables that will hold their module values.</source>
          <target state="translated">이 toString () 스캐닝을 지원할 수없는 브라우저의 수가 매우 적기 때문에, 특히 모듈 값을 보유 할 변수로 종속성 이름을 정렬하려는 경우 모든 모듈에이 설탕 양식을 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="52b854694bd5e5771964d6aeb56b3122adca21f7" translate="yes" xml:space="preserve">
          <source>So if you want to support Internet Explorer, catch load errors, and have modular code either through direct define() calls or shim config, always set &lt;b&gt;enforceDefine&lt;/b&gt; to be true. See the next section for an example.</source>
          <target state="translated">따라서 Internet Explorer를 지원하고로드 오류를 포착하고 직접 define () 호출 또는 shim 구성을 통해 모듈 식 코드를 사용 하려면 항상 &lt;b&gt;enforceDefine&lt;/b&gt; 을 true로 설정 &lt;b&gt;하십시오&lt;/b&gt; . 예제는 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="adb1e49d3b56382dbb3da8e1388589dbfdb6edd8" translate="yes" xml:space="preserve">
          <source>So it is very difficult with IE to allow both anonymous AMD modules, which are a core benefit of AMD modules, and reliable detect errors.</source>
          <target state="translated">따라서 IE에서는 AMD 모듈의 핵심 이점 인 익명의 AMD 모듈과 안정적인 감지 오류를 모두 허용하는 것이 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="ed198cdf72a10321f902977a45fe3402f281e373" translate="yes" xml:space="preserve">
          <source>So to reiterate, you will likely get an error if you refer to jQuery with another module name, like &lt;code&gt;'lib/jquery'&lt;/code&gt;. &lt;strong&gt;This example will not work&lt;/strong&gt;:</source>
          <target state="translated">다시 &lt;code&gt;'lib/jquery'&lt;/code&gt; 와 같은 다른 모듈 이름으로 jQuery를 참조하면 오류가 발생합니다 . &lt;strong&gt;이 예제는 작동하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7584d5a05b7d1c094e8b77096a5d326613084abd" translate="yes" xml:space="preserve">
          <source>So we need to know the dependencies and make sure we load them before executing our script. The best way to do that is construct our module loading API with function wrappers. Like so:</source>
          <target state="translated">따라서 스크립트를 실행하기 전에 종속성을 알고로드해야합니다. 가장 좋은 방법은 함수 래퍼로 모듈 로딩 API를 구성하는 것입니다. 이렇게 :</target>
        </trans-unit>
        <trans-unit id="ca7eb5272fcc04433bcc053cb2963d977963db96" translate="yes" xml:space="preserve">
          <source>So, the plugin's module name comes before the ! separator. The part after the ! separator is called the &lt;b&gt;resource name&lt;/b&gt;. The resource name may look like a normal module name. The plugin's module name can be any valid module name, so for instance, you could use a relative indicator:</source>
          <target state="translated">따라서 플러그인의 모듈 이름은! 앞에옵니다. 분리 기호. 후 부분! 분리자를 &lt;b&gt;자원 이름&lt;/b&gt; 이라고합니다 . 리소스 이름은 일반 모듈 이름처럼 보일 수 있습니다. 플러그인의 모듈 이름은 유효한 모듈 이름 일 수 있으므로 예를 들어 상대 표시기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="5b1c2f328244970b14a382cc8a349babf5b6d91c" translate="yes" xml:space="preserve">
          <source>Some environments do not allow eval().</source>
          <target state="translated">일부 환경에서는 eval ()을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07007bf416c3f4f988e538292cbda2590016887c" translate="yes" xml:space="preserve">
          <source>Some notes about using a pluginBuilder:</source>
          <target state="translated">pluginBuilder 사용에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="eec270a80e28815db46c4a348f8a91f7a7d65008" translate="yes" xml:space="preserve">
          <source>Some plugins may do an async operation in the browser, but opt to complete the resource load synchronously when run in Node/Nashorn. This is what the text plugin does. If you just want to run AMD modules and load plugin dependencies using &lt;a href=&quot;http://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; in Node, those also need to complete synchronously to match Node's synchronous module system.</source>
          <target state="translated">일부 플러그인은 브라우저에서 비동기 작업을 수행 할 수 있지만 Node / Nashorn에서 실행될 때 리소스로드를 동 기적으로 완료하도록 선택합니다. 이것이 텍스트 플러그인의 기능입니다. 노드에서 &lt;a href=&quot;http://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; 을 사용하여 AMD 모듈을 실행하고 플러그인 종속성을로드하려는 경우 노드의 동기 모듈 시스템과 일치하도록 동기식으로 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="481dc38cae68c948e1d659f3b1dcfb25af737ad5" translate="yes" xml:space="preserve">
          <source>Some plugins may do an async operation in the browser, but opt to complete the resource load synchronously when run in Node/Nashorn. This is what the text plugin does. If you just want to run AMD modules and load plugin dependencies using &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; in Node, those also need to complete synchronously to match Node's synchronous module system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98e0c339cb5123126f2c87c4e5f5e975fbf4182" translate="yes" xml:space="preserve">
          <source>Some plugins may need to evaluate some JavaScript that was retrieved as text, and use that evaluated JavaScript as the value for the resource. There is a function off the onload() argument, &lt;strong&gt;onload.fromText()&lt;/strong&gt;, that can be used to evaluate the JavaScript. eval() is used by RequireJS to evaluate that JavaScript, and RequireJS will do the right work for any anonymous define() call in the evaluated text, and use that define() module as the value for the resource.</source>
          <target state="translated">일부 플러그인은 텍스트로 검색된 일부 JavaScript를 평가하고이를 평가 한 JavaScript를 자원의 값으로 사용해야합니다. JavaScript를 평가하는 데 사용할 수있는 onload () 인수 &lt;strong&gt;onload.fromText ()&lt;/strong&gt; 에서 함수 가 있습니다. eval ()은 RequireJS에서 JavaScript를 평가하는 데 사용되며, RequireJS는 평가 된 텍스트에서 익명의 define () 호출에 대해 올바른 작업을 수행하고 해당 define () 모듈을 자원의 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a77096861b93dda4c39daec387e1adc8966cb7b0" translate="yes" xml:space="preserve">
          <source>Some sort of #include/import/require</source>
          <target state="translated">일종의 # include / import / require</target>
        </trans-unit>
        <trans-unit id="bd025dec7c9eed165679f96d5db69313b876152d" translate="yes" xml:space="preserve">
          <source>Some types of circular dependencies.</source>
          <target state="translated">일부 유형의 순환 종속성</target>
        </trans-unit>
        <trans-unit id="d937f64e544eafc99471358c2faba19abd5ae90a" translate="yes" xml:space="preserve">
          <source>Something similar is possible with paths config, but it is much wordier, and the paths config route does not allow loader plugin resource IDs in its configuration, since the paths config values are path segments, not IDs.</source>
          <target state="translated">paths 구성에서는 이와 유사한 것이 가능하지만 훨씬 더 복잡하며 paths 구성 경로는 구성에서 로더 플러그인 자원 ID를 허용하지 않습니다. paths 구성 값은 ID가 아닌 경로 세그먼트이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="30e86ffbe954826823e73c12cfc55bea76005dff" translate="yes" xml:space="preserve">
          <source>Source maps</source>
          <target state="translated">소스 맵</target>
        </trans-unit>
        <trans-unit id="821968db542d3c05ea3a4f2fcda630b7acc0474b" translate="yes" xml:space="preserve">
          <source>Specify a JSONP Service Dependency</source>
          <target state="translated">JSONP 서비스 종속성 지정</target>
        </trans-unit>
        <trans-unit id="578a43d52c70e40530d94cddc8363ce456449172" translate="yes" xml:space="preserve">
          <source>Specify a Text File Dependency</source>
          <target state="translated">텍스트 파일 종속성 지정</target>
        </trans-unit>
        <trans-unit id="d76e7ed422b0495466015a46e070fb6f00448162" translate="yes" xml:space="preserve">
          <source>Starts with a &quot;/&quot;.</source>
          <target state="translated">&quot;/&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7e371c122fa82685d7671b68016968141187d2ec" translate="yes" xml:space="preserve">
          <source>Sugar</source>
          <target state="translated">Sugar</target>
        </trans-unit>
        <trans-unit id="8f97776b7c626d7c787bc588e92f2b2b737f5f55" translate="yes" xml:space="preserve">
          <source>Supported configuration options:</source>
          <target state="translated">지원되는 구성 옵션 :</target>
        </trans-unit>
        <trans-unit id="1d3251f0fb778fe3a355e2f1674b59fed9ce6f5e" translate="yes" xml:space="preserve">
          <source>That config states: modules 'main', 'util', 'text' and 'text!template.html' will be found by loading module ID 'primary'. Module 'text!secondary.html' can be found by loading module ID 'secondary'.</source>
          <target state="translated">해당 구성 상태는 모듈 ID 'primary'를로드하여 'main', 'util', 'text'및 'text! template.html'모듈을 찾습니다. 모듈 'text! secondary.html'은 모듈 ID 'secondary'를로드하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66f7f17f0623e2b899f65569369b3f96996b2778" translate="yes" xml:space="preserve">
          <source>That type of module relies on attaching properties to the global object to export the module value, and it is difficult to declare dependencies with this model. The dependencies are assumed to be immediately available when this function executes. This limits the loading strategies for the dependencies.</source>
          <target state="translated">해당 유형의 모듈은 전역 값을 속성에 첨부하여 모듈 값을 내보내는 데 의존하므로이 모델과의 종속성을 선언하기가 어렵습니다. 이 함수가 실행될 때 종속성이 즉시 사용 가능한 것으로 가정합니다. 이는 종속성에 대한로드 전략을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="4b5f14ad5e1dddfd4e78fad824cde3595b71d76f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;index!&lt;/b&gt; plugin could be written like so:</source>
          <target state="translated">&lt;b&gt;인덱스! &lt;/b&gt;플러그인은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9079b459ee168c30bd095d64a00af0fccaf64255" translate="yes" xml:space="preserve">
          <source>The AMD execution model is better aligned with how ECMAScript Harmony modules are being specified. The CommonJS modules that would not work in an AMD wrapper will also not work as a Harmony module. AMD's code execution behavior is more future compatible.</source>
          <target state="translated">AMD 실행 모델은 ECMAScript Harmony 모듈을 지정하는 방법에 더 적합합니다. AMD 랩퍼에서 작동하지 않는 CommonJS 모듈도 하모니 모듈로 작동하지 않습니다. AMD의 코드 실행 동작은 미래에 더 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="0ea1b57a9458b65d966c291b92a6e5f40f3e9499" translate="yes" xml:space="preserve">
          <source>The AMD format comes from wanting a module format that was better than today's &quot;write a bunch of script tags with implicit dependencies that you have to manually order&quot; and something that was easy to use directly in the browser. Something with good debugging characteristics that did not require server-specific tooling to get started. It grew out of Dojo's real world experience with using XHR+eval and wanting to avoid its weaknesses for the future.</source>
          <target state="translated">AMD 형식은 오늘날의 &quot;수동으로 주문해야하는 암시 적 종속성으로 여러 스크립트 태그를 작성하는 것&quot;과 브라우저에서 직접 사용하기 쉬운 것보다 더 나은 모듈 형식을 원합니다. 서버 특정 툴링을 시작할 필요가없는 디버깅 특성이 좋은 것. XHR + eval을 사용하고 미래에 대한 약점을 피하려는 Dojo의 실제 경험에서 나왔습니다.</target>
        </trans-unit>
        <trans-unit id="c808a506a2b1a1d3a8441fd50fe8872a13558f0e" translate="yes" xml:space="preserve">
          <source>The AMD loader will parse out the require('') calls by using Function.prototype.toString(), then internally convert the above define call into this:</source>
          <target state="translated">AMD 로더는 Function.prototype.toString ()을 사용하여 require ( '') 호출을 구문 분석 한 다음 내부적으로 위의 정의 호출을 다음으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="11a4dc84c9d70c7ea727b71031d89d8fdc9c59e5" translate="yes" xml:space="preserve">
          <source>The CJS module format only allowed one module per file, so a &quot;transport format&quot; would be used for bundling more than one module in a file for optimization/bundling purposes.</source>
          <target state="translated">CJS 모듈 형식은 파일 당 하나의 모듈 만 허용하므로 최적화 / 번들링 목적으로 파일에 둘 이상의 모듈을 묶는 데 &quot;전송 형식&quot;이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="a39ad20def9de6ddadb36d4488aeb74ca38ea578" translate="yes" xml:space="preserve">
          <source>The RequireJS optimizer, as of version 1.0.3, will strip out the use of 'amdefine' above, so it is safe to use this module for your web-based projects too. Just be sure to use &lt;strong&gt;the exact 'amdefine' if() test and contents as shown above&lt;/strong&gt;. Differences in spaces/line breaks are allowed. See the &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine project&lt;/a&gt; for more information.</source>
          <target state="translated">버전 1.0.3부터 RequireJS 옵티마이 저는 위의 'amdefine'사용을 제거하므로 웹 기반 프로젝트에도이 모듈을 사용하는 것이 안전합니다. &lt;strong&gt;위와 같이 정확한 'amdefine'if () 테스트 및 내용&lt;/strong&gt; 을 사용해야 &lt;strong&gt;합니다&lt;/strong&gt; . 공백 / 줄 바꿈의 차이가 허용됩니다. 자세한 정보는 &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine 프로젝트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b330aa0f4d280892b5122f26adc82cf344b78ceb" translate="yes" xml:space="preserve">
          <source>The RequireJS syntax for modules allows them to be loaded as fast as possible, even out of order, but evaluated in the correct dependency order, and since global variables are not created, it makes it possible to &lt;a href=&quot;#multiversion&quot;&gt;load multiple versions of a module in a page&lt;/a&gt;.</source>
          <target state="translated">모듈의 RequireJS 구문을 사용하면 순서에 관계없이 가능한 한 빨리로드 할 수 있지만 올바른 종속성 순서로 평가할 수 있으며 전역 변수가 작성되지 않으므로 &lt;a href=&quot;#multiversion&quot;&gt;페이지에서 여러 버전의 모듈&lt;/a&gt; 을 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ef05a888778e04dcbd6355136af94fe3f21ee10" translate="yes" xml:space="preserve">
          <source>The RequireJS wiki has a longer &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;list of plugins&lt;/a&gt;.</source>
          <target state="translated">RequireJS 위키에는 더 긴 &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;플러그인 목록이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10037c39cb0572d4517b7b19be7e3b6e476d3924" translate="yes" xml:space="preserve">
          <source>The Web Today</source>
          <target state="translated">오늘날의 웹</target>
        </trans-unit>
        <trans-unit id="d6f95b126d877e46f4ca85d50dfc9f3c59e1b78b" translate="yes" xml:space="preserve">
          <source>The above AMD example works in all browsers. However, there is a risk of mismatched dependency names with named function arguments, and it can start to look a bit strange if your module has many dependencies:</source>
          <target state="translated">위의 AMD 예제는 모든 브라우저에서 작동합니다. 그러나 이름이 지정된 함수 인수와 종속성 이름이 일치하지 않을 위험이 있으며 모듈에 많은 종속성이 있으면 조금 이상하게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea71ad89663a3826e96822644f48226e30ddba03" translate="yes" xml:space="preserve">
          <source>The above pattern for detecting a load failure, undef()ing a module, modifying paths and reloading is a common enough request that there is also a shorthand for it. The paths config allows array values:</source>
          <target state="translated">로드 실패를 감지하고, 모듈을 undef ()하고, 경로를 수정하고 다시로드하기위한 위의 패턴은 일반적으로 필요한 약식입니다. 경로 설정은 배열 값을 허용합니다 :</target>
        </trans-unit>
        <trans-unit id="86f2b9664fdda056e416ecb6be7e43754e30ec9f" translate="yes" xml:space="preserve">
          <source>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</source>
          <target state="translated">baseUrl은 require.js를로드 할 페이지와 다른 도메인의 URL 일 수 있습니다. RequireJS 스크립트 로딩은 여러 도메인에서 작동합니다. 텍스트로로드 된 텍스트 내용에 대한 유일한 제한 사항입니다! 플러그인 : 해당 경로는 최소한 개발 중에 페이지와 동일한 도메인에 있어야합니다. 최적화 도구는 텍스트를 인라인합니다! 최적화 도구를 사용한 후에는 텍스트를 참조하는 리소스를 사용할 수 있습니다. 다른 도메인의 플러그인 리소스</target>
        </trans-unit>
        <trans-unit id="188d96d93a522f85db45464063c57eeed54c2581" translate="yes" xml:space="preserve">
          <source>The biggest time drain is minification. If you are just doing builds as part of a dev workflow, then set &lt;strong&gt;optimize&lt;/strong&gt; to &lt;code&gt;&quot;none&quot;&lt;/code&gt;.</source>
          <target state="translated">가장 큰 시간 소모는 최소화입니다. 개발자 워크 플로의 일부로 빌드를 수행하는 경우 &lt;strong&gt;optimize&lt;/strong&gt; 를 &lt;code&gt;&quot;none&quot;&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="833cfb3d9133e355fe39d334558fdb889f46740f" translate="yes" xml:space="preserve">
          <source>The complete Plugin API:</source>
          <target state="translated">완전한 플러그인 API :</target>
        </trans-unit>
        <trans-unit id="fbf24dab70c96ad5b4a4111826b377d63c4b7d93" translate="yes" xml:space="preserve">
          <source>The contents of that file should look like so:</source>
          <target state="translated">해당 파일의 내용은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="57689d439b992bc5af51a359d8f6310514b900ad" translate="yes" xml:space="preserve">
          <source>The data-main attribute is a special attribute that require.js will check to start script loading:</source>
          <target state="translated">data-main 속성은 require.js가 스크립트 로딩을 시작하기 위해 확인하는 특수 속성입니다.</target>
        </trans-unit>
        <trans-unit id="7f1d6700235d757014c048a09c5572615308e47e" translate="yes" xml:space="preserve">
          <source>The default for the optimizer is for &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; to be true. So if using &lt;strong&gt;generateSourceMaps&lt;/strong&gt;, then explicitly set &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; to false. If you want to preserve some license comments, you can manually modify the license comments in the JS source to use the JSDoc-style &lt;code&gt;@license&lt;/code&gt; comment. See &quot;&lt;a href=&quot;https://developers.google.com/closure/compiler/docs/js-for-compiler#tag-license&quot;&gt;Annotating JavaScript for the Closure Compiler&lt;/a&gt;&quot; for more information. That same format works for UglifyJS2.</source>
          <target state="translated">옵티마이 저의 기본값은 &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; 가 true입니다. 그래서 사용하는 경우 &lt;strong&gt;generateSourceMaps을&lt;/strong&gt; 다음 명시 적으로 설정 &lt;strong&gt;preserveLicenseComments을&lt;/strong&gt; false로. 일부 라이센스 주석을 유지하려면 JSDoc 스타일 &lt;code&gt;@license&lt;/code&gt; 주석 을 사용하도록 JS 소스에서 라이센스 주석을 수동으로 수정할 수 있습니다 . 자세한 내용은 &quot; &lt;a href=&quot;https://developers.google.com/closure/compiler/docs/js-for-compiler#tag-license&quot;&gt;클로저 컴파일러의 JavaScript 주석&lt;/a&gt; &quot;을 참조하십시오. 동일한 형식이 UglifyJS2에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ed208f1f847352477d5ff2c440d221d28e46603f" translate="yes" xml:space="preserve">
          <source>The default for the optimizer is to do the safest, most robust set of actions that avoid surprises after a build. However, depending on your project setup, you may want to turn off some of these features to get faster builds:</source>
          <target state="translated">옵티마이 저의 기본값은 빌드 후 놀라움을 피하는 가장 안전하고 강력한 조치를 수행하는 것입니다. 그러나 프로젝트 설정에 따라 더 빠른 빌드를 위해 이러한 기능 중 일부를 끄고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7240c5ed21fca9b8654b10aeae53d76526350c3d" translate="yes" xml:space="preserve">
          <source>The dependencies are very weakly stated: the developer needs to know the right dependency order. For instance, The file containing Backbone cannot come before the jQuery tag.</source>
          <target state="translated">종속성은 매우 약하게 설명되어 있습니다. 개발자는 올바른 종속성 순서를 알아야합니다. 예를 들어 Backbone을 포함하는 파일은 jQuery 태그 앞에 올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61bd565a453f9fd7f3247103a42eaddea165cea4" translate="yes" xml:space="preserve">
          <source>The error object passed to errbacks and the global requirejs.onError function will usually contain two custom properties:</source>
          <target state="translated">에러 객체는 errback으로 전달되며 전역 requirejs.onError 함수는 일반적으로 두 가지 사용자 정의 속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="316bf166ecc014ef8bc6882e464ddfb3c066d80a" translate="yes" xml:space="preserve">
          <source>The example above in the &lt;strong&gt;Multiversion Support&lt;/strong&gt; section shows how code can later be loaded by nested require() calls.</source>
          <target state="translated">&lt;strong&gt;멀티 버전 지원&lt;/strong&gt; 섹션의 위 예제 는 나중에 중첩 된 require () 호출로 코드를로드하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2f906ca6df78eb04d4f2471e8af7277fa535310f" translate="yes" xml:space="preserve">
          <source>The examples in this page will assume you downloaded and saved r.js in a directory that is a sibling to your project directory. The optimizer that is part of r.js can live anywhere you want, but you will likely need to adjust the paths accordingly in these examples.</source>
          <target state="translated">이 페이지의 예제에서는 r.js를 프로젝트 디렉토리의 형제 디렉토리에 다운로드하여 저장했다고 가정합니다. r.js의 일부인 옵티마이 저는 원하는 어느 곳에 나있을 수 있지만이 예제에서 경로를 적절하게 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="63f1352f2a22f29f7eba80a7f07fe3640f7c41b3" translate="yes" xml:space="preserve">
          <source>The function call above specifies two arguments, &quot;cart&quot; and &quot;inventory&quot;. These are the modules represented by the &quot;./cart&quot; and &quot;./inventory&quot; module names.</source>
          <target state="translated">위의 함수 호출은 &quot;cart&quot;와 &quot;inventory&quot;라는 두 개의 인수를 지정합니다. &quot;./cart&quot;및 &quot;./inventory&quot;모듈 이름으로 표시되는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="ba297d0cdf6db0dcddbde4f96f4e5f762f3c8d6b" translate="yes" xml:space="preserve">
          <source>The function is not called until the my/cart and my/inventory modules have been loaded, and the function receives the modules as the &quot;cart&quot; and &quot;inventory&quot; arguments.</source>
          <target state="translated">my / cart 및 my / inventory 모듈이로드 될 때까지 함수가 호출되지 않으며 함수는 &quot;cart&quot;및 &quot;inventory&quot;인수로 모듈을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="646d4a9744ff05859b5314213bf0fc732c97dc58" translate="yes" xml:space="preserve">
          <source>The general class of errors are 404s for scripts (not found), network timeouts or errors in the scripts that are loaded. RequireJS has a few tools to deal with them: require-specific errbacks, a &quot;paths&quot; array config, and a global requirejs.onError.</source>
          <target state="translated">일반적인 오류 클래스는 스크립트 (찾을 수 없음), 네트워크 시간 초과 또는로드 된 스크립트의 오류에 대한 404입니다. RequireJS에는이를 처리 할 수있는 몇 가지 도구가 있습니다. 요구 관련 오류, &quot;경로&quot;배열 구성 및 전역 requirejs.onError.</target>
        </trans-unit>
        <trans-unit id="e63c31bbc3167bcd297e7f2c00dc5d691b57b43a" translate="yes" xml:space="preserve">
          <source>The init function will &lt;strong&gt;not&lt;/strong&gt; be called for AMD modules. For example, you cannot use a shim init function to call jQuery's noConflict. See &lt;a href=&quot;jquery#noconflictmap&quot;&gt;Mapping Modules to use noConflict&lt;/a&gt; for an alternate approach to jQuery.</source>
          <target state="translated">init 함수는 AMD 모듈에 대해 호출 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 예를 들어 shim init 함수를 사용하여 jQuery의 noConflict를 호출 할 수 없습니다. jQuery에 대한 대체 접근 방법은 &lt;a href=&quot;jquery#noconflictmap&quot;&gt;noConflict를 사용하도록 모듈 맵핑을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79cd9e532bfc3f909ce1a7cd0b33b3a46f14bfc7" translate="yes" xml:space="preserve">
          <source>The modules that break are ones that do a dynamic calculation of a dependency, anything that does not use a string literal for the require() call, and anything that does not look like a declarative require() call. So things like this fail:</source>
          <target state="translated">중단되는 모듈은 종속성의 동적 계산, require () 호출에 문자열 리터럴을 사용하지 않는 것, 선언적인 require () 호출처럼 보이지 않는 것입니다. 따라서 이와 같은 것은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3015edf1d8929053306c224b7504d1c821a6e9f9" translate="yes" xml:space="preserve">
          <source>The my/lamps module has one property called &quot;testMessage&quot; that uses colors.red to show the localized value for the color red.</source>
          <target state="translated">my / lamps 모듈에는 colors.red를 사용하여 빨간색으로 지역화 된 값을 표시하는 &quot;testMessage&quot;라는 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c2c7d55feef0ee5662cbb414805068c6cae379" translate="yes" xml:space="preserve">
          <source>The node module also exposes the RequireJS Optimizer as an &lt;strong&gt;optimize&lt;/strong&gt; method for using the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt; via a function call instead of a command line tool:</source>
          <target state="translated">또한 노드 모듈 은 명령 줄 도구 대신 함수 호출을 통해 &lt;a href=&quot;optimization&quot;&gt;RequireJS 최적화 프로그램&lt;/a&gt; 을 사용하기위한 &lt;strong&gt;최적화&lt;/strong&gt; 방법으로 RequireJS 최적화 프로그램 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6350be35e53443e7abedf9e1bacdc3773be517cd" translate="yes" xml:space="preserve">
          <source>The optimizer can be run using Node, Java with Rhino or Nashorn, or in the browser. The requirements for each option:</source>
          <target state="translated">Optimizer는 Node, Java with Rhino 또는 Nashorn을 사용하거나 브라우저에서 실행할 수 있습니다. 각 옵션의 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="4d2c07d263378d0346f09b22f277d0d3e406cae7" translate="yes" xml:space="preserve">
          <source>The optimizer can take care of optimizing all the CSS and JS files in your project by using a build profile.</source>
          <target state="translated">최적화 프로그램은 빌드 프로파일을 사용하여 프로젝트의 모든 CSS 및 JS 파일을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9597937557a9085898a43c6059a1eebe7339fa9" translate="yes" xml:space="preserve">
          <source>The optimizer cannot load network resources, so if you want it included in the build, be sure to create a &lt;a href=&quot;api#config-paths&quot;&gt;paths config&lt;/a&gt; to map the file to a module name. Then, for running the optimizer, download the CDN script and pass a paths config to the optimizer that maps the module name to the local file path.</source>
          <target state="translated">옵티마이 저가 네트워크 자원을로드 할 수 없으므로 빌드에 포함 시키려면 파일을 모듈 이름에 맵핑 하는 &lt;a href=&quot;api#config-paths&quot;&gt;경로 구성&lt;/a&gt; 을 작성하십시오 . 그런 다음, 옵티 마이저를 실행하려면 CDN 스크립트를 다운로드하고 모듈 이름을 로컬 파일 경로에 맵핑하는 옵티 마이저에 경로 구성을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="24dc87afb98a25d8ecbaf32f04ae2ac2d6d3a749" translate="yes" xml:space="preserve">
          <source>The optimizer has supported &lt;a href=&quot;https://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/&quot;&gt;sourceURL&lt;/a&gt; (by setting &lt;strong&gt;useSourceUrl&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;), for debugging combined modules as individual files. However, that only works with non-minified code. Source maps translate a minified file to a non-minified version. It does not make sense to use useSourceUrl with generateSourceMaps since useSourceUrl needs the source values as strings, which prohibits the useful minification done in combination with generateSourceMaps.</source>
          <target state="translated">최적화 프로그램은 결합 된 모듈을 개별 파일로 디버깅 하기 위해 &lt;a href=&quot;https://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/&quot;&gt;sourceURL&lt;/a&gt; ( &lt;strong&gt;useSourceUrl&lt;/strong&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 ) 을 지원했습니다 . 그러나 그것은 축소되지 않은 코드에서만 작동합니다. 소스 맵은 축소 된 파일을 축소되지 않은 버전으로 변환합니다. useSourceUrl은 소스 값을 문자열로 필요로하므로 generateSourceMaps와 함께 사용하면 유용한 축소가 금지되므로 useSourceUrl을 generateSourceMaps와 함께 사용하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="97adcb3e43739938bb0b24c540239f8776fdf70e" translate="yes" xml:space="preserve">
          <source>The optimizer is part of the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js adapter for Node and Nashorn&lt;/a&gt;, and it is designed to be run as part of a build or packaging step after you are done with development and are ready to deploy the code for your users.</source>
          <target state="translated">옵티마이 저는 &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;Node 및 Nashorn 용 r.js 어댑터의&lt;/a&gt; 일부이며, 개발을 마치고 사용자를 위해 코드를 배포 할 준비가 된 후에 빌드 또는 패키징 단계의 일부로 실행되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4dd7b81667d35089632d3cb2dbefac91d4924a99" translate="yes" xml:space="preserve">
          <source>The optimizer will only combine modules that are specified in arrays of string literals that are passed to top-level require and define calls, or the require('name') string literal calls in a &lt;a href=&quot;whyamd#sugar&quot;&gt;simplified CommonJS wrapping&lt;/a&gt;. So, it will not find modules that are loaded via a variable name:</source>
          <target state="translated">옵티마이 저는 최상위 레벨 require 및 정의 호출에 전달 된 문자열 리터럴 배열에 지정된 모듈 만 &lt;a href=&quot;whyamd#sugar&quot;&gt;단순화&lt;/a&gt; 하거나 CommonJS 랩핑 에서 require ( 'name') 문자열 리터럴 호출을 결합합니다 . 따라서 변수 이름을 통해로드 된 모듈을 찾지 못합니다.</target>
        </trans-unit>
        <trans-unit id="e736ee2d0486212242109d874b9057adc10b369e" translate="yes" xml:space="preserve">
          <source>The original &lt;a href=&quot;http://groups.google.com/group/commonjs&quot;&gt;CommonJS (CJS) list&lt;/a&gt; participants decided to work out a module format that worked with today's JavaScript language, but was not necessarily bound to the limitations of the browser JS environment. The hope was to use some stop-gap measures in the browser and hopefully influence the browser makers to build solutions that would enable their module format to work better natively. The stop-gap measures:</source>
          <target state="translated">최초의 &lt;a href=&quot;http://groups.google.com/group/commonjs&quot;&gt;CommonJS (CJS) 목록&lt;/a&gt; 참가자는 오늘날의 JavaScript 언어와 호환되는 모듈 형식을 결정하기로 결정했지만 브라우저 JS 환경의 한계에 반드시 구속되는 것은 아닙니다. 브라우저에서 일부 스톱 갭 (stop-gap) 측정을 사용하고 브라우저 제작자들이 모듈 형식이 기본적으로 더 잘 작동 할 수있는 솔루션을 빌드하도록 영향을 미치기를 희망했습니다. 스톱 갭 측정 :</target>
        </trans-unit>
        <trans-unit id="49726bf75802c1e0d2ae363b06e8ab652be497a7" translate="yes" xml:space="preserve">
          <source>The original &lt;a href=&quot;https://groups.google.com/group/commonjs&quot;&gt;CommonJS (CJS) list&lt;/a&gt; participants decided to work out a module format that worked with today's JavaScript language, but was not necessarily bound to the limitations of the browser JS environment. The hope was to use some stop-gap measures in the browser and hopefully influence the browser makers to build solutions that would enable their module format to work better natively. The stop-gap measures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ffd664aad13e13f0e39499785339e02cc90784" translate="yes" xml:space="preserve">
          <source>The other (recommended) solution is to just name the file 'jquery.js' and place it in the baseUrl directory. Then the above paths entry is not needed.</source>
          <target state="translated">다른 (권장) 솔루션은 파일 이름을 'jquery.js'로 지정하고 baseUrl 디렉토리에 배치하는 것입니다. 그런 다음 위의 경로 입력이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8db7c7e84d06e02e54baf98a25cf84663fe34ff" translate="yes" xml:space="preserve">
          <source>The package config can specify the following properties for a specific package:</source>
          <target state="translated">패키지 구성은 특정 패키지에 대해 다음 특성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d157456a6adc4bf429c0462916d2f169f00d2d" translate="yes" xml:space="preserve">
          <source>The path configuration for a module is incorrect. Check the &quot;Net&quot; or &quot;Network&quot; tab in the browser's developer tools to see if there was a 404 for an URL that would map to the module name. Make sure the script file is in the right place. In some cases you may need to use the &lt;a href=&quot;api#config&quot;&gt;paths configuration&lt;/a&gt; to fix the URL resolution for the script.</source>
          <target state="translated">모듈의 경로 구성이 올바르지 않습니다. 브라우저의 개발자 도구에서 &quot;Net&quot;또는 &quot;Network&quot;탭을 확인하여 모듈 이름에 매핑되는 URL에 대한 404가 있는지 확인하십시오. 스크립트 파일이 올바른 위치에 있는지 확인하십시오. 경우에 따라 &lt;a href=&quot;api#config&quot;&gt;경로 구성&lt;/a&gt; 을 사용 하여 스크립트의 URL 확인을 수정 해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d86259d6a0a722e27d583979961ce1e8aa9945a9" translate="yes" xml:space="preserve">
          <source>The path that is used for a module name should &lt;strong&gt;not&lt;/strong&gt; include an extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path. If &lt;a href=&quot;#modulenotes-urls&quot;&gt;require.toUrl()&lt;/a&gt; is used, it will add the appropriate extension, if it is for something like a text template.</source>
          <target state="translated">경로 이름은 디렉토리에 대한 것일 수 있으므로 모듈 이름에 사용되는 경로 는 확장자를 포함 &lt;strong&gt;하지&lt;/strong&gt; 않아야합니다 . 경로 맵핑 코드는 모듈 이름을 경로에 맵핑 할 때 자동으로 .js 확장자를 추가합니다. 경우 &lt;a href=&quot;#modulenotes-urls&quot;&gt;require.toUrl ()가&lt;/a&gt; 사용됩니다 그것은 텍스트 템플릿 같은 뭔가를하는 경우, 그것은 적절한 확장을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4e91b10b7f7d53ba941c2c7e0e1bb6a153f797cb" translate="yes" xml:space="preserve">
          <source>The paths config was used to set two module IDs to the same file, and that file only has one anonymous module in it. If module IDs &quot;something&quot; and &quot;lib/something&quot; are both configured to point to the same &quot;scripts/libs/something.js&quot; file, and something.js only has one anonymous module in it, this kind of timeout error can occur. The fix is to make sure all module ID references use the same ID (either choose &quot;something&quot; or &quot;lib/something&quot; for all references), or use &lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt;.</source>
          <target state="translated">paths 구성은 두 개의 모듈 ID를 동일한 파일로 설정하는 데 사용되었으며 해당 파일에는 하나의 익명 모듈 만 있습니다. 모듈 ID &quot;something&quot;과 &quot;lib / something&quot;이 모두 동일한 &quot;scripts / libs / something.js&quot;파일을 가리 키도록 구성되고 something.js에 하나의 익명 모듈 만있는 경우 이러한 종류의 시간 초과 오류가 발생할 수 있습니다 . 수정은 모든 모듈 ID 참조가 동일한 ID를 사용하도록하거나 (모든 참조에 대해 &quot;something&quot;또는 &quot;lib / something&quot;을 선택) &lt;a href=&quot;api#config-map&quot;&gt;map config를&lt;/a&gt; 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c0c55e2f25518ff91b12e2171a0f0a388d17bb4d" translate="yes" xml:space="preserve">
          <source>The precedence for config: command line, build profile, mainConfigFile. In other words, the mainConfigFile configuration has the lowest priority.</source>
          <target state="translated">config의 우선 순위 : 명령 행, 빌드 프로파일, mainConfigFile. 즉, mainConfigFile 구성의 우선 순위가 가장 낮습니다.</target>
        </trans-unit>
        <trans-unit id="1242359748292937312acf98b1a6eb87d8a3b11f" translate="yes" xml:space="preserve">
          <source>The previous example with a concatenated require-jquery file</source>
          <target state="translated">연결된 require-jquery 파일이있는 이전 예제</target>
        </trans-unit>
        <trans-unit id="192ab3acce5094758f21a50e14a8da17d6acde2e" translate="yes" xml:space="preserve">
          <source>The r.js optimizer is designed to offer some primitives that can be used for different deployment scenarios by adding other code on top of it. See the &lt;a href=&quot;https://github.com/requirejs/r.js/wiki/Deployment-Techniques&quot;&gt;deployment techniques wiki page&lt;/a&gt; for ideas on how to use the optimizer in that fashion.</source>
          <target state="translated">r.js 최적화 프로그램은 다른 코드를 추가하여 다른 배포 시나리오에 사용할 수있는 기본 형식을 제공하도록 설계되었습니다. 해당 방식으로 최적화 프로그램을 사용하는 방법에 대한 아이디어 는 &lt;a href=&quot;https://github.com/requirejs/r.js/wiki/Deployment-Techniques&quot;&gt;배치 기술 위키 페이지&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2ee0d524bcd6704760b685962eeb8cfaff57213" translate="yes" xml:space="preserve">
          <source>The rest of this page assumes that r.js is just downloaded manually from the download page. It is normally the clearest, most portable way to use the optimizer.</source>
          <target state="translated">이 페이지의 나머지 부분에서는 r.js가 다운로드 페이지에서 수동으로 다운로드 된 것으로 가정합니다. 일반적으로 옵티 마이저를 사용하는 가장 명확하고 휴대하기 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ecf160a12aa61fb012a8b2424316d88aa0e4fd22" translate="yes" xml:space="preserve">
          <source>The return object from the function call defines the &quot;my/shirt&quot; module. By defining modules in this way, &quot;my/shirt&quot; does not exist as a global object.</source>
          <target state="translated">함수 호출의 리턴 오브젝트는 &quot;my / shirt&quot;모듈을 정의합니다. 이런 방식으로 모듈을 정의하면 &quot;my / shirt&quot;가 전역 객체로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c88e63a484581ec383ad067c9875d460057af30" translate="yes" xml:space="preserve">
          <source>The shim config only sets up code relationships. To load modules that are part of or use shim config, a normal require/define call is needed. Setting shim by itself does not trigger code to load.</source>
          <target state="translated">shim 구성은 코드 관계 만 설정합니다. shim 구성의 일부이거나이를 사용하는 모듈을로드하려면 정상적인 요구 / 정의 호출이 필요합니다. shim 만 설정해도 코드가로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5be64048efe7324abe49142f72faeeaaa7e1ca4a" translate="yes" xml:space="preserve">
          <source>The simplified CommonJS wrapper can be used in &lt;a href=&quot;https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/&quot;&gt;Jetpack/Add-on SDK&lt;/a&gt; for Firefox</source>
          <target state="translated">Firefox 용 &lt;a href=&quot;https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/&quot;&gt;Jetpack / Add-on SDK&lt;/a&gt; 에서 단순화 된 CommonJS 래퍼를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="286eeb9d4dd615a5ee96545dccd9adba277a55b2" translate="yes" xml:space="preserve">
          <source>The text! plugin implements write, to write out a string value for the text file that it loaded. A snippet from that file:</source>
          <target state="translated">텍스트! 플러그인은로드 한 텍스트 파일의 문자열 값을 쓰도록 쓰기를 구현합니다. 해당 파일의 스 니펫 :</target>
        </trans-unit>
        <trans-unit id="c439d72b6a34f9f0ba042a5650c9c5ee79e4df55" translate="yes" xml:space="preserve">
          <source>The workaround is to just remove the space. This is fixed in the 2.0 code, and may be backported to the 1.0.x series if a 1.0.9 release is done.</source>
          <target state="translated">해결 방법은 공간을 제거하는 것입니다. 이것은 2.0 코드로 수정되었으며 1.0.9 릴리스가 완료되면 1.0.x 시리즈로 백 포트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ec19343751911c72325582b0361861caae8236f" translate="yes" xml:space="preserve">
          <source>Then configure the HTML page to load the main-built.js file instead of main.js by configuring the path used for &quot;main&quot; to be &quot;main-built&quot;:</source>
          <target state="translated">그런 다음 &quot;main&quot;에 사용 된 경로를 &quot;main-built&quot;로 구성하여 main.js 대신 main-built.js 파일을로드하도록 HTML 페이지를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="259d26828f417e2f8c13bd0c6028af122d81b719" translate="yes" xml:space="preserve">
          <source>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</source>
          <target state="translated">그런 다음 my / nls / fr-fr / colors.js에 다음 내용이 포함 된 파일을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="be36ae0eb8667335a927273da0e6ab92b4edcb64" translate="yes" xml:space="preserve">
          <source>Then the RequireJS configuration would look like so:</source>
          <target state="translated">그런 다음 RequireJS 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a910327d077ce4eca13382ba87c8e201b1acd698" translate="yes" xml:space="preserve">
          <source>Then the optimizer will transform the above code sample to:</source>
          <target state="translated">그런 다음 옵티마이 저는 위 코드 샘플을 다음과 같이 변환합니다.</target>
        </trans-unit>
        <trans-unit id="62170f7da0384f803f3a8eb7d89b68cf954fd553" translate="yes" xml:space="preserve">
          <source>Then the value for red in &quot;root&quot; will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</source>
          <target state="translated">그런 다음 &quot;root&quot;의 빨간색 값이 사용됩니다. 이것은 모든 로케일 조각에 적용됩니다. 아래 나열된 모든 번들이 정의 된 경우 RequireJS는 다음 우선 순위 순서로 값을 사용합니다 (맨 위의 항목이 가장 우선 함).</target>
        </trans-unit>
        <trans-unit id="f6cde8d9e24c8b9374a3bdc6f65bb6e76f868f68" translate="yes" xml:space="preserve">
          <source>Then, if you use the default optimize setting of &quot;uglify&quot; in r.js 0.26.0 or later, or if the &lt;b&gt;optimize&lt;/b&gt; setting is set to &quot;closure&quot; (when &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;run under Java&lt;/a&gt;), the minifier will optimize out the dead code branch! So you can do custom builds of your code that are optimized for a set of has() tests.</source>
          <target state="translated">그런 다음 r.js 0.26.0 이상에서 기본 최적화 설정 &quot;uglify&quot;를 사용하거나 &lt;b&gt;최적화&lt;/b&gt; 설정이 &quot;closure&quot;( &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;Java에서 실행될&lt;/a&gt; 때)로 설정된 경우 축소 기는 데드 코드 분기를 최적화합니다. ! 따라서 일련의 has () 테스트에 최적화 된 사용자 지정 코드 빌드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f0e546fbe705942eca29d67bf81ee3c8a7db75d" translate="yes" xml:space="preserve">
          <source>Then, when running the optimizer, use 'empty:' for the paths config:</source>
          <target state="translated">그런 다음 최적화 프로그램을 실행할 때 경로 구성에 'empty :'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="00b6895c862979cc2eba13bb2a4e9203df3d2928" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module&quot;&gt;some patterns for separating the config from main module loading&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module&quot;&gt;메인 모듈 로딩에서 설정을 분리하기위한 몇 가지 패턴&lt;/a&gt; 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c914c8913f0c704632585755ad2fd92421214c70" translate="yes" xml:space="preserve">
          <source>There are a small number of CommonJS modules do not work well as define()-wrapped modules. See the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js README&lt;/a&gt;</source>
          <target state="translated">소수의 CommonJS 모듈이 define () 랩핑 된 모듈로 작동하지 않습니다. &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js 읽어&lt;/a&gt; 보기를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="79d96503df59aae56b5b8ba278910ed073296911" translate="yes" xml:space="preserve">
          <source>There are also hidden costs with the CommonJS format:</source>
          <target state="translated">CommonJS 형식에는 숨겨진 비용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e5d4466510ba561a8c62882157f7d3f3f8d4f6" translate="yes" xml:space="preserve">
          <source>There are some CommonJS systems, mainly Node, that allow setting the exported value by assigning the exported value as module.exports. That idiom is supported by RequireJS, but there is another, easier way -- just return the value from the function passed to &lt;strong&gt;define&lt;/strong&gt;:</source>
          <target state="translated">내 보낸 값을 module.exports로 지정하여 내 보낸 값을 설정할 수있는 일부 CommonJS 시스템 (주로 노드)이 있습니다. 이 관용구는 RequireJS에서 지원하지만, 더 쉬운 또 다른 방법이 있습니다. &lt;strong&gt;정의&lt;/strong&gt; 하기 위해 전달 된 함수에서 값을 반환하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="db7bc183023059aacc1b28ac85497f6757932ed2" translate="yes" xml:space="preserve">
          <source>There are two ways to get the Node adapter:</source>
          <target state="translated">노드 어댑터를 얻는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82b7a30d627e088df9f0dc5d7ebd9889f9e8c88" translate="yes" xml:space="preserve">
          <source>There is a &lt;strong&gt;limitation&lt;/strong&gt; on the command line argument syntax. Dots are viewed as object property separators, to allow something like &lt;code&gt;paths.jquery=lib/jquery&lt;/code&gt; to be transformed to the following in the optimizer:</source>
          <target state="translated">명령 행 인수 구문 에는 &lt;strong&gt;제한&lt;/strong&gt; 이 있습니다 . 점은 객체 속성 구분자로 표시되어 &lt;code&gt;paths.jquery=lib/jquery&lt;/code&gt; 와 같은 것이 최적화 프로그램에서 다음과 같이 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49ed2d13d62753769d4a3e4b16bbff6caf763443" translate="yes" xml:space="preserve">
          <source>There is a bit more involved than just the above snippet, but that is the basic idea. This approach has the advantage over document.write in that it will not block page rendering and it works after page load.</source>
          <target state="translated">위의 스 니펫보다 조금 더 관련이 있지만 기본 아이디어입니다. 이 방법은 페이지 렌더링을 차단하지 않으며 페이지로드 후 작동한다는 점에서 document.write에 비해 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1195ff6977b15b525b4fb9026d68e10938839170" translate="yes" xml:space="preserve">
          <source>There is a global function, &lt;b&gt;requirejs.undef()&lt;/b&gt;, that allows undefining a module. It will reset the loader's internal state to forget about the previous definition of the module.</source>
          <target state="translated">모듈을 정의 할 수 없는 글로벌 함수 &lt;b&gt;requirejs.undef ()&lt;/b&gt; 가 있습니다. 로더의 내부 상태를 재설정하여 모듈의 이전 정의를 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="19b7fe5cd5ae02fb158a358fbe1b88a6534c1ae6" translate="yes" xml:space="preserve">
          <source>There is also support for a &quot;*&quot; map value which means &quot;for all modules loaded, use this map config&quot;. If there is a more specific map config, that one will take precedence over the star config. Example:</source>
          <target state="translated">&quot;*&quot;맵 값도 지원합니다. &quot;로드 된 모든 모듈에 대해이 맵 구성 사용&quot;을 의미합니다. 보다 구체적인 맵 구성이있는 경우 해당 맵 구성이 스타 구성보다 우선합니다. 예:</target>
        </trans-unit>
        <trans-unit id="cf8ab1380352baedf713333d3304b748679a3eaa" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js&quot;&gt;example.build.js&lt;/a&gt; file in the requirejs/build directory that details all of the allowed optimizer configuration options.</source>
          <target state="translated">requirejs / build 디렉토리에는 허용 된 모든 옵티 마이저 구성 옵션을 자세히 설명 하는 &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js&quot;&gt;example.build.js&lt;/a&gt; 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a8e51faef4350fa51a39f9fddc9216e1cdff43" translate="yes" xml:space="preserve">
          <source>There may be times when you do want to reference a script directly and not conform to the &quot;baseUrl + paths&quot; rules for finding it. If a module ID has one of the following characteristics, the ID will not be passed through the &quot;baseUrl + paths&quot; configuration, and just be treated like a regular URL that is relative to the document:</source>
          <target state="translated">스크립트를 직접 참조하고 &quot;baseUrl + paths&quot;규칙을 따르지 않는 경우가 있습니다. 모듈 ID가 다음 특성 중 하나를 갖는 경우 ID는 &quot;baseUrl + paths&quot;구성을 통과하지 않고 문서와 관련된 일반 URL처럼 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="15a0d6c1171150ff1ab728d8563c6ef03f5aeb87" translate="yes" xml:space="preserve">
          <source>There should only be &lt;strong&gt;one&lt;/strong&gt; module definition per file on disk. The modules can be grouped into optimized bundles by the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt;.</source>
          <target state="translated">디스크의 파일 당 &lt;strong&gt;하나의&lt;/strong&gt; 모듈 정의 만 있어야합니다 . &lt;a href=&quot;optimization&quot;&gt;최적화 도구를 사용&lt;/a&gt; 하여 모듈을 최적화 된 번들로 그룹화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9aafa4f6a11dfb424aaf808dc827232de9516114" translate="yes" xml:space="preserve">
          <source>There should only be at most &lt;strong&gt;one IO action for each module&lt;/strong&gt;, and it should be straightforward. Web browsers are not tolerant of multiple IO lookups to find a module. This argues against the multiple path lookups that Node does now, and avoiding the use of a package.json &quot;main&quot; property. Just use module names that map easily to one location based on the project's location, using a reasonable default convention that does not require verbose configuration, but allow for simple configuration when needed.</source>
          <target state="translated">&lt;strong&gt;각 모듈마다&lt;/strong&gt; 최대 &lt;strong&gt;하나의 IO 동작&lt;/strong&gt; 이 있어야하며 간단해야합니다. 웹 브라우저는 모듈을 찾기 위해 여러 IO 조회를 허용하지 않습니다. 이것은 Node가 지금 수행하는 다중 경로 조회와는 반대이며 package.json &quot;main&quot;속성의 사용을 피합니다. 자세한 구성이 필요하지 않지만 필요한 경우 간단한 구성을 허용하는 합리적인 기본 규칙을 사용하여 프로젝트 위치를 기반으로 한 위치에 쉽게 매핑되는 모듈 이름 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdfa1e7131c14d32efb9df0bc08c01be59e54bd9" translate="yes" xml:space="preserve">
          <source>There was a script error in one of the listed modules. If there is no script error in the browser's error console, and if you are using Firebug, try loading the page in another browser like Chrome or Safari. Sometimes script errors do not show up in Firebug.</source>
          <target state="translated">나열된 모듈 중 하나에 스크립트 오류가 발생했습니다. 브라우저의 오류 콘솔에 스크립트 오류가없고 Firebug를 사용중인 경우 Chrome 또는 Safari와 같은 다른 브라우저에 페이지를로드하십시오. 때로는 스크립트 오류가 Firebug에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="468caacfedf05ebd845bad705ed5482dfe20bd36" translate="yes" xml:space="preserve">
          <source>These are normally generated by the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt;. You can explicitly name modules yourself, but it makes the modules less portable -- if you move the file to another directory you will need to change the name. It is normally best to avoid coding in a name for the module and just let the optimization tool burn in the module names. The optimization tool needs to add the names so that more than one module can be bundled in a file, to allow for faster loading in the browser.</source>
          <target state="translated">이것들은 일반적으로 &lt;a href=&quot;optimization&quot;&gt;최적화 도구에&lt;/a&gt; 의해 생성됩니다 . 모듈 이름을 명시 적으로 지정할 수 있지만 모듈의 이식성이 떨어집니다. 파일을 다른 디렉토리로 이동하면 이름을 변경해야합니다. 일반적으로 모듈 이름으로 코딩하는 것을 피하고 최적화 도구가 모듈 이름으로 구워 지도록하는 것이 가장 좋습니다. 브라우저에서 더 빠르게로드 할 수 있도록 최적화 도구는 파일에 둘 이상의 모듈을 번들 할 수 있도록 이름을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="98b4938725e5a5341b6305461362cc0477d874b0" translate="yes" xml:space="preserve">
          <source>These cases are handled by the &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;, &lt;code&gt;require([moduleName], function (){})&lt;/code&gt; normally present in AMD loaders.</source>
          <target state="translated">이러한 경우는 일반적으로 AMD 로더 에있는 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt; , &lt;code&gt;require([moduleName], function (){})&lt;/code&gt; 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="a79accd25478216f5822c8a4c6bf603479d9922e" translate="yes" xml:space="preserve">
          <source>These instructions assume an npm installation of 'requirejs'. If you are using the r.js file directly, replace require('requirejs') with require('./path/to/r.js'). Basic usage is:</source>
          <target state="translated">이 지침에서는 npm 설치 'requirejs'를 가정합니다. r.js 파일을 직접 사용하는 경우 require ( 'requirejs')를 require ( './ path / to / r.js')로 바꾸십시오. 기본 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16b53404d787cd045723983e31d60ff96d23db07" translate="yes" xml:space="preserve">
          <source>Thinking about the problem.</source>
          <target state="translated">문제에 대한 생각.</target>
        </trans-unit>
        <trans-unit id="380032a22f9c26e6024b670111955c2798e616e2" translate="yes" xml:space="preserve">
          <source>This above code will try the CDN location, but if that fails, fall back to the local lib/jquery.js location.</source>
          <target state="translated">위의 코드는 CDN 위치를 시도하지만 실패하면 로컬 lib / jquery.js 위치로 폴백합니다.</target>
        </trans-unit>
        <trans-unit id="49752fc8bf27c03316c7e59051f18837913b9909" translate="yes" xml:space="preserve">
          <source>This allows the loader to load dependency1 and dependency2 asynchronously, execute those dependencies, then execute this function.</source>
          <target state="translated">이를 통해 로더는 dependency1 및 dependency2를 비동기 적으로로드하고 해당 종속성을 실행 한 다음이 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ddedef1b43d7b8525f6b0973e7a8d964d29e5e0" translate="yes" xml:space="preserve">
          <source>This allows you to build other optimization workflows, like &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/build/tests/http&quot;&gt;a web builder&lt;/a&gt; that can be used if you prefer to always develop with the &quot;one script file included before the &amp;lt;/body&amp;gt; tag&quot; approach. The optimizer running in Node is fairly fast, but for larger projects that do not want to regenerate the build for every browser request, but just if you modify a script that is part of the build. You could use Node's fs.watchFile() to watch files and then trigger the build when a file changes.</source>
          <target state="translated">이를 통해 항상 &quot;&amp;lt;/ body&amp;gt; 태그 앞에 포함 된 하나의 스크립트 파일&quot;접근 방식으로 개발하려는 경우 사용할 수 &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/build/tests/http&quot;&gt;있는 웹 빌더&lt;/a&gt; 와 같은 다른 최적화 워크 플로우를 작성할 수 있습니다. Node에서 실행되는 옵티마이 저는 상당히 빠르지 만 모든 브라우저 요청에 대해 빌드를 재생성하지 않고 빌드의 일부인 스크립트를 수정하는 대규모 프로젝트에 적합합니다. Node의 fs.watchFile ()을 사용하여 파일을보고 파일이 변경되면 빌드를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b65d4f771bf52e95454a2cd0ee5bb01541e3c07" translate="yes" xml:space="preserve">
          <source>This behavior allows dynamic loading of modules even after optimization. You can always explicitly add modules that are not found via the optimizer's static analysis by using the &lt;strong&gt;include&lt;/strong&gt; option.</source>
          <target state="translated">이 동작을 통해 최적화 후에도 모듈을 동적으로로드 할 수 있습니다. &lt;strong&gt;include&lt;/strong&gt; 옵션 을 사용하여 옵티마이 저의 정적 분석을 통해 찾을 수없는 모듈을 항상 명시 적으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c2186e1d7918e19fbd7e4fbea3be0565cf286b9" translate="yes" xml:space="preserve">
          <source>This build profile tells RequireJS to copy all of &lt;strong&gt;appdirectory&lt;/strong&gt; to a sibling directory called &lt;strong&gt;appdirectory-build&lt;/strong&gt; and apply all the optimizations in the &lt;strong&gt;appdirectory-build&lt;/strong&gt; directory. It is strongly suggested you use a different output directory than the source directory -- otherwise bad things will likely happen as the optimizer overwrites your source.</source>
          <target state="translated">이 빌드 프로파일은 RequireJS에 모든 &lt;strong&gt;appdirectory&lt;/strong&gt; 를 &lt;strong&gt;appdirectory-build&lt;/strong&gt; 라는 형제 디렉토리 에 복사 하고 &lt;strong&gt;appdirectory-build&lt;/strong&gt; 디렉토리 에 모든 최적화를 적용하도록 &lt;strong&gt;지시&lt;/strong&gt; 합니다. 소스 디렉토리와 다른 출력 디렉토리를 사용하는 것이 좋습니다. 그렇지 않으면 옵티마이 저가 소스를 겹쳐 쓰면 나쁜 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e9d0c26ff83452cfff825256989fd861112776" translate="yes" xml:space="preserve">
          <source>This can be difficult to manage on large projects, particularly as scripts start to have many dependencies in a way that may overlap and nest. Hand-writing script tags is not very scalable, and it leaves out the capability to load scripts on demand.</source>
          <target state="translated">특히 스크립트가 겹치거나 중첩 될 수있는 방식으로 많은 종속성이 있기 때문에 대규모 프로젝트에서는 관리하기가 어려울 수 있습니다. 필기 스크립트 태그는 확장 성이 뛰어나며 필요할 때 스크립트를로드하는 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f1d8dae4f31129d18ce4fad1393977e24dba9d8" translate="yes" xml:space="preserve">
          <source>This error may not show up in IE, just other browsers, and instead, in IE you may see the &lt;a href=&quot;#nodefine&quot;&gt;No define call for ...&lt;/a&gt; error when you see &quot;Script error&quot;. This is due to &lt;a href=&quot;api#ieloadfail&quot;&gt;IE's quirks in detecting script errors&lt;/a&gt;.</source>
          <target state="translated">이 오류는 IE, 다른 브라우저에만 표시되지 않을 수 있습니다. 대신 IE에서는 &quot;스크립트 오류&quot; 가 표시되면 &lt;a href=&quot;#nodefine&quot;&gt;No define call for ...&lt;/a&gt; 오류가 표시 될 수 있습니다. 이것은 &lt;a href=&quot;api#ieloadfail&quot;&gt;스크립트 오류를 ​​감지하는 IE의 단점&lt;/a&gt; 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="ea2ee18c32fb715b5f3e2c96e54faac7bfe81e43" translate="yes" xml:space="preserve">
          <source>This error occurs when the optimizer encounters a path to a module or script which is a network path. The optimizer only allows building with local resources. To fix it:</source>
          <target state="translated">이 오류는 옵티마이 저가 네트워크 경로 인 모듈 또는 스크립트에 대한 경로를 발견 할 때 발생합니다. 최적화 프로그램은 로컬 자원으로 만 빌드 할 수 있습니다. 그것을 해결하기 위해:</target>
        </trans-unit>
        <trans-unit id="108ce34bf7d5c20a79f2d5aa7de03e6a1873c06c" translate="yes" xml:space="preserve">
          <source>This error only shows up in some IE browsers. Most likely caused by loading a script that calls define() but was loaded in a plain script tag or via some other call, like an eval() of a JavaScript string.</source>
          <target state="translated">이 오류는 일부 IE 브라우저에서만 나타납니다. define ()을 호출하지만 일반 스크립트 태그 또는 JavaScript 문자열의 eval ()과 같은 다른 호출을 통해로드 된 스크립트를로드했을 때 발생했을 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="de7406078370325ab6a57dde8efdcf94e3a45238" translate="yes" xml:space="preserve">
          <source>This example should illustrate the basic problem for the browser. Suppose we have an Employee object and we want a Manager object to derive from the Employee object. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy&quot;&gt;Taking this example&lt;/a&gt;, we might code it up like this using our script loading API:</source>
          <target state="translated">이 예제는 브라우저의 기본 문제를 보여줍니다. Employee 객체가 있고 Employee 객체에서 Manager 객체를 파생한다고 가정합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy&quot;&gt;이 예제를&lt;/a&gt; 사용하면 스크립트 로딩 API를 사용하여 다음과 같이 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bfc2a8f38484617acf67685853c4317495387bb" translate="yes" xml:space="preserve">
          <source>This example shows how to use the &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; to specify dependencies for jQuery plugins that do not call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt;. This example is useful if you have an existing jQuery project you want to convert and do not want to modify the sources of the jQuery plugins to call define().</source>
          <target state="translated">이 예제는 &lt;a href=&quot;api#config-shim&quot;&gt;shim 구성&lt;/a&gt; 을 사용하여 &lt;a href=&quot;api#define&quot;&gt;define ()을&lt;/a&gt; 호출하지 않는 jQuery 플러그인에 대한 종속성을 지정 하는 방법을 보여줍니다 . 이 예제는 변환하려는 기존 jQuery 프로젝트가 있고 define ()을 호출하도록 jQuery 플러그인의 소스를 수정하지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="961683c2e345f519a690d1fef03102383240f8dc" translate="yes" xml:space="preserve">
          <source>This fails because requirejs needs to be sure to load and execute all dependencies before calling the factory function above. If a dependency array is given to define(), then requirejs assumes that all dependencies are listed in that array, and it will not scan the factory function for other dependencies. So, either do not pass in the dependency array, or if using the dependency array, list all the dependencies in it.</source>
          <target state="translated">위의 팩토리 함수를 호출하기 전에 requirejs가 모든 종속성을로드하고 실행해야하기 때문에 실패합니다. 종속성 배열이 define ()에 제공되면 requirejs는 모든 종속성이 해당 배열에 나열되어 있다고 가정하고 팩토리 함수에서 다른 종속성을 스캔하지 않습니다. 따라서 종속성 배열을 전달하지 않거나 종속성 배열을 사용하는 경우 종속성을 모두 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="023d496162ffcb10b7cee76e6630652af2251947" translate="yes" xml:space="preserve">
          <source>This feature only works well for scripts that are real AMD modules that call define() and register as anonymous modules. Also, &lt;strong&gt;only use absolute module IDs&lt;/strong&gt; for map config. Relative IDs (like &lt;code&gt;'../some/thing'&lt;/code&gt;) do not work.</source>
          <target state="translated">이 기능은 define ()을 호출하고 익명 모듈로 등록하는 실제 AMD 모듈 인 스크립트에만 적합합니다. 또한 맵 구성 &lt;strong&gt;에는 절대 모듈 ID 만 사용하십시오&lt;/strong&gt; . 상대 ID (예 : &lt;code&gt;'../some/thing'&lt;/code&gt; )가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59e2e5874b3bfece421a8bffb9d4f0bc76a33cd1" translate="yes" xml:space="preserve">
          <source>This form will use Function.prototype.toString() to find the require() calls, and add them to the dependency array, along with &quot;require&quot;, so the code will work correctly with relative paths.</source>
          <target state="translated">이 형식은 Function.prototype.toString ()을 사용하여 require () 호출을 찾아서 &quot;require&quot;와 함께 종속성 배열에 추가하므로 코드가 상대 경로와 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e8ed70de90f1dd1e9ab06535ec8d2f6b33f8586d" translate="yes" xml:space="preserve">
          <source>This function also contains a property function, &lt;b&gt;write.asModule(moduleName, fileName, text)&lt;/b&gt;. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(&quot;&quot;) dependencies that need to be pulled out for the optimized file.</source>
          <target state="translated">이 함수에는 속성 함수 &lt;b&gt;write.asModule (moduleName, fileName, text)&lt;/b&gt; 도 포함되어 있습니다 . asModule은 이름 삽입이 필요하거나 최적화 된 파일을 위해 꺼내야하는 암시 적 require ( &quot;&quot;) 종속성을 포함하는 익명의 정의 호출이있을 수있는 모듈을 작성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d2cf725c69b1eebada5d75140b90dfb091161d" translate="yes" xml:space="preserve">
          <source>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</source>
          <target state="translated">이 기능은 실시간 스트리밍을 처리하는 API 인 장기 폴링 JSONP 연결에 사용해서는 안됩니다. 이러한 종류의 API는 각 응답을받은 후 더 많은 스크립트 정리를 수행해야하며 RequireJS는 JSONP URL을 한 번만 가져옵니다. require () 또는 define () 호출의 종속성과 동일한 URL을 사용하면 캐시 된 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e89c5e06d3af4319ae091f80dd3551a4bc45ff27" translate="yes" xml:space="preserve">
          <source>This is an example on how to load an optimize your code while loading jQuery from a &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network&lt;/a&gt; (CDN). This example requires all your jQuery plugins to call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt; to properly express their dependencies. &lt;a href=&quot;api#config-shim&quot;&gt;Shim config&lt;/a&gt; does not work after optimization builds with CDN resources.</source>
          <target state="translated">다음은 CDN ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network)&lt;/a&gt; 에서 jQuery를로드하는 동안 코드 최적화를로드하는 방법에 대한 예입니다 . 이 예제에서는 모든 jQuery 플러그인이 &lt;a href=&quot;api#define&quot;&gt;define ()&lt;/a&gt; 을 호출 하여 종속성을 올바르게 표현해야합니다. CDN 리소스를 사용한 최적화 빌드 후에 &lt;a href=&quot;api#config-shim&quot;&gt;Shim 구성&lt;/a&gt; 이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c45233a38eed42b024ceb6884edbdad4d0bc54c" translate="yes" xml:space="preserve">
          <source>This is an example on how to load an optimize your code while loading jQuery from a &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network&lt;/a&gt; (CDN). This example requires all your jQuery plugins to call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt; to properly express their dependencies. &lt;a href=&quot;api#config-shim&quot;&gt;Shim config&lt;/a&gt; does not work after optimization builds with CDN resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ccd67f04bf3d8be2fc0d6f03574cd28eb692e8" translate="yes" xml:space="preserve">
          <source>This is because the config settings for a build can be very different, with multiple optimization targets. So a separate set of config options need to be specified for the optimizer.</source>
          <target state="translated">여러 최적화 대상으로 빌드의 구성 설정이 매우 다를 수 있기 때문입니다. 따라서 옵티 마이저에 대해 별도의 구성 옵션 세트를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c08ad2236b0738d01b1e87a814f05cd47dfb7993" translate="yes" xml:space="preserve">
          <source>This is not possible with the &lt;a href=&quot;#multiversion&quot;&gt;context-backed multiversion support&lt;/a&gt;. In addition, the &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt; is only for setting up root paths for module IDs, not for mapping one module ID to another one.</source>
          <target state="translated">&lt;a href=&quot;#multiversion&quot;&gt;컨텍스트 기반 멀티 버전 지원&lt;/a&gt; 에서는 불가능합니다 . 또한 &lt;a href=&quot;#config-paths&quot;&gt;paths 구성&lt;/a&gt; 은 모듈 ID에 대한 루트 경로를 설정하기위한 것이며 하나의 모듈 ID를 다른 모듈 ID에 매핑하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dbd4ac4ce622f942627879025300deca09f57bd3" translate="yes" xml:space="preserve">
          <source>This means that any module which uses jQuery will need to use the AMD return value rather than depending on the global $:</source>
          <target state="translated">즉, jQuery를 사용하는 모든 모듈은 전역 $에 의존하지 않고 AMD 반환 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="660aa1bff65fdcc611a8965c59f57a351f6f7cd7" translate="yes" xml:space="preserve">
          <source>This occurs when enforceDefine is set to true, and a script that is loaded either:</source>
          <target state="translated">enforceDefine이 true로 설정되고 다음 중 하나가로드 된 스크립트가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f289c4df7b00d5edd870e53e404ebd6b7af70cdb" translate="yes" xml:space="preserve">
          <source>This occurs when the script.onerror function is triggered in a browser. This usually means there is a JavaScript syntax error or other execution problem running the script. To fix it, examine the script that generated the error in a script debugger.</source>
          <target state="translated">브라우저에서 script.onerror 함수가 트리거 될 때 발생합니다. 이는 일반적으로 스크립트 실행 중 JavaScript 구문 오류 또는 기타 실행 문제가 있음을 의미합니다. 이를 해결하려면 스크립트 디버거에서 오류를 생성 한 스크립트를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="6aada266dc2b34a31cd1025b898441e43473ae95" translate="yes" xml:space="preserve">
          <source>This occurs when there is a call like:</source>
          <target state="translated">다음과 같은 호출이있을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="928706501045c1df1973346d9b52dc67e9760f4b" translate="yes" xml:space="preserve">
          <source>This occurs when there is a require('name') call, but the 'name' module has not been loaded yet.</source>
          <target state="translated">require ( 'name') 호출이 있지만 'name'모듈이 아직로드되지 않은 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d5a19ba0ac3512b99642760d7832ca4bbfdbf103" translate="yes" xml:space="preserve">
          <source>This only sets up where to find a module inside a script that has multiple define()'d modules in it. It does not automatically bind those modules to the bundle's module ID. The bundle's module ID is just used for locating the set of modules.</source>
          <target state="translated">이것은 여러 개의 define () 모듈이있는 스크립트 내에서 모듈을 찾을 위치를 설정합니다. 해당 모듈을 번들의 모듈 ID에 자동으로 바인딩하지 않습니다. 번들의 모듈 ID는 모듈 세트를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ff463f5c13219de083a5b986d24729b282c0b63" translate="yes" xml:space="preserve">
          <source>This option will install the latest release.</source>
          <target state="translated">이 옵션은 최신 릴리스를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="3080e3b4e7305b7a390be280a008f2efaa8b0dce" translate="yes" xml:space="preserve">
          <source>This page discusses why modules on the web are useful and the mechanisms that can be used on the web today to enable them. There is a separate page that talks about &lt;a href=&quot;whyamd&quot;&gt;the design forces&lt;/a&gt; for the particular function wrapped format used by RequireJS.</source>
          <target state="translated">이 페이지에서는 웹의 모듈이 유용한 이유와 오늘날 웹에서 사용할 수있는 메커니즘에 대해 설명합니다. RequireJS가 사용하는 특정 함수 랩핑 형식 &lt;a href=&quot;whyamd&quot;&gt;의 설계 력&lt;/a&gt; 에 대해 설명하는 별도의 페이지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c32b7767b663c9b112dbfb1a72ec9435610f40c" translate="yes" xml:space="preserve">
          <source>This page lists errors that are generated by RequireJS. If the following information does not fix the problem, you can ask on the &lt;a href=&quot;https://groups.google.com/group/requirejs&quot;&gt;RequireJS list&lt;/a&gt; or &lt;a href=&quot;https://github.com/requirejs/requirejs/issues&quot;&gt;open an issue&lt;/a&gt;. In either case it is best to have an example or detailed explanation of the problem, hopefully with steps to reproduce.</source>
          <target state="translated">이 페이지에는 RequireJS에서 생성 된 오류가 나열되어 있습니다. 다음 정보로 문제가 해결되지 않으면 &lt;a href=&quot;https://groups.google.com/group/requirejs&quot;&gt;RequireJS 목록을&lt;/a&gt; 요청 하거나 &lt;a href=&quot;https://github.com/requirejs/requirejs/issues&quot;&gt;문제를 열 ​​수&lt;/a&gt; 있습니다. 두 경우 모두 문제를 재현하기위한 단계와 함께 문제에 대한 예나 자세한 설명을하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d329b7fabff8549e3864ca1c943467a2e9c50ff6" translate="yes" xml:space="preserve">
          <source>This page talks about the design forces and use of the &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;Asynchronous Module Definition (AMD) API&lt;/a&gt; for JavaScript modules, the module API supported by RequireJS. There is a different page that talks about &lt;a href=&quot;why&quot;&gt;general approach to modules on the web&lt;/a&gt;.</source>
          <target state="translated">이 페이지 에서는 RequireJS에서 지원하는 모듈 API 인 JavaScript 모듈 용 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD (Asynchronous Module Definition) API&lt;/a&gt; 의 설계 및 사용에 대해 설명 합니다. &lt;a href=&quot;why&quot;&gt;웹의 모듈에&lt;/a&gt; 대한 일반적인 접근 방식에 대한 다른 페이지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7547edb3cbad1a453ea3d817f5a0c1d8a4736ba" translate="yes" xml:space="preserve">
          <source>This sort of capability is really important for larger projects which may have two sets of modules that need to use two different versions of 'foo', but they still need to cooperate with each other.</source>
          <target state="translated">이러한 종류의 기능은 두 개의 다른 버전의 'foo'를 사용해야하는 두 개의 모듈 세트가있을 수있는 대규모 프로젝트에는 실제로 중요하지만 여전히 서로 협력해야합니다.</target>
        </trans-unit>
        <trans-unit id="0667b0a681c9b05158e69aa153c3649764124d9b" translate="yes" xml:space="preserve">
          <source>This type of syntax was chosen because it is terse and allows the loader to use head.appendChild(script) type of loading.</source>
          <target state="translated">이 유형의 구문은 간결하고 로더가 head.appendChild (script) 유형의 로딩을 사용할 수 있기 때문에 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="7fbbc6fb221c91b49f8258b96647211b9f95e5f7" translate="yes" xml:space="preserve">
          <source>This use of JSONP should be limited to JSONP services for initial application setup. If the JSONP service times out, it means other modules you define via define() may not get executed, so the error handling is not robust.</source>
          <target state="translated">이러한 JSONP 사용은 초기 애플리케이션 설정을 위해 JSONP 서비스로 제한되어야합니다. JSONP 서비스가 시간 초과되면 define ()을 통해 정의한 다른 모듈이 실행되지 않을 수 있으므로 오류 처리가 강력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c1fda79acd078a4d1f652fe39b9fd5add1ef63f" translate="yes" xml:space="preserve">
          <source>This will create a file called &lt;strong&gt;appdirectory/css/main-build.css&lt;/strong&gt; that will include the contents of main.css, have the url() paths properly adjusted, and have comments removed.</source>
          <target state="translated">이렇게하면 main.css의 내용을 포함하고 url () 경로를 적절히 조정하며 주석을 제거하는 &lt;strong&gt;appdirectory / css / main-build.css&lt;/strong&gt; 라는 파일이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="ef9cf9d96109395280b1d0122aae6bddc9d67c04" translate="yes" xml:space="preserve">
          <source>This will create a file called &lt;strong&gt;appdirectory/scripts/main-built.js&lt;/strong&gt; that will include the contents of main.js, one.js, two.js and three.js.</source>
          <target state="translated">그러면 main.js, one.js, two.js 및 three.js의 내용을 포함하는 &lt;strong&gt;appdirectory / scripts / main-built.js&lt;/strong&gt; 라는 파일이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="a1edb6163d3cb5d334a5064291a25cbd6b030b50" translate="yes" xml:space="preserve">
          <source>This will instruct require.js to load scripts/main.js. &lt;strong&gt;main.js&lt;/strong&gt; uses the &quot;packages&quot; config to set up packages that are relative to require.js, which in this case are the source packages &quot;cart&quot; and &quot;store&quot;:</source>
          <target state="translated">그러면 require.js가 scripts / main.js를로드하도록 지시합니다. &lt;strong&gt;main.js&lt;/strong&gt; 는 &quot;packages&quot;구성을 사용하여 require.js와 관련된 패키지를 설정합니다.이 경우 소스 패키지 &quot;cart&quot;및 &quot;store&quot;는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c5b1c3af64e803c47342d3ad7896c9f28af8c07" translate="yes" xml:space="preserve">
          <source>This wrapper relies on Function.prototype.toString() to give a useful string value of the function contents. This does not work on some devices like the PS3 and some older Opera mobile browsers. Use the &lt;a href=&quot;optimization&quot;&gt;optimizer&lt;/a&gt; to pull out the dependencies in the array format for use on those devices.</source>
          <target state="translated">이 랩퍼는 Function.prototype.toString ()을 사용하여 함수 내용의 유용한 문자열 값을 제공합니다. PS3와 같은 일부 장치 및 일부 이전 Opera 모바일 브라우저에서는 작동하지 않습니다. 사용 &lt;a href=&quot;optimization&quot;&gt;최적화를&lt;/a&gt; 해당 장치에서 사용하기 위해 배열 형식으로 종속성을 꺼내.</target>
        </trans-unit>
        <trans-unit id="4ea26143e34ae9633403f4fd5a98ac5694f88e74" translate="yes" xml:space="preserve">
          <source>Those IE behaviors result in &lt;a href=&quot;api#ieloadfail&quot;&gt;IE's quirks in detecting script errors&lt;/a&gt;.</source>
          <target state="translated">이러한 IE 동작으로 &lt;a href=&quot;api#ieloadfail&quot;&gt;인해 스크립트 오류를 ​​감지하는 데 IE의 단점이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac488f97d42aa2e61a9ce4a064fafcf5bd478c2a" translate="yes" xml:space="preserve">
          <source>Threw a JavaScript syntax/evaluation error.</source>
          <target state="translated">JavaScript 구문 / 평가 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="96453b3268c65bdfaf0b098f61bbc13d247c2512" translate="yes" xml:space="preserve">
          <source>To avoid the error, be sure to load all scripts that call define via the RequireJS API.</source>
          <target state="translated">오류를 피하려면 RequireJS API를 통해 define을 호출하는 모든 스크립트를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="45ed3d91f7409c8fcc6de93c3d7c8e6c0d28c524" translate="yes" xml:space="preserve">
          <source>To avoid the error:</source>
          <target state="translated">오류를 피하려면</target>
        </trans-unit>
        <trans-unit id="b81ae61caebc13a78c16e37ec4312cbb3981bf52" translate="yes" xml:space="preserve">
          <source>To avoid verbosity, it is strongly suggested to always use packages that use &quot;main&quot; convention in their structure.</source>
          <target state="translated">자세한 정보를 피하려면 항상 &quot;메인&quot;규칙을 사용하는 패키지를 구조에 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="530150d7bd05dc2c544154697dc2d2ab00652849" translate="yes" xml:space="preserve">
          <source>To define a bundle, put it in a directory called &quot;nls&quot; -- the i18n! plugin assumes a module name with &quot;nls&quot; in it indicates an i18n bundle. The &quot;nls&quot; marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your &quot;my&quot; set of modules, create the directory structure like so:</source>
          <target state="translated">번들을 정의하려면 &quot;nls&quot;라는 디렉토리 (i18n)에 넣으십시오! 플러그인은 &quot;nls&quot;가있는 모듈 이름으로 i18n 번들을 나타냅니다. 이름의 &quot;nls&quot;마커는 i18n 플러그인에 로케일 디렉토리를 예상 할 위치를 알려줍니다 (nls 디렉토리의 직계 자식이어야 함). &quot;my&quot;모듈 세트에 색상 이름 묶음을 제공하려면 다음과 같이 디렉토리 구조를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5e288589ea56ef3a80663c84121f07a74a5ac771" translate="yes" xml:space="preserve">
          <source>To detect errors that are not caught by local errbacks, you can override requirejs.onError():</source>
          <target state="translated">로컬 오류로 인해 발견되지 않은 오류를 감지하려면 requirejs.onError ()를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73a7dcc27c7d6f6895600c807abaff1dd3a1a4f4" translate="yes" xml:space="preserve">
          <source>To enable the source map generation, set &lt;strong&gt;generateSourceMaps&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;. Since the minifier needs to have full control over the minified file to generate the source map, the &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; should be explicitly set to &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;errors#sourcemapcomments&quot;&gt;There is is a way to get some license comments in the minified source though&lt;/a&gt;.</source>
          <target state="translated">소스 맵 생성을 사용하려면 &lt;strong&gt;generateSourceMaps&lt;/strong&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 축소 기는 소스 맵을 생성하기 위해 축소 된 파일을 완전히 제어 해야하므로 &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; 를 명시 적으로 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 . &lt;a href=&quot;errors#sourcemapcomments&quot;&gt;그래도 축소 된 소스에서 일부 라이센스 설명을 얻을 수있는 방법이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e7715057c88fc3ede1f6116ac0416e2c729170f" translate="yes" xml:space="preserve">
          <source>To fix it:</source>
          <target state="translated">그것을 해결하기 위해:</target>
        </trans-unit>
        <trans-unit id="a6b6d7bba93f6e1e868d22c4ce5e8fd401f399ba" translate="yes" xml:space="preserve">
          <source>To make this easier, and to make it easy to do a simple wrapping around CommonJS modules, this form of define is supported, sometimes referred to as &quot;simplified CommonJS wrapping&quot;:</source>
          <target state="translated">이 작업을보다 쉽게하고 CommonJS 모듈 주위에 간단한 줄 바꿈을 쉽게 수행 할 수 있도록하기 위해 다음과 같은 형식의 정의가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="82e845da0003462942d83d91b7eadeddf354717e" translate="yes" xml:space="preserve">
          <source>To run the build, run this command from inside the &lt;strong&gt;appdirectory/scripts&lt;/strong&gt; directory:</source>
          <target state="translated">빌드를 실행하려면 &lt;strong&gt;appdirectory / scripts&lt;/strong&gt; 디렉토리 에서 다음 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="b966b017967eef9b2e7721cf76e9ae536670e6c7" translate="yes" xml:space="preserve">
          <source>To see a more complete example that loads a module via RequireJS but uses Node-native modules for other things, see the &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/tests/node/embedded&quot;&gt;embedded test&lt;/a&gt; in the r.js repo.</source>
          <target state="translated">RequireJS를 통해 모듈을로드하지만 노드 네이티브 모듈을 다른 용도로 사용하는보다 완전한 예를 보려면 r.js 저장소 의 &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/tests/node/embedded&quot;&gt;내장 테스트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd4ac4ae170da9b146e596ddd3711697926708ca" translate="yes" xml:space="preserve">
          <source>To use a JSONP service in RequireJS, specify &quot;define&quot; as the callback parameter's value. This means you can get the value of a JSONP URL as if it was a module definition.</source>
          <target state="translated">RequireJS에서 JSONP 서비스를 사용하려면 콜백 매개 변수 값으로 &quot;define&quot;을 지정하십시오. 즉, JSONP URL의 값을 모듈 정의 인 것처럼 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e6b87677764cd023d6559e51135d23b8537fde7" translate="yes" xml:space="preserve">
          <source>Turbo options</source>
          <target state="translated">터보 옵션</target>
        </trans-unit>
        <trans-unit id="55dd7970fca07c8a75f9aec4ee294f40a4e2c493" translate="yes" xml:space="preserve">
          <source>Undefining a Module</source>
          <target state="translated">모듈 정의</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="4997c3bd4bc74709bc6843fcd14f2bdb1f7ad512" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://npmjs.org&quot;&gt;npm&lt;/a&gt; to install it:</source>
          <target state="translated">&lt;a href=&quot;http://npmjs.org&quot;&gt;npm&lt;/a&gt; 을 사용 하여 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="bd6b9479e460e2b59235dee4fb939136093ae550" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://npmjs.org&quot;&gt;npm&lt;/a&gt; to install it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30513a9146bbc0ebb732f04c610e5cdcb9629b08" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt; either in command line mode or as an &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/tests/http/httpBuild.js&quot;&gt;HTTP service&lt;/a&gt; with the &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;almond AMD shim&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;a href=&quot;optimization&quot;&gt;최적화 RequireJS를&lt;/a&gt; 명령 줄 모드에서 또는으로 중 &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/tests/http/httpBuild.js&quot;&gt;HTTP 서비스&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;아몬드 AMD 심&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c904f7d34df4986bde9381d86c2179b0ac9fd6ef" translate="yes" xml:space="preserve">
          <source>Use the above example setup, if you just wanted to optimize main.css, you could use this command, from inside the &lt;strong&gt;appdirectory/css&lt;/strong&gt; directory:</source>
          <target state="translated">위 예제 설정을 사용하십시오. main.css를 최적화하려는 경우 &lt;strong&gt;appdirectory / css&lt;/strong&gt; 디렉토리 에서이 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67649effa4ce87323ef0aebd844fbda30158f942" translate="yes" xml:space="preserve">
          <source>Use the above example setup, if you just wanted to optimize main.js, you could use this command, from inside the &lt;strong&gt;appdirectory/scripts&lt;/strong&gt; directory:</source>
          <target state="translated">위 예제 설정을 사용하십시오. main.js를 최적화하려는 경우 &lt;strong&gt;appdirectory / scripts&lt;/strong&gt; 디렉토리 에서이 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4a7a353170f8234a34024bafeaef356b8a52975" translate="yes" xml:space="preserve">
          <source>Used by &lt;a href=&quot;http://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 1.8+</source>
          <target state="translated">에서 사용 &lt;a href=&quot;http://getfirebug.com/&quot;&gt;방화범&lt;/a&gt; 1.8 이상</target>
        </trans-unit>
        <trans-unit id="1ab95f8dd9363667edb7c709a2b8b217619a0bdf" translate="yes" xml:space="preserve">
          <source>Used by &lt;a href=&quot;https://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 1.8+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a847f63dd57eec0beb9d1e9525a841568bcd78" translate="yes" xml:space="preserve">
          <source>Used for parts of sites on &lt;a href=&quot;http://www.bbc.co.uk/&quot;&gt;the BBC&lt;/a&gt; (observed by looking at the source, not an official recommendation of AMD/RequireJS)</source>
          <target state="translated">&lt;a href=&quot;http://www.bbc.co.uk/&quot;&gt;BBC&lt;/a&gt; 사이트 일부에 사용 (AMD / RequireJS의 공식 권장 사항이 아닌 소스를 통해 관찰 됨)</target>
        </trans-unit>
        <trans-unit id="676e70a259493e207e5d446865f8b6a8d77c070f" translate="yes" xml:space="preserve">
          <source>Used for parts of sites on &lt;a href=&quot;https://www.bbc.co.uk/&quot;&gt;the BBC&lt;/a&gt; (observed by looking at the source, not an official recommendation of AMD/RequireJS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d41fd422f48e9ed0d3aae94c29bc124059cf2fe" translate="yes" xml:space="preserve">
          <source>Uses the CommonJS practice of string IDs for dependencies. Clear declaration of dependencies and avoids the use of globals.</source>
          <target state="translated">종속성에 대한 CommonJS 문자열 ID 연습을 사용합니다. 종속성을 명확하게 선언하고 전역 사용을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="cfa856e44663f218032ac9363f5587a815abdfb8" translate="yes" xml:space="preserve">
          <source>Using JavaScript functions for encapsulation has been documented as the &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;module pattern&lt;/a&gt;:</source>
          <target state="translated">캡슐화에 JavaScript 함수를 사용하는 것이 &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;모듈 패턴&lt;/a&gt; 으로 문서화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a13efaa4a436994146b35afa81f0dbfea7e1c8c8" translate="yes" xml:space="preserve">
          <source>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</source>
          <target state="translated">동기 로딩이있는 서버 측 JavaScript 환경에서 RequireJS를 사용하는 것은 require.load ()를 재정의하는 것만 큼 쉬워야합니다. 빌드 시스템은이를 수행하며 해당 환경에 대한 require.load 메소드는 build / jslib / requirePatch.js에 있습니다.</target>
        </trans-unit>
        <trans-unit id="289a74aa4c0456df8650ad33e2452d68f57e8d5d" translate="yes" xml:space="preserve">
          <source>Using eval() to evaluate the modules is bad:</source>
          <target state="translated">eval ()을 사용하여 모듈을 평가하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c78edb579e3dbb222f2d259b6740f11757398aac" translate="yes" xml:space="preserve">
          <source>Using script tags with body text set to file text is bad:</source>
          <target state="translated">본문 텍스트가 파일 텍스트로 설정된 스크립트 태그를 사용하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="228d83b80eb38ba23af9f37e0663410934e378f7" translate="yes" xml:space="preserve">
          <source>Using the optimizer as a node module</source>
          <target state="translated">최적화 프로그램을 노드 모듈로 사용</target>
        </trans-unit>
        <trans-unit id="c3fd77222b2e71662b263477d33da9477f3ede5c" translate="yes" xml:space="preserve">
          <source>Verbosity vs. Usefulness</source>
          <target state="translated">자세한 내용과 유용성</target>
        </trans-unit>
        <trans-unit id="508686787ae997d3c41509077c7ba378e743f470" translate="yes" xml:space="preserve">
          <source>Version 2.1.6 and higher have experimental support for &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;. It works for mapping minified, bundled code to unminified, separate modules and only when &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt;. optimize set to &lt;code&gt;&quot;closure&quot;&lt;/code&gt; allows only mapping minified, bundled code to unminified bundled code (closure only available when running under Java with Rhino). The unminified files will show up in the developer tools with a &quot;.src.js&quot; file extension.</source>
          <target state="translated">버전 2.1.6 이상에서는 &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;소스 맵을&lt;/a&gt; 실험적으로 지원 합니다 . &lt;strong&gt;최적화 된&lt;/strong&gt; 번들 코드를 축소되지 않은 개별 모듈에 매핑하고 &lt;strong&gt;optimize&lt;/strong&gt; 가 &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt; 로 설정된 경우에만 작동 합니다. optimize를 &lt;code&gt;&quot;closure&quot;&lt;/code&gt; 로 설정하면 축소 된 번들 코드를 축소되지 않은 번들 코드로만 매핑 할 수 있습니다 (closure는 Java로 Rhino에서 실행할 때만 사용 가능). 축소되지 않은 파일은 &quot;.src.js&quot;파일 확장자를 가진 개발자 도구에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5f620e812b7700803d72b13ad0b2acfd35653cef" translate="yes" xml:space="preserve">
          <source>Version 2.1.6 and higher have experimental support for &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;. It works for mapping minified, bundled code to unminified, separate modules and only when &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt;. optimize set to &lt;code&gt;&quot;closure&quot;&lt;/code&gt; allows only mapping minified, bundled code to unminified bundled code (closure only available when running under Java with Rhino). The unminified files will show up in the developer tools with a &quot;.src.js&quot; file extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ca0f4365b0300cd8d135ed858b5f4630b5f824" translate="yes" xml:space="preserve">
          <source>We also want some sort of syntax that will allow loading plain JavaScript files that exist today -- a developer should not have to rewrite all of their JavaScript to get the benefits of script loading.</source>
          <target state="translated">또한 오늘날 존재하는 일반 JavaScript 파일을로드 할 수있는 일종의 구문을 원합니다. 개발자는 스크립트 로딩의 이점을 얻기 위해 모든 JavaScript를 다시 작성할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="289b86ce1649fa4f7108b9c4b6021d64ea08c079" translate="yes" xml:space="preserve">
          <source>We can create scripts on demand and add them to the head:</source>
          <target state="translated">요청시 스크립트를 작성하여 헤드에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ec9bf7282d39f1ec2d480df5541aa3df59aee1" translate="yes" xml:space="preserve">
          <source>Web Worker Support</source>
          <target state="translated">웹 워커 지원</target>
        </trans-unit>
        <trans-unit id="2e99e1a486438cbb3065bc99ce45e9c7f8d976a6" translate="yes" xml:space="preserve">
          <source>Web Workers might be another way to load scripts, but:</source>
          <target state="translated">웹 워커는 스크립트를로드하는 또 다른 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dc2b7a514c40d738fcb40c24966fdd35b7ab44e" translate="yes" xml:space="preserve">
          <source>Web sites are turning into Web apps</source>
          <target state="translated">웹 사이트가 웹 앱으로 바뀌고 있습니다</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">할 수있는 일</target>
        </trans-unit>
        <trans-unit id="d2b9d5645e3e29755ed6d5e5bd23b5476467de76" translate="yes" xml:space="preserve">
          <source>What are JavaScript modules? What is their purpose?</source>
          <target state="translated">JavaScript 모듈이란 무엇입니까? 그들의 목적은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9ba322e4d451d61aa1aa925a8fc046c545b21e05" translate="yes" xml:space="preserve">
          <source>What is important: being able to actually share code with others. AMD is the lowest energy pathway to that goal.</source>
          <target state="translated">중요한 것은 실제로 다른 사람과 코드를 공유 할 수 있다는 것입니다. AMD는 그 목표를 달성하기위한 가장 낮은 에너지 경로입니다.</target>
        </trans-unit>
        <trans-unit id="3069c65b9df09bdc25a6487669983185f31b7699" translate="yes" xml:space="preserve">
          <source>When 'some/newmodule' does `require('foo')` it will get the foo1.2.js file, and when 'some/oldmodule' does `require('foo')` it will get the foo1.0.js file.</source>
          <target state="translated">'some / newmodule'이`require ( 'foo')`를 수행하면 foo1.2.js 파일을 얻게되고 'some / oldmodule'이`require ( 'foo')`를 획득하면 foo1.0을 얻게됩니다. js 파일.</target>
        </trans-unit>
        <trans-unit id="13a587a5f71c45fb2a2ee5c7ebede909a0a90ccd" translate="yes" xml:space="preserve">
          <source>When RequireJS is used in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers&quot;&gt;Web Worker&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers#Importing_scripts_and_libraries&quot;&gt;importScripts&lt;/a&gt; is used to load modules. If that call failed for some reason, this error is generated.</source>
          <target state="translated">RequireJS가 사용하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers&quot;&gt;웹 노동자&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers#Importing_scripts_and_libraries&quot;&gt;importScripts는&lt;/a&gt; 부하 모듈에 사용됩니다. 어떤 이유로 해당 호출이 실패하면이 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7fa66298280c020819d91748b0ae9d2ec88742bb" translate="yes" xml:space="preserve">
          <source>When run in a browser, &lt;a href=&quot;#pathsfallbacks&quot;&gt;paths fallbacks&lt;/a&gt; can be specified, to allow trying a load from a CDN location, but falling back to a local location if the CDN location fails to load.</source>
          <target state="translated">브라우저에서 실행할 때 CDN 위치에서로드를 시도하지만 CDN 위치가로드되지 않으면 로컬 위치로 &lt;a href=&quot;#pathsfallbacks&quot;&gt;폴백&lt;/a&gt; 하도록 경로 대체를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45a6bc83259e410831e5ab4ac9eae06192f6fba" translate="yes" xml:space="preserve">
          <source>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</source>
          <target state="translated">최상위 HTML 페이지 (또는 모듈을 정의하지 않은 최상위 스크립트 파일)에서 require ()를 사용하면 구성 객체를 첫 번째 옵션으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d8a8cb4134eda8c65a86351c434df5553a6ead3" translate="yes" xml:space="preserve">
          <source>While RequireJS loads jQuery just like any other dependency, jQuery's wide use and extensive plugin ecosystem mean you'll likely have other scripts in your project that also depend on jQuery. You might approach your jQuery RequireJS configuration differently depending on whether you are starting a new project or whether you are adapting existing code.</source>
          <target state="translated">RequireJS는 다른 종속성과 마찬가지로 jQuery를로드하는 반면, jQuery의 광범위하고 광범위한 플러그인 에코 시스템은 프로젝트에 jQuery에 의존하는 다른 스크립트가있을 수 있음을 의미합니다. 새 프로젝트를 시작하는지 또는 기존 코드를 적용하고 있는지에 따라 jQuery RequireJS 구성에 다르게 접근 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a365eae40482509c1f0aa1f29bc4a4bfcd1a236" translate="yes" xml:space="preserve">
          <source>While debugging, the line number you get for an error does not map to the original source file.</source>
          <target state="translated">디버깅하는 동안 오류가 발생하는 줄 번호는 원본 소스 파일에 매핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60d30561ad47c3e2e8a86b25641c43eb2c815a72" translate="yes" xml:space="preserve">
          <source>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the &lt;a href=&quot;commonjs#autoconversion&quot;&gt;CommonJS converter tool&lt;/a&gt; if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</source>
          <target state="translated">패키지는 CommonJS 디렉토리 레이아웃을 가질 수 있지만 모듈 자체는 RequireJS가 이해할 수있는 모듈 형식이어야합니다. 규칙 예외 : r.js 노드 어댑터를 사용하는 경우 모듈은 일반적인 CommonJS 모듈 형식 일 수 있습니다. 기존 CommonJS 모듈을 RequireJS가 사용하는 비동기 모듈 형식으로 변환해야하는 경우 &lt;a href=&quot;commonjs#autoconversion&quot;&gt;CommonJS 변환기 도구를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c7f642c080d5fc3b4f51344f0cf442a310298a7" translate="yes" xml:space="preserve">
          <source>Why AMD?</source>
          <target state="translated">왜 AMD인가?</target>
        </trans-unit>
        <trans-unit id="71369dce19ad499c48f1624383e9218e3dd40601" translate="yes" xml:space="preserve">
          <source>Why Web Modules?</source>
          <target state="translated">왜 웹 모듈인가?</target>
        </trans-unit>
        <trans-unit id="c5f8918743f6d7a09acef8b6e47dcd1fabab011d" translate="yes" xml:space="preserve">
          <source>With `requirejs.undef()`, if you later set up a different config and try to load the same module, the loader will still remember which modules needed that dependency and finish loading them when the newly configured module loads.</source>
          <target state="translated">`requirejs.undef ()`를 사용하여 나중에 다른 구성을 설정하고 동일한 모듈을로드하려고하면 로더는 여전히 어떤 모듈이 해당 종속성이 필요한지 기억하고 새로 구성된 모듈이로드 될 때로드를 완료합니다.</target>
        </trans-unit>
        <trans-unit id="cd9fb2c8cfbcd1191658318a7ea78f5b12fe941e" translate="yes" xml:space="preserve">
          <source>With the local install, you can also &lt;a href=&quot;node#optimizer&quot;&gt;use the optimizer via a function call&lt;/a&gt; inside a node program.</source>
          <target state="translated">로컬 설치에서는 노드 프로그램 내부의 &lt;a href=&quot;node#optimizer&quot;&gt;함수 호출을 통해 옵티 마이저를 사용할&lt;/a&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8debcd1d8b575c073e319ccbee375c82809a4e3" translate="yes" xml:space="preserve">
          <source>With this approach, the CommonJS group was able to work out dependency references and how to deal with circular dependencies, and how to get some properties about the current module. However, they did not fully embrace some things in the browser environment that cannot change but still affect module design:</source>
          <target state="translated">이 접근 방식을 통해 CommonJS 그룹은 종속성 참조와 순환 종속성을 처리하는 방법 및 현재 모듈에 대한 일부 특성을 얻는 방법을 해결할 수있었습니다. 그러나 브라우저 환경에서 변경할 수는 없지만 여전히 모듈 디자인에 영향을 미치는 몇 가지 사항을 완전히 수용하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="6a22952292ff7c2d65a8ad8ea0b53628bf602df7" translate="yes" xml:space="preserve">
          <source>With this approach, then you normally do not need the exports and module function arguments, so you can leave them off the module definition.</source>
          <target state="translated">이 방법을 사용하면 일반적으로 내보내기 및 모듈 함수 인수가 필요하지 않으므로 모듈 정의에서 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2f2f7f294f064bba8074a81bae1e972660489d" translate="yes" xml:space="preserve">
          <source>With this local install, you can run the optimizer by running the &lt;code&gt;r.js&lt;/code&gt; or &lt;code&gt;r.js.cmd&lt;/code&gt; file found in the project's &lt;code&gt;node_modules/.bin&lt;/code&gt; directory.</source>
          <target state="translated">이 로컬 설치를 사용하면 프로젝트의 &lt;code&gt;node_modules/.bin&lt;/code&gt; 디렉토리에 있는 &lt;code&gt;r.js&lt;/code&gt; 또는 &lt;code&gt;r.js.cmd&lt;/code&gt; 파일을 실행하여 최적화 프로그램을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfe5ad7fe6d1924fe8f5873b574afb12bdfa0c42" translate="yes" xml:space="preserve">
          <source>XHR also has issues with cross-domain requests. Some browsers now have cross-domain XHR support, but it is not universal, and IE decided to create a different API object for cross-domain calls, XDomainRequest. More moving parts and more things to get wrong. In particular, you need to be sure to not send any non-standard HTTP headers or there may be another &quot;preflight&quot; request done to make sure the cross-domain access is allowed.</source>
          <target state="translated">XHR에는 도메인 간 요청에도 문제가 있습니다. 일부 브라우저는 이제 도메인 간 XHR을 지원하지만 보편적이지 않으며 IE는 도메인 간 호출 XDomainRequest에 대해 다른 API 객체를 만들기로 결정했습니다. 더 많은 움직이는 부품과 더 많은 것들이 잘못됩니다. 특히 비표준 HTTP 헤더를 보내지 않아야합니다. 그렇지 않으면 도메인 간 액세스가 허용되도록하기 위해 다른 &quot;프리 플라이트&quot;요청이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c2c59b547d0a7ab95d805593077bc3374fcdb4" translate="yes" xml:space="preserve">
          <source>Yes &lt;a href=&quot;http://nodejs.org&quot;&gt;Node&lt;/a&gt; does. That loader uses the CommonJS module format. The CommonJS module format is &lt;a href=&quot;why&quot;&gt;non-optimal for the browser&lt;/a&gt;, and I do not agree with &lt;a href=&quot;http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;some of the trade-offs made in the CommonJS module format&lt;/a&gt;. By using RequireJS on the server, you can use one format for all your modules, whether they are running server side or in the browser. That way you can preserve the speed benefits and easy debugging you get with RequireJS in the browser, and not have to worry about extra translation costs for moving between two formats.</source>
          <target state="translated">예 &lt;a href=&quot;http://nodejs.org&quot;&gt;노드&lt;/a&gt; 는 않습니다. 해당 로더는 CommonJS 모듈 형식을 사용합니다. CommonJS 모듈 형식은 &lt;a href=&quot;why&quot;&gt;브라우저에 최적화되어&lt;/a&gt; 있지 않으며 &lt;a href=&quot;http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;CommonJS 모듈 형식으로 작성된 일부 장단점에&lt;/a&gt; 동의하지 않습니다 . 서버에서 RequireJS를 사용하면 서버 측 또는 브라우저에서 모든 모듈에 대해 하나의 형식을 사용할 수 있습니다. 이렇게하면 브라우저에서 RequireJS를 사용하여 얻을 수있는 속도 이점과 쉬운 디버깅을 유지할 수 있으며 두 형식 간 이동에 따른 추가 번역 비용에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="68f725711a636de1365501f3d51b375b44fb0e6f" translate="yes" xml:space="preserve">
          <source>Yes &lt;a href=&quot;https://nodejs.org&quot;&gt;Node&lt;/a&gt; does. That loader uses the CommonJS module format. The CommonJS module format is &lt;a href=&quot;why&quot;&gt;non-optimal for the browser&lt;/a&gt;, and I do not agree with &lt;a href=&quot;https://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;some of the trade-offs made in the CommonJS module format&lt;/a&gt;. By using RequireJS on the server, you can use one format for all your modules, whether they are running server side or in the browser. That way you can preserve the speed benefits and easy debugging you get with RequireJS in the browser, and not have to worry about extra translation costs for moving between two formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8663ce779c85954c38a5af8306faf37b7880023" translate="yes" xml:space="preserve">
          <source>Yes! The Node adapter for RequireJS, called r.js, will use Node's implementation of require and Node's search paths if the module is not found with the configuration used by RequireJS, so you can continue to use your existing Node-based modules without having to do changes to them.</source>
          <target state="translated">예! r.js라고하는 RequireJS 용 노드 어댑터는 RequireJS에서 사용하는 구성에서 모듈을 찾을 수없는 경우 Node의 require 및 Node 검색 경로 구현을 사용하므로 기존 노드 기반 모듈을 계속 사용할 필요가 없습니다. 그들에게 변화.</target>
        </trans-unit>
        <trans-unit id="ee8947dc57d182a3011ce395532368374e65caa2" translate="yes" xml:space="preserve">
          <source>You can avoid lots of configuration lines by placing the files according to the default ID-to-path convention of &lt;code&gt;baseUrl + moduleID + '.js'&lt;/code&gt;. The examples below show how to set baseUrl to be the directory for third-party, library code, and use one extra paths config for your app code.</source>
          <target state="translated">&lt;code&gt;baseUrl + moduleID + '.js'&lt;/code&gt; 의 기본 ID- 경로 규칙에 따라 파일을 배치하여 많은 구성 행을 피할 수 있습니다 . 아래 예제는 baseUrl을 써드 파티, 라이브러리 코드의 디렉토리로 설정하고 앱 코드에 하나의 추가 경로 구성을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="934837e40083f6a48dd3d019d739d3bb3bd6f17f" translate="yes" xml:space="preserve">
          <source>You can define a &lt;b&gt;has&lt;/b&gt; object in the build config with true or false values for some has() tests, and the optimizer will replace the has() test with the true or false value.</source>
          <target state="translated">일부 has () 테스트에 대해 빌드 구성에서 &lt;b&gt;has&lt;/b&gt; 객체를 true 또는 false 값으로 정의 할 수 있으며 옵티마이 저는 has () 테스트를 true 또는 false 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="0d9092704d3269e06cf75c7384f32aa09d5f3586" translate="yes" xml:space="preserve">
          <source>You can do this by using the &lt;strong&gt;excludeShallow&lt;/strong&gt; option. Using the &lt;a href=&quot;#example&quot;&gt;example setup&lt;/a&gt; above, assume you are currently building out or debugging two.js. You could use this optimization command:</source>
          <target state="translated">&lt;strong&gt;excludeShallow&lt;/strong&gt; 옵션 을 사용하여 &lt;strong&gt;이를&lt;/strong&gt; 수행 할 수 있습니다 . 위 의 &lt;a href=&quot;#example&quot;&gt;예제 설정을&lt;/a&gt; 사용하여 현재 two.js를 빌드하거나 디버깅한다고 가정합니다. 이 최적화 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca244dd9b6be738c5452010e67be2b0c37758fa8" translate="yes" xml:space="preserve">
          <source>You can either specify options on the command line:</source>
          <target state="translated">명령 행에서 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52217d43c25ef584de1ffe0ee00d4d33eea6385" translate="yes" xml:space="preserve">
          <source>You can reference your plugin by putting its module name before a ! in the dependency. For instance, if you create a plugin with the name &quot;foo.js&quot;, you would use it like so:</source>
          <target state="translated">모듈 이름 앞에!를 붙여서 플러그인을 참조 할 수 있습니다. 의존성. 예를 들어, 이름이 &quot;foo.js&quot;인 플러그인을 작성하면 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94af4f0eaff062d0b3e49c77a862fe434306c96d" translate="yes" xml:space="preserve">
          <source>You can see an example of its use by looking at one of the files used in &lt;a href=&quot;http://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;the unit test&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;단위 테스트에&lt;/a&gt; 사용 된 파일 중 하나를 보면 사용 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5ccb7204771be86c6e5d3656d2629fae574f27d" translate="yes" xml:space="preserve">
          <source>You can see an example of its use by looking at one of the files used in &lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;the unit test&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f18da7863e56fdfa33c97e023770bcb1c79817" translate="yes" xml:space="preserve">
          <source>You can then use the above module in another module, say, in a my/lamps.js file:</source>
          <target state="translated">그런 다음 my / lamps.js 파일과 같은 다른 모듈에서 위 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d408cedf635435c4559ea8c022ad45cd120dee1" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#onejs&quot;&gt;one JavaScript file optimization&lt;/a&gt; approach to make your development experience faster. By optimizing all the modules in your project into one file, except the one you are currently developing, you can reload your project quickly in the browser, but still give you the option of fine grained debugging in a module.</source>
          <target state="translated">당신이 사용할 수있는 &lt;a href=&quot;#onejs&quot;&gt;하나의 자바 스크립트 파일 최적화&lt;/a&gt; 빠르게 개발 경험을하는 방법을. 현재 개발중인 모듈을 제외하고 프로젝트의 모든 모듈을 하나의 파일로 최적화하면 브라우저에서 프로젝트를 빠르게 다시로드 할 수 있지만 모듈에서 세부적인 디버깅 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e85f93e17713bad14a95d8cd370414470f034be1" translate="yes" xml:space="preserve">
          <source>You can use this example with the CDN example above -- the shim example will not work since shimmed libraries need a global jQuery.</source>
          <target state="translated">이 예제는 위의 CDN 예제와 함께 사용할 수 있습니다. shimed 라이브러리에는 전역 jQuery가 필요하므로 shim 예제가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35637298babea9951136fe42e40ee8a2641302e6" translate="yes" xml:space="preserve">
          <source>You do not need to implement normalize if the resource name is just a regular module name. For instance, the text! plugin does not implement normalize because the dependency names look like 'text!./some/path.html'.</source>
          <target state="translated">리소스 이름이 일반 모듈 이름 인 경우 정규화를 구현할 필요가 없습니다. 예를 들어, 텍스트! 종속성 이름이 'text! ./ some / path.html'처럼 보이기 때문에 플러그인이 정규화를 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="268347d9cc7d9cf7908d577ac75d750a3ec06657" translate="yes" xml:space="preserve">
          <source>You may also call require.config from your &lt;a href=&quot;api#data-main&quot;&gt;data-main Entry Point&lt;/a&gt;, but be aware that the data-main script is loaded asynchronously. Avoid other entry point scripts which wrongly assume that data-main and its require.config will always execute prior to their script loading.</source>
          <target state="translated">&lt;a href=&quot;api#data-main&quot;&gt;data-main 진입 점&lt;/a&gt; 에서 require.config를 호출 할 수도 있지만 data-main 스크립트는 비동기 적으로로드됩니다. data-main 및 require.config가 항상 스크립트로드 전에 실행된다고 잘못 가정하는 다른 진입 점 스크립트는 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c90399d9bc6d39e4e0323a4f654f5ad35f0761ea" translate="yes" xml:space="preserve">
          <source>You may encounter some define() calls that include a name for the module as the first argument to define():</source>
          <target state="translated">모듈 이름을 define ()의 첫 번째 인수로 포함하는 define () 호출이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ff5b58fd6ef6fa6b20479d3b624ce5c45a8836" translate="yes" xml:space="preserve">
          <source>You may have a script you want to load from a &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network (CDN)&lt;/a&gt; or any other server on a different domain.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN (Content Delivery Network)&lt;/a&gt; 또는 다른 도메인의 다른 서버에서 로드하려는 스크립트가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6857ed319a34a42444b0124457cbd761b051ca92" translate="yes" xml:space="preserve">
          <source>You may have a script you want to load from a &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network (CDN)&lt;/a&gt; or any other server on a different domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cb0c91120fb108d906ccb84178ac86146de663" translate="yes" xml:space="preserve">
          <source>You should avoid naming modules yourself, and only place one module in a file while developing. However, for tooling and performance, a module solution needs a way to identify modules in built resources.</source>
          <target state="translated">모듈 이름을 직접 지정하지 말고 개발하는 동안 하나의 모듈 만 파일에 배치해야합니다. 그러나 툴링 및 성능을 위해 모듈 솔루션에는 빌드 된 리소스에서 모듈을 식별 할 수있는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="020d90c4a950b7c671e463b43e9d47537f9c25b6" translate="yes" xml:space="preserve">
          <source>You should use the &lt;a href=&quot;optimization#mainConfigFile&quot;&gt;mainConfigFile build option&lt;/a&gt; to specify the file where to find the shim config. Otherwise the optimizer will not know of the shim config. The other option is to duplicate the shim config in the build profile.</source>
          <target state="translated">shim 구성을 찾을 파일을 지정 하려면 &lt;a href=&quot;optimization#mainConfigFile&quot;&gt;mainConfigFile 빌드 옵션&lt;/a&gt; 을 사용해야합니다 . 그렇지 않으면 옵티마이 저는 shim 구성을 알 수 없습니다. 다른 옵션은 빌드 프로파일에서 shim 구성을 복제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="97681be93dfef60f3fb4d09b005e73fd388aec7f" translate="yes" xml:space="preserve">
          <source>You will likely need to set the &lt;strong&gt;baseUrl&lt;/strong&gt;&lt;a href=&quot;#config&quot;&gt;configuration option&lt;/a&gt; to make sure require() can find the scripts to load.</source>
          <target state="translated">당신은 아마 설정해야합니다 &lt;strong&gt;base을의 &lt;/strong&gt;&lt;a href=&quot;#config&quot;&gt;구성 옵션&lt;/a&gt; 부하에 스크립트를 찾을 수 있는지 확인이 필요하기를 ().</target>
        </trans-unit>
        <trans-unit id="6dba9d538cc7725fb3a6aa1bf1b4ce6a48e9f9b4" translate="yes" xml:space="preserve">
          <source>You will typically use a data-main script to &lt;a href=&quot;#config&quot;&gt;set configuration options&lt;/a&gt; and then load the first application module. Note: the script tag require.js generates for your data-main module includes the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async&quot;&gt;async attribute&lt;/a&gt;. This means that &lt;strong&gt;you cannot assume that the load and execution of your data-main script will finish prior to other scripts referenced later in the same page.&lt;/strong&gt;</source>
          <target state="translated">일반적으로 data-main 스크립트를 사용하여 &lt;a href=&quot;#config&quot;&gt;구성 옵션&lt;/a&gt; 을 설정 한 다음 첫 번째 애플리케이션 모듈을로드합니다. 참고 : data-main 모듈에 대해 require.js 생성 스크립트 태그에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async&quot;&gt;async 속성이&lt;/a&gt; 포함됩니다 . 즉 &lt;strong&gt;, 동일한 페이지에서 나중에 참조되는 다른 스크립트에 앞서 데이터 기본 스크립트의로드 및 실행이 완료된다고 가정 할 수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="369dac7c679f0128f82fcbd8ee8a70df45995f85" translate="yes" xml:space="preserve">
          <source>Your time coding is mostly spent thinking, not typing. While fewer words are generally preferable, there is a limit to that approach paying off, and the extra typing in AMD is not that much more.</source>
          <target state="translated">시간 코딩은 대부분 타이핑이 아닌 생각에 소비됩니다. 일반적으로 적은 단어가 선호되지만 그 접근 방식에는 한계가 있으며 AMD의 추가 타이핑은 그다지 많지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa5e2f93089b6ba91d69ad2df5ffb1b8e3b30434" translate="yes" xml:space="preserve">
          <source>and in app.js:</source>
          <target state="translated">그리고 app.js에서 :</target>
        </trans-unit>
        <trans-unit id="30d099754f286078db100db738bf8973842acc61" translate="yes" xml:space="preserve">
          <source>and the root bundle would look like:</source>
          <target state="translated">루트 번들은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a68969ef8e858229267b842dedf42ab5dde4d50" translate="yes" xml:space="preserve">
          <source>app.js</source>
          <target state="translated">app.js</target>
        </trans-unit>
        <trans-unit id="68620029c15ee91081f25087c97731ddec131ed1" translate="yes" xml:space="preserve">
          <source>app/</source>
          <target state="translated">app/</target>
        </trans-unit>
        <trans-unit id="182b400a51ca1ed7d5e68cd0c9e35beb52b7043d" translate="yes" xml:space="preserve">
          <source>appdirectory</source>
          <target state="translated">appdirectory</target>
        </trans-unit>
        <trans-unit id="a6e2217113e1101cebbd54678d99479155ebe930" translate="yes" xml:space="preserve">
          <source>avoid dumping global variables in the page</source>
          <target state="translated">페이지에서 전역 변수 덤프를 피하십시오</target>
        </trans-unit>
        <trans-unit id="d8b586bf1b6b8514e418f30ddc1550845968e12d" translate="yes" xml:space="preserve">
          <source>baseUrl</source>
          <target state="translated">baseUrl</target>
        </trans-unit>
        <trans-unit id="35e8277cc95cf8aaf1e8e9ffcb5ea39e6502bbd0" translate="yes" xml:space="preserve">
          <source>bundles</source>
          <target state="translated">bundles</target>
        </trans-unit>
        <trans-unit id="1d87cf050f073de171743e1289b27e42077e9332" translate="yes" xml:space="preserve">
          <source>bundles config is useful if doing a build and that build target was not an existing module ID, or if you have loader plugin resources in built JS files that should not be loaded by the loader plugin. &lt;strong&gt;Note that the keys and values are module IDs&lt;/strong&gt;, not path segments. They are absolute module IDs, not a module ID prefix like &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt; or &lt;a href=&quot;#config-map&quot;&gt;map config&lt;/a&gt;. Also, bundle config is different from map config in that map config is a one-to-one module ID relationship, where bundle config is for pointing multiple module IDs to a bundle's module ID.</source>
          <target state="translated">bundles config는 빌드를 수행하고 해당 빌드 대상이 기존 모듈 ID가 아니거나 로더 플러그인이로드하지 않아야하는 빌드 된 JS 파일에 로더 플러그인 자원이있는 경우에 유용합니다. &lt;strong&gt;키와 값은&lt;/strong&gt; 경로 세그먼트가 아닌 &lt;strong&gt;모듈 ID&lt;/strong&gt; 입니다. &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt; 또는 &lt;a href=&quot;#config-map&quot;&gt;map config&lt;/a&gt; 와 같은 모듈 ID 접두사가 아닌 절대 모듈 ID 입니다. 또한 번들 구성은 일대일 모듈 ID 관계라는 점에서 번들 구성은 맵 구성과 다릅니다. 여기서 번들 구성은 여러 모듈 ID를 번들의 모듈 ID를 가리 키기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="579c9417979d7785e6b71b4f343a3a25028e0208" translate="yes" xml:space="preserve">
          <source>but 'a' and 'b' will be included if specified like so:</source>
          <target state="translated">그러나 다음과 같이 지정하면 'a'와 'b'가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5651c3e30152897bed64070f9ea7509fbb7eaf58" translate="yes" xml:space="preserve">
          <source>but this means you cannot set the value for a paths property of &quot;core/jquery.tabs&quot; to a value. This would not work: &lt;code&gt;paths.core/jquery.tabs=empty:&lt;/code&gt;, since it would result in this incorrect structure:</source>
          <target state="translated">그러나 이는 &quot;core / jquery.tabs&quot;의 경로 특성 값을 값으로 설정할 수 없음을 의미합니다. &lt;code&gt;paths.core/jquery.tabs=empty:&lt;/code&gt; 작동하지 않습니다. 이 잘못된 구조가 발생하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="translated">callback</target>
        </trans-unit>
        <trans-unit id="9031234d18c313213c6fa8578b1a6efffa132f47" translate="yes" xml:space="preserve">
          <source>canvas.js</source>
          <target state="translated">canvas.js</target>
        </trans-unit>
        <trans-unit id="0ba1b6d81cde508d26591e899916a6b092ccc039" translate="yes" xml:space="preserve">
          <source>cart/</source>
          <target state="translated">cart/</target>
        </trans-unit>
        <trans-unit id="5db796b338afba355ef805d024ec3e62501d72e9" translate="yes" xml:space="preserve">
          <source>common.css</source>
          <target state="translated">common.css</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="2f84417a9e73cead4d5c99e05daff2a534b30132" translate="yes" xml:space="preserve">
          <source>css</source>
          <target state="translated">css</target>
        </trans-unit>
        <trans-unit id="5300d17a1d695bd411e4cdf96f9548c23ced6175" translate="yes" xml:space="preserve">
          <source>curl</source>
          <target state="translated">curl</target>
        </trans-unit>
        <trans-unit id="b549cb140e511f5ac2733025ff6d8eda8a8b7fc8" translate="yes" xml:space="preserve">
          <source>data-main Entry Point</source>
          <target state="translated">데이터 기본 진입 점</target>
        </trans-unit>
        <trans-unit id="9f2696583122964a7d696a2d47ac4a3db6ad1bcb" translate="yes" xml:space="preserve">
          <source>deps</source>
          <target state="translated">deps</target>
        </trans-unit>
        <trans-unit id="4bad62c293c46433ccc5a55eff2c143661293c1a" translate="yes" xml:space="preserve">
          <source>document.write() can be used to load scripts -- it can load scripts from other domains and it maps to how browsers normally consume scripts, so it allows for easy debugging.</source>
          <target state="translated">document.write ()는 스크립트를로드하는 데 사용할 수 있습니다. 다른 도메인에서 스크립트를로드 할 수 있으며 브라우저가 일반적으로 스크립트를 사용하는 방식에 매핑되므로 쉽게 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5958b76387ccd458d5f527ca464f090598df6741" translate="yes" xml:space="preserve">
          <source>edge cases that break in browsers, like cross-domain access</source>
          <target state="translated">도메인 간 액세스와 같이 브라우저에서 깨지는 엣지 케이스</target>
        </trans-unit>
        <trans-unit id="ff8af39bb078e2360da7fdc28417e6c1c52d5174" translate="yes" xml:space="preserve">
          <source>empty: paths for network/CDN resources</source>
          <target state="translated">비어 있음 : 네트워크 / CDN 리소스의 경로</target>
        </trans-unit>
        <trans-unit id="4b572a52b55bf1889556c6ce1e404be0d7ce946c" translate="yes" xml:space="preserve">
          <source>enforceDefine</source>
          <target state="translated">enforceDefine</target>
        </trans-unit>
        <trans-unit id="d90d8771241a7a05d34eed9205b8b446fb5b5f3a" translate="yes" xml:space="preserve">
          <source>eval context is different across browsers. You might be able to use execScript in IE to help this, but it means more moving parts.</source>
          <target state="translated">eval 컨텍스트는 브라우저마다 다릅니다. IE에서 execScript를 사용하면 도움이 될 수 있지만 더 움직이는 부분을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="43cca01843358114d77138bdf4c270875286cec3" translate="yes" xml:space="preserve">
          <source>foo1.0.js</source>
          <target state="translated">foo1.0.js</target>
        </trans-unit>
        <trans-unit id="42bf6d0b49db5b2166474ae85e2cf958a05393cb" translate="yes" xml:space="preserve">
          <source>foo1.2.js</source>
          <target state="translated">foo1.2.js</target>
        </trans-unit>
        <trans-unit id="b0cf8d3b30f6f61f1cfb2f257448bf0165378abc" translate="yes" xml:space="preserve">
          <source>for more information.</source>
          <target state="translated">자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="0032176e806dc0ce8286589b0e98559a66027030" translate="yes" xml:space="preserve">
          <source>for the optimization target.</source>
          <target state="translated">최적화 대상</target>
        </trans-unit>
        <trans-unit id="ead9f7e89bbc436a96977295af1dc1bc42e42683" translate="yes" xml:space="preserve">
          <source>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). &lt;a href=&quot;http://requirejs.org/docs/download.html#i18n&quot;&gt;Download the plugin&lt;/a&gt; and put it in the same directory as your app's main JS file.</source>
          <target state="translated">i18n 번들 지원은 i18n.js 플러그인에서 제공합니다. 모듈 또는 종속성이 i18n을 지정할 때 자동으로로드됩니다! 접두사 (자세한 내용은 아래 참조). &lt;a href=&quot;http://requirejs.org/docs/download.html#i18n&quot;&gt;플러그인을 다운로드&lt;/a&gt; 하여 앱의 기본 JS 파일과 동일한 디렉토리에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="dc5f7718fd7e5c233be9044ede6ef58c83b5d6d2" translate="yes" xml:space="preserve">
          <source>importScripts failed for ...</source>
          <target state="translated">importScripts가 실패했습니다 ...</target>
        </trans-unit>
        <trans-unit id="2c1a36cd8bde417114cd4f15a9d7802a1c5bf634" translate="yes" xml:space="preserve">
          <source>in index.html:</source>
          <target state="translated">index.html에서 :</target>
        </trans-unit>
        <trans-unit id="f6013a00b362253c64368d6eebc50ea2131754e2" translate="yes" xml:space="preserve">
          <source>index.html</source>
          <target state="translated">index.html</target>
        </trans-unit>
        <trans-unit id="33249b1929c8b83eb4a72adebb385c134300aa14" translate="yes" xml:space="preserve">
          <source>inherent asynchronicity</source>
          <target state="translated">고유 한 비동기 성</target>
        </trans-unit>
        <trans-unit id="3f33a365d57118fb6c072149b026bf3898687f01" translate="yes" xml:space="preserve">
          <source>jQuery defines &lt;a href=&quot;api#modulename&quot;&gt;named AMD module&lt;/a&gt; 'jquery' (all lower case) when it detects AMD/RequireJS. To reduce confusion, we recommend using 'jquery' as the module name in your requirejs.config.</source>
          <target state="translated">jQuery는 AMD / RequireJS를 탐지 할 때 &lt;a href=&quot;api#modulename&quot;&gt;명명 된 AMD 모듈&lt;/a&gt; 'jquery'(모두 소문자)를 정의합니다. 혼동을 줄이려면 requirejs.config에서 'jquery'를 모듈 이름으로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9138a4fadeb7b3d7df1c442e211cb8d36112cba1" translate="yes" xml:space="preserve">
          <source>jQuery registers itself as the global variables &quot;$&quot; and &quot;jQuery&quot;, even when it detects AMD/RequireJS. The AMD approach advises against the use of global functions, but the decision to turn off these jQuery globals hinges on whether you have non-AMD code that depends on them. jQuery has a &lt;a href=&quot;http://api.jquery.com/jQuery.noConflict/&quot;&gt;noConflict function&lt;/a&gt; that supports releasing control of the global variables and this can be automated in your requirejs.config, as we will see &lt;a href=&quot;#noconflictmap&quot;&gt;later&lt;/a&gt;.</source>
          <target state="translated">jQuery는 AMD / RequireJS를 감지하더라도 글로벌 변수 &quot;$&quot;및 &quot;jQuery&quot;로 자체 등록됩니다. AMD 접근 방식은 전역 함수 사용을 권장하지 않지만 이러한 jQuery 전역을 끄는 결정은 사용자에게 의존하는 비 AMD 코드가 있는지 여부에 달려 있습니다. jQuery에는 전역 변수의 제어 해제를 지원 하는 &lt;a href=&quot;http://api.jquery.com/jQuery.noConflict/&quot;&gt;noConflict 함수&lt;/a&gt; 가 있으며 &lt;a href=&quot;#noconflictmap&quot;&gt;나중에&lt;/a&gt; 볼 수 있듯이 requirejs.config에서 자동화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63ee06036c004043a1670e9dc620e1643bb8fd2c" translate="yes" xml:space="preserve">
          <source>jQuery registers itself as the global variables &quot;$&quot; and &quot;jQuery&quot;, even when it detects AMD/RequireJS. The AMD approach advises against the use of global functions, but the decision to turn off these jQuery globals hinges on whether you have non-AMD code that depends on them. jQuery has a &lt;a href=&quot;https://api.jquery.com/jQuery.noConflict/&quot;&gt;noConflict function&lt;/a&gt; that supports releasing control of the global variables and this can be automated in your requirejs.config, as we will see &lt;a href=&quot;#noconflictmap&quot;&gt;later&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0d2a18212b79b67dee0e91e19cf1b654062c92" translate="yes" xml:space="preserve">
          <source>jquery.js</source>
          <target state="translated">jquery.js</target>
        </trans-unit>
        <trans-unit id="9ed0b2469c22926565156df53ef6562350753750" translate="yes" xml:space="preserve">
          <source>js/</source>
          <target state="translated">js/</target>
        </trans-unit>
        <trans-unit id="70070d20d4c6e863f10cb8b6749cc4b4efaf6027" translate="yes" xml:space="preserve">
          <source>lib/</source>
          <target state="translated">lib/</target>
        </trans-unit>
        <trans-unit id="5dbc716c4600097b85b9e51d6aeb77a4363b03ed" translate="yes" xml:space="preserve">
          <source>load</source>
          <target state="translated">load</target>
        </trans-unit>
        <trans-unit id="ec030ee0a72bb1bad48e285b9d1e42ab5b8170ee" translate="yes" xml:space="preserve">
          <source>load is a function, and it will be called with the following arguments:</source>
          <target state="translated">load는 함수이며 다음과 같은 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6dff233c807097ef10ae79c568dc973d30c3cf68" translate="yes" xml:space="preserve">
          <source>load: function (name, parentRequire, onload, config)</source>
          <target state="translated">로드 : 함수 (이름, parentRequire, onload, 구성)</target>
        </trans-unit>
        <trans-unit id="0b6d8e9672e5ffa1f585413a4ff5521b40332f97" translate="yes" xml:space="preserve">
          <source>lsjs</source>
          <target state="translated">lsjs</target>
        </trans-unit>
        <trans-unit id="33e0a7d96f2f283eb6f94bbfd4ce882c6816f77d" translate="yes" xml:space="preserve">
          <source>main.css</source>
          <target state="translated">main.css</target>
        </trans-unit>
        <trans-unit id="7b6b9d0efba95dec0a83ec36edc8acd84043be9d" translate="yes" xml:space="preserve">
          <source>main.css has content like the following:</source>
          <target state="translated">main.css의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d6427cfcffb5ef37b2d32bd7aac8a9b7450a987" translate="yes" xml:space="preserve">
          <source>main.html</source>
          <target state="translated">main.html</target>
        </trans-unit>
        <trans-unit id="f1df1c5603aa500b9411213f4ea48cf4e5d422e0" translate="yes" xml:space="preserve">
          <source>main.html has script tags for require.js and loads main.js via a require call, like so:</source>
          <target state="translated">main.html에는 require.js에 대한 스크립트 태그가 있으며 require 호출을 통해 다음과 같이 main.js를로드합니다.</target>
        </trans-unit>
        <trans-unit id="c4a4248f7568c9e41265502c39b0daeb8b635431" translate="yes" xml:space="preserve">
          <source>main.js</source>
          <target state="translated">main.js</target>
        </trans-unit>
        <trans-unit id="5bde0c1eb87162d48261ef607a5f7367edd8af16" translate="yes" xml:space="preserve">
          <source>main.js loads one.js, two.js and three.js via a require call:</source>
          <target state="translated">main.js는 require 호출을 통해 one.js, two.js 및 three.js를로드합니다.</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="839a384082f672d5b0e4ed1c48403f66bc62c7e5" translate="yes" xml:space="preserve">
          <source>map example:</source>
          <target state="translated">지도 예 :</target>
        </trans-unit>
        <trans-unit id="3c439d3b6842ae589d848604d613de606883e341" translate="yes" xml:space="preserve">
          <source>my/cart.js</source>
          <target state="translated">my/cart.js</target>
        </trans-unit>
        <trans-unit id="6ff94085a8329ba4ee05cefa0a0b5b1b179b3db7" translate="yes" xml:space="preserve">
          <source>my/inventory.js</source>
          <target state="translated">my/inventory.js</target>
        </trans-unit>
        <trans-unit id="23b2f9933585fb1b37de87310c51e3eb51c83b97" translate="yes" xml:space="preserve">
          <source>my/nls/colors.js</source>
          <target state="translated">my/nls/colors.js</target>
        </trans-unit>
        <trans-unit id="c3e4ffdb238e5c58edbed616f0dfed31ef1359ff" translate="yes" xml:space="preserve">
          <source>my/nls/fr-fr-paris/colors.js</source>
          <target state="translated">my/nls/fr-fr-paris/colors.js</target>
        </trans-unit>
        <trans-unit id="6d560f42236d5cf1594fcea61de2e335709a6b4e" translate="yes" xml:space="preserve">
          <source>my/nls/fr-fr/colors.js</source>
          <target state="translated">my/nls/fr-fr/colors.js</target>
        </trans-unit>
        <trans-unit id="5a03cbc43369adc59a77432f3dbe892648c90d2f" translate="yes" xml:space="preserve">
          <source>my/nls/fr/colors.js</source>
          <target state="translated">my/nls/fr/colors.js</target>
        </trans-unit>
        <trans-unit id="68644578c0e8f200b5d33adf2401413115a74114" translate="yes" xml:space="preserve">
          <source>my/shirt.js</source>
          <target state="translated">my/shirt.js</target>
        </trans-unit>
        <trans-unit id="a412083cb1fc91a30f7e8b0861829a50827f0b6c" translate="yes" xml:space="preserve">
          <source>network loading</source>
          <target state="translated">네트워크 로딩</target>
        </trans-unit>
        <trans-unit id="2fad3300f3300cc8d668154fa62ddaae9e5376d5" translate="yes" xml:space="preserve">
          <source>newmodule.js</source>
          <target state="translated">newmodule.js</target>
        </trans-unit>
        <trans-unit id="71878dcf848606242ed856e0c6a0c24d1d32a939" translate="yes" xml:space="preserve">
          <source>nodeIdCompat</source>
          <target state="translated">nodeIdCompat</target>
        </trans-unit>
        <trans-unit id="514d9f2e0acc04d77fc45ca16b43c69b19977218" translate="yes" xml:space="preserve">
          <source>normalize</source>
          <target state="translated">normalize</target>
        </trans-unit>
        <trans-unit id="2a281ad421bb92791152f62669135fa7021cb816" translate="yes" xml:space="preserve">
          <source>normalize: function (name, normalize)</source>
          <target state="translated">정규화 : 함수 (이름, 정규화)</target>
        </trans-unit>
        <trans-unit id="660051d15ac64cec704cfacca2c2eab008f657e8" translate="yes" xml:space="preserve">
          <source>npm</source>
          <target state="translated">npm</target>
        </trans-unit>
        <trans-unit id="d8631383a6178b11a2917aa845f41707e9185dc0" translate="yes" xml:space="preserve">
          <source>oldmodule.js</source>
          <target state="translated">oldmodule.js</target>
        </trans-unit>
        <trans-unit id="7a39e1d29475a2a77167507df7366126892c9900" translate="yes" xml:space="preserve">
          <source>onLayerEnd</source>
          <target state="translated">onLayerEnd</target>
        </trans-unit>
        <trans-unit id="6010d31025036ae4e749a8b5c4d5bc7058a8c6f4" translate="yes" xml:space="preserve">
          <source>onLayerEnd is called with the following arguments:</source>
          <target state="translated">onLayerEnd는 다음 인수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b01854b4ccf9ea6577756f43de48539c45cd34d9" translate="yes" xml:space="preserve">
          <source>onLayerEnd: function (write, data)</source>
          <target state="translated">onLayerEnd : 함수 (쓰기, 데이터)</target>
        </trans-unit>
        <trans-unit id="4ec3dc925c02508cf421d1fa6fa05251616d92d3" translate="yes" xml:space="preserve">
          <source>one.js</source>
          <target state="translated">one.js</target>
        </trans-unit>
        <trans-unit id="da3a307e7a7ab71834fdcca6a6af66dcf9eeebce" translate="yes" xml:space="preserve">
          <source>or in a build profile. In a &lt;strong&gt;build.js&lt;/strong&gt;, the same command line arguments can be specified like so:</source>
          <target state="translated">또는 빌드 프로파일에서. A의 &lt;strong&gt;build.js&lt;/strong&gt; , 동일한 명령 줄 인수는과 같이 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7030d0b2f71b999ff89a343de08c414af32fc93a" translate="yes" xml:space="preserve">
          <source>package.json</source>
          <target state="translated">package.json</target>
        </trans-unit>
        <trans-unit id="d8ae088aee969371bf4ed994e9106b5d3e799c35" translate="yes" xml:space="preserve">
          <source>packages</source>
          <target state="translated">packages</target>
        </trans-unit>
        <trans-unit id="1910200239e6caafdd7288bf98705c63894fa1e7" translate="yes" xml:space="preserve">
          <source>participate in a workable module system for JS in the browser today.</source>
          <target state="translated">브라우저에서 JS를위한 실행 가능한 모듈 시스템에 참여하십시오.</target>
        </trans-unit>
        <trans-unit id="0c6eeceb6e5744cc0a0a7d55d06e7292f43c9f8c" translate="yes" xml:space="preserve">
          <source>paths</source>
          <target state="translated">paths</target>
        </trans-unit>
        <trans-unit id="55431d04ee22f086c0e4730ad2d0ad6ba1df9215" translate="yes" xml:space="preserve">
          <source>paths config fallbacks</source>
          <target state="translated">경로 구성 폴백</target>
        </trans-unit>
        <trans-unit id="3247077e9f813f61c28294ebf0b04fa7b7e763f6" translate="yes" xml:space="preserve">
          <source>pluginBuilder</source>
          <target state="translated">pluginBuilder</target>
        </trans-unit>
        <trans-unit id="d37b10be4b23b3a5407225d5efaed1c9d5e4e805" translate="yes" xml:space="preserve">
          <source>project-directory/</source>
          <target state="translated">project-directory/</target>
        </trans-unit>
        <trans-unit id="055c5bd0721336c320466362c116cc9e22059fd0" translate="yes" xml:space="preserve">
          <source>project.html</source>
          <target state="translated">project.html</target>
        </trans-unit>
        <trans-unit id="e6c30fb20717a4f9320c2216f6eb104985e6e25d" translate="yes" xml:space="preserve">
          <source>r.js (The r.js optimizer from &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;download page&lt;/a&gt;)</source>
          <target state="translated">r.js ( &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;다운로드 페이지&lt;/a&gt; 의 r.js 최적화 프로그램 )</target>
        </trans-unit>
        <trans-unit id="d167818bd51e72c059598e330a28144029cd8fc5" translate="yes" xml:space="preserve">
          <source>require('requirejs')</source>
          <target state="translated">require('requirejs')</target>
        </trans-unit>
        <trans-unit id="3558129c06c8b15607f833dd7dfd9f07eeda7dfe" translate="yes" xml:space="preserve">
          <source>require([]) errbacks</source>
          <target state="translated">필요 ([]) 오류</target>
        </trans-unit>
        <trans-unit id="3eddd1f1e5f1762adabfa0582463ae368a1590f8" translate="yes" xml:space="preserve">
          <source>require.js</source>
          <target state="translated">require.js</target>
        </trans-unit>
        <trans-unit id="52b4004b2a5f9427f8ae9be275de601264335e33" translate="yes" xml:space="preserve">
          <source>script.onerror does not work in IE 6-8. There is no way to know if loading a script generates a 404, worse, it triggers the onreadystatechange with a complete state even in a 404 case.</source>
          <target state="translated">IE 6-8에서는 script.onerror가 작동하지 않습니다. 스크립트를로드하면 404가 생성되는지 알 수있는 방법이 없습니다. 심지어 404 경우에도 완전한 상태로 onreadystatechange를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="1da4f66f62a84398d6a63d2bdcbb0c6bbfb2ae9f" translate="yes" xml:space="preserve">
          <source>script.onerror does work in IE 9+, but it has a bug where it does not fire script.onload event handlers right after execution of script, so it cannot support the standard method of allowing anonymous AMD modules. So script.onreadystatechange is still used. However, onreadystatechange fires with a complete state before the script.onerror function fires.</source>
          <target state="translated">script.onerror는 IE 9+에서 작동하지만 스크립트 실행 직후 script.onload 이벤트 핸들러를 실행하지 않는 버그가 있으므로 익명의 AMD 모듈을 허용하는 표준 방법을 지원할 수 없습니다. 따라서 script.onreadystatechange가 여전히 사용됩니다. 그러나 onreadystatechange는 script.onerror 함수가 실행되기 전에 완전한 상태로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7818b054440ca239beb44d0b0991165ee0ad46f4" translate="yes" xml:space="preserve">
          <source>scriptType</source>
          <target state="translated">scriptType</target>
        </trans-unit>
        <trans-unit id="16728d18790deb58b3b8c1df74f06e536b532695" translate="yes" xml:space="preserve">
          <source>scripts</source>
          <target state="translated">scripts</target>
        </trans-unit>
        <trans-unit id="0cec61d8fab53349479d2fc0899c8c9fdc57a2c5" translate="yes" xml:space="preserve">
          <source>scripts/</source>
          <target state="translated">scripts/</target>
        </trans-unit>
        <trans-unit id="089017cedf29ba7955e32e88c25d3948b4f3fdea" translate="yes" xml:space="preserve">
          <source>shim</source>
          <target state="translated">shim</target>
        </trans-unit>
        <trans-unit id="357d6240a2159a33c8d69670dbeaf60f751f6066" translate="yes" xml:space="preserve">
          <source>skipDataMain</source>
          <target state="translated">skipDataMain</target>
        </trans-unit>
        <trans-unit id="94a86d6fcf88d9b98c51727a4b90aa8812e2c49e" translate="yes" xml:space="preserve">
          <source>some/</source>
          <target state="translated">some/</target>
        </trans-unit>
        <trans-unit id="94af276c25727779efc4cfa45d83a3c73f4be23c" translate="yes" xml:space="preserve">
          <source>store.js</source>
          <target state="translated">store.js</target>
        </trans-unit>
        <trans-unit id="8ca15b529f630f7ce97e77cae45b2785290b1404" translate="yes" xml:space="preserve">
          <source>store/</source>
          <target state="translated">store/</target>
        </trans-unit>
        <trans-unit id="a41e737bdcb57316f3b931ebc708a240ae2684de" translate="yes" xml:space="preserve">
          <source>sub.js</source>
          <target state="translated">sub.js</target>
        </trans-unit>
        <trans-unit id="a18864cfdb7cf1305a2ae73d6709348bf2a1be5a" translate="yes" xml:space="preserve">
          <source>the optimization could overwrite or place files outside the output directory. For those cases, create a &lt;strong&gt;paths&lt;/strong&gt; config to map that file to a local name, like:</source>
          <target state="translated">최적화는 파일을 겹쳐 쓰거나 출력 디렉토리 외부에 배치 할 수 있습니다. 이러한 경우 &lt;strong&gt;경로&lt;/strong&gt; 구성을 작성하여 다음과 같이 해당 파일을 로컬 이름에 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="e76fa894c07e30c55a48e7c792952c4491d0cd8d" translate="yes" xml:space="preserve">
          <source>the tooling dependency cost</source>
          <target state="translated">툴링 의존 비용</target>
        </trans-unit>
        <trans-unit id="2750d4c188b4b1a71febebc268725da0cb849812" translate="yes" xml:space="preserve">
          <source>then just pass the build profile's file name to the optimizer:</source>
          <target state="translated">그런 다음 빌드 프로파일의 파일 이름을 최적화 프로그램에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="bf8b5529b79e43921112789bda96246277ea7d0f" translate="yes" xml:space="preserve">
          <source>then use name:</source>
          <target state="translated">그런 다음 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c441435c0602c49b97cc1e421949a1f5095cd1fb" translate="yes" xml:space="preserve">
          <source>three.js</source>
          <target state="translated">three.js</target>
        </trans-unit>
        <trans-unit id="4ddfb1710fe5f5980cb00ef5dd17923d67356df7" translate="yes" xml:space="preserve">
          <source>two.js</source>
          <target state="translated">two.js</target>
        </trans-unit>
        <trans-unit id="cf67f0d1ebbbec2dd994c75b048536c4cd0b757e" translate="yes" xml:space="preserve">
          <source>urlArgs</source>
          <target state="translated">urlArgs</target>
        </trans-unit>
        <trans-unit id="e0971e2c6fc32a880b2a4273d8cd19d12b256a30" translate="yes" xml:space="preserve">
          <source>use existing AMD tooling to optimize their project</source>
          <target state="translated">기존 AMD 툴링을 사용하여 프로젝트 최적화</target>
        </trans-unit>
        <trans-unit id="44317b82ece1d6cd2d98c56b0e42b6ace033067f" translate="yes" xml:space="preserve">
          <source>use more options for code loading, delayed loading</source>
          <target state="translated">코드 로딩, 지연 로딩에 더 많은 옵션 사용</target>
        </trans-unit>
        <trans-unit id="d3b2ef2f2fe3412d2bdf5d97d5d41fe37cf0e715" translate="yes" xml:space="preserve">
          <source>util.js</source>
          <target state="translated">util.js</target>
        </trans-unit>
        <trans-unit id="8f91e15d036639328135c4f04e40da6bdfdf31aa" translate="yes" xml:space="preserve">
          <source>waitSeconds</source>
          <target state="translated">waitSeconds</target>
        </trans-unit>
        <trans-unit id="bdb53d29bbbbaa4071ae3637cca5a02d7bba4c4e" translate="yes" xml:space="preserve">
          <source>where the main.js module looks like this:</source>
          <target state="translated">main.js 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="535e4e9b361a4e62b7649966552382e07ec58337" translate="yes" xml:space="preserve">
          <source>will return the current document when used as a loader plugin:</source>
          <target state="translated">로더 플러그인으로 사용될 때 현재 문서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0adb626f023cbc31f0be36d86bd7e915c1af3143" translate="yes" xml:space="preserve">
          <source>worse debugging, a cost that continues to add up over time</source>
          <target state="translated">더 나쁜 디버깅, 시간이 지남에 따라 계속 증가하는 비용</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
        <trans-unit id="5ae459e45b554a20a34db9cf6e8545cfa6f52ddd" translate="yes" xml:space="preserve">
          <source>write: function (pluginName, moduleName, write)</source>
          <target state="translated">쓰기 : 함수 (pluginName, moduleName, 쓰기)</target>
        </trans-unit>
        <trans-unit id="6b8257fc78666892f1dfe434d6373f1c5b7bdfaf" translate="yes" xml:space="preserve">
          <source>writeFile</source>
          <target state="translated">writeFile</target>
        </trans-unit>
        <trans-unit id="ee09b7c80317309eef991c850400f0f5da599fcd" translate="yes" xml:space="preserve">
          <source>writeFile: function (pluginName, name, parentRequire, write)</source>
          <target state="translated">writeFile : 함수 (pluginName, 이름, parentRequire, 쓰기)</target>
        </trans-unit>
        <trans-unit id="0e547e2244cf8baca179b01e93513122cc2fdef1" translate="yes" xml:space="preserve">
          <source>www/</source>
          <target state="translated">www/</target>
        </trans-unit>
        <trans-unit id="152de8eee480369bd7bffe90947136dd08b6baa2" translate="yes" xml:space="preserve">
          <source>xhtml</source>
          <target state="translated">xhtml</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
