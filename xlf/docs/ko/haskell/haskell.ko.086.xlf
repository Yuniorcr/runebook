<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">이 변경 사항은 메인 모듈에만 적용됩니다. 다른 모듈은 &lt;code&gt;-main-is&lt;/code&gt; 플래그에 관계없이 여전히 기본 내보내기 목록에서 &lt;code&gt;main&lt;/code&gt; 을 내 보냅니다 . 이 예제에서와 같이 &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; 다른 진입 점을 가리키는 경우에도 &lt;code&gt;-main-is&lt;/code&gt; 를 기본 내보내기 목록을 통해 &lt;code&gt;main&lt;/code&gt; 을 내보내는 기존 모듈 에서 &lt;code&gt;-main-is&lt;/code&gt; 를 사용할 수 있습니다 ( -main-is MainWrapper.program로 컴파일 됨 ).</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">이 클래스에는 &lt;em&gt;용어에&lt;/em&gt; 포함 된 정보에서 두 가지 유형의 동등성을 배울 수있는 유형이 포함되어 있습니다 . 일반적으로이 클래스에는 단일 유형 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">이 클래스는 형식 수준의 자연과 관련된 정수를 제공합니다. 모든 구체적인 리터럴에는 0, 1, 2 등의 클래스 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">이 클래스는 유형 수준 기호와 관련된 문자열을 제공합니다. 모든 구체적인 리터럴에는 &quot;hello&quot;등의 클래스 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">이 클래스는 FlexibleInstances가 없기 때문에 Haskell98 호환성 해결 방법으로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">이 클래스는 재귀의 번역에 사용되는 &lt;code&gt;do&lt;/code&gt; GHC와 포옹 지원 표기.</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">하나의 인스턴스 만있는이 클래스 는 구체적 유형 인 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이 유형 클래스 인스턴스로 허용되지 않는다는 사실에 대한 임시 해결책으로 사용됩니다 . 역 호환성을 위해 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; 를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">이 코드 조각은 치명적인 오류를 유발해야하지만 다음과 같은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍을 이루도록합니다. (이 코드를 직접 작성하는 대신 일반 패턴을 추상화하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="83010be07376269d9080bf541aef5e0b9bd24515" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍 을 이루도록 보장합니다 . (이 코드를 직접 작성하는 것보다 사용하는 것이 좋습니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 일반적인 패턴을 추상화하는 대괄호).</target>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍을 이루도록합니다. (이 코드를 직접 작성하는 대신 일반 패턴을 추상화하는 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 결합기는 선택을 구현합니다. 파서 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 먼저 &lt;code&gt;p&lt;/code&gt; 를 적용 합니다. 성공하면 &lt;code&gt;p&lt;/code&gt; 의 값 이 반환됩니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 실패 &lt;em&gt;모든 입력을 사용하지 않고&lt;/em&gt; , 파서 &lt;code&gt;q&lt;/code&gt; 는 시도됩니다. 이 연결자들은 동일한 정의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 용 의 부재 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 의 클래스 및 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 부재) &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05f82f2ce2fd9bc7ef8dc6adbbe8bab553e349cc" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 결합자는 선택을 구현합니다. 파서 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 먼저 &lt;code&gt;p&lt;/code&gt; 를 적용 합니다. 성공하면 &lt;code&gt;p&lt;/code&gt; 값 이 반환됩니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 실패 &lt;em&gt;모든 입력을 사용하지 않고&lt;/em&gt; , 파서 &lt;code&gt;q&lt;/code&gt; 는 시도됩니다. 이 연결자들은 동일한 정의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 용 의 부재 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 의 클래스 및 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 부재) &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">이 결합기는 임의의 미리보기가 필요할 때마다 사용됩니다. &lt;code&gt;p&lt;/code&gt; 가 실패 할 때 입력을 소비하지 않은 것처럼 가장하기 때문에 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 입력을 소비하면서 첫 번째 파서가 실패한 경우에도 두 번째 대안을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">이 결합기는 임의의 미리보기가 필요할 때마다 사용됩니다. &lt;code&gt;p&lt;/code&gt; 가 실패 할 때 입력을 소비하지 않은 것처럼 가장하기 때문에 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 입력을 소비하면서 첫 번째 파서가 실패한 경우에도 두 번째 대안을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">이 명령을 사용하면 적절한 터미널 대신 파이프를 통해 상호 작용할 때에도 GHCi에서 명령 완료를 요청할 수 있으며 GHCi의 완료를 텍스트 편집기 및 IDE와 통합하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">이 명령은 편집기 및 IDE에서 식별자의 모든 사용을 강조 표시하고 탐색하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">이 명령은 GHCi를 텍스트 편집기 및 IDE와 통합하여 goto-definition 기능을 제공 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">이 명령은 GHCi를 텍스트 편집기 및 IDE와 통합하여 show-type-under-point 기능을 제공 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">이 계산은 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 예외 중 하나와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">이 계산은 다음과 같이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">이것은 외부 호출과 &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; 의 상호 작용과 관련이 있습니다. 일반적으로 &lt;code&gt;throwTo&lt;/code&gt; 의 대상이 외래 통화에 관련된 경우에는 통화가 돌아올 때까지 그리고 발신자가 차단 될 때까지 예외가 발생하지 않습니다. 이로 인해 응답하지 않을 수 있으며 이는 사용자 인터럽트 (예 : Control-C)의 경우 특히 바람직하지 않습니다. Control-C 신호가 수신 될 때 ( UNIX의 &lt;code&gt;SIGINT&lt;/code&gt; ) 기본 동작 은 기본 스레드에서 &lt;code&gt;UserInterrupt&lt;/code&gt; 예외를 발생시키는 것입니다. 그 때 메인 스레드가 외래 호출에서 차단되면 프로그램은 사용자 인터럽트에 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">이 조건은 유형별로 확인되지 않습니다. 제공된 값이 유효한 전체 주문인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">이렇게하면 문자열이 변환되지만 공백을 줄 바꿈 불가능으로 유지하고 입력 목록의 각 문자열 사이에 줄 바꿈을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">이것은 문자열을 변환하지만 공백을 줄 바꿈 불가능한 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">이받는 대응 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 연산에 의해 제공되는 &lt;code&gt;base&lt;/code&gt; 의 &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;수치의&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">이것은 현재</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">이 데이터 유형은 동등성 관계를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;a&lt;/code&gt; 유형 의 값에서 작동하는 연산자를 지정 합니다 . 연산자는 이진 접두사 또는 단항 접두사 또는 접미사입니다. 이항 연산자에는 관련 연관성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">이 데이터 유형은 연산자의 연관성을 지정합니다 (왼쪽, 오른쪽 또는 없음).</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 로 점진적 으로 상승하는 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">이 데이터 유형 &lt;code&gt;G&lt;/code&gt; 는 종류와 유형이 모두 GADT와 유사합니다. &lt;code&gt;g :: G a&lt;/code&gt; 있고 &lt;code&gt;a :: k&lt;/code&gt; 가 있다고 가정하십시오 . 그런 다음 &lt;code&gt;g&lt;/code&gt; 가 실제로 &lt;code&gt;GMaybe&lt;/code&gt; 임을 발견하기 위해 패턴 일치 는 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 과 &lt;code&gt;a ~ Maybe&lt;/code&gt; 를 알려줍니다 . &lt;code&gt;G&lt;/code&gt; 에 대한 정의 는 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 유효 해야 하지만 &lt;code&gt;G&lt;/code&gt; 에서의 패턴 일치는 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 넘어서는 확장이 필요하지 않습니다 . 이 작업은 실제로 일반 GADT의 간단한 확장이며 종류와 유형이 동일하다는 결과입니다.</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 의해 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; 의 버퍼 별 버퍼 실행을위한 공통 인터페이스 역할을합니다 . 이 인터페이스의 일반적인 사용자는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;enumerator&lt;/code&gt; 와 같은 iteratee 스타일 라이브러리 입니다.</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">이 디코더는 모든 입력을 읽어야 리턴 할 수 있다는 단점이 있습니다. 반면, 디코더 오류없이 디코딩 할 수 있다는 것을 알기 전까지는 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">이 정의는 운영 체제를 기반으로 조건부 컴파일을 허용합니다. 여기서 ⟨os⟩는 현재 운영 체제의 이름입니다 (예 : &lt;code&gt;linux&lt;/code&gt; , Windows의 경우 &lt;code&gt;mingw32&lt;/code&gt; , &lt;code&gt;solaris&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">이 정의는 호스트 아키텍처를 기반으로 조건부 컴파일을 허용합니다. 여기서 &quot;arch⟨는 현재 아키텍처의 이름입니다 (예 : &lt;code&gt;i386&lt;/code&gt; , &lt;code&gt;x86_64&lt;/code&gt; , &lt;code&gt;powerpc&lt;/code&gt; , &lt;code&gt;sparc&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">이 정의는 &lt;code&gt;f1&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt; 에서 엄격 하게 만드는 반면, 뱅이 없으면 게으를 것입니다. 강타 패턴은 물론 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">이는 일반적인 &lt;code&gt;deriving&lt;/code&gt; 조항 과 거의 동일한 방식으로 컨텍스트가 추론 되는 파생 &lt;code&gt;Eq (Foo a)&lt;/code&gt; 인스턴스를 나타냅니다 . 독립형 &lt;code&gt;deriving&lt;/code&gt; 선언 에서 와일드 카드를 사용 하는 것은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">이 디자인은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 구현에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 완전한 액세스를 제공합니다 . 따라서 지정된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 외부의 내용을 덮어 쓰지 않도록 각별히주의해야합니다 . 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 적으로 투명 하도록 추가주의를 기울여야합니다 . 의 의견을 참조 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 자세한 내용은 기능을. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 액션을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현할 때는 &lt;em&gt;안전 벨트&lt;/em&gt; 가 &lt;em&gt;전혀 없습니다&lt;/em&gt; . Haskell 서버에서 다음 버퍼 오버플로 공격을 가능하게하는 코드를 작성하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="9424f4d941d065861400a0aac7eda9e8e5e684ee" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">이 디자인은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 구현에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 전체 액세스 권한을 제공합니다 . 따라서 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 외부의 어떤 것도 덮어 쓰지 않도록 최대한주의해야합니다 . 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 적으로 투명 하도록 추가주의를 기울여야합니다 . 의 의견을 참조 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 자세한 내용은 기능을. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현할 때 &lt;em&gt;안전 벨트&lt;/em&gt; 가 &lt;em&gt;전혀 없습니다.&lt;/em&gt; 작업을 . Haskell 서버에서 다음 버퍼 오버플로 공격을 가능하게 할 수있는 코드를 작성하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">이 차이점은 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 의&lt;/a&gt; 작동 방식 때문에 중요 합니다. 파생 된 &lt;code&gt;Functor Right&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">런타임 경로는 포함되지 않습니다. 표준 위치 또는 &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 환경 변수가 제공하는 디렉토리에서 사용 가능한 공유 라이브러리에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">더 이상 작동하지 않습니다. 가정하자 모듈 &lt;code&gt;C&lt;/code&gt; 의 수입 모듈 &lt;code&gt;B&lt;/code&gt; 를 , 및 &lt;code&gt;B&lt;/code&gt; 의 수입 모듈 &lt;code&gt;A&lt;/code&gt; . 모듈의 변경 그래서 &lt;code&gt;A&lt;/code&gt; 는 모듈이 필요할 수 있습니다 &lt;code&gt;C&lt;/code&gt; 를 컴파일하고, 따라서하면된다 &lt;code&gt;A.hi&lt;/code&gt; 은 우리가 여부를 확인해야합니다 변경 &lt;code&gt;C&lt;/code&gt; 가 다시 컴파일해야합니다. 그러나 &lt;code&gt;C&lt;/code&gt; 의 종속성은 &lt;code&gt;B.hi&lt;/code&gt; 가 아닌 &lt;code&gt;A.hi&lt;/code&gt; 만 나열 하며 &lt;code&gt;A&lt;/code&gt; 에 대한 일부 변경 사항 ( &lt;code&gt;B&lt;/code&gt; 에서 내 보낸 함수의 인라인에 나타나는 함수의 정의 변경 )은 &lt;code&gt;B.hi&lt;/code&gt; 변경하지 않을 수 있습니다 . 안녕 하나 그래서 지금&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">변수 &lt;code&gt;x&lt;/code&gt; 가 표현-다형 적 유형을 가질 것이기 때문에 이것은 &lt;code&gt;bad&lt;/code&gt; 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">이것은 코드 생성기의 조립 단계에서 바로 가기를 가능하게합니다. 간단히 말하면 단축 명령은 명령 블록 A가 무조건 점프로만 구성된 경우 A의 후속 점프로 점프하여 A에 대한 모든 점프를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">이 인코딩은 어느 방향으로도 실패하지 않습니다. 그러나 인코딩하면 정보가 삭제되므로 인코딩 다음에 디코딩하는 것이 ID가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">이 인코딩은 바이트 시퀀스 &quot;xc0x80&quot;을 사용하여 NUL을 나타내며 문자열은 NUL로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이를 통해 Bifold의 각 단계가 적용되기 전에 약한 머리 정상적인 형태로 강요되어 다른 방식으로 발생하는 뭉크의 수집을 피할 수 있습니다. 이것은 종종 유한 구조를 단일 모 놀리 식 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ) 로 엄격하게 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이것은 접힘의 각 단계가 적용되기 전에 약한 머리 정상 형태로 강요되도록 보장하고, 그렇지 않으면 발생하는 썽크의 수집을 피합니다. 이것은 종종 유한리스트를 하나의 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ) 로 엄격히 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이것은 접힘의 각 단계가 적용되기 전에 약한 머리 정상 형태로 강요되도록 보장하고, 그렇지 않으면 발생하는 썽크의 수집을 피합니다. 이것은 종종 유한리스트를 하나의 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ) 로 엄격히 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">이 오류 메시지 :</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">이를 통해 모듈을 신뢰할 수 있지만 모듈 작성자가 보증을 제공합니다. 그런 다음이 모듈의 클라이언트는 모듈을 포함하는 패키지를 신뢰하도록 지정하여 모듈 작성자를 신뢰하도록 지정합니다. &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 은 모듈을 안전한 언어로 제한하지 않습니다. 그러나 &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;안전한 중복 인스턴스&lt;/a&gt; 만 허용하도록 중복 인스턴스의 해상도를 제한합니다 . 또한 안전한 가져 오기 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">이 예제는 이스케이프 연속이 작동하는 방식을 보여주고 사용법에 대한 일반적인 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">이 예는 다음 중 하나의 컷 다운 버전입니다.</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">이 예제는 &lt;code&gt;Type&lt;/code&gt; 생성자를 직접 사용한 경우 훨씬 복잡한 구성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">이 예제는 &lt;code&gt;Functor&lt;/code&gt; 만 필요합니다. Functor 는 &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 변환되기 때문입니다 . 더 복잡한 예제에는 &lt;code&gt;Applicative&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">이 예제는 생성자에 포함 된 값을 신경 쓰지 않을 때 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 를 사용하여 패턴 일치를 피하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">이 예제는 생성자에 포함 된 값을 신경 쓰지 않을 때 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 를 사용하여 패턴 일치를 피하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">이 예는 사용 &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 마이크로 소프트 워드의 기능을하지만, 제공 &lt;code&gt;HsStart&lt;/code&gt; 는 첫 번째 함수 전에 호출되며, &lt;code&gt;HsEnd&lt;/code&gt; 이 지난 후, 다음 그것을 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예는 원본 Concurrent Haskell 논문에서 수정되었습니다. 상위 레벨 동기화 프리미티브를 빌드하는 데 사용되는 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 더 많은 예는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">이 예제는 다음 예제에서 알 수 있듯이 명령문에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">이 예외는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 를 호출하는 다른 스레드 또는 어떤 이유로 스레드를 종료해야하는 경우 시스템에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">이 예외는 사용자가 일반적인 메커니즘 (예 : 콘솔의 Control-C)을 통해 프로그램 종료를 요청하면 프로그램의 기본 스레드에서 기본적으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">이 확장을 통해 프로그래머는 &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;IntMap&lt;/code&gt; , &lt;code&gt;Vector&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; 및 &lt;code&gt;Array&lt;/code&gt; 와 같은 구조 구성에 목록 표기법을 사용할 수 있습니다 . 다음 코드 목록은 몇 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">이 확장을 통해 모든 형식의 제약 조건을 작성할 수 있습니다 &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 는 &lt;code&gt;(==)&lt;/code&gt; 방법 의 두 번째 사용법에서 발생하는 &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 제약 조건 을 해결하는 데 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">이 확장을 사용하면 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#type-instance-declarations&quot;&gt;형식 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#closed-type-families&quot;&gt;닫힌 형식 패밀리&lt;/a&gt; , &lt;a href=&quot;#assoc-inst&quot;&gt;연결된 인스턴스&lt;/a&gt; 및 &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; 에서 형식 및 종류 변수를 명시 적으로 수량화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f49ba4e744c9be271237eb0c498b43e818d8451" translate="yes" xml:space="preserve">
          <source>This extension also relaxes some of the restrictions around data family instances. In particular, &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; permits a &lt;code&gt;newtype instance&lt;/code&gt; to be given a return kind of &lt;code&gt;TYPE r&lt;/code&gt;, not just &lt;code&gt;Type&lt;/code&gt;. For example, the following &lt;code&gt;newtype instance&lt;/code&gt; declarations would be permitted:</source>
          <target state="translated">이 확장은 또한 데이터 계열 인스턴스에 대한 일부 제한 사항을 완화합니다. 특히 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;newtype instance&lt;/code&gt; 에 &lt;code&gt;Type&lt;/code&gt; 뿐만 아니라 &lt;code&gt;TYPE r&lt;/code&gt; 의 반환 종류를 제공하도록 허용합니다 . 예를 들어, 다음 &lt;code&gt;newtype instance&lt;/code&gt; 선언이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">이 확장은 다음 위치에서 종류 서명을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">이 확장은 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을 일반화&lt;/a&gt; 합니다. GND 를 사용하여 &lt;code&gt;Num Unicode&lt;/code&gt; 를 파생 시키려면 ( &lt;code&gt;deriving newtype Num&lt;/code&gt; ) &lt;code&gt;Num Int&lt;/code&gt; 인스턴스를 재사용해야합니다 . 함께 &lt;code&gt;DerivingVia&lt;/code&gt; , 우리는 명시 적으로 표현 유형을 지정할 수 있습니다 &lt;code&gt;Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6100b971f8f1c7a7cc634cc306d12a82af5c029a" translate="yes" xml:space="preserve">
          <source>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified &lt;a href=&quot;#complete-kind-signatures&quot;&gt;the section on CUSKs&lt;/a&gt;.</source>
          <target state="translated">이 확장은 새 유형에 완전한 사용자 지정 종류 서명 (CUSK)이 있는지 여부를 결정하는 데 영향을줍니다. 정확한 영향은 &lt;a href=&quot;#complete-kind-signatures&quot;&gt;CUSK 섹션에 명시되어 있습니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ff362e6ce2b0d8092c35b1a623732b4842ee02e" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">이 확장은 &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MHC (MonadFail Proposal)&lt;/a&gt; 아래 GHC 8.6.1부터 기본적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="db2c878062f2c6f99bf839e6b59f2f657c40d838" translate="yes" xml:space="preserve">
          <source>This extension is temporary, and will be deprecated in a future release.</source>
          <target state="translated">이 확장은 일시적이며 이후 릴리스에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51aed31ab5dc37f8c4c608df090d56016afc9279" translate="yes" xml:space="preserve">
          <source>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</source>
          <target state="translated">이 기능은 GHC 8.0.x에서 실험 중이지만 이후 릴리스에서 기본값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="248986ebd9528e7c25e52eb6e4b4dede26b21415" translate="yes" xml:space="preserve">
          <source>This feature is no longer in GHC, but rewrite rules let you do the same thing:</source>
          <target state="translated">이 기능은 더 이상 GHC에 없지만 다시 쓰기 규칙을 사용하면 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f2d728a4138ae527fa096fa51af75f94d85b2c" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">이 기능은 GHC와 함께 제공되는 핵심 라이브러리 외부에서 사용하기위한 것이 아닙니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC 개발자 위키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee160906b857c67fe57bb11a964fcfc779b0e3a" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">이 기능은 GHC와 함께 제공되는 핵심 라이브러리 외부에서 사용하기위한 것이 아닙니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC 개발자 위키를&lt;/a&gt; 참조하세요. .</target>
        </trans-unit>
        <trans-unit id="a2a0010dea23f4d2c3a5e18529c4edce4ab678e9" translate="yes" xml:space="preserve">
          <source>This feature was added in GHC 7.4.1.</source>
          <target state="translated">이 기능은 GHC 7.4.1에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="55b7950f0dfe4e76a8ae330af2ece8c8a531dce2" translate="yes" xml:space="preserve">
          <source>This flag also enables the printing of &lt;em&gt;inferred&lt;/em&gt; type variables inside braces. See &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 또한 중괄호 안에 &lt;em&gt;유추 된&lt;/em&gt; 유형 변수를 인쇄 할 수있게합니다 . &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;유추 된 변수와 지정된 형식 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b07b2f670bc045df573c1ececcdcb07736068e4d" translate="yes" xml:space="preserve">
          <source>This flag appends a colon-separated list of &lt;code&gt;dirs&lt;/code&gt; to the search path.</source>
          <target state="translated">이 플래그는 콜론으로 구분 된 &lt;code&gt;dirs&lt;/code&gt; 목록을 검색 경로에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b10d8784b554d32814d37717727898e2e17029f6" translate="yes" xml:space="preserve">
          <source>This flag can be enabled to override any declared safety property of the module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of these flags were specified. This is particularly useful when compiling using plugins, which usually results in the compiled modules being marked as unsafe.</source>
          <target state="translated">이 플래그는 모듈의 선언 된 안전 속성 (Safe, Unsafe, Trustworthy)을 무시하도록 활성화 될 수 있으므로 이러한 플래그가 지정되지 않은 것처럼 컴파일이 진행됩니다. 이는 플러그인을 사용하여 컴파일 할 때 특히 유용하며, 일반적으로 컴파일 된 모듈이 안전하지 않은 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="24dac7bf8e47224079c398a6d277a8612ab70ec9" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to decrease the verbosity of the valid hole fit suggestions by not showing the provenance nor type application of the suggestions.</source>
          <target state="translated">이 플래그는 토글의 제안 또는 유형 적용을 표시하지 않음으로써 유효한 홀 맞춤 제안의 상세를 줄이기 위해 토글 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ce608eee3aba6eebf0d253b9eec2e8fe86f19e" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to turn off the display of valid hole fits entirely.</source>
          <target state="translated">이 플래그를 전환하여 유효한 구멍 맞춤 표시를 완전히 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="090f73c78c09543d9d38b2c5a37d696699bd497f" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flags, which enables this behaviour for &lt;a href=&quot;#typed-holes&quot;&gt;typed holes&lt;/a&gt; and variables. Should you so wish, it is possible to enable &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; without enabling &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;, by explicitly specifying &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fno-defer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; on the command-line after the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 플래그를 의미하며, 이는 &lt;a href=&quot;#typed-holes&quot;&gt;형식화 된 구멍&lt;/a&gt; 및 변수에 대해이 동작을 가능하게 합니다. 원하는 경우 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fno-defer-typed-holes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 를 명시 적으로 지정 하여 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 를 활성화하지 않고 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 를 활성화 할 수 있습니다. -fdefer- &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 플래그 다음에 명령 행에서 -defer-out-of-scope-variables .</target>
        </trans-unit>
        <trans-unit id="8a419a9746c4cf7f690ae762b4c975fdd0783957" translate="yes" xml:space="preserve">
          <source>This flag is hacker territory. The main purpose of this flag is to make it easy to debug and tune the new code layout algorithm. There is no guarantee that values giving better results now won&amp;rsquo;t be worse with the next release.</source>
          <target state="translated">이 깃발은 해커 영토입니다. 이 플래그의 주요 목적은 새로운 코드 레이아웃 알고리즘을 쉽게 디버깅하고 조정할 수 있도록하는 것입니다. 더 나은 결과를 제공하는 값이 다음 릴리스에서 더 나 빠지지 않을 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f00c8bb7e27cc51ca8b0f0d3dba471e43e3c711" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a definition is not inlined.</source>
          <target state="translated">이 플래그는 정의가 인라인되지 않은 이유를 디버깅하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="259f9f5ba8da11cbb10f0d1540dcc3a2d81b3b63" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a rule you expect to be firing isn&amp;rsquo;t.</source>
          <target state="translated">이 플래그는 실행하려는 규칙이 실행되지 않는 이유를 디버깅하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="913346e87539751c35ed9c7fbbe9dacd336e394e" translate="yes" xml:space="preserve">
          <source>This flag offers a workaround, albeit a slightly convoluted one. To be able to load an object file outside of the low 2Gb, the object code needs to be compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt;. When the &lt;code&gt;+RTS -xp&lt;/code&gt; flag is passed, the linker will assume that all object files were compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and load them anywhere in the address space. It&amp;rsquo;s up to you to arrange that the object files you load (including all packages) were compiled in the right way. If this is not the case for an object, the linker will probably fail with an error message when the problem is detected.</source>
          <target state="translated">이 플래그는 약간 복잡하지만 해결 방법을 제공합니다. 낮은 2Gb 외부에서 객체 파일을로드하려면 객체 코드를 &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; 로 컴파일해야합니다 . 때 &lt;code&gt;+RTS -xp&lt;/code&gt; 플래그가 전달되고, 링커는 모든 오브젝트 파일로 컴파일 된 것으로 가정합니다 &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; 과 주소 공간에서 어디를로드합니다. 로드하는 개체 파일 (모든 패키지 포함)이 올바른 방식으로 컴파일되었는지는 사용자가 결정합니다. 개체에 해당하지 않는 경우 링커는 문제가 감지 될 때 오류 메시지와 함께 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8510f05be6657462af6908558e01f9535cc7df" translate="yes" xml:space="preserve">
          <source>This flag passes &lt;code&gt;-Wundef&lt;/code&gt; to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the &lt;code&gt;#if&lt;/code&gt; directive on undefined identifiers.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-Wundef&lt;/code&gt; 를 C 전 처리기 (사용중인 경우)에 전달 하여 정의되지 않은 식별자 에서 &lt;code&gt;#if&lt;/code&gt; 지시문의 사용에 대해 전처리 기를 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="1da039cc7b4dc5b7877656e448f679fa2aaf620b" translate="yes" xml:space="preserve">
          <source>This flag selects one of a number of modes for finding shared libraries at runtime. See &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;Finding shared libraries at runtime&lt;/a&gt; for a description of each mode.</source>
          <target state="translated">이 플래그는 런타임시 공유 라이브러리를 찾기위한 여러 모드 중 하나를 선택합니다. 각 모드에 대한 설명은 &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;런타임시 공유 라이브러리 찾기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="707ef7038c152a9d95c30f93e519ab392f0434e0" translate="yes" xml:space="preserve">
          <source>This flag sets the size (in bytes) threshold above which the second approach is used. You can disable the second approach entirely by setting the threshold to 0.</source>
          <target state="translated">이 플래그는 두 번째 방법이 사용되는 크기 (바이트) 임계 값을 설정합니다. 임계 값을 0으로 설정하여 두 번째 접근 방식을 완전히 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd5e5d63941b332238370339bd4abcd493f7faf1" translate="yes" xml:space="preserve">
          <source>This flag specifies that a backspace at column 0 wraps the cursor to the last column of the previous line.</source>
          <target state="translated">이 플래그는 열 0의 백 스페이스가 커서를 이전 행의 마지막 열로 랩핑하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="03626a7094edacd615db3da035980eaa87b66cfc" translate="yes" xml:space="preserve">
          <source>This flag specifies that the cursor wraps automatically from the last column of one line to the first column of the next.</source>
          <target state="translated">이 플래그는 커서가 한 행의 마지막 열에서 다음 행의 첫 번째 열로 자동 랩핑되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="152fd56bf497fbd287fadf04927a68a1b45161ca" translate="yes" xml:space="preserve">
          <source>This flag specifies that the terminal does not perform &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt;-style wrapping when the character which would cause the wraparound is a control character. This is also known as the &quot;newline glitch&quot; or &quot;magic wrap&quot;.</source>
          <target state="translated">이 플래그 는 랩 어라운드를 야기하는 문자가 제어 문자 일 때 터미널이 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt; 스타일 랩핑을 수행하지 않도록 지정합니다 . 이것을 &quot;뉴 라인 글리치&quot;또는 &quot;매직 랩&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="237ea7657c0749769ad0460f79b1ebe14776910d" translate="yes" xml:space="preserve">
          <source>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see -shared). See &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt; on how to create them.</source>
          <target state="translated">이 플래그는 GHC에게 공유 Haskell 라이브러리에 연결하도록 지시합니다. 이 플래그는 현재 대상의 형식이 아닌 종속 라이브러리의 선택에만 영향을줍니다 (-shared 참조). &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;공유 라이브러리&lt;/a&gt; 작성 방법에 대한 공유 라이브러리 사용을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="548eff16b1f921e7136ec0c8b1d05c12f1aee8db" translate="yes" xml:space="preserve">
          <source>This flag used to be simply &lt;code&gt;-k&lt;/code&gt;, but was renamed to &lt;code&gt;-ki&lt;/code&gt; in GHC 7.2.1. The old name is still accepted for backwards compatibility, but that may be removed in a future version.</source>
          <target state="translated">이 플래그는 단순히 &lt;code&gt;-k&lt;/code&gt; 였지만 GHC 7.2.1에서는 &lt;code&gt;-ki&lt;/code&gt; 로 이름이 바뀌 었습니다 . 이전 이름은 이전 버전과의 호환성을 위해 여전히 허용되지만 이후 버전에서는 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="132a6f0fb187f19db841ab54e53adaeca2ba441f" translate="yes" xml:space="preserve">
          <source>This flag warns if you declare a module without declaring an explicit export list. For example</source>
          <target state="translated">명시 적 내보내기 목록을 선언하지 않고 모듈을 선언하면이 플래그가 경고합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c9662da7b45b17a0a6428b9dfe5bd157c250c8da" translate="yes" xml:space="preserve">
          <source>This flag warns if you use an unqualified &lt;code&gt;import&lt;/code&gt; declaration that does not explicitly list the entities brought into scope. For example</source>
          <target state="translated">이 플래그는 범위로 가져온 엔티티를 명시 적으로 나열하지 않는 규정되지 않은 &lt;code&gt;import&lt;/code&gt; 선언을 사용하는 경우 경고합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="164c1b4e302cfd37b98b634159b85132a613d2b3" translate="yes" xml:space="preserve">
          <source>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for information about unlifted types.</source>
          <target state="translated">이 플래그는 유형이 해제되지 않은 변수를 바인딩하는 패턴을 작성할 때마다 경고하지만 패턴은 뱅 패턴이나 베어 변수가 아닙니다. 언 리프트 &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;타입에&lt;/a&gt; 대한 정보는 언 박스 타입 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cae0b42613ae5635daabfb73c1fd1a6fde87c094" translate="yes" xml:space="preserve">
          <source>This flag was not implemented correctly and is now deprecated. It will be removed in a later version of GHC.</source>
          <target state="translated">이 플래그는 올바르게 구현되지 않았으며 이제 더 이상 사용되지 않습니다. 이후 버전의 GHC에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c3352dc95a1207a9c6e17148992da28a73903b" translate="yes" xml:space="preserve">
          <source>This form is intended to catch cases where an imported function that is marked as &lt;code&gt;INLINABLE&lt;/code&gt; (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</source>
          <target state="translated">이 양식은 &lt;code&gt;INLINABLE&lt;/code&gt; (아마도 전문화 가능) 로 표시된 가져온 함수를 특수화되지 않은 다른 함수를 호출하여 특수화 할 수없는 경우를 포착하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="05bd3fd9bbf23e07af768726368e949e8e01172d" translate="yes" xml:space="preserve">
          <source>This form is similar to the previous one, but allows you to create a function which will be passed as the first argument to f. As a consequence f must have the type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;. As you can see from the type, this function lets f &amp;ldquo;project out&amp;rdquo; some information from the elements of the list it is transforming.</source>
          <target state="translated">이 형식은 이전 형식과 유사하지만 f의 첫 번째 인수로 전달되는 함수를 작성할 수 있습니다. 결과적으로 f는 모든 유형을 가져야합니다 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 입니다. 유형에서 볼 수 있듯이이 기능을 사용하면 변환중인 목록의 요소에서 일부 정보를 &quot;투영&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b210b3ae2d9ae56e35b1c184f6366fb5e908d874" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="translated">이 함수는 선택적 선행 부호 문자와 하나 이상의 10 진수를 허용합니다. 후행 &lt;code&gt;'.'&lt;/code&gt; 을 제외 하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 함수에서 허용하는 구문과 유사한 구문 입니다. 또는 &lt;code&gt;'e'&lt;/code&gt; &lt;em&gt;하지&lt;/em&gt; 뒤에 숫자가 소모되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a796cd8e434fa9169ce349d782e3ca0927d44d88" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">이 함수는 주어진 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 종료 자를 추가합니다 . 종료 자는 이미 등록 된 동일한 객체에 대해 다른 모든 종료 자 &lt;em&gt;보다 먼저&lt;/em&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c44cb1ccf0b7e4784ceeb306a067bdfeb7b206c" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;ForeignPtr&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">이 함수는 주어진 &lt;code&gt;ForeignPtr&lt;/code&gt; 에 종료 자를 추가합니다 . 종료 자는 이미 등록 된 동일한 객체에 대해 다른 모든 종료 자 &lt;em&gt;보다 먼저&lt;/em&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f425649d9029247ad78fad40decd5202c4bc27eb" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given foreign object. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">이 함수는 주어진 외부 객체에 종료자를 추가합니다. 종료 자는 이미 등록 된 동일한 객체에 대해 다른 모든 종료 자 &lt;em&gt;보다 먼저&lt;/em&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f81d22635890e3a218f1ce58339b1c6ca6b2b5e3" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the current thread's event manager when using the threaded RTS and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">이 함수 는 스레드 RTS를 사용할 때 항상 현재 스레드의 이벤트 관리자 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 반환 하고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 반환 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a7ca54d1ebb1f65a298f3f5394187b62319bd58" translate="yes" xml:space="preserve">
          <source>This function behaves as though it was defined as follows:</source>
          <target state="translated">이 함수는 다음과 같이 정의 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a19a74c60710c427c9a8983f923cfe3116f4e33e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="translated">이 함수 는 입력 영역을 미리 채운다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt; 과 정확히 동일한 방식으로 작동 합니다. 입력 영역에있는 텍스트는 두 개의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이 있는 2 개의 튜플로 제공됩니다 . 튜플의 왼쪽에있는 문자열 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; 를 호출하여 획득 )은 커서 왼쪽에 표시되고 오른쪽에있는 문자열 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt; 를 호출하여 획득 )은 커서 오른쪽에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ccadaf8449c87b756fcca9de3051eea76595bb20" translate="yes" xml:space="preserve">
          <source>This function blocks only if there is no data available, and EOF has not yet been reached. Once EOF is reached, this function returns an empty string instead of throwing an exception.</source>
          <target state="translated">이 기능은 사용 가능한 데이터가없고 EOF에 아직 도달하지 않은 경우에만 차단합니다. EOF에 도달하면이 함수는 예외를 발생시키는 대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3727686d1f0656f78fbd676216e6218bba0d8f05" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">이 함수는 특히 파일 이름 자체에 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 보다 예측 가능할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="95f9843654954e98c26a755ad5eb70155e80d09e" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">이 함수는 특히 파일 이름 자체에 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 보다 예측 가능할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="6370e62b7224731eb33323a61cd0cd0212bd73ab" translate="yes" xml:space="preserve">
          <source>This function can be used to parse commandline arguments and return the split up arguments as elements in a list.</source>
          <target state="translated">이 함수는 명령 행 인수를 구문 분석하고 분할 된 인수를 목록의 요소로 리턴하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b011ec479c4f18015f65a01a6cb42ad6c894e37" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">이 함수 는 한 유형별로 매개 변수화 된 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다른 유형으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="8455333cef6a211c11d46770009f2e17b149dc91" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">이 함수 는 한 유형별로 매개 변수화 된 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다른 유형으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="4c95a06b11246310d156afc3703af8aa75228ea4" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">이 함수 는 한 유형별로 매개 변수화 된 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다른 유형으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="bae8bc388aa8fda5c095416ea7ccdf604e21a4b9" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3b38848479394206747ac44eca6fc387251ec91" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5db91917bf331211a29772aa52154e422f3f1d5b" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="519eb4a4b4c327867fd23f6eab3128242f48c9bb" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="857206c786beb79b34c3684c023645a579f1bf0a" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">이 함수는 복사를 전혀 수행하지 않고 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 풀어 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 으로 표시합니다 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; 두 가지 방법 :</target>
        </trans-unit>
        <trans-unit id="0c2f12c1f574e8470c8cd228760ee018fd8aa95d" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">이 기능은 제로 복사를 수행하고, 단지 펼쳤다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; A와 나타나는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a47c3f2d7d39a2c3b063895b58a717924193e65c" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">이 함수는 제로 복사를 수행하고 단순히 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 래핑 해제 하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 으로 표시합니다 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; 두 가지 방법 :</target>
        </trans-unit>
        <trans-unit id="c7536fe5974322621a8dd1f75ea634bfbda36cef" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">이 기능은 제로 복사를 수행하고, 단지 펼쳤다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; A와 나타나는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="f085bd357a8ba52ec5bf8ea2e8098bb00f21c4f3" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">이 기능은 해당 이물질이 일련의 IO 동작에서 지정된 위치에 존재하도록합니다. 특히 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 은 사용자 조치를 실행 한 후 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fb2f540bf09969c8d0c8f8908ba854010bd23f1b" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">이 기능은 해당 이물질이 일련의 IO 동작에서 지정된 위치에 존재하도록합니다. 특히 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 은 사용자 조치를 실행 한 후 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2149a9af262bcc49b7038b2f4d5b65dcac58accb" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">이 기능은 해당 이물질이 일련의 IO 동작에서 지정된 위치에 존재하도록합니다. 특히 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 은 사용자 조치를 실행 한 후 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="56e6ded1b8cebed967e3f67bfe07578a6914f462" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">이 함수는 외부 포인터의 포인터 구성 요소를 추출합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 에 대한 인수가 지정된 외부 포인터의 마지막 사용 발생 인 경우 종료자가 실행되어 방금 얻은 일반 포인터가 무효화되는 것처럼 잠재적으로 위험한 작업 입니다. 따라서 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 은 포인터의 위치가 보장되어야 할 때마다 사용해야합니다. 즉, 다른 사용법이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49a9ef9954f7355cd3182b557ae76bf73f873f39" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">이 함수는 외부 포인터의 포인터 구성 요소를 추출합니다. &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 에 대한 인수가 지정된 외부 포인터의 마지막 사용 발생 인 경우 종료자가 실행되어 방금 얻은 일반 포인터가 무효화되는 것처럼 잠재적으로 위험한 작업 입니다. 따라서 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 은 포인터의 위치가 보장되어야 할 때마다 사용해야합니다. 즉, 다른 사용법이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="297ce1fcde50c3e64b2e180ca7a8295dfe927277" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 결과와 비교할 때와 같은 대답을 제공 하지만 문자 수가 숫자보다 많으면 더 단락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9bfe488bf922598761ef0e89e23f74a82ced08d" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number or if the stream can't possibly be as long as the number supplied, and hence be more efficient.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt; 의 결과와 비교할 때와 같은 대답을 제공 하지만 문자 수가 숫자보다 많거나 스트림이 제공된 수만큼 길어서 더 효율적일 경우 단락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c6fa989d414314e9aa49500aecc381f432a513" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 결과와 비교할 때와 같은 대답을 제공 하지만 문자 수가 숫자보다 많으면 더 단락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb23fb6497a24d6ecb9c3763d5c34edba9c40d0" translate="yes" xml:space="preserve">
          <source>This function has been available from the &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; module for some time, and is part of the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module since version 1.2.1.0.</source>
          <target state="translated">이 기능은 한동안 &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; 모듈 에서 사용 가능했으며 버전 1.2.1.0부터 &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; 모듈의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="a6e9d76dad212825f2ce225dc9cdac55e8d4e959" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt; 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="be411b927981a56314a00c20ba75fa59b5652a67" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c2e5206205cd6b75d161fb7bfc7299c5bdb8abf" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 정지 된 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1be0ffbb5619ad9aa9e30d9508745c85fb811ff4" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 정지 된 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36afc198b9f7118549c1b6104d61dadd4fcd1cd4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">이 기능은 두 가지 방식으로 &lt;em&gt;안전하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2a132e2c97ab0ed1a1b3a90355bbe48b412b6f7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, as there may be other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s referring to the same underlying pages. If you use this, you need to have a proof of some kind that all &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s ever generated from the underlying byte array are no longer live.</source>
          <target state="translated">동일한 기본 페이지를 참조하는 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이있을 수 있으므로이 함수는 &lt;em&gt;안전하지 &lt;/em&gt;않습니다 . 이것을 사용 하면 기본 바이트 배열에서 생성 된 모든 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 더 이상 유효 하지 않다는 증거가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bf420b59471bce124dbbd8b697170ee16a0713d7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, it is possible to break referential transparency by modifying the underlying buffer pointed to by the first argument. Any changes to the original buffer will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;안전하지&lt;/em&gt; 않습니다. 첫 번째 인수가 가리키는 기본 버퍼를 수정하여 참조 투명성을 해제 할 수 있습니다. 원래 버퍼에 대한 변경 사항은 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="3455262f8a39897a50aa39230052cbe6dba0d568" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을가 나중에 수정이 변경 사항이 결과에 반영됩니다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 참조 투명성을 깨고.</target>
        </trans-unit>
        <trans-unit id="1834d9d84b56bb752c51f02a1d644b2b93d96323" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을가 나중에 수정이 변경 사항이 결과에 반영됩니다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 참조 투명성을 깨고.</target>
        </trans-unit>
        <trans-unit id="e2747e624978d112ce90afa471f172dfb2b9cd31" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 나중에 수정하면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영되어 참조 투명성을 손상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f0382305dc3450f3e698022f8c72e2ed93bc7c33" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 나중에 수정하면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영되어 참조 투명성을 손상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f349071f25d8991d866f99530006dd7090d11a0c" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 이 나중에 수정되면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영됩니다. 참조 투명도가 깨집니다.</target>
        </trans-unit>
        <trans-unit id="e7b49b304d9d1b37bde4bfa9bfeb7383e8f4a58d" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 이 나중에 수정되면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영되어 참조 투명도가 깨집니다.</target>
        </trans-unit>
        <trans-unit id="4a191d5e90e0d3c89ab168efaec7413d2cd0acb4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 이 가리키는 버퍼를 수정하면 이 수정 내용이 결과 &lt;code&gt;ByteString&lt;/code&gt; 에 반영되어 참조 투명성이 손상 됩니다.</target>
        </trans-unit>
        <trans-unit id="ce62a4da0ca7ff6594e5735e96a49ced57bae709" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 가리키는 버퍼를 수정하면 이 수정이 결과 &lt;code&gt;ByteString&lt;/code&gt; 에 반영되어 참조 투명성이 깨집니다.</target>
        </trans-unit>
        <trans-unit id="c9bb19123a210482015c0eb529407c8c92bd8a9d" translate="yes" xml:space="preserve">
          <source>This function is almost identical to &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;. The only differences are:</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 와 거의 동일합니다 . 유일한 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="127b48d0ce942f2e91014031d7ba1b7c2f584c47" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">finalizer를 두 번 호출하여 &lt;em&gt;double free&lt;/em&gt; 오류가 발생하거나 &lt;code&gt;malloc&lt;/code&gt; 으로 할당되지 않은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 에 전달하면 이 함수도 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="725d98580cd2d533b5eb08b0b83d5983bcb4d0b9" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">이 함수는 종료자를 두 번 호출하여 &lt;em&gt;이중 자유&lt;/em&gt; 오류가 발생하거나 &lt;code&gt;malloc&lt;/code&gt; 로 할당되지 않은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 전달하는 경우 에도 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a1352738c1dd68227a434686b430958d3c19705e" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="3624112a91081c7d0092b5f7cbbb5f82d405f7c9" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b637539c4592b1c460f40d32f474fe342dccfe09" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e297580fc2021dc8c611b1cab7ef8ab0b1a171b6" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d928e0ca94addd99cca4a82d7c03710b0e1ff8e8" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a7dbf169335c01f89eb6a63ed0156362fcda8c5" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c431a15b17f66529ec0971f021718a3de7606559" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="78dce4476ccaf3b80909ed078582168f3c380495" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0be1b4711ed0b36e7147869439e2d34b0cf4d927" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="13a1297dbe50a5705a1a7b087e24f8f8c0611b79" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 와 같습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 터미널에 연결되어 있고 에코가 활성화 된 경우 터미널 스타일 상호 작용을 사용합니다. 그렇지 않으면 (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 파이프 인 경우) 파일 스타일 상호 작용을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="74b22623dc818147f2c6f57929328997d17b3b24" translate="yes" xml:space="preserve">
          <source>This function is identical to the normal unsafeInterleaveST, but is inlined and hence faster.</source>
          <target state="translated">이 함수는 일반적인 unsafeInterleaveST와 동일하지만 인라인되어 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="3df65f8bec8d8ab7b43b6ab0ab2e82da15c0ef13" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">이 함수는 코드 크기가 크더라도 할당 전략과 융합 할 수 있도록 인라인되어 있습니다. 예를 들어, 기본 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 함수 &lt;code&gt;toLazyByteString&lt;/code&gt; 은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="235b6b044bd31212b9719a4b1325277577dea428" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">이 함수는 코드 크기가 크더라도 할당 전략과 융합 할 수 있도록 인라인되어 있습니다. 예를 들어, 기본 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 함수 &lt;code&gt;toLazyByteString&lt;/code&gt; 은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5e260df7d73e67cac6b68c2a311d7baa6dc73777" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (also known as case insensitive) string comparisons.</source>
          <target state="translated">이 함수는 대소 문자를 구분하지 않고 대소 문자를 구분하지 않는 문자열 비교를 수행 할 때 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="982fe52bf42753f9c092c03c7dda6cf3ea3642ac" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (or case insensitive) string comparisons.</source>
          <target state="translated">이 함수는 주로 대소 문자를 구분하지 않거나 대소 문자를 구분하지 않는 문자열 비교를 수행하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="88a949c7c5b9a60ae7e9844db387f3275f199bc9" translate="yes" xml:space="preserve">
          <source>This function is meant to be invoked from any application level cleanup handler. It terminates the process, and closes any &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle&lt;/code&gt;s.</source>
          <target state="translated">이 기능은 모든 응용 프로그램 수준 정리 처리기에서 호출하기위한 것입니다. 프로세스를 종료하고 &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle&lt;/code&gt; 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="00b26bf5c664293ce811e9f9293ca81ecc310513" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">이 기능은 &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; 보다 효율적 입니다. 많은 경우 버퍼 할당을 수행 할 필요가 없기 때문에 toLazyByteString . 또한 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 여러 실행 결과 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 버퍼에 연결 되므로 불필요한 버퍼 플러시를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af91de3226aaac03a1110fced423ab247dd1f835" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">이 함수는 &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; 보다 효율적 입니다. toLazyByteString 은 대부분의 경우 버퍼 할당을 수행 할 필요가 없기 때문입니다. 또한 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 여러 실행 결과가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 버퍼에 연결되어 불필요한 버퍼 플러시를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="81cef0e8688cdc48d9b9ff9c39a55f003fae9595" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 의 작업을 사용하여 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 가리키는 개체와 데이터를 마샬링하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcc8eee9cef2591d3719a4001c66eea308bb00b1" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 의 작업을 사용하여 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 가리키는 개체와 데이터를 마샬링하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f40048a5f3caebc5fe300ab653bf30f1e2b70070" translate="yes" xml:space="preserve">
          <source>This function is only defined if &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; and &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; (Note: the documentation claims that only &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; is supported, however the actual implementation supports up to base 256).</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; 및 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; 경우에만 정의됩니다 (참고 : 문서에서는 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; 만 지원 한다고 주장 하지만 실제 구현은 최대 256을 지원합니다).</target>
        </trans-unit>
        <trans-unit id="213dcd0849e6345864ca5752cd6d03ec515775cd" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리 크기가 명시 적으로 여러 바이트로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="7180b41a302c7c04e8da7fd8f83d119c939f7280" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리 크기가 명시 적으로 여러 바이트로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="5f63596c51e12b4f409448cb34c60a65c7a9ca0d" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 메모리 영역을 해제하는 종료자가 연결된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4083768355a45fdb0a42de16aa51a3af8c228c66" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 메모리 영역을 해제하는 종료자가 연결된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b1d46b44ea9232c55a861a5d882fa3688f6cd96" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 메모리 영역을 해제하는 종료 장치가 첨부 된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7672c2399ed76b968a47b4291c113d59075f7990" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 메모리 영역을 해제하는 종료 장치가 첨부 된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff12ee367a6fdd15f0645b4e1ebf055ffe60727" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리 크기가 명시 적으로 여러 바이트로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="b6c52e12f35a2275476d84741c02f0045857af05" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt; 이없는 내부적으로 최적화 된 ForeignPtr 표현이 사용된다는 점을 제외하고 mallocForeignPtrAlignedBytes 와 유사합니다 . 종료자를 추가하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8bb381fc113886f37459f57bc0e517e18d58f74" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 이없는 내부적으로 최적화 된 ForeignPtr 표현이 사용된다는 점을 제외하면 mallocForeignPtrBytes 와 유사합니다 . 종료자를 추가하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d6f8324541e76c432236c537e2a380f498fdc16" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the size and alignment of the memory required is given explicitly as numbers of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리의 크기와 정렬이 명시 적으로 바이트 수로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="c6266d7b17854517fbd86bf34d982e2073442b47" translate="yes" xml:space="preserve">
          <source>This function is strict in &lt;code&gt;needle&lt;/code&gt;, and lazy (as far as possible) in the chunks of &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;needle&lt;/code&gt; 에서 엄격하고 &lt;code&gt;haystack&lt;/code&gt; 덩어리에서 게으르다 (가능한 한) .</target>
        </trans-unit>
        <trans-unit id="f216683cc82aa64de779d88daeaba4d1152d651d" translate="yes" xml:space="preserve">
          <source>This function is strict in its first argument, and lazy in its second.</source>
          <target state="translated">이 함수는 첫 번째 인수에서 엄격하고 두 번째 인수에서 게으르다.</target>
        </trans-unit>
        <trans-unit id="b0b32655d3a8d92812d81f5285c18f655d5a3859" translate="yes" xml:space="preserve">
          <source>This function is strict in the computed result and lazy in the writing of the bytes. For example, given</source>
          <target state="translated">이 함수는 계산 결과가 엄격하고 바이트 쓰기가 게으 릅니다. 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="d42e669b72fdf00ca69c1146fbc6cd4f7fd2b0e3" translate="yes" xml:space="preserve">
          <source>This function is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 순수 코드에서 사용하기에 적합합니다. IO 컨텍스트에서는 대신 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3b80efc4be65cc4f7d016d8e9df62478b06cdd3" translate="yes" xml:space="preserve">
          <source>This function is unsafe because the program behavior is undefined if the type of the returned &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; does not match the expected one.</source>
          <target state="translated">반환 된 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 의 유형 이 예상 한 유형과 일치하지 않으면 프로그램 동작이 정의되지 않으므로이 함수는 안전 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0ef53dc671c66eb4f726f95bfbceabd2738d518" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 리터럴 을 구성하기 위해 GHC에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5abca3b3eff9479232b2f8880d6591a9960af27b" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">이 함수는 GHC에서 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 리터럴 을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a76dc2ebb647a8a46428d99317295ae5c89ee276" translate="yes" xml:space="preserve">
          <source>This function is useful for informing the parent when a child terminates, for example.</source>
          <target state="translated">이 기능은 예를 들어 자녀가 종료 될 때 부모에게 알리는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d5042b5be97cdd0d8f13f55579035132f9596b0e" translate="yes" xml:space="preserve">
          <source>This function is useful for using &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; in a safe way in a multithreaded program. If you only have one &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, then using &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; to access and modify it will prevent race conditions.</source>
          <target state="translated">이 기능은 멀티 스레드 프로그램에서 안전한 방식으로 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 를 사용하는 데 유용합니다 . 하나만있는 경우 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 사용하여 다음을 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 를 액세스하고 수정이 경쟁 조건을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f182126e093e425fc7c58b56f7052d3cc81fd2" translate="yes" xml:space="preserve">
          <source>This function isn't suitable when we want to set the cTRL_C_EVENT handler. If you want to set the cTRL_C_EVENT handler, use &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 cTRL_C_EVENT 핸들러를 설정하려고 할 때 적합하지 않습니다. cTRL_C_EVENT 핸들러를 설정하려면 대신 &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9871f6366cef22e329fca1bc704e039bd6520451" translate="yes" xml:space="preserve">
          <source>This function maps one exception into another as proposed in the paper &quot;A semantics for imprecise exceptions&quot;.</source>
          <target state="translated">이 함수는 &quot;정확하지 않은 예외에 대한 의미론&quot;논문에서 제안한대로 하나의 예외를 다른 예외에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="1a5ff8da6eff5ff073f1ef4ac1e4757b5f92be33" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="626e558e3754f72bcf94652b857bc1fadf635831" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, provided that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is defined. (Using &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instance defined only by &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; will result in infinite recursion.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 가 정의 된 경우이 함수는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 . &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 로만 정의 된 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스 와 함께 &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; 를 사용하면 무한 재귀가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e58338f4629941ddeb6081adb1d67e46144c1a35" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written and the same value being computed. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, monadic sequencing of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">이 기능은 참조 적으로 투명해야합니다. 즉, 동일한 크기의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 여러 번 호출 하면 동일한 바이트 시퀀스가 ​​작성되고 동일한 값이 계산되어야합니다. 변경 가능한 상태가 필요한 경우이 함수를 호출 할 때마다 새로 할당해야합니다. 무어 인 경우,이 함수는 연속이 완료되면 호출해야합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 의 모노 닉 시퀀싱이 작동하지 않습니다. 마지막으로,이 함수는 그것이 작성했다고 주장하는 모든 바이트에 써야합니다. 그렇지 않으면 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 투명성을 보장하지 않으며 민감한 데이터가 유출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45d9a503757dbc2e079e55bb2d136d8ac259338" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">이 기능은 참조 적으로 투명해야합니다. 즉, 동일한 크기의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 여러 번 호출 하면 동일한 바이트 시퀀스가 ​​작성되어야합니다. 변경 가능한 상태가 필요한 경우이 함수를 호출 할 때마다 새로 할당해야합니다. 무어 인 경우,이 함수는 연속이 완료되면 호출해야합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 연결이 작동하지 않습니다. 마지막으로,이 함수는 그것이 작성했다고 주장하는 모든 바이트에 써야합니다. 그렇지 않으면 결과로 생성 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 가 참조 투명성을 보장하지 않으며 민감한 데이터가 유출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b24ee1d1129f69b81aa438d99f4c55ce18780e" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">이 함수는 한 번에 청크를 읽고 각 판독에서 청크 크기를 증가시킵니다. 그런 다음 최종 문자열은 적절한 크기로 재 할당됩니다. 사용 가능한 메모리의 절반보다 큰 파일의 경우 메모리가 소진 될 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb38f0c0e138df73f1bb18283100e26479279ef9" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">이 함수는 한 번에 청크를 읽고 각 판독에서 청크 크기를 증가시킵니다. 그런 다음 최종 문자열은 적절한 크기로 재 할당됩니다. 사용 가능한 메모리의 절반보다 큰 파일의 경우 메모리가 소진 될 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="b96182eaae363b6548da5c4708f3fee19d0eba44" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">이 함수는 인수에 다음 &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 중 하나가 있으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08b901589b02acf03fdb2c4330ddaefe06ce9626" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">이 함수는 인수에 다음 &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 중 하나가 있으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="829c7b2049bce335518e8e6987f223cd44774ac1" translate="yes" xml:space="preserve">
          <source>This function should not be called on a closed or cancelled &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 닫히거나 취소 된 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 에서 호출하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="4becc58728105fc63f4543e724ceed3d0b38faa9" translate="yes" xml:space="preserve">
          <source>This function takes an adjacency list representing a graph with vertices of type &lt;code&gt;key&lt;/code&gt; labeled by values of type &lt;code&gt;node&lt;/code&gt; and produces a &lt;code&gt;Graph&lt;/code&gt;-based representation of that list. The &lt;code&gt;Graph&lt;/code&gt; result represents the &lt;em&gt;shape&lt;/em&gt; of the graph, and the functions describe a) how to retrieve the label and adjacent vertices of a given vertex, and b) how to retrive a vertex given a key.</source>
          <target state="translated">이 함수는 &lt;code&gt;node&lt;/code&gt; 유형의 값으로 레이블이 지정된 &lt;code&gt;key&lt;/code&gt; 유형의 정점이있는 그래프를 나타내는 인접 목록을 가져 와서 해당 목록 의 &lt;code&gt;Graph&lt;/code&gt; 기반 표현을 생성 합니다. &lt;code&gt;Graph&lt;/code&gt; 결과가 나타내는 &lt;em&gt;형상&lt;/em&gt; 주어진 정점의 라벨 인접한 정점을 검색하고, b) 방법 키 주어진 정점을 가져 오지 방법)의 그래프를, 상기 기능들은 설명합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6070795d0875a01577e4829d564fa22e24b1b00c" translate="yes" xml:space="preserve">
          <source>This function takes an extra &lt;code&gt;String&lt;/code&gt; argument to be used in creating error messages.</source>
          <target state="translated">이 함수는 오류 메시지를 작성하는 데 사용할 추가 &lt;code&gt;String&lt;/code&gt; 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f0c1ada42e597613fc7e7e6786e2387ef148b77" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 이외의 다른 경우이 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 . 대신 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 를 얻으려면 &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="12b8c3042780b1688ac6a3ee1fab2256e1f014dd" translate="yes" xml:space="preserve">
          <source>This function will be invoked at two points in the constraint solving process: after simplification of given constraints, and after unflattening of wanted constraints. The two phases can be distinguished because the deriveds and wanteds will be empty in the first case. In each case, the plugin should either</source>
          <target state="translated">이 함수는 제한 조건 해결 프로세스에서 두 가지 지점에서 호출됩니다. 주어진 제한 조건을 단순화 한 후 및 원하는 제한 조건을 전개하지 않은 후. 두 단계는 도출 될 수 있고 원치 않는 것이 첫 번째 경우에 비어 있기 때문에 구별 될 수 있습니다. 각각의 경우 플러그인은</target>
        </trans-unit>
        <trans-unit id="6467a527fa88959e8823896b96be26bf195128c1" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; which has some implementation pecularities to take into account:</source>
          <target state="translated">이 함수는 &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; 를 래핑 하는데, 여기에는 몇 가지 구현 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80485bdbfd7c212c63fd29a0333499c58e82d6b5" translate="yes" xml:space="preserve">
          <source>This function, like &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt;, has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt; 과 같은이 함수 는 고정 된 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="842a68272f46af66e4862fdc0bc066609f64b0e0" translate="yes" xml:space="preserve">
          <source>This generalizes the list-based &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이것은 목록 기반 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 기능을 일반화합니다 .</target>
        </trans-unit>
        <trans-unit id="b2ff47cfc567ef028dcfe716cd26e468cb33a9de" translate="yes" xml:space="preserve">
          <source>This generates one file per Haskell module, and 4 index files, &lt;code&gt;hpc_index.html&lt;/code&gt;, &lt;code&gt;hpc_index_alt.html&lt;/code&gt;, &lt;code&gt;hpc_index_exp.html&lt;/code&gt;, &lt;code&gt;hpc_index_fun.html&lt;/code&gt;.</source>
          <target state="translated">이는 Haskell 모듈 당 하나의 파일과 &lt;code&gt;hpc_index.html&lt;/code&gt; , &lt;code&gt;hpc_index_alt.html&lt;/code&gt; , &lt;code&gt;hpc_index_exp.html&lt;/code&gt; , &lt;code&gt;hpc_index_fun.html&lt;/code&gt; 색인 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c5344bdf0cc9457503d3d92a9eb3e0f2cb07653d" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;unpinned&lt;/a&gt;&lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">이는 &lt;code&gt;safe&lt;/code&gt; 외부 함수 호출에 힙 개체 참조를 전달하는 것이 안전하지 않다는 것을 의미하므로 라이브러리 작성자를 크게 제한합니다 . 예를 들어, &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;고정되지 않은 &lt;/a&gt; &lt;code&gt;ByteArray#&lt;/code&gt; 를 네이티브 코드에 직접 전달하여 불필요한 복사본을 만드는 것을 방지하는 것이 바람직합니다 . 그러나 이것은 호출 중에 가비지 수집기에 의해 배열이 이동되지 않도록 보장되는 경우에만 안전하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c64c30705c50c32c9be3389ffedce10aebc7f56" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an unpinned &lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">이는 힙 객체 참조를 &lt;code&gt;safe&lt;/code&gt; 외부 함수 호출 에 전달하는 것이 안전하지 않기 때문에 라이브러리 작성자를 크게 제한합니다 . 예를 들어, 불필요한 복사를 피하기 위해 고정되지 않은 &lt;code&gt;ByteArray#&lt;/code&gt; 를 원시 코드로 직접 전달하는 것이 바람직합니다 . 그러나 이것은 호출 도중에 가비지 콜렉터가 배열을 이동시키지 않는 경우에만 안전하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41834e436d1719d30cabcc4b9b9f363c58c43156" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 호출과 같은 효과를 갖는다 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 가진 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 함께, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="6ae7b2e29f0249e038dc6f2d5f144f9852f9724a" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 호출과 같은 효과를 갖는다 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 가진 &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 함께, &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="74c85cbe0088849b70271ff6b2b4f90df21c84ea" translate="yes" xml:space="preserve">
          <source>This has two effects. The first is to compile the code in such a way that it can be linked against shared library versions of Haskell packages (such as base). The second is when linking, to link against the shared versions of the packages&amp;rsquo; libraries rather than the static versions. Obviously this requires that the packages were built with shared libraries. On supported platforms GHC comes with shared libraries for all the core packages, but if you install extra packages (e.g. with Cabal) then they would also have to be built with shared libraries (&lt;code&gt;--enable-shared&lt;/code&gt; for Cabal).</source>
          <target state="translated">이것은 두 가지 효과가 있습니다. 첫 번째는 공유 라이브러리 버전의 Haskell 패키지 (예 : base)와 링크 될 수있는 방식으로 코드를 컴파일하는 것입니다. 두 번째는 링크 할 때 정적 버전이 아닌 패키지 라이브러리의 공유 버전에 대한 링크입니다. 분명히 패키지를 공유 라이브러리로 빌드해야합니다. 지원되는 플랫폼에서 GHC는 모든 핵심 패키지에 대한 공유 라이브러리와 함께 제공되지만 추가 패키지 (예 : Cabal)를 설치하는 경우 공유 라이브러리 ( Cabal의 경우 &lt;code&gt;--enable-shared&lt;/code&gt; ) 로 빌드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="548fc7aaea96607acee200e9ba71f5d0c6b166be" translate="yes" xml:space="preserve">
          <source>This idea is very old; see Seciton 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable type classes&lt;/a&gt;.</source>
          <target state="translated">이 아이디어는 매우 오래되었습니다. 파생 가능 &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;클래스&lt;/a&gt; 의 Seciton 7을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9630590333acefa1eb165b1fdb491f1028f3c007" translate="yes" xml:space="preserve">
          <source>This implemenation uses &lt;code&gt;memset(3)&lt;/code&gt;</source>
          <target state="translated">이 구현은 &lt;code&gt;memset(3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884b09618f3fa095f6ec125ed96fbbf8ccd437a1" translate="yes" xml:space="preserve">
          <source>This implementation is intentionally naive. Instances are expected to provide an optimized implementation for their size.</source>
          <target state="translated">이 구현은 의도적으로 순진합니다. 인스턴스는 규모에 맞게 최적화 된 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="621e9b697c58fe612c7eaaea244ee764c09bb5f3" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">이는 단일 바이트 만 포함하더라도 출력 버퍼를 비우는 것을 의미합니다. 그러므로 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 만 대형 (위해 &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 들. 그렇지 않으면 생성 된 청크가 너무 조각화되어 나중에 효율적으로 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec6a5f5a381024ce57d5b678b6cb847a23f169c1" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">이는 단일 바이트 만 포함하더라도 출력 버퍼를 비우는 것을 의미합니다. 그러므로 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 만 대형 (위해 &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 들. 그렇지 않으면 생성 된 청크가 너무 조각화되어 나중에 효율적으로 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f03bf2766810922713f86acfde0e9c886b0e80e" translate="yes" xml:space="preserve">
          <source>This improves efficiency slightly but significantly for most programs, and is bad for only a few. To suppress this bogus &amp;ldquo;optimisation&amp;rdquo; use &lt;code&gt;-fpedantic-bottoms&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 대부분의 프로그램에서 효율성이 약간 향상되지만 크게 향상되지는 않습니다. 이 가짜 &quot;최적화&quot;를 억제하려면 &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c3ae98027814be110bac171a0407c5649c80296" translate="yes" xml:space="preserve">
          <source>This includes the main thread, so using &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; is a good way to see how much stack space the program is using.</source>
          <target state="translated">여기에는 주 스레드가 포함되므로 &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; 를&lt;/a&gt; 사용 하면 프로그램에서 사용중인 스택 공간을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a0e9f59821fc6a5f78b81c882c88a9ce445a90" translate="yes" xml:space="preserve">
          <source>This indicates that there may be more data to write. It gives you the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. You should call that action with an appropriate buffer. The int indicates the &lt;em&gt;minimum&lt;/em&gt; buffer size required by the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. That is, if you call the next action you &lt;em&gt;must&lt;/em&gt; supply it with a buffer length of at least this size.</source>
          <target state="translated">이것은 더 많은 데이터를 쓸 수 있음을 나타냅니다. 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 작업을 제공합니다 . 적절한 버퍼로 해당 조치를 호출해야합니다. int는 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 작업에 필요한 &lt;em&gt;최소&lt;/em&gt; 버퍼 크기를 나타냅니다 . 즉, 다음 조치를 호출하면 최소한이 크기의 버퍼 길이를 제공 &lt;em&gt;해야합니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12dc46ef50110e91a94e6d325a61778b34facf10" translate="yes" xml:space="preserve">
          <source>This inlining occurs regardless of the argument to the call or the size of &lt;code&gt;f&lt;/code&gt;'s definition; it is unconditional. The main caveat is that &lt;code&gt;f&lt;/code&gt;'s definition must be visible to the compiler; it is therefore recommended to mark the function with an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition so that GHC guarantees to record its unfolding regardless of size.</source>
          <target state="translated">이 인라이닝은 호출에 대한 인수 나 &lt;code&gt;f&lt;/code&gt; 정의 크기에 관계없이 발생합니다 . 무조건적입니다. 주된주의 사항은 &lt;code&gt;f&lt;/code&gt; 의 정의가 컴파일러에 표시되어야한다는 것입니다. 따라서 GHC가 크기에 관계없이 전개를 기록 할 수 있도록 정의에 &lt;code&gt;INLINABLE&lt;/code&gt; pragma를 사용하여 기능을 표시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1ef01da60f8e50833762de51e88f6f38500b8529" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">플러그인을 코어-투-코어 패스로 삽입합니다. &lt;code&gt;-fplugin=(module)&lt;/code&gt; 과 달리 플러그인 모듈은 &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin을&lt;/a&gt; 호출하는 모듈과 동일한 패키지에 상주 할 수 없습니다 . 이런 식으로, 구현은 플러그인이 필요할 때까지 빌드 될 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff50fa3f4d1717b720187c6141e26cd711cc26f" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">이렇게하면 플러그인이 코어 대 코어 패스로 삽입됩니다. &lt;code&gt;-fplugin=(module)&lt;/code&gt; 과 달리 플러그인 모듈은 &lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin을&lt;/a&gt; 호출하는 모듈과 동일한 패키지에있을 수 없습니다 . 이러한 방식으로 구현시 필요한 시간에 플러그인이 빌드 될 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c72aeeca496ff034d5ed0f5d68c44678b8f30bdc" translate="yes" xml:space="preserve">
          <source>This instance has similar considerations to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instance: it preserves abstraction at the cost of inefficiency.</source>
          <target state="translated">이 인스턴스는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스 와 비슷한 고려 사항이 있습니다. 비효율적 인 비용으로 추상화를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f4e5c9cc750ce5f88a69b78165e5f0f4d42bcbfe" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">이 인스턴스는 편의성과 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 와의 일관성을위한 것 입니다. 이것은 WHNF가 함수의 NF와 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0eaa2be703bfed5db1962bf2e87d773ccbf9e44d" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">이 인스턴스는 편리하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 와의 일관성을위한 것 입니다. 이것은 WHNF가 함수의 NF와 동일하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="292d6bb24eb4520bb3e5e03c32ef914fb200aaac" translate="yes" xml:space="preserve">
          <source>This instance is only usable if the constructor &lt;code&gt;MkNT&lt;/code&gt; is in scope.</source>
          <target state="translated">이 인스턴스는 생성자 &lt;code&gt;MkNT&lt;/code&gt; 가 범위 내에 있는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f66688755fda8b6fa988624af4229d29f0758a6a" translate="yes" xml:space="preserve">
          <source>This instance preserves data abstraction at the cost of inefficiency. We omit reflection services for the sake of data abstraction.</source>
          <target state="translated">이 인스턴스는 비효율적 인 비용으로 데이터 추상화를 유지합니다. 데이터 추상화를 위해 리플렉션 서비스를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="6b584a1a609b62c189a035f58e1f74d23dc48f4f" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. If you feel a mistake has been made, please feel free to submit improvements.</source>
          <target state="translated">이 인스턴스는 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt; 동작을 복사하여 생성되었습니다 . &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; . 실수가 있다고 생각되면 언제든지 개선 사항을 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="cebbf89c2d62c75612dfe9b00700d435728a9709" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 인스턴스는 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt; 동작을 복사하여 작성되었습니다 . &lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9547a346372e77b8a94a20c518fb263a9e88db" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 필드가 제거 된 경우이 인스턴스는 파생 된 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype 인스턴스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d8b5c5a18b4eafeeabf6e2ae459cf6f977e8e46" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 필드가 제거 된 경우이 인스턴스는 파생 된 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype 인스턴스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f442041027e514839d6c7dbd7ef45f00a4ededa" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; 필드가 제거 된 경우이 인스턴스는 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype 의 파생 인스턴스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="04b4bf75fa251a6d79ae490ffe498133e416deeb" translate="yes" xml:space="preserve">
          <source>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using &lt;code&gt;-optl -rdynamic&lt;/code&gt; on Linux, and &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; on Windows.</source>
          <target state="translated">이렇게하면 사용 된 심볼뿐만 아니라 모든 심볼을 동적 심볼 테이블에 추가하도록 링커에 지시합니다. 현재 Linux 및 Windows / MinGW32 만 해당됩니다. 이는 Linux에서 &lt;code&gt;-optl -rdynamic&lt;/code&gt; 을 사용 하고 Windows에서 &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d93a8b76f0ddcde6fb04d1a2d2bc4ce8187928c7" translate="yes" xml:space="preserve">
          <source>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt;&lt;code&gt;-fPIE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 링커가 위치 독립적 실행 파일을 생성하도록 지시합니다. 이 플래그는 실행 파일을 생성하는 동안에 만 유효하며 링크되는 모든 오브젝트 코드는 &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt; &lt;code&gt;-fPIE&lt;/code&gt; &lt;/a&gt; 로 생성되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f3eb5f30b0cea2845a0034105f6b2f42741738e" translate="yes" xml:space="preserve">
          <source>This interface was introduced for parsers by Niklas R&amp;ouml;jemo, because it admits more sharing than the monadic interface. The names here are mostly based on parsing work by Doaitse Swierstra.</source>
          <target state="translated">이 인터페이스는 Niklas R&amp;ouml;jemo에서 파서 (parser)를 위해 도입되었습니다. 이는 수도원 인터페이스보다 더 많은 공유를 허용하기 때문입니다. 여기서 이름은 대부분 Doaitse Swierstra의 구문 분석 작업을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="2193f86cf24477bc6ea98a7a666bf4f097144114" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; with its arguments flipped.</source>
          <target state="translated">이다 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; 의 인수가 튀 겼다.</target>
        </trans-unit>
        <trans-unit id="853ad3fece6dfad54dfa810a5f259b18c1ca92df" translate="yes" xml:space="preserve">
          <source>This is a &quot;secure&quot; variant of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;mpz_powm_sec()&lt;/code&gt; function which is designed to be resilient to side channel attacks and is therefore intended for cryptographic applications.</source>
          <target state="translated">이것의 &quot;안전한&quot;변종 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 은 USING &lt;code&gt;mpz_powm_sec()&lt;/code&gt; 부 채널 공격에 반발하도록 설계되고 따라서 암호화 애플리케이션을 위해 의도되는 기능.</target>
        </trans-unit>
        <trans-unit id="206d2c688e36d3f91786f4ad10d32b3bbd76f245" translate="yes" xml:space="preserve">
          <source>This is a change in behaviour relative to 6.2 and earlier.</source>
          <target state="translated">이것은 6.2 및 이전 버전에 비해 동작이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="00558cc92150447e28cfde519a9ac027ba98b199" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt;; ie. it takes the value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, puts it back, and also returns it.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 의 조합입니다 . 즉. &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에서 값을 가져 와서 다시 넣고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d6388ad09499896ee48a8e46a65f919073bd630f" translate="yes" xml:space="preserve">
          <source>This is a consequence of the requirement that all applications of a type family must be fully saturated with respect to their arity.</source>
          <target state="translated">이는 유형 패밀리의 모든 응용 프로그램이 그 배열과 관련하여 완전히 포화되어야한다는 요구 사항의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="5cf7cdffdf7f677c3d65b226f0158c81eb00adc8" translate="yes" xml:space="preserve">
          <source>This is a good alternative to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; when you are trying to directly link in an object file.</source>
          <target state="translated">이것은 객체 파일에서 직접 링크를 시도 할 때 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; 의 좋은 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="085ff8e3a0f8a72b0a54eeb21ca799400340b070" translate="yes" xml:space="preserve">
          <source>This is a good way to insulate your program from differences in the globally exposed packages, and being explicit about package dependencies is a Good Thing. Cabal always passes the &lt;code&gt;-hide-all-packages&lt;/code&gt; flag to GHC, for exactly this reason.</source>
          <target state="translated">이것은 전 세계적으로 노출 된 패키지의 차이점으로부터 프로그램을 격리하는 좋은 방법이며 패키지 종속성에 대해 명시 적으로 설명하는 것이 좋습니다. Cabal은 항상 이런 이유로 &lt;code&gt;-hide-all-packages&lt;/code&gt; 플래그를 GHC에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="8027c0b11e662d6e52978de63e39356d25b88d32" translate="yes" xml:space="preserve">
          <source>This is a guide to using the Glasgow Haskell Compiler (GHC): an interactive and batch compilation system for the &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; language.</source>
          <target state="translated">이 안내서는 &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; 언어를 위한 대화식 및 일괄 컴파일 시스템 인 Glasgow Haskell Compiler (GHC) 사용에 대한 안내서 입니다.</target>
        </trans-unit>
        <trans-unit id="c43f1cd29cf3fbfdaab28a7b865c723e0177f5eb" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by UTC. It has a precision of 10^-12 s.</source>
          <target state="translated">UTC로 측정 한 시간입니다. 정밀도는 10 ^ -12 초입니다.</target>
        </trans-unit>
        <trans-unit id="b188ac0ba94d5b91f8dbb5c660aa1046ae2821a3" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has a precision of 10^-12 s.</source>
          <target state="translated">이것은 시계로 측정 한 시간 길이입니다. 변환 함수는이를 초로 취급합니다. 정밀도는 10 ^ -12 초입니다.</target>
        </trans-unit>
        <trans-unit id="b931fc8ba0422aa66c49ca99c7502e98ce5770ff" translate="yes" xml:space="preserve">
          <source>This is a library of parser combinators, originally written by Koen Claessen. It parses all alternatives in parallel, so it never keeps hold of the beginning of the input string, a common source of space leaks with other parsers. The &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; choice combinator is genuinely commutative; it makes no difference which branch is &quot;shorter&quot;.</source>
          <target state="translated">Koen Claessen이 처음 작성한 파서 결합기 라이브러리입니다. 모든 대안을 병렬로 구문 분석하므로 다른 파서와의 일반적인 공간 누출 소스 인 입력 문자열의 시작 부분을 유지하지 않습니다. &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; 선택 콤비는 진정으로 교환 법칙이 성립이다; 어느 분기가 &quot;더 짧아&quot;차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e42801ec302676ba22f8d444806417ba897f7527" translate="yes" xml:space="preserve">
          <source>This is a lot of information! However, most of it is actually merely meta-information that makes names of datatypes and constructors and more available on the type level.</source>
          <target state="translated">이것은 많은 정보입니다! 그러나 대부분은 실제로 메타 정보에 불과하므로 데이터 유형 및 생성자의 이름을 만들고 유형 수준에서 더 많은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f7c821c90cd714f631d4e0a4b9d09aa6b02e5d" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Haskell style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">하스켈 스타일 언어에 대한 최소 토큰 정의입니다. 주석 스타일, 유효한 식별자 및 대소 문자 구분을 정의합니다. 예약어나 연산자를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7695f0f91603fc6b7578c654d8c907922e492b31" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Java style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">이것은 Java 스타일 언어에 대한 최소 토큰 정의입니다. 주석 스타일, 유효한 식별자 및 대소 문자 구분을 정의합니다. 예약어나 연산자를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa0a32456a663556dc4c0ba610d08c21985dc005" translate="yes" xml:space="preserve">
          <source>This is a module for efficient stack traces. This stack trace implementation is considered low overhead. Basic usage looks like this:</source>
          <target state="translated">효율적인 스택 추적을위한 모듈입니다. 이 스택 추적 구현은 낮은 오버 헤드로 간주됩니다. 기본 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8d7e87f49a4a49c2284947686e2481c865a646c" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . 프로세스가 여전히 실행 중이면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이 반환됩니다. 프로세스가 종료 된 경우, &lt;code&gt;e&lt;/code&gt; 는 프로세스의 종료 코드 인 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; 가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdec4fb766d4e0ba04b6cea6e7ffd45bb020610" translate="yes" xml:space="preserve">
          <source>This is a rather fragile arrangement, as generally a programmer expects &lt;code&gt;(*) a b&lt;/code&gt; to be equivalent to &lt;code&gt;a * b&lt;/code&gt;. With &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt;&lt;code&gt;-Wstar-binder&lt;/code&gt;&lt;/a&gt; we warn when this special treatment of &lt;code&gt;(*)&lt;/code&gt; takes place.</source>
          <target state="translated">일반적으로 프로그래머는 &lt;code&gt;(*) a b&lt;/code&gt; 가 &lt;code&gt;a * b&lt;/code&gt; 와 같을 것으로 예상하기 때문에 다소 약한 배열 입니다. &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt; &lt;code&gt;-Wstar-binder&lt;/code&gt; 를&lt;/a&gt; 사용하면 &lt;code&gt;(*)&lt;/code&gt; 의이 특별한 처리가 발생할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="bfbddac5a335e3a88e1f9114ff2652333aff0d5e" translate="yes" xml:space="preserve">
          <source>This is a slightly involved heuristic, but captures the situation of an imported module &lt;code&gt;N&lt;/code&gt; changing the behaviour of existing code. For example, if the second condition isn&amp;rsquo;t violated, then the module author &lt;code&gt;M&lt;/code&gt; must depend either on a type-class or type defined in &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">이것은 약간 포함 된 휴리스틱이지만 기존 코드의 동작을 변경 하는 가져온 모듈 &lt;code&gt;N&lt;/code&gt; 의 상황을 캡처합니다 . 예를 들어, 두 번째 조건을 위반하지 않으면 모듈 작성자 &lt;code&gt;M&lt;/code&gt; 은 형식 클래스 또는 &lt;code&gt;N&lt;/code&gt; 에 정의 된 형식에 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4721594427df43592a87eef3fe9a7c319440d2ac" translate="yes" xml:space="preserve">
          <source>This is a suitable definition for an &lt;code&gt;mtimes&lt;/code&gt; member of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 정의에 적합한 것이다 &lt;code&gt;mtimes&lt;/code&gt; 의 멤버 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d950f78f6594d495d879d450f50f2aaabfabc86" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 유효한 정의입니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f7c8d617e149468fb4914e042ce1964608c94f4" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 유효한 정의입니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 멱등을위한 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85d5215128cc4957be290b7930eb2a5cf73d213f" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 유효한 정의입니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 멱등에 대한 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172ab78ae87f58f1be94549d14a2e6f93c70f4c1" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 의 변형으로 , finalizer는 임의의 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작입니다. 호출되면 종료자는 새 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e325aa9ef040b927e3fb7ef2baa5b6a0f1b819" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;IO&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">이것은 &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; 의 변형으로 , finalizer는 임의의 &lt;code&gt;IO&lt;/code&gt; 동작입니다. 호출되면 종료자는 새 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="371673f71c58c2e9cdb85387820977d33c4caf49" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">이것은 이물질 안에있는 포인터를 보는 방법입니다. 이 함수는 해당 포인터에 적용되는 함수를 사용합니다. 그런 다음 결과 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 실행됩니다. 이물질은 내부에서 직접 사용되지 않더라도 적어도 전체 동작 중에 살아 있어야합니다. 조치에서 포인터를 리턴하고 조치가 완료된 후 사용하는 것은 안전하지 않습니다. 포인터의 모든 사용은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 브래킷 안에 있어야합니다 . 이 안전하지 않은 이유는 아래의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 과 동일 합니다. 컴파일러는 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 개체가 아닌 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 개체의 사용 만 추적 할 수 있기 때문에 종료자가 예상보다 빨리 실행될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bf47a6eebbbeb1a3756083812189988818bf7bb" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">이것은 이물질 안에있는 포인터를 보는 방법입니다. 이 함수는 해당 포인터에 적용되는 함수를 사용합니다. 그런 다음 결과 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 실행됩니다. 이물질은 내부에서 직접 사용되지 않더라도 적어도 전체 동작 중에 살아 있어야합니다. 조치에서 포인터를 리턴하고 조치가 완료된 후 사용하는 것은 안전하지 않습니다. 포인터의 모든 사용은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 브래킷 안에 있어야합니다 . 이 안전하지 않은 이유는 아래의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 과 동일 합니다. 컴파일러는 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 개체가 아닌 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 개체의 사용 만 추적 할 수 있기 때문에 종료자가 예상보다 빨리 실행될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f341bdd202c5cbf36cfc8ae95ca15781837c676" translate="yes" xml:space="preserve">
          <source>This is a workaround for poor optimisation in GHC 6.8.2. It fails to notice constant-width shifts, and adds a test and branch to every shift. This imposes about a 10% performance hit.</source>
          <target state="translated">이것은 GHC 6.8.2의 최적화가 좋지 않은 경우의 해결 방법입니다. 일정한 너비의 이동을 감지하지 못하고 모든 이동에 테스트 및 분기를 추가합니다. 약 10 %의 성능 저하가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c2b599fbba068d2e3306d55e3da89a6dea9c30d" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt;, but returns a quadruple consisting of the option arguments, a list of non-options, a list of unrecognized options, and a list of error messages.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; 와 거의 동일 하지만 옵션 인수, 비 옵션 목록, 인식 할 수없는 옵션 목록 및 오류 메시지 목록으로 구성된 4 배를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d0e2442d2a5176acfea0d861dcdf4c526699f651" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt;, except that &lt;code&gt;ghc-pkg dump&lt;/code&gt; is intended for use by tools that parse the results, so for example where &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; will emit an error if it can&amp;rsquo;t find any packages that match the pattern, &lt;code&gt;ghc-pkg dump&lt;/code&gt; will simply emit nothing.</source>
          <target state="translated">이것은 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 와 거의 동일합니다 . 단, &lt;code&gt;ghc-pkg dump&lt;/code&gt; 는 결과를 구문 분석하는 도구에서 사용하기위한 것입니다. 예를 들어 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 는 오류가 발생하는 경우 ' 패턴과 일치하는 패키지를 찾지 못하면 &lt;code&gt;ghc-pkg dump&lt;/code&gt; 는 아무 것도 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7792587286beb0c2340a33dbd540974a7aa95716" translate="yes" xml:space="preserve">
          <source>This is also known as the catamorphism on trees.</source>
          <target state="translated">이것은 나무의 이화 현상으로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f05073a7db37870040709ee8825ace5ad9e27b" translate="yes" xml:space="preserve">
          <source>This is also the number of threads that will participate in parallel garbage collection. It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores, and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine.</source>
          <target state="translated">병렬 가비지 콜렉션에 참여할 스레드 수이기도합니다. 기능 수는 물리적 프로세서 코어 수보다 크게 설정하지 않는 것이 좋습니다. 시스템의 다른 프로세스와의 충돌을 피하기 위해 하나 이상의 코어를 자유롭게 두는 것이 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beec198333c6e916a71dc2007f654bbfb496d115" translate="yes" xml:space="preserve">
          <source>This is always an integral type. Width and signedness are platform specific.</source>
          <target state="translated">이것은 항상 필수 유형입니다. 너비와 부호는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2c94c1e0eafc78c19212557dee894b114bd63e4b" translate="yes" xml:space="preserve">
          <source>This is an alternative backend that uses the &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; compiler to produce executable code. It generally produces code as with performance as good as the native code generator but for some cases can produce much faster code. This is especially true for numeric, array heavy code using packages like vector. The penalty is a significant increase in compilation times. Select the LLVM backend with the &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; 컴파일러를 사용하여 실행 코드를 생성 하는 대체 백엔드입니다 . 일반적으로 네이티브 코드 생성기만큼 성능이 뛰어난 코드를 생성하지만 경우에 따라 훨씬 빠른 코드를 생성 할 수 있습니다. 이것은 벡터와 같은 패키지를 사용하는 숫자 배열 무거운 코드의 경우 특히 그렇습니다. 패널티는 컴파일 시간이 크게 늘어납니다. &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 플래그 와 함께 LLVM 백엔드를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="b07234aad669def52b50175f945aeebcd045d700" translate="yes" xml:space="preserve">
          <source>This is an experimental feature, please let us know if it causes problems and/or could benefit from further tuning.</source>
          <target state="translated">이 기능은 실험적인 기능이므로 문제가 발생하거나 추가 튜닝을 통해 이점을 얻을 수 있는지 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="d518bb2db084fc2424d01684cf81e93ef233a006" translate="yes" xml:space="preserve">
          <source>This is an infix alias for &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 의 접두사 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="101923d23a1c0936899b25445ac34361e56b2129" translate="yes" xml:space="preserve">
          <source>This is an infix version of &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; with the arguments flipped.</source>
          <target state="translated">이것은 인수가 뒤집힌 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 의 접미사 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="58c0c8b3a56848782113a6355b13f876cdde90db" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;qsort&lt;/code&gt; is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display &lt;code&gt;left&lt;/code&gt; at the prompt, GHCi can&amp;rsquo;t figure out which instance of &lt;code&gt;Show&lt;/code&gt; to use, so it emits the type error above.</source>
          <target state="translated">때문이다 &lt;code&gt;qsort&lt;/code&gt; 가이 다형성 함수이며, GHCi 런타임에 타입 정보를 전달하지 않기 때문에,이 형태 변수를 포함하는 자유 변수의 런타임 형식을 확인할 수 없습니다. 따라서 프롬프트에서 &lt;code&gt;left&lt;/code&gt; 을 표시하도록 요청하면 GHCi는 사용할 &lt;code&gt;Show&lt;/code&gt; 인스턴스를 파악할 수 없으므로 위의 유형 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="31f122da1e52003fb749b42feb286b289a499229" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="translated">&lt;code&gt;Natural&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 에서 사용하는 일반적인 유형 입니다. 이 형식은 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; 래핑하는 단일 생성자로 구성 되므로 압축을 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e46c9188c411a7574791b7db9d68e4a5ba400984" translate="yes" xml:space="preserve">
          <source>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</source>
          <target state="translated">정확성을 유지하는 데 중요합니다. 다른 모듈에 정의 된 엔터티는 정확성 (기능 또는 성능)에 대해 게으름에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed31266df50c8047adeba9f8ad5ed4814f624b36" translate="yes" xml:space="preserve">
          <source>This is currently only returned by the following operations:</source>
          <target state="translated">현재 다음 조작으로 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="69022b713a9a3be30ce145d8a3fa9a46d52862c0" translate="yes" xml:space="preserve">
          <source>This is dangerous territory, however. Here, for example, is a program that would make the typechecker loop:</source>
          <target state="translated">그러나 이것은 위험한 영토입니다. 예를 들어, 다음은 typechecker 루프를 만드는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="8bef230a1b33fc363b0b8397f3ec27a17fff06b4" translate="yes" xml:space="preserve">
          <source>This is definitely caused by a bug in GHC. Please report it (see &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt;).</source>
          <target state="translated">이것은 GHC의 버그로 인한 것입니다. 보고하십시오 ( &lt;a href=&quot;intro#bug-reporting&quot;&gt;GHC의 버그보고&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="50509e11fe7ca6ff18f57510c20c4165a78570ab" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;if p then y else x&lt;/code&gt;; that is, one can think of it as an if-then-else construct with its arguments reordered.</source>
          <target state="translated">이것은 &lt;code&gt;if p then y else x&lt;/code&gt; 와 같다; 즉, 인수가 재정렬 된 if-then-else 구문으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac94cb7c266f7957cc925f86fcff5b3aa8d29a4c" translate="yes" xml:space="preserve">
          <source>This is essentially a more performant version of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; that always returns the first result, if any. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 본질적으로 항상 첫 번째 결과를 리턴하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 의 성능이 더 우수한 버전입니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62b9a042aea0816af6e299c00f387f0402dcd3d1" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Eq&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">이것은 본질적으로 &lt;code&gt;data Foo a&lt;/code&gt; 대한 선언 후에 &lt;code&gt;deriving Eq&lt;/code&gt; 을 작성한 것과 동일 합니다 . 이 기능을 사용하려면 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt; )를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9595725d43f98726f370669a781ee6935055f745" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Foo&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">이것은 &lt;code&gt;data Foo a&lt;/code&gt; 대한 선언 후 &lt;code&gt;deriving Foo&lt;/code&gt; 를 파생시키는 것처럼 본질적으로 동일 합니다 . 이 기능을 사용하려면 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt; )를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d6cf1a68093409280369c1b6acf1d281e7ce24d" translate="yes" xml:space="preserve">
          <source>This is expected to improve performance on average, but actual performance difference can vary.</source>
          <target state="translated">이는 평균적으로 성능을 향상시킬 것으로 예상되지만 실제 성능 차이는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac537ddcd723a43b8f01589d4e737eed3f70681" translate="yes" xml:space="preserve">
          <source>This is exposed solely for people writing GHC rewrite rules.</source>
          <target state="translated">이것은 GHC 다시 쓰기 규칙을 작성하는 사람들에게만 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="8f87cd084e7f91046e80a5ffa06a25dbafabc73f" translate="yes" xml:space="preserve">
          <source>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren&amp;rsquo;t referenced by any other code linked into the executable. If you&amp;rsquo;re using &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt;, you probably also want &lt;code&gt;-rdynamic&lt;/code&gt;.</source>
          <target state="translated">실행 파일에 링크 된 다른 코드가 참조하지 않더라도 런타임에 이러한 Haskell 라이브러리에 정의 된 기호가 필요할 수있는 특수 응용 프로그램을위한 것입니다. 당신이 사용하는 경우 &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt; , 당신은 아마 또한 원하는 &lt;code&gt;-rdynamic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0b93f1aaeb2183a73344bfad7f37c373c52776" translate="yes" xml:space="preserve">
          <source>This is how to define &lt;code&gt;insertLookup&lt;/code&gt; using &lt;code&gt;insertLookupWithKey&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;insertLookup&lt;/code&gt; WithKey를 사용하여 &lt;code&gt;insertLookupWithKey&lt;/code&gt; 을 정의하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="f42e6638d71ed609c1ebc5bfa4f5a4bdde5aa067" translate="yes" xml:space="preserve">
          <source>This is illegal because the use of &lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt; on the right-hand sides prevents it from being a well formed expression. However, constructing a strict pattern synonym is quite possible with an explicitly bidirectional pattern synonym:</source>
          <target state="translated">오른쪽 에 &lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt; 를 사용 하면 표현이 잘되지 않기 때문에 불법 입니다. 그러나 명시적인 양방향 패턴 동의어를 사용하면 엄격한 패턴 동의어를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0c93b41bba3d3d671093acebd3b256b511ac64" translate="yes" xml:space="preserve">
          <source>This is internally implemented as count-leading-zeros machine instruction.</source>
          <target state="translated">이것은 내부적으로 0을 나타내는 기계 명령어로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="852b04a3b6aa2150c763c2710aeb536c17bc4e95" translate="yes" xml:space="preserve">
          <source>This is just a convenience function, it's defined simply as:</source>
          <target state="translated">이것은 단지 편리한 기능이며 간단히 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e45e37056992d6af3645dca1e73531419ebe8cab" translate="yes" xml:space="preserve">
          <source>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2 we run the pass again at the asm stage to catch these.</source>
          <target state="translated">이것은 대부분 Cmm 패스 중에 수행됩니다. 그러나 이것은 코너 케이스를 놓칠 수 있습니다. 따라서 -O2에서 asm 단계에서 패스를 다시 실행하여이를 잡습니다.</target>
        </trans-unit>
        <trans-unit id="a5b597ca7719e3d8708a1e507512f84a11523c7d" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">이것은 일반적으로 가능한 모든 문자를 반환하는 것이 아니라 상위 수준의 구성으로 오류 메시지를 반환하려는 대체 대안의 끝에 사용됩니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 예제 의 &lt;code&gt;expr&lt;/code&gt; 구문 분석기 가 실패하면 오류 메시지는 '... : expecting expression'입니다. &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 결합자가 없으면 메시지는 '... : &quot;let&quot;또는 letter'를 기대하지만 덜 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="39a3eeed9577807a13413d7d9a4747103d4ba578" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">이것은 일반적으로 가능한 모든 문자를 반환하는 것이 아니라 상위 수준의 구성으로 오류 메시지를 반환하려는 대체 대안의 끝에 사용됩니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 예제 의 &lt;code&gt;expr&lt;/code&gt; 구문 분석기 가 실패하면 오류 메시지는 '... : expecting expression'입니다. &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 결합자가 없으면 메시지는 '... : &quot;let&quot;또는 letter'를 기대하지만 덜 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="c67587857810fc437f5fd2889f14753f716a50b7" translate="yes" xml:space="preserve">
          <source>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</source>
          <target state="translated">출력이 길거나 ASCII가 아닌 문자가 포함 된 문자열을 포함하는 경우와 같이 특정 경우에는 이상적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19107584e7f459839bffc5515c49619c3a279acc" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특수 문자에는 처리되지 않습니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 와 같은 특수 문자를 이해하므로 사용자 문자열에 대해 stringToHtml 또는 lineToHtml을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eee7f5de1930e679b3ff1bf2b45247aa3e4891d" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특수 문자에 대해서는 처리되지 않습니다. 사용자 문자열에는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 와 같은 특수 문자를 이해하므로 stringToHtml 또는 lineToHtml을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7fa5f45c008c43283961b6bf73fec56028cc02f" translate="yes" xml:space="preserve">
          <source>This is particularly useful in conjunction with larger &lt;code&gt;-A&lt;/code&gt; values, for example &lt;code&gt;-A64m -n4m&lt;/code&gt; is a useful combination on larger core counts (8+).</source>
          <target state="translated">이것은 큰 함께 특히 유용하다 &lt;code&gt;-A&lt;/code&gt; 의 예를 들면, 값 &lt;code&gt;-A64m -n4m&lt;/code&gt; 큰 코어 카운트 (8 +)의 조합이 유용하다.</target>
        </trans-unit>
        <trans-unit id="9eda36a1c5f71327f9a1ce36f39f69ceebc7a2ca" translate="yes" xml:space="preserve">
          <source>This is particularly useful with the &lt;code&gt;ViewPatterns&lt;/code&gt; extension to GHC, as follows:</source>
          <target state="translated">이것은 다음과 같이 GHC에 대한 &lt;code&gt;ViewPatterns&lt;/code&gt; 확장에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="f9953554c74c35663186a90c0246462e6382fb5f" translate="yes" xml:space="preserve">
          <source>This is rather similar to the class &lt;code&gt;IsString&lt;/code&gt; (see &lt;a href=&quot;#overloaded-strings&quot;&gt;Overloaded string literals&lt;/a&gt;), but with an additional type parameter that makes the text of the label available as a type-level string (see &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;). Note that &lt;code&gt;fromLabel&lt;/code&gt; had an extra &lt;code&gt;Proxy# x&lt;/code&gt; argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) can be used instead.</source>
          <target state="translated">이 클래스는 &lt;code&gt;IsString&lt;/code&gt; 클래스 ( &lt;a href=&quot;#overloaded-strings&quot;&gt;오버로드 된 문자열 리터럴&lt;/a&gt; 참조 )와 비슷하지만 레이블의 텍스트를 유형 수준 문자열로 사용할 수있게하는 추가 유형 매개 변수가 있습니다 ( &lt;a href=&quot;#type-level-literals&quot;&gt;유형 수준 리터럴&lt;/a&gt; 참조 ). 참고 것을 &lt;code&gt;fromLabel&lt;/code&gt; 는 추가했다 &lt;code&gt;Proxy# x&lt;/code&gt; GHC 8.0에서 인수를, 그러나 이것은 (참조 유형의 응용 프로그램으로 GHC 8.2에서 제거 &lt;a href=&quot;#visible-type-application&quot;&gt;눈에 보이는 유형의 응용 프로그램을&lt;/a&gt; 대신 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="275797ad44149a221def0ee243441fcab463f9bc" translate="yes" xml:space="preserve">
          <source>This is rejected because there is no &amp;ldquo;outermost level&amp;rdquo; for the types on the RHS (it would obviously be terrible to add extra parameters to &lt;code&gt;PackMap&lt;/code&gt;), so no implicit quantification happens, and the declaration is rejected (with &amp;ldquo;&lt;code&gt;f&lt;/code&gt; is out of scope&amp;rdquo;). Solution: use an explicit &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">RHS의 유형에 대해 &quot;최상위 레벨&quot;이 없기 때문에 ( &lt;code&gt;PackMap&lt;/code&gt; 에 추가 매개 변수를 추가하는 것이 끔찍할 수 있기 때문에) 거부되므로 암시 적 수량 화가 발생하지 않으며 선언이 거부됩니다 ( &quot; &lt;code&gt;f&lt;/code&gt; 가 범위를 벗어남 &quot; &amp;rdquo;). 해결책 : 명시 적 &lt;code&gt;forall&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="965462ce779e5c5398c7b7c8822c6fe46cd11f7e" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type is generalised, to get</source>
          <target state="translated">이것은 하스켈 98 거부하지만, 존스의 방식 하에서 대한 정의 &lt;code&gt;g&lt;/code&gt; 은 따로 행 들면 제 타입 체크된다 &lt;code&gt;f&lt;/code&gt; 참조가 있기 때문에, &lt;code&gt;f&lt;/code&gt; 의 &lt;code&gt;g&lt;/code&gt; 의 오른쪽은 종속성 분석에 의해 무시된다. 그런 다음 &lt;code&gt;g&lt;/code&gt; 의 유형이 일반화되어</target>
        </trans-unit>
        <trans-unit id="af9e5e6b5a1471403ba13a39e6cf598e61cc7f1f" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type is generalised, to get</source>
          <target state="translated">이것은 하스켈 98 거부하지만, 존스의 방식 하에서 대한 정의 &lt;code&gt;g&lt;/code&gt; 은 따로 행 들면 제 타입 체크된다 &lt;code&gt;f&lt;/code&gt; 참조가 있기 때문에, &lt;code&gt;f&lt;/code&gt; 의 &lt;code&gt;g&lt;/code&gt; 의 오른쪽은 종속성 분석에 의해 무시된다. 그런 다음 &lt;code&gt;g&lt;/code&gt; 유형이 일반화되어</target>
        </trans-unit>
        <trans-unit id="173eae666fe7062188303aaed7c3e9e91b4501ad" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;1&lt;/code&gt; when the compiler supports Template Haskell, and to &lt;code&gt;0&lt;/code&gt; when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</source>
          <target state="translated">컴파일러가 Template Haskell을 지원하면 &lt;code&gt;1&lt;/code&gt; 로 설정되고 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 으로 설정 됩니다. 후자는 부트 스트랩 중 또는 인터프리터를 사용할 수없는 아키텍처의 1 단계 컴파일러의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e2a9fd34e0777a91dc7abb06fe3e0b3098e9ec74" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 법칙 이 일종의 연관성을 암시 하기 때문에 이것은 추상 형식에도 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="e5265ef186d0fe504d07549453be769b06cb5de9" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 법칙 이 일종의 연관성을 암시 하기 때문에 이것은 추상 형식에도 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="886cde162909e5053a7382858de7970df163c591" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the monoid is assumed to satisfy the monoid laws. Alternatively, one could define &lt;code&gt;foldr&lt;/code&gt;:</source>
          <target state="translated">단일체가 단일체 법칙을 만족한다고 가정하기 때문에 이것은 추상 유형에도 적합합니다. 또는 &lt;code&gt;foldr&lt;/code&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbe2ee805fe872cdfa9dad562a94abbdd44ba100" translate="yes" xml:space="preserve">
          <source>This is suitable for datatypes that are exported transparently.</source>
          <target state="translated">투명하게 내보내는 데이터 유형에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="fb6774461de6668cb4c86bcd9b2d0f93d1213ac5" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 &quot;후문&quot; 이므로 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 수행 할 수 있습니다. 이를 안전하게하려면 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산에 부작용이없고 환경과 무관해야합니다.</target>
        </trans-unit>
        <trans-unit id="e076e79d373c95008b4305220e373d648e1a35dc" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 &quot;후문&quot; 이므로 언제든지 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 수행 할 수 있습니다. 이를 안전하게하려면 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산에 부작용이없고 환경과 무관해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbf56641bd07ddb82df111a846a14d313459064a" translate="yes" xml:space="preserve">
          <source>This is the analogue of the &lt;code&gt;LINE&lt;/code&gt; pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</source>
          <target state="translated">이것은 &lt;code&gt;LINE&lt;/code&gt; pragma와 유사하며 자동으로 생성 된 Haskell 코드에서 사용하기위한 것입니다. 원래 코드의 열 번호를 지정할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5c9cf33d55e8504f25f0586b2ca2f9cf2d7a74c1" translate="yes" xml:space="preserve">
          <source>This is the defined behaviour of &lt;code&gt;getContents&lt;/code&gt;: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">이것은 &lt;code&gt;getContents&lt;/code&gt; 의 정의 된 동작입니다 . stdin Handle을 반 닫힘으로 알려진 상태로 설정합니다. 여기서 추가 I / O 작업은 금지됩니다. I / O 상태는 계산간에 유지되므로 semi-closed 상태는 다음 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 명령 까지 지속 됩니다.</target>
        </trans-unit>
        <trans-unit id="d59a26993924ddd4622ca180b22b28d96a32273b" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="a8cafe2ab0917d4201e6879d83ae5338339737b2" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="f6167f3d89f3a57f13ddc1cfc30ba818a1c14f35" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="1d382c742dccd9be34f30f4a4585a36c280b6334" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="cbc6595af04522c2fde6302bbc4d97ab2ecf3276" translate="yes" xml:space="preserve">
          <source>This is the initial locale encoding: if it has been subsequently changed by &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; this value will not reflect that change.</source>
          <target state="translated">초기 로케일 인코딩입니다. &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; 에 의해 이후에 변경된 경우이 값은 해당 변경 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abd17a970d52fd304b594c189a551764634555bd" translate="yes" xml:space="preserve">
          <source>This is the magic cut-off figure for unfolding (aka inlining): below this size, a function definition will be unfolded at the call-site, any bigger and it won&amp;rsquo;t. The size computed for a function depends on two things: the actual size of the expression minus any discounts that apply depending on the context into which the expression is to be inlined.</source>
          <target state="translated">이것은 펼치기 (일명 인라인)에 대한 마술 컷오프 수치입니다.이 크기 아래에서는 함수 정의가 콜 사이트에서 펼쳐지지만 더 크지 않습니다. 함수에 대해 계산되는 크기는 표현식의 실제 크기에서 표현식을 인라인 할 컨텍스트에 따라 적용되는 할인을 뺀 두 가지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="67b68027f5d62fd3f61a1b54666f56f7507aeca1" translate="yes" xml:space="preserve">
          <source>This is the most basic way to make your program go faster. Compilation time will be slower, especially with &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">이것이 프로그램을 더 빠르게 만드는 가장 기본적인 방법입니다. 특히 &lt;code&gt;-O2&lt;/code&gt; 의 경우 컴파일 시간이 느려집니다 .</target>
        </trans-unit>
        <trans-unit id="da3c5884261af5d6c5ce2a2fefd25b97aeda4835" translate="yes" xml:space="preserve">
          <source>This is the most general interface for building a weak pointer.</source>
          <target state="translated">이것은 약한 포인터를 만들기위한 가장 일반적인 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5dbbb7f4bd171d6e5fe3f02c892e785922548729" translate="yes" xml:space="preserve">
          <source>This is the most general of the grouping-type statements. In this form, f is required to have type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt;. As with the &lt;code&gt;then f by e&lt;/code&gt; case above, the first argument is a function supplied to f by the compiler which lets it compute e on every element of the list being transformed. However, unlike the non-grouping case, f additionally partitions the list into a number of sublists: this means that at every point after this statement, binders occurring before it in the comprehension refer to &lt;em&gt;lists&lt;/em&gt; of possible values, not single values. To help understand this, let&amp;rsquo;s look at an example:</source>
          <target state="translated">이것은 그룹화 유형 문 중 가장 일반적인 것입니다. 이 형식에서, f는 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt; 유형을 가져야 합니다. (a-&amp;gt; t)-&amp;gt; [a]-&amp;gt; [[a]] 입니다. 와 마찬가지로 &lt;code&gt;then f by e&lt;/code&gt; 상기의 경우, 첫 번째 인자는리스트의 각 요소가 변형되고 그것을 계산 예를 할 수있는 컴파일러에 의해 F에 공급되는 함수이다. 그러나 비 그룹화 사례와 달리 f는 추가로 목록을 여러 하위 목록으로 분할합니다. 즉,이 명령문 이후의 모든 지점에서 이해하기 전에 &lt;em&gt;목록&lt;/em&gt; 에서 발생하는 바인더는 단일 값이 아닌 가능한 값 &lt;em&gt;목록&lt;/em&gt; 을 나타냅니다. 이를 이해하기 위해 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="97cacebb8a50334f0aa10455086684215843c90c" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="translated">이것은 외부 프로세스를 생성하는 가장 일반적인 방법입니다. 프로세스는 쉘에 의해 실행되는 명령 행이거나 인수 목록이있는 원시 명령 일 수 있습니다. 새 프로세스의 stdin, stdout 및 stderr 스트림은 개별적으로 새 파이프, 기존 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 연결되거나 부모에서 상속 될 수 있습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="17c6bc999a6e66cdf70760668583b194f94060fb" translate="yes" xml:space="preserve">
          <source>This is the most minimal token definition. It is recommended to use this definition as the basis for other definitions. &lt;code&gt;emptyDef&lt;/code&gt; has no reserved names or operators, is case sensitive and doesn't accept comments, identifiers or operators.</source>
          <target state="translated">이것이 가장 작은 토큰 정의입니다. 이 정의를 다른 정의의 기초로 사용하는 것이 좋습니다. &lt;code&gt;emptyDef&lt;/code&gt; 에는 예약 된 이름이나 연산자가 없으며 대소 문자를 구분하며 주석, 식별자 또는 연산자를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28714170914c36c5937fb4d6795c7183bf135afa" translate="yes" xml:space="preserve">
          <source>This is the most primitive combinator for accepting tokens. For example, the &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; parser could be implemented as:</source>
          <target state="translated">이것은 토큰을 수락하는 가장 원시적 인 조합입니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; 파서는 다음과 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c028e89a3d3ce63ac917bdfc38f641c5b46ea80a" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt;&lt;code&gt;-fvia-C&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">이것은 GHC에서 가장 오래된 코드 생성기이며 일반적으로 GHC 7.0에서 더 이상 사용되지 않는 더 이상 포함되지 않습니다. &lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt; &lt;code&gt;-fvia-C&lt;/code&gt; &lt;/a&gt; 플래그로 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b5e00d2ed34cf00eb62f197974c932b271f59b3" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;code&gt;-fvia-C&lt;/code&gt; flag.</source>
          <target state="translated">이것은 GHC에서 가장 오래된 코드 생성기이며 일반적으로 GHC 7.0에서 더 이상 사용되지 않는 것은 아닙니다. &lt;code&gt;-fvia-C&lt;/code&gt; 플래그로 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ef0a3e02d26e1de4897c94f804fb945f14b00c6" translate="yes" xml:space="preserve">
          <source>This is the simplest of the exception-catching functions. It takes a single argument, runs it, and if an exception is raised the &quot;handler&quot; is executed, with the value of the exception passed as an argument. Otherwise, the result is returned as normal. For example:</source>
          <target state="translated">이것은 예외 포착 기능 중 가장 간단한 것입니다. 단일 인수를 취하여 실행하며 예외가 발생하면 예외 값이 인수로 전달 된 &quot;handler&quot;가 실행됩니다. 그렇지 않으면 결과가 정상적으로 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="709bbf178e88d31284082a439684f263fe4c4cba" translate="yes" xml:space="preserve">
          <source>This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.</source>
          <target state="translated">이것은 UTC의 가장 간단한 표현입니다. 요일 번호와 자정의 시간 오프셋으로 구성됩니다. 하루에 윤초가 추가 된 경우 86401 초가됩니다.</target>
        </trans-unit>
        <trans-unit id="e4dbe9128e5734a5df9b1f11da3e326916a92167" translate="yes" xml:space="preserve">
          <source>This is the traditional batch-compiler mode, in which GHC can compile source files one at a time, or link objects together into an executable. See &lt;a href=&quot;#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;.</source>
          <target state="translated">GHC가 소스 파일을 한 번에 하나씩 컴파일하거나 객체를 실행 파일에 연결할 수있는 일반적인 배치 컴파일러 모드입니다. &lt;a href=&quot;#options-order&quot;&gt;배치 컴파일러 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63579352bd238619f1e8291119e93600ef4a9cde" translate="yes" xml:space="preserve">
          <source>This is the type of a field formatter reified over its argument.</source>
          <target state="translated">이것은 인수를 통해 구체화 된 필드 포맷터의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e04da25499a8419831fe5bf0581bda0dfaf2d2e9" translate="yes" xml:space="preserve">
          <source>This is thrown when the user calls &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. The first &lt;code&gt;String&lt;/code&gt; is the argument given to &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, second &lt;code&gt;String&lt;/code&gt; is the location.</source>
          <target state="translated">사용자가 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 를 호출하면 발생 합니다. 첫 번째 &lt;code&gt;String&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 에 지정된 인수 이고 두 번째 &lt;code&gt;String&lt;/code&gt; 은 위치입니다.</target>
        </trans-unit>
        <trans-unit id="a3b52992dd96200ef77ecde2d026b069e2b12589" translate="yes" xml:space="preserve">
          <source>This is used for holes or unresolved identifiers in AST quotes. Note that it could either have a variable name or constructor name.</source>
          <target state="translated">이는 AST 따옴표의 구멍 또는 확인되지 않은 식별자에 사용됩니다. 변수 이름이나 생성자 이름이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328c1fbc5f4cd720ec3ec26821113be04b4a5990" translate="yes" xml:space="preserve">
          <source>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type &lt;code&gt;Any&lt;/code&gt; (by way of &lt;code&gt;unsafeCoerce#&lt;/code&gt;) and the result type is allowed to be an unboxed tuple or the type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">내부 GHC 호출 규칙을 따르는 Cmm 코드로 작성된 함수를 가져 오는 데 사용됩니다. 인수 및 결과는 인수 유형이 될 수 있습니다 것을 제외하고, 언 박싱 유형해야합니다 &lt;code&gt;Any&lt;/code&gt; (의 방법으로 &lt;code&gt;unsafeCoerce#&lt;/code&gt; ) 및 결과 유형은 언 박싱 튜플 또는 유형으로 허용되는 &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b782ef95535f2b46a643a86d5559d4d59530093" translate="yes" xml:space="preserve">
          <source>This is useful for functions parameterized by a monad transformer.</source>
          <target state="translated">이것은 모나드 변환기에 의해 매개 변수화 된 기능에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="191eaf7a7c1efa9d12f4d0ead171eac959ffb8bd" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;lsquo;s.</source>
          <target state="translated">생성 된 파일이 &lt;code&gt;Unique&lt;/code&gt; 순서에 의존하는지 테스트하기 위해 &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="eb2802e19e3cc64605ff63d36592512d32cabe42" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;rsquo;s.</source>
          <target state="translated">생성 된 파일이 &lt;code&gt;Unique&lt;/code&gt; 순서에 따라 달라지는 지 테스트하기 위해 &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d104180869342bc19c17c8e3619b3cc9055aa1fa" translate="yes" xml:space="preserve">
          <source>This is why the RIO module is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;&amp;gt;, to allow the &lt;code&gt;Danger&lt;/code&gt; module to import it. The &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; flag doesn&amp;rsquo;t place any restrictions on the module like &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; does (expect to restrict overlapping instances to &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;). Instead the module author claims that while code may use unsafe features internally, it only exposes an API that can used in a safe manner.</source>
          <target state="translated">RIO 모듈이 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; &amp;gt;로 컴파일되어 &lt;code&gt;Danger&lt;/code&gt; 모듈이 임포트 할 수있게 됩니다. &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 플래그는 같은 모듈에 어떤 제한을 두지 않는 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; (에 인스턴스를 중복 제한 할 것으로 예상 않는 &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;안전 중복되는 경우&lt;/a&gt; ). 대신 모듈 작성자는 코드가 안전하지 않은 기능을 내부적으로 사용할 수 있지만 안전한 방식으로 사용할 수있는 API 만 노출한다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="b712b2b82446ae28f73908890d2ef7531e15ac14" translate="yes" xml:space="preserve">
          <source>This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension &lt;code&gt;DatatypeContexts&lt;/code&gt;.</source>
          <target state="translated">이것은 널리 잘못된 기능으로 간주되며 언어에서 제거 될 예정입니다. GHC에서는 사용되지 않는 확장 &lt;code&gt;DatatypeContexts&lt;/code&gt; 에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="6778bfd500940c8e2d9a62565cee855196c0bd56" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t particularly enlightening. What happened is that &lt;code&gt;left&lt;/code&gt; is bound to an unevaluated computation (a suspension, or thunk), and &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; does not force any evaluation. The idea is that &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; can be used to inspect values at a breakpoint without any unfortunate side effects. It won&amp;rsquo;t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won&amp;rsquo;t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see &lt;a href=&quot;#nested-breakpoints&quot;&gt;Nested breakpoints&lt;/a&gt;). Rather than forcing thunks, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds each thunk to a fresh variable beginning with an underscore, in this case &lt;code&gt;_t1&lt;/code&gt;.</source>
          <target state="translated">이것은 특별히 깨달 지 않습니다. 무슨 일하는 것입니다 &lt;code&gt;left&lt;/code&gt; 평가되지 않은 계산 (현탁액, 또는 썽크)에 결합되고, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 어떤 평가를 강요하지 않습니다. 아이디어는 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 를 사용하여 불행한 부작용없이 중단 점에서 값을 검사 할 수 있다는 것입니다. 평가를 강제로 수행하지 않아 프로그램이 평상시와 다른 응답을 줄 수 있으므로 예외가 발생하거나 무한 루프 또는 추가 중단 점이 발생하지 않습니다 ( &lt;a href=&quot;#nested-breakpoints&quot;&gt;중첩 된 중단 점&lt;/a&gt; 참조 ). . 썽크를 강제하는 대신 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; 는&lt;/a&gt; 각 썽크를 밑줄로 시작하는 새로운 변수 (이 경우 &lt;code&gt;_t1&lt;/code&gt; )에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="a27ce07dfb7b638358503a182b9e384fb7c6d870" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;) for details.</source>
          <target state="translated">GHC는 패키지라고하는 사전 컴파일 된 라이브러리에서 모듈을 찾습니다. 자세한 내용은 패키지 ( &lt;a href=&quot;packages#packages&quot;&gt;패키지&lt;/a&gt; ) 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="e058359ab2e82e0cac7dd3d00a96ceff57c41dfb" translate="yes" xml:space="preserve">
          <source>This kind is similar to the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;, but with a key difference: the type variables quantified by the &lt;code&gt;forall&lt;/code&gt; are followed by an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;), not a dot (&lt;code&gt;.&lt;/code&gt;). This is a visible, dependent quantifier. It is visible in that it the user must pass in a type for &lt;code&gt;k&lt;/code&gt; explicitly, and it is dependent in the sense that &lt;code&gt;k&lt;/code&gt; appears later in the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;. As a counterpart, the &lt;code&gt;k&lt;/code&gt; binder in &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; can be thought of as an &lt;em&gt;invisible&lt;/em&gt;, dependent quantifier.</source>
          <target state="translated">이러한 종류의 종류 비슷 &lt;code&gt;ProxyKInvis&lt;/code&gt; 하지만 중요한 차이가 다음에 의해 정량화 된 형태 변수 &lt;code&gt;forall&lt;/code&gt; 화살표 따른다 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; )가 아니라 도트 ( &lt;code&gt;.&lt;/code&gt; ). 이것은 가시적이고 종속적 인 수량 자입니다. 사용자가 &lt;code&gt;k&lt;/code&gt; 에 대한 유형을 명시 적으로 전달해야한다는 점에서 볼 수 있으며 &lt;code&gt;k&lt;/code&gt; 가 나중에 &lt;code&gt;ProxyKVis&lt;/code&gt; 유형으로 표시 된다는 점 에서 종속적 입니다. 대응 물로서, &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 의 &lt;code&gt;k&lt;/code&gt; 바인더 . k-&amp;gt; 유형 은 &lt;em&gt;보이지 않는&lt;/em&gt; 종속 수량 자로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1decd194e9db593e0098385b29579f07d63ab43" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">친절한 추론의 부족은 단순히 GHC 내에서 공학적 문제이지만,이를 작동시키는 것은 추론 인프라를 실질적으로 변화시킬 것이며, 그 대가가 가치가 있는지는 확실하지 않습니다. 위의 인스턴스에서 &lt;code&gt;b&lt;/code&gt; 의 종류 를 제한 하려면 인스턴스 헤드에서 종류 서명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="35e744da89ea652776d7de1d49ded5a0e6370630" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">이러한 종류의 추론의 결여는 GHC 내의 엔지니어링 문제 일 뿐이지 만 작동하게하면 추론 인프라에 상당한 변화가 생기며 그만한 가치가있는 것은 분명하지 않습니다. 위의 인스턴스에서 &lt;code&gt;b&lt;/code&gt; 의 종류 를 제한 하려면 인스턴스 헤드에 종류 서명을 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9700917da64757c5e788e69e5482f32627c03338" translate="yes" xml:space="preserve">
          <source>This legacy module provides access to the list-specialised operations of &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable/Traversable-in-Prelude Proposal (FTP)&lt;/a&gt;.</source>
          <target state="translated">이 레거시 모듈은 목록 전문화 된 &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; 작업에 대한 액세스를 제공합니다 . 이 모듈은 향후 GHC 버전에서 다시 사라질 수 있으며 &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;FTP (Foldable / Traversable-in-Prelude Proposal)&lt;/a&gt; 구현으로 인해 일반화해야하는 목록 전문 작업 중 일부에 액세스 할 수있는 전환 도구로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e36c09f207f2c815a09c379dd1fb2c4090b7e037" translate="yes" xml:space="preserve">
          <source>This lets you use a difference list of a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 차이 목록을 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; A와 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ae93c187283325d394ffe8b8fa3d56bccb015c1" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">이 lexeme 파서는 부동 소수점 값을 구문 분석합니다. 숫자 값을 반환합니다. 숫자는 Haskell 보고서에 정의 된 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="527289d10a300c5f304dffa89904edeb2b163f3d" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 lexeme 구문 분석기는 유효한 식별자를 구문 분석합니다. 식별자 문자열을 반환합니다. 이 구문 분석기는 예약어 인 식별자에서 실패합니다. 유효한 식별자 (시작) 문자와 예약어는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;identifier&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="163be1f77c7bb2337562a94b4777b7e5c72dc90c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 lexeme 구문 분석기는 유효한 식별자를 구문 분석합니다. 식별자 문자열을 반환합니다. 이 구문 분석기는 예약어 인 식별자에서 실패합니다. 유효한 식별자 (시작) 문자와 예약어는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;identifier&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bd0992deca5f231a8e4bc4885419bb1a6bfcba7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 exeme 파서는 법정 연산자를 구문 분석합니다. 연산자의 이름을 반환합니다. 이 파서는 예약 된 연산자 인 연산자에서 실패합니다. 유효한 연산자 (시작) 문자와 예약 연산자는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;operator&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e90133adb94e7c3876b0dc934a4c349e00e9fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 exeme 파서는 법정 연산자를 구문 분석합니다. 연산자의 이름을 반환합니다. 이 파서는 예약 된 연산자 인 연산자에서 실패합니다. 유효한 연산자 (시작) 문자와 예약 연산자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;operator&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4009cc9448509a74e6a8d7bad513db7193f58fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a literal string. Returns the literal string value. This parsers deals correctly with escape sequences and gaps. The literal string is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">이 lexeme 파서는 리터럴 문자열을 구문 분석합니다. 리터럴 문자열 값을 반환합니다. 이 파서는 이스케이프 시퀀스 및 간격을 올바르게 처리합니다. 리터럴 문자열은 Haskell 보고서에 정의 된 문법 규칙 (대부분의 프로그래밍 언어와 매우 일치)에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7e07a35842fb9e4e49f081c6500aa5f24d9520" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 lexeme 구문 분석기는 자연수 (양수)를 구문 분석합니다. 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="ace0ef235b44c04e9847cae55d4c39fc3655ea48" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 lexeme 구문 분석기는 자연수 (양수)를 구문 분석합니다. 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="5b51da9dfdc6deacb56625f72d3743f1f276426c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a single literal character. Returns the literal character value. This parsers deals correctly with escape sequences. The literal character is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">이 lexeme 파서는 단일 리터럴 문자를 구문 분석합니다. 리터럴 문자 값을 리턴합니다. 이 파서는 이스케이프 시퀀스를 올바르게 처리합니다. 리터럴 문자는 Haskell 보고서에 정의 된 문법 규칙 (대부분의 프로그래밍 언어와 매우 일치)에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="df49a67e0891da13df2aeac391d3a61690541ebd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 exeme 파서는 정수 (정수)를 구문 분석합니다. 이 파서는 기호 앞에 접두사를 붙일 수 있다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 습니다 (예 : '-'또는 '+'). 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="ca0065c43e88f0ea0be37c852f441cefb8de14a7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 exeme 파서는 정수 (정수)를 구문 분석합니다. 이 파서는 기호 앞에 접두사를 붙일 수 있다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 습니다 (예 : '-'또는 '+'). 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="bf7d3fe039b607009e325c09fadc027724bbba18" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">이 lexeme 파서는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; 을 구문 분석합니다 . 숫자 값을 반환합니다. 이 파서는 자연수와 수레에 대한 문법 규칙의 중복을 처리합니다. 숫자는 Haskell 보고서에 정의 된 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc0de1ff1da25f44b1ba64f4600fc6b2f58174a" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">이 lexeme 파서는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; 을 구문 분석합니다 . 숫자 값을 반환합니다. 이 파서는 자연수와 수레에 대한 문법 규칙의 중복을 처리합니다. 숫자는 Haskell 보고서에 정의 된 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="8b3e538648d90a568eed7b3e4b7980db877318e7" translate="yes" xml:space="preserve">
          <source>This lexer is not completely faithful to the Haskell lexical syntax in the following respects:</source>
          <target state="translated">이 어휘 분석기는 다음과 같은 측면에서 Haskell 어휘 구문에 충실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba0c905e7229e2d42cfbc9060686e3e8b51c3edc" translate="yes" xml:space="preserve">
          <source>This library defines parser combinators for precedence parsing.</source>
          <target state="translated">이 라이브러리는 우선 순위 구문 분석을위한 구문 분석기 결합기를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="26d58c3f8313372fb9a5712eb67174707d34b82e" translate="yes" xml:space="preserve">
          <source>This library provides facilities for parsing the command-line options in a standalone program. It is essentially a Haskell port of the GNU &lt;code&gt;getopt&lt;/code&gt; library.</source>
          <target state="translated">이 라이브러리는 독립형 프로그램에서 명령 행 옵션을 구문 분석하기위한 기능을 제공합니다. 기본적으로 GNU &lt;code&gt;getopt&lt;/code&gt; 라이브러리 의 Haskell 포트입니다 .</target>
        </trans-unit>
        <trans-unit id="dd805dfecd7f77257c432c66329c165e81f0fc28" translate="yes" xml:space="preserve">
          <source>This library provides support for &lt;em&gt;strict&lt;/em&gt; state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones &lt;em&gt;Lazy Functional State Threads&lt;/em&gt;.</source>
          <target state="translated">이 라이브러리는 John Launchbury와 Simon Peyton Jones &lt;em&gt;Lazy Functional State Threads&lt;/em&gt; 의 PLDI '94 논문에 설명 된대로 &lt;em&gt;엄격한&lt;/em&gt; 상태 스레드를 지원합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8126030a0db08f6efcbf327884b71cf1e6318582" translate="yes" xml:space="preserve">
          <source>This limitation is easily subvertible, so please ask if you get stuck on it.</source>
          <target state="translated">이 제한은 쉽게 바꿀 수 있으므로 문제가 발생했는지 물어보십시오.</target>
        </trans-unit>
        <trans-unit id="21a515f07e3c656c64c893fcd677dfba412563b8" translate="yes" xml:space="preserve">
          <source>This list could readily be extended; if there are Prelude functions that you use a lot which are not included, please tell us.</source>
          <target state="translated">이 목록은 쉽게 확장 될 수 있습니다. 포함되지 않은 로트를 사용하는 Prelude 기능이있는 경우 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="c9d77f7a9ab7e1d50b50bd600bb71a7967ecbbfb" translate="yes" xml:space="preserve">
          <source>This list is for GHC users to chat among themselves. If you have a specific question about GHC, please check the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; first.</source>
          <target state="translated">이 목록은 GHC 사용자가 서로 대화 할 수 있도록하기위한 것입니다. GHC에 대한 특정 질문이 있으면 먼저 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="29a814259d6babfac9ea76d85ac921a5f02baa19" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro expands to a string recording the version of &lt;code&gt;pkgname&lt;/code&gt; that is exposed for module import. It is identical in behavior to the &lt;code&gt;VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">이 매크로는 GHC 8.0부터 사용할 수 있습니다. 노출 된 모든 패키지에 대해 정의됩니다. 이 매크로 는 모듈 가져 오기에 노출 되는 &lt;code&gt;pkgname&lt;/code&gt; 버전을 기록하는 문자열로 확장됩니다 . Cabal이 정의한 &lt;code&gt;VERSION_pkgname&lt;/code&gt; 매크로와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a74c45d8cbbb98f3219b81a76db9cbe9b302bc7d" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro is provided for convenience to write CPP conditionals testing if a package version is &lt;code&gt;x.y.z&lt;/code&gt; or later. It is identical in behavior to the &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">이 매크로는 GHC 8.0부터 사용할 수 있습니다. 노출 된 모든 패키지에 대해 정의됩니다. 이 매크로는 패키지 버전이 &lt;code&gt;x.y.z&lt;/code&gt; 이상인 경우 CPP 조건부 테스트를 편리하게 작성할 수 있도록 제공됩니다 . Cabal이 정의한 &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; 매크로 와 동작은 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="369c31dee13e7ebf7250f99f560cae58a6ec67ab" translate="yes" xml:space="preserve">
          <source>This macro is available starting with GHC 7.10.1.</source>
          <target state="translated">이 매크로는 GHC 7.10.1부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b70fd2d98680d3ba8f51b750ceee956a98a51c" translate="yes" xml:space="preserve">
          <source>This macro is provided for convenience to write CPP conditionals testing whether the GHC version used is version &lt;code&gt;x.y.z.z'&lt;/code&gt; or later.</source>
          <target state="translated">이 매크로는 사용 된 GHC 버전이 버전 &lt;code&gt;x.y.z.z'&lt;/code&gt; 이상 인지 여부를 테스트하는 CPP 조건부 테스트를 편리하게 작성하기 위해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ccb8c1a1ef41b359721ee50eeb5b0ffe5456b94" translate="yes" xml:space="preserve">
          <source>This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">이 매크로는 Haskell 모듈에서 생성 된 C 소스 (예 : &lt;code&gt;.hs&lt;/code&gt; , &lt;code&gt;.lhs&lt;/code&gt; , &lt;code&gt;.c&lt;/code&gt; 및 &lt;code&gt;.hc&lt;/code&gt; 파일)를 포함하여 Haskell 소스 및 C 소스를 사전 처리 할 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="126816cfbceb17265259c1bfd692cfa851e88117" translate="yes" xml:space="preserve">
          <source>This makes a copy, so does not retain the input string.</source>
          <target state="translated">이렇게하면 복사본이 만들어 지므로 입력 문자열이 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="409b9c14a753a56835750678eec0ceed50896009" translate="yes" xml:space="preserve">
          <source>This makes it convenient for printing the values of interesting variables or expressions inside a function. For example here we print the value of the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">이것은 함수 안에서 흥미로운 변수 나 표현식의 값을 인쇄하는데 편리합니다. 예를 들어 변수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 값을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d154b682a58894f927011c8dcf1525090a6bca45" translate="yes" xml:space="preserve">
          <source>This may take real work, but&amp;hellip; There exist piles of massively-tuned library code, and the best thing is not to compete with it, but link with it.</source>
          <target state="translated">이 작업에는 실제 작업이 필요할 수 있지만 ... 엄청나게 조정 된 라이브러리 코드가 많이 있으며, 가장 좋은 점은 경쟁하지 않고 링크하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8e305a9c2249a611331558008a6864ebdcc9df92" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 성능이 우수 합니다.</target>
        </trans-unit>
        <trans-unit id="a2f7283b2f57776282bb867fc6a49c83c2f23c8b" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 성능이 우수 합니다.</target>
        </trans-unit>
        <trans-unit id="1d65304cb52af71023e15bd45422c06447d534f9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 약간 더 나은 성능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9f79e70de4e10cc28ee0029d0a6a35c1bbea2e78" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 약간 더 나은 성능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="5f2b22c1be27f1ee28d05bb2aade303875940243" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 약간 더 나은 성능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9c92fe3388c138613ddb9738050b4232a8c3e292" translate="yes" xml:space="preserve">
          <source>This means that if you need to make a foreign call to a function that takes a long time or blocks indefinitely, then you should mark it &lt;code&gt;safe&lt;/code&gt; and use &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;. Some library functions make such calls internally; their documentation should indicate when this is the case.</source>
          <target state="translated">즉, 시간이 오래 걸리거나 무기한으로 차단되는 함수에 대한 외래 호출을해야하는 경우이를 &lt;code&gt;safe&lt;/code&gt; 표시하고 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다. 일부 라이브러리 함수는 이러한 호출을 내부적으로 수행합니다. 이 경우에는 해당 문서에 해당 내용이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c345f7d8502440fe1972767e0230a2d484f96fc3" translate="yes" xml:space="preserve">
          <source>This means that many operations on sequences are stricter than those on lists. For example,</source>
          <target state="translated">이는 시퀀스에 대한 많은 작업이 목록에있는 작업보다 엄격하다는 것을 의미합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="512d8c4339c4e152167f7ed6529861156bdd0ce2" translate="yes" xml:space="preserve">
          <source>This means that the usual string syntax can be used, e.g., for &lt;code&gt;ByteString&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, and other variations of string like types. String literals behave very much like integer literals, i.e., they can be used in both expressions and patterns. If used in a pattern the literal will be replaced by an equality test, in the same way as an integer literal is.</source>
          <target state="translated">즉, 일반적인 문자열 구문을 사용할 수 있습니다 (예 : &lt;code&gt;ByteString&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; 및 기타 유형의 문자열 유사). 문자열 리터럴은 정수 리터럴과 매우 유사하게 작동합니다. 즉, 표현식과 패턴 모두에 사용할 수 있습니다. 패턴에 사용될 경우 리터럴은 정수 리터럴과 같은 방식으로 동등 테스트로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6e84b7b55ab4e53c7918a9eed0f0386ae7086f12" translate="yes" xml:space="preserve">
          <source>This means we're all done. All the builder data has now been written.</source>
          <target state="translated">이것은 우리 모두 끝났음을 의미합니다. 모든 빌더 데이터가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="a699a362a2564a3c76496bfcaced4dda0fd71569" translate="yes" xml:space="preserve">
          <source>This mechanism makes use of GHC's efficient built-in generics support.</source>
          <target state="translated">이 메커니즘은 GHC의 효율적인 내장 제네릭 지원을 활용합니다.</target>
        </trans-unit>
        <trans-unit id="ed8ed8da55dd83a0ef130774f673009214846879" translate="yes" xml:space="preserve">
          <source>This method is surprisingly useful. Where both instances exist and are lawful we have the following laws:</source>
          <target state="translated">이 방법은 놀랍게도 유용합니다. 두 경우 모두 존재하고 합법적 인 경우 다음과 같은 법률이 있습니다.</target>
        </trans-unit>
        <trans-unit id="917ff2b24c3401ef265e4f82c89c8ae89e4dbe83" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; as its default implementation (which ought to be equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; for types which possess a 0th bit).</source>
          <target state="translated">이 메소드는 &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; 을 기본 구현으로 사용합니다 ( 0 비트를 소유 한 유형의 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; 와 동일해야 함 ).</target>
        </trans-unit>
        <trans-unit id="a56c576252b7c2f659be8b6306ca50d283138678" translate="yes" xml:space="preserve">
          <source>This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; option can be omitted.</source>
          <target state="translated">이 모드는 명령 행에 언급 된 Haskell 소스 파일이있는 경우 기본값이며,이 경우 &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 옵션을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa78e5fdb695de8a1ddc90859fa15ef056bc6c5" translate="yes" xml:space="preserve">
          <source>This mode is very similar to interactive mode, except that there is a single expression to evaluate which is specified on the command line as an argument to the &lt;code&gt;-e&lt;/code&gt; option:</source>
          <target state="translated">이 모드는 &lt;code&gt;-e&lt;/code&gt; 옵션 의 인수로 명령 행에 지정된 단일 표현식이 있다는 점을 제외하고 대화식 모드와 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c36679dee1440f17c5d2fe66c1ebdd875fd933fe" translate="yes" xml:space="preserve">
          <source>This module also contains generalisations of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to work with any &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">이 모듈에는 모든 &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 인스턴스 와 작동하기위한 &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; 의 일반화도 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4d1e1a6706fb58eb88829be1d42c2470d6cd3f3" translate="yes" xml:space="preserve">
          <source>This module can be imported for defining forward compatible &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instances:</source>
          <target state="translated">이 모듈은 앞으로 호환 가능한 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의하기 위해 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e27f3d7a593111ec01d1dd70cd801444f3e1d34" translate="yes" xml:space="preserve">
          <source>This module contains platform specific information about types. __/As such the types presented on this page reflect the platform on which the documentation was generated and may not coincide with the types on your platform./__</source>
          <target state="translated">이 모듈에는 유형에 대한 플랫폼 별 정보가 포함되어 있습니다. __ /이 페이지에 제시된 이러한 유형은 문서가 생성 된 플랫폼을 반영하며 플랫폼의 유형과 일치하지 않을 수 있습니다 ./__</target>
        </trans-unit>
        <trans-unit id="69fea24c1770ed9b0390c085efc99817f8d87553" translate="yes" xml:space="preserve">
          <source>This module contains support for pooled memory management. Under this scheme, (re-)allocations belong to a given pool, and everything in a pool is deallocated when the pool itself is deallocated. This is useful when &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; with its implicit allocation and deallocation is not flexible enough, but explicit uses of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; are too awkward.</source>
          <target state="translated">이 모듈은 풀링 된 메모리 관리를 지원합니다. 이 체계에서 (재) 할당은 주어진 풀에 속하며 풀 자체의 할당이 해제 될 때 풀의 모든 할당이 해제됩니다. 이것은 암시 적 할당과 할당 해제가있는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; 가 충분히 유연하지 않지만 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 를 명시 적으로 사용하는 것이 너무 어색한 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="13d5f93e40c79a18376dc00ca5c87434053f0a7f" translate="yes" xml:space="preserve">
          <source>This module currently does not expose functions that require the special properties of fixed-size primitives. They are useful for prefixing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s with their size or for implementing chunked encodings. We will expose the corresponding functions in future releases of this library.</source>
          <target state="translated">이 모듈은 현재 고정 크기 프리미티브의 특수 속성이 필요한 기능을 노출하지 않습니다. 그것들은 크기가 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 인 접두사 또는 청크 인코딩을 구현 하는 데 유용합니다 . 이 라이브러리의 이후 릴리스에서 해당 기능을 공개 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5142c08054d9871661f7f0d130cb3d6fdd9407d3" translate="yes" xml:space="preserve">
          <source>This module defines a &quot;Fixed&quot; type for fixed-precision arithmetic. The parameter to &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; is any type that's an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; has a single method that gives the resolution of the &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈은 고정밀 산술을위한 &quot;고정&quot;유형을 정의합니다. &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 에 대한 매개 변수 는 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 모든 유형입니다 . &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 유형 의 해상도를 제공하는 단일 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c812190315e834b8c95ed3f2997592b7564b3fdf" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="748c4571f3ce28ef125886641fac7bef9890107e" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75f0e64e356523d1a0c9eb699ad805d54ab82048" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a495bc59840aa160735fbc988dd7aa12e8ba85b8" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af9c5e66541cb60627fc011c4ff85f664b7cc4ed" translate="yes" xml:space="preserve">
          <source>This module defines bitwise operations for signed and unsigned integers. Instances of the class &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; types are available from this module, and instances for explicitly sized integral types are available from the &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; modules.</source>
          <target state="translated">이 모듈은 부호있는 정수와 부호없는 정수에 대한 비트 단위 연산을 정의합니다. 클래스의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 위한 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 타입은이 모듈에서 사용할 수 있으며, 명백하게 크기 일체형 타입 인스턴스로부터 가능한 &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; 및 &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="64cded15389022e2237acadfc2c3eed972bdb24d" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; class used by the &lt;code&gt;OverloadedRecordFields&lt;/code&gt; extension. See the &amp;lt;&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; wiki page&amp;gt; for more details.</source>
          <target state="translated">이 모듈은 &lt;code&gt;OverloadedRecordFields&lt;/code&gt; 확장에서 사용되는 &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; 클래스를 정의합니다 . 자세한 내용은 &amp;lt; &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; 위키 페이지&amp;gt;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec6eb416164cb4715d4e03695cde3fb980e473a9" translate="yes" xml:space="preserve">
          <source>This module defines the basic operations on I/O &quot;handles&quot;. All of the operations defined here are independent of the underlying device.</source>
          <target state="translated">이 모듈은 I / O &quot;핸들&quot;에 대한 기본 조작을 정의합니다. 여기에 정의 된 모든 작업은 기본 장치와 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="d59bda9eaeaf5c1e3a36e9b88b617c773901fa3b" translate="yes" xml:space="preserve">
          <source>This module describes a structure intermediate between a functor and a monad (technically, a strong lax monoidal functor). Compared with monads, this interface lacks the full power of the binding operation &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, but</source>
          <target state="translated">이 모듈은 functor와 monad (기술적으로는 강력한 lax monoidal functor) 사이의 중간 구조를 설명합니다. 모나드와 비교할 때이 인터페이스에는 바인딩 작업의 모든 기능이 부족 하지만 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6da3e730b43c82c0b85f8ebac281848e3fc9fe3b" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">이 모듈 은 모든 파일 경로와 환경 문자열이 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;ByteString&lt;/code&gt; 으로 표시된다는 점을 제외하고 &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; 와 정확히 동일한 API를 내 보냅니다 . &lt;a href=&quot;system-posix&quot;&gt;System.Posix의&lt;/a&gt; API를이 버전이 더 인코딩을하지 않습니다 또는 디코딩 및 원시 바이트의 관점에서 직접 작동하는 반면 API는 암시 적으로 모든 파일 경로 및 로케일 인코딩을 사용하여 환경 문자열을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="432a06fcd12fe64c315d994b347ca09ea56e286d" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">이 모듈 은 모든 파일 경로와 환경 문자열이 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;ByteString&lt;/code&gt; 으로 표시된다는 점을 제외하면 &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; 와 정확히 동일한 API를 내 보냅니다 . &lt;a href=&quot;system-posix&quot;&gt;System.Posix의&lt;/a&gt; API를이 버전이 더 인코딩을하지 않습니다 또는 디코딩 및 원시 바이트의 관점에서 직접 작동하는 반면 API는 암시 적으로 모든 파일 경로 및 로케일 인코딩을 사용하여 환경 문자열을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ae57a29c16b708a5f862b98209ca33ec88b9833b" translate="yes" xml:space="preserve">
          <source>This module exposes the &lt;em&gt;portable&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API. See &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; for the &lt;code&gt;integer-gmp&lt;/code&gt;-specific internal representation of &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; as well as optimized GMP-specific operations.</source>
          <target state="translated">이 모듈은 &lt;em&gt;이식 가능한 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API를 제공합니다. &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 의 정수 &lt;code&gt;integer-gmp&lt;/code&gt; 특정 내부 표현 과 최적화 된 GMP 특정 작업에 대해서는 &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a94829165fdca15372f0126fd78a0b495ce0522" translate="yes" xml:space="preserve">
          <source>This module implements permutation parsers. The algorithm used is fairly complex since we push the type system to its limits :-) The algorithm is described in:</source>
          <target state="translated">이 모듈은 순열 파서를 구현합니다. 사용 된 알고리즘은 타입 시스템을 한계로 밀어 넣기 때문에 상당히 복잡합니다 :-) 알고리즘은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="c272683515777617630ed062550e54f1e41af5ba" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 기능에 대한 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화 하기 위한 GHC 다시 쓰기 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 단 , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 것보다 시간이 오래 걸립니다. 시간이 매우 많이 소요될 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96caa6e7405bbcf705758c402e5dc69c91123112" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 펑터에 대해 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화하는 GHC 재 작성 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 유일한 예외는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 경우보다 시간이 더 오래 걸린다는 것입니다. 이것이 매우 많은 시간 동안 발생할 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="480d93e68fd6dc10a57cdf9aae6e88c254901353" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 기능에 대한 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화 하기 위한 GHC 다시 쓰기 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 단 , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 것보다 시간이 오래 걸립니다. 시간이 매우 많이 소요될 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="824034cfb4513aba4aa1c338187313dac84e67aa" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 펑터에 대해 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화하는 GHC 재 작성 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 유일한 예외는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 경우보다 시간이 더 오래 걸린다는 것입니다. 이것이 매우 많은 시간 동안 발생할 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7db164d6a986565222e119d577ff5c229ba8b29b" translate="yes" xml:space="preserve">
          <source>This module includes everything you need to get started writing a parser.</source>
          <target state="translated">이 모듈에는 파서 작성을 시작하는 데 필요한 모든 것이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0f68392cbf21d07cf104e09ea0593872ccee43" translate="yes" xml:space="preserve">
          <source>This module is GHC-only and should not be considered portable.</source>
          <target state="translated">이 모듈은 GHC 전용이므로 휴대용으로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="84656ba40cd08703f7a3e8f512a38792e056d9c4" translate="yes" xml:space="preserve">
          <source>This module is an internal GHC module. It declares the constants used in the implementation of type-level natural numbers. The programmer interface for working with type-level naturals should be defined in a separate library.</source>
          <target state="translated">이 모듈은 내부 GHC 모듈입니다. 타입 레벨의 자연수 구현에 사용되는 상수를 선언합니다. 타입 레벨 내츄럴로 작업하기위한 프로그래머 인터페이스는 별도의 라이브러리에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3afde49cd7420849dc0a50c7430aa7753bf402f" translate="yes" xml:space="preserve">
          <source>This module is considered &lt;strong&gt;internal&lt;/strong&gt;.</source>
          <target state="translated">이 모듈은 &lt;strong&gt;내부&lt;/strong&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="32342dd868ac356dff4bac50bb615e44b16dffd8" translate="yes" xml:space="preserve">
          <source>This module is inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">이 모듈은 &lt;em&gt;과부하 및 고차 다형성을 이용한 기능적 프로그래밍&lt;/em&gt; , Mark P Jones ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt; ) 1995 년 고급 기능성 스쿨 (School School of Functional Programming) 이라는 논문에서 영감을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="7096f5bf81e4fc89257ced2d74b5c3eaad60b08c" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions, e.g.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 기능 과의 이름 충돌을 피하기 위해 &lt;code&gt;qualified&lt;/code&gt; 가져 오기 위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eee7efdf6521c2a0678812a45bb80ea8d0fd2ac6" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 기능 과 이름 충돌을 피하기 위해 &lt;code&gt;qualified&lt;/code&gt; 되어 가져 오기위한 것입니다. 예.</target>
        </trans-unit>
        <trans-unit id="ed3534379c86106e1fb6aab32dbe9ba4e8065b07" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">이 모듈은 수입하기위한 것입니다 &lt;code&gt;qualified&lt;/code&gt; 과 이름이 충돌하지 않도록, &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;서곡의&lt;/a&gt; 기능을. 예.</target>
        </trans-unit>
        <trans-unit id="93e00704b6043d91bc0b1a65e596b7ceb43c33c8" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported qualified, to avoid name clashes with Prelude functions:</source>
          <target state="translated">이 모듈은 Prelude 기능과 이름 충돌을 피하기 위해 가져 오기 자격을 갖도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="c97f8a3f89d9890b95b69a48863882918e86fa8c" translate="yes" xml:space="preserve">
          <source>This module is part of the Foreign Function Interface (FFI) and will usually be imported via the module &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 FFI (Foreign Function Interface)의 일부이며 일반적으로 &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; 모듈을 통해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="461f2e382a01bf00f47b644a6f12f006c2e2728e" translate="yes" xml:space="preserve">
          <source>This module only defines the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad; you probably want to import &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; (which exports &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 만 정의합니다 . &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; ( &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt; 내보내기 ) 을 가져오고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fcaff35e4331afea7bccc306685504864f4b033e" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; operations until a value depending on them is required.</source>
          <target state="translated">이 모듈 은 모나드가 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 연산에 대한 값이 필요할 때까지 ST 연산의 평가를 지연 시킨다는 점을 제외하고 &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt; 와 동일한 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="785b925d63da4b41979c13438250f723b3f36584" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of state operations until a value depending on them is required.</source>
          <target state="translated">이 모듈 은 모나드가 그에 따른 값이 필요할 때까지 상태 연산의 평가를 지연 시킨다는 점을 제외하고 &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt; 와 동일한 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="5d29751e61c6eafcb5fbfdc53fe9336d12c4e225" translate="yes" xml:space="preserve">
          <source>This module provides &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;&lt;em&gt;primitives&lt;/em&gt;, which are lower level building blocks for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. You don't need to go down to this level but it can be slightly faster.</source>
          <target state="translated">이 모듈은 제공 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; &lt;em&gt; 프리미티브&lt;/em&gt; 구성에 대한 낮은 수준의 빌딩 블록, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 들. 이 수준으로 내려갈 필요는 없지만 약간 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4ed2fc38393aca2df37326ba9f3afba3af1d5c" translate="yes" xml:space="preserve">
          <source>This module provides a low-level API to the line history stored in the &lt;code&gt;InputT&lt;/code&gt; monad transformer.</source>
          <target state="translated">이 모듈은 &lt;code&gt;InputT&lt;/code&gt; 모나드 변환기에 저장된 회선 히스토리에 저수준 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f1d3e88a44dc84dd2e2655daf9dcf215e0055df4" translate="yes" xml:space="preserve">
          <source>This module provides a low-level interface to the C functions of the terminfo library.</source>
          <target state="translated">이 모듈은 terminfo 라이브러리의 C 함수에 대한 저수준 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dcfa8281ead615b485cbc67a44a0d67023dd3214" translate="yes" xml:space="preserve">
          <source>This module provides a simple interface for executing external commands. For a more complex, but more powerful, interface, see the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module.</source>
          <target state="translated">이 모듈은 외부 명령을 실행하기위한 간단한 인터페이스를 제공합니다. 더 복잡하지만 더 강력한 인터페이스는 &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a90fd78951dfe7db7ffb984d132da2184a51611f" translate="yes" xml:space="preserve">
          <source>This module provides a stateful, IO-based interface to Haskeline, which may be easier to integrate into some existing programs or libraries.</source>
          <target state="translated">이 모듈은 Haskeline에 상태 기반 IO 기반 인터페이스를 제공하여 기존의 일부 프로그램이나 라이브러리에 쉽게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7665bb8888c593637beee8ce6f79ca4404cc5473" translate="yes" xml:space="preserve">
          <source>This module provides a version of pretty that allows for annotations to be attached to documents. Annotations are arbitrary pieces of metadata that can be attached to sub-documents.</source>
          <target state="translated">이 모듈은 주석을 문서에 첨부 할 수있는 pretty 버전을 제공합니다. 주석은 하위 문서에 첨부 할 수있는 임의의 메타 데이터 조각입니다.</target>
        </trans-unit>
        <trans-unit id="c1a38449e4b89f12a5a25525a42c36b9312c0f84" translate="yes" xml:space="preserve">
          <source>This module provides access to internal garbage collection and memory usage statistics. These statistics are not available unless a program is run with the &lt;code&gt;-T&lt;/code&gt; RTS flag.</source>
          <target state="translated">이 모듈은 내부 가비지 수집 및 메모리 사용 통계에 대한 액세스를 제공합니다. 프로그램이 &lt;code&gt;-T&lt;/code&gt; RTS 플래그 와 함께 실행되지 않으면이 통계를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9f3add7a2fb1719164d2ace74420d665a5258e75" translate="yes" xml:space="preserve">
          <source>This module provides capabilities for moving the cursor on the terminal.</source>
          <target state="translated">이 모듈은 터미널에서 커서를 이동하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e18030012ebf6800ca52122e711e5ae7b02da7e6" translate="yes" xml:space="preserve">
          <source>This module provides efficient containers-based functions on the list type.</source>
          <target state="translated">이 모듈은 목록 유형에서 효율적인 컨테이너 기반 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1f668197932586f66f5efc5d3fb7ae4c036d630e" translate="yes" xml:space="preserve">
          <source>This module provides overloaded functions, such as &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt;, for fully evaluating data structures (that is, evaluating to &quot;Normal Form&quot;).</source>
          <target state="translated">이 모듈은 데이터 구조를 완전히 평가하기 위해 (즉, &quot;정상 형식&quot;으로 평가하기 위해) &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 와 같은 오버로드 된 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="582a828ee9bdf70b77d17ebec335ad7850fb4e35" translate="yes" xml:space="preserve">
          <source>This module provides scalable event notification for file descriptors and timeouts.</source>
          <target state="translated">이 모듈은 파일 디스크립터 및 시간 종료에 대한 확장 가능한 이벤트 알림을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="854a2eebed7e5e3bcde5ed1dde2b3bcda6e0ef76" translate="yes" xml:space="preserve">
          <source>This module provides support for raising and catching both built-in and user-defined exceptions.</source>
          <target state="translated">이 모듈은 내장 예외 및 사용자 정의 예외를 발생시키고 포착하는 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="779b1cd1a00e8f21b85e9635dbc10c2617ea3dc3" translate="yes" xml:space="preserve">
          <source>This module provides text encoding/decoding using iconv</source>
          <target state="translated">이 모듈은 iconv를 사용하여 텍스트 인코딩 / 디코딩을 제공합니다</target>
        </trans-unit>
        <trans-unit id="bd39e9a11c79866d26b9bd27b7ee858d0e154873" translate="yes" xml:space="preserve">
          <source>This module provides the various sorting implementations for &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence&lt;/a&gt;. Further notes are available in the file sorting.md (in this directory).</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence에&lt;/a&gt; 대한 다양한 정렬 구현을 제공합니다 . 추가 정보는 sorting.md 파일 (이 디렉토리에 있음)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c752cac235dedd97d14389620cb23346095a0f16" translate="yes" xml:space="preserve">
          <source>This module provides typed pointers to foreign data. It is part of the Foreign Function Interface (FFI) and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">이 모듈은 외부 데이터에 대한 형식화 된 포인터를 제공합니다. 외부 기능 인터페이스 (FFI)의 일부이며 일반적으로 &lt;a href=&quot;foreign&quot;&gt;외부&lt;/a&gt; 모듈을 통해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8127ca85318ff1824be538551fa1fd1e340e9ab9" translate="yes" xml:space="preserve">
          <source>This module re-exports &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional&lt;/a&gt;, which produces XHTML 1.0 Transitional. Use &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict&lt;/a&gt; if you want XHTML 1.0 Strict, and &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset&lt;/a&gt; if you want to produce XHTML 1.0 Frameset.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional을&lt;/a&gt; 다시 내보내 XHTML 1.0 Transitional을 생성합니다. XHTML 1.0 Strict 를 원하면 &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Strict를&lt;/a&gt; , XHTML 1.0 프레임 셋을 생성 하려면 &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Frameset을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8ec7f9f123682eb0cc274e7c52cca0f3a5f423e" translate="yes" xml:space="preserve">
          <source>This module re-exports the value lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API, plus several deprecated value strict functions. Please note that these functions have different strictness properties than those in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;: they only evaluate the result of the combining function. For example, the default value to &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; is only evaluated if the combining function is called and uses it.</source>
          <target state="translated">이 모듈은 lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API 값과 더 이상 사용되지 않는 몇 가지 값 엄격한 함수를 다시 내 보냅니다 . 이러한 함수는 &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; 와 다른 엄격 속성을 갖습니다 . 결합 함수의 결과 만 평가합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; 의 기본값 은 결합 함수가 호출되어 사용되는 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="652efe48d7f69bcc3c5490c01c5c8cb0efb0564b" translate="yes" xml:space="preserve">
          <source>This module redefines some of the functions in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; to work for more general monads built on top of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception의&lt;/a&gt; 일부 기능을 재정 의하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 위에 구축 된보다 일반적인 모나드에 대해 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3f6ca5d2535d9794227136b6b0c705ce4e24c48c" translate="yes" xml:space="preserve">
          <source>This module satisfies the following strictness property:</source>
          <target state="translated">이 모듈은 다음과 같은 엄격 성을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="d8eb2deb7a56d67d9c957df553d23a112baecc39" translate="yes" xml:space="preserve">
          <source>This module should be considered GHC internal.</source>
          <target state="translated">이 모듈은 GHC 내부로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="29e73688c548bf0c2243628b3c05e4e5e0b07e48" translate="yes" xml:space="preserve">
          <source>This module should be used as opposed to the &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; module. Both are equivalent though as this module simply re-exports the other.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 모듈 과 반대로 사용해야 합니다. 이 모듈은 단순히 다른 모듈을 다시 내보내므로 둘 다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="59ad027c5fc678b3f6724e2d8a2c3619f02ad834" translate="yes" xml:space="preserve">
          <source>This modules provides access to the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; constructors and exposes some highly optimized GMP-operations.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 생성자에 대한 액세스를 제공하고 고도로 최적화 된 GMP 작업을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="1130e146d0ff983a031a0a8522c8725e170d0829" translate="yes" xml:space="preserve">
          <source>This monad transformer adds the ability to fail or throw exceptions to a monad.</source>
          <target state="translated">이 모나드 변환기는 모나드에 예외를 던지거나 예외를 던지는 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2a98bbb5afc9600bb6b74cc7f447cb8e1866b15b" translate="yes" xml:space="preserve">
          <source>This monad transformer extends a monad with the ability to throw exceptions.</source>
          <target state="translated">이 모나드 변압기는 예외를 던질 수있는 기능으로 모나드를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="bba2acb7a712203bd9458987272d1dea78c2f000" translate="yes" xml:space="preserve">
          <source>This monad transformer is similar to both state and writer monad transformers. Thus it can be seen as</source>
          <target state="translated">이 모나드 변압기는 상태 및 기록기 모나드 변압기와 유사합니다. 따라서 다음과 같이 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7f2bb8a9d0620b88f4451a6324781ede4a2121a7" translate="yes" xml:space="preserve">
          <source>This monad transformer provides append-only accumulation during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">이 모나드 변환기는 계산 중에 추가 전용 누적을 제공합니다. 보다 일반적인 액세스를 위해서는 &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c53c5e051f564d4139a6d22099093a9506011e0" translate="yes" xml:space="preserve">
          <source>This monad transformer provides only limited access to the output during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">이 모나드 변환기는 계산 중에 출력에 대한 제한된 액세스 만 제공합니다. 보다 일반적인 액세스를 위해서는 &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e64b48298e57e04598190a3e73a7a420ac326928" translate="yes" xml:space="preserve">
          <source>This now re-exports &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="48569d17cf06edd49e682678e1dd43b354e7266d" translate="yes" xml:space="preserve">
          <source>This only happens if:</source>
          <target state="translated">다음과 같은 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c0b5dda6372d83897c8a1df104f5345b0b4220f" translate="yes" xml:space="preserve">
          <source>This only shows the time zone name, or offset if the name is empty.</source>
          <target state="translated">시간대 이름 만 표시되거나 이름이 비어 있으면 오프셋이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="48af544d61c79afa3a39e1cd49eb4f6213f4528d" translate="yes" xml:space="preserve">
          <source>This only stands a chance of working for an encoding which is an ASCII superset, as for security reasons we refuse to escape any bytes smaller than 128. Many encodings of interest are ASCII supersets (in particular, you can assume that the locale encoding is an ASCII superset) but many (such as UTF-16) are not.</source>
          <target state="translated">보안상의 이유로 128보다 작은 바이트를 이스케이프하지 않으려는 경우 ASCII 수퍼 셋 인 인코딩에 대해서만 작업 할 수 있습니다. 관심있는 많은 인코딩은 ASCII 수퍼 셋입니다 (특히 로케일 인코딩은 ASCII 수퍼 셋)이지만 UTF-16과 같은 많은 것은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6ecf6dcbeadf01a7014b13f5a368ef88d650353" translate="yes" xml:space="preserve">
          <source>This only works for &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">이는 &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; 형식, 단일 문자 군 시간대 및 &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</target>
        </trans-unit>
        <trans-unit id="d7c1d4016c14da3ba1514123886da29a32443086" translate="yes" xml:space="preserve">
          <source>This only works for a &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">이것은 단지 작동 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; 형식, 단일 문자 군용 시간 영역 및이 시간 영역 : &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot; CDT &quot;,&quot;MST &quot;,&quot;MDT &quot;,&quot;PST &quot;,&quot;PDT &quot;.</target>
        </trans-unit>
        <trans-unit id="23816db6dd8bea367310677e3bfbcb17ade64070" translate="yes" xml:space="preserve">
          <source>This operation acquires a unit from the semaphore (i.e. decreases the internal counter) and blocks (via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;) if no units are available (i.e. if the counter is &lt;em&gt;not&lt;/em&gt; positive).</source>
          <target state="translated">이 작업은 세마포어에서 장치를 획득하고 (즉, 내부 카운터를 감소시킵니다) 사용 가능한 장치가없는 경우 (즉 카운터가 양수 가 &lt;em&gt;아닌&lt;/em&gt; 경우) &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 를 통해 차단 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7014f780887d062aecc25cade39318f1f4267c3d" translate="yes" xml:space="preserve">
          <source>This operation adds/releases a unit back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">이 작업은 장치를 세마포어에 다시 추가 / 해제합니다 (즉, 내부 카운터를 증가시킵니다).</target>
        </trans-unit>
        <trans-unit id="bbef804c0feb5706c138bd85cf6a98a3ae663039" translate="yes" xml:space="preserve">
          <source>This operation adds/releases multiple units back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">이 작업은 여러 장치를 세마포에 다시 추가 / 해제합니다 (즉, 내부 카운터를 증가시킵니다).</target>
        </trans-unit>
        <trans-unit id="23431b855341eca76cdc24f413dd7563b100983c" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">이 연산은 주로 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값을 직접 구성하는 테스트 슈트 및 / 또는 코드에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="49d93c809fbddf9cf81dbda4c05507ecf14db03e" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">이 연산은 주로 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값을 직접 구성하는 테스트 슈트 및 / 또는 코드에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3297c146519190d66c5419366b511b5ce250ad" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">이 작업은 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 정의 에서 IO 작업이 여러 번 실행되는 것을 방지하기 위해 사용되며 일반적으로 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2f6053c6fe980d3303ab7779a6c30bf3b23e441" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">이 작업은 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 정의 에서 IO 작업이 여러 번 실행되는 것을 방지하기 위해 사용되며 일반적으로 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ee46adec231f99964d238f6075b76987a604b31" translate="yes" xml:space="preserve">
          <source>This operation may fail with:</source>
          <target state="translated">이 작업은 다음과 같이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a481371f0ca2e52248cb4d557f65d6db3c681c94" translate="yes" xml:space="preserve">
          <source>This optimisation isn&amp;rsquo;t always beneficial though (so GHC applies some heuristics to decide when to apply it). The details get complicated but a simple example is that it is often beneficial to move let bindings outwards so that multiple let bindings can be grouped into a larger single let binding, effectively batching their allocation and helping the garbage collector and allocator.</source>
          <target state="translated">이 최적화가 항상 유익하지는 않습니다 (따라서 GHC는 일부 휴리스틱을 적용하여 적용시기를 결정합니다). 세부 사항은 복잡하지만 간단한 예는 여러 let 바인딩이 더 큰 단일 let 바인딩으로 그룹화되어 할당을 효과적으로 일괄 처리하고 가비지 수집기 및 할당자를 도와 줄 수 있도록 let 바인딩을 바깥쪽으로 옮기는 것이 종종 유리하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="daf337b821cabcc31b64cb93551eb620a65ef97d" translate="yes" xml:space="preserve">
          <source>This optimisation moves let bindings closer to their use site. The benefit here is that this may avoid unnecessary allocation if the branch the let is now on is never executed. It also enables other optimisation passes to work more effectively as they have more information locally.</source>
          <target state="translated">이 최적화는 바인딩을 사용 사이트에 더 가깝게 만듭니다. 여기서 이점은 이제 let이있는 분기가 실행되지 않으면 불필요한 할당을 피할 수 있다는 것입니다. 또한 로컬에 더 많은 정보가 있으므로 다른 최적화 단계가 더 효과적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc0b111503fc7f964b8ba8ae4f63543b67f459b" translate="yes" xml:space="preserve">
          <source>This optimisation specializes recursive functions according to their argument &amp;ldquo;shapes&amp;rdquo;. This is best explained by example so consider:</source>
          <target state="translated">이 최적화는 인수 &quot;모양&quot;에 따라 재귀 함수를 전문화합니다. 이것은 예제로 가장 잘 설명되므로 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3fa5960caadfa09849470cf6386b6072cc3ffa4f" translate="yes" xml:space="preserve">
          <source>This option affects the processing of RTS control options given either on the command line or via the &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt; environment variable. There are three possibilities:</source>
          <target state="translated">이 옵션은 명령 행 또는 &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt; 환경 변수 를 통해 제공된 RTS 제어 옵션 처리에 영향을줍니다 . 세 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f85a6ef1d8626265a37c882bf54d7b55e6bccf" translate="yes" xml:space="preserve">
          <source>This option allows you to set the default RTS options at link-time. For example, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; sets the default heap size to 128MB. This will always be the default heap size for this program, unless the user overrides it. (Depending on the setting of the &lt;code&gt;-rtsopts&lt;/code&gt; option, the user might not have the ability to change RTS options at run-time, in which case &lt;code&gt;-with-rtsopts&lt;/code&gt; would be the &lt;em&gt;only&lt;/em&gt; way to set them.)</source>
          <target state="translated">이 옵션을 사용하면 링크 타임에 기본 RTS 옵션을 설정할 수 있습니다. 예를 들어, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; 은 기본 힙 크기를 128MB로 설정합니다. 사용자가이를 무시하지 않는 한 항상이 프로그램의 기본 힙 크기가됩니다. ( &lt;code&gt;-rtsopts&lt;/code&gt; 옵션 의 설정에 따라 런타임시 RTS 옵션을 변경하는 기능이 사용자에게 없을 수 있습니다.이 경우 &lt;code&gt;-with-rtsopts&lt;/code&gt; 가 옵션 을 설정 하는 &lt;em&gt;유일한&lt;/em&gt; 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f91f71cb98fa24b36d5d90d1dbeb3041d935c33b" translate="yes" xml:space="preserve">
          <source>This option causes a warning to be emitted whenever an inner-scope value has the same name as an outer-scope value, i.e. the inner value shadows the outer one. This can catch typographical errors that turn into hard-to-find bugs, e.g., in the inadvertent capture of what would be a recursive call in &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 내부 범위 값이 외부 범위 값과 같은 이름을 가질 때마다 경고가 발생합니다. 즉, 내부 값이 외부 값을 가리게됩니다. 예를 들어, &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt; 재귀 호출이 무엇인지 실수로 캡처하는 경우 찾기 어려운 버그로 바뀌는 인쇄상의 오류를 포착 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed96edbbc25b6f1208ec75b666dd489af6409055" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &amp;ldquo;!&amp;rdquo;) and which representation is smaller or equal to the size of a pointer to be unpacked, if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;) to every strict constructor field that fulfils the size restriction.</source>
          <target state="translated">이 옵션을 사용하면 엄격하게 표시된 (예 :&amp;ldquo;!&amp;rdquo;) 모든 가능한 생성자 필드와 가능한 경우 포인터의 크기보다 작거나 같은 표현이 풀립니다. 그것은 추가 동등 &lt;code&gt;UNPACK&lt;/code&gt; 래그를 (참조 &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;언팩 프라그가&lt;/a&gt; 크기 제한을 만족마다 엄격한 생성자 필드).</target>
        </trans-unit>
        <trans-unit id="e2cd4133d01d71e89460c606007690e42b1fcee7" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &lt;code&gt;!&lt;/code&gt;) to be unpacked if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma to every strict constructor field (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">이 옵션을 사용하면 엄격한 (즉, &lt;code&gt;!&lt;/code&gt; )으로 표시된 모든 생성자 필드가 가능하면 압축이 풀립니다. 모든 엄격한 생성자 필드에 &lt;code&gt;UNPACK&lt;/code&gt; pragma 를 추가하는 것과 같습니다 ( &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fc09848f730f75b415b16f985abe5f3c3b0d4c17" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and distrusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be distrusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">이 옵션을 사용하면 설치 패키지 ⟩pkg⟩가 GHC에 의해 노출되고 신뢰할 수 없게됩니다. 이 명령은 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 명령 과 매우 유사한 방식으로 작동 하지만 또한 패키지 데이터베이스의 내용에 관계없이 선택된 패키지를 GHC에서 신뢰할 수 없도록 설정합니다. ( &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;안전 하스켈&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e900a6603015890af3c88ede22e351087bcb2f4c" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and trusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be trusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">이 옵션을 사용하면 설치 패키지 ⟨pkg⟩가 GHC에 의해 노출되고 신뢰됩니다. 이 명령은 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 명령 과 매우 유사한 방식으로 작동 하지만 패키지 데이터베이스의 내용에 관계없이 선택한 패키지를 GHC에서 신뢰하도록 설정합니다. ( &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;안전 하스켈&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d7d9bf3c24fe2f83f01a2a1fe6e2465277d625b8" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed for plugins, such as &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted if there is only one version of the package installed. If there are multiple versions of ⟨pkg⟩ installed and &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt;&lt;code&gt;-hide-all-plugin-packages&lt;/code&gt;&lt;/a&gt; was not specified, then all other versions will become hidden. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 설치된 패키지 ⟩pkg⟩가 &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; 과 같은 플러그인에 노출됩니다 . 패키지 ⟨pkg⟩는 버전 번호 (예 : &lt;code&gt;network-1.0&lt;/code&gt; ) 로 완전히 지정 하거나 하나의 패키지 버전 만 설치된 경우 버전 번호를 생략 할 수 있습니다. 여러 버전의 ⟨pkg⟩가 설치되어 있고 &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt; &lt;code&gt;-hide-all-plugin-packages&lt;/code&gt; &lt;/a&gt; 가 지정되지 않은 경우 다른 모든 버전이 숨겨집니다. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning 및 &lt;/a&gt;Renaming 모듈에 설명 된 Thinning 및 Renaming을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ef5788126155cc03138f5109c85138baa08f3cb" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted in which case GHC will automatically expose the latest non-broken version from the installed versions of the package.</source>
          <target state="translated">이 옵션을 사용하면 설치된 패키지 ⟨pkg⟩가 노출됩니다. 패키지 ⟨pkg⟩는 버전 번호 (예 : &lt;code&gt;network-1.0&lt;/code&gt; ) 로 완전히 지정 하거나 버전 번호를 생략 할 수 있습니다.이 경우 GHC는 설치된 최신 버전의 패키지에서 최신의 최신 버전을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a0e41ab6d83305de686a095b3332cab6407d1ce0" translate="yes" xml:space="preserve">
          <source>This option causes the runtime to print out the current cost-centre stack whenever an exception is raised. This can be particularly useful for debugging the location of exceptions, such as the notorious &lt;code&gt;Prelude.head: empty list&lt;/code&gt; error. See &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 예외가 발생할 때마다 런타임에서 현재 비용 센터 스택을 인쇄합니다. 이는 악명 높은 &lt;code&gt;Prelude.head: empty list&lt;/code&gt; error 와 같은 예외 위치를 디버깅하는 데 특히 유용 할 수 있습니다 . &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;해커, 디버거 및 관심이 많은 영혼을위한 RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b57872a61028ef8c64baf35e07feb3f3f77cf233" translate="yes" xml:space="preserve">
          <source>This option controls the amount of memory reserved for the older generations (and in the case of a two space collector the size of the allocation area) as a factor of the amount of live data. For example, if there was 2M of live data in the oldest generation when we last collected it, then by default we&amp;rsquo;ll wait until it grows to 4M before collecting it again.</source>
          <target state="translated">이 옵션은 이전 세대 (및 두 공간 콜렉터의 경우 할당 영역 크기)에 예약 된 메모리 양을 라이브 데이터 양의 계수로 제어합니다. 예를 들어, 가장 오래된 세대에 2M의 라이브 데이터가 마지막으로 수집 된 경우 기본적으로 4M으로 커질 때까지 기다렸다가 다시 수집합니다.</target>
        </trans-unit>
        <trans-unit id="fb38d77df4357efae92d504cd6786c9d8c4e6bf3" translate="yes" xml:space="preserve">
          <source>This option disables RTS suggestions about linking with &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; when they are not available. These suggestions would be unhelpful if the users have installed Haskell programs through their package managers. With this option enabled, these suggestions will not appear. It is recommended for people distributing binaries to build with either &lt;code&gt;-rtsopts&lt;/code&gt; or &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 사용 가능하지 않을 때 &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; 와의 링크에 대한 RTS 제안을 비활성화 합니다. 사용자가 패키지 관리자를 통해 Haskell 프로그램을 설치 한 경우 이러한 제안은 도움이되지 않습니다. 이 옵션을 사용하면 이러한 제안이 나타나지 않습니다. 바이너리를 배포하는 사람들은 &lt;code&gt;-rtsopts&lt;/code&gt; 또는 &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt; 로 빌드하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="956ede657ecee5ab5112379453aca532a83df0ab" translate="yes" xml:space="preserve">
          <source>This option displays the currently installed packages, for each of the databases known to &lt;code&gt;ghc-pkg&lt;/code&gt;. That includes the global database, the user&amp;rsquo;s local database, and any further files specified using the &lt;code&gt;-f&lt;/code&gt; option on the command line.</source>
          <target state="translated">이 옵션은 &lt;code&gt;ghc-pkg&lt;/code&gt; 로 알려진 각 데이터베이스에 대해 현재 설치된 패키지를 표시합니다 . 여기에는 글로벌 데이터베이스, 사용자의 로컬 데이터베이스 및 명령 행 에서 &lt;code&gt;-f&lt;/code&gt; 옵션을 사용하여 지정된 추가 파일이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="a08204879e3c5670124e4d3fa4df08f09c2c5827" translate="yes" xml:space="preserve">
          <source>This option does not put a &lt;em&gt;limit&lt;/em&gt; on the heap size: the heap may grow beyond the given size as usual.</source>
          <target state="translated">이 옵션은 힙 크기에 &lt;em&gt;제한&lt;/em&gt; 을 두지 않습니다 . 힙은 평소와 같이 지정된 크기 이상으로 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="177e417c340a66f0470d8511743420a60bcc5fbb" translate="yes" xml:space="preserve">
          <source>This option does the opposite of &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;: it causes the specified package to be hidden, which means that none of its modules will be available for import by Haskell &lt;code&gt;import&lt;/code&gt; directives.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 의 반대입니다 . 지정된 패키지가 숨겨 지므로 Haskell &lt;code&gt;import&lt;/code&gt; 지시문으로 가져올 수있는 모듈이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1560370f0ba5d1fdfc6dfeeacc2a54b30787c270" translate="yes" xml:space="preserve">
          <source>This option is a bit of a sledgehammer: it might sometimes make things worse. Selectively unboxing fields by using &lt;code&gt;UNPACK&lt;/code&gt; pragmas might be better. An alternative is to use &lt;code&gt;-funbox-strict-fields&lt;/code&gt; to turn on unboxing by default but disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 약간의 망치입니다. 때때로 상황이 악화 될 수 있습니다. &lt;code&gt;UNPACK&lt;/code&gt; pragma 를 사용하여 필드를 선택적으로 개봉 하면 더 나을 수 있습니다. 대안은 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 를 사용하여 기본적으로 unboxing을 설정하지만 &lt;code&gt;NOUNPACK&lt;/code&gt; pragma를 사용하여 특정 생성자 필드에 대해 사용하지 않도록 설정하는 것입니다 ( &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3c07ac232f23724b3889cefd06b22eb4683d2f7a" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. Consider recompiling the objects with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and using the &lt;code&gt;-xp&lt;/code&gt; flag instead. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">이 옵션은 메모리 할당 문제를 해결하기위한 것입니다. GHCi가&amp;ldquo; &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; &amp;rdquo; 와 같은 메시지와 함께 실패하지 않는 한 사용하지 마십시오 . &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; 로 오브젝트를 다시 컴파일하고 대신 &lt;code&gt;-xp&lt;/code&gt; 플래그를 사용하는 것을 고려하십시오 . 이 옵션을 사용하여 GHCi가 컴퓨터에서 작동하도록하려면 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="0ac262cc50deac3cfae652d65a7a869356b40b86" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">이 옵션은 메모리 할당 문제를 해결하기위한 것입니다. &quot; &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; &quot;와 같은 메시지와 함께 GHCi가 실패하지 않으면 사용하지 마십시오 . 이 옵션을 사용하여 컴퓨터에서 GHCi를 작동 시키려면 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="1c1ed9c302993c8a254ff902df0dbce38b594005" translate="yes" xml:space="preserve">
          <source>This option is less of a sledgehammer than &lt;code&gt;-funbox-strict-fields&lt;/code&gt;: it should rarely make things worse. If you use &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; to turn on unboxing by default you can disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 보다 슬레지 해머가 적습니다 . 당신이 사용하는 경우 &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; 기본적으로 개봉기를 켭니다 당신은 사용하여 특정 생성자 필드를 비활성화 할 수 있습니다 &lt;code&gt;NOUNPACK&lt;/code&gt; 의 (참조 프라그를 &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK 프라그를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2fd49d1f76860f1c44d6c219e62e7f40bc9c2382" translate="yes" xml:space="preserve">
          <source>This option is most often used when creating an executable file, to set the filename of the executable. For example:</source>
          <target state="translated">이 옵션은 실행 파일을 만들 때 실행 파일 이름을 설정하기 위해 가장 자주 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ec4e8819778435da9e1806c3a1ad92e747cbb70" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 이제 &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="267371a5e841319f6a790d155fb592c269a41960" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 이제 &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt; 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0235b6cb10974ea14ea0574ec14232194a831212" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wredundant-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 이제 &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wredundant-constraints&lt;/code&gt; &lt;/a&gt; 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d62299c9dde524b1ef3bb3933973aa22ff0ff398" translate="yes" xml:space="preserve">
          <source>This option is off by default.</source>
          <target state="translated">이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4293e9fab7792eac1853c48400535b8a8b77123a" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever an instance declaration is missing one or more methods, and the corresponding class declaration has no default declaration for them.</source>
          <target state="translated">이 옵션은 기본적으로 켜져 있으며 인스턴스 선언에 하나 이상의 메소드가 누락되고 해당 클래스 선언에 기본 선언이없는 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="aeda602ded05cab94ca86a41b88530e26ba7b489" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever the construction of a labelled field constructor isn&amp;rsquo;t complete, missing initialisers for one or more fields. While not an error (the missing fields are initialised with bottoms), it is often an indication of a programmer error.</source>
          <target state="translated">이 옵션은 기본적으로 설정되어 있으며 레이블이 지정된 필드 생성자의 구성이 완료되지 않고 하나 이상의 필드에 대한 초기자가 누락 될 때마다 경고합니다. 오류는 아니지만 누락 된 필드는 맨 아래로 초기화되지만 종종 프로그래머 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa97f50ca584638ac24325128130ef5efe4b2fbf" translate="yes" xml:space="preserve">
          <source>This option is on by default.</source>
          <target state="translated">이 옵션은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2fe70b27b67051a789b82f4eb4f639ee630173" translate="yes" xml:space="preserve">
          <source>This option is on by default. As usual you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 기본적으로 켜져 있습니다. 평소처럼 &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt; &lt;/a&gt; 하여 모듈 단위로 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccde2620c81cc8f927379b68565101df835bced2" translate="yes" xml:space="preserve">
          <source>This option is only useful when running in parallel (&lt;code&gt;-N2&lt;/code&gt; or greater). It allows the processor cores to make better use of the available allocation area, even when cores are allocating at different rates. Without &lt;code&gt;-n&lt;/code&gt;, each core gets a fixed-size allocation area specified by the &lt;code&gt;-A&lt;/code&gt;, and the first core to exhaust its allocation area triggers a GC across all the cores. This can result in a collection happening when the allocation areas of some cores are only partially full, so the purpose of the &lt;code&gt;-n&lt;/code&gt; is to allow cores that are allocating faster to get more of the allocation area. This means less frequent GC, leading a lower GC overhead for the same heap size.</source>
          <target state="translated">이 옵션은 병렬로 실행할 때만 유용합니다 ( &lt;code&gt;-N2&lt;/code&gt; 이상). 코어가 다른 속도로 할당되는 경우에도 프로세서 코어가 사용 가능한 할당 영역을 더 잘 활용할 수 있습니다. &lt;code&gt;-n&lt;/code&gt; 이 없으면 각 코어는 &lt;code&gt;-A&lt;/code&gt; 로 지정된 고정 크기 할당 영역을 가져오고 할당 영역 을 소진하는 첫 번째 코어는 모든 코어에서 GC를 트리거합니다. 이로 인해 일부 코어의 할당 영역이 일부만 가득 찼을 때 수집이 발생할 수 있으므로 &lt;code&gt;-n&lt;/code&gt; 의 목적은 더 빨리 할당되는 코어가 더 많은 할당 영역을 가져 오도록하는 것입니다. 즉, GC 빈도가 낮아서 동일한 힙 크기에 대해 GC 오버 헤드가 낮아집니다.</target>
        </trans-unit>
        <trans-unit id="8d9c254d7b78a3a3ecbc5027783e6457d1d482ef" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt; 으로 CPU에 스레드를 명시 적으로 예약하는 동시 프로그램에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="95f6bdd8b0e33deb9f64ace0ba5f278fa7702c9e" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt; 을 사용하여 스레드를 CPU에 명시 적으로 예약하는 동시 프로그램에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f35434e6bd52920e5c48189b8cfc8e504aad6697" translate="yes" xml:space="preserve">
          <source>This option is there mainly to stop the program eating up all the available memory in the machine if it gets into an infinite loop.</source>
          <target state="translated">이 옵션은 프로그램이 무한 루프에 빠지면 기계에서 사용 가능한 모든 메모리를 차지하지 않도록 주로 중지합니다.</target>
        </trans-unit>
        <trans-unit id="57d29d5e7df4da4169fdb64e362ca3677dd89e06" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be a bit noisy, and it doesn&amp;rsquo;t always indicate a bug in the program. However, it&amp;rsquo;s generally considered good practice to cover all the cases in your functions, and it is switched on by &lt;a href=&quot;#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 약간 시끄럽기 때문에 기본적으로 활성화되어 있지 않으며 프로그램의 버그를 나타내는 것은 아닙니다. 그러나 일반적으로 함수의 모든 경우를 다루는 것이 좋으며 &lt;a href=&quot;#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 에 의해 켜집니다 .</target>
        </trans-unit>
        <trans-unit id="9f98751831a4a39977803e9637f7e77e2e14db0e" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be very noisy, and it often doesn&amp;rsquo;t indicate a bug in the program.</source>
          <target state="translated">이 옵션은 소음이 심할 수 있으며 프로그램의 버그를 나타내지 않기 때문에 기본적으로 활성화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="674da51224e4596bdb3744f26e1f9a1fbcb8b81f" translate="yes" xml:space="preserve">
          <source>This option lists registered packages exposing module ⟨M⟩. Examples:</source>
          <target state="translated">이 옵션은 ⟨M⟩ 모듈을 노출시키는 등록 된 패키지를 나열합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="c794703287cedcb0e1c47b116ac501bee05de960" translate="yes" xml:space="preserve">
          <source>This option may help if the evaluated top-level expressions are consuming large amounts of space, or if you need repeatable performance measurements.</source>
          <target state="translated">이 옵션은 평가 된 최상위식이 많은 양의 공간을 소비하거나 반복 가능한 성능 측정이 필요한 경우에 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ff2c217eff8117af9178fc8b3897c5316f401a" translate="yes" xml:space="preserve">
          <source>This option provides a &amp;ldquo;suggested heap size&amp;rdquo; for the garbage collector. Think of &lt;code&gt;-Hsize&lt;/code&gt; as a variable &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-A ⟨size⟩&lt;/code&gt;&lt;/a&gt; option. It says: I want to use at least ⟨size⟩ bytes, so use whatever is left over to increase the &lt;code&gt;-A&lt;/code&gt; value.</source>
          <target state="translated">이 옵션은 가비지 수집기에 &quot;추천 힙 크기&quot;를 제공합니다. &lt;code&gt;-Hsize&lt;/code&gt; 를 변수 &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-A ⟨size⟩&lt;/code&gt; &lt;/a&gt; 옵션 으로 생각하십시오 . 그것은 말합니다 : 적어도 ⟨size⟩ 바이트를 사용하고 싶습니다. 남은 것을 사용하여 &lt;code&gt;-A&lt;/code&gt; 값 을 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="8853a9d72e715d15e409a53251078ae18153a456" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">이 옵션은 할당 제한과 관련이 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit를&lt;/a&gt; 참조하십시오 . 스레드가 할당 제한에 도달하면 RTS는 스레드에 예외를 throw하고 예외가 다시 발생하기 전에 스레드가 추가 할당량을 얻습니다. 이는 스레드가 예외 처리기를 실행할 수 있도록하는 아이디어입니다. &lt;code&gt;-xq&lt;/code&gt; 은 이 추가 할당량의 크기를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5d0cb54597e16fb360f23cd6c09d2b5b66dd5dd4" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">이 옵션은 할당 제한과 관련이 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit을&lt;/a&gt; 참조하십시오 . 스레드가 할당 제한에 도달하면 RTS는 스레드에 예외를 던지고 스레드는 예외가 다시 발생하기 전에 추가 할당 할당량을 얻습니다. 이는 스레드가 예외 처리기를 실행할 수 있도록하는 것입니다. &lt;code&gt;-xq&lt;/code&gt; 은 이 추가 할당량의 크기를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1ea918ac03fd189d0258f1a47317cf8c206c5d32" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (although they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">이 출력은 현재 세션의 컨텍스트 (예 : &lt;code&gt;Prelude&lt;/code&gt; 범위 )에서 &lt;code&gt;Data.Maybe&lt;/code&gt; 의 첫 번째 항목 그룹이 범위 내에 있지 않음을 보여줍니다 (GHCi 세션에서 정규화 된 형식으로 사용할 수 있음에도 불구하고-What &lt;a href=&quot;#ghci-scope&quot;&gt;'s&lt;/a&gt; 참조). 실제로 프롬프트에서 범위에 있습니까? ), 두 번째 항목 그룹은 범위 ( &lt;code&gt;Prelude&lt;/code&gt; 를 통해 )에 있으므로 제한되지 않거나 &lt;code&gt;Prelude.&lt;/code&gt; 와 함께 사용할 수 있습니다 . 한정자.</target>
        </trans-unit>
        <trans-unit id="363c890a3de72dcec771b7f4c76b67f54a27050f" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (althought they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">(의 범위, 즉 현재 세션의 맥락에서,이 출력 쇼 &lt;code&gt;Prelude&lt;/code&gt; )에서 항목의 첫 번째 그룹 &lt;code&gt;Data.Maybe&lt;/code&gt; 는 그들이 GHCi 세션에서 완전한 형태로 사용할 수 있습니다 althought (범위에없는은 - 참조 &lt;a href=&quot;#ghci-scope&quot;&gt;무엇입니까 실제로 프롬프트 범위?&lt;/a&gt; ), 항목의 두 번째 그룹은 비아 범위 (반면에 &lt;code&gt;Prelude&lt;/code&gt; ) 때문에 가능 하나 비정규 또는 함께있는 &lt;code&gt;Prelude.&lt;/code&gt; 한정자.</target>
        </trans-unit>
        <trans-unit id="d32fd0e1a9f5bf7e2d98a725ace2312b41fff634" translate="yes" xml:space="preserve">
          <source>This package provides both strict and lazy &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; types. The strict type is provided by the &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; module, while the lazy type is provided by the &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; module. Internally, the lazy &lt;code&gt;Text&lt;/code&gt; type consists of a list of strict chunks.</source>
          <target state="translated">이 패키지는 엄격한 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형 과 지연된 텍스트 유형을 모두 제공합니다 . 엄격한 유형은 &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; 모듈에서 제공되는 반면, 지연 유형은 &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; 모듈에서 제공 합니다. 내부적으로 게으른 &lt;code&gt;Text&lt;/code&gt; 유형은 엄격한 청크 목록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5c301e63fdee476a49263ba8163281e72adf6b96" translate="yes" xml:space="preserve">
          <source>This package uses the term &lt;em&gt;character&lt;/em&gt; to denote Unicode &lt;em&gt;code points&lt;/em&gt;.</source>
          <target state="translated">이 패키지는 &lt;em&gt;문자&lt;/em&gt; 라는 용어를 사용하여 유니 &lt;em&gt;코드 코드 포인트&lt;/em&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="aae5addb116c887a46f27acc513b2117c6d86f14" translate="yes" xml:space="preserve">
          <source>This parameter is reserved. You should pass just &lt;em&gt;nullPtr&lt;/em&gt;.</source>
          <target state="translated">이 매개 변수는 예약되어 있습니다. &lt;em&gt;nullPtr&lt;/em&gt; 만 전달 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="15f0fa32e677164a596a3b41ef5acc2c4991ec87" translate="yes" xml:space="preserve">
          <source>This parameter requires to use Windows 7 or later.</source>
          <target state="translated">이 매개 변수는 Windows 7 이상을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b0fc7a248b7324fafef584b213680e79287e0c9" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 파서는 입력이 끝날 때만 성공합니다. 이것은 원시 파서가 아니지만 &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b70e45e4186d009ec916862fca7c137404104fc" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 파서는 입력이 끝날 때만 성공합니다. 이것은 원시 파서가 아니지만 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4dfbf340dce50dc9038b479329f38e8ec299cf61" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 파서는 입력이 끝날 때만 성공합니다. 이것은 원시 파서가 아니지만 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9300de657d2872adc67fa41e5ab353e07ce88a2d" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of identifiers. For example &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">이 파서는 식별자의 유효한 꼬리 문자를 허용해야합니다. 예를 들어 &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8528eebabb9825d0176f24d442e7c8b026df63e" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">이 파서는 연산자의 유효한 꼬리 문자를 허용해야합니다. 언어가 사용자 정의 연산자를 지원하지 않는 경우에도이 구문 분석기를 정의해야 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; 구문 분석기가 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00d8c7a0c04c027e82791e73a94a73041f724be2" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">이 파서는 연산자의 유효한 꼬리 문자를 허용해야합니다. 언어가 사용자 정의 연산자를 지원하지 않는 경우에도이 구문 분석기를 정의해야 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; 구문 분석기가 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d983e2b71ccf1f3a26f0aff85466bf1e651e9beb" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of identifiers. For example &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">이 파서는 식별자의 시작 문자를 받아 들여야합니다. 예를 들어 &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b9eeef0a0daf3a30997aca44251904a3bc4ace8" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of operators. For example &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</source>
          <target state="translated">이 파서는 연산자의 시작 문자를 받아 들여야합니다. 예를 들어 &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9db4088868263aaafdfa869a0f8e2314217323d7" translate="yes" xml:space="preserve">
          <source>This parser succeeds for any character. Returns the parsed character.</source>
          <target state="translated">이 파서는 모든 문자에 성공합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a306a889dc9a52a42b11381f826b2d7630214d4b" translate="yes" xml:space="preserve">
          <source>This pragma is similar to C&amp;rsquo;s &lt;code&gt;#line&lt;/code&gt; pragma, and is mainly for use in automatically generated Haskell code. It lets you specify the line number and filename of the original code; for example</source>
          <target state="translated">이 pragma는 C의 &lt;code&gt;#line&lt;/code&gt; pragma 와 유사하며 주로 자동 생성 된 Haskell 코드에 사용됩니다. 원본 코드의 줄 번호와 파일 이름을 지정할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ca88c24656a8d8661c565a0c56d31be0ec21660f" translate="yes" xml:space="preserve">
          <source>This primitive is only available when the underlying GMP library supports it (GMP &amp;gt;= 5). Otherwise, it internally falls back to &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt;, and a warning will be emitted when used.</source>
          <target state="translated">이 기본 요소는 기본 GMP 라이브러리가이를 지원하는 경우에만 사용할 수 있습니다 (GMP&amp;gt; = 5). 그렇지 않으면 내부적으로 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 로 폴백 되며 사용시 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dceb51efdb1a52e7502aaf8f2f6a2f14168bc8e4" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">이 문제는 GHCi에만 영향을주는 것이 아니라 콘솔 이벤트를 포착하려는 GHC 컴파일 프로그램에 영향을 미칩니다. &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a497560db9bd41df0e1b95425a2c75d218c8ec8" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">이 문제는 GHCi에만 영향을 미치는 것이 아니라 콘솔 이벤트를 포착하려는 GHC 컴파일 프로그램에 영향을줍니다. &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c277562015915ae2718208c757d99e3c4a5c2ea5" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">이것은 각 키에 대해 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="520ac415055f1c0bf4aa6e9c1ae9d27830756102" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">그러면 각 키에 대해 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="d113cd0a06b95adde252febb8a83dc6d268b9573" translate="yes" xml:space="preserve">
          <source>This program will be rejected as ambiguous because GHC will not unify the type variables &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 GHC가 유형 변수 &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;i&lt;/code&gt; 를 통합하지 않기 때문에 모호한 것으로 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="e24c8bfbcd524c9aaee115418d115977f5d18a8a" translate="yes" xml:space="preserve">
          <source>This program will be rejected, because &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; does not scope over the definition of &amp;ldquo;&lt;code&gt;g&lt;/code&gt;&amp;rdquo;, so &amp;ldquo;&lt;code&gt;x::a&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;x::forall a. a&lt;/code&gt;&amp;rdquo; by Haskell&amp;rsquo;s usual implicit quantification rules.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;가&amp;ldquo; &lt;code&gt;g&lt;/code&gt; &amp;rdquo; 의 정의를 다루지 않기 때문에이 프로그램은 거부 될 것이므로&amp;ldquo; &lt;code&gt;x::a&lt;/code&gt; &amp;rdquo;는&amp;ldquo; &lt;code&gt;x::forall a. a&lt;/code&gt; &amp;rdquo;를 의미 합니다. &quot;하스켈의 일반적인 암시 정량화 규칙에 의해.</target>
        </trans-unit>
        <trans-unit id="d583e97443b28f0723fcc05e1353f50d62ca3ee1" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">이 프로그램은 코어 덤프됩니다. 다형성 참조에 대한이 문제는 ML 커뮤니티에서 잘 알려져 있으며 참조를 일반적으로 사용하는 경우에는 발생하지 않습니다. &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하면 불가능한 쉬운 방법이 없습니다 . 실제로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의 도움으로 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; b 를 작성할 수 있습니다. 그러니 조심해!</target>
        </trans-unit>
        <trans-unit id="39080170230fd9e748e118da55a46cb1b209f144" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">이 프로그램은 코어 덤프됩니다. 다형성 참조에 대한이 문제는 ML 커뮤니티에서 잘 알려져 있으며 참조를 일반적으로 사용하는 경우에는 발생하지 않습니다. &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하면 불가능한 쉬운 방법이 없습니다 . 실제로 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의 도움으로 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; b 를 작성할 수 있습니다. 그러니 조심해!</target>
        </trans-unit>
        <trans-unit id="8c3070f1819b5144ee0019a42b9364d5b62ac534" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">이 프로그램은 코어 덤프됩니다. 다형성 참조에 대한이 문제는 ML 커뮤니티에서 잘 알려져 있으며 참조를 일반적으로 사용하는 경우에는 발생하지 않습니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하면 불가능한 쉬운 방법이 없습니다 . 실제로 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의 도움으로 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; b 를 작성할 수 있습니다. 그러니 조심해!</target>
        </trans-unit>
        <trans-unit id="8edf15b81edbb17eae494e16b7d0533a271e50da" translate="yes" xml:space="preserve">
          <source>This provides a type-indexed type representation mechanism, similar to that described by,</source>
          <target state="translated">이것은 타입 인덱스 타입 표현 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="77d3447bc17b046a19fec0f3cc3c7ab330fb5b15" translate="yes" xml:space="preserve">
          <source>This reduces the allocation and trimming overhead, as all generated &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s fit into the first buffer and there is no trimming required, if more than 64 bytes and less than 128 bytes are written.</source>
          <target state="translated">이렇게하면 생성 된 모든 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 첫 번째 버퍼에 맞고 64 바이트 이상 128 바이트 미만이 기록되는 경우 트리밍이 필요하지 않으므로 할당 및 트리밍 오버 헤드가 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="79b2e379cd0f1eaf600da24618a21f3bffdedc96" translate="yes" xml:space="preserve">
          <source>This relative path technique can be used with either of the two &lt;code&gt;-dynload&lt;/code&gt; modes, though it makes most sense with the &lt;code&gt;deploy&lt;/code&gt; mode. The difference is that with the &lt;code&gt;deploy&lt;/code&gt; mode, the above example will end up with an ELF &lt;code&gt;RUNPATH&lt;/code&gt; of just &lt;code&gt;$ORIGIN&lt;/code&gt; while with the &lt;code&gt;sysdep&lt;/code&gt; mode the &lt;code&gt;RUNPATH&lt;/code&gt; will be &lt;code&gt;$ORIGIN&lt;/code&gt; followed by all the library directories of all the packages that the program depends on (e.g. &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages etc.) which are typically absolute paths. The unix tool &lt;code&gt;readelf --dynamic&lt;/code&gt; is handy for inspecting the &lt;code&gt;RPATH&lt;/code&gt;/&lt;code&gt;RUNPATH&lt;/code&gt; entries in ELF shared libraries and executables.</source>
          <target state="translated">이 상대 경로 기술은 두 개의 &lt;code&gt;-dynload&lt;/code&gt; 모드 중 하나와 함께 사용할 수 있지만 &lt;code&gt;deploy&lt;/code&gt; 모드 에서는 가장 적합 합니다. 차이점은 함께한다는 것입니다 &lt;code&gt;deploy&lt;/code&gt; 모드, 위의 예는 ELF와 함께 종료됩니다 &lt;code&gt;RUNPATH&lt;/code&gt; 단지의 &lt;code&gt;$ORIGIN&lt;/code&gt; 동안 함께 &lt;code&gt;sysdep&lt;/code&gt; 의 모드 &lt;code&gt;RUNPATH&lt;/code&gt; 이 될 것입니다 &lt;code&gt;$ORIGIN&lt;/code&gt; 프로그램에 의존하는 모든 패키지의 모든 라이브러리 디렉토리 다음에 ( 예를 들어 &lt;code&gt;base&lt;/code&gt; 및 &lt;code&gt;rts&lt;/code&gt; 패키지 등)은 일반적으로 절대 경로입니다. 유닉스 도구 &lt;code&gt;readelf --dynamic&lt;/code&gt; 검사 용에 편리 &lt;code&gt;RPATH&lt;/code&gt; 를 / &lt;code&gt;RUNPATH&lt;/code&gt; ELF 공유 라이브러리 및 실행 파일의 RUNPATH 항목</target>
        </trans-unit>
        <trans-unit id="370040cae2bc778368a6b92c807c4b5827ecb99e" translate="yes" xml:space="preserve">
          <source>This representation is generated automatically if a &lt;code&gt;deriving Generic&lt;/code&gt; clause is attached to the datatype. &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Standalone deriving&lt;/a&gt; can also be used.</source>
          <target state="translated">&lt;code&gt;deriving Generic&lt;/code&gt; 표현 조항이 데이터 유형에 첨부 되면이 표현이 자동으로 생성됩니다 . &lt;a href=&quot;#stand-alone-deriving&quot;&gt;독립형 파생&lt;/a&gt; 도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30dd0b304103583a22935853ab5fa131cea21cbe" translate="yes" xml:space="preserve">
          <source>This representation is very generic in that no types are given special treatment. However, some functions might need to handle some known types specially, for example the following two functions collect all argument types of (nested) arrow types, and recognize the &lt;code&gt;Int&lt;/code&gt; type, respectively:</source>
          <target state="translated">이 표현은 특별한 처리가 제공되지 않는 점에서 매우 일반적입니다. 그러나 일부 함수는 일부 알려진 유형을 특별히 처리해야 할 수 있습니다. 예를 들어 다음 두 함수는 (중첩 된) 화살표 유형의 모든 인수 유형을 수집하고 각각 &lt;code&gt;Int&lt;/code&gt; 유형을 인식합니다 .</target>
        </trans-unit>
        <trans-unit id="54c505cd157188eeaeea208a88996c170f20c5ef" translate="yes" xml:space="preserve">
          <source>This resembles the wildcards that can be used in &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;. However, there are some differences. No error messages reporting the inferred types are generated, nor does the extension &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; have any effect.</source>
          <target state="translated">이는 &lt;a href=&quot;#partial-type-signatures&quot;&gt;부분 형식 서명에&lt;/a&gt; 사용할 수있는 와일드 카드와 유사합니다 . 그러나 약간의 차이가 있습니다. 유추 된 유형을보고하는 오류 메시지가 생성되지 않으며 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; 확장 도 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05658b8ed19f8a18e37b401843f9f1390a5fc067" translate="yes" xml:space="preserve">
          <source>This results in the variable &lt;code&gt;output&lt;/code&gt; taking on the value below:</source>
          <target state="translated">변수 &lt;code&gt;output&lt;/code&gt; 은 아래 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="faeb3724827d317e7530a6953ccd1a741efde90d" translate="yes" xml:space="preserve">
          <source>This rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">이 규칙은 데이터 유형 선언에도 적용됩니다. 예를 들어 &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; 있고 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;k&lt;/code&gt; 종류가 할당됩니다 . 여기서 &lt;code&gt;k&lt;/code&gt; 는 새로운 종류 변수입니다. &lt;code&gt;k&lt;/code&gt; 는 사용자가 작성하지 않았기 때문에 생성자 &lt;code&gt;Proxy&lt;/code&gt; 유형의 유형 응용 프로그램에는 사용할 수 없습니다 . 단지 &lt;code&gt;a&lt;/code&gt; 는 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ab2f281f7fbf2bff47d327fa4cfe489acb61e45" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;#10132&lt;/a&gt;).</source>
          <target state="translated">이 규칙은 때때로 놀라운 결과를 가져 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;옵니다&lt;/a&gt; ( # 10132 참조 ).</target>
        </trans-unit>
        <trans-unit id="0dae13ecc0c945a796e78580e4456aee9006b862" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;Issue #10132&lt;/a&gt;.</source>
          <target state="translated">이 규칙은 때때로 놀라운 결과를 초래합니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;문제 # 10132&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f8a75e7f4aae139decf4dbddc8f92f07f78b73ed" translate="yes" xml:space="preserve">
          <source>This rule is applied regardless of flags. If you want a more exotic context, you can write it yourself, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">이 규칙은 플래그에 관계없이 적용됩니다. 보다 이국적인 컨텍스트를 원한다면 &lt;a href=&quot;#stand-alone-deriving&quot;&gt;독립형 파생 메커니즘을&lt;/a&gt; 사용하여 직접 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9ad35ca09458fcaf673d419d014807d6053c2a9" translate="yes" xml:space="preserve">
          <source>This rule will cause the compiler to go into an infinite loop.</source>
          <target state="translated">이 규칙은 컴파일러가 무한 루프로 들어가게합니다.</target>
        </trans-unit>
        <trans-unit id="2d325df582f925494ea658de7dc04323c3323bae" translate="yes" xml:space="preserve">
          <source>This rule works for any concrete type constructor, including type constructors with polymorphic kinds. The only restriction is that if the type constructor has a polymorphic kind, then it has to be applied to all of its kinds parameters, and these kinds need to be concrete (i.e., they cannot mention kind variables).</source>
          <target state="translated">이 규칙은 다형성 종류의 유형 생성자를 포함하여 모든 구체적인 유형 생성자에 적용됩니다. 유일하게 제한되는 것은 타입 생성자가 다형성 종류를 가진다면 모든 종류의 매개 변수에 적용되어야하고, 이러한 종류는 구체적이어야합니다 (즉, 종류 변수를 언급 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="012cf785712f9f58baa44a19777eaca31580d1fc" translate="yes" xml:space="preserve">
          <source>This runs the interpreted code in a separate process (see &lt;a href=&quot;#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;) and runs it in profiling mode to collect call stack information. Note that because we&amp;rsquo;re running the interpreted code in profiling mode, all packages that you use must be compiled for profiling. The &lt;code&gt;-prof&lt;/code&gt; flag to GHCi only works in conjunction with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;.</source>
          <target state="translated">해석 된 코드를 별도의 프로세스에서 &lt;a href=&quot;#external-interpreter&quot;&gt;실행하고&lt;/a&gt; (별도의 프로세스 에서 인터프리터 실행 참조 ) 호출 모드 정보를 수집하기 위해 프로파일 링 모드에서 실행합니다. 프로파일 링 모드에서 해석 된 코드를 실행하기 때문에 사용하는 모든 패키지가 프로파일 링을 위해 컴파일되어야합니다. GHCi에 대한 &lt;code&gt;-prof&lt;/code&gt; 플래그는 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 와 함께 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0e7a2ad40c566ce0f6643ee923a3e30a05545bee" translate="yes" xml:space="preserve">
          <source>This says that &lt;code&gt;modify (+1)&lt;/code&gt; acts over any Monad that is a member of the &lt;code&gt;MonadState&lt;/code&gt; class, with an &lt;code&gt;Int&lt;/code&gt; state.</source>
          <target state="translated">이것은 &lt;code&gt;modify (+1)&lt;/code&gt; 이 &lt;code&gt;MonadState&lt;/code&gt; 클래스 의 멤버 인 Monad 에 대해 &lt;code&gt;Int&lt;/code&gt; 와 함께 작동한다는 것을 나타냅니다. 상태 냅니다.</target>
        </trans-unit>
        <trans-unit id="aeefc346ad248407772de61eb44c91ebc62b1dff" translate="yes" xml:space="preserve">
          <source>This section defines the layout of these events. The &lt;code&gt;String&lt;/code&gt; type below is defined to be a UTF-8 encoded NUL-terminated string.</source>
          <target state="translated">이 섹션에서는 이러한 이벤트의 레이아웃을 정의합니다. &lt;code&gt;String&lt;/code&gt; 아래의 형식은 UTF-8 인코딩 NUL 종료 문자열로 정의된다.</target>
        </trans-unit>
        <trans-unit id="426477ffd0f3109ffb983e296577e866ad83653a" translate="yes" xml:space="preserve">
          <source>This section describes &lt;em&gt;data type promotion&lt;/em&gt;, an extension to the kind system that complements kind polymorphism. It is enabled by &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, and described in more detail in the paper &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Giving Haskell a Promotion&lt;/a&gt;, which appeared at TLDI 2012.</source>
          <target state="translated">이 섹션에서는 종류 다형성을 보완하는 종류 시스템의 확장 인 &lt;em&gt;데이터 형식 승격에&lt;/em&gt; 대해 설명 &lt;em&gt;합니다&lt;/em&gt; . 그것은 &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; 에 의해 가능하며 , TLDI 2012에 출연 한 &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Haskell a Promotion&lt;/a&gt; 이라는 논문에 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb974cf5a36706fbeb443061b653e868010df89d" translate="yes" xml:space="preserve">
          <source>This section describes GHC&amp;rsquo;s kind system, as it appears in version 8.0 and beyond. The kind system as described here is always in effect, with or without extensions, although it is a conservative extension beyond standard Haskell. The extensions above simply enable syntax and tweak the inference algorithm to allow users to take advantage of the extra expressiveness of GHC&amp;rsquo;s kind system.</source>
          <target state="translated">이 섹션에서는 버전 8.0 이상에서 나타나는 GHC 종류 시스템에 대해 설명합니다. 여기에 설명 된 종류 시스템은 표준 Haskell을 넘어서는 보수적 인 확장 임에도 불구하고 항상 확장이 있든 없든 적용됩니다. 위의 확장은 구문을 활성화하고 추론 알고리즘을 조정하여 사용자가 GHC 종류 시스템의 추가 표현성을 활용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d4d58a26ba3b02f1db1fe2de0ac14aa3d6a048b5" translate="yes" xml:space="preserve">
          <source>This section describes features specific to GHC's implementation of Concurrent Haskell.</source>
          <target state="translated">이 섹션에서는 GHC의 Concurrent Haskell 구현과 관련된 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bdd49ffb73a3731ac6d967fc14496c16e1567101" translate="yes" xml:space="preserve">
          <source>This section describes how to create DLLs to be called from other languages, such as Visual Basic or C++. This is a special case of &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;; we&amp;rsquo;ll deal with the DLL-specific issues that arise below. Here&amp;rsquo;s an example:</source>
          <target state="translated">이 섹션에서는 Visual Basic 또는 C ++과 같은 다른 언어에서 호출 할 DLL을 만드는 방법에 대해 설명합니다. 이것은 &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;외부 코드에서 호출 할 수있는 Haskell 라이브러리를 만드는&lt;/a&gt; 특별한 경우입니다 . 아래에서 발생하는 DLL 관련 문제를 다룰 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c716f59912a3ade4c8a600a747406892f16105cd" translate="yes" xml:space="preserve">
          <source>This section describes other program(s) which we distribute, that help with the Great Haskell Programming Task.</source>
          <target state="translated">이 섹션에서는 Great Haskell Programming Task에 도움이되는 우리가 배포하는 다른 프로그램에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd9343002ee7f20ea72481ff97c75ea4a9503720" translate="yes" xml:space="preserve">
          <source>This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour.</source>
          <target state="translated">이 섹션에서는 GHC가 찾은 파일, 생성 된 파일, 파일이 저장된 위치 및이 옵션에 어떤 옵션이 영향을 미치는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f1c1c7aa4c4b76ef9244f133c648760bb4ada19e" translate="yes" xml:space="preserve">
          <source>This section documents GHC&amp;rsquo;s take on various issues that are left undefined or implementation specific in Haskell 98.</source>
          <target state="translated">이 절에서는 GHC가 정의하지 않았거나 Haskell 98에 특정 구현 된 다양한 문제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d1b5cee4b5290696273cb8636327d9703229eadc" translate="yes" xml:space="preserve">
          <source>This section documents the encodings of the events emitted to GHC&amp;rsquo;s &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt;. These events can include information about the thread scheduling events, garbage collection statistics, profiling information, user-defined tracing events.</source>
          <target state="translated">이 섹션에서는 GHC의 &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;이벤트 로그로 생성&lt;/a&gt; 된 이벤트의 인코딩을 설명합니다 . 이러한 이벤트에는 스레드 스케줄링 이벤트, 가비지 콜렉션 통계, 프로파일 링 정보, 사용자 정의 추적 이벤트에 대한 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b978b97b7476bee1ad03a8af2ae4346819b8abd7" translate="yes" xml:space="preserve">
          <source>This section is a quick-reference for GHC&amp;rsquo;s command-line flags. For each flag, we also list its mode/dynamic status (see &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;), and the flag&amp;rsquo;s opposite (if available).</source>
          <target state="translated">이 섹션은 GHC의 명령 행 플래그에 대한 빠른 참조입니다. 각 플래그에 대해 모드 / 동적 상태 ( &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;동적 및 모드 옵션&lt;/a&gt; 참조 )와 플래그의 반대 (사용 가능한 경우) 도 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="e5d224e7441e3fb869faddf4a0821bffaff71c9b" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events.</source>
          <target state="translated">이 섹션은 이러한 이벤트를 소비하는 툴링 구현자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2631d568425721367141e5ca16a0dc349ee46597" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events. GHC ships with a C header file (&lt;code&gt;EventlogFormat.h&lt;/code&gt;) which provides symbolic names for the event type IDs described in this file.</source>
          <target state="translated">이 섹션은 이러한 이벤트를 사용하는 도구 구현자를위한 것입니다. GHC 는이 파일에 설명 된 이벤트 유형 ID에 대한 기호 이름을 제공 하는 C 헤더 파일 ( &lt;code&gt;EventlogFormat.h&lt;/code&gt; )과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4793c1dfb931aabba357e67757e80e8fe4a49b96" translate="yes" xml:space="preserve">
          <source>This section lists Glasgow Haskell infelicities in its implementation of Haskell 98 and Haskell 2010. See also the &amp;ldquo;when things go wrong&amp;rdquo; section (&lt;a href=&quot;gone_wrong#wrong&quot;&gt;What to do when something goes wrong&lt;/a&gt;) for information about crashes, space leaks, and other undesirable phenomena.</source>
          <target state="translated">이 섹션에는 Haskell 98 및 Haskell 2010 구현에서 Glasgow Haskell의 부적절 함이 나열되어 있습니다. 충돌, 공간 누출 및 기타 바람직하지 않은 현상에 대한 정보 &lt;a href=&quot;gone_wrong#wrong&quot;&gt;는&lt;/a&gt; &amp;ldquo;일이 잘못 되었을 때 수행 할 작업 &amp;rdquo;섹션 (문제 가 발생했을 때 수행 할 작업 )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d329579f2386fca40f0668d94a24284cae13ec1" translate="yes" xml:space="preserve">
          <source>This section, and the next one, documents GHC&amp;rsquo;s type-class extensions. There&amp;rsquo;s lots of background in the paper &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;Type classes: exploring the design space&lt;/a&gt; (Simon Peyton Jones, Mark Jones, Erik Meijer).</source>
          <target state="translated">이 섹션과 다음 섹션에서는 GHC의 유형 클래스 확장에 대해 설명합니다. 논문 &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;유형 클래스에는 디자인 공간 탐색&lt;/a&gt; (Simon Peyton Jones, Mark Jones, Erik Meijer) 에 대한 배경 지식이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b1a90dce5c453c0f69c1639a0cce7223844a1ff" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">이것은 표준 &lt;code&gt;$&lt;/code&gt; 연산자 의 일반화처럼 보입니다 . 그러나 이것을 실행 가능한 코드로 컴파일하려고하면 문제가 발생합니다. 특히, 우리가 &lt;code&gt;bad&lt;/code&gt; 를 호출 할 때 , 우리는 어떻게 든 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;bad&lt;/code&gt; 에 전달해야합니다 . &lt;code&gt;x&lt;/code&gt; 의 폭 (즉, 몇 비트) 입니까? 포인터입니까? 어떤 종류의 레지스터 (부동 소수점 또는 정수)한다 &lt;code&gt;x&lt;/code&gt; 갈? &lt;code&gt;x&lt;/code&gt; 의 타입, &lt;code&gt;a :: TYPE r1&lt;/code&gt; 때문에 말할 수는 없습니다. 은 다형성 . 따라서 다음과 같은 간단한 규칙을 통해 이러한 구성을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="36e8a4554348a6c067a922b4fe362601f76eb118" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">이것은 표준 &lt;code&gt;$&lt;/code&gt; 연산자 의 일반화처럼 보입니다 . 그러나 이것을 실행 가능한 코드로 컴파일하는 것에 대해 생각하면 문제가 나타납니다. 특히, &lt;code&gt;bad&lt;/code&gt; 를 호출 할 때 어떻게 든 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;bad&lt;/code&gt; 로 전달해야합니다 . &lt;code&gt;x&lt;/code&gt; 는 얼마나 넓습니까 (즉, 몇 비트) ? 포인터입니까? 어떤 종류의 레지스터 (부동 소수점 또는 정수)한다 &lt;code&gt;x&lt;/code&gt; 갈? &lt;code&gt;x&lt;/code&gt; 의 유형 인 &lt;code&gt;a :: TYPE r1&lt;/code&gt; 이 levity 다형성 이기 때문에 모두 말할 수 없습니다 . 따라서 우리는 다음과 같은 간단한 규칙을 통해 이러한 구성을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="c863740ea2de0c5a648f81c5a1a438b882986762" translate="yes" xml:space="preserve">
          <source>This seems the most intuitive and transparent approach towards the developer, who no longer needs to concern himself with the fact that his code might contain overlapping axioms or with the ordering of his instance contexts. But backtracking would apply equally to ordinary instance selection (in the presence of overlapping instances), so it is a much more pervasive change, with substantial consequences for the type inference engine.</source>
          <target state="translated">이것은 개발자에게 가장 직관적이고 투명한 접근 방식으로 보이며 더 이상 코드에 중복되는 공리가 있거나 인스턴스 컨텍스트의 순서와 관련이 있다는 사실에 더 이상 신경 쓸 필요가 없습니다. 그러나 역 추적은 일반적인 인스턴스 선택 (겹치는 인스턴스가있는 경우)에 동일하게 적용되므로 훨씬 유포 된 변경이며 형식 유추 엔진에 상당한 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="91bbd3a27d52a3a851dbfdab4b9ab18c81125223" translate="yes" xml:space="preserve">
          <source>This should call &lt;code&gt;error&lt;/code&gt; but actually prints &lt;code&gt;True&lt;/code&gt;. Reason: GHC eta-expands &lt;code&gt;f&lt;/code&gt; to</source>
          <target state="translated">이것은 &lt;code&gt;error&lt;/code&gt; 를 호출해야 하지만 실제로는 &lt;code&gt;True&lt;/code&gt; 를 인쇄합니다 . 이유 : GHC eta-expands &lt;code&gt;f&lt;/code&gt; to</target>
        </trans-unit>
        <trans-unit id="7ab63a2693cd6c7a45c1f790143037cd6507bc64" translate="yes" xml:space="preserve">
          <source>This should produce a file named &lt;code&gt;fib.dSYM&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fib.dSYM&lt;/code&gt; 이라는 파일이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="739e32040ecc4d2911d13031c9ae018167e3429f" translate="yes" xml:space="preserve">
          <source>This should work, as long as your GHCi was built with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; switch, which is the default. Consult whoever supplied your GHCi installation.</source>
          <target state="translated">이것은 한 당신의 GHCi가로 구축되면서 작동합니다 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 기본입니다 스위치. GHCi 설치를 제공 한 사람에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="58d6ca6d530436d6559c489e7dd370e9564a3d34" translate="yes" xml:space="preserve">
          <source>This simple plugin takes over the execution of Template Haskell code, replacing any expression splice it encounters by &lt;code&gt;0&lt;/code&gt; (at type &lt;code&gt;Int&lt;/code&gt;), and errors out on any other type of splice.</source>
          <target state="translated">이 간단한 플러그인은 Template Haskell 코드의 실행을 인계 받아서 만나는 표현식 스플 라이스를 &lt;code&gt;0&lt;/code&gt; ( &lt;code&gt;Int&lt;/code&gt; 유형에서 )으로 바꾸고 다른 유형의 스플 라이스에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="689b2645ac8c6757ff69fc4ca6accdc5ec8ea0cb" translate="yes" xml:space="preserve">
          <source>This slightly odd-looking rule instructs GHC to replace &lt;code&gt;genericLookup&lt;/code&gt; by &lt;code&gt;intLookup&lt;/code&gt;&lt;em&gt;whenever the types match&lt;/em&gt;. What is more, this rule does not need to be in the same file as &lt;code&gt;genericLookup&lt;/code&gt;, unlike the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragmas which currently do (so that they have an original definition available to specialise).</source>
          <target state="translated">이 약간 이상한 규칙은 GHC가 &lt;em&gt;형식이 일치 할 때마다 &lt;/em&gt; &lt;code&gt;genericLookup&lt;/code&gt; 을 &lt;code&gt;intLookup&lt;/code&gt; 으로 바꾸 도록 지시 합니다. 또한이 규칙은 현재 수행 하는 &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma 와 달리 &lt;code&gt;genericLookup&lt;/code&gt; 과 동일한 파일에있을 필요는 없습니다 (전문화 할 수있는 원래 정의를 갖도록).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="074a31f4d9e16cb86e220f5f40a063ee59b833fe" translate="yes" xml:space="preserve">
          <source>This stack structure means that the order of &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; flags or &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is important. Each substack of the stack must be well formed (packages in databases on top of the stack can refer to packages below, but not vice versa).</source>
          <target state="translated">이 스택 구조는 &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt; 플래그 또는 &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 의 순서&lt;/a&gt; 가 중요 함을 의미합니다. 스택의 각 하위 스택은 올바르게 구성되어야합니다 (스택의 상단에있는 데이터베이스의 패키지는 아래 패키지를 참조 할 수 있지만 그 반대는 아닙니다).</target>
        </trans-unit>
        <trans-unit id="e66c29e8f81778a2aa9684e85767a00ebb262ce6" translate="yes" xml:space="preserve">
          <source>This statement requires that f have the type forall a. [a] -&amp;gt; [a] . You can see an example of its use in the motivating example, as this form is used to apply take 5 .</source>
          <target state="translated">이 문장은 f가 모든 유형을 갖도록 요구한다. [a]-&amp;gt; [a]. 이 양식이 take 5를 적용하는 데 사용되므로 동기 부여 예제에서 그 사용 예제를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61c78a7e665855a92db9c5e9ffaec8226aba79b6" translate="yes" xml:space="preserve">
          <source>This strategy is as follows: GHC keeps a list of directories called the search path. For each of these directories, it tries appending &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; to the directory, and checks whether the file exists. The value of ⟨basename⟩ is the module name with dots replaced by the directory separator (&amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;\\&quot;&lt;/code&gt;, depending on the system), and ⟨extension⟩ is a source extension (&lt;code&gt;hs&lt;/code&gt;, &lt;code&gt;lhs&lt;/code&gt;) if we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, or ⟨hisuf⟩ otherwise.</source>
          <target state="translated">이 전략은 다음과 같습니다. GHC는 검색 경로라는 디렉토리 목록을 유지합니다. 이러한 각 디렉토리 에 대해 디렉토리에 &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; 을 추가하려고 시도 하고 파일이 존재하는지 확인합니다. ⟨basename⟩의 값은 디렉토리 구분 기호 ( 시스템에 따라 &quot; &lt;code&gt;/&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;\\&quot;&lt;/code&gt; ) 로 대체 된 점이있는 모듈 이름 이며, ⟨extension⟩은 소스 확장자 ( &lt;code&gt;hs&lt;/code&gt; , &lt;code&gt;lhs&lt;/code&gt; )입니다. &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모드 또는 GHCi 또는 그렇지 않으면 ⟨hisuf⟩.</target>
        </trans-unit>
        <trans-unit id="11ed97c596e1d0bcc228efb8114c48f030b93b3b" translate="yes" xml:space="preserve">
          <source>This tells you:</source>
          <target state="translated">이것은 당신에게 알려줍니다 :</target>
        </trans-unit>
        <trans-unit id="07d8f00faa3ae75b40703b0528f229ea480038a2" translate="yes" xml:space="preserve">
          <source>This thread has exceeded its allocation limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드는 할당 제한을 초과했습니다. &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c243ec7e03c31ba25363993635c259a833d99359" translate="yes" xml:space="preserve">
          <source>This translates to:</source>
          <target state="translated">이것은 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="e21f274a51f9949f29f1cc84b56dc845f3250ad2" translate="yes" xml:space="preserve">
          <source>This trick isn&amp;rsquo;t foolproof, because there might be other &lt;code&gt;B&lt;/code&gt; closures in the heap which aren&amp;rsquo;t the retainers we are interested in, but we&amp;rsquo;ve found this to be a useful technique in most cases.</source>
          <target state="translated">우리가 관심있는 리테이너가 아닌 힙에 다른 &lt;code&gt;B&lt;/code&gt; 클로저 가있을 수 있기 때문에이 트릭은 절대 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7eedf2bab1365e54cbd4693945639257ad4fb0f2" translate="yes" xml:space="preserve">
          <source>This trivial type constructor serves two purposes:</source>
          <target state="translated">이 간단한 유형 생성자는 두 가지 목적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="628155b5f0687904716807bcd6409248a6482468" translate="yes" xml:space="preserve">
          <source>This two stage process is required because GHC cannot currently profile using both biographical and retainer information simultaneously.</source>
          <target state="translated">GHC는 현재 전기 및 보유자 정보를 동시에 사용하여 프로파일 링 할 수 없으므로이 2 단계 프로세스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="da64adf134879e08323ed89e3b1e4948df137364" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level natural numbers.</source>
          <target state="translated">이 유형은 알려지지 않은 유형 수준의 자연수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63e71d7f0b07e2f8017ecf6cb7990bb372b6c369" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level symbols.</source>
          <target state="translated">이 유형은 알려지지 않은 유형 수준 기호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc9fd430c3e406e9bfda4395aaf8dea448b92e37" translate="yes" xml:space="preserve">
          <source>This type signature contains a kind error which cannot be deferred.</source>
          <target state="translated">이 형식 서명에는 지연 될 수없는 종류 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1458226daed690560f642a2591b54664bcd7099" translate="yes" xml:space="preserve">
          <source>This use of underscore for wildcard in a type pattern is exactly like pattern matching in the term language, but is rather different to the use of a underscore in a partial type signature (see &lt;a href=&quot;#type-wildcards&quot;&gt;Type Wildcards&lt;/a&gt;).</source>
          <target state="translated">유형 패턴에서 와일드 카드에 밑줄을 사용하는 것은 언어라는 용어에서 패턴 일치와 정확히 동일하지만 부분 유형 서명에 밑줄을 사용하는 것과는 다릅니다 ( &lt;a href=&quot;#type-wildcards&quot;&gt;유형 와일드 카드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="843b161d44b1dbfe532489a8737416458e734625" translate="yes" xml:space="preserve">
          <source>This uses the above tree rendering function, and displays the Html as a tree structure, allowing debugging of what is actually getting produced.</source>
          <target state="translated">위의 트리 렌더링 기능을 사용하고 Html을 트리 구조로 표시하여 실제로 생성되는 것을 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="115cfdee365c54682223fbca3e4f895eb1f6e102" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">이 하스켈의 사실 사용 &lt;code&gt;let&lt;/code&gt; 소개하고이 바인딩을 재귀. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 를 사용하여이 정의를 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1be3ce1530bcdc820d6c90501be79827a35abad" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">이 하스켈의 사실 사용 &lt;code&gt;let&lt;/code&gt; 소개하고이 바인딩을 재귀. &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 를 사용하여이 정의를 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f88835ef04d1f3754243e8cd078d29d91f94c0a" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">이것은 일반적으로 문제가되지 않으며, GHC 런타임 시스템이 OS 스레드 리소스를 효율적으로 사용할 수 있도록합니다. 그러나 스레드 로컬 상태를 사용하는 외래 코드를 호출 할 때 사용되는 OS 스레드를보다 잘 제어하는 ​​것이 유용한 경우가 있습니다. 이와 같은 경우 에는 특정 OS 스레드에 묶인 Haskell 스레드 인 &lt;em&gt;바운드 스레드를&lt;/em&gt; 제공 합니다. 바운드 스레드에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1160e9ee24dc05017fdb7f0fab69b46a37237f1" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">이것은 일반적으로 문제가되지 않으며 GHC 런타임 시스템이 OS 스레드 리소스를 효율적으로 사용할 수 있도록합니다. 그러나 스레드 로컬 상태를 사용하는 외래 코드를 호출 할 때와 같이 사용되는 OS 스레드를 더 많이 제어하는 ​​것이 유용한 경우가 있습니다. 이와 같은 경우 에는 특정 OS 스레드에 연결된 Haskell 스레드 인 &lt;em&gt;바운드 스레드를&lt;/em&gt; 제공 합니다. 바인딩 된 스레드에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 모듈에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6fe6c899f31bf735023aed7edade5c845bb20c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 변형은 완성 된 포인터 외에 환경을 기대하는 종료자를 추가합니다. finalizer에 전달 될 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="73272fcd0ad868eb9d7204167149b902a10e97d9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 변형은 완성 된 포인터 외에 환경을 기대하는 종료자를 추가합니다. finalizer에 전달 될 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9448bed87d0380afdfc5a0e85ab115284bc4a12f" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; appears at the type level.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 변종은 유형 레벨에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d456ce198372e2f1c13a10638b827f2a19ffc595" translate="yes" xml:space="preserve">
          <source>This version builds its output lazily; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt;.</source>
          <target state="translated">이 버전은 출력을 느리게 빌드합니다. 거의 동일한 인터페이스를 가진 고정 공간 버전은 &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bbca1b395d2fc0bccc520c78f768d92dd9c439e" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly and uses continuation-passing-style to achieve constant space usage. This transformer can be used as a drop-in replacement for &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt;.</source>
          <target state="translated">이 버전은 출력을 엄격하게 빌드하고 연속 전달 스타일을 사용하여 일정한 공간 사용을 달성합니다. 이 변압기는 &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt; 의 드롭 인 대체품으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="930ffaae31f052ddd842b0cc0750e75bde4d30d4" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt; instead.</source>
          <target state="translated">이 버전은 출력을 엄격하게 빌드합니다. 동일한 인터페이스의 게으른 버전은 &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy를&lt;/a&gt; 참조하십시오 . 출력이 엄격하게 구축되었지만이 변환기를 사용하여 일정한 공간 동작을 수행 할 수는 없습니다 . 대신 &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c43334581b0313064f9793791ae64d3cd9cb11bb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5b59dda432be30bd0d16af2bacfdfe2d0f94c9cd" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f67494c6dd16fe58429c914e2600fd861b46bc50" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="67c8e6fa4d8cd33fa64562f0db26d801a347a4eb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c4d88c16a70afcd9d0a8c3fb7463a254c46bdefe" translate="yes" xml:space="preserve">
          <source>This version requires going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, which can be inefficient. However, &lt;code&gt;toIntegralSized&lt;/code&gt; is optimized to allow GHC to statically determine the relative type sizes (as measured by &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt;) and avoid going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for many types. (The implementation uses &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is itself optimized with rules for &lt;code&gt;base&lt;/code&gt; types but may go through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for some type pairs.)</source>
          <target state="translated">이 버전은 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 거쳐야 하는데 비효율적 일 수 있습니다. 그러나 &lt;code&gt;toIntegralSized&lt;/code&gt; 는 GHC가 상대 크기를 정적으로 결정하고 ( &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt; 에 의해 측정 된 ) 여러 유형에 대해 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 거치지 않도록 최적화 되었습니다. (이 구현은 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용 하는데 , 이는 &lt;code&gt;base&lt;/code&gt; 유형에 대한 규칙으로 자체적으로 최적화 되지만 일부 유형 쌍에 대해서는 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 거칠 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="1713051baed32864f550a4d0ea48ed3f725fb1d1" translate="yes" xml:space="preserve">
          <source>This warning allows to detect such uses of &lt;code&gt;*&lt;/code&gt; before the actual breaking change takes place. The recommended fix is to replace &lt;code&gt;*&lt;/code&gt; with &lt;code&gt;Type&lt;/code&gt; imported from &lt;code&gt;Data.Kind&lt;/code&gt;.</source>
          <target state="translated">이 경고를 통해 실제 파손 변경이 발생하기 전에 이러한 &lt;code&gt;*&lt;/code&gt; 사용을 감지 할 수 있습니다 . 권장되는 수정 프로그램을 대체하는 것입니다 &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;Type&lt;/code&gt; 에서 수입 &lt;code&gt;Data.Kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8dcf8302d1086b7ab10e1c70ed396a42e5a77b9" translate="yes" xml:space="preserve">
          <source>This warning can be addressed by either adding an explicit import list or using a &lt;code&gt;qualified&lt;/code&gt; import.</source>
          <target state="translated">이 경고는 명시 적 가져 오기 목록을 추가하거나 &lt;code&gt;qualified&lt;/code&gt; 가져 오기를 사용하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78b29ba7cfb3d2918f39c1441e99d9f4ce1287c2" translate="yes" xml:space="preserve">
          <source>This warning can be turned off with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wno-missing-methods&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 경고는 &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wno-missing-methods&lt;/code&gt; &lt;/a&gt; 플래그로 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f18c523e2627209783834547bda765478c64d4a5" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; mode.</source>
          <target state="translated">이 경고는 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; 모드 에서 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="72dcfecc8d5494d290ee1b21677961cb5175c2ed" translate="yes" xml:space="preserve">
          <source>This warning is off by default.</source>
          <target state="translated">이 경고는 기본적으로 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e25d5e92b85c829fac2f9477e4538faeeb61aa6" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">이 경고는 기본적으로 꺼져 있습니다. 그러나 &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="6ab34268e22349a8e7d47871cb222ede5f058bf5" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">이 경고는 기본적으로 꺼져 있습니다. 그러나 &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="90f45b839bbf6248dce6eb6cd816c8aef78b200f" translate="yes" xml:space="preserve">
          <source>This warning is on by default.</source>
          <target state="translated">이 경고는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a4aecbf183fdb5c42584066dc8c58f74eb0df7" translate="yes" xml:space="preserve">
          <source>This warning message:</source>
          <target state="translated">이 경고 메시지 :</target>
        </trans-unit>
        <trans-unit id="f2d8282f3131ab448c2e8fe1cea01afde1138b09" translate="yes" xml:space="preserve">
          <source>This will be translated to:</source>
          <target state="translated">이것은 다음과 같이 번역됩니다 :</target>
        </trans-unit>
        <trans-unit id="67139a4dd79ac7320ecf17b1941945dc01b22766" translate="yes" xml:space="preserve">
          <source>This will generate a derived instance for &lt;code&gt;(Foo [a])&lt;/code&gt; and &lt;code&gt;(Foo (Maybe a))&lt;/code&gt;, but other types such as &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; will not be an instance of &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;(Foo [a])&lt;/code&gt; 및 &lt;code&gt;(Foo (Maybe a))&lt;/code&gt; 에 대한 파생 인스턴스를 생성 하지만 &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; 과 같은 다른 유형 은 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="a8f28dc06b16f7d92df21079a2ca982f57eeedb1" translate="yes" xml:space="preserve">
          <source>This will generate code to the effect of:</source>
          <target state="translated">이렇게하면 다음과 같은 효과가있는 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c07dbdd03a5f971eb5b11d111347c944fa4be0b3" translate="yes" xml:space="preserve">
          <source>This will generate the derived instance:</source>
          <target state="translated">그러면 파생 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd17e4450ac723145ea38f572707911ae4592ad5" translate="yes" xml:space="preserve">
          <source>This will not actually evaluate &lt;code&gt;[|1|]&lt;/code&gt;, but instead replace it with the &lt;code&gt;0 :: Int&lt;/code&gt; literal.</source>
          <target state="translated">이것은 실제로 &lt;code&gt;[|1|]&lt;/code&gt; 평가하지 않고 대신 &lt;code&gt;0 :: Int&lt;/code&gt; 리터럴로 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="2f9635805f734d6a6ddee1819b851b9ba1e60653" translate="yes" xml:space="preserve">
          <source>This will sometimes exit with &quot;interrupted&quot; and code 0, because the main thread is given a chance to shut down when the child thread calls safeExit. There is a race to shut down between the main and child threads.</source>
          <target state="translated">하위 스레드가 safeExit를 호출 할 때 기본 스레드가 종료 될 수 있기 때문에 때때로 &quot;중단됨&quot;및 코드 0으로 종료됩니다. 메인 스레드와 자식 스레드 사이를 종료하는 경쟁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e043ff52775ea24499678e808e45c2c181b6a4d7" translate="yes" xml:space="preserve">
          <source>This will take &lt;code&gt;1 + 1 + 3&lt;/code&gt; words (the &lt;code&gt;ThingId&lt;/code&gt; constructor + unpacked &lt;code&gt;Int&lt;/code&gt; + unpacked &lt;code&gt;ShortByteString&lt;/code&gt;), plus the words for the string data.</source>
          <target state="translated">이 소요됩니다 &lt;code&gt;1 + 1 + 3&lt;/code&gt; 단어합니다 ( &lt;code&gt;ThingId&lt;/code&gt; 생성자 + 압축을 푼 &lt;code&gt;Int&lt;/code&gt; + 압축을 푼 &lt;code&gt;ShortByteString&lt;/code&gt; 문자열 데이터), 플러스 말을.</target>
        </trans-unit>
        <trans-unit id="ffb0c676449de8bbdd669f772c381c5dd02a2d1b" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00447b8aa68db10f55c7e645117a8e9f6fffe839" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53fc96ce3bb24d77dd77c6af32ec3bc111b921f5" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf6f8f26d3df6178377eb2f4bcb17017279b918" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fa41044d20ae1ba84ba01e6410c48a361f0588d" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a6c139763138b599cb7bbf37ebd6c6563d7c63" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434dd08be079cc0bd5826173db52237398cf0bd7" translate="yes" xml:space="preserve">
          <source>This will yield a list containing every prefix of the word &amp;ldquo;hello&amp;rdquo; written out 5 times:</source>
          <target state="translated">이렇게하면 &quot;hello&quot;라는 단어의 모든 접두어가 5 번 쓰여진 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5b7edf0cfa8817128eb97357c0b339d3968afe03" translate="yes" xml:space="preserve">
          <source>This works even if the type of the expression is more general, provided it can be &lt;em&gt;instantiated&lt;/em&gt; to &lt;code&gt;IO a&lt;/code&gt;. For example</source>
          <target state="translated">이 식의 유형이 될 수있다 제공,보다 일반적인 경우에도 작동 &lt;em&gt;인스턴스화&lt;/em&gt; 에 &lt;code&gt;IO a&lt;/code&gt; . 예를 들어</target>
        </trans-unit>
        <trans-unit id="8a8c5448116287ce4d1ddb842a2e4bddd7bd26ff" translate="yes" xml:space="preserve">
          <source>This would generate the following instances:</source>
          <target state="translated">다음과 같은 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8b2e3b821f17047f04dce70c983fcb5b75e25f" translate="yes" xml:space="preserve">
          <source>Thread stacks (including the main thread&amp;rsquo;s stack) live on the heap. As the stack grows, new stack chunks are added as required; if the stack shrinks again, these extra stack chunks are reclaimed by the garbage collector. The default initial stack size is deliberately small, in order to keep the time and space overhead for thread creation to a minimum, and to make it practical to spawn threads for even tiny pieces of work.</source>
          <target state="translated">스레드 스택 (기본 스레드 스택 포함)은 힙에 존재합니다. 스택이 커짐에 따라 필요에 따라 새 스택 청크가 추가됩니다. 스택이 다시 축소되면 가비지 수집기에서 이러한 추가 스택 청크를 회수합니다. 기본 초기 스택 크기는 스레드 작성에 필요한 시간과 공간 오버 헤드를 최소화하고 작은 작업에도 스레드를 생성하는 것이 실용적 이도록 의도적으로 작습니다.</target>
        </trans-unit>
        <trans-unit id="afb01736a569cf800957c75c764e7b08e4d42882" translate="yes" xml:space="preserve">
          <source>ThreadDied</source>
          <target state="translated">ThreadDied</target>
        </trans-unit>
        <trans-unit id="b5249abe5125d8129b1f6094e27ca24e5dfd7b53" translate="yes" xml:space="preserve">
          <source>ThreadFinished</source>
          <target state="translated">ThreadFinished</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="cbacd9f0811868fee2692211c0f50253994d843c" translate="yes" xml:space="preserve">
          <source>ThreadId#</source>
          <target state="translated">ThreadId#</target>
        </trans-unit>
        <trans-unit id="210277f1f5be789fa38d99bf66d700f891a72b7b" translate="yes" xml:space="preserve">
          <source>ThreadKilled</source>
          <target state="translated">ThreadKilled</target>
        </trans-unit>
        <trans-unit id="1aacc5025242586267973269d42242e70a03c918" translate="yes" xml:space="preserve">
          <source>ThreadRunning</source>
          <target state="translated">ThreadRunning</target>
        </trans-unit>
        <trans-unit id="03539ff112c319a9993d65dc00b7fc1e80ba7832" translate="yes" xml:space="preserve">
          <source>ThreadStatus</source>
          <target state="translated">ThreadStatus</target>
        </trans-unit>
        <trans-unit id="c415b82d91d35c84fcc4655fc993abc0a3ab34c8" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 비동기 예외를 수신하기 전에 분기 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 작성하려면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca92e3299d152bebbdb5564f0db2b030aafcd93c" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 이것은 비동기 예외가 수신되기 전에 분기 된 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 생성하려면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a5f845685a6adcb61487ea721a7c03d396057a" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 비동기 예외를 수신하기 전에 분기 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 작성하려면 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="02ddbb9a27e7d4b8d61317f07ad835b30faeee84" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 비동기 예외를 수신하기 전에 분기 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 작성하려면 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="581562d7fdd77f3436334b5a7259e674b4960049" translate="yes" xml:space="preserve">
          <source>Threads with affinity</source>
          <target state="translated">선호도가있는 스레드</target>
        </trans-unit>
        <trans-unit id="1831f9d9a0a484604033e790590c1ca2132ad8fe" translate="yes" xml:space="preserve">
          <source>Three handles are allocated during program initialisation, and are initially open.</source>
          <target state="translated">프로그램 초기화 중에 세 개의 핸들이 할당되며 처음에는 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cfb69dc1eee67ef7ef938e002c1dcccfc372df6" translate="yes" xml:space="preserve">
          <source>Three kinds of buffering are supported: line-buffering, block-buffering or no-buffering. These modes have the following effects. For output, items are written out, or &lt;em&gt;flushed&lt;/em&gt;, from the internal buffer according to the buffer mode:</source>
          <target state="translated">라인 버퍼링, 블록 버퍼링 또는 버퍼링 없음의 세 가지 버퍼링이 지원됩니다. 이 모드는 다음과 같은 효과가 있습니다. 출력 을 위해 버퍼 모드에 따라 내부 버퍼에서 항목을 쓰거나 &lt;em&gt;플러시&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="67de4025637fbb0de0ee6f5d57e06c1db2d37ad2" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if decoding fails.</source>
          <target state="translated">드로 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; 를 복호가 실패하면.</target>
        </trans-unit>
        <trans-unit id="530bb7b54f06bf2237068556f8b41935da4566c0" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if encoding fails.</source>
          <target state="translated">드로 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; 를 부호화가 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="a88939f2bc16a79d5911956081588d78806af274" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치가 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 리턴 하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="c86385b37440a2c4d1929356fdf6fd642b72d158" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5653f6b091b3b56dbab455fefe64b2589e61e727" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, but retry in case of an interrupted operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치가 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 리턴 하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 처리하고 조작이 중단 된 경우 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="34d7cc6341315d979ebf0a280e2812fcea684005" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치가 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 리턴 하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="79cea3439c030b18b5417d5220cf8e7402498869" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;, but retries in case of an interrupted operation.</source>
          <target state="translated">던져 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 현재의 값에 대응 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 된 액션의 결과를 반환 &lt;code&gt;-1&lt;/code&gt; 있지만 재시 인터럽트 동작시.</target>
        </trans-unit>
        <trans-unit id="4caf9e3403704122998dcd2e56f9c103bccc209c" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 액션이 &lt;code&gt;-1&lt;/code&gt; 의 결과를 반환 하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="036abf121e52aab2f60490c26b79ff2ead7c1e41" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the result value of the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action meets the given predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치 의 결과 값이 주어진 술어를 충족하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="64aa8ce5d4c7d3f7f49e076896c60b8c7ef43c89" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="6a07ee5048c29ff28ddf4e5f424d1fa111508ece" translate="yes" xml:space="preserve">
          <source>Throw an error when an illegal sequence is encountered</source>
          <target state="translated">잘못된 시퀀스가 ​​발생하면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="4479756108b443a98b7354d085dbc835dc21aeb8" translate="yes" xml:space="preserve">
          <source>Throw an exception. Exceptions may be thrown from purely functional code, but may only be caught within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">예외를 던지십시오. 순전히 기능적인 코드에서 예외가 발생할 수 있지만 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe9dd6f4bbcbd9abdc92b3911d6713b369a19e14" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; 에서 예외를 발생 시키면 트랜잭션이 중단되고 예외가 전파됩니다. &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 를 통해 예외가 발견 되면 catch로 묶인 변경 사항 만 롤백됩니다. &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 외부에서 변경 한 내용은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2e15244ee40229604b0e667942ba71e6efbddfe9" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; 에서 예외를 발생 시키면 트랜잭션이 중단되고 예외가 전파됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 를 통해 예외가 발견 되면 catch로 묶인 변경 사항 만 롤백됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 외부에서 변경 한 내용은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="62d516dc1db40b86d1546ce065ac2b133fff005a" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; 에서 예외를 발생 시키면 트랜잭션이 중단되고 예외가 전파됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 를 통해 예외가 발견 되면 catch로 묶인 변경 사항 만 롤백됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 외부에서 변경 한 내용은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3c57924c9d0ac14d868ac4b1686bc50ff51630e3" translate="yes" xml:space="preserve">
          <source>Throwing and catching I/O errors</source>
          <target state="translated">I / O 오류 발생 및 포착</target>
        </trans-unit>
        <trans-unit id="7506d1dc91f2739ca014aacfd180c12f7a3cf7ce" translate="yes" xml:space="preserve">
          <source>Throwing exceptions</source>
          <target state="translated">예외 던지기</target>
        </trans-unit>
        <trans-unit id="7f06faf78ca599a5c5c8ba7a35902fe72d473ba2" translate="yes" xml:space="preserve">
          <source>Thrown when the program attempts to call &lt;code&gt;atomically&lt;/code&gt;, from the &lt;code&gt;stm&lt;/code&gt; package, inside another call to &lt;code&gt;atomically&lt;/code&gt;.</source>
          <target state="translated">프로그램 이 &lt;code&gt;stm&lt;/code&gt; 패키지에서 &lt;code&gt;atomically&lt;/code&gt; 다른 호출 내부 에서 &lt;code&gt;atomically&lt;/code&gt; 호출하려고 할 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="153488b4e16cb9e06414f6864aee37a111104fae" translate="yes" xml:space="preserve">
          <source>Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not.</source>
          <target state="translated">런타임 시스템에서 계산이 종료되지 않는다는 것을 감지하면 발생합니다. 런타임 시스템이 주어진 계산이 종료되는지 여부를 알 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e18cad06fc314dbe98850c48826dae1e000f1a31" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;ctermid(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="63e549a9e7a930bc1cd82834decb9a2bd163ce62" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fdatasync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="b4fc88eb1e2da00b43f2c50a60cc44995e0823b9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fsync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="a9d629909206eee0dbcf9f3ef3c94be04cfef1d6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ( &quot;지원되지 않는 작업&quot;) 플랫폼이 제공하지 않는 경우 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e500df7fdd7f0b1291a3902735fde41700da58" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;tcdrain(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="9e328518c0ae7f5df305277a12db24a54f0d6efe" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;ctermid(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="c41ac56fe434c624b1c17bcefea186ed1bdc1b6f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fdatasync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="c4e26076fb50ee8c52870cfd73b0440602f666fd" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fsync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="12e34fcbe929eb8dbb817a0cb66109a820af381c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ( &quot;지원되지 않는 작업&quot;) 플랫폼이 제공하지 않는 경우 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec30f6587d00e8236ddbc556fd0ce8c29324a9f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;tcdrain(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="da37849b4252a8c8814bc0fdc57bbfa1e662b4c6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; when the channel is empty and no other thread holds a reference to the channel.</source>
          <target state="translated">채널이 비어 있고 다른 스레드가 채널에 대한 참조를 보유하지 않으면 &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 를 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="26e7a0586580fb90b1858fbd0f15fd38c47f7010" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is the empty string or contains an equals sign.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; 이는 경우 &lt;code&gt;name&lt;/code&gt; 빈 문자열 또는 등호 기호가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="88ad0dcfc452814fa2ec2a379a00e78d0cb0ada8" translate="yes" xml:space="preserve">
          <source>Throws a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; if the terminfo database could not be read.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; 을 terminfo 데이터베이스를 읽을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="76031ddf92450ba52c1e3945097079807a9065c2" translate="yes" xml:space="preserve">
          <source>Thursday</source>
          <target state="translated">Thursday</target>
        </trans-unit>
        <trans-unit id="cef8354a2187206dae84b0978cfa2cac783fc184" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f4111a9574afc73ad4fb9aa2d80eb12106046f" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20ffe6f7fbe373d959e03833b11abe8e7b589cd" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c7038c652bd8ef014d4a0872642e6726ba19bc5" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e24cd4910ef566d3177761fb96a3a2e10793cb" translate="yes" xml:space="preserve">
          <source>Thus rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">따라서 규칙은 데이터 유형 선언에도 적용됩니다. 예를 들어, &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; 있고 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;a&lt;/code&gt; 에 kind &lt;code&gt;k&lt;/code&gt; 가 할당됩니다 . 여기서 &lt;code&gt;k&lt;/code&gt; 는 새로운 종류 변수입니다. &lt;code&gt;k&lt;/code&gt; 는 사용자가 작성하지 않았기 때문에 생성자 &lt;code&gt;Proxy&lt;/code&gt; 의 유형에서 유형 애플리케이션에 사용할 수 없습니다 . 단지 &lt;code&gt;a&lt;/code&gt; 는 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1b4b67a9b45e5176c700a1accff9ef1d36429d" translate="yes" xml:space="preserve">
          <source>Thus, a common invocation would be:</source>
          <target state="translated">따라서 일반적인 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10617fc5bcf1b09fbc9f71f965511f582f11805a" translate="yes" xml:space="preserve">
          <source>Thus, if we call &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; we will get a formatted call-stack alongside our string.</source>
          <target state="translated">따라서 &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; 을 호출하면 문자열과 함께 형식이 지정된 콜 스택이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e5c7ac32fac38f64112fb32061b44ba48e48877f" translate="yes" xml:space="preserve">
          <source>Thus, the chief benefit of kind polymorphism is that we can now infer these most general kinds and use &lt;code&gt;App&lt;/code&gt; at a variety of kinds:</source>
          <target state="translated">따라서 종류 다형성의 주요 이점은 이제 가장 일반적인 종류를 추론 하고 다양한 종류의 &lt;code&gt;App&lt;/code&gt; 을 사용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="78f6be9afb4189596518c56574c13c30720db0d1" translate="yes" xml:space="preserve">
          <source>Thus, the instance triggers only when the implicit parameter to &lt;code&gt;UnEx&lt;/code&gt; matches the implicit parameter to &lt;code&gt;MkEx&lt;/code&gt;. Because &lt;code&gt;k&lt;/code&gt; is actually a parameter to &lt;code&gt;UnEx&lt;/code&gt;, the kind is not escaping the existential, and the above code is valid.</source>
          <target state="translated">따라서 &lt;code&gt;UnEx&lt;/code&gt; 에 대한 암시 적 매개 변수가 &lt;code&gt;MkEx&lt;/code&gt; 에 대한 암시 적 매개 변수와 일치하는 경우에만 인스턴스가 트리거됩니다 . &lt;code&gt;k&lt;/code&gt; 는 실제로 &lt;code&gt;UnEx&lt;/code&gt; 의 매개 변수 이기 때문에 종류가 실존 을 벗어나지 않으며 위의 코드가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="96728018a51a18d78a6c7c7a21bb29d195c725bd" translate="yes" xml:space="preserve">
          <source>TickyFlags</source>
          <target state="translated">TickyFlags</target>
        </trans-unit>
        <trans-unit id="e426b9f760c1a38c2bacbad2f64c53212cc3ffbf" translate="yes" xml:space="preserve">
          <source>Time as measured by the Earth.</source>
          <target state="translated">지구가 측정 한 시간.</target>
        </trans-unit>
        <trans-unit id="de35e180cbf98fcc51757a7d0eeb7aa8703d0daf" translate="yes" xml:space="preserve">
          <source>Time locale.</source>
          <target state="translated">시간 로캘.</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">시간</target>
        </trans-unit>
        <trans-unit id="311ad74f1246fe76fb5e13a02593b243dfa01e4b" translate="yes" xml:space="preserve">
          <source>Time of day as represented in hour, minute and second (with picoseconds), typically used to express local time of day.</source>
          <target state="translated">시간, 분 및 초로 표시되는 시간 (피코 초 포함)으로, 일반적으로 현지 시간을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="674eca31894fe11111cc9e95a912f546b20cfa4c" translate="yes" xml:space="preserve">
          <source>Time of last access in sub-second resolution.</source>
          <target state="translated">1 초 미만의 최종 액세스 시간.</target>
        </trans-unit>
        <trans-unit id="bf5b7ea4cfe40f929342452c57b6445e307ff98f" translate="yes" xml:space="preserve">
          <source>Time of last access.</source>
          <target state="translated">마지막 액세스 시간.</target>
        </trans-unit>
        <trans-unit id="dd0e25f4fa1eea55d5c7dc261f690719e80e92b5" translate="yes" xml:space="preserve">
          <source>Time of last modification in sub-second resolution.</source>
          <target state="translated">1 초 미만의 해상도에서 마지막 수정 시간.</target>
        </trans-unit>
        <trans-unit id="d3ed1832d868c8126249a2fb407fc69507dfb189" translate="yes" xml:space="preserve">
          <source>Time of last modification.</source>
          <target state="translated">마지막 수정 시간.</target>
        </trans-unit>
        <trans-unit id="8a1b24f9546d48f74a1fc1f2be79cc16e32ce4b8" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.) in sub-second resolution.</source>
          <target state="translated">1 초 미만의 해상도에서 마지막 상태 변경 시간 (예 : 소유자, 그룹, 링크 수, 모드 등)</target>
        </trans-unit>
        <trans-unit id="de40af977c44da7ce142082cfbcc26c6ffe0cb65" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.).</source>
          <target state="translated">마지막 상태 변경 시간 (예 : 소유자, 그룹, 링크 수, 모드 등)</target>
        </trans-unit>
        <trans-unit id="37cc2e4553f3b7c4572077f6ce8dcd7260d2fd48" translate="yes" xml:space="preserve">
          <source>Time values from the RTS, using a fixed resolution of nanoseconds.</source>
          <target state="translated">고정 된 나노초 분해능을 사용하는 RTS의 시간 값.</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">시간대</target>
        </trans-unit>
        <trans-unit id="3694fd8d8502573c050c12c21dfc64202808f47a" translate="yes" xml:space="preserve">
          <source>TimeExpired</source>
          <target state="translated">TimeExpired</target>
        </trans-unit>
        <trans-unit id="54ca8d2ae2173c38ac3276efe44835c04bf7b464" translate="yes" xml:space="preserve">
          <source>TimeLocale</source>
          <target state="translated">TimeLocale</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="a4208dd784207f8d84ef4fa31bd30bdd2b432c1d" translate="yes" xml:space="preserve">
          <source>TimeZone</source>
          <target state="translated">TimeZone</target>
        </trans-unit>
        <trans-unit id="30a4ddc2d1e47c72524d2ae1195d49334429ec48" translate="yes" xml:space="preserve">
          <source>TimeoutCallback</source>
          <target state="translated">TimeoutCallback</target>
        </trans-unit>
        <trans-unit id="03a9149686779469a820b3f21f5f3096edd2e773" translate="yes" xml:space="preserve">
          <source>TimeoutKey</source>
          <target state="translated">TimeoutKey</target>
        </trans-unit>
        <trans-unit id="554c6dbe0800fb90ce862ee9b17611f1be40e742" translate="yes" xml:space="preserve">
          <source>TimerManager</source>
          <target state="translated">TimerManager</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e0f0bc7f2e5196ca0e12562d2fea3c45abb35a55" translate="yes" xml:space="preserve">
          <source>TitlecaseLetter</source>
          <target state="translated">TitlecaseLetter</target>
        </trans-unit>
        <trans-unit id="2234a4a2c47c8ff0b64637496c3e6c3bfefcacba" translate="yes" xml:space="preserve">
          <source>Tix</source>
          <target state="translated">Tix</target>
        </trans-unit>
        <trans-unit id="a74eb4584cb5c18ee809ed00eb188fdec5bb579c" translate="yes" xml:space="preserve">
          <source>TixModule</source>
          <target state="translated">TixModule</target>
        </trans-unit>
        <trans-unit id="fe0563e640d1279bce1fac48bf8a1b5e02bcb7ab" translate="yes" xml:space="preserve">
          <source>To a foreign library, the bound thread will look exactly like an ordinary operating system thread created using OS functions like &lt;code&gt;pthread_create&lt;/code&gt; or &lt;code&gt;CreateThread&lt;/code&gt;.</source>
          <target state="translated">외부 라이브러리의 경우 바운드 스레드는 &lt;code&gt;pthread_create&lt;/code&gt; 또는 &lt;code&gt;CreateThread&lt;/code&gt; 와 같은 OS 함수를 사용하여 작성된 일반 운영 체제 스레드와 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="ff80debaf5b64e3919c264f8e4e883f22ace9ad9" translate="yes" xml:space="preserve">
          <source>To abandon the current evaluation, use &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt;&lt;code&gt;:abandon&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">현재 평가를 포기하려면 &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt; &lt;code&gt;:abandon&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d87be1eb54b07a48c8e89e1267bd4da7830b639e" translate="yes" xml:space="preserve">
          <source>To accumulate a value without using it on the way, see &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer&lt;/a&gt;.</source>
          <target state="translated">도중에 값을 사용하지 않고 값을 누적하려면 &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e5f8467c41adb6b14b429081219eab2c60a0901" translate="yes" xml:space="preserve">
          <source>To achieve these properties, in the safe language dialect we disable completely the following features:</source>
          <target state="translated">이러한 속성을 달성하기 위해 안전한 언어 방언에서 다음 기능을 완전히 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2aa92551218d14a1f44f24fb7177ce7a2bf713bc" translate="yes" xml:space="preserve">
          <source>To add modules to the scope, use ordinary Haskell &lt;code&gt;import&lt;/code&gt; syntax:</source>
          <target state="translated">범위에 모듈을 추가하려면 일반적인 Haskell &lt;code&gt;import&lt;/code&gt; 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e2f3886d316e1e619156706746a8dfbb48e79115" translate="yes" xml:space="preserve">
          <source>To alleviate this issue, GHCi commands can be split over multiple lines, by wrapping them in &lt;code&gt;:{&lt;/code&gt; and &lt;code&gt;:}&lt;/code&gt; (each on a single line of its own):</source>
          <target state="translated">이 문제를 완화하기 위해 GHCi 명령을 &lt;code&gt;:{&lt;/code&gt; 및 &lt;code&gt;:}&lt;/code&gt; (각각 한 줄씩)으로 묶어 여러 줄로 나눌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de30b4286a2929bfdff88d5ee52a322ecb634497" translate="yes" xml:space="preserve">
          <source>To allow for such an instance, we would have to define &lt;code&gt;(:~~:)&lt;/code&gt; as follows:</source>
          <target state="translated">이러한 인스턴스를 허용하려면 다음과 같이 &lt;code&gt;(:~~:)&lt;/code&gt; 을 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="14c677f99c3ebfb083d5ba45347b3df00c07e009" translate="yes" xml:space="preserve">
          <source>To also set the directory in which to run &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 를 실행할 디렉토리를 설정하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ef0b5766dccbebaac045d8e4e6bded46db835a3" translate="yes" xml:space="preserve">
          <source>To always compile everything to object code and never use the interpreter, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;#ghci-obj&quot;&gt;Compiling to object code inside GHCi&lt;/a&gt;).</source>
          <target state="translated">항상 모든 것을 객체 코드로 컴파일하고 인터프리터를 사용하지 않으려면 &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 ( GHCi&lt;a href=&quot;#ghci-obj&quot;&gt; 내에서 객체 코드로 컴파일&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5df8df6d3cdb1b8cf45eb7ff8b8e9438a9330317" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종류와 종류의 중복을 피하기 위해 동일하게 정의됩니다. 당연히 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; 이고 절대 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; 가 아니지만 다른 생성자가 많이 공유됩니다. 종류 있습니다 &lt;code&gt;Bool&lt;/code&gt; 로 표시되어 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 하지 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; . 마찬가지로 튜플 종류는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 가 아닌 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 로 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="9bbefb7d7331de5a028c9b6fdc70e6d980c4f650" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종류와 종류의 중복을 피하기 위해 동일하게 정의됩니다. 당연히 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; 이고 절대 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; 가 아니지만 다른 생성자가 많이 공유됩니다. 종류 있습니다 &lt;code&gt;Bool&lt;/code&gt; 로 표시되어 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 하지 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; . 마찬가지로 튜플 종류는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 가 아닌 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 로 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="b6771efdf3a686f294db18bd2d14bac4e3dba651" translate="yes" xml:space="preserve">
          <source>To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: &lt;code&gt;-ohi /dev/null&lt;/code&gt;, for example.</source>
          <target state="translated">인터페이스를 전혀 생성하지 않으려면이 옵션을 사용하여 인터페이스를 비트 버킷으로 리디렉션 할 수 있습니다 ( 예 : &lt;code&gt;-ohi /dev/null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7aaccb0bd8d229ee1d19d9e75f8795d4cf2370af" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">미묘한 코딩 오류를 방지하려면, 손으로 쓴 마샬링 코드는 바람직하게 사용해야합니다 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 을 오히려 조합보다 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; . 그러나 후자의 루틴은 도구 생성 마샬링 코드에서 선호되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa34733b5e19e7e6a87e5c91b392ff0b0780aa0b" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">미묘한 코딩 오류를 방지하려면, 손으로 쓴 마샬링 코드는 바람직하게 사용해야합니다 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 을 오히려 조합보다 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; . 그러나 후자의 루틴은 도구 생성 마샬링 코드에서 선호되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b35e7282d157dcf47660cd59431c4a8fca882cba" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 문제를 피하려면 대신 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93dbcc0e48dafb4a864c6c8fc82578cf9d42f26f" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 문제를 피하려면, 대신 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68c0704d5dd80ea4a49e31c8c21b3410ffa34f67" translate="yes" xml:space="preserve">
          <source>To avoid undefined behaviour, the original &lt;code&gt;MutableByteArray#&lt;/code&gt; shall not be accessed anymore after a &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; has been performed. Moreover, no reference to the old one should be kept in order to allow garbage collection of the original &lt;code&gt;MutableByteArray#&lt;/code&gt; in case a new &lt;code&gt;MutableByteArray#&lt;/code&gt; had to be allocated.</source>
          <target state="translated">정의되지 않은 동작을 피하기 위해 &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; 가 수행 된 후에는 원래 &lt;code&gt;MutableByteArray#&lt;/code&gt; 더 이상 액세스 할 수 없습니다 . 또한 새 &lt;code&gt;MutableByteArray#&lt;/code&gt; 를 할당 해야하는 경우 원래 &lt;code&gt;MutableByteArray#&lt;/code&gt; 의 가비지 수집을 허용하기 위해 이전 항목을 참조하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d67bfc1538ab33d21305009ebcc630714c1858" translate="yes" xml:space="preserve">
          <source>To be precise, if the class being derived is of the form</source>
          <target state="translated">정확하게 말하면 파생 클래스가 다음 형식 인 경우</target>
        </trans-unit>
        <trans-unit id="c0d9f8d6315eb7cbdcbf50a9f874b3aee61aa5d5" translate="yes" xml:space="preserve">
          <source>To be precise, the annotation &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; is well staged if and only if &lt;code&gt;$(e)&lt;/code&gt; would be (disregarding the usual type restrictions of the splice syntax, and the usual restriction on splicing inside a splice - &lt;code&gt;$([|1|])&lt;/code&gt; is fine as an annotation, albeit redundant).</source>
          <target state="translated">정확하게 말하면, &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; 주석은 &lt;code&gt;$(e)&lt;/code&gt; 가 될 경우에만 잘 준비됩니다. (접합 구문의 일반적인 유형 제한과 접합 내부의 접합에 대한 일반적인 제한을 무시합니다- &lt;code&gt;$([|1|])&lt;/code&gt; 은 주석으로도 사용 가능하지만 중복적임).</target>
        </trans-unit>
        <trans-unit id="28876308b2232e888282a46a9f2647185f20da23" translate="yes" xml:space="preserve">
          <source>To build Haskell modules that export a C API into a shared library use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">C API를 공유 라이브러리로 내보내는 Haskell 모듈을 빌드하려면 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99edfbf2248bb2a627dfdcc360ffdb881b08cb4d" translate="yes" xml:space="preserve">
          <source>To build a simple program and have it use shared libraries for the runtime system and the base libraries use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">간단한 프로그램을 빌드하고 런타임 시스템 및 공유 라이브러리를위한 공유 라이브러리를 사용하려면 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="007ba52a2d8fb965e0b5df4e486442e39607c309" translate="yes" xml:space="preserve">
          <source>To bundle a pattern synonym with a type constructor, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">패턴 동의어를 형식 생성자와 번들로 묶기 위해 형식 생성자를 내보내는 모듈의 내보내기 목록에 패턴 동의어를 나열합니다. 예를 들어, &lt;code&gt;Zero&lt;/code&gt; 를 &lt;code&gt;MyNum&lt;/code&gt; 과 번들로 제공하기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5aae458adadd6ea36810e5833a7811c73bd6831" translate="yes" xml:space="preserve">
          <source>To check whether your &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; setting is doing the right thing, &lt;code&gt;ghc-pkg list&lt;/code&gt; will list all the databases in use, in the reverse order they are searched.</source>
          <target state="translated">&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 설정이 올바른지 확인하기 위해 &lt;code&gt;ghc-pkg list&lt;/code&gt; 는 사용중인 모든 데이터베이스를 검색된 순서와 반대로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="d99b230674f283901189e80464c11bff12827985" translate="yes" xml:space="preserve">
          <source>To compile a module which is to be part of a new package, use the &lt;code&gt;-package-name&lt;/code&gt; (to identify the name of the package) and &lt;code&gt;-library-name&lt;/code&gt; (to identify the version and the version hashes of its identities.) options (&lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;). Failure to use these options when compiling a package will probably result in disaster, but you will only discover later when you attempt to import modules from the package. At this point GHC will complain that the package name it was expecting the module to come from is not the same as the package name stored in the &lt;code&gt;.hi&lt;/code&gt; file.</source>
          <target state="translated">새 패키지의 일부가 될 모듈을 컴파일하려면 &lt;code&gt;-package-name&lt;/code&gt; (패키지 이름 식별) 및 &lt;code&gt;-library-name&lt;/code&gt; (버전 및 해당 버전의 버전 해시 식별) 옵션 ( &lt;a href=&quot;#using-packages&quot;&gt;패키지 사용&lt;/a&gt; ). 패키지를 컴파일 할 때 이러한 옵션을 사용하지 않으면 재난이 발생할 수 있지만 나중에 패키지에서 모듈을 가져 오려고 할 때만 발견됩니다. 이 시점에서 GHC는 모듈에서 오는 패키지 이름이 &lt;code&gt;.hi&lt;/code&gt; 파일에 저장된 패키지 이름과 동일하지 않다고 불평 합니다.</target>
        </trans-unit>
        <trans-unit id="12fd6ddf28c5285fa1983ff47d370bb4e33b05da" translate="yes" xml:space="preserve">
          <source>To compile the program, use GHC like this:</source>
          <target state="translated">프로그램을 컴파일하려면 다음과 같이 GHC를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="485c5e401e6a134f4abe73897df6824e3409a20e" translate="yes" xml:space="preserve">
          <source>To compile these three files, issue the following commands:</source>
          <target state="translated">이 세 파일을 컴파일하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8a91e9bb879d47c785fc61c253926f7398d2eae9" translate="yes" xml:space="preserve">
          <source>To control the choice of instance, it is possible to specify the overlap behavior for individual instances with a pragma, written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword. The pragma may be one of: &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt;, or &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt;.</source>
          <target state="translated">인스턴스 선택을 제어하기 위해 &lt;code&gt;instance&lt;/code&gt; 키워드 바로 뒤에 쓰여진 pragma를 사용하여 개별 인스턴스에 대한 오버랩 동작을 지정할 수 있습니다 . pragma는 &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; , &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt; , &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt; 또는 &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc0d1e2f710041d917fa9128128d16f4e0b579c" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt;, use the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 으로 변환하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1c0964746ae7b2a2f00992a848001548495aecef" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 값을 해당 Haskell 함수 로 변환 하기 위해 특정 외부 유형에 대한 &lt;em&gt;동적&lt;/em&gt; 스텁을 정의 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="5d067decf6925ff18738730cccec299d546abf35" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 값을 해당 Haskell 함수 로 변환 하기 위해 특정 외부 유형에 대한 &lt;em&gt;동적&lt;/em&gt; 스텁을 정의 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="fea7f792e37393718cca4a9b6921cb08aba10fa5" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 값을 해당 Haskell 함수 로 변환 하기 위해 특정 외부 유형에 대한 &lt;em&gt;동적&lt;/em&gt; 스텁을 정의 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="2acaa5dea000cc74154c0f402c3febbfb83f1a58" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 유니 코드로 정의 된 해당 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값으로 변환 하거나 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 각각 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 (또는 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="786657e4c88a725db3968f98b13dce85d65db23b" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 유니 코드로 정의 된 해당 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값으로 변환 하거나 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 각각 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 (또는 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="d7130a3be670709f03cd81a58cb2b61282e0d6dd" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 유니 코드로 정의 된 해당 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값으로 변환 하거나 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 각각 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 (또는 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="13a465a9773b015ffc884872ada910d6f797abb7" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; 에서 변환하려면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e3196791a7a1592e7daa80285f0558ede2e0d6d" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; 에서 변환하려면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1659f84a77c9a2443a59423cc658f61a338f3abe" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코딩이 전혀없는 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 만들려면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 기존 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 추가 인코딩 또는 디코딩을 중지하려면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f153e244215130d9c4edb53cdcbba15630d42840" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코딩이 전혀없는 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 만들려면 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 기존 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 추가 인코딩 또는 디코딩을 중지하려면 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1171deb859f0f29f6aacadc46ea52378fb28f5f8" translate="yes" xml:space="preserve">
          <source>To create a pipe from which to read the output of &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 의 출력을 읽을 파이프를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="96af4537bfd12fadb83763899a123cc096a36017" translate="yes" xml:space="preserve">
          <source>To define the &lt;code&gt;item&lt;/code&gt; parser, we need to lift the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; operations through the &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; 파서 를 정의하려면 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 변환기를 통해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 작업 을 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="61b1e6de56b01e5140d8cba3ed36c3acb9b257dc" translate="yes" xml:space="preserve">
          <source>To delete a breakpoint, use the &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt;&lt;code&gt;:delete&lt;/code&gt;&lt;/a&gt; command with the number given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">중단 점을 삭제하려면 &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt; 의 출력에 제공된 번호와 함께 &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt; &lt;code&gt;:delete&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea8e294886bade8bd7cc5b83aa9ec115d1403bbc" translate="yes" xml:space="preserve">
          <source>To delete all breakpoints at once, use &lt;code&gt;:delete *&lt;/code&gt;.</source>
          <target state="translated">모든 중단 점을 한 번에 &lt;code&gt;:delete *&lt;/code&gt; 하려면 : delete *를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="20c69ea8d7a8119ee63218b8c507949aacadde61" translate="yes" xml:space="preserve">
          <source>To derive &lt;code&gt;Eq&lt;/code&gt; in the standard way we would need to have equality between the single component of two &lt;code&gt;MkT&lt;/code&gt; constructors:</source>
          <target state="translated">표준 방식으로 &lt;code&gt;Eq&lt;/code&gt; 를 도출하려면 두 &lt;code&gt;MkT&lt;/code&gt; 생성자 의 단일 구성 요소간에 동등성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f0219713c4b957a1c6e5e311515abfddd97e7be" translate="yes" xml:space="preserve">
          <source>To disable one or several defined breakpoint, use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command with one or several blank separated numbers given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:. To disable all breakpoints at once, use &lt;code&gt;:disable *&lt;/code&gt;.</source>
          <target state="translated">하나 또는 여러 개의 정의 된 중단 점을 비활성화하려면 &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt; : 의 출력에 주어진 하나 또는 여러 개의 공백으로 구분 된 숫자와 함께 &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt; &lt;code&gt;:disable&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 . 모든 중단 점을 한 번에 &lt;code&gt;:disable *&lt;/code&gt; 하려면 : disable *을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9be5e62141d987ac491830af48130b4bb8a0121e" translate="yes" xml:space="preserve">
          <source>To examine one of the steps in the history, use &lt;a href=&quot;#ghci-cmd-:back&quot;&gt;&lt;code&gt;:back&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">히스토리의 단계 중 하나를 검사하려면 &lt;a href=&quot;#ghci-cmd-:back&quot;&gt; &lt;code&gt;:back&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="66eef0e4ec6c04a45dd59938c23022bba82ff967" translate="yes" xml:space="preserve">
          <source>To export them on their own, in an export or import specification, you must prefix pattern names with the &lt;code&gt;pattern&lt;/code&gt; keyword, e.g.:</source>
          <target state="translated">내보내기 또는 가져 오기 스펙에서 자체적으로 내보내려면 패턴 이름 앞에 &lt;code&gt;pattern&lt;/code&gt; 키워드를 접두어로 붙여야 합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="059e3de99f2d80caf2d89e7201f6c7c557017928" translate="yes" xml:space="preserve">
          <source>To figure out what exactly they do, the least bad way is to grep the rts/ directory in the ghc code for macros like &lt;code&gt;DEBUG(scheduler&lt;/code&gt; or &lt;code&gt;DEBUG_scheduler&lt;/code&gt;.</source>
          <target state="translated">정확히 무엇을하는지 알아 내려면 가장 나쁜 방법은 &lt;code&gt;DEBUG(scheduler&lt;/code&gt; 또는 &lt;code&gt;DEBUG_scheduler&lt;/code&gt; 와 같은 매크로에 대해 ghc 코드에서 rts / 디렉토리를 grep하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="373832b60bccf6816963a2a722042fdc637fe0c9" translate="yes" xml:space="preserve">
          <source>To figure out which part of the compiler is badly behaved, the &lt;code&gt;-v2&lt;/code&gt; option is your friend.</source>
          <target state="translated">컴파일러의 어느 부분이 잘못 작동하는지 파악하려면 &lt;code&gt;-v2&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="617e8f413888e2a59390516c4594fefa6467d4c8" translate="yes" xml:space="preserve">
          <source>To fix the problem, you need to recompile the broken packages against the new dependencies. The easiest way to do this is to use &lt;code&gt;cabal-install&lt;/code&gt;, or download the packages from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt; and build and install them as normal.</source>
          <target state="translated">문제를 해결하려면 새 종속성에 대해 손상된 패키지를 다시 컴파일해야합니다. 가장 쉬운 방법 은 &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;cabal &lt;/a&gt; &lt;code&gt;cabal-install&lt;/code&gt; 을 사용 하거나 HackageDB 에서 패키지를 다운로드하여 정상적으로 빌드하고 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1fadbae3a14577a0f008fefc32f335b95527ef3" translate="yes" xml:space="preserve">
          <source>To further explain this example, the right-hand side of the default type signature for &lt;code&gt;bar&lt;/code&gt; must be something that is alpha-equivalent to &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; (where &lt;code&gt;a&lt;/code&gt; is bound by the class itself, and is thus free in the methods&amp;rsquo; type signatures). So this would also be an acceptable default type signature:</source>
          <target state="translated">이 예제를 자세히 설명하려면 &lt;code&gt;bar&lt;/code&gt; 에 대한 기본 유형 서명의 오른쪽 이 &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 와 알파벳과 같아야합니다 . a-&amp;gt; b-&amp;gt; b (여기서 &lt;code&gt;a&lt;/code&gt; 는 클래스 자체에 의해 바인딩되므로 메소드의 유형 시그니처에서 자유 롭습니다). 따라서 이것은 허용되는 기본 유형 서명이기도합니다.</target>
        </trans-unit>
        <trans-unit id="1e54d546d02ad4863886b9ee73d1e131e1c71a9f" translate="yes" xml:space="preserve">
          <source>To gain access to a much larger family of encodings, use the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">훨씬 더 큰 인코딩 제품군에 액세스하려면 &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7552595f3e9f52aba2ce1ac4224b4fd08998d77" translate="yes" xml:space="preserve">
          <source>To generate a heap profile from your program:</source>
          <target state="translated">프로그램에서 힙 프로파일을 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5c213d8e1ad0bf625f6921a8437f98eeb3f4a1b0" translate="yes" xml:space="preserve">
          <source>To generate a time and allocation profile, give one of the following RTS options to the compiled program when you run it (RTS options should be enclosed between &lt;code&gt;+RTS ... -RTS&lt;/code&gt; as usual):</source>
          <target state="translated">시간 및 할당 프로파일을 생성하려면 컴파일 할 때 다음 RTS 옵션 중 하나를 컴파일 된 프로그램에 제공하십시오 (RTS 옵션은 평소와 같이 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; 사이에 포함되어야 함 ).</target>
        </trans-unit>
        <trans-unit id="34cea9b35b2bfd8b0bd668c0b07e2825a95e1c3d" translate="yes" xml:space="preserve">
          <source>To get a list of the bindings currently in scope, use the &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt;&lt;code&gt;:show bindings&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">현재 범위 내에있는 바인딩 목록을 가져 오려면 &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt; &lt;code&gt;:show bindings&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="584aacfb52fdd9de92b4db69f120bc255bd58b9a" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">보다 유용한 &lt;code&gt;Collects&lt;/code&gt; 클래스 버전을 얻기 위해 GHC는 프로그래머가 여러 매개 변수 클래스의 매개 변수 사이의 종속성을 지정할 수있는 메커니즘을 제공합니다 (이론적 기초 및 이전 연구에 관심이있는 독자의 경우 : 종속성 정보의 사용을 볼 수 있음) Chen, Hudak 및 Odersky가 제시 한 &quot;매개 변수 유형 클래스&quot;제안의 일반화 또는 자격이있는 유형의 &quot;개선&quot;을위한 Mark Jones의 후일 프레임 워크의 특별한 사례로 사용됩니다. 원고에서보다 이론적이고 추상적 인 설정 &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;여기서 암시 적 매개 변수화 시스템을위한 일반 설계 공간에서 한 지점으로 식별됩니다. 추상 예제로 시작하려면 다음과 같은 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3b643a5f53fe92a51d4d6cc04833d6658ab9e142" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id32&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">&lt;code&gt;Collects&lt;/code&gt; 클래스 의보다 유용한 버전을 얻기 위해 GHC는 프로그래머가 다중 매개 변수 클래스의 매개 변수 간의 종속성을 지정할 수있는 메커니즘을 제공합니다 (이론적 기초 및 이전 작업에 관심이있는 독자를 위해 : 종속성 정보의 사용을 볼 수 있습니다. Chen, Hudak 및 Odersky가 제안한 &quot;파라 메트릭 유형 클래스&quot;에 대한 제안의 일반화 또는 정규화 된 유형의 &quot;개선&quot;을위한 Mark Jones의 이후 프레임 워크의 특수 사례로서의 기본 아이디어도 다음에서 논의됩니다. &lt;a href=&quot;#jones1999&quot; id=&quot;id32&quot;&gt; [Jones1999]&lt;/a&gt;묵시적 매개 변수화 시스템을위한 일반적인 디자인 공간의 한 지점으로 식별 되는 원고의 더 이론적이고 추상적 인 설정 ). 추상적 인 예제로 시작하려면 다음과 같은 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2dd4283dabd7adbbf3b3fa6217759a91e02bf006" translate="yes" xml:space="preserve">
          <source>To get better errors, it is recommended to use #line pragmas when emitting C files, e.g.</source>
          <target state="translated">더 나은 오류를 얻으려면 C 파일을 내보낼 때 #line pragma를 사용하는 것이 좋습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="c4c508962468a9bf469857dfae6ad15a1e12b86c" translate="yes" xml:space="preserve">
          <source>To get maximum performance when building lazy &lt;code&gt;Text&lt;/code&gt; values using a builder, associate &lt;code&gt;mappend&lt;/code&gt; calls to the right. For example, prefer</source>
          <target state="translated">빌더를 사용하여 지연 &lt;code&gt;Text&lt;/code&gt; 값을 빌드 할 때 최대 성능을 얻으려면 &lt;code&gt;mappend&lt;/code&gt; 호출을 오른쪽으로 연관 시키십시오 . 예를 들어 선호</target>
        </trans-unit>
        <trans-unit id="e54b5b21677328842d1e9a6b9afb2745752f58b5" translate="yes" xml:space="preserve">
          <source>To get the annotations of a single binder, you can use &lt;code&gt;getAnnotations&lt;/code&gt; and specify the proper type. Here&amp;rsquo;s an example that will print out the name of any top-level non-recursive binding with the &lt;code&gt;SomeAnn&lt;/code&gt; annotation:</source>
          <target state="translated">단일 바인더의 주석을 얻으려면 &lt;code&gt;getAnnotations&lt;/code&gt; 를 사용하고 적절한 유형을 지정하십시오. 다음은 &lt;code&gt;SomeAnn&lt;/code&gt; 주석을 사용하여 최상위 비 재귀 바인딩의 이름을 인쇄하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="427028b92998e9d2972ad20dfdc92870e2d3c450" translate="yes" xml:space="preserve">
          <source>To help understand the use of these functions, consider the Unicode string &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt;. If encoded as UTF-8, this becomes &lt;code&gt;&quot;hi
 \xe2\x98\x83&quot;&lt;/code&gt;; the final &lt;code&gt;'☃'&lt;/code&gt; is encoded as 3 bytes.</source>
          <target state="translated">이러한 기능의 사용을 이해하려면 유니 코드 문자열 &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt; 을 고려하십시오 . UTF-8로 인코딩 된 경우 &lt;code&gt;&quot;hi \xe2\x98\x83&quot;&lt;/code&gt; . 마지막 &lt;code&gt;'☃'&lt;/code&gt; 은 3 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="99872510dc191d4452db56bf22957570e23b92b9" translate="yes" xml:space="preserve">
          <source>To help you get over the confidence barrier, try out this skeletal worked example. First cut and paste the two modules below into &lt;code&gt;Main.hs&lt;/code&gt; and &lt;code&gt;Printf.hs&lt;/code&gt;:</source>
          <target state="translated">자신감의 장벽을 극복 할 수 있도록이 골격 작동 예제를 사용해보십시오. 먼저 아래 두 모듈을 잘라 &lt;code&gt;Main.hs&lt;/code&gt; 및 &lt;code&gt;Printf.hs&lt;/code&gt; 에 붙여 넣 습니다 .</target>
        </trans-unit>
        <trans-unit id="48b1aabf0c4a191f672c0b44cca67c4f38a6d577" translate="yes" xml:space="preserve">
          <source>To hopefully illuminate the role of the different data structures, here are the command-line options for a (very simple) compiler, done in two different ways. The difference arises because the type of &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; is parameterized by the type of values derived from flags.</source>
          <target state="translated">다른 데이터 구조의 역할을 희망적으로 밝히기 위해 두 가지 다른 방식으로 수행되는 (매우 간단한) 컴파일러의 명령 행 옵션이 있습니다. &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; 의 유형이 플래그에서 파생 된 값의 유형으로 매개 변수화 되기 때문에 차이가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="d8ae72f545b1ce82b2cfe09ab991783beb655542" translate="yes" xml:space="preserve">
          <source>To implement &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findLast&lt;/code&gt; on any &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;find&lt;/code&gt; 또는 &lt;code&gt;findLast&lt;/code&gt; 를 구현하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="458751b9fab299d8f4e8789e1128f4827ef9c961" translate="yes" xml:space="preserve">
          <source>To import a qualified module usually you must specify &lt;code&gt;qualified&lt;/code&gt; in prepositive position : &lt;code&gt;import qualified M&lt;/code&gt;. This often leads to a &amp;ldquo;hanging indent&amp;rdquo; (which is automatically inserted by some autoformatters and common in many code bases. For example:</source>
          <target state="translated">자격을 갖춘 모듈을 가져 오려면 보통 지정해야 &lt;code&gt;qualified&lt;/code&gt; 전치 위치 : &lt;code&gt;import qualified M&lt;/code&gt; . 이로 인해 종종 &quot;내어 쓰기&quot;가 발생합니다 (일부 자동 서식 지정 도구에 의해 자동으로 삽입되고 많은 코드베이스에서 일반적입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2c7c52e770ffa8a6b97378d2c5e459f4d2e43a4e" translate="yes" xml:space="preserve">
          <source>To install LLVM and Clang:</source>
          <target state="translated">LLVM 및 Clang을 설치하려면</target>
        </trans-unit>
        <trans-unit id="f4755fa59e195e04ee11ff89504edf74eae51201" translate="yes" xml:space="preserve">
          <source>To invoke &lt;code&gt;foo()&lt;/code&gt; from C, just &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; and call &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">C에서 &lt;code&gt;foo()&lt;/code&gt; 를 호출하려면 &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; 와 &lt;code&gt;foo()&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="67c620f61de0b4e8243389340a761b127a5420c3" translate="yes" xml:space="preserve">
          <source>To learn more about this decision and the design of GHC under the hood please see the &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;paper&lt;/a&gt; introducing this kind system to GHC/Haskell.</source>
          <target state="translated">이 결정 및 GHC 디자인에 대한 자세한 내용은 이러한 종류의 시스템을 GHC / Haskell에 소개 하는 &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aae76ecf649e9d0d8a82065b74e94e13fc57f2d4" translate="yes" xml:space="preserve">
          <source>To load a Haskell source file into GHCi, use the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">Haskell 소스 파일을 GHCi에 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 하려면 : load 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="84282ca7b4af31d8f72f41e5b0309bfeef77e8b2" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">패키지 &lt;code&gt;foo&lt;/code&gt; 를로드하기 위해 &lt;code&gt;libHSfoo.a&lt;/code&gt; 는 libHSfoo.a 라이브러리를 직접로드 할 수 있지만, 사전 링크 된 단일 &lt;code&gt;HSfoo.o&lt;/code&gt; 파일 형식으로 패키지를로드 할 수도 있습니다. &lt;code&gt;.o&lt;/code&gt; 파일을 로드하는 것은 약간 빠르지 만 컴파일 된 패키지의 다른 사본이 필요합니다. 경험상 패키지의 모듈이 &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 로 컴파일 된 경우 패키지를 GHCi에로드 할 때 시간이 절약되므로 &lt;code&gt;HSfoo.o&lt;/code&gt; 를 작성하는 것이 좋습니다. 없이 &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; , 사이로드 시간에 큰 차이가없는 &lt;code&gt;.o&lt;/code&gt; 인 과 &lt;code&gt;.a&lt;/code&gt; 는 디스크 공간을 절약 만 유지하는 것이 좋습니다 그래서 라이브러리는, &lt;code&gt;.a&lt;/code&gt; 주변. GHC 배포판 에서는 GHC 패키지 자체를 제외한 대부분의 패키지에 &lt;code&gt;.o&lt;/code&gt; 파일을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ab99b40605f7da9e4eebad8eb504404bd0faa1f0" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">패키지 &lt;code&gt;foo&lt;/code&gt; 를로드하기 위해 &lt;code&gt;libHSfoo.a&lt;/code&gt; 는 libHSfoo.a 라이브러리를 직접로드 할 수 있지만 사전 링크 된 단일 &lt;code&gt;HSfoo.o&lt;/code&gt; 파일 형식으로 패키지를로드 할 수도 있습니다. &lt;code&gt;.o&lt;/code&gt; 파일을 로드하는 것이 약간 더 빠르지 만 컴파일 된 패키지의 다른 사본이 필요합니다. 경험상 패키지의 모듈이 &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt; &lt;code&gt;-split-sections&lt;/code&gt; &lt;/a&gt; 로 컴파일 된 경우 &lt;code&gt;HSfoo.o&lt;/code&gt; 를 빌드하면 GHCi 로 패키지를로드 할 때 시간을 절약 할 수 있으므로 가치가 있습니다. 없이 &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt; &lt;code&gt;-split-sections&lt;/code&gt; &lt;/a&gt; , 사이로드 시간에 큰 차이가없는 &lt;code&gt;.o&lt;/code&gt; 인 및 &lt;code&gt;.a&lt;/code&gt; 라이브러리이므로 디스크 공간을 절약하고 &lt;code&gt;.a&lt;/code&gt; 만 유지하는 것이 좋습니다 . GHC 배포판 에서는 GHC 패키지 자체를 제외한 대부분의 패키지에 대해 &lt;code&gt;.o&lt;/code&gt; 파일을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="d2e3260144403e14ad423568ae3ce8f12c1a164c" translate="yes" xml:space="preserve">
          <source>To make an executable program, the GHC system compiles your code and then links it with a non-trivial runtime system (RTS), which handles storage management, thread scheduling, profiling, and so on.</source>
          <target state="translated">실행 가능한 프로그램을 만들기 위해 GHC 시스템은 코드를 컴파일 한 다음 스토리지 관리, 스레드 스케줄링, 프로파일 링 등을 처리하는 사소한 런타임 시스템 (RTS)과 코드를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="409b50b71b1cf04f14989a6bebb5d1b08c15a045" translate="yes" xml:space="preserve">
          <source>To make life slightly easier, the GHCi prompt also behaves as if there is an implicit &lt;code&gt;import qualified&lt;/code&gt; declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; flag.</source>
          <target state="translated">GHCi 프롬프트는 약간의 편의성을 높이기 위해 모든 패키지의 모든 모듈과 현재 GHCi에로드 된 모든 모듈에 대해 내재 된 &lt;code&gt;import qualified&lt;/code&gt; 선언 이있는 것처럼 작동합니다 . 이 동작은 &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; 플래그 로 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3811e1546e787ed220aa8285f2fd305ece22386" translate="yes" xml:space="preserve">
          <source>To make this more robust, GHC has a notion of deriving strategies, which allow the user to explicitly request which approach to use when deriving an instance. To enable this feature, one must enable the &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; language extension. A deriving strategy can be specified in a deriving clause</source>
          <target state="translated">이를 더욱 강력하게하기 위해 GHC에는 파생 전략이라는 개념이 있으며,이를 통해 사용자는 인스턴스를 파생시킬 때 사용할 접근 방식을 명시 적으로 요청할 수 있습니다. 이 기능을 활성화하려면 &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; 언어 확장을 활성화해야합니다 . 파생 전략에 파생 전략을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b64615441fb8a751e6636d849ab82db0727aa6e0" translate="yes" xml:space="preserve">
          <source>To make use of the profiling system &lt;em&gt;all&lt;/em&gt; modules must be compiled and linked with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option. Any &lt;code&gt;SCC&lt;/code&gt; annotations you&amp;rsquo;ve put in your source will spring to life.</source>
          <target state="translated">프로파일 링 시스템을 사용하려면 &lt;em&gt;모든&lt;/em&gt; 모듈을 컴파일하고 &lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션 과 연결해야합니다 . 모든 &lt;code&gt;SCC&lt;/code&gt; 의 당신이 당신의 소스에 넣어 한 주석 생활에 봄 것입니다.</target>
        </trans-unit>
        <trans-unit id="cadd792349a4de388974151ed3334973779b0aae" translate="yes" xml:space="preserve">
          <source>To make use of these hidden fields, we need to create some helper functions:</source>
          <target state="translated">이러한 숨겨진 필드를 사용하려면 도우미 함수를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a354e65731baf61d210fdcef00d7fcaebe03d2c" translate="yes" xml:space="preserve">
          <source>To provide more control over the compiler&amp;rsquo;s verbosity, the &lt;code&gt;-v&lt;/code&gt; flag takes an optional numeric argument. Specifying &lt;code&gt;-v&lt;/code&gt; on its own is equivalent to &lt;code&gt;-v3&lt;/code&gt;, and the other levels have the following meanings:</source>
          <target state="translated">컴파일러의 세부 정보를보다 강력하게 제어하기 위해 &lt;code&gt;-v&lt;/code&gt; 플래그는 선택적 숫자 인수를 사용합니다. &lt;code&gt;-v&lt;/code&gt; 자체를 지정 하는 것은 &lt;code&gt;-v3&lt;/code&gt; 과 동일 하며 다른 레벨은 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e09a1d373d13bfd1fe833239f80a4362b6548f69" translate="yes" xml:space="preserve">
          <source>To recover after an exception and do something else, the best choice is to use one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; family.</source>
          <target state="translated">예외 후에 복구하고 다른 작업을 수행하려면 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 제품군 중 하나를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="14e26ca731fed1a65d734c4805ba32c05da97880" translate="yes" xml:space="preserve">
          <source>To remove an existing directory symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기존 디렉토리 기호 링크를 제거하려면 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt; 를 사용하십시오. .</target>
        </trans-unit>
        <trans-unit id="902b5e7fc39d15c95b3964399bd08b53ff7a117f" translate="yes" xml:space="preserve">
          <source>To remove an existing file symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기존 파일 기호 링크를 제거하려면 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. .</target>
        </trans-unit>
        <trans-unit id="0eb5610465d9a35f189f4445a996d1ae11b587c8" translate="yes" xml:space="preserve">
          <source>To safely use this API you must either extract the list of vertices directly from the graph or first call &lt;code&gt;vertexFromKey k&lt;/code&gt; to check if a vertex corresponds to the key &lt;code&gt;k&lt;/code&gt;. Once it is known that a vertex exists you can use &lt;code&gt;nodeFromVertex&lt;/code&gt; to access the labelled node and adjacent vertices. See below for examples.</source>
          <target state="translated">이 API를 안전하게 사용하려면 그래프에서 직접 정점 목록을 추출하거나 &lt;code&gt;vertexFromKey k&lt;/code&gt; 를 먼저 호출 하여 정점이 키 &lt;code&gt;k&lt;/code&gt; 에 해당하는지 확인해야합니다 . 정점이 존재하는 것으로 알려진 후에는 &lt;code&gt;nodeFromVertex&lt;/code&gt; 를 사용할 수 있습니다 를 사용하여 레이블이 지정된 노드 및 인접한 정점에 액세스 . 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a5e1113a1ceca8ac3b9f3aacd5ed4c7c86f2fc6d" translate="yes" xml:space="preserve">
          <source>To see whether you&amp;rsquo;re making good use of all the memory reseverd for the allocation area (&lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;), look at the output of &lt;code&gt;+RTS -S&lt;/code&gt; and check whether the amount of memory allocated between GCs is equal to &lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;. If not, there are two possible remedies: use &lt;code&gt;-n&lt;/code&gt; to set a nursery chunk size, or use &lt;code&gt;-AL&lt;/code&gt; to increase the limit for large objects.</source>
          <target state="translated">당신이 (할당 영역에 대한 모든 메모리 reseverd 잘 활용하고 있는지 여부를 확인하려면 &lt;code&gt;-A&lt;/code&gt; 의 시간이 &lt;code&gt;-N&lt;/code&gt; 의 출력에서) 살펴 &lt;code&gt;+RTS -S&lt;/code&gt; 와 GC를 사이에 할당 된 메모리의 양이 같은지 여부를 확인 &lt;code&gt;-A&lt;/code&gt; 시간 &lt;code&gt;-N&lt;/code&gt; . 그렇지 않은 경우 두 가지 가능한 해결 방법이 있습니다. &lt;code&gt;-n&lt;/code&gt; 을 사용하여 보육 청크 크기를 설정하거나 &lt;code&gt;-AL&lt;/code&gt; 을 사용 하여 큰 오브젝트의 한계를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="7f2b1743b3c15e52d49c7a46f47317e7b211afa8" translate="yes" xml:space="preserve">
          <source>To see which modules are provided by a package use the &lt;code&gt;ghc-pkg&lt;/code&gt; command (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;):</source>
          <target state="translated">패키지에서 제공하는 모듈을 확인하려면 &lt;code&gt;ghc-pkg&lt;/code&gt; 명령을 사용 하십시오 ( &lt;a href=&quot;#package-management&quot;&gt;패키지 관리 (ghc-pkg 명령) 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d20768e5351c559b7b7519dd0d6001dcac049eb" translate="yes" xml:space="preserve">
          <source>To see which packages are currently available, use the &lt;code&gt;ghc-pkg list&lt;/code&gt; command:</source>
          <target state="translated">현재 사용 가능한 패키지를 확인하려면 &lt;code&gt;ghc-pkg list&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a70566dabf5a41f2019632020db79dab54902519" translate="yes" xml:space="preserve">
          <source>To see why a data type with a contravariant occurrence of its last type parameter cannot have a derived &lt;code&gt;Functor&lt;/code&gt; instance, let&amp;rsquo;s suppose that a &lt;code&gt;Functor ContraFun1&lt;/code&gt; instance exists. The implementation would look something like this:</source>
          <target state="translated">마지막 유형 매개 변수의 반 변형이있는 데이터 유형이 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스를 가질 수없는 이유를 확인하려면 &lt;code&gt;Functor ContraFun1&lt;/code&gt; 이라고 가정 하십시오. 인스턴스가 . 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dd1e599c7b99d0ef6415d16c2b63820670b8ef4" translate="yes" xml:space="preserve">
          <source>To serialise a custom type, an instance of Binary for that type is required. For example, suppose we have a data structure:</source>
          <target state="translated">사용자 정의 유형을 직렬화하려면 해당 유형의 이진 인스턴스가 필요합니다. 예를 들어, 데이터 구조가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="ec5ac163ebb0f97a307be294a6581754c5f32393" translate="yes" xml:space="preserve">
          <source>To serialise this to a bytestring, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;, which packs the data structure into a binary format, in a lazy bytestring</source>
          <target state="translated">이것을 바이트 문자열로 직렬화하려면 &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 를 사용하십시오. , 데이터 구조를 이진 형식으로 지연 바이트 문자열로 압축하는 합니다</target>
        </trans-unit>
        <trans-unit id="8c4bb74fa2bda9539f0db58684ace13bfcd04704" translate="yes" xml:space="preserve">
          <source>To set a package&amp;rsquo;s trust property in the package database please refer to &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;.</source>
          <target state="translated">패키지 데이터베이스에 패키지의 신뢰 속성을 설정하려면을 참조하십시오 &lt;a href=&quot;packages#packages&quot;&gt;패키지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a25ac21c6d3b62631dd08b42b9fae80c8727be0" translate="yes" xml:space="preserve">
          <source>To skip to the first occurence of a string:</source>
          <target state="translated">문자열의 첫 항목으로 건너 뛰려면</target>
        </trans-unit>
        <trans-unit id="edb758d0d6990d34bd2a170aea31bb2ebe72017b" translate="yes" xml:space="preserve">
          <source>To solve such concern, the references provided by this module offer a key that can be used to locate the values on each process. Each process maintains a global table of references which can be looked up with a given key. This table is known as the Static Pointer Table. The reference can then be dereferenced to obtain the value.</source>
          <target state="translated">이러한 문제를 해결하기 위해이 모듈에서 제공하는 참조는 각 프로세스에서 값을 찾는 데 사용할 수있는 키를 제공합니다. 각 프로세스는 주어진 키로 조회 할 수있는 전역 참조 테이블을 유지 관리합니다. 이 테이블을 정적 포인터 테이블이라고합니다. 그런 다음 참조를 역 참조하여 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c68944d2e59e0a66846b50f57d32b2ca1f9acb" translate="yes" xml:space="preserve">
          <source>To solve this, GHC provides a single type-level function,</source>
          <target state="translated">이를 해결하기 위해 GHC는 단일 유형 레벨 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf25b9f1720e9ac7d0d7fdd7aee2f1ed9e0566fe" translate="yes" xml:space="preserve">
          <source>To start with an example, suppose you had a module &lt;code&gt;A&lt;/code&gt; which made use of some string operations. Using normal module imports, you would only be able to pick a particular implementation of strings:</source>
          <target state="translated">예를 들어, 일부 문자열 연산을 사용 하는 모듈 &lt;code&gt;A&lt;/code&gt; 가 있다고 가정합니다 . 일반적인 모듈 가져 오기를 사용하면 특정 문자열 구현 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c4479e20c71a25f4dfb43028231f4a734bfcce" translate="yes" xml:space="preserve">
          <source>To take the parts of a string before a delimiter:</source>
          <target state="translated">구분 기호 앞에 문자열 부분을 가져 오려면</target>
        </trans-unit>
        <trans-unit id="e0c0e5556db2e9b3b7a23b8b7d2d49b51aa44349" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">Concurrent Haskell은 프로그래머에게 새로운 언어 구조를 도입하지 않습니다. 오히려 단순히 라이브러리 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 로 나타납니다 . 이 라이브러리에서 내 보낸 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bfc70e59567edf696404769885739682f80dcc8" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">프로그래머에게 Concurrent Haskell은 새로운 언어 구조를 도입하지 않습니다. 오히려 단순히 라이브러리 인 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 로 나타납니다 . 이 라이브러리에서 내 보낸 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c62456e79e21d498915acbcba13f52cb41593ec" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 와 함께 &lt;code&gt;+RTS&lt;/code&gt; 플래그 를 사용하려면 예제를 약간 수정해야합니다. 기본적으로 GHC의 RTS는 &quot;안전한&quot; &lt;code&gt;+RTS&lt;/code&gt; 플래그 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조) 만 허용 하고 &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; 링크 시간 플래그가이를 무시합니다. 그러나 &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; 은 &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; 이 사용 중일 때 효과가 없습니다 (그리고 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 도 마찬가지입니다 ). 이러한 옵션을 설정하려면 &lt;code&gt;hs_init()&lt;/code&gt; 대신 GHC 특정 API를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="23874375ac3170d79af0c71d4f8ee2bec3a32884" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 와 함께 &lt;code&gt;+RTS&lt;/code&gt; 플래그 를 사용하려면 예제를 약간 수정해야합니다. 기본적으로 GHC의 RTS는 &quot;안전한&quot; &lt;code&gt;+RTS&lt;/code&gt; 플래그 만 허용하며 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조 ) &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 링크 타임 플래그가이를 무시합니다. 그러나 &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; 이 사용 중일 때는 &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 이 적용되지 않습니다 (그리고 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 도 마찬가지 ). 이러한 옵션을 설정하려면 &lt;code&gt;hs_init()&lt;/code&gt; 대신 GHC 특정 API를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="58ce08b9cab583ec1630da790acaeb1e4504d015" translate="yes" xml:space="preserve">
          <source>To use an &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt; the RTS API provides the following functions:</source>
          <target state="translated">&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; 를 사용하기 위해 RTS API는 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c832a5995effff9df59220a2bd9f7e56cfb4614f" translate="yes" xml:space="preserve">
          <source>To use an extended and very rich family of functions for working with Unicode text (including normalization, regular expressions, non-standard encodings, text breaking, and locales), see the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">유니 코드 텍스트 (정규화, 정규식, 비표준 인코딩, 텍스트 분리 및 로캘 포함) 작업에 확장되고 매우 다양한 기능을 사용하려면 &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu 패키지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b96ac2af089bcd3267331bb1501aa1e1d197309c" translate="yes" xml:space="preserve">
          <source>To use relative paths for dependent libraries on Linux and Solaris you can pass a suitable &lt;code&gt;-rpath&lt;/code&gt; flag to the linker:</source>
          <target state="translated">Linux 및 Solaris에서 종속 라이브러리에 상대 경로를 사용하려면 적절한 &lt;code&gt;-rpath&lt;/code&gt; 플래그를 링커에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f309e398fff568b18e392785bde202981de0be5" translate="yes" xml:space="preserve">
          <source>To use this equality in practice, pattern-match on the &lt;code&gt;Coercion a b&lt;/code&gt; to get out the &lt;code&gt;Coercible a b&lt;/code&gt; instance, and then use &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; to apply it.</source>
          <target state="translated">실제로이 평등을 사용하려면에 패턴 일치 &lt;code&gt;Coercion a b&lt;/code&gt; 밖으로 얻을 &lt;code&gt;Coercible a b&lt;/code&gt; 인스턴스를 한 후 사용 &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa17a9e79c9dcc3ca39fe2b79ee583cccf33fc4" translate="yes" xml:space="preserve">
          <source>To use tracing, evaluate an expression with the &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command. For example, if we set a breakpoint on the base case of &lt;code&gt;qsort&lt;/code&gt;:</source>
          <target state="translated">추적을 사용하려면 &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; 명령으로 표현식을 평가하십시오 . 예를 들어 &lt;code&gt;qsort&lt;/code&gt; 의 기본 경우에 중단 점을 설정하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efc675a1383ace97e3c2b8987f540eb58b6ceef5" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the documentation of the valid hole fits in the output.</source>
          <target state="translated">유효한 구멍 맞춤의 문서를 출력에 표시할지 여부를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="332b4115b5fb01dc68e2b60acec1f7d2ed0f11c6" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the provenance of the valid hole fits in the output.</source>
          <target state="translated">출력에 유효한 구멍 맞춤의 출처를 표시할지 여부를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="a7f408bf113ca084f529db4badbce821ff390f15" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type application of the valid hole fits in the output.</source>
          <target state="translated">유효한 구멍 맞춤 유형을 출력에 표시할지 여부를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="2c4d22b7c838a1ecfb6276f53708bb0e679bc1f9" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the additional holes in refinement hole fits.</source>
          <target state="translated">구체화 구멍 맞춤에 추가 구멍의 유형을 표시할지 여부를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="04756312abbe3334230e9fe9c79fe06f08cf1ef4" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the valid hole fits in the output.</source>
          <target state="translated">출력에 유효한 구멍 유형을 표시할지 여부를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="f88544b7c345be9bc6286319d7234499cb7a2281" translate="yes" xml:space="preserve">
          <source>Toggles whether to show what type each quantified variable takes in a valid hole fit.</source>
          <target state="translated">각 정량화 된 변수가 유효한 구멍 맞춤에서 어떤 유형을 사용하는지 표시할지 여부를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="8d4022d64adedc28fae75a3f895c4e8da81cd40c" translate="yes" xml:space="preserve">
          <source>Token pretty-printing function.</source>
          <target state="translated">예쁜 인쇄 기능 토큰.</target>
        </trans-unit>
        <trans-unit id="daef2147e79571af8d5a4f376f29fb535295e66d" translate="yes" xml:space="preserve">
          <source>TokenParser</source>
          <target state="translated">TokenParser</target>
        </trans-unit>
        <trans-unit id="de9a588a8ad015eb8d4acc3d2eccb5cd88ff7637" translate="yes" xml:space="preserve">
          <source>Top-level declaration splices break up a source file into &lt;em&gt;declaration groups&lt;/em&gt;. A &lt;em&gt;declaration group&lt;/em&gt; is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. N.B. only top-level splices delimit declaration groups, not expression splices. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice.</source>
          <target state="translated">최상위 선언 스플 라이스는 소스 파일을 &lt;em&gt;선언 그룹&lt;/em&gt; 으로 나눕니다 . &lt;em&gt;선언 그룹은&lt;/em&gt; 최상위 선언 스플 라이스에 의해 만들어진 선언의 그룹입니다, 게다가 그 아래로, 그 다음 그러나 다음 최상위 선언 스플 라이스를 포함하지 않음. NB는 최상위 스플 라이스 만 선언 그룹을 구분하고 표현식 스플 라이스는 구분하지 않습니다. 모듈의 첫 번째 선언 그룹에는 첫 번째 최상위 선언 스플 라이스를 포함하지 않는 모든 최상위 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="64e70a05233381ae9b755ec9cdc13f4a77ee5cb1" translate="yes" xml:space="preserve">
          <source>Total CPU time (at the previous GC)</source>
          <target state="translated">총 CPU 시간 (이전 GC에서)</target>
        </trans-unit>
        <trans-unit id="8386f73231e1e92e73f6b519f210511ca9193151" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the GC</source>
          <target state="translated">GC에서 사용한 총 CPU 시간</target>
        </trans-unit>
        <trans-unit id="042e7e784ddb44e360a337daa72b2ae8ba023cf1" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the init phase @since 4.12.0.0</source>
          <target state="translated">초기화 단계 @since 4.12.0.0에서 사용한 총 CPU 시간</target>
        </trans-unit>
        <trans-unit id="d2dd5d438fb3dcc8fdc1f04bf55f6d2c501879d3" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the mutator</source>
          <target state="translated">뮤 테이터가 사용한 총 CPU 시간</target>
        </trans-unit>
        <trans-unit id="cd8f3ebd1cb51ba0810348d6c47b2fdc351d6519" translate="yes" xml:space="preserve">
          <source>Total amount of data copied during this GC</source>
          <target state="translated">이 GC 동안 복사 된 총 데이터 양</target>
        </trans-unit>
        <trans-unit id="9735e288f821d32fcba71a1a70c14b5cdc350199" translate="yes" xml:space="preserve">
          <source>Total amount of live data in compact regions</source>
          <target state="translated">컴팩트 한 지역의 총 라이브 데이터 양</target>
        </trans-unit>
        <trans-unit id="490b2f80ac8821885d90f86d57b7974bbf2682ad" translate="yes" xml:space="preserve">
          <source>Total amount of live data in large objects</source>
          <target state="translated">큰 객체의 총 라이브 데이터 양</target>
        </trans-unit>
        <trans-unit id="e6b177b175f265fd062fef05a1277c622c233454" translate="yes" xml:space="preserve">
          <source>Total amount of live data in the heap (incliudes large + compact data). Updated after every GC. Data in uncollected generations (in minor GCs) are considered live.</source>
          <target state="translated">힙에있는 총 라이브 데이터 양 (대용량 + 컴팩트 데이터 포함) 모든 GC 후에 업데이트됩니다. 수집되지 않은 세대 (소규모 GC)의 데이터는 실시간으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2439e747cf079533fc119f7f3372deeb2e6b3e0c" translate="yes" xml:space="preserve">
          <source>Total amount of memory in use by the RTS</source>
          <target state="translated">RTS에서 사용중인 총 메모리 양</target>
        </trans-unit>
        <trans-unit id="ae1cf3a5225a7fa4703cee57bd8a99cfbdc1fa37" translate="yes" xml:space="preserve">
          <source>Total amount of slop (wasted memory)</source>
          <target state="translated">총 슬로프 양 (메모리 낭비)</target>
        </trans-unit>
        <trans-unit id="381d3d3026564b15b98332086f85db8c9c5116c1" translate="yes" xml:space="preserve">
          <source>Total bytes allocated</source>
          <target state="translated">할당 된 총 바이트</target>
        </trans-unit>
        <trans-unit id="7ddb5932284e85cdb998a88ee61c45b3fb084550" translate="yes" xml:space="preserve">
          <source>Total elapsed time (at the previous GC)</source>
          <target state="translated">총 경과 시간 (이전 GC에서)</target>
        </trans-unit>
        <trans-unit id="5176bda3a891825313e991007cfcf6a2dfe321e1" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the GC</source>
          <target state="translated">GC에서 사용한 총 경과 시간</target>
        </trans-unit>
        <trans-unit id="a76b13b30e1f96d1561f8aba9418764cdf896ec9" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the init phase @since 4.12.0.0</source>
          <target state="translated">초기화 단계 @ 4.12.0.0에서 사용한 총 경과 시간</target>
        </trans-unit>
        <trans-unit id="f8dffa4e4bface78bbc47de7cc9c4f635615fd39" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the mutator</source>
          <target state="translated">뮤 테이터가 사용한 총 경과 시간</target>
        </trans-unit>
        <trans-unit id="c702e8f0d2bf491124a83b3aba7ca49be01b7437" translate="yes" xml:space="preserve">
          <source>Total number of GCs</source>
          <target state="translated">총 GC 수</target>
        </trans-unit>
        <trans-unit id="f31fc901ada0fd73f4d6d8746668c45f8b841486" translate="yes" xml:space="preserve">
          <source>Total number of major (oldest generation) GCs</source>
          <target state="translated">주요 (구세대) GC의 총 수</target>
        </trans-unit>
        <trans-unit id="5d0fb43e49fcfea4980958defc073241b65ca7be" translate="yes" xml:space="preserve">
          <source>Total width of the field.</source>
          <target state="translated">필드의 총 너비</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="26f445c1d8b2f4e101fdf56e72eb92189d409de2" translate="yes" xml:space="preserve">
          <source>Trace exhaustiveness checker</source>
          <target state="translated">철저한 철저 검사기</target>
        </trans-unit>
        <trans-unit id="8d94ec6e077733db6938cd196aa7260c918b123b" translate="yes" xml:space="preserve">
          <source>Trace interface files</source>
          <target state="translated">추적 인터페이스 파일</target>
        </trans-unit>
        <trans-unit id="fdbe7d47032190e46bbad6a5b35e468fcdd74e5e" translate="yes" xml:space="preserve">
          <source>Trace renamer</source>
          <target state="translated">추적 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="b6912fb740cfa5def4327273bd86af0baeb5f9b4" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference</source>
          <target state="translated">추적 런타임 유형 유추</target>
        </trans-unit>
        <trans-unit id="ea97ebbaf9290aacc9db9230d7d8410a1b17dde1" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference done by various interpreter commands.</source>
          <target state="translated">다양한 인터프리터 명령으로 수행되는 런타임 유형 유추를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="918226cc8c88c96d88772b200fb277ce2462c0b2" translate="yes" xml:space="preserve">
          <source>Trace typechecker</source>
          <target state="translated">추적 유형 검사기</target>
        </trans-unit>
        <trans-unit id="cac5cce622b33dcb41c89b31f1cab4a7d79e4ee1" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Mix</source>
          <target state="translated">Trace.Hpc.Mix</target>
        </trans-unit>
        <trans-unit id="4dc37d38ccb40ad731bd6b735a3d79a901047644" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Tix</source>
          <target state="translated">Trace.Hpc.Tix</target>
        </trans-unit>
        <trans-unit id="b9911dc4ca5e0e643713d12b25be14491d441daa" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Util</source>
          <target state="translated">Trace.Hpc.Util</target>
        </trans-unit>
        <trans-unit id="0ce5cee6755ef940551826d010c5c2ba3528d3db" translate="yes" xml:space="preserve">
          <source>TraceEventLog</source>
          <target state="translated">TraceEventLog</target>
        </trans-unit>
        <trans-unit id="8255bba6a712a935f53931169349c3bf3667e4e7" translate="yes" xml:space="preserve">
          <source>TraceFlags</source>
          <target state="translated">TraceFlags</target>
        </trans-unit>
        <trans-unit id="f45cd5da920597cccb919c43b85883e95c0eb5ba" translate="yes" xml:space="preserve">
          <source>TraceNone</source>
          <target state="translated">TraceNone</target>
        </trans-unit>
        <trans-unit id="95797df6040c41d1f62d4c30f5d575a3fde2b6e0" translate="yes" xml:space="preserve">
          <source>TraceStderr</source>
          <target state="translated">TraceStderr</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="ee76b0788bcc9e4d134c6e63c0f905595d53f415" translate="yes" xml:space="preserve">
          <source>Traditional record syntax, such as &lt;code&gt;C {f = x}&lt;/code&gt;, is enabled by default. To disable it, you can use the &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt;&lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">&lt;code&gt;C {f = x}&lt;/code&gt; 와 같은 기존 레코드 구문 은 기본적으로 사용됩니다. 비활성화하려면 &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt; &lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt; &lt;/a&gt; 확장을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e945a1a9931ffbae11e35d8dc13f62ffcd7e4996" translate="yes" xml:space="preserve">
          <source>TraditionalRecordSyntax</source>
          <target state="translated">TraditionalRecordSyntax</target>
        </trans-unit>
        <trans-unit id="07d54591052808d7665525ab9d03e9a8e6047941" translate="yes" xml:space="preserve">
          <source>Trailing slash functions</source>
          <target state="translated">후행 슬래시 기능</target>
        </trans-unit>
        <trans-unit id="5a701b108c7ddd010bd4e5e1046abd3e059fbfcd" translate="yes" xml:space="preserve">
          <source>Transactional variables.</source>
          <target state="translated">거래 변수.</target>
        </trans-unit>
        <trans-unit id="c6bd77f69d4cdf801791ad51b3a5613597cd452f" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">주어진 함수 ( &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; 전문화)를 사용하여 계산에 의해 발생 된 예외를 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="aefaf0cd8aa07449321af97629ce4b3770e62358" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">주어진 함수 ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; 전문화)를 사용하여 계산에 의해 발생 된 예외를 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="a4e682fcac2a4512b74e3dc63612d9586743f8e8" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 계산에 의해 발생 된 예외를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4578ae8d733586d0310337c8b520cee638a41571" translate="yes" xml:space="preserve">
          <source>Transform comprehensions</source>
          <target state="translated">이해력 향상</target>
        </trans-unit>
        <trans-unit id="6d9379f1a17e7f9d27b049266346529304db629e" translate="yes" xml:space="preserve">
          <source>Transform statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">(와 같은 문장을 변환 &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="34bbbf0593112d8021164739182249451cd348ed" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;MaybeT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MaybeT&lt;/code&gt; 안에서 계산을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e3add4bdcd20865c3718142bc9551385a370674" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;ReaderT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ReaderT&lt;/code&gt; 내부에서 계산을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="d94f891243caad66af3028997e36082e6d8dd8dc" translate="yes" xml:space="preserve">
          <source>Transform the value returned by a &lt;code&gt;Reader&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; 가 반환 한 값을 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="529ddea17b3a6fb911dfd08011006b0a6dba6150" translate="yes" xml:space="preserve">
          <source>TransformListComp</source>
          <target state="translated">TransformListComp</target>
        </trans-unit>
        <trans-unit id="28382f411cec0cea1fa0d72a330aaf42ace1a9fe" translate="yes" xml:space="preserve">
          <source>Transformation of at least one immediate subterm does not fail</source>
          <target state="translated">하나 이상의 즉각적인 하위 용어 변환이 실패하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6553c0c77ccd33d074aee1942550fc0f472cd3f4" translate="yes" xml:space="preserve">
          <source>Transformation of one immediate subterm with success</source>
          <target state="translated">하나의 즉각적인 하위 용어를 성공으로 변환</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="bc40fc64b9787d7dac7665e7c80ced3be2f64e6a" translate="yes" xml:space="preserve">
          <source>Transformer class</source>
          <target state="translated">변압기 등급</target>
        </trans-unit>
        <trans-unit id="12656556988bc57237e887a0b3bd66131be270a9" translate="yes" xml:space="preserve">
          <source>Transforming ByteStrings</source>
          <target state="translated">바이트 문자열 변환</target>
        </trans-unit>
        <trans-unit id="64733f4060672520e5c156055aa404b5a2fff0ad" translate="yes" xml:space="preserve">
          <source>Transforms a parser into one that does the same, but in addition returns the exact characters read. IMPORTANT NOTE: &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; gives a runtime error if its first argument is built using any occurrences of readS_to_P.</source>
          <target state="translated">파서를 동일한 작업으로 변환하지만, 읽은 정확한 문자를 반환합니다. 중요 참고 : 첫 번째 인수가 readS_to_P를 사용하여 빌드되면 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; 는 런타임 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8f321ea579e546977788ec7503fb201f9808151b" translate="yes" xml:space="preserve">
          <source>Transitional module providing the &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; class and primitive instances.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 클래스 및 기본 인스턴스를 제공하는 전환 모듈 .</target>
        </trans-unit>
        <trans-unit id="cf6c281c3321c220a2860f225e26547c6663a008" translate="yes" xml:space="preserve">
          <source>Transitivity</source>
          <target state="translated">Transitivity</target>
        </trans-unit>
        <trans-unit id="7bd7baf126db335320e85434af814c47329f4fb9" translate="yes" xml:space="preserve">
          <source>Transitivity of equality</source>
          <target state="translated">평등의 전이성</target>
        </trans-unit>
        <trans-unit id="ee21a36234c54ae6acecacce32dde8221553c2ab" translate="yes" xml:space="preserve">
          <source>Transitivity of representational equality</source>
          <target state="translated">표현 평등의 전이성</target>
        </trans-unit>
        <trans-unit id="e98e003d090d824a54f132e10d2d3a1b2abb08a4" translate="yes" xml:space="preserve">
          <source>TransliterateCodingFailure</source>
          <target state="translated">TransliterateCodingFailure</target>
        </trans-unit>
        <trans-unit id="9dcc95f8a9883fb6fa511276e0d2f0bd822f6472" translate="yes" xml:space="preserve">
          <source>TransmitStart</source>
          <target state="translated">TransmitStart</target>
        </trans-unit>
        <trans-unit id="d2cf87c31932f3da157ec8f3b86b864b9e7f88fd" translate="yes" xml:space="preserve">
          <source>TransmitStop</source>
          <target state="translated">TransmitStop</target>
        </trans-unit>
        <trans-unit id="59ababde52e8e86da31349f66a50ec3bb7819a93" translate="yes" xml:space="preserve">
          <source>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt; for more about GHCi&amp;rsquo;s debugging facilities. See also: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">역사에서 ⟨n⟩ 걸음 여행. ⟨n⟩는 생략하면 하나입니다. GHCi의 디버깅 기능에 대한 자세한 내용은 &lt;a href=&quot;#tracing&quot;&gt;추적 및 기록&lt;/a&gt; 을 참조하십시오 . : &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b795f17232474b10e4eb05eb081a307e9d9dfa5d" translate="yes" xml:space="preserve">
          <source>Traversable</source>
          <target state="translated">Traversable</target>
        </trans-unit>
        <trans-unit id="9c8ab9d8f52e3cebde865983061e92e1572d8906" translate="yes" xml:space="preserve">
          <source>Traversal</source>
          <target state="translated">Traversal</target>
        </trans-unit>
        <trans-unit id="7b1817a217845dfc3e24c8c230b82767b4c56356" translate="yes" xml:space="preserve">
          <source>Traverse from right to left.</source>
          <target state="translated">오른쪽에서 왼쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="977ae6d655ca9f1978129e8ccbfa10a6559b3561" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="5e48e3b92b1820252cbfde816e12e1a271b17cb1" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b18e053b42f93b44a5abf294af55c3136c4f408d" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7200db17563eaefb9847d8db2d6e8155f2a4676c" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d03af00b13b95140684e72553fba4a01106b42c9" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가없는 항목을 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="30dc152103c6133db322f634f929327d30f349a1" translate="yes" xml:space="preserve">
          <source>Traverses in order of increasing key.</source>
          <target state="translated">키 증가 순서로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7e92b229a11c1c4e925555ecc443d546f7203f39" translate="yes" xml:space="preserve">
          <source>Treat &lt;code&gt;*&lt;/code&gt; as &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 으로 취급하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd46d6f300df9c79faeae4e756e06e57fe755cd8" translate="yes" xml:space="preserve">
          <source>Treat the unqualified uses of the &lt;code&gt;*&lt;/code&gt; type operator as nullary and desugar to &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 유형 연산자 의 규정되지 않은 사용을 nullary로 취급하고 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 에 대한 설탕을 제거 하십시오 .</target>
        </trans-unit>
        <trans-unit id="99f5ff6378a0b48f815677894306b090ee036726" translate="yes" xml:space="preserve">
          <source>Tree</source>
          <target state="translated">Tree</target>
        </trans-unit>
        <trans-unit id="1e7081d736f43ad30574ac906d26acdd03c38ed9" translate="yes" xml:space="preserve">
          <source>Trees</source>
          <target state="translated">Trees</target>
        </trans-unit>
        <trans-unit id="d6ebaccbb7b2994140dcf46fc8cbd5a71b52292c" translate="yes" xml:space="preserve">
          <source>Trees and Forests</source>
          <target state="translated">나무와 숲</target>
        </trans-unit>
        <trans-unit id="d1f88855d73f9050543090a479c62b476a835f18" translate="yes" xml:space="preserve">
          <source>Tried to encode a character that could not be represented under the given encoding, or ran out of input in mid-encode.</source>
          <target state="translated">주어진 인코딩으로 표현할 수 없거나 미드 인코딩으로 입력이 부족한 문자를 인코딩하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="dcf41f4658aee61513347d3d72256ba068f1cb3d" translate="yes" xml:space="preserve">
          <source>Tries to find the definition site of the name at the given source-code span, e.g.:</source>
          <target state="translated">주어진 소스 코드 범위에서 이름의 정의 사이트를 찾으려고 시도합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="6d6761d1d070e2158059fdae1344762916cfe5cd" translate="yes" xml:space="preserve">
          <source>Triggers an immediate major garbage collection.</source>
          <target state="translated">즉시 주요 가비지 수집을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="5211c258ae504b8bbd5a65143e1ffaccbfaf5d21" translate="yes" xml:space="preserve">
          <source>Triggers an immediate minor garbage collection.</source>
          <target state="translated">즉시 사소한 가비지 수집을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="97bfbacf53c224ce01bb87815c2b91e603df8ea4" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions and related functions.</source>
          <target state="translated">삼각법 및 쌍곡선 함수 및 관련 함수</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="6842273367fb0a7314d3db77e80a4246de4d0209" translate="yes" xml:space="preserve">
          <source>True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;compact all the time&quot;</source>
          <target state="translated">True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;항상 컴팩트&quot;</target>
        </trans-unit>
        <trans-unit id="ff0a01862c74c77c6757cf7463f92a3698aca6ec" translate="yes" xml:space="preserve">
          <source>Truncate the destination file and then copy the contents of the source file to the destination file. If the destination file already exists, its attributes shall remain unchanged. Otherwise, its attributes are reset to the defaults.</source>
          <target state="translated">대상 파일을 자른 다음 소스 파일의 내용을 대상 파일로 복사하십시오. 대상 파일이 이미 존재하는 경우 해당 속성은 변경되지 않습니다. 그렇지 않으면 해당 속성이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b645724bb0724739a37a0f389e05496a29a993a0" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; to least-significant &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 가장 중요하지 않은 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="a4191815c130347968d06550006d8bef069d5483" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Double#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Double#&lt;/code&gt; 값을 가장 가까운 &lt;code&gt;Int#&lt;/code&gt; 로 자릅니다 . 잘림 인 경우 잘림이 &lt;code&gt;Int#&lt;/code&gt; 범위 밖의 값을 생성하면 잘림이 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f6d495ffdebdce795d559dc7a00814f02a9ed4a" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Float#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Float#&lt;/code&gt; 값을 가장 가까운 &lt;code&gt;Int#&lt;/code&gt; 로 자릅니다 . 잘림 인 경우 잘림이 &lt;code&gt;Int#&lt;/code&gt; 범위 밖의 값을 생성하면 잘림이 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c24171999adb97c4a8f884ec45a305760feb8353" translate="yes" xml:space="preserve">
          <source>Truncates the file down to the specified length. If the file was larger than the given length before this operation was performed the extra is lost.</source>
          <target state="translated">파일을 지정된 길이로 자릅니다. 이 작업을 수행하기 전에 파일이 지정된 길이보다 길면 추가 파일이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="e5062783e7bc3741e7a3f6f2e923c1f2ca0f5891" translate="yes" xml:space="preserve">
          <source>Trust the used plugins and no longer mark the compiled module as unsafe</source>
          <target state="translated">사용 된 플러그인을 신뢰하고 더 이상 컴파일 된 모듈을 안전하지 않은 것으로 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bc4bdf5385df47149206feaa36c849748d83b64" translate="yes" xml:space="preserve">
          <source>Trustworthy</source>
          <target state="translated">Trustworthy</target>
        </trans-unit>
        <trans-unit id="c3d3c6266583689c8044755f6755946b22e2e727" translate="yes" xml:space="preserve">
          <source>Try alternatives in the same order as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 와 같은 순서로 대안을 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="649615639f9b9c6ba5bc23c5c62fdf483263edda" translate="yes" xml:space="preserve">
          <source>Try downcasting &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; value. Returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if value doesn't fit in &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 값으로 다운 캐스트하십시오 . value가 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에 맞지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9f32a8bcb3ae56ab6fee54ca560a7075df79e35e" translate="yes" xml:space="preserve">
          <source>Try to use local disks when linking:</source>
          <target state="translated">연결할 때 로컬 디스크를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="42e43b612a5dfae57ddf5929f0fb945ae83cbf61" translate="yes" xml:space="preserve">
          <source>Tuesday</source>
          <target state="translated">Tuesday</target>
        </trans-unit>
        <trans-unit id="0fae6c283b56ecb589a1f52cbd69ed8461516cd4" translate="yes" xml:space="preserve">
          <source>Tuple data constructor</source>
          <target state="translated">튜플 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="fe995f3be3d2ff04b4539a5c33f7f5265c5ec905" translate="yes" xml:space="preserve">
          <source>Tuple type constructor</source>
          <target state="translated">튜플 타입 생성자</target>
        </trans-unit>
        <trans-unit id="f3571e8acb567c55596ec89e11c3c7590fcd1efb" translate="yes" xml:space="preserve">
          <source>Tuple types. When a non-unit tuple is used on the right-hand side of a data declaration, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; treats it as a product of distinct types. In other words, the following code:</source>
          <target state="translated">튜플 타입. 데이터 선언의 오른쪽에 비 단위 튜플이 사용되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 는이를 고유 한 유형의 곱으로 취급합니다. 즉, 다음 코드는</target>
        </trans-unit>
        <trans-unit id="07bc188bc9976952fc0cc95ef067281f658cb805" translate="yes" xml:space="preserve">
          <source>TupleSections</source>
          <target state="translated">TupleSections</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="0090b6abe499cb5c3a21cf4b91f82b1dc060fb8b" translate="yes" xml:space="preserve">
          <source>Tuples are currently limited to size 100. However, standard instances for tuples (&lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;) are available &lt;em&gt;only&lt;/em&gt; up to 16-tuples.</source>
          <target state="translated">튜플은 현재 크기가 100으로 제한되어 있습니다. 그러나 튜플의 표준 인스턴스 ( &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; )는 최대 16 개의 튜플 &lt;em&gt;만&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb72a46d788e7aaf184a3a1b039183884ebc8ddf" translate="yes" xml:space="preserve">
          <source>Tuples, all of whose component types have kind &lt;code&gt;Constraint&lt;/code&gt;. So for example the type &lt;code&gt;(Show a, Ord a)&lt;/code&gt; is of kind &lt;code&gt;Constraint&lt;/code&gt;.</source>
          <target state="translated">구성 요소 유형이 모두 &lt;code&gt;Constraint&lt;/code&gt; 인 튜플 . 예를 들어 &lt;code&gt;(Show a, Ord a)&lt;/code&gt; 유형은 &lt;code&gt;Constraint&lt;/code&gt; 종류 입니다.</target>
        </trans-unit>
        <trans-unit id="208297b00f068e5585208c000785f0fce4f36c23" translate="yes" xml:space="preserve">
          <source>Tuples, lists, &lt;code&gt;Maybe&lt;/code&gt;, and all the other types from &lt;code&gt;Prelude&lt;/code&gt; continue to have their existing, lazy, semantics.</source>
          <target state="translated">&lt;code&gt;Prelude&lt;/code&gt; 의 튜플, 목록, &lt;code&gt;Maybe&lt;/code&gt; 및 기타 모든 유형 에는 계속 기존의 게으른 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="253a3d85a1beb3288a473dc352f001b3960133ba" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; &amp;ldquo;update-frame squeezing&amp;rdquo; at garbage-collection time. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">돌려 &lt;em&gt;오프&lt;/em&gt; 가비지 수집 시간에 &quot;업데이트 프레임 짜내을&quot;. (썽크 항목 수와 관련하여 수집 된 특정 데이터의 정확성을 보장하는 경우를 제외하고는이를 해제 할 특별한 이유가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="275633f17b4e4cf83d036cacf3592d3d73e3ed05" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; update frame squeezing on context switch. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">돌려 &lt;em&gt;오프&lt;/em&gt; 컨텍스트 스위치에 업데이트 프레임 짜내합니다. (청크 항목 수와 관련하여 수집 된 특정 데이터의 정확성을 보장하는 것을 제외하고는 끄는 특별한 이유가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="46ed6208974a650db0bd1f82cc0c70d6411a0c0e" translate="yes" xml:space="preserve">
          <source>Turn a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; into its initial &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">차례 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 초기에 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="99920f5c3b939caebceea45731d8b9d3427458f2" translate="yes" xml:space="preserve">
          <source>Turn a value into a Template Haskell expression, suitable for use in a splice.</source>
          <target state="translated">스플 라이스에 사용하기에 적합한 값을 Template Haskell 식으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="18c10b159949d028b9e59ba53a57b08c8fed29bf" translate="yes" xml:space="preserve">
          <source>Turn an existing Handle into a file descriptor. This function throws an IOError if the Handle does not reference a file descriptor.</source>
          <target state="translated">기존 핸들을 파일 설명 자로 바꿉니다. Handle이 파일 설명자를 참조하지 않으면이 함수는 IOError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ff88efd554e6e2bbf0d6b57ed109bd14bff32a19" translate="yes" xml:space="preserve">
          <source>Turn an existing file descriptor into a Handle. This is used by various external libraries to make Handles.</source>
          <target state="translated">기존 파일 디스크립터를 핸들로 바꿉니다. 이것은 다양한 외부 라이브러리에서 핸들을 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af1ea6cee0d8a6d561bf79d4ae3fe34c934b40bb" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining</source>
          <target state="translated">사전 인라인 끄기</target>
        </trans-unit>
        <trans-unit id="d635f6906b908f74109d28ae4ecba3d5b4cf43a2" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining.</source>
          <target state="translated">사전 인라인을 끕니다.</target>
        </trans-unit>
        <trans-unit id="17471888502443f29d90093ff7b1d13417c48663" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking (which is on by default). Recompilation checking normally stops compilation early, leaving an existing &lt;code&gt;.o&lt;/code&gt; file in place, if it can be determined that the module does not need to be recompiled.</source>
          <target state="translated">재 컴파일 검사를 해제합니다 (기본적으로 켜져 있음). 재 컴파일 검사 는 모듈을 다시 컴파일 할 필요가 없다고 판단 될 경우 기존 &lt;code&gt;.o&lt;/code&gt; 파일을 그대로두고 컴파일을 일찍 중지 합니다.</target>
        </trans-unit>
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">재 컴파일 검사를 끕니다. 이것은 단일 파일을 컴파일 할 때 (즉, &lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; 를&lt;/a&gt; 사용할 때) &lt;code&gt;-ddump-X&lt;/code&gt; 옵션에 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">인수로 &lt;code&gt;State#&lt;/code&gt; 토큰 이있는 모든 람다 는 단일 항목으로 간주되므로 내부 항목을 인라인하는 것으로 간주 되는 &quot;state hack&quot;을 끄십시오 . 이는 IO 및 ST 모나드 코드의 성능을 향상시킬 수 있지만 공유를 줄일 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">강제 옵티 마이저 끄기</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">강제 옵티 마이저를 끕니다.</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">인수로 간주되는 실제 상태 토큰이있는 람다는 단일 항목으로 간주되는 상태 핵을 끄십시오. 따라서 내부의 내용을 인라인해도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;열성적인 블랙홀 링&lt;/a&gt; 켜기</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">수요 분석가에서 CPR 분석을 켭니다.</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수요 분석가에서 CPR 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">Haskell 프로그램 적용 범위 계측 켜기</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">통화 패턴 전문화를 켭니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Haskell 프로그램의 콜 패턴 전문화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">디버그 인쇄 켜기 (보다 자세한 정보)</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게으름을 완전히 켭니다 (유동 바인딩을 바깥쪽으로). &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">코어 수준에서 GHC 내에서 헤비급 인트라 패스 위생 검사를 켭니다. (그것은 당신의 GHC의 정신 상태를 검사합니다.)</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">내부 위생 검사 켜기</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">GHCi에서 제본 결과 인쇄 켜기</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">프로파일 링 켜기</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">다른 모듈에서 가져온 오버로드 된 기능의 특수화를 켭니다.</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">펼칠 수있는 경우 크기에 관계없이 오버로드 된 기능의 전문화</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 기능의 전문화를 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="186b5bba16e6ae8eb15a9abb5dd5b71128ae5773" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt;&lt;code&gt;-fworker-wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">엄격 성 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt; &lt;code&gt;-fworker-wrapper&lt;/code&gt; 를&lt;/a&gt; 의미합니다.</target>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">엄격 성 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;code&gt;-fworker-wrapper&lt;/code&gt; 를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SpecConstr 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">float-in 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자유 사례 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">자유 사례 변환을 켭니다. 이것은 자유 변수의 반복적 인 사례 분석을 피하기 위해 자체 RHS에서 재귀 함수를 한 번 풀어줍니다. 콜 패턴 스페셜 &lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt; ( -fspec-constr )와 비슷하지만 인수가 아닌 자유 변수입니다.</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">정적 인수 변환을 켜면 재귀 함수가 로컬 재귀 루프가있는 비 재귀 함수로 바뀝니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos의 PhD 논문&lt;/a&gt; 7 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">정적 인수 변환을 켜십시오.</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">까다로운 프로파일 링 켜기</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성 된 어셈블리에서 포화 자체 재귀 테일 콜을 로컬 점프로 전환합니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">유형 오류를 경고로 바꾸고 &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;런타임까지 오류를 연기하십시오&lt;/a&gt; . 의미 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; . 참조 &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">특수 구문을 활성화하는 옵션을 설정하면 예약 된 단어가 된 변수 이름을 사용하기 때문에 Haskell 98 코드 작업이 컴파일되지 않을 &lt;em&gt;수&lt;/em&gt; 있습니다. 이 섹션에는 언어 확장에 의해 &quot;도난 된&quot;구문이 나열되어 있습니다. 우리는 Haskell 98 어휘 구문에서 표기법과 비 터미널 이름을 사용합니다 (Haskell 98 보고서 참조). 여기에는 기존 작업 프로그램에 영향을 줄 수있는 구문 변경 사항 만 나열됩니다 (예 : &quot;도난&quot;구문). 이러한 확장 중 상당수는 새로운 컨텍스트 프리 구문도 사용할 수 있지만 모든 경우에 새 구문을 사용하도록 작성된 프로그램은 옵션을 사용하지 않으면 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">패턴을 반박 할 수없는 패턴으로 바꾸려면 &lt;code&gt;Strict&lt;/code&gt; 가 활성화 된 경우 &lt;code&gt;~(~p)&lt;/code&gt; 또는 &lt;code&gt;(~ ~p)&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">모나드 연산으로 지정된 종료자를 참조와 연결하여 일반 메모리 참조를 외부 객체로 변환합니다. 스토리지 관리자는 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 대한 마지막 참조 가 삭제 된 후 얼마 후에 별도의 스레드에서 종료자를 시작합니다 . 신속 함을 보장 할 수 없으며 실제로 최종자가 결국 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">모나드 연산으로 지정된 종료자를 참조와 연결하여 일반 메모리 참조를 외부 객체로 변환합니다. 스토리지 관리자는 &lt;code&gt;ForeignPtr&lt;/code&gt; 에 대한 마지막 참조 가 삭제 된 후 얼마 후에 별도의 스레드에서 종료자를 시작합니다 . 신속 함을 보장 할 수 없으며 실제로 최종자가 결국 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">일반 메모리 참조를 외부 포인터로 변환하고 종료자를 참조와 연관시킵니다. 외부 객체에 대한 마지막 참조가 삭제 된 후 종료자가 실행됩니다. 프롬프트가 보장되지는 않지만 프로그램이 종료되기 전에 종료자가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">모든 텍스트 속성을 끕니다. 이 기능은 항상 성공하지만 텍스트 속성을 지원하지 않는 터미널에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">표준 경고 및 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; 에서 사용&lt;/a&gt; 하지 않는 경고를 포함하여 모든 경고를 끕니다 .</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">의심스러운 코드를 나타내는 모든 경고 옵션을 설정합니다. &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; 에 의해 활성화 &lt;em&gt;되지 않은&lt;/em&gt; 경고 는</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">주어진 텍스트를 출력하기 전에 굵게 모드를 켠 다음 모든 속성을 끕니다.</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">컴파일러가 지원하는 모든 단일 경고를 켭니다.</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">지정된 텍스트를 출력하기 전에 스탠드 아웃 모드를 켠 다음 끕니다.</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">주어진 텍스트를 출력하기 전에 밑줄 모드를 켠 다음 끕니다.</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">향후 기본적으로 활성화 될 예정인 경고를 설정하지만 당분간은 정상적인 컴파일 상태를 유지하지 않습니다. 이를 통해 라이브러리 작성자는 경고를 생성하기 전에 새로운 기능에 적응할 수 있도록 향후 코드를 호환 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">두 가지 명령 줄 옵션은 시작 파일 파일을 읽을 지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">주의해야 할 두 가지 :</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">가능한 모든 대체에 대해 유형이 공통 리 덕트로 환원 될 수없는 경우 두 유형이 분리 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">두 가지 유형의 메시지가 생성됩니다. &lt;code&gt;***&lt;/code&gt; 로 시작하는 메시지는 컴파일 단계의 시작을 나타내는 반면 &lt;code&gt;!!!&lt;/code&gt; 로 시작하는 메시지는 !!! 패스의 끝을 표시하고 할당 및 런타임 통계를 동반합니다.</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">문자 리터럴</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">인수 이름이 중요하지 않은 경우 유형 인수를 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 바꿀 수 있습니다 . 이것은 고유 한 이름으로 유형 변수를 작성하는 것과 같습니다. &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그가 사용 가능한 경우 경고를 피하기 위해 사용하지 않는 유형 인수를 밑줄로 대체하거나 접 두부를 붙일 수 있습니다 . &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 과 동일한 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">유형 검사기는 구멍에 대해 유추 된 유형을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">I / O 제공자를위한 유형 클래스.</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 같이 자체 확장을 파생시켜야하는 유형 클래스 ( &lt;a href=&quot;#deriving-extra&quot;&gt;추가 클래스의 인스턴스 파생 (데이터 등) 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="926bf298afdb2d507c3bd7a1413520e17a01edb6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 같이 자체 확장을 활성화해야하는 유형 클래스 ( &lt;a href=&quot;#deriving-extra&quot;&gt;예 : 추가 클래스 (데이터 등)의 파생 인스턴스&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt; - all 과 관련된 유형에 적용된 형식 생성자 ( ImpredicativeTypes 가 해제 된 경우)</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">타입 생성자</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">타입 생성자와 클래스; 하스켈은 현재 같은 이름 공간에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4cb9160c66acee90d4523d170727eb5eabf6f68" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. #14605).</source>
          <target state="translated">forall 아래의 형식 평등은 연기 할 수 없습니다 (# 14605 참조).</target>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">forall 아래의 유형 평등은 연기 될 수 없습니다 (참조 Trac # 14605).</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">유형 평등</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">유형 패밀리는 세 가지 맛으로 나타납니다. 연관된 유형 동의어라고합니다). 최상위 색인 패밀리는 유형 색인이 클래스 매개 변수와 일치하지 않아도되므로보다 일반적입니다. 그러나 일부 유형 인스턴스가 실수로 생략 된 경우 연관된 유형 동의어가보다 명확하게 구조화 된 코드 및 컴파일러 경고를 유발할 수 있습니다. 다음에서 우리는 항상 일반 최상위 양식을 먼저 논의한 다음 관련 유형에 대한 추가 제약 조건을 다룹니다. 닫힌 연관된 유형 동의어가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">언어 패밀리는 &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; 언어 확장으로 활성화됩니다 . GHC에서 유형 군 사용에 대한 추가 정보는 유형 군에 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;관한 Haskell 위키 페이지에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">유형 패밀리는 인스턴스 헤드의 규칙에 대한 규칙을 확장해야 &lt;a href=&quot;#flexible-instance-head&quot;&gt;하며, 인스턴스 헤드의 완화 규칙에 나와&lt;/a&gt; 있습니다. 구체적으로 특별히:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
