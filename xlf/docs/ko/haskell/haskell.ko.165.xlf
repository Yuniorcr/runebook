<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0f31095d17e6be1b28728b97a802ce50d67ad701" translate="yes" xml:space="preserve">
          <source>The WriterT monad transformer</source>
          <target state="translated">WriterT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="5e770d7fbf72d91df1534aadfbf35eb816e6cdd8" translate="yes" xml:space="preserve">
          <source>The a &lt;code&gt;pat &amp;lt;- u&lt;/code&gt; statement uses &lt;code&gt;M.fail&lt;/code&gt; for the failing case, if such a case is needed</source>
          <target state="translated">a &lt;code&gt;pat &amp;lt;- u&lt;/code&gt; 문은 그러한 경우가 필요한 경우 실패한 경우에 &lt;code&gt;M.fail&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="e564641fef849b7748c52b9e3bbf79b098ce5698" translate="yes" xml:space="preserve">
          <source>The ability to &lt;em&gt;inherit&lt;/em&gt; required signatures from packages we depend upon, combining the signatures into a single merged signature which reflects the requirements of any locally defined signature, as well as the requirements of our dependencies.</source>
          <target state="translated">우리가 의존하는 패키지에서 필요한 서명 을 &lt;em&gt;상속&lt;/em&gt; 하고 서명을 로컬로 정의 된 서명의 요구 사항과 종속성의 요구 사항을 반영하는 단일 병합 된 서명으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="7dbeb7f19d92db3db611e99643a65e9afeeb3443" translate="yes" xml:space="preserve">
          <source>The ability to define an &lt;code&gt;hsig&lt;/code&gt; file, containing type definitions and type signature for values which can be used by modules that import the signature, and must be provided by the eventual implementing module, and</source>
          <target state="translated">서명을 가져 오는 모듈에서 사용할 수 있고 최종 구현 모듈에서 제공해야하는 값에 대한 형식 정의 및 형식 서명을 포함 하는 &lt;code&gt;hsig&lt;/code&gt; 파일 을 정의하는 기능</target>
        </trans-unit>
        <trans-unit id="e18a26f623d4b3d5b0afaeca9ff88864b2448314" translate="yes" xml:space="preserve">
          <source>The ability to set a breakpoint on a function definition or expression in the program. When the function is called, or the expression evaluated, GHCi suspends execution and returns to the prompt, where you can inspect the values of local variables before continuing with the execution.</source>
          <target state="translated">프로그램에서 함수 정의 또는 표현식에 중단 점을 설정하는 기능 함수가 호출되거나 표현식이 평가되면 GHCi는 실행을 일시 중단하고 프롬프트로 돌아가며, 여기서 실행을 계속하기 전에 로컬 변수의 값을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="310f755673bc29e8cd19bd1e50c2672bd0ba64a5" translate="yes" xml:space="preserve">
          <source>The above code is equivalent to:</source>
          <target state="translated">위 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ceb853b961139ea8a430dce957f73b5c77a03245" translate="yes" xml:space="preserve">
          <source>The above declaration (which requires the language pragma &lt;code&gt;DeriveGeneric&lt;/code&gt;) causes the following representation to be generated:</source>
          <target state="translated">위의 선언 (언어 pragma &lt;code&gt;DeriveGeneric&lt;/code&gt; 필요 )으로 인해 다음과 같은 표현이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="124bdbaef2420b9e89592fec3e57e81f0de35ec8" translate="yes" xml:space="preserve">
          <source>The above declaration causes the following representation to be generated:</source>
          <target state="translated">위의 선언으로 다음과 같은 표현이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f76366168215856429247956c4826993833306ed" translate="yes" xml:space="preserve">
          <source>The above definition of trust has an issue. Any module can be compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and it will be trusted. To control this, there is an additional definition of package trust (enabled with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag). The point of package trust is to require that the client C explicitly say which packages are allowed to contain trustworthy modules. Trustworthy packages are only trusted if they reside in a package trusted by C.</source>
          <target state="translated">위의 신뢰 정의에는 문제가 있습니다. 모든 모듈은 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 것으로 컴파일 할 수 있으며 신뢰할 수 있습니다. 이를 제어하기 위해 패키지 신뢰에 대한 추가 정의가 있습니다 ( &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그로 사용 가능). 패키지 신뢰의 요점은 클라이언트 C가 어떤 패키지가 신뢰 가능한 모듈을 포함 할 수 있는지 명시 적으로 말하도록 요구하는 것입니다. 신뢰할 수있는 패키지는 C에서 신뢰할 수있는 패키지에있는 경우에만 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="323fd637be514c92181134fb16d4c774e53e4b7b" translate="yes" xml:space="preserve">
          <source>The above definitions sequence the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; effects of &lt;strong&gt;&lt;code&gt;F&lt;/code&gt;&lt;/strong&gt; in the expected order while producing results of the expected shape &lt;strong&gt;&lt;code&gt;T&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">위의 정의 는 예상되는 모양 &lt;strong&gt; &lt;code&gt;T&lt;/code&gt; 의&lt;/strong&gt; 결과를 생성하면서 예상되는 순서 로 &lt;strong&gt; &lt;code&gt;F&lt;/code&gt; &lt;/strong&gt; 의 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 효과를 순서대로 나열 합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dec694c0ea578b50a9bf51f9360afaba3fc6e523" translate="yes" xml:space="preserve">
          <source>The above example is somewhat contrived, some structures keep track of their length internally, and can return it in \(\mathcal{O}(1)\) time, so this particular recipe for averages is not always the most efficient. In general, composite aggregate functions of large structures benefit from single-pass reduction. This is especially the case when reuse of a list and memoisation of its elements is thereby avoided,</source>
          <target state="translated">위의 예는 다소 인위적이며, 일부 구조는 내부적으로 길이를 추적하고 \ (\ mathcal {O} (1) \) 시간에이를 반환 할 수 있으므로이 특정 평균 레시피가 항상 가장 효율적인 것은 아닙니다. 일반적으로 대형 구조의 복합 집계 함수는 단일 패스 감소의 이점을 얻습니다. 이것은 특히 목록의 재사용과 그 요소의 메모 화를 피할 때 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="2df7fb2c193365ff646472a721e6b7dbe5bf63ae" translate="yes" xml:space="preserve">
          <source>The above function takes a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; supposed to represent Base64 encoded data and the current decoding state. It writes the decoded bytes as the side-effect of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and returns the new decoding state, if the decoding of all data in the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; was successful. The checking if the strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; represents Base64 encoded data and the actual decoding are fused. This makes the common case, where all data represents Base64 encoded data, more efficient. It also implies that all data must be decoded before the final decoding state can be returned. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are intended for implementing such fused checking and decoding/encoding, which is reflected in their strictness properties.</source>
          <target state="translated">위 함수는 Base64로 인코딩 된 데이터와 현재 디코딩 상태를 나타내는 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 사용합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 모든 데이터 디코딩에 성공한 경우 디코딩 된 바이트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 의 부작용으로 쓰고 새 디코딩 상태를 반환합니다 . 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 Base64로 인코딩 된 데이터를 나타내는 지 확인 하고 실제 디코딩은 통합됩니다. 모든 데이터가 Base64로 인코딩 된 데이터를 나타내는 일반적인 경우가 더 효율적입니다. 또한 최종 디코딩 상태가 반환되기 전에 모든 데이터를 디코딩해야 함을 의미합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 은 이러한 융합 검사 및 디코딩 / 인코딩을 구현하기 위해 고안되었으며, 이는 엄격 성 속성에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="0308489ed1646a7d427f7b348942d76c9c0d5d69" translate="yes" xml:space="preserve">
          <source>The above informal specification is fine for simple situations, but matters can get complicated. In particular, it needs to be clear exactly when a key dies, so that any weak pointers that refer to it can be finalized. Suppose, for example, the value of one weak pointer refers to the key of another...does that keep the key alive?</source>
          <target state="translated">위의 비공식 사양은 간단한 상황에는 적합하지만 문제가 복잡해질 수 있습니다. 특히, 키가 죽었을 때이를 명확하게해야 키를 가리키는 약한 포인터를 완성 할 수 있습니다. 예를 들어, 한 약한 포인터의 값이 다른 약한 키를 참조한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="2361448fcf86f9607ed9aa3c2d047337ebd0125c" translate="yes" xml:space="preserve">
          <source>The above laws imply:</source>
          <target state="translated">위의 법률은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6121e60b6f07d4583d6a2f3988fc1fab1e503635" translate="yes" xml:space="preserve">
          <source>The above will parse a string like &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; and return a successful parse result &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt;. Compare against the below which will produce a result of &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; for the same input:</source>
          <target state="translated">위의 내용은 &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; 와 같은 문자열을 구문 분석하고 성공적인 구문 분석 결과 &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; 를 반환합니다 . 동일한 입력에 대해 &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; 결과를 생성하는 아래를 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="23defdad22c174ac934178c72dd4c87d6b200033" translate="yes" xml:space="preserve">
          <source>The absence of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; superclass allows &lt;code&gt;Foldable&lt;/code&gt; structures to impose constraints on their element types. Thus, Sets are &lt;code&gt;Foldable&lt;/code&gt;, even though &lt;code&gt;Set&lt;/code&gt; imposes an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; constraint on its elements (this precludes defining a &lt;code&gt;Functor&lt;/code&gt; instance for &lt;code&gt;Set&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 수퍼 클래스가 없으면 &lt;code&gt;Foldable&lt;/code&gt; 구조가 요소 유형에 제약을 부과 할 수 있습니다. 따라서 &lt;code&gt;Set&lt;/code&gt; 이 요소에 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 제약 조건을 적용 하더라도 Set 은 &lt;code&gt;Foldable&lt;/code&gt; 입니다 (이는 &lt;code&gt;Set&lt;/code&gt; 에 대한 &lt;code&gt;Functor&lt;/code&gt; 인스턴스 정의를 배제 함 ).</target>
        </trans-unit>
        <trans-unit id="20d7c122429fa587037c0b158d78237d0e61f8fb" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 형식 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) 및 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="a0dc001d398ba43af02553419233d88958cb5682" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position ( &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) of the error and a list of error messages ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</target>
        </trans-unit>
        <trans-unit id="7c5ad48cec60ebaef30194326effe275f0375cd5" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 유형 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; )와 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="2860dda2765620cbf0f468a55ba7b993da164fe3" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 형식 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) 및 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="a16390824d4b63d5b034583c35efee2fa442421d" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) of the error and a list of error messages ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</target>
        </trans-unit>
        <trans-unit id="0ce749bfeba3859cb92e96105471b0c372d6cc33" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 유형 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; )와 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="aab9864f2e792b8ac699847b4dbdbb4a77ea80ac" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 형식 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) 및 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="bcac48e5c098987927b81058fb32ab48d7f41565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) of the error and a list of error messages ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</target>
        </trans-unit>
        <trans-unit id="79760a03c9f8fbd365a75c46f4627b53be785882" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 유형 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; )와 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="510da1eb070dd00ee03ec16a47305698f8cacdd9" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 형식 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) 및 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="c0cae1d0e9d25bf84bec3f0ea7979ae65c16dd54" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ) of the error and a list of error messages ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</target>
        </trans-unit>
        <trans-unit id="30678695bca808cf542e9ee4a30521989c0fce7f" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">추상 데이터 유형 &lt;code&gt;ParseError&lt;/code&gt; 는 구문 분석 오류를 나타 냅니다. 오류 의 소스 위치 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; )와 오류 메시지 목록 ( &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; )을 제공합니다. &lt;code&gt;ParseError&lt;/code&gt; 는 함수에 의해 반환 될 수 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;ParseError&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="de0533afad3f79319b3bf4b1fcb91b9bbdbc0565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">추상 데이터 유형 &lt;code&gt;SourcePos&lt;/code&gt; 는 소스 위치를 나타냅니다. 여기에는 소스 이름 (예 : 파일 이름), 줄 번호 및 열 번호가 포함됩니다. &lt;code&gt;SourcePos&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="6a773f64dd31cf8cbcbf716ca186f3f80ceeb204" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</target>
        </trans-unit>
        <trans-unit id="5d3cbbc6884b3a86d41cf6dc62d48c159c2b95ad" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">추상 데이터 유형 &lt;code&gt;SourcePos&lt;/code&gt; 는 소스 위치를 나타냅니다. 여기에는 소스 이름 (예 : 파일 이름), 행 번호 및 열 번호가 포함됩니다. &lt;code&gt;SourcePos&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="4896de6a97029ad3c503ab35de30ebe552f9de1c" translate="yes" xml:space="preserve">
          <source>The abstract type of documents. A Doc represents a &lt;em&gt;set&lt;/em&gt; of layouts. A Doc with no occurrences of Union or NoDoc represents just one layout.</source>
          <target state="translated">추상적 유형의 문서. Doc은 &lt;em&gt;일련&lt;/em&gt; 의 레이아웃을 나타냅니다 . Union 또는 NoDoc이없는 Doc은 하나의 레이아웃 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a80b0e5c19c356bd9ef420910831b319cf81af79" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 조치 는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 출력을 위해 버퍼링 된 항목 이 운영 체제로 즉시 전송되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ee59ce1aebad5edf7e6e4aaef4677f21c7eefc31" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; flushes all buffered data in &lt;code&gt;hdl&lt;/code&gt;, including any buffered read data. Buffered read data is flushed by seeking the file position back to the point before the bufferred data was read, and hence only works if &lt;code&gt;hdl&lt;/code&gt; is seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 조치 는 버퍼링 된 읽기 데이터를 포함하여 &lt;code&gt;hdl&lt;/code&gt; 의 모든 버퍼링 된 데이터를 플러시합니다 . 버퍼링 된 읽기 데이터는 파일 위치를 버퍼링 된 데이터를 읽기 전에 다시 검색하여 플러시되므로 &lt;code&gt;hdl&lt;/code&gt; 을 검색 할 수있는 경우에만 작동합니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a371db2521146387741275550e657dffca505303" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">액션 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; 핸들의 텍스트 인코딩 변경 &lt;code&gt;hdl&lt;/code&gt; 로 &lt;code&gt;encoding&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 생성 될 때 기본 인코딩 은 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 즉, 현재 로캘의 기본 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="2e5909c7d1c1b470eac7ec2d2a3d5f1c7a3e6b23" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 조치 는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 출력을 위해 버퍼링 된 항목 이 운영 체제로 즉시 전송되도록합니다.</target>
        </trans-unit>
        <trans-unit id="30e8a3b807220ec41770ad1fcda8f8906a927d36" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 조치 는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 출력을 위해 버퍼링 된 항목 이 운영 체제로 즉시 전송되도록합니다.</target>
        </trans-unit>
        <trans-unit id="9c8d6d26b1ac4ce2c7a317b47737557b2e637055" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">액션 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; 핸들의 텍스트 인코딩 변경 &lt;code&gt;hdl&lt;/code&gt; 로 &lt;code&gt;encoding&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 생성 될 때 기본 인코딩 은 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 즉, 현재 로캘의 기본 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="576c394b164a6cc29cb4991bc6f5ba5ca7f6c771" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;g&lt;/code&gt; is called regardless of what occurs within &lt;code&gt;f&lt;/code&gt;, including async exceptions. Some monads allow &lt;code&gt;f&lt;/code&gt; to abort the computation via other effects than throwing an exception. For simplicity, we will consider aborting and throwing an exception to be two forms of &quot;throwing an error&quot;.</source>
          <target state="translated">액션 &lt;code&gt;g&lt;/code&gt; 는 비동기 예외를 포함하여 &lt;code&gt;f&lt;/code&gt; 내에서 발생하는 일에 관계없이 호출 됩니다. 일부 모나드는 &lt;code&gt;f&lt;/code&gt; 가 예외를 던지는 것 이외의 다른 효과를 통해 계산을 중단 하도록 허용 합니다. 단순화를 위해, 우리는 &quot;오류 던지기&quot;의 두 가지 형태로 예외를 중단하고 던지는 것을 고려할 것입니다.</target>
        </trans-unit>
        <trans-unit id="88ecb8776a874cfae1e583d670074ac14b0b3b9f" translate="yes" xml:space="preserve">
          <source>The action can handle the interrupt itself; a new &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; exception will be thrown every time Ctrl-C is pressed.</source>
          <target state="translated">이 작업은 인터럽트 자체를 처리 할 수 ​​있습니다. Ctrl-C를 누를 때마다 새로운 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c560f66ad19d0c44deb93f325922bbfa7a14cb7" translate="yes" xml:space="preserve">
          <source>The actions to perform when a signal is received.</source>
          <target state="translated">신호가 수신 될 때 수행 할 동작입니다.</target>
        </trans-unit>
        <trans-unit id="17c5e604d289acc48a4aeb8ca32b75ead60baded" translate="yes" xml:space="preserve">
          <source>The actual command line arguments (presumably got from &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">실제 명령 행 인수 (아마 &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 에서 가져옴 )</target>
        </trans-unit>
        <trans-unit id="51507a88f0049d4973537c6abea3ce2abf60b884" translate="yes" xml:space="preserve">
          <source>The actual meaning of the various columns in the output is:</source>
          <target state="translated">출력에서 다양한 열의 실제 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75d01a234516a40a70a8063deca25961c004f6c5" translate="yes" xml:space="preserve">
          <source>The additional module name (here &lt;code&gt;M&lt;/code&gt;) is called the qualifier of the do-expression.</source>
          <target state="translated">추가 모듈 이름 (여기서는 &lt;code&gt;M&lt;/code&gt; )을 do-expression의 규정 자라고합니다.</target>
        </trans-unit>
        <trans-unit id="8d600203b76ff6ccdd7956053fbe52659d549a35" translate="yes" xml:space="preserve">
          <source>The advantage of smaller stack chunks is that the garbage collector can avoid traversing stack chunks if they are known to be unmodified since the last collection, so reducing the chunk size means that the garbage collector can identify more stack as unmodified, and the GC overhead might be reduced. On the other hand, making stack chunks too small adds some overhead as there will be more overflow/underflow between chunks. The default setting of 32k appears to be a reasonable compromise in most cases.</source>
          <target state="translated">더 작은 스택 청크의 장점은 가비지 수집기가 마지막 수집 이후 수정되지 않은 것으로 알려진 경우 스택 청크 통과를 피할 수 있다는 것입니다. 따라서 청크 크기를 줄이면 가비지 수집기가 더 많은 스택을 수정되지 않은 것으로 식별 할 수 있으며 GC 오버 헤드가 발생할 수 있습니다. 줄어든다. 반면에 스택 청크를 너무 작게 만들면 청크간에 오버플로 / 언더 플로가 많아 지므로 약간의 오버 헤드가 발생합니다. 기본 설정 인 32k는 대부분의 경우 합리적인 타협으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="351839425c4046d1ef3e16ab0a651854e611c6da" translate="yes" xml:space="preserve">
          <source>The advantage of this is that the key can be retrieved by &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; in addition to the value.</source>
          <target state="translated">이것의 장점은 키 외에 값 외에 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 에 의해 키를 검색 할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="51801fd153e97264561ce8060f8815074cf0359c" translate="yes" xml:space="preserve">
          <source>The alarm timer</source>
          <target state="translated">알람 타이머</target>
        </trans-unit>
        <trans-unit id="e9de65a28b0e1c87c6c42bf35a90ef7382160962" translate="yes" xml:space="preserve">
          <source>The algebraic data types</source>
          <target state="translated">대수 데이터 유형</target>
        </trans-unit>
        <trans-unit id="af0e67390188169e10bce1a919bdd538300c70aa" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates definitions for &lt;code&gt;foldMap&lt;/code&gt;, &lt;code&gt;foldr&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not need to be folded over.</source>
          <target state="translated">위한 알고리즘 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; 는&lt;/a&gt; 로부터 적응 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 의&lt;/a&gt; 알고리즘이지만에 대한 정의가 생성 &lt;code&gt;foldMap&lt;/code&gt; , &lt;code&gt;foldr&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 대신 &lt;code&gt;fmap&lt;/code&gt; 함수 . 또한 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 RHS 표현식에서 마지막 유형 매개 변수를 언급하지 않는 유형의 모든 생성자 인수를 필터링합니다. 이러한 인수는 접을 필요가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="606c23fd4a39d6f5da98fdda576dd31c1413daef" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates a definition for &lt;code&gt;traverse&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not produce any effects in a traversal.</source>
          <target state="translated">위한 알고리즘 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 는&lt;/a&gt; 로부터 적응 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 의&lt;/a&gt; 알고리즘이지만 대한 정의를 생성 &lt;code&gt;traverse&lt;/code&gt; 대신 &lt;code&gt;fmap&lt;/code&gt; 함수 . 또한 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 유형이 마지막 유형 매개 변수를 언급하지 않는 RHS 표현식에서 모든 생성자 인수를 필터링합니다. 이러한 인수는 순회에 영향을주지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="76b01a57a6338aab828a7c6e4ed1bf39e383096b" translate="yes" xml:space="preserve">
          <source>The allowed fields, with their types, are:</source>
          <target state="translated">허용되는 필드 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="007ff1d2ad1a216037acaa14b7a1f3887c82c2b0" translate="yes" xml:space="preserve">
          <source>The alternative spelling &lt;code&gt;INLINEABLE&lt;/code&gt; is also accepted by GHC.</source>
          <target state="translated">대체 철자 &lt;code&gt;INLINEABLE&lt;/code&gt; 도 GHC에서 승인합니다.</target>
        </trans-unit>
        <trans-unit id="305a13d8f5f537b644a0383d8511ddbfd1c351ee" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">상각 된 실행 시간은 각 작업에 대해 주어지며, &lt;em&gt;n&lt;/em&gt; 은 맵의 항목 수를 나타내고 &lt;em&gt;W&lt;/em&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="4c5c6e2226b125e7f1dbe13dda91ec65df83b59c" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</target>
        </trans-unit>
        <trans-unit id="1b9dadb18fa845e28ee381d88480264c2657a599" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">분할 된 실행 시간은 각 작업에 대해 제공되며 &lt;em&gt;n&lt;/em&gt; 은 맵의 항목 수를 나타내고 &lt;em&gt;W&lt;/em&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="43383f5e57411cb28bfae33d1e0cb0912284dd35" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;Int&lt;/code&gt; (32 or 64).</source>
          <target state="translated">상각 된 실행 시간은 각 작업에 대해 주어지며, &lt;em&gt;n&lt;/em&gt; 은 맵의 항목 수를 나타내고 &lt;em&gt;W&lt;/em&gt; 는 &lt;code&gt;Int&lt;/code&gt; (32 또는 64) 의 비트 수를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="9a366c01859c8d621928b2208d0c7ed30604c01f" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map.</source>
          <target state="translated">상각 된 실행 시간은 각 작업에 대해 주어지며 &lt;em&gt;n&lt;/em&gt; 은 맵의 항목 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a8bc34451c62ea9fef00489d326317052195ef0d" translate="yes" xml:space="preserve">
          <source>The amount of CPU time and elapsed wall clock time while initialising the runtime system (INIT), running the program itself (MUT, the mutator), and garbage collecting (GC).</source>
          <target state="translated">런타임 시스템 (INIT)을 초기화하고 프로그램 자체 (MUT, 뮤 테이터) 및 가비지 수집 (GC)을 초기화하는 동안 CPU 시간 및 경과 된 벽시계 시간.</target>
        </trans-unit>
        <trans-unit id="f5a041672cba6c9ce2cf79e0f2353d1f14191304" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propagated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">대답은 &quot;둘 중 하나를 던질 수 있습니다&quot;입니다. 선택은 비 결정적입니다. 어떤 유형의 예외를 포착하는 경우 둘 중 하나를 포착 할 수 있습니다. &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 유형으로 &lt;code&gt;catch&lt;/code&gt; 를 호출하는 경우 핸들러는 &lt;code&gt;DivideByZero&lt;/code&gt; 를 인수로 사용하여 실행 되거나 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 예외가 더 위로 전파 될 수 있습니다. 다시 전화하면 반대 행동을 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="d333d57b3bbb2f25b44ea7ef714696a1779ed43f" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propagated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">대답은 &quot;둘 중 하나를 던질 수 있습니다&quot;입니다. 선택은 비 결정적입니다. 어떤 유형의 예외를 포착하는 경우 둘 중 하나를 포착 할 수 있습니다. &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 유형으로 &lt;code&gt;catch&lt;/code&gt; 를 호출하는 경우 핸들러는 &lt;code&gt;DivideByZero&lt;/code&gt; 를 인수로 사용하여 실행 되거나 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 예외가 더 위로 전파 될 수 있습니다. 다시 전화하면 반대 행동을 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="4e261a78d3eb68ae4f4c2988b42a7f497028424d" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propagated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">대답은 &quot;둘 중 하나를 던질 수 있습니다&quot;입니다. 선택은 비 결정적입니다. 어떤 유형의 예외를 포착하는 경우 둘 중 하나를 포착 할 수 있습니다. &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 유형으로 &lt;code&gt;catch&lt;/code&gt; 를 호출하는 경우 핸들러는 &lt;code&gt;DivideByZero&lt;/code&gt; 를 인수로 사용하여 실행 되거나 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 예외가 더 위로 전파 될 수 있습니다. 다시 전화하면 반대 행동을 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="324b96835c11121147eb9632d3d28270b6cd3cf5" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">대답은 &quot;둘 중 하나를 던질 것&quot;입니다. 선택은 비 결정적입니다. 모든 유형의 예외를 잡는 경우 둘 중 하나를 잡을 수 있습니다. &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 유형으로 &lt;code&gt;catch&lt;/code&gt; 를 호출 하면 처리기가 &lt;code&gt;DivideByZero&lt;/code&gt; 를 인수로 실행 하거나 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 예외가 더 많이 전파 될 수 있습니다. 다시 전화하면 반대 행동을 취할 수 있습니다. &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="fc2d971716bd2fe11fe8e65858d3f263f32451c4" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">대답은 &quot;둘 중 하나를 던질 것&quot;입니다. 선택은 비 결정적입니다. 모든 유형의 예외를 잡는 경우 둘 중 하나를 잡을 수 있습니다. &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 유형으로 &lt;code&gt;catch&lt;/code&gt; 를 호출 하면 처리기가 &lt;code&gt;DivideByZero&lt;/code&gt; 를 인수로 실행 하거나 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 예외가 더 많이 전파 될 수 있습니다. 다시 전화하면 반대 행동을 취할 수 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="6636ed331b405e67e4aa7a8f8c1f88ee4738daae" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">대답은 &quot;둘 중 하나를 던질 것&quot;입니다. 선택은 비 결정적입니다. 모든 유형의 예외를 잡는 경우 둘 중 하나를 잡을 수 있습니다. &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 유형으로 &lt;code&gt;catch&lt;/code&gt; 를 호출 하면 처리기가 &lt;code&gt;DivideByZero&lt;/code&gt; 를 인수로 실행 하거나 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 예외가 더 많이 전파 될 수 있습니다. 다시 전화하면 반대 행동을 취할 수 있습니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="c111ce92793f7c8faf352718e7e5cd09fac00817" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</target>
        </trans-unit>
        <trans-unit id="943135ca0c852bb7fdf88d6047a279eefeb54769" translate="yes" xml:space="preserve">
          <source>The approach works &lt;em&gt;only&lt;/em&gt; for foreign code that does I/O (system calls), not for CPU-intensive computations that do not do any system calls. This is because the only way by which the foreign code can observe interruption is by system calls returning interruption error codes. To be able to interrupt long-running foreign code doing no system calls, the code must likely be changed to explicitly check for intended early termination.</source>
          <target state="translated">이 접근 방식 은 I / O (시스템 호출)를 수행하는 외부 코드 &lt;em&gt;에만 적용&lt;/em&gt; 되며 시스템 호출을 수행하지 않는 CPU 집약적 계산에는 적용되지 않습니다. 이는 외부 코드가 인터럽트를 관찰 할 수있는 유일한 방법은 인터럽트 오류 코드를 반환하는 시스템 호출이기 때문입니다. 시스템 호출없이 장기 실행되는 외부 코드를 인터럽트 할 수 있으려면 의도 된 조기 종료를 명시 적으로 확인하도록 코드를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="215e7b52176702d87e95e2ce03acf7002f6125af" translate="yes" xml:space="preserve">
          <source>The approximate time when the program finished execution as a UNIX epoch timestamp.</source>
          <target state="translated">프로그램이 UNIX epoch 시간 소인으로 실행을 완료 한 대략적인 시간입니다.</target>
        </trans-unit>
        <trans-unit id="bba06a7c745bfe3d2d4d032c0a5307f863b5c408" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">임의 정밀도 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="77f549adbb8c3243a4f421f1caa3469b06d519cd" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">임의 정밀도 &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7e4663001ff64b0062c525758c18f678a0b593f7" translate="yes" xml:space="preserve">
          <source>The argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters.</source>
          <target state="translated">인수는 일반적으로 응용 프로그램의 이름입니다. 경로에 통합되므로 유효한 경로 문자로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f7c4f0dc994aa251501707da51ab6248d1b7b620" translate="yes" xml:space="preserve">
          <source>The argument must be strictly positive, that condition is &lt;em&gt;not&lt;/em&gt; checked.</source>
          <target state="translated">인수는 엄격하게 양수 여야하며 해당 조건은 점검 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd85e788b1a4102dc5506f2821063aaee1859f8" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 전달 된 인수는 다른 함수를 인수로 사용하는 함수로, 마스킹 된 계산 컨텍스트 내에서 일반적인 마스킹 상태를 복원하는 데 사용할 수 있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하는 일반적인 방법 은 리소스 획득을 보호하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec41714558fc08d08da55c62fab2fe097c6c6a18" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 전달 된 인수는 다른 함수를 인수로 사용하는 함수로, 마스킹 된 계산 컨텍스트 내에서 일반적인 마스킹 상태를 복원하는 데 사용할 수 있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하는 일반적인 방법 은 리소스 획득을 보호하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8b310556e765050dba6b8aa3221dbec61d539ee" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 전달 된 인수는 다른 함수를 인수로 사용하는 함수로, 마스킹 된 계산 컨텍스트 내에서 일반적인 마스킹 상태를 복원하는 데 사용할 수 있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하는 일반적인 방법 은 리소스 획득을 보호하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c1e08fffd8f2b265d44f0c771329303cef101fc" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;runGhc&lt;/code&gt; is a bit tricky. GHC needs this to find its libraries, so the argument must refer to the directory that is printed by &lt;code&gt;ghc --print-libdir&lt;/code&gt; for the same version of GHC that the program is being compiled with. Above we therefore use the &lt;code&gt;ghc-paths&lt;/code&gt; package which provides this for us.</source>
          <target state="translated">&lt;code&gt;runGhc&lt;/code&gt; 에 대한 주장 은 약간 까다 롭습니다. GHC는 라이브러리를 찾기 위해 이것이 필요하므로 인수는 프로그램이 컴파일되는 동일한 버전의 GHC에 대해 &lt;code&gt;ghc --print-libdir&lt;/code&gt; 로 인쇄되는 디렉토리를 참조해야합니다 . 위에서 우리 는 이것을 제공 하는 &lt;code&gt;ghc-paths&lt;/code&gt; 패키지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="937438b46c14780890e239d1e034a6d669654a3d" translate="yes" xml:space="preserve">
          <source>The argument used for comparisons in &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 에서 비교에 사용되는 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af48f7ebb72df2bb8fd591d8c3756cf037769ab7" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 대한 인수 는 다음 순서로되어 있으므로 부분적으로 적용 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="9ab336f12a087d2ee8f1cb00edb943f2a0db5354" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 대한 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6d74e6182495971a70d15c2958c5a641ef0bc47" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 대한 인수 는 다음 순서로되어 있으므로 부분적으로 적용 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="bcf374949da96559812c28916c86dc0dd2c3b398" translate="yes" xml:space="preserve">
          <source>The arity can be specified using explicit binders and inline kind annotations:</source>
          <target state="translated">The arity can be specified using explicit binders and inline kind annotations:</target>
        </trans-unit>
        <trans-unit id="ecd5594ea721a5c5b4964510fa025a0ba7161ee7" translate="yes" xml:space="preserve">
          <source>The array is undefined (i.e. bottom) if any index in the list is out of bounds. The Haskell 2010 Report further specifies that if any two associations in the list have the same index, the value at that index is undefined (i.e. bottom). However in GHC's implementation, the value at such an index is the value part of the last association with that index in the list.</source>
          <target state="translated">리스트의 인덱스가 범위를 벗어난 경우 배열은 정의되지 않습니다 (즉, 아래쪽). Haskell 2010 보고서는 목록의 두 연관이 동일한 색인을 갖는 경우 해당 색인의 값이 정의되지 않음 (즉, 맨 아래)을 지정합니다. 그러나 GHC의 구현에서 그러한 인덱스의 값은 목록에서 해당 인덱스와의 마지막 연결의 값 부분입니다.</target>
        </trans-unit>
        <trans-unit id="44d43a4b5ab2e55067cf3b1a8adecaad475ca23d" translate="yes" xml:space="preserve">
          <source>The array type</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="f14b40d222c3b195d28ca364c99460ad8aae96cd" translate="yes" xml:space="preserve">
          <source>The arrows web page at &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt;&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;&amp;gt;`__.</source>
          <target state="translated">&lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt; &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; &amp;gt;`__ 의 화살표 웹 페이지</target>
        </trans-unit>
        <trans-unit id="5d75f1d30789a0cbac459769864941506e40cd41" translate="yes" xml:space="preserve">
          <source>The arrows web page at &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt;&lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;&amp;gt;`__.</source>
          <target state="translated">화살표 웹 페이지 &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt; &lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; &amp;gt;`__.</target>
        </trans-unit>
        <trans-unit id="f81f04fe2e69119373236a50c3a7031af8803aa8" translate="yes" xml:space="preserve">
          <source>The atomic exchange operation. Atomically exchanges the value at the address with the given value. Returns the old value. Implies a read barrier.</source>
          <target state="translated">원자 교환 작업입니다. 주소의 값을 주어진 값과 원자 ​​적으로 교환합니다. 이전 값을 반환합니다. 읽기 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bb0009366c213c66c1868a5615d36a47daf4cea6" translate="yes" xml:space="preserve">
          <source>The atomic exchange operation. Atomically exchanges the value at the first address with the Addr# given as second argument. Implies a read barrier.</source>
          <target state="translated">원자 교환 작업입니다. 첫 번째 주소의 값을 두 번째 인수로 지정된 Addr #과 원자 적으로 교환합니다. 읽기 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5375e79ae4b0bd456d40500fcf8a53d9559263ad" translate="yes" xml:space="preserve">
          <source>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a &lt;code&gt;*&lt;/code&gt; to the module name or filename when using &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, for example</source>
          <target state="translated">내 보내지 않은 모듈의 최상위 레벨 정의는 모듈을 해석 할 때 프롬프트에서 표현식으로 만 사용할 수 있기 때문에 오브젝트 파일의 자동로드로 인해 혼란이 발생할 수 있습니다 (프롬프트 &lt;a href=&quot;#ghci-scope&quot;&gt;의 실제 범위는 무엇입니까? 참조&lt;/a&gt; ). 이러한 이유로 때때로 GHCi가 인터프리터를 사용하여 모듈을로드하도록 할 수 있습니다. &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 를&lt;/a&gt; 사용할 때 모듈 이름 또는 파일 이름 앞에 &lt;code&gt;*&lt;/code&gt; 를 붙여서 수행 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="b8d9c5b3787a7ee0e2557b6cd2dbfe90790c68e2" translate="yes" xml:space="preserve">
          <source>The automatic specialisation of overloaded functions (with &lt;code&gt;-O&lt;/code&gt;) should take care of overloaded local and/or unexported functions.</source>
          <target state="translated">오버로드 된 함수의 자동 특수화 ( &lt;code&gt;-O&lt;/code&gt; 사용 )는 오버로드 된 로컬 및 / 또는 익스포트되지 않은 함수를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b4889f9c5c10822085aef8616f19dbeeab3bf53" translate="yes" xml:space="preserve">
          <source>The available GHCi options are:</source>
          <target state="translated">사용 가능한 GHCi 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="320cabfd45dc56924b1a16a731023c186da51000" translate="yes" xml:space="preserve">
          <source>The available mode flags are:</source>
          <target state="translated">사용 가능한 모드 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d80beedcca979af44b30619e5e06f25ee652ee4" translate="yes" xml:space="preserve">
          <source>The average and maximum &amp;ldquo;residency&amp;rdquo;, which is the amount of live data in bytes. The runtime can only determine the amount of live data during a major GC, which is why the number of samples corresponds to the number of major GCs (and is usually relatively small). To get a better picture of the heap profile of your program, use the &lt;a href=&quot;#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; RTS option (&lt;a href=&quot;#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">평균 및 최대 &quot;잔차&quot;(바이트 단위의 라이브 데이터 양) 런타임은 주요 GC 동안 라이브 데이터의 양만 결정할 수 있으므로 샘플 수가 주요 GC의 수에 해당합니다 (일반적으로 상대적으로 적음). 프로그램의 힙 프로파일을 더 잘 이해하려면 &lt;a href=&quot;#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt; RTS 옵션 ( &lt;a href=&quot;#rts-profiling&quot;&gt;프로파일 링을위한 RTS 옵션&lt;/a&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a46eb9d9f0c06124eb5d61df6a1e2c54302d74ae" translate="yes" xml:space="preserve">
          <source>The avoided &amp;ldquo;dangerous&amp;rdquo; optimisations are those that can make runtime or space &lt;em&gt;worse&lt;/em&gt; if you&amp;rsquo;re unlucky. They are normally turned on or off individually.</source>
          <target state="translated">피하는 &quot;위험한&quot;최적화는 운이 &lt;em&gt;좋지&lt;/em&gt; 않으면 런타임이나 공간을 &lt;em&gt;악화시킬&lt;/em&gt; 수있는 최적화 입니다. 일반적으로 개별적으로 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="eecb19b8afe1b4ff965ad37ca33e048b7e8a4fe6" translate="yes" xml:space="preserve">
          <source>The base must be greater than &lt;code&gt;1&lt;/code&gt;, the second argument, the number whose logarithm is sought, shall be positive, otherwise the result is meaningless.</source>
          <target state="translated">밑은 &lt;code&gt;1&lt;/code&gt; 보다 커야하며 , 두 번째 인수는 로그를 구하는 수이며 양수 여야합니다. 그렇지 않으면 결과는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bc476ce11547136a2a5b9c892017204522ab1a2" translate="yes" xml:space="preserve">
          <source>The basic algorithm for &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; walks the arguments of each constructor of a data type, applying a mapping function depending on the type of each argument. If a plain type variable is found that is syntactically equivalent to the last type parameter of the data type (&lt;code&gt;a&lt;/code&gt; in the above example), then we apply the function &lt;code&gt;f&lt;/code&gt; directly to it. If a type is encountered that is not syntactically equivalent to the last type parameter &lt;em&gt;but does mention&lt;/em&gt; the last type parameter somewhere in it, then a recursive call to &lt;code&gt;fmap&lt;/code&gt; is made. If a type is found which doesn&amp;rsquo;t mention the last type parameter at all, then it is left alone.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 의 기본 알고리즘 은 각 인수의 유형에 따라 맵핑 함수를 적용하여 데이터 유형의 각 생성자의 인수를 안내합니다. 데이터 형식의 마지막 형식 매개 변수 ( 위의 예에서 &lt;code&gt;a&lt;/code&gt; ) 와 구문 적으로 동일한 일반 형식 변수가 발견 되면 함수 &lt;code&gt;f&lt;/code&gt; 를 직접 적용 합니다. 마지막 유형 매개 변수와 구문 상 동일 &lt;em&gt;하지 않지만&lt;/em&gt; 그 유형 어딘가에 마지막 유형 매개 변수를 &lt;em&gt;언급&lt;/em&gt; 한 유형이 있으면 &lt;code&gt;fmap&lt;/code&gt; 에 대한 재귀 호출 이 작성됩니다. 마지막 유형 매개 변수를 전혀 언급하지 않는 유형이 발견되면 단독으로 남겨집니다.</target>
        </trans-unit>
        <trans-unit id="3880ac769d164951235b5160f553818be744abe1" translate="yes" xml:space="preserve">
          <source>The basic arrow class.</source>
          <target state="translated">기본 화살표 클래스.</target>
        </trans-unit>
        <trans-unit id="f8e6230ac47ed9f2f8c9e5c744ea8b38e5723913" translate="yes" xml:space="preserve">
          <source>The basic idea is as follows:</source>
          <target state="translated">기본 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba3b2fdca46ebd4f364c251ed8663faaa8ea67c0" translate="yes" xml:space="preserve">
          <source>The basic idea is you render your structure in the form of this tree, and then use treeHtml to turn it into a Html object with the structure explicit.</source>
          <target state="translated">기본 아이디어는이 트리의 형태로 구조를 렌더링 한 다음 treeHtml을 사용하여 구조를 명시적인 Html 객체로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c047de532274bb72034a6627c348b88e9f40677" translate="yes" xml:space="preserve">
          <source>The basic principle is that all variables mentioned on the right hand side &lt;code&gt;&amp;lt;rhs&amp;gt;&lt;/code&gt; must be bound on the left hand side:</source>
          <target state="translated">The basic principle is that all variables mentioned on the right hand side &lt;code&gt;&amp;lt;rhs&amp;gt;&lt;/code&gt; must be bound on the left hand side:</target>
        </trans-unit>
        <trans-unit id="ca1a1e0f9e4dd44a7cc3e7b636c0566990b56840" translate="yes" xml:space="preserve">
          <source>The basic syntax is that instead of specifying a package name P to the package flag &lt;code&gt;-package&lt;/code&gt;, instead we specify both a package name and a parenthesized, comma-separated list of module names to import. For example, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; makes only &lt;code&gt;Data.List&lt;/code&gt; and &lt;code&gt;Data.Bool&lt;/code&gt; visible from package &lt;code&gt;base&lt;/code&gt;. We also support renaming of modules, in case you need to refer to both modules simultaneously; this is supporting by writing &lt;code&gt;OldModName as NewModName&lt;/code&gt;, e.g. &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt;. You can also write &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; to include all of the original bindings (e.g. the renaming is strictly additive). It&amp;rsquo;s important to specify quotes so that your shell passes the package name and thinning/renaming list as a single argument to GHC.</source>
          <target state="translated">기본 구문은 패키지 플래그 &lt;code&gt;-package&lt;/code&gt; 에 패키지 이름 P를 지정하는 대신 패키지 이름과 쉼표로 구분 된 쉼표로 구분 된 가져올 모듈 이름 목록을 모두 지정한다는 것입니다. 예를 들어, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; 는 패키지 &lt;code&gt;base&lt;/code&gt; 에서 &lt;code&gt;Data.List&lt;/code&gt; 및 &lt;code&gt;Data.Bool&lt;/code&gt; 만 표시 합니다 . 또한 두 모듈을 동시에 참조해야하는 경우 모듈 이름 변경을 지원합니다. &lt;code&gt;OldModName as NewModName&lt;/code&gt; 으로 작성하여 지원 &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt; 예 : -package &quot;base (Data.Bool as Bool)) . &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; 원래 바인딩을 모두 포함합니다 (예 : 이름 변경은 엄격하게 추가됩니다). 쉘이 패키지 이름과 씬닝 / 이름 변경 목록을 GHC에 대한 단일 인수로 전달하도록 따옴표를 지정하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e4d64a56087518fa3e2214a7adad0a68d002b762" translate="yes" xml:space="preserve">
          <source>The batch compiler can be used alongside GHCi: compiled modules can be loaded into an interactive session and used in the same way as interpreted code, and in fact when using GHCi most of the library code will be pre-compiled. This means you get the best of both worlds: fast pre-compiled library code, and fast compile turnaround for the parts of your program being actively developed.</source>
          <target state="translated">배치 컴파일러는 GHCi와 함께 사용할 수 있습니다. 컴파일 된 모듈은 대화식 세션에로드되고 해석 된 코드와 같은 방식으로 사용될 수 있으며 실제로 GHCi를 사용하는 경우 대부분의 라이브러리 코드가 사전 컴파일됩니다. 즉, 사전 컴파일 된 빠른 라이브러리 코드와 적극적으로 개발중인 프로그램 부분에 대한 빠른 컴파일 처리라는 두 가지 이점을 모두 누릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ef12a287f244edad57a058eca9787cf5ada079d" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the given search directories and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 검색 디렉토리를 사용하고 각 파일에서 실행 권한을 테스트 하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 와 동일합니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a37ab05f29aa8d1d66f30bee4471417ca0bbd0f1" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;, returning only the first occurrence. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 동작은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 와 동일 하며 첫 번째 항목 만 리턴합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c8e66257c1f95cca3356ee64f960b20dcb60818" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동작은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 와 같습니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb1e1a3692688caa279ab0329a4e161ca0e7b861" translate="yes" xml:space="preserve">
          <source>The behaviour is simply this:</source>
          <target state="translated">동작은 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="4e22b1ce78f6bd0374bd10bb559bcf1d11076d6f" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt; can be at first surprising when the applicative functor &lt;strong&gt;&lt;code&gt;f&lt;/code&gt;&lt;/strong&gt; is &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; (i.e. the List monad). The List monad is said to be &lt;em&gt;non-deterministic&lt;/em&gt;, by which is meant that applying a list of &lt;strong&gt;&lt;code&gt;n&lt;/code&gt;&lt;/strong&gt; functions &lt;strong&gt;&lt;code&gt;[a -&amp;gt; b]&lt;/code&gt;&lt;/strong&gt; to a list of &lt;strong&gt;&lt;code&gt;k&lt;/code&gt;&lt;/strong&gt; values &lt;strong&gt;&lt;code&gt;[a]&lt;/code&gt;&lt;/strong&gt; produces a list of &lt;strong&gt;&lt;code&gt;n*k&lt;/code&gt;&lt;/strong&gt; values of each function applied to each input value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt; 의 동작은 응용 펑터 &lt;strong&gt; &lt;code&gt;f&lt;/code&gt; &lt;/strong&gt; 가 &lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt; (즉, List 모나드) 일 때 처음에는 놀랍습니다 . List 모나드는 &lt;em&gt;비 결정적&lt;/em&gt; 이라고합니다. 즉, &lt;strong&gt; &lt;code&gt;n&lt;/code&gt; 개의&lt;/strong&gt; 함수 목록 &lt;strong&gt; &lt;code&gt;[a -&amp;gt; b]&lt;/code&gt; &lt;/strong&gt; 을 &lt;strong&gt; &lt;code&gt;k&lt;/code&gt; &lt;/strong&gt; 값 목록 &lt;strong&gt; &lt;code&gt;[a]&lt;/code&gt; 에&lt;/strong&gt; 적용하면 다음에 적용된 각 함수 의 &lt;strong&gt; &lt;code&gt;n*k&lt;/code&gt; &lt;/strong&gt; 값 목록이 생성 됩니다. 각 입력 값.</target>
        </trans-unit>
        <trans-unit id="25a0b28ac23419d2d5d4b31eb8e82eaa74968d1a" translate="yes" xml:space="preserve">
          <source>The behaviour of parallel list comprehensions follows that of zip, in that the resulting list will have the same length as the shortest branch.</source>
          <target state="translated">병렬 목록 이해의 동작은 결과 목록의 길이가 가장 짧은 분기와 동일하므로 zip 동작을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="61d055ddbe3626e56799e23f2310dd79c75612f2" translate="yes" xml:space="preserve">
          <source>The below folds, are neither strict reductions that produce a final answer in constant space, nor lazy corecursions, and so have limited applicability. They do have specialised uses, but are best avoided when in doubt.</source>
          <target state="translated">아래 폴드는 일정한 공간에서 최종 답변을 생성하는 엄격한 축소도 아니고 게으른 코어 커션도 아니므로 적용 가능성이 제한적입니다. 특수 용도가 있지만 의심스러운 경우 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4c2566b6e8b4d963d45c5f213c50828df28117fe" translate="yes" xml:space="preserve">
          <source>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of &lt;code&gt;Collects&lt;/code&gt; with a simple dependency:</source>
          <target state="translated">의존성 정보를 포함하는 이점은 모호성 문제없이보다 정확한 유형의 이점으로보다 일반적인 여러 매개 변수 클래스를 정의 할 수 있다는 것입니다. 이를 설명하기 위해 콜렉션 클래스 예제로 돌아가서 간단한 종속성 으로 &lt;code&gt;Collects&lt;/code&gt; 의 원래 정의에 주석을 답니다 .</target>
        </trans-unit>
        <trans-unit id="947bc2cb4d922e45d67175db691e9955f759c4f5" translate="yes" xml:space="preserve">
          <source>The biconnected components of a graph. An undirected graph is biconnected if the deletion of any vertex leaves it connected.</source>
          <target state="translated">그래프의 이중 연결 구성 요소. 정점을 삭제해도 연결된 상태가 아닌 경우 무 방향 그래프는 이중 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd73ac6d922a5bdced0fb605663eb345d894008" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be at the top level (i.e. no nested binders)</source>
          <target state="translated">주석이 달린 바인더는 최상위 레벨에 있어야합니다 (즉, 중첩 바인더가 없어야 함)</target>
        </trans-unit>
        <trans-unit id="63969d96d060c4b503447fa167a99cc5d9a634d8" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be declared in the current module</source>
          <target state="translated">주석을 달고있는 바인더는 현재 모듈에서 선언되어야합니다</target>
        </trans-unit>
        <trans-unit id="7e1a540e18890acf0212904549c9082483047e09" translate="yes" xml:space="preserve">
          <source>The binding is lazy, but when either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is evaluated by &lt;code&gt;b&lt;/code&gt; the entire pattern is matched, including forcing the evaluation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">바인딩은 지연이지만, 어느 경우에 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 평가되는 &lt;code&gt;b&lt;/code&gt; 를 전체 패턴의 평가 강제 포함 일치 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5313486dfdead25fb97fb53d215625b3a8e92cb9" translate="yes" xml:space="preserve">
          <source>The body &lt;code&gt;e&lt;/code&gt; of a &lt;code&gt;static e&lt;/code&gt; expression must be a closed expression. Where we say an expression is &lt;em&gt;closed&lt;/em&gt; when all of its free (type) variables are closed. And a variable is &lt;em&gt;closed&lt;/em&gt; if it is let-bound to a &lt;em&gt;closed&lt;/em&gt; expression and its type is &lt;em&gt;closed&lt;/em&gt; as well. And a type is &lt;em&gt;closed&lt;/em&gt; if it has no free variables.</source>
          <target state="translated">본체 &lt;code&gt;e&lt;/code&gt; (A)의 &lt;code&gt;static e&lt;/code&gt; 식은 식 폐쇄해야한다. 우리는 표현이되는 말을 어디 &lt;em&gt;폐쇄&lt;/em&gt; 자유 (유형) 모든 변수를 닫을 때. 그리고 변수입니다 &lt;em&gt;폐쇄&lt;/em&gt; 그것이로하자 - 바인딩 된 경우 &lt;em&gt;폐쇄&lt;/em&gt; 표현과 그 형식이됩니다 &lt;em&gt;폐쇄&lt;/em&gt; 아니라. 자유 변수가없는 유형은 &lt;em&gt;닫힙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="592ada029a062869cce6e9bab58606be6defb777" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;f&lt;/code&gt; requires a &lt;code&gt;Num Int&lt;/code&gt; instance. We could solve this constraint from the context because we have &lt;code&gt;C Int b&lt;/code&gt; and that provides us a solution for &lt;code&gt;Num Int&lt;/code&gt;. However, we can often produce much better code by directly solving for an available &lt;code&gt;Num Int&lt;/code&gt; dictionary we might have at hand. This removes potentially many layers of indirection and crucially allows other optimisations to fire as the dictionary will be statically known and selector functions can be inlined.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 본문 에는 &lt;code&gt;Num Int&lt;/code&gt; 인스턴스 가 필요 합니다. &lt;code&gt;C Int b&lt;/code&gt; 가 있고 &lt;code&gt;Num Int&lt;/code&gt; 에 대한 솔루션을 제공하기 때문에 컨텍스트에서이 제약 조건을 해결할 수 있습니다. 그러나 우리는 종종 사용 가능한 &lt;code&gt;Num Int&lt;/code&gt; 사전 을 직접 해결하여 훨씬 더 나은 코드를 생성 할 수 있습니다. 이로 인해 잠재적으로 많은 간접 계층이 제거되고 사전이 정적으로 알려지고 선택기 기능이 인라인 될 수 있으므로 다른 최적화를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d145adb9d3d5724f47490428e23e3c43d0c8235" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;h&lt;/code&gt;&lt;em&gt;can&lt;/em&gt; refer to the function &lt;code&gt;k&lt;/code&gt; appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</source>
          <target state="translated">쿼시 쿼터가 선언 그룹을 분리하지 않기 때문에 &lt;code&gt;h&lt;/code&gt; 의 본문은 선언 쿼시 쿼터의 다른쪽에 나타나는 함수 &lt;code&gt;k&lt;/code&gt; 를 참조 할 &lt;em&gt;수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8c2a782fcf9cc8cd32d7c6db0f011051b79d7285" translate="yes" xml:space="preserve">
          <source>The bound on the size of sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 바이트 순서의 사이즈에 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="efcab014d352f2160b0e056ce4481103488be8c8" translate="yes" xml:space="preserve">
          <source>The bounds are specified as a pair of the lowest and highest bounds in the array respectively. For example, a one-origin vector of length 10 has bounds (1,10), and a one-origin 10 by 10 matrix has bounds ((1,1),(10,10)).</source>
          <target state="translated">경계는 각각 배열에서 가장 낮은 경계와 가장 높은 경계의 쌍으로 지정됩니다. 예를 들어, 길이 10의 1- 원점 벡터에는 범위 (1,10)이 있고 원-원점 10 x 10 행렬에는 범위가 있습니다 ((1,1), (10,10)).</target>
        </trans-unit>
        <trans-unit id="ba1cb6f6655a10a0c6294b458c9d83470571695d" translate="yes" xml:space="preserve">
          <source>The bounds of an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 의 경계입니다 .</target>
        </trans-unit>
        <trans-unit id="55a1eeab90b32df97217b33a312a220ee3d8254d" translate="yes" xml:space="preserve">
          <source>The bounds of the array</source>
          <target state="translated">배열의 경계</target>
        </trans-unit>
        <trans-unit id="5e0f777f52cc6d21bfe3b719f3991ded42b0a70a" translate="yes" xml:space="preserve">
          <source>The bounds with which an array was constructed.</source>
          <target state="translated">배열이 구성된 경계입니다.</target>
        </trans-unit>
        <trans-unit id="303ea8cac283769e3c2c1f4546351c40f5d232c0" translate="yes" xml:space="preserve">
          <source>The braces are &lt;em&gt;not&lt;/em&gt; allowed in the following places:</source>
          <target state="translated">다음 위치에서는 중괄호를 사용할 수 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d9507b0cfc42e043b16f31d4dd9efa6a48909a9c" translate="yes" xml:space="preserve">
          <source>The braces are allowed in the following places:</source>
          <target state="translated">중괄호는 다음 위치에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="98540debb0cfa723d804774334df0da2c3c2438d" translate="yes" xml:space="preserve">
          <source>The breakpoint on the function &lt;code&gt;add&lt;/code&gt; can be set with one of the following commands:</source>
          <target state="translated">함수 &lt;code&gt;add&lt;/code&gt; 의 중단 점 은 다음 명령 중 하나로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="606c7ca088c78a3f35afe2ec49468115c18dfed0" translate="yes" xml:space="preserve">
          <source>The buffer is represented by a record, where the record contains the raw buffer and the start/end points of the filled portion. The buffer contents itself is mutable, but the rest of the record is immutable. This is a slightly odd mix, but it turns out to be quite practical: by making all the buffer metadata immutable, we can have operations on buffer metadata outside of the IO monad.</source>
          <target state="translated">버퍼는 레코드로 표시되며, 레코드에는 원시 버퍼와 채워진 부분의 시작 / 끝 지점이 포함됩니다. 버퍼 내용 자체는 변경 가능하지만 나머지 레코드는 변경할 수 없습니다. 이것은 약간 홀수 인 혼합이지만, 매우 실용적인 것으로 판명되었습니다. 모든 버퍼 메타 데이터를 변경할 수 없도록함으로써 IO 모나드 외부의 버퍼 메타 데이터에 대한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e80cbba3a922b5261d972496342488e7c081b28" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">버그 추적기는 GHC에서보고되었지만 아직 수정되지 않은 버그를 나열합니다 ( &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt; 참조) . 그 외에도 GHC에는 다음과 같은 알려진 버그 또는 악의가 있습니다. 이 버그는 더 영구적입니다. 그들 중 어느 것도 단기적으로 고쳐질 것 같지는 않다.</target>
        </trans-unit>
        <trans-unit id="a911bbbc10fa83662b5cd864e984b17a1755dfc0" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues&quot;&gt;GHC issue tracker&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues&quot;&gt;GHC issue tracker&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</target>
        </trans-unit>
        <trans-unit id="2f2ef36ba655ad50c14492007c1cd08415323ca3" translate="yes" xml:space="preserve">
          <source>The builtin function type, written in infix form as &lt;code&gt;a # m -&amp;gt; b&lt;/code&gt;. Values of this type are functions taking inputs of type &lt;code&gt;a&lt;/code&gt; and producing outputs of type &lt;code&gt;b&lt;/code&gt;. The multiplicity of the input is &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">내장 함수 유형, 중위 형식으로 &lt;code&gt;a # m -&amp;gt; b&lt;/code&gt; . 이 유형의 값은 유형 &lt;code&gt;a&lt;/code&gt; 의 입력을 받고 &lt;code&gt;b&lt;/code&gt; 유형의 출력을 생성 하는 함수 입니다. 입력의 다중도는 &lt;code&gt;m&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d744be67f1776bdfc00f733d34e658a4d32ac76" translate="yes" xml:space="preserve">
          <source>The byte buffer just before we did our last batch of decoding.</source>
          <target state="translated">마지막 디코딩 배치를 수행하기 직전의 바이트 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="7c15ff27610c2478bb9e4d3ab87096d2c276c0af" translate="yes" xml:space="preserve">
          <source>The byte ordering of the target machine.</source>
          <target state="translated">대상 머신의 바이트 순서입니다.</target>
        </trans-unit>
        <trans-unit id="9d60877c7df977c480a2e8c741eba795e8186655" translate="yes" xml:space="preserve">
          <source>The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes used to identify the encoding of a file.</source>
          <target state="translated">바이트 순서 표시는 UTF-8에서 반드시 필요하지는 않지만 파일의 인코딩을 식별하는 데 사용되기도합니다.</target>
        </trans-unit>
        <trans-unit id="a1ef7711364b299ccecf0740fe399441352dee0d" translate="yes" xml:space="preserve">
          <source>The bytecode interpreter doesn&amp;rsquo;t support most uses of unboxed tuples or sums, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">The bytecode interpreter doesn&amp;rsquo;t support most uses of unboxed tuples or sums, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</target>
        </trans-unit>
        <trans-unit id="8e514a824a293915d542219870ba513432dcaf11" translate="yes" xml:space="preserve">
          <source>The bytes read, how many bytes were read.</source>
          <target state="translated">읽은 바이트 수, 읽은 바이트 수</target>
        </trans-unit>
        <trans-unit id="b6a0060fcedfd8a68377b3d1eb2b5aba06d7d975" translate="yes" xml:space="preserve">
          <source>The call</source>
          <target state="translated">호출</target>
        </trans-unit>
        <trans-unit id="39398c8eae38902a5e0ff83f99f6b2f202aad4e7" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;inline f&lt;/code&gt; arranges that &lt;code&gt;f&lt;/code&gt; is inlined, regardless of its size. More precisely, the call &lt;code&gt;inline f&lt;/code&gt; rewrites to the right-hand side of &lt;code&gt;f&lt;/code&gt;'s definition. This allows the programmer to control inlining from a particular call site rather than the definition site of the function (c.f. &lt;code&gt;INLINE&lt;/code&gt; pragmas).</source>
          <target state="translated">호출 &lt;code&gt;inline f&lt;/code&gt; 는 크기에 관계없이 &lt;code&gt;f&lt;/code&gt; 가 인라인되도록 정렬합니다 . 보다 정확하게 말하면, 호출 &lt;code&gt;inline f&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 정의 의 오른쪽에 다시 씁니다 . 이를 통해 프로그래머는 함수의 정의 사이트가 아닌 특정 호출 사이트에서 인라인을 제어 할 수 있습니다 (참조 &lt;code&gt;INLINE&lt;/code&gt; pragma).</target>
        </trans-unit>
        <trans-unit id="f840dc76b51e89091e120df6a05d574071d82002" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;noinline f&lt;/code&gt; arranges that &lt;code&gt;f&lt;/code&gt; will not be inlined. It is removed during CorePrep so that its use imposes no overhead (besides the fact that it blocks inlining.)</source>
          <target state="translated">호출 &lt;code&gt;noinline f&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 가 인라인되지 않도록 배열합니다 . CorePrep 중에 제거되므로 사용시 오버 헤드가 발생하지 않습니다 (인라인을 차단한다는 사실 외에도).</target>
        </trans-unit>
        <trans-unit id="7b04d6b098bff47077a3361dce7c4b2060070b35" translate="yes" xml:space="preserve">
          <source>The call may block for a long time if a GC is in progress. We can&amp;rsquo;t use this method if the C API we&amp;rsquo;re calling doesn&amp;rsquo;t allow blocking in the callback.</source>
          <target state="translated">GC가 진행 중이면 통화가 오랫동안 차단 될 수 있습니다. 호출하는 C API가 콜백에서 차단을 허용하지 않는 경우이 방법을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f662e8be9b1e8327dfadad6256f93b3102227e4" translate="yes" xml:space="preserve">
          <source>The call stack</source>
          <target state="translated">콜 스택</target>
        </trans-unit>
        <trans-unit id="0b95e6d04b2d9db9df511faee23c172fb043db56" translate="yes" xml:space="preserve">
          <source>The call stack here consists of a single entry, pinpointing the source of the call to &lt;code&gt;error&lt;/code&gt;. However, by annotating several computations with &lt;code&gt;HasCallStack&lt;/code&gt;, figuring out the exact circumstances and sequences of calls that lead to a call to &lt;code&gt;error&lt;/code&gt; becomes a lot easier, as demonstrated with the simple example below.</source>
          <target state="translated">여기서 호출 스택은 단일 항목으로 구성되어 호출 소스를 &lt;code&gt;error&lt;/code&gt; 로 지정 합니다. 그러나 &lt;code&gt;HasCallStack&lt;/code&gt; 을 사용 하여 여러 계산에 주석을 달면 &lt;code&gt;error&lt;/code&gt; 에 대한 호출로 이어지는 정확한 상황과 호출 순서를 파악하는 것이 아래의 간단한 예와 같이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="e65b75e639ba49f45b306162220bcb4b4e376b49" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;hs_init()&lt;/code&gt; initializes GHC&amp;rsquo;s runtime system. Do NOT try to invoke any Haskell functions before calling &lt;code&gt;hs_init()&lt;/code&gt;: bad things will undoubtedly happen.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 호출하면 GHC의 런타임 시스템이 초기화됩니다. &lt;code&gt;hs_init()&lt;/code&gt; 를 호출하기 전에 Haskell 함수를 호출하지 마십시오 . 의심 할 여지없이 나쁜 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0d2f80290077bea927d89a134d957a184f32cc5" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 를 호출 하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="319dd86afb1a88f29e7d25a55be6766bfa4bbc86" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 를 호출 하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="82bb223904345033a341142d4c4dc792513b34b0" translate="yes" xml:space="preserve">
          <source>The case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; is rather interesting. Here, we call the final function &lt;code&gt;encode&lt;/code&gt; that we yet have to define, recursively. We will use another type class &lt;code&gt;Encode&lt;/code&gt; for that function:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 의 경우 는 다소 흥미 롭습니다. 여기서 우리는 재귀 적으로 정의해야 할 최종 함수 인 &lt;code&gt;encode&lt;/code&gt; 를 호출합니다 . 해당 함수에 다른 유형의 클래스 &lt;code&gt;Encode&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="dbeba971901c44630a87f3ab4af1926015f93dc7" translate="yes" xml:space="preserve">
          <source>The channels are implemented with &lt;code&gt;MVar&lt;/code&gt;s and therefore inherit all the caveats that apply to &lt;code&gt;MVar&lt;/code&gt;s (possibility of races, deadlocks etc). The stm (software transactional memory) library has a more robust implementation of channels called &lt;code&gt;TChan&lt;/code&gt;s.</source>
          <target state="translated">채널은 &lt;code&gt;MVar&lt;/code&gt; 로 구현 되므로 &lt;code&gt;MVar&lt;/code&gt; 에 적용되는 모든 경고 (인종, 교착 상태 등)를 상속합니다 . stm (소프트웨어 트랜잭션 메모리) 라이브러리에는 &lt;code&gt;TChan&lt;/code&gt; 이라는보다 강력한 채널 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4069bea430852a057890df955f47a154334cab42" translate="yes" xml:space="preserve">
          <source>The character that is used to separate the entries in the $PATH environment variable.</source>
          <target state="translated">$ PATH 환경 변수에서 항목을 구분하는 데 사용되는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="ba11d47bc9956242fbb3ca66e5d4200f63de5f8d" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">디렉토리를 구분하는 문자입니다. 하나 이상의 문자가 가능한 경우 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; 는 '이상적인' 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="0adbd55b5e31c8dee6ffdd25e981917f83978616" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">디렉토리를 구분하는 문자입니다. 하나 이상의 문자가 가능한 경우 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; 는 '이상적인' 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="3300c6070d1ff47cc64a9cd4f2a57598bed4fe49" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자 유형 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 는 값이 유니 코드 (또는 이에 상응하는 ISO / IEC 10646) 코드 포인트를 나타내는 열거입니다 (예 : 문자, 자세한 내용은 &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 참조). 이 세트는 ISO 8859-1 (Latin-1) 문자 세트 (처음 256 자)를 확장하며, 이는 ASCII 문자 세트 (처음 128 자)의 확장입니다. Haskell의 문자 리터럴은 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c58ab281a96d608a838facfb500eec9f8af59ed2" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자 유형 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 는 값이 유니 코드 (또는 이에 상응하는 ISO / IEC 10646) 코드 포인트 (예 : 문자, 자세한 내용은 &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 참조)를 나타내는 열거 형입니다 . 이 세트는 ASCII 문자 세트 (처음 128 자)의 확장 인 ISO 8859-1 (Latin-1) 문자 세트 (처음 256 자)를 확장합니다. Haskell의 문자 리터럴에는 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a83bfe2a3131f5d1fa9053b377b2dd8ef00abbee" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자 유형 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 는 값이 유니 코드 (또는 이에 상응하는 ISO / IEC 10646) 코드 포인트를 나타내는 열거입니다 (예 : 문자, 자세한 내용은 &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 참조). 이 세트는 ISO 8859-1 (Latin-1) 문자 세트 (처음 256 자)를 확장하며, 이는 ASCII 문자 세트 (처음 128 자)의 확장입니다. Haskell의 문자 리터럴은 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="d8b9579e1d45f067de340f390cfc1c13ade31317" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자 유형 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 는 값이 유니 코드 (또는 이에 상응하는 ISO / IEC 10646) 코드 포인트 (예 : 문자, 자세한 내용은 &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 참조)를 나타내는 열거 형입니다 . 이 세트는 ASCII 문자 세트 (처음 128 자)의 확장 인 ISO 8859-1 (Latin-1) 문자 세트 (처음 256 자)를 확장합니다. Haskell의 문자 리터럴에는 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e57b1fe87f343495401c4e61909f138148056d67" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자 유형 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 는 값이 유니 코드 (또는 이에 상응하는 ISO / IEC 10646) 코드 포인트를 나타내는 열거입니다 (예 : 문자, 자세한 내용은 &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 참조). 이 세트는 ISO 8859-1 (Latin-1) 문자 세트 (처음 256 자)를 확장하며, 이는 ASCII 문자 세트 (처음 128 자)의 확장입니다. Haskell의 문자 리터럴은 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="ba03ec4416da5ecc47e0c6f913a40f91a16c3e59" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자 유형 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 는 값이 유니 코드 (또는 이에 상응하는 ISO / IEC 10646) 코드 포인트 (예 : 문자, 자세한 내용은 &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 참조)를 나타내는 열거 형입니다 . 이 세트는 ASCII 문자 세트 (처음 128 자)의 확장 인 ISO 8859-1 (Latin-1) 문자 세트 (처음 256 자)를 확장합니다. Haskell의 문자 리터럴에는 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="47f8f2f2dc9e65ebc1b9adf566bdf62f3dc06201" translate="yes" xml:space="preserve">
          <source>The chunk size used for I/O. Currently set to 32k, less the memory management overhead</source>
          <target state="translated">I / O에 사용 된 청크 크기입니다. 현재 32k로 설정, 메모리 관리 오버 헤드 감소</target>
        </trans-unit>
        <trans-unit id="c4ebe1e22516dcf7d377102ba02d7a72071fb54c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 클래스를 사용하면 유형의 구체적인 표현을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ec99c0bc5533ce5fa506bf5dd334d666afbabf" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 클래스를 사용하면 유형의 구체적인 표현을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e5985c3bffdb6706bd6da87ba82bb2b1f9502b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 클래스를 사용하면 유형의 구체적인 표현을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0793307c198436ef6cbb2b38d12d842f11f5daa" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsLabel&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsLabel&lt;/code&gt; 클래스 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="da702fa4f893f1ff84ab94ead774536cedcefc5d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; 클래스 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="314c44e92114b49583eff2b98f5eb8171a7374ef" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is not in scope by default. If you want to mention it explicitly (for example, to give an instance declaration for it), you can import it from module &lt;code&gt;Data.String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; 클래스 는 기본적으로 범위 내에 있지 않습니다. 명시 적으로 언급하고 싶다면 (예 : 인스턴스 선언을 위해) &lt;code&gt;Data.String&lt;/code&gt; 모듈에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12ede30f8436e96616acb62bcd423d7bf0ba15da" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt; and &lt;code&gt;Code Q a&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">클래스 &lt;code&gt;Lift&lt;/code&gt; , 다른 유도 클래스와는 달리,에 살고있는 &lt;code&gt;template-haskell&lt;/code&gt; 대신 &lt;code&gt;base&lt;/code&gt; . 데이터 유형이 &lt;code&gt;Lift&lt;/code&gt; 의 인스턴스가되면 해당 값이 템플릿 Haskell 표현식 ( &lt;code&gt;ExpQ&lt;/code&gt; 및 &lt;code&gt;Code Q a&lt;/code&gt; 유형)으로 승격 된 다음 Haskell 소스 코드에 스 플라이 싱 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66741f48f8c9a811c479be37c49092c2f5831600" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt; and &lt;code&gt;TExpQ a&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">The class &lt;code&gt;Lift&lt;/code&gt; , unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt; . Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt; and &lt;code&gt;TExpQ a&lt;/code&gt; ), which can then be spliced into Haskell source code.</target>
        </trans-unit>
        <trans-unit id="46c25aa9d510e6dfd769a86618af627836e67d95" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">&lt;code&gt;Lift&lt;/code&gt; 클래스 는 다른 파생 클래스와 달리 &lt;code&gt;base&lt;/code&gt; 대신 &lt;code&gt;template-haskell&lt;/code&gt; 에 있습니다 . 데이터 유형을 &lt;code&gt;Lift&lt;/code&gt; 의 인스턴스로 설정 하면 값이 템플리트 Haskell 표현식 ( &lt;code&gt;ExpQ&lt;/code&gt; 유형 ) 으로 승격 되어 Haskell 소스 코드에 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfedc7f27395d9e14f3b5dcae9116c684144dba3" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Typeable&lt;/code&gt; is very special:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; 클래스 는 매우 특별합니다.</target>
        </trans-unit>
        <trans-unit id="a352e3bea5c92259e258192deb3bd391cda34543" translate="yes" xml:space="preserve">
          <source>The class instances for sequences are all based very closely on those for lists.</source>
          <target state="translated">시퀀스의 클래스 인스턴스는 모두 목록에 대한 클래스 인스턴스와 매우 밀접한 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29fdb13c7afe65c971d977ce119c943fb00e75f" translate="yes" xml:space="preserve">
          <source>The class of contravariant functors.</source>
          <target state="translated">반 변형 펑터 클래스.</target>
        </trans-unit>
        <trans-unit id="15b84a81fb0f85cb419535a3a61b9ad1d3da02f7" translate="yes" xml:space="preserve">
          <source>The class of monad transformers.</source>
          <target state="translated">모나드 변압기의 클래스.</target>
        </trans-unit>
        <trans-unit id="1aba4d36676a8723cc042f0ef18005b4207f229e" translate="yes" xml:space="preserve">
          <source>The class of monad transformers. Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a monad transformation:</source>
          <target state="translated">모나드 변압기의 클래스. 인스턴스는 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 가 모나드 변환 이라는 다음 법률을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="968994db3d9c45181b57f61fe4736e2627f5c6a6" translate="yes" xml:space="preserve">
          <source>The class of monoids (types with an associative binary operation that has an identity). Instances should satisfy the following:</source>
          <target state="translated">모노 이드 클래스 (ID가있는 연관 이진 연산이있는 유형). 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="80aae29c2b395ab518f6cbf2867e04f61aabbf53" translate="yes" xml:space="preserve">
          <source>The class of semigroups (types with an associative binary operation).</source>
          <target state="translated">반 그룹의 클래스 (연관 이진 연산이있는 유형).</target>
        </trans-unit>
        <trans-unit id="ef50832e806510cb4bbe9f9aafa22744526d2ab1" translate="yes" xml:space="preserve">
          <source>The class of the instance declaration is not declared in &lt;code&gt;M&lt;/code&gt;, and</source>
          <target state="translated">인스턴스 선언의 클래스에 선언되지 않은 &lt;code&gt;M&lt;/code&gt; , 및</target>
        </trans-unit>
        <trans-unit id="cc31daa90372a8a474d012704a661ac277d958aa" translate="yes" xml:space="preserve">
          <source>The class of types which can be parsed given a UNIX-style time format string.</source>
          <target state="translated">UNIX 스타일 시간 형식 문자열이 주어지면 구문 분석 할 수있는 유형의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="380a9b6da5c050f1cf3fa8febdb6d2797a540fc9" translate="yes" xml:space="preserve">
          <source>The closure of the superclass relation over these local axioms : &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</source>
          <target state="translated">이러한 지역 공리에 대한 수퍼 클래스 관계의 폐쇄 : &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; 및 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0848f15a7a4cc86662e9097e3f0cf4b1532d9192" translate="yes" xml:space="preserve">
          <source>The code for the method in the instance declaration is typechecked against the type signature supplied in the instance declaration, as you would expect. So if the instance signature is more polymorphic than required, the code must be too.</source>
          <target state="translated">인스턴스 선언의 메소드 코드는 예상대로 인스턴스 선언에 제공된 유형 서명과 비교하여 유형 검사됩니다. 따라서 인스턴스 서명이 필요한 것보다 다형성이면 코드도 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5001edd8f78114b36e24d8f0a44754ee90b2f4d" translate="yes" xml:space="preserve">
          <source>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</source>
          <target state="translated">코드 생성기는 각 Unboxed 합계에 대해 가능한 한 작은 레이아웃을 생성하려고합니다. 가장 좋은 경우, 상자에없는 합계의 크기는 가장 큰 대안의 크기에 한 단어 (태그의 경우)를 더한 크기입니다. 합 유형에 대한 메모리 레이아웃을 생성하는 알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3837898dd791b811ea7932889c5130e161088d94" translate="yes" xml:space="preserve">
          <source>The code of the &quot;dominant&quot; language of the webpage.</source>
          <target state="translated">웹 페이지의 &quot;주요한&quot;언어 코드.</target>
        </trans-unit>
        <trans-unit id="a45302a43608cfe9a77b37998c0a415b8fef0ffc" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">코드는 대부분 설명이 필요합니다. 약간 어색한 구문은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 가 작성되어 결과 BoundedPrim 의 크기 바인딩이 컴파일 타임에 계산 될 수 있기 때문입니다. 또한 고정 된 튜플을 인코딩하는 &lt;code&gt;fixed2&lt;/code&gt; 프리미티브를 명시 적으로 인라인하여 컴파일시 바인딩 된 계산이 이루어 지도록합니다. 다음의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 리스트를 인코딩 할 때 , &lt;code&gt;renderString&lt;/code&gt; 의 최적화 된 구현 은 두 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="93c66ed4ee1310bccd13dda5d5b0820443482dc4" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</target>
        </trans-unit>
        <trans-unit id="e49b8f6ffa3d4e8cbb63cddf88f834628317e65f" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">코드는 대부분 자명해야합니다. 약간 어색한 구문은 컴파일 타임에 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 의 크기 제한을 계산할 수 있도록 결합자가 작성 되었기 때문 입니다. 또한 고정 된 문자 튜플을 인코딩하는 &lt;code&gt;fixed2&lt;/code&gt; 프리미티브를 명시 적으로 인라인하여 바운드 계산이 컴파일 타임에 발생하도록합니다. 다음 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 목록을 인코딩 할 때 최적화 된 &lt;code&gt;renderString&lt;/code&gt; 구현 이 두 배 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4421b2e89d7c073b3eeabb7b626aa07e05c2b134" translate="yes" xml:space="preserve">
          <source>The combinators &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt;, etc are all provided with default definitions in terms of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt;, leaving open the opportunity to provide datatype-specific definitions. (The inclusion of the &lt;code&gt;gmap&lt;/code&gt; combinators as members of class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; allows the programmer or the compiler to derive specialised, and maybe more efficient code per datatype. &lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is more higher-order than the &lt;code&gt;gmap&lt;/code&gt; combinators. This is subject to ongoing benchmarking experiments. It might turn out that the &lt;code&gt;gmap&lt;/code&gt; combinators will be moved out of the class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">결합 자 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt; 등은 모두 gfoldl 과 관련하여 기본 정의가 제공되므로 데이터 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 정의 를 제공 할 수 있습니다. 의 (포함시키는 &lt;code&gt;gmap&lt;/code&gt; 클래스의 멤버로 콤비 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 프로그래머 나 컴파일러가 전문 도출 할 수 있고, 데이터 타입 당 어쩌면 더 효율적인 코드입니다. &lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 는 댄 더 높은 순서입니다 &lt;code&gt;gmap&lt;/code&gt; 콤비이 될 수 있습니다 벤치마킹 실험을 진행합니다. . 그것은 것으로 판명 수 &lt;code&gt;gmap&lt;/code&gt; 콤비가 클래스 밖으로 이동합니다 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="8d6f1f7c8a32c8db29cc4151cc5a6c27c5f31776" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the size of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time.</source>
          <target state="translated">연결자의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 의 결과의 크기의 것으로는 구현 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 는 컴파일 시간에 계산 될 수있다.</target>
        </trans-unit>
        <trans-unit id="133b8b51a252192de7eb7c3da1c445dfb72c71c3" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; is computed at compile time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 에 대한 결합 자는 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 가 컴파일 타임에 계산 되도록 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="b36fb23ba2c0fd5cf9cc5fbcaa48f3fa3936ed5b" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the &lt;code&gt;size&lt;/code&gt; of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; is computed at compile time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 의 결합 자는 결과로 생성 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;size&lt;/code&gt; 가 컴파일 타임에 계산 되도록 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="2acc0788b34136669ccf2620396da51b7563e2c2" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt; will show a summary of which modules contribute to the top-level scope.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt; 명령 은 어떤 모듈이 최상위 범위에 기여하는지에 대한 요약을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5fdeb122c09642094fcfc48bef6bdcdff89e8605" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step expr&lt;/code&gt;&lt;/a&gt; begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt;&lt;code&gt;:steplocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt;&lt;code&gt;:stepmodule&lt;/code&gt;&lt;/a&gt; commands work similarly.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step expr&lt;/code&gt; &lt;/a&gt; 명령 은 단일 스테핑 모드에서 ⟨expr⟩의 평가를 시작합니다. ⟨expr⟩을 생략하면 현재 중단 점에서 한 단계 씩 진행됩니다. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt; &lt;code&gt;:steplocal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt; &lt;code&gt;:stepmodule&lt;/code&gt; &lt;/a&gt; 명령은 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a632ebd88f50b8ac78cacda34b5408a0be9ab51c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:break 2&lt;/code&gt; sets a breakpoint on line 2 of the most recently-loaded module, in this case &lt;code&gt;qsort.hs&lt;/code&gt;. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:break 2&lt;/code&gt; 명령 은 가장 최근에로드 된 모듈의 2 행에 중단 점을 설정합니다 (이 경우 &lt;code&gt;qsort.hs&lt;/code&gt; ) . 특히, 중단 점을 설정할 해당 행에서 가장 왼쪽의 완전한 하위 표현식을 선택합니다.이 경우 표현식입니다 &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e40dd230e05a9e07fe62ec45624d094d383aa421" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:info!&lt;/code&gt; works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</source>
          <target state="translated">명령 &lt;code&gt;:info!&lt;/code&gt; 비슷한 방식으로 작동하지만 제한 범위 (b)를 제거하여 범위 내에 있고 머리에 ⟨name⟩을 언급하는 모든 인스턴스를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="db3abb134ad672048db99caf88a85888bde3b864" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; finds the end of every complete sample in &lt;code&gt;FOO.hp&lt;/code&gt;, and labels each sample with its ending line number. We then select the line number of the last complete sample using &lt;strong&gt;tail&lt;/strong&gt; and &lt;strong&gt;cut&lt;/strong&gt;. This is used as a parameter to &lt;strong&gt;head&lt;/strong&gt;; the result is as if we deleted the final incomplete sample from &lt;code&gt;FOO.hp&lt;/code&gt;. This results in a properly-formatted .hp file which we feed directly to &lt;strong&gt;hp2ps&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; 명령 은 &lt;code&gt;FOO.hp&lt;/code&gt; 에서 모든 완료된 샘플의 끝을 찾고 각 샘플의 끝 줄 번호로 레이블을 지정합니다. 그런 다음 &lt;strong&gt;tail&lt;/strong&gt; and &lt;strong&gt;cut을&lt;/strong&gt; 사용하여 마지막으로 완성 된 샘플의 라인 번호를 선택합니다 . 이것은 &lt;strong&gt;향하는&lt;/strong&gt; 매개 변수로 사용됩니다 . 결과는 &lt;code&gt;FOO.hp&lt;/code&gt; 에서 최종 불완전한 샘플을 삭제 한 것과 같습니다 . 그러면 올바른 형식의 .hp 파일이 생성되어 &lt;strong&gt;hp2ps에&lt;/strong&gt; 직접 공급됩니다 .</target>
        </trans-unit>
        <trans-unit id="270408c21f336615635c1e2a2c6f2941c9ac84d6" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the program</source>
          <target state="translated">프로그램에 전달 된 명령 행 인수</target>
        </trans-unit>
        <trans-unit id="e7e794e0f93c2fa925b60afdb7fbdedb64d80c09" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the runtime system</source>
          <target state="translated">런타임 시스템에 전달 된 명령 행 인수</target>
        </trans-unit>
        <trans-unit id="77b364d49a3dfa5e15b2ed62d447248ab845ef6f" translate="yes" xml:space="preserve">
          <source>The command to run, which must be in the $PATH, or an absolute or relative path</source>
          <target state="translated">실행할 명령 ($ PATH 또는 절대 또는 상대 경로에 있어야 함)</target>
        </trans-unit>
        <trans-unit id="a9eb0075b8efba5d950b353dc2ba8dd18856c0b6" translate="yes" xml:space="preserve">
          <source>The command versions of lambda abstraction and application are analogous to the expression versions. In particular, the beta and eta rules describe equivalences of commands. These three features (operators, lambda abstraction and application) are the core of the notation; everything else can be built using them, though the results would be somewhat clumsy. For example, we could simulate &lt;code&gt;do&lt;/code&gt;-notation by defining</source>
          <target state="translated">람다 추상화 및 응용 프로그램의 명령 버전은 표현식 버전과 유사합니다. 특히 베타 및 에타 규칙은 명령의 동등성을 설명합니다. 이 세 가지 특징 (연산자, 람다 추상화 및 응용)은 표기법의 핵심입니다. 결과는 다소 어색하지만 다른 모든 것은 그것들을 사용하여 만들 수 있습니다. 예를 들어, 다음을 정의 하여 &lt;code&gt;do&lt;/code&gt; - notation을 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69ed99fc3cead2f4b29389ab07a3549b66be32cf" translate="yes" xml:space="preserve">
          <source>The command-line arguments passed to the program</source>
          <target state="translated">The command-line arguments passed to the program</target>
        </trans-unit>
        <trans-unit id="8a1e2c9e679e0ed25e609bb32dccdb1dffa31a77" translate="yes" xml:space="preserve">
          <source>The comparable symbols for other systems are: &lt;code&gt;__HUGS__&lt;/code&gt; for Hugs, &lt;code&gt;__NHC__&lt;/code&gt; for nhc98, and &lt;code&gt;__HBC__&lt;/code&gt; for hbc).</source>
          <target state="translated">: 다른 시스템에 대한 비교 기호는 &lt;code&gt;__HUGS__&lt;/code&gt; , 포옹에 대한 &lt;code&gt;__NHC__&lt;/code&gt; nhc98을 위해, 그리고 &lt;code&gt;__HBC__&lt;/code&gt; ) HBC 위해.</target>
        </trans-unit>
        <trans-unit id="b172d1caf74bb5840fcb833db8910b15eee4ccf4" translate="yes" xml:space="preserve">
          <source>The compiler does not overwrite an existing &lt;code&gt;.hi&lt;/code&gt; interface file if the new one is the same as the old one; this is friendly to &lt;strong&gt;make&lt;/strong&gt;. When an interface does change, it is often enlightening to be informed. The &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt;&lt;code&gt;-ddump-hi-diffs&lt;/code&gt;&lt;/a&gt; option will make GHC report the differences between the old and new &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">새 파일이 이전 파일과 동일한 경우 컴파일러는 기존 &lt;code&gt;.hi&lt;/code&gt; 인터페이스 파일을 덮어 쓰지 않습니다 . 이에 친절 &lt;strong&gt;하게&lt;/strong&gt; . 인터페이스가 바뀌면 정보를 얻기 위해 종종 깨달아줍니다. &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt; &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; &lt;/a&gt; 옵션은 GHC는 과거와 현재의 차이점에보고 할 것 &lt;code&gt;.hi&lt;/code&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="b50c4e0495b638bc78f832720f50e287f9de7a05" translate="yes" xml:space="preserve">
          <source>The compiler infers that the field is lazy, so it is tagged with &lt;code&gt;'DecidedLazy&lt;/code&gt;. Bear in mind that what the compiler decides may be quite different from what is written in the source. See &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; for a more detailed explanation.</source>
          <target state="translated">컴파일러는 필드가 게으른 것으로 추론하므로 &lt;code&gt;'DecidedLazy&lt;/code&gt; 태그가 지정됩니다 . 컴파일러가 결정한 내용은 소스에 작성된 내용과는 상당히 다를 수 있습니다. 자세한 설명 은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9774a668aa7877058c555311f9fc25aa40959a13" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;-XCPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">컴파일러 버전은 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP 매크로 ( &lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;-XCPP&lt;/code&gt; &lt;/a&gt; 가 사용될 때만 정의 됨 )를 사용 하여 컴파일 된 코드 내에서 테스트 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;표준 CPP 매크로&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8fd806e873a214570099da2d9771dbac6f16d96" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; &lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="23952ceade2f091ff5234e0262e885fb63f5be39" translate="yes" xml:space="preserve">
          <source>The compiler will avoid reboxing &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; by inlining &lt;code&gt;+&lt;/code&gt; on floats, but only when &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">컴파일러는 float에 &lt;code&gt;+&lt;/code&gt; 를 인라인하여 &lt;code&gt;f1&lt;/code&gt; 및 &lt;code&gt;f2&lt;/code&gt; 를 리 박싱하지 않지만 &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 가 켜져 있을 때만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="d31425166e0b9b41d209465f54952b68c26f02ba" translate="yes" xml:space="preserve">
          <source>The compiler will avoid reboxing &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; by inlining &lt;code&gt;+&lt;/code&gt; on floats, but only when &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">컴파일러는 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 가 켜져 있을 때만 부동 소수점에 &lt;code&gt;+&lt;/code&gt; 를 인라인하여 &lt;code&gt;f1&lt;/code&gt; 및 &lt;code&gt;f2&lt;/code&gt; 를 재 박싱하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="de44b9f2e1ef706e339f2edc3608707c2f4d1431" translate="yes" xml:space="preserve">
          <source>The compiler will warn here that the deriving clause doesn&amp;rsquo;t specify a strategy. If the warning is enabled, but &lt;a href=&quot;exts/deriving_strategies#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is not enabled, the compiler will suggest turning on the &lt;a href=&quot;exts/deriving_strategies#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; extension. This option is not on by default, having to be turned on manually or with &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일러는 여기서 파생 절이 전략을 지정하지 않는다고 경고합니다. 경고가 활성화되었지만 &lt;a href=&quot;exts/deriving_strategies#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; 가 활성화되지 않은 경우 컴파일러는 &lt;a href=&quot;exts/deriving_strategies#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; 확장을 활성화하도록 제안 합니다. 이 옵션은 기본적으로 켜져 있지 않으며 수동으로 또는 &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt; &lt;code&gt;-Weverything&lt;/code&gt; &lt;/a&gt; 으로 켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="a57eab48089d44200f2aa63903639e1a99c72105" translate="yes" xml:space="preserve">
          <source>The compiler will warn here that the deriving clause doesn&amp;rsquo;t specify a strategy. If the warning is enabled, but &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is not enabled, the compiler will suggest turning on the &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; extension. This option is not on by default, having to be turned on manually or with &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일러는 파생 조항이 전략을 지정하지 않는다고 경고합니다. 경고는 활성화되어 있지만 &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; 는 활성화되어 있지 않으면 컴파일러는 &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; 확장을 설정하도록 제안 합니다. 이 옵션은 기본적으로 켜져 있지 않으므로 수동으로 또는 &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt; &lt;code&gt;-Weverything&lt;/code&gt; &lt;/a&gt; 으로 켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="364015fc14eeca9fb27fa97b755433aec50ba3bb" translate="yes" xml:space="preserve">
          <source>The compiler will warn when none of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; is specified. This option is off by default.</source>
          <target state="translated">The compiler will warn when none of &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; is specified. This option is off by default.</target>
        </trans-unit>
        <trans-unit id="281ed5525515ea0993e70db30ed197e71b26abff" translate="yes" xml:space="preserve">
          <source>The complete user-supplied kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">완전한 사용자 제공 종류 서명은 &lt;code&gt;T&lt;/code&gt; 의 다형성 종류를 지정하며이 서명은 재귀 호출을 포함하여 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 호출에 사용 됩니다. 특히,의 재귀 사용 &lt;code&gt;T&lt;/code&gt; 는 종류에있다 &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2bfd3d94f53069effc94df0d648f9c72f750ccc" translate="yes" xml:space="preserve">
          <source>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) in the &amp;ldquo;then &lt;code&gt;f&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt;&amp;rdquo; clauses, when the &amp;ldquo;by &lt;code&gt;b&lt;/code&gt;&amp;rdquo; qualifier is omitted, argument &lt;code&gt;f&lt;/code&gt; should have a polymorphic type. In particular, &amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt;&amp;rdquo; are insufficiently polymorphic.</source>
          <target state="translated">&amp;ldquo;by &lt;code&gt;b&lt;/code&gt; &amp;rdquo;한정자가 생략 된 경우&amp;ldquo;then &lt;code&gt;f&lt;/code&gt; &amp;rdquo;및&amp;ldquo;then using &lt;code&gt;f&lt;/code&gt; &amp;rdquo;절의 &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;일반화 (SQL과 유사한 목록 이해&lt;/a&gt; 에서 논의 된 바와 같이)를 제외하고, 설탕 제거가 유형 검사를 수행 할 때 이해력은 유형 점검을해야 합니다 . 인수 &lt;code&gt;f&lt;/code&gt; 는 다형성 유형이어야합니다. 특히 &quot;then &lt;code&gt;Data.List.sort&lt;/code&gt; &quot;및 &quot; &lt;code&gt;Data.List.group&lt;/code&gt; 을 사용하는 그룹 &quot;은 다형성이 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a229e3ce3ae94e6cde0b3a92fc9a7c254663af9a" translate="yes" xml:space="preserve">
          <source>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in &lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) in the &amp;ldquo;then &lt;code&gt;f&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt;&amp;rdquo; clauses, when the &amp;ldquo;by &lt;code&gt;b&lt;/code&gt;&amp;rdquo; qualifier is omitted, argument &lt;code&gt;f&lt;/code&gt; should have a polymorphic type. In particular, &amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt;&amp;rdquo; are insufficiently polymorphic.</source>
          <target state="translated">comprehension은 desugaring이 typecheck 할 때 typecheck해야합니다. 단 ,&amp;ldquo;then &lt;code&gt;f&lt;/code&gt; &amp;rdquo;및&amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt; &amp;rdquo;절에서 &quot;by &lt;code&gt;b&lt;/code&gt; &quot;한정자가 생략 된 경우를 제외하고는 &lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;일반화 된 (SQL과 유사한) List Comprehensions&lt;/a&gt; 에서 설명합니다 . 인수 &lt;code&gt;f&lt;/code&gt; 는 다형성 유형을 가져야합니다. 특히&amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt; &amp;rdquo;와&amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt; &amp;rdquo;은 다형성이 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e59db8b8873fb6251bff5cd6dfad77bf9b5938cd" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; 계산 은 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서만 작동한다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="4db661a0ed20c5ec5982f7d8919849e8c9e5e488" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서만 작동한다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="cebda4e55c3afba7a9d7719124e3ada63e52bb27" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 함수는 문자열 &lt;code&gt;str&lt;/code&gt; 을 파일 &lt;code&gt;file&lt;/code&gt; 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="46965f614145fd2e0bb961350e8543a37e0dd3ca" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 함수는 문자열 &lt;code&gt;str&lt;/code&gt; 을 파일 &lt;code&gt;file&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7a4547aaf52f671ee4d0ac2c8d5630bfc87a6e62" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 계산 은 운영 체제 명령 &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; 를 실행하여 재미있는 이스케이프 또는 쉘 메타 구문 확장없이 주어진대로 정확하게 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 문자열 을 인수로 수신 합니다. 따라서 이상의 운영 체제 사이에 더 이식 동작합니다 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9a90ff37849eb4211f81461b5303f42712fea0c" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 계산 은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 와 같습니다. 여기서 &lt;em&gt;exitfail&lt;/em&gt; 은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="36e8bf647c12299f893bf95551889fc682fcb895" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt;exitfail&lt;/em&gt; &lt;code&gt;)&lt;/code&gt; , where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</target>
        </trans-unit>
        <trans-unit id="af09cf3e940a006a6f925e848e4a5d531edbfff7" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">계산 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 와 동일하며 여기서 &lt;em&gt;exitfail&lt;/em&gt; 은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fc29dbc900c1c24c106776b04df9bca05e5cfe6e" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 계산 은 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 와 같습니다. 여기서 &lt;em&gt;exitfail&lt;/em&gt; 은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fb6d36ed658ece003695ded60aa84d344703fa74" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;, It terminates the program successfully.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; 계산 은 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 와 동일 하며 프로그램을 성공적으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a4d04e67ce9ab76c0bbbdea2ad0f01cd7fcbeeb5" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 함수는 문자열 &lt;code&gt;str&lt;/code&gt; 을 파일 &lt;code&gt;file&lt;/code&gt; 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="18d116851ac5689419eab11fff58738d4aba225b" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; 계산 은 &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서만 작동한다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="46ebfbedadd3b348e49908c00c7a136ae0a3b598" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 함수는 문자열 &lt;code&gt;str&lt;/code&gt; 을 파일 &lt;code&gt;file&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="beccc8e7666a74c9241e66c916390d713f7e9a28" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 운영 체제 명령 실행 &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; 는 인수로 수신하는 방식으로 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 문자열이 정확히 같은 재미없는 이스케이프 또는 쉘 메타 구문 확장하면서 설명한다. 따라서 이상의 운영 체제 사이에 더 이식 동작합니다 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1a05335883c13dae3be1b4a36833b306a5efd1" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">계산은 가능하면 동시에 다른 스레드에 의해 여러 번 수행 될 수 있습니다. 계산이 한 번만 수행되도록하려면 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="44b39b2d94fcf4d161bbbadc2ba27b97f45eae93" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">계산은 가능하면 동시에 다른 스레드에 의해 여러 번 수행 될 수 있습니다. 계산이 한 번만 수행되도록하려면 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="add1c55634d2623f9699ebad8b5515dd2d17e5c6" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">계산은 가능하면 동시에 다른 스레드에 의해 여러 번 수행 될 수 있습니다. 이를 방지하려면 &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; 대신 unsafeInterleaveST를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="07d17cfabe3f3fcfca85238e3259375c3de9c784" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">계산은 가능하면 동시에 다른 스레드에 의해 여러 번 수행 될 수 있습니다. 이를 방지하려면 &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오. 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="52f9695a125810fcb1729c58e4b509090979268c" translate="yes" xml:space="preserve">
          <source>The computation to run</source>
          <target state="translated">실행할 계산</target>
        </trans-unit>
        <trans-unit id="7849b8b63ccfaa0ec4dad86a18080d47939b33fc" translate="yes" xml:space="preserve">
          <source>The concatenation of all the elements of a container of lists.</source>
          <target state="translated">목록 컨테이너의 모든 요소를 ​​연결합니다.</target>
        </trans-unit>
        <trans-unit id="511dfe8f476504df65281a958ed6b2922f8e44b9" translate="yes" xml:space="preserve">
          <source>The concurrency extension for Haskell is described in the paper &lt;em&gt;Concurrent Haskell&lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;.</source>
          <target state="translated">Haskell의 동시성 확장은 &lt;em&gt;Concurrent Haskell &lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz에&lt;/a&gt; 설명되어 있습니다 . 있습니다.</target>
        </trans-unit>
        <trans-unit id="884749f3ebd0c110d3c9675149153a40b35f3f2f" translate="yes" xml:space="preserve">
          <source>The concurrency extension for Haskell is described in the paper &lt;em&gt;Concurrent Haskell&lt;/em&gt;&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;.</source>
          <target state="translated">Haskell의 동시성 확장은 &lt;em&gt;Concurrent Haskell &lt;/em&gt;&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="00393330d59cb21f77b62b7a951195b4749b08f5" translate="yes" xml:space="preserve">
          <source>The conjugate of a complex number.</source>
          <target state="translated">복소수의 켤레입니다.</target>
        </trans-unit>
        <trans-unit id="7e61d83010032d16fcd6d96bc1ee67e74abc2ee7" translate="yes" xml:space="preserve">
          <source>The connected components of a graph. Two vertices are connected if there is a path between them, traversing edges in either direction.</source>
          <target state="translated">그래프의 연결된 구성 요소. 두 정점 사이에 경로가 있으면 두 정점이 연결되어 어느 방향 으로든 모서리를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="b5b6ceffe39d0d5eedc736955541b7ffa6430ede" translate="yes" xml:space="preserve">
          <source>The cons constructor (e.g &lt;code&gt;3:4:[]&lt;/code&gt;)</source>
          <target state="translated">단점 생성자 (예 : &lt;code&gt;3:4:[]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8ba3b2a290b55dc2fc0d0d6af5a22e45514ed39e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">상수 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; 에는 식별 된 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 값이 있습니다. 유효한 메모리 위치와 연관되지 않는다.</target>
        </trans-unit>
        <trans-unit id="28d23ff9245e92f331af466af03ff314f5479be2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">상수 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 에는 고유 한 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 값이 있습니다. 유효한 메모리 위치와 연관되지 않은 있습니다.</target>
        </trans-unit>
        <trans-unit id="9836a72bb97f8856c19c64a657d43deda4d232f2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">상수 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; 는 의 고유 값을 포함 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 유효한 메모리 위치와 연관되지 않는다.</target>
        </trans-unit>
        <trans-unit id="f76a0e137f54f18c3f7ac1708ea489f83a12cf45" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">상수 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 에는 유효한 메모리 위치와 연관되지 않은 고유 한 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d0acfb8c600d07e3b3575390f9c70049148847" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">상수 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 에는 유효한 메모리 위치와 연관되지 않은 고유 한 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aee9b6f259cc959b36e11590eea5cb4db85f0c33" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">상수 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 에는 유효한 메모리 위치와 연관되지 않은 고유 한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde3669019f674519abd41b72eceb3038215dc5e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</target>
        </trans-unit>
        <trans-unit id="9e323b2912a66e4fe9969ad196c1b2488978012c" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 상수 에는 유효한 메모리 위치와 연결되지 않은 &lt;code&gt;&lt;a href=&quot;../base/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 의 고유 값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="799dc66320c38ca69a9441401db6bffcbf9eb360" translate="yes" xml:space="preserve">
          <source>The constant functor.</source>
          <target state="translated">일정한 functor.</target>
        </trans-unit>
        <trans-unit id="15ca88cd220e51ba407b106275a1029cb4b766e9" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">구속 조건 &lt;code&gt;Coercible t1 t2&lt;/code&gt; 는 &lt;code&gt;t1 ~ t2&lt;/code&gt; 와 유사 하지만 역할 ( &lt;a href=&quot;#roles&quot;&gt;역할&lt;/a&gt; ) 의 의미에서 &lt;code&gt;t1&lt;/code&gt; 과 &lt;code&gt;t2&lt;/code&gt; 사이의 표현 평등을 나타냅니다 . &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; 에서 내 보내며 여기에는 설명서도 포함되어 있습니다. 자세한 내용과 논의는 &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;안전한 강제&amp;rdquo;&lt;/a&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cda43f4b9e044bd999f3ffb0d1982eddf1b3ad96" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.14.1.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt; , but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.14.1.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="82fd177c707d5be07d98e3c1e0c1b21a0f17a8f3" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../../libraries/base-4.15.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Coercible t1 t2&lt;/code&gt; 제약 조건 은 &lt;code&gt;t1 ~ t2&lt;/code&gt; 와 유사 하지만 역할 ( &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt; ) 의 의미에서 &lt;code&gt;t1&lt;/code&gt; 과 &lt;code&gt;t2&lt;/code&gt; 간의 표현 평등을 나타냅니다 . 문서도 포함하는 &lt;a href=&quot;../../libraries/base-4.15.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; 에서 내보내집니다 . 자세한 내용과 논의는 &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&quot;안전 강요&quot;&lt;/a&gt; 백서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b45d0e4831d974f0b76095cef9bc4b87f2ec6bb" translate="yes" xml:space="preserve">
          <source>The constraint has fewer constructors and variables (taken together and counting repetitions) than the head</source>
          <target state="translated">구속 조건은 헤드보다 생성자와 변수가 적습니다 (함께 가져오고 반복 계산).</target>
        </trans-unit>
        <trans-unit id="a50d755f429fad42bcff479620bc13360a0c4b46" translate="yes" xml:space="preserve">
          <source>The constraint mentions at least one type variable. So this is allowed:</source>
          <target state="translated">제약 조건에는 하나 이상의 유형 변수가 언급됩니다. 따라서 이것은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce649c6fe844bb02501d53bdc8fcdcf10a388961" translate="yes" xml:space="preserve">
          <source>The constraint mentions no type functions. A type function application can in principle expand to a type of arbitrary size, and so are rejected out of hand</source>
          <target state="translated">제약 조건에는 유형 함수가 없습니다. 유형 함수 응용 프로그램은 원칙적으로 임의 크기의 유형으로 확장 할 수 있으므로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="e1443e2e18615f60be07422db9598a6ab2679217" translate="yes" xml:space="preserve">
          <source>The constraints: &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</source>
          <target state="translated">제약 조건 : &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="112775bf1168cc3582de7a46d153e201b0ce10f8" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">구성 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; 는 계산 내에서 발생하고 완전히 처리되지 않은 IO 오류를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="f2cbf6e1527ac15029debb90371be54661016768" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">구성 &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; 는 계산 내에서 발생하고 완전히 처리되지 않은 IO 오류를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="e1ff01023030bfbb2459f4b8c5a1be98a9a1aebf" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;MkT&lt;/code&gt; defined in this example is kind polymorphic, which is emphasized to the reader by explicitly abstracting over the &lt;code&gt;k&lt;/code&gt; variable. As this variable is marked as inferred, it can not be manually instantiated.</source>
          <target state="translated">이 예제에서 정의 된 생성자 &lt;code&gt;MkT&lt;/code&gt; 는 종류 다형성이며 &lt;code&gt;k&lt;/code&gt; 변수를 명시 적으로 추상화하여 독자에게 강조됩니다 . 이 변수는 추론 된 것으로 표시되므로 수동으로 인스턴스화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9cb341bdfdb67d6c8abafd06a4a86c8917f60b5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 의 생성자 는 크게 &quot;vanilla&quot;구문을 사용하는 생성자 ( &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; )와 GADT 구문을 사용하는 생성자 ( &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; )로 분류 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 추가 유형 변수와 클래스 컨텍스트를 수량화 생성자는 다양한 생성자를 둘러 쌀 수 있습니다. 그러나 수량화하는 유형 변수는 사용되는 생성자 구문에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="96dfdfe1a048f1f49896be9e99d5931a975888f5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 의 생성자 는 크게 &quot;vanilla&quot;구문을 사용하는 생성자 ( &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; )와 GADT 구문을 사용하는 생성자 ( &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; )로 분류 할 수 있습니다. 추가 유형 변수와 클래스 컨텍스트를 수량화 하는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 생성자는 다양한 생성자를 둘러 쌀 수 있습니다. 그러나 수량화하는 유형 변수는 사용되는 생성자 구문에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d2ef5f16504fcf65ef460021616315706e1e4d2a" translate="yes" xml:space="preserve">
          <source>The constructors have rank-2 types:</source>
          <target state="translated">생성자는 순위 -2 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f9e51adba83704f5afe34590e66e2249e5965154" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;OPTIONS_GHC&lt;/code&gt; are appended to the command-line options, so options given in the source file override those given on the command-line.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; 의 내용이 명령 행 옵션에 추가되므로 소스 파일에 제공된 옵션이 명령 행에 제공된 옵션을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="dff9227ff63668c69518bca492a298e49c135a62" translate="yes" xml:space="preserve">
          <source>The contents of this module is liable to change, or disappear entirely. Please &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;let me know&lt;/a&gt; if you depend on anything here.</source>
          <target state="translated">이 모듈의 내용은 변경되거나 완전히 사라질 수 있습니다. 제발 &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;알려주세요&lt;/a&gt;당신이 여기에 무엇이든 의존하는 경우 .</target>
        </trans-unit>
        <trans-unit id="8a40246a3e18d1d7e41c15d6857dbf0b4d63fa72" translate="yes" xml:space="preserve">
          <source>The contents of this module may change &lt;strong&gt;in any way whatsoever&lt;/strong&gt; and &lt;strong&gt;without any warning&lt;/strong&gt; between minor versions of this package.</source>
          <target state="translated">이 모듈의 내용은 변경 될 수 있습니다 &lt;strong&gt;어떤 방법든지에&lt;/strong&gt; 와 &lt;strong&gt;경고없이&lt;/strong&gt; 이 패키지의 마이너 버전 사이.</target>
        </trans-unit>
        <trans-unit id="bf37f21b6a3daad2c6c95d66502066032ad944e9" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">연속 모나드 변압기. 모든 타입 생성자에 연속 처리를 추가하는 데 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스와 대부분의 작업에서 &lt;code&gt;m&lt;/code&gt; 이 모나드 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="30545a4e8f9d1b896fc755171a6a74c0b349be13" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</target>
        </trans-unit>
        <trans-unit id="ad92561a39c7d3b91010d8e347a46d05d0751570" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">연속 모나드 변환기. 모든 유형 생성자에 연속 처리를 추가하는 데 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스와 대부분의 작업은 &lt;code&gt;m&lt;/code&gt; 이 모나드 일 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f75193e312873c254935fbb8e4b2cdc1397df81b" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;makeAbsolute&lt;/code&gt; function can be found in &lt;code&gt;System.Directory&lt;/code&gt;.</source>
          <target state="translated">해당 &lt;code&gt;makeAbsolute&lt;/code&gt; 함수는 &lt;code&gt;System.Directory&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbffcb96186edf6acc0b855b93198f4a5cdf1151" translate="yes" xml:space="preserve">
          <source>The corresponding translation for an IO-typed &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">IO 유형 &lt;code&gt;e&lt;/code&gt; 에 대한 해당 변환 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86d8b09707b93cf768c10a7d141f2453f73455d0" translate="yes" xml:space="preserve">
          <source>The costs of all CAFs in a module are usually attributed to one &amp;ldquo;big&amp;rdquo; CAF cost-centre. With this option, all CAFs get their own cost-centre. An &amp;ldquo;if all else fails&amp;rdquo; option&amp;hellip;</source>
          <target state="translated">모듈의 모든 CAF 비용은 일반적으로 하나의 &quot;큰&quot;CAF 비용 센터에 기인합니다. 이 옵션을 사용하면 모든 CAF가 자체 비용 중심을 갖습니다. &quot;다른 모든 것이 실패하면&quot;옵션&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7cf65e46a7de9baa89f7b3eb6db073c4649dd328" translate="yes" xml:space="preserve">
          <source>The cumulative allocations of the program in bytes.</source>
          <target state="translated">바이트 단위로 프로그램의 누적 할당.</target>
        </trans-unit>
        <trans-unit id="7a3b930a34c98c0e41a7bef5730a3bbf42841f7f" translate="yes" xml:space="preserve">
          <source>The current implementation of the &lt;code&gt;OverloadedLists&lt;/code&gt; extension can be improved by handling the lists that are only populated with literals in a special way. More specifically, the compiler could allocate such lists statically using a compact representation and allow &lt;code&gt;IsList&lt;/code&gt; instances to take advantage of the compact representation. Equipped with this capability the &lt;code&gt;OverloadedLists&lt;/code&gt; extension will be in a good position to subsume the &lt;code&gt;OverloadedStrings&lt;/code&gt; extension (currently, as a special case, string literals benefit from statically allocated compact representation).</source>
          <target state="translated">특수한 방식으로 리터럴로 채워진 목록을 처리 하여 &lt;code&gt;OverloadedLists&lt;/code&gt; 확장 의 현재 구현을 개선 할 수 있습니다. 보다 구체적으로, 컴파일러는 간결한 표현을 사용하여 이러한 목록을 정적으로 할당하고 &lt;code&gt;IsList&lt;/code&gt; 인스턴스가 간결한 표현을 활용할 수 있습니다. 다음은이 기능을 장착 &lt;code&gt;OverloadedLists&lt;/code&gt; 확장이 포괄 할 수있는 좋은 위치에있을 것입니다 &lt;code&gt;OverloadedStrings&lt;/code&gt; 의 확장 (현재, 특별한 경우로, 문자열 리터럴은 정적으로 할당 된 컴팩트 한 표현의 혜택).</target>
        </trans-unit>
        <trans-unit id="1ad91c37c3debcd3611b7e9c0f27ffd87d2d02eb" translate="yes" xml:space="preserve">
          <source>The current notion of when two view pattern expressions are &amp;ldquo;the same&amp;rdquo; is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; will not be coalesced.</source>
          <target state="translated">두 개의 뷰 패턴 표현이 &quot;동일&quot;한 시점에 대한 현재 개념은 매우 제한적입니다. 이는 전체 구문 평등조차도 아닙니다. 그러나 여기에는 변수, 리터럴, 응용 프로그램 및 튜플이 포함됩니다. 예를 들어, 두 개의 &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; 인스턴스 ( &quot;hi&quot;, &quot;there&quot;) 가 수집됩니다. 그러나 현재 구현은 알파 동등성과 비교되지 않으므로 &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; 의 두 인스턴스는 통합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a1a29ae3433386a16c919320319cfdd85da4c46" translate="yes" xml:space="preserve">
          <source>The current status of a thread</source>
          <target state="translated">스레드의 현재 상태</target>
        </trans-unit>
        <trans-unit id="82c826fe4c2ec0dd5e2b6732f42c3a1009fa7e05" translate="yes" xml:space="preserve">
          <source>The current thread's stack exceeded its limit. Since an exception has been raised, the thread's stack will certainly be below its limit again, but the programmer should take remedial action immediately.</source>
          <target state="translated">현재 스레드의 스택이 한계를 초과했습니다. 예외가 발생했기 때문에 스레드의 스택은 확실히 다시 한계 아래로 떨어지지 만 프로그래머는 즉시 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed3b026bad78c443d4533994012a8c4a2846cb3c" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;-N&lt;/code&gt; option is available to the Haskell program via &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt;, and it may be changed while the program is running by calling &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-N&lt;/code&gt; 옵션 의 현재 값은 Haskell 프로그램이 &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt; 를 통해 사용할 수 있으며 &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt; 를 호출하여 프로그램이 실행되는 동안 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ec8f77a94455e151e4c1a9e7ec7c517542a0b66" translate="yes" xml:space="preserve">
          <source>The cut-down Haskell lexer, used by Text.Read</source>
          <target state="translated">Text에서 사용하는 컷 다운 Haskell lexer</target>
        </trans-unit>
        <trans-unit id="00bd3d9662d83ac9ec53f0ae935356d4eabc4566" translate="yes" xml:space="preserve">
          <source>The data family &lt;code&gt;URec&lt;/code&gt; is provided to enable generic programming over datatypes with certain unlifted arguments. There are six instances corresponding to common unlifted types:</source>
          <target state="translated">데이터 패밀리 &lt;code&gt;URec&lt;/code&gt; 은 특정 리프팅되지 않은 인수로 데이터 유형에 대한 일반 프로그래밍을 가능하게하기 위해 제공됩니다. 일반적인 리프팅되지 않은 유형에 해당하는 6 가지 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3058c037aeba55737ee0b54b17d0c2036b7f87f" translate="yes" xml:space="preserve">
          <source>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must be precisely the same as types given in the instance head. For example:</source>
          <target state="translated">연관된 유형에 대한 데이터 또는 유형 패밀리 인스턴스는 클래스 매개 변수에 해당하는 유형 색인이 인스턴스 헤드에 제공된 유형과 정확히 동일해야한다는 규칙을 따라야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cc312cbbdd186a59028317a6d6a5545651161f0" translate="yes" xml:space="preserve">
          <source>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must have precisely the same as type given in the instance head. For example:</source>
          <target state="translated">연관된 유형의 데이터 또는 유형 패밀리 인스턴스는 클래스 매개 변수에 해당하는 유형 색인이 인스턴스 헤드에 제공된 유형과 정확히 동일해야한다는 규칙을 따라야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c9753438fba7e9bfbfa96374f6632d59b89893a" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;Foo&lt;/code&gt; has two constructors with types:</source>
          <target state="translated">데이터 유형 &lt;code&gt;Foo&lt;/code&gt; 에는 유형 이있는 두 개의 생성자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e622f9e9a73471a6364b9efb8251bd756d0f5650" translate="yes" xml:space="preserve">
          <source>The data type invariant for lazy &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;: Every &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 대해 변하지 않는 데이터 유형 : 모든 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; 있거나 널이 아닌 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 로 구성됩니다 . 모든 함수는이를 유지해야하며 QC 속성은이를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d0441bbee470c2143c8f36a2d1679d26b7e70ba" translate="yes" xml:space="preserve">
          <source>The data type invariant: Every ByteString is either &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">데이터 유형 불변 : 모든 ByteString이 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; 있거나 널이 아닌 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 구성됩니다 . 모든 함수는이를 유지해야하며 QC 속성은이를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c1e49f4b6a938582409e8668ce41b2adab8537d" translate="yes" xml:space="preserve">
          <source>The data types and monadic constructor functions for Template Haskell are in the library &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt;.</source>
          <target state="translated">Template Haskell의 데이터 유형 및 모나 딕 생성자 함수는 &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; 라이브러리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d85f04588f07b22aadb87552b730e4cf6174d81" translate="yes" xml:space="preserve">
          <source>The data types and monadic constructor functions for Template Haskell are in the library &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt;.</source>
          <target state="translated">Template Haskell의 데이터 유형 및 모나드 생성자 함수는 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; 라이브러리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="65cb9fa712c4ef1743587a031048fc3377115bf6" translate="yes" xml:space="preserve">
          <source>The datatype below derives the &lt;code&gt;Eq&lt;/code&gt; typeclass, but doesn&amp;rsquo;t specify a strategy. When &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt;&lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this.</source>
          <target state="translated">아래의 데이터 유형은 &lt;code&gt;Eq&lt;/code&gt; 유형 클래스를 도출 하지만 전략을 지정하지는 않습니다. 때 &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt; &lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt; &lt;/a&gt; 활성화, 컴파일러는 이것에 대해 경고를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="09ea5a667a11159497b7db70c8ac2393a6a6a569" translate="yes" xml:space="preserve">
          <source>The day of the epoch of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt;, 1970-01-01</source>
          <target state="translated">1970-01-01 의 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt; 시대의 시대</target>
        </trans-unit>
        <trans-unit id="425505b50ca94bcb223c9489d59b624f0fd02138" translate="yes" xml:space="preserve">
          <source>The debugger provides the following:</source>
          <target state="translated">디버거는 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d008597f45a1f7e417f2daa3afa26ed473de0e47" translate="yes" xml:space="preserve">
          <source>The debugging options &lt;code&gt;-Dx&lt;/code&gt; also generate events which are logged using the tracing framework. By default those events are dumped as text to stdout (&lt;code&gt;-Dx&lt;/code&gt; implies &lt;code&gt;-v&lt;/code&gt;), but they may instead be stored in the binary eventlog file by using the &lt;code&gt;-l&lt;/code&gt; option.</source>
          <target state="translated">디버깅 옵션 &lt;code&gt;-Dx&lt;/code&gt; 는 추적 프레임 워크를 사용하여 로그 된 이벤트도 생성합니다. 기본적으로 이러한 이벤트는 stdout에 텍스트로 덤프되지만 ( &lt;code&gt;-Dx&lt;/code&gt; 는 &lt;code&gt;-v&lt;/code&gt; 를 의미 함 ) 대신 &lt;code&gt;-l&lt;/code&gt; 옵션 을 사용하여 이진 이벤트 로그 파일에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dbf33fb940a3d9f2a5b57f121f6732a25396c40" translate="yes" xml:space="preserve">
          <source>The declaration</source>
          <target state="translated">선언</target>
        </trans-unit>
        <trans-unit id="61598f72e2c92204906e453b4899d9c4f265e7a4" translate="yes" xml:space="preserve">
          <source>The declaration for &lt;code&gt;HCons&lt;/code&gt; also requires &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; because of infix type operator &lt;code&gt;(':)&lt;/code&gt;</source>
          <target state="translated">대한 선언 &lt;code&gt;HCons&lt;/code&gt; 은 또한 필요 &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; 때문에 중위 유형의 연산자를 &lt;code&gt;(':)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5349a18df540e12c03489096e2986d42e386fd51" translate="yes" xml:space="preserve">
          <source>The declaration for &lt;code&gt;HCons&lt;/code&gt; also requires &lt;a href=&quot;type_operators#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; because of infix type operator &lt;code&gt;(':)&lt;/code&gt;</source>
          <target state="translated">대한 선언 &lt;code&gt;HCons&lt;/code&gt; 은 또한 필요 &lt;a href=&quot;type_operators#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; 때문에 중위 유형의 연산자를 &lt;code&gt;(':)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4404a7232bfc86c4b3054c2503dd6ddca4de51d" translate="yes" xml:space="preserve">
          <source>The declaration group containing &lt;code&gt;D&lt;/code&gt; is terminated by the empty top-level declaration splice &lt;code&gt;$(return [])&lt;/code&gt; (recall, &lt;code&gt;Q&lt;/code&gt; is a Monad, so we may simply &lt;code&gt;return&lt;/code&gt; the empty list of declarations).</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; 를 포함하는 선언 그룹 은 빈 최상위 선언 스플 라이스 &lt;code&gt;$(return [])&lt;/code&gt; 의해 종료됩니다 ( &lt;code&gt;Q&lt;/code&gt; 는 Monad이므로 빈 선언 목록을 &lt;code&gt;return&lt;/code&gt; 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="c3ea4ce42435200f8c7550076521012105fc2dd4" translate="yes" xml:space="preserve">
          <source>The declarations above are accepted. However, if we add &lt;code&gt;MkOther :: T Int&lt;/code&gt;, we get an error that the equality constraint is not satisfied; &lt;code&gt;Int&lt;/code&gt; is not a type literal. Note that explicitly quantifying with &lt;code&gt;forall a&lt;/code&gt; is necessary in order for &lt;code&gt;T&lt;/code&gt; to typecheck (see &lt;a href=&quot;#complete-kind-signatures&quot;&gt;Complete user-supplied kind signatures and polymorphic recursion&lt;/a&gt;).</source>
          <target state="translated">The declarations above are accepted. However, if we add &lt;code&gt;MkOther :: T Int&lt;/code&gt; , we get an error that the equality constraint is not satisfied; &lt;code&gt;Int&lt;/code&gt; is not a type literal. Note that explicitly quantifying with &lt;code&gt;forall a&lt;/code&gt; is necessary in order for &lt;code&gt;T&lt;/code&gt; to typecheck (see &lt;a href=&quot;#complete-kind-signatures&quot;&gt;Complete user-supplied kind signatures and polymorphic recursion&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="4f3eb1e20a19137970a20b350de0e993090c5f42" translate="yes" xml:space="preserve">
          <source>The declarations and types from signatures of dependencies that will be merged in are not in scope when type checking an &lt;code&gt;hsig&lt;/code&gt; file. To refer to any such type, you must declare it yourself:</source>
          <target state="translated">병합 할 종속성의 서명에서 선언 및 유형은 &lt;code&gt;hsig&lt;/code&gt; 파일을 유형 검사 할 때 범위 내에 있지 않습니다 . 이러한 유형을 참조하려면 직접 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="28bc248b719a26880d510c50487bc9904247476f" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">디코더가 사용 가능한 입력을 소비했으며 계속하려면 더 많은 것이 필요합니다. 제공 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 더 입력이 가능하며, 경우에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그렇지 않으면, 당신은 새로운 얻을 것이다 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17837e6c81e48bb3e926bbb5320107b945f00a06" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">디코더가 사용 가능한 입력을 소비했으며 계속하려면 더 많이 필요합니다. 제공 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 더 입력이 가능하며, 경우에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그렇지 않으면, 당신은 새로운 얻을 것이다 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="730f776720011b753ca2eb355f4f8a8efdb7dabb" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">디코더가 사용 가능한 입력을 소비했으며 계속하려면 더 많이 필요합니다. 제공 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 더 입력이 가능하며, 경우에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그렇지 않으면, 당신은 새로운 얻을 것이다 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7be60721ea4767c773d4ff5809e621bbad6d744b" translate="yes" xml:space="preserve">
          <source>The decoder has successfully finished. Except for the output value you also get any unused input as well as the number of bytes consumed.</source>
          <target state="translated">디코더가 성공적으로 완료되었습니다. 출력 값을 제외하고 사용되지 않은 입력과 소비 된 바이트 수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c50453020b64e1b5897a128e6a4b8f6fd0ce71b8" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">디코더에 오류가 발생했습니다. 디코더가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 했거나 충분한 입력이 제공되지 않았습니다. 소비되지 않은 입력과 소비 된 바이트 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c501f9a41e6b7b39a369772921e2a14165d1beb5" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">디코더에 오류가 발생했습니다. 디코더가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 했거나 충분한 입력이 제공되지 않았습니다. 사용되지 않은 입력 및 사용 된 바이트 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="80d55af0e0a94be932a7e65396c4ffbcb07b2fba" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">디코더에 오류가 발생했습니다. 디코더가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 했거나 충분한 입력이 제공되지 않았습니다. 사용되지 않은 입력 및 사용 된 바이트 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1106af4463a8221ffa09eb5ef1181409ca7b66ab" translate="yes" xml:space="preserve">
          <source>The decoder to isolate</source>
          <target state="translated">분리 할 디코더</target>
        </trans-unit>
        <trans-unit id="81c283366c767d1de7c06c6bf075b9bb441a10c1" translate="yes" xml:space="preserve">
          <source>The deduction (via generativity) that if &lt;code&gt;g x :~: g y&lt;/code&gt; then &lt;code&gt;x :~: y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;g x :~: g y&lt;/code&gt; 다음 &lt;code&gt;x :~: y&lt;/code&gt; 경우 (생성을 통한) 공제 .</target>
        </trans-unit>
        <trans-unit id="9109ffd32c6c50a2b3bbde42b4613b2367726367" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt;, which does no translation on Unix systems, but translates &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; and back on Windows.</source>
          <target state="translated">기본 &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt; 유닉스 시스템에 아무런 번역을하지 않습니다,하지만 변환 &lt;code&gt;'\r\n'&lt;/code&gt; 에 &lt;code&gt;'\n'&lt;/code&gt; 다시 Windows에서하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1abf9eda04f648cec0d055b085fe295d921786f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is the same as the default encoding on your system, which is also available as &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;. (GHC note: on Windows, we currently do not support double-byte encodings; if the console's code page is unsupported, then &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">기본 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 시스템의 기본 인코딩과 동일하며 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 으로 도 제공됩니다 . (GHC 참고 : Windows에서는 현재 2 바이트 인코딩을 지원하지 않습니다. 콘솔의 코드 페이지가 지원되지 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="1f7510baab521b5948629307f9f6f4dc19cd4a03" translate="yes" xml:space="preserve">
          <source>The default backend for GHC. It is a native code generator, compiling Cmm all the way to assembly code. It is the fastest backend and generally produces good performance code. It has the best support for compiling shared libraries. Select it with the &lt;code&gt;-fasm&lt;/code&gt; flag.</source>
          <target state="translated">GHC의 기본 백엔드 Cmm을 어셈블리 코드까지 컴파일하는 기본 코드 생성기입니다. 백엔드가 가장 빠르며 일반적으로 우수한 성능 코드를 생성합니다. 공유 라이브러리를 컴파일하는 데 가장 적합합니다. &lt;code&gt;-fasm&lt;/code&gt; 플래그로 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="372a76ca948e47b638039a6cfbc912e969dc50c4" translate="yes" xml:space="preserve">
          <source>The default buffering mode is different in GHCi to GHC.</source>
          <target state="translated">기본 버퍼링 모드는 GHCi와 GHC에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="612f5aad425db1f69a9dbdbaaa3947648f24e8cc" translate="yes" xml:space="preserve">
          <source>The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered.</source>
          <target state="translated">핸들을 열 때의 기본 버퍼링 모드는 구현에 따라 다르며 해당 핸들에 연결된 파일 시스템 객체에 따라 달라질 수 있습니다. 대부분의 구현에서 실제 파일은 일반적으로 블록 버퍼링되고 터미널은 일반적으로 라인 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="0961e4a3376f291925aa422749fabd42ce25f975" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and the right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">기본 선언은 왼쪽에 유형 &lt;em&gt;변수&lt;/em&gt; 만 언급 하고 오른쪽에는 왼쪽에 명시 적으로 바인딩 된 유형 변수 만 언급해야합니다. 이 제한에 대한 완화되는 &lt;em&gt;종류의&lt;/em&gt; 오른쪽이 암시 적으로 왼쪽에 바인딩 종류의 변수를 언급하는 것을 허용 한, 그러나 변수.</target>
        </trans-unit>
        <trans-unit id="c6f838e51c0c9ed9fe723da0d1493d400aae5e3d" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and type variables may not be repeated on the left-hand side. The right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and type variables may not be repeated on the left-hand side. The right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</target>
        </trans-unit>
        <trans-unit id="e629035dab4042ca2e3774c6dd02fa07a19ca5ba" translate="yes" xml:space="preserve">
          <source>The default definition for &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt;, which is suitable for abstract datatypes with no substructures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 의 기본 정의 는 &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 로 , 하위 구조가없는 추상 데이터 유형에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b37307a1a8b5c8a76936f7e75a2ac6d6c53b888a" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to an identity datatype constructor, using the isomorphism pair as injection and projection.</source>
          <target state="translated">기본 정의 는 주입 및 프로젝션으로 동 형사상 쌍을 사용하여 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 유형의 유형 생성자 &lt;code&gt;c&lt;/code&gt; 를 ID 데이터 유형 생성자로 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="0ebc5859a93e62be528328f3201553481af2edf0" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to the monad datatype constructor, defining injection and projection using &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 정의 는 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 유형의 유형 생성자 &lt;code&gt;c&lt;/code&gt; 를 모나드 데이터 유형 생성자로 인스턴스화 하여 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 을 사용하여 주입 및 투영을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="4bd4056577869d6ffa3c25c8d2085ea54f8f3b3d" translate="yes" xml:space="preserve">
          <source>The default definition is</source>
          <target state="translated">기본 정의는</target>
        </trans-unit>
        <trans-unit id="0c68a975cf82f38a807abb27f8056b694f43e039" translate="yes" xml:space="preserve">
          <source>The default definition is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, which is appropriate for instances of other forms.</source>
          <target state="translated">기본 정의는 &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이며 다른 양식의 인스턴스에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="aa9945acbeccb98293938a8f8c707927dd353e5f" translate="yes" xml:space="preserve">
          <source>The default definition may be overridden with a more efficient version if desired.</source>
          <target state="translated">원하는 경우 기본 정의가 더 효율적인 버전으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71589b344fdce3f6d3065162df2b93817e514841" translate="yes" xml:space="preserve">
          <source>The default definition should be sufficient, but this can be overridden for efficiency.</source>
          <target state="translated">기본 정의는 충분해야하지만 효율성을 위해 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b230bf83d4661530a10d60a3a4832bae81967728" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 정의는 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; 를 사용 합니다 . &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 를 정의하는 인스턴스 도 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; 로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7b8f0470f58f998c4d12f0e8356a21d2ca7b5de3" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 정의는 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; 를 사용 합니다 . &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 를 정의하는 인스턴스 도 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; 로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c58343eea6290f399d2ab6ad1cadcd380e922e3" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 함수 의 기본 정의 는 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 과 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec66529839a9863362b72c24581910fe9d869109" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 함수 의 기본 정의 는 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 과 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="491d8a12b5fa1e7b0bec380645e2c6e813fe0eda" translate="yes" xml:space="preserve">
          <source>The default method definitions in the &lt;code&gt;Exception&lt;/code&gt; class do what we need in this case. You can now throw and catch &lt;code&gt;ThisException&lt;/code&gt; and &lt;code&gt;ThatException&lt;/code&gt; as exceptions:</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 클래스 의 기본 메소드 정의 는이 경우 필요한 것을 수행합니다. 이제 &lt;code&gt;ThisException&lt;/code&gt; 및 &lt;code&gt;ThatException&lt;/code&gt; 을 예외로 throw하고 catch 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06f71be64b1eace75a4676b9f81b6631fa302e4c" translate="yes" xml:space="preserve">
          <source>The default method for &lt;code&gt;put&lt;/code&gt; is then used, corresponding to the generic implementation of serialization. If you are using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, the same instance is generated by simply attaching a &lt;code&gt;deriving Serialize&lt;/code&gt; clause to the &lt;code&gt;UserTree&lt;/code&gt; datatype declaration. For more examples of generic functions please refer to the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;generic-deriving&lt;/a&gt; package on Hackage.</source>
          <target state="translated">그런 다음 일반적인 직렬화 구현에 해당하는 &lt;code&gt;put&lt;/code&gt; 의 기본 방법 이 사용됩니다. &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 를 사용 하는 경우 &lt;code&gt;deriving Serialize&lt;/code&gt; 절을 &lt;code&gt;UserTree&lt;/code&gt; 데이터 유형 선언에 첨부하여 동일한 인스턴스가 생성됩니다 . 제네릭 함수의 더 많은 예는 Hackage 의 &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;제네릭 파생&lt;/a&gt; 패키지 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49619bcbeb14288ef5d75943e47c972ec48f5d75" translate="yes" xml:space="preserve">
          <source>The default method for &lt;code&gt;put&lt;/code&gt; is then used, corresponding to the generic implementation of serialization. If you are using &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, the same instance is generated by simply attaching a &lt;code&gt;deriving Serialize&lt;/code&gt; clause to the &lt;code&gt;UserTree&lt;/code&gt; datatype declaration. For more examples of generic functions please refer to the &lt;a href=&quot;https://hackage.haskell.org/package/generic-deriving&quot;&gt;generic-deriving&lt;/a&gt; package on Hackage.</source>
          <target state="translated">그런 다음 직렬화의 일반 구현에 해당하는 &lt;code&gt;put&lt;/code&gt; 에 대한 기본 메소드 가 사용됩니다. &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 를 사용 하는 경우 &lt;code&gt;deriving Serialize&lt;/code&gt; 절을 &lt;code&gt;UserTree&lt;/code&gt; 데이터 유형 선언에 연결하기 만하면 동일한 인스턴스가 생성됩니다 . 제네릭 함수의 더 많은 예제는 Hackage 의 &lt;a href=&quot;https://hackage.haskell.org/package/generic-deriving&quot;&gt;제네릭 파생&lt;/a&gt; 패키지 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84a8076800f1a94cd466a3ca2cb82ca67bed6590" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">기본 병렬 GC 설정은 일반적으로 병렬 프로그램 (예 : &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt; , Strategies 또는 다중 스레드 사용)에 적합합니다. 그러나, 특히 프로그램에 많은 양의 힙 데이터가 있고 GC가 런타임의 상당 부분 인 경우 단일 스레드 순차 프로그램에 대해서도 병렬 GC를 사용하는 것이 유리합니다. 순차적 프로그램의 병렬 GC를 사용하려면, 적당한와 병렬 실행 가능 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션을 추가적으로이 함께 이전 세대 병렬 GC를 제한하는 것이 도움이 될 수 &lt;code&gt;-qg1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b8f4457b131cbd6a076f86c5f337a8e72b95e39" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24a5c3a876c7bfd8073c3b1a043ba73ff9d03aa2" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.15.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">기본 병렬 GC 설정은 일반적으로 병렬 프로그램 (예 : &lt;a href=&quot;../libraries/base-4.15.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt; , Strategies 또는 다중 스레드를 사용하는 프로그램)에 적합합니다 . 그러나 특히 프로그램에 많은 양의 힙 데이터가 있고 GC가 런타임의 상당 부분을 차지하는 경우 단일 스레드 순차 프로그램에 대해서도 병렬 GC를 사용하는 것이 유익 할 수 있습니다. 순차적 프로그램의 병렬 GC를 사용하려면, 적당한와 병렬 실행 가능 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션을 추가적으로이 함께 이전 세대 병렬 GC를 제한하는 것이 도움이 될 수 &lt;code&gt;-qg1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c469f1e0fe0a399e3c8b4ab9c90096159140285" translate="yes" xml:space="preserve">
          <source>The default preferences which may be overwritten in the &lt;code&gt;.haskeline&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.haskeline&lt;/code&gt; 파일 에서 덮어 쓸 수있는 기본 환경 설정 .</target>
        </trans-unit>
        <trans-unit id="76e553d75634d087dca23d1794203019e46160e9" translate="yes" xml:space="preserve">
          <source>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See &lt;a href=&quot;exts/roles#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">추상 데이터 유형 매개 변수의 기본 역할은 이제 표현입니다. (추상 데이터 유형은 생성자가 나열되지 않은 것입니다.) 다른 역할을 얻으려면 역할 주석을 사용하십시오. ( &lt;a href=&quot;exts/roles#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="2646b613e6eb1c1c85aa64b66ff2f7d3602d210c" translate="yes" xml:space="preserve">
          <source>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See &lt;a href=&quot;glasgow_exts#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">추상 데이터 유형 매개 변수의 기본 역할은 이제 표현입니다. 추상 데이터 유형은 생성자가없는 유형입니다. 다른 역할을 얻으려면 역할 주석을 사용하십시오. &lt;a href=&quot;glasgow_exts#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60620248a38bdba79e7fcf67abe638e2752d6a16" translate="yes" xml:space="preserve">
          <source>The default seems to work well here. If you have plenty of memory, it is usually better to use &lt;code&gt;-H ⟨size⟩&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt;) than to increase &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값은 여기에서 잘 작동하는 것 같습니다. 메모리가 충분하면 일반적으로 &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt; 를 늘리는 것보다 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; ( &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt; 참조) 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3395f0bc00fd88ab55e5b4f27b7ed6fe2e944e0a" translate="yes" xml:space="preserve">
          <source>The default style (&lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt;).</source>
          <target state="translated">기본 스타일 ( &lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af2102e497ed3634f45c2fd75b234c6748ca55b8" translate="yes" xml:space="preserve">
          <source>The definition (of a function, variable, struct or typedef) is written to the C file, and its prototype or extern declaration to the C header. Inline functions are handled correctly. struct definitions and typedefs are written to the C program too. The &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;typedef&lt;/code&gt; keyword must come just after &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="translated">함수, 변수, 구조체 또는 typedef의 정의는 C 파일에 작성되고 프로토 타입 또는 extern 선언은 C 헤더에 작성됩니다. 인라인 함수가 올바르게 처리됩니다. 구조체 정의와 typedef도 C 프로그램에 기록됩니다. &lt;code&gt;inline&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;typedef&lt;/code&gt; 키워드는 바로 뒤에 와야 &lt;code&gt;def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c8661345439bef92de6f21733c68492b49b19b5" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;compatible&amp;rdquo; uses a notion of &amp;ldquo;apart&amp;rdquo;, whose definition in turn relies on type family reduction. This condition of &amp;ldquo;apartness&amp;rdquo;, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</source>
          <target state="translated">&quot;compatible&quot;에 대한 정의는 &quot;apart&quot;라는 개념을 사용하며, 그 정의는 유형 패밀리 축소에 의존합니다. 언급 된 바와 같이이 &quot;아파트 니스&quot;조건은 확인할 수 없으므로이 보수적 인 근사법을 사용합니다. 잠재적으로 무한한 통합 자에 의해서도 두 유형이 통합 될 수 없을 때 두 유형이 분리 된 것으로 간주됩니다. unifier를 무제한으로 허용하면 다음 인스턴스 쌍이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70f33fa7b9f96d835ab103c50be5ec10b816d10e" translate="yes" xml:space="preserve">
          <source>The definition is syntactic:</source>
          <target state="translated">정의는 구문입니다.</target>
        </trans-unit>
        <trans-unit id="df390321900febf5a604611d2971ac50e861f17b" translate="yes" xml:space="preserve">
          <source>The definition of &quot;math symbol&quot; may be a little counter-intuitive depending on one's background:</source>
          <target state="translated">&quot;수학 기호&quot;의 정의는 배경에 따라 약간 반 직관적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9142eae3b3df142878b925196063f3a19a7bf511" translate="yes" xml:space="preserve">
          <source>The definition of (say) &lt;code&gt;build&lt;/code&gt; in &lt;code&gt;GHC/Base.hs&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;GHC/Base.hs&lt;/code&gt; 에서 &lt;code&gt;build&lt;/code&gt; 의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2ee65e9c75aa9258dca0f16a6b10f4fd9a759a9" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;lsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 의 정의는 &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; 유형 을 인스턴스화해야하므로 허용되지 않으므로 거부 됩니다. 다형성 유형으로 다형성 유형 변수를 인스턴스화하는 것을 &lt;em&gt;즉석 다형성&lt;/em&gt; 이라고 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="771404ab6f98868990a30122c2e2669c9b6b0a26" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;rsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt; &amp;rsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; , and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="ed024c34bd63c1441cb3695b992556af082202b2" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;inst&lt;/code&gt; is unchanged from the Haskell Report (roughly, just a type). The &lt;code&gt;context =&amp;gt;&lt;/code&gt; part is optional. That is the only syntactic change to the language.</source>
          <target state="translated">&lt;code&gt;inst&lt;/code&gt; 의 정의는 Haskell Report (대략 유형)와 동일합니다. &lt;code&gt;context =&amp;gt;&lt;/code&gt; 부분은 선택 사항입니다. 이것이 언어에 대한 구문상의 유일한 변화입니다.</target>
        </trans-unit>
        <trans-unit id="0bfdf9f8e4b0cf4d6ac3380a527908a80562e1fe" translate="yes" xml:space="preserve">
          <source>The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced. A good example is looking up a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant computations to be performed eagerly, using &lt;code&gt;seq&lt;/code&gt; or strictness annotations on data constructor fields.</source>
          <target state="translated">리테이너의 정의는 공간 누출의 일반적인 원인을 반영하도록 설계되었습니다. 큰 구조는 평가되지 않은 계산에 의해 유지되며 계산이 강제되면 해제됩니다. 좋은 예는 유한지도에서 값을 찾는 것입니다. 여기서 조회를 적시에 강제하지 않으면 평가되지 않은 조회로 인해 전체 매핑이 유지됩니다. 이러한 종류의 공간 누출은 종종 데이터 생성자 필드에 &lt;code&gt;seq&lt;/code&gt; 또는 strictness 주석을 사용하여 관련 계산을 열심히 수행함으로써 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a4d062a38697a5c692b5c4d00fce9e23429e7b4" translate="yes" xml:space="preserve">
          <source>The delayed RSS update can confuse programmers debugging memory issues, production memory monitoring tools, and end users who may complain about undue memory usage shown in reporting tools, so with this flag it can be turned off.</source>
          <target state="translated">The delayed RSS update can confuse programmers debugging memory issues, production memory monitoring tools, and end users who may complain about undue memory usage shown in reporting tools, so with this flag it can be turned off.</target>
        </trans-unit>
        <trans-unit id="f9455c27066e060f9c4ed319a5e6f962fe125ba2" translate="yes" xml:space="preserve">
          <source>The dependency &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; here specifies that the type &lt;code&gt;e&lt;/code&gt; of elements is uniquely determined by the type of the collection &lt;code&gt;ce&lt;/code&gt;. Note that both parameters of Collects are of kind &lt;code&gt;Type&lt;/code&gt;; there are no constructor classes here. Note too that all of the instances of &lt;code&gt;Collects&lt;/code&gt; that we gave earlier can be used together with this new definition.</source>
          <target state="translated">여기서 &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; 종속성 은 요소 의 유형 &lt;code&gt;e&lt;/code&gt; 가 콜렉션 &lt;code&gt;ce&lt;/code&gt; 의 유형에 의해 고유하게 결정되도록 지정합니다 . Collects의 두 매개 변수는 &lt;code&gt;Type&lt;/code&gt; 입니다 . 여기에는 생성자 클래스가 없습니다. 우리가 앞서 준 &lt;code&gt;Collects&lt;/code&gt; 의 모든 인스턴스는 이 새로운 정의와 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ed435c3cbe535cb6b31533a151482c8d2a49765" translate="yes" xml:space="preserve">
          <source>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</source>
          <target state="translated">GHC의 의존성 생성 단계는 몇 가지 추가 옵션을 취할 수 있으며, 유용 할 수 있습니다. 종속성 생성에 영향을주는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b14601aa73f99ec94b5c907467d51ea631241fb4" translate="yes" xml:space="preserve">
          <source>The dependency is based on file content, not a modification time</source>
          <target state="translated">종속성은 수정 시간이 아니라 파일 내용을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3c358c9fef1903c6b809a8b35e1f6f1eb8d8555a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separately from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">The derivation mechanism can be used separately from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1f589bf2ae89289500dfb7481eba937d3aa5c120" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separately from the data type declaration, using the &lt;a href=&quot;standalone_deriving#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">파생 메커니즘은 &lt;a href=&quot;standalone_deriving#stand-alone-deriving&quot;&gt;독립형 파생 메커니즘을&lt;/a&gt; 사용하여 데이터 유형 선언과 별도로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adeb50d906769008b71fc1da461a1b88d5c5394a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separtely from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">파생 메커니즘은 &lt;a href=&quot;#stand-alone-deriving&quot;&gt;독립형 파생 메커니즘을&lt;/a&gt; 사용하여 데이터 유형 선언과 별도로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7b9b515a6b382dc8b30446310290e049039607a" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">파생 된 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스는 입력 문자열의 토큰 사이에 임의의 Haskell 공백을 허용합니다. 추가 괄호도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0df45d847dca83db9351f4d864dd9921bcab85be" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">파생 된 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스는 입력 문자열의 토큰 사이에 임의의 Haskell 공백을 허용합니다. 추가 괄호도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="827987dc4d21c55f29757d61b2ead342246251b4" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">파생 된 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스는 입력 문자열의 토큰 사이에 임의의 Haskell 공백을 허용합니다. 추가 괄호도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="181a26c0ac10388c1c28e3a4a0bb2c744983c69d" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;HasRing&lt;/code&gt; instance would look like</source>
          <target state="translated">파생 된 &lt;code&gt;HasRing&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4744374c6426f29a0ece90c5038f8bb5efa3725d" translate="yes" xml:space="preserve">
          <source>The derived instance in GHC is equivalent to</source>
          <target state="translated">GHC에서 파생 된 인스턴스는</target>
        </trans-unit>
        <trans-unit id="2aa9649e650abb1ccfd00ab90d331d7948d62cc4" translate="yes" xml:space="preserve">
          <source>The derived instance is obtained by completing the application of the class to the new type:</source>
          <target state="translated">파생 된 인스턴스는 클래스의 응용 프로그램을 새로운 유형으로 완성하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="75901f130a621087c5df4e3c7ff2bcd908627e72" translate="yes" xml:space="preserve">
          <source>The design also relies on &lt;code&gt;Danger&lt;/code&gt; not being able to access the &lt;code&gt;UnsafeRIO&lt;/code&gt; constructor. Unfortunately Template Haskell can be used to subvert module boundaries and so could be used to gain access to this constructor.</source>
          <target state="translated">디자인은 또한 &lt;code&gt;Danger&lt;/code&gt; 가 &lt;code&gt;UnsafeRIO&lt;/code&gt; 생성자 에 접근 할 수 없다는 것에 의존합니다 . 불행히도 Template Haskell은 모듈 경계를 파괴하는 데 사용될 수 있으므로이 생성자에 액세스하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49cc72101ca9237972311dd03a0fd606151e4195" translate="yes" xml:space="preserve">
          <source>The design attempts to restrict the operations that &lt;code&gt;Danger&lt;/code&gt; can perform by using types, specifically the &lt;code&gt;RIO&lt;/code&gt; type wrapper around &lt;code&gt;IO&lt;/code&gt; . The author of &lt;code&gt;Danger&lt;/code&gt; can subvert this though by simply writing arbitrary &lt;code&gt;IO&lt;/code&gt; actions and using &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; to execute them as pure functions.</source>
          <target state="translated">이 디자인은 타입, 특히 &lt;code&gt;IO&lt;/code&gt; 주위 의 &lt;code&gt;RIO&lt;/code&gt; 타입 래퍼 를 사용하여 &lt;code&gt;Danger&lt;/code&gt; 가 수행 할 수 있는 작업을 제한하려고 시도합니다 . &lt;code&gt;Danger&lt;/code&gt; 의 저자는 임의의 &lt;code&gt;IO&lt;/code&gt; 동작을 작성 하고 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; 를 사용하여 순수한 기능으로 실행함으로써이를 파괴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd2da32dc935177290030f66437b8442e648de85" translate="yes" xml:space="preserve">
          <source>The design follows the following principles</source>
          <target state="translated">디자인은 다음 원리를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9466c5e433429a9de73933afb90979fc026c19da" translate="yes" xml:space="preserve">
          <source>The design for this extension is described in details in the &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst&quot;&gt;Linear types proposal&lt;/a&gt;</source>
          <target state="translated">이 확장에 대한 디자인은 &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst&quot;&gt;선형 유형 제안&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8290c7ce1697900c8e40df8ad0fc8ee4040a8ead" translate="yes" xml:space="preserve">
          <source>The design of Safe Haskell covers the following aspects:</source>
          <target state="translated">Safe Haskell의 설계는 다음과 같은 측면을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="db9668c7f3a96172360c5f50287354a3f36ed64a" translate="yes" xml:space="preserve">
          <source>The design of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid is optimized such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid 의 디자인은 다음 과 같이 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="d69ade52bf3d6bc1c9e9d54294cef3da66243040" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">이 결합기의 설계는 &lt;code&gt;timeout n f&lt;/code&gt; 가 &lt;code&gt;f&lt;/code&gt; 가 타임 아웃되지 않는 한 &lt;code&gt;f&lt;/code&gt; 와 정확히 동일하게 동작해야한다는 목표에 따라 결정되었습니다. 이는 &lt;code&gt;f&lt;/code&gt; 가 시간 종료 랩퍼가없는 것과 동일한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; 를 가짐을 의미합니다 . 모든 예외 &lt;code&gt;f&lt;/code&gt; 는 시간 초과를 취소하고 더 ​​이상 전파 될 수 있습니다. &lt;code&gt;f&lt;/code&gt; 가 다른 스레드에 의해 예외를 수신 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a12fd0294a8f0c5a36accd7b8d8d788bbce4f21" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</target>
        </trans-unit>
        <trans-unit id="651e143c8844e8b8b199ffe2f4595e61954e4c3f" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">이 결합기의 디자인은 &lt;code&gt;f&lt;/code&gt; 가 시간 초과되지 않는 한 시간 &lt;code&gt;timeout n f&lt;/code&gt; 가 &lt;code&gt;f&lt;/code&gt; 와 정확히 동일하게 작동해야한다는 목표에 의해 안내되었습니다 . 이것은 &lt;code&gt;f&lt;/code&gt; 가 시간 초과 래퍼없이 가질 수 있는 동일한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; 를 가짐을 의미합니다 . 모든 예외 &lt;code&gt;f&lt;/code&gt; 는 시간 초과를 취소하고 더 ​​위로 전파 될 수 있습니다. &lt;code&gt;f&lt;/code&gt; 가 다른 스레드에 의해 던져진 예외를 수신하는 것도 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="ddf2c08a7e7a13b99ab3673124ddb5f1ed0a8e6e" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">이 결합기의 설계는 &lt;code&gt;timeout n f&lt;/code&gt; 가 &lt;code&gt;f&lt;/code&gt; 가 타임 아웃되지 않는 한 &lt;code&gt;f&lt;/code&gt; 와 정확히 동일하게 동작해야한다는 목표에 따라 결정되었습니다. 이는 &lt;code&gt;f&lt;/code&gt; 가 시간 종료 랩퍼가없는 것과 동일한 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; 를 가짐을 의미합니다 . 모든 예외 &lt;code&gt;f&lt;/code&gt; 는 시간 초과를 취소하고 더 ​​이상 전파 될 수 있습니다. &lt;code&gt;f&lt;/code&gt; 가 다른 스레드에 의해 예외를 수신 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd234e4b4e15d4efe10b5e111d420a8fb768c7de" translate="yes" xml:space="preserve">
          <source>The desugaring of &lt;code&gt;-XApplicativeDo&lt;/code&gt; uses &lt;code&gt;(M.&amp;lt;$&amp;gt;)&lt;/code&gt;, &lt;code&gt;(M.&amp;lt;*&amp;gt;)&lt;/code&gt;, and &lt;code&gt;M.join&lt;/code&gt; (after the the applicative-do grouping has been performed)</source>
          <target state="translated">-XApplicativeDo의 &lt;code&gt;-XApplicativeDo&lt;/code&gt; 은 &lt;code&gt;(M.&amp;lt;$&amp;gt;)&lt;/code&gt; , &lt;code&gt;(M.&amp;lt;*&amp;gt;)&lt;/code&gt; 및 &lt;code&gt;M.join&lt;/code&gt; 을 사용합니다 (applicative-do 그룹화가 수행 된 후).</target>
        </trans-unit>
        <trans-unit id="069d6b594d5ec9b69dd4d93d8ec6094f3feb0544" translate="yes" xml:space="preserve">
          <source>The details of how to create the process are passed in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; record. To make it easier to construct a &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt;, the functions &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are supplied that fill in the fields with default values which can be overriden as needed.</source>
          <target state="translated">프로세스 작성 방법에 대한 세부 사항은 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 레코드에 전달됩니다 . &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 를 보다 쉽게 ​​구성 할 수 있도록 필드에 필요한 값을 대체 할 수있는 기본값으로 필드를 채우는 &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 함수 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4faba3c52f5f6f8ccfc588aad8cbbfccac6eb185" translate="yes" xml:space="preserve">
          <source>The detection of CUSKs is enabled by the &lt;a href=&quot;#extension-CUSKs&quot;&gt;&lt;code&gt;CUSKs&lt;/code&gt;&lt;/a&gt; flag, which is switched on by default. This extension is scheduled for deprecation to be replaced with &lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt;&lt;code&gt;StandaloneKindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The detection of CUSKs is enabled by the &lt;a href=&quot;#extension-CUSKs&quot;&gt; &lt;code&gt;CUSKs&lt;/code&gt; &lt;/a&gt; flag, which is switched on by default. This extension is scheduled for deprecation to be replaced with &lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt; &lt;code&gt;StandaloneKindSignatures&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ed02330a1fbdda98a3ba7bccd58b777f6e21c2c1" translate="yes" xml:space="preserve">
          <source>The developer knows that a monad transformer takes a monad &lt;code&gt;m&lt;/code&gt; into a new monad &lt;code&gt;t m&lt;/code&gt;. But this property is not formally specified in the above declaration. This omission becomes an issue when defining monad transformer composition:</source>
          <target state="translated">개발자는 모나드 변압기가 모나드 &lt;code&gt;m&lt;/code&gt; 을 새로운 모나드 &lt;code&gt;t m&lt;/code&gt; 으로 가져 간다는 것을 알고 있습니다. 그러나이 속성은 위 선언에서 공식적으로 지정되지 않았습니다. 이 누락은 모나드 변압기 구성을 정의 할 때 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="baaf6bdd8fde5eba43c6847cbbb88e9af95ebd7b" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is that this one determines if a function definition will be inlined &lt;em&gt;at a call site&lt;/em&gt;. The other option determines if a function definition will be kept around at all for potential inlining.</source>
          <target state="translated">이것과 &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt; 의 차이점&lt;/a&gt; 은 이것이 함수 정의가 &lt;em&gt;콜 사이트에서&lt;/em&gt; 인라인 될 것인지를 결정한다는 것 입니다. 다른 옵션은 잠재적 인라이닝을 위해 함수 정의를 유지할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7ce598ae08dc7d0d31f3dc6c209cf1408d599371" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for recovery is that in &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; the handler is inside an implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; (see &quot;Asynchronous Exceptions&quot;) which is important when catching asynchronous exceptions, but when catching other kinds of exception it is unnecessary. Furthermore it is possible to accidentally stay inside the implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; by tail-calling rather than returning from the handler, which is why we recommend using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for ordinary exception recovery.</source>
          <target state="translated">복구를 위해 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것의 차이점은 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 에서 핸들러가 암시 적 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ( &quot;비동기 예외&quot;참조) 내에 있다는 점입니다. 이는 비동기 예외를 포착 할 때 중요하지만 다른 종류의 예외를 포착 할 때는 필요하지 않습니다. 또한 처리기에서 반환하지 않고 꼬리 호출 을 통해 실수로 암시 적 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에 머무를 수 있으므로 일반적인 예외 복구 에는 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7baf36ea1c4b3f790ba00b9fa8c653d9d8edc0dc" translate="yes" xml:space="preserve">
          <source>The difference involves the placement of the last type parameter, &lt;code&gt;a&lt;/code&gt;. In the &lt;code&gt;Right&lt;/code&gt; case, &lt;code&gt;a&lt;/code&gt; occurs within the type &lt;code&gt;Either Int a&lt;/code&gt;, and moreover, it appears as the last type argument of &lt;code&gt;Either&lt;/code&gt;. In the &lt;code&gt;Wrong&lt;/code&gt; case, however, &lt;code&gt;a&lt;/code&gt; is not the last type argument to &lt;code&gt;Either&lt;/code&gt;; rather, &lt;code&gt;Int&lt;/code&gt; is.</source>
          <target state="translated">차이점은 마지막 유형 매개 변수 &lt;code&gt;a&lt;/code&gt; 의 배치와 관련됩니다 . 에서 &lt;code&gt;Right&lt;/code&gt; 의 경우, &lt;code&gt;a&lt;/code&gt; 유형 내에서 발생하는 &lt;code&gt;Either Int a&lt;/code&gt; , 그리고 또한, 마지막 형식 인수로 나타납니다 &lt;code&gt;Either&lt;/code&gt; . 에서 &lt;code&gt;Wrong&lt;/code&gt; 경우, 그러나, &lt;code&gt;a&lt;/code&gt; 는 마지막 형식 인수하지 않다 &lt;code&gt;Either&lt;/code&gt; ; 오히려 &lt;code&gt;Int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b237dd43561a7048051c81d4534c2c8653cc063" translate="yes" xml:space="preserve">
          <source>The directory returned is expected to be writable by the current user, but note that it isn't generally considered good practice to store application-specific data here; use &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">반환 된 디렉토리는 현재 사용자가 쓸 수있는 것으로 예상되지만 일반적으로 여기에 응용 프로그램 별 데이터를 저장하는 것은 좋은 방법으로 간주되지 않습니다. 사용 &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="f3fd89060d3d904eb037df5f1a407e3dff7763e4" translate="yes" xml:space="preserve">
          <source>The distinction between these types of folds is critical, both in deciding which &lt;code&gt;Foldable&lt;/code&gt; method to use to perform the reduction efficiently, and in writing &lt;code&gt;Foldable&lt;/code&gt; instances for new structures. Below is a more detailed overview of each type.</source>
          <target state="translated">축소를 효율적으로 수행하기 위해 사용할 &lt;code&gt;Foldable&lt;/code&gt; 방법을 결정 하고 새로운 구조에 대한 &lt;code&gt;Foldable&lt;/code&gt; 인스턴스를 작성 하는 데있어서 이러한 유형의 접기를 구분하는 것이 중요 합니다. 다음은 각 유형에 대한 자세한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="d678522b8fbe1bfba9bfaea6f20349fc6c790192" translate="yes" xml:space="preserve">
          <source>The do-notation of Haskell 98 does not allow &lt;em&gt;recursive bindings&lt;/em&gt;, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</source>
          <target state="translated">Haskell 98의 do-notation은 &lt;em&gt;재귀 바인딩을&lt;/em&gt; 허용하지 않습니다 . 즉, do-expression에 바인딩 된 변수는 텍스트 뒤에 오는 코드 블록에서만 볼 수 있습니다. 이를 바인딩 전체 변수 그룹에서 볼 수있는 let-expression과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="ed0761a6931cceb4a4d7abb1349cfebd091b9cae" translate="yes" xml:space="preserve">
          <source>The document type</source>
          <target state="translated">문서 유형</target>
        </trans-unit>
        <trans-unit id="b44ad1035675a222470b757eea4beb20cf50c47b" translate="yes" xml:space="preserve">
          <source>The document.</source>
          <target state="translated">문서.</target>
        </trans-unit>
        <trans-unit id="f1cdc66d16588511d035499d8789d0de0a61455f" translate="yes" xml:space="preserve">
          <source>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">여기 문서는 GHC에서 템플릿 Haskell의 구현을 설명합니다. 템플릿 Haskell을 이해하기에는 충분하지 않습니다. 투시 &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;위키 페이지를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b602f1ed17410d7a722dcfb0d77938da139d87d4" translate="yes" xml:space="preserve">
          <source>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the &lt;a href=&quot;https://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">여기에있는 문서는 GHC에서 Template Haskell의 실현에 대해 설명합니다. Template Haskell을 이해하기에는 충분히 상세하지 않습니다. 투시 &lt;a href=&quot;https://haskell.org/haskellwiki/Template_Haskell&quot;&gt;위키 페이지를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d161d8e5801d84e4bc6cb6d1ba3399418931f1f" translate="yes" xml:space="preserve">
          <source>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a &lt;code&gt;deriving&lt;/code&gt; clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</source>
          <target state="translated">단점은 상용구 코드가 유형 검사에 실패하면 해당 코드에 대한 오류 메시지가 표시되고 작성하지 않은 것입니다. , 반면에 &lt;code&gt;deriving&lt;/code&gt; 절 사이드 조건은 반드시 보수적이지만, 오류 메시지가 더 이해할 수있다.</target>
        </trans-unit>
        <trans-unit id="0d40a85296a889e2235c05d3e594413e6271c9b0" translate="yes" xml:space="preserve">
          <source>The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary. When the program is built with the &lt;code&gt;-threaded&lt;/code&gt; option (to link against the multithreaded version of the runtime), a thread making a &lt;code&gt;safe&lt;/code&gt; foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns. The runtime maintains a pool of these &lt;em&gt;worker&lt;/em&gt; threads so that multiple Haskell threads can be involved in external calls simultaneously.</source>
          <target state="translated">경량 스레드의 단점은 한 번에 하나만 실행할 수 있으므로 한 스레드가 외래 호출에서 차단되는 경우 다른 스레드는 계속할 수 없다는 것입니다. GHC 런타임은 필요한 경우 전체 OS 스레드를 사용하여이 문제를 해결합니다. 프로그램이 &lt;code&gt;-threaded&lt;/code&gt; 옵션으로 빌드 될 때 (멀티 스레드 버전의 런타임에 연결) &lt;code&gt;safe&lt;/code&gt; 외래 호출을하는 스레드는 시스템의 다른 스레드를 차단하지 않습니다. 다른 OS 스레드는 원래 호출이 반환 될 때까지 Haskell 스레드 실행을 대신합니다. 런타임 은 여러 Haskell 스레드가 외부 호출에 동시에 참여할 수 있도록 이러한 &lt;em&gt;작업자&lt;/em&gt; 스레드 풀을 유지 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="7e1ca2d2eeb59a37201caba0870b3b617ae2b6e7" translate="yes" xml:space="preserve">
          <source>The drag stage, which lasts from the final use until the last reference to the object is dropped.</source>
          <target state="translated">최종 사용에서 객체에 대한 마지막 참조가 삭제 될 때까지 지속되는 드래그 스테이지입니다.</target>
        </trans-unit>
        <trans-unit id="5112337835e0aaa1f4501d77e936abde1e9f5833" translate="yes" xml:space="preserve">
          <source>The dual of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, obtained by swapping the arguments of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">a의 듀얼 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 의 인수를 교환하여 얻은 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7fab6e06621905edcea476fea0795c21d73fe816" translate="yes" xml:space="preserve">
          <source>The dynamic binding constraints are just a new form of predicate in the type class system.</source>
          <target state="translated">동적 바인딩 제약 조건은 형식 클래스 시스템에서 새로운 형식의 조건 자일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="c9658faad340c4e37684884e4b4de1d55529e10f" translate="yes" xml:space="preserve">
          <source>The easiest way to see what &lt;code&gt;-O&lt;/code&gt; (etc.) &amp;ldquo;really mean&amp;rdquo; is to run with &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt;, then stand back in amazement.</source>
          <target state="translated">&lt;code&gt;-O&lt;/code&gt; 등이 실제로 의미 하는 바를 확인하는 가장 쉬운 방법 은 &lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt; 와 함께 실행 한 다음 놀랍도록 반대하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d5eb6a79829c0b2ad6433410a38b38fee844c58" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빈 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ac8593ee22b444a0803d2615c08c3ad783eddab" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빈 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffb10a0d9ca8c58bdee511053f10bf4fc11e9fd3" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">높이와 너비가없는 빈 문서입니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; , hcat , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; 등 의 인수 목록에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c38333a804d1c05d76e22c031e0de30532f2b0b2" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">높이와 너비가없는 빈 문서입니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; , hcat , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; 등 의 인수 목록에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57055327e0a4ff0414ff005dc9f2d958097b63a1" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">높이와 너비가없는 빈 문서입니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; , hcat , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; 등 의 인수 목록에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="322d102fb89074ac997d55fe8155256f83635242" translate="yes" xml:space="preserve">
          <source>The empty stream.</source>
          <target state="translated">빈 스트림.</target>
        </trans-unit>
        <trans-unit id="aaade1a4c344a06009213d97ea6d90338497c9b0" translate="yes" xml:space="preserve">
          <source>The entire string prior to the &lt;em&gt;k&lt;/em&gt;th match (i.e. the prefix)</source>
          <target state="translated">&lt;em&gt;k&lt;/em&gt; 번째 일치 이전의 전체 문자열 (예 : 접두사)</target>
        </trans-unit>
        <trans-unit id="7e6880e4680eabaf9b865ccc3e11f4776c77ad73" translate="yes" xml:space="preserve">
          <source>The environment variable can also be set to the magical values &lt;code&gt;never&lt;/code&gt; or &lt;code&gt;always&lt;/code&gt;, which is equivalent to setting the corresponding &lt;code&gt;-fdiagnostics-color&lt;/code&gt; flag but with lower precedence.</source>
          <target state="translated">환경 변수는 &lt;code&gt;never&lt;/code&gt; 또는 &lt;code&gt;always&lt;/code&gt; 마법 값으로 설정할 수도 있습니다 . 이는 해당 &lt;code&gt;-fdiagnostics-color&lt;/code&gt; 플래그 를 설정하는 것과 같지만 우선 순위는 낮습니다.</target>
        </trans-unit>
        <trans-unit id="e95be2fe9b83d12508c00e4a3f425f900f860572" translate="yes" xml:space="preserve">
          <source>The environment variable name/value pairs. (TODO: encoding?)</source>
          <target state="translated">The environment variable name/value pairs. (TODO: encoding?)</target>
        </trans-unit>
        <trans-unit id="a78af08f35ea577d78dded305fcc5c4e9509b316" translate="yes" xml:space="preserve">
          <source>The epoch of TAI, which is 1858-11-17 00:00:00 TAI.</source>
          <target state="translated">TAI의 시대는 1858-11-17 00:00:00 TAI입니다.</target>
        </trans-unit>
        <trans-unit id="81943c20c210a66a07a8f11e6429a84649f3e7b2" translate="yes" xml:space="preserve">
          <source>The equality test in an overloaded numeric pattern uses whatever &lt;code&gt;(==)&lt;/code&gt; is in scope.</source>
          <target state="translated">오버로드 된 숫자 패턴의 등식 테스트 는 범위에있는 모든 &lt;code&gt;(==)&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="afd1105a178de8acf9d4f7264289cbff2eca2561" translate="yes" xml:space="preserve">
          <source>The equality types</source>
          <target state="translated">평등 유형</target>
        </trans-unit>
        <trans-unit id="c36adceaaf4799a94ea7ebf3aee8bed0bb6f61c1" translate="yes" xml:space="preserve">
          <source>The equations are numbered starting from 0, and the comment after each equation refers to all preceding equations it is incompatible with.</source>
          <target state="translated">The equations are numbered starting from 0, and the comment after each equation refers to all preceding equations it is incompatible with.</target>
        </trans-unit>
        <trans-unit id="1199dfc965e5955380e63499fadc65f9cbd20ac3" translate="yes" xml:space="preserve">
          <source>The equivalent REPL example is:</source>
          <target state="translated">동등한 REPL 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d39f7dfb145cb81010fc146adcc072a6753c454" translate="yes" xml:space="preserve">
          <source>The error message contains some clues as to the transformation happening internally.</source>
          <target state="translated">오류 메시지에는 내부에서 발생하는 변환에 대한 힌트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e467fc1987c039f09f1829c27318997a022a9d" translate="yes" xml:space="preserve">
          <source>The error monad transformer. It can be used to add error handling to other monads.</source>
          <target state="translated">에러 모나드 변압기. 다른 모나드에 오류 처리를 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="584676bca032e15cb39d4d01b07dc527b1765a4e" translate="yes" xml:space="preserve">
          <source>The errors that can be deferred are:</source>
          <target state="translated">지연 될 수있는 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53caa6a4eadedbc6b469bff64565461d1ccdfebf" translate="yes" xml:space="preserve">
          <source>The event manager state.</source>
          <target state="translated">이벤트 관리자 상태</target>
        </trans-unit>
        <trans-unit id="2743b97e9374251f3952bb86a616a8b6b2d9cbac" translate="yes" xml:space="preserve">
          <source>The event-log stream begins with a header describing the event types present in the file. The header is followed by the event records themselves, each of which consist of a 64-bit timestamp</source>
          <target state="translated">The event-log stream begins with a header describing the event types present in the file. The header is followed by the event records themselves, each of which consist of a 64-bit timestamp</target>
        </trans-unit>
        <trans-unit id="5f9ab52fbe55b01321892b7fd29ab1a98bb7681d" translate="yes" xml:space="preserve">
          <source>The example below shows quasi-quotation in action. The quoter &lt;code&gt;expr&lt;/code&gt; is bound to a value of type &lt;code&gt;QuasiQuoter&lt;/code&gt; defined in module &lt;code&gt;Expr&lt;/code&gt;. The example makes use of an antiquoted variable &lt;code&gt;n&lt;/code&gt;, indicated by the syntax &lt;code&gt;'int:n&lt;/code&gt; (this syntax for anti-quotation was defined by the parser&amp;rsquo;s author, &lt;em&gt;not&lt;/em&gt; by GHC). This binds &lt;code&gt;n&lt;/code&gt; to the integer value argument of the constructor &lt;code&gt;IntExpr&lt;/code&gt; when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type &lt;code&gt;String -&amp;gt; a&lt;/code&gt; to generate both an expression parser that returns a value of type &lt;code&gt;Q Exp&lt;/code&gt; and a pattern parser that returns a value of type &lt;code&gt;Q Pat&lt;/code&gt;.</source>
          <target state="translated">아래의 예는 실제 인용을 보여줍니다. 견적서 &lt;code&gt;expr&lt;/code&gt; 은 &lt;code&gt;Expr&lt;/code&gt; 모듈에 정의 된 &lt;code&gt;QuasiQuoter&lt;/code&gt; 유형의 값에 바인딩됩니다 . 이 예에서는 구문 &lt;code&gt;'int:n&lt;/code&gt; '으로 표시되는 인용 부호가있는 변수 &lt;code&gt;n&lt;/code&gt; 을 사용 합니다 (이 인용 부호에 대한 구문 은 GHC가 &lt;em&gt;아니라&lt;/em&gt; 파서 작성자에 의해 정의 됨 ). 패턴 일치시 &lt;code&gt;n&lt;/code&gt; 을 생성자 &lt;code&gt;IntExpr&lt;/code&gt; 의 정수 값 인수에 바인딩 합니다. 인용 부호에 대한 자세한 내용과 SYB를 사용하여 &lt;code&gt;String -&amp;gt; a&lt;/code&gt; 유형의 단일 파서를 활용하는 기술에 대한 설명은 참조 문서를 참조하십시오 .&lt;em&gt;&lt;/em&gt; &lt;code&gt;Q Exp&lt;/code&gt; 유형의 값을 리턴하는 표현식 구문 분석기 와 &lt;code&gt;Q Pat&lt;/code&gt; 유형의 값을 리턴하는 패턴 구문 분석기를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e130d4a858cd5958b963d63c7fe21940f766b4ef" translate="yes" xml:space="preserve">
          <source>The exception itself is bound to a new variable, &lt;code&gt;_exception&lt;/code&gt;.</source>
          <target state="translated">예외 자체는 새로운 변수 &lt;code&gt;_exception&lt;/code&gt; 에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="988d36edf500c18480e248b3ba03ea83da4d2cbf" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">실행 된 조치의 예외 마스킹 상태가 상속됩니다 ( &lt;code&gt;forkIO&lt;/code&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 ( &lt;em&gt;2.7.0.0 이후&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc8f732aa9ca323261d4591444f25b148d16268f" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">실행 된 조치의 예외 마스킹 상태가 상속됩니다 ( &lt;code&gt;forkIO&lt;/code&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 ( &lt;em&gt;2.7.0.0 이후&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebf03146e8f23e21eb8275358c982d6013264e4c" translate="yes" xml:space="preserve">
          <source>The exception thrown by &quot;fail&quot; in the GHCiQ monad</source>
          <target state="translated">GHCiQ 모나드에서 &quot;실패&quot;에 의해 발생 된 예외</target>
        </trans-unit>
        <trans-unit id="ceefa01748ad0dcbb4f9adc6b0c343de52816f7c" translate="yes" xml:space="preserve">
          <source>The exception thrown when an infinite cycle is detected in &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 에서 무한주기가 감지되면 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e73e797f0aaf19c29e3a38b80b61adffd05c8530" translate="yes" xml:space="preserve">
          <source>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</source>
          <target state="translated">이 규칙의 예외는 독립형 파생 선언의 컨텍스트가 단일 와일드 카드 제한 조건이 다음과 같이 컨텍스트로 사용될 때 컨텍스트를 유추 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a9b0765cdd57857b495fa1668f0cbcf42055c10" translate="yes" xml:space="preserve">
          <source>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</source>
          <target state="translated">실행은 이전에 중지 된 지점에서 계속되었으며 이제 중단 점에서 두 번째로 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="11953fb00b8ad70bb93132200530ed5421e8c22b" translate="yes" xml:space="preserve">
          <source>The exit status of a process</source>
          <target state="translated">프로세스의 종료 상태</target>
        </trans-unit>
        <trans-unit id="927dcdbea9e7b5ba6ac39897b83ff1c61f46b2d3" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the expanded right-hand side expression refers to the nearest enclosing variable that is spelled the same as the field name.</source>
          <target state="translated">확장은 순전히 구문이므로 확장 된 오른쪽 표현식은 필드 이름과 동일한 철자가 가장 가까운 둘러싸는 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0bb43782d3d91d6c0cfe9ab486e0facf443af806" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.</source>
          <target state="translated">확장은 순전히 구문이므로 레코드 와일드 카드 식은 생략 된 필드 이름과 같은 철자가 가장 가까운 가장 가까운 둘러싸는 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6fa2123bab4a96fc3dff4e1405c75b76df70f413" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(x `par` y)&lt;/code&gt;&lt;em&gt;sparks&lt;/em&gt; the evaluation of &lt;code&gt;x&lt;/code&gt; (to weak head normal form) and returns &lt;code&gt;y&lt;/code&gt;. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. In this way the available parallelism is spread amongst the real CPUs.</source>
          <target state="translated">표현식 &lt;code&gt;(x `par` y)&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; 의 평가 (약한 머리 정규 형식으로)를 &lt;em&gt;촉발&lt;/em&gt; 하고 &lt;code&gt;y&lt;/code&gt; 를 반환합니다 . 스파크는 FIFO 순서대로 실행되도록 대기하지만 즉시 실행되지는 않습니다. 런타임에서 유휴 CPU가 있음을 감지하면 스파크를 실제 스레드로 변환하고 유휴 CPU에서 새 스레드를 실행할 수 있습니다. 이런 식으로 사용 가능한 병렬 처리가 실제 CPU에 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="60035052d2f9f9dbcb2234d0c35b5862aef3671d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; results in the following lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;encodeUtf8CSV table&lt;/code&gt; 표현식의 결과는 다음과 같은 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ec7656c8e0e128b3c718fea844b6924e7c9db92" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">&lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; 표현식 은 구문 분석기 &lt;code&gt;p&lt;/code&gt; 로 구성된 새로운 순열 구문 분석기를 작성합니다 . 순열 파서의 최종 결과는 함수 반환 값 &lt;code&gt;p&lt;/code&gt; 에 적용된 함수 &lt;code&gt;f&lt;/code&gt; 입니다. 파서 &lt;code&gt;p&lt;/code&gt; 는 빈 입력을 허용하지 않습니다 . 대신 옵션 조합기 ( &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; )를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="688562a46f3c26c92c14ba3e2ae41abc13cf015e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">&lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; 표현식 은 구문 분석기 &lt;code&gt;p&lt;/code&gt; 로 구성된 새로운 순열 구문 분석기를 작성합니다 . 순열 파서의 최종 결과는 함수 반환 값 &lt;code&gt;p&lt;/code&gt; 에 적용된 함수 &lt;code&gt;f&lt;/code&gt; 입니다. 파서 &lt;code&gt;p&lt;/code&gt; 는 빈 입력을 허용하지 않습니다 . 대신 옵션 조합기 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; )를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="133ce73b1396f38f1c484e835e97b17e44814c41" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead.</source>
          <target state="translated">&lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; 식은 파서 &lt;code&gt;p&lt;/code&gt; 로 구성된 새로운 순열 파서를 만듭니다 . 순열 파서의 최종 결과는 함수 반환 값 &lt;code&gt;p&lt;/code&gt; 에 적용된 함수 &lt;code&gt;f&lt;/code&gt; 입니다. 파서 &lt;code&gt;p&lt;/code&gt; 는 선택 사항입니다. 적용 할 수없는 경우 기본값 &lt;code&gt;x&lt;/code&gt; 가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb79b3e4e6a014a406705b86fa9c5b9e188c8b4" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">표현의 &lt;code&gt;makeTokenParser language&lt;/code&gt; 생성 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 의 의 정의를 사용하여 정의됩니다 어휘 파서 포함 기록 &lt;code&gt;language&lt;/code&gt; 기록.</target>
        </trans-unit>
        <trans-unit id="d2c369052f3c05736ed3d0aa835e5b9167fa8ef9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">표현의 &lt;code&gt;makeTokenParser language&lt;/code&gt; 생성 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 의 의 정의를 사용하여 정의됩니다 어휘 파서 포함 기록 &lt;code&gt;language&lt;/code&gt; 기록.</target>
        </trans-unit>
        <trans-unit id="8b086207ac432a47ad80161d4b4db423c87b1bcf" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;parseTest p input&lt;/code&gt; applies a parser &lt;code&gt;p&lt;/code&gt; against input &lt;code&gt;input&lt;/code&gt; and prints the result to stdout. Used for testing parsers.</source>
          <target state="translated">&lt;code&gt;parseTest p input&lt;/code&gt; 표현식은 입력 &lt;code&gt;input&lt;/code&gt; 에 대해 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 적용 하고 결과를 stdout에 인쇄합니다. 파서를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d09630aef55bc10a1cc5f993e20aa9d2c8fa633" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead. Returns a new permutation parser that includes the optional parser &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; 표현식은 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 순열 구문 분석기 &lt;code&gt;perm&lt;/code&gt; 에 추가합니다 . 파서 &lt;code&gt;p&lt;/code&gt; 는 선택 사항입니다. 적용 할 수없는 경우 기본값 &lt;code&gt;x&lt;/code&gt; 가 대신 사용됩니다. 선택적 파서 &lt;code&gt;p&lt;/code&gt; 를 포함하는 새로운 순열 파서를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9774c66620e8ebb6dc4947bd7a30ad32d4083961" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; 표현식은 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 순열 구문 분석기 &lt;code&gt;perm&lt;/code&gt; 에 추가합니다 . 파서 &lt;code&gt;p&lt;/code&gt; 는 빈 입력을 허용하지 않습니다 . 대신 옵션 조합기 ( &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; )를 사용하십시오. &lt;code&gt;p&lt;/code&gt; 를 포함하는 새로운 순열 파서를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c1eff7acfdc904aa55b95ecd8fd5d523b792b889" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; 표현식은 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 순열 구문 분석기 &lt;code&gt;perm&lt;/code&gt; 에 추가합니다 . 파서 &lt;code&gt;p&lt;/code&gt; 는 빈 입력을 허용하지 않습니다 . 대신 옵션 조합기 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; )를 사용하십시오. &lt;code&gt;p&lt;/code&gt; 를 포함하는 새로운 순열 파서를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5b91ada54b3ba346f8466cd7a2f1f8bea7674bcd" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;s (t xs)&lt;/code&gt; does not match the rule &lt;code&gt;&quot;map/map&quot;&lt;/code&gt;, but GHC will substitute for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, giving an expression which does match. If &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</source>
          <target state="translated">&lt;code&gt;s (t xs)&lt;/code&gt; 표현식 은 &lt;code&gt;&quot;map/map&quot;&lt;/code&gt; 규칙과 일치하지 않지만 GHC는 &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;t&lt;/code&gt; 를 대체하여 일치하는 표현식을 제공합니다. 경우 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;t&lt;/code&gt; 가 있었다 (a) 두 번 이상 사용하고, (b) 큰 또는 REDEX는 다음은 치환되지 않을 것이고,이 규칙은 화재 않는다.</target>
        </trans-unit>
        <trans-unit id="efeb52340545b81120b442152fbbc21924dfa6d1" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;updatePosString pos s&lt;/code&gt; 표현식 은 &lt;code&gt;s&lt;/code&gt; 의 모든 문자에 대해 &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; 를 호출 하여 소스 위치 &lt;code&gt;pos&lt;/code&gt; 를 업데이트합니다 . &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a46b242264f8f265b934b320d1ad118b5d5d70f9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;updatePosString pos s&lt;/code&gt; 표현식 은 &lt;code&gt;s&lt;/code&gt; 의 모든 문자에 대해 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; 를 호출 하여 소스 위치 &lt;code&gt;pos&lt;/code&gt; 를 업데이트합니다 . &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5483b1f876b299153ecdf0ce5e6d8239b22dcf61" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;. Its value (literal or negated literal) will be output.</source>
          <target state="translated">표현식은 &lt;code&gt;long&lt;/code&gt; 또는 &lt;code&gt;unsigned long&lt;/code&gt; 으로 변환 가능해야합니다 . 그 값 (리터럴 또는 부정 리터럴)이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="820e3f9e6884aadccb720549e1d4a6de8381de85" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to const char pointer. Its value (string literal) will be output.</source>
          <target state="translated">표현식은 const char 포인터로 변환 가능해야합니다. 그 값 (문자열 리터럴)이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="0a5b6e32463e5a84d94f6198a0b148bf41758e64" translate="yes" xml:space="preserve">
          <source>The expression you are annotating with must have a type with &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances</source>
          <target state="translated">주석을다는 표현식에는 &lt;code&gt;Typeable&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인스턴스 가있는 유형이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6a2b1973077b8ad117174952fdf79b72f3549905" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; and (for some reason) by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; 확장 은 &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; 에&lt;/a&gt; 의해 그리고 어떤 이유로 &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; 에&lt;/a&gt; 의해 암시 됩니다.</target>
        </trans-unit>
        <trans-unit id="2547351b5cd723bd169397d3043f2f105b017cbe" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;type_operators#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; and (for some reason) by &lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; 확장 은 &lt;a href=&quot;type_operators#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; 및 (어떤 이유로) &lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; 에&lt;/a&gt; 의해 암시 됩니다.</target>
        </trans-unit>
        <trans-unit id="c2c1dd16b1be083ccd27c6c41c6082833199d042" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;NoMonoLocalBinds&lt;/code&gt;&lt;/a&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;. You can switch it off again with &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; &lt;/a&gt; but type inference becomes less predictable if you do so. (Read the papers!)</target>
        </trans-unit>
        <trans-unit id="56045ff1bf81ad580973e6c5e5797cb6699258d1" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; 확장 은 &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 의해 암시됩니다 . &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; 를 사용 하여이 기능을 다시 끌 수 있지만 그렇게하면 유형 유추가 예측하기 어려워집니다. (논문을 읽으십시오!)</target>
        </trans-unit>
        <trans-unit id="44fb06b6c47710ff4c991f59097322e9e0e9daaa" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;gadt#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;NoMonoLocalBinds&lt;/code&gt;&lt;/a&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt; 확장 은 &lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;gadt#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 의해 암시됩니다 . &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; 를 사용&lt;/a&gt; 하여 다시 끌 수 있지만 그렇게하면 유형 추론의 예측 가능성이 낮아집니다. (논문을 읽으십시오!)</target>
        </trans-unit>
        <trans-unit id="6edfbf43884f0659ca2c3eed2dacc284530ca4be" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt;&lt;code&gt;QuantifiedConstraints&lt;/code&gt;&lt;/a&gt; introduces &lt;strong&gt;quantified constraints&lt;/strong&gt;, which give a new level of expressiveness in constraints. For example, consider</source>
          <target state="translated">&lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt; &lt;code&gt;QuantifiedConstraints&lt;/code&gt; &lt;/a&gt; 확장 은 &lt;strong&gt;한정된 제약을&lt;/strong&gt; 도입 하여 새로운 차원의 제약을 제공합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5a1fbd6833d7bf7f6b464ba5557bf0f418ef8516" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; also introduces a new keyword &lt;code&gt;rec&lt;/code&gt;, which wraps a mutually-recursive group of monadic statements inside a &lt;code&gt;do&lt;/code&gt; expression, producing a single statement. Similar to a &lt;code&gt;let&lt;/code&gt; statement inside a &lt;code&gt;do&lt;/code&gt;, variables bound in the &lt;code&gt;rec&lt;/code&gt; are visible throughout the &lt;code&gt;rec&lt;/code&gt; group, and below it. For example, compare</source>
          <target state="translated">&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; 확장 은 새로운 키워드 &lt;code&gt;rec&lt;/code&gt; 를 도입 하여 &lt;code&gt;do&lt;/code&gt; 표현식 안에 상호 재귀적인 모나 딕 명령문 그룹을 감싸 단일 명령문을 생성합니다. &lt;code&gt;do&lt;/code&gt; 내부 의 &lt;code&gt;let&lt;/code&gt; 문과 유사하게 &lt;code&gt;rec&lt;/code&gt; 에 바인딩 된 변수 는 &lt;code&gt;rec&lt;/code&gt; 그룹 전체 와 그 아래에 표시됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2340bd5004afb06c66885f9f37fdc1ab908eab6d" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt; is now deprecated: its sole effect is to switch on &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; (and hence &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;) and &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이제 &lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt; 확장 은 더 이상 사용되지 않습니다. 유일한 효과는 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; ) 및 &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를 켜는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e340f5c4dc022842b5a051a902e16bd388985d70" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt; is now deprecated: its sole effect is to switch on &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; (and hence &lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;) and &lt;a href=&quot;data_kinds#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장 &lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt; 은 이제 더 이상 사용되지 않습니다. 유일한 효과는 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; (따라서 &lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; ) 및 &lt;a href=&quot;data_kinds#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를 켜는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d7aee131ad6d19c93d8e0e5cef004d81b83103a" translate="yes" xml:space="preserve">
          <source>The extension adds a new kind of expression for defining arrows:</source>
          <target state="translated">확장은 화살표를 정의하기위한 새로운 종류의 표현을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="68fc04e40e72e9a26d6e832da587e68cf89dce71" translate="yes" xml:space="preserve">
          <source>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</source>
          <target state="translated">확장은 함수 정의의 왼쪽으로 확장되지 않습니다. 접두사 형식으로 이러한 함수를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad6ad2707106caf932a9bcc6bc55d2c587ffc598" translate="yes" xml:space="preserve">
          <source>The extension is enabled with the extension &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장명은 &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; 확장명으로 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="592f0075b3be7dea40fca2f7b78b5f78b8bee1db" translate="yes" xml:space="preserve">
          <source>The extension only affects definitions in this module.</source>
          <target state="translated">확장은이 모듈의 정의에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="dbed722a20b0c81708629361d2e36ddb255e740e" translate="yes" xml:space="preserve">
          <source>The fact that as many elements as possible are translated is used by the IO library in order to report translation errors at the point they actually occur, rather than when the buffer is translated.</source>
          <target state="translated">가능한 많은 요소가 변환된다는 사실은 버퍼가 변환 될 때가 아니라 실제로 발생하는 지점에서 변환 오류를보고하기 위해 IO 라이브러리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9688a61970d69ede4ef28783b4cdd7a6fa982ec" translate="yes" xml:space="preserve">
          <source>The field width is a minimum, not a maximum: it will be expanded as needed to avoid mutilating a value.</source>
          <target state="translated">필드 너비는 최대 값이 아닌 최소값입니다. 값이 잘리지 않도록 필요에 따라 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="766dc6dc2e472365cee52e53c97df5ee0cb680d9" translate="yes" xml:space="preserve">
          <source>The fields in &lt;code&gt;Trade&lt;/code&gt; are marked as strict (using &lt;code&gt;!&lt;/code&gt;) since we don't need laziness here. In practise, you would probably consider using the UNPACK pragma as well. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</source>
          <target state="translated">우리는 여기에 게으름이 필요하지 않기 때문에 &lt;code&gt;Trade&lt;/code&gt; 의 필드는 엄격한 ( &lt;code&gt;!&lt;/code&gt; 사용 ) 으로 표시됩니다 . 실제로 UNPACK 프라 그마 사용을 고려할 수도 있습니다. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5972e4dbbb1da0195c707d37fda525d476ee44e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">의 필드 &lt;code&gt;ExampleConstructor&lt;/code&gt; 는 이 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt; 을 각각.</target>
        </trans-unit>
        <trans-unit id="90aff6649fd9e503bb0cd5dab7faab1470bbcfc9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">의 필드 &lt;code&gt;ExampleConstructor&lt;/code&gt; 는 이 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt; 을 각각.</target>
        </trans-unit>
        <trans-unit id="867052d71989ead15b5268bf62e49c7c19eae92d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;A.hs-boot&lt;/code&gt; is a programmer-written source file. It must live in the same directory as its parent source file &lt;code&gt;A.hs&lt;/code&gt;. Currently, if you use a literate source file &lt;code&gt;A.lhs&lt;/code&gt; you must also use a literate boot file, &lt;code&gt;A.lhs-boot&lt;/code&gt;; and vice versa.</source>
          <target state="translated">&lt;code&gt;A.hs-boot&lt;/code&gt; 파일 은 프로그래머가 작성한 소스 파일입니다. 상위 소스 파일 &lt;code&gt;A.hs&lt;/code&gt; 와 동일한 디렉토리에 있어야합니다 . 현재 읽고 쓸 수있는 원본 파일 &lt;code&gt;A.lhs&lt;/code&gt; 를 사용하는 경우 읽고 쓸 수있는 부팅 파일 인 &lt;code&gt;A.lhs-boot&lt;/code&gt; 를 사용해야합니다 . 그 반대.</target>
        </trans-unit>
        <trans-unit id="9a674c835d28bfb6d72a5275286859913c1e00bf" translate="yes" xml:space="preserve">
          <source>The file contains package IDs and optionally package databases, one directive per line:</source>
          <target state="translated">이 파일에는 패키지 ID와 패키지 데이터베이스 (선택 사항)가 한 줄에 하나씩 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3dad592ba2c56d2ff45ef3e10379f2cd7056cb1" translate="yes" xml:space="preserve">
          <source>The file descriptor is ready to accept a write.</source>
          <target state="translated">파일 디스크립터가 쓰기를 승인 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0a87aafdf7c80c25cee8605761116960c822dc15" translate="yes" xml:space="preserve">
          <source>The file is created with permissions such that only the current user can read/write it.</source>
          <target state="translated">현재 사용자 만 파일을 읽고 쓸 수 있도록 권한으로 파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="cfb39651c9d8c9724affb75edf0166a16b2ab2da" translate="yes" xml:space="preserve">
          <source>The file-header pragmas are: &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt;, &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt;, and &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt;.</source>
          <target state="translated">파일 헤더 프라그 &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt; &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt; , {-# OPTIONS_GHC #-} 및 &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ce398b5e4e0b12caa271926c6711a527e411174" translate="yes" xml:space="preserve">
          <source>The final build step that returns the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 신호 를 반환하는 최종 빌드 단계입니다 .</target>
        </trans-unit>
        <trans-unit id="87005632e427f20e49e6f8bedc0a39a36ece9f40" translate="yes" xml:space="preserve">
          <source>The final bullet (about unifiying instances) makes GHC conservative about committing to an overlapping instance. For example:</source>
          <target state="translated">마지막 탄환 (인스턴스 통합에 대한)은 GHC가 겹치는 인스턴스에 대한 커밋을 보수적으로 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63553fcae8fca9b9e4908ace2ac39b9e81cb2563" translate="yes" xml:space="preserve">
          <source>The final bullet (about unifying instances) makes GHC conservative about committing to an overlapping instance. For example:</source>
          <target state="translated">마지막 글 머리 기호 (인스턴스 통합에 대한)는 GHC가 겹치는 인스턴스 커밋에 대해 보수적으로 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1913f6cc3ff526a515670ed4f1b49aa9b4f8a2bf" translate="yes" xml:space="preserve">
          <source>The final form is just what we want: a simple case expression.</source>
          <target state="translated">마지막 형태는 우리가 원하는 것입니다 : 간단한 대소 문자 표현.</target>
        </trans-unit>
        <trans-unit id="f7d925c1be71fce63599be5c5644561348c21d6e" translate="yes" xml:space="preserve">
          <source>The final layout will be something like</source>
          <target state="translated">최종 레이아웃은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="6729ffbfc62ed5264c25d40a8efb2c10f3b0eeec" translate="yes" xml:space="preserve">
          <source>The final type of &lt;code&gt;unG1&lt;/code&gt; is therefore &lt;code&gt;forall x a. G a (Maybe x) -&amp;gt; forall e. Either e (a, x)&lt;/code&gt;. As a result, one way to use &lt;code&gt;unG1&lt;/code&gt; with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;unG1 @Int @Bool (MkG (Right (True, 42)) ()) @Char&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;unG1&lt;/code&gt; 의 최종 유형은 &lt;code&gt;forall x a. G a (Maybe x) -&amp;gt; forall e. Either e (a, x)&lt;/code&gt; . 결과적으로 &lt;code&gt;unG1&lt;/code&gt; 와 함께 &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 을 사용하는 한 가지 방법 은 &lt;code&gt;unG1 @Int @Bool (MkG (Right (True, 42)) ()) @Char&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c346b4b1087261fd8135095310d9f7fd0d9dfb79" translate="yes" xml:space="preserve">
          <source>The final type of &lt;code&gt;unP1&lt;/code&gt; is therefore &lt;code&gt;forall a. Read a =&amp;gt; G a (Maybe Bool) -&amp;gt; forall e. Either e (a, Bool)&lt;/code&gt;. As a result, one way to use &lt;code&gt;unP1&lt;/code&gt; with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;unP1 @Double (MkG (Right (4.5, True)) ()) @Char&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;unP1&lt;/code&gt; 의 최종 유형은 &lt;code&gt;forall a. Read a =&amp;gt; G a (Maybe Bool) -&amp;gt; forall e. Either e (a, Bool)&lt;/code&gt; . 결과적으로 &lt;code&gt;unP1&lt;/code&gt; 와 함께 &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 을 사용하는 한 가지 방법 은 &lt;code&gt;unP1 @Double (MkG (Right (4.5, True)) ()) @Char&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5411121bd692d30db83b370163f589813359fd32" translate="yes" xml:space="preserve">
          <source>The final type of &lt;code&gt;unT&lt;/code&gt; is therefore &lt;code&gt;forall a b. T a b -&amp;gt; forall e. Either e a&lt;/code&gt;. As a result, one way to use &lt;code&gt;unT&lt;/code&gt; with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;unT @Int @Bool (MkT (Right 1)) @Char&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;unT&lt;/code&gt; 의 최종 유형은 &lt;code&gt;forall a b. T a b -&amp;gt; forall e. Either e a&lt;/code&gt; . 결과적으로 &lt;code&gt;unT&lt;/code&gt; 와 함께 &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용하는 한 가지 방법 은 &lt;code&gt;unT @Int @Bool (MkT (Right 1)) @Char&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="509bc33604e7ee8a244ab55cc215005d17244214" translate="yes" xml:space="preserve">
          <source>The finalizer is given the local type environment at the splice point. Thus &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; is able to find the local definitions when executed inside the finalizer.</source>
          <target state="translated">종료점에는 스플 라이스 지점에서 로컬 유형 환경이 제공됩니다. 따라서 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; 는 finalizer 내에서 실행될 때 로컬 정의를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="147a1899cc99c9241165663b9d1797441102fedd" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">프로그램이 &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 개체에 대한 참조를 유지하는지 여부에 관계없이 종료 자와 키와 값 사이의 관계가 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="d9f13e14cac52cb8d1ac6c69d4a111452644d3b2" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">프로그램이 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 개체에 대한 참조를 유지하는지 여부에 관계없이 종료 자와 키와 값 사이의 관계가 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="deaaee000865e026093bdaeb2c9fc2020dfc3055" translate="yes" xml:space="preserve">
          <source>The fine distinction between different kinds of parse errors allows the system to generate quite good error messages for the user. It also allows error messages that are formatted in different languages. Each kind of message is generated by different combinators:</source>
          <target state="translated">서로 다른 종류의 구문 분석 오류를 미세하게 구분하면 시스템에서 사용자에게 상당히 좋은 오류 메시지를 생성 할 수 있습니다. 또한 다른 언어로 형식화 된 오류 메시지를 허용합니다. 각 종류의 메시지는 서로 다른 결합기에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c672354048c81f22453abece53dcb4410b87ec06" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">첫 번째 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인수는 커서 왼쪽의 줄 내용을 반대로합니다. 두 번째 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인수는 커서 오른쪽의 행 내용입니다.</target>
        </trans-unit>
        <trans-unit id="d34b4a39f6372f80e7ab6dab2763aad3974a8747" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">첫 번째 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인수는 커서 왼쪽에있는 행의 내용을 반대로합니다. 두 번째 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인수는 커서 오른쪽에있는 행의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="b1011e29f58eb5128870bbcd1852b43f2d56e849" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">첫 번째 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인수는 커서 왼쪽에있는 행의 내용을 반대로합니다. 두 번째 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인수는 커서 오른쪽에있는 행의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="e20d358fcdcc868c8bd11a6755028db0bb2e37f3" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Int32&lt;/code&gt; is for the tag. There are two &lt;code&gt;Float32&lt;/code&gt; fields because floating point types can&amp;rsquo;t overlap with other types, because of limitations of the code generator that we&amp;rsquo;re hoping to overcome in the future. The second alternative needs two &lt;code&gt;Float32&lt;/code&gt; fields: The &lt;code&gt;Word32&lt;/code&gt; field is for the &lt;code&gt;Word32#&lt;/code&gt; in the first alternative. The &lt;code&gt;Pointer&lt;/code&gt; field is shared between &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Maybe Int&lt;/code&gt; values of the alternatives.</source>
          <target state="translated">첫 번째 &lt;code&gt;Int32&lt;/code&gt; 는 태그 용입니다. 부동 소수점 유형은 다른 유형과 겹칠 수 없기 때문에 &lt;code&gt;Float32&lt;/code&gt; 필드 는 두 가지 가 있습니다. 앞으로 우리가 극복하고자하는 코드 생성기의 한계 때문입니다. 두 번째 대안은 두 개의 &lt;code&gt;Float32&lt;/code&gt; 필드 가 필요 합니다. &lt;code&gt;Word32&lt;/code&gt; 필드는 첫 번째 대안 의 &lt;code&gt;Word32#&lt;/code&gt; 입니다. &lt;code&gt;Pointer&lt;/code&gt; 필드간에 공유되는 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;Maybe Int&lt;/code&gt; 대안의 값.</target>
        </trans-unit>
        <trans-unit id="349930f2f6ac001a1f1d9bc41ac40db08cbf14ec" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;(l,u)&lt;/code&gt; of each of these operations is a pair specifying the lower and upper bounds of a contiguous subrange of values.</source>
          <target state="translated">이러한 각 연산 의 첫 번째 인수 &lt;code&gt;(l,u)&lt;/code&gt; 는 인접한 하위 범위 값의 하한과 상한을 지정하는 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="98e1b7e625f83ea6b9930c008570eb57a4afec70" translate="yes" xml:space="preserve">
          <source>The first argument of both is an explicit &lt;em&gt;operator&lt;/em&gt; that merges the contribution of an element of the structure with a partial fold over, respectively, either the preceding or following elements of the structure.</source>
          <target state="translated">둘 다의 첫 번째 인수는 구조의 이전 또는 다음 요소를 각각 부분적으로 접은 구조 요소의 기여를 병합 하는 명시 적 &lt;em&gt;연산자&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da354ca0b85aa26c68bc2b60c29e2527cd434859" translate="yes" xml:space="preserve">
          <source>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC&amp;rsquo;s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that &lt;code&gt;k&lt;/code&gt; must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</source>
          <target state="translated">첫 번째 글 머리 기호는 단순히 종속성의 범위가 좁아 야한다는 것을 의미합니다. 두 번째 글 머리 기호는 GHC의 의존성을 유추 할 수있는 능력에 관한 것입니다. 이러한 의존성을 유추하는 것은 어렵고, GHC는 현재 의존성을 명시 적으로 제시 할 것을 요구하는데, 이는 &lt;code&gt;k&lt;/code&gt; 가 유형 변수의 종류로 나타나야 한다는 것을 의미하며 , GHC에게 의존성이 의도 된 것을 명백하게한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5990c2111448ff95032208b84313c09eb4e8e7c7" translate="yes" xml:space="preserve">
          <source>The first clause of &amp;ldquo;compatible&amp;rdquo; is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</source>
          <target state="translated">&quot;호환성&quot;의 첫 번째 절이 더 간단합니다. 두 가지 유형의 패밀리 인스턴스의 패턴이 겹칠 수 없다고 말합니다. 예를 들어 다음은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d05ff555d4b0984db447de192b3bf9a34809e33" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 의 첫 번째 구성 요소는 열린 간격 ( &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; ) ( &lt;code&gt;0.0&lt;/code&gt; 또는 절대 값 &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; ) 에 있도록 크기가 조정되며 , 여기서 &lt;code&gt;b&lt;/code&gt; 는 부동 소수점 기수입니다. 무한대 또는 &lt;code&gt;NaN&lt;/code&gt; 값 에서는 동작이 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f4f7b2948c8c1ae005bcea73d45f0bbfbc9162d6" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 의 첫 번째 구성 요소는 열린 간격 ( &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; ) ( &lt;code&gt;0.0&lt;/code&gt; 또는 절대 값 &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; ) 에 있도록 크기가 조정되며 , 여기서 &lt;code&gt;b&lt;/code&gt; 는 부동 소수점 기수입니다. 무한대 또는 &lt;code&gt;NaN&lt;/code&gt; 값 에서는 동작이 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7a78b840c5ec7a8bd0522ac73f6d9db7e7f7c6e2" translate="yes" xml:space="preserve">
          <source>The first constructor consists of a single field, which is the parameter &lt;code&gt;a&lt;/code&gt;. This is represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt;.</source>
          <target state="translated">첫 번째 생성자는 매개 변수 &lt;code&gt;a&lt;/code&gt; 인 단일 필드로 구성됩니다 . 이것은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a491a7e0c75f57c1c82c6779842a217b78376985" translate="yes" xml:space="preserve">
          <source>The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; up to and including the last match of &lt;code&gt;needle&lt;/code&gt;. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, following the match.</source>
          <target state="translated">반환 된 튜플의 첫 번째 요소는 &lt;code&gt;haystack&lt;/code&gt; 의 접두사 이며 &lt;code&gt;needle&lt;/code&gt; 의 마지막 일치를 포함합니다 . 두 번째는 일치 하는 &lt;code&gt;haystack&lt;/code&gt; 의 나머지 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="d48cef11152d7e2e71a8b3fb779c57c59642ed57" translate="yes" xml:space="preserve">
          <source>The first example from that paper is set out below (&lt;a href=&quot;#th-example&quot;&gt;A Template Haskell Worked Example&lt;/a&gt;) as a worked example to help get you started.</source>
          <target state="translated">이 논문의 첫 번째 예제는 시작하는 데 도움이되는 &lt;a href=&quot;#th-example&quot;&gt;예제로&lt;/a&gt; 아래에 설명되어 있습니다 ( Template Haskell Worked Example ).</target>
        </trans-unit>
        <trans-unit id="9f5e8571c06e192e03c26745db1bf9e5167e5bff" translate="yes" xml:space="preserve">
          <source>The first example is a parser monad in the style of</source>
          <target state="translated">첫 번째 예는 다음과 같은 스타일의 파서 모나드입니다.</target>
        </trans-unit>
        <trans-unit id="344345d2a6c7ebd5be055b17fb828ba147f8861d" translate="yes" xml:space="preserve">
          <source>The first example is a strict fold, which in practice is best performed with &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`.</source>
          <target state="translated">첫 번째 예는 strict fold로, 실제로는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ` 와 함께 수행하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ee9ad851ad837059433c87c70599b4b779461c29" translate="yes" xml:space="preserve">
          <source>The first example is a strict fold, which in practice is best performed with &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`.</source>
          <target state="translated">첫 번째 예는 strict fold로, 실제로는 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ` 와 함께 수행하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e21b7d0fbf673358b9fc910ab3527cb11169b254" translate="yes" xml:space="preserve">
          <source>The first example is a strict fold, which in practice is best performed with &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`.</source>
          <target state="translated">첫 번째 예는 strict fold로, 실제로는 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ` 와 함께 수행하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0db21633e5e7584a4e85ed5e4b67955d4a3ea721" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예는 예외 e 가 발생하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 의 변종에 우선적으로 사용되어야 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내에서 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 다른에 대한 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 반면, &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00faf7d78a638c92e98de0c4bd577d041551012a" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</target>
        </trans-unit>
        <trans-unit id="7a9264a11b232afb865bd5a70544aaa9c229ee38" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예는 예외 e 가 발생하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="bf12173ab90254ce40a51d2687a7ddecbe9ad0b6" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="8f3e5d2c79d3a07179c61145b801c7f34f1307d5" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="00088afbc5cbb44faba064e52d1c85ccc7ca138f" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예는 예외 e 가 발생하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="3192e8f3b39e6ecb06656a1ed30e4d50abfc6c52" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="7ed74d4567fdb2bf2c77234153b706fdcff07852" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="d99c86cee59c7b0e9addd7c9710d9c1d2d607961" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예는 예외 e 가 발생하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="eb5048f17b8e4737b6386ce45f982b9c57b947c5" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 의 변형이 우선하여 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내의 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에 그것은 다른 관련하여 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 에서 동작하는 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않는다.</target>
        </trans-unit>
        <trans-unit id="61f2b73f50ebef4a57359acc8a1b5ae0989d7aec" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 의 변종에 우선적으로 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내에서 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 다른에 대한 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b34efd21f2daa7d49fe1224a63934d829e838b06" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예는 예외 e 가 발생하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 의 변종에 우선적으로 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내에서 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 다른에 대한 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab75401d78178ad0148e08455bf616c83bbfdc3d" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 의 변종에 우선적으로 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내에서 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 다른에 대한 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c46e0719305fcb7afbedd529b28ef7ed1317a3e9" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예는 예외 e 가 발생하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 의 변종에 우선적으로 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내에서 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 다른에 대한 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d90a57ad5eaafaf589120d5639047d2ad20009e" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</target>
        </trans-unit>
        <trans-unit id="7decfb29cf2701853ea9c894d57d341004df9185" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">첫 번째 예에서는 예외 &lt;code&gt;e&lt;/code&gt; 가 발생하지만 두 번째 예에서는 발생 하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서 사용될 때만 예외가 발생하도록합니다 . &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 의 변종에 우선적으로 사용되어야 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 내에서 예외를 발생하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 다른에 대한 순서를 보장하기 때문에 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 반면, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8377e7f947ca82c2d03b9e96804a9cc74da945a8" translate="yes" xml:space="preserve">
          <source>The first form declares that &lt;code&gt;f&lt;/code&gt; is a (pure) C function that takes no arguments and returns a pointer to a C function with type &lt;code&gt;t&lt;/code&gt;, whereas the second form declares that &lt;code&gt;f&lt;/code&gt; itself is a C function with type &lt;code&gt;t&lt;/code&gt;. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</source>
          <target state="translated">첫 번째 양식은 &lt;code&gt;f&lt;/code&gt; 가 인수가없고 ( &lt;code&gt;t&lt;/code&gt; ) 유형의 C 함수에 대한 포인터를 리턴하는 (순수한) C 함수임을 선언하는 반면, 두 번째 양식은 &lt;code&gt;f&lt;/code&gt; 자체가 &lt;code&gt;t&lt;/code&gt; 유형의 C 함수 임을 선언합니다 . 첫 번째 선언은 일반적으로 실수이며 충돌을 일으키기 때문에 디버그하기 어려운 선언이므로이 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b437c04b578dcbe34c5b61a20dafa47889b4aaf9" translate="yes" xml:space="preserve">
          <source>The first four lines (&lt;code&gt;JOB&lt;/code&gt;, &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;SAMPLE_UNIT&lt;/code&gt;, &lt;code&gt;VALUE_UNIT&lt;/code&gt;) form a header. Each block of lines starting with &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; and ending with &lt;code&gt;END_SAMPLE&lt;/code&gt; forms a single sample (you can think of this as a vertical slice of your heap profile). The hp2ps utility should accept any input with a properly-formatted header followed by a series of &lt;em&gt;complete&lt;/em&gt; samples.</source>
          <target state="translated">처음 네 줄 ( &lt;code&gt;JOB&lt;/code&gt; , &lt;code&gt;DATE&lt;/code&gt; , &lt;code&gt;SAMPLE_UNIT&lt;/code&gt; , &lt;code&gt;VALUE_UNIT&lt;/code&gt; )은 헤더를 형성합니다. &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; 로 시작하고 &lt;code&gt;END_SAMPLE&lt;/code&gt; 로 끝나는 각 라인 블록은 단일 샘플을 형성합니다 (이것을 힙 프로파일의 수직 슬라이스로 생각할 수 있습니다). hp2ps 유틸리티는 올바른 형식의 헤더와 일련의 &lt;em&gt;완전한&lt;/em&gt; 샘플이 있는 입력을 수용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c2b82a03029ef67f0b50718409c503eea389a692" translate="yes" xml:space="preserve">
          <source>The first letter of the input is converted to title case, as is every subsequent letter that immediately follows a non-letter. Every letter that immediately follows another letter is converted to lower case.</source>
          <target state="translated">입력되지 않은 문자 바로 다음에 오는 모든 후속 문자와 마찬가지로 입력의 첫 번째 문자가 제목으로 변환됩니다. 다른 문자 바로 뒤에 오는 모든 문자는 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="63efb85344c0aa9c20ebac363da48aba559537ad" translate="yes" xml:space="preserve">
          <source>The first matching axiom we encounter while entailing &lt;code&gt;C a&lt;/code&gt;, is &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;. We have a local axiom &lt;code&gt;B a&lt;/code&gt; available, so now the program is suddenly accepted. This behaviour, where the ordering of an instance context determines whether or not the program is accepted, seems rather confusing for the developer.</source>
          <target state="translated">&lt;code&gt;C a&lt;/code&gt; 를 수반하는 동안 우리가 만나는 첫 번째 일치 공리 는 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; 입니다. 우리는 지역 공리 &lt;code&gt;B a&lt;/code&gt; 를 사용할 수있게되었으므로 이제 프로그램이 갑자기 받아 들여졌습니다. 인스턴스 컨텍스트의 순서에 따라 프로그램의 수락 여부가 결정되는이 동작은 개발자에게 혼동을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0123b61d2574afe7df7113981a9973c5d86d2592" translate="yes" xml:space="preserve">
          <source>The first most common step is the concatenation of two &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Internally, concatenation corresponds to function composition. (Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s can be seen as difference-lists of buffer-filling functions; cf. &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;. ) Function composition is a fast O(1) operation. However, we can use bounded primitives to remove some of these function compositions altogether, which is more efficient.</source>
          <target state="translated">가장 일반적인 첫 번째 단계는 두 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 연결입니다 . 내부적으로 연결은 기능 구성에 해당합니다. ( &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 버퍼 채움 함수의 차이 목록으로 볼 수 있습니다; &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt; 참조 ) 함수 구성은 빠른 O ( 1) 작동. 그러나 우리는 경계 프리미티브를 사용하여 이러한 기능 구성 중 일부를 완전히 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d498a2eb12dfc05986c1bdf328c0f2fb70b8b62" translate="yes" xml:space="preserve">
          <source>The first most common step is the concatenation of two &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Internally, concatenation corresponds to function composition. (Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s can be seen as difference-lists of buffer-filling functions; cf. &lt;a href=&quot;https://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;. ) Function composition is a fast O(1) operation. However, we can use bounded primitives to remove some of these function compositions altogether, which is more efficient.</source>
          <target state="translated">가장 일반적인 첫 번째 단계는 두 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 연결하는 것입니다 . 내부적으로 연결은 함수 구성에 해당합니다. ( &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 버퍼 채우기 함수의 차이점 목록으로 볼 수 있습니다. 참조 : &lt;a href=&quot;https://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt; ) 함수 구성은 빠른 O ( 1) 작동. 그러나 경계가있는 프리미티브를 사용하여 이러한 함수 구성 중 일부를 모두 제거 할 수 있으므로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="2b6aa4f035d3b73aa4ab4041c788e09ed98100cf" translate="yes" xml:space="preserve">
          <source>The first of the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operations, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt;, is a simple action, so we can lift it through &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;InterpM&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">의 첫 번째 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 의 작업은, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; , 간단한 작업은, 우리는 통해 그것을 들어 올릴 수 있도록 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;InterpM&lt;/code&gt; 사용하여 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2faac1fc5843e8344edfa39159393215c540048a" translate="yes" xml:space="preserve">
          <source>The first of these is obviously fine. The second is still fine, although less obviously. The third is not Haskell 98, and risks losing termination of instances.</source>
          <target state="translated">이것들 중 첫 번째는 분명히 괜찮습니다. 덜 명확하지만 두 번째는 여전히 괜찮습니다. 세 번째는 Haskell 98이 아니며 인스턴스 종료를 잃을 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23c2d18f54a6700ee1bddf4a4ced9e452ae0f90" translate="yes" xml:space="preserve">
          <source>The first option is to compile the program twice:</source>
          <target state="translated">첫 번째 옵션은 프로그램을 두 번 컴파일하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="abf1dca0b44a86f075342cd32443de5cb6266cb1" translate="yes" xml:space="preserve">
          <source>The first parameter (path) must be a file path and not a module name. The type of this path is dependent on how the module was loaded into GHCi: If the module was loaded by name, then the path name calculated by GHCi as described in &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt; must be used. If the module was loaded with an absolute or a relative path, then the same path must be specified.</source>
          <target state="translated">The first parameter (path) must be a file path and not a module name. The type of this path is dependent on how the module was loaded into GHCi: If the module was loaded by name, then the path name calculated by GHCi as described in &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt; must be used. If the module was loaded with an absolute or a relative path, then the same path must be specified.</target>
        </trans-unit>
        <trans-unit id="b7637c081a47d73b9bc11cd583b13a110b93646f" translate="yes" xml:space="preserve">
          <source>The first part of the file gives the program name and options, and the total time and total memory allocation measured during the run of the program (note that the total memory allocation figure isn&amp;rsquo;t the same as the amount of &lt;em&gt;live&lt;/em&gt; memory needed by the program at any one time; the latter can be determined using heap profiling, which we will describe later in &lt;a href=&quot;#prof-heap&quot;&gt;Profiling memory usage&lt;/a&gt;).</source>
          <target state="translated">파일의 첫 번째 부분은 프로그램 이름과 옵션, 프로그램 실행 중 측정 된 총 시간 및 총 메모리 할당량을 제공합니다 (총 메모리 할당량은 &lt;em&gt;실제&lt;/em&gt; 메모리 필요량과 동일하지 않습니다) . 후자는 힙 프로파일 링을 사용하여 결정할 수 있습니다. 힙 프로파일 링은 나중에 &lt;a href=&quot;#prof-heap&quot;&gt;메모리 프로파일 링 프로파일 링&lt;/a&gt; 에서 설명 합니다 ).</target>
        </trans-unit>
        <trans-unit id="fef3e13957b592e13b7450a30e6df7cd6f143a71" translate="yes" xml:space="preserve">
          <source>The first phase to run is determined by each input-file suffix, and the last phase is determined by a flag. If no relevant flag is present, then go all the way through to linking. This table summarises:</source>
          <target state="translated">실행할 첫 번째 단계는 각 입력 파일 접미사에 의해 결정되며 마지막 단계는 플래그에 의해 결정됩니다. 관련 플래그가 없으면 링크로 연결하십시오. 이 테이블은 다음을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="145ee321d09d8f6c8d70bccf9d36b9f9aa7af807" translate="yes" xml:space="preserve">
          <source>The first thing we need is generic representations. The &lt;code&gt;GHC.Generics&lt;/code&gt; module defines a couple of primitive types that are used to represent Haskell datatypes:</source>
          <target state="translated">가장 먼저 필요한 것은 일반적인 표현입니다. &lt;code&gt;GHC.Generics&lt;/code&gt; 는 정의를 하스켈의 데이터 유형을 나타내는 데 사용하는 기본 유형의 몇 가지 모듈 :</target>
        </trans-unit>
        <trans-unit id="dcb9aeaafc5a5d6cc7b8b5258a10f22de3bc512c" translate="yes" xml:space="preserve">
          <source>The first two examples are instances where the input and and output of &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; are isomorphic.</source>
          <target state="translated">처음 두 예는 &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 의 입력과 출력 이 동형 인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="654dc2e40c641bf446a1ba1f3e79a7385dd0ca41" translate="yes" xml:space="preserve">
          <source>The first two examples are instances where the input and and output of &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; are isomorphic.</source>
          <target state="translated">처음 두 예는 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 의 입력과 출력 이 동형 인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e5a2b1bfbd7d4f61bc6b42e6c0d20e138a80852e" translate="yes" xml:space="preserve">
          <source>The first two examples are instances where the input and and output of &lt;code&gt;&lt;a href=&quot;prelude#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; are isomorphic.</source>
          <target state="translated">처음 두 예는 &lt;code&gt;&lt;a href=&quot;prelude#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 의 입력과 출력 이 동형 인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="4a1ecb3ae40da3aae2e8c25cd4cee41373d627e8" translate="yes" xml:space="preserve">
          <source>The fixed point of a monadic computation. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; executes the action &lt;code&gt;f&lt;/code&gt; only once, with the eventual output fed back as the input. Hence &lt;code&gt;f&lt;/code&gt; should not be strict, for then &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; would diverge.</source>
          <target state="translated">모나 딕 계산의 고정 점. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; 는 최종 출력을 입력으로 피드백 하여 조치 &lt;code&gt;f&lt;/code&gt; 를 한 번만 실행합니다 . 따라서 &lt;code&gt;f&lt;/code&gt; 는 엄격하지 않아야하며, 따라서 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; 는 분기 될 것이다.</target>
        </trans-unit>
        <trans-unit id="3b861bc9465ad5c567e33d3c5ea5e7f4fe10fe04" translate="yes" xml:space="preserve">
          <source>The fixity of a type operator may be set using the usual fixity declarations but, as in &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;, the function and type constructor share a single fixity.</source>
          <target state="translated">유형 연산자의 고정 성은 일반적인 고 정성 선언을 사용하여 설정할 수 있지만 &lt;a href=&quot;#infix-tycons&quot;&gt;Infix 유형 생성자, 클래스 및 유형 변수에서&lt;/a&gt; 와 같이 함수 및 유형 생성자는 단일 고 정성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="0006bfd24cc5b62b3e47843e523d751dcd598808" translate="yes" xml:space="preserve">
          <source>The fixity of a type operator may be set using the usual fixity declarations but, as in &lt;a href=&quot;infix_tycons#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;, the function and type constructor share a single fixity.</source>
          <target state="translated">형식 연산자의 고정 성은 일반적인 고 정성 선언을 사용하여 설정할 수 있지만 &lt;a href=&quot;infix_tycons#infix-tycons&quot;&gt;Infix 형식 생성자, 클래스 및 형식 변수에서&lt;/a&gt; 와 같이 함수 및 형식 생성자는 단일 고 정성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="397ad5d952fd5d1bd350537f1bb34e2a9d3464c7" translate="yes" xml:space="preserve">
          <source>The fixity of the constructor</source>
          <target state="translated">생성자의 고정</target>
        </trans-unit>
        <trans-unit id="0127191c720e27284ab5a66b202e3464fd573afd" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; also lifts the corresponding restriction on class declarations (&lt;a href=&quot;#superclass-rules&quot;&gt;The superclasses of a class declaration&lt;/a&gt;) and instance declarations (&lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 플래그 는 클래스 선언 (클래스 선언 &lt;a href=&quot;#superclass-rules&quot;&gt;의 수퍼 클래스&lt;/a&gt; ) 및 인스턴스 선언 ( &lt;a href=&quot;#instance-rules&quot;&gt;인스턴스 컨텍스트에 대한 완화 된 규칙&lt;/a&gt; ) 에 대한 해당 제한도 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="680d808c4989476cdf108f73531ac73891762a24" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt;, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</source>
          <target state="translated">플래그 &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 와 유사하지만 , 단일 패턴 만 허용하는 람다 표현식 및 패턴 바인딩에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b79e0ee85c7165a369baa04cb9639b641623921" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt; warns about user-written orphan rules or instances.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt; 플래그 는 사용자 작성 고아 규칙 또는 인스턴스에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="6444f39733d8014ca144750cd7ba00423630703d" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--fprint-evld-with-show&quot;&gt;&lt;code&gt;-fprint-evld-with-show&lt;/code&gt;&lt;/a&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">The flag &lt;a href=&quot;#ghc-flag--fprint-evld-with-show&quot;&gt; &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; &lt;/a&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</target>
        </trans-unit>
        <trans-unit id="97161fdc8b67b4621315c0544c9531583ebc6af8" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the &lt;a href=&quot;../debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;../debugging#dumping-output&quot;&gt;Dumping out compiler intermediate structures&lt;/a&gt;. For each file using Template Haskell, this will show the output in a &lt;code&gt;.dump-splices&lt;/code&gt; file.</source>
          <target state="translated">&lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; 플래그 는 유형이 지정되거나 유형이 지정되지 않은 모든 최상위 선언 스플 라이스의 확장을 표시합니다. 모든 덤프 플래그와 마찬가지로 기본값은이 출력이 stdout으로 전송되는 것입니다. 사소하지 않은 프로그램의 경우 이것을 &lt;a href=&quot;../debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; 플래그 와 결합하는 데 관심이있을 수 있습니다 ( &lt;a href=&quot;../debugging#dumping-output&quot;&gt;컴파일러 중간 구조 덤프&lt;/a&gt; 참조 . Template Haskell을 사용하는 각 파일에 대해 이것은 &lt;code&gt;.dump-splices&lt;/code&gt; 파일에 출력을 표시 합니다. .</target>
        </trans-unit>
        <trans-unit id="311b3a39d89ac70dfd0ebb1cca3a345acfac023f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt; dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file &lt;code&gt;M.th.hs&lt;/code&gt; for each module &lt;code&gt;M&lt;/code&gt; being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using &lt;a href=&quot;../debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; but it always generates a file instead of being coupled to &lt;a href=&quot;../debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</source>
          <target state="translated">&lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt; 플래그 는 컴파일되는 각 모듈 &lt;code&gt;M&lt;/code&gt; 에 대한 파일 &lt;code&gt;M.th.hs&lt;/code&gt; 에서 유형 및 유형이 지정되지 않은 모든 최상위 TH 선언 스플 라이스의 확장을 덤프합니다 . 다른 유형의 스플 라이스 (표현식, 유형 및 패턴)는 표시되지 않습니다. 애플리케이션 개발자는이를 저장소에 체크인하여 템플릿 Haskell에 정의 된 식별자를 grep 할 수 있습니다. 이것은 &lt;a href=&quot;../debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 것과 유사 하지만 항상 &lt;a href=&quot;../debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; 에 결합되는 대신 파일을 생성 합니다.. 형식도 다릅니다. 원본 파일의 코드를 표시하지 않고 생성 된 코드 만 표시하고 원본 파일의 스플 라이스 위치에 대한 설명을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b95d855cdc7665a3449f26c7fa1faf11aa01ee6b" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;a href=&quot;../using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt;&lt;/a&gt; to suppress these warnings.</source>
          <target state="translated">&lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 플래그 는 유형 오류가 런타임으로 연기되는지 여부를 제어합니다. 유형 오류는 여전히 경고로 생성되지만 컴파일을 방해하지는 않습니다. &lt;a href=&quot;../using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt; &lt;/a&gt; 를 사용하여 이러한 경고를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65881eb1bc9a787ba7459a19fc35e1a84e1f288d" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; works in GHCi as well, with one exception: for &amp;ldquo;naked&amp;rdquo; expressions typed at the prompt, type errors don&amp;rsquo;t get delayed, so for example:</source>
          <target state="translated">&lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 플래그 는 GHCi에서도 작동하지만 한 가지 예외가 있습니다. 프롬프트에 입력 된 &quot;naked&quot;표현식의 경우 유형 오류가 지연되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47cb0b5fb9b4f5cbc05ae1ed28f5f328bb28aed6" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;debugging#dumping-output&quot;&gt;Dumping out compiler intermediate structures&lt;/a&gt;. For each file using Template Haskell, this will show the output in a &lt;code&gt;.dump-splices&lt;/code&gt; file.</source>
          <target state="translated">플래그 &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; 는 모든 최상위 선언 스플 라이스의 유형 및 유형이 지정되지 않은 확장을 보여줍니다. 모든 덤프 플래그와 마찬가지로 기본값은이 출력이 stdout으로 전송되는 것입니다. 사소하지 않은 프로그램의 경우이를 &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; 플래그 와 결합하는 데 관심이있을 수 있습니다 ( &lt;a href=&quot;debugging#dumping-output&quot;&gt;컴파일러 중간 구조 덤프&lt;/a&gt; 참조) . 템플리트 Haskell을 사용하는 각 파일의 경우 &lt;code&gt;.dump-splices&lt;/code&gt; 파일에 출력이 표시 됩니다. .</target>
        </trans-unit>
        <trans-unit id="4495b2a19abefc172f62863056de3aa383544711" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt; dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file &lt;code&gt;M.th.hs&lt;/code&gt; for each module &lt;code&gt;M&lt;/code&gt; being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; but it always generates a file instead of being coupled to &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</source>
          <target state="translated">플래그 &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt; 은 컴파일되는 각 모듈 &lt;code&gt;M&lt;/code&gt; 의 &lt;code&gt;M.th.hs&lt;/code&gt; 파일에서 유형이 지정되거나 유형이 지정되지 않은 모든 최상위 TH 선언 스플 라이스의 확장을 덤프합니다 . 다른 유형의 스플 라이스 (표현식, 유형 및 패턴)는 표시되지 않습니다. 응용 프로그램 개발자는이를 저장소로 체크인하여 템플리트 Haskell에 정의 된 ID를 grep 할 수 있습니다. 이는 &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 유사 하지만 항상 &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; 에 연결되는 대신 파일을 생성 합니다.. 형식도 다릅니다. 원본 파일의 코드를 표시하지 않고 생성 된 코드 만 표시하고 원본 파일의 스플 라이스 위치에 대한 주석이 있습니다.</target>
        </trans-unit>
        <trans-unit id="404c9a659d03a9f69f856dce2aa843799cee4f29" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; also lifts the corresponding restriction on class declarations (&lt;a href=&quot;flexible_contexts#superclass-rules&quot;&gt;Flexible contexts&lt;/a&gt;) and instance declarations (&lt;a href=&quot;instances#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 플래그 는 또한 클래스 선언 ( &lt;a href=&quot;flexible_contexts#superclass-rules&quot;&gt;Flexible contexts&lt;/a&gt; ) 및 인스턴스 선언 ( &lt;a href=&quot;instances#instance-rules&quot;&gt;인스턴스 컨텍스트에 대한 완화 된 규칙&lt;/a&gt; ) 에 대한 해당 제한을 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="956cfa095b764303bb3df255e599d046113e1e5f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt;&lt;/a&gt; to suppress these warnings.</source>
          <target state="translated">The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt; &lt;/a&gt; to suppress these warnings.</target>
        </trans-unit>
        <trans-unit id="b93b2c7d1b9eda88e393a8f5e74873331f11d482" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;code&gt;-Wno-type-errors&lt;/code&gt; to suppress these warnings.</source>
          <target state="translated">플래그 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 는 유형 오류가 런타임으로 지연되는지 여부를 제어합니다. 유형 오류는 여전히 경고로 표시되지만 컴파일을 방해하지는 않습니다. &lt;code&gt;-Wno-type-errors&lt;/code&gt; 를 사용하여 이러한 경고를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b3baa03b1de2ae2d10fcb9504c97b6f24d46a7f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; works in GHCi as well, with one exception: for &amp;ldquo;naked&amp;rdquo; expressions typed at the prompt, type errors don&amp;rsquo;t get delayed, so for example:</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 플래그 는 GHCi에서도 작동하지만, 프롬프트에 입력 된 &quot;나이키 (naked)&quot;표현식의 경우 유형 오류가 지연되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bc71daa56ee822998e1d64f92a7832d0f7badec" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fglasgow-exts&lt;/code&gt; is equivalent to enabling the following extensions:</source>
          <target state="translated">&lt;code&gt;-fglasgow-exts&lt;/code&gt; 플래그 는 다음 확장을 활성화하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfe7b59eddf66920c11dffff433c9395a1cc1d4e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">&lt;code&gt;-fprint-evld-with-show&lt;/code&gt; 플래그는 가능한 경우 사용 가능한 &lt;code&gt;Show&lt;/code&gt; 인스턴스 를 재사용 하도록 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 에 지시 합니다. 이는 검사중인 변수의 내용이 완전히 평가 된 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d43a045f4632b27bf091372de67333d21d36a1ae" translate="yes" xml:space="preserve">
          <source>The flag reference tables (&lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;) lists the status of each flag.</source>
          <target state="translated">플래그 참조 테이블 ( &lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt; )에는 각 플래그의 상태가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="960b0cead1ab39ce475efd50a401951d0d90317c" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt; control whether the resulting shared object links statically or dynamically to Haskell package libraries given as &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; 플래그 는 결과 공유 객체가 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 옵션으로 제공된 Haskell 패키지 라이브러리에 정적으로 또는 동적으로 링크되는지 여부를 제어합니다 . 비 하스켈 라이브러리는 gcc가 시스템에서 정기적으로 링크하므로 링크됩니다. 예를 들어 대부분의 ELF 시스템에서 링커는 발견시 동적 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a522dd66e717085ecc76a6c4786f0f9260178c11" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; have no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, because they are implemented by changing the definition of &lt;code&gt;main&lt;/code&gt; that GHC generates. See &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for how to get the effect of &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; when using your own &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">플래그 &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt; 함께 사용하면 효과가 없습니다 &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; 들이의 정의를 변경하여 구현되기 때문에, &lt;code&gt;main&lt;/code&gt; GHC가 생성합니다. 참조 &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;() 자신의 주 사용&lt;/a&gt; 의 효과를 얻는 방법에 대한 &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt; 자신의 사용하는 경우 &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7668d5e6fe85390adb7a3ecf19db212413e1eebc" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; have no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, because they are implemented by changing the definition of &lt;code&gt;main&lt;/code&gt; that GHC generates. See &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for how to get the effect of &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; when using your own &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">플래그 &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt; 함께 사용하면 효과가 없습니다 &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; 들이의 정의를 변경하여 구현되기 때문에, &lt;code&gt;main&lt;/code&gt; GHC가 생성하는 참조 &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;() 자신의 주 사용&lt;/a&gt; 의 효과를 얻는 방법에 대한 &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt; 자신의 사용하는 경우 &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="translated">플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcad0a34c93b0b86bbc687fc84b1ffd20b52d6a1" translate="yes" xml:space="preserve">
          <source>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (&lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt;), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</source>
          <target state="translated">부동 소수점 환경은 일반 스레드 컨텍스트 스위치를 통해 저장되지 않습니다. 따라서 한 스레드에서 부동 소수점 상태를 수정하면 다른 스레드에서도 해당 변경 사항이 표시 될 수 있습니다. 또한 컨텍스트 스위치가 변경 될 수 있으므로 예외 상태 테스트는 신뢰할 수 없습니다. 부동 소수점 상태를 수정 또는 테스트하고 스레드를 사용해야하는 경우 , 바인딩 된 스레드에는 자체 OS 스레드가 있고 OS 스레드는 부동 소수점을 저장하고 복원하므로 바인딩 된 스레드 ( &lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt; ) 를 사용해야합니다. 상태.</target>
        </trans-unit>
        <trans-unit id="d84e5b1b19c72a9f2f8e38f56f6835541ed5d999" translate="yes" xml:space="preserve">
          <source>The following RTS option(s) affect the behaviour of Concurrent Haskell programs:</source>
          <target state="translated">다음 RTS 옵션은 동시 Haskell 프로그램의 동작에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="52952117f68d88486d7181f97f7977ad0131a484" translate="yes" xml:space="preserve">
          <source>The following are QuickCheck specifications of what the combinators do. These can be seen as formal specifications of the behavior of the combinators.</source>
          <target state="translated">다음은 결합기의 기능에 대한 QuickCheck 사양입니다. 이들은 결합기의 동작에 대한 공식적인 사양으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="880afa09746074737763ff34c90d8a824dfb1e1a" translate="yes" xml:space="preserve">
          <source>The following are definitions for &quot;merge&quot; for each of the heaps above. Each takes a comparison function which is used to order the elements.</source>
          <target state="translated">다음은 위의 각 힙에 대한 &quot;병합&quot;에 대한 정의입니다. 각각 요소를 주문하는 데 사용되는 비교 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9031e690866836bd079eb18cd7f2cf6f4a7c0278" translate="yes" xml:space="preserve">
          <source>The following are definitions for &lt;code&gt;popMin&lt;/code&gt;, a function which constructs a stateful action which pops the smallest element from the queue, where &quot;smallest&quot; is according to the supplied comparison function.</source>
          <target state="translated">다음은 큐에서 가장 작은 요소를 표시하는 상태 저장 조치를 구성하는 함수 인 &lt;code&gt;popMin&lt;/code&gt; 에 대한 정의입니다 . 여기서 &quot;가장 작은&quot;은 제공된 비교 함수 를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="853c1b2416dd00409c8f94cbaaab4d500ad921b0" translate="yes" xml:space="preserve">
          <source>The following are definitions for functions to build queues, given a comparison function.</source>
          <target state="translated">다음은 비교 함수를 고려하여 큐를 빌드하는 함수에 대한 정의입니다.</target>
        </trans-unit>
        <trans-unit id="00e5f1459a91351f85b76ba47f587250af056d92" translate="yes" xml:space="preserve">
          <source>The following are definitions for various specialized pairing heaps.</source>
          <target state="translated">다음은 다양한 특수 페어링 힙에 대한 정의입니다.</target>
        </trans-unit>
        <trans-unit id="bcfac859b1b4efae75f25f72bc0530006c88e6e1" translate="yes" xml:space="preserve">
          <source>The following are good consumers:</source>
          <target state="translated">다음은 좋은 소비자입니다.</target>
        </trans-unit>
        <trans-unit id="415fb3cf16155d23aebc101af30f40f1175a4761" translate="yes" xml:space="preserve">
          <source>The following are good producers:</source>
          <target state="translated">다음은 좋은 생산자입니다.</target>
        </trans-unit>
        <trans-unit id="fc2c73f87b7ae21e5d1bff7544c615fae9cb5d03" translate="yes" xml:space="preserve">
          <source>The following behaves as expected:</source>
          <target state="translated">다음은 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0f147698ae3534209b092f6955e20175ff56a36f" translate="yes" xml:space="preserve">
          <source>The following command works to load new packages into a running GHCi:</source>
          <target state="translated">다음 명령은 실행중인 GHCi에 새 패키지를로드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e7ad1243df876884047bbd1cfa2abad6fc2f257e" translate="yes" xml:space="preserve">
          <source>The following commands turn the keypad on/off (&lt;code&gt;smkx&lt;/code&gt; and &lt;code&gt;rmkx&lt;/code&gt;). They have no effect if those capabilities are not defined. For portability between terminals, the keypad should be explicitly turned on before accepting user key input.</source>
          <target state="translated">다음 명령은 키패드를 켜거나 끕니다 ( &lt;code&gt;smkx&lt;/code&gt; 및 &lt;code&gt;rmkx&lt;/code&gt; ). 이러한 기능이 정의되어 있지 않으면 아무런 영향을 미치지 않습니다. 터미널 간 이식성을 위해 사용자 키 입력을 수락하기 전에 키패드를 명시 적으로 켜야합니다.</target>
        </trans-unit>
        <trans-unit id="25f14bebf678b2e0c7df12fa6531f8bc946288ab" translate="yes" xml:space="preserve">
          <source>The following definition is available to C programs inter-operating with Haskell code when including the header &lt;code&gt;HsFFI.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HsFFI.h&lt;/code&gt; 헤더를 포함 할 때 Haskell 코드와 상호 운용되는 C 프로그램에서 다음 정의를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6d695a5cf6d19ccd0a26b89aff9c95dd12f497b" translate="yes" xml:space="preserve">
          <source>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</source>
          <target state="translated">기능 종속성의 동기 부여 및 사용에 대한 다음 설명은 Hugs 사용 설명서에서 가져 왔으며 Mark Jones의 친절한 허가를 받아 여기에 약간 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="255eb2a60233998edc485b972b2b920903f06efc" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 방정식은 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 와 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="713d7c0768135036f33a7e1109e709b8e968874e" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음 방정식은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 와 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5932637debfc712f536a5a82f8f2316ec988c2f6" translate="yes" xml:space="preserve">
          <source>The following examples demonstrate short circuit behavior for &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 대한 단락 동작을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9b83dec9a58f676651fac034f4604b4f535ae7bb" translate="yes" xml:space="preserve">
          <source>The following examples demonstrate short circuit behavior for &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 대한 단락 동작을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="80071055ad7de002a9be9ac272460f952e92f3ef" translate="yes" xml:space="preserve">
          <source>The following examples demonstrate short circuit behavior for &lt;code&gt;&lt;a href=&quot;prelude#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;&lt;a href=&quot;prelude#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 대한 단락 동작을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="dbc7d38cb4fbd659d01d9a4ef580cbd8a454bdc2" translate="yes" xml:space="preserve">
          <source>The following extra instances are defined:</source>
          <target state="translated">다음과 같은 추가 인스턴스가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="219485ecc6b675dce37eba80ce2494e945235236" translate="yes" xml:space="preserve">
          <source>The following flags are simple ways to select standard &amp;ldquo;packages&amp;rdquo; of warnings:</source>
          <target state="translated">다음 플래그는 표준 경고의 &quot;패키지&quot;를 선택하는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9e8f2bd1d4e584f03bc71486665d6449cff997d8" translate="yes" xml:space="preserve">
          <source>The following flags control the way in which GHC displays types in error messages and in GHCi:</source>
          <target state="translated">다음 플래그는 GHC가 오류 메시지 및 GHCi에서 유형을 표시하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="369fd24532366a269db0dd996324b5e45dfd6c9e" translate="yes" xml:space="preserve">
          <source>The following functions allow a thread to control delivery of asynchronous exceptions during a critical region.</source>
          <target state="translated">다음 기능을 통해 스레드는 임계 영역 동안 비동기 예외의 전달을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf919ec9ecd009bd434b357d75af7e1bf8279715" translate="yes" xml:space="preserve">
          <source>The following functions enable cross-platform output of text that may contain Unicode characters.</source>
          <target state="translated">다음 함수는 유니 코드 문자를 포함 할 수있는 텍스트의 크로스 플랫폼 출력을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="38af53e84d563801f65a6120a4900e75bb8e39ff" translate="yes" xml:space="preserve">
          <source>The following functions for cursor movement will combine the more primitive capabilities. For example, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; may use either &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; depending on the parameter and which of &lt;code&gt;cud&lt;/code&gt; and &lt;code&gt;cud1&lt;/code&gt; are defined.</source>
          <target state="translated">다음과 같은 커서 이동 기능은보다 원시적 인 기능을 결합합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; 는 어느 사용할 수 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; 이 파라미터에 따라서 그리고되는 &lt;code&gt;cud&lt;/code&gt; 과 &lt;code&gt;cud1&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="0b7bd1ee8d2490e346b323a061ee5d6bf4bd98aa" translate="yes" xml:space="preserve">
          <source>The following functions read one line or character of input from the user.</source>
          <target state="translated">다음 함수는 사용자로부터 한 줄 또는 입력 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="defeb72fa9fc8defce3095a722d77cd56b0b0897" translate="yes" xml:space="preserve">
          <source>The following holds:</source>
          <target state="translated">다음과 같은 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0e843336042b652d443e731d806dae137491a142" translate="yes" xml:space="preserve">
          <source>The following instances of &lt;code&gt;MonadFix&lt;/code&gt; are automatically provided: List, Maybe, IO. Furthermore, the &lt;code&gt;Control.Monad.ST&lt;/code&gt; and &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; modules provide the instances of the &lt;code&gt;MonadFix&lt;/code&gt; class for Haskell&amp;rsquo;s internal state monad (strict and lazy, respectively).</source>
          <target state="translated">다음과 같은 &lt;code&gt;MonadFix&lt;/code&gt; 인스턴스 가 자동으로 제공됩니다 : List, Maybe, IO. 또한 &lt;code&gt;Control.Monad.ST&lt;/code&gt; 및 &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; 모듈은 Haskell의 내부 상태 모나드 (각각 엄격하고 게으른) 에 대한 &lt;code&gt;MonadFix&lt;/code&gt; 클래스 의 인스턴스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="974f2bea79592d4497c7bb6f1878062d29b69e35" translate="yes" xml:space="preserve">
          <source>The following laws ought to hold (for all valid bit indices &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;):</source>
          <target state="translated">다음의 법규를 준수해야합니다 (모든 유효한 비트 인덱스 &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="3bc96821c04daf88673e5973fb7e13baaeb66bc4" translate="yes" xml:space="preserve">
          <source>The following operations are guaranteed not to be interruptible:</source>
          <target state="translated">다음 작업은 중단되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="740d5fed1fd466547dd8bedbd7c0b84313346d32" translate="yes" xml:space="preserve">
          <source>The following options affect the way the runtime schedules threads on CPUs:</source>
          <target state="translated">다음 옵션은 런타임이 CPU에서 스레드를 예약하는 방식에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="2b8d3fdea7e46b30a4c9898c10dbf48da92a4aa0" translate="yes" xml:space="preserve">
          <source>The following options are useful for keeping (or not keeping) certain intermediate files around, when normally GHC would throw these away after compilation:</source>
          <target state="translated">다음 옵션은 일반적으로 GHC가 컴파일 후 파일을 버릴 때 특정 중간 파일을 유지하거나 유지하지 않는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4b91e9673e3ffcbc96d29b28282cb41f8f1d21ce" translate="yes" xml:space="preserve">
          <source>The following plugins allows users to limit the search for valid hole fits to certain modules, to sort the hole fits by where they originated (in ascending or descending order), as well as allowing users to put a limit on how much time is spent on searching for valid hole fits, after which new searches are aborted.</source>
          <target state="translated">The following plugins allows users to limit the search for valid hole fits to certain modules, to sort the hole fits by where they originated (in ascending or descending order), as well as allowing users to put a limit on how much time is spent on searching for valid hole fits, after which new searches are aborted.</target>
        </trans-unit>
        <trans-unit id="38c3f1cd516a144b167f804cbad9091a110d7738" translate="yes" xml:space="preserve">
          <source>The following property holds</source>
          <target state="translated">다음 부동산이 보유하고 있습니다</target>
        </trans-unit>
        <trans-unit id="c4d20004308e57029d6af08f5d4d162927106726" translate="yes" xml:space="preserve">
          <source>The following relationships hold:</source>
          <target state="translated">다음 관계가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="78400d597f1cd2c8bbeafc9eb8299b783cc0473e" translate="yes" xml:space="preserve">
          <source>The following sections also give some hints and tips on the use of the foreign function interface in GHC.</source>
          <target state="translated">다음 섹션에서는 GHC에서 외부 기능 인터페이스 사용에 대한 힌트와 팁도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f17c609e8f1c6b37d3130d2dff0e1652b3175021" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;'1'&lt;/code&gt; 과 &lt;code&gt;'2'&lt;/code&gt; 는 모두 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 구문 분석 할 수 있으므로 다음이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="1f604ae57c21e961a4347d16a255de560a7918fb" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;'1'&lt;/code&gt; 과 &lt;code&gt;'2'&lt;/code&gt; 는 모두 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 구문 분석 할 수 있으므로 다음이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="f68ed3cdb6c1e1e040a389af1a8ea7b8ca3ea19d" translate="yes" xml:space="preserve">
          <source>The following syntax is stolen:</source>
          <target state="translated">다음 구문이 도난되었습니다.</target>
        </trans-unit>
        <trans-unit id="f24a325a1df690e88417cf55ef160f4f9b155bda" translate="yes" xml:space="preserve">
          <source>The following unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6): &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, &lt;code&gt;StablePtr# a&lt;/code&gt;, &lt;code&gt;MutableByteArray#&lt;/code&gt;, &lt;code&gt;ForeignObj#&lt;/code&gt;, and &lt;code&gt;ByteArray#&lt;/code&gt;.</source>
          <target state="translated">다음 언 박싱 된 유형은 기본 외국 유형 (8.6 절을 FFI 장 참조)로 사용될 수있다 &lt;code&gt;Int#&lt;/code&gt; , &lt;code&gt;Word#&lt;/code&gt; , &lt;code&gt;Char#&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; , &lt;code&gt;Double#&lt;/code&gt; , &lt;code&gt;Addr#&lt;/code&gt; , &lt;code&gt;StablePtr# a&lt;/code&gt; , &lt;code&gt;MutableByteArray#&lt;/code&gt; , &lt;code&gt;ForeignObj#&lt;/code&gt; , 그리고 &lt;code&gt;ByteArray#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a390fae09d9d59559fad6e009bd1023970f06a76" translate="yes" xml:space="preserve">
          <source>The following unlifted unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6) for both &lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;unsafe&lt;/code&gt; foreign calls: &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, and &lt;code&gt;StablePtr# a&lt;/code&gt;. Several unlifted boxed types may be used as arguments to FFI calls, subject to these restrictions:</source>
          <target state="translated">The following unlifted unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6) for both &lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;unsafe&lt;/code&gt; foreign calls: &lt;code&gt;Int#&lt;/code&gt; , &lt;code&gt;Word#&lt;/code&gt; , &lt;code&gt;Char#&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; , &lt;code&gt;Double#&lt;/code&gt; , &lt;code&gt;Addr#&lt;/code&gt; , and &lt;code&gt;StablePtr# a&lt;/code&gt; . Several unlifted boxed types may be used as arguments to FFI calls, subject to these restrictions:</target>
        </trans-unit>
        <trans-unit id="bc89363b3d736091da072542a570e3138b391d30" translate="yes" xml:space="preserve">
          <source>The following uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are supposed to work (i.e. not lead to spurious compile-time or run-time crashes):</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; 의 다음 사용은 작동하는 것으로 간주됩니다 (즉, 잘못된 컴파일 타임 또는 런타임 충돌로 이어지지 않음).</target>
        </trans-unit>
        <trans-unit id="1c72fa99c47cb70fcbd686ee80df427b2899a75e" translate="yes" xml:space="preserve">
          <source>The following will fail with an &amp;ldquo;Illegal unboxed tuple&amp;rdquo; error, since the derived instance produced by the compiler makes use of unboxed tuple syntax,</source>
          <target state="translated">컴파일러에서 생성 된 파생 인스턴스가 언 박스 튜플 구문을 사용하기 때문에 &quot;잘못된 박스형 튜플&quot;오류와 함께 다음이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bbe044a46ef1c2c19252cc897f6025061c027f6f" translate="yes" xml:space="preserve">
          <source>The followup discussion that changed the behavior of &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is archived here: &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;Proposal: Allow gunfold for Data.Map, ...&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 동작을 변경 한 후속 토론 은 여기에 보관되어 있습니다. &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;제안 : Data.Map에 대해 건 폴드 허용, ...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cee1c36106928daf538418e53cc5b65ec5381bc2" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt; and all its methods &lt;em&gt;and associated types&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;C(..)&lt;/code&gt; 형식 ( 여기서 &lt;code&gt;C&lt;/code&gt; 는 클래스 임) 은 클래스 &lt;code&gt;C&lt;/code&gt; 와 모든 메소드 &lt;em&gt;및 연관된 유형의&lt;/em&gt; 이름을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="16df0b26ad83c27523378eaf1216ddacafe4cfa5" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt;, and the specified methods &lt;code&gt;mi&lt;/code&gt; and associated types &lt;code&gt;Tj&lt;/code&gt;. The types need a keyword &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to distinguish them from data constructors.</source>
          <target state="translated">폼 &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt; 여기서, &lt;code&gt;C&lt;/code&gt; 는 클래스, 이름, 클래스 인 &lt;code&gt;C&lt;/code&gt; , 지정된 방법 &lt;code&gt;mi&lt;/code&gt; 와 연관된 유형 &lt;code&gt;Tj&lt;/code&gt; . 유형 은 데이터 생성자와 구별하기 위해 키워드 &quot; &lt;code&gt;type&lt;/code&gt; &quot;이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="54deed429c05521fb5fa3d0bb8ceb609130a547f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names the family &lt;code&gt;T&lt;/code&gt; and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">폼 &lt;code&gt;T(..)&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 는 데이터 가족이 이름 가족 &lt;code&gt;T&lt;/code&gt; 모든 범위 내 생성자 (범위하거나 규정없이)의 데이터 인스턴스 (instance)이며, &lt;code&gt;T&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="784438eaf0aa44838a323a050c855ee268899421" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names &lt;code&gt;T&lt;/code&gt; and the specified constructors &lt;code&gt;ci&lt;/code&gt; and fields &lt;code&gt;fj&lt;/code&gt; as usual. The constructors and field names must belong to some data instance of &lt;code&gt;T&lt;/code&gt;, but are not required to belong to the &lt;em&gt;same&lt;/em&gt; instance.</source>
          <target state="translated">폼 &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt; 여기서, &lt;code&gt;T&lt;/code&gt; 는 데이터 계열이고, 이름 &lt;code&gt;T&lt;/code&gt; 지정된 생성자의 &lt;code&gt;ci&lt;/code&gt; 및 필드 &lt;code&gt;fj&lt;/code&gt; 평소. 생성자와 필드 이름은 &lt;code&gt;T&lt;/code&gt; 의 일부 데이터 인스턴스에 속해야하지만 &lt;em&gt;동일한&lt;/em&gt; 인스턴스 에 속할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e19f785765e870b264c7a6f5303ec2d2e122f27d" translate="yes" xml:space="preserve">
          <source>The form is called a &amp;ldquo;GADT-style declaration&amp;rdquo; because Generalised Algebraic Data Types, described in &lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;, can only be declared using this form.</source>
          <target state="translated">GADT (Generalized Algebraic Data Types)에 설명 된 &lt;a href=&quot;#gadt&quot;&gt;Generalized Algebraic Data Types&lt;/a&gt; 는이 형식을 사용해서 만 선언 할 수 있기 때문에이 형식을 &quot;GADT 스타일 선언&quot;이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="4109842ab4ae7847f6aa71522185decc06f846e0" translate="yes" xml:space="preserve">
          <source>The form is called a &amp;ldquo;GADT-style declaration&amp;rdquo; because Generalised Algebraic Data Types, described in &lt;a href=&quot;gadt#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;, can only be declared using this form.</source>
          <target state="translated">GADT (Generalized Algebraic Data Types)에 설명 된 &lt;a href=&quot;gadt#gadt&quot;&gt;Generalized Algebraic Data Types&lt;/a&gt; 는이 양식을 사용해서 만 선언 할 수 있기 때문에이 양식을 &quot;GADT 스타일 선언&quot;이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="ccb8198ff02595b7c5252294cca08712b727694b" translate="yes" xml:space="preserve">
          <source>The form with a type variable at the head allows this:</source>
          <target state="translated">헤드에 유형 변수가있는 양식은 다음을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="33fa9d40a30aa7e6dce906a9649768430ce7ca3a" translate="yes" xml:space="preserve">
          <source>The format character &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; was invoked with. &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; should fail unless this character matches the type. It is normal to handle many different format characters for a single type.</source>
          <target state="translated">형식 문자 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 가 호출되었습니다. 이 문자가 형식과 일치하지 않으면 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 가 실패합니다. 단일 유형에 대해 다양한 형식의 문자를 처리하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="3b0d06acd5997423d85afc8f840323a4c6b86ed5" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;#16233&lt;/a&gt; for more.</source>
          <target state="translated">GHC가 현재 유형 검사 된 AST를 저장하는 형식은 일부 표현식 노드의 유형을 수집하는 데 비용이 많이 듭니다. 성능을 위해 GHC는 현재이를 건너 뛰도록 선택하므로 모든 표현식 노드에 유형 정보가 있어야하는 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;# 16233&lt;/a&gt; 을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="2d9a19d4aec50fa6639cb12bdd8357cf823eed22" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;Issue #16233&lt;/a&gt; for more.</source>
          <target state="translated">GHC가 현재 형식 검사 AST를 저장하는 형식으로 인해 일부 표현식 노드의 형식을 수집하는 데 많은 비용이 듭니다. 성능을 위해 GHC는 현재이를 건너 뛰기로 선택하므로 모든 표현 노드에 유형 정보가있는 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;문제 # 16233&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77eb958799ae389fcdbbcf943703d169a775084b" translate="yes" xml:space="preserve">
          <source>The format is endian-independent: all values are represented in big-endian order.</source>
          <target state="translated">형식은 엔디안 독립적입니다. 모든 값은 빅 엔디안 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="52265627b3cdf75e5930faf68e8602be59d016e4" translate="yes" xml:space="preserve">
          <source>The format is extensible:</source>
          <target state="translated">형식은 확장 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8d12d8f748fe76f6f798cf8384f400dd6e25b26a" translate="yes" xml:space="preserve">
          <source>The format of the log file is described by the header &lt;code&gt;EventLogFormat.h&lt;/code&gt; that comes with GHC, and it can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">로그 파일의 형식은 GHC와 함께 제공되는 &lt;code&gt;EventLogFormat.h&lt;/code&gt; 헤더로 설명되며 &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; 라이브러리를 사용하여 Haskell에서 구문 분석 할 수 있습니다 . &lt;code&gt;.eventlog&lt;/code&gt; 파일 의 내용을 텍스트로 덤프하려면 &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; 패키지 와 함께 제공 되는 도구 &lt;code&gt;ghc-events show&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a21a934d4a700fb3b992b87fb1cc1e6e5af3937" translate="yes" xml:space="preserve">
          <source>The format of the log file is described in this users guide in &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog encodings&lt;/a&gt; It can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">로그 파일의 형식은이 사용자 가이드의 &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog 인코딩&lt;/a&gt; 에 설명되어 있습니다. &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; 라이브러리를 사용하여 Haskell에서 구문 분석 할 수 있습니다 . &lt;code&gt;.eventlog&lt;/code&gt; 파일 의 내용을 텍스트로 덤프하려면 &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; 패키지 와 함께 제공되는 &lt;code&gt;ghc-events show&lt;/code&gt; 도구를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cfb8adc36c2a93c5e821d16746cc0ba516eae21" translate="yes" xml:space="preserve">
          <source>The format of the log file is described in this users guide in &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog encodings&lt;/a&gt; It can be parsed in Haskell using the &lt;a href=&quot;https://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;https://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">로그 파일의 형식은이 사용자 가이드의 &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog 인코딩&lt;/a&gt; 에 설명되어 있습니다. &lt;a href=&quot;https://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; 라이브러리를 사용하여 Haskell에서 구문 분석 할 수 있습니다 . &lt;code&gt;.eventlog&lt;/code&gt; 파일 의 내용을 텍스트로 덤프하려면 &lt;a href=&quot;https://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; 패키지 와 함께 제공되는 &lt;code&gt;ghc-events show&lt;/code&gt; 도구를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="be4698f989f63506bf7e347d2e60a53dbb0e6400" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary characters and &lt;em&gt;conversion specifications&lt;/em&gt;, which specify how to format one of the arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; in the output string. A format specification is introduced by the &lt;code&gt;%&lt;/code&gt; character; this character can be self-escaped into the format string using &lt;code&gt;%%&lt;/code&gt;. A format specification ends with a &lt;em&gt;format character&lt;/em&gt; that provides the primary information about how to format the value. The rest of the conversion specification is optional. In order, one may have flag characters, a width specifier, a precision specifier, and type-specific modifier characters.</source>
          <target state="translated">형식 문자열은 일반 문자와 &lt;em&gt;변환 스펙&lt;/em&gt; 으로 구성 되며, 출력 문자열에서 인수 중 하나를 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 로 형식화하는 방법을 지정합니다 . 형식 지정은 &lt;code&gt;%&lt;/code&gt; 문자로 소개됩니다 . 이 문자는 &lt;code&gt;%%&lt;/code&gt; 를 사용하여 형식 문자열로 자체 이스케이프 될 수 있습니다 . 형식 스펙 은 값 형식화 방법에 대한 기본 정보를 제공 하는 &lt;em&gt;형식 문자로&lt;/em&gt; 끝납니다 . 나머지 변환 사양은 선택 사항입니다. 순서대로 플래그 문자, 너비 지정자, 정밀도 지정자 및 유형별 수정 자 문자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e09c7cb4393ecfca8f299ffa2b0d2ecb753a77" translate="yes" xml:space="preserve">
          <source>The former will result in far better code.</source>
          <target state="translated">전자는 훨씬 더 나은 코드를 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="64194ba26d3825d046086abae5391759fabeb498" translate="yes" xml:space="preserve">
          <source>The full Haskell import syntax is supported, including &lt;code&gt;hiding&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; clauses. The prompt shows the modules that are currently imported, but it omits details about &lt;code&gt;hiding&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and so on. To see the full story, use &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;hiding&lt;/code&gt; 및 &lt;code&gt;as&lt;/code&gt; 절을 포함하여 전체 Haskell 가져 오기 구문이 지원됩니다 . 프롬프트는 현재 가져온 모듈을 표시하지만 , &lt;code&gt;as&lt;/code&gt; 등 &lt;code&gt;hiding&lt;/code&gt; 에 대한 세부 사항은 생략 합니다. 전체 내용을 보려면 &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="baa9ed28ff451076e010d26ad3fbfd9bfa094445" translate="yes" xml:space="preserve">
          <source>The full list of lazy corecursive functions in this module is:</source>
          <target state="translated">이 모듈에있는 lazy corecursive 함수의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09c77c37933440b6a8a2be275bd3e8cedf49ad23" translate="yes" xml:space="preserve">
          <source>The full list of short-circuit folds in this module is:</source>
          <target state="translated">이 모듈의 전체 단락 접기 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7896bf902d37d2a63077e1d62b31a0c1a70ca8c" translate="yes" xml:space="preserve">
          <source>The full list of strict recursive functions in this module is:</source>
          <target state="translated">이 모듈의 엄격한 재귀 함수의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d2ba0a02591100122d7720b515c37aa08242448" translate="yes" xml:space="preserve">
          <source>The full set of warning options is described below. To turn off any warning, simply give the corresponding &lt;code&gt;-Wno-...&lt;/code&gt; option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with &lt;code&gt;-f(no-)warn-*&lt;/code&gt; instead of &lt;code&gt;-W(no-)*&lt;/code&gt;.</source>
          <target state="translated">전체 경고 옵션 세트가 아래에 설명되어 있습니다. 경고를 끄려면 명령 행에서 해당 &lt;code&gt;-Wno-...&lt;/code&gt; 옵션을 제공하십시오. 8.0 이전의 GHC 버전과의 호환성을 위해 이러한 모든 경고는 여전히 &lt;code&gt;-W(no-)*&lt;/code&gt; &lt;code&gt;-f(no-)warn-*&lt;/code&gt; 대신 -f (no-) warn- * 으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85f17eafeb486710aee49e213718913273279295" translate="yes" xml:space="preserve">
          <source>The full version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted. It includes the major, minor, revision and an additional identifier, generally in the form &quot;&lt;a href=&quot;year&quot;&gt;year&lt;/a&gt;&lt;a href=&quot;month&quot;&gt;month&lt;/a&gt;&lt;a href=&quot;day&quot;&gt;day&lt;/a&gt;&quot;.</source>
          <target state="translated">프로그램을 컴파일하거나 해석하는 데 사용한 &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; 의 전체 버전입니다 . 여기에는 주, 부, 개정 및 추가 식별자가 포함되며 일반적으로 &quot; &lt;a href=&quot;year&quot;&gt;년 &lt;/a&gt;&lt;a href=&quot;month&quot;&gt;월 &lt;/a&gt;&lt;a href=&quot;day&quot;&gt;일&lt;/a&gt; &quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="dc028589c7596178a298d55a5adc62737995f4c1" translate="yes" xml:space="preserve">
          <source>The fully-qualified name of the module where the type is declared</source>
          <target state="translated">형식이 선언 된 모듈의 정규화 된 이름</target>
        </trans-unit>
        <trans-unit id="a1840c040d0f137dff3d86a1c41a473b6f4799b8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, but it takes an extra argument which is an &lt;em&gt;exception predicate&lt;/em&gt;, a function which selects which type of exceptions we're interested in.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 함수 는 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 와 비슷하지만 &lt;em&gt;예외 술어&lt;/em&gt; 인 추가 인수 , 관심있는 예외 유형을 선택하는 함수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6c24fa3787eba0e6f28035b825969cadbe339326" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; takes a complex number and returns a (magnitude, phase) pair in canonical form: the magnitude is nonnegative, and the phase in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;; if the magnitude is zero, then so is the phase.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; 함수 는 복소수를 취하여 정식 형태로 (크기, 위상) 쌍을 반환합니다. 크기는 음이 아니고 범위의 위상 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; ; 크기가 0이면 위상도 같습니다.</target>
        </trans-unit>
        <trans-unit id="d424b407dc86bdf0a0767c07efa10515030815a2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실수 부동 소수점 숫자에 적용된 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 함수 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 와 적절하게 스케일 된 지수 ( &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ) 로 표현 된 significand를 리턴합니다 . 경우 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; 수율 &lt;code&gt;(m,n)&lt;/code&gt; 다음 &lt;code&gt;x&lt;/code&gt; 에 값과 같다 &lt;code&gt;m*b^^n&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 부동 소수점 기수이며, 또한, 어느 &lt;code&gt;m&lt;/code&gt; 과 &lt;code&gt;n&lt;/code&gt; 을 제로 또는 다른 모두 &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; , 여기서 &lt;code&gt;d&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; 값입니다 . 특히, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; . 유형에 음수 0이 포함 된 경우, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; 됩니다. &lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;또는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;중 하나 &lt;/em&gt;&lt;em&gt;가 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인&lt;em&gt; 경우 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;의 결과 &lt;/em&gt;&lt;em&gt;는 지정되지 않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe262135e4b1d91cb57eb1b81744970db71313a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 함수 는 실수 소수 &lt;code&gt;x&lt;/code&gt; 를 취하여 &lt;code&gt;x = n+f&lt;/code&gt; 되도록 쌍 &lt;code&gt;(n,f)&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="afbc2bb6bd9e243f694f4d3b3dece0b75ced87dd" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실수 부동 소수점 숫자에 적용된 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 함수 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 와 적절하게 스케일 된 지수 ( &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ) 로 표현 된 significand를 리턴합니다 . 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; 수율 &lt;code&gt;(m,n)&lt;/code&gt; 다음 &lt;code&gt;x&lt;/code&gt; 에 값과 같다 &lt;code&gt;m*b^^n&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 부동 소수점 기수이며, 또한, 어느 &lt;code&gt;m&lt;/code&gt; 과 &lt;code&gt;n&lt;/code&gt; 을 제로 또는 다른 모두 &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; , 여기서 &lt;code&gt;d&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; 값입니다 . 특히, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; . 유형에 음수 0이 포함 된 경우, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; 됩니다. &lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;또는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;중 하나 &lt;/em&gt;&lt;em&gt;가 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인&lt;em&gt; 경우 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;의 결과 &lt;/em&gt;&lt;em&gt;는 지정되지 않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="079629951658e63a1aceb4ed5c824cc91a0b5d86" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 함수 는 실수 소수 &lt;code&gt;x&lt;/code&gt; 를 취하여 &lt;code&gt;x = n+f&lt;/code&gt; 되도록 쌍 &lt;code&gt;(n,f)&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="88f909330278d9f82a3312e25ef59ec6d2186b36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coerce&lt;/code&gt; allows you to safely convert between values of types that have the same representation with no run-time overhead. In the simplest case you can use it instead of a newtype constructor, to go from the newtype's concrete type to the abstract type. But it also works in more complicated settings, e.g. converting a list of newtypes to a list of concrete types.</source>
          <target state="translated">함수 &lt;code&gt;coerce&lt;/code&gt; 변환을 사용하면 런타임 오버 헤드없이 동일한 표현을 가진 유형 값 사이를 안전하게 변환 할 수 있습니다. 가장 간단한 경우, newtype 생성자 대신이를 사용하여 newtype의 구체적 유형에서 추상 유형으로 이동할 수 있습니다. 그러나 더 복잡한 설정에서도 작동합니다 (예 : 새 유형 목록을 구체적 유형 목록으로 변환).</target>
        </trans-unit>
        <trans-unit id="a9426870a71de06c1f556cf879bcdaf0553394f4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f3&lt;/code&gt; has a rank-3 type; it has rank-2 types on the left of a function arrow.</source>
          <target state="translated">함수 &lt;code&gt;f3&lt;/code&gt; 의 순위는 3입니다. 기능 화살표 왼쪽에 순위 -2 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bebe5f1a75a0eddf8839f635c3decbffc5557dc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">아래 함수 &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;Bar&lt;/code&gt; 에 적용될 때 실패 하므로 컴파일러는 &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt; &lt;code&gt;-Wincomplete-record-updates&lt;/code&gt; 일&lt;/a&gt; 때 이에 대한 경고를 표시 합니다. 가 활성화 .</target>
        </trans-unit>
        <trans-unit id="782d3d59f72773f7952ce1ebae2822b75b04a8b7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; from the previous section has a more accurate type:</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 이전 섹션 f 는보다 정확한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7ec7041ec2658984f17f499a66ced25885c4a3a1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromList&lt;/code&gt; constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fromList&lt;/code&gt; 함수 는 주어진 목록에서 구조 &lt;code&gt;l&lt;/code&gt; 을 구성합니다. &lt;code&gt;Item l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53dd445850b902910cfbc7105e43df3c60dfa18d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromListN&lt;/code&gt; takes the input list&amp;rsquo;s length as a hint. Its behaviour should be equivalent to &lt;code&gt;fromList&lt;/code&gt;. The hint can be used for more efficient construction of the structure &lt;code&gt;l&lt;/code&gt; compared to &lt;code&gt;fromList&lt;/code&gt;. If the given hint is not equal to the input list&amp;rsquo;s length the behaviour of &lt;code&gt;fromListN&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;fromListN&lt;/code&gt; 함수 는 입력 목록의 길이를 힌트로 사용합니다. 동작은 &lt;code&gt;fromList&lt;/code&gt; 와 동일해야합니다 . 힌트는 &lt;code&gt;fromList&lt;/code&gt; 에 비해 구조 &lt;code&gt;l&lt;/code&gt; 의보다 효율적인 구성을 위해 사용될 수 있습니다 . 주어진 힌트가 입력 목록의 길이와 같지 않으면 &lt;code&gt;fromListN&lt;/code&gt; 같지 않으면 fromListN 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2c51e1ae6a25019f5b8dcb68c7e1cc6360380a0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g&lt;/code&gt; from the previous section is now rejected with a type error as we would hope because the type of &lt;code&gt;f&lt;/code&gt; does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the &lt;code&gt;Collects&lt;/code&gt; class is nowhere near as general as the original class seemed to be: only one of the four instances for &lt;code&gt;Collects&lt;/code&gt; given above can be used with this version of Collects because only one of them&amp;mdash;the instance for lists&amp;mdash;has a collection type that can be written in the form &lt;code&gt;c
e&lt;/code&gt;, for some type constructor &lt;code&gt;c&lt;/code&gt;, and element type &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 타입이 두 인자가 다른 타입을 가지도록 허용하지 않기 때문에 이전 섹션 의 함수 &lt;code&gt;g&lt;/code&gt; 는 타입 에러와 함께 거부됩니다 . 이것은 모호성 문제없이 실제로 실제로 잘 작동하는 다중 매개 변수 클래스의 예입니다. 그러나 캐치가 있습니다. 이 버전의 &lt;code&gt;Collects&lt;/code&gt; 클래스는 원래 클래스와 거의 비슷 하지 않습니다. 위에 제공된 &lt;code&gt;Collects&lt;/code&gt; 의 네 가지 인스턴스 중 하나만 이 버전의 Collects와 함께 사용할 수 있습니다. &lt;code&gt;c e&lt;/code&gt; 형식으로 작성 될 수있는 컬렉션 형식 , 일부 형식 생성자 &lt;code&gt;c&lt;/code&gt; 및 요소 형식 &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e1caf69d4b138be614d3615769e3ef6ea6617e4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;toList&lt;/code&gt; should be the inverse of &lt;code&gt;fromList&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;toList&lt;/code&gt; 은 의 역되어야 &lt;code&gt;fromList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f8ca21e6067d938666eb5fad69ffc6307e5c9d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;unsafeCoerce#&lt;/code&gt; allows you to side-step the typechecker entirely. That is, it allows you to coerce any type into any other type. If you use this function, you had better get it right, otherwise segmentation faults await. It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed.</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; 함수를 사용하면 유형 검사기를 완전히 회피 할 수 있습니다. 즉, 모든 유형을 다른 유형으로 강제 변환 할 수 있습니다. 이 기능을 사용하면 올바르게 작동하는 것이 좋으며 그렇지 않으면 세그먼테이션 오류가 발생합니다. 일반적으로 잘 알려진 프로그램을 작성하려고 할 때 사용되지만 Haskell의 유형 시스템이 표현력이 충분하지 않아서 잘 입력되었음을 증명할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4078d840830c2b32e85bca92ef57e0c6f82bd822" translate="yes" xml:space="preserve">
          <source>The function also returns two new handles: * an I/O Completion Port handle on which events will be signaled. * a Job handle which can be used to kill all running processes.</source>
          <target state="translated">이 함수는 또한 두 개의 새로운 핸들을 반환합니다. * 이벤트가 신호를받을 I / O 완료 포트 핸들. * 실행중인 모든 프로세스를 종료하는 데 사용할 수있는 작업 핸들.</target>
        </trans-unit>
        <trans-unit id="e1893333248495eec7a1e7dfe188fc6025a705a5" translate="yes" xml:space="preserve">
          <source>The function applied to &lt;code&gt;z0&lt;/code&gt; is built corecursively, and its terms are applied eagerly to the accumulator before further terms are applied to the result. So, as promised, this will run in constant space, and GHC is able to optimise this to an efficient loop.</source>
          <target state="translated">&lt;code&gt;z0&lt;/code&gt; 에 적용된 함수 는 핵심적으로 빌드되며, 추가 항이 결과에 적용되기 전에 해당 항이 누산기에 열심히 적용됩니다. 따라서 약속 한대로 이것은 일정한 공간에서 실행되며 GHC는이를 효율적인 루프로 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e72213f9f513b34bc27c803b9c687fb47fd6c8" translate="yes" xml:space="preserve">
          <source>The function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; is &lt;code&gt;infixr&lt;/code&gt; with fixity -1.</source>
          <target state="translated">기능 화살표 &lt;code&gt;-&amp;gt;&lt;/code&gt; 는 &lt;code&gt;infixr&lt;/code&gt; 가 -1입니다.</target>
        </trans-unit>
        <trans-unit id="ee88385ecb4c6c5e75ef1e364cd9dc3ba55a232c" translate="yes" xml:space="preserve">
          <source>The function arrows in a &lt;code&gt;prefix_gadt_body&lt;/code&gt;, as well as the function arrow in a &lt;code&gt;record_gadt_body&lt;/code&gt;, are required to be used infix. For example, &lt;code&gt;MkA :: (-&amp;gt;) Int A&lt;/code&gt; would be rejected.</source>
          <target state="translated">A의 함수 화살표 &lt;code&gt;prefix_gadt_body&lt;/code&gt; 뿐만 아니라 펑션 화살표 &lt;code&gt;record_gadt_body&lt;/code&gt; 는 중고 중위 것이 요구된다. 예를 들어, &lt;code&gt;MkA :: (-&amp;gt;) Int A&lt;/code&gt; 는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="54424bef429db403f4735db658be9ddb164137b0" translate="yes" xml:space="preserve">
          <source>The function creates a temporary file in ReadWrite mode. The created file isn't deleted automatically, so you need to delete it manually.</source>
          <target state="translated">이 함수는 ReadWrite 모드에서 임시 파일을 만듭니다. 생성 된 파일은 자동으로 삭제되지 않으므로 수동으로 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d31db636076141a2d374629e18c022c852ebef1" translate="yes" xml:space="preserve">
          <source>The function doesn't verify whether the path exists.</source>
          <target state="translated">이 함수는 경로가 존재하는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="add6d8a8d14a017a7abdc22d6a499ce254500df6" translate="yes" xml:space="preserve">
          <source>The function is assumed to define a total ordering.</source>
          <target state="translated">이 함수는 총 주문을 정의한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8c87908085624472ff4238bfb948223b787875d2" translate="yes" xml:space="preserve">
          <source>The function that applies a parser must now unwrap each of the monad transformers in turn:</source>
          <target state="translated">파서를 적용하는 기능은 이제 각 모나드 변압기를 차례로 풀어야합니다.</target>
        </trans-unit>
        <trans-unit id="83dbb4039dba1fe07aa4bcd8c6ba58bf457a2ec1" translate="yes" xml:space="preserve">
          <source>The function to modify the environment.</source>
          <target state="translated">환경을 수정하는 기능.</target>
        </trans-unit>
        <trans-unit id="1ccbf33c88dc57758ba1b802fb4f53d665b9edec" translate="yes" xml:space="preserve">
          <source>The function type constructor.</source>
          <target state="translated">함수 타입 생성자.</target>
        </trans-unit>
        <trans-unit id="f0f44ae6963080cf76e0ebf83f004dc8df761919" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">이 함수는 해당 값을 &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; 또는 키가 맵에없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2928b1b30db8e1f8656b8116560fcb94973556a2" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">함수는 해당 값을 &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; 로 반환 하거나 키가 맵에 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e918ffba33ab1fb40fa35f1cdb71387322ddea93" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">함수는 해당 값을 &lt;code&gt;(&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; 로 반환 하거나 키가 맵에 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce3cf6b1fb41916c15598ef7c7a2316d0affe736" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to a comparison function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">이 함수는 일반적으로 비교 함수에 적용되지만보다 일반적인 유형은 구현시 첫 번째 컨테이너의 요소를 두 번째 컨테이너의 요소와 비교하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="57722a7fa81914229dcd7f438a467425fc2444d4" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to an equality function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">이 함수는 일반적으로 동등 함수에 적용되지만보다 일반적인 유형은 구현시 첫 번째 컨테이너의 요소를 두 번째 컨테이너의 요소와 비교하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a2f33e33f25cc5b116bd53d1e8871c737f431f0f" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to comparison functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">이 함수는 일반적으로 비교 함수에 적용되지만보다 일반적인 유형은 구현시 첫 번째 컨테이너의 요소를 두 번째 컨테이너의 요소와 비교하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4fea0a18b8df51f28201953f3c7f75703eb47939" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to equality functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">이 함수는 일반적으로 평등 함수에 적용되지만,보다 일반적인 유형은 구현시 첫 번째 컨테이너의 요소를 두 번째 컨테이너의 요소와 비교하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6b6bc4aeee7f2323c64ee51bd60f90b62c365dcb" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f2&lt;/code&gt; and &lt;code&gt;g2&lt;/code&gt; have rank-2 types; the &lt;code&gt;forall&lt;/code&gt; is on the left of a function arrow. As &lt;code&gt;g2&lt;/code&gt; shows, the polymorphic type on the left of the function arrow can be overloaded.</source>
          <target state="translated">함수 &lt;code&gt;f2&lt;/code&gt; 및 &lt;code&gt;g2&lt;/code&gt; 는 순위 -2 유형을 갖습니다. &lt;code&gt;forall&lt;/code&gt; 함수 화살표의 좌측에있다. &lt;code&gt;g2&lt;/code&gt; 에서 알 수 있듯이 기능 화살표 왼쪽의 다형성 유형에 과부하가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="436e2ff4e3f10ce06692935420d28156ccb98ad6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; have the same body, but only &lt;code&gt;f&lt;/code&gt; is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function&amp;rsquo;s type.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;g&lt;/code&gt; 는 동일한 본문을 갖지만 &lt;code&gt;f&lt;/code&gt; 에만 유형 서명이 부여됩니다. GHC가 가시적 유형 애플리케이션을 처리하는 방법을 알아낼 때 인스턴스화 할 변수를 알아야합니다. 따라서 함수 유형의 유형 변수에 순서를 제공 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="709a35f15e3b44bedbeb0d4b4dddb4664dc2f475" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;g5&lt;/code&gt; and &lt;code&gt;g6&lt;/code&gt; mean exactly the same thing. But &lt;code&gt;g7&lt;/code&gt; evaluates &lt;code&gt;(f x)&lt;/code&gt;, binds &lt;code&gt;y&lt;/code&gt; to the result, and then evaluates &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;g5&lt;/code&gt; 와 &lt;code&gt;g6&lt;/code&gt; 은 정확히 같은 것을 의미합니다. 그러나 &lt;code&gt;g7&lt;/code&gt; 은 &lt;code&gt;(f x)&lt;/code&gt; 를 평가하고 &lt;code&gt;y&lt;/code&gt; 를 결과에 바인딩 한 다음 &lt;code&gt;body&lt;/code&gt; 를 평가 합니다 .</target>
        </trans-unit>
        <trans-unit id="0b19b31f5cbfb6277d7255768c1a9509164d5a55" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; are careful to force values before installing them in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">의 기능 &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict는&lt;/a&gt; 에 설치하기 전에 값을 강제로 조심 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; . 게으름이 필수적이지 않은 경우 일반적으로 더 효율적입니다. 이 모듈의 기능은 그렇게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="670d1298e5cb7a4e8403b208919c4f9aa9e19f28" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; are careful to force values before installing them in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; 의 함수 는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 에 값을 설치하기 전에 값을 강제로 설정합니다 . 게으름이 필수적이지 않은 경우 일반적으로 더 효율적입니다. 이 모듈의 기능은 그렇게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7ac968071ec3d6db992b2e9189f08e304a943fb" translate="yes" xml:space="preserve">
          <source>The functions in this library use the following naming conventions:</source>
          <target state="translated">이 라이브러리의 함수는 다음 이름 지정 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4d771bd73e07b4943d9ccd53e1231da21d4a47f0" translate="yes" xml:space="preserve">
          <source>The functions in this module obey the runtime system's locale, character set encoding, and line ending conversion settings.</source>
          <target state="translated">이 모듈의 기능은 런타임 시스템의 로케일, 문자 세트 인코딩 및 줄 끝 변환 설정을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d0245bbfde5cb4645880f74fa8998ab54478221f" translate="yes" xml:space="preserve">
          <source>The general form is &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; are optional.</source>
          <target state="translated">일반적인 형식은 &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; 는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d87f5dd37c519e3511a8db8b010d4f7ff96c2337" translate="yes" xml:space="preserve">
          <source>The general interface</source>
          <target state="translated">일반적인 인터페이스</target>
        </trans-unit>
        <trans-unit id="ec767503aee97b2532b6ed4020896fc0a3c857b5" translate="yes" xml:space="preserve">
          <source>The general principle is this:</source>
          <target state="translated">일반적인 원리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63fa8f01398fe9d9b6a5c91481c5c9f9c693d55d" translate="yes" xml:space="preserve">
          <source>The general rendering interface, supporting annotations. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">주석을 지원하는 일반적인 렌더링 인터페이스. 렌더링 모드, 선 길이 및 리본에 대한 설명은 &lt;code&gt;Style&lt;/code&gt; 및 &lt;code&gt;Mode&lt;/code&gt; 유형을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="443a3115347a69de80f7eab2e438bb5e78262ac7" translate="yes" xml:space="preserve">
          <source>The general rendering interface. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">일반적인 렌더링 인터페이스. 렌더링 모드, 선 길이 및 리본에 대한 설명은 &lt;code&gt;Style&lt;/code&gt; 및 &lt;code&gt;Mode&lt;/code&gt; 유형을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c8107939525836136417ba263c01627df220ab0" translate="yes" xml:space="preserve">
          <source>The generated code for the &lt;code&gt;Functor Wrong&lt;/code&gt; instance would look exactly the same, except with &lt;code&gt;Wrong&lt;/code&gt; replacing every occurrence of &lt;code&gt;Right&lt;/code&gt;. The problem is now that &lt;code&gt;fmap&lt;/code&gt; is being applied recursively to a value of type &lt;code&gt;Either a Int&lt;/code&gt;. This cannot possibly produce a value of type &lt;code&gt;Either b Int&lt;/code&gt;, as &lt;code&gt;fmap&lt;/code&gt; can only change the last type parameter! This causes the generated code to be ill-typed.</source>
          <target state="translated">&lt;code&gt;Functor Wrong&lt;/code&gt; 인스턴스에 대해 생성 된 코드 는 &lt;code&gt;Right&lt;/code&gt; 의 모든 발생을 &lt;code&gt;Wrong&lt;/code&gt; 대체하는 것을 제외하고는 정확히 동일하게 보입니다 . 문제는 이제 &lt;code&gt;fmap&lt;/code&gt; 이 &lt;code&gt;Either a Int&lt;/code&gt; 유형의 값에 재귀 적으로 적용되고 있다는 것 입니다. &lt;code&gt;fmap&lt;/code&gt; 은 마지막 유형 매개 변수 만 변경할 수 있기 때문에이 유형은 &lt;code&gt;Either b Int&lt;/code&gt; 유형의 값을 생성 할 수 없습니다 ! 이로 인해 생성 된 코드가 잘못 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="32903708d002dac9c0ac078342e2e27cabf0d2dd" translate="yes" xml:space="preserve">
          <source>The generation number of this GC</source>
          <target state="translated">이 GC의 세대수</target>
        </trans-unit>
        <trans-unit id="878b032694848adb77a2b859c02bd1b95a7bae5c" translate="yes" xml:space="preserve">
          <source>The goal here is to &lt;code&gt;lift&lt;/code&gt; from monad &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;t2 m&lt;/code&gt; and then &lt;code&gt;lift&lt;/code&gt; this again into &lt;code&gt;t1 (t2 m)&lt;/code&gt;. However, this second &lt;code&gt;lift&lt;/code&gt; can only be accepted when &lt;code&gt;(t2 m)&lt;/code&gt; is a monad and there is no way of establishing that this fact universally holds.</source>
          <target state="translated">여기서의 목표이다 &lt;code&gt;lift&lt;/code&gt; 모나드에서 &lt;code&gt;m&lt;/code&gt; 행 &lt;code&gt;t2 m&lt;/code&gt; 후 &lt;code&gt;lift&lt;/code&gt; 로 다시 이것을 &lt;code&gt;t1 (t2 m)&lt;/code&gt; . 그러나,이 두 번째 &lt;code&gt;lift&lt;/code&gt; 는 &lt;code&gt;(t2 m)&lt;/code&gt; 가 모나드이고이 사실이 보편적으로 유지된다는 것을 확립 할 방법이 없을 때만 수용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbfa1f88a3966514e5f590037e0742d3e33e28f3" translate="yes" xml:space="preserve">
          <source>The goal is to preserve the meaning of paths better than &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목표는 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt; 보다 경로의 의미를 더 잘 유지하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4e6155b86f48a01b347dfb545d9546dfe24b006f" translate="yes" xml:space="preserve">
          <source>The goal of the roles system is to track when two types have the same underlying representation. In the example above, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation. But, the corresponding instances of &lt;code&gt;BadIdea&lt;/code&gt; would &lt;em&gt;not&lt;/em&gt; have the same representation, because the types of the implementations of &lt;code&gt;bad&lt;/code&gt; would be different.</source>
          <target state="translated">역할 시스템의 목표는 두 유형이 동일한 기본 표현을 갖는시기를 추적하는 것입니다. 위의 예에서 &lt;code&gt;Age&lt;/code&gt; 와 &lt;code&gt;Int&lt;/code&gt; 는 같은 표현입니다. 그러나,의 해당 인스턴스 &lt;code&gt;BadIdea&lt;/code&gt; 는 것 &lt;em&gt;하지&lt;/em&gt; 의 구현의 종류 때문에, 같은 표현이 &lt;code&gt;bad&lt;/code&gt; 다른 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae5a7fa8ebdfcbe0b2302748233617b3ca55c26a" translate="yes" xml:space="preserve">
          <source>The goal of typed holes is to help with writing Haskell code rather than to change the type system. Typed holes can be used to obtain extra information from the type checker, which might otherwise be hard to get. Normally, using GHCi, users can inspect the (inferred) type signatures of all top-level bindings. However, this method is less convenient with terms that are not defined on top-level or inside complex expressions. Holes allow the user to check the type of the term they are about to write.</source>
          <target state="translated">유형이 지정된 구멍의 목표는 유형 시스템을 변경하는 것이 아니라 Haskell 코드 작성을 돕는 것입니다. 유형이 지정된 구멍을 사용하여 유형 검사기에서 추가 정보를 얻을 수 있습니다. 그렇지 않으면 얻기가 어려울 수 있습니다. 일반적으로 GHCi를 사용하여 사용자는 모든 최상위 바인딩의 (유추 된) 유형 서명을 검사 할 수 있습니다. 그러나이 방법은 최상위 수준이나 복잡한 식에 정의되어 있지 않은 용어의 경우 편리하지 않습니다. 구멍을 사용하면 작성하려는 용어의 유형을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbbcd933189820e27a73038da6c88d11c5e0b90" translate="yes" xml:space="preserve">
          <source>The gory details:</source>
          <target state="translated">처참한 세부 사항 :</target>
        </trans-unit>
        <trans-unit id="19256158b7bc99497456b028690add2697259def" translate="yes" xml:space="preserve">
          <source>The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible.</source>
          <target state="translated">문법은 람다 추상화, let 표현 및 조건의 범위와 관련하여 모호합니다. 모호성은 이러한 각 구성이 가능한 한 오른쪽으로 확장되는 메타 규칙에 의해 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="13bcdca0f47d6db8faa9273bbcc3a3514eb3a812" translate="yes" xml:space="preserve">
          <source>The graph obtained by reversing all edges.</source>
          <target state="translated">모든 모서리를 반전시켜 얻은 그래프.</target>
        </trans-unit>
        <trans-unit id="84d579939cacc525ddd770c640be60c5f760cbb9" translate="yes" xml:space="preserve">
          <source>The graph: a list of nodes uniquely identified by keys, with a list of keys of nodes this node has edges to. The out-list may contain keys that don't correspond to nodes of the graph; such edges are ignored.</source>
          <target state="translated">그래프 : 키로 고유하게 식별 된 노드 목록과이 노드에있는 노드 키 목록이 있습니다. 외부 목록에는 그래프의 노드에 해당하지 않는 키가 포함될 수 있습니다. 이러한 모서리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="19a77ba5e8a6424783c2bacf9d044768e5056e5e" translate="yes" xml:space="preserve">
          <source>The group database</source>
          <target state="translated">그룹 데이터베이스</target>
        </trans-unit>
        <trans-unit id="5f7f3691b9f49cffc78327c99568ee0ff918b8c6" translate="yes" xml:space="preserve">
          <source>The hand-crafted instances can get away with only defining one of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;. All the other methods have default definitions in terms of one of these. The default definitions have the expected strictness and the expected asymptotic runtime and space costs, modulo small constant factors. If you choose to hand-tune, benchmarking is advised to see whether you're doing better than the default derived implementations, plus careful tests to ensure that the custom methods are correct.</source>
          <target state="translated">손으로 만든 인스턴스는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 중 하나만 정의하면 벗어날 수 있습니다 . 다른 모든 방법에는 이들 중 하나에 대한 기본 정의가 있습니다. 기본 정의에는 예상되는 엄격 성과 예상되는 점근 적 런타임 및 공간 비용, 모듈로 작은 상수 계수가 있습니다. 수동 조정을 선택하는 경우 기본 파생 구현보다 더 잘하고 있는지 확인하기위한 벤치마킹과 사용자 지정 메서드가 올바른지 확인하기위한 세심한 테스트가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="f37dce2ec9ac848392eba760bfa9b2a8e001c3e2" translate="yes" xml:space="preserve">
          <source>The hash sign does not change semantics at all. We tend to use variable names ending in &amp;ldquo;#&amp;rdquo; for unboxed values or types (e.g. &lt;code&gt;Int#&lt;/code&gt;), but there is no requirement to do so; they are just plain ordinary variables. Nor does the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension bring anything into scope. For example, to bring &lt;code&gt;Int#&lt;/code&gt; into scope you must import &lt;code&gt;GHC.Prim&lt;/code&gt; (see &lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;); the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension then allows you to &lt;em&gt;refer&lt;/em&gt; to the &lt;code&gt;Int#&lt;/code&gt; that is now in scope. Note that with this option, the meaning of &lt;code&gt;x#y = 0&lt;/code&gt; is changed: it defines a function &lt;code&gt;x#&lt;/code&gt; taking a single argument &lt;code&gt;y&lt;/code&gt;; to define the operator &lt;code&gt;#&lt;/code&gt;, put a space: &lt;code&gt;x # y = 0&lt;/code&gt;.</source>
          <target state="translated">해시 부호는 의미를 전혀 변경하지 않습니다. 우리는 unboxed 값이나 타입 (예 : &lt;code&gt;Int#&lt;/code&gt; ) 에&amp;ldquo;#&amp;rdquo;으로 끝나는 변수 이름을 사용하는 경향이 있지만 그렇게 할 필요는 없습니다. 그것들은 평범한 보통 변수입니다. &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; 확장은 범위에 포함 되지 않습니다 . 예를 들어, &lt;code&gt;Int#&lt;/code&gt; 를 범위 내로 가져 오려면 &lt;code&gt;GHC.Prim&lt;/code&gt; 을 가져와야합니다 ( &lt;a href=&quot;#primitives&quot;&gt;박스없는 유형 및 기본 작업 참조&lt;/a&gt; ). 그러면 &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; 확장을 통해 현재 범위 에있는 &lt;code&gt;Int#&lt;/code&gt; 를 &lt;em&gt;참조&lt;/em&gt; 할 수 있습니다 . 이 옵션을 사용하면 &lt;code&gt;x#y = 0&lt;/code&gt; 의 의미 가 변경됩니다. 단일 인수를 사용하여 &lt;code&gt;x#&lt;/code&gt; 함수를 정의합니다. &lt;code&gt;y&lt;/code&gt; ; 연산자 &lt;code&gt;#&lt;/code&gt; 를 정의하려면 &lt;code&gt;x # y = 0&lt;/code&gt; 공백을 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="fe6235d545c856a2120a7bce1771f62a044ee79e" translate="yes" xml:space="preserve">
          <source>The hash sign does not change semantics at all. We tend to use variable names ending in &amp;ldquo;#&amp;rdquo; for unboxed values or types (e.g. &lt;code&gt;Int#&lt;/code&gt;), but there is no requirement to do so; they are just plain ordinary variables. Nor does the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension bring anything into scope. For example, to bring &lt;code&gt;Int#&lt;/code&gt; into scope you must import &lt;code&gt;GHC.Prim&lt;/code&gt; (see &lt;a href=&quot;primitives#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;); the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension then allows you to &lt;em&gt;refer&lt;/em&gt; to the &lt;code&gt;Int#&lt;/code&gt; that is now in scope. Note that with this option, the meaning of &lt;code&gt;x#y = 0&lt;/code&gt; is changed: it defines a function &lt;code&gt;x#&lt;/code&gt; taking a single argument &lt;code&gt;y&lt;/code&gt;; to define the operator &lt;code&gt;#&lt;/code&gt;, put a space: &lt;code&gt;x # y = 0&lt;/code&gt;.</source>
          <target state="translated">해시 기호는 의미 체계를 전혀 변경하지 않습니다. 박스되지 않은 값이나 유형 (예 : &lt;code&gt;Int#&lt;/code&gt; )에 대해 &quot;#&quot;로 끝나는 변수 이름을 사용하는 경향이 있지만 그렇게 할 필요는 없습니다. 그들은 단지 평범한 일반 변수 일뿐입니다. &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; 확장은 어떤 것도 범위로 가져 오지 않습니다 . 예를 들어 &lt;code&gt;Int#&lt;/code&gt; 을 범위로 가져 오려면 &lt;code&gt;GHC.Prim&lt;/code&gt; 을 가져와야합니다 ( &lt;a href=&quot;primitives#primitives&quot;&gt;Unboxed 유형 및 기본 연산 참조&lt;/a&gt; ). 그러면 &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; 확장을 통해 현재 범위 에있는 &lt;code&gt;Int#&lt;/code&gt; 을 &lt;em&gt;참조&lt;/em&gt; 할 수 있습니다 . 이 옵션을 사용하면 &lt;code&gt;x#y = 0&lt;/code&gt; 의 의미 가 변경됩니다. 단일 인수를 사용하는 &lt;code&gt;x#&lt;/code&gt; 함수를 정의합니다. &lt;code&gt;y&lt;/code&gt; ; &lt;code&gt;#&lt;/code&gt; 연산자를 정의하려면 공백을 넣으십시오 : &lt;code&gt;x # y = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5774d0c554fe343baa60ffa9eae14d57f8ade00" translate="yes" xml:space="preserve">
          <source>The header describes each event type and its length. Tools that don&amp;rsquo;t recognise a particular event type can skip those events.</source>
          <target state="translated">헤더는 각 이벤트 유형과 길이를 설명합니다. 특정 이벤트 유형을 인식하지 못하는 도구는 해당 이벤트를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2210882c0ad0919709f59e7db6b4f28dc98cefd9" translate="yes" xml:space="preserve">
          <source>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</source>
          <target state="translated">헤더 행 다음에는 (따옴표가 붙은) 문자열 리터럴로 인코딩 된 하나의 완료 후보를 각각 포함하는 ⟨l⟩ 행이옵니다. 다음은 다양한 경우를 보여주는 예제 호출입니다.</target>
        </trans-unit>
        <trans-unit id="de913877c8fa30a91fa438399fb16f39f34a7e00" translate="yes" xml:space="preserve">
          <source>The header of a signature is &lt;code&gt;signature A where ...&lt;/code&gt; (instead of the usual &lt;code&gt;module A where ...&lt;/code&gt;).</source>
          <target state="translated">서명의 헤더는 &lt;code&gt;signature A where ...&lt;/code&gt; (일반 &lt;code&gt;module A where ...&lt;/code&gt; 대신 ).</target>
        </trans-unit>
        <trans-unit id="78e62bbf377912fb128bb2f1870fb9fa408d92d9" translate="yes" xml:space="preserve">
          <source>The heap profiler can produce output to GHC&amp;rsquo;s event log, allowing samples to be correlated with other event log events over the program&amp;rsquo;s lifecycle.</source>
          <target state="translated">힙 프로파일 러는 GHC의 이벤트 로그에 출력을 생성하여 프로그램 수명주기 동안 샘플을 다른 이벤트 로그 이벤트와 상관시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd522d72de3dbc3a1ac632468d70b83c0446184" translate="yes" xml:space="preserve">
          <source>The heap-overflow message.</source>
          <target state="translated">힙 오버플로 메시지</target>
        </trans-unit>
        <trans-unit id="baec639ab942341375f18c11aa4da668c27baef2" translate="yes" xml:space="preserve">
          <source>The hexadecimal notation for floating point literals is useful when you need to specify floating point constants precisely, as the literal notation corresponds closely to the underlying bit-encoding of the number.</source>
          <target state="translated">부동 소수점 리터럴에 대한 16 진 표기법은 리터럴 표기법이 숫자의 기본 비트 인코딩과 거의 일치하므로 부동 소수점 상수를 정확하게 지정해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0542015ab0e10f3b338b694e109bbc36d0e1ca73" translate="yes" xml:space="preserve">
          <source>The history is only available when using &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</source>
          <target state="translated">히스토리는 다음을 사용할 때만 사용 가능 &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; . 그 이유는 히스토리에서 각 중단 점을 로깅하면 성능이 2 배 이상 줄어든다는 사실을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="8e8742e7091ac952b2100b44f6fcab38011c36c7" translate="yes" xml:space="preserve">
          <source>The hpc command has several sub-commands:</source>
          <target state="translated">hpc 명령에는 몇 가지 하위 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd85d2b986388d0386fde70a80e9bce5adc09ca4" translate="yes" xml:space="preserve">
          <source>The hpc tool assumes you are in the top-level directory of the location where you built your application, and the &lt;code&gt;.tix&lt;/code&gt; file is in the same top-level directory. You can use the flag &lt;code&gt;--srcdir&lt;/code&gt; to use &lt;code&gt;hpc&lt;/code&gt; for any other directory, and use &lt;code&gt;--srcdir&lt;/code&gt; multiple times to analyse programs compiled from difference locations, as is typical for packages.</source>
          <target state="translated">hpc 도구는 사용자가 응용 프로그램을 빌드 한 위치의 최상위 디렉토리에 있고 &lt;code&gt;.tix&lt;/code&gt; 파일이 동일한 최상위 디렉토리에 있다고 가정합니다 . &lt;code&gt;--srcdir&lt;/code&gt; 플래그 를 사용 하여 다른 디렉토리에 &lt;code&gt;hpc&lt;/code&gt; 를 사용하고 &lt;code&gt;--srcdir&lt;/code&gt; 을 여러 번 사용 하여 패키지와 같이 다른 위치에서 컴파일 된 프로그램을 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae95e293d652aa6b2e442077a87caf492f54c808" translate="yes" xml:space="preserve">
          <source>The idea is that &lt;code&gt;a&lt;/code&gt; should really be a representational parameter, but role inference assigns it to phantom. This makes some level of sense: a pointer to an &lt;code&gt;Int&lt;/code&gt; really is representationally the same as a pointer to a &lt;code&gt;Bool&lt;/code&gt;. But, that&amp;rsquo;s not at all how we want to use &lt;code&gt;Ptr&lt;/code&gt;s! So, we want to be able to say</source>
          <target state="translated">아이디어는 점이다 &lt;code&gt;a&lt;/code&gt; 는 정말 역할 추론 양수인은 팬텀에 재현 매개 변수 수 있지만합니다. 이것은 어느 정도 의미가 있습니다 &lt;code&gt;Int&lt;/code&gt; 대한 포인터 는 실제로 &lt;code&gt;Bool&lt;/code&gt; 에 대한 포인터와 동일 합니다. 그러나 그것은 우리가 &lt;code&gt;Ptr&lt;/code&gt; 을 어떻게 사용하고 싶은가가 아닙니다 ! 그래서 우리는 말할 수 있기를 원합니다</target>
        </trans-unit>
        <trans-unit id="e9b8ad3e3c7027edac335bae313b7046d76ae478" translate="yes" xml:space="preserve">
          <source>The idea is that we can then use &lt;code&gt;Point&lt;/code&gt; just as if we had defined a new datatype &lt;code&gt;MyPoint&lt;/code&gt; with two fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">아이디어는 두 개의 필드 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 로 새 데이터 유형 &lt;code&gt;MyPoint&lt;/code&gt; 를 정의한 것처럼 &lt;code&gt;Point&lt;/code&gt; 를 사용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b5577da026d4ae923963655859a7950c0d959c92" translate="yes" xml:space="preserve">
          <source>The idea is that we have a new fundamental type constant &lt;code&gt;TYPE&lt;/code&gt;, which is parameterised by a &lt;code&gt;RuntimeRep&lt;/code&gt;. We thus get &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt;. Anything with a type of the form &lt;code&gt;TYPE x&lt;/code&gt; can appear to either side of a function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt;. We can thus say that &lt;code&gt;-&amp;gt;&lt;/code&gt; has type &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt;. The result is always lifted because all functions are lifted in GHC.</source>
          <target state="translated">아이디어는 새로운 기본 유형 상수 &lt;code&gt;TYPE&lt;/code&gt; 을 가지고 있으며, 이는 &lt;code&gt;RuntimeRep&lt;/code&gt; 에 의해 매개 변수화됩니다 . 따라서 &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; 및 &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt; . &lt;code&gt;TYPE x&lt;/code&gt; 형식의 유형을 가진 모든 것은 기능 화살표 &lt;code&gt;-&amp;gt;&lt;/code&gt; 의 양쪽에 나타날 수 있습니다 . 따라서 &lt;code&gt;-&amp;gt;&lt;/code&gt; 유형이 &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt; 있습니다. 모든 기능이 GHC에서 해제되므로 결과는 항상 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fa2009e07206ad049abebf85b239bfe1d707aee1" translate="yes" xml:space="preserve">
          <source>The idea is there can be no legal calls to &lt;code&gt;f&lt;/code&gt; because every call will give rise to an ambiguous constraint. Indeed, the &lt;em&gt;only&lt;/em&gt; purpose of the ambiguity check is to report functions that cannot possibly be called. We could soundly omit the ambiguity check on type signatures entirely, at the expense of delaying ambiguity errors to call sites. Indeed, the language extension &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt;&lt;code&gt;AllowAmbiguousTypes&lt;/code&gt;&lt;/a&gt; switches off the ambiguity check.</source>
          <target state="translated">모든 호출이 모호한 제약을 야기하기 때문에 &lt;code&gt;f&lt;/code&gt; 에 대한 합법적 인 호출은 불가능하다는 아이디어입니다 . 실제로 모호성 검사 의 &lt;em&gt;유일한&lt;/em&gt; 목적은 호출 할 수없는 기능을보고하는 것입니다. 호출 사이트에 대한 모호성 오류를 지연시키면서 유형 서명에 대한 모호성 검사를 완전히 생략 할 수 있습니다. 실제로 언어 확장 &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt; &lt;code&gt;AllowAmbiguousTypes&lt;/code&gt; &lt;/a&gt; 는 모호성 검사를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9edc673edb982c2282b649a46c26961301e8081f" translate="yes" xml:space="preserve">
          <source>The idea of using existential quantification in data type declarations was suggested by Perry, and implemented in Hope+ (Nigel Perry, &lt;em&gt;The Implementation of Practical Functional Programming Languages&lt;/em&gt;, PhD Thesis, University of London, 1991). It was later formalised by Laufer and Odersky (&lt;em&gt;Polymorphic type inference and abstract data types&lt;/em&gt;, TOPLAS, 16(5), pp. 1411-1430, 1994). It&amp;rsquo;s been in Lennart Augustsson&amp;rsquo;s &lt;code&gt;hbc&lt;/code&gt; Haskell compiler for several years, and proved very useful. Here&amp;rsquo;s the idea. Consider the declaration:</source>
          <target state="translated">데이터 유형 선언에 실존 적 정량화를 사용한다는 아이디어는 Perry가 제안했으며 Hope + (Nigel Perry, &lt;em&gt;실용 기능 프로그래밍 언어 구현&lt;/em&gt; , PhD 논문, 1991 년 런던)에서 구현되었습니다. 나중에 Laufer와 Odersky에 의해 공식화되었다 ( &lt;em&gt;다형성 형 추론과 추상 자료형&lt;/em&gt; , TOPLAS, 16 (5), 141-1430, 1994). Lennart Augustsson의 &lt;code&gt;hbc&lt;/code&gt; Haskell 컴파일러에서 몇 년 동안 사용 되어 왔으며 매우 유용하다는 것이 입증되었습니다. 여기 아이디어가 있습니다. 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f61001cad70bbaad44a625a79404312846844b51" translate="yes" xml:space="preserve">
          <source>The identity arrow, which plays the role of &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in arrow notation.</source>
          <target state="translated">화살표 표기법에서 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 의 역할을하는 ID 화살표 .</target>
        </trans-unit>
        <trans-unit id="d797741d4a3ad156d7b9784f618a05a1d311a057" translate="yes" xml:space="preserve">
          <source>The identity functor and monad.</source>
          <target state="translated">정체성 functor와 모나드.</target>
        </trans-unit>
        <trans-unit id="7c8b0e59b588b67f3edbe61854791ee47cfe12bb" translate="yes" xml:space="preserve">
          <source>The identity monad transformer</source>
          <target state="translated">아이덴티티 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="54f9712c13de60b181bae26ad1f4c1f7a1f328db" translate="yes" xml:space="preserve">
          <source>The identity monad transformer.</source>
          <target state="translated">아이덴티티 모나드 변압기.</target>
        </trans-unit>
        <trans-unit id="bf1cafdec594d8369ed303bb1c662b40aaf0daff" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="a4ceda1c87510537b203d25ca80c04c39b54cdf6" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 의 정체성 . 또한 방정식을 만족해야합니다</target>
        </trans-unit>
        <trans-unit id="deee9983cee920e92095b678fac9a903e0f11845" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="034960daf8bea9c51407ed94a1c25464ed2788bc" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 의 정체성 . 또한 방정식을 만족해야합니다</target>
        </trans-unit>
        <trans-unit id="5dbaaef3597110434c54ae1a2138fb5629731bbb" translate="yes" xml:space="preserve">
          <source>The implementation does not support system calls.</source>
          <target state="translated">구현은 시스템 호출을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7512c5f22af2e468e091d738afee317bd6f3ab0c" translate="yes" xml:space="preserve">
          <source>The implementation is based on</source>
          <target state="translated">구현은</target>
        </trans-unit>
        <trans-unit id="4406a52eaac6bbe886c15f95aa7c9a4f4887ba65" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">구현은 &lt;em&gt;빅 엔디안 패트리샤 트리를&lt;/em&gt; 기반으로 합니다. 이 데이터 구조는 특히 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 와 같은 이진 연산에서 잘 수행 됩니다. 또한 벤치 마크에 따르면 일반적인 크기 균형 맵 구현과 비교할 때 삽입 및 삭제 속도가 훨씬 빠릅니다 ( &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="42cee383ad635f6c8d6a1715e198b017fcd560b8" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">구현은 &lt;em&gt;빅 엔디안 패트리샤 트리를&lt;/em&gt; 기반으로 합니다. 이 데이터 구조는 특히 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 와 같은 이진 연산에서 잘 수행 됩니다. 또한 벤치 마크에 따르면 일반적인 크기 균형 맵 구현과 비교할 때 삽입 및 삭제 속도가 훨씬 빠릅니다 ( &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5899bda78d1b99406df43306b7f1534696819133" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">구현은 &lt;em&gt;빅 엔디안 패트리샤 트리를&lt;/em&gt; 기반으로 합니다. 이 데이터 구조는 특히 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 와 같은 이진 연산에서 잘 수행 됩니다. 또한 벤치 마크에 따르면 일반적인 크기 균형 맵 구현과 비교할 때 삽입 및 삭제 속도가 훨씬 빠릅니다 ( &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="78d8c8ee898c5c545e70528f4e14f986552f2ded" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">구현은 &lt;em&gt;빅 엔디안 패트리샤 트리를&lt;/em&gt; 기반으로 합니다. 이 데이터 구조는 특히 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 와 같은 이진 연산에서 잘 수행 됩니다. 그러나 내 벤치 마크는 일반적인 크기 균형 맵 구현과 비교할 때 삽입 및 삭제가 훨씬 빠릅니다 ( &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="24c8616bf917dc1c69eac297bc08b786fe0c06a6" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">구현은 &lt;em&gt;빅 엔디안 패트리샤 트리를&lt;/em&gt; 기반으로 합니다. 이 데이터 구조는 특히 &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 와 같은 이진 연산에서 잘 수행 됩니다. 그러나 내 벤치 마크에 따르면 일반적인 크기 균형 세트 구현과 비교할 때 삽입 및 삭제가 훨씬 빠릅니다 ( &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="55fccc3b15937a9358c0161b537d1afd44dfe908" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">구현은 &lt;em&gt;빅 엔디안 패트리샤 트리를&lt;/em&gt; 기반으로 합니다. 이 데이터 구조는 특히 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 와 같은 이진 연산에서 잘 수행 됩니다. 그러나 내 벤치 마크에 따르면 일반적인 크기 균형 세트 구현과 비교할 때 삽입 및 삭제가 훨씬 빠릅니다 ( &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="178e58b7fb96bd95fd580401e99f441f886cc770" translate="yes" xml:space="preserve">
          <source>The implementation is based on the traditional purely-functional queue representation that uses two lists to obtain amortised O(1) enqueue and dequeue operations.</source>
          <target state="translated">구현은 두 개의 목록을 사용하여 상각 된 O (1) 대기열에 넣고 대기열에 넣는 작업을 얻는 전통적인 순수 기능 대기열 표현을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="4463036bd69024477097c960a434a6af09c8061f" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that reordering of memory operations cannot cause type-correct code to go wrong. In particular, when inspecting the value read from an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, the memory writes that created that value must have occurred from the point of view of the current thread.</source>
          <target state="translated">메모리 연산의 재정렬로 인해 유형이 올바른 코드가 잘못 될 수 없도록 구현해야합니다. 특히, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 에서 읽은 값을 검사 할 때 해당 값 을 작성한 메모리는 현재 스레드의 관점에서 발생했음을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2265bbdfb2325f3d1ecc971e928ff3e80fe406dd" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 용 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; 구현 . &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 에 전달 된 함수 가 해당 인수를 검사하면 결과 작업에서 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="fb8ec445b14ea757e9282327414d673b0305ee28" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 용 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; 구현 . &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 에 전달 된 함수 가 인수를 검사하면 결과 조치는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; 을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="1954d03eb74e27b2786def1df3092b1af81aea19" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 용 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; 구현 . &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 에 전달 된 함수 가 해당 인수를 검사하면 결과 작업에서 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="10f5d1702e3170c14a64676532aebf2fd23b667a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 구현은 다음 과 같이 &lt;em&gt;크기 균형&lt;/em&gt; 이진 트리 (또는 &lt;em&gt;경계 균형&lt;/em&gt; 트리)를 기반으로 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f3594b695ff2e4cfc4a3fffda3940bb5f4b15f6c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 구현은 다음 과 같이 &lt;em&gt;크기 균형&lt;/em&gt; 이진 트리 (또는 &lt;em&gt;경계 균형&lt;/em&gt; 트리)를 기반으로 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ded865df489185e9f39c1a5890fb3ac2d0d16a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 의 구현은 다음 과 같이 &lt;em&gt;크기 균형&lt;/em&gt; 이진 트리 (또는 &lt;em&gt;경계 균형&lt;/em&gt; 트리)를 기반으로 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb1e65a073f89d353d1b82491d0d335135d9d69" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; 메시지 의 구현</target>
        </trans-unit>
        <trans-unit id="0444f9d8082237d5b98f84df587436a9614cf1ab" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; message: create a new IORef QState, and return a RemoteRef to it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; 메시지 의 구현 : 새로운 IORef QState를 생성하고 RemoteRef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc3fa0b81755563203b0ca242878725420112c8" translate="yes" xml:space="preserve">
          <source>The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of</source>
          <target state="translated">이 구현에서는 4.2 절에 설명 된대로 크기가 지정된 2-3 개의 핑거 트리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a87c4ceafe0cd86c1c0f98a96d0e26cff7b08cc5" translate="yes" xml:space="preserve">
          <source>The implementation uses the call-stack simulation maintained by the profiler, so it only works if the program was compiled with &lt;code&gt;-prof&lt;/code&gt; and contains suitable SCC annotations (e.g. by using &lt;code&gt;-fprof-auto&lt;/code&gt;). Otherwise, the list returned is likely to be empty or uninformative.</source>
          <target state="translated">구현은 프로파일 러가 유지 관리하는 콜 스택 시뮬레이션을 사용하므로 프로그램이 &lt;code&gt;-prof&lt;/code&gt; 로 컴파일되고 적합한 SCC 주석이 포함 된 경우에만 작동합니다 (예 : &lt;code&gt;-fprof-auto&lt;/code&gt; 사용 ). 그렇지 않으면 리턴 된 목록이 비어 있거나 정보가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279de2dca31772c5e08f0ef6fa2ed64feed258e6" translate="yes" xml:space="preserve">
          <source>The important part here is the mismatch between &lt;code&gt;StateT s IO ()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ()&lt;/code&gt;.</source>
          <target state="translated">여기서 중요한 부분은 &lt;code&gt;StateT s IO ()&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ()&lt;/code&gt; 간의 불일치 입니다.</target>
        </trans-unit>
        <trans-unit id="b6788a58c1982f00220dd59a9ac7e8fe15617f19" translate="yes" xml:space="preserve">
          <source>The incoming &lt;code&gt;x&lt;/code&gt; is converted using &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt;, then we dispatch to the generic instances using &lt;code&gt;encode'&lt;/code&gt;. We use this as a default definition for &lt;code&gt;encode&lt;/code&gt;. We need the &lt;code&gt;default encode&lt;/code&gt; signature because ordinary Haskell default methods must not introduce additional class constraints, but our generic default does.</source>
          <target state="translated">들어오는 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; 을 사용하여 변환 된 다음 &lt;code&gt;encode'&lt;/code&gt; 사용하여 일반 인스턴스로 전달합니다 . 우리는 이것을 &lt;code&gt;encode&lt;/code&gt; 의 기본 정의로 사용 합니다. 일반적인 Haskell 기본 메소드는 추가 클래스 제약 조건을 도입해서는 안되지만 일반적인 &lt;code&gt;default encode&lt;/code&gt; 은 적용되므로 기본 인코딩 서명이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="2cdd8c06c5214198e849b6d05981aab3d32d8114" translate="yes" xml:space="preserve">
          <source>The incremental input interface</source>
          <target state="translated">증분 입력 인터페이스</target>
        </trans-unit>
        <trans-unit id="982c0c54fd891b5bd49cff179145ac54d3aa5b07" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">증분 인터페이스는 한 번에 엄격한 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 사용하며, 각각은 총 입력량의 일부입니다. 디코더가 완료하기 위해 더 많은 입력이 필요한 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; 을 반환합니다 계속되는 을 . 더 이상 입력이 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5fa1eaf98cc1d03c60771d063de7bc0a8c7e802" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">증분 인터페이스는 한 번에 총 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 엄격한 ByteString 을 사용합니다. 디코더가 완료하는 데 더 많은 입력이 필요한 경우 계속되는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; 을 반환합니다 . 더 이상 입력이 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e3c41ad6b5d83d116fe4119d2cee7ab80645968" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">증분 인터페이스는 한 번에 총 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 엄격한 ByteString 을 사용합니다. 디코더가 완료하는 데 더 많은 입력이 필요한 경우 계속되는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; 을 반환합니다 . 더 이상 입력이 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3146e319b6642665d719ade7d912bb954ff2d63" translate="yes" xml:space="preserve">
          <source>The incremental interface gives you more control over how input is provided during parsing. This lets you e.g. interleave parsing and I/O.</source>
          <target state="translated">인크 리 멘탈 인터페이스는 구문 분석 중 입력이 제공되는 방식을보다 강력하게 제어합니다. 이를 통해 인터리브 파싱 및 I / O를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d79c63965b8db6183932a4864f6bc6a68ec9ed" translate="yes" xml:space="preserve">
          <source>The indicated thread has been been woken up on another capability.</source>
          <target state="translated">표시된 스레드가 다른 기능에서 깨어났습니다.</target>
        </trans-unit>
        <trans-unit id="3fe6927713a0d567bb5595e1921afdf920aea86e" translate="yes" xml:space="preserve">
          <source>The indicated thread has been given a label (e.g. with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel&lt;/a&gt;).</source>
          <target state="translated">표시된 스레드에 레이블이 지정되었습니다 (예 : &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="15075d4fc62d0b6f1aaae2200c305eb363a5e225" translate="yes" xml:space="preserve">
          <source>The indicated thread has been given a label (e.g. with &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel&lt;/a&gt;).</source>
          <target state="translated">표시된 스레드에 레이블이 지정되었습니다 (예 : &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d766deb37652756438446d85435fb842af7f7ec5" translate="yes" xml:space="preserve">
          <source>The indicated thread has been migrated to a new capability.</source>
          <target state="translated">표시된 스레드가 새 기능으로 마이그레이션되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1273c5dfadba5394e62978c1d56db3a507e8ef5" translate="yes" xml:space="preserve">
          <source>The indicated thread has been woken up on another capability.</source>
          <target state="translated">표시된 스레드가 다른 기능에서 깨어났습니다.</target>
        </trans-unit>
        <trans-unit id="3ee679cea0bd8e5594a77998bcffe40595e2bc90" translate="yes" xml:space="preserve">
          <source>The indicated thread has started running.</source>
          <target state="translated">표시된 스레드가 실행을 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="01836651ef18a2e66ee3afe13febce95aa0f2625" translate="yes" xml:space="preserve">
          <source>The indicated thread has stopped running for the reason given by &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="translated">표시된 스레드가 &lt;code&gt;status&lt;/code&gt; 에 지정된 이유로 실행을 중지했습니다 .</target>
        </trans-unit>
        <trans-unit id="1c157bc7e4dea489c9b0115c1f05cad2ef0e188e" translate="yes" xml:space="preserve">
          <source>The indicated thread is has been marked as ready to run.</source>
          <target state="translated">표시된 스레드는 실행할 준비가 된 것으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="5e10db54e6f002a3c2b9a12ba3b2e1c228bc85a6" translate="yes" xml:space="preserve">
          <source>The inferred status is volatile: if an unsafe import is added to the module &lt;code&gt;B&lt;/code&gt;, it will cause compilation error of &lt;code&gt;A&lt;/code&gt;. When &lt;a href=&quot;#ghc-flag--Winferred-safe-imports&quot;&gt;&lt;code&gt;-Winferred-safe-imports&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this. This option is off by default.</source>
          <target state="translated">추론 된 상태는 휘발성입니다. 안전하지 않은 가져 오기가 모듈 &lt;code&gt;B&lt;/code&gt; 에 추가되면 &lt;code&gt;A&lt;/code&gt; 의 컴파일 오류가 발생 합니다. 때 &lt;a href=&quot;#ghc-flag--Winferred-safe-imports&quot;&gt; &lt;code&gt;-Winferred-safe-imports&lt;/code&gt; &lt;/a&gt; 활성화되어, 컴파일러는 이것에 대해 경고를 방출합니다. 이 옵션은 기본적으로 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c051b888dc5371d4c7a1728cceef03c9f9b40699" translate="yes" xml:space="preserve">
          <source>The information is formatted such that it can be read as a of type &lt;code&gt;[(String, String)]&lt;/code&gt;. Currently the following fields are present:</source>
          <target state="translated">정보는 형식으로 읽을 수 있도록 형식화됩니다 &lt;code&gt;[(String, String)]&lt;/code&gt; 됩니다. 현재 다음 필드가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5a76a6fe1392f713b6ebeea929ebb56029f377be" translate="yes" xml:space="preserve">
          <source>The initial counter value can be negative which denotes a resource &quot;debt&quot; that requires a respective amount of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; operations to counter-balance.</source>
          <target state="translated">초기 카운터 값은 음수 일 수 있으며, 이는 각각의 신호 량을 요구하는 자원 &quot;debt&quot;를 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; 카운터-밸런싱을 위해 동작을 .</target>
        </trans-unit>
        <trans-unit id="2dec26d2e77fa146664e92628931f0bd402a7a5d" translate="yes" xml:space="preserve">
          <source>The initial value left and right of the cursor</source>
          <target state="translated">커서의 왼쪽과 오른쪽의 초기 값</target>
        </trans-unit>
        <trans-unit id="c7b64e8e48e54908c3b727b4c3f0042b5289f865" translate="yes" xml:space="preserve">
          <source>The initialisation routine, &lt;code&gt;mylib_init&lt;/code&gt;, calls &lt;code&gt;hs_init()&lt;/code&gt; as normal to initialise the Haskell runtime, and the corresponding deinitialisation function &lt;code&gt;mylib_end()&lt;/code&gt; calls &lt;code&gt;hs_exit()&lt;/code&gt; to shut down the runtime.</source>
          <target state="translated">초기화 루틴 &lt;code&gt;mylib_init&lt;/code&gt; 는 , 호출 &lt;code&gt;hs_init()&lt;/code&gt; 하스켈 런타임을 초기화하는 정상 및 대응 deinitialisation 함수로서 &lt;code&gt;mylib_end()&lt;/code&gt; 호출 &lt;code&gt;hs_exit()&lt;/code&gt; 런타임 종료.</target>
        </trans-unit>
        <trans-unit id="77a4bde453187e4123c0b62e7f8a1460d7c946e4" translate="yes" xml:space="preserve">
          <source>The injectivity annotation is added after the type family head and consists of two parts:</source>
          <target state="translated">주 입성 주석은 유형 패밀리 헤드 뒤에 추가되며 다음 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="74ecac49867880c39edcc9122f73fce73221a98f" translate="yes" xml:space="preserve">
          <source>The input file should end with .hsc (it should be plain Haskell source only; literate Haskell is not supported at the moment). Output files by default get names with the &lt;code&gt;.hsc&lt;/code&gt; suffix replaced:</source>
          <target state="translated">입력 파일은 .hsc로 끝나야합니다 (일반 Haskell 소스 여야하며 현재는 문해 Haskell이 지원되지 않습니다). 기본적으로 출력 파일은 &lt;code&gt;.hsc&lt;/code&gt; 접미사가 바뀐 이름을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="54a5800cd273f30522c8241f5237a75f5ea6ce1e" translate="yes" xml:space="preserve">
          <source>The input lines stored in the history (newest first)</source>
          <target state="translated">히스토리에 저장된 입력 라인 (최초 순)</target>
        </trans-unit>
        <trans-unit id="6c739498395288f23756ffacf049c5d728041bb8" translate="yes" xml:space="preserve">
          <source>The input prompt</source>
          <target state="translated">입력 프롬프트</target>
        </trans-unit>
        <trans-unit id="57092b7ab7c2a987bc9c90336b0ad9cdf5249eb0" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오류를 일으킨 입력 값입니다. 입력 끝에 도달했거나 정확하게 식별 할 수 없어 오류가 발생한 경우이 값은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c829e8dd6d64c1ce230cecb6f9d190426f2f0af1" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오류를 일으킨 입력 값입니다. 입력 끝에 도달했거나 정확하게 식별 할 수 없어 오류가 발생한 경우이 값은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a789102517fd80a2368724fddec7f265c2285356" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오류를 일으킨 입력 값입니다. 입력 끝에 도달했거나 정확하게 식별 할 수 없어 오류가 발생한 경우이 값은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="194fbc6c8e32f5966df1c8df3ba5f34c6b050d18" translate="yes" xml:space="preserve">
          <source>The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;ldquo;.hs&amp;rdquo; and &amp;ldquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt;.</source>
          <target state="translated">Win32에 GHC를 설치하는 설치 프로그램은 &quot;.hs&quot;및 &quot;.lhs&quot;파일에 대한 파일 접미사 연결을 설정하여 두 번 클릭하면 &lt;code&gt;ghci&lt;/code&gt; 를 시작 합니다 .</target>
        </trans-unit>
        <trans-unit id="38d4405c8eebc2938893eeda1606e7e5691e0dd1" translate="yes" xml:space="preserve">
          <source>The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;rdquo;.hs&amp;rdquo; and &amp;rdquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt;.</source>
          <target state="translated">Win32에 GHC를 설치하는 설치 관리자는 &quot;.hs&quot;및 &quot;.lhs&quot;파일에 대한 파일 접미사 연결도 설정하여 두 번 클릭하면 &lt;code&gt;ghci&lt;/code&gt; 가 시작됩니다 . .</target>
        </trans-unit>
        <trans-unit id="aeaab7d9918fe1175bfdf3172a8ff60d6d574ffa" translate="yes" xml:space="preserve">
          <source>The instance axioms : &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</source>
          <target state="translated">인스턴스 공리 : &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf7d82e643d691468293fcd6f5135cfe7a24d9a1" translate="yes" xml:space="preserve">
          <source>The instance context is determined by the type signatures of the derived class&amp;rsquo;s methods. For instance, if the class is:</source>
          <target state="translated">인스턴스 컨텍스트는 파생 클래스 메서드의 형식 서명에 의해 결정됩니다. 예를 들어 클래스가 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="ead7524ad446883d4bbd99873e64016bb63c69da" translate="yes" xml:space="preserve">
          <source>The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt;&amp;lsquo;s interface file to find &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s definition.</source>
          <target state="translated">인스턴스 선언은 타입 &lt;code&gt;T&lt;/code&gt; 가 사용중인 경우에만 관련 이 있으며, 그렇다면 GHC는 &lt;code&gt;A&lt;/code&gt; 의 인터페이스 파일을 방문하여 &lt;code&gt;T&lt;/code&gt; 의 정의 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c74af4802b1ad145c9277583e68f6f35a7769d" translate="yes" xml:space="preserve">
          <source>The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt;&amp;rsquo;s interface file to find &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s definition.</source>
          <target state="translated">인스턴스 선언은 유형 &lt;code&gt;T&lt;/code&gt; 가 사용중인 경우에만 관련 이 있으며, 그렇다면 GHC는 &lt;code&gt;T&lt;/code&gt; 의 정의 를 찾기 위해 &lt;code&gt;A&lt;/code&gt; 의 인터페이스 파일을 방문했을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c7c21710f81c09d49133c941cdff45d1b58bd4f0" translate="yes" xml:space="preserve">
          <source>The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">단일 프로그램에서 사용되는 데이터 패밀리의 인스턴스 선언은 연관 여부에 관계없이 전혀 겹치지 않을 수 있습니다. 형식 클래스 인스턴스와 달리 이는 일관성 문제 일뿐만 아니라 형식 안전 문제이기도합니다.</target>
        </trans-unit>
        <trans-unit id="8cc7dac373c8ecc1b365857145ddad40214eea96" translate="yes" xml:space="preserve">
          <source>The instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is slightly awkward (but also rarely used):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 의 인스턴스 는 약간 어색합니다 (그러나 거의 사용되지 않음).</target>
        </trans-unit>
        <trans-unit id="289b8b3ebc33cd2f4157166d16a368f79f089f26" translate="yes" xml:space="preserve">
          <source>The instance for an associated type can be omitted in class instances. In that case, unless there is a default instance (see &lt;a href=&quot;#assoc-decl-defs&quot;&gt;Associated type synonym defaults&lt;/a&gt;), the corresponding instance type is not inhabited; i.e., only diverging expressions, such as &lt;code&gt;undefined&lt;/code&gt;, can assume the type.</source>
          <target state="translated">클래스 형식에서는 관련 형식의 인스턴스를 생략 할 수 있습니다. 이 경우 기본 인스턴스가 없으면 ( &lt;a href=&quot;#assoc-decl-defs&quot;&gt;관련 유형 동의어 기본값&lt;/a&gt; 참조 ) 해당 인스턴스 유형이 거주하지 않습니다. 즉, &lt;code&gt;undefined&lt;/code&gt; 와 같은 분기 식 만 유형을 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59904cb0ab2fe8f19f68bd984f2b517b8091cc17" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Prelude에&lt;/a&gt; 정의 된 목록, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 이러한 법률을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="585199a1b65eac2628d79ac97b369b88ce05f950" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Prelude에&lt;/a&gt; 정의 된 목록, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 이러한 법률을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="1581053810276ec21d30df3978e3008a7ff9fc55" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Prelude에&lt;/a&gt; 정의 된 목록, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 이러한 법률을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="1a017b052435df19797d88fb110f1e8782d90594" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;Prelude에&lt;/a&gt; 정의 된 목록, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 이러한 법률을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="f9f0c8e6289e586cc5baeea5fcfbbbe115d5e7f6" translate="yes" xml:space="preserve">
          <source>The intention is for &lt;code&gt;IsLabel&lt;/code&gt; to be used to support overloaded record fields and perhaps anonymous records. Thus, it may be given instances for base datatypes (in particular &lt;code&gt;(-&amp;gt;)&lt;/code&gt;) in the future.</source>
          <target state="translated">&lt;code&gt;IsLabel&lt;/code&gt; 레코드 필드 및 익명 레코드를 지원하기 위해 IsLabel 을 사용합니다. 따라서 향후 기본 데이터 유형 (특히 &lt;code&gt;(-&amp;gt;)&lt;/code&gt; )에 대한 인스턴스가 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26b1329858bfddb7f19887db1797b6a20a449184" translate="yes" xml:space="preserve">
          <source>The interact function takes a function of type &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">interact 함수는 &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; 유형의 함수를 인수로 사용합니다. 표준 입력 장치의 전체 입력이 인수로이 함수에 전달되고 결과 문자열이 표준 출력 장치에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="28bb27e789e236bd63cc99925076154513d01eb7" translate="yes" xml:space="preserve">
          <source>The interactive classes (only relevant when &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; is in effect) are: any numeric class, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; or &lt;code&gt;Traversable&lt;/code&gt;.</source>
          <target state="translated">대화식 클래스 ( &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt; 가 적용되는 경우에만 해당 )는 숫자 클래스, &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Foldable&lt;/code&gt; 또는 &lt;code&gt;Traversable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c15d5fb52d82aa70762f462a28f7dddcf408ca0" translate="yes" xml:space="preserve">
          <source>The interface file, which normally ends in a &lt;code&gt;.hi&lt;/code&gt; suffix, contains the information that GHC needs in order to compile further modules that depend on this module. It contains things like the types of exported functions, definitions of data types, and so on. It is stored in a binary format, so don&amp;rsquo;t try to read one; use the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option instead (see &lt;a href=&quot;#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">일반적으로 &lt;code&gt;.hi&lt;/code&gt; 접미사로 끝나는 인터페이스 파일 에는이 모듈에 종속 된 추가 모듈을 컴파일하기 위해 GHC에 필요한 정보가 포함되어 있습니다. 익스포트 된 함수의 유형, 데이터 유형의 정의 등과 같은 것이 포함됩니다. 이진 형식으로 저장되므로 읽지 마십시오. 사용 &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; 대신 옵션을 (참조 &lt;a href=&quot;#hi-options&quot;&gt;인터페이스 파일과 관련된 기타 옵션&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="01f926777c79e4e6d52fb1a2cf6afecc0a8b7f65" translate="yes" xml:space="preserve">
          <source>The interface output may be directed to another file &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; with the option &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; (not recommended).</source>
          <target state="translated">인터페이스 출력은 옵션 &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; (권장되지 않음)를 사용 하여 다른 파일 &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d422eff6b38b54b7b01cf3f23285761f3009b5be" translate="yes" xml:space="preserve">
          <source>The interface provides &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, a type representation which can be safely decomposed and composed. See &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; for an example of this.</source>
          <target state="translated">이 인터페이스는 안전하게 분해 및 구성 할 수있는 유형 표현 인 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 를 제공합니다 . &lt;a href=&quot;data-dynamic&quot;&gt;이에&lt;/a&gt; 대한 예는 Data.Dynamic 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7525fed411a95f2aba1be67c722e982ae098165e" translate="yes" xml:space="preserve">
          <source>The interpreter can&amp;rsquo;t load modules with foreign export declarations!</source>
          <target state="translated">인터프리터는 외국 수출 신고가있는 모듈을로드 할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="c6f1b29cc56478e029057e80fde7617996385c3a" translate="yes" xml:space="preserve">
          <source>The interpreter doesn&amp;rsquo;t support unboxed tuples, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">인터프리터는 언 박스 튜플을 지원하지 않으므로 GHCi는 이러한 모듈과 모듈이 의존하는 모든 모듈을 바이트 코드 대신 객체 코드로 자동 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="bcc96915fbf058774c86b1ad6764191d649fe219" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 역 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960baabb94ec6d41e7f419f3f0516ce7cfa51827" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 역 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e108698be586db7ffe3f616a94bfc73b7ee1a2" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year, the number of the Monday-starting week, and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 는 GET &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; , 해 월요일 - 시작 주 수, 요일을 지정. 첫 번째 월요일 주 1의 첫 번째 날, 올해 이전의 모든 일 주 0입니다 (같은 &lt;code&gt;%W&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2617db8ad5e573ea343c5794cabc4dfe2b8d32ba" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year and the number of the day of a Sunday-starting week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 오는 Get &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; 년 주어 일요일 - 시작하는 요일의 수를. 첫 번째 일요일은 주 1의 첫 번째 요일이며, 그 이전의 모든 요일은 주 0입니다 ( &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;%U&lt;/code&gt; 로 ).</target>
        </trans-unit>
        <trans-unit id="8e1d7169fde4f120c1aa4f3ece9ee57253f95f60" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; 의 역 , 즉 우리는 정체성</target>
        </trans-unit>
        <trans-unit id="085f4b1b3304279a7c72a59a48e1ceb8b934a83e" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; 의 역 , 즉 우리는 정체성</target>
        </trans-unit>
        <trans-unit id="bdd2cce8158f1320bcd058983fb015f9d2fa4781" translate="yes" xml:space="preserve">
          <source>The key component of a typechecker plugin is a function of type &lt;code&gt;TcPluginSolver&lt;/code&gt;, like this:</source>
          <target state="translated">유형 &lt;code&gt;TcPluginSolver&lt;/code&gt; 플러그인의 주요 구성 요소는 다음 과 같이 TcPluginSolver 유형의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="50146b4ed40e4fdb3a0f98772092c373b41b7b82" translate="yes" xml:space="preserve">
          <source>The key difference here is that we abstract over the type constructor &lt;code&gt;c&lt;/code&gt; that is used to form the collection type &lt;code&gt;c e&lt;/code&gt;, and not over that collection type itself, represented by &lt;code&gt;ce&lt;/code&gt; in the original class declaration. This avoids the immediate problems that we mentioned above: empty has type &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt;, which is not ambiguous.</source>
          <target state="translated">여기서 중요한 차이점 은 원래 클래스 선언에서 &lt;code&gt;ce&lt;/code&gt; 로 표시되는 컬렉션 유형 자체가 아니라 컬렉션 유형 &lt;code&gt;c e&lt;/code&gt; 를 형성하는 데 사용되는 형식 생성자 &lt;code&gt;c&lt;/code&gt; 를 추상화한다는 것 입니다. 이렇게하면 위에서 언급 한 즉각적인 문제를 피할 수 있습니다. empty에는 &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt; 유형 이 있습니다. 이는 모호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0a2d63680a54d95a48f0a685597191a4afae471" translate="yes" xml:space="preserve">
          <source>The key distinguishing feature of these folds is &lt;em&gt;conditional&lt;/em&gt; strictness in the second argument, it is sometimes evaluated and sometimes not.</source>
          <target state="translated">이러한 폴드의 주요 특징은 두 번째 인수의 &lt;em&gt;조건부&lt;/em&gt; 엄격 성이며 때로는 평가되고 때로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d931654af7b546e8d6ff7d64be51ee7d51eed95b" translate="yes" xml:space="preserve">
          <source>The key point about GADTs is that &lt;em&gt;pattern matching causes type refinement&lt;/em&gt;. For example, in the right hand side of the equation</source>
          <target state="translated">GADT의 핵심은 &lt;em&gt;패턴 일치로 인해 형식이 구체화&lt;/em&gt; 된다는 것 &lt;em&gt;입니다&lt;/em&gt; . 예를 들어 방정식의 오른쪽에서</target>
        </trans-unit>
        <trans-unit id="1c6ccf2ae2f2b690d9a1832c4814300edcd715a9" translate="yes" xml:space="preserve">
          <source>The key to defining your own datatype-generic functions is to understand how to represent datatypes using the given set of type constructors.</source>
          <target state="translated">고유 한 데이터 유형 일반 함수를 정의하는 핵심은 주어진 유형 생성자 세트를 사용하여 데이터 유형을 표시하는 방법을 이해하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="101f96a1728772ac592ac70565bf2d4fd3554ddc" translate="yes" xml:space="preserve">
          <source>The key tool to use in making your Haskell program run faster are GHC&amp;rsquo;s profiling facilities, described separately in &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;. There is &lt;em&gt;no substitute&lt;/em&gt; for finding where your program&amp;rsquo;s time/space is &lt;em&gt;really&lt;/em&gt; going, as opposed to where you imagine it is going.</source>
          <target state="translated">Haskell 프로그램을보다 빠르게 실행하는 데 사용하는 핵심 도구는 GHC의 프로파일 링 기능으로, &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링에&lt;/a&gt; 별도로 설명되어 있습니다. 프로그램의 시간 / 공간이 &lt;em&gt;실제로&lt;/em&gt; 어디로 가고 있는지를 찾는 &lt;em&gt;대신&lt;/em&gt; 에 프로그램의 시간 / 공간이 어디로 가고 있는지를 찾는 &lt;em&gt;대신&lt;/em&gt; 할 수있는 것은 &lt;em&gt;없습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52cd9e5fb65950d32847b984e9879cffe2f00ec9" translate="yes" xml:space="preserve">
          <source>The keypad</source>
          <target state="translated">키패드</target>
        </trans-unit>
        <trans-unit id="89852fc3a3f80fb4cacd31fc13b712715ce5683a" translate="yes" xml:space="preserve">
          <source>The kind &lt;code&gt;Type&lt;/code&gt; (imported from &lt;code&gt;Data.Kind&lt;/code&gt;) classifies ordinary types. With &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; (currently enabled by default), &lt;code&gt;*&lt;/code&gt; is desugared to &lt;code&gt;Type&lt;/code&gt;, but using this legacy syntax is not recommended due to conflicts with &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;. This also applies to &lt;code&gt;★&lt;/code&gt;, the Unicode variant of &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">종류 &lt;code&gt;Type&lt;/code&gt; (수입 &lt;code&gt;Data.Kind&lt;/code&gt; 가 ) 일반 유형을 분류한다. 함께 &lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; (현재 기본적으로 활성화 됨), &lt;code&gt;*&lt;/code&gt; 가 에 desugared되는 &lt;code&gt;Type&lt;/code&gt; 으로 인해 충돌에 있지만, 기존의 구문을 사용하지 않는 것이 좋습니다 &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; . 이것은 &lt;code&gt;*&lt;/code&gt; 의 유니 코드 변형 &lt;code&gt;★&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6913b5570f0803d21ed13498d1bb41de1395b416" translate="yes" xml:space="preserve">
          <source>The kind &lt;code&gt;Type&lt;/code&gt; (imported from &lt;code&gt;Data.Kind&lt;/code&gt;) classifies ordinary types. With &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; (currently enabled by default), &lt;code&gt;*&lt;/code&gt; is desugared to &lt;code&gt;Type&lt;/code&gt;, but using this legacy syntax is not recommended due to conflicts with &lt;a href=&quot;type_operators#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;. This also applies to &lt;code&gt;★&lt;/code&gt;, the Unicode variant of &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;Type&lt;/code&gt; ( &lt;code&gt;Data.Kind&lt;/code&gt; 에서 가져옴 )은 일반 유형을 분류합니다. 함께 &lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; (현재 기본적으로 활성화 됨), &lt;code&gt;*&lt;/code&gt; 가 에 desugared되는 &lt;code&gt;Type&lt;/code&gt; 으로 인해 충돌에 있지만, 기존의 구문을 사용하지 않는 것이 좋습니다 &lt;a href=&quot;type_operators#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; . 이것은 &lt;code&gt;*&lt;/code&gt; 의 유니 코드 변형 인 &lt;code&gt;★&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cd808c3a0aa47774f7ee55994f44b345c1912bc" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;lsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 매개 변수 의 종류 는 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 이지만 &lt;code&gt;Proxy&lt;/code&gt; 종류 는 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; , 여기서 &lt;code&gt;{k}&lt;/code&gt; 는 사용자가 지정하지 않은 종류 변수 &lt;code&gt;k&lt;/code&gt; 가 유추 됨을 나타냅니다 . 유추 지정 구별에 대한 자세한 내용은 &lt;a href=&quot;#visible-type-application&quot;&gt;Visible 유형 응용 프로그램&lt;/a&gt; 을 참조하십시오 . GHC는 모든 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 고려하지 않습니다 . k-&amp;gt; 유형 및 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; 가 같으면 유형 이 같으므로 &lt;code&gt;Foo Proxy&lt;/code&gt; 가 잘못된 것으로 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="501e257428a07ed8604e6574daf6ab00012b8123" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;lsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 매개 변수 의 종류 는 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 만의 종류 &lt;code&gt;Proxy&lt;/code&gt; 입니다 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; , 여기서 &lt;code&gt;{k}&lt;/code&gt; 는 사용자가 지정하지 않은 종류 변수 &lt;code&gt;k&lt;/code&gt; 가 유추 됨을 나타냅니다 . ( 추론 지정 구분에 대한 자세한 내용은 &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible 유형 응용 프로그램&lt;/a&gt; 을 참조하십시오 ). GHC는 모든 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 고려하지 않습니다 . k-&amp;gt; 유형 및 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; 은 종류 수준에서 동일하므로 &lt;code&gt;Foo Proxy&lt;/code&gt; 를 불친절한 것으로 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="0ade0b3069a9704ce4a195f04a058eddb6e7d6c9" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;rsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 의 매개 변수 종류 는 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 만의 종류 &lt;code&gt;Proxy&lt;/code&gt; 입니다 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; . 여기서 &lt;code&gt;{k}&lt;/code&gt; 는 사용자가 지정하지 않은 종류 변수 &lt;code&gt;k&lt;/code&gt; 가 유추 됨을 나타냅니다 . ( 추론 지정 구분에 대한 자세한 내용은 &lt;a href=&quot;#visible-type-application&quot;&gt;Visible 유형 응용 프로그램&lt;/a&gt; 을 참조하십시오 ). GHC는 모든 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 고려하지 않습니다 . k-&amp;gt; 유형 및 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; 은 종류 수준에서 동일하므로 &lt;code&gt;Foo Proxy&lt;/code&gt; 를 불친절한 것으로 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="d650258dfa554e9a0a612c8d7a0289cda5964e46" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Vec&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt;. This means that, e.g., &lt;code&gt;Vec Int Char&lt;/code&gt; is a well-kinded type, even though this is not what we intend when defining length-indexed vectors.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 의 종류 는 &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; 입니다. 예를 들어 &lt;code&gt;Vec Int Char&lt;/code&gt; 는 길이가 인덱스 된 벡터를 정의 할 때 의도 한 것이 아니라도 좋은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6bdcf0025de5c2355bf036fb20350561d0e1ffc4" translate="yes" xml:space="preserve">
          <source>The kind of constraints, like &lt;code&gt;Show a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Show a&lt;/code&gt; 와 같은 제약의 종류</target>
        </trans-unit>
        <trans-unit id="edcdb1e98f798994b974989fbcf928e872ca0cb5" translate="yes" xml:space="preserve">
          <source>The kind of types with lifted values. For example &lt;code&gt;Int :: Type&lt;/code&gt;.</source>
          <target state="translated">값이 해제 된 유형입니다. 예를 들어 &lt;code&gt;Int :: Type&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3970d2a390e8339e6194fae0a800fd7ee383f1f3" translate="yes" xml:space="preserve">
          <source>The kind of types with values. For example &lt;code&gt;Int :: Type&lt;/code&gt;.</source>
          <target state="translated">값이있는 유형의 종류 예를 들어 &lt;code&gt;Int :: Type&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a2ff1eafaf2cf50aa099b7bed39cd8ce178efc2" translate="yes" xml:space="preserve">
          <source>The kind-polymorphism from the class declaration makes &lt;code&gt;D1&lt;/code&gt; kind-polymorphic, but not so &lt;code&gt;D2&lt;/code&gt;; and similarly &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;.</source>
          <target state="translated">클래스 선언의 종류 다형성 은 &lt;code&gt;D1&lt;/code&gt; 을 종류 다형성으로 만들지 만 &lt;code&gt;D2&lt;/code&gt; 는 그렇지 않습니다 . 및 유사하게 &lt;code&gt;F1&lt;/code&gt; , &lt;code&gt;F1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddd8f61b7527fcc1e638886b50c5d6a07d4b1f1e" translate="yes" xml:space="preserve">
          <source>The kind-polymorphism from the class declaration makes &lt;code&gt;D1&lt;/code&gt; kind-polymorphic, but not so &lt;code&gt;D2&lt;/code&gt;; and similarly &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F2&lt;/code&gt;.</source>
          <target state="translated">클래스 선언의 종류 다형성 은 &lt;code&gt;D1&lt;/code&gt; 을 종류 다형성으로 만들지 만 &lt;code&gt;D2&lt;/code&gt; 는 그렇지 않습니다 . 및 유사하게 &lt;code&gt;F1&lt;/code&gt; , &lt;code&gt;F2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="142a287b02ca78aabf16196f308cd74692a41234" translate="yes" xml:space="preserve">
          <source>The kinds of the literals and all other low-level operations for this feature are defined in module &lt;code&gt;GHC.TypeLits&lt;/code&gt;. Note that the module defines some type-level operators that clash with their value-level counterparts (e.g. &lt;code&gt;(+)&lt;/code&gt;). Import and export declarations referring to these operators require an explicit namespace annotation (see &lt;a href=&quot;#explicit-namespaces&quot;&gt;Explicit namespaces in import/export&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 리터럴 및 기타 모든 하위 수준 작업은 &lt;code&gt;GHC.TypeLits&lt;/code&gt; 모듈에 정의되어 있습니다. 이 모듈은 값 수준 대응 요소와 충돌하는 일부 유형 수준 연산자 (예 : &lt;code&gt;(+)&lt;/code&gt; )를 정의합니다. 이러한 연산자를 참조하는 가져 오기 및 내보내기 선언에는 명시적인 네임 스페이스 주석이 필요합니다 ( &lt;a href=&quot;#explicit-namespaces&quot;&gt;import / export의 명시 적 네임 스페이스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e83d6bcc0e323c52a353a06373cda9346ea8686b" translate="yes" xml:space="preserve">
          <source>The kinds of the literals and all other low-level operations for this feature are defined in modules &lt;code&gt;GHC.TypeLits&lt;/code&gt; and &lt;code&gt;GHC.TypeNats&lt;/code&gt;. Note that these modules define some type-level operators that clash with their value-level counterparts (e.g. &lt;code&gt;(+)&lt;/code&gt;). Import and export declarations referring to these operators require an explicit namespace annotation (see &lt;a href=&quot;explicit_namespaces#explicit-namespaces&quot;&gt;Explicit namespaces in import/export&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 리터럴 및 기타 모든 저수준 작업의 종류는 &lt;code&gt;GHC.TypeLits&lt;/code&gt; 및 &lt;code&gt;GHC.TypeNats&lt;/code&gt; 모듈에 정의되어 있습니다. 이러한 모듈은 값 수준 대응 요소 (예 : &lt;code&gt;(+)&lt;/code&gt; ) 와 충돌하는 일부 유형 수준 연산자를 정의 합니다. 이러한 연산자를 참조하는 가져 오기 및 내보내기 선언에는 명시적인 네임 스페이스 주석이 필요합니다 ( &lt;a href=&quot;explicit_namespaces#explicit-namespaces&quot;&gt;import / export의 명시 적 네임 스페이스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f14aa2c065169defb0f47595c9265ce4ba5857e8" translate="yes" xml:space="preserve">
          <source>The lag stage, which is the time between creation and the first use of the object,</source>
          <target state="translated">지연 단계는 개체 생성과 처음 사용 사이의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="67f729cc5793b907e6283b32042b3a6379b975b3" translate="yes" xml:space="preserve">
          <source>The language &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; changes this behaviour:</source>
          <target state="translated">언어 &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt; 는이 동작을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="96eef94888750b6bf04df904c79af345e5cf88c6" translate="yes" xml:space="preserve">
          <source>The language definition for the Haskell language.</source>
          <target state="translated">하스켈 언어의 언어 정의.</target>
        </trans-unit>
        <trans-unit id="f35e66eca43d1117d42cef793c6da9da1b53ea98" translate="yes" xml:space="preserve">
          <source>The language definition for the language Mondrian.</source>
          <target state="translated">언어 Mondrian의 언어 정의.</target>
        </trans-unit>
        <trans-unit id="c6db1b982530559c016310cc1374654d4e113cec" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; adds support for expressing integer literals in binary notation with the prefix &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;. For instance, the binary integer literal &lt;code&gt;0b11001001&lt;/code&gt; will be desugared into &lt;code&gt;fromInteger 201&lt;/code&gt; when &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">언어 확장 기능 &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt; 는 접두사 &lt;code&gt;0b&lt;/code&gt; 또는 &lt;code&gt;0B&lt;/code&gt; 를 사용하여 정수 리터럴을 이진 표기법으로 표현할 수 있도록 지원합니다 . 예를 들어, &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 이진 정수 리터럴 &lt;code&gt;0b11001001&lt;/code&gt; 이 정수 &lt;code&gt;fromInteger 201&lt;/code&gt; desugar 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="2aa01e6792de69a814fc51631fa469117dc53520" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; allows &lt;code&gt;#&lt;/code&gt; as a postfix modifier to identifiers. Thus, &lt;code&gt;x#&lt;/code&gt; is a valid variable, and &lt;code&gt;T#&lt;/code&gt; is a valid type constructor or data constructor.</source>
          <target state="translated">언어 확장 &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 를&lt;/a&gt; 사용하면 식별자에 &lt;code&gt;#&lt;/code&gt; 를 접미사로 사용할 수 있습니다 . 따라서 &lt;code&gt;x#&lt;/code&gt; 은 유효한 변수이고 &lt;code&gt;T#&lt;/code&gt; 은 유효한 형식 생성자 또는 데이터 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="482fac3caa33dc4889f02993b124d842b7fc23c8" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumDecimals&quot;&gt;&lt;code&gt;NumDecimals&lt;/code&gt;&lt;/a&gt; allows you to also use the floating literal syntax for instances of &lt;code&gt;Integral&lt;/code&gt;, and have values like &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</source>
          <target state="translated">언어 확장 &lt;a href=&quot;#extension-NumDecimals&quot;&gt; &lt;code&gt;NumDecimals&lt;/code&gt; 는&lt;/a&gt; 당신은 또한 인스턴스에 대한 부동 리터럴 구문을 사용할 수 있습니다 &lt;code&gt;Integral&lt;/code&gt; 과 같은 값이 &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cdb57723b585621c77843b2adc5f3dd7c9046be" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;#14473&lt;/a&gt;.</source>
          <target state="translated">언어 확장 &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; 는 숫자 리터럴에서 밑줄을 표현하기위한 지원을 추가합니다. 예를 들어 숫자 리터럴 &lt;code&gt;1_000_000&lt;/code&gt; 은 &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;1000000&lt;/code&gt; 으로 구문 분석됩니다 . 즉, &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 숫자 리터럴의 밑줄이 무시됩니다 . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;# 14473&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7301f20dd6642c45e1a8ac269b635e38af928e05" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue #14473&lt;/a&gt;.</source>
          <target state="translated">언어 확장 &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; 는 밑줄을 숫자 리터럴로 표현할 수 있도록 지원합니다. 예를 들어 &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 숫자 리터럴 &lt;code&gt;1_000_000&lt;/code&gt; 이 &lt;code&gt;1000000&lt;/code&gt; 으로 구문 분석됩니다 . 즉, &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 숫자 리터럴의 밑줄이 무시됩니다 . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue # 14473&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1df0d3ed5fc3e05e0b2f091352293e402f435759" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; adds a new syntactic form &lt;code&gt;static e&lt;/code&gt;, which stands for a reference to the closed expression ⟨e⟩. This reference is stable and portable, in the sense that it remains valid across different processes on possibly different machines. Thus, a process can create a reference and send it to another process that can resolve it to ⟨e⟩.</source>
          <target state="translated">언어 확장 &lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt; 는 새로운 구문 양식 &lt;code&gt;static e&lt;/code&gt; 를 추가합니다. 이는 정적 표현 ⟨e⟩에 대한 참조를 나타냅니다. 이 참조는 가능한 한 다른 시스템의 다른 프로세스에서 유효하게 유지된다는 점에서 안정적이고 휴대 가능합니다. 따라서 프로세스는 참조를 작성하고이를 참조 할 수있는 다른 프로세스로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1164d109e3a8912c2bd8dbd337b1bd95e59931eb" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; allows much more flexible constraints in superclasses.</source>
          <target state="translated">&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; &lt;/a&gt; 언어 확장 은 수퍼 클래스에서 훨씬 더 유연한 제약을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a23afb63a5225acfa62366c99fa9002b8bd272d4" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; enables Unicode characters to be used to stand for certain ASCII character sequences. The following alternatives are provided:</source>
          <target state="translated">언어 확장 &lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; 를&lt;/a&gt; 사용하면 유니 코드 문자를 사용하여 특정 ASCII 문자 시퀀스를 나타낼 수 있습니다. 다음과 같은 대안이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0f020db4c2779c8a84447ac375908f8cf1851cd7" translate="yes" xml:space="preserve">
          <source>The language extensions control what variation of the language are permitted.</source>
          <target state="translated">언어 확장은 허용되는 언어 변형을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1e3e7e5b927ef3a07b1708c8234ccb8fab69c087" translate="yes" xml:space="preserve">
          <source>The language extensions known to GHC.</source>
          <target state="translated">GHC에 알려진 언어 확장.</target>
        </trans-unit>
        <trans-unit id="47f8be94c2ca864c563003d6cd62e96954c9f6b8" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; enables an alternative translation for the do-notation, which uses the operators &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, along with &lt;code&gt;join&lt;/code&gt; as far as possible. There are two main reasons for wanting to do this:</source>
          <target state="translated">언어 옵션 &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; 를 사용하면 가능한 한 &lt;code&gt;join&lt;/code&gt; 과 함께 연산자 &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 를 사용하는 do-notation에 대한 대체 번역이 가능합니다. 이 작업을 수행하려는 주된 이유는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="6758c18bb77d5105f15261fc6f768c32b1ac1a54" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;) enables higher-rank types. That is, you can nest &lt;code&gt;forall&lt;/code&gt;s arbitrarily deep in function arrows. For example, a forall-type (also called a &amp;ldquo;type scheme&amp;rdquo;), including a type-class context, is legal:</source>
          <target state="translated">언어 옵션 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 을 의미 )는 상위 유형을 활성화합니다. 즉 당신은 할 수 둥지입니다 &lt;code&gt;forall&lt;/code&gt; 기능 화살표에 임의 깊은이야. 예를 들어 형식 클래스 컨텍스트를 포함하여 forall 형식 ( &quot;유형 체계&quot;라고도 함)은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="c64f2257a0c3cac860c31a28931376ced36d51ce" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;) enables higher-rank types. That is, you can nest &lt;code&gt;forall&lt;/code&gt;s arbitrarily deep in function arrows. For example, a forall-type (also called a &amp;ldquo;type scheme&amp;rdquo;), including a type-class context, is legal:</source>
          <target state="translated">언어 옵션 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 을 의미 함 )는 더 높은 순위 유형을 활성화합니다. 즉, &lt;code&gt;forall&lt;/code&gt; 을 함수 화살표 깊이에 임의로 중첩 할 수 있습니다 . 예를 들어, 유형 클래스 컨텍스트를 포함하는 forall 유형 ( &quot;유형 체계&quot;라고도 함)은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="e43581d03051421db388e53bc00c80ed362d21f6" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">주어진 비교 함수와 관련하여 비어 있지 않은 구조의 가장 큰 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a09e69c04a0fae36b18bfad0cec44eb5b7dac599" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure.</source>
          <target state="translated">비어 있지 않은 구조의 가장 큰 요소입니다.</target>
        </trans-unit>
        <trans-unit id="1c3c62ef7c501b737425bd024e6b97dd8602a4d0" translate="yes" xml:space="preserve">
          <source>The last of these examples will generate a RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very well. If you use this kind of specialisation, let us know how well it works.</source>
          <target state="translated">이 예제 중 마지막 예제는 다소 복잡한 왼쪽을 가진 RULE을 생성하므로 직접 시도하십시오. 이런 종류의 전문화를 사용하는 경우 그것이 얼마나 잘 작동하는지 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="c09c37300640da9fa5a1e825531f7baf46e4a4a9" translate="yes" xml:space="preserve">
          <source>The last point means that, for example, this program:</source>
          <target state="translated">마지막 요점은 예를 들어 다음 프로그램을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c7b0fe0f98d69788b12fc3fe8961316784922da5" translate="yes" xml:space="preserve">
          <source>The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; falls back to a general &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; like lookup.</source>
          <target state="translated">마지막 문자열 매개 변수는 범위가 오래된 경우, 즉 파일이 변경되고 코드가 이동 한 경우에 유용합니다. 이 경우 &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt; 는 일반적인 &lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; like lookup으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="74662c9c171e1f11f6d4c17936e04e8cfc73a0a4" translate="yes" xml:space="preserve">
          <source>The last time we looked, this bug still wasn&amp;rsquo;t fixed in the BFD codebase, and there wasn&amp;rsquo;t any noticeable interest in fixing it when we reported the bug back in 2001 or so.</source>
          <target state="translated">우리가 마지막으로 보았을 때,이 버그는 여전히 BFD 코드베이스에서 수정되지 않았으며, 2001 년쯤에 버그를보고했을 때이 버그를 수정하는 데 별다른 관심이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="9fe53eb782e21aa8623285f038e6b38c9a5b34c9" translate="yes" xml:space="preserve">
          <source>The latter issue is partly mitigated by &lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt;. When it is enabled, &lt;code&gt;-5&lt;/code&gt; is parsed as negative 5 regardless of context, so &lt;code&gt;f
-5&lt;/code&gt; works as expected. However, it only applies to literals, so &lt;code&gt;f -x&lt;/code&gt; or &lt;code&gt;f -(a*2)&lt;/code&gt; are still parsed as subtraction.</source>
          <target state="translated">후자의 문제는 &lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; 에&lt;/a&gt; 의해 부분적으로 완화됩니다 . 활성화되면 &lt;code&gt;-5&lt;/code&gt; 는 컨텍스트에 관계없이 음수 5로 구문 분석되므로 &lt;code&gt;f -5&lt;/code&gt; 는 예상대로 작동합니다. 그러나 리터럴에만 적용되므로 &lt;code&gt;f -x&lt;/code&gt; 또는 &lt;code&gt;f -(a*2)&lt;/code&gt; 는 여전히 빼기로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="cc178347052a701ca8893682ca3efb8b74c8a5b7" translate="yes" xml:space="preserve">
          <source>The latter two extensions are simply a way to avoid littering high-performance code with bang patterns, making it harder to read.</source>
          <target state="translated">후자의 두 확장은 단순히 뱅 패턴으로 고성능 코드가 흩어지는 것을 피하여 읽기가 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="83ef67ff9e0acbd2b46b885ad1e2b9746fa12727" translate="yes" xml:space="preserve">
          <source>The layout rule applies in a pragma. Currently no new indentation level is set, so if you put several rules in single &lt;code&gt;RULES&lt;/code&gt; pragma and wish to use layout to separate them, you must lay out the starting in the same column as the enclosing definitions.</source>
          <target state="translated">레이아웃 규칙은 pragma에 적용됩니다. 현재 새 들여 쓰기 수준이 설정되어 있지 않으므로 단일 &lt;code&gt;RULES&lt;/code&gt; 규칙에 여러 규칙을 적용하고 레이아웃을 사용하여 규칙 을 구분하려면 시작 정의를 동일한 열에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2d17886ee9122e995c736b68557cda7950811bf" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; SA &lt;code&gt; returns a value of type &lt;/code&gt; &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; S &lt;code&gt;. The &lt;/code&gt; 의 @ 매개 변수 중 하나입니다</target>
        </trans-unit>
        <trans-unit id="ac6e3ae7e4004348b8ef187155f19d79dd8bbec8" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike &lt;code&gt;IO&lt;/code&gt;). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and executes in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. ST 모나드는 파괴적인 업데이트를 허용하지만 &lt;code&gt;IO&lt;/code&gt; 와 달리 이스케이프 할 수 있습니다 . 유형의 계산 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 리턴 형의 값 &quot;스레드&quot;에서 실행한다 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb5e3600ef521edc02534f8316cf1842086384c6" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; SA &lt;code&gt; returns a value of type &lt;/code&gt; &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; S &lt;code&gt;. The &lt;/code&gt; 의 @ 매개 변수 중 하나입니다</target>
        </trans-unit>
        <trans-unit id="1ad2f1e7509844be3baee16ce3c7bba88cdb0544" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike &lt;code&gt;IO&lt;/code&gt;). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and executes in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. ST 모나드는 파괴적인 업데이트를 허용하지만 &lt;code&gt;IO&lt;/code&gt; 와 달리 이스케이프 할 수 있습니다 . 유형의 계산 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 리턴 형의 값 &quot;스레드&quot;에서 실행한다 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40d868f620139062b248b76538a36b443a676fd8" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds accumulation capabilities (such as declarations or document patches) to a given monad.</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; 모나드 트랜스포머는 지정된 모나드에 누적 기능 (예 : 선언 또는 문서 패치)을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0148fab25056e7d25108af73020e1e1fd6b568bc" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 모나드 변환기는 주어진 모나드에 출력 (카운트 또는 문자열 출력과 같은) 컬렉션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="460dbda305fa0fdf243ff4aaca3b36cbface9176" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">게으른 &lt;code&gt;ByteString&lt;/code&gt; 유형 및 표현</target>
        </trans-unit>
        <trans-unit id="cd66658dbdbc20cd277316b5f47a31d85a5a657d" translate="yes" xml:space="preserve">
          <source>The lazy ByteString that results from &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; can be written to disk, and read from disk using Data.ByteString.Lazy IO functions, such as hPutStr or writeFile:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 인한 지연 ByteString 은 hPutStr 또는 writeFile과 같은 Data.ByteString.Lazy IO 함수를 사용하여 디스크에 기록하고 디스크에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81b4ea9d6659ffec90b8a98fd916cb7519cdd284" translate="yes" xml:space="preserve">
          <source>The lazy input interface</source>
          <target state="translated">게으른 입력 인터페이스</target>
        </trans-unit>
        <trans-unit id="18194b6ea93e37e29c30dcb32e97e5e2850d4eab" translate="yes" xml:space="preserve">
          <source>The lazy interface consumes a single lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It's the easiest interface to get started with, but it doesn't support interleaving I/O and parsing, unless lazy I/O is used.</source>
          <target state="translated">게으른 인터페이스는 하나의 게으른 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 사용 합니다. 시작하기 가장 쉬운 인터페이스이지만 지연 I / O를 사용하지 않으면 인터리빙 I / O 및 구문 분석을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="092a2d7e6eb9578252d9c4e385f301042def1952" translate="yes" xml:space="preserve">
          <source>The lazy interface consumes a single lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It's the easiest interface to get started with, but it doesn't support interleaving I/O and parsing, unless lazy I/O is used.</source>
          <target state="translated">lazy 인터페이스는 단일 lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 사용 합니다. 시작하기 가장 쉬운 인터페이스이지만 지연 I / O를 사용하지 않는 한 인터리빙 I / O 및 구문 분석을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e19ca3b21ce60a3bd3a188b4cb7d0f78b7ffd608" translate="yes" xml:space="preserve">
          <source>The lazy left-folds (used corecursively) and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldrM&quot;&gt;foldrM&lt;/a&gt;&lt;/code&gt; (used to sequence actions right-to-left) can be efficient in structures whose &lt;code&gt;Foldable&lt;/code&gt; instances take advantage of efficient right-to-left iteration to perform lazy left folds outside-in from the right-most element.</source>
          <target state="translated">lazy left-folds (corecursively 사용) 및 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldrM&quot;&gt;foldrM&lt;/a&gt;&lt;/code&gt; (오른쪽에서 왼쪽으로 작업 순서를 지정하는 데 사용됨)은 &lt;code&gt;Foldable&lt;/code&gt; 인스턴스가 효율적인 오른쪽에서 왼쪽 반복을 활용하여 외부에서 lazy left fold를 수행 하는 구조에서 효율적일 수 있습니다 . 맨 오른쪽 요소.</target>
        </trans-unit>
        <trans-unit id="d0f94810b2d4d1d107dde9a11881d98fcdccae35" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">주어진 비교 함수와 관련하여 비어 있지 않은 구조의 최소 요소.</target>
        </trans-unit>
        <trans-unit id="07d9943e6fdf33ee01fbdf7cd0db14fb536c6243" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure.</source>
          <target state="translated">비어 있지 않은 구조의 최소 요소</target>
        </trans-unit>
        <trans-unit id="a1279477379720ce92251e07056ae886bac29bc5" translate="yes" xml:space="preserve">
          <source>The left fold:</source>
          <target state="translated">왼쪽 접기 :</target>
        </trans-unit>
        <trans-unit id="0e70192fc1725fb44e6261baa525bb34fe0d8271" translate="yes" xml:space="preserve">
          <source>The left hand side of a rule must consist of a top-level variable applied to arbitrary expressions. For example, this is &lt;em&gt;not&lt;/em&gt; OK:</source>
          <target state="translated">규칙의 왼쪽은 임의의 표현식에 적용된 최상위 변수로 구성되어야합니다. 예를 들어, 이것은 OK 가 &lt;em&gt;아닙니다&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="9bbc16e1c3670ac6be9b561d2b10f00b7e4c905c" translate="yes" xml:space="preserve">
          <source>The length of a given month in the Gregorian or Julian calendars. First arg is leap year flag.</source>
          <target state="translated">그레고리력 또는 율리우스 력으로 주어진 달의 길이. 첫 번째 인수는 윤년 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="02862fec4929a80083ca47de3fabc777823d03ea" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reserved name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid identifier. A &lt;code&gt;reserved&lt;/code&gt; word is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">lexeme 구문 분석기 &lt;code&gt;reserved name&lt;/code&gt; &lt;code&gt;symbol name&lt;/code&gt; name을 구문 분석 하지만 &lt;code&gt;name&lt;/code&gt; 이 올바른 ID의 접 두부가 아닌지 확인합니다. &lt;code&gt;reserved&lt;/code&gt; 단어는 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12483176ac2649de2ec04abe4c197ebb522e5167" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reservedOp name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid operator. A &lt;code&gt;reservedOp&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">lexeme 구문 분석기 &lt;code&gt;reservedOp name&lt;/code&gt; 은 &lt;code&gt;symbol name&lt;/code&gt; name을 구문 분석 하지만 &lt;code&gt;name&lt;/code&gt; 이 올바른 연산자의 접 두부가 아닌지 도 확인합니다 . &lt;code&gt;reservedOp&lt;/code&gt; 를 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fe325967df8e680315725cbc04cfb4a0cda946a" translate="yes" xml:space="preserve">
          <source>The libraries listed in &lt;code&gt;extra-libraries&lt;/code&gt; may be any libraries supported by your system&amp;rsquo;s linker, including dynamic libraries (&lt;code&gt;.so&lt;/code&gt; on Unix, &lt;code&gt;.DLL&lt;/code&gt; on Windows).</source>
          <target state="translated">&lt;code&gt;extra-libraries&lt;/code&gt; 라이브러리에 나열된 라이브러리 는 동적 라이브러리 ( UNIX의 &lt;code&gt;.so&lt;/code&gt; , Windows의 &lt;code&gt;.DLL&lt;/code&gt; ) 를 포함하여 시스템의 링커에서 지원하는 모든 라이브러리 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="177074a86a1a2bfb7162db93da0c7658d94219a2" translate="yes" xml:space="preserve">
          <source>The lifetime of an event registration.</source>
          <target state="translated">이벤트 등록 기간.</target>
        </trans-unit>
        <trans-unit id="abc2a96639fca06ac1cbe729983e770d28dcf330" translate="yes" xml:space="preserve">
          <source>The limitations here are listed in Haskell Report order (roughly).</source>
          <target state="translated">여기의 제한 사항은 Haskell Report 순서대로 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="784ff4347be7881d2192a4f916753de82b4cba78" translate="yes" xml:space="preserve">
          <source>The linker standard library search can also be overridden on some systems using the &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; environment variable. Because of some implementation detail on Windows, setting &lt;code&gt;LIBRARY_PATH&lt;/code&gt; will also extend the system loader path for any library it finds. So often setting &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; is enough.</source>
          <target state="translated">링커 표준 라이브러리 검색은 &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; 환경 변수를 사용하여 일부 시스템에서 재정의 할 수도 있습니다 . Windows의 일부 구현 세부 사항으로 인해 &lt;code&gt;LIBRARY_PATH&lt;/code&gt; 를 설정 하면 찾은 라이브러리에 대한 시스템 로더 경로도 확장됩니다. 그래서 자주 &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; 를 설정하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="d2f24eb430e5f7113d1bb42457d3209f32c4782e" translate="yes" xml:space="preserve">
          <source>The linker standard library search can also be overriden on some systems using the &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; environment variable. Because of some implementation detail on Windows, setting &lt;code&gt;LIBRARY_PATH&lt;/code&gt; will also extend the system loader path for any library it finds. So often setting &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; is enough.</source>
          <target state="translated">&lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; 환경 변수를 사용하여 일부 시스템에서 링커 표준 라이브러리 검색을 대체 할 수도 있습니다 . Windows에 대한 구현 세부 사항으로 인해 &lt;code&gt;LIBRARY_PATH&lt;/code&gt; 를 설정 하면 찾은 라이브러리의 시스템 로더 경로도 확장됩니다. &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; 를 설정하는 것만으로도 충분합니다.</target>
        </trans-unit>
        <trans-unit id="35439bfe005709a8b0e917ffb02271e76a64cd30" translate="yes" xml:space="preserve">
          <source>The linker to use (default: &lt;code&gt;gcc&lt;/code&gt;).</source>
          <target state="translated">사용할 링커 (기본값 : &lt;code&gt;gcc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eeafbb95d04ce25f7a78da969fb894e2ec069b3e" translate="yes" xml:space="preserve">
          <source>The list is ordered by most recent call.</source>
          <target state="translated">이 목록은 가장 최근의 전화로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1f523c49a9fa8705bc3372a7af5bd59d5259f47e" translate="yes" xml:space="preserve">
          <source>The list must be finite.</source>
          <target state="translated">목록은 유한해야합니다.</target>
        </trans-unit>
        <trans-unit id="95bb9fda3d0750b05641de34c2d4bc742e5f26cc" translate="yes" xml:space="preserve">
          <source>The list of all possible separators.</source>
          <target state="translated">가능한 모든 구분 기호 목록입니다.</target>
        </trans-unit>
        <trans-unit id="140110a0fe6147ee6523b90cc08f34ea3d3d7870" translate="yes" xml:space="preserve">
          <source>The list of associations of an array in index order.</source>
          <target state="translated">인덱스 순서로 배열의 연관 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3ae1f93402e7c384b257cee551dcd23931311c1e" translate="yes" xml:space="preserve">
          <source>The list of breakpoints currently defined can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">현재 정의 된 중단 점 목록은 &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; 를&lt;/a&gt; 사용하여 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4db5b3fb0ce028bd2eb08c3da0fe9c3bade145e2" translate="yes" xml:space="preserve">
          <source>The list of breakpoints currently enabled can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">현재 활성화 된 중단 점 목록은 &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; 를&lt;/a&gt; 사용하여 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6840298fc1ff7b758a2385cba92227fe7cb9d802" translate="yes" xml:space="preserve">
          <source>The list of elements of an array in index order.</source>
          <target state="translated">인덱스의 배열 요소 목록입니다.</target>
        </trans-unit>
        <trans-unit id="920d0464cfa124351a5c124482bb76f7bb005ea6" translate="yes" xml:space="preserve">
          <source>The list of indices of an array in ascending order.</source>
          <target state="translated">오름차순으로 배열의 인덱스 목록.</target>
        </trans-unit>
        <trans-unit id="c272635afded4d839339a1be1f84abe89e36c500" translate="yes" xml:space="preserve">
          <source>The list of paths is split using &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt;, which on Windows is a semicolon.</source>
          <target state="translated">경로 목록은 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt; 를 사용하여 분할 되며 Windows에서는 세미콜론입니다.</target>
        </trans-unit>
        <trans-unit id="dc809c8f4a7b8427301c5f620413f00381ab3112" translate="yes" xml:space="preserve">
          <source>The list of possible &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt;s in the API documentation is not exhaustive. The full list may vary by platform and/or evolve over time.</source>
          <target state="translated">API 문서에서 가능한 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 목록은 완전한 것은 아닙니다. 전체 목록은 플랫폼에 따라 다를 수 있으며 시간이 지남에 따라 발전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f1b33fdad02db727e19018a482ecf607406289" translate="yes" xml:space="preserve">
          <source>The list of reserved identifiers.</source>
          <target state="translated">예약 된 식별자 목록입니다.</target>
        </trans-unit>
        <trans-unit id="91edba8a3a46eed84d044f0b039fdf7160f70fd8" translate="yes" xml:space="preserve">
          <source>The list of reserved operators.</source>
          <target state="translated">예약 된 연산자 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c39f3749d7b0f0a59a29e12553ad09d0740f4541" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is found by checking which bindings in scope would fit into the hole. As an example, compiling the following module with GHC:</source>
          <target state="translated">유효한 구멍 맞춤 목록은 범위에있는 바인딩 중 구멍에 맞는 바인딩을 확인하여 찾을 수 있습니다. 예를 들어, GHC로 다음 모듈을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="2438a0705dcb689373167d3061da6964ec71e04e" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;a href=&quot;#ghc-flag--fmax-valid-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt;&lt;/a&gt; displays all found hole fits.</source>
          <target state="translated">유효한 구멍 맞춤 목록은 구멍 당 최대 6 개의 구멍 맞춤을 표시하여 제한됩니다. 표시된 구멍 맞춤 수는이 플래그로 설정할 수 있습니다. &lt;a href=&quot;#ghc-flag--fmax-valid-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; 로&lt;/a&gt; 한계를 끄면 발견 된 모든 구멍 맞춤이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d5e76811a70379851fd0870f7be2601a8c80c1" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">유효한 구멍 맞춤 목록은 구멍 당 최대 6 개의 구멍 맞춤을 표시하여 제한됩니다. 표시된 구멍 맞춤 수는이 플래그로 설정할 수 있습니다. &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; 로 한계를 끄면 발견 된 모든 구멍 맞춤이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d8490f70aa9b2cb5e8e7f8af8e97ea93b083ee94" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is generated by considering hole fits with a varying amount of additional holes. The amount of holes in a refinement can be set by this flag. If the flag is set to 0 or not set at all, no valid refinement hole fits will be suggested.</source>
          <target state="translated">유효한 추가 구멍 맞춤 목록은 다양한 양의 추가 구멍이있는 구멍 맞춤을 고려하여 생성됩니다. 다듬기의 구멍 수는이 플래그로 설정할 수 있습니다. 플래그가 0으로 설정되거나 전혀 설정되지 않은 경우 유효한 미세 조정 구멍 맞춤이 제안되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca3a8b64a43dcccb6d83962220ef2222dedc1fab" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;a href=&quot;#ghc-flag--fmax-refinement-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt;&lt;/a&gt; displays all found hole fits.</source>
          <target state="translated">유효한 미세 조정 구멍 맞춤 목록은 구멍 당 최대 6 개의 구멍 맞춤을 표시하여 제한됩니다. 표시된 구멍 맞춤 수는이 플래그로 설정할 수 있습니다. &lt;a href=&quot;#ghc-flag--fmax-refinement-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; 로&lt;/a&gt; 제한을 끄면 발견 된 모든 구멍 맞춤이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9c3cb541a9f4b1ef3a2b89a4f5da3c5f2f0b80" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">유효한 정련 구멍 맞춤리스트는 구멍 당 최대 6 개의 구멍 맞춤을 표시하여 제한됩니다. 표시된 구멍 맞춤 수는이 플래그로 설정할 수 있습니다. &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; 로 한계를 끄면 발견 된 모든 구멍 맞춤이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b86a88a2e8b5e2bcc9593f30db6f5ffae5340c3d" translate="yes" xml:space="preserve">
          <source>The list of values in the subrange defined by a bounding pair.</source>
          <target state="translated">경계 쌍으로 정의 된 하위 범위의 값 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c06dff0a9cb5a38686c70f9512cbd43e5942e7dc" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;-123&lt;/code&gt; is, according to Haskell98 and Haskell 2010, desugared as &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. The language extension &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt; means that it is instead desugared as &lt;code&gt;fromInteger (-123)&lt;/code&gt;.</source>
          <target state="translated">Haskell98 및 Haskell 2010에 따르면 리터럴 &lt;code&gt;-123&lt;/code&gt; 은 &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; . 언어 확장 &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; &lt;/a&gt; 는 대신 &lt;code&gt;fromInteger (-123)&lt;/code&gt; 로 설탕이 제거됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="18bc094ffd74419a56c6c5c3bb60e715da5fa06d" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;-123&lt;/code&gt; is, according to Haskell98 and Haskell 2010, two tokens, a unary minus (&lt;code&gt;-&lt;/code&gt;) and the number 123, and is desugared as &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. The language extension &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt; causes it to be treated as a single token and desugared as &lt;code&gt;fromInteger (-123)&lt;/code&gt;.</source>
          <target state="translated">Haskell98 및 Haskell 2010에 따르면 리터럴 &lt;code&gt;-123&lt;/code&gt; 은 단항 마이너스 ( &lt;code&gt;-&lt;/code&gt; )와 숫자 123의 두 개의 토큰이며 &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; 됩니다. 언어 확장 &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; 를 사용&lt;/a&gt; 하면 단일 토큰으로 처리되고 &lt;code&gt;fromInteger (-123)&lt;/code&gt; 로 desugared 됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4c18eaf2be8a9b015eed5cef929f88b0717761" translate="yes" xml:space="preserve">
          <source>The local axioms from the instance context : &lt;code&gt;B a&lt;/code&gt;, &lt;code&gt;D a&lt;/code&gt; and &lt;code&gt;E a&lt;/code&gt;</source>
          <target state="translated">인스턴스 컨텍스트에서 로컬 공리 : &lt;code&gt;B a&lt;/code&gt; , &lt;code&gt;D a&lt;/code&gt; 및 &lt;code&gt;E a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47ffc1a6bb0aa38dfc306316588a7559300ef95b" translate="yes" xml:space="preserve">
          <source>The location at which this computation is spliced.</source>
          <target state="translated">이 계산이 연결되는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="f36139e3c6bbb05207907f6e241b4c98c08b0d8a" translate="yes" xml:space="preserve">
          <source>The log format is designed to be extensible: old tools should be able to parse (but not necessarily understand all of) new versions of the format, and new tools will be able to understand old log files.</source>
          <target state="translated">로그 형식은 확장 가능하도록 설계되었습니다. 이전 도구는 형식의 새 버전을 구문 분석 할 수 있어야하며 (반드시 모든 것을 이해할 필요는 없음) 새 도구는 이전 로그 파일을 이해할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="eeb6dd18dd0c7cd9fc57a8f2ff6c2bb37bc4af79" translate="yes" xml:space="preserve">
          <source>The lowercase versions (&lt;em&gt;syntax operators&lt;/em&gt;) of these constructors are preferred to these constructors, since they compose better with quotations (&lt;code&gt;[| |]&lt;/code&gt;) and splices (&lt;code&gt;$( ... )&lt;/code&gt;)</source>
          <target state="translated">이러한 생성자 의 소문자 버전 ( &lt;em&gt;구문 연산자&lt;/em&gt; )은 따옴표 ( &lt;code&gt;[| |]&lt;/code&gt; ) 및 스플 라이스 ( &lt;code&gt;$( ... )&lt;/code&gt; )로 더 잘 작성되므로 이러한 생성자보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="abe92315667ac8537af92643ee70ab06a908884e" translate="yes" xml:space="preserve">
          <source>The machine architecture on which the program is running.</source>
          <target state="translated">프로그램이 실행중인 머신 아키텍처</target>
        </trans-unit>
        <trans-unit id="456d5035c203f2f64b5829b1204338a9aa2f1fca" translate="yes" xml:space="preserve">
          <source>The machine architecture on which the program is running. Common values include:</source>
          <target state="translated">프로그램이 실행되는 시스템 아키텍처입니다. 일반적인 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32815c54d6aac2d0c3f3ab1768e3826958371ab4" translate="yes" xml:space="preserve">
          <source>The main advantages to using &lt;code&gt;ghc --make&lt;/code&gt; over traditional &lt;code&gt;Makefile&lt;/code&gt;s are:</source>
          <target state="translated">전통적인 &lt;code&gt;Makefile&lt;/code&gt; 보다 &lt;code&gt;ghc --make&lt;/code&gt; 를 사용하는 주요 이점 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f8b11338657365b7972c69ff46bf6811e5d4123" translate="yes" xml:space="preserve">
          <source>The main idea is to add a single new production to the syntax of patterns:</source>
          <target state="translated">주요 아이디어는 패턴 구문에 새로운 단일 프로덕션을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb265d0d99b20462c3bedd36be578770dd2b3955" translate="yes" xml:space="preserve">
          <source>The main library you need to use is the &lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stm library&lt;/a&gt;. The main features supported are these:</source>
          <target state="translated">사용해야하는 기본 라이브러리는 &lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stm 라이브러리&lt;/a&gt; 입니다. 지원되는 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="096db4a1cc7bc2e068d0698234e29539596642ef" translate="yes" xml:space="preserve">
          <source>The main library you need to use is the &lt;a href=&quot;https://hackage.haskell.org/package/stm&quot;&gt;stm library&lt;/a&gt;. The main features supported are these:</source>
          <target state="translated">사용해야하는 메인 라이브러리는 &lt;a href=&quot;https://hackage.haskell.org/package/stm&quot;&gt;stm 라이브러리&lt;/a&gt; 입니다. 지원되는 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e1d49c28d217785350db1f824835b79bff3fc25" translate="yes" xml:space="preserve">
          <source>The main reason for using phase control on specialisations is so that you can write optimisation RULES that fire early in the compilation pipeline, and only &lt;em&gt;then&lt;/em&gt; specialise the calls to the function. If specialisation is done too early, the optimisation rules might fail to fire.</source>
          <target state="translated">전문에 위상 제어를 사용하는 주된 이유는 그래서 당신은 최적화를 쓸 수 있다는 점이다 초기에 컴파일 파이프 라인의 화재를 규칙 만 &lt;em&gt;다음&lt;/em&gt; 함수의 호출을 전문. 전문화가 너무 일찍 수행되면 최적화 규칙이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd99fbab8c2a96e5d1994f5a584841ebedd4fc5c" translate="yes" xml:space="preserve">
          <source>The main requirement here is that the runtime needs to be initialized before any Haskell code can be called, so your library should provide initialisation and deinitialisation entry points, implemented in C or C++. For example:</source>
          <target state="translated">여기서 주요 요구 사항은 Haskell 코드를 호출하기 전에 런타임을 초기화해야하므로 라이브러리는 C 또는 C ++로 구현 된 초기화 및 초기화 해제 진입 점을 제공해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a36b3b528156f09407c2aa49bd251573cb91ec76" translate="yes" xml:space="preserve">
          <source>The main thread principle also applies to calls to Haskell from outside, using &lt;code&gt;foreign export&lt;/code&gt;. When the &lt;code&gt;foreign export&lt;/code&gt;ed function is invoked, it starts a new main thread, and it returns when this main thread terminates. If the call causes new threads to be forked, they may remain in the system after the &lt;code&gt;foreign export&lt;/code&gt;ed function has returned.</source>
          <target state="translated">주요 스레드 원칙은 &lt;code&gt;foreign export&lt;/code&gt; 사용하여 외부에서 Haskell에 대한 호출에도 적용됩니다 . 때 &lt;code&gt;foreign export&lt;/code&gt; 에드 함수가 호출되고, 그것은 새로운 메인 쓰레드를 시작하고,이 때이 메인 스레드의 종료를 반환합니다. 호출로 인해 새 스레드가 분기되면 &lt;code&gt;foreign export&lt;/code&gt; 기능이 리턴 된 후에도 시스템에 남아있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8aa707c2a5513daf094974e7984d291b1194cb2" translate="yes" xml:space="preserve">
          <source>The maintainers are glad to accept patches for further standard encodings of standard Haskell values.</source>
          <target state="translated">관리자는 표준 Haskell 값의 추가 표준 인코딩을위한 패치를 수용하게되어 기쁩니다.</target>
        </trans-unit>
        <trans-unit id="744ef2d7aabc6bab260fc29bb9d92f2367435b58" translate="yes" xml:space="preserve">
          <source>The major effect of an &lt;code&gt;INLINE&lt;/code&gt; pragma is to declare a function&amp;rsquo;s &amp;ldquo;cost&amp;rdquo; to be very low. The normal unfolding machinery will then be very keen to inline it. However, an &lt;code&gt;INLINE&lt;/code&gt; pragma for a function &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; has a number of other effects:</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 프라 그마 의 주요 효과는 함수의 &quot;비용&quot;을 매우 낮게 선언하는 것입니다. 그러면 일반적인 전개 기계는이를 인라인하는 데 매우 열심입니다. 그러나 함수 &quot; &lt;code&gt;f&lt;/code&gt; &quot;에 대한 &lt;code&gt;INLINE&lt;/code&gt; pragma 에는 여러 가지 다른 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1159d0b17e1c60d7b892bb9301ccde55977e5feb" translate="yes" xml:space="preserve">
          <source>The manifest file that GHC generates when linking a binary on Windows is also embedded in the executable itself, by default. This means that the binary can be distributed without having to supply the manifest file too. The embedding is done by running &lt;strong&gt;windres&lt;/strong&gt;; to see exactly what GHC does to embed the manifest, use the &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; flag. A GHC installation comes with its own copy of &lt;code&gt;windres&lt;/code&gt; for this reason.</source>
          <target state="translated">Windows에서 바이너리를 연결할 때 GHC가 생성하는 매니페스트 파일도 기본적으로 실행 파일 자체에 포함됩니다. 이는 매니페스트 파일도 제공하지 않고도 바이너리를 배포 할 수 있음을 의미합니다. 임베드는 &lt;strong&gt;windres&lt;/strong&gt; 를 실행하여 수행됩니다 . GHC가 매니페스트를 포함시키기 위해 수행하는 작업을 정확히 보려면 &lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오 . 이러한 이유로 GHC 설치에는 자체 &lt;code&gt;windres&lt;/code&gt; 사본이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3378e6fba41b187d6615b43817c87aba7dfb73d6" translate="yes" xml:space="preserve">
          <source>The marshalling converts each Haskell character, representing a Unicode code point, to one or more bytes in a manner that, by default, is determined by the current locale. As a consequence, no guarantees can be made about the relative length of a Haskell string and its corresponding C string, and therefore all the marshalling routines include memory allocation. The translation between Unicode and the encoding of the current locale may be lossy.</source>
          <target state="translated">마샬링은 기본적으로 현재 로케일에 의해 결정되는 방식으로 유니 코드 코드 포인트를 나타내는 각 Haskell 문자를 하나 이상의 바이트로 변환합니다. 결과적으로 Haskell 문자열과 해당 C 문자열의 상대 길이에 대해 보장 할 수 없으므로 모든 마샬링 루틴에는 메모리 할당이 포함됩니다. 유니 코드와 현재 로캘의 인코딩 간 변환이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3ddf92b0204346524d60c5ce7d32e072cd0d54" translate="yes" xml:space="preserve">
          <source>The matching behaviour is also influenced by two module-level language extension flags: &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;. These extensions are now deprecated (since GHC 7.10) in favour of the fine-grained per-instance pragmas.</source>
          <target state="translated">일치 동작은 &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; 의&lt;/a&gt; 두 모듈 수준 언어 확장 플래그의 영향을받습니다 . 세분화 된 인스턴스 별 프 래그 마를 위해 이러한 확장은 더 이상 사용되지 않습니다 (GHC 7.10부터).</target>
        </trans-unit>
        <trans-unit id="e2ff7a2e018dbc48e22ad18efcef13edd8c486f6" translate="yes" xml:space="preserve">
          <source>The matrix of platforms that:</source>
          <target state="translated">다음과 같은 플랫폼의 매트릭스</target>
        </trans-unit>
        <trans-unit id="07015c741417849721502853df57df8b2fae7145" translate="yes" xml:space="preserve">
          <source>The maximal prefix of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; that could be decoded from the given input.</source>
          <target state="translated">주어진 입력에서 디코딩 할 수있는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 최대 접두사입니다 .</target>
        </trans-unit>
        <trans-unit id="aa2a714293d353e1ff3212bd761cfba481644c07" translate="yes" xml:space="preserve">
          <source>The maximal size of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that is copied. &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; to guarantee that on average a chunk is of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">복사 되는 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 최대 크기입니다 . &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 는 평균 청크가 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 임을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="4d1640b5c03c6ca6aaac14f9e05c39afaa8e1c64" translate="yes" xml:space="preserve">
          <source>The maximum heap size also affects other garbage collection parameters: when the amount of live data in the heap exceeds a certain fraction of the maximum heap size, compacting collection will be automatically enabled for the oldest generation, and the &lt;code&gt;-F&lt;/code&gt; parameter will be reduced in order to avoid exceeding the maximum heap size.</source>
          <target state="translated">최대 힙 크기는 다른 가비지 콜렉션 매개 변수에도 영향을줍니다. 힙의 라이브 데이터 양이 최대 힙 크기의 특정 비율을 초과하면 압축 콜렉션이 가장 오래된 세대에 대해 자동으로 사용되며 &lt;code&gt;-F&lt;/code&gt; 매개 변수가 줄어 듭니다. 최대 힙 크기를 초과하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="7deac0bbef1cce9de070bc6eff250887dc27e012" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">히스토리에 저장된 최대 라인 수입니다. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 역사 스토리지는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="926742977d518fd000b685af89eeb0e0f46e5036" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">히스토리에 저장된 최대 라인 수입니다. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 역사 스토리지는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6484f192f4ed6e365a46616f6b99809373ead45e" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">히스토리에 저장된 최대 라인 수입니다. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 역사 스토리지는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d734e50598efc9c9203e0509468ba84ba10e6429" translate="yes" xml:space="preserve">
          <source>The maximum number of of colors on the screen.</source>
          <target state="translated">화면의 최대 색상 수입니다.</target>
        </trans-unit>
        <trans-unit id="b7d459650a2ba9b1231e79e180aceb1bd015d81c" translate="yes" xml:space="preserve">
          <source>The maximum space actually used by your program is the &amp;ldquo;bytes maximum residency&amp;rdquo; figure. This is only checked during major garbage collections, so it is only an approximation; the number of samples tells you how many times it is checked.</source>
          <target state="translated">프로그램에서 실제로 사용하는 최대 공간은&amp;ldquo;바이트 최대 상주&amp;rdquo;숫자입니다. 이것은 주요 가비지 수집 중에 만 확인되므로 근사치 일뿐입니다. 샘플 수는 확인 횟수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16877d3133192b7596dd9edb65bc59d15909dfa6" translate="yes" xml:space="preserve">
          <source>The maximum time elapsed during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="translated">이동하지 않는 동시 GC의 소인 일시 중지 단계 동안 경과 된 최대 시간입니다.</target>
        </trans-unit>
        <trans-unit id="8b43db138dc3a233b97e08a96f2e5508bd7bc2ca" translate="yes" xml:space="preserve">
          <source>The maximum tuple size</source>
          <target state="translated">최대 튜플 크기</target>
        </trans-unit>
        <trans-unit id="3c1ae6c029d2317f8ba5fb3110e02abfdbf30bfa" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. (See &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS options for heap profiling&lt;/a&gt; for details.)</source>
          <target state="translated">단축 된 &lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; 의 의미는 프로그램이 프로파일 링을 위해 컴파일되었는지 여부에 따라 다릅니다. 자세한 내용 &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;은 힙 프로파일 링에&lt;/a&gt; 대한 RTS 옵션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d87c8b0eb65b8cb788e02129482e2e2b711668c6" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. When compiled for profiling, &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;#rts-flag--hc&quot;&gt;&lt;code&gt;-hc&lt;/code&gt;&lt;/a&gt;, but otherwise is equivalent to &lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">단축 된 &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; 의 의미는 프로그램이 프로파일 링을 위해 컴파일되었는지 여부에 따라 다릅니다. 프로파일 링을 위해 컴파일 될 때 &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#rts-flag--hc&quot;&gt; &lt;code&gt;-hc&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 그렇지 않으면 &lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;프로파일 링에 대한 RTS 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2c90c10f5a199858ea71a07e1f9c65a1b0281964" translate="yes" xml:space="preserve">
          <source>The mechanism is simple: whenever the program evaluates an expression with an SCC annotation, &lt;code&gt;{-# SCC c -#} E&lt;/code&gt;, the cost centre &lt;code&gt;c&lt;/code&gt; is pushed on the current stack, and the entry count for this stack is incremented by one. The stack also sometimes has to be saved and restored; in particular when the program creates a thunk (a lazy suspension), the current cost-centre stack is stored in the thunk, and restored when the thunk is evaluated. In this way, the cost-centre stack is independent of the actual evaluation order used by GHC at runtime.</source>
          <target state="translated">매커니즘은 간단합니다. 프로그램이 SCC 주석 &lt;code&gt;{-# SCC c -#} E&lt;/code&gt; 로 표현식을 평가할 때마다 코스트 센터 &lt;code&gt;c&lt;/code&gt; 가 현재 스택에서 푸시되고이 스택의 엔트리 수가 1 씩 증가합니다. 스택은 때때로 저장 및 복원되어야합니다. 특히 프로그램이 썽크 (게으른 서스펜션)를 생성하면 현재 비용 센터 스택이 썽크에 저장되고 썽크가 평가 될 때 복원됩니다. 이러한 방식으로 비용 센터 스택은 런타임시 GHC가 사용하는 실제 평가 순서와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="f7c0a3feb5345a104be8d4a49924286ed63663fa" translate="yes" xml:space="preserve">
          <source>The member functions of this class facilitate writing values of primitive types to raw memory (which may have been allocated with the above mentioned routines) and reading values from blocks of raw memory. The class, furthermore, includes support for computing the storage requirements and alignment restrictions of storable types.</source>
          <target state="translated">이 클래스의 멤버 함수는 원시 유형의 값을 원시 메모리 (위에 언급 된 루틴으로 할당되었을 수 있음)에 쓰고 원시 메모리 블록에서 값을 읽는 것을 용이하게합니다. 또한이 클래스에는 저장 요구 사항 및 저장 가능한 유형의 정렬 제한을 계산하기위한 지원이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cba31954fa26087a15e99fd14a2e8df87f705a4d" translate="yes" xml:space="preserve">
          <source>The members &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class map all values of &lt;code&gt;CT&lt;/code&gt; to the corresponding value of &lt;code&gt;t&lt;/code&gt; and vice versa.</source>
          <target state="translated">회원은 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 모든 값에 매핑 클래스 &lt;code&gt;CT&lt;/code&gt; 을 의 대응하는 값을 &lt;code&gt;t&lt;/code&gt; 반대로.</target>
        </trans-unit>
        <trans-unit id="723dfa6d14019cdcb7ea8b493daa172324f5d5cf" translate="yes" xml:space="preserve">
          <source>The memory is freed when &lt;code&gt;f&lt;/code&gt; terminates (either normally or via an exception), so the pointer passed to &lt;code&gt;f&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be used after this.</source>
          <target state="translated">경우 메모리가 해제된다 &lt;code&gt;f&lt;/code&gt; 종료는 (일반적으로 하나 또는 예외를 통해)에 전달하므로 포인터 &lt;code&gt;f&lt;/code&gt; 는 해야 &lt;em&gt;하지&lt;/em&gt; 이 후에 사용된다.</target>
        </trans-unit>
        <trans-unit id="30cdd2b8067e97ef326db4b7a7649ae2a1d70b50" translate="yes" xml:space="preserve">
          <source>The memory management overhead. Currently this is tuned for GHC only.</source>
          <target state="translated">메모리 관리 오버 헤드 현재 이것은 GHC에만 맞게 조정되었습니다.</target>
        </trans-unit>
        <trans-unit id="296145d71ce1908abeb930aa215c007de95d6dac" translate="yes" xml:space="preserve">
          <source>The memory may be deallocated using &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">더 이상 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; 를 사용하여 메모리 할당을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7786c976f2ff7540d0a6e4b59833c22c599315f" translate="yes" xml:space="preserve">
          <source>The memory may freed at any point after the subcomputation terminates, so the pointer to the storage must *not* be used after this.</source>
          <target state="translated">하위 계산이 종료 된 후 어느 시점에서나 메모리가 해제 될 수 있으므로이 후에는 저장소에 대한 포인터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="51295ee3cd81001e8a30ec8543497b0e8c877217" translate="yes" xml:space="preserve">
          <source>The merit of this is that you can derive instances for GADTs and other exotic data types, providing only that the boilerplate code does indeed typecheck. For example:</source>
          <target state="translated">이것의 장점은 상용구 코드가 실제로 유형 검사를 제공하는 경우에만 GADT 및 기타 이국적인 데이터 유형에 대한 인스턴스를 파생시킬 수 있다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="706d394f30bc5168ee0ad023e79bd99ae56018eb" translate="yes" xml:space="preserve">
          <source>The message</source>
          <target state="translated">메시지</target>
        </trans-unit>
        <trans-unit id="09ce093d9b8936752c951269f1ca598cad553080" translate="yes" xml:space="preserve">
          <source>The message printed if &lt;code&gt;malloc&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; 이 실패하면 메시지가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c55c4a564eeb697e2553fd6d32d12eec12c5af2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 메소드 는 프로그래머가 값 목록을 구문 분석하는 특수한 방법을 제공 할 수 있도록 제공됩니다. 예를 들어, 이것은 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 의 사전 정의 된 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스에 의해 사용되며 , 여기서 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값은 대괄호 대신 큰 따옴표를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bb9dae247f1417713fe2e3ff89e568a58dd2064" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 메소드 는 프로그래머가 값 목록을 표시하는 특수한 방법을 제공 할 수 있도록 제공됩니다. 예를 들어, 이것은 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 의 사전 정의 된 &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스에서 사용됩니다. 여기서 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값은 대괄호가 아닌 큰 따옴표로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b206e34c8564a26770cfb63266e92dafdef2f00" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 메소드 는 프로그래머가 값 목록을 구문 분석하는 특수한 방법을 제공 할 수 있도록 제공됩니다. 예를 들어, 이것은 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 의 사전 정의 된 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스에 의해 사용되며 , 여기서 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값은 대괄호 대신 큰 따옴표를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b9ba8a954c2ae61c20aa36e469332d7313c7d48" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 메소드 는 프로그래머가 값 목록을 표시하는 특수한 방법을 제공 할 수 있도록 제공됩니다. 예를 들어, 이것은 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 의 사전 정의 된 &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스에서 사용됩니다. 여기서 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값은 대괄호가 아닌 큰 따옴표로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="332ed4acf796a389b61681f06e5d3b89101d146a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 메소드 는 프로그래머가 값 목록을 구문 분석하는 특수한 방법을 제공 할 수 있도록 제공됩니다. 예를 들어, 이것은 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 의 사전 정의 된 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스에 의해 사용되며 , 여기서 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값은 대괄호 대신 큰 따옴표를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e8a0b574789d1de5cf8d746837c55989fd9ec8f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 메소드 는 프로그래머가 값 목록을 표시하는 특수한 방법을 제공 할 수 있도록 제공됩니다. 예를 들어, 이것은 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 유형 의 사전 정의 된 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스에서 사용됩니다. 여기서 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값은 대괄호가 아닌 큰 따옴표로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a55e07264dbb157af3468bbfef9f673d9ed1c760" translate="yes" xml:space="preserve">
          <source>The method names refer to the monoid of lists under concatenation, but there are many other instances.</source>
          <target state="translated">메소드 이름은 연결되어있는 목록의 단일 ID를 참조하지만 다른 많은 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af30b26f773faca8a1c0563232c5aeb832b3fec" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">&lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; 모듈 은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="14f5aff046cf43c34ac7e373b3ac53e710239001" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; 모듈 은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5f6effa84fa526911a5bc26f168d26945f6ee5ab" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; 모듈 은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6fe9f2287d708875ff918672eee840079c919130" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt; provides operations to allocate and deallocate blocks of raw memory (i.e., unstructured chunks of memory outside of the area maintained by the Haskell storage manager). These memory blocks are commonly used to pass compound data structures to foreign functions or to provide space in which compound result values are obtained from foreign functions.</source>
          <target state="translated">&lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt; 모듈 은 원시 메모리 블록 (예 : Haskell 스토리지 관리자가 관리하는 영역 외부의 구조화되지 않은 메모리 청크)을 할당 및 할당 해제하는 작업을 제공합니다. 이 메모리 블록은 일반적으로 복합 데이터 구조를 외부 함수로 전달하거나 외부 결과에서 복합 결과 값을 얻을 수있는 공간을 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0aaac35805022709131420c56844a405405859b9" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy (except for &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt;):</source>
          <target state="translated">모듈 &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe의&lt;/a&gt; 재 보냅니다 내의 다른 모듈 &lt;code&gt;Foreign.Marshal&lt;/code&gt; (제외한 계층 &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b1df10bb69bf2b89bf3830cfbd382b7d65aa4ba2" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy:</source>
          <target state="translated">모듈 &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe의&lt;/a&gt; 에서 재 - 수출 다른 모듈을 &lt;code&gt;Foreign.Marshal&lt;/code&gt; 계층 구조 :</target>
        </trans-unit>
        <trans-unit id="28a8a8e9077c7af6ee0166e9bad843be62034b8c" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt; provides most elementary support for marshalling and is part of the language-independent portion of the Foreign Function Interface (FFI), and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt; 모듈 은 마샬링에 대한 대부분의 기본 지원을 제공하며 FFI (Foreign Function Interface)의 언어 독립적 부분의 일부이며 일반적으로 &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; 모듈을 통해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="069e815b76b5c1d72c5235cae4cd411f8d4fdcf6" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;A&lt;/code&gt; below is annotated to be explicitly &lt;code&gt;Safe&lt;/code&gt;, but it imports &lt;code&gt;Safe-Inferred&lt;/code&gt; module.</source>
          <target state="translated">아래 모듈 &lt;code&gt;A&lt;/code&gt; 는 명시 적으로 &lt;code&gt;Safe&lt;/code&gt; 로 주석 처리 되었지만 &lt;code&gt;Safe-Inferred&lt;/code&gt; 모듈을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c4efc02d68c3af490556f0b55e2f290168abc177" translate="yes" xml:space="preserve">
          <source>The module &lt;code&gt;A&lt;/code&gt; below is annotated to be explictly &lt;code&gt;Safe&lt;/code&gt;, but it imports &lt;code&gt;Safe-Inferred&lt;/code&gt; module.</source>
          <target state="translated">아래 의 모듈 &lt;code&gt;A&lt;/code&gt; 는 명시 적으로 &lt;code&gt;Safe&lt;/code&gt; 로 주석이 달렸 지만 &lt;code&gt;Safe-Inferred&lt;/code&gt; 모듈을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7b7c64247943d5ed0c07fe913e3a4cc1b0d102fc" translate="yes" xml:space="preserve">
          <source>The module header (including the export list), and import statements, are exactly as in Haskell, and so are the scoping rules. Hence, to mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">모듈 헤더 (내보내기 목록 포함) 및 import 문은 Haskell에서와 동일하며 범위 지정 규칙도 마찬가지입니다. 따라서 비 Prelude 유형 또는 클래스를 언급하려면 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="b241106611a1f8529d586a81dae31e263788b6e8" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">모듈은 &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 를 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="4ce45cb81b574e7a52ecde45d4ee5f41764d49db" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">모듈은 &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 를 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="d0567f67de5a3f399a53df0817cedcf626bf1864" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">모듈은 &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 를 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="271abdd5800add2d2a429d3960db113d446e207f" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 로 컴파일되었습니다</target>
        </trans-unit>
        <trans-unit id="61f9fc1e39c23939a82e428406225578b440fb61" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 것으로 컴파일되었습니다</target>
        </trans-unit>
        <trans-unit id="8638db98256357d4532755afc9c9f9aac9ff4038" translate="yes" xml:space="preserve">
          <source>The monad and its operations</source>
          <target state="translated">모나드와 그 작동</target>
        </trans-unit>
        <trans-unit id="da5e8905606683d3d0ad467ab40cd56a8717786c" translate="yes" xml:space="preserve">
          <source>The monoid of endomorphisms under composition.</source>
          <target state="translated">구성 하의 이질 체의 단일체.</target>
        </trans-unit>
        <trans-unit id="c2ab47bb2be3d494730b67150aa964b55fa528d5" translate="yes" xml:space="preserve">
          <source>The more general methods of the &lt;code&gt;Foldable&lt;/code&gt; class are now exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; in place of the original List-specific methods (see the &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;FTP Proposal&lt;/a&gt;). The List-specific variants are for now still available in &lt;a href=&quot;ghc-oldlist&quot;&gt;GHC.OldList&lt;/a&gt;, but that module is intended only as a transitional aid, and may be removed in the future.</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 클래스 의보다 일반적인 메서드 는 이제 원본 목록 관련 메서드 대신 &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; 에서 내 보냅니다 ( &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;FTP 제안&lt;/a&gt; 참조 ). List 특정 변형은 현재 &lt;a href=&quot;ghc-oldlist&quot;&gt;GHC.OldList&lt;/a&gt; 에서 계속 사용할 수 있지만 해당 모듈은 전환 지원용으로 만 사용되며 향후 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9ccf96ea16ca69c701719763f3afb8aa9f150cf" translate="yes" xml:space="preserve">
          <source>The most common usage of &lt;code&gt;COMPLETE&lt;/code&gt; pragmas is with &lt;a href=&quot;#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; pragma 의 가장 일반적인 사용법은 &lt;a href=&quot;#pattern-synonyms&quot;&gt;Pattern 동의어&lt;/a&gt; 입니다. 검사기는 자체적으로 매우 순진하며 패턴 동의어와 관련된 모든 일치가 실패한다고 가정합니다. 결과적으로, 패턴 동의어에서 패턴 일치는 사용자가 모든 경우를 추가하지 않는 한 불완전한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="eb063647bc6db1e24a43f0bce938f6f5a0b0b3af" translate="yes" xml:space="preserve">
          <source>The most common usage of &lt;code&gt;COMPLETE&lt;/code&gt; pragmas is with &lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; pragma 의 가장 일반적인 사용법은 &lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;Pattern 동의어&lt;/a&gt; 입니다. 그 자체로 검사기는 매우 순진하고 패턴 동의어와 관련된 모든 일치가 실패 할 것이라고 가정합니다. 결과적으로 패턴 동의어에 대한 패턴 일치는 사용자가 포괄 대소 문자를 추가하지 않는 한 불완전한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="063a9618d36844f08d6ef94989127397ea9b9b40" translate="yes" xml:space="preserve">
          <source>The most common way this can happen is when you&amp;rsquo;re evaluating a CAF (e.g. main), stop at a breakpoint, and ask for the value of the CAF at the prompt again.</source>
          <target state="translated">이 문제가 발생할 수있는 가장 일반적인 방법은 CAF (예 : 주)를 평가하고 중단 점에서 중지 한 후 프롬프트에서 CAF 값을 다시 요청하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="75340b8409f86aba60aed6656112aab745923bcd" translate="yes" xml:space="preserve">
          <source>The most commonly used ISO 8601 format for this type.</source>
          <target state="translated">이 유형에 가장 일반적으로 사용되는 ISO 8601 형식입니다.</target>
        </trans-unit>
        <trans-unit id="bfe39e2ecd43cfd563f91e4eca3de1502694fa6f" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identity 모나드에 대해 파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParser p state filePath input&lt;/code&gt; 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 가져온 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ) 유형 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="543b04448bf8e6b461926178ee2dbfc4a06a930b" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identity 모나드에서 파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParser p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. 반환 값 중 하나 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 형의 값 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45b72e1df1e1bcb0854a46ac8226b77dd0861833" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identity 모나드에서 파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParser p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. 반환 값 중 하나 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 형의 값 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aeb3d7e2ffb679903cf3a78fe1e8a43f4f5df8ed" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identity 모나드에 대해 파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParser p state filePath input&lt;/code&gt; 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 가져온 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ) 유형 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c81f5972096e036f48bc7e8b9d08264ff1cf03cf" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identity 모나드에서 파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParser p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. 반환 값 중 하나 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 형의 값 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ccf82f20c0a6feb5929cc6f355f3375cfd32c776" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Identity 모나드에서 파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParser p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. 반환 값 중 하나 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 형의 값 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c5053914782286bf569d388ab06bfb0dd58462e" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 가져온 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. 반환 기본 모나드에서 계산 &lt;code&gt;m&lt;/code&gt; 돌려 중 하나 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 입력 값 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9e6c38470342e612c5ecfc863c68e581e87f551" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 유형 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ) 값 을 반환 하는 기본 모나드 &lt;code&gt;m&lt;/code&gt; 에서 계산 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c397272bb6d972615e869fd516bb17c5abd646cb" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 유형 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ) 값 을 반환 하는 기본 모나드 &lt;code&gt;m&lt;/code&gt; 의 계산 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0c6a5560b83d86896cc9662f87720adba5507322" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 가져온 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. 반환 기본 모나드에서 계산 &lt;code&gt;m&lt;/code&gt; 돌려 중 하나 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 입력 값 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5191e620570ba9224bf45cd4aebb8c9b695aafc1" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 유형 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ) 값 을 반환 하는 기본 모나드 &lt;code&gt;m&lt;/code&gt; 에서 계산 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8a95d978f355454055f2efb85e48463043b88695" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파서를 실행하는 가장 일반적인 방법입니다. &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 은 초기 사용자 상태가 &lt;code&gt;st&lt;/code&gt; 인 소스 &lt;code&gt;filePath&lt;/code&gt; 에서 얻은 토큰 &lt;code&gt;input&lt;/code&gt; 의 입력 목록에서 구문 분석기 &lt;code&gt;p&lt;/code&gt; 를 실행 합니다. &lt;code&gt;filePath&lt;/code&gt; 오류 메시지 만 사용되며 빈 문자열 일 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ) 또는 유형 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ) 값 을 반환 하는 기본 모나드 &lt;code&gt;m&lt;/code&gt; 의 계산 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5be00a95c813a0dae9db110b897e76b924717d2" translate="yes" xml:space="preserve">
          <source>The motivation for the change is that it means &lt;code&gt;IO a&lt;/code&gt; actions default to &lt;code&gt;IO ()&lt;/code&gt;, which in turn means that ghci won&amp;rsquo;t try to print a result when running them. This is particularly important for &lt;code&gt;printf&lt;/code&gt;, which has an instance that returns &lt;code&gt;IO a&lt;/code&gt;. However, it is only able to return &lt;code&gt;undefined&lt;/code&gt; (the reason for the instance having this type is so that printf doesn&amp;rsquo;t require extensions to the class system), so if the type defaults to &lt;code&gt;Integer&lt;/code&gt; then ghci gives an error when running a printf.</source>
          <target state="translated">변경의 동기는 &lt;code&gt;IO a&lt;/code&gt; 기본 조치 인 &lt;code&gt;IO ()&lt;/code&gt; 를 의미하며, 이는 ghci가 결과를 실행할 때 결과를 인쇄하지 않음을 의미합니다. 이것은 &lt;code&gt;IO a&lt;/code&gt; 를 반환하는 인스턴스가있는 &lt;code&gt;printf&lt;/code&gt; 에 특히 중요 합니다 . 그러나 그것은 단지 반환 할 수있을 때 &lt;code&gt;undefined&lt;/code&gt; 에 유형 기본값 그렇다면, (이 유형을 갖는 인스턴스에 대한 이유는 그래서 printf와 클래스 시스템의 확장을 필요로하지 않는다는 것입니다) &lt;code&gt;Integer&lt;/code&gt; printf와 실행시 다음 ghci 오류를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="959ea0490110e05809c000a4c38196ada4c3c8cf" translate="yes" xml:space="preserve">
          <source>The mtl style typeclass</source>
          <target state="translated">mtl 스타일 유형 클래스</target>
        </trans-unit>
        <trans-unit id="ab27351eba8cd3ca070ac277f24750ccae0305c2" translate="yes" xml:space="preserve">
          <source>The multiplicity-polymorphic arrow &lt;code&gt;a %m -&amp;gt; b&lt;/code&gt; is available in a prefix version as &lt;code&gt;GHC.Exts.FUN m a b&lt;/code&gt;, which can be applied partially. See, however &lt;a href=&quot;#linear-types-limitations&quot;&gt;Limitations&lt;/a&gt;.</source>
          <target state="translated">다중 다형성 화살표 &lt;code&gt;a %m -&amp;gt; b&lt;/code&gt; 는 부분적으로 적용될 수있는 &lt;code&gt;GHC.Exts.FUN m a b&lt;/code&gt; 로 접두사 버전에서 사용할 수 있습니다. 그러나 &lt;a href=&quot;#linear-types-limitations&quot;&gt;제한 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c736836da3c61a5b28a8e40cd26c58ac3671ca42" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 라는 이름 은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 와의 관계를 설명하는 데 사용됩니다 . 여기서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 는 인수의 최상위 수준 만 평가한다는 점에서 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 는 전체 데이터 구조를 완전히 평가합니다.</target>
        </trans-unit>
        <trans-unit id="c8c9046bcf066fa425b4dcc4d07e5da4b61485a0" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">이름 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 와의 관계를 설명하는 데 사용됩니다 . 여기서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 는 인수의 최상위 수준 만 평가한다는 의미에서 얕고, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 는 전체 데이터 구조를 완전히 평가하여 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="68b62c4abd0c0e9bf64c7cd8de3bb498a58caa13" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">이름 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 와의 관계를 설명하는 데 사용됩니다 . 여기서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 는 인수의 최상위 수준 만 평가한다는 점에서 얕고, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 는 전체 데이터 구조를 완전히 평가하여 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="ecfeb2264bf3f2219dcf11640cc5f23d975957a1" translate="yes" xml:space="preserve">
          <source>The name of an executable with a list of arguments</source>
          <target state="translated">인수 목록이있는 실행 파일 이름</target>
        </trans-unit>
        <trans-unit id="e05e238891a0e5d7a1ad5addb5acbfa1d828b57f" translate="yes" xml:space="preserve">
          <source>The name of the constructor</source>
          <target state="translated">생성자의 이름</target>
        </trans-unit>
        <trans-unit id="2372d4365121c955cf759525401a9a51abda2da3" translate="yes" xml:space="preserve">
          <source>The name of the datatype (unqualified)</source>
          <target state="translated">데이터 타입의 이름</target>
        </trans-unit>
        <trans-unit id="4ad137cef439e5cbd9d31d951cbeeb39fa772cfe" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library on Windows systems (optional).</source>
          <target state="translated">Windows 시스템의 동적 라이브러리 이름 (선택 사항).</target>
        </trans-unit>
        <trans-unit id="a75d937e0b98713b032f66a0d3ddc12a66577a2c" translate="yes" xml:space="preserve">
          <source>The name of the interface file is derived using the same rules, except that the suffix is ⟨hisuf⟩ (&lt;code&gt;.hi&lt;/code&gt; by default) instead of ⟨osuf⟩, and the relevant options are &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">인터페이스 파일의 이름이 동일한 규칙을 사용하여 파생 접미사가 (⟨hisuf⟩ 것을 제외 &lt;code&gt;.hi&lt;/code&gt; 대신 ⟨osuf⟩의 기본값) 및 관련 옵션은 &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt; 대신 의 &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="81ece37146db578e5ad6a58ba4a56df41a18aad4" translate="yes" xml:space="preserve">
          <source>The name of the library on Unix and Windows (mingw) systems.</source>
          <target state="translated">Unix 및 Windows (mingw) 시스템의 라이브러리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6453686e83ae95972b7e17f3b926e084c57ab74f" translate="yes" xml:space="preserve">
          <source>The name of the library on Unix and Windows (mingw) systems. Note that we don&amp;rsquo;t support building dynamic libraries of Haskell code on Unix systems.</source>
          <target state="translated">Unix 및 Windows (mingw) 시스템의 라이브러리 이름 우리는 유닉스 시스템에서 Haskell 코드의 동적 라이브러리 구축을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0f5dc8321c09ce84049b074ac570bfbec19828a" translate="yes" xml:space="preserve">
          <source>The name of the object file generated by GHC is derived according to the following rules, where ⟨osuf⟩ is the object-file suffix (this can be changed with the &lt;code&gt;-osuf&lt;/code&gt; option).</source>
          <target state="translated">GHC가 생성 한 오브젝트 파일의 이름은 다음 규칙에 따라 파생됩니다. 여기서 ⟨osuf⟩는 오브젝트 파일 접미 부입니다 ( &lt;code&gt;-osuf&lt;/code&gt; 옵션 으로 변경할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="6861c4770b27354d7d4cfab408a9a6ca379e4807" translate="yes" xml:space="preserve">
          <source>The name of the pattern synonym is in the same namespace as proper data constructors. Like normal data constructors, pattern synonyms can be imported and exported through association with a type constructor or independently.</source>
          <target state="translated">패턴 동의어의 이름은 적절한 데이터 생성자와 동일한 네임 스페이스에 있습니다. 일반 데이터 생성자와 마찬가지로 패턴 동의어는 유형 생성자와의 연관을 통해 또는 독립적으로 가져오고 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be799bf296167235ebb2ca091eee552b142616f" translate="yes" xml:space="preserve">
          <source>The name of the program</source>
          <target state="translated">프로그램 이름</target>
        </trans-unit>
        <trans-unit id="39a42659e6043aff3532b0014c5b4fae37244931" translate="yes" xml:space="preserve">
          <source>The name of the selector</source>
          <target state="translated">선택기의 이름</target>
        </trans-unit>
        <trans-unit id="7c51ecee2db2e110dbf3d1d2d9420bc2a5044c61" translate="yes" xml:space="preserve">
          <source>The name of the zone, typically a three- or four-letter acronym.</source>
          <target state="translated">영역의 이름으로, 일반적으로 3 자 또는 4 자 약어입니다.</target>
        </trans-unit>
        <trans-unit id="4e49908da6a172e68a423a7eb23e95b552938d75" translate="yes" xml:space="preserve">
          <source>The name of this group (gr_name)</source>
          <target state="translated">이 그룹의 이름 (gr_name)</target>
        </trans-unit>
        <trans-unit id="fae25b47526c2bd90bbb6d0b312e7136e668661b" translate="yes" xml:space="preserve">
          <source>The name of this operator is an allusion to &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt;. Note the similarities between their types:</source>
          <target state="translated">이 연산자의 이름은 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 에 대한 암시 입니다. 유형 간의 유사점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="3bffd90620f4f0f826e5aaf337b1fe1334e782e4" translate="yes" xml:space="preserve">
          <source>The name without its module prefix.</source>
          <target state="translated">모듈 접두어가없는 이름</target>
        </trans-unit>
        <trans-unit id="646f96f37bb735ef8278fbc57b542fce8c940d51" translate="yes" xml:space="preserve">
          <source>The named wildcard forces the argument and result types to be the same. Lacking a signature, GHC would have inferred &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt;. A named wildcard can be mentioned in constraints, provided it also occurs in the monotype part of the type signature to make sure that it unifies with something:</source>
          <target state="translated">명명 된 와일드 카드는 인수와 결과 유형이 동일하도록합니다. 서명이 없었기 때문에 GHC는 모든 것을 유추했을 것 &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt; . 명명 된 와일드 카드는 형식 서명의 단일 유형 부분에서도 발생하여 다음과 통합되도록하기 위해 제약 조건에서 언급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb6c48a77c3ff916d6d31d64741779306bc02b7" translate="yes" xml:space="preserve">
          <source>The names in this module resemble those in the &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; family of modules, but are shorter due to the assumption of qualified naming.</source>
          <target state="translated">이 모듈의 이름은 &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 모듈 제품군의 이름과 유사 하지만 정규화 된 이름 지정으로 인해 더 짧습니다.</target>
        </trans-unit>
        <trans-unit id="2a298a889af18ee73428f1b23010db1d461094d5" translate="yes" xml:space="preserve">
          <source>The namespaces are:</source>
          <target state="translated">네임 스페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c41bfe70547efc280b4b232c6db8795351037886" translate="yes" xml:space="preserve">
          <source>The naming scheme may look a bit weird, but it has the purpose of allowing the co-existence of import libraries with ordinary static libraries (e.g., &lt;code&gt;libHSfoo.a&lt;/code&gt; and &lt;code&gt;libHSfoo.dll.a&lt;/code&gt;. Additionally, when the compiler driver is linking in non-static mode, it will rewrite occurrence of &lt;code&gt;-lHSfoo&lt;/code&gt; on the command line to &lt;code&gt;-lHSfoo.dll&lt;/code&gt;. By doing this for you, switching from non-static to static linking is simply a question of adding &lt;code&gt;-static&lt;/code&gt; to your command line.</source>
          <target state="translated">이름 지정 체계는 약간 이상하게 보일 수 있지만 일반 정적 라이브러리 (예 : &lt;code&gt;libHSfoo.a&lt;/code&gt; 및 &lt;code&gt;libHSfoo.dll.a&lt;/code&gt; ) 와 가져 오기 라이브러리의 공존을 허용 할 목적이 있습니다. 또한 컴파일러 드라이버가 -정적 모드 를 사용하면 명령 줄에서 &lt;code&gt;-lHSfoo.dll&lt;/code&gt; 의 발생을 &lt;code&gt;-lHSfoo&lt;/code&gt; .dll로 다시 씁니다 .이 작업을 수행하면 정적이 아닌 링크에서 정적 링크로 전환하는 것은 명령 줄에 &lt;code&gt;-static&lt;/code&gt; 을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="db2b10aabaace6cc9d2b20bf6478500589166faa" translate="yes" xml:space="preserve">
          <source>The native code-generator can either dump binary blobs (e.g. string literals) into the assembly file (by using &amp;ldquo;.asciz&amp;rdquo; or &amp;ldquo;.string&amp;rdquo; assembler directives) or it can dump them as binary data into a temporary file which is then included by the assembler (using the &amp;ldquo;.incbin&amp;rdquo; assembler directive).</source>
          <target state="translated">네이티브 코드 생성기는 이진 blob (예 : 문자열 리터럴)을 어셈블리 파일에 덤프하거나 ( &quot;.asciz&quot;또는 &quot;.string&quot;어셈블러 지시문을 사용하여) 이진 데이터로 임시 파일에 덤프 할 수 있습니다. 어셈블러에 의해 ( &quot;.incbin&quot;어셈블러 지시문 사용)</target>
        </trans-unit>
        <trans-unit id="2ee4fcb4be15b4c1be4d987c3b4b722af25c57c2" translate="yes" xml:space="preserve">
          <source>The native code-generator can either dump binary blobs (e.g. string literals) into the assembly file (by using &amp;rdquo;.asciz&amp;rdquo; or &amp;rdquo;.string&amp;rdquo; assembler directives) or it can dump them as binary data into a temporary file which is then included by the assembler (using the &amp;rdquo;.incbin&amp;rdquo; assembler directive).</source>
          <target state="translated">원시 코드 생성기는 이진 blob (예 : 문자열 리터럴)을 어셈블리 파일에 덤프하거나 ( &quot;.asciz&quot;또는 &quot;.string&quot;어셈블러 지시문을 사용하여) 이진 데이터로 임시 파일에 덤프 할 수 있습니다. 어셈블러에 의해 ( &quot;.incbin&quot;어셈블러 지시문 사용)</target>
        </trans-unit>
        <trans-unit id="a0044db577b12199ca68313af424ef55cbf96d30" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">현재 플랫폼의 기본 줄 바꿈 표현 : Unix 시스템의 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; , Windows의 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17286b53488467d11ce996bb67e9ac72d58ccc97" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">현재 플랫폼의 기본 줄 바꿈 표현 : Unix 시스템의 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; , Windows의 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78f21582e0027e530ef578f9b561481600ae0181" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">현재 플랫폼의 기본 줄 바꿈 표현 : Unix 시스템의 &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; , Windows의 &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f38af79343aeda66e3c105c4d632b98dde240785" translate="yes" xml:space="preserve">
          <source>The natural generated &lt;code&gt;Eq&lt;/code&gt; code would result in these instance declarations:</source>
          <target state="translated">자연스럽게 생성 된 &lt;code&gt;Eq&lt;/code&gt; 코드는 다음과 같은 인스턴스 선언을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="2aa75ff914d05468b9b141013cb484ac0d26b5d2" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">새로운 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 원본에 대한 다른 참조를 만드는 것과 같은 최종 관점에서 원본의 최종 자를 공유합니다. 즉, 새 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 도달 하기 전에 종료자가 호출되지 않으며이 호출로 인해 추가 시간이 호출되지 않으며 호출자가 발생하지 않았을 때와 동일한 주소로 종료자가 호출됩니다. 새 주소가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d537ecc2a0a7273339bdcd281e6203980acce3cf" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">새로운 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 원본에 대한 다른 참조를 만드는 것과 같은 최종 관점에서 원본의 최종 자를 공유합니다. 즉, 새 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 도달 하기 전에 종료자가 호출되지 않으며이 호출로 인해 추가 시간이 호출되지 않으며 호출자가 발생하지 않았을 때와 동일한 주소로 종료자가 호출됩니다. 새 주소가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9565bf7af2fc32661af4296e391a5a4f73420f53" translate="yes" xml:space="preserve">
          <source>The new algorithm considers all outgoing edges of a basic blocks for code layout instead of only the last jump instruction. It also builds a control flow graph for functions, tries to find hot code paths and place them sequentially leading to better cache utilization and performance.</source>
          <target state="translated">새로운 알고리즘은 마지막 점프 명령 만이 아니라 코드 레이아웃을위한 기본 블록의 모든 나가는 모서리를 고려합니다. 또한 함수에 대한 제어 흐름 그래프를 작성하고 핫 코드 경로를 찾아서 순차적으로 배치하여 캐시 활용도 및 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="0e6b6e161e08547e4c2e84b69fc3ce69fd7fe2bd" translate="yes" xml:space="preserve">
          <source>The new prompt is &lt;code&gt;*Main&lt;/code&gt;, which indicates that we are typing expressions in the context of the top-level of the &lt;code&gt;Main&lt;/code&gt; module. Everything that is in scope at the top-level in the module &lt;code&gt;Main&lt;/code&gt; we just loaded is also in scope at the prompt (probably including &lt;code&gt;Prelude&lt;/code&gt;, as long as &lt;code&gt;Main&lt;/code&gt; doesn&amp;rsquo;t explicitly hide it).</source>
          <target state="translated">새로운 프롬프트는 &lt;code&gt;*Main&lt;/code&gt; 이며, &lt;code&gt;Main&lt;/code&gt; 모듈 의 최상위 컨텍스트에서 표현식을 입력하고 있음을 나타냅니다 . 모듈의 최상위에 범위에 모든 &lt;code&gt;Main&lt;/code&gt; 우리가로드는 (아마도 포함하여 프롬프트에서 범위 또한 &lt;code&gt;Prelude&lt;/code&gt; 만큼, &lt;code&gt;Main&lt;/code&gt; 명시 적으로 숨기지 않습니다).</target>
        </trans-unit>
        <trans-unit id="53f5b2e47a4b9ae427e19c9dbf1f618026a18fe1" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">새 스레드는 부모 의 &lt;em&gt;마스크 된&lt;/em&gt; 상태를 상속합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b2c4fdfc801aad37935508fdd942cd092c0f04c2" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">새 스레드는 부모 의 &lt;em&gt;마스크&lt;/em&gt; 상태를 상속합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bcc805e0439a11e291b44cd7c9f1e66222dea760" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">새 스레드는 부모 의 &lt;em&gt;마스크&lt;/em&gt; 상태를 상속합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8d318f738e712b9a7c49deddbf087cc0b4b1ac85" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">새 스레드는 부모 의 &lt;em&gt;마스크 된&lt;/em&gt; 상태를 상속합니다 ( &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f49ffa4a3cda912cfa43024b34a8d1f99a2d6f8d" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">새로운 스레드는 가볍고 &lt;em&gt;언 바운드&lt;/em&gt; 스레드입니다. 이 스레드에 의한 외래 호출은 특정 OS 스레드에 의해 보장되는 것은 아닙니다. 특정 OS 스레드에서 외래 호출을해야하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8fbb6e9f1289a8fa68ffdbef26f7af463547a02e" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">새 스레드는 가볍고 &lt;em&gt;바인딩되지 않은&lt;/em&gt; 스레드입니다. 이 스레드에 의한 외래 호출은 특정 OS 스레드에 의해 수행된다는 보장이 없습니다. 특정 OS 스레드에 의한 외래 호출이 필요한 경우 대신 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1197c94f7e0ac7f82a62aa457b5035a8b93c1978" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">새 스레드는 가볍고 &lt;em&gt;바인딩되지 않은&lt;/em&gt; 스레드입니다. 이 스레드에 의한 외래 호출은 특정 OS 스레드에 의해 수행된다는 보장이 없습니다. 특정 OS 스레드에 의한 외래 호출이 필요한 경우 대신 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d79262bf7af143e8fe77bde10bec763c9abf1332" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">새로운 스레드는 가볍고 &lt;em&gt;언 바운드&lt;/em&gt; 스레드입니다. 이 스레드에 의한 외래 호출은 특정 OS 스레드에 의해 보장되는 것은 아닙니다. 특정 OS 스레드에서 외래 호출을해야하는 경우 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b442e2a2732ad1aadc2d2333cde267e32b0b385" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">새로 생성 된 스레드에는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 예외를 버리고 다른 모든 예외를 포착되지 않은 예외 처리기에 전달하는 예외 처리기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc43222cc5f22f48444dca9a33addd84a41162b9" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">새로 작성된 스레드에는 예외 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 를 삭제하고 다른 모든 예외를 포착되지 않은 예외 핸들러로 전달하는 예외 핸들러가 있습니다.</target>
        </trans-unit>
        <trans-unit id="579e80199534cdc2b932fbff0d17b1af98df418f" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">새로 생성 된 스레드에는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 예외를 버리고 다른 모든 예외를 포착되지 않은 예외 처리기에 전달하는 예외 처리기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="06467093ec13b99be21e49f501d476baef2995e0" translate="yes" xml:space="preserve">
          <source>The next Sunday strictly after a given day.</source>
          <target state="translated">주어진 일요일 이후 엄격하게 다음 일요일.</target>
        </trans-unit>
        <trans-unit id="e51f1e019c165b5ff5fa63cf369da84fd6846719" translate="yes" xml:space="preserve">
          <source>The next two example show &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; will short circuit the resulting structure if present in the input. For more context, check the &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음의 두 가지 예를 표시 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 단락 얻어진 구조 경우 입력 존재. 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스를 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="00707ee65b7f00c3337f8bb735096db5d8c588ed" translate="yes" xml:space="preserve">
          <source>The next two example show &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; will short circuit the resulting structure if present in the input. For more context, check the &lt;code&gt;&lt;a href=&quot;prelude#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음의 두 가지 예를 표시 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 단락 얻어진 구조 경우 입력 존재. 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스를 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="00554018ca7c76296e2e972dcf6e4032903f571e" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">비 복사 구현은 특정 쌍의 배열 유형 사이에서만 지원됩니다. 한 가지 제약 조건은 배열 유형이 동일한 표현을 가져야한다는 것입니다. GHC에서 다음 쌍의 배열 유형에는 &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt; 의 비 복사 O (1) 구현이 있습니다 . 최적화 된 버전은 전문화에 의해 활성화되므로 최적화 (-O)로 컴파일하여 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="a17dd35e1a788245fc2675b10d198269467558f5" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">비 복사 구현은 특정 쌍의 배열 유형 사이에서만 지원됩니다. 한 가지 제약 조건은 배열 유형이 동일한 표현을 가져야한다는 것입니다. GHC에서, 다음 배열 유형 쌍은 &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt; 의 비 복사 O (1) 구현을 갖습니다 . 최적화 된 버전은 전문화에 의해 활성화되므로 최적화 (-O)로 컴파일하여 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="25b29270e30e332a1316f0fc53e01b19e55849c5" translate="yes" xml:space="preserve">
          <source>The non-moving heap census events (enabled with the &lt;code&gt;+RTS -ln&lt;/code&gt; event-set) are intended to provide insight into fragmentation of the non-moving heap.</source>
          <target state="translated">이동하지 않는 힙 센서스 이벤트 ( &lt;code&gt;+RTS -ln&lt;/code&gt; 이벤트 세트로 활성화 됨 )는 이동하지 않는 힙의 조각화에 대한 통찰력을 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4065cd5ff81b5cc613fc73a9059855b99c8be0cc" translate="yes" xml:space="preserve">
          <source>The non-termination is reported like this:</source>
          <target state="translated">비 종료는 다음과 같이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="7d6d02244fcddd7ae83db06c2e068263589664bf" translate="yes" xml:space="preserve">
          <source>The nonnegative magnitude of a complex number.</source>
          <target state="translated">복소수의 음수가 아닌 크기입니다.</target>
        </trans-unit>
        <trans-unit id="2ff00bf6c0c197af17057ab64282dcdcec685b3e" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">왼쪽 대신 오른쪽 연관성 이있는 일반 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2a0c86a118296186481a0035095ac01fc1c9459b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">왼쪽 대신 오른쪽 연관성을 갖는 노멀 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="66177060899f226aedfa721331c31bc207cac457" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">왼쪽 대신 오른쪽 연관성을 갖는 노멀 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="e8ea10bfd840fdd3f1f9ba01648e552adcfe5390" translate="yes" xml:space="preserve">
          <source>The normal rule in Haskell is that your program must supply a &lt;code&gt;main&lt;/code&gt; function in module &lt;code&gt;Main&lt;/code&gt;. When testing, it is often convenient to change which function is the &amp;ldquo;main&amp;rdquo; one, and the &lt;code&gt;-main-is&lt;/code&gt; flag allows you to do so. The ⟨thing⟩ can be one of:</source>
          <target state="translated">Haskell의 일반적인 규칙은 프로그램이 &lt;code&gt;Main&lt;/code&gt; 모듈에서 &lt;code&gt;main&lt;/code&gt; 기능을 제공해야한다는 것 입니다. 테스트 할 때 &quot;main&quot;기능을 변경하는 것이 편리한 경우가 많으며 &lt;code&gt;-main-is&lt;/code&gt; 플래그를 사용하면 변경할 수 있습니다. ⟨thing⟩은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8565c7cc336e9d2bc02ea4c1cab0de9e55beac01" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;a -&amp;gt; b&lt;/code&gt; used here between the &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; symbols &amp;mdash; not to be confused with a function type &amp;mdash; indicates that the &lt;code&gt;a&lt;/code&gt; parameter uniquely determines the &lt;code&gt;b&lt;/code&gt; parameter, and might be read as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; determines &lt;code&gt;b&lt;/code&gt;.&amp;rdquo; Thus &lt;code&gt;D&lt;/code&gt; is not just a relation, but actually a (partial) function. Similarly, from the two dependencies that are included in the definition of &lt;code&gt;E&lt;/code&gt;, we can see that &lt;code&gt;E&lt;/code&gt; represents a (partial) one-to-one mapping between types.</source>
          <target state="translated">여기에 사용 된 표기법 a- &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 는 &lt;code&gt;|&lt;/code&gt; 그리고 &lt;code&gt;where&lt;/code&gt; 함수 형태와 혼동되지 않음 - - 심볼들이는 것을 나타낸다 파라미터가 고유하게 결정 &lt;code&gt;b&lt;/code&gt; 매개 변수와 같이 판독 될 수있는 &quot; &lt;code&gt;a&lt;/code&gt; 결정 &lt;code&gt;b&lt;/code&gt; .&quot; 따라서 &lt;code&gt;D&lt;/code&gt; 는 단순한 관계가 아니라 실제로 (부분) 함수입니다. 유사하게,의 정의에 포함되는 두 의존성에서 &lt;code&gt;E&lt;/code&gt; , 우리는 것을 알 수있다 &lt;code&gt;E&lt;/code&gt; 는 유형 사이 (부분) 일대일 매핑을 나타낸다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65e0f3cb1cdca573b0a31816dea29f6e08943a92" translate="yes" xml:space="preserve">
          <source>The null address.</source>
          <target state="translated">널 주소</target>
        </trans-unit>
        <trans-unit id="6f24da5886263ef92cea0da538817aecc2d6f529" translate="yes" xml:space="preserve">
          <source>The number of bytes that must be consumed</source>
          <target state="translated">소비해야하는 바이트 수</target>
        </trans-unit>
        <trans-unit id="ca0f126d79cabf7e2c5e95757d200444f569118d" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Gregorian calendar. First argument is year, second is month.</source>
          <target state="translated">Proleptic Gregorian 달력에 따른 특정 달의 일 수입니다. 첫 번째 인수는 연도이고 두 번째 인수는 월입니다.</target>
        </trans-unit>
        <trans-unit id="9391d34aef57b18832247680a9bb961c2cb802e0" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Julian calendar. First argument is year, second is month.</source>
          <target state="translated">Proleptic Julian 일정에 따른 특정 달의 일 수입니다. 첫 번째 인수는 연도이고 두 번째 인수는 월입니다.</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">배열의 요소 수</target>
        </trans-unit>
        <trans-unit id="43d9d47c41193f72155e7e7c1d8d822460113e6b" translate="yes" xml:space="preserve">
          <source>The number of minutes offset from UTC. Positive means local time will be later in the day than UTC.</source>
          <target state="translated">UTC에서 분 단위의 오프셋입니다. 양수는 현지 시간이 UTC보다 나중에 늦음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="69b816c0ec0e62c60a64cad0412b6307fc8984cc" translate="yes" xml:space="preserve">
          <source>The number of times this particular point in the call tree was entered.</source>
          <target state="translated">통화 트리에서이 특정 지점이 입력 된 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="d0ef27c2e92d99ce3709f3c8cd8149198afbb479" translate="yes" xml:space="preserve">
          <source>The numeric branch for this version. This reflects the fact that most software versions are tree-structured; there is a main trunk which is tagged with versions at various points (1,2,3...), and the first branch off the trunk after version 3 is 3.1, the second branch off the trunk after version 3 is 3.2, and so on. The tree can be branched arbitrarily, just by adding more digits.</source>
          <target state="translated">이 버전의 숫자 분기입니다. 이것은 대부분의 소프트웨어 버전이 트리 구조라는 사실을 반영합니다. 다양한 지점 (1,2,3 ...)의 버전으로 태그가 지정된 기본 트렁크가 있으며 버전 3 이후 트렁크의 첫 번째 분기는 3.1이고 버전 3 이후 트렁크의 두 번째 분기는 3.2입니다. 곧. 더 많은 숫자를 추가하여 트리를 임의로 분기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f31d4347cd14b9ff9a95c759d4f40a65f6f736b" translate="yes" xml:space="preserve">
          <source>The object file, which normally ends in a &lt;code&gt;.o&lt;/code&gt; suffix, contains the compiled code for the module.</source>
          <target state="translated">일반적으로 &lt;code&gt;.o&lt;/code&gt; 접미사로 끝나는 객체 파일 에는 모듈에 대한 컴파일 된 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="805b61067737cd38cfcd7f8a184e0af8d81d4642" translate="yes" xml:space="preserve">
          <source>The object files, &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Bar.o&lt;/code&gt;, and &lt;code&gt;Bumble.o&lt;/code&gt; would be put into a subdirectory named after the architecture of the executing machine (&lt;code&gt;x86&lt;/code&gt;, &lt;code&gt;mips&lt;/code&gt;, etc).</source>
          <target state="translated">객체 파일 &lt;code&gt;Foo.o&lt;/code&gt; , &lt;code&gt;Bar.o&lt;/code&gt; 및 &lt;code&gt;Bumble.o&lt;/code&gt; 는 실행중인 컴퓨터의 아키텍처 ( &lt;code&gt;x86&lt;/code&gt; , &lt;code&gt;mips&lt;/code&gt; 등)의 이름을 딴 하위 디렉토리에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="75f3688b610f29c49c2454cfe45bd0a8cb6e12b0" translate="yes" xml:space="preserve">
          <source>The object version of the library used by GHCi.</source>
          <target state="translated">GHCi가 사용하는 라이브러리의 객체 버전.</target>
        </trans-unit>
        <trans-unit id="403a24f2ec97b5832764d3f75bef5030d88d4c2e" translate="yes" xml:space="preserve">
          <source>The obsolete language option &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; is a synonym for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes.</source>
          <target state="translated">사용되지 않는 언어 옵션 &lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; 는&lt;/a&gt; 동의어입니다 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; . 그들은 GHC가 더 이상 만들지 않는 더 세밀한 구별을 지정하는 데 사용되었습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
