<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">재 컴파일 검사를 끕니다. 이것은 단일 파일을 컴파일 할 때 (즉, &lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; 를&lt;/a&gt; 사용할 때) &lt;code&gt;-ddump-X&lt;/code&gt; 옵션에 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">인수로 &lt;code&gt;State#&lt;/code&gt; 토큰 이있는 모든 람다 는 단일 항목으로 간주되므로 내부 항목을 인라인하는 것으로 간주 되는 &quot;state hack&quot;을 끄십시오 . 이는 IO 및 ST 모나드 코드의 성능을 향상시킬 수 있지만 공유를 줄일 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">강제 옵티 마이저 끄기</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">강제 옵티 마이저를 끕니다.</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">인수로 간주되는 실제 상태 토큰이있는 람다는 단일 항목으로 간주되는 상태 핵을 끄십시오. 따라서 내부의 내용을 인라인해도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;열성적인 블랙홀 링&lt;/a&gt; 켜기</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">수요 분석가에서 CPR 분석을 켭니다.</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수요 분석가에서 CPR 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">Haskell 프로그램 적용 범위 계측 켜기</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">통화 패턴 전문화를 켭니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Haskell 프로그램의 콜 패턴 전문화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">디버그 인쇄 켜기 (보다 자세한 정보)</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게으름을 완전히 켭니다 (유동 바인딩을 바깥쪽으로). &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">코어 수준에서 GHC 내에서 헤비급 인트라 패스 위생 검사를 켭니다. (그것은 당신의 GHC의 정신 상태를 검사합니다.)</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">내부 위생 검사 켜기</target>
        </trans-unit>
        <trans-unit id="dc3c205a62aa2d2da8175eab4c4b97ecb966fe59" translate="yes" xml:space="preserve">
          <source>Turn on linearity checking in GHC. Currently, some optimizations in GHC might not preserve linearity and they valid programs might fail Linear Core Lint. In the near future, this option will be removed and folded into normal Core Lint.</source>
          <target state="translated">GHC에서 선형성 검사를 켭니다. 현재 GHC의 일부 최적화는 선형성을 유지하지 못할 수 있으며 유효한 프로그램은 Linear Core Lint에 실패 할 수 있습니다. 가까운 장래에이 옵션은 제거되어 일반 Core Lint로 접힐 것입니다.</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">GHCi에서 제본 결과 인쇄 켜기</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">프로파일 링 켜기</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">다른 모듈에서 가져온 오버로드 된 기능의 특수화를 켭니다.</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">펼칠 수있는 경우 크기에 관계없이 오버로드 된 기능의 전문화</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 기능의 전문화를 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="186b5bba16e6ae8eb15a9abb5dd5b71128ae5773" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt;&lt;code&gt;-fworker-wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">엄격 성 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt; &lt;code&gt;-fworker-wrapper&lt;/code&gt; 를&lt;/a&gt; 의미합니다.</target>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">엄격 성 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;code&gt;-fworker-wrapper&lt;/code&gt; 를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SpecConstr 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">float-in 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자유 사례 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">자유 사례 변환을 켭니다. 이것은 자유 변수의 반복적 인 사례 분석을 피하기 위해 자체 RHS에서 재귀 함수를 한 번 풀어줍니다. 콜 패턴 스페셜 &lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt; ( -fspec-constr )와 비슷하지만 인수가 아닌 자유 변수입니다.</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">정적 인수 변환을 켜면 재귀 함수가 로컬 재귀 루프가있는 비 재귀 함수로 바뀝니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos의 PhD 논문&lt;/a&gt; 7 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">정적 인수 변환을 켜십시오.</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">까다로운 프로파일 링 켜기</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성 된 어셈블리에서 포화 자체 재귀 테일 콜을 로컬 점프로 전환합니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="817ee37f90284803efb9153022786df4682fbe53" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">유형 오류를 경고로 바꾸고 &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;런타임까지 오류를 연기합니다&lt;/a&gt; . 의미 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">유형 오류를 경고로 바꾸고 &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;런타임까지 오류를 연기하십시오&lt;/a&gt; . 의미 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; . 참조 &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">특수 구문을 활성화하는 옵션을 설정하면 예약 된 단어가 된 변수 이름을 사용하기 때문에 Haskell 98 코드 작업이 컴파일되지 않을 &lt;em&gt;수&lt;/em&gt; 있습니다. 이 섹션에는 언어 확장에 의해 &quot;도난 된&quot;구문이 나열되어 있습니다. 우리는 Haskell 98 어휘 구문에서 표기법과 비 터미널 이름을 사용합니다 (Haskell 98 보고서 참조). 여기에는 기존 작업 프로그램에 영향을 줄 수있는 구문 변경 사항 만 나열됩니다 (예 : &quot;도난&quot;구문). 이러한 확장 중 상당수는 새로운 컨텍스트 프리 구문도 사용할 수 있지만 모든 경우에 새 구문을 사용하도록 작성된 프로그램은 옵션을 사용하지 않으면 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">패턴을 반박 할 수없는 패턴으로 바꾸려면 &lt;code&gt;Strict&lt;/code&gt; 가 활성화 된 경우 &lt;code&gt;~(~p)&lt;/code&gt; 또는 &lt;code&gt;(~ ~p)&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c36dca2d0bb2acce2b8d943939d7c270f3396cfe" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;Strict&lt;/code&gt; 가 활성화 된 경우 패턴을 반박 할 수없는 패턴으로 바꾸려면 &lt;code&gt;~(~p)&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">모나드 연산으로 지정된 종료자를 참조와 연결하여 일반 메모리 참조를 외부 객체로 변환합니다. 스토리지 관리자는 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 대한 마지막 참조 가 삭제 된 후 얼마 후에 별도의 스레드에서 종료자를 시작합니다 . 신속 함을 보장 할 수 없으며 실제로 최종자가 결국 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">모나드 연산으로 지정된 종료자를 참조와 연결하여 일반 메모리 참조를 외부 객체로 변환합니다. 스토리지 관리자는 &lt;code&gt;ForeignPtr&lt;/code&gt; 에 대한 마지막 참조 가 삭제 된 후 얼마 후에 별도의 스레드에서 종료자를 시작합니다 . 신속 함을 보장 할 수 없으며 실제로 최종자가 결국 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">일반 메모리 참조를 외부 포인터로 변환하고 종료자를 참조와 연관시킵니다. 외부 객체에 대한 마지막 참조가 삭제 된 후 종료자가 실행됩니다. 프롬프트가 보장되지는 않지만 프로그램이 종료되기 전에 종료자가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">모든 텍스트 속성을 끕니다. 이 기능은 항상 성공하지만 텍스트 속성을 지원하지 않는 터미널에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">표준 경고 및 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; 에서 사용&lt;/a&gt; 하지 않는 경고를 포함하여 모든 경고를 끕니다 .</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">의심스러운 코드를 나타내는 모든 경고 옵션을 설정합니다. &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; 에 의해 활성화 &lt;em&gt;되지 않은&lt;/em&gt; 경고 는</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">주어진 텍스트를 출력하기 전에 굵게 모드를 켠 다음 모든 속성을 끕니다.</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">컴파일러가 지원하는 모든 단일 경고를 켭니다.</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">지정된 텍스트를 출력하기 전에 스탠드 아웃 모드를 켠 다음 끕니다.</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">주어진 텍스트를 출력하기 전에 밑줄 모드를 켠 다음 끕니다.</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">향후 기본적으로 활성화 될 예정인 경고를 설정하지만 당분간은 정상적인 컴파일 상태를 유지하지 않습니다. 이를 통해 라이브러리 작성자는 경고를 생성하기 전에 새로운 기능에 적응할 수 있도록 향후 코드를 호환 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">두 가지 명령 줄 옵션은 시작 파일 파일을 읽을 지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">주의해야 할 두 가지 :</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">가능한 모든 대체에 대해 유형이 공통 리 덕트로 환원 될 수없는 경우 두 유형이 분리 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">두 가지 유형의 메시지가 생성됩니다. &lt;code&gt;***&lt;/code&gt; 로 시작하는 메시지는 컴파일 단계의 시작을 나타내는 반면 &lt;code&gt;!!!&lt;/code&gt; 로 시작하는 메시지는 !!! 패스의 끝을 표시하고 할당 및 런타임 통계를 동반합니다.</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">문자 리터럴</target>
        </trans-unit>
        <trans-unit id="0ff156671a95e7d7958f54c3801c9a78059e1834" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">인수 이름이 중요하지 않은 경우 형식 인수를 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 바꿀 수 있습니다 . 이것은 고유 한 이름으로 유형 변수를 작성하는 것과 동일합니다. &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그가 사용 가능할 때 경고를 피하기 위해 사용되지 않는 유형 인수를 대체하거나 밑줄로 접 두부를 붙일 수 있습니다 . &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 과 동일한 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">인수 이름이 중요하지 않은 경우 유형 인수를 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 바꿀 수 있습니다 . 이것은 고유 한 이름으로 유형 변수를 작성하는 것과 같습니다. &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그가 사용 가능한 경우 경고를 피하기 위해 사용하지 않는 유형 인수를 밑줄로 대체하거나 접 두부를 붙일 수 있습니다 . &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 과 동일한 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">유형 검사기는 구멍에 대해 유추 된 유형을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">I / O 제공자를위한 유형 클래스.</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 같이 자체 확장을 파생시켜야하는 유형 클래스 ( &lt;a href=&quot;#deriving-extra&quot;&gt;추가 클래스의 인스턴스 파생 (데이터 등) 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="926bf298afdb2d507c3bd7a1413520e17a01edb6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 같이 자체 확장을 활성화해야하는 유형 클래스 ( &lt;a href=&quot;#deriving-extra&quot;&gt;예 : 추가 클래스 (데이터 등)의 파생 인스턴스&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="561c814be6dae335c98b673227b1a4d073e164e6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;deriving_extra#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;deriving_extra#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;deriving_extra#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 같이 자체 확장을 활성화해야하는 유형 클래스 ( &lt;a href=&quot;deriving_extra#deriving-extra&quot;&gt;예 : 추가 클래스 (데이터 등)의 파생 인스턴스&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt; - all 과 관련된 유형에 적용된 형식 생성자 ( ImpredicativeTypes 가 해제 된 경우)</target>
        </trans-unit>
        <trans-unit id="ccd8b1a39bf697129dfe9925ae54f15bbbb0a75a" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;impredicative_types#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">for-alls를 포함하는 유형에 적용된 유형 생성자 ( &lt;a href=&quot;impredicative_types#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt; 가 꺼져있는 경우)</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">타입 생성자</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">타입 생성자와 클래스; 하스켈은 현재 같은 이름 공간에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4cb9160c66acee90d4523d170727eb5eabf6f68" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. #14605).</source>
          <target state="translated">forall 아래의 형식 평등은 연기 할 수 없습니다 (# 14605 참조).</target>
        </trans-unit>
        <trans-unit id="9fc11fe5ce4f23f06fca295618c3b4ba02ddb103" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14605&quot;&gt;#14605&lt;/a&gt;).</source>
          <target state="translated">forall 아래의 형식 같음을 연기 할 수 없습니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14605&quot;&gt;# 14605 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">forall 아래의 유형 평등은 연기 될 수 없습니다 (참조 Trac # 14605).</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">유형 평등</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">유형 패밀리는 세 가지 맛으로 나타납니다. 연관된 유형 동의어라고합니다). 최상위 색인 패밀리는 유형 색인이 클래스 매개 변수와 일치하지 않아도되므로보다 일반적입니다. 그러나 일부 유형 인스턴스가 실수로 생략 된 경우 연관된 유형 동의어가보다 명확하게 구조화 된 코드 및 컴파일러 경고를 유발할 수 있습니다. 다음에서 우리는 항상 일반 최상위 양식을 먼저 논의한 다음 관련 유형에 대한 추가 제약 조건을 다룹니다. 닫힌 연관된 유형 동의어가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">언어 패밀리는 &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; 언어 확장으로 활성화됩니다 . GHC에서 유형 군 사용에 대한 추가 정보는 유형 군에 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;관한 Haskell 위키 페이지에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f76f6ce50fb342101781212e18ae010ee327b2c4" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">유형 패밀리는 언어 확장 &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; 에&lt;/a&gt; 의해 활성화됩니다 . GHC에서 타입 패밀리 사용에 대한 추가 정보는 타입 패밀리에 &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;대한 Haskell 위키 페이지에서&lt;/a&gt; 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">유형 패밀리는 인스턴스 헤드의 규칙에 대한 규칙을 확장해야 &lt;a href=&quot;#flexible-instance-head&quot;&gt;하며, 인스턴스 헤드의 완화 규칙에 나와&lt;/a&gt; 있습니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="f4251de5d3214c46072d1ab7da575f6b1ff192df" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;instances#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">유형 패밀리에서는 인스턴스 헤드에 &lt;a href=&quot;instances#flexible-instance-head&quot;&gt;대한 완화 된 규칙에&lt;/a&gt; 제공된 인스턴스 헤드 형식에 대한 규칙을 확장해야합니다 . 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="0a8c0f063a56614635f7174c757855682f77adaa" translate="yes" xml:space="preserve">
          <source>Type family declarations have no right-hand side, but GHC must still infer a kind for &lt;code&gt;F&lt;/code&gt;. Since there are no constraints, it could infer &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt;, but that seems &lt;em&gt;too&lt;/em&gt; polymorphic. So GHC defaults those entirely-unconstrained kind variables to &lt;code&gt;Type&lt;/code&gt; and we get &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt;. You can still declare &lt;code&gt;F&lt;/code&gt; to be kind-polymorphic using kind signatures:</source>
          <target state="translated">유형 패밀리 선언에는 오른쪽이 없지만 GHC는 여전히 &lt;code&gt;F&lt;/code&gt; 에 대한 종류를 유추해야합니다 . 제약 조건이 없으므로, 모든 &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt; 유추 할 수 있습니다. k1-&amp;gt; k2 이지만 &lt;em&gt;너무&lt;/em&gt; 다형성으로 보입니다 . 따라서 GHC는 완전히 제한되지 않은 종류 변수를 &lt;code&gt;Type&lt;/code&gt; 으로 기본 설정 하고 &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt; 얻습니다 . 종류 시그니처를 사용하여 &lt;code&gt;F&lt;/code&gt; 를 종류가 다형성으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd7475025d74b7eaf3a5c6c31d02e60c9ba84c8" translate="yes" xml:space="preserve">
          <source>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</source>
          <target state="translated">클래스 패밀리 인스턴스 선언은 적절한 패밀리 선언이 범위 내에있을 때만 합법적입니다. 클래스 인스턴스가 클래스 선언을 표시해야하는 것처럼 말입니다. 또한 각 인스턴스 선언은 패밀리 선언에 의해 결정된 종류를 따라야하며 인스턴스 선언의 유형 매개 변수 수는 패밀리 선언의 유형 매개 변수 수와 일치해야합니다. 마지막으로, 유형 인스턴스의 오른쪽은 단일 유형이어야하며 (즉, 모든 유형을 포함하지 않을 수 있음) 모든 포화 바닐라 유형 동의어가 확장 된 후에는 패밀리 동의어를 제외하고 동의어가 없습니다.</target>
        </trans-unit>
        <trans-unit id="70bbb20d2a1a6691ef9fa237cff60e4e6de9eb91" translate="yes" xml:space="preserve">
          <source>Type family result</source>
          <target state="translated">유형 가족 결과</target>
        </trans-unit>
        <trans-unit id="0f4828f660b26b8e0b84ed945344b94a3b83159e" translate="yes" xml:space="preserve">
          <source>Type family result signature</source>
          <target state="translated">유형 군 결과 서명</target>
        </trans-unit>
        <trans-unit id="c9902ea99522cdd8d23085400914695929774e22" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;#10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;#10946&lt;/a&gt;)</source>
          <target state="translated">입력 된 스플 라이스에 구멍 입력 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;# 10945&lt;/a&gt; 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;# 10946 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="358e178753bb1e86971badaa924cf0ea2c52929d" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Issue #10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;Issue #10946&lt;/a&gt;)</source>
          <target state="translated">타이핑 된 스플 라이스의 타이핑 구멍 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;문제 # 10945&lt;/a&gt; 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;문제 # 10946 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="276b31a5f89d022c33dce55c2768f21e907ef802" translate="yes" xml:space="preserve">
          <source>Type lookup</source>
          <target state="translated">유형 조회</target>
        </trans-unit>
        <trans-unit id="873a99e95101acee0eaf6ee1997f0cfc41142d03" translate="yes" xml:space="preserve">
          <source>Type of a device that can be used to back a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (see also &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt;). The standard libraries provide creation of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s via Posix file operations with file descriptors (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt;) with FD being the underlying &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 백업하는 데 사용할 수있는 장치의 유형입니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt; 참조 ). 표준 라이브러리 는 기본 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 인스턴스 가 FD 인 파일 디스크립터 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt; 참조 )를 사용 하여 Posix 파일 조작을 통해 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 작성을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="1a8dd35ccae4e966a68ff35c41712c9b36c641b0" translate="yes" xml:space="preserve">
          <source>Type of a function that will parse modifier characters from the format string.</source>
          <target state="translated">형식 문자열에서 수정 자 문자를 구문 분석 할 함수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="abcdceb02cff6a2c30770317c525208b3a8f1938" translate="yes" xml:space="preserve">
          <source>Type representations</source>
          <target state="translated">타입 표현</target>
        </trans-unit>
        <trans-unit id="d476627bc725ea2b4474151d280a2bff44c61eb5" translate="yes" xml:space="preserve">
          <source>Type representing 128-bit Unicode subset bitfields, as the &lt;code&gt;base&lt;/code&gt; package does include a module exporting a 128-bit unsigned integer type.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 패키지에는 128 비트 부호없는 정수 유형을 내보내는 모듈이 포함 되어 있으므로 128 비트 유니 코드 하위 집합 비트 필드를 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4a3e13a726a19383a1d4e94b6299671bdfe44312" translate="yes" xml:space="preserve">
          <source>Type representing &lt;em&gt;raw&lt;/em&gt; arbitrary-precision Naturals</source>
          <target state="translated">&lt;em&gt;원시&lt;/em&gt; 임의 정밀도 Naturals를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="671703d1ace4903a86338074fcbb10d8c7abb79d" translate="yes" xml:space="preserve">
          <source>Type representing a GMP Limb</source>
          <target state="translated">GMP 사지를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="54d9ef78d2f719690e76c88c724133d9268d3dbd" translate="yes" xml:space="preserve">
          <source>Type representing arbitrary-precision non-negative integers.</source>
          <target state="translated">임의 정밀도의 음이 아닌 정수를 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="07805eadc38f7082f8142805c647fecdc2fe145b" translate="yes" xml:space="preserve">
          <source>Type representing locale data</source>
          <target state="translated">로케일 데이터를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="04f3c2b34d933ed0082ee4d9a77619193e0fa0ae" translate="yes" xml:space="preserve">
          <source>Type signature declarations for functions, values, and class methods</source>
          <target state="translated">함수, 값 및 클래스 메서드에 대한 형식 서명 선언</target>
        </trans-unit>
        <trans-unit id="1e453cabd9572ae7f533e9e17c78f4446cb10208" translate="yes" xml:space="preserve">
          <source>Type signatures for &lt;a href=&quot;gadt#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt; constructors</source>
          <target state="translated">&lt;a href=&quot;gadt#gadt&quot;&gt;GADT (Generalized Algebraic Data Types)&lt;/a&gt; 생성자에 대한 형식 서명</target>
        </trans-unit>
        <trans-unit id="b796829535549c68436fd73f285f127abfd7701a" translate="yes" xml:space="preserve">
          <source>Type signatures for &lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;패턴 동의어에&lt;/a&gt; 대한 유형 서명</target>
        </trans-unit>
        <trans-unit id="27011d116ac3ec121518ae6e931cca052bc0fc9e" translate="yes" xml:space="preserve">
          <source>Type signatures in a &lt;a href=&quot;pragmas#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt; or &lt;a href=&quot;pragmas#specialize-instance-pragma&quot;&gt;SPECIALIZE instance pragma&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragmas#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt; 또는 &lt;a href=&quot;pragmas#specialize-instance-pragma&quot;&gt;SPECIALIZE 인스턴스 pragma의&lt;/a&gt; 형식 서명</target>
        </trans-unit>
        <trans-unit id="d1f333d10338307bc1b784667a629594e079c4f4" translate="yes" xml:space="preserve">
          <source>Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</source>
          <target state="translated">유형 스플 라이스 : 유형 스플 라이스에서는 익명 와일드 카드 만 지원됩니다. 명명 된 및 추가 제약 조건 와일드 카드는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f11439c31a98487626c375dcea7b024dac99e79d" translate="yes" xml:space="preserve">
          <source>Type synonym families may not appear (at all) in an instance head</source>
          <target state="translated">유형 동의어 패밀리가 인스턴스 헤드에 전혀 나타나지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0d76a40c54b048eccf092f3d284b847909f588a0" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr #의&lt;/a&gt; 유형 동의어</target>
        </trans-unit>
        <trans-unit id="f8bdd4c143c24e4a800f150ca0b3c707e64b8ee5" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="6200650e3b073a512de8a4f746fe7641f19f3b6e" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double #에&lt;/a&gt; 대한 동의어</target>
        </trans-unit>
        <trans-unit id="68f0b26db1c67e68b16638c3bdb6e48c2730cfcb" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="786449ff1af28a830302acb40a4df639ec0b1a9a" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int #에&lt;/a&gt; 대한 동의어</target>
        </trans-unit>
        <trans-unit id="b833c73340a6aca568e641af9389cb5068a1b69c" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="fbc2d6b543125a6bbcf32afd5ebc2e6194481a75" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for constructors</source>
          <target state="translated">생성자를위한 메타 정보 인코딩을위한 타입 동의어</target>
        </trans-unit>
        <trans-unit id="01637cf0f027de68fdc7b5aa075fa796a7541a5a" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for datatypes</source>
          <target state="translated">데이터 유형의 메타 정보를 인코딩하기위한 유형 동의어</target>
        </trans-unit>
        <trans-unit id="4614911dbcdbe75ce8420ef09e4cddfbd8bcd75b" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for record selectors</source>
          <target state="translated">레코드 선택기의 메타 정보를 인코딩하기위한 유형 동의어</target>
        </trans-unit>
        <trans-unit id="cd6568ab830a42d4743f02c359ffccacc3f04b1f" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding recursion (of kind &lt;code&gt;Type&lt;/code&gt;)</source>
          <target state="translated">재귀를 인코딩하기위한 형식 동의어 ( &lt;code&gt;Type&lt;/code&gt; 종류 )</target>
        </trans-unit>
        <trans-unit id="2e57d9ed04b093b3c81d176b71e171ce86cead21" translate="yes" xml:space="preserve">
          <source>Type synonyms</source>
          <target state="translated">타입 동의어</target>
        </trans-unit>
        <trans-unit id="66c87db4429ac309b453d99467ebf0303fe2943b" translate="yes" xml:space="preserve">
          <source>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt;&lt;code&gt;LiberalTypeSynonyms&lt;/code&gt;&lt;/a&gt; extension, GHC does validity checking on types &lt;em&gt;only after expanding type synonyms&lt;/em&gt;. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</source>
          <target state="translated">유형 동의어는 유형 수준의 매크로와 비슷하지만 Haskell 98은 개별 동의어 선언에 많은 규칙을 적용합니다. &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt; &lt;code&gt;LiberalTypeSynonyms&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC는 &lt;em&gt;유형 동의어를 확장 한 후에 만&lt;/em&gt; 유형에 대한 유효성 검사를 수행합니다 . 이는 GHC가 Haskell 98보다 유형 동의어에 대해 훨씬 더 자유로울 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b53035e4ebf40cc37041e2c629488482dfa0e22e" translate="yes" xml:space="preserve">
          <source>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. &lt;code&gt;_a&lt;/code&gt;. These are called &lt;em&gt;named wildcards&lt;/em&gt;. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</source>
          <target state="translated">밑줄에 식별자를 접미사 (예 : &lt;code&gt;_a&lt;/code&gt; ) 로 지정하여 유형 와일드 카드의 이름을 지정할 수도 있습니다 . 이를 &lt;em&gt;와일드 카드&lt;/em&gt; 라고 합니다. 하나의 유형 서명 내에서 동일한 이름의 와일드 카드가 발생하면 모두 동일한 유형으로 통합됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ead66032815d945b91e7f3ca53e01f2a9b3d371" translate="yes" xml:space="preserve">
          <source>Type-Indexed</source>
          <target state="translated">Type-Indexed</target>
        </trans-unit>
        <trans-unit id="89349ef7a3b1aed9c4a2611c575f48ebe1f9588c" translate="yes" xml:space="preserve">
          <source>Type-checking and renaming</source>
          <target state="translated">유형 확인 및 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="e4df789f69216abcb6af7685ef88fccb48d4e029" translate="yes" xml:space="preserve">
          <source>Type-class and implicit-parameter constraints</source>
          <target state="translated">타입 클래스와 암시 적 매개 변수 제약</target>
        </trans-unit>
        <trans-unit id="925e6d79cddba2c3bddc37cf1588ba124ea988cc" translate="yes" xml:space="preserve">
          <source>Type-level &quot;and&quot;</source>
          <target state="translated">타입 레벨 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="da8bd8c22c8d2b83e3a41e6db5bb694a1cab398a" translate="yes" xml:space="preserve">
          <source>Type-level &quot;not&quot;. An injective type family since &lt;code&gt;4.10.0.0&lt;/code&gt;.</source>
          <target state="translated">유형 수준 &quot;not&quot;. &lt;code&gt;4.10.0.0&lt;/code&gt; 이후의 인젝 티브 타입 패밀리 .</target>
        </trans-unit>
        <trans-unit id="4ace6e6dff738eea140d3177610f72ab3c710220" translate="yes" xml:space="preserve">
          <source>Type-level &quot;or&quot;</source>
          <target state="translated">타입 레벨 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="fb80fb0cd37d8fc564daf6fedf45033846615274" translate="yes" xml:space="preserve">
          <source>Type-level &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;. &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt;; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">유형 레벨 &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt; . &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt; ; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8911f3eca1306cba381f9e1e254ca16f95d810" translate="yes" xml:space="preserve">
          <source>Type-safe cast</source>
          <target state="translated">타입 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="2dbb305ead6c25f7be1be5c3d5f41eb8a9a76dd6" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using propositional equality</source>
          <target state="translated">제안 평등을 사용하는 유형 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="50d265b22a2aba2469677629fcf416096471ba92" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using representational equality</source>
          <target state="translated">표현 평등을 사용하는 유형 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="4d7fb49caed5ccaa28b4e22df123b1870b603064" translate="yes" xml:space="preserve">
          <source>Type.Reflection</source>
          <target state="translated">Type.Reflection</target>
        </trans-unit>
        <trans-unit id="1742f07af879d3cf88a9051291b4573ccd9dc6bc" translate="yes" xml:space="preserve">
          <source>Type.Reflection.Unsafe</source>
          <target state="translated">Type.Reflection.Unsafe</target>
        </trans-unit>
        <trans-unit id="64d3d705e437d4286c78a22f6d7ee8620f4bda1e" translate="yes" xml:space="preserve">
          <source>TypeApplications</source>
          <target state="translated">TypeApplications</target>
        </trans-unit>
        <trans-unit id="a90b20668004606ae955d09021dde257f6505557" translate="yes" xml:space="preserve">
          <source>TypeArg</source>
          <target state="translated">TypeArg</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="1baee472beb95c11f5ef2d7b8b3f743a3ba9ddf6" translate="yes" xml:space="preserve">
          <source>TypeFamilies</source>
          <target state="translated">TypeFamilies</target>
        </trans-unit>
        <trans-unit id="77b335820321b9c88753310855c49f382d99b38c" translate="yes" xml:space="preserve">
          <source>TypeFamilyDependencies</source>
          <target state="translated">TypeFamilyDependencies</target>
        </trans-unit>
        <trans-unit id="0ff4704cf9871d172e46093c902963c62493a59a" translate="yes" xml:space="preserve">
          <source>TypeFamilyHead</source>
          <target state="translated">TypeFamilyHead</target>
        </trans-unit>
        <trans-unit id="074e8ef03d4629b59466a2657ccae4e537c30d86" translate="yes" xml:space="preserve">
          <source>TypeInType</source>
          <target state="translated">TypeInType</target>
        </trans-unit>
        <trans-unit id="3e43198a1e6eec381f4d9a60cfec193b835e2b96" translate="yes" xml:space="preserve">
          <source>TypeLitNat</source>
          <target state="translated">TypeLitNat</target>
        </trans-unit>
        <trans-unit id="ab5cc289c62cf3f22557ac72519f3c08dfbfa2dd" translate="yes" xml:space="preserve">
          <source>TypeLitSymbol</source>
          <target state="translated">TypeLitSymbol</target>
        </trans-unit>
        <trans-unit id="7f2923c4751f8935c12b50c7a13c90ec460b9a65" translate="yes" xml:space="preserve">
          <source>TypeOperators</source>
          <target state="translated">TypeOperators</target>
        </trans-unit>
        <trans-unit id="127efaa98624e5386e6a57b6846ecf29edc5596f" translate="yes" xml:space="preserve">
          <source>TypeQ</source>
          <target state="translated">TypeQ</target>
        </trans-unit>
        <trans-unit id="97dd0a1ff386b68a6a4f4b903b4e8e20ccdf5f41" translate="yes" xml:space="preserve">
          <source>TypeRep</source>
          <target state="translated">TypeRep</target>
        </trans-unit>
        <trans-unit id="4923be1ff37db9ead0d3ce6f70368f3d9cb65db0" translate="yes" xml:space="preserve">
          <source>TypeSynonymInstances</source>
          <target state="translated">TypeSynonymInstances</target>
        </trans-unit>
        <trans-unit id="2e8fb009fca3a1778df4dee9b6ede33b60b37c30" translate="yes" xml:space="preserve">
          <source>Typeable</source>
          <target state="translated">Typeable</target>
        </trans-unit>
        <trans-unit id="40fb2a246a44fdd76a25bc4dee91c9b12c42ad29" translate="yes" xml:space="preserve">
          <source>Typeclass</source>
          <target state="translated">Typeclass</target>
        </trans-unit>
        <trans-unit id="a8e6ea3785b64f099cfa5c96f73972ea0e5a388d" translate="yes" xml:space="preserve">
          <source>Typeclass of &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;-formattable values. The &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; method takes a value and a field format descriptor and either fails due to a bad descriptor or produces a &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; as the result. The default &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; expects no modifiers: this is the normal case. Minimal instance: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 가능 값의 유형 클래스입니다 . &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 의 방법은 값 필드 포맷 디스크립터를 받아 하나 실패로 인해 잘못된 설명하거나 생성 &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; 결과한다. 기본 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 은 수정자를 기대하지 않습니다. 일반적인 경우입니다. 최소 예 : &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26ab741c0b6c1149ecdfc5c0b36d8ccc700d5b32" translate="yes" xml:space="preserve">
          <source>Typed TH quotes on the other hand are perfectly compatible with the eager application of rebindable syntax rules, and GHC will therefore process any such quotes according to the rebindable syntax rules whenever the &lt;code&gt;RebindableSyntax&lt;/code&gt; extension is turned on in the modules where such quotes appear.</source>
          <target state="translated">반면에 타이핑 된 TH 따옴표는 리 바인딩 가능한 구문 규칙의 열성적인 적용과 완벽하게 호환되므로 GHC는 이러한 따옴표가 나타나는 모듈에서 &lt;code&gt;RebindableSyntax&lt;/code&gt; 확장이 켜질 때마다 리 바인딩 가능한 구문 규칙에 따라 이러한 따옴표를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="a9b0eb1a7576e399628fdc3f0014f73ffc225afc" translate="yes" xml:space="preserve">
          <source>Typed expression splices: the same wildcards as in (untyped) expression splices are supported.</source>
          <target state="translated">유형이 지정된 표현식 스플 라이스 : 유형이 지정되지 않은 표현식 스플 라이스와 동일한 와일드 카드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c10bf0f7958e4932169a9efbd5924f628c46f331" translate="yes" xml:space="preserve">
          <source>Typed expressions</source>
          <target state="translated">유형이 지정된 표현식</target>
        </trans-unit>
        <trans-unit id="3e24cfa370c748c1f34054356703adda13ee79c0" translate="yes" xml:space="preserve">
          <source>Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole&amp;rsquo;s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</source>
          <target state="translated">유형이 지정된 구멍은 GHC의 기능으로 밑줄 (예 : &quot; &lt;code&gt;_&lt;/code&gt; &quot;, &quot; &lt;code&gt;_foo&lt;/code&gt; &quot;, &quot; &lt;code&gt;_bar&lt;/code&gt; &quot;)로 작성된 특수 자리 표시자를 표현식으로 사용할 수 있습니다. 컴파일하는 동안 이러한 구멍은 구멍 위치에 어떤 유형이 예상되는지, 자유 유형 변수의 원점에 대한 정보 및 구멍을 채우는 데 도움이되는 로컬 바인딩 목록 및 유형에 맞는 범위의 바인딩을 설명하는 오류 메시지를 생성합니다. 실제 코드로 구멍을 채우는 데 도움이 될 수 있습니다. 타입 홀은 GHC에서 항상 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a56497f57a4c65ed19388200c5c29fe14b9f29e1" translate="yes" xml:space="preserve">
          <source>Types and functions for UTC and UT1</source>
          <target state="translated">UTC 및 UT1의 유형 및 함수</target>
        </trans-unit>
        <trans-unit id="7005254a2a8a6ae56b5da2106d2a7390dfa74f52" translate="yes" xml:space="preserve">
          <source>Types and functions for dealing with encoding and decoding errors in Unicode text.</source>
          <target state="translated">유니 코드 텍스트의 인코딩 및 디코딩 오류를 처리하기위한 유형 및 기능</target>
        </trans-unit>
        <trans-unit id="a2c52d7c6cf4bc87e6f29125e9f05a6c3ab0de78" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;GHC&lt;/em&gt;Runtime/Interpreter.hs</source>
          <target state="translated">원격 GHCi에서 원격 개체를 참조하기위한 유형입니다. 자세한 내용은 컴파일러 &lt;em&gt;GHC&lt;/em&gt; Runtime / Interpreter.hs의 참고 [외부 GHCi 포인터]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5fa0ad82cb92df6a78d9d90490a6174d9700473" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs</source>
          <target state="translated">리모트 GHCi에서 리모트 오브젝트를 참조하기위한 유형. 자세한 내용은 컴파일러 &lt;em&gt;ghci&lt;/em&gt; GHCi.hs의 참고 [외부 GHCi 포인터]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5580e68a19fcd07f6f63b4ef4e2909db886ab488" translate="yes" xml:space="preserve">
          <source>Types for specifying how text encoding/decoding fails</source>
          <target state="translated">텍스트 인코딩 / 디코딩 실패 방법을 지정하는 유형</target>
        </trans-unit>
        <trans-unit id="7cbee61c2faa6400b77721042e85c6886eb1b3e4" translate="yes" xml:space="preserve">
          <source>Types of I/O error</source>
          <target state="translated">I / O 오류의 종류</target>
        </trans-unit>
        <trans-unit id="f0320286a762dea4d157070a0b18d0bf262e2900" translate="yes" xml:space="preserve">
          <source>Types, and class constraints, can be written infix. For example</source>
          <target state="translated">유형과 클래스 제약 조건은 접두사로 쓸 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="244a23d239a744b67869603db5aa7a8a108d006d" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2b54a022fd50a70fd5342e23351e38dc98cf9e0" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용 : &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f47fb4e5fc6ce9d393da5169defdd4830664a47" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.15.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용 : &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.15.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6125766e1667a0dc730d60edd60595e68e0998" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f931421ae1bb4e608cfffd3d56162d588a8834" translate="yes" xml:space="preserve">
          <source>Typically GHCi will show only the number of modules that it loaded after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command. With this flag, GHC will also list the loaded modules&amp;rsquo; names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</source>
          <target state="translated">일반적으로 GHCi는 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 후에로드 한 모듈 수만 표시합니다 . 이 플래그를 사용하면 GHC는로드 된 모듈의 이름도 나열합니다. 이것은 GHC 8.2.1 이전의 기본 동작이며 일부 툴링 사용자에게 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbc4cfc97456201bcbb7c532592eda4f36c7e91c" translate="yes" xml:space="preserve">
          <source>Typically this &lt;code&gt;GSerialize&lt;/code&gt; class will not be exported, as it only makes sense to have instances for the representation types.</source>
          <target state="translated">일반적으로이 &lt;code&gt;GSerialize&lt;/code&gt; 클래스는 표현 유형에 대한 인스턴스 만 갖는 것이 적합하므로 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72dcc23bd7878a3f40b67b09ecb95c71f87fb8c1" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 자체를 입력 하면 현재 정의 된 매크로가 나열됩니다. &lt;code&gt;:def!&lt;/code&gt; 가 아니면 기존 명령 이름을 재정의하려고하면 오류가 발생합니다 . form이 사용되며,이 경우 해당 이름의 이전 명령을 자동으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="03049aa8714feb7c10314b4dd7463192a8695411" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 를 입력 하면 현재 정의 된 매크로가 나열됩니다. 기존 명령 이름을 재정의하려고하면 &lt;code&gt;:def!&lt;/code&gt; 이 경우 해당 이름의 이전 명령을 자동으로 덮어 씁니다. 그러나 내장 명령의 경우 명령 이름 앞에 이중 콜론 (예 : &lt;code&gt;::load&lt;/code&gt; )을 추가 하여 이전 명령을 계속 사용할 수 있습니다 . &lt;code&gt;:{&lt;/code&gt; , &lt;code&gt;:}&lt;/code&gt; 및 &lt;code&gt;:!&lt;/code&gt; 명령을 재정의 할 수 없습니다 . .</target>
        </trans-unit>
        <trans-unit id="a6e5374291987ed29812b27d3b5a192b78251690" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceeding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 를 입력 하면 현재 정의 된 매크로가 나열됩니다. 기존 명령 이름을 재정의하려고하면 &lt;code&gt;:def!&lt;/code&gt; 이 경우 해당 이름을 가진 이전 명령을 자동으로 덮어 씁니다. 그러나 내장 명령의 경우 명령 이름 앞에 이중 콜론 (예 : &lt;code&gt;::load&lt;/code&gt; )을 추가 하여 이전 명령을 계속 사용할 수 있습니다 . &lt;code&gt;:{&lt;/code&gt; , &lt;code&gt;:}&lt;/code&gt; 및 &lt;code&gt;:!&lt;/code&gt; 명령을 재정의 할 수 없습니다 . .</target>
        </trans-unit>
        <trans-unit id="1a380e5db1ec24a6a91d28381a66d5665dba31c2" translate="yes" xml:space="preserve">
          <source>Typing: If ⟨exp⟩ has type ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩.</source>
          <target state="translated">입력 : ⟨exp⟩ 유형이 ⟨T1⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩이고 ⟨pat⟩가 ⟨T2⟩와 일치하면 전체보기 패턴이 ⟨T1⟩과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="24b302f5a735a69a8b9ba233ec702fe31fd00c63" translate="yes" xml:space="preserve">
          <source>U1</source>
          <target state="translated">U1</target>
        </trans-unit>
        <trans-unit id="a8d7fd6a76417ab647f8d8fa5c07399d3b79ee63" translate="yes" xml:space="preserve">
          <source>UAddr</source>
          <target state="translated">UAddr</target>
        </trans-unit>
        <trans-unit id="78ab6083abe9df189496de94a58ccb0d4eb4a56f" translate="yes" xml:space="preserve">
          <source>UArray</source>
          <target state="translated">UArray</target>
        </trans-unit>
        <trans-unit id="7f21fdd64775282d97bf00c9ca8e8405b807e74b" translate="yes" xml:space="preserve">
          <source>UCHAR</source>
          <target state="translated">UCHAR</target>
        </trans-unit>
        <trans-unit id="8b101f49d46272e31b5ba7171610ec3d6c1e2b54" translate="yes" xml:space="preserve">
          <source>UChar</source>
          <target state="translated">UChar</target>
        </trans-unit>
        <trans-unit id="43946f1efc1b2a75244305a241b3665d50475303" translate="yes" xml:space="preserve">
          <source>UDouble</source>
          <target state="translated">UDouble</target>
        </trans-unit>
        <trans-unit id="3edc70483a381cca079dc023cf3096fe6750a38b" translate="yes" xml:space="preserve">
          <source>UFloat</source>
          <target state="translated">UFloat</target>
        </trans-unit>
        <trans-unit id="c710015e919de9398203f722f1db05a3c86586b2" translate="yes" xml:space="preserve">
          <source>UINT</source>
          <target state="translated">UINT</target>
        </trans-unit>
        <trans-unit id="db37a94db2ae5203a3708accea85d32d3c958e7e" translate="yes" xml:space="preserve">
          <source>UINT32</source>
          <target state="translated">UINT32</target>
        </trans-unit>
        <trans-unit id="3f2f073dc8e5d6347e3222fc44f034ebea308d84" translate="yes" xml:space="preserve">
          <source>UINT64</source>
          <target state="translated">UINT64</target>
        </trans-unit>
        <trans-unit id="ff85ccc79dc26d56bd24e1879eed03562a6fc6b4" translate="yes" xml:space="preserve">
          <source>UINT_PTR</source>
          <target state="translated">UINT_PTR</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="97a5a303674f079e7149593fff8ef1e3e8389241" translate="yes" xml:space="preserve">
          <source>ULONG</source>
          <target state="translated">ULONG</target>
        </trans-unit>
        <trans-unit id="d2cf8ae8cc99c4b7100d4b971ec75a50e14fda1e" translate="yes" xml:space="preserve">
          <source>ULONG32</source>
          <target state="translated">ULONG32</target>
        </trans-unit>
        <trans-unit id="2d38af495bc94e414019aaafb693e22712716988" translate="yes" xml:space="preserve">
          <source>ULONG64</source>
          <target state="translated">ULONG64</target>
        </trans-unit>
        <trans-unit id="172d0f1733b4b4e189ef0a8bd989c1df79a0a4ad" translate="yes" xml:space="preserve">
          <source>ULONG_PTR</source>
          <target state="translated">ULONG_PTR</target>
        </trans-unit>
        <trans-unit id="92f8d734a054faa5854ec44e1923ff5867ef42ae" translate="yes" xml:space="preserve">
          <source>UNIX-style formatting</source>
          <target state="translated">유닉스 스타일 포맷</target>
        </trans-unit>
        <trans-unit id="2eb5e103de68431585f421ef220db04767f7ba61" translate="yes" xml:space="preserve">
          <source>UNIX-style parsing</source>
          <target state="translated">유닉스 스타일 파싱</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="95694b86c9d37ae5849026b15800b16e458b0df0" translate="yes" xml:space="preserve">
          <source>URec</source>
          <target state="translated">URec</target>
        </trans-unit>
        <trans-unit id="77b169462df86e1c5aedf20d7b1a20e282333aa5" translate="yes" xml:space="preserve">
          <source>USERPROFILE environment variable.</source>
          <target state="translated">USERPROFILE 환경 변수.</target>
        </trans-unit>
        <trans-unit id="63e558d691ebae5862cec7aa8ac03ad3a1478cfc" translate="yes" xml:space="preserve">
          <source>USHORT</source>
          <target state="translated">USHORT</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="4cb9de204b5c73618b7be72527d84e114cc9d671" translate="yes" xml:space="preserve">
          <source>UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as &quot;leap seconds&quot;. These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.</source>
          <target state="translated">UTC는 시계로 측정 한 시간으로 &quot;도약 초&quot;라고하는 가끔씩 초를 추가하거나 제거하여 지구와 보조를 맞추도록 수정되었습니다. 이러한 수정 사항은 예측할 수 없으며 6 개월 전에 통지합니다. 이 수정 프로그램으로 컴파일 된 프로그램은 6 개월 후에 만료 될 수 있으므로 이러한 수정 사항에 대한 표는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f8fd2ae6171d356d37592b428a7472153ac6c7c" translate="yes" xml:space="preserve">
          <source>UTCTime</source>
          <target state="translated">UTCTime</target>
        </trans-unit>
        <trans-unit id="16faea8ad3a55af18ec4c289c3edcd975c20d0b8" translate="yes" xml:space="preserve">
          <source>UTF-16 (as used on Windows systems).</source>
          <target state="translated">UTF-16 (Windows 시스템에서 사용).</target>
        </trans-unit>
        <trans-unit id="4c077f1764058778dde0d28028b1640ee7c397ac" translate="yes" xml:space="preserve">
          <source>UTF-16 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-16 코덱</target>
        </trans-unit>
        <trans-unit id="5665eacf0693e62a4f7712f2e963fa3cb8bca4ae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16 서로 게이트 코드 포인트는 유니 코드 스칼라 값 세트에 포함되지 않지만 불행히도 Haskell에 의해 유효한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값으로 인정됩니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 이 함수는 해당 코드 포인트를 유니 코드 대체 문자 (U + FFFD, '')로 다시 매핑하고 다른 코드 포인트는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62cdcaea7e563aff141140dcd64fe723c057ad8d" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16 대리 코드 포인트는 유니 코드 스칼라 값 집합에 포함되지 않지만 안타깝게도 Haskell에서 유효한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값으로 인정합니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 이 함수는 해당 코드 포인트를 유니 코드 대체 문자 (U + FFFD, ' ')로 다시 매핑하고 다른 코드 포인트는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f5128ce869af750fe326f9013d7f2423f34ccae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16 대리 코드 포인트는 유니 코드 스칼라 값 집합에 포함되지 않지만 안타깝게도 Haskell에서 유효한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값으로 인정합니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 이 함수는 해당 코드 포인트를 유니 코드 대체 문자 (U + FFFD, ' ')로 다시 매핑하고 다른 코드 포인트는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d917769493a54382b65e50b279329a9344690b1" translate="yes" xml:space="preserve">
          <source>UTF-32 (the C compiler defines &lt;code&gt;201605L&lt;/code&gt;), or</source>
          <target state="translated">UTF-32 (C 컴파일러는 &lt;code&gt;201605L&lt;/code&gt; 을 정의 함 ) 또는</target>
        </trans-unit>
        <trans-unit id="854e15ff4be42fae1ff8c7fb8c10cdc2c177ba36" translate="yes" xml:space="preserve">
          <source>UTF-32 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-32 코덱</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="37a41f96a793664e92dc44b397d82e864c6bbd46" translate="yes" xml:space="preserve">
          <source>UTF-8 Codec for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-8 코덱</target>
        </trans-unit>
        <trans-unit id="8d41e6620a06998e7e74776be3a2672ad12aaa66" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e6476e4ebd7d465ca35fd2bf19d6fbce5908bd12" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a7eb34db31e9392459f63eb077bb3f212ab1af60" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="f0c0cd4179d49f23f7a3bf2bc61e8abbec66b800" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a56714f6e98c5c1a765732fe18ea00295cc6fbfa" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="dae2c4b8b30ebe563e4e1fec9abe5214e0622a59" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e66eae2fc6a96a1729848d37d9b93a495e2b1958" translate="yes" xml:space="preserve">
          <source>UWord</source>
          <target state="translated">UWord</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">단항 부정.</target>
        </trans-unit>
        <trans-unit id="87c537c6f19502c79261326e0bcf549009e63301" translate="yes" xml:space="preserve">
          <source>Unary negation. Since the negative &lt;code&gt;Int#&lt;/code&gt; range extends one further than the positive range, &lt;code&gt;negateInt#&lt;/code&gt; of the most negative number is an identity operation. This way, &lt;code&gt;negateInt#&lt;/code&gt; is always its own inverse.</source>
          <target state="translated">단항 부정. 음의 &lt;code&gt;Int#&lt;/code&gt; 범위는 양의 범위보다 하나 더 확장 되므로 가장 음수 인 &lt;code&gt;negateInt#&lt;/code&gt; 는 항등 연산입니다. 이런 식으로 &lt;code&gt;negateInt#&lt;/code&gt; 는 항상 자체 역수입니다.</target>
        </trans-unit>
        <trans-unit id="2df091d96696a6761fe09148bfdbcee91a798d7d" translate="yes" xml:space="preserve">
          <source>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in &lt;em&gt;patterns&lt;/em&gt; cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.)</source>
          <target state="translated">식에 사용 된 언 바운드 데이터 생성자는 위와 동일하게 동작합니다. 그러나 &lt;em&gt;패턴에&lt;/em&gt; 사용 된 바인딩되지 않은 데이터 생성자 는 지연 될 수 없으며 대신 컴파일을 중단합니다. (구현 용어에서는 유형 검사기 대신 이름 바꾸기 프로그램에 의해보고됩니다.)</target>
        </trans-unit>
        <trans-unit id="9049099bd1356e2b34f95b9747b190e51f0a36b0" translate="yes" xml:space="preserve">
          <source>Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</source>
          <target state="translated">이름이 같은 언 바운드 식별자는 동일한 기능 내에서도 통합되지 않지만 개별적으로 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f1627f59b22afb759acb35503f6337e9c4c895a" translate="yes" xml:space="preserve">
          <source>Unbounded channels.</source>
          <target state="translated">무제한 채널.</target>
        </trans-unit>
        <trans-unit id="d03b993f9203e9dae9e61b362f008be4381a648e" translate="yes" xml:space="preserve">
          <source>Unboxed arrays</source>
          <target state="translated">박스형 배열</target>
        </trans-unit>
        <trans-unit id="56cb77471192863f11d27c2de3b8fa29f43e70b1" translate="yes" xml:space="preserve">
          <source>Unboxed immutable arrays.</source>
          <target state="translated">박스형 불변 배열.</target>
        </trans-unit>
        <trans-unit id="2aa04c668d583672e063948de2c1a768fe11553b" translate="yes" xml:space="preserve">
          <source>Unboxed representation types</source>
          <target state="translated">박스형 표현 유형</target>
        </trans-unit>
        <trans-unit id="dd649dca9ccfcb0236fe154a419fdf07086a983b" translate="yes" xml:space="preserve">
          <source>Unboxed sum data constructor</source>
          <target state="translated">박스형 합계 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="97a10e27338aec3a003f59edcf6ef410c80641a0" translate="yes" xml:space="preserve">
          <source>Unboxed sum type constructor</source>
          <target state="translated">박스형 합계 유형 생성자</target>
        </trans-unit>
        <trans-unit id="24fca97998eebced6e5644295e7a0d139f93456e" translate="yes" xml:space="preserve">
          <source>Unboxed sums are &amp;ldquo;unboxed&amp;rdquo; in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These &amp;ldquo;components&amp;rdquo; depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</source>
          <target state="translated">Unboxed sum은 힙에 sum을 할당하고 포인터로 값을 나타내는 대신 unboxed tuple과 같이 구성 요소로 표시된다는 의미에서&amp;ldquo;unboxed&amp;rdquo;입니다. 이러한&amp;ldquo;구성 요소&amp;rdquo;는 합계 유형의 대안에 따라 다릅니다. 박스형 튜플과 같이 박스형 합계는 리프팅 된 구성 요소에 게으르다.</target>
        </trans-unit>
        <trans-unit id="da43c5db4c48a2614146aab275d3c450e7579b03" translate="yes" xml:space="preserve">
          <source>Unboxed tuple data constructor</source>
          <target state="translated">박스형 튜플 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="4b0c75d87c461fd4cbfd4b9516e3165c420899ff" translate="yes" xml:space="preserve">
          <source>Unboxed tuple type constructor</source>
          <target state="translated">박스형 튜플 타입 생성자</target>
        </trans-unit>
        <trans-unit id="39c7cca5b4d7f980a01917a1438349d9ea99ed9b" translate="yes" xml:space="preserve">
          <source>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in &lt;code&gt;primops.txt.pp&lt;/code&gt; return unboxed tuples. In particular, the &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt; monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</source>
          <target state="translated">박스형 튜플은 여러 값을 반환해야하는 함수에 사용되지만 일반적으로 본격적인 튜플 사용과 관련된 힙 할당을 피합니다. 박스형 튜플이 반환되면 구성 요소는 레지스터 나 스택에 직접 저장됩니다. 박스형 튜플 자체에는 합성 표현이 없습니다. &lt;code&gt;primops.txt.pp&lt;/code&gt; 에 나열된 많은 기본 작업은 상자가 없는 튜플을 반환합니다. 특히, &lt;code&gt;IO&lt;/code&gt; 및 &lt;code&gt;ST&lt;/code&gt; 모나드는 작동 순서 동안 불필요한 할당을 피하기 위해 상자없는 튜플을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ed095a67c7dac513f9801658e42edf86f068e20a" translate="yes" xml:space="preserve">
          <source>Unboxed tuples aren&amp;rsquo;t really exported by &lt;code&gt;GHC.Exts&lt;/code&gt;; they are a syntactic extension (&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;). An unboxed tuple looks like this:</source>
          <target state="translated">Unboxed 튜플은 실제로 &lt;code&gt;GHC.Exts&lt;/code&gt; ; 그것들은 구문 확장 ( &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; )입니다. 박스형 튜플은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="6dc6698adabda63cc8b5a7e3cdf7aebe0aa330c8" translate="yes" xml:space="preserve">
          <source>Unboxed tuples can be used for multi-arity alternatives. For example:</source>
          <target state="translated">박스형 튜플은 다중 대치 대안에 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aaf4cf051bde1d4837c0c90f8d330d3debcebecb" translate="yes" xml:space="preserve">
          <source>Unboxed types correspond to the &amp;ldquo;raw machine&amp;rdquo; types you would use in C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *), etc. The &lt;em&gt;primitive operations&lt;/em&gt; (PrimOps) on these types are what you might expect; e.g., &lt;code&gt;(+#)&lt;/code&gt; is addition on &lt;code&gt;Int#&lt;/code&gt;s, and is the machine-addition that we all know and love&amp;mdash;usually one instruction.</source>
          <target state="translated">박스형 유형은 C에서 사용하는 &quot;원시 기계&quot;유형에 해당합니다. &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *) 등 이러한 유형 의 &lt;em&gt;기본 작업&lt;/em&gt; (PrimOps)은 다음과 같습니다. 기대할 수 있습니다. 예를 들어, &lt;code&gt;(+#)&lt;/code&gt; 은 &lt;code&gt;Int#&lt;/code&gt; s 에 추가 된 것으로서, 우리 모두가 알고 사랑하는 기계 추가 (일반적으로 하나의 명령)입니다.</target>
        </trans-unit>
        <trans-unit id="94297f2cb5d15e87f00e136087b5e28e1ec12634" translate="yes" xml:space="preserve">
          <source>UnboxedSums</source>
          <target state="translated">UnboxedSums</target>
        </trans-unit>
        <trans-unit id="7c1b45d712d0b6864323ebefc5430714cce43006" translate="yes" xml:space="preserve">
          <source>UnboxedTuples</source>
          <target state="translated">UnboxedTuples</target>
        </trans-unit>
        <trans-unit id="1c00c43be5ef32bb2c58214859766bddcb001ee1" translate="yes" xml:space="preserve">
          <source>Unchecked access</source>
          <target state="translated">확인되지 않은 액세스</target>
        </trans-unit>
        <trans-unit id="94184bea267f4505d495b4d4d6947698b708d718" translate="yes" xml:space="preserve">
          <source>Unchecked floating-point arithmetic</source>
          <target state="translated">확인되지 않은 부동 소수점 산술</target>
        </trans-unit>
        <trans-unit id="5a7ea60a6f45e07dcb8218b1e7485ce758f557f0" translate="yes" xml:space="preserve">
          <source>Unchecked read of an immutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">불변 배열의 확인되지 않은 읽기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b2a1b6fe721a10cd0610eba2242b579bad0bb5f" translate="yes" xml:space="preserve">
          <source>Unchecked write of a mutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">변경 가능한 배열의 확인되지 않은 쓰기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cc6f93ca7453c5d92325af29e3d26b1dae45e7" translate="yes" xml:space="preserve">
          <source>Unclutter the list of valid hole fits by not showing provenance nor type applications of suggestions.</source>
          <target state="translated">제안의 유형이나 응용 프로그램을 표시하지 않음으로써 유효한 구멍 맞춤 목록을 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="92d9913ec326ea74caabbca08223befd12ff0d41" translate="yes" xml:space="preserve">
          <source>UndecidableInstances</source>
          <target state="translated">UndecidableInstances</target>
        </trans-unit>
        <trans-unit id="dcba899dfe07dc0580f1fd4d4e2b04b64512a67c" translate="yes" xml:space="preserve">
          <source>UndecidableSuperClasses</source>
          <target state="translated">UndecidableSuperClasses</target>
        </trans-unit>
        <trans-unit id="524a80e3cff00c5e0580dc9263ab4a88165efc16" translate="yes" xml:space="preserve">
          <source>Undefine a symbol in the C pre-processor</source>
          <target state="translated">C 전 처리기에서 기호 정의</target>
        </trans-unit>
        <trans-unit id="d43a17d536b34a95ec352c02a0e1fa2bfac08b1a" translate="yes" xml:space="preserve">
          <source>Undefine macro ⟨symbol⟩ in the usual way.</source>
          <target state="translated">일반적인 방법으로 매크로 &quot;기호&quot;를 정의하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cc16de424326616c4ed48a51f05170fb404dcb0e" translate="yes" xml:space="preserve">
          <source>Undefines the user-defined command ⟨name⟩ (see &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; above).</source>
          <target state="translated">사용자 정의 명령 ⟨name⟩을 정의 해제하십시오 ( 위의 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="739d95b825e4aa989aff734d85f2e64f070e8d07" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt;, negated literals are desugared without &lt;code&gt;negate&lt;/code&gt;. That is, &lt;code&gt;-123&lt;/code&gt; stands for &lt;code&gt;fromInteger (-123)&lt;/code&gt; rather than &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. This makes &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt; a valid replacement for &lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; &lt;/a&gt; , 부정 리터럴없이 desugared된다 &lt;code&gt;negate&lt;/code&gt; . 즉, &lt;code&gt;-123&lt;/code&gt; 은 &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; 아니라 &lt;code&gt;fromInteger (-123)&lt;/code&gt; 를 나타냅니다 . 따라서 &lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; &lt;/a&gt; 의 유효한 대체품이됩니다 .</target>
        </trans-unit>
        <trans-unit id="548a3041dcf33dfa2cebed472eb6cc52a0efe3ba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 같은 식 수단이 있다는 &lt;code&gt;Either * Char&lt;/code&gt; 로 파싱 &lt;code&gt;Either (*) Char&lt;/code&gt; 아닌 &lt;code&gt;(*) Either Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9357dbe3d4862458ad80f085c14206fe2d8eac4b" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;-XStarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;-XStarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 이는 &lt;code&gt;Either * Char&lt;/code&gt; 와 같은 표현식이 &lt;code&gt;(*) Either Char&lt;/code&gt; 아닌 &lt;code&gt;Either (*) Char&lt;/code&gt; 로 구문 분석 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6c0d27dce34085e806931a10af8a883394beb69a" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 같은 식 수단이 있다는 &lt;code&gt;Either * Char&lt;/code&gt; 로 파싱 &lt;code&gt;Either (*) Char&lt;/code&gt; 아닌 &lt;code&gt;(*) Either Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83acc7e2fcd190b9029f0366e2b5f34e8c87d524" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries /do not support/ locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서는 시스템 I / O 라이브러리가 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="45aadb84db37059cb048a3619c050dc25846d7f8" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries do not support locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서는 시스템 I / O 라이브러리가 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="6a35d752fd9cbd386bd76776c4f13c497a1eeb9e" translate="yes" xml:space="preserve">
          <source>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</source>
          <target state="translated">GHC에서 다시 쓰기 규칙은 중단 (==)을 특수한 breakByte에 대한 호출로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b507369e223691105dbfe5a381bf76a0cf2dc2da" translate="yes" xml:space="preserve">
          <source>Under Mac OS X debug information is kept apart from the executable. After compiling the executable you&amp;rsquo;ll need to use the &lt;code&gt;dsymutil&lt;/code&gt; utility to extract the debugging information and place them in the debug archive,</source>
          <target state="translated">Mac OS X에서는 디버그 정보가 실행 파일과 떨어져 있습니다. 실행 파일을 컴파일 한 후 &lt;code&gt;dsymutil&lt;/code&gt; 유틸리티를 사용하여 디버깅 정보를 추출하여 디버그 아카이브에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9448e4f1f1bc1a4848bdf810185f068342adf0" translate="yes" xml:space="preserve">
          <source>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</source>
          <target state="translated">대부분의 상황에서 독립 실행 형 파생을 사용하여 생성자가 모두 범위에 속하지 않는 데이터 유형에 대한 인스턴스를 작성할 수는 없습니다. 파생 된 인스턴스가 배후에서 생성자를 사용하는 코드를 생성하기 때문에 추상화가 중단되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="befde3cad169af590a27942ec587ed85bf818337" translate="yes" xml:space="preserve">
          <source>Underflow</source>
          <target state="translated">Underflow</target>
        </trans-unit>
        <trans-unit id="73d89b3a81eb250a4b44258aed0e8fed46b29f5a" translate="yes" xml:space="preserve">
          <source>Underlying monadic value</source>
          <target state="translated">기본 모나드 값</target>
        </trans-unit>
        <trans-unit id="c982cc09160648fab8b183af5c0c2149ea73000b" translate="yes" xml:space="preserve">
          <source>Underlying untyped Template Haskell expression</source>
          <target state="translated">기본 형식이 지정되지 않은 템플릿 Haskell 표현식</target>
        </trans-unit>
        <trans-unit id="c21c7d09d002fd765aab0ed41ec3c61f09c3bb52" translate="yes" xml:space="preserve">
          <source>Unfolding</source>
          <target state="translated">Unfolding</target>
        </trans-unit>
        <trans-unit id="a400d187aefff9554f2dba096d918bdfffe6746c" translate="yes" xml:space="preserve">
          <source>Unfolding ByteStrings</source>
          <target state="translated">ByteString 펼치기</target>
        </trans-unit>
        <trans-unit id="27df4ee6ad39c049fab42c4d04ccfca737a63344" translate="yes" xml:space="preserve">
          <source>Unfolding constructor applications</source>
          <target state="translated">생성자 응용 프로그램 펼치기</target>
        </trans-unit>
        <trans-unit id="d3b9185e6a4c71709e29813b48ffdc7956f41b7a" translate="yes" xml:space="preserve">
          <source>Unfortunately DWARF isn&amp;rsquo;t expressive enough to fully describe the code that GHC produces. This is most apparent in the case of line information, where GHC is forced to choose some between a variety of possible originating source locations. This limits the usefulness of DWARF information with traditional statistical profiling tools. For profiling it is recommended that one use the extended debugging information. See the &lt;em&gt;Profiling&lt;/em&gt; section below.</source>
          <target state="translated">불행히도 DWARF는 GHC가 생성하는 코드를 완전히 설명하기에 충분하지 않습니다. 이것은 라인 정보의 경우에 가장 분명합니다. GHC는 다양한 가능한 소스 위치 중에서 일부를 선택해야합니다. 이는 기존 통계 프로파일 링 도구로 DWARF 정보의 유용성을 제한합니다. 프로파일 링을 위해서는 확장 된 디버깅 정보를 사용하는 것이 좋습니다. 아래의 &lt;em&gt;프로파일 링&lt;/em&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6af016495fc0911fc823f78e0cef0cecf47d4281" translate="yes" xml:space="preserve">
          <source>Unfortunately not. We haven&amp;rsquo;t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</source>
          <target state="translated">불행히도. 아직 구현하지 않았습니다. GHCi에로드하기 전에 문제가있는 모듈을 직접 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fc2ac28fcbb9012b214aa245e8b7f0b3808aac" translate="yes" xml:space="preserve">
          <source>Uni</source>
          <target state="translated">Uni</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="a1d3d5a32e8c988012ad8507f17107abf2db03c5" translate="yes" xml:space="preserve">
          <source>Unicode General Categories (column 2 of the UnicodeData table) in the order they are listed in the Unicode standard (the Unicode Character Database, in particular).</source>
          <target state="translated">유니 코드 표준 범주 (UnicodeData 테이블의 열 2)는 유니 코드 표준 (특히 유니 코드 문자 데이터베이스)에 나열된 순서대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b1cd569a3121684aa423894fbcbdf345cc5b88e" translate="yes" xml:space="preserve">
          <source>Unicode Roman numerals are &quot;numbers&quot; as well:</source>
          <target state="translated">유니 코드 로마 숫자도 &quot;숫자&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="97fd6e9e895c72b521ac2e308c742d79b142fbcd" translate="yes" xml:space="preserve">
          <source>Unicode alternative</source>
          <target state="translated">유니 코드 대안</target>
        </trans-unit>
        <trans-unit id="a65c9d80435c08abe776fbae85509e93cf7c4cbf" translate="yes" xml:space="preserve">
          <source>Unicode characters are divided into letters, numbers, marks, punctuation, symbols, separators (including spaces) and others (including control characters).</source>
          <target state="translated">유니 코드 문자는 문자, 숫자, 표시, 문장 부호, 기호, 구분 기호 (공백 포함) 및 기타 (제어 문자 포함)로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb07603277143928d306b764aee2aa5fcca7a63" translate="yes" xml:space="preserve">
          <source>Unicode encoding/decoding</source>
          <target state="translated">유니 코드 인코딩 / 디코딩</target>
        </trans-unit>
        <trans-unit id="f9e742f9d39fd05cf65c9f6a96d4c36b5ffd45b2" translate="yes" xml:space="preserve">
          <source>Unicode encodings</source>
          <target state="translated">유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="1d3197d948b5d54120c87a9dc026e98f7afb2329" translate="yes" xml:space="preserve">
          <source>Unicode general categories</source>
          <target state="translated">유니 코드 일반 범주</target>
        </trans-unit>
        <trans-unit id="b3471a7cade0200813e7f5a65bfc13c08a37abb4" translate="yes" xml:space="preserve">
          <source>UnicodeException</source>
          <target state="translated">UnicodeException</target>
        </trans-unit>
        <trans-unit id="28994769bba962bb066d22d1fcd75c46baf1f910" translate="yes" xml:space="preserve">
          <source>UnicodeSubsetBitfield</source>
          <target state="translated">UnicodeSubsetBitfield</target>
        </trans-unit>
        <trans-unit id="416bfa34f2ec7dc6a0e57308141fdf8712f09250" translate="yes" xml:space="preserve">
          <source>UnicodeSyntax</source>
          <target state="translated">UnicodeSyntax</target>
        </trans-unit>
        <trans-unit id="9d591225a789a1e2dd25c12959566ecdbe116b67" translate="yes" xml:space="preserve">
          <source>Unidir</source>
          <target state="translated">Unidir</target>
        </trans-unit>
        <trans-unit id="21d169e1e1ba8ff5f3db678f5a3a331dbf85a922" translate="yes" xml:space="preserve">
          <source>Unidirectional</source>
          <target state="translated">Unidirectional</target>
        </trans-unit>
        <trans-unit id="857d540c20885058e9036f20ddbdbb0f3967a8b4" translate="yes" xml:space="preserve">
          <source>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</source>
          <target state="translated">단방향 동의어는 패턴 컨텍스트에서만 사용할 수 있으며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d9701d585a57c337e54ac1677953d5a0ec923f" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original output history on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​출력 기록으로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="79444c001b62604780520e1d8cc531b07ad38937" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original state on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​상태로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="f92d78e3b22bfa68fdbc9865cf302e8784a6ed59" translate="yes" xml:space="preserve">
          <source>Uninhabited data type</source>
          <target state="translated">무인 데이터 유형</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="5cb05b9c841af29c6d7076675127c6f1751b1611" translate="yes" xml:space="preserve">
          <source>Uniq</source>
          <target state="translated">Uniq</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="6740271407e0346633d83d694dccd887dc851ab1" translate="yes" xml:space="preserve">
          <source>Unique index for datatype constructors, counting from 1 in the order they are given in the program text.</source>
          <target state="translated">프로그램 텍스트에 지정된 순서대로 1부터 계산하여 데이터 유형 생성자를위한 고유 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="0cdacf36b6c56119b440b93ba791e8060793975b" translate="yes" xml:space="preserve">
          <source>Unique objects</source>
          <target state="translated">독특한 개체</target>
        </trans-unit>
        <trans-unit id="e9681f3eecc02057c1930f3e437fac4c4dc0a528" translate="yes" xml:space="preserve">
          <source>Unit: used for constructors without arguments</source>
          <target state="translated">단위 : 인수가없는 생성자에 사용</target>
        </trans-unit>
        <trans-unit id="e5c5ea9f2e8d47273274318044fa87be4d1553ac" translate="yes" xml:space="preserve">
          <source>Universal Time</source>
          <target state="translated">세계시</target>
        </trans-unit>
        <trans-unit id="3ccc8ae980014996c3ba2b246d1968e7182cd21b" translate="yes" xml:space="preserve">
          <source>Universal combining function</source>
          <target state="translated">범용 결합 기능</target>
        </trans-unit>
        <trans-unit id="9b649bd37c2b26f2b1eea5d886435ad1639c3dcd" translate="yes" xml:space="preserve">
          <source>UniversalTime</source>
          <target state="translated">UniversalTime</target>
        </trans-unit>
        <trans-unit id="3188f36c5a9baab0220303d08a37a90ed3c179ef" translate="yes" xml:space="preserve">
          <source>Unix systems</source>
          <target state="translated">유닉스 시스템</target>
        </trans-unit>
        <trans-unit id="904813cf231fd43102ff510ba028e64ed13e11f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise documented:</source>
          <target state="translated">달리 문서화되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="8642dfb2a45b656d6cf0f11c976548175dd112cc" translate="yes" xml:space="preserve">
          <source>Unlifted</source>
          <target state="translated">Unlifted</target>
        </trans-unit>
        <trans-unit id="02139489e61ee59e21afe01951fcc0f2d3926eef" translate="yes" xml:space="preserve">
          <source>UnliftedFFITypes</source>
          <target state="translated">UnliftedFFITypes</target>
        </trans-unit>
        <trans-unit id="5b45d2b7d96fbef96a9bc758815c76e0e2e71a5f" translate="yes" xml:space="preserve">
          <source>UnliftedNewtypes</source>
          <target state="translated">UnliftedNewtypes</target>
        </trans-unit>
        <trans-unit id="86de4c205eb285a93150c129623bae5eb391405f" translate="yes" xml:space="preserve">
          <source>UnliftedRep</source>
          <target state="translated">UnliftedRep</target>
        </trans-unit>
        <trans-unit id="05387fc15f74919cf9fdeff901519828076433b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; cannot be used on data types containing a function type on the right-hand side.</source>
          <target state="translated">달리 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 는&lt;/a&gt; 우측 함수 유형을 포함하는 데이터 타입에 이용 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="9ec0ce71b212aa99a2244669feec22e6979c5a4f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is not implied by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</source>
          <target state="translated">달리 &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 암시하지 않습니다 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; . 이 결정의 근거는 용어 레벨 패턴 이름과 달리 유형 이름은 종종 문서화 목적으로 명시 적으로 선택되므로 유형 이름에 밑줄을 사용하면 문서를 읽기가 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9588771c39f566dc9284aa81dce97aa98380c66a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">프로그램을 불완전하게 만들고 평가할 때 오류를 생성하는 &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; 과 달리 형식 서명에 구멍이있을 필요는 없습니다. 형식 검사기는 형식 서명이 있거나없는 바인딩을 형식 검사 할 수 있습니다 (대부분의 경우). 부분 타입 시그니처는 두 극단 사이의 간격을 메우고, 프로그래머는 어떤 유형의 부분에 주석을 달고 어떤 부분을 유형 검사기에 남겨 둘지를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b99ca092888b44bba510df4577b6b4d2d84d797" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;typed_holes#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">프로그램을 불완전하게 만들고 평가할 때 오류를 생성하는 &lt;a href=&quot;typed_holes#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; 와는 달리 형식 서명의 구멍에 대해서는 그렇지 않습니다. 유형 검사기는 유형 서명의 유무에 관계없이 바인딩을 유형 검사 할 수 있습니다 (대부분의 경우). 부분 유형 서명은 두 극단 사이의 간격을 메우고, 프로그래머는 유형의 어떤 부분에 주석을 달고 어떤 부분을 유추 할 유형 검사기에 남겨 둘지 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d404ca61d5a715fd529bb048e306eac1275e0be5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</source>
          <target state="translated">&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 와 달리이 옵션으로 인해 패키지 ⟨pkg be가 결과 실행 파일 또는 공유 객체에 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1acefef11c592c3d3f17d3c7be838d89128c3315" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS가 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="897acea06a039f9d84c343986efe70490281cb9e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS가 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="05566e43d5c34bd670cdfbd05fbe866ec3e61186" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS에서 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd4e4ff32086d994ad37eddbf8517bcc52472a7b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, this can be used to retrieve an element without forcing it. For example, to insert the fifth element of a sequence &lt;code&gt;xs&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; at key &lt;code&gt;k&lt;/code&gt;, you could use</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 와 달리 요소를 강제하지 않고 검색하는 데 사용할 수 있습니다. 예를 들어, 시퀀스의 다섯 번째 요소 삽입 &lt;code&gt;xs&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 키에서 &lt;code&gt;k&lt;/code&gt; , 당신은 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89f9aac36a458d5958d7d9a2bc209869dd9e0111" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; type constructors do not map to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;. They are defined directly, as follows:</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 타입 생성자에 매핑되지 않는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; . 다음과 같이 직접 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2e1400b4a387ddd47964b16ed92dc51a65a21d9a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1964f70216a8e1c70dcdc64cbaedc2bf1867ae" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef1eaf78214b10e7045c65146fa5532f8c3f3e14" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 절대 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="255633d21e505289c6e8c6e3a244c4a2c1e30045" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="b6ac906b2e87deb1331972ed52f86a854e2d6b08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="9055ff7794bcb0b3cd85d08c18a0bc07df718029" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INLINE&lt;/code&gt;, it is OK to use an &lt;code&gt;INLINABLE&lt;/code&gt; pragma on a recursive function. The principal reason do to so to allow later use of &lt;code&gt;SPECIALISE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 과 달리 재귀 함수 에는 &lt;code&gt;INLINABLE&lt;/code&gt; pragma 를 사용하는 것이 좋습니다 . &lt;code&gt;SPECIALISE&lt;/code&gt; 나중에 사용할 수 있도록하는 주된 이유</target>
        </trans-unit>
        <trans-unit id="e861e82acc7f14c2da4b67efcccf071159b37de4" translate="yes" xml:space="preserve">
          <source>Unlike C &lt;code&gt;printf(3)&lt;/code&gt;, the formatting of this &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; is driven by the argument type; formatting is type specific. The types formatted by &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;out of the box&quot; are:</source>
          <target state="translated">달리 C에서 &lt;code&gt;printf(3)&lt;/code&gt; 이 본의 서식 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 인수의 형태에 의해 구동된다; 형식은 유형에 따라 다릅니다. 로 포맷 종류 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;상자 밖으로&quot;는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="822d212fad8aaf79fe48fb52b7ebba6d9f068e32" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 GHC는 데이터 유형의 형식을 제한하지 않습니다. 대신 GHC는 단순히 지정된 클래스에 적합한 상용구 코드를 생성하고 유형을 확인합니다. 유형 오류가 있으면 문제입니다. (GHC는 유형 오류가있는 경우 문제 코드를 표시합니다.)</target>
        </trans-unit>
        <trans-unit id="e2d675265d1e9b5ebb6d33cbfd2b5818fa8d06b3" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 선언에 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 인스턴스는 데이터 유형보다 더 구체적 일 수 있습니다 ( &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#instance-rules&quot;&gt;인스턴스 컨텍스트에 대해 완화 된 규칙을&lt;/a&gt; 사용한다고 가정) ). 예를 들어 고려</target>
        </trans-unit>
        <trans-unit id="b63d1a43428a8154e612e52025ecfc75af2b7757" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;instances#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;instances#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 선언에 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 인스턴스는 데이터 유형보다 더 구체적 일 수 있습니다 ( &lt;a href=&quot;instances#instance-rules&quot;&gt;인스턴스 컨텍스트에 대해 &lt;/a&gt;&lt;a href=&quot;instances#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; , Relaxed 규칙 도 사용한다고 가정 ). 예를 들면</target>
        </trans-unit>
        <trans-unit id="e94fcd606b07271129ee53f7579bff16996d2e37" translate="yes" xml:space="preserve">
          <source>Unlike a Haskell-98-style data type declaration, the type variable(s) in the &amp;ldquo;&lt;code&gt;data Set a where&lt;/code&gt;&amp;rdquo; header have no scope. Indeed, one can write a kind signature instead:</source>
          <target state="translated">Haskell-98 스타일 데이터 형식 선언과 달리 &quot; &lt;code&gt;data Set a where&lt;/code&gt; &quot;헤더 의 형식 변수 에는 범위가 없습니다. 실제로, 대신에 친절한 서명을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d15facd9212fb40624ed67a1a3dac71c37d65618" translate="yes" xml:space="preserve">
          <source>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a &lt;em&gt;pattern binding&lt;/em&gt; may only mention type variables that are already in scope. For example:</source>
          <target state="translated">표현식 및 선언 유형 서명과 달리 패턴 유형 서명은 암시 적으로 일반화되지 않습니다. &lt;em&gt;패턴 바인딩&lt;/em&gt; 의 &lt;em&gt;패턴&lt;/em&gt; 은 이미 범위에있는 유형 변수 만 언급 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f7bdadab6da6a387044d423d8a6e43eccb971ac" translate="yes" xml:space="preserve">
          <source>Unlike in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, the instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; refers to &lt;code&gt;encode'&lt;/code&gt;, not &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 과 달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 인스턴스 는 &lt;code&gt;encode'&lt;/code&gt; 가 아니라 &lt;code&gt;encode&lt;/code&gt; '를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a23057942854a08eb5e6d0e2e84f25f90f7394f0" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices of the form &lt;code&gt;$(...)&lt;/code&gt;, declaration quasi-quotes do not cause a declaration group break. See &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;$(...)&lt;/code&gt; 형식의 일반 선언 스플 라이스와 달리 선언 준 따옴표는 선언 그룹을 중단시키지 않습니다. 자세한 정보는 &lt;a href=&quot;#th-syntax&quot;&gt;구문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd0c6a2c2ff514ddc9d128c7471e1ec6efddc93" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by &lt;code&gt;reify&lt;/code&gt; from a declaration quasiquoter will not include anything from the quasiquoter&amp;rsquo;s declaration group.</source>
          <target state="translated">일반적인 선언 스플 라이스와 달리 선언 준 따옴표는 분리되지 않습니다. 이 준표자는 나머지 선언 그룹이 처리되기 전에 확장되고 생성 된 선언은 주변 선언 그룹에 병합됩니다. 따라서, 볼 타입 환경 &lt;code&gt;reify&lt;/code&gt; 선언의 quasiquoter에서이 quasiquoter의 선언 그룹에서 아무것도 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23764803cb059caa49d708a6b67c530ad09e8222" translate="yes" xml:space="preserve">
          <source>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</source>
          <target state="translated">서명 파일에 선언 된 엔터티 만 범위로 가져 오는 다른 선언과 달리 구현의 인스턴스는 서명 파일에서 선언되지 않은 경우에도 항상 범위로 가져옵니다. 이것은 모듈이 서명에 대해서는 타입 검사를 할 수 있지만 일치하는 구현에 대해서는 검사 할 수 없음을 의미합니다. 서명이있는 패키지 내에 고아 인스턴스를 정의하지 않으면 이와 같은 상황을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597c7f9ea0c6e86579770ef9d59523f0d75fb167" translate="yes" xml:space="preserve">
          <source>Unlike other removal functions, this function will also attempt to delete files marked as read-only or otherwise made unremovable due to permissions. As a result, if the removal is incomplete, the permissions or attributes on the remaining files may be altered. If there are hard links in the directory, then permissions on all related hard links may be altered.</source>
          <target state="translated">다른 제거 기능과 달리이 기능은 읽기 전용으로 표시되거나 권한으로 인해 제거 할 수없는 파일을 삭제하려고 시도합니다. 결과적으로 제거가 완료되지 않으면 나머지 파일의 권한 또는 속성이 변경 될 수 있습니다. 디렉토리에 하드 링크가 있으면 모든 관련 하드 링크에 대한 권한이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4457728427c26c787e87ceb48b1b248cdd0cff88" translate="yes" xml:space="preserve">
          <source>Unlike other similarly named functions, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; does not use &lt;code&gt;SearchPath&lt;/code&gt; from the Win32 API. The behavior of this function on Windows is therefore equivalent to those on non-Windows platforms.</source>
          <target state="translated">비슷한 이름의 다른 함수와 달리 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 는 Win32 API의 &lt;code&gt;SearchPath&lt;/code&gt; 를 사용하지 않습니다 . 따라서 Windows에서이 기능의 동작은 Windows 이외의 플랫폼에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06300c11959df3c55eab5253ee8af1fdd51c9a69" translate="yes" xml:space="preserve">
          <source>Unlike regular modules, the defined entities of a signature include not only those written in the local &lt;code&gt;hsig&lt;/code&gt; file, but also those from inherited signatures (as inferred from the &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flags). These entities are not considered in scope when typechecking the local &lt;code&gt;hsig&lt;/code&gt; file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</source>
          <target state="translated">일반 모듈과 달리 서명의 정의 된 엔터티에는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일에 작성된 엔터티 뿐만 아니라 상속 된 서명의 엔터티 도 포함됩니다 ( &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 플래그 에서 유추 ). 이러한 엔티티는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일을 유형 검사 할 때 범위 내에서 고려되지 않지만 서명을 가져 오는 모듈 또는 서명으로 가져올 수 있습니다. 이 규칙의 예외는 아래에 설명 된 내보내기 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b445b71f37755ceafc44164842f3cafdfc51ad7e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">달리 &lt;code&gt;forall&lt;/code&gt; 형태 가변형 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;f&lt;/code&gt; 의 범위를 통해 서명되지 &lt;code&gt;f&lt;/code&gt; 의 식 (S). 패턴 시그니처로 묶인 타입 변수 &lt;code&gt;aa&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 방정식 의 오른쪽에 걸쳐 있습니다. (따라서 구별 유형 변수 사용할 필요가 없다; 사용 &lt;code&gt;a&lt;/code&gt; . 동등한 것)를</target>
        </trans-unit>
        <trans-unit id="b933a24b64cdbef2c38c5866a81b259e2fd9806b" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">달리 &lt;code&gt;forall&lt;/code&gt; 형태 가변형 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;f&lt;/code&gt; 의 범위를 통해 서명되지 &lt;code&gt;f&lt;/code&gt; 의 식 (S). 패턴 시그니처로 바인딩 된 유형 변수 &lt;code&gt;aa&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 방정식 의 오른쪽 범위로 지정 됩니다. (따라서 고유 한 유형 변수를 사용할 필요가 없습니다. &lt;code&gt;a&lt;/code&gt; 를 사용 하는 것은 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="07937d8189c5060ed5381ab32883c57e83ee831e" translate="yes" xml:space="preserve">
          <source>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</source>
          <target state="translated">연관된 유형 패밀리 선언 자체와 달리 기본 인스턴스의 유형 변수는 상위 클래스의 유형 변수와 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="69f4d9a01fb6d7ddab12b0c937f801a23fbb7f34" translate="yes" xml:space="preserve">
          <source>Unlike the default definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt;, it is defined for 0 and so it should be preferred where possible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 의 기본 정의와 달리 0에 대해 정의되므로 가능하면 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="865d4045d80f8564c6ad3ca37c512ab3a0dd4aa4" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이전 예제와 달리 현재는 &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용하여 모호성을 수동으로 해결할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="77dcfd6345308258ebb060f9ef483bfd2e2232d6" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이전 예제와 달리 현재는 &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용하여 모호성을 수동으로 해결할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9b6cc89d8ca2d4d98a8cd94a124ce20e53b59f2e" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;. It can alternatively be:</source>
          <target state="translated">일반 데이터 정의와 달리 데이터 계열의 결과 종류는 &lt;code&gt;Type&lt;/code&gt; 일 필요가 없습니다 . 또는 다음과 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="737888d68afa4f88e72ac4273f546c5a3360f81f" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;: it can alternatively be a kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;). Data instances&amp;rsquo; kinds must end in &lt;code&gt;Type&lt;/code&gt;, however.</source>
          <target state="translated">일반 데이터 정의와는 달리, 데이터 가족의 결과 종류 일 필요는 없습니다 &lt;code&gt;Type&lt;/code&gt; : 그것은 양자 택일 (와 종류의 변수가 될 수 있습니다 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ). 그러나 데이터 인스턴스의 종류는 &lt;code&gt;Type&lt;/code&gt; 으로 끝나야합니다 .</target>
        </trans-unit>
        <trans-unit id="7946e2babfb31beb0cce042d8dd3c699ab7f6a8e" translate="yes" xml:space="preserve">
          <source>Unlikely :-) A useful be-more-paranoid option to give to GHC is &lt;code&gt;-dcore-lint&lt;/code&gt;-dcore-lint option; this causes a &amp;ldquo;lint&amp;rdquo; pass to check for errors (notably type errors) after each Core-to-Core transformation pass. We run with &lt;code&gt;-dcore-lint&lt;/code&gt; on all the time; it costs about 5% in compile time.</source>
          <target state="translated">:-) GHC에 제공하는 유용한 편집증 옵션은 &lt;code&gt;-dcore-lint&lt;/code&gt; -dcore-lint 옵션입니다. 이로 인해 각 코어에서 코어로의 변환 패스 후 &quot;보풀이없는&quot;패스가 오류 (특히 유형 오류)를 확인합니다. 우리는 &lt;code&gt;-dcore-lint&lt;/code&gt; 실행 합니다. 컴파일 시간이 약 5 %입니다.</target>
        </trans-unit>
        <trans-unit id="1526a17ee7570e6235eb76a6fef8ce4b6d9a3486" translate="yes" xml:space="preserve">
          <source>Unlock</source>
          <target state="translated">Unlock</target>
        </trans-unit>
        <trans-unit id="3b8f8d955c9b7f88d2d430a6fbd48f07e8b6555d" translate="yes" xml:space="preserve">
          <source>Unlock the semaphore.</source>
          <target state="translated">세마포어를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="1cd4113e1e43e9853f32e740b4dd9283a784af37" translate="yes" xml:space="preserve">
          <source>Unlocks a given range in a file handle, To unlock an entire file use 0xFFFFFFFFFFFFFFFF for size and 0 for offset.</source>
          <target state="translated">파일 핸들에서 주어진 범위를 잠금 해제합니다. 전체 파일을 잠금 해제하려면 크기에 0xFFFFFFFFFFFFFFFF를 사용하고 오프셋에 0을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="902f2805ba20ce5f892f5f33360fcdd69a38eafb" translate="yes" xml:space="preserve">
          <source>Unmasked</source>
          <target state="translated">Unmasked</target>
        </trans-unit>
        <trans-unit id="cc6650b603c5c0ea0f873838ead84fd4b5b2f977" translate="yes" xml:space="preserve">
          <source>Unpack the elements of a vector into an unboxed tuple. #</source>
          <target state="translated">벡터의 요소를 언 박스 튜플에 풉니 다. #</target>
        </trans-unit>
        <trans-unit id="f45849052f775de0ca7ba2014ab45df8d98aa51a" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id16&quot; id=&quot;id15&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">Unpacking 생성자 필드는 &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id16&quot; id=&quot;id15&quot;&gt; [1]&lt;/a&gt; 와 함께 사용해야 만 컴파일러에 전개를 노출하여 리 박싱을 최대한 자주 제거 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f6f9c62709d24e188cc2de205e309b7f76b6e3bf" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">압축 풀기 생성자 필드는 컴파일러에 펼침을 표시하여 가능한 한 자주 복싱을 제거 할 수 있도록 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt; [1]&lt;/a&gt; 과 함께 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="186ac86a8a426917ea872e83fd56ac894b4b2cf2" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt;1&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">Unpacking 생성자 필드는 Unfolding을 컴파일러에 노출하여 가능한 한 자주 리 박싱을 제거 할 수 있도록 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt; 1&lt;/a&gt; 과 함께 사용해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1a9a082ee76ad3d4406b6dd0d0891c9553bc0d38" translate="yes" xml:space="preserve">
          <source>Unregister an active timeout.</source>
          <target state="translated">활성 시간 초과를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="e9504a1e28553feaf1224a031b0767c5e24517b0" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation can be useful when porting GHC to a new machine, since it reduces the prerequisite tools to &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; and nothing more, and furthermore the amount of platform-specific code that needs to be written in order to get unregisterised compilation going is usually fairly small.</source>
          <target state="translated">등록되지 않은 컴파일은 GHC를 새로운 머신으로 포팅 할 때 유용 할 수 있습니다. 이는 사전 설치 도구를 &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 로 줄이며 그 외에는 더 이상 등록되지 않은 컴파일을 얻기 위해 작성해야하는 플랫폼 별 코드의 양을 줄여 주기 때문입니다. 가는 것은 보통 아주 작습니다.</target>
        </trans-unit>
        <trans-unit id="dbff9e9dc3cf5e9ee81b6a6d8db9918d35a26bed" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation cannot be selected at compile-time; you have to build GHC with the appropriate options set. Consult the GHC Building Guide for details.</source>
          <target state="translated">컴파일 타임에는 등록되지 않은 컴파일을 선택할 수 없습니다. 적절한 옵션 세트로 GHC를 빌드해야합니다. 자세한 내용은 GHC 빌딩 가이드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca66248420ad1912a2a95b83e1e2c85f11c52168" translate="yes" xml:space="preserve">
          <source>Unsafe</source>
          <target state="translated">Unsafe</target>
        </trans-unit>
        <trans-unit id="4a2f98011fe504349513b1f09c5c052c2e96e8f4" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (첨자) 연산자, 0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 반환 반환 범위 검사를 생략합니다. 이는 프로그래머가 범위를 다른 방식으로 검사하도록 보장해야 할 의무가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0dd91a3653dbdf62b055e276b77befee135ac9fe" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 반환하는 안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (아래 첨자) 연산자입니다. 이는 경계 검사를 생략합니다. 이는 프로그래머가 다른 방식으로 경계를 검사해야한다는 의무가 수반된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0e304ea4f61d467cda0009f4bab7e4e8c2092dcc" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 반환하는 안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (아래 첨자) 연산자 는 경계 검사를 생략합니다. 이는 프로그래머가 다른 방식으로 경계를 검사해야한다는 의무가 수반된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e55c2ba804dd339a0824a6746b1d478621fe6af8" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="1804d52485698b7ab99bc85550d8574dc5e3223d" translate="yes" xml:space="preserve">
          <source>Unsafe API Only.</source>
          <target state="translated">안전하지 않은 API 만.</target>
        </trans-unit>
        <trans-unit id="929444982a786a3b3d6195dff840214a59813e0b" translate="yes" xml:space="preserve">
          <source>Unsafe API.</source>
          <target state="translated">안전하지 않은 API.</target>
        </trans-unit>
        <trans-unit id="1ad1dfd8c1d43724099c7d74cf10393e4b7e2fc9" translate="yes" xml:space="preserve">
          <source>Unsafe IO operations</source>
          <target state="translated">안전하지 않은 IO 작업</target>
        </trans-unit>
        <trans-unit id="2e63719dae10937b05aa3be17e1f0f0af79e6f2e" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 사이의 안전하지 않은 변환 . 이것은 no-op이며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성에 편의상 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="051c814b3361ac5063677f84f8043980e0deb4d4" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 간의 안전하지 않은 변환 . 이것은 작동하지 않으며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성의 편의를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8241dd25799379ccded94491ee5eb28c3782621d" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 간의 안전하지 않은 변환 . 이것은 작동하지 않으며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성의 편의를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b73be1b54132992ff041e34ae070dde1fb960bba" translate="yes" xml:space="preserve">
          <source>Unsafe conversion code</source>
          <target state="translated">안전하지 않은 변환 코드</target>
        </trans-unit>
        <trans-unit id="163edb3c1def98928bd5f4858359e0e0ba9d4b21" translate="yes" xml:space="preserve">
          <source>Unsafe conversion for decimal digits.</source>
          <target state="translated">소수 자릿수에 대한 안전하지 않은 변환.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">안전하지 않은 기능</target>
        </trans-unit>
        <trans-unit id="2ccc22d5296723bf78d52f0e5432593f86660059" translate="yes" xml:space="preserve">
          <source>Unsafe general combining function</source>
          <target state="translated">안전하지 않은 일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="9864d3a94f4afb983bb1b979ff62b900e924fd12" translate="yes" xml:space="preserve">
          <source>Unsafe low-level operations</source>
          <target state="translated">안전하지 않은 저수준 작업</target>
        </trans-unit>
        <trans-unit id="4c84437a853ee0a263a2128827f73358c00f701b" translate="yes" xml:space="preserve">
          <source>Unsafe operations</source>
          <target state="translated">안전하지 않은 작업</target>
        </trans-unit>
        <trans-unit id="d897903ce6ca852a862bb42ee05a2321d0b71d9e" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an Array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 수준 비교 및 ​​배열 내의 요소 교체.</target>
        </trans-unit>
        <trans-unit id="5f01ef3f9963b0e9162caa23773fd9c03da561ee" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 단위 비교 및 ​​배열 내의 요소 교체.</target>
        </trans-unit>
        <trans-unit id="da875dda0af919ad5cb1b82f3bb406408186e93d" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array. See the documentation of &lt;code&gt;casArray#&lt;/code&gt;.</source>
          <target state="translated">안전하지 않은 시스템 수준의 원자 적 비교 및 ​​배열 내의 요소 교체. &lt;code&gt;casArray#&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23605c5b9ae4700123f875a656e77bc71e5d4742" translate="yes" xml:space="preserve">
          <source>Unsafe.Coerce</source>
          <target state="translated">Unsafe.Coerce</target>
        </trans-unit>
        <trans-unit id="63d2c6f9ecdfa3c8e1f8b40433e3d3b53557b684" translate="yes" xml:space="preserve">
          <source>UnsafeShift</source>
          <target state="translated">UnsafeShift</target>
        </trans-unit>
        <trans-unit id="35f4214602b8699ce1216c3d3a7141e959379206" translate="yes" xml:space="preserve">
          <source>Unsafely convert an untyped code representation into a typed code representation.</source>
          <target state="translated">형식이 지정되지 않은 코드 표현을 형식이 지정된 코드 표현으로 안전하지 않게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7390aa47d06ecf661a083cdb4c0a11930fc547be" translate="yes" xml:space="preserve">
          <source>Unsafely performs IO in the STM monad. Beware: this is a highly dangerous thing to do.</source>
          <target state="translated">STM 모나드에서 IO를 안전하지 않게 수행합니다. 조심하십시오 : 이것은 매우 위험한 일입니다.</target>
        </trans-unit>
        <trans-unit id="aa0e468d81cdfb7797b46f3cfbe92285b8c0656b" translate="yes" xml:space="preserve">
          <source>UnsatisfiedConstraints</source>
          <target state="translated">UnsatisfiedConstraints</target>
        </trans-unit>
        <trans-unit id="b570c31cfc9e1525756bea752d3f5378fbd40609" translate="yes" xml:space="preserve">
          <source>Unsets certain options. See &lt;a href=&quot;#ghci-set&quot;&gt;The :set and :seti commands&lt;/a&gt; for a list of available options.</source>
          <target state="translated">특정 옵션을 설정 해제합니다. 사용 가능한 옵션 목록은 &lt;a href=&quot;#ghci-set&quot;&gt;: set 및 : seti 명령&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e5387ceda9c1b244093608d8f5bbf329289a392" translate="yes" xml:space="preserve">
          <source>Unsigned integer types.</source>
          <target state="translated">부호없는 정수 유형.</target>
        </trans-unit>
        <trans-unit id="15d0066b74b820208c4e67dd995d745f22ff8b1c" translate="yes" xml:space="preserve">
          <source>Unsigned integral types</source>
          <target state="translated">부호없는 정수 유형</target>
        </trans-unit>
        <trans-unit id="0e683d0c1771359f194744b32634eb2816c4aba7" translate="yes" xml:space="preserve">
          <source>Unsound</source>
          <target state="translated">Unsound</target>
        </trans-unit>
        <trans-unit id="1afd000d072edf5c9a0c898690bcf0eb48c73be4" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Unsound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 불건전</target>
        </trans-unit>
        <trans-unit id="ad6bfcbce4213c08e4e664178dc9b7272c478b19" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 소리</target>
        </trans-unit>
        <trans-unit id="d5fc19d20b078f2546ad7041f570431236521a3c" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 불건전</target>
        </trans-unit>
        <trans-unit id="e9b9c22eade05319854ce1cdcc767667ce930aec" translate="yes" xml:space="preserve">
          <source>Unstable snapshot releases are named &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt;. where &lt;code&gt;YYYYMMDD&lt;/code&gt; is the date of the sources from which the snapshot was built. For example, &lt;code&gt;6.7.20040225&lt;/code&gt; would be a snapshot of the HEAD before the creation of the &lt;code&gt;6.8&lt;/code&gt; branch.</source>
          <target state="translated">불안정한 스냅 샷 릴리스의 이름은 &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt; 입니다. 여기서 &lt;code&gt;YYYYMMDD&lt;/code&gt; 는 스냅 샷이 작성된 소스의 날짜입니다. 예를 들어, &lt;code&gt;6.7.20040225&lt;/code&gt; 는 &lt;code&gt;6.8&lt;/code&gt; 분기를 만들기 전에 HEAD의 스냅 샷입니다 .</target>
        </trans-unit>
        <trans-unit id="373738bf142634e8e0dbabff8a938293663b328c" translate="yes" xml:space="preserve">
          <source>Unstreaming</source>
          <target state="translated">Unstreaming</target>
        </trans-unit>
        <trans-unit id="0a4adcf14688819a74c324ec71080a0f50ecc9d1" translate="yes" xml:space="preserve">
          <source>UnsupportedOperation</source>
          <target state="translated">UnsupportedOperation</target>
        </trans-unit>
        <trans-unit id="b3573ff37e8ab6eec0c7b76d222c391fd7fc4b0d" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="dc1e17125720aceb3cede9a397f7f6e537e85241" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="33964687cef4a0572a11fc515789a6d8366599b4" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e2057c9bc72225f9086a4e989d696e8995930bfa" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ea52fd4b682160e248727bb92f76eca80e1a4842" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="96e4d767723784751cda063eb47114da43bc353b" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ec5d83ec2dbad8875a7ab9032145f16380b2713f" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="eb2311da15c44fced6ec19017f698cf0da1fd04a" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="61be95428c0873884060ddea20acadc6af8e44d8" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a7b78bffc2f09872eafde186a7e64a02f9ce1502" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="f2e39dac134e08f335a2b0e3e50b9b76c674574f" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="6fe0545b79d1cecd8b1a757466d50502955540d8" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e90c4a46b0377f59faa429f1568928e49344a24a" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a9e19ebd4bf17f3e5101a8ce003af6477d70170c" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="2644b7747be90f51535d6476569dc41fd793744d" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="60f474ea604d8eeb4374ae5afe4e53944954d231" translate="yes" xml:space="preserve">
          <source>Unwrap an RWST computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWST 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="8f98e2ac9e2d748b70021352a635e8ef794ef05f" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">누적 계산을 (결과, 출력) 쌍으로 래핑 해제합니다. (의 역 &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="820c88e1c78e627590ad260b28a7707ed0558640" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation.</source>
          <target state="translated">누적 계산을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="2197473bde49255cd6618b199e4bc1a3de0d25e5" translate="yes" xml:space="preserve">
          <source>Unzip a sequence of pairs.</source>
          <target state="translated">일련의 쌍을 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="d6c94435f616ce33704a63b12b13869b2055fe6c" translate="yes" xml:space="preserve">
          <source>Update a source position given a character. If the character is a newline ('\n') or carriage return ('\r') the line number is incremented by 1. If the character is a tab ('t') the column number is incremented to the nearest 8'th column, ie. &lt;code&gt;column + 8 -
 ((column-1) `mod` 8)&lt;/code&gt;. In all other cases, the column is incremented by 1.</source>
          <target state="translated">문자가 지정된 소스 위치를 업데이트하십시오. 문자가 개행 ( ​​'\ n') 또는 캐리지 리턴 ( '\ r') 인 경우 행 번호는 1 씩 증가합니다. 문자가 탭 ( 't') 인 경우 열 번호는 가장 가까운 8 '까지 증가합니다 열, 즉 &lt;code&gt;column + 8 - ((column-1) `mod` 8)&lt;/code&gt; . 다른 모든 경우에는 열이 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ccafe26aeb5d542f797ce6d7bdcc125f7297b7b0" translate="yes" xml:space="preserve">
          <source>Update an active timeout to fire in the given number of microseconds.</source>
          <target state="translated">지정된 시간 (마이크로 초) 내에 실행되도록 활성 시간 초과를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="fe1ade2fe693811ed537bfc473a8a30ed8b8b5a3" translate="yes" xml:space="preserve">
          <source>UppercaseLetter</source>
          <target state="translated">UppercaseLetter</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="72a232f54a91a95c710346e72e4c91d976431058" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt;&quot; to compute the exact number of bytes written in advance for &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt;. In case of &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; will write and report zero bytes written, whereas &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; report one byte.</source>
          <target state="translated">&quot; &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt; &quot;을 사용하여 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt; 대해 미리 작성된 정확한 바이트 수를 계산하십시오 . 경우 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 가 작성되고보고 제로 반면, 기록 된 바이트 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 에 보고 한 바이트.</target>
        </trans-unit>
        <trans-unit id="25759557c641b7c83447c73b3afcbb7529fa6edc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt;&lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt;&lt;/a&gt; to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt; &lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt; &lt;/a&gt; 사용할 프로그램을 선택 하려면 -pgmF ⟨cmd⟩ 를 사용하십시오 . ⟨cmd⟩ 프리 프로세서는 명령 행에 최소한 세 개의 인수가 제공됩니다. 첫 번째 인수는 원본 소스 파일의 이름이고, 두 번째는 입력을 보유한 파일의 이름이며, 세 번째는 ⟨cmd⟩가 출력을 기록해야하는 파일의 이름</target>
        </trans-unit>
        <trans-unit id="0b4372542a118b48b81e477bf6a20ba6b09913d2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">사용 &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 규칙이 해고되고 있는지 아주 자세하게 볼 수 있습니다. &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e56a9d5c91f6126fe3042d4f398b5871676f85bf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">사용 &lt;a href=&quot;../debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt; 정의 된 규칙 확인 &lt;em&gt;이 모듈을&lt;/em&gt; . 여기에는 전문화 단계에서 생성 된 규칙이 포함되지만 다른 모듈에서 가져온 규칙은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="b11f0cc2df4b4a340cba4cb75322d6acc2d731d3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">&lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용 하여 어떤 규칙이 실행되고 있는지 확인하십시오. &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a74fc84a08bb050a8c0f9d9847a761164de8655" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 규칙이 해고되고 있는지 아주 자세하게 볼 수 있습니다. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bfae0475a23191547214f74e349943e83d21e0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt; 정의 된 규칙 확인 &lt;em&gt;이 모듈을&lt;/em&gt; . 여기에는 전문화 단계에서 생성 된 규칙이 포함되지만 다른 모듈에서 가져온 규칙은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b3e1b5c3fa8b32869bb0120876b5d5da5603bc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용 하여 실행중인 규칙을 확인하십시오. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b771ec12132aa2e0c2b47e42c8669142adcb966c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용 하고 중단 가능한 작업을 피 하십시오 . 이를 위해서는 인터럽트가 가능한 작업을 알아야합니다. 주어진 라이브러리 함수에 대해 내부적으로 인터럽트 가능한 조작을 호출 할 수 있는지 여부를 알 수 없습니다. 대신 아래에 보장 할 수없는 보장 가능한 작업 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="57ec9ad7fbe9ded694e2e346c6b70bfb493d9263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; can only ever block for a short time. Otherwise, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; is a good way to make your program deadlock and be unresponsive to user interrupts.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 범위 동안 호출 된 인터럽트 가능 조작 이 단시간 동안 만 차단 될 수 있다는 것을 보장 할 수 없으면 일반적으로 권장되지 않습니다 . 그렇지 않으면, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 는 프로그램을 교착 상태로 만들고 사용자 인터럽트에 응답하지 않는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9560818c30df433ea1d8321d618a619a497012b8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; to avoid this problem.</source>
          <target state="translated">이 문제를 피 하려면 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="32aaf763496559c71074751f07941cee5db7b2fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; 의 동작을 얻으려면 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0965bb3313f69c3f81efc222ad17894b547d4f4f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; 을 사용 하여 &lt;a href=&quot;data-monoid&quot;&gt;Data&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; 의 동작을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="6e13d276c8e0d029eae5978336ac0693463e26ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25c751dae0926d2f7b6e06f66b29b041f9b1c1c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512fb5121eabf3e465918becf9c349f15bf52375" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8958d144abe494ec2ceac7996d592080bc32ae" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;strip&lt;/strong&gt; on your executables.</source>
          <target state="translated">실행 파일에 &lt;strong&gt;strip&lt;/strong&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaebd479a4ffe804021ed586cb29ed1e63a61ba4" translate="yes" xml:space="preserve">
          <source>Use GHC&amp;rsquo;s &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; rather than compiling via LLVM. &lt;code&gt;-fasm&lt;/code&gt; is the default.</source>
          <target state="translated">LLVM을 통해 컴파일하는 대신 GHC의 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;고유 코드 생성기를&lt;/a&gt; 사용하십시오 . &lt;code&gt;-fasm&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="37bef6dae0e3c404226f866a87bb48ee5a6ad08b" translate="yes" xml:space="preserve">
          <source>Use GHCi&amp;rsquo;s extended default rules in a normal module.</source>
          <target state="translated">일반 모듈에서 GHCi의 확장 기본 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="559c9b9fd04f1e3041713b6f2cf9e35cff9d879f" translate="yes" xml:space="preserve">
          <source>Use GHCi's extended default rules in a normal module.</source>
          <target state="translated">일반 모듈에서 GHCi의 확장 된 기본 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="04d5949406943eaf29d4718abd7e8752c49273b7" translate="yes" xml:space="preserve">
          <source>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</source>
          <target state="translated">STM을 사용하십시오. 트랜잭션은 항상 완전히 실행되거나 전혀 실행되지 않기 때문에 트랜잭션은 비동기 (및 실제로 동기) 예외가있는 상태에서 변하지 않는 상태를 유지하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f35f11885972458dd5435b0c60945844fa1cf70e" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="338f9df27e568de9a873343298f1ee5a259c53a9" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; evidence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 를 입력 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 증거 로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="746a26a0ae875d24d6db1c324d9b7183d086ea3c" translate="yes" xml:space="preserve">
          <source>Use a POSIX I/O Sub-System</source>
          <target state="translated">POSIX I / O 하위 시스템 사용</target>
        </trans-unit>
        <trans-unit id="eafe0f628bdb243fb3b0edbccb0c80d5e94c239c" translate="yes" xml:space="preserve">
          <source>Use a bigger heap!</source>
          <target state="translated">더 큰 힙을 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="48d50a26d4092a032e5ec1812697e2ae5f2493e9" translate="yes" xml:space="preserve">
          <source>Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.</source>
          <target state="translated">가장 오래된 세대를 수집하려면 압축 알고리즘을 사용하십시오. 기본적으로 가장 오래된 세대는 복사 알고리즘을 사용하여 수집됩니다. 이 옵션을 사용하면 대신 해당 위치로 압축됩니다. 압축 알고리즘은 복사 알고리즘보다 속도가 느리지 만 메모리 사용량을 상당히 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939b950f9853220f1f4457399d66662e4cd19c03" translate="yes" xml:space="preserve">
          <source>Use a slower but better algorithm for ApplicativeDo</source>
          <target state="translated">ApplicativeDo에 대해 느리지 만 더 나은 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="77ea136d96ab55918616e2de414adfe26e040bbf" translate="yes" xml:space="preserve">
          <source>Use a small box for the title.</source>
          <target state="translated">제목에 작은 상자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b52135628f58b3a037f43c82033c20d263ba93a5" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6a33f2bd018cb8aaf8733cbb07dec137c9b267" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Always enabled by default.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오. 항상 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b25b503bf1e131032b9194d35870945071ac8245" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Behaviour is unconditionally enabled starting with 9.2</source>
          <target state="translated">사전 선택기에 특수 수요 변환기를 사용하십시오. 동작은 9.2부터 무조건 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9c0adf8c16cf722d99aad385f8f59801bd334547" translate="yes" xml:space="preserve">
          <source>Use an explicit type signature on the record expression, as in:</source>
          <target state="translated">다음과 같이 레코드 표현식에 명시 적 유형 서명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="292fc35c66c20d657884010ef14bdc8af40861f8" translate="yes" xml:space="preserve">
          <source>Use as: s -&amp;gt; atomicCasAddrAddr# location expected desired s</source>
          <target state="translated">다음으로 사용 : s-&amp;gt; atomicCasAddrAddr # 위치 예상 원하는 s</target>
        </trans-unit>
        <trans-unit id="ff515038361d9bf7c3d5fdf1f946a7c3b1673ee7" translate="yes" xml:space="preserve">
          <source>Use as: s -&amp;gt; atomicCasWordAddr# location expected desired s</source>
          <target state="translated">다음으로 사용 : s-&amp;gt; atomicCasWordAddr # 위치 예상 원하는 s</target>
        </trans-unit>
        <trans-unit id="9253a45a0ac7d8f0b34981a4a8e896e300094aae" translate="yes" xml:space="preserve">
          <source>Use colors in error messages</source>
          <target state="translated">오류 메시지에 색상 사용</target>
        </trans-unit>
        <trans-unit id="f17361b13fb3a2074cdb146eaa615b5c6cb69427" translate="yes" xml:space="preserve">
          <source>Use current directory for the GHCi command history file &lt;code&gt;.ghci-history&lt;/code&gt;.</source>
          <target state="translated">GHCi 명령 히스토리 파일 &lt;code&gt;.ghci-history&lt;/code&gt; 에 현재 디렉토리를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="60cf6b84707199f4795abe12d1ae35ef2d41e1d1" translate="yes" xml:space="preserve">
          <source>Use decimal notation for values between &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;9,999,999&lt;/code&gt;, and scientific notation otherwise.</source>
          <target state="translated">사이의 값을 소수점 표기법을 사용하여 &lt;code&gt;0.1&lt;/code&gt; 및 &lt;code&gt;9,999,999&lt;/code&gt; 달리, 과학 표기법을.</target>
        </trans-unit>
        <trans-unit id="8a0a45ab79448b01d6ee5ed7e5abdb75681dee62" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="babd2ff76089a3d1f8aa9f2a697eb17aef342e31" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일 스타일 상호 작용을 사용하여 주어진 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="a9390e87846d6a93528abe67fa5bb72b908f7c7f" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일 스타일 상호 작용을 사용하여 주어진 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="316508bd71c0c5222c8f5a0b92e83093f7ef8d81" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given file.</source>
          <target state="translated">주어진 파일에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e83731aa81291c66034e6c2f8713ae82f0abfb1" translate="yes" xml:space="preserve">
          <source>Use foreign export declarations to export the Haskell functions you want to call from the outside. For example:</source>
          <target state="translated">외국 수출 신고를 사용하여 외부에서 호출하려는 Haskell 함수를 수출하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d25d6807c73eb047cf28c6f6c34e364514a196a6" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbc73e0426aece56e09a684e49c4bbc54078eb05" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59ab30f8bb5418fd366c74cb8d2d5172978bb6f9" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b82fc19a9b21a0e738f7458d40e3287caf342b3" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d18f84af3a8332dfa6f2cefc28870581d3c1af0" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cba5ffe9e5bbc4089ab256ab21a6e1f61feb47e5" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbe36f44a27a0189506ed9bcc5455131593cc6b7" translate="yes" xml:space="preserve">
          <source>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ disables load-balancing entirely.</source>
          <target state="translated">세대 Cgen⟩ 이상의 병렬 GC에서로드 밸런싱을 사용하십시오. ⟨gen⟩을 생략하면로드 밸런싱이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fcd08dc2fdbb61836f1f89ef8e9fbe1cfdf541" translate="yes" xml:space="preserve">
          <source>Use more memory:</source>
          <target state="translated">더 많은 메모리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6eaea9f8fe75d7534bd9ba845082e28f6577e255" translate="yes" xml:space="preserve">
          <source>Use of this type is discouraged. Note the following equivalence:</source>
          <target state="translated">이 유형의 사용은 권장하지 않습니다. 다음과 같은 내용을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb452a5c138ef6d6999a87a31eb6eb9a345911f" translate="yes" xml:space="preserve">
          <source>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the parallel GC completely, reverting to sequential GC.</source>
          <target state="translated">세대 ⟨gen⟩ 이상에서는 병렬 GC를 사용하십시오. ⟨gen⟩을 생략하면 병렬 GC가 완전히 꺼지고 순차적 GC로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="1de741d6efbec754e80e7e93becb988786a18010" translate="yes" xml:space="preserve">
          <source>Use platform native Sub-System. For unix OSes this is the same as IoPOSIX, but on Windows this means use the Windows native APIs for I/O, including IOCP and RIO.</source>
          <target state="translated">플랫폼 네이티브 하위 시스템을 사용합니다. 유닉스 OS의 경우 이는 IoPOSIX와 동일하지만 Windows에서는 IOCP 및 RIO를 포함하여 I / O 용 Windows 네이티브 API를 사용하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="56b1d864443428aa9218cc82070c092c301dc501" translate="yes" xml:space="preserve">
          <source>Use posix setgid to set child process's group id; does nothing on other platforms.</source>
          <target state="translated">posix setgid를 사용하여 하위 프로세스의 그룹 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39925d946ab1c9c0725df1e4920b81ccd158d12d" translate="yes" xml:space="preserve">
          <source>Use posix setsid to start the new process in a new session; does nothing on other platforms.</source>
          <target state="translated">posix setsid를 사용하여 새 세션에서 새 프로세스를 시작하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf6e7dcdcd547e2f6790215eda406e40ab63d1d5" translate="yes" xml:space="preserve">
          <source>Use posix setuid to set child process's user id; does nothing on other platforms.</source>
          <target state="translated">posix setuid를 사용하여 하위 프로세스의 사용자 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14976703db8bc962fb6e74a997ae61f1d13d892f" translate="yes" xml:space="preserve">
          <source>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The &lt;code&gt;-p&lt;/code&gt; flag causes the graph to be drawn using the parameters determined by a previous run of &lt;code&gt;hp2ps&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;. These are extracted from &lt;code&gt;file@.aux&lt;/code&gt;.</source>
          <target state="translated">이전 매개 변수를 사용하십시오. 기본적으로 PostScript 그래프는 페이지를 채울 수 있도록 가로 및 세로로 자동 배율이 조정됩니다. 그러나 프리젠 테이션에 사용할 일련의 그래프를 준비 할 때 이전 그래프와 동일한 스케일, 음영 및 순서를 사용하여 새 그래프를 그리는 것이 종종 유용합니다. &lt;code&gt;-p&lt;/code&gt; 플래그의 이전 실행에 의해 결정된 파라미터를 사용하여 그려 그래프 발생 &lt;code&gt;hp2ps&lt;/code&gt; 에 &lt;code&gt;file&lt;/code&gt; . 이들은 &lt;code&gt;file@.aux&lt;/code&gt; 에서 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="99aacaeb246dcd6fd6f08321e48778f7a8f45355" translate="yes" xml:space="preserve">
          <source>Use static Haskell libraries</source>
          <target state="translated">정적 하스켈 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="92cedb657ea08377a2d0891b88a0e7c40ed55ee1" translate="yes" xml:space="preserve">
          <source>Use strictness annotations:</source>
          <target state="translated">엄격 주석을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa085a6df8595e3f12af85a3f58c8a624eb4c73a" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 이 터미널이 아닌 경우에도 가능하면 터미널 스타일의 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c701d48b2ddc2ad9f38319eaef995257ab48d8b" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 이 터미널이 아니더라도 가능하면 터미널 스타일 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="702fcd88a46378df6ea71ccb1190fa14cbe9bac6" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 이 터미널이 아니더라도 가능하면 터미널 스타일 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3e92ec8a74dacde2eaa4a5a97ab32c527f59c0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;네이티브 코드 생성기를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b4f48cb9a708494d358733ee6311bb2890a74d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of the legacy &lt;code&gt;Monad.fail&lt;/code&gt; function when desugaring refutable patterns in &lt;code&gt;do&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 블록 에서 반박 가능한 패턴을 제거 할 때 레거시 &lt;code&gt;Monad.fail&lt;/code&gt; 함수 대신 &lt;code&gt;MonadFail.fail&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4d3a4fd4f7e397d42bb7af957939ab364ef83c" translate="yes" xml:space="preserve">
          <source>Use the C code generator. Only supposed in unregisterised GHC builds.</source>
          <target state="translated">C 코드 생성기를 사용하십시오. 등록되지 않은 GHC 빌드에서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3b6c94c81606492d87dce6da844389bd6d123781" translate="yes" xml:space="preserve">
          <source>Use the Haskell 2010 language variant.</source>
          <target state="translated">Haskell 2010 언어 변형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66e695e59e51ae41d59efa1f0452144c08e51e4d" translate="yes" xml:space="preserve">
          <source>Use the Haskell 98 language variant.</source>
          <target state="translated">Haskell 98 언어 변형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0627207e13b5374967883369ea83fa36b1b2d8d1" translate="yes" xml:space="preserve">
          <source>Use the OS&amp;rsquo;s affinity facilities to try to pin OS threads to CPU cores.</source>
          <target state="translated">OS 선호도 기능을 사용하여 OS 스레드를 CPU 코어에 고정하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d77e21a24f58ed3cfa9fc40fc67b161d6efb10" translate="yes" xml:space="preserve">
          <source>Use the compiler flag &lt;code&gt;-fno-cse&lt;/code&gt; to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like &lt;code&gt;test&lt;/code&gt; in the example below).</source>
          <target state="translated">컴파일러 플래그 &lt;code&gt;-fno-cse&lt;/code&gt; 를 사용하면 모듈에서 공통 하위 표현식 제거가 수행되지 않도록 할 수 있습니다. 이는 별도의 두 가지 부작용을 결합 할 수 있습니다. 좋은 예는 여러 전역 변수를 사용하는 것입니다 ( 아래 예의 &lt;code&gt;test&lt;/code&gt; 와 같은 ).</target>
        </trans-unit>
        <trans-unit id="7fe585682db3ba3c0e51a716fd4585abd8b10372" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">디버그 플래그 &lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용하여 실행 된 규칙을 확인하십시오. 더 많은 정보가 필요한 경우 &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 는 각 개별 규칙 실행을 보여주고 &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 는 재 작성 전후의 코드 모습도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="05f98fdb0a464272614c6fe514e416fde94c65c8" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">실행 된 규칙을 보려면 디버그 플래그 &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용하십시오. 추가 정보가 필요한 경우 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 는 각 개별 규칙 발생을 보여주고 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 는 코드가 재 작성 전후에 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="31025e911529ebd63f8206b2d16a61f3669154ce" translate="yes" xml:space="preserve">
          <source>Use the debugging runtime</source>
          <target state="translated">디버깅 런타임 사용</target>
        </trans-unit>
        <trans-unit id="144d20ef0b0c9d8763e7b3511495086ba6c61351" translate="yes" xml:space="preserve">
          <source>Use the graph colouring register allocator for register allocation in the native code generator. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 코드 생성기의 레지스터 할당에 그래프 색상 지정 레지스터 할당자를 사용하십시오. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8346b41ccfa200a85cecf48a8e542509566a4d6" translate="yes" xml:space="preserve">
          <source>Use the iterative coalescing graph colouring register allocator in the native code generator.</source>
          <target state="translated">기본 코드 생성기에서 반복 병합 그래프 색상 지정 레지스터 할당자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc6eaa52001219c7a0e89385d4db8d4bec3bd8c1" translate="yes" xml:space="preserve">
          <source>Use the native newline representation on both input and output</source>
          <target state="translated">입력 및 출력 모두에서 기본 개행 표시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b94051e0d240dec7f44d3ae63663006f51a70e2e" translate="yes" xml:space="preserve">
          <source>Use the new cfg based block layout algorithm.</source>
          <target state="translated">새로운 cfg 기반 블록 레이아웃 알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="621ad9797959ada9554dba1b4e40103b721856b4" translate="yes" xml:space="preserve">
          <source>Use the package environment in ⟨file⟩, or in &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; If set to &lt;code&gt;-&lt;/code&gt; no package environment is read.</source>
          <target state="translated">⟨file⟩ 또는 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; 패키지 환경 을 사용하십시오 &lt;code&gt;-&lt;/code&gt; 패키지 환경을 읽지 않으면 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e928c9363dc2761d919623c37eb23f20043344b" translate="yes" xml:space="preserve">
          <source>Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped.</source>
          <target state="translated">개인용 이스케이프 메커니즘을 사용하여 잘못된 시퀀스를 라운드 트립 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe223bc5664e0dbbbb86d91d8f8e20115be7c77e" translate="yes" xml:space="preserve">
          <source>Use the runtime flag &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; on the executable program to see the options set with &lt;code&gt;-with-rtsopts&lt;/code&gt;.</source>
          <target state="translated">실행 가능 프로그램 에서 런타임 플래그 &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;-with-rtsopts&lt;/code&gt; 로 설정된 옵션을보십시오 .</target>
        </trans-unit>
        <trans-unit id="0d0e51d18f065395391915a571efbca349dbf8ff" translate="yes" xml:space="preserve">
          <source>Use the specified package environment.</source>
          <target state="translated">지정된 패키지 환경을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a4cdd1140930338cd84d92d2d4f03e8bbf83e2f9" translate="yes" xml:space="preserve">
          <source>Use the supplied Handle</source>
          <target state="translated">제공된 손잡이를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="3c447f3debfd4d77bf363bb22fe9e22b23154955" translate="yes" xml:space="preserve">
          <source>Use the threaded runtime</source>
          <target state="translated">스레드 런타임 사용</target>
        </trans-unit>
        <trans-unit id="5893cdc411d65af273e86691b8f798550a825ef2" translate="yes" xml:space="preserve">
          <source>Use the type being pushed in to the record update, as in the following:</source>
          <target state="translated">다음과 같이 레코드 업데이트에 푸시되는 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8155ca974b5f10eabbc2c9fa6db785cf2b7e95de" translate="yes" xml:space="preserve">
          <source>Use the windows CREATE_NEW_CONSOLE flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">프로세스를 작성할 때 Windows CREATE_NEW_CONSOLE 플래그를 사용하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="076eeb25f49f7ce0697c6ad0d6b033989c99f7be" translate="yes" xml:space="preserve">
          <source>Use the windows DETACHED_PROCESS flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">프로세스를 작성할 때 Windows DETACHED_PROCESS 플래그를 사용하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12dc915cf8e611c4a5bbf96add0aeb690c53aa47" translate="yes" xml:space="preserve">
          <source>Use this function &lt;em&gt;only&lt;/em&gt; in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes &lt;em&gt;heavy&lt;/em&gt; use of concurrency (e.g. a web server), might want to wrap its &lt;code&gt;main&lt;/code&gt; action in &lt;code&gt;runInUnboundThread&lt;/code&gt;.</source>
          <target state="translated">바운드 스레드 사용으로 인해 실제로 성능 손실이 관찰 된 드문 경우 &lt;em&gt;에만&lt;/em&gt; 이 기능을 사용하십시오 . 메인 스레드를 바인딩 할 필요가없고 동시성 (예 : 웹 서버) 을 &lt;em&gt;많이&lt;/em&gt; 사용 하는 프로그램 은 &lt;code&gt;main&lt;/code&gt; 액션을 &lt;code&gt;runInUnboundThread&lt;/code&gt; 로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fbe341ed72c59fb75fa6a4a5047d697d5105b52" translate="yes" xml:space="preserve">
          <source>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</source>
          <target state="translated">이 기능을 사용하면 JSON 또는 HTML과 같은 텍스트 기반 형식에 효율적인 인코더를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597699da79003c9f11a8170c1b3b401789da4fea" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용 하여 작은 ( &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 작성 하거나 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에서 생성 된 청크와 공유되지 않도록 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="40d805c5f47d1eda4e3e392efeab020927b7af69" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용 하여 작은 ( &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 작성 하거나 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에서 생성 된 청크와 공유되지 않도록 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d21a0c0848e2fe24c35241efc6aba2596b116b" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are discarded right after they are generated. For example, if you just generate them to write them to a network socket.</source>
          <target state="translated">청크가 생성 된 직후 폐기되는 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 생성에이 전략을 사용하십시오 . 예를 들어 네트워크 소켓에 쓰기 위해 생성하는 경우를 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3896a54fb513e8f65a867da9dc52309786700cc" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are likely to survive one garbage collection. This strategy trims buffers that are filled less than half in order to avoid spilling too much memory.</source>
          <target state="translated">이 전략을 사용하면 청크가 하나의 가비지 콜렉션에서 살아남을 수있는 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성 할 수 있습니다. 이 전략은 너무 많은 메모리가 쏟아지지 않도록 절반 이하로 채워지는 버퍼를 잘라냅니다.</target>
        </trans-unit>
        <trans-unit id="1939c777b53d41b8b4e7104cff916c96b4a7c053" translate="yes" xml:space="preserve">
          <source>Use unboxed types (a GHC extension):</source>
          <target state="translated">박스가없는 유형 (GHC 확장)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b123b85d967a1500e8666eb4e128ba145310fa7f" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">표현식, 유형 및 종류를 인쇄 할 때 유니 코드 구문을 사용하십시오. &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="02c50c019808c45b0dca4dff7fb4c84f4971f171" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">표현식, 유형 및 종류를 인쇄 할 때는 유니 코드 구문을 사용하십시오. &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="1217e1edd93d0feba5136f9afad7e849709839fd" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">표현식, 유형 및 종류를 인쇄 할 때 유니 코드 구문을 사용하십시오. &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="cc21fce3863bcaec7184d0faa94b76871818b8de" translate="yes" xml:space="preserve">
          <source>Use whitespace to determine whether the minus sign stands for negation or subtraction.</source>
          <target state="translated">공백을 사용하여 마이너스 기호가 부정 또는 뺄셈을 의미하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d8a5442d751be61fc485493c3b80caf299427002" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt; 와 함께 사용</target>
        </trans-unit>
        <trans-unit id="eb059e8d4d640a98cf37158c3bbc517ef2335d75" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt; 와 함께 사용</target>
        </trans-unit>
        <trans-unit id="a7c895629df0d08bc454b5180ba8b8f749d5e729" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler</source>
          <target state="translated">C 컴파일러로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="3b19fb7d83e0550bc9d6938909644b80cc44debf" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler.</source>
          <target state="translated">C 컴파일러로 cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48e5e2c2e148dc62026ced8a7307093b27049893" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only)</source>
          <target state="translated">C 프리 프로세서로 ⟨cmd⟩ 사용 ( &lt;code&gt;-cpp&lt;/code&gt; 만 해당)</target>
        </trans-unit>
        <trans-unit id="01b0b15ae4e5390c5b9fd9ed11028c5a3806955a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only).</source>
          <target state="translated">C 프리 프로세서로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-cpp&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="bd777d1b368559dc8f94f852a03bdd03d5c158b7" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator</source>
          <target state="translated">DLL 생성기로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="789f1801d66fb6195efab4aa1b2123da996a8572" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator.</source>
          <target state="translated">DLL 생성기로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b27a03dda1cfc10ac7e5c1cd38f3ff58004f4f40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler</source>
          <target state="translated">LLcmd⟩를 LLVM 컴파일러로 사용</target>
        </trans-unit>
        <trans-unit id="1436e09dd97ed0423b0bd42c04ab22ffaac47e27" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler.</source>
          <target state="translated">LLcmd⟩를 LLVM 컴파일러로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53809f0ed5671c0b308870f2ae7256160fc842ef" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser</source>
          <target state="translated">LLVM 최적화 프로그램으로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="aaf8f14c77b588ce45629e8618e368236c9a5b16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser.</source>
          <target state="translated">LLcmd⟩를 LLVM 최적화 프로그램으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f4353f860ce7ec12fdb2801304532e01df4d8f16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler</source>
          <target state="translated">⟨cmd⟩를 어셈블러로 사용</target>
        </trans-unit>
        <trans-unit id="6410b4096f4180f08edab2aa46f3bb1a6e286a5a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler.</source>
          <target state="translated">⟨cmd⟩를 어셈블러로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb31dfc0c69b643471fc895b68566295b7824e3e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">libtool에 대한 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="cd6eacbfc9012ab6009581fcb6ca48bb6bcb8883" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtool의 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-staticlib&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="71a83bd18619d2dc927e0bb5ca8f99a89d38bbb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">⟨cmd⟩를 외부 인터프리터 명령으로 사용합니다 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 ). 기본값 : &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;ghc-iserv-prof&lt;/code&gt; , &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 이 활성화 된 경우 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;ghc-iserv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6db1d3ff7c078c6ed925326bc988128971d3e6a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see: &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;code&gt;-prof&lt;/code&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;code&gt;-dynamic&lt;/code&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">interpretcmd⟩를 외부 인터프리터 명령으로 사용하십시오 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 ). 기본값 : &lt;code&gt;-prof&lt;/code&gt; 가 활성화 된 경우 &lt;code&gt;ghc-iserv-prof&lt;/code&gt; , &lt;code&gt;-dynamic&lt;/code&gt; 이 활성화 된 경우 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 또는 그렇지 않은 경우 &lt;code&gt;ghc-iserv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4e9da7f5bb3b749e809cd18b20a8233dfd64c38" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command.</source>
          <target state="translated">외부 통역사 명령으로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="481e440a89078b7c2339966f16ab888ce0b1d958" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">⟨cmd⟩를 libtool 명령으로 사용하십시오 ( &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt; 만 사용 하는 경우).</target>
        </trans-unit>
        <trans-unit id="33602c22bf82b32ce392224b8386b32a3918beba" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtool 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-staticlib&lt;/code&gt; 만 사용 하는 경우).</target>
        </trans-unit>
        <trans-unit id="8825dbbd517730047c01dd2f1cb0fdf5aecfff1f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker</source>
          <target state="translated">링커로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="ac711284292bd26e5315cd00ca382caef9435d2c" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files</source>
          <target state="translated">개체 파일 병합시 ⟨cmd⟩를 링커로 사용</target>
        </trans-unit>
        <trans-unit id="aa8be27c0b9f201fc0c9472f4f8108d93d582bc5" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files (e.g. when generating joined objects for loading into GHCi).</source>
          <target state="translated">개체 파일을 병합 할 때 (예 : GHCi에로드하기 위해 결합 된 개체를 생성 할 때) ⟨cmd⟩를 링커로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="044987ff622cf075400b97ce65ad16deaa9afb40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker.</source>
          <target state="translated">링커로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f0729f199f6bd7daa32c90ed274f3139614300" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor</source>
          <target state="translated">리터럴 프리 프로세서로 precmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2261658d2fadf5a466ddd17c0a48d56d1de60076" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor.</source>
          <target state="translated">리터럴 프리 프로세서로 precmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae3fcd7e913573d0ca98fd73aac79e8ca6510b13" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">⟨cmd⟩를 전처리기로 사용합니다 ( &lt;a href=&quot;#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="7a29c6934473566c99b28cee4bc5456cde213b21" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;phases#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only)</source>
          <target state="translated">⟨cmd⟩를 전처리기로 사용 ( &lt;a href=&quot;phases#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt; 만 사용)</target>
        </trans-unit>
        <trans-unit id="1cebb98327d9395dab0cb8072c4f8ca1b63e721e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only)</source>
          <target state="translated">프리 프로세서로 ⟨cmd⟩ 사용 ( &lt;code&gt;-F&lt;/code&gt; 만 해당)</target>
        </trans-unit>
        <trans-unit id="0646cba0fc73865471883ba72a732a857f6b001f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only).</source>
          <target state="translated">프리 프로세서로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-F&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="8d78d3aa183826f09ec39398f8525769841ecfa8" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program for embedding manifests on Windows.</source>
          <target state="translated">Windows에서 매니페스트를 포함시키기위한 프로그램으로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="06f092be8a595002e75e8cde42011af9133ed460" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inject &lt;code&gt;runpath&lt;/code&gt; into mach-o dylibs on macOS</source>
          <target state="translated">⟨cmd⟩를 프로그램으로 사용 하여 macOS의 mach-o dylibs에 &lt;code&gt;runpath&lt;/code&gt; 를 삽입 하십시오.</target>
        </trans-unit>
        <trans-unit id="2aa3b14fe034bb785dbc95f7e2f098debf4b70be" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inject &lt;code&gt;runpath``s into mach-o dynamic
libraries and executables.&amp;nbsp; As detected by the ``otool&lt;/code&gt; call.</source>
          <target state="translated">⟨cmd⟩를 프로그램으로 사용하여 실행 &lt;code&gt;runpath``s into mach-o dynamic libraries and executables.&amp;nbsp; As detected by the ``otool&lt;/code&gt; 호출에 의해 감지됩니다 .</target>
        </trans-unit>
        <trans-unit id="e75123a572cd455ff35b1a2ec2ba9af921d11a57" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inspect mach-o dylibs on macOS</source>
          <target state="translated">⟨cmd⟩를 프로그램으로 사용하여 macOS에서 mach-o dylibs를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="5b79c5d224e16858a476d6f862fdbc459ee62882" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inspect mach-o dynamic libraries and executables to read the dynamic library dependencies. We will compute the necessary &lt;code&gt;runpath``s to embed for the dependencies based on the
result of the ``otool&lt;/code&gt; call.</source>
          <target state="translated">⟨cmd⟩를 프로그램으로 사용하여 mach-o 동적 라이브러리 및 실행 파일을 검사하여 동적 라이브러리 종속성을 읽습니다. &lt;code&gt;runpath``s to embed for the dependencies based on the result of the ``otool&lt;/code&gt; 호출 의 결과를 기반으로 종속성을 포함 하는 데 필요한 실행 경로 ''를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="3cdb19e159e8f49ae555412eae549a3cfd049ac9" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program &lt;code&gt;windres&lt;/code&gt;, which is supplied with a GHC installation. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">Windows에서 매니페스트를 포함하는 데 사용할 프로그램으로 ⟨cmd⟩를 사용하십시오. 일반적으로 이것은 GHC 설치와 함께 제공되는 프로그램 &lt;code&gt;windres&lt;/code&gt; 입니다. &lt;a href=&quot;#options-linker&quot;&gt;연결에 영향을주는 옵션의 &lt;/a&gt; &lt;code&gt;-fno-embed-manifest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3510499be750179e96b10f06b02b8e4bfde31eb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter</source>
          <target state="translated">스플리터로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="2ddd654081c3e141217debcdaf12ebb2e94ac63e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter.</source>
          <target state="translated">스플리터로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c6f4febe792ad114505eb5ec857ff33af060815" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile</source>
          <target state="translated">filefile⟩을 makefile로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd7c6879b5a5e6c77b73fa449baad133ae5d56cf" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile, rather than &lt;code&gt;makefile&lt;/code&gt; or &lt;code&gt;Makefile&lt;/code&gt;. If ⟨file⟩ doesn&amp;rsquo;t exist, &lt;code&gt;mkdependHS&lt;/code&gt; creates it. We often use &lt;code&gt;-dep-makefile .depend&lt;/code&gt; to put the dependencies in &lt;code&gt;.depend&lt;/code&gt; and then &lt;code&gt;include&lt;/code&gt; the file &lt;code&gt;.depend&lt;/code&gt; into &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;makefile&lt;/code&gt; 또는 &lt;code&gt;Makefile&lt;/code&gt; 대신 ⟨file⟩을 makefile로 사용하십시오 . ⟨file⟩이 존재하지 않는 경우, &lt;code&gt;mkdependHS&lt;/code&gt; 는 그것을 만듭니다. 우리는 종종 &lt;code&gt;-dep-makefile .depend&lt;/code&gt; 를 사용 하여 종속성을 &lt;code&gt;.depend&lt;/code&gt; 에 넣은 다음 &lt;code&gt;.depend&lt;/code&gt; 파일 을 &lt;code&gt;Makefile&lt;/code&gt; 에 &lt;code&gt;include&lt;/code&gt; 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="91f7bf56d858ac23099d424e99b3748f4ffa9e6f" translate="yes" xml:space="preserve">
          <source>Use ⟨x⟩ simultaneous threads when running the program.</source>
          <target state="translated">프로그램을 실행할 때 ⟨x⟩ 동시 스레드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50c0ee0a9a8e3c487e2501cb1dcb6572d2d149ee" translate="yes" xml:space="preserve">
          <source>Used by GHCi to add an SPT entry for a set of interactive bindings.</source>
          <target state="translated">대화식 바인딩 세트에 대한 SPT 항목을 추가하기 위해 GHCi에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ce78d982417b9cb4deb2ddcc1a484efef31c9e70" translate="yes" xml:space="preserve">
          <source>Used for 'x etc, but not available to the programmer</source>
          <target state="translated">'x 등에 사용되지만 프로그래머는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3847aa787c24cd1d44a17f4805f957dd8caf3458" translate="yes" xml:space="preserve">
          <source>Used for compiler-generated error message; encoding saves bytes of string junk.</source>
          <target state="translated">컴파일러 생성 오류 메시지에 사용됩니다. 인코딩하면 문자열 정크 바이트가 절약됩니다.</target>
        </trans-unit>
        <trans-unit id="48f7b38aeba5a7256e7131d8cb8c98f966810900" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="a955f7ae96dd2396e997eaaba64e06e03450d7ce" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="6f585b6f35665233ba6dfd37448fddc289f902eb" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="f78d41a4bcd03ebc472455f23710c4336f3e4510" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="ae4850a6beb132067b0d17bd048ad2ac3b2c4d19" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="ac37eb2d964ae070e77a81603004056ba16fd6c1" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="cbfbb476822c67fb944c2ccc3737c5d876459fac" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="4ca58513d0191a18bd8970f148670b2ac5f22912" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="9cd28c49f71c816b7f9ae60ffd4e7c302e1776af" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of the parameter</source>
          <target state="translated">매개 변수 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="fea1f906365eb90369e6c8aa238cf26f0304a28e" translate="yes" xml:space="preserve">
          <source>Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?</source>
          <target state="translated">오버로드 및 오버로드되지 않은 리터럴에 사용됩니다. 현재 오버로드되지 않은 리터럴을 표현할 수있는 좋은 방법이 없습니다. 그게 중요하지 않을까요?</target>
        </trans-unit>
        <trans-unit id="238e061ebe06d65547e2bee202766499de802474" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..]&lt;/code&gt; with &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt;, &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; and &lt;code&gt;f n y
     | n &amp;gt; 0 = f (n - 1) (succ y)
     | n &amp;lt; 0 = f (n + 1) (pred y)
     | otherwise = y&lt;/code&gt; For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n,n'..]&lt;/code&gt; 에서 &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt; 에 사용되며 가능한 구현은 &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt; , &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt; , &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; 및 &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec710c9c70c84a0fa35609489a6b9ef33af6c8b0" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..m]&lt;/code&gt; with &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt;, &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt;&lt;code&gt;f n y
      | n &amp;gt; 0 = f (n - 1) (succ y)
      | n &amp;lt; 0 = f (n + 1) (pred y)
      | otherwise = y&lt;/code&gt; and &lt;code&gt;worker s c v m
      | c v m = v : worker s c (s v) m
      | otherwise = []&lt;/code&gt; For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n,n'..m]&lt;/code&gt; 에서 &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt; 에 사용되며 가능한 구현은 &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt; , &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; , &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt; &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 및 &lt;code&gt;worker s c v m | c v m = v : worker s c (s v) m | otherwise = []&lt;/code&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="2376147b4b93f0f0f659194995859c4171be7e97" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..]&lt;/code&gt; with &lt;code&gt;[n..] = enumFrom n&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt;. For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n..]&lt;/code&gt; 을 &lt;code&gt;[n..] = enumFrom n&lt;/code&gt; 변환하는 데 사용되며 가능한 구현은 &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="721ad854036f4864103a86da3e89b972bead0e02" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..m]&lt;/code&gt; with &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromTo n m
      | n &amp;lt;= m = n : enumFromTo (succ n) m
      | otherwise = []&lt;/code&gt;. For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n..m]&lt;/code&gt; 을 &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt; 변환하는 데 사용되며 가능한 구현은 &lt;code&gt;enumFromTo n m | n &amp;lt;= m = n : enumFromTo (succ n) m | otherwise = []&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ba12a872816eab7cd55766f4e299e6fee8d6fce" translate="yes" xml:space="preserve">
          <source>Used to represent a Fast String fragment but now deprecated and identical to the Str constructor.</source>
          <target state="translated">Fast String 조각을 나타내는 데 사용되지만 이제는 더 이상 사용되지 않으며 Str 생성자와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a45835be33274394b1b372013bc338e7249d972f" translate="yes" xml:space="preserve">
          <source>Useful combinator for use in conjunction with the &lt;code&gt;xxxBy&lt;/code&gt; family of functions from &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;, for example:</source>
          <target state="translated">&lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; 의 &lt;code&gt;xxxBy&lt;/code&gt; 함수 계열 과 함께 사용하기에 유용한 결합기 ( 예 :</target>
        </trans-unit>
        <trans-unit id="8a579dd6a4399af21a11c4ed52bc9f7f6576690e" translate="yes" xml:space="preserve">
          <source>Useful error handling functions</source>
          <target state="translated">유용한 오류 처리 기능</target>
        </trans-unit>
        <trans-unit id="2edd003dedc171d3ac005a45bdf1c7df9611bd5d" translate="yes" xml:space="preserve">
          <source>Useful for defining &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; for types for which NF=WHNF holds.</source>
          <target state="translated">NF = WHNF가 보유하는 유형에 대해 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 를 정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="682d4409a64a47028acddb1087ca1ca87620ae82" translate="yes" xml:space="preserve">
          <source>Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then &lt;code&gt;mallocForeignPtr&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a good choice, however.</source>
          <target state="translated">가비지 수집이 필요한 장기 할당에 유용합니다. 그러나 메모리에 대한 포인터를 외부 데이터 구조로 저장하려는 경우 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 을 사용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="565822cd77b6637c10be116d419e7696260595d2" translate="yes" xml:space="preserve">
          <source>Useful for short-term allocation when the allocation is intended to scope over a given &lt;code&gt;IO&lt;/code&gt; computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</source>
          <target state="translated">할당이 지정된 &lt;code&gt;IO&lt;/code&gt; 계산을 통해 범위를 지정하려는 경우 단기 할당에 유용합니다 . 이러한 종류의 할당은 일반적으로 FFI 기능과 데이터를 마샬링 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2af6e52f982f79a13b501af79e093ed843c9514a" translate="yes" xml:space="preserve">
          <source>Useful for:</source>
          <target state="translated">에 유용한:</target>
        </trans-unit>
        <trans-unit id="44bd11006ea2446fabab47fc4ab28f60a56d501a" translate="yes" xml:space="preserve">
          <source>Useful functions and combinators.</source>
          <target state="translated">유용한 기능과 결합기.</target>
        </trans-unit>
        <trans-unit id="4dcc8c5851caf5e6ae38c18983779597f18f22bc" translate="yes" xml:space="preserve">
          <source>Useful functions.</source>
          <target state="translated">유용한 기능.</target>
        </trans-unit>
        <trans-unit id="170b3665888bbcbc92df989b316b0344229dd072" translate="yes" xml:space="preserve">
          <source>Useful helper function</source>
          <target state="translated">유용한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="5654edd09aadece1962526d4e7c8a06e94d88138" translate="yes" xml:space="preserve">
          <source>Useful helpers for writing instances</source>
          <target state="translated">인스턴스 작성에 유용한 헬퍼</target>
        </trans-unit>
        <trans-unit id="cf9d2c2460705878a701d0fdfe5bf5da9d8e8c5d" translate="yes" xml:space="preserve">
          <source>Useful properties resulting from the invariants:</source>
          <target state="translated">불변으로 인한 유용한 속성 :</target>
        </trans-unit>
        <trans-unit id="1770280560169f702ff9a9b3a4b66731a5e241be" translate="yes" xml:space="preserve">
          <source>User environment</source>
          <target state="translated">사용자 환경</target>
        </trans-unit>
        <trans-unit id="7f9550c2041ef0abb58791782b9d7bac7d6fb605" translate="yes" xml:space="preserve">
          <source>User interaction functions</source>
          <target state="translated">사용자 상호 작용 기능</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">사용자 이름</target>
        </trans-unit>
        <trans-unit id="c3c46a581b46f42100507c50992392d2bb9e3eba" translate="yes" xml:space="preserve">
          <source>User preferences</source>
          <target state="translated">사용자 환경 설정</target>
        </trans-unit>
        <trans-unit id="509063363ef89fe8150aab1353f6034852260bd6" translate="yes" xml:space="preserve">
          <source>User-defined operators are flagged with banana brackets instead of a new &lt;code&gt;form&lt;/code&gt; keyword.</source>
          <target state="translated">사용자 정의 연산자에는 새 &lt;code&gt;form&lt;/code&gt; 키워드 대신 바나나 괄호가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7514c17314f4300451e6509de3b0c15d464eb52f" translate="yes" xml:space="preserve">
          <source>User-defined type errors</source>
          <target state="translated">사용자 정의 유형 오류</target>
        </trans-unit>
        <trans-unit id="ddaf25ba7d5224155d5c5745dc554102c7d6bedc" translate="yes" xml:space="preserve">
          <source>User-supplied comparison (replacing an &lt;code&gt;Ord&lt;/code&gt; context)</source>
          <target state="translated">사용자 제공 비교 ( &lt;code&gt;Ord&lt;/code&gt; 컨텍스트 대체 )</target>
        </trans-unit>
        <trans-unit id="3601596f3b23f544013c9df7093000280be41f71" translate="yes" xml:space="preserve">
          <source>User-supplied equality (replacing an &lt;code&gt;Eq&lt;/code&gt; context)</source>
          <target state="translated">사용자 제공 평등 ( &lt;code&gt;Eq&lt;/code&gt; 컨텍스트 대체 )</target>
        </trans-unit>
        <trans-unit id="7d0c5b19b57ac836c34ca570d05dfece9b3a3763" translate="yes" xml:space="preserve">
          <source>UserEntry</source>
          <target state="translated">UserEntry</target>
        </trans-unit>
        <trans-unit id="0c60361852b81bf7f9c1d451a3ffea1b382edcfa" translate="yes" xml:space="preserve">
          <source>UserError</source>
          <target state="translated">UserError</target>
        </trans-unit>
        <trans-unit id="6bc00f4e4ce1e79e2aff101eccac581ca84cc9e9" translate="yes" xml:space="preserve">
          <source>UserID</source>
          <target state="translated">UserID</target>
        </trans-unit>
        <trans-unit id="515d8ba663afe12bffe269a5563a1e3be0f09933" translate="yes" xml:space="preserve">
          <source>UserInterrupt</source>
          <target state="translated">UserInterrupt</target>
        </trans-unit>
        <trans-unit id="03a0196d9c0db13aabbd53088348d392ffc363f9" translate="yes" xml:space="preserve">
          <source>Users can use the same functions that GHC uses internally to compute fingerprints. The &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt; module provides useful functions for constructing fingerprints. For example, combining together &lt;code&gt;fingerprintFingerprints&lt;/code&gt; and &lt;code&gt;fingerprintString&lt;/code&gt; provides an easy to to naively fingerprint the arguments to a plugin.</source>
          <target state="translated">사용자는 GHC가 지문을 계산하기 위해 내부적으로 사용하는 것과 동일한 기능을 사용할 수 있습니다. &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint의&lt;/a&gt; 모듈은 지문을 구성하기위한 유용한 기능을 제공합니다. 예를 들어, &lt;code&gt;fingerprintFingerprints&lt;/code&gt; 와 &lt;code&gt;fingerprintString&lt;/code&gt; 을 함께 사용 하면 플러그인에 인수를 순진하게 쉽게 지문으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc1a454472d7c66c5ba761b635d39b2cf0fa0fb" translate="yes" xml:space="preserve">
          <source>Users may customize the interface with a &lt;code&gt;~/.haskeline&lt;/code&gt; file; see &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;~/.haskeline&lt;/code&gt; 파일을 사용 하여 인터페이스를 사용자 정의 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da092016386ac606886d79c8fb8c43516b7b8c37" translate="yes" xml:space="preserve">
          <source>Users may define their own instances of &lt;code&gt;HasField&lt;/code&gt;, provided they do not conflict with the built-in constraint solving behaviour. This allows &amp;ldquo;virtual&amp;rdquo; record fields to be defined for datatypes that do not otherwise have them.</source>
          <target state="translated">내장 제약 조건 해결 동작과 충돌하지 않는 경우 사용자는 자신의 &lt;code&gt;HasField&lt;/code&gt; 인스턴스를 정의 할 수 있습니다. 이를 통해 다른 유형의 데이터 유형에 대해 &quot;가상&quot;레코드 필드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9a5666b2ee0d2dbc3c969b19d7aa3ebfc7d2f9" translate="yes" xml:space="preserve">
          <source>Users may provide custom instances of &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; which are expected to conform the following rules:</source>
          <target state="translated">사용자는 다음 규칙을 준수 할 것으로 예상되는 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 의 사용자 지정 인스턴스를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e560e88292d8b8c47a593e73f19652f4d50d4e3" translate="yes" xml:space="preserve">
          <source>Users of this function should compile with &lt;code&gt;-threaded&lt;/code&gt; if they want other Haskell threads to keep running while waiting on the result of readProcess.</source>
          <target state="translated">이 기능의 사용자는 컴파일해야 &lt;code&gt;-threaded&lt;/code&gt; 그들이 다른 하스켈 스레드가 readProcess의 결과를 기다리는 동안 계속 실행하려면.</target>
        </trans-unit>
        <trans-unit id="bf2063f5abd0ca89a61797d833fc04083ed0e2e6" translate="yes" xml:space="preserve">
          <source>Users will most likely want &lt;code&gt;~&lt;/code&gt;, but &lt;code&gt;~~&lt;/code&gt; is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; tells GHC both that &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are the same and that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same.</source>
          <target state="translated">사용자는 &lt;code&gt;~&lt;/code&gt; 를 원할 가능성이 높지만 , GHC가 사전에 두 가지 관심 유형이 같은 종류라는 것을 알 수없는 경우 &lt;code&gt;~~&lt;/code&gt; 를 사용할 수 있습니다. 있다는 증거 &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; GHC이 모두 알려 &lt;code&gt;k1&lt;/code&gt; 과 &lt;code&gt;k2&lt;/code&gt; 동일하고 있는지 및 &lt;code&gt;b&lt;/code&gt; 동일하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6f56533730578a43f251e2c5623e991811d7d26" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">구성 및 패턴 일치를 포함하여 생성자를 언급하기 때문에 항상 모호하지 않은 필드를 사용하면 중복 된 필드 이름을 자유롭게 사용할 수 있습니다. 예를 들어, &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 다음이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0265064a73ec5c4a274e96b0ad1d58643baccfe3" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">구성 및 패턴 일치를 포함하여 생성자를 언급하기 때문에 항상 모호하지 않은 필드를 사용하면 중복 된 필드 이름을 자유롭게 사용할 수 있습니다. 예를 들어 다음이 허용됩니다 ( &lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 ).</target>
        </trans-unit>
        <trans-unit id="3581ad6f94790a2bc201861caba85a7f7a678467" translate="yes" xml:space="preserve">
          <source>Uses the generational copying garbage collector for all generations. This is the default.</source>
          <target state="translated">모든 세대에 대해 세대 별 복사 가비지 수집기를 사용합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="612e2184a830c5e8bfb111b212202a249fdd7423" translate="yes" xml:space="preserve">
          <source>Using 8-bit characters</source>
          <target state="translated">8 비트 문자 사용</target>
        </trans-unit>
        <trans-unit id="942545b1bade40c96607a6882802a1a540e6738b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">프로그래머는 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#newtype-deriving&quot;&gt;newtypes의 일반화 된 파생 인스턴스)을&lt;/a&gt; 사용하여 기존 클래스 인스턴스를 가져 와서 새 유형의 해당 클래스 인스턴스로 &quot;리프팅&quot;할 수 있습니다. 그러나 이것이 항상 안전한 것은 아닙니다. 예를 들어 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2206acdb3d9d430eddec1b9a13c7b987ec134bee" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; tells GHC to display incompatibilities between closed type families&amp;rsquo; equations, whenever they are printed by &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt; &lt;code&gt;-fprint-axiom-incomps&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC에 &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; 에&lt;/a&gt; 의해 인쇄 될 때마다 닫힌 유형 패밀리 방정식 간의 비 호환성을 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="ec190b27f84b5eb38a386fb9b591e8f3127b6c54" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;exts/equality_constraints#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC가 인쇄 할 때 동등 관계를 구별하도록 지시합니다. 예를 들어 &lt;code&gt;~&lt;/code&gt; 는 동종 해제 평등 (인수의 종류는 동일)이고 &lt;code&gt;~~&lt;/code&gt; 는 이종 해제 평등 (인수의 종류가 다를 수 있음)이고 &lt;code&gt;~#&lt;/code&gt; 은 이종 해제 평등, GHC에서 사용되는 내부 평등 관계입니다. 해결사. 일반적으로 사용자는 여기서 미묘한 부분에 대해 걱정할 필요가 없습니다. &lt;code&gt;~&lt;/code&gt; 아마도 당신이 원하는 것입니다. &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 가&lt;/a&gt; 없으면 GHC는이 모든 것을 &lt;code&gt;~&lt;/code&gt; 로 인쇄합니다 . &lt;a href=&quot;exts/equality_constraints#equality-constraints&quot;&gt;동등 제약을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="de0b5d96a3f84293d62fc5945b56c1a2f7dbeabf" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC에게 인쇄시 동등 관계를 구별하도록 지시합니다. 예를 들어, &lt;code&gt;~&lt;/code&gt; 는 균질 해제 평등 (인수의 종류는 동일 함)이며 &lt;code&gt;~~&lt;/code&gt; 는 이종 해제 평등 (인수의 종류가 다를 수 있음)이며 &lt;code&gt;~#&lt;/code&gt; 는 이기종 해제 된 평등, GHC의 내부 평등 관계입니다. 솔버. 일반적으로 사용자는 여기서 미묘함에 대해 걱정할 필요가 없습니다. &lt;code&gt;~&lt;/code&gt; 아마 당신이 원하는 것입니다. &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 가&lt;/a&gt; 없으면 GHC는이 모든 것을 &lt;code&gt;~&lt;/code&gt; 로 인쇄합니다 . &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;평등 제약 조건을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="db31842f72950c064c2c1d80ab6cd7638c74c75a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt;&lt;code&gt;-fprint-explicit-coercions&lt;/code&gt;&lt;/a&gt; makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt; &lt;code&gt;-fprint-explicit-coercions&lt;/code&gt; &lt;/a&gt; 유형의 GHC 인쇄 강제 변환을합니다. 다른 종류의 유형 간 동등성을 증명하려고 할 때 GHC는 유형 수준의 강제를 사용합니다. 사용자는 내부 용이므로 이러한 정보를 거의 볼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a865f6c37f89cedcb8505588d923ee2281de4d2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; makes GHC print explicit &lt;code&gt;forall&lt;/code&gt; quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt; GHC는 명시 적으로 인쇄 할 수 &lt;code&gt;forall&lt;/code&gt; 유형의 상단 수준에서 정량화; 일반적으로 이것은 억제됩니다. 예를 들어 GHCi에서 :</target>
        </trans-unit>
        <trans-unit id="43ad6734ad17f8262129b4ce1b63135691fef1c2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; GHC는 일반적으로 억제하는 유형의 종류 인수를 인쇄 할 수 있습니다. 종류 다형성을 사용할 때 중요 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b89399a162079f667d1fdc83d81ed74335bde10d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; 을&lt;/a&gt; 사용하면 &lt;code&gt;myLength1&lt;/code&gt; 형식 시그니처 의 형식 변수가 형식 응용 프로그램에 사용할 수 없다는 결론을 내릴 수 있습니다. 그러나 이것은 사실이 아닙니다! 가시적 유형 응용 프로그램 속성과 관련하여 가장 정확한 정보를 원하면 &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ba5edf2cd7332c5ea401eda291414370405189" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; 을&lt;/a&gt; 사용하면 &lt;code&gt;myLength1&lt;/code&gt; 의 형식 서명 에있는 형식 변수가 형식 응용 프로그램에 사용 가능 하지 않다는 결론을 내릴 수 있습니다. 그러나 이것은 사실이 아닙니다! 보이는 유형 응용 프로그램 속성과 관련하여 가장 정확한 정보를 원하면 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b75747b0323839514f55b98e3b0763a8b7a1bc59" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;rsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; 을&lt;/a&gt; 사용하면 &lt;code&gt;myLength1&lt;/code&gt; 의 유형 서명 에있는 유형 변수가 유형 적용에 사용할 수 없다는 결론을 내릴 수 있습니다. 그러나 이것은 사실이 아닙니다! 가시적 인 유형 응용 프로그램 속성과 관련하여 가장 정확한 정보를 원하면 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6570d089faca67f533b154812bbbc95cc61616d4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">사용 &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;newtypes에 대한 일반화 된 파생 인스턴스&lt;/a&gt; ), 프로그래머는 기존의 클래스의 인스턴스와 newtype이란에 대한 그 클래스의 인스턴스로이 &quot;리프트&quot;를 취할 수 있습니다. 그러나 이것이 항상 안전한 것은 아닙니다. 예를 들어 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c7163ac930661c0cf77d155fe52c3f373ab2481a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; is only really a good idea in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, because otherwise the extra packing and unpacking won&amp;rsquo;t be optimised away. In fact, it is possible that &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; may worsen performance even &lt;em&gt;with&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, but this is unlikely (let us know if it happens to you).</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 를&lt;/a&gt; 사용 하는 것은 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 것이 좋습니다. 그렇지 않으면 추가 포장 및 포장 풀기가 최적화되지 않기 때문입니다. 사실, 가능성이 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 도 성능을 악화시킬 수 &lt;em&gt;와 &lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 를&lt;/a&gt; (그것이 당신에게 무슨 일이 생기면 알려 주시기), 그러나 이것은 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7aa8fda92921d739d127c5d2933e838b7a2f61" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d18768c0ec1399365712ea9b78325eb3b52d261" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a922b4d719b40ab46b07c97a191b43983233d5ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5c8de2889d8f4c002578848aa975a3d58a7fe14" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the &lt;code&gt;-threaded&lt;/code&gt; option when linking your program, and to make sure the foreign import is not marked &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 은 하스켈 런타임 시스템의 스케줄링 행동에 전혀 차이가 없습니다. 당신이 사용해야하는 일반적인 오해입니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 을 외국 전화를 걸 때 모든 하스켈 스레드를 차단하지 않도록; 그렇지 않습니다. 모든 Haskell 스레드 (GHC 포함)를 차단하지 않고 외래 전화를 걸 려면 프로그램을 링크 할 때 &lt;code&gt;-threaded&lt;/code&gt; 옵션 만 사용 하고 외래 가져 오기가 &lt;code&gt;unsafe&lt;/code&gt; 않은지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0401fcf7d550abc85181d154e59167befc356ffe" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수는 있지만 유형 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="653b55d8219ef951a3573cfdf98d122082b2dcdc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 파괴됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수 있지만 typechecker는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않습니다. 즉, 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="96c07fa0636126bb91dda25884d1c1fbe2b0138a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 파괴됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수 있지만 typechecker는 중첩 된 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않습니다. 즉, 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="0e17939a2d4f4e2440854125dad598dc76040ef2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; is a shortcut for &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; in most cases:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; 사용 은 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="4a054818c10692dac12322c248296bc64eb19894" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수는 있지만 유형 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="b09ee4eae40000bfed240eddfae72c34dbbbb367" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수는 있지만 유형 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="40b41e20161a45a722c2225074d2b6894f2f36e9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="327764f8188ed7c066bf1aeb35152bb98286d9d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab3deb78b20e89efa13a9a442f13a5722f047491" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b96ae088c649d5a06c694f9e9ee5ee9dc8687a02" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d111b0d48c558b38badb2c9405749a987627b42" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2172f3ccd962a6ecd9b4cc15ce3cf95a1be7eb5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f674202704940c277740f7f4ae49cd37b3a5f78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt;' can be understood as the pseudo-&lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt; '는 pseudo- &lt;code&gt;do&lt;/code&gt; 표현 으로 이해 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b459af09ae8043d5f7b1a6c9159131c0b0fd22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4087f9008dd31f8281176bc7c8f4d1d90f9e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1570094d52e557732c703a05b9b1c145c2dd064a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f501d2ca81d0c4860698f021f0de3ecdc4a0f4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="108f9b97edb22ce149c8927414975f8505b7580d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c837790b7d1462717c4308d600ad3e92eeaf1c9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">사용 &lt;code&gt;ApplicativeDo&lt;/code&gt; 를 ' &lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt; '는 것으로 이해 될 수있다 &lt;code&gt;do&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="14c32ccf8b63eb011e4dfda0a4088dddc4bcbb92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd6b1455603f9e6df9249daef0be0bed100da03" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2a8dbc4ffe0ccbf1d373d624329159d46946500" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b865211f58b24998cdf3ed8e08bdcf5e692e5e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00a3efcb29a05c36224847d355496627fce12e1f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9165dbc2c9969c24f2215ef6972a0880bb8278cb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4a4d9eb30eacc6d2b8ca81bb1bd234ce8594a6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ccbb1fb2ddb1f53f896c4cc85e9a37ce0b41f0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fce8cbc36fc6d6dcdd6a6150d8297a2eb75e02c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1004bfc9a7477fe977e15f814e05ceb1b205da67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71cb9307570de629188fffa91efa031876cc2110" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="774bbfc5e54c815dbed906d0f74123e150de4f6c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69d911e731ca95c1fd9a07c919774126a522e977" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84196a31a9d5c8e34d17aa2ef18dc24c40e44aab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b25d8a860bc159c6b22d827207b11014882905b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a06315a7f9f08f9387659d3c5c4197621c13971" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64871c74d2047073bc61343ed982993443145244" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7235239be554865a0935a618eb2b2336543f4705" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6309b1896f5220de1092c0929134f7a07019870d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a548000114a6581f99bb89aac62e4c4178082e2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; 사용 : ' &lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; '는 &lt;code&gt;do&lt;/code&gt; 표현식 으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6203018fe62d6ff03754e5bb607909a52d373ff" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">로 ByteStrings를 사용 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="7f60e44e7419f981a24cfdfef3321af38c83c15f" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;CString&lt;/code&gt;s</source>
          <target state="translated">로 ByteStrings를 사용 &lt;code&gt;CString&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="a94cb64e5153c8019b8459af3ab058315f2c3c3a" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as CStrings</source>
          <target state="translated">ByteString을 CString으로 사용</target>
        </trans-unit>
        <trans-unit id="b40f94fc1f11dd5c42c861cd8b875e12da7278be" translate="yes" xml:space="preserve">
          <source>Using ByteStrings with functions for CStrings</source>
          <target state="translated">CString에 함수와 함께 ByteStrings 사용</target>
        </trans-unit>
        <trans-unit id="5c85522eb99bdc899ee747f76772b3a2cff55270" translate="yes" xml:space="preserve">
          <source>Using GHC without the &lt;code&gt;-threaded&lt;/code&gt; option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the &lt;code&gt;-threaded&lt;/code&gt; option, only foreign calls with the &lt;code&gt;unsafe&lt;/code&gt; attribute will block all other threads.</source>
          <target state="translated">&lt;code&gt;-threaded&lt;/code&gt; 옵션 없이 GHC를 사용하면 모든 외래 호출은 시스템의 다른 모든 Haskell 스레드를 차단하지만 I / O 작업은 그렇지 않습니다. 으로 &lt;code&gt;-threaded&lt;/code&gt; 옵션의 만 외국 통화 &lt;code&gt;unsafe&lt;/code&gt; 속성은 다른 모든 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="251592b15ab7216827445436b461897f62f41677" translate="yes" xml:space="preserve">
          <source>Using GHC&amp;rsquo;s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix &lt;code&gt;/usr/lib&lt;/code&gt;. To obtain the version number of GHC invoke &lt;code&gt;ghc --numeric-version&lt;/code&gt; and use its output in place of ⟨GHCVersion⟩. See also &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt; on how object files must be prepared for shared object linking.</source>
          <target state="translated">공유 객체 이름에 GHC의 버전 번호를 사용하면 다른 GHC 버전으로 컴파일 된 다른 라이브러리 버전을 표준 시스템 위치 (예 : * nix &lt;code&gt;/usr/lib&lt;/code&gt; 아래)에 설치할 수 있습니다 . GHC의 버전 번호를 얻으려면 &lt;code&gt;ghc --numeric-version&lt;/code&gt; 을 호출 하고 ⟨GHCVersion⟩ 대신 해당 출력을 사용하십시오. 공유 객체 링크를 위해 객체 파일을 준비하는 방법에 대한 &lt;a href=&quot;phases#options-codegen&quot;&gt;코드 생성&lt;/a&gt; 에 영향을주는 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d44a49d31d530124806f0f14d7c3a25fa4d0e74c" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 조합을 사용하면 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; 프레임 워크를 사용하여 데이터 유형 일반 프로그래밍을 쉽게 수행 할 수 있습니다 . 이 섹션에서는 수행 방법에 대한 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f8eaede999cdbad9cc93f8d51a7d597d7f74c072" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 조합을 사용하면 &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; 프레임 워크를 사용하여 데이터 유형 제네릭 프로그래밍을 쉽게 수행 할 수 있습니다 . 이 섹션에서는이를 수행하는 방법에 대한 매우 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c82c05e8fe15e1579841159f1a517a26f5bffb8" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 조합을 사용하면 &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; 프레임 워크를 사용하여 데이터 유형 일반 프로그래밍을 쉽게 수행 할 수 있습니다 . 이 섹션에서는이를 수행하는 방법에 대한 매우 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e9d8addfa8df264e573b6a81847a90f2b01a758" translate="yes" xml:space="preserve">
          <source>Using a locale-dependent encoding</source>
          <target state="translated">로케일 종속 인코딩 사용</target>
        </trans-unit>
        <trans-unit id="ab506530173fceaff35d888e32b6577ed8bfcdc6" translate="yes" xml:space="preserve">
          <source>Using a package couldn&amp;rsquo;t be simpler: if you&amp;rsquo;re using &lt;code&gt;--make&lt;/code&gt; or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in &lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;.</source>
          <target state="translated">패키지를 사용하는 것이 더 간단 할 수는 없습니다 : &lt;code&gt;--make&lt;/code&gt; 또는 GHCi를 사용 하는 경우 설치된 패키지의 대부분은 추가 옵션없이 프로그램에서 자동으로 사용할 수 있습니다. 이 규칙의 예외는 아래의 &lt;a href=&quot;#using-packages&quot;&gt;패키지 사용&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="ec49e61de1a6708770ca5ea53d854637f189900e" translate="yes" xml:space="preserve">
          <source>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</source>
          <target state="translated">값을 0으로 설정하면 RTS 클럭이 완전히 비활성화되고 컨텍스트 스위치 타이머 및 힙 프로파일 링 타이머에 따라 타이머를 비활성화하는 효과가 있습니다. 상황 전환은 여전히 ​​발생하지만 결정 론적으로 정상보다 훨씬 빠른 속도로 진행됩니다. 인터벌 타이머를 비활성화하면 런타임시 비결 정성 소스가 제거되므로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6a4a9903244534f370840c1922f33e5fac470a05" translate="yes" xml:space="preserve">
          <source>Using hole-fit plugins, you can extend the behavior of valid hole fit suggestions to use e.g. Hoogle or other external tools to find and/or synthesize valid hole fits, with the same information about the typed-hole that GHC uses.</source>
          <target state="translated">구멍 맞춤 플러그인을 사용하면 유효한 구멍 맞춤 제안의 동작을 확장하여 GHC가 사용하는 유형이 지정된 구멍에 대한 동일한 정보를 사용하여 Hoogle 또는 기타 외부 도구를 사용하여 유효한 구멍 맞춤을 찾거나 합성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32acf51d7f62b559e6f6ac1d8c3d14ffc7ed8b21" translate="yes" xml:space="preserve">
          <source>Using record selectors</source>
          <target state="translated">레코드 선택기 사용</target>
        </trans-unit>
        <trans-unit id="3077d1ef00911ed60eb22f6af1d4962cdd9d8cfb" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt; flag, you can compile modules in parallel. Specify &lt;code&gt;-j ⟨n⟩&lt;/code&gt; to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 모듈을 병렬로 컴파일 할 수 있습니다. ⟨n⟩ 작업을 병렬로 컴파일하려면 &lt;code&gt;-j ⟨n⟩&lt;/code&gt; 을 지정 하십시오 . ⟨n⟩을 생략하면 기본값은 프로세서 수입니다.</target>
        </trans-unit>
        <trans-unit id="858fa87b359c2a8dfa1bed3d7354f1c98c94c937" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;+&lt;/code&gt; form of the &lt;code&gt;module&lt;/code&gt; commands adds modules to the current scope, and &lt;code&gt;-&lt;/code&gt; removes them. Without either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out &lt;code&gt;Prelude&lt;/code&gt;, an implicit &lt;code&gt;Prelude&lt;/code&gt; import will be added automatically.</source>
          <target state="translated">은 Using &lt;code&gt;+&lt;/code&gt; 용 의 형태 &lt;code&gt;module&lt;/code&gt; 명령은 현재 범위에 모듈을 추가하고 &lt;code&gt;-&lt;/code&gt; 이를 제거한다. &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 가 없으면 현재 범위는 지정된 모듈 세트로 대체됩니다. 이 양식을 사용하고 &lt;code&gt;Prelude&lt;/code&gt; 를 생략 하면 암시 적 &lt;code&gt;Prelude&lt;/code&gt; 가져 오기가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="dcd0ac8cbd97b2347e8fe4749682a842e661035c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;control-monad#v:Except&quot;&gt;Except&lt;/a&gt;&lt;/code&gt;, the following functions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:Except&quot;&gt;Except&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용하여 다음 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="88ce1fb571afb65c6d0e842b399fa0b1a914f2d0" translate="yes" xml:space="preserve">
          <source>Using this is expected to make the program slightly slower.</source>
          <target state="translated">이것을 사용하면 프로그램이 약간 느려질 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5ef9a787762006bd887ef2118ae12eb3d21b09" translate="yes" xml:space="preserve">
          <source>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;Haskell on a shared-memory multiprocessor&lt;/a&gt;.</source>
          <target state="translated">일반적으로 GHC 블랙홀은 스레드를 전환 할 때만 썽크입니다. 이 플래그는 썽크가 입력 되 자마자 그렇게합니다. &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;공유 메모리 멀티 프로세서에서 Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af0f890994f908319ff8d9afb1777b9fcb88bad5" translate="yes" xml:space="preserve">
          <source>Usually the real name for the user (pw_gecos)</source>
          <target state="translated">일반적으로 사용자의 실제 이름 (pw_gecos)</target>
        </trans-unit>
        <trans-unit id="ab2c7549e2b0bdddc9c6bb5863f4c4abcb5e2393" translate="yes" xml:space="preserve">
          <source>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module &lt;code&gt;A.B.C&lt;/code&gt; should be placed in the file &lt;code&gt;A/B/C.hs&lt;/code&gt;, relative to some base directory. If the module is not going to be imported by another module (&lt;code&gt;Main&lt;/code&gt;, for example), then you are free to use any filename for it.</source>
          <target state="translated">일반적으로 파일 이름은 모듈 이름을 따서 지정해야하며 모듈 이름의 점은 디렉토리 구분 기호로 대체해야합니다. 예를 들어, Unix 시스템에서 &lt;code&gt;A.B.C&lt;/code&gt; 모듈 은 일부 기본 디렉토리와 관련 하여 파일 &lt;code&gt;A/B/C.hs&lt;/code&gt; 에 배치되어야합니다 . 다른 모듈 ( 예 : &lt;code&gt;Main&lt;/code&gt; ) 에서 모듈을 가져 오지 않으면 파일 이름을 자유롭게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="9cb298e9034198322f8d610f9cbe52f277fdbbe5" translate="yes" xml:space="preserve">
          <source>Utilities for calling Win32 API</source>
          <target state="translated">Win32 API 호출을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="4f53403de824c0a45ffa413d18703d7d05768956" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshaling</source>
          <target state="translated">기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="4bc50e97c77d17fd8ac0d95a8e80d0d8b03fc415" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of C strings.</source>
          <target state="translated">C 문자열의 기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="5a3ec9890970dfcee014d906f6083905237f8661" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of Windows' C strings.</source>
          <target state="translated">Windows C 문자열의 기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="3e0867dbafd8a42d911ff54eb5dad6778a1edcbf" translate="yes" xml:space="preserve">
          <source>Utility functions for documents</source>
          <target state="translated">문서를위한 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="b88d1ba4914007f59dea7e944d19e43e2ddb7cc5" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitQueue</source>
          <target state="translated">Utils.Containers.Internal.BitQueue</target>
        </trans-unit>
        <trans-unit id="7b70402153c5d56ff512a1212d04b73c0f830ab1" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitUtil</source>
          <target state="translated">Utils.Containers.Internal.BitUtil</target>
        </trans-unit>
        <trans-unit id="ad42400973d4932315815a075fb7ef6560156596" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.StrictPair</source>
          <target state="translated">Utils.Containers.Internal.StrictPair</target>
        </trans-unit>
        <trans-unit id="c14e3dde339a29a416ace2e144201e8a61988686" translate="yes" xml:space="preserve">
          <source>V1</source>
          <target state="translated">V1</target>
        </trans-unit>
        <trans-unit id="fdd7168fb33dcc8aadeb03f101642602b4482322" translate="yes" xml:space="preserve">
          <source>VDisableChar</source>
          <target state="translated">VDisableChar</target>
        </trans-unit>
        <trans-unit id="0dd37a83e54442139e4aed5d892a8264e1d1a20d" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls: &lt;code&gt;ByteArray#&lt;/code&gt; and &lt;code&gt;MutableByteArray#&lt;/code&gt;. The byte array must be &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;pinned&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;foreign import safe&lt;/code&gt; FFI 호출에 유효한 인수 : &lt;code&gt;ByteArray#&lt;/code&gt; 및 &lt;code&gt;MutableByteArray#&lt;/code&gt; . 바이트 배열은 &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;고정&lt;/a&gt; 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="89dcf84a837ed25d40e781204368ac37d7aee9e9" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import unsafe&lt;/code&gt; FFI calls: &lt;code&gt;Array#&lt;/code&gt;, &lt;code&gt;SmallArray#&lt;/code&gt;, &lt;code&gt;ArrayArray#&lt;/code&gt;, &lt;code&gt;ByteArray#&lt;/code&gt;, and the mutable counterparts of these types.</source>
          <target state="translated">&lt;code&gt;foreign import unsafe&lt;/code&gt; FFI 호출에 유효한 인수 : &lt;code&gt;Array#&lt;/code&gt; , &lt;code&gt;SmallArray#&lt;/code&gt; , &lt;code&gt;ArrayArray#&lt;/code&gt; , &lt;code&gt;ByteArray#&lt;/code&gt; 및 이러한 유형의 변경 가능한 대응 항목.</target>
        </trans-unit>
        <trans-unit id="ae8a9ce75262d79bd93f92191a9bbcb04181578d" translate="yes" xml:space="preserve">
          <source>Valid list of valid refinement hole fits can often grow large when the refinement level is &lt;code&gt;&amp;gt;= 2&lt;/code&gt;, with holes like &lt;code&gt;head _ _&lt;/code&gt; or &lt;code&gt;fst _ _&lt;/code&gt;, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</source>
          <target state="translated">유효한 &lt;code&gt;fst _ _&lt;/code&gt; 구멍 인 &lt;code&gt;head _ _&lt;/code&gt; 또는 fst _ _ 와 같은 구멍 이 있지만 리파이닝 레벨이 &lt;code&gt;&amp;gt;= 2&lt;/code&gt; 인 경우 유효한 리파이닝 구멍 맞춤의 유효한 목록이 종종 커질 수 있습니다 .이 구멍 은 하나 이상의 구멍 때문에 관련이 없을 것입니다 이러한 구멍의 종류 나 종류가 제안 된 식별자에 의해 전혀 제약을받지 않는다는 점에서 여전히 완전히 개방되어있다. 기본적으로 이러한 구멍은보고되지 않습니다. 이 플래그를 켜면 해당 구멍이 유효한 다듬기 구멍 맞춤 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="06dce05cc030efdb204cf599ff782415e84cde95" translate="yes" xml:space="preserve">
          <source>Validates &lt;code&gt;name&lt;/code&gt;. This approach illustrates advantage of using &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt;. We pass the continuation to &lt;code&gt;validateName&lt;/code&gt;, and interrupt execution of the &lt;code&gt;Cont&lt;/code&gt; block from &lt;em&gt;inside&lt;/em&gt; of &lt;code&gt;validateName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 의 유효성을 검사합니다 . 이 접근 방식은 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt; 사용의 장점을 보여 줍니다 . 우리는에 계속 전달 &lt;code&gt;validateName&lt;/code&gt; 및 인터럽트의 실행을 &lt;code&gt;Cont&lt;/code&gt; 발 블록 &lt;em&gt;내부&lt;/em&gt; 의 &lt;code&gt;validateName&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="7e3d80a59e713df86b771fc1d2dd18a3958c972f" translate="yes" xml:space="preserve">
          <source>Validation use-case</source>
          <target state="translated">유효성 검사 사용 사례</target>
        </trans-unit>
        <trans-unit id="5a57a1d6fee5b373ae7f22a03bfc92a759af4f09" translate="yes" xml:space="preserve">
          <source>Value computed while filling this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 를 채우는 동안 계산 된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="b73ed1f417d158fcb9b149b9e60cf332e0c47800" translate="yes" xml:space="preserve">
          <source>Values encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class could be written on any machine, and read back on any another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여 인코딩 된 값 은 항상 네트워크 순서 (빅 엔디안) 형식으로 인코딩되며 인코딩 된 데이터는 컴퓨터 엔디안, 워드 크기 또는 컴파일러 버전간에 이식 가능해야합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여 인코딩 된 데이터 는 모든 컴퓨터에서 쓰고 다른 컴퓨터에서 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01add5475921fe7570fa9905256bf6986e326854" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;TExp a&lt;/code&gt; may be converted to values of type &lt;code&gt;Exp&lt;/code&gt; using the function &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TExp a&lt;/code&gt; 유형의 값은 &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt; 함수를 사용하여 &lt;code&gt;Exp&lt;/code&gt; 유형의 값으로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c964e3ccb5360d4732d58bfab5d5bef0a8262e7" translate="yes" xml:space="preserve">
          <source>Vanilla type synonym declarations are exactly as in Haskell.</source>
          <target state="translated">바닐라 유형 동의어 선언은 Haskell에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f5cef75c90dc2e8cbbacdc00ed3a93e598d08c37" translate="yes" xml:space="preserve">
          <source>VarBangType</source>
          <target state="translated">VarBangType</target>
        </trans-unit>
        <trans-unit id="b1ba05716061d4ad4a7067da94c9ed09f99a946c" translate="yes" xml:space="preserve">
          <source>VarBangTypeQ</source>
          <target state="translated">VarBangTypeQ</target>
        </trans-unit>
        <trans-unit id="f123f793dd439ad762f7c51e88cad426181d7814" translate="yes" xml:space="preserve">
          <source>VarName</source>
          <target state="translated">VarName</target>
        </trans-unit>
        <trans-unit id="531a33bcae814983d338572b59b9463ed28fb861" translate="yes" xml:space="preserve">
          <source>VarStrictType</source>
          <target state="translated">VarStrictType</target>
        </trans-unit>
        <trans-unit id="5711069c2082e5c4d77257ab44a6c08571094741" translate="yes" xml:space="preserve">
          <source>VarStrictTypeQ</source>
          <target state="translated">VarStrictTypeQ</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="15c4ecedc500ccfa482669edb2e845eacd4e0e84" translate="yes" xml:space="preserve">
          <source>Variables not available for type application come first.</source>
          <target state="translated">타입 어플리케이션에 사용할 수없는 변수가 우선입니다.</target>
        </trans-unit>
        <trans-unit id="ad3fca5915fe871548a7a02e59688c2946d84dec" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">사용자가 명시 적으로 정렬하지 않은 변수는 ScopedSort ( &lt;a href=&quot;#scopedsort&quot;&gt;지정된 변수의&lt;/a&gt; 정렬)에 따라 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7cf04f66b938e191f936b1736b7f07717f7def2" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;type_applications#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">사용자가 명시 적으로 정렬하지 않은 변수는 ScopedSort ( &lt;a href=&quot;type_applications#scopedsort&quot;&gt;지정된 변수의&lt;/a&gt; 정렬)에 따라 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="7890a19f065bc82a225115edf83959ecb868d200" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (ScopedSort).</source>
          <target state="translated">사용자가 명시 적으로 정렬하지 않은 변수는 ScopedSort (ScopedSort)에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="ce923a612b2be3e0d26e1de671e160005bec40d5" translate="yes" xml:space="preserve">
          <source>Variant of (&amp;gt;&amp;gt;) which allows effectful computations to be injected into code generation.</source>
          <target state="translated">효과적인 계산을 코드 생성에 삽입 할 수있는 (&amp;gt;&amp;gt;)의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="7e69428f906bf03a78f1b42caa4156197b506c43" translate="yes" xml:space="preserve">
          <source>Variant of (&amp;gt;&amp;gt;=) which allows effectful computations to be injected into code generation.</source>
          <target state="translated">효과적인 계산을 코드 생성에 삽입 할 수있는 (&amp;gt;&amp;gt; =)의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="c5051532d560f3e6f1cb25da75aeaa4c6b08bdc0" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; with the &quot;barrier to reordering&quot; property that &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; has.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; 하는 &quot;장벽 재정렬에&quot;속성 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6152289241c94f597f6f430c66fd3bcb3064ef73" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 의 스타일 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="556bb60fe16c57c50b8543c1c68d9deecb83fe23" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 의 스타일 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ab80571e288ed5bbe0be1c8d6716fdd8193ae7b" translate="yes" xml:space="preserve">
          <source>Varieties of allowed instance overlap.</source>
          <target state="translated">허용되는 인스턴스의 다양성이 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="835f0ba40d3b282f5ab98f68f598b44f65bc9888" translate="yes" xml:space="preserve">
          <source>Vec16</source>
          <target state="translated">Vec16</target>
        </trans-unit>
        <trans-unit id="540c75a5875243c37fecc6bd16c9d7f6772ae9cf" translate="yes" xml:space="preserve">
          <source>Vec2</source>
          <target state="translated">Vec2</target>
        </trans-unit>
        <trans-unit id="dc943584902ab4bbd002a43d692ce71b9d58f2de" translate="yes" xml:space="preserve">
          <source>Vec32</source>
          <target state="translated">Vec32</target>
        </trans-unit>
        <trans-unit id="f8eca818e08bab8db06cb6f66fc580f204186bc4" translate="yes" xml:space="preserve">
          <source>Vec4</source>
          <target state="translated">Vec4</target>
        </trans-unit>
        <trans-unit id="8ba0e699ad554ce2e474bcde193517e598ba5c05" translate="yes" xml:space="preserve">
          <source>Vec64</source>
          <target state="translated">Vec64</target>
        </trans-unit>
        <trans-unit id="77c1450dba51a2de1b8c2c3dea0bef1c0881e1c4" translate="yes" xml:space="preserve">
          <source>Vec8</source>
          <target state="translated">Vec8</target>
        </trans-unit>
        <trans-unit id="71dc2126c05298594ccc8ee707120167da9301ff" translate="yes" xml:space="preserve">
          <source>VecCount</source>
          <target state="translated">VecCount</target>
        </trans-unit>
        <trans-unit id="0ad1ad8219ee6dfc03f9e55b6d4f4192aec151ef" translate="yes" xml:space="preserve">
          <source>VecElem</source>
          <target state="translated">VecElem</target>
        </trans-unit>
        <trans-unit id="5b8fb03269330bfd03e8a0ef6505dd31cd9aef3b" translate="yes" xml:space="preserve">
          <source>VerNTDomainControler</source>
          <target state="translated">VerNTDomainControler</target>
        </trans-unit>
        <trans-unit id="c615bd07a7c294b1379f8a4f09767f529b9759c0" translate="yes" xml:space="preserve">
          <source>VerNTServer</source>
          <target state="translated">VerNTServer</target>
        </trans-unit>
        <trans-unit id="99b2611bdc2d4621ca6b2a6f13d6c11fd6197f76" translate="yes" xml:space="preserve">
          <source>VerNTWorkStation</source>
          <target state="translated">VerNTWorkStation</target>
        </trans-unit>
        <trans-unit id="9ae538ce2ead84f96e0983545f16a938a86ec050" translate="yes" xml:space="preserve">
          <source>VerboseGCStats</source>
          <target state="translated">VerboseGCStats</target>
        </trans-unit>
        <trans-unit id="c004031cc38b772cc79ef49fac3a30036d52b965" translate="yes" xml:space="preserve">
          <source>Verify OS version</source>
          <target state="translated">OS 버전 확인</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d0560558326cfe0814496b75139ad411b6e5c6d7" translate="yes" xml:space="preserve">
          <source>Version Info</source>
          <target state="translated">버전 정보</target>
        </trans-unit>
        <trans-unit id="6392f7e65414938d8f9a4a698376045c9e03b96e" translate="yes" xml:space="preserve">
          <source>Version information about your computer.</source>
          <target state="translated">컴퓨터에 대한 버전 정보.</target>
        </trans-unit>
        <trans-unit id="e16193c9fa0396ab60a71b729b4a04cd813d0d61" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; without any value being passed to the second and third actions.</source>
          <target state="translated">두 번째 및 세 번째 작업에 값이 전달되지 않은 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="a4d9e02f3589b6f19de666e5b0bee38d7559d42d" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="74c019334e2fff57ca4e39f259c2452610b715a1" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="0c674b58777219e1075437ed39b3c9108ee08578" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="3f6eda259e7693d3f6bb91c551fe6552272e7401" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="1e7284b212c3e18b15655fd8a93f4230611c203f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="bd6ce8b322b59cc5d8064026a32cbb943fe8545c" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="832e7e2813641581d62224e801d6ea6e8ce61f6e" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; 구성하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="15a7e4e675439edfb4791329d53c5140785feffe" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; 구성하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="3383f2c0a3a8b49db2500fd0baa98b81bb0d0957" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="f765b17c2a64921c78875b10782b9628b760d848" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="9d7b173a0dcac34771410bf511deb7fb53172de2" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 크기의 모듈에 대한 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="c801b21720bc581908856b870e17ed49d47664d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 크기의 moduli 용 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="5327d1f9c85d2b9f4ca753101d89eae2dbb8c788" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="bcd38df7c17761d370b1e5803d31bed7f709a369" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="4d5f4af0d958ccbfedde85a3c86cd01593836917" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="b6f1069fce56ce801f8354d107d5e21e6b621ce9" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="1c0304fc532fda6e0a0fb66673b691dbdd8f5987" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="cd667eefc588b1d250466aacaf85fc27e718fb5f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="a6044e2d3109e70122fc56fdcea3e1d09e656dfa" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="22b9c46cdd68688219fc77a7a7a0110bec5346a6" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 버전 #</target>
        </trans-unit>
        <trans-unit id="34e828c6392feef9cda9a5abcfda4742e696efb0" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 의 버전</target>
        </trans-unit>
        <trans-unit id="a536b25d8e167ced3997cbed939d7787c9262c5a" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="e9f8dae2a07adfa71cf9369406dff32b07be5f54" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="9f8f2244600b387515bdab7904923bc126c9eb96" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="8cdbd76fc9bb8d2b3e6d6713ff0d54dc00311cca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;nextPrimeInteger&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;nextPrimeInteger&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전</target>
        </trans-unit>
        <trans-unit id="0ebfec0d93e79f27fbe5c6446dcd99376cb8889b" translate="yes" xml:space="preserve">
          <source>Version of Unicode standard used by &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 에서 사용하는 유니 코드 표준 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="c6de149b153b8aa69634515bd7cf4e2a928766c9" translate="yes" xml:space="preserve">
          <source>Versioning schemes are many and varied, so the version representation provided by this library is intended to be a compromise between complete generality, where almost no common functionality could reasonably be provided, and fixing a particular versioning scheme, which would probably be too restrictive.</source>
          <target state="translated">버전 관리 체계는 다양하고 다양하므로이 라이브러리에서 제공하는 버전 표현은 거의 모든 기능이 합리적으로 제공 될 수없는 전체 일반 성과 너무 제한적인 특정 버전 관리 체계를 수정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5648eccf2ada7509f9293bed38e65578d366748" translate="yes" xml:space="preserve">
          <source>Vertex</source>
          <target state="translated">Vertex</target>
        </trans-unit>
        <trans-unit id="7c6f1ef6ee2199899662d0306223ad7c19cd46c1" translate="yes" xml:space="preserve">
          <source>Very unsafe coercion</source>
          <target state="translated">매우 안전하지 않은 강제</target>
        </trans-unit>
        <trans-unit id="258d739865b4967aba2b35b179e8923c0c132927" translate="yes" xml:space="preserve">
          <source>View of the left end of a sequence.</source>
          <target state="translated">시퀀스의 왼쪽 끝을 봅니다.</target>
        </trans-unit>
        <trans-unit id="e5a2c0c052661af0715d02ca0746b83ffc99ead9" translate="yes" xml:space="preserve">
          <source>View of the right end of a sequence.</source>
          <target state="translated">시퀀스의 오른쪽 끝보기</target>
        </trans-unit>
        <trans-unit id="d4429efe2ba08d11709f9a9411ea8bf96035c79f" translate="yes" xml:space="preserve">
          <source>View patterns</source>
          <target state="translated">패턴보기</target>
        </trans-unit>
        <trans-unit id="759011cb4b498a00a5d40b985273fec7c69b96d4" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">언어 패턴 &lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; 에&lt;/a&gt; 의해 뷰 패턴이 활성화됩니다 . 보기 패턴에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e310bf26720d505a9536f51e809dfeaae92ef176" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">보기 패턴은 언어 확장 &lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; 에&lt;/a&gt; 의해 활성화됩니다 . 보기 패턴에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="385f30104d7ac03e2ef259bd63000a69f570c213" translate="yes" xml:space="preserve">
          <source>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</source>
          <target state="translated">뷰 패턴은 다른 패턴 안에 중첩 될 수있는 패턴 가드와 다소 비슷합니다. 그것들은 추상 타입의 값들에 대한 패턴 매칭의 편리한 방법입니다. 예를 들어, 프로그래밍 언어 구현에서 다음과 같이 언어 유형의 구문을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df943f62e6c8ddc92646e7016412dbb6ea1b50e" translate="yes" xml:space="preserve">
          <source>View patterns permit calling the view function inside the pattern and matching against the result:</source>
          <target state="translated">뷰 패턴을 사용하면 패턴 내부에서 뷰 함수를 호출하고 결과와 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb31bc0e3393551ce685fb55bf7120aa72babea6" translate="yes" xml:space="preserve">
          <source>ViewL</source>
          <target state="translated">ViewL</target>
        </trans-unit>
        <trans-unit id="d1991a4d3da871522e2bbc6ec649eb8b2443c06f" translate="yes" xml:space="preserve">
          <source>ViewPatterns</source>
          <target state="translated">ViewPatterns</target>
        </trans-unit>
        <trans-unit id="2b6a45709971580ec2c9bf4fd7edac984b91011b" translate="yes" xml:space="preserve">
          <source>ViewR</source>
          <target state="translated">ViewR</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="0c9512fc7af324680205ac18f56b08c8977ff468" translate="yes" xml:space="preserve">
          <source>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</source>
          <target state="translated">거의 모든 종류의 데이터 생성자를 포함하여 거의 모든 데이터 생성자를 승격시킬 수 있습니다. 이 규칙에는 몇 가지 예외 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="0e6da5d7cf3ddcb038a9cd33f4c9a4ead9f1f224" translate="yes" xml:space="preserve">
          <source>Void#</source>
          <target state="translated">Void#</target>
        </trans-unit>
        <trans-unit id="1744c6671af49183ef1e812a57246c735303f9b9" translate="yes" xml:space="preserve">
          <source>Void: used for datatypes without constructors</source>
          <target state="translated">무효 : 생성자가없는 데이터 유형에 사용</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="fc9b625441892438a2a4e98eb96658b46731cefe" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경고 :이 기능은 맵을 손상시킬 수 있으며 결과는 입력의 내부 구조에 따라 달라질 수 있습니다. 사용자는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 를 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f1d631a527f3bd9dc355e39579514f4553de63e" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경고 :이 기능은 맵을 손상시킬 수 있으며 결과는 입력의 내부 구조에 따라 달라질 수 있습니다. 사용자는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 를 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="084fa6805f92e87b6e77edf5f9a630d4cdb4aefc" translate="yes" xml:space="preserve">
          <source>WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign.</source>
          <target state="translated">경고 : 컴파일러가 기본 데이터 구조를 자유롭게 최적화하거나 복제 할 수 있기 때문에 기본이 아닌 기본 Haskell 유형에 대한 약한 포인터는 특히 취약합니다. 따라서 종료자를 일반 Haskell 유형에 배치하려고하면 종료 기가 예상보다 빨리 실행될 수 있습니다. 조기 종료가 쉬운 캐시 및 메모 테이블에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="828a0630535cfdfa8da88cbc77494ab9ee052b4d" translate="yes" xml:space="preserve">
          <source>WIN32_FILE_ATTRIBUTE_DATA</source>
          <target state="translated">WIN32_FILE_ATTRIBUTE_DATA</target>
        </trans-unit>
        <trans-unit id="365c8d927f6c55a00833c44920ae5ef485b24497" translate="yes" xml:space="preserve">
          <source>WIN32_FIND_DATA</source>
          <target state="translated">WIN32_FIND_DATA</target>
        </trans-unit>
        <trans-unit id="2902f0e3f68395e4fc65aadd29162468ba35af66" translate="yes" xml:space="preserve">
          <source>WNDCLASS</source>
          <target state="translated">WNDCLASS</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="430f8d35dbcd6de24ccbd7d66bfdb1103a3b3b50" translate="yes" xml:space="preserve">
          <source>WPARAM</source>
          <target state="translated">WPARAM</target>
        </trans-unit>
        <trans-unit id="6bbe857b7c7f17106bc9c59652d265e7579cd9db" translate="yes" xml:space="preserve">
          <source>Wait for a unit to become available</source>
          <target state="translated">장치를 사용할 수있게 될 때까지 기다리십시오</target>
        </trans-unit>
        <trans-unit id="6318af48ff9b448ca1d106c8c5f9cb40406a4e18" translate="yes" xml:space="preserve">
          <source>Wait for the specified quantity to become available</source>
          <target state="translated">지정된 수량이 준비 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="27f62e224bf5811713a6aa41515c5ce1c138cd54" translate="yes" xml:space="preserve">
          <source>Wait on &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; (aka &lt;strong&gt;P&lt;/strong&gt; operation).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 을 기다 립니다 (일명 &lt;strong&gt;P&lt;/strong&gt; 작업).</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="fdee09e1c8568a0971d8797c7eceeb9038bfcbcb" translate="yes" xml:space="preserve">
          <source>Waiting for signals</source>
          <target state="translated">신호를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="572c89962b6ad39f8a6c6c966a575192e24a760d" translate="yes" xml:space="preserve">
          <source>Waits for one key to be pressed, then returns. Ignores the value of the specific key.</source>
          <target state="translated">하나의 키가 눌릴 때까지 기다렸다가 돌아옵니다. 특정 키의 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="57389edadcb916db172b6b4efd5296864599035f" translate="yes" xml:space="preserve">
          <source>Waits for the specified process to terminate, and returns its exit code.</source>
          <target state="translated">지정된 프로세스가 종료 될 때까지 대기하고 종료 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="61b5000b8e42614f728bac5368665c9afa541b95" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration.</source>
          <target state="translated">최상위 인스턴스 선언을 사용하여 단순화 할 수있는 형식 서명의 클래스 제약 조건에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="43078a38014da565cf36b789293d26d37c791bef" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</source>
          <target state="translated">최상위 인스턴스 선언을 사용하여 단순화 할 수있는 형식 서명의 클래스 제약 조건에 대해 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f17deafc978e685508816d0d4ac503ec8d814c7" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when none of the bound variables are used.</source>
          <target state="translated">바인딩 된 변수가 사용되지 않는 경우 레코드 와일드 카드 일치에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="a962ab5861876e6eea5477b0e84923e9646bd87f" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when the wildcard binds no patterns.</source>
          <target state="translated">와일드 카드가 패턴을 바인딩하지 않으면 레코드 와일드 카드 일치에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="35c0f6e86b2815a92eee0403dbbef1a02e0722d0" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 이 거꾸로 정의 된 경우 경고합니다 ( 예 : &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="59480446bfa54f329c48448e6528e481181e7868" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(*&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(*&amp;gt;)&lt;/code&gt; 이 거꾸로 정의 된 경우 경고합니다 ( 즉, &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29a113dacf30bae34993ef0968692193ceabe83b" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;fail&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; 가 거꾸로 정의 된 경우 경고합니다 (예 : &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="849b5273d5eb661e6eb5614d0cddf2d6fd432ef3" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;pure&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;pure = return&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 가 거꾸로 정의되어 있으면 경고합니다 (예 : &lt;code&gt;pure = return&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d0b01e21f7d62ff7ec2fdb8f36e3e14f652bc2a" translate="yes" xml:space="preserve">
          <source>Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</source>
          <target state="translated">패턴 바인딩이 고독한 와일드 카드 패턴이거나 뱅킹 패턴이 아닌 한 변수가 바인딩되지 않는 경우 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1d186912c1ee8144fbf61683a158749e17d0d8e" translate="yes" xml:space="preserve">
          <source>Warn if a promoted data constructor is used without a tick preceding its name.</source>
          <target state="translated">승격 된 데이터 생성자가 이름 앞에 틱없이 사용 된 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="086bb0536ea1d969c7c5649822f9159c7df38091" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;exts/rewrite_rules#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">규칙이 실행되기 전에 함수가 인라인 될 수 있기 때문에 재 작성 RULE이 실행되지 않을 수있는 경우 경고합니다. &lt;a href=&quot;exts/rewrite_rules#rules-inline&quot;&gt;규칙이 INLINE / NOINLINE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55515cbed4e1b2f4cafa3830ade353ff4bda2502" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">규칙이 실행되기 전에 함수가 인라인 될 수 있으므로 재 작성 RULE이 실행되지 않을 수 있음을 경고합니다. &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;규칙이 INLINE / NOINLINE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1ee84bd31cfd036a652ec43cd7989ce759f8b29" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규 &lt;code&gt;Applicative&lt;/code&gt; 또는 &lt;code&gt;Monad&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="9cef51bc5727ce621a5f1887fb407974a04d16d0" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;MonadFail&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규적인 &lt;code&gt;Monad&lt;/code&gt; 또는 &lt;code&gt;MonadFail&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="ed48e3c9af6f4e305d15859d8b2f83e1331ef132" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Semigroup&lt;/code&gt; or &lt;code&gt;Monoid&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규 &lt;code&gt;Semigroup&lt;/code&gt; 또는 &lt;code&gt;Monoid&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="68b4c1ca04373000f34260c5d11f4973aeeeccf7" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없으면 패키지를로드하고 대상 패키지 설명의 추가 라이브러리 스탠자를 분석 할 때로드해야한다고 추론했습니다.</target>
        </trans-unit>
        <trans-unit id="9965a9366f3d0595feaae0ce4341dcbef127b246" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없을 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="6590e9bd34bfc2ad804659f30bd772d752f4af5b" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can't load a shared lib.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없을 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="d46390c87741b9706a466b65da731fff3e418560" translate="yes" xml:space="preserve">
          <source>Warn when a deferred out-of-scope variable is encountered.</source>
          <target state="translated">범위를 벗어난 지연된 변수가 발생하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="96bfc5daceff7e0488089aa570da728cb493edc4" translate="yes" xml:space="preserve">
          <source>Warn when a failable pattern is used in a do-block that does not have a &lt;code&gt;MonadFail&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;MonadFail&lt;/code&gt; 인스턴스 가없는 do-block에 실패한 패턴이 사용될 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="3293ac237f66bb3bd8a2afd3f8f8ca5a83dd8162" translate="yes" xml:space="preserve">
          <source>Warn when definitions are in conflict with the future inclusion of &lt;code&gt;Semigroup&lt;/code&gt; into the standard typeclasses.</source>
          <target state="translated">정의가 향후 &lt;code&gt;Semigroup&lt;/code&gt; 타입을 표준 유형 클래스에 포함시키는 것과 충돌 할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="e2a74af50193828b0a14e324da2adc93937af1a2" translate="yes" xml:space="preserve">
          <source>Warn when using &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; with an unsupported version of LLVM.</source>
          <target state="translated">지원되지 않는 LLVM 버전으로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 을 사용할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="c38b084fb6f65e7af1b378de79589e1325e38a54" translate="yes" xml:space="preserve">
          <source>Warning: The &lt;code&gt;nodeFromVertex&lt;/code&gt; function will cause a runtime exception if the given &lt;code&gt;Vertex&lt;/code&gt; does not exist.</source>
          <target state="translated">경고 : 주어진 &lt;code&gt;Vertex&lt;/code&gt; 이없는 경우 &lt;code&gt;nodeFromVertex&lt;/code&gt; 함수는 런타임 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f75b5d0e744c785f19b3b4e68a6a3627d41d76ee" translate="yes" xml:space="preserve">
          <source>Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead.</source>
          <target state="translated">경고 :이 기능에는 몇 가지 단점이 있습니다 (설명서 참조). 대신 Control.Concurrent.threadDelay를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fddc0d2254098ec17b8f54408305994aa1d6fcb" translate="yes" xml:space="preserve">
          <source>Warning: This function will cause a runtime exception if a vertex in the edge list is not within the given &lt;code&gt;Bounds&lt;/code&gt;.</source>
          <target state="translated">경고 :이 함수는 가장자리리스트의 꼭짓점이 주어진 &lt;code&gt;Bounds&lt;/code&gt; 내에 있지 않으면 런타임 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ddc67996032923fb44bbe38302d09be9a107bc9e" translate="yes" xml:space="preserve">
          <source>Warning: This is an unstable interface.</source>
          <target state="translated">경고 : 인터페이스가 불안정합니다.</target>
        </trans-unit>
        <trans-unit id="7c32ffe73eb28c83dc7fdc739c17c7f330c7b154" translate="yes" xml:space="preserve">
          <source>Warning: newlines and tab characters are not considered separators.</source>
          <target state="translated">경고 : 줄 바꾸기 및 탭 문자는 구분 기호로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee168ab9a58029df5beac805f3270bcfd9fe72d2" translate="yes" xml:space="preserve">
          <source>Warning: since the &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; is called from the I/O manager, it must not throw an exception or block for a long period of time. In particular, be wary of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;: if the target thread is making a foreign call, these functions will block until the call completes.</source>
          <target state="translated">경고 : &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; 은 I / O 관리자에서 호출되므로 오랜 기간 동안 예외 또는 차단을 발생시키지 않아야합니다. 특히 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 에 주의 하십시오. 대상 스레드가 외부 호출을 수행하는 경우 이러한 함수는 호출이 완료 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="6d01607b3c9e9f53fb1f960cc714c8c6dd8da973" translate="yes" xml:space="preserve">
          <source>Warning: since the &lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; is called from the I/O manager, it must not throw an exception or block for a long period of time. In particular, be wary of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;: if the target thread is making a foreign call, these functions will block until the call completes.</source>
          <target state="translated">경고 : &lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; 은 I / O 관리자에서 호출되므로 오랜 기간 동안 예외 또는 차단을 발생시키지 않아야합니다. 특히 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 에 주의 하십시오. 대상 스레드가 외부 호출을 수행하는 경우 이러한 함수는 호출이 완료 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="629bc586b5e729bb9402698a5fab7a7d389d1585" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">경고 : *이 모듈은 내부에 있습니다. 필요한 경우 관리자에게 문의하여 수행하려는 작업을 설명하고 공개 API에서 필요한 작업에 대해 토론하십시오. 향후 릴리스에서는 모듈이 전혀 노출되지 않을 수 있으므로이 작업을 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="cf088808c116353dbd9751c6832d8f94da7809aa" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it then please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">경고 : *이 모듈은 내부에 있습니다. 필요한 경우 관리자에게 문의하여 수행하려는 작업을 설명하고 공개 API에서 필요한 작업에 대해 토론하십시오. 향후 릴리스에서는 모듈이 전혀 노출되지 않을 수 있으므로이 작업을 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="26ca8ee92f6bef28fdcc1bef2c38389bdc4002fe" translate="yes" xml:space="preserve">
          <source>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</source>
          <target state="translated">(a) 정의 모듈 내에서의 사용, (b) 클래스 인스턴스에서 메소드 정의 및 (c) 내보내기 목록에서의 사용에 대해서는 경고 및 사용 중단이보고되지 않습니다. 후자는 한 모듈이 모여 여러 다른 모듈의 내보내기를 다시 내보내는 라이브러리 내에서 가짜 불만을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1e250b1caeb20441fd438fd161ae0b14cdfe173a" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">경고는 오류가 아닌 경고로만 취급됩니다. 이것이 기본값이지만 &lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 플래그 를 무효화하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2494895ad5475179cdf03bf37393c57bb4ffcf96" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">경고는 오류가 아닌 경고로만 처리됩니다. 이것이 기본값이지만 &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 플래그 를 부정하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3800447d155c1657cd8727b0981f5edb4c28c0bc" translate="yes" xml:space="preserve">
          <source>Warns on qualified imports of core library modules which are subject to change in future GHC releases. Currently the following modules are covered by this warning:</source>
          <target state="translated">향후 GHC 릴리스에서 변경 될 수있는 핵심 라이브러리 모듈의 정식 가져 오기에 대해 경고합니다. 현재 다음 모듈에이 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="144e9714d0407d7b54e8bc884ed3f1a3e6c89f17" translate="yes" xml:space="preserve">
          <source>Was this program compiled with an &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;unregistered&amp;rdquo;&lt;/a&gt; version of GHC? (I.e., a version of GHC that has no platform-specific optimisations compiled in, usually because this is a currently unsupported platform.) This value will usually be no, unless you&amp;rsquo;re using an experimental build of GHC.</source>
          <target state="translated">이 프로그램은 &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;등록되지 않은&amp;rdquo;&lt;/a&gt; GHC 버전으로 컴파일 되었습니까 ? (즉, 현재 지원되지 않는 플랫폼이기 때문에 플랫폼 별 최적화가 컴파일되지 않은 GHC 버전입니다.)이 값은 실험적으로 빌드 된 GHC를 사용하지 않는 한 일반적으로 아니오입니다.</target>
        </trans-unit>
        <trans-unit id="0ec4a53513a96c37bb1d735df3ccce52d2721a6b" translate="yes" xml:space="preserve">
          <source>We achieve (1) by completely handing over control over writing to the buffer to the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; implementing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. This &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is just told the start and the end of the buffer (represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;). Then, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; can write to as big a prefix of this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; in any way it desires. If the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is done, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; is full, or a long sequence of bytes should be inserted directly, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; signals this to its caller using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우리는 (1) 버퍼를 작성하는 것에 대한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현하는 BuildStep 에 완전히 넘겨줌으로써 달성 합니다 . 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 은 버퍼의 시작과 끝을 알려줍니다 ( &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 나타냄 ). 그런 다음, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 는 이것의 큰 접두사로 쓸 수 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 이 원하시는 어떤 방법이다. 경우] &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 가 완료되면, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 은 전체, 또는 바이트의 긴 시퀀스는 다음 직접 삽입 할 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 를 사용하여 A 호출자이 신호 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7129f4a3666efd25be6cb12c609b3df9c118e270" translate="yes" xml:space="preserve">
          <source>We achieve (2) by requiring that every &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is implemented by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; that takes a continuation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;, which it calls with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; after it is done. Therefore, only two pointers have to be passed in a function call to implement concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Moreover, many &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are completely inlined, which enables the compiler to sequence them without a function call and with no boxing at all.</source>
          <target state="translated">우리는 (2) 모든 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 가 계속되는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 을 수행하는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 으로 구현 되도록 요구함으로써이를 달성 함으로써 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 호출 합니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 연결을 구현하려면 함수 호출에서 두 개의 포인터 만 전달하면됩니다 . 또한 많은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 완전히 인라인되어 있으므로 컴파일러는 함수 호출없이 그리고 권투없이 전혀 시퀀스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34141d222212ddc97bf14e8cf292ad013e804639" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">병렬 프로그램을 프로파일 링 하는 데 &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; 를 사용하는 것이 좋습니다 . 병렬 실행을 시각화하기위한 GUI를 제공하며 GHC와 함께 제공되는 시간 및 공간 프로파일 링 기능을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="c301d61ee67c2ed79282027770ed709d177658e3" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;https://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">또한 병렬 프로그램을 프로파일 링 하는 데 &lt;a href=&quot;https://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; 를 사용하는 것이 좋습니다 . 병렬 실행을 시각화하기위한 GUI를 제공하며 GHC에서 제공하는 시간 및 공간 프로파일 링 기능을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="7b758bcc0523e67b5511af6416e9d11a986e5ca3" translate="yes" xml:space="preserve">
          <source>We also wish to lift the operations of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; through both &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. For the operation &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt;, we know &lt;code&gt;throwE e&lt;/code&gt; is a simple action, so we can lift it through the two monad transformers to &lt;code&gt;InterpM&lt;/code&gt; with two &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 의 운영을 높이고 자 합니다. 동작을 위해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt; , 우리는 알고 &lt;code&gt;throwE e&lt;/code&gt; 우리가 두 개의 모나드 변압기를 통해 올릴 수 있도록, 간단한 작업입니다 &lt;code&gt;InterpM&lt;/code&gt; 이와 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="012374a3782eface8cda6f8176b4f967bdf07645" translate="yes" xml:space="preserve">
          <source>We are actually using &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; here with the more specific type</source>
          <target state="translated">우리는 실제로 더 구체적인 유형으로 &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; 를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1364b2ffc98a40ba87a6d1a4baeb267657a77bf2" translate="yes" xml:space="preserve">
          <source>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of &lt;code&gt;*&lt;/code&gt; and non-&lt;code&gt;*&lt;/code&gt; forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</source>
          <target state="translated">우리는 하나의 모듈에 국한되지 않습니다 : GHCi는의 혼합, 여러 개의 모듈에서 범위를 결합 할 수 있습니다 &lt;code&gt;*&lt;/code&gt; 및 비 &lt;code&gt;*&lt;/code&gt; 의 형태. GHCi는 이러한 모든 모듈의 범위를 결합하여 프롬프트에서 적용되는 범위를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="505b8bfd5df7cd6941272c5cbc63e2f31a6818f5" translate="yes" xml:space="preserve">
          <source>We call this a procedure or arrow abstraction. As with a lambda expression, the variable &lt;code&gt;x&lt;/code&gt; is a new variable bound within the &lt;code&gt;proc&lt;/code&gt;-expression. It refers to the input to the arrow. In the above example, &lt;code&gt;-&amp;lt;&lt;/code&gt; is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</source>
          <target state="translated">이것을 절차 또는 화살표 추상화라고합니다. 람다 식과 마찬가지로 변수 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;proc&lt;/code&gt; -expression 내에 바인딩 된 새 변수 입니다. 화살표 입력을 나타냅니다. 위의 예에서 &lt;code&gt;-&amp;lt;&lt;/code&gt; 는 식별자가 아니라 화살표 유형의 표현식과 해당 화살표에 대한 입력으로 공급 될 표현식에서 명령을 빌드하는 데 사용되는 새로운 예약 기호입니다. (이상한 모양은 나중에 더 의미가있을 것입니다.) 화살표의 적용과 유사하게 읽을 수 있습니다. 위의 예는 Haskell 식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e5716800a0eaccf2960d2b7a5093cb3ebe30351" translate="yes" xml:space="preserve">
          <source>We can also define a primitive using the Writer:</source>
          <target state="translated">Writer를 사용하여 프리미티브를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9121877015a3f7b1808375eae4f4fe67fa8ae2" translate="yes" xml:space="preserve">
          <source>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</source>
          <target state="translated">비슷한 방식으로 생성자 클래스의 인스턴스를 파생시킬 수도 있습니다. 예를 들어, 상태 및 고장 모나드 변압기를 구현했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="741f9736e016d9e070c0aa7dbe73afecd6f0010b" translate="yes" xml:space="preserve">
          <source>We can also directly serialise a value to and from a Handle, or a file:</source>
          <target state="translated">또한 핸들 또는 파일과의 값을 직접 직렬화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f871cfbc2b7125e2e8dcf75e051bc46571b48be3" translate="yes" xml:space="preserve">
          <source>We can also generate a marked-up version of the source.</source>
          <target state="translated">소스의 마크 업 버전을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22254f055266e4957fe0dec18116c8e64f2caa21" translate="yes" xml:space="preserve">
          <source>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</source>
          <target state="translated">공백과 같은 문자를 포함하는 인수를 인용 할 수도 있고 Haskell 문자열처럼 취급하거나 Haskell 목록 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c5f88dde35a93a41c4cb3d95351a5898162e27d" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-ascii#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; example above.</source>
          <target state="translated">위 의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-ascii#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; 예제 에서 볼 수 있듯이 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 16 진수 인코딩하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa27fa4197acc4f2720dc6ce9a9707a4f8d1435c" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;byteStringHex&lt;/code&gt; example above.</source>
          <target state="translated">위 의 &lt;code&gt;byteStringHex&lt;/code&gt; 예제 와 같이 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 16 진수로 인코딩하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ce8823816dc5997208d0d3df16b93ce9755a58f" translate="yes" xml:space="preserve">
          <source>We can carry this further, and define more non-default methods...</source>
          <target state="translated">우리는 이것을 더 수행하고 더 많은 기본이 아닌 메서드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="babbe24170cb9915e4b398c5539adfe43947f851" translate="yes" xml:space="preserve">
          <source>We can check now that as expected, the type of &lt;code&gt;x&lt;/code&gt; has been reconstructed, and with it the type of &lt;code&gt;f&lt;/code&gt; has been too:</source>
          <target state="translated">이제 예상대로 &lt;code&gt;x&lt;/code&gt; 의 유형 이 재구성 되었으며 &lt;code&gt;f&lt;/code&gt; 의 유형 도 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="04273c99bc18760cd81d4706487c1581b70b8de7" translate="yes" xml:space="preserve">
          <source>We can clearly see that we are converting to a &lt;em&gt;binary&lt;/em&gt; format. The '&amp;lambda;' and '&amp;ouml;' characters, which have a Unicode codepoint above 127, are expanded to their corresponding UTF-8 multi-byte representation.</source>
          <target state="translated">우리는 &lt;em&gt;바이너리&lt;/em&gt; 형식으로 변환하고 있음을 분명히 알 수 있습니다 . 유니 코드 코드 포인트가 127보다 큰 '&amp;lambda;'및 '&amp;ouml;'문자는 해당 UTF-8 멀티 바이트 표현으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="371d2c63febd96740f02aa9a6938c3c33c947260" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 를 여러 번 사용하여 여러 프리미티브를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1282c8550fbf06601d51db5aa6d160a69b5d732" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 를 여러 번 사용하여 여러 프리미티브를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27dcb75f752bffd30cefe5814229f01f2029d702" translate="yes" xml:space="preserve">
          <source>We can combine multiple values in a list into a single value using the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; function. Note that we have to specify the type here since &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is a monoid under several different operations:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 목록의 여러 값을 단일 값으로 결합 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 여러 가지 다른 작업에서 monoid 이므로 여기에서 유형을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c22fbe2e8acadfba1f70ca18177a9747d7880239" translate="yes" xml:space="preserve">
          <source>We can compile &lt;code&gt;D&lt;/code&gt;, then load the whole program, like this:</source>
          <target state="translated">우리는 &lt;code&gt;D&lt;/code&gt; 를 컴파일 한 다음 다음과 같이 전체 프로그램을로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6673177b0a5b4448a0b279c9a7468bd7b3f97bc2" translate="yes" xml:space="preserve">
          <source>We can convert a regular list to an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; with:</source>
          <target state="translated">다음을 사용하여 일반 목록을 &lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6b34f628eb0b709631642cca69699daa7f68c06" translate="yes" xml:space="preserve">
          <source>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</source>
          <target state="translated">파일에서 GHCi 입력을 읽는 명령을 정의 할 수 있습니다. 이는 GHCi 세션에 반복적으로로드 할 바인딩 세트를 작성하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9716152c7206a19681525bfc80a69323b0c68dff" translate="yes" xml:space="preserve">
          <source>We can define a parser that also counts by adding a &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 변환기 를 추가하여 계산하는 파서를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e74500104f965816a71f75ad2e503eda1dea427" translate="yes" xml:space="preserve">
          <source>We can define either prefix, infix or record pattern synonyms by modifying the form of &lt;code&gt;pat_lhs&lt;/code&gt;. The syntax for these is as follows:</source>
          <target state="translated">&lt;code&gt;pat_lhs&lt;/code&gt; 형식을 수정하여 접두사, 접두사 또는 레코드 패턴 동의어를 정의 할 수 있습니다 . 이에 대한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56be7f23e4f4ea2ae4416d0b7ff5efb2b70ee14f" translate="yes" xml:space="preserve">
          <source>We can define parallel list comprehensions by translation to regular comprehensions. Here&amp;rsquo;s the basic idea:</source>
          <target state="translated">정규 이해로 번역하여 병렬 목록 이해를 정의 할 수 있습니다. 기본 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="907cdcaa99e2ff41201b2662179ecfa39a9ce78e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">비결 정성을 제공 하는 &lt;code&gt;[]&lt;/code&gt; 모나드에 상태 ( 파싱 ​​될 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )를 추가하여 이러한 파서 모나드를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9c01a3a2622d4196ecfba7e8743aedf0cb3a68d" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">비결 정성을 제공 하는 &lt;code&gt;[]&lt;/code&gt; 모나드에 상태 ( 파싱 ​​될 남은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )를 추가하여 이러한 파서 모나드를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df8374e1acf095dee848a44f1577d87dbc000a3e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">비결 정성을 제공 하는 &lt;code&gt;[]&lt;/code&gt; 모나드에 상태 ( 파싱 ​​될 남은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )를 추가하여 이러한 파서 모나드를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dc02c0a7e6a16240bcfe1eb3a01240b894592e9" translate="yes" xml:space="preserve">
          <source>We can encode values of this type into bytestrings using the following instance, which proceeds by recursively breaking down the structure to serialise:</source>
          <target state="translated">다음 인스턴스를 사용하여이 유형의 값을 바이트 문자열로 인코딩 할 수 있습니다.이 인스턴스는 반복적으로 구조를 직렬화하여 처리합니다.</target>
        </trans-unit>
        <trans-unit id="609bdca8889dc8d6840c848dc0cf9da272df2f46" translate="yes" xml:space="preserve">
          <source>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a &amp;ldquo;partial application&amp;rdquo; of the class appears in the &lt;code&gt;deriving&lt;/code&gt; clause. For example, given the class</source>
          <target state="translated">newtype이 마지막 클래스 매개 변수 인 경우 다중 매개 변수 클래스의 인스턴스를 파생시킬 수도 있습니다. 이 경우 클래스의 &quot;부분 응용 프로그램&quot;이 &lt;code&gt;deriving&lt;/code&gt; 조항에 나타납니다 . 예를 들어, 클래스가 주어지면</target>
        </trans-unit>
        <trans-unit id="bb904fd56e78dfb6ddf362dca7a6154b196c3889" translate="yes" xml:space="preserve">
          <source>We can instead create a newtype &lt;code&gt;App&lt;/code&gt; (where &lt;code&gt;App f a&lt;/code&gt; and &lt;code&gt;f a&lt;/code&gt; are represented the same in memory) and use &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; to explicitly enable uses of this pattern:</source>
          <target state="translated">대신 새로운 유형의 &lt;code&gt;App&lt;/code&gt; ( &lt;code&gt;App f a&lt;/code&gt; 및 &lt;code&gt;f a&lt;/code&gt; 가 메모리에서 동일하게 표시됨)을 만들고 &lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt; 를 사용하여이 패턴의 사용을 명시 적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d5422d9cdcd8f1fd638150c60756059c44e629" translate="yes" xml:space="preserve">
          <source>We can lift &lt;code&gt;append&lt;/code&gt; and apply it to &lt;code&gt;f0&lt;/code&gt; to get:</source>
          <target state="translated">&lt;code&gt;append&lt;/code&gt; 를 해제 하고 &lt;code&gt;f0&lt;/code&gt; 에 적용하여 다음을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b01ed5c6649677e3f37624bba9963e68fbbcb79" translate="yes" xml:space="preserve">
          <source>We can now catch a &lt;code&gt;MismatchedParentheses&lt;/code&gt; exception as &lt;code&gt;MismatchedParentheses&lt;/code&gt;, &lt;code&gt;SomeFrontendException&lt;/code&gt; or &lt;code&gt;SomeCompilerException&lt;/code&gt;, but not other types, e.g. &lt;code&gt;IOException&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;MismatchedParentheses&lt;/code&gt; 예외를 &lt;code&gt;MismatchedParentheses&lt;/code&gt; , &lt;code&gt;SomeFrontendException&lt;/code&gt; 또는 &lt;code&gt;SomeCompilerException&lt;/code&gt; 으로 잡을 수 있지만 &lt;code&gt;IOException&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8c00c1af4cb249b526b0a337c48983f4e7b424b" translate="yes" xml:space="preserve">
          <source>We can now inspect the history of evaluation steps:</source>
          <target state="translated">이제 평가 단계 기록을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6f3e30515c510be759d2caa31d207bd8d44a8cd" translate="yes" xml:space="preserve">
          <source>We can only make field selectors for pattern synonym records that do not mention any existential type variables whatsoever in their types, per &lt;a href=&quot;pattern_synonyms#record-patsyn&quot;&gt;Record Pattern Synonyms&lt;/a&gt;. (This is a stronger requirement than for GADT records, whose types can mention existential type variables provided that they are also mentioned in the return type.) We can see that &lt;code&gt;unP2&lt;/code&gt; cannot be used as a top-level field selector since its type has a free type variable &lt;code&gt;n&lt;/code&gt;, which is existential. &lt;code&gt;unP1&lt;/code&gt; is fine, on the other hand, as its type only has one free variable, the universal type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">우리는 당, 자신의 유형에 어떠한 존재 형태 변수를 언급하지 않는 패턴 동의어 레코드 필드 선택기 할 수 있습니다 &lt;a href=&quot;pattern_synonyms#record-patsyn&quot;&gt;기록 패턴 동의어&lt;/a&gt; . (이것은 반환 유형에서도 언급되는 경우 유형이 존재 유형 변수를 언급 할 수있는 GADT 레코드보다 강력한 요구 사항입니다.) &lt;code&gt;unP2&lt;/code&gt; 는 유형에 자유 유형 변수 &lt;code&gt;n&lt;/code&gt; , 이는 실존 적입니다. &lt;code&gt;unP1&lt;/code&gt; 은 유형에 하나의 자유 변수 인 범용 유형 변수 &lt;code&gt;a&lt;/code&gt; 만 있기 때문에 괜찮 습니다 .</target>
        </trans-unit>
        <trans-unit id="a7912bd1416a6837d9fa5e26fca0fe44eeb19351" translate="yes" xml:space="preserve">
          <source>We can pass simple expressions to EvalStmt, consisting of values and application. This allows us to wrap the statement to be executed in another function, which is used by GHCi to implement :set args and :set prog. It might be worthwhile to extend this little language in the future.</source>
          <target state="translated">값과 응용 프로그램으로 구성된 간단한 표현식을 EvalStmt에 전달할 수 있습니다. 이를 통해 GHCi가 : set args 및 : set prog를 구현하는 데 사용하는 다른 함수에서 명령문을 랩핑 할 수 있습니다. 앞으로이 작은 언어를 확장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="183a3587dfb7920efd5e1a4cc461e7be30ed0dd2" translate="yes" xml:space="preserve">
          <source>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</source>
          <target state="translated">클래스 선언에서 빈 멤버를 제거하여이 특정 문제를 회피 할 수 있습니다. 그러나 나머지 멤버 인 insert 및 member에는 모호한 유형이 없지만 사용하려고 할 때 여전히 문제가 발생합니다. 예를 들어 다음 두 가지 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c18fae3a664786d2f5921a461ad4addabedf0e5b" translate="yes" xml:space="preserve">
          <source>We can simplify the writing of &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; instances using monadic combinators:</source>
          <target state="translated">모나드 결합자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; 인스턴스 작성을 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5bd84c51422d4a14cd362b46283c89cd3c1da6b" translate="yes" xml:space="preserve">
          <source>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</source>
          <target state="translated">다음과 같이 마지막 두 개로 작성된 명령에 필요한 추가 입력을 일반 표현식에 적용하여 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7790e7c5277fb5ba71b2c08e17c443fb508ca879" translate="yes" xml:space="preserve">
          <source>We can then use &lt;code&gt;HeadC&lt;/code&gt; in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</source>
          <target state="translated">그런 다음 표현 및 패턴 컨텍스트에서 &lt;code&gt;HeadC&lt;/code&gt; 를 사용할 수 있습니다. 패턴 컨텍스트에서는 길이가 하나 이상인 목록의 헤드와 일치합니다. 표현식 컨텍스트에서 싱글 톤 목록을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b415212c014ea0fcc281b456f186980a0ca3cc80" translate="yes" xml:space="preserve">
          <source>We can thus distinguish the type &lt;code&gt;P&lt;/code&gt; (which has a constructor &lt;code&gt;MkP&lt;/code&gt;) from the promoted data constructor &lt;code&gt;'P&lt;/code&gt; (of kind &lt;code&gt;Prom&lt;/code&gt;).</source>
          <target state="translated">따라서 &lt;code&gt;P&lt;/code&gt; 유형 (생성자 &lt;code&gt;MkP&lt;/code&gt; 가 있음 )을 승격 된 데이터 생성자 &lt;code&gt;'P&lt;/code&gt; (종류 &lt;code&gt;Prom&lt;/code&gt; ) 와 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c213d93934a1e2d831f6660e414061f0c2d9d87" translate="yes" xml:space="preserve">
          <source>We can typecheck &lt;code&gt;A&lt;/code&gt; against this signature, or we can instantiate &lt;code&gt;Str&lt;/code&gt; with a module that provides the following declarations. Refer to Cabal&amp;rsquo;s documentation for a more in-depth discussion on how to instantiate signatures.</source>
          <target state="translated">우리는 유형 체킹 수 &lt;code&gt;A&lt;/code&gt; 이 서명에 대해, 또는 우리는 인스턴스화 할 수 &lt;code&gt;Str&lt;/code&gt; 다음과 같은 선언을 제공하는 모듈. 서명 인스턴스화 방법에 대한 자세한 내용은 Cabal의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="962ad3b3e4a229cc5ed476afe00f9dbc23ed54ea" translate="yes" xml:space="preserve">
          <source>We can use do-notation with types that are an instance of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, but not &lt;code&gt;Monad&lt;/code&gt;</source>
          <target state="translated">우리는 &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt; 의 인스턴스 이지만 &lt;code&gt;Monad&lt;/code&gt; 가 아닌 타입으로 do-notation을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1316cac24a8121f893c44f812e970138fc3afa32" translate="yes" xml:space="preserve">
          <source>We can use it for example to prepend and/or append fixed values to an primitive.</source>
          <target state="translated">예를 들어 고정 값을 프리미티브 앞에 추가하거나 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2059c45fd11e8690d6c4e13b96ba375eeaab04a6" translate="yes" xml:space="preserve">
          <source>We can use levity polymorphism to good effect with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, whose types are given here:</source>
          <target state="translated">우리는 levity polymorphism을 사용하여 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 와 함께 좋은 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8383f1aba14acad4a5f9a110e22c1d3c3245bd62" translate="yes" xml:space="preserve">
          <source>We can use the following functions to extract pieces.</source>
          <target state="translated">다음 함수를 사용하여 조각을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9784ff84edea883eaae11308c9b368f4fdfc76" translate="yes" xml:space="preserve">
          <source>We can use the profiler to collect stack traces when using GHCi (see &lt;a href=&quot;#ghci-stack-traces&quot;&gt;Stack Traces in GHCi&lt;/a&gt;).</source>
          <target state="translated">GHCi를 사용할 때 프로파일 러를 사용하여 스택 추적을 수집 할 수 있습니다 (GHCi의 &lt;a href=&quot;#ghci-stack-traces&quot;&gt;스택 추적&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1eb2e3e74cc9a81f662b64cea38f9f0af332774b" translate="yes" xml:space="preserve">
          <source>We can use this to find the longest entry of a list:</source>
          <target state="translated">이를 사용하여 목록의 가장 긴 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571a67745023d8194d2db6b6211b599e037a7e5a" translate="yes" xml:space="preserve">
          <source>We can use this to find the shortest entry of a list:</source>
          <target state="translated">이를 사용하여 목록의 가장 짧은 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f381f4d9c2ee9452187bc2d63e1896c154f0679e" translate="yes" xml:space="preserve">
          <source>We cannot define these functions in a module where they might be used (e.g., &lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;), because the magical wired-in type will get confused with what the typechecker figures out.</source>
          <target state="translated">마법의 유선 유형이 유형 &lt;a href=&quot;ghc-base&quot;&gt;검사기&lt;/a&gt; 가 알아 낸 것과 혼동되기 때문에 이러한 기능을 사용할 수있는 모듈 (예 : GHC.Base ) 에서 이러한 기능을 정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eb0f870d06595902b343868b42028d552207bac6" translate="yes" xml:space="preserve">
          <source>We could define our own operator</source>
          <target state="translated">우리는 우리 자신의 연산자를 정의 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0a7f8355cb86bba1864ad75f7b2c3f6c7ca24357" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">우리는 들어 올릴 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 작업을 &lt;code&gt;InterpM&lt;/code&gt; 이 세 가지 사용하여 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 들,하지만 &lt;code&gt;InterpM&lt;/code&gt; 는 자동의 인스턴스 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 우리가 사용할 수 있도록, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 을 대신 :</target>
        </trans-unit>
        <trans-unit id="552e222727964454376c689c5337b632f2f7ae47" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">우리는 들어 올릴 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 작업을 &lt;code&gt;InterpM&lt;/code&gt; 이 세 가지 사용하여 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 들,하지만 &lt;code&gt;InterpM&lt;/code&gt; 는 자동의 인스턴스 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 우리가 사용할 수 있도록, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 을 대신 :</target>
        </trans-unit>
        <trans-unit id="b98be665de6d96e1b325862bf69bb2db5b4de5f2" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">우리는 들어 올릴 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 작업을 &lt;code&gt;InterpM&lt;/code&gt; 이 세 가지 사용하여 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 들,하지만 &lt;code&gt;InterpM&lt;/code&gt; 는 자동의 인스턴스 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 우리가 사용할 수 있도록, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 을 대신 :</target>
        </trans-unit>
        <trans-unit id="f7594ab65e591e1f7cdb2f863210f655104b0f0a" translate="yes" xml:space="preserve">
          <source>We could not give &lt;code&gt;f0&lt;/code&gt; enough input to decode anything, so it returned an empty string. Once we feed our second continuation &lt;code&gt;f1&lt;/code&gt; the last byte of input, it will make progress.</source>
          <target state="translated">우리는 &lt;code&gt;f0&lt;/code&gt; 에게 아무것도 해독하기에 충분한 입력을 줄 수 없었 으므로 빈 문자열을 반환했습니다. 두 번째 연속 &lt;code&gt;f1&lt;/code&gt; 에 입력의 마지막 바이트를 공급하면 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="30d395b80b89dae6f0b1dfe707dc1dd3db5f2c33" translate="yes" xml:space="preserve">
          <source>We could simulate &lt;code&gt;if&lt;/code&gt; by defining</source>
          <target state="translated">우리는 시뮬레이션 할 수 &lt;code&gt;if&lt;/code&gt; 정의하여</target>
        </trans-unit>
        <trans-unit id="88145d1139ce025753cf32ad3ebd398f5e30f0d7" translate="yes" xml:space="preserve">
          <source>We could try applying &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. This won&amp;rsquo;t work though, as &lt;code&gt;g&lt;/code&gt; expects an argument of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Even worse, we can&amp;rsquo;t turn &lt;code&gt;x&lt;/code&gt; into something of type &lt;code&gt;a&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; also needs an argument of type &lt;code&gt;a&lt;/code&gt;! In short, there&amp;rsquo;s no good way to make this work.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;g&lt;/code&gt; 를 적용 해 볼 수 있습니다. &lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 유형의 인수 와 &lt;code&gt;x :: b&lt;/code&gt; 기대하기 때문에 작동하지 않습니다 . 더 나쁜 것은, &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 타입의 인수가 필요하기 때문에 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;a&lt;/code&gt; 타입 의 무언가로 바꿀 수 없다는 것입니다 ! 요컨대,이 작업을 수행하는 좋은 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b78e79e9cebc29339a24122d72bf15b41a0e6358" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">우리는 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형의 두 값을 생성합니다 . 하나는 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자를 사용하고 다른 하나는 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자를 사용합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이있는 경우 ) 또는 &quot;times-two&quot;함수 ( &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가있는 경우 )를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="acdd431f6357c3729418bd46bd62b31425e9ed68" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">우리는 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형의 두 값을 생성합니다 . 하나는 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자를 사용하고 다른 하나는 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자를 사용합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이있는 경우 ) 또는 &quot;times-two&quot;함수 ( &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가있는 경우 )를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="872adf42a857495035f7402099a48180fad06405" translate="yes" xml:space="preserve">
          <source>We demonstrate our UTF-8 CSV encoding function on the following table.</source>
          <target state="translated">다음 표에서 UTF-8 CSV 인코딩 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="953b1d254c2334f50b6823d0ecdbd80d0194eee3" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">컴파일 된 버전의 &lt;code&gt;C&lt;/code&gt; 를 얻지 못했습니다 ! 어떻게 된 거예요? 글쎄, GHCi에서 컴파일 된 모듈은 다른 컴파일 된 모듈에만 의존 할 수 있으며,이 경우 &lt;code&gt;C&lt;/code&gt; 는 객체 파일이없는 &lt;code&gt;D&lt;/code&gt; 에 의존 하므로 GHCi는 &lt;code&gt;C&lt;/code&gt; 의 객체 파일 도 거부했다 . 자, &lt;code&gt;D&lt;/code&gt; 도 컴파일하자 :</target>
        </trans-unit>
        <trans-unit id="3b8a8e128dde8f3cc09d2617fe4a012e9ad66250" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">우리는 &lt;code&gt;C&lt;/code&gt; 의 컴파일 된 버전을 얻지 못했습니다 ! 어떻게 된 거예요? 글쎄요, GHCi에서 컴파일 된 모듈은 다른 컴파일 된 모듈에만 의존 할 수 있습니다.이 경우 &lt;code&gt;C&lt;/code&gt; 는 객체 파일이없는 &lt;code&gt;D&lt;/code&gt; 에 의존 하므로 GHCi는 &lt;code&gt;C&lt;/code&gt; 의 객체 파일 도 거부했습니다 . 좋습니다. &lt;code&gt;D&lt;/code&gt; 를 컴파일 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e9bd04af4ad4fdf69f006447ba60f1c3e65c62b6" translate="yes" xml:space="preserve">
          <source>We distinguish three kinds of wildcards.</source>
          <target state="translated">우리는 세 종류의 와일드 카드를 구별합니다.</target>
        </trans-unit>
        <trans-unit id="cf8979a2d9c164c587d8e4dc4e5509249cbdf0f4" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the argument of &lt;code&gt;E3&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is not universally polymorphic. The &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;E3&lt;/code&gt; is (implicitly) existentially quantified, so it is not the same as the last type parameter of &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 보편적으로 다형성이 아니기 때문에 &lt;code&gt;E3&lt;/code&gt; 의 주장을 접지 않습니다. 에서 &lt;code&gt;E3&lt;/code&gt; 은 그것의 최종 형태 파라미터와 동일하지 않도록, (암시 적) 실존 정량화 &lt;code&gt;E&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a164bb70c45021b2d0872cd4b8c7acc02624d024" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the arguments of &lt;code&gt;E1&lt;/code&gt; or &lt;code&gt;E4&lt;/code&gt; because even though &lt;code&gt;(a ~ Int)&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">비록 &lt;code&gt;(a ~ Int)&lt;/code&gt; 이지만 &lt;code&gt;Int&lt;/code&gt; 가 구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지 않기 때문에 &lt;code&gt;E1&lt;/code&gt; 또는 &lt;code&gt;E4&lt;/code&gt; 의 인수를 접지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ab798ba88a4ca0a4d0cbf31feb27163ceef28cf8" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">어려운 방법으로 패키지를 작성하지 않는 것이 좋습니다. 대신 가능 하면 &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; 인프라를 사용하십시오 . 패키지가 특히 복잡하거나 많은 구성이 필요한 경우 저수준 메커니즘으로 돌아 가야 할 수 있으므로 용감한 영혼을위한 몇 가지 힌트가 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1756ea7351d5c75b6ae409dae0c3a8cdf9b2c46f" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">어려운 방식으로 패키지를 빌드하는 것은 권장하지 않습니다. 대신 가능한 경우 &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; 인프라를 사용하십시오 . 패키지가 특히 복잡하거나 많은 구성이 필요한 경우 저수준 메커니즘으로 돌아 가야 할 수 있으므로 용감한 영혼을위한 몇 가지 힌트가 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bc2113e91a9e6010ff8cf726465f0e888d7a9a27" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t use a &lt;code&gt;-O*&lt;/code&gt; flag for day-to-day work. We use &lt;code&gt;-O&lt;/code&gt; to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use &lt;code&gt;-O2&lt;/code&gt; (and we go for lots of coffee breaks).</source>
          <target state="translated">우리는 일상 업무에 &lt;code&gt;-O*&lt;/code&gt; 플래그를 사용하지 않습니다 . 우리는 &lt;code&gt;-O&lt;/code&gt; 를 사용 하여 적절한 속도를 얻습니다. 예를 들어, 무언가를 측정하고 싶을 때. 우리는 파산을 원할 때 &lt;code&gt;-O2&lt;/code&gt; 를 사용하는 경향이 있습니다 (그리고 우리는 많은 커피 휴식을 취합니다).</target>
        </trans-unit>
        <trans-unit id="2d08599ef2845ec4c18886d2e05cb517fe66bac5" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level numbers, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수가 동일한 유형 수준의 숫자로 인스턴스화되었다는 증거를 얻거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d254f10f035de6db1e618d7d7ad498a649421081" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level symbols, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수가 동일한 유형 레벨 기호로 인스턴스화되었다는 증거를 얻거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e1eab0389773836a826bac9246539026d3ebc063" translate="yes" xml:space="preserve">
          <source>We evaluated only the &lt;code&gt;_t1&lt;/code&gt; thunk, revealing the head of the list, and the tail is another thunk now bound to &lt;code&gt;_t2&lt;/code&gt;. The &lt;code&gt;seq&lt;/code&gt; function is a little inconvenient to use here, so you might want to use &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; to make a nicer interface (left as an exercise for the reader!).</source>
          <target state="translated">우리는 &lt;code&gt;_t1&lt;/code&gt; 썽크 만 평가 하여 목록의 머리를 드러 냈으며 꼬리는 이제 &lt;code&gt;_t2&lt;/code&gt; 에 바인딩 된 또 다른 썽크 입니다. &lt;code&gt;seq&lt;/code&gt; 기능을 사용할 수 있도록, 여기에 사용하기 조금 불편 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; (! 독자들에게 숙제로 남긴다) 더 좋은 인터페이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fdb86aff4e68170d19ff52b844aa793fc663425" translate="yes" xml:space="preserve">
          <source>We extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">두 개의 추가 형식, 즉 인스턴스 선언에 나타날 수있는 내용을 사용하여 &lt;code&gt;class&lt;/code&gt; 확장 합니다 (경고 : 이것은 다소 혼란스럽게 명명 된 비 터미널 기호입니다).</target>
        </trans-unit>
        <trans-unit id="13dd6433b391a3acfa1f23e4695a261b1c01ce9e" translate="yes" xml:space="preserve">
          <source>We find out the current capability number and pass it to C. This is passed back to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and helps the RTS to know which capability it should try to perform the &lt;code&gt;tryPutMVar&lt;/code&gt; on. If you don&amp;rsquo;t care, you can pass &lt;code&gt;-1&lt;/code&gt; for the capability to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and it will pick an arbitrary one.</source>
          <target state="translated">현재 기능 번호를 찾아 C로 전달합니다.이 값은 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 로 다시 전달 되며 RTS가 &lt;code&gt;tryPutMVar&lt;/code&gt; 를 수행하려고 시도 할 기능을 RTS가 알 수 있도록 도와줍니다 . 신경 쓰지 않으면 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 에 기능에 대해 &lt;code&gt;-1&lt;/code&gt; 을 전달 하면 임의의 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4cde7d17a1a927283996015f702fc3ec30ac59d9" translate="yes" xml:space="preserve">
          <source>We have &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type &lt;code&gt;Int&lt;/code&gt;. What are our options?</source>
          <target state="translated">우리는이 &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt; , &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt; , 그리고 &lt;code&gt;x :: b&lt;/code&gt; . 이것을 사용하여 어떻게 든 구멍에 밑줄로 표시하고 &lt;code&gt;Int&lt;/code&gt; 유형의 값을 채워야합니다 . 우리의 옵션은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="09dbbfe5180f316ca6dcabdf80e88644dd24f734" translate="yes" xml:space="preserve">
          <source>We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed. There is more background in &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inliner&lt;/a&gt;.</source>
          <target state="translated">우리는 GHC를 분기시키고 문제를 해결하는 것이이 컴파일 된 것 이외의 다른 클래스의 프로그램을 발견 한 적이 없으며, 모든 컴파일에 추가적인 오버 헤드를 부과 할 것입니다. 따라서 버그는 수정되지 않은 상태로 유지됩니다. &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;GHC 인라이너의 비밀&lt;/a&gt; 에는 더 많은 배경이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57baa188441448bf100848ab0c3a3c54936d2303" translate="yes" xml:space="preserve">
          <source>We infer these kinds:</source>
          <target state="translated">우리는 이러한 종류를 유추합니다 :</target>
        </trans-unit>
        <trans-unit id="069aec79fd852b144f1ab0e04e00d9fe20331d65" translate="yes" xml:space="preserve">
          <source>We internally represent the Cell inside a Table with an object of the type</source>
          <target state="translated">내부적으로 테이블 내부의 셀을 유형의 객체로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5089f9acc0bbfad470ea9fc8ae47af4cd87aa22b" translate="yes" xml:space="preserve">
          <source>We mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">&lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 이벤트 로 새 샘플의 시작을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="18dab782d675f36855bb63945664409f3d29f932" translate="yes" xml:space="preserve">
          <source>We may also need to signal an invalid character if we detect them when encoding a sequence of &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s into &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s because the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; mode creates these to round-trip bytes through our internal UTF-16 encoding.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; 모드는 내부 UTF-16 인코딩을 통해 바이트를 왕복하는 바이트를 만들기 때문에 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 시퀀스 를 &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 로 인코딩 할 때 문자를 감지하면 잘못된 문자를 표시해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ec960543391474c6f77e98679f0051008de2792" translate="yes" xml:space="preserve">
          <source>We may change the syntax and semantics of this feature in the future.</source>
          <target state="translated">나중에이 기능의 구문과 의미를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b280e9e965a5ce2574a975e02721f8e9dd198f6" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEAD의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;를 다운로드&lt;/a&gt; 할 수있게 만들 수 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 구할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ebe98c6a2119e741bdf064584e3db025f6347d2" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEAD 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;를 다운로드 할 수&lt;/a&gt; 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c79f15081f54da10e6044689f529ce2f478e6d97" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;https://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEAD의 스냅 샷 릴리스 &lt;a href=&quot;https://www.haskell.org/ghc/dist/current/dist/&quot;&gt;를 다운로드 할 수&lt;/a&gt; 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="627fed2246d090d6133a9e16548caedabebe413b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">현재 안정적인 브랜치의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;를 다운로드&lt;/a&gt; 할 수있게 만들 수 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git 리포지토리&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4fb296fd8e8ef0d2da857b55d5e427e6713096b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">현재 stable 브랜치의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;를 다운로드 할 수&lt;/a&gt; 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8f550102596507541eecd8fea3584501d85066c" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;https://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">현재 stable 브랜치의 스냅 샷 릴리스 &lt;a href=&quot;https://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;를 다운로드 할 수&lt;/a&gt; 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0f8df20c6e6b47bd015211c44bf700bb364d39e" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">우리는 지연 계산, 즉 썽크가 생성 될 때 현재 스택을 캡처하고 평가 될 때이 스택을 복원한다고 앞서 언급했습니다. 최상위 썽 크는 어떻습니까? 프로그램이 컴파일 될 때 &quot;생성&quot;되므로 어떤 스택을 제공해야합니까? 최상위 썽크의 기술적 이름은 CAF ( &quot;Constant Applicative Form&quot;)입니다. GHC는 모듈의 모든 CAF에 단일 비용 센터 &lt;code&gt;M.CAF&lt;/code&gt; 로 구성된 스택을 할당합니다 . 여기서 &lt;code&gt;M&lt;/code&gt; 은 모듈의 이름입니다. &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 각 CAF에 다른 스택을 제공 할 수도 있습니다 . 이것은 &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 로&lt;/a&gt; 컴파일 할 때 특히 유용합니다 (기본값은 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;이상) 함수 본문의 상수가 최상위 수준으로 올라가 CAF가되기 때문입니다. 이러한 CAF가 무엇에 해당하는지 확인 하려면 Core ( &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; )&lt;/a&gt; 를 참조해야 할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="082cfbff49aee1c63c6b424e58fe2b98b5f12765" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">앞서 언급 한 바와 같이 게으른 계산, 즉 썽 크는 생성 될 때 현재 스택을 캡처하고 평가 될 때이 스택을 복원합니다. 최상위 썽 크는 어떻습니까? 그것들은 프로그램이 컴파일 될 때&amp;ldquo;만들어집니다&amp;rdquo;. 그래서 우리는 어떤 스택을 주어야합니까? 최상위 썽크의 기술적 이름은 CAF (&amp;ldquo;일정 적용 신청서&amp;rdquo;)입니다. GHC는 모듈의 모든 CAF에 단일 비용 센터 &lt;code&gt;M.CAF&lt;/code&gt; 로 구성된 스택을 할당합니다 . 여기서 &lt;code&gt;M&lt;/code&gt; 은 모듈의 이름입니다. &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 각 CAF에 다른 스택을 제공 할 수도 있습니다 . &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 로&lt;/a&gt; 컴파일 할 때 특히 유용합니다 ( &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 의&lt;/a&gt; 기본값과 같이).기능 체의 상수가 최상위 수준으로 상승하여 CAF가됨에 따라) 이러한 CAF가 무엇에 해당하는지 판별 하려면 코어 ( &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; )&lt;/a&gt; 를 참조해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7ac173e2f1e3e157189bce46a9d6b1220792bdd5" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;../using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">우리는 (B)를 훨씬 선호합니다. 왜? GHC는 &lt;code&gt;(True :~: False)&lt;/code&gt; 가 빈 유형 임을 알아낼 수 있기 때문 입니다. 따라서 (B)는 편파성이 없으며 GHC는 &lt;a href=&quot;../using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 수 있습니다. 반면에 (A)는 위험 해 보이며 GHC는 실제로 함수가 호출 될 수 없는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f89173fef21c2ae8f8a6534be41e16813ce12d43" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">우리는 (B)를 훨씬 선호합니다. 왜? GHC는 &lt;code&gt;(True :~: False)&lt;/code&gt; 가 빈 유형 임을 알 수 있습니다 . 따라서 (B)는 부분 성이 없으며 GHC는 &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 수 있습니다. 반면에 (A)는 위험 해 보이며, GHC는 실제로 함수가 절대 호출 될 수 없는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="703530a9bd76b6d41cdef63f80ac7642abb989f8" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">우리는 (B)를 훨씬 선호합니다. 왜? GHC는 &lt;code&gt;(True :~: False)&lt;/code&gt; 가 빈 유형 임을 알 수 있기 때문 입니다. 따라서 (B)는 편파성이 없으며 GHC는 &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 수 있습니다. 반면에 (A)는 위험 해 보이며 GHC는 실제로 함수가 호출 될 수 없는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b18525b3456e672ccab92cf738f47ed84e0b770" translate="yes" xml:space="preserve">
          <source>We normally mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">일반적으로 새 샘플의 시작을 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 이벤트로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1d3ba152883128893cbf6ffdf29a1fd6fe11e834" translate="yes" xml:space="preserve">
          <source>We now define class &lt;code&gt;Encode&lt;/code&gt; for the actual &lt;code&gt;encode&lt;/code&gt; function:</source>
          <target state="translated">이제 실제 &lt;code&gt;encode&lt;/code&gt; 함수에 대해 &lt;code&gt;Encode&lt;/code&gt; 클래스를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1377e18111b86ccead4e0b186e1c1a556ed53fba" translate="yes" xml:space="preserve">
          <source>We now explain in more details the major modes of hpc.</source>
          <target state="translated">이제 hpc의 주요 모드에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35d4fb55ace34add811b7ad430f098cc0cd3b23d" translate="yes" xml:space="preserve">
          <source>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</source>
          <target state="translated">우리는 원래 표현의 자유 변수가 아닌 범위 내의 모든 변수에 대한 바인딩을 제공했지만, 이것이 성능에 상당한 영향을 미치기 때문에 자유 변수에 대한 현재 제한 사항이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d27d12506ea61f7f54862326a16fa048ca62128" translate="yes" xml:space="preserve">
          <source>We pass references to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; to &lt;code&gt;hs_init()&lt;/code&gt; so that it can separate out any arguments for the RTS (i.e. those arguments between &lt;code&gt;+RTS...-RTS&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 및 &lt;code&gt;argv&lt;/code&gt; 에 대한 참조를 &lt;code&gt;hs_init()&lt;/code&gt; 전달하여 RTS에 대한 인수를 분리 할 수 ​​있습니다 (예 : &lt;code&gt;+RTS...-RTS&lt;/code&gt; 사이의 인수 ).</target>
        </trans-unit>
        <trans-unit id="724d15d030dde64030cae6581a56f055b565b95a" translate="yes" xml:space="preserve">
          <source>We quit if the file is not found or reading somehow fails. (A convenience routine for haddock or possibly other clients)</source>
          <target state="translated">파일을 찾을 수 없거나 읽기에 실패하면 종료합니다. (대구 또는 다른 고객을위한 편의 루틴)</target>
        </trans-unit>
        <trans-unit id="d18c7f0650c4448b87f6b1933a38ca47b67ffa76" translate="yes" xml:space="preserve">
          <source>We recommend compiling any code that is intended to be run in parallel with the &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt; 플래그 와 병렬로 실행되도록 코드를 컴파일하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="dd137eb9f9ef9f1a324bec16b4c37c93cef73a26" translate="yes" xml:space="preserve">
          <source>We recommend running GHCi in a standard Windows console: select the &lt;code&gt;GHCi&lt;/code&gt; option from the start menu item added by the GHC installer, or use &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; to get a Windows console and invoke &lt;code&gt;ghci&lt;/code&gt; from there (as long as it&amp;rsquo;s in your &lt;code&gt;PATH&lt;/code&gt;).</source>
          <target state="translated">표준 Windows 콘솔에서 GHCi를 실행하는 것이 좋습니다 . GHC 설치 프로그램이 추가 한 시작 메뉴 항목에서 &lt;code&gt;GHCi&lt;/code&gt; 옵션을 선택 하거나 &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; 를 사용하여 Windows 콘솔을 가져 &lt;code&gt;ghci&lt;/code&gt; 를 호출 하십시오 . 당신의 &lt;code&gt;PATH&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0cc790e21929b801027a2b0bf099d41ea4a4f5c7" translate="yes" xml:space="preserve">
          <source>We represent the branch as a list of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, so version 3.2.1 becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;[Int]&lt;/code&gt;) gives the natural ordering of branches.</source>
          <target state="translated">분기를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 목록으로 나타내 므로 버전 3.2.1은 [3,2,1]이됩니다. 사전 순서 (즉, &lt;code&gt;[Int]&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 기본 인스턴스 )는 분기의 자연스러운 순서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89593894dcf2a0d71f7d1ad6ca489afd099ffae1" translate="yes" xml:space="preserve">
          <source>We reuse the keyword &lt;code&gt;default&lt;/code&gt; to signal that a signature applies to the default method only; when defining instances of the &lt;code&gt;Enum&lt;/code&gt; class, the original type &lt;code&gt;[a]&lt;/code&gt; of &lt;code&gt;enum&lt;/code&gt; still applies. When giving an empty instance, however, the default implementation &lt;code&gt;(map to genum)&lt;/code&gt; is filled-in, and type-checked with the type &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt;.</source>
          <target state="translated">서명이 기본 방법에만 적용됨을 알리기 위해 &lt;code&gt;default&lt;/code&gt; 키워드를 재사용합니다 . 의 인스턴스를 정의 할 때 &lt;code&gt;Enum&lt;/code&gt; 클래스가 원래 형 &lt;code&gt;[a]&lt;/code&gt; 의 &lt;code&gt;enum&lt;/code&gt; 여전히 적용된다. 그러나 빈 인스턴스를 제공 할 때 기본 구현 &lt;code&gt;(map to genum)&lt;/code&gt; 이 채워지고 유형 &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt; 유형 검사됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f9e3f88ef588eea2884342e308084935512f974" translate="yes" xml:space="preserve">
          <source>We rewrite consecutive uses of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; such that the bound-checks are fused. For example,</source>
          <target state="translated">바운드 검사가 융합되도록 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; 의 연속 사용을 다시 작성합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="4fd7ec02dbb95e726ccd7b6229d42c6b16b30b10" translate="yes" xml:space="preserve">
          <source>We run the following mailing lists about GHC. We encourage you to join, as you feel is appropriate.</source>
          <target state="translated">GHC에 대한 다음 메일 링리스트를 운영합니다. 적절하다고 생각되면 가입하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f1dbba1856e51980e45e786acb354e0d1d1df7c9" translate="yes" xml:space="preserve">
          <source>We say that a variable whose multiplicity constraint is &lt;code&gt;Many&lt;/code&gt; is &lt;em&gt;unrestricted&lt;/em&gt;.</source>
          <target state="translated">다중성 제약이 &lt;code&gt;Many&lt;/code&gt; 인 변수 는 &lt;em&gt;제한되지 않는다고&lt;/em&gt; 말합니다 .</target>
        </trans-unit>
        <trans-unit id="21cff9ed481d8fd83cf7c2afd03d533d1340b407" translate="yes" xml:space="preserve">
          <source>We say that the type variables in &lt;code&gt;f&lt;/code&gt; are &lt;em&gt;specified&lt;/em&gt;, while those in &lt;code&gt;g&lt;/code&gt; are &lt;em&gt;inferred&lt;/em&gt;. The general rule is this: if the user has written a type variable in the source program, it is &lt;em&gt;specified&lt;/em&gt;; if not, it is &lt;em&gt;inferred&lt;/em&gt;.</source>
          <target state="translated">우리는 &lt;code&gt;f&lt;/code&gt; 의 타입 변수 가 &lt;em&gt;지정&lt;/em&gt; 되고 &lt;code&gt;g&lt;/code&gt; 의 변수 는 &lt;em&gt;유추&lt;/em&gt; 된다고 말합니다 . 일반적인 규칙은 다음과 같습니다. 사용자가 소스 프로그램에서 유형 변수를 작성한 경우 &lt;em&gt;지정됩니다&lt;/em&gt; . 그렇지 않은 경우 &lt;em&gt;추론됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="86eabd9ae7f589e2df7e5f7c967151a67519bb49" translate="yes" xml:space="preserve">
          <source>We see that a lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;g e&lt;/code&gt; endomorphisms, with &lt;code&gt;f'&lt;/code&gt; as as the operator, in fact yields a strict left fold, that avoids building a deep chain of intermediate thunks:</source>
          <target state="translated">&lt;code&gt;f'&lt;/code&gt; 를 연산자로 사용 하는 &lt;code&gt;g e&lt;/code&gt; endomorphism 의 lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 는 실제로 중간 썽크의 깊은 체인을 구축하지 않는 엄격한 왼쪽 폴드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d1d876669543ac56e563fe5e0f4a71e0eb3b27cc" translate="yes" xml:space="preserve">
          <source>We set a breakpoint on &lt;code&gt;map&lt;/code&gt;, and call it.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에 중단 점을 설정 하고 호출합니다.</target>
        </trans-unit>
        <trans-unit id="024423d139e42844141faa4bae40cb34e8a5e857" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt;&lt;code&gt;-fno-prof-count-entries&lt;/code&gt;&lt;/a&gt; when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</source>
          <target state="translated">항목 개수도 공유 메모리에 저장되고 여러 코어에서 지속적으로 업데이트하기 때문에 여러 코어에서 프로파일 링 할 프로그램을 컴파일 할 때 &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt; &lt;code&gt;-fno-prof-count-entries&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d38883454548f1a00020fd8ec4a415f17e5632b2" translate="yes" xml:space="preserve">
          <source>We then compile the &lt;code&gt;Danger&lt;/code&gt; plugin using the new Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; flag:</source>
          <target state="translated">그런 다음 새로운 Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;Danger&lt;/code&gt; 플러그인 을 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="480a5fe002071f5d9a996045885005b615d7bf0d" translate="yes" xml:space="preserve">
          <source>We to extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">우리는 &lt;code&gt;class&lt;/code&gt; 를 확장해야 합니다 (경고 : 이것은 다소 혼란스럽지 않은 비 터미널 기호입니다), 즉 인스턴스 선언에 나타날 수있는 두 가지 추가 양식</target>
        </trans-unit>
        <trans-unit id="47d397e8df6bede4d54c1099104c6d4fbbb85e92" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">기본 서명을 사용하여 GHC ( &lt;a href=&quot;#generic-programming&quot;&gt;일반 프로그래밍&lt;/a&gt; )의 일반 프로그래밍 을 단순화 합니다.</target>
        </trans-unit>
        <trans-unit id="688e02acbe0a3ecd6d1989ae0fb801ec38f3ebed" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;generics#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">GHC ( &lt;a href=&quot;generics#generic-programming&quot;&gt;Generic programming&lt;/a&gt; ) 에서 일반 프로그래밍을 단순화하기 위해 기본 서명을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="125a5084123f7c5b39098e8dae224d6228f6152b" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">다음 표에서 인코딩 기능의 효율성을 벤치마킹 하기 위해 &lt;code&gt;criterion&lt;/code&gt; 라이브러리 ( &lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1dae9d07b3904219cff50bee9567703d83f53689" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;https://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">다음 표에서 인코딩 기능의 효율성을 벤치마킹 하기 위해 &lt;code&gt;criterion&lt;/code&gt; 라이브러리 ( &lt;a href=&quot;https://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="651493c4df9c22d796fc7f5135203d8ed9018b48" translate="yes" xml:space="preserve">
          <source>We use the continuation &lt;code&gt;f0&lt;/code&gt; to decode our second packet.</source>
          <target state="translated">연속 &lt;code&gt;f0&lt;/code&gt; 을 사용하여 두 번째 패킷을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="0b6335997171de81f090e2683152fed3460a0025" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">다음 가져 오기를 사용하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 줄여 읽기 를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="f22709004a13a3fd94746ba6a021463ab6f37071" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">읽기를 단순화하기 위해 다음 가져 오기를 사용하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 축약 합니다.</target>
        </trans-unit>
        <trans-unit id="22f0961872a4ad51f0a43371524e8f12b244e439" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">읽기를 단순화하기 위해 다음 가져 오기를 사용하고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 축약 합니다.</target>
        </trans-unit>
        <trans-unit id="f7512aaa70635b88b2af47a520c014d401727a75" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d rather you reported such behaviour as a bug, so that we can try to correct it.</source>
          <target state="translated">차라리 버그와 같은 동작을보고하여 문제를 해결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="cc16631b4890edd93973a20a4f9c5e2d14d862c2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">GHC 특정 비트를 &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt; . 나머지 코드는 FFI 표준을 지원하는 Haskell 구현간에 이식 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="65acee36cf41a1b7912dd8dd307ffedf598be82e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">우리는 &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt; ; 나머지 코드는 FFI 표준을 지원하는 Haskell 구현에서 이식 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="5a793d25465a65272f23a30bedf1a841c6e93416" translate="yes" xml:space="preserve">
          <source>Weak pointers are particularly useful for caches and memo tables. To build a memo table, you build a data structure mapping from the function argument (the key) to its result (the value). When you apply the function to a new argument you first check whether the key/value pair is already in the memo table. The key point is that the memo table itself should not keep the key and value alive. So the table should contain a weak pointer to the key, not an ordinary pointer. The pointer to the value must not be weak, because the only reference to the value might indeed be from the memo table.</source>
          <target state="translated">약한 포인터는 캐시 및 메모 테이블에 특히 유용합니다. 메모 테이블을 작성하려면 함수 인수 (키)에서 결과 (값)로 데이터 구조 맵핑을 빌드하십시오. 함수를 새 인수에 적용하면 먼저 키 / 값 쌍이 이미 메모 테이블에 있는지 확인하십시오. 요점은 메모 테이블 자체가 키와 값을 유지하지 않아야한다는 것입니다. 따라서 테이블에는 일반적인 포인터가 아닌 키에 대한 약한 포인터가 포함되어야합니다. 값에 대한 유일한 참조는 실제로 메모 테이블에서 올 수 있으므로 값에 대한 포인터는 약해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="faba8c00ffb62bd7028e9f0c9a30a924a7d52926" translate="yes" xml:space="preserve">
          <source>Weak pointers.</source>
          <target state="translated">약한 포인터.</target>
        </trans-unit>
        <trans-unit id="2d19b42c89a1ffa7f94dcb2e215670bafea0f235" translate="yes" xml:space="preserve">
          <source>Weak references to ThreadIds</source>
          <target state="translated">ThreadId에 대한 약한 참조</target>
        </trans-unit>
        <trans-unit id="29bd6c9aa748ebb7965a1af0f607d43846c1eca6" translate="yes" xml:space="preserve">
          <source>Weak#</source>
          <target state="translated">Weak#</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="4738b6db466a17900cde0c392a366f81ee255686" translate="yes" xml:space="preserve">
          <source>Welcome to the GHC User&amp;rsquo;s Guide</source>
          <target state="translated">GHC 사용자 안내서에 오신 것을 환영합니다</target>
        </trans-unit>
        <trans-unit id="9a43d24919845073d089f519130b6009f44f6465" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;.</source>
          <target state="translated">재귀 함수와 상호 재귀 함수 그룹은 어떻습니까? 비용은 어디에 계산됩니까? 글쎄, GHC는 서로를 재귀 적으로 호출 한 함수 그룹에 대한 정보를 유지하지만이 정보는 기본 시간 및 할당 프로필에 표시되지 않고 대신 호출 그래프가 다음과 같이 트리로 평면화됩니다. 현재 스택의 다른 곳에서 발생하면 스택의 다른 항목을 푸시하지 않고 대신이 호출에 대한 비용이 호출자 &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt; 로 집계됩니다 .</target>
        </trans-unit>
        <trans-unit id="86b948584445577633b2d886da1cecc0b987ad2b" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">재귀 함수와 상호 재귀 함수 그룹은 어떻습니까? 비용은 어디에서 발생합니까? GHC는 서로 호출하는 함수 그룹에 대한 정보를 재귀 적으로 유지하지만이 정보는 기본 시간 및 할당 프로파일에 표시되지 않고 대신 다음과 같이 콜 그래프가 트리로 표시됩니다. 현재 스택의 다른 곳에서 발생하면 스택의 다른 항목을 푸시하지 않고이 호출에 대한 비용이 호출자에게 집계됩니다 &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7463ff41252948f9a667ff3bc05fd6cfe9f627b" translate="yes" xml:space="preserve">
          <source>What about the ambiguity problems that we encountered with the original definition? The empty function still has type &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt;, but it is no longer necessary to regard that as an ambiguous type: Although the variable &lt;code&gt;e&lt;/code&gt; does not appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, the dependency for class &lt;code&gt;Collects&lt;/code&gt; tells us that it is uniquely determined by &lt;code&gt;ce&lt;/code&gt;, which does appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol. Hence the context in which empty is used can still give enough information to determine types for both &lt;code&gt;ce&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; that is not uniquely determined (either directly or indirectly) by the variables on the right.</source>
          <target state="translated">원래 정의에서 발생한 모호성 문제는 어떻습니까? 빈 함수에는 여전히 &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt; 유형이 있지만 더 이상 모호한 유형으로 간주 할 필요가 없습니다. 변수 &lt;code&gt;e&lt;/code&gt; 가 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 의 오른쪽에 나타나지 않지만 &lt;code&gt;Collects&lt;/code&gt; 클래스에 대한 종속성 은 우리에게 알려줍니다 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 의 오른쪽에 나타나는 &lt;code&gt;ce&lt;/code&gt; 에 의해 고유하게 결정됩니다 . 따라서 빈이 사용되는 컨텍스트는 여전히 &lt;code&gt;ce&lt;/code&gt; 와 &lt;code&gt;e&lt;/code&gt; 모두에 대한 유형을 결정하기에 충분한 정보를 제공 할 수 있습니다.모호함이 없습니다. 보다 일반적으로, 오른쪽의 변수에 의해 (직접 또는 간접적으로) 고유하게 결정되지 않은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 왼쪽에 변수가 포함 된 경우에만 유형을 모호한 것으로 간주하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c4b747f5f91cbc11d5f22a2bf7469fd4c91ae77" translate="yes" xml:space="preserve">
          <source>What actually happens is that GHCi typechecks the expression, and if it doesn&amp;rsquo;t have an &lt;code&gt;IO&lt;/code&gt; type, then it transforms it as follows: an expression &lt;code&gt;e&lt;/code&gt; turns into</source>
          <target state="translated">무엇 실제로 일어나는 일은 GHCi는 표현을 typechecks 것을, 그리고 그것이이없는 경우 &lt;code&gt;IO&lt;/code&gt; 의 유형을 다음과 같이 다음 그것을 변환 : 표현의 &lt;code&gt;e&lt;/code&gt; 로 변신</target>
        </trans-unit>
        <trans-unit id="e9043cea2c18dd5a9e4e8750a0588455697b7ca7" translate="yes" xml:space="preserve">
          <source>What can we do with a value of type &lt;code&gt;Foo&lt;/code&gt;? In particular, what happens when we pattern-match on &lt;code&gt;MkFoo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 타입의 값으로 무엇을 할 수 있습니까? 특히 &lt;code&gt;MkFoo&lt;/code&gt; 에서 패턴 일치를 하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="04d6fb868c328fab711283d4e71b610250d64e7f" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">x에 대한 명시 적 유형을 &quot;제공&quot;한다는 것은 무엇을 의미합니까? 패턴 유형 서명 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt; )을 사용하여 x에 대한 유형 서명을 직접 제공하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91ea760880e6d9bd2555f022fdf2a6393ee5b3e8" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">x에 대한 명시 적 유형을 &quot;제공&quot;한다는 것은 무엇을 의미합니까? 패턴 유형 서명 ( &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically 범위 유형 변수&lt;/a&gt; )을 사용하여 x에 대한 유형 서명을 직접 제공하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65229e46e73bff9547a997f15a9069c14aa568e2" translate="yes" xml:space="preserve">
          <source>What does it mean to be Safe? That importing a module compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; shouldn&amp;rsquo;t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as &lt;em&gt;semantic consistency&lt;/em&gt;.</source>
          <target state="translated">안전하다는 것은 무엇을 의미합니까? &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈을 가져와도 모듈 을 가져 오지 않고 잘 컴파일되는 코드의 의미를 변경해서는 안됩니다. &lt;em&gt;시맨틱 일관성&lt;/em&gt; 이라고 알려진 Safe Haskell 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="74897f429b64222556ce5fc87639db27ebbf457c" translate="yes" xml:space="preserve">
          <source>What exactly is considered to be a &amp;ldquo;complete user-supplied kind signature&amp;rdquo; for a type constructor? These are the forms:</source>
          <target state="translated">유형 생성자에 대해&amp;ldquo;완전한 사용자 제공 종류 서명&amp;rdquo;으로 간주되는 것은 무엇입니까? 다음과 같은 형태입니다.</target>
        </trans-unit>
        <trans-unit id="08f17076308c21f263ea9532451d09d88621d62c" translate="yes" xml:space="preserve">
          <source>What has this to do with &lt;em&gt;existential&lt;/em&gt; quantification? Simply that &lt;code&gt;MkFoo&lt;/code&gt; has the (nearly) isomorphic type</source>
          <target state="translated">&lt;em&gt;실존 적&lt;/em&gt; 정량화 와 어떤 관련이 있습니까? 간단히 &lt;code&gt;MkFoo&lt;/code&gt; 는 (거의) 동형 형태 를가 집니다</target>
        </trans-unit>
        <trans-unit id="881be7a062d2217bf57522931583f797d11f6eff" translate="yes" xml:space="preserve">
          <source>What if we want to define generic classes that range over type constructors (such as &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;)?</source>
          <target state="translated">유형 생성자 (예 : &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; )를 포괄하는 일반 클래스를 정의하려면 어떻게해야 합니까?</target>
        </trans-unit>
        <trans-unit id="52d850cf6e82ee71cba430d22124534321d40e28" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depend&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; 의 종류는 무엇입니까 ? &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; 라고 말할 수 있습니다 . Type-&amp;gt; k-&amp;gt; Type 이지만 이것은 올바르지 않습니다. &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; 와 같은 잘못된 항목을 허용 하므로 &lt;code&gt;Int&lt;/code&gt; 가 &lt;code&gt;Bool&lt;/code&gt; 종류가 아니기 때문에 거부해야합니다 . 중요한 관찰은 두 번째 주장의 종류가 첫 번째 주장에 &lt;em&gt;달려&lt;/em&gt; 있다는 것입니다 . GHC는 &lt;code&gt;ProxyKVis&lt;/code&gt; 의 종류에 대해 제공하는 구문에서 이러한 종속성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="39c87b0db40f56398a44a5dc90aefe416e407bb2" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depends&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; 의 종류는 무엇입니까 ? &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; 라고 말할 수 있습니다 . Type-&amp;gt; k-&amp;gt; Type 이지만 이것은 올바르지 않습니다. &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; 와 같은 잘못된 항목을 허용 하므로 &lt;code&gt;Int&lt;/code&gt; 가 &lt;code&gt;Bool&lt;/code&gt; 종류가 아니기 때문에 거부해야합니다 . 중요한 관찰은 두 번째 주장의 종류가 첫 번째 주장에 &lt;em&gt;달려&lt;/em&gt; 있다는 것입니다 . GHC는 &lt;code&gt;ProxyKVis&lt;/code&gt; 종류에 대해 제공하는 구문에서이 종속성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9b6156ac418f74ed9ece766ec906a41817dd7888" translate="yes" xml:space="preserve">
          <source>What is this &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; in the result type? Clearly we don&amp;rsquo;t mean this:</source>
          <target state="translated">결과 유형 에서이 &quot; &lt;code&gt;a&lt;/code&gt; &quot; 는 무엇입니까 ? 분명히 우리는 이것을 의미하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="9f3ffd4ecaba0a4fb7ec792f4dfaea484d5b2b16" translate="yes" xml:space="preserve">
          <source>What kind of splice it is</source>
          <target state="translated">어떤 종류의 접속인가</target>
        </trans-unit>
        <trans-unit id="658954d7cdd84a10f186220aa5a43363b9844f19" translate="yes" xml:space="preserve">
          <source>What remains to be done is an inductive step beyond the empty and singleton cases. For a concrete &lt;code&gt;Traversable&lt;/code&gt; functor &lt;code&gt;T&lt;/code&gt; we need to be able to extend our structure incrementally by filling in holes. We can view a partially built structure &lt;strong&gt;&lt;code&gt;t0 :: T a&lt;/code&gt;&lt;/strong&gt; as a function &lt;strong&gt;&lt;code&gt;append :: a -&amp;gt; T a&lt;/code&gt;&lt;/strong&gt; that takes one more element &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; to insert into the container to the right of the existing elements to produce a larger structure. Conversely, we can view an element &lt;code&gt;a&lt;/code&gt; as a function &lt;strong&gt;&lt;code&gt;prepend :: T a -&amp;gt; T a&lt;/code&gt;&lt;/strong&gt; of a partially built structure that inserts the element to the left of the existing elements.</source>
          <target state="translated">남은 일은 빈 케이스와 싱글 톤 케이스를 넘어선 귀납적 단계입니다. 콘크리트 &lt;code&gt;Traversable&lt;/code&gt; functor &lt;code&gt;T&lt;/code&gt; 의 경우 구멍을 채워 구조를 점진적으로 확장 할 수 있어야합니다. 부분적으로 빌드 된 구조 &lt;strong&gt; &lt;code&gt;t0 :: T a&lt;/code&gt; &lt;/strong&gt; 를 함수 &lt;strong&gt; &lt;code&gt;append :: a -&amp;gt; T a&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;T a&lt;/strong&gt; 로 볼 수 있습니다. 이 함수 는 더 큰 구조를 생성하기 위해 기존 요소의 오른쪽에있는 컨테이너에 하나 이상의 요소 &lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt; 를 삽입합니다. 반대로 기존 요소의 왼쪽에 요소를 삽입하는 부분적으로 빌드 된 구조의 &lt;strong&gt; &lt;code&gt;prepend :: T a -&amp;gt; T a&lt;/code&gt; &lt;/strong&gt; a 함수로 요소 &lt;code&gt;a&lt;/code&gt; 를 볼 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ab258d9d72836e598da4742fd3511500e02364b" translate="yes" xml:space="preserve">
          <source>What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; has two representational parameters; &lt;code&gt;(~)&lt;/code&gt; has two nominal parameters; all type families&amp;rsquo; parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</source>
          <target state="translated">주어진 유형 매개 변수의 역할은 무엇입니까? GHC는 역할 유추를 수행하여 모든 매개 변수에 대한 올바른 역할을 결정합니다. 몇 가지 기본 사실로 시작합니다. &lt;code&gt;(-&amp;gt;)&lt;/code&gt; 에는 두 가지 표현 매개 변수가 있습니다. &lt;code&gt;(~)&lt;/code&gt; 두 개의 공칭 매개 변수가 있습니다. 모든 유형 패밀리의 매개 변수는 공칭입니다. 모든 GADT와 유사한 매개 변수는 공칭입니다. 그런 다음 이러한 사실은 이러한 유형이 사용되는 모든 장소로 전파됩니다. 데이터 유형 및 동의어의 기본 역할은 팬텀입니다. 클래스의 기본 역할은 명목입니다. 따라서 데이터 유형 및 동의어의 경우 오른쪽에서 사용되지 않거나 팬텀 위치의 다른 유형에서만 사용되는 모든 매개 변수는 팬텀이됩니다. 매개 변수가 표현 위치에서 사용될 때마다 (즉, 해당 변수가 역할 표현 인 생성자에 대한 유형 인수로 사용됨) 우리는 그 역할을 팬텀에서 표현으로 올립니다. 마찬가지로 매개 변수가 공칭 위치에 사용되면 해당 역할이 공칭으로 업그레이드됩니다. 우리는 역할을 명목에서 팬텀 또는 표현으로, 또는 표현에서 팬텀으로 다운 그레이드하지 않습니다.이러한 방식으로 각 매개 변수에 대해 가장 일반적인 역할을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="5e163d757026398a851a492e27beac64aa80af0b" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;lsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; 의 역할 은 무엇입니까 ? 처음에는 홍당무가 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 역할을 나타내는 것처럼 보일 것입니다. 둘 다 오른쪽에 사용되며 유형 패밀리에는 관여하지 않기 때문입니다. 그러나 다음 예제와 같이 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="7201ad0e4b9c4fd0ef63e8c881a6df6e60416a86" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;rsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; 의 역할 은 무엇입니까 ? 처음에는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 둘 다 역할을 표현해야하는 것처럼 보일 것입니다. 둘 다 오른쪽에서 사용되고 둘 다 유형 패밀리에 포함되지 않기 때문입니다. 그러나 다음 예에서 볼 수 있듯이 이것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="f319ebff2240395cf0b480e1f2c12f478863009f" translate="yes" xml:space="preserve">
          <source>What should GHCi do? Strictly speaking, the program is ambiguous. &lt;code&gt;show (reverse [])&lt;/code&gt; (which is what GHCi computes here) has type &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; and how that displays depends on the type &lt;code&gt;a&lt;/code&gt;. For example:</source>
          <target state="translated">GHCi는 무엇을해야합니까? 엄밀히 말하면, 프로그램은 모호합니다. &lt;code&gt;show (reverse [])&lt;/code&gt; (여기서 GHCi가 계산하는 것)는 &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; 유형을 &lt;code&gt;a&lt;/code&gt; 표시 방법은 유형 a 에 따라 다릅니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36df37661ec67327bae64a89f5fda20d13ff69fa" translate="yes" xml:space="preserve">
          <source>What should happen if there are multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets that apply to a single set of patterns? Consider this example:</source>
          <target state="translated">단일 패턴 세트에 적용 되는 여러 개의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트 가있는 경우 어떻게 됩니까? 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="648b00f4e347bf90a6a0fb0d972beb792cf753dc" translate="yes" xml:space="preserve">
          <source>What sort of heap profile are we collecting?</source>
          <target state="translated">어떤 종류의 힙 프로필을 수집합니까?</target>
        </trans-unit>
        <trans-unit id="8126e143260b66c2fb583df8e9c347a06cdfbd9b" translate="yes" xml:space="preserve">
          <source>What the Haskell compiler proper produces depends on what backend code generator is used. See &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC Backends&lt;/a&gt; for more details.</source>
          <target state="translated">Haskell 컴파일러가 올바르게 생성하는 것은 사용되는 백엔드 코드 생성기에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC 백엔드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="429c385bbd56293e7efc1f03bbf57fcd1117da26" translate="yes" xml:space="preserve">
          <source>What the user explicitly requests when deriving an instance.</source>
          <target state="translated">인스턴스를 파생시킬 때 사용자가 명시 적으로 요청하는 것.</target>
        </trans-unit>
        <trans-unit id="b19a3d9cbaa78a6c5a7484da4d4cd12504b118c0" translate="yes" xml:space="preserve">
          <source>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</source>
          <target state="translated">이것이 우리가 할 수있는 것은 이기종 값을 조작하는 여러 함수와 함께 이기종 값을 패키징 한 다음 패키지 모음을 균일 한 방식으로 처리하는 것입니다. 이런 식으로 객체 지향 프로그래밍을 상당히 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24853926c03c1e59ec849769b4f2d90053671dc4" translate="yes" xml:space="preserve">
          <source>What to do at the end.</source>
          <target state="translated">마지막에해야 할 일.</target>
        </trans-unit>
        <trans-unit id="f7686a5c0ed176c27b8cd695136d1f7bed6c4a34" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m1&lt;/code&gt; but not &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 이 아닌 &lt;code&gt;m2&lt;/code&gt; 의 키로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="c37ddb3fb337621682dafb8ac0d643b90e215e7c" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m2&lt;/code&gt; but not &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">에서 키 수행 할 작업 &lt;code&gt;m2&lt;/code&gt; 하지만 &lt;code&gt;m1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efa2a8fb6db1cfa21819c5147e06d6aefeed8bd0" translate="yes" xml:space="preserve">
          <source>What to do with keys in both &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 의 키로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="73b2b6134413a32046831817687c29ff928ae2e4" translate="yes" xml:space="preserve">
          <source>What to do with options following non-options</source>
          <target state="translated">비 옵션에 따른 옵션으로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="996e10cf546cff543352df9ce3ef3c87c74174b2" translate="yes" xml:space="preserve">
          <source>What to do with text.</source>
          <target state="translated">텍스트로해야 할 일.</target>
        </trans-unit>
        <trans-unit id="c658b7c4ea121db3dfee7cd15b4b8680dde66f0e" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve shown should work with any &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">우리가 보여준 것은 어떤 &lt;code&gt;make&lt;/code&gt; 와도 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d19139af1e36286bf84856578a8fdfb18aa2232" translate="yes" xml:space="preserve">
          <source>What's different is that we now use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; to refer to the parameter (and that parameter, which used to be &lt;code&gt;a&lt;/code&gt;), is not mentioned explicitly by name anywhere; and we use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; to refer to a recursive use of &lt;code&gt;Tree a&lt;/code&gt;.</source>
          <target state="translated">어떤 다른 것은 우리가 지금 사용하는 것입니다 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 매개 변수 (그리고로 사용되는 매개 변수를 참조 &lt;code&gt;a&lt;/code&gt; ), 이름 어디서나 명시 적으로 언급되지 않는다; 우리는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;Tree a&lt;/code&gt; 의 재귀 적 사용을 나타 냅니다 .</target>
        </trans-unit>
        <trans-unit id="9bb20323ff98b32b6715abf861bfc65712d9780e" translate="yes" xml:space="preserve">
          <source>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</source>
          <target state="translated">예외가 발생할 때 대상 스레드가 수행 한 작업은 손실되지 않습니다. 다른 스레드가 필요할 때까지 계산이 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="25aaf639f200ab012209ed7c616b7427cf43a690" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 anyclass 를 사용 &lt;code&gt;anyclass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8311b798f1a1d8eab7dbb5ae1a94d12113de6b90" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</source>
          <target state="translated">때 &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 모호한 필드는 오히려 최상위 레벨에보다, 그 데이터 타입의 일환으로 내 보내야합니다. 예를 들어 다음은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="2d6fdf1d7d01ce1777950f2bd094b6b3a91b0824" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">때 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 유형 및 종류의 변수가 explicily 같은 방식으로 관련 데이터 또는 형의 가족 인스턴스에 바인딩 할 수 있습니다 (같은 제한)와 같은 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 또는 &lt;a href=&quot;#type-instance-declarations&quot;&gt;유형의 인스턴스 선언&lt;/a&gt; . 예를 들어, 위의 내용을 적용하면 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcb444e9dc2c42002165fa1d9f676b2862da1a0d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 이 활성화 되면 왼쪽에서 사용되는 유형 및 종류 변수를 명시 적으로 바인딩 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="a5c5adf24a15bed78aec999f1b504402cb4c91e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">경우 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 좌측에서 사용 유형 또는 종류의 변수를 명시 적으로 결합 될 수있다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b1b787d1263816e3855c7cfe78d8c359b80a2c3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 가&lt;/a&gt; 활성화되고 우리가 newtype이란에 대한 파생되는, 다음 사용 &lt;code&gt;newtype&lt;/code&gt; 은을 .</target>
        </trans-unit>
        <trans-unit id="a92680fcc9c9c1502de789f18babeedf32dc9462" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt;&lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt;&lt;/a&gt; is enabled, GHC prints &lt;code&gt;RuntimeRep&lt;/code&gt; type variables for levity-polymorphic types. Otherwise GHC will default these to &lt;code&gt;LiftedRep&lt;/code&gt;. For example,</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt; &lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt; &lt;/a&gt; 활성화되어, GHC는 인쇄 &lt;code&gt;RuntimeRep&lt;/code&gt; 의 경솔-다형성 유형에 대한 유형의 변수를. 그렇지 않으면 GHC는이를 기본값으로 &lt;code&gt;LiftedRep&lt;/code&gt; 로 설정 합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5cd8e7617284a82575e75959536dc8754f27decc" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 anyclass 를 사용 &lt;code&gt;anyclass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a39604dbdf930eeb49569712f91ae6fd1a07491" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicitly bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">때 &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 유형 및 종류의 변수가 명시 적으로 동일한 방식으로 관련 데이터 또는 형의 가족 인스턴스에 바인딩 할 수 있습니다 (같은 제한)와 같은 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 또는 &lt;a href=&quot;#type-instance-declarations&quot;&gt;유형의 인스턴스 선언&lt;/a&gt; . 예를 들어, 위의 내용을 적용하면 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="37685117656dc05c88d241b88847cf56b98f6523" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 이 활성화 되면 왼쪽에서 사용되는 유형 및 종류 변수를 명시 적으로 바인딩 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1700d840d06c00c9fb0b89fd7a848535205dcc1d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;exts/explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">경우 &lt;a href=&quot;exts/explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 명시 적 정량 형 변수는 사용되지 않는 것으로 식별 될 수있다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="eb26b4b9b42719afc5d58080892c87f4e9a4c151" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 을 사용 하면 명시 적 으로 수량화 된 유형 변수도 사용되지 않은 것으로 식별 될 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="5311fb9fec0c8a69090b42668184cdd614a4ed78" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 가&lt;/a&gt; 활성화되고 우리가 newtype이란에 대한 파생되는, 다음 사용 &lt;code&gt;newtype&lt;/code&gt; 은을 .</target>
        </trans-unit>
        <trans-unit id="5071f001a427f312da8ff26b7cf483642333afbe" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; is enabled, inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example would be &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">때 &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt; 활성화되어, 추정 변수는 중괄호로 인쇄됩니다. 따라서 이전 예제 의 데이터 생성자 &lt;code&gt;Proxy&lt;/code&gt; 유형은 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; . GHCi 세션에서이 동작을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e630e40474031593156647d2e58d26eafbc9c93" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-pgmc&lt;/code&gt; is used, GHC by default will never pass the &lt;code&gt;-no-pie&lt;/code&gt; command line flag. The rationale is that it is not known whether the specified compiler will support it. This flag can be used to indicate that &lt;code&gt;-no-pie&lt;/code&gt; is supported. It has to be passed after &lt;code&gt;-pgmc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-pgmc&lt;/code&gt; 를 사용 하면 기본적으로 GHC는 &lt;code&gt;-no-pie&lt;/code&gt; 명령 줄 플래그를 전달하지 않습니다 . 근거는 지정된 컴파일러가이를 지원할지 여부를 알 수 없다는 것입니다. 이 플래그는 &lt;code&gt;-no-pie&lt;/code&gt; 가 지원됨 을 표시하는 데 사용할 수 있습니다 . &lt;code&gt;-pgmc&lt;/code&gt; 다음에 전달 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="e71fb29e10669e9f7c683566c4b79f1c652a9191" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="4aaaa0ba1a64c3d7d910545fc6c8b5e6446f7b2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e300aa1722b3687399fefcf98ac7da8e8418a15c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c0a743c0152059b012ce81ab66c44377dc65ef53" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="5200adccb49ebd80f56d109e8f140d348d18d90e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="afb5f089e5c2d608a63aa2fcae939b3d1365c1ae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="77eb1ded96e8103d67da6e7e333c6b643ba6f717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
